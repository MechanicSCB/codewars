{"59dd24407997cb5cc0000117":[{"id":214570,"user_id":106,"body":"import sets, math, algorithm\n \nproc divisors*(n: uint64): seq[uint64] =\n  var fs = initHashSet[uint64]()\n  for x in 1 .. uint64(sqrt(float(n))):\n    if n mod x == 0:\n      fs.incl(x)\n      fs.incl(n div x)\n  result = @[]\n  for x in fs:\n    result.add(x)\n  sort(result, system.cmp[uint64])","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214571,"user_id":759,"body":"#[\nfrom algorithm import sort\n\nproc divisors*(n: uint64): seq[uint64] =\n  newSeq(result, 0)\n  var\n    bound = n\n    i = 1'u64\n  while i < bound:\n    if n mod i == 0:\n      bound = (n.int \/ i.int).uint64\n      if bound != i: result.add(bound) \n      result.add(i)\n    inc i\n  result.sort(cmp[uint64])\n]#\nimport math, algorithm\n\nproc divisors*(n: uint64): seq[uint64] =\n  result = @[]\n  var maxq = uint64(floor(sqrt(float(n))))\n  for i in 1..maxq:\n    if n mod i == 0:\n      result.add(i)\n      let d = n div i\n      if d != i:\n        result.add(d)\n  result.sort(system.cmp[uint64])","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214572,"user_id":106,"body":"import sets, math, algorithm\n \nproc divisors*(n: uint64): seq[uint64] =\n  var fs = initSet[uint64]()\n  for x in 1 .. uint64(sqrt(float(n))):\n    if n mod x == 0:\n      fs.incl(x)\n      fs.incl(n div x)\n  result = @[]\n  for x in fs:\n    result.add(x)\n  sort(result, system.cmp[uint64])","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214573,"user_id":null,"body":"import math, sequtils, algorithm\n\n\nproc divisors*(n: uint64): seq[uint64] =\n  result = @[]\n  var maxq = uint64(floor(sqrt(float(n))))\n  for i in 1..maxq:\n    if n mod i == 0:\n      result.add(i)\n      let d = n div i\n      if d != i:\n        result.add(d)\n  result.sort(system.cmp[uint64])","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214574,"user_id":null,"body":"from math import sqrt, floor\nfrom algorithm import sort\n\nproc divisors*(n: uint64): seq[uint64] =\n  var numbers = newSeq[uint64]()\n  for i in 1'u64..(n.float64.sqrt.floor.uint64):\n    if n mod i == 0'u64:\n      numbers.add(i)\n      numbers.add(n div i)\n  numbers.sort(cmp[uint64])\n  \n  result = @[]\n  var last = 0'u64\n  for number in numbers:\n    if number != last:\n      result.add(number)\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214575,"user_id":null,"body":"import math, sequtils, algorithm\nproc divisors*(n: uint64): seq[uint64] =\n  result = @[]\n  for i in 1..int sqrt(float(n))+1:\n    if n mod uint64(i) == 0:\n      result.add(uint64(i))\n      result.add(uint64 int(n)\/i)\n  result = deduplicate result \n  result.sort system.cmp[uint64]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214576,"user_id":527,"body":"import math\n\nproc divisors*(n: uint64): seq[uint64] =\n  let sqrtN = n.float64.sqrt.round.uint64\n  result = newSeq[uint64]()\n  var result2 = newSeq[uint64]()\n  for i in 1..sqrtN:\n    if n mod i == 0:\n      result.add(i)\n      result2.add(n div i)\n  if n * n == sqrtN:\n    result.add(sqrtN)\n  for i in result2.high.countdown(0):\n    result.add(result2[i])","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214577,"user_id":676,"body":"from math import sqrt\n\nproc divisors*(n: uint64): seq[uint64] =\n  var\n    a = newSeq[uint64]()\n    b = newSeq[uint64]()\n  for d in 1..uint64(sqrt(float64(n))):\n    if n mod d == 0:\n      a.add(d)\n      let q = n div d\n      if q != d: b.add(q)\n  for i in countdown(b.high, b.low): a.add(b[i])\n  return a","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214578,"user_id":null,"body":"import math\nproc divisors*(n: uint64): seq[uint64] =\n  if n==0: discard\n  result = @[1'u64]\n  if n==1: return\n  var l = uint64(sqrt(float64(n)))\n  for i in countup(2, l): \n    if n mod i==0: result.add(i)\n  if n==l*l: l-=1\n  for i in countdown(l, 1): \n    if n mod i==0: result.add(n div i)  ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"51ba717bb08c1cd60f00002f":[{"id":214579,"user_id":null,"body":"proc solution*(a: seq[int]): string =\n  var range = a[0] .. a[0]\n  proc commit(r: var string, needsComma = false) =\n    if range.a + 1 < range.b:\n      r &= $range.a & '-' & $range.b\n    else:\n      for it in range:\n        r &= $it\n        if it < range.b:\n          r &= ','\n    if needsComma:\n      r &= ','\n  for i in 1 .. a.high:\n    let it = a[i]\n    if it == range.b + 1:\n      range.b.inc()\n    else:\n      result.commit(true)\n      range = it .. it\n  result.commit()","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214580,"user_id":76,"body":"proc solution*(a: seq[int]): string =\n  var i = 0\n  while i < a.len:\n    if result != \"\": result &= ','\n    var j = i\n    while j < a.len.pred and a[j] + 1 == a[j + 1]:\n      j += 1\n    result &= $a[i]\n    if j - i > 1:\n      result &= \"-\" & $a[j]\n      i = j\n    i += 1","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214581,"user_id":111,"body":"proc f(s:seq):string=\n  if s.len == 1:\n    return $s[0] & \",\"\n  elif s.len == 2:\n    return $s[0] & \",\" & $s[1] & \",\"\n  else:\n    return $s[0] & \"-\" & $s[^1] & \",\"\n\nproc solution*(arg: seq[int]): string =\n  var stock:seq[int] = arg[0..0]\n  for a in arg[1..^1]:\n    if a != stock[^1]+1:\n      result &= f(stock); stock = @[]\n    stock.add(a)\n  return (result & f(stock))[0..^2]","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214582,"user_id":null,"body":"import strutils\n\nproc splitNonconsecutive(a: seq[int]): seq[seq[int]] =\n  var b = @[a[0]]\n  for i, x in a[1..^1]:\n    if x == a[i] + 1: b.add(x)\n    else: result.add(b); b = @[x]\n  result.add(b)\n\nproc solution*(a: seq[int]): string =\n  var b: seq[string]\n  for x in splitNonconsecutive(a):\n    case x.len\n    of 1: b.add($x[0])\n    of 2:\n      for y in x: b.add($y)\n    else: b.add([x[0], x[^1]].join(\"-\"))\n  return b.join(\",\")","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214583,"user_id":53,"body":"import strutils, sequtils, strformat\n\nproc solution*(a: seq[int]): string =\n  var ans: seq[string] = @[]\n  var last = 0\n  var cnt = 0\n  let n = a.len\n  for i in countup(0, n):\n    let x = (if i < n: a[i] else: 0)\n    if i == 0 or i == n or last + cnt != x:\n      if i != 0:\n        if cnt == 1:\n          ans = concat(ans, @[&\"{last}\"])\n        elif cnt == 2:\n          ans = concat(ans, @[&\"{last},{last+1}\"])\n        else:\n          ans = concat(ans, @[&\"{last}-{last+cnt-1}\"])\n      last = x\n      cnt = 1\n    else:\n      cnt = cnt + 1\n  return ans.join(\",\")","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214584,"user_id":null,"body":"import strformat, strutils\n\nproc addRange(ranges: var seq[string], start: int, prev: int) =\n  if start == prev:\n    ranges.add($start)\n  elif start + 1 == prev:\n    ranges.add($start)\n    ranges.add($prev)\n  else:\n    ranges.add(&\"{start}-{prev}\")\n\nproc solution*(a: seq[int]): string =\n  if a.len == 0:\n    return \"\"\n  var\n    start = a[0]\n    prev = a[0]\n    ranges = newSeq[string]()\n  for x in a[1..^1]:\n    if x == prev + 1:\n      prev = x\n    else:\n      ranges.addRange(start, prev)\n      start = x\n      prev = x\n  ranges.addRange(start, prev)\n  join(ranges, \",\")","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214585,"user_id":759,"body":"proc solution*(a: seq[int]): string =\n  var i = 0\n  while i < a.len:\n    if i != 0: result.add(',')\n    let n = a[i]\n    if i + 2 < a.len and a[i + 2] - n == 2:\n      var j = i + 3\n      while j < a.len and a[j] - n == j - i: inc j\n      result.add($n)\n      result.add('-')\n      result.add($a[j - 1])\n      i = j\n    else:\n      result.add($n)\n      inc i","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"54d496788776e49e6b00052f":[{"id":214586,"user_id":null,"body":"import sequtils, math\n\niterator primes(bound: int): int =\n  var numbers = toSeq(2..bound)\n  while numbers.len != 0:\n    let p = numbers[0]\n    yield p\n    numbers.keepItIf(it mod p != 0)\n\nproc sum_of_divided*(lst: seq[int]): seq[seq[int]] =\n  if lst.len == 0: return\n  for p in primes(max(lst.mapIt(abs(it)))):\n    let nums = lst.filterIt(it mod p == 0)\n    if nums.len != 0: result.add(@[p, sum(nums)])\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214587,"user_id":492,"body":"import sequtils, algorithm\n\nproc sum_of_divided*(lst: seq[int]): seq[seq[int]] =\n    proc primeFactors(n: int): seq[int] =\n        var res: seq[int] = @[]; var fac = 2; var m = abs(n)\n        while fac <= m:\n            var count = 0\n            while m %% fac == 0:\n                count += 1\n                m = m div fac\n            if count > 0:\n                res.add(fac)\n            fac += 1\n        return res\n    proc listOfPrimeFactors(lst: seq[int]): seq[int] =\n        var res =  deduplicate(concat(map(lst, proc(x: int): seq[int] = primeFactors(x))))\n        sort(res, system.cmp[int])\n        return res\n    var res: seq[seq[int]] = @[]\n    let l = listOfPrimeFactors(lst)\n    for _, ll in l:\n        var s = 0\n        for _, v in lst:\n            if (abs(v) %% ll == 0):\n                s += v\n        res.add(@[ll, s])\n    return res","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214588,"user_id":76,"body":"from math import sqrt, sum\nfrom sequtils import filterIt, mapIt, anyIt\n\nproc isPrime(n: int): bool =\n  n > 1 and not (2 .. n.float.sqrt.int).anyIt(n mod it == 0)\n  \nproc sum_of_divided*(lst: seq[int]): seq[seq[int]] =\n  if lst.len == 0: return @[]\n  let lim = max(0, lst.mapIt(it.abs).max)\n  for i in 2 .. lim:\n    if isPrime(i) and lst.anyIt(it mod i == 0):\n      let s = lst.filterIt(it mod i == 0).sum\n      result.add(@[i, s]) ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214589,"user_id":null,"body":"import std\/intsets\nimport std\/tables\nimport std\/algorithm\n\nproc primeFactor(i: int): IntSet =\n  var i = i\n  var ctr = 2\n  while i > 1:\n    if i mod ctr == 0:\n      result.incl(ctr)\n      i = i div ctr\n    else:\n      ctr += 1\n\nproc sum_of_divided*(lst: seq[int]): seq[seq[int]] =\n  # prime factor : sum\n  var pfs = initTable[int, int]()\n  for i in lst:\n    let pf = i.abs.primeFactor\n    for p in pf:\n      pfs[p] = pfs.getOrDefault(p) + i\n  for pf, s in pfs.pairs:\n    result.add(@[pf, s])\n  result.sort do (x, y: seq[int]) -> int:\n    x[0].cmp(y[0])","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214590,"user_id":53,"body":"proc sum_of_divided*(lst: seq[int]): seq[seq[int]] =\n  var ls: seq[seq[int]] = @[]\n  var hs: seq[int] = @[]\n  var n: int = lst.len\n  var m: int = 0\n  if n > 0:\n    m = lst[0]\n  for _, e in lst:\n    m = max(m, abs(e))\n  for i in 0..m:\n    hs.add(0)\n  for i in 2..m:\n    if hs[i] == 0:\n      var b: int = 0\n      var s: int = 0\n      for _, e in lst:\n        if abs(e) %% i == 0:\n          b = b + 1\n          s = s + e\n      if b > 0:\n        ls.add(@[i, s])\n      var j: int = 2 * i\n      while j <= m:\n        hs[j] = 1\n        j = j + i\n  return ls","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214591,"user_id":null,"body":"import std\/[algorithm, math, sequtils]\n\nproc sum_of_divided*(lst: seq[int]): seq[seq[int]] =\n  if len(lst) == 0:\n    return @[]\n  let\n    x = max(lst.mapIt(abs(it)))\n  var\n    k = sqrt(x.float).int\n    s = 0\n    flag = false\n    prime_numbers = @[2]\n    prime = newSeq[bool](x + 1)\n  prime.fill(true)\n  for n in countup(3, k, 2):\n    if prime[n]:\n      prime_numbers.add(n)\n      for t in countup(n ^ 2, x, n):\n        prime[t] = false\n  if k mod 2 == 0:\n    k += 1\n  else:\n    k += 2\n  for n in countup(k, x, 2):\n    if unlikely(prime[n]):\n      prime_numbers.add(n)\n  for p in prime_numbers:\n    for i in lst:\n      if i mod p == 0:\n        flag = true\n        s += i\n    if flag:\n      result.add @[p, s]\n      s = 0\n      flag = false\n\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214592,"user_id":null,"body":"import options\nfrom math import sqrt\n\nproc getPrimeFactors(n: int): seq[int] =\n  let sqr = n.float.sqrt.int\n  if n mod 2 == 0:\n    result.add 2\n  if n mod 3 == 0:\n    result.add 3\n  for i in countup(5, sqr, 6):\n    if n mod i == 0:\n      result.add i\n    if n mod (i + 2) == 0:\n      result.add(i + 2)\n  if result.len == 0:\n    result.add n\n    \nproc getAllPrimesTo(n: int): seq[int] =\n  let sgn = if n < 0: -1 else: 1\n  case sgn * n\n  of 0..1: return @[]\n  of 2: return @[2]\n  else:\n    result.add 2\n    for i in countup(3, n, 2):\n      if i.getPrimeFactors[0] == i: result.add i\n  \n\nproc sum_of_divided*(lst: seq[int]): seq[seq[int]] =\n  if lst.len == 0: return\n  var divisorSum: Option[int]\n  let biggestNumber = max([lst.max, -lst.min])\n  for divisor in getAllPrimesTo(biggestNumber):\n    divisorSum = none int\n    for number in lst:\n      if number mod divisor == 0:\n        if divisorSum.isNone:\n          divisorSum = some 0\n        divisorSum = some divisorSum.get + number\n    if divisorSum.isSome:\n      result.add @[divisor, divisorSum.get]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214593,"user_id":null,"body":"import math\nimport strutils\nimport sequtils\nimport sugar\nproc isPrime(n: int) :bool = \n  if n > 1 and n < 3: return true\n  if n mod 2 == 0: return false\n  for i in countup(3,ceil(sqrt(n.toFloat())).toInt(),2):\n    if n mod i == 0: return false\n  return true\n  \nproc sum_of_divided*(lst: seq[int]): seq[seq[int]] =\n    if len(lst) == 0: return @[]\n    let mx = max(lst.map(x=>abs(x)))\n    \n    for i in 2..mx:\n      if i.isPrime():\n        #echo \"$1 is prime\".format(i)\n        var sum = 0\n        var isDivisor = false\n        for l in lst:\n          #echo \"i:$1 l:$2 mod: $3\".format(i,l,l mod i)\n          if l mod i == 0:\n            isDivisor = true\n            sum += l\n        #echo \"sum: $1\".format(sum)\n        #if sum != 0:\n        if isDivisor:\n          result.add(@[i,sum])\n          \n          \n#a: @[17, -17, 51, -51]\n\n#Exp: @[@[3, 0], @[17, 0]]\n#got: @[]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"54eb33e5bc1a25440d000891":[{"id":214594,"user_id":null,"body":"import math, options\n\nproc helper(n, zz: int, seen: seq[int]): Option[seq[int]] =\n  if n == 0: return some(newSeq[int]())\n  for lg in countdown(zz, 1, 1):\n    if lg notin seen:\n      let x = n - lg * lg\n      let l = helper(x, int(sqrt x.float), seen=seen & @[lg])\n      if l.isSome:\n        return some(l.get() & @[lg])\n\n\n\nproc decompose*(n: int): seq[int] =\n  let l = helper(n * n, n - 1, @[])\n  if l.isSome:\n    return l.get()\n  else:\n    return @[]\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214595,"user_id":76,"body":"import options\nfrom sequtils import concat\n\nproc decomposer(n, maxChoice: int, sol: seq[int]): Option[seq[int]] =\n  if n == 0: return some(sol)\n  for choice in countdown(maxChoice, 1):\n    let rem = n - choice * choice\n    if rem < 0: continue\n    let sol = decomposer(rem, choice - 1, @[choice].concat(sol))\n    if sol.isSome:\n      return sol\n  none(seq[int])\n\nproc decompose*(n: int): seq[int] =\n  let sol = decomposer(n * n, n - 1, @[])\n  if sol.isSome:\n    sol.get\n  else:\n    @[]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214596,"user_id":null,"body":"import math, strformat\n\nproc asSqSum(s: int, max_k: int = s): seq[int] =\n  ## returns different integers which sum of those squares is `s`\n  if s <= 0:\n    return\n  var k = min(s.float.sqrt.ceil.int, max_k)\n  while k > 0:\n    if k * k == s:\n      return @[k]\n    var a = asSqSum(s - k * k, k - 1)\n    if a.len != 0 and a[^1] < k:\n      a.add k\n      return a\n    dec k\n  return @[]\n  \nproc decompose*(n: int): seq[int] =\n  return asSqSum(n * n, n - 1)\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214597,"user_id":492,"body":"import sequtils\n\nproc decompose*(n: int): seq[int] =\n    proc loop(s, i: int): seq[int] =\n        if s < 0: return @[]\n        if s == 0: return @[0]\n        var j: int = i - 1\n        while j > 0:\n            var sub = loop(s - j * j, j)\n            if sub != @[]: \n                let res: seq[int] = sub & @[j]\n                return res\n            j -= 1\n        return @[]\n    var r = loop(n*n, n)\n    r.delete(0, 0)\n    return r","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"55cf3b567fc0e02b0b00000b":[{"id":214598,"user_id":53,"body":"import tables, algorithm, sequtils, strformat\n\nproc part*(n: int): string =\n  var prods = initTable[int, int]()\n  var ls: seq[int] = @[];\n  prods[1] = 1\n  proc aux(t: int, p: int, m: int) =\n    prods[p] = p\n    var i = 2\n    while (i <= m and t + i <= n):\n      aux(t + i, p * i, i)\n      i += 1\n  aux(0, 1, n)\n  for key, val in prods:\n    ls.add(val)\n  ls.sort()\n  let l = ls.len\n  let s = ls.foldl(a + b)\n  let r = ls[l - 1] - ls[0]\n  let u = s \/ l\n  let m = 0.5 * (ls[l div 2] + ls[(l - 1) div 2]).float\n  echo u\n  return &\"Range: {r} Average: {u:.2f} Median: {m:.2f}\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214599,"user_id":null,"body":"import algorithm, sequtils, strutils\n\nproc prods(n: int): seq[int] =\n  var p = @[n]&repeat(1, n-1)\n  var ps = @[n]\n  var ones: int\n  var k = 0\n  while true:\n    ones = 0\n    while k>=0 and p[k]==1: \n      ones+=p[k]; k-=1\n    if ones==n: break\n    ones+=1; p[k]-=1 \n    while ones>p[k]: \n      ones-=p[k]; p[k+1] = p[k]; k+=1\n    k+=1; p[k] = ones\n    ps&=foldl(p, a*b)\n  sorted(deduplicate ps, cmp[int])\n\nproc part*(n: int): string =\n  let lp = prods n\n  let len = len lp\n  let rng = (max lp)-(min lp)\n  let avr = foldl(lp, a+b)\/len\n  let med = (lp[(len-1)\/%2]+lp[len\/%2])\/2\n  \"Range: $1 Average: $2 Median: $3\" % \n    [$rng, avr.formatFloat(ffDecimal, 2), med.formatFloat(ffDecimal, 2)]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214600,"user_id":492,"body":"import sequtils, algorithm, strutils\n\nproc part*(n: int): string =\n    proc average(a: seq[int]): float64 =\n        var total: float64 = float64(a.foldl(a + b))\n        return total \/ float64(a.len)\n    proc arraysProds(a: seq[seq[int]]) : seq[int] =\n        proc produ(a: seq[int]): int = a.foldl(a * b)\n        return map(a, proc(x: seq[int]): int = produ(x))\n    proc partAux(s, k: int): seq[seq[int]] =\n        let k0 = min(s, k)\n        var res: seq[seq[int]] = @[]\n        var n = k0\n        var r: int\n        while n > 0:\n            r = s - n\n            if r > 0:\n                var arr = partAux(r, n)\n                for _, v in arr:\n                    var t = v\n                    t.add(n)\n                    res.add(t)\n            else:\n                res.add(@[n])\n            n -= 1\n        return res\n    \n    var prods: seq[int] = deduplicate(arraysProds(partAux(n, n)))\n    sort(prods, system.cmp[int])\n    let avg = average(prods)\n    let lg = prods.len\n    let rge = prods[lg - 1] -  prods[0]\n    let md = float64(prods[(lg - 1) div 2] + prods[lg div 2]) \/ 2.0\n    let res = \"Range: $1\".format(rge) & \" Average: \" & avg.formatFloat(ffDecimal, 2) & \" Median: \" & md.formatFloat(ffDecimal, 2)\n    return res","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214601,"user_id":null,"body":"import sequtils, math, algorithm, strformat, sets\n\nfunc partitions(n: int): seq[seq[int]] =\n  var partitions = newSeq[seq[seq[int]]](n + 1) \n  partitions[1] = @[@[1]]\n  for k in 2..n:\n    for i in 1..(k div 2): # `i` is minimal number in partition \n      for part in partitions[k - i]:\n        if i <= part[0]:\n          partitions[k].add(@[i].concat(part))\n    partitions[k].add(@[k])\n  return partitions[^1]\n  \nproc part*(n: int): string =\n  let prod = partitions(n).mapIt(prod(it)).toHashSet.toSeq.sorted\n  let median =\n    if prod.len mod 2 == 1: prod[prod.len div 2].float\n    else: (prod[prod.len div 2 - 1] + prod[prod.len div 2]) \/ 2\n  return &\"Range: {prod[^1] - prod[0]} Average: {prod.sum \/ prod.len:.2f} Median: {median:.2f}\"\n\n  ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214602,"user_id":null,"body":"import sequtils, algorithm, strformat\n\nvar items: seq[int]\nvar ans: seq[int]\nproc backtrack(n: int, start: int, target: int) =\n    # echo(n, start, target)\n    if target == 0: \n        # echo(items, \", \", items.foldl(a*b))\n        ans.add(items.foldl(a*b))\n        return\n    for i in start..n:\n        if target - i >= 0:\n            items.add(i)\n            # echo(i)\n            backtrack(n, i, target - i)\n            items.del(len(items)-1)\n\nproc part*(n: int): string =\n    # your code\n    # echo(\"n=\",n)\n    items = newSeq[int]()\n    ans = newSeq[int]()\n    backtrack(n, 1, n)\n    ans.sort()\n    ans = deduplicate(ans, true)\n    # echo(\"ans:\", ans)\n    let rr = ans[len(ans)-1] - ans[0]\n    let aa = float(ans.foldl(a+b)) \/ float(len(ans))\n    var mm = 0.0\n    if len(ans) mod 2 == 1:\n        mm = float(ans[len(ans) div 2])\n    else:\n        mm = float(ans[len(ans) div 2 - 1] + ans[len(ans) div 2]) \/ 2.0\n    return &\"Range: {rr} Average: {aa:.2f} Median: {mm:.2f}\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5629db57620258aa9d000014":[{"id":214603,"user_id":76,"body":"import tables, strutils, sequtils, algorithm\n\nproc mix_strings*(s1, s2: string): string =\n  var \n    m1 = toCountTable(s1.filter(isLowerAscii))\n    m2 = toCountTable(s2.filter(isLowerAscii))\n    parts = newSeq[tuple[c: char, maxCnt: int, repr: char]]()\n  \n  for c in 'a' .. 'z':\n    let \n      cntA = m1.getOrDefault(c, 0)\n      cntB = m2.getOrDefault(c, 0)\n      maxCnt = max(cntA, cntB)\n      repr = if cntA > cntB: '1' elif cntA < cntB: '2' else: '='\n    if maxCnt > 1:\n      parts.add((c, maxCnt, repr))\n      \n  parts = parts.sortedByIt((-it.maxCnt, it.repr, it.c))\n  \n  for p in parts:\n    if result.len > 0: result &= '\/'\n    result &= \"$1:$2\".format(p.repr, p.c.repeat(p.maxCnt))","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214604,"user_id":null,"body":"import strutils\n\nproc mix_strings*(s1, s2: string): string =\n  var\n    x: seq[tuple[count: int, owner: char, letter: char]]\n    s: string\n    k, i: int\n  for c in s1 & s2 :\n    if 'a' <= c and c <= 'z':\n      if not (c in s):\n        let\n          n = s1.count(c)\n          m = s2.count(c)\n        if n > m and n > 1:\n          x.add (n, '1', c)\n        elif n < m and m > 1:\n          x.add (m, '2', c)\n        elif n == m and n > 1:\n          x.add (n, '=', c)\n        s.add c\n  k = len(x)\n  while k > 0:\n    for j in 0 ..< k:\n      if x[j][0] > x[i][0]:\n        i = j\n      elif x[j][0] == x[i][0]:\n        if x[j][1] < x[i][1]:\n          i = j\n        elif x[j][1] == x[i][1]:\n          if x[j][2] < x[i][2]:\n            i = j\n    result.add '\/' & x[i][1] & ':'\n    for _ in 1 .. x[i][0]:\n      result.add x[i][2]\n    x.delete i\n    i = 0\n    k.dec\n  if result.len > 0:\n    result = result[1..^1]\n\n\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214605,"user_id":null,"body":"from tables import toCountTable, `[]`\nfrom strutils import join, repeat\nfrom algorithm import sorted\nimport sequtils\nimport nre except toSeq\n\nproc mix_strings*(s1, s2: string): string =\n  let\n    c1 = toCountTable(replace(s1, re\"[^a-z]\", \"\"))\n    c2 = toCountTable(replace(s2, re\"[^a-z]\", \"\"))\n\n  {'a'..'z'}\n    .toSeq()\n    .filterIt(c1[it] > 1 or c2[it] > 1)\n    .map(proc (it: char): string =\n      let cmp = c1[it] - c2[it]\n      result = if cmp == 0: \"=:\"\n      elif cmp >= 1: \"1:\"\n      else: \"2:\"\n      result &= repeat(it, if cmp>0: c1[it] else: c2[it])\n    )\n    .sorted(proc (x, y: string): int =\n      result = cmp(y.len, x.len)\n      if result == 0:\n        result = cmp(x, y)\n    )\n    .join(\"\/\")\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214606,"user_id":null,"body":"import tables, strutils, sequtils, algorithm\n\nproc `[]`(t: var Table; k: t.A, v: t.B): var t.B =\n  if k notin t: t[k] = v\n  t[k]\n\nproc mix_strings*(s1, s2: string): string =\n  var t = initTable[char, (int, int)]()\n  for ch in s1: (if ch.isLowerAscii: t[ch, (0, 0)][0] += 1)\n  for ch in s2: (if ch.isLowerAscii: t[ch, (0, 0)][1] += 1)\n  let l = toSeq(t.pairs)\n    .filterIt(max(it[1][0], it[1][1]) > 1)\n    .map do (kv: auto) -> auto:\n      let \n        ch = kv[0]\n        (a, b) = kv[1]\n        v = if a == b: '=' else: (if a > b: '1' else: '2')\n      (ch: v, str: ($ch).repeat(max(a, b)))\n  l.sortedByIt((-it.str.len, it.ch, it.str[0]))\n    .mapIt(it.ch & \":\" & it.str)\n    .join(\"\/\")","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214607,"user_id":492,"body":"import strutils, algorithm\n    \nproc mix_strings*(s1, s2: string): string =\n    proc comp(x, y: string): int =\n        if x.len() == y.len:\n            return cmp(x, y)\n        return cmp(y.len, x.len)\n    let alphabase = \"abcdefghijklmnopqrstuvwxyz\"\n    var res: seq[string] = @[]\n    for c in alphabase:\n        let nbS1 = s1.count(c)\n        let nbS2 = s2.count(c)\n        if nbS1 > 1 or nbS2 > 1:\n            if nbS1 == nbS2:\n                res.add(\"=:\" & repeat(c, nbS1))\n            elif nbS1 > nbS2:\n                res.add(\"1:\" & repeat(c, nbS1))\n            elif nbS1 < nbS2:\n               res.add(\"2:\" & repeat(c, nbS2))\n    res.sort(comp)\n    return join(res, \"\/\")","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5672682212c8ecf83e000050":[{"id":214608,"user_id":53,"body":"proc dbl_linear*(n: int): int =\n  var u: array[0..1000000, int]\n  u[0] = 1\n  var x = 0\n  var y = 0\n  var a = 0\n  var b = 0\n  for i in countup(1, n):\n    a = 2 * u[x] + 1\n    b = 3 * u[y] + 1\n    u[i] = (if a < b: a else: b)\n    if u[i] == 2 * u[x] + 1:\n      x += 1\n    if u[i] == 3 * u[y] + 1:\n      y += 1\n  result = u[n]","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214609,"user_id":492,"body":"import deques\n\nproc dbl_linear*(n: int): int =\n    var h = 1\n    var cnt = 0\n    var q2 = initDeque[int]()\n    var q3 = initDeque[int]()\n    while true:\n        if (cnt >= n):\n            return h\n        q2.addLast(2 * h + 1)\n        q3.addLast(3 * h + 1)\n        h = min(q2[0], q3[0])\n        if h == q2[0]: h = q2.popFirst()\n        if h == q3[0]: h = q3.popFirst()\n        cnt += 1","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214610,"user_id":null,"body":"proc dbl_linear*(n: int): int =\n  var\n    u = @[1]\n    i = 0\n    j = 0\n  \n  for _ in 1..n:\n    let x = 2 * u[i] + 1\n    let y = 3 * u[j] + 1\n    if x <= y: i += 1\n    if x >= y: j += 1\n    u.add(min(x,y))\n\n  return u[n]\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214611,"user_id":76,"body":"proc dbl_linear*(n: int): int =\n  var\n    sequence: seq[int] = @[1]\n    a = 0\n    b = 0\n  \n  while sequence.len <= n:\n    let y = 2 * sequence[a] + 1\n    let z = 3 * sequence[b] + 1\n    if y < z:\n      sequence.add(y)\n      inc a\n    elif y > z:\n      sequence.add(z)\n      inc b\n    else:\n      sequence.add(y)\n      inc a\n      inc b\n      \n  sequence[^1]","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214612,"user_id":null,"body":"import std\/intsets\nimport std\/algorithm\nimport std\/sequtils\n\nvar vals = initIntSet()\nvals.incl(1)\nproc calc(n, depth: int) =\n  let y = 2 * n + 1\n  let z = 3 * n + 1\n  vals.incl(y)\n  vals.incl(z)\n  if depth >= 1:\n    calc(y, depth-1)\n    calc(z, depth-1)\n  \ncalc(1, 20)\n\nvar v: seq[int] = toSeq(items(vals))\nv.sort()\n\nproc dbl_linear*(n: int): int =\n  return v[n]","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214613,"user_id":50,"body":"import std\/lists\n\nproc dbl_linear*(n: int): int =\n  var i=0\n  var j=0\n  var m=n\n  var L: seq[int]\n  L.add(1)\n  while m != 0:\n    m-=1\n    var a=L[i]*2+1\n    var b=L[j]*3+1\n    if a<=b:\n      L.add(a)\n      i+=1\n      if a==b:\n        j+=1\n    else:\n      L.add(b)\n      j+=1\n  return L[n]","lang_id":33,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"56c04261c3fcf33f2d000534":[{"id":214614,"user_id":676,"body":"import math\n\nproc doubles*(maxk, maxn: int): float64 =\n  result = 0\n  for k in countup(1, maxk):\n    for n in countup(1, maxn):\n      result += 1\/(float(k)*pow(float(n + 1), float(2*k)))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214615,"user_id":492,"body":"import math\nproc doubles*(maxk, maxn: int): float64 =\n  var sum: float64 = 0.0\n  for k in 1..maxk:\n    for n in 1..maxn:\n      sum = sum + (1.0 \/ (float64(k) * math.pow(float64(n + 1), float64(2 * k))))\n  return sum","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214616,"user_id":492,"body":"import math\nproc doubles*(maxk, maxn: int): float64 =\n  var sum: float64 = 0.0\n  for k in 1..maxk:\n    for n in 1..maxn:\n      sum = sum + (1.0 \/ (float64(k) * math.pow(float64(n + 1), float64(2 * k))))\n  return sum","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214617,"user_id":76,"body":"import math\n\nproc doubles*(maxk, maxn: int): float64 =\n  for k in 1 .. maxk:\n    for n in 1 .. maxn:\n      result += 1 \/ (float64(k) * pow(float64(n + 1), float64(k * 2)))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214618,"user_id":null,"body":"import math\n\nproc f(ki, ni: int): float64 =\n    let k = ki.toFloat\n    let n = ni.toFloat\n    1 \/ (k * pow((n+1), 2*k))\n\n\nproc doubles*(maxk, maxn: int): float64 =\n    for k in 1..maxk:\n        for n in 1..maxn:\n            result += f(k, n)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214619,"user_id":50,"body":"import math\nproc doubles*(maxk, maxn: int): float64 =\n  var o=0.0\n  for k in 1..maxk:\n    for n in 1..maxn:\n      o+=1.0\/(k.float*math.pow((n+1).float,(2*k).float))\n  return o","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214620,"user_id":53,"body":"import math\n\nproc doubles*(maxk, maxn: int): float64 =\n  var sum = float64(0)\n  var k = float64(1)\n  var n = float64(0)\n  while int(k) <= maxk:\n    n = float64(1)\n    while int(n) <= maxn:\n      sum += float64(1) \/ (k * pow(n + float64(1), float64(2) * k))\n      n += float64(1)\n    k += float64(1)\n  return sum","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214621,"user_id":null,"body":"import math, sequtils, sugar\n\nproc doubles*(maxk, maxn: int): float64 =\n  toSeq(1..maxk)\n  .map(k => toSeq(1..maxn)\n       .map(n => 1\/(k.float*pow(n.float+1, 2*k.float)))\n       .foldl(a+b))\n  .foldl(a+b)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214622,"user_id":null,"body":"import future\nimport sequtils\nimport math\nproc doubles*(maxk, maxn: int): float64 = foldl(lc[ 1 \/ (float64(k) * pow(float64(n + 1), float64(2 * k))) | (n <- toSeq(1..maxn), k <- toSeq(1..maxk)), float64], a + b)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214623,"user_id":null,"body":"import math\n\nproc doubles*(maxk, maxn: int): float64 = \n  for k in 1..maxk:\n    for n in 1..maxn:\n      result += 1.0 \/ k.float \/ pow((n.float + 1.0), (2.0 * k.float))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5868a68ba44cfc763e00008d":[{"id":214624,"user_id":53,"body":"import tables, re\n\nproc interpreter*(raw: string, limit: int, w: int, h: int): string =\n  \n  let code = raw.replace(re\"[^nesw*\\[\\]]\", \"\")\n  var jumps = initTable[int, int]()\n  var opens: seq[int] = @[];\n  var grid: seq[seq[string]] = @[];\n  \n  for i in countup(0, h - 1):\n    var r: seq[string] = @[]\n    for j in countup(0, w - 1):\n      r.add(\"0\")\n    grid.add(r)\n      \n  for i in countup(0, code.len - 1):\n    var c = code[i]\n    if c == '[':\n      opens.add(i)\n    elif c == ']':\n      var j = opens[opens.len - 1]\n      jumps[i] = j\n      jumps[j] = i\n      opens.del(opens.len - 1)\n    \n  var i = 0\n  var j = 0\n  var x = 0\n  var y = 0\n  while j < limit and i < code.len:\n    var c = code[i]\n    var z = grid[y][x]\n    if c == 'n':\n      y = (y - 1 + h) %% h\n    elif c == 'w':\n      x = (x - 1 + w) %% w\n    elif c == 's':\n      y = (y + 1) %% h\n    elif c == 'e':\n      x = (x + 1) %% w\n    elif c == '*' and z == \"0\":\n      grid[y][x] = \"1\"\n    elif c == '*' and z == \"1\":\n      grid[y][x] = \"0\"\n    elif c == '[' and z == \"0\":\n      i = jumps[i]\n    elif c == ']' and z == \"1\":\n      i = jumps[i]\n    i = i + 1\n    j = j + 1\n    \n  var ans = \"\"\n  for i in countup(0, h - 1):\n    for j in countup(0, w - 1):\n      ans = ans & grid[i][j]\n    if i < h - 1:\n      ans = ans & \"\\r\n\"\n      \n  return ans","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214625,"user_id":null,"body":"import sequtils, strutils, re\n\nproc sb(ch: char, b: int): int =\n  case ch:\n    of '[': b+1\n    of ']': b-1\n    else: b\n\nproc interpreter*(code: string, iterations: int, \n                  width: int, height: int): string =\n  var grid = repeat(repeat(0, width), height)\n  if iterations>0:\n    let coms = code.replace re\"[^nswe\\*\\[\\]]\"\n    if coms!=\"\":\n      var pos = 0; var it = 0\n      var r = 0; var c = 0\n      let size = len coms\n      var b: int\n      while it<iterations and pos<size:\n        case coms[pos]:\n          of 'e': c = (c+1) mod width\n          of 's': r = (r+1) mod height\n          of 'w': c = (c-1+width) mod width\n          of 'n': r = (r-1+height) mod height\n          of '[': \n            if grid[r][c]==0: \n              b = 1; while b>0 and pos+1<size: \n                       pos+=1; b = sb(coms[pos], b)\n          of ']':         \n            if grid[r][c]==1: \n              b = -1; while b<0 and pos>0: \n                        pos-=1; b = sb(coms[pos], b)\n          of '*': grid[r][c] = (grid[r][c]+1) mod 2  \n          else: discard  \n        pos+=1; it+=1\n  grid.mapIt(foldl(it, a & $b, \"\")).join(\"\\r\n\")","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214626,"user_id":null,"body":"import strutils\nconst\n    Flip = '*'\n    Jump = '['\n    Ret = ']'\n    East = 'e'\n    North = 'n'\n    South = 's'\n    West = 'w'\ntype\n  Program = object\n    code: string#seq[Cmd]\n    grid: seq[bool]\n    pc,turtle:int\n    width,height: int\n    frames: seq[int]\n    \nproc init(p:typedesc[Program],code:string,w,h:int):Program =\n  result.width = w\n  result.height = h\n  result.grid = newSeq[bool](w*h)\n  result.code = code#cast[seq[Cmd]](code)\n  result.pc = 0\n  result.turtle = 0\n    \nproc `$`(p:Program):string = \n  var x=0\n  for cell in p.grid:\n    result.add (if cell: \"1\" else: \"0\")\n    inc x\n    if x==p.width:\n      result.add(\"\\r\n\")\n      x=0\n  result.setlen result.len - 2\nproc find(s:string,pc:int):int =\n  var stack = 0\n  result = pc + 1\n  while stack > 0 or s[result] != ']':\n    case s[result]\n    of '[': inc stack\n    of ']': dec stack\n    else: discard\n    inc result\nproc rfind(s:string,pc:int):int =\n  var stack = 0\n  result = pc - 1\n  while stack > 0 or s[result] != '[':\n    case s[result]\n    of ']': inc stack\n    of '[': dec stack\n    else: discard\n    dec result\nproc step(p:var Program):int =\n  result = 1\n  case p.code[p.pc]\n  of North:\n    p.turtle -= p.width\n    if p.turtle < 0: p.turtle += p.grid.len\n  of South:\n    p.turtle += p.width\n    if p.turtle >= p.grid.len: p.turtle -= p.grid.len\n  of West:\n    if p.turtle mod p.width == 0:\n      p.turtle += (p.width - 1)\n    else:\n      p.turtle -= 1\n  of East:\n    if p.turtle mod p.width == (p.width - 1):\n      p.turtle -= (p.width - 1)\n    else:\n      p.turtle += 1\n  of Flip:\n    p.grid[p.turtle] = not p.grid[p.turtle]\n  of Jump:\n    if not p.grid[p.turtle]:\n      p.pc = p.code.find(p.pc)\n  of Ret:\n    if p.grid[p.turtle]:\n      p.pc = p.code.rfind(p.pc)\n  else:\n    result = 0\n  inc p.pc\n  \nproc interpreter*(code: string,\n                  iterations: int,\n                  width: int, height: int): string =\n  # Implement your interpreter here\n  var program = Program.init(code,width,height)\n  var it = iterations\n  while it > 0:\n    try:\n      it -= program.step()\n    except IndexError:\n      break\n    \n  return $program","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214627,"user_id":null,"body":"import sequtils, tables, strutils\n\nproc findMatchingBrace(s: string, b: int): int =\n  let costs = { '[': 1, ']': -1 }.toTable\n  result = b\n  var open_braces = costs[s[b]]\n  while open_braces != 0:\n    result += costs[s[b]]\n    open_braces += costs.getOrDefault(s[result])\n\n\nproc interpreter*(code: string,\n                  iterations: int,\n                  width: int, height: int): string =\n  var cells = newSeq[int8](width).repeat(height) ## !!y-coord first!!\n  var \n    x = 0\n    y = 0\n    eval_pointer = 0\n    iters_remain = iterations\n  while iters_remain != 0:\n    if eval_pointer == code.len:\n      break\n    case code[eval_pointer]\n    of 'n': y = (y - 1 + height) mod height\n    of 'e': x = (x + 1) mod width\n    of 's': y = (y + 1) mod height\n    of 'w': x = (x - 1 + width) mod width\n    of '*': cells[y][x] = (cells[y][x] + 1) mod 2\n    of '[':\n      if cells[y][x] == 0:\n        eval_pointer = code.findMatchingBrace(eval_pointer)\n    of ']':\n      eval_pointer = code.findMatchingBrace(eval_pointer)\n      continue\n    else:\n      inc eval_pointer\n      continue \n    inc eval_pointer\n    dec iters_remain\n  return cells.mapIt(it.mapIt($it).join()).join(\"\\r\n\")","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214628,"user_id":null,"body":"import sequtils, strutils, re\n\nproc sb(ch: char, b: int): int =\n  case ch:\n    of '[': b+1\n    of ']': b-1\n    else: b\n\nproc init(w, h: int): seq[seq[int]] = \n  repeat(repeat(0, w), h)\n\nproc toStr(grid: seq[seq[int]]): string = \n  grid.mapIt(foldl(it, a & $b, \"\")).join(\"\\r\n\")\n\nproc interpreter*(code: string, iterations: int, \n                  width: int, height: int): string =\n  var grid = init(width, height)\n  if iterations>0:\n    let ccode = code.replace re\"[^nswe\\*\\[\\]]\"\n    if ccode!=\"\":\n      let coms = toSeq(ccode.items)\n      var pos = 0; var it = 0\n      var r = 0; var c = 0\n      let size = len coms\n      var b: int\n      while it<iterations and pos<size:\n        case coms[pos]:\n          of 'e': c = (c+1) mod width\n          of 's': r = (r+1) mod height\n          of 'w': c = (c-1+width) mod width\n          of 'n': r = (r-1+height) mod height\n          of '[': \n            if grid[r][c]==0: \n              b = 1; while b>0 and pos+1<size: \n                       pos+=1; b = sb(coms[pos], b)\n          of ']':         \n            if grid[r][c]==1: \n              b = -1; while b<0 and pos>0: \n                        pos-=1; b = sb(coms[pos], b)\n          of '*': grid[r][c] = (grid[r][c]+1) mod 2  \n          else: discard  \n        pos+=1; it+=1\n  toStr grid","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214629,"user_id":null,"body":"proc interpreter*(code: string,\n                  iterations: int,\n                  width: int, height: int): string =\n\n  var canvas = newSeq[bool](height*width)\n  var (cx, cy) = (0, 0)\n\n  var instr = 0\n  var it = 0\n  # not `for` to handle loops (`instr`) and comments (`it`), use `while`\n  while instr < code.len and it < iterations:\n    case code[instr]\n    of 'n':\n      cy = (cy + height - 1) mod height\n    of 's':\n      cy = (cy          + 1) mod height\n    of 'w':\n      cx = (cx + width  - 1) mod width\n    of 'e':\n      cx = (cx          + 1) mod width\n    of '*':\n      canvas[width*cy + cx] = not canvas[width*cy + cx]\n    of '[':\n      if not canvas[width*cy + cx]:\n        # jump to next ']'\n        var depth = 1\n        while depth > 0 and instr < code.len:\n          inc instr\n          case code[instr]\n          of '[': inc depth\n          of ']': dec depth\n          else:   discard\n\n        if instr == code.len:\n          raise newException(ValueError, \"no matching `[` found\")\n    of ']':\n      # jump to the prev '['\n      if canvas[width*cy + cx]:\n        var depth = 1\n        while depth > 0 and instr >= 0:\n          dec instr\n          case code[instr]\n          of '[': dec depth\n          of ']': inc depth\n          else:   discard\n\n        if instr == -1:\n          raise newException(ValueError, \"no matching `[` found\")\n    else:\n      dec it\n    inc instr\n    inc it\n\n  result = newStringOfCap(height*(width+2) - 2)\n  for i in 0 ..< height:\n    for j in 0 ..< width:\n      let ch = if canvas[width*i + j]: '1' else: '0'\n      result.add(ch)\n    if i != height-1:\n      result.add(\"\\r\n\")","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5886e082a836a691340000c3":[{"id":214630,"user_id":53,"body":"import math\n\nproc rectangle_rotation*(a: int, b: int): int =\n  var x = int(float64(a) \/ sqrt(2.0))\n  var y = int(float64(b) \/ sqrt(2.0))\n  var r = (x + 1) * (y + 1) + x * y\n  return r + r %% 2 - 1","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214631,"user_id":76,"body":"from math import sqrt\n\nproc rectangle_rotation*(a: int, b: int): int =\n  let\n    x = (a.float \/ sqrt(2.0)).int\n    y = (b.float \/ sqrt(2.0)).int\n    p = int(x mod 2 == y mod 2)\n  2 * x * y + x + y + p","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214632,"user_id":168,"body":"import std\/math\n\nproc rectangle_rotation*(a: int, b: int): int =\n  let x = int(float(a) \/ sqrt(2.0))\n  let y = int(float(b) \/ sqrt(2.0))\n  2 * x * y + x + y + (x + y + 1) %% 2","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214633,"user_id":50,"body":"import math\nproc rectangle_rotation*(a: int, b: int): int =\n  var e=int(float(a) \/ sqrt(2.0))\n  var h=int(float(b) \/ sqrt(2.0))\n  var x=2*e*h+e+h+1\n  if x mod 2 == 0:\n    return x-1\n  return x","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214634,"user_id":645,"body":"import math\nproc rectangle_rotation*(a: int, b: int): int =\n  let h = int(float(a) \/ sqrt(2.0))\n  let v = int(float(b) \/ sqrt(2.0))\n  h * v + (h + 1) * (v + 1) - ((h mod 2) xor (v mod 2))","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"50654ddff44f800200000004":[{"id":214635,"user_id":676,"body":"proc multiply*(a, b: auto): auto = a * b","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214636,"user_id":527,"body":"p_R_o_C m_U_l_T_i_P_l_Y*(a, b: a_U_tO): a_UT_O = a * b","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214637,"user_id":759,"body":"template multiply*(a,b):auto=a*b","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214638,"user_id":492,"body":"proc multiply*(a:int, b: int): int = \n  result = a * b","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214639,"user_id":null,"body":"func multiply*(a, b: int): int = a * b","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214640,"user_id":null,"body":"proc multiply*(a, b: int): auto = \n#  result = a * b\n  return a * b","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214641,"user_id":53,"body":"proc multiply*(a, b: int) : int {.discardable.} = a * b","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214642,"user_id":null,"body":"proc multiply*(a: int, b: int): int =\n  return (a * b);","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214643,"user_id":null,"body":"proc multiply* (a, b: int): auto =\n  a * b","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214644,"user_id":null,"body":"proc multiply*(a, b: int): int {.discardable.} =\n  return a * b\n\n","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"511f11d355fe575d2c000001":[{"id":214645,"user_id":527,"body":"proc two_oldest_ages*(ages: seq[int]): array[2, int] =\n  for x in ages:\n    if x > result[0]:\n      if x > result[1]:\n        (result[0], result[1]) = (result[1], x)\n      else:\n        result[0] = x","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214646,"user_id":null,"body":"import algorithm\nproc two_oldest_ages*(ages: seq[int]): array[2, int] =\n  let r = ages.sorted(system.cmp[int], SortOrder.Descending)\n  result = [r[1], r[0]]","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214647,"user_id":null,"body":"from algorithm import sorted\n\nproc two_oldest_ages*(ages: seq[int]): array[2, int] =\n  var ages = ages.sorted(cmp)\n  [ages[^2], ages[^1]]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214648,"user_id":53,"body":"import algorithm\nimport sequtils, sugar\n\nproc compare(x, y: int): int =\n  if x < y: 1\n  elif x == y: 0\n  else: -1\n  \nproc two_oldest_ages*(ages: seq[int]): array[2, int] =\n  var sorted = ages.map(e => e)\n  sorted.sort(compare)\n  return [ sorted[1], sorted[0] ]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214649,"user_id":76,"body":"from algorithm import sorted\n\nproc two_oldest_ages*(ages: seq[int]): seq[int] =\n  ages.sorted[^2 .. ^1]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214650,"user_id":null,"body":"import std\/algorithm\n\nproc two_oldest_ages*(ages: seq[int]): array[2, int] =\n  var a = ages\n  a.sort(system.cmp)\n  return [a[^2],a[^1]]\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214651,"user_id":null,"body":"import std\/algorithm\n\nproc two_oldest_ages*(ages: seq[int]): array[2, int] =\n  let aa = ages.sorted()\n  return [aa[^2], aa[^1]]\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214652,"user_id":null,"body":"proc two_oldest_ages*(ages: seq[int]): array[2, int] =\n  for age in ages:\n    if age > result[0]:\n      result[0] = age\n      if age > result[1]:\n        swap(result[0], result[1])","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214653,"user_id":null,"body":"proc two_oldest_ages*(ages: seq[int]): array[2, int] =\n  assert(ages.len >= 2)\n  var res: array[2, int]\n  res[0] = low(int)\n  res[1] = low(int)\n  \n  for age in ages:\n    if age > res[1]:\n      res[0] = res[1]\n      res[1] = age\n    elif age > res[0]:\n      res[0] = age\n  return res","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214654,"user_id":null,"body":"import std\/algorithm\nproc two_oldest_ages*(ages: seq[int]): array[2, int] =\n  var agesS = ages\n  agesS.sort(SortOrder.Descending)\n  [agesS[1], agesS[0]]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"514b92a657cdc65150000006":[{"id":214655,"user_id":null,"body":"proc solution*(n: int): int =\n  for num in 1..<n:\n    if num mod 3 == 0 or num mod 5 == 0:\n      result += num\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214656,"user_id":null,"body":"proc solution*(n: int): int =\n  for n in 1..<n:\n    if n mod 3 == 0 or n mod 5 == 0:\n      result += n\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214657,"user_id":null,"body":"proc solution*(n: int): int =\n    var sum = 0\n    for x in 1..<n:\n        if x mod 3 == 0 or x mod 5 == 0: sum += x\n    return sum","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214658,"user_id":null,"body":"proc solution*(n: int): int =\n  result = 0\n  for i in 0 ..< n:\n    if i mod 3 == 0 or i mod 5 == 0:\n      result += i","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214659,"user_id":null,"body":"import sequtils\nimport future\nproc solution*(n: int): int = foldl(lc[x | (x <- 1..(n - 1), x mod 3 == 0 or x mod 5 == 0), int], a + b)\n","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214660,"user_id":null,"body":"proc solution*(n: int): int =\n  for x in 3..<n:\n    if x mod 3 == 0 or x mod 5 == 0:\n      inc result, x","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214661,"user_id":null,"body":"from math import sum\nfrom sequtils import filter, toSeq\n\nproc solution*(n: int): int =\n  toSeq(3..<n).filter(proc(i: int): bool = i mod 3 == 0 or i mod 5 == 0).sum","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214662,"user_id":168,"body":"proc solution*(n: int): int =\n  var i = 1\n  var s = 0\n  while i < n:\n    if i %% 3 == 0 or i %% 5 == 0:\n      s += i\n    i += 1\n  return s\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214663,"user_id":null,"body":"import sequtils, math\nproc solution*(n: int): int =\n  if n <= 0:\n    0\n  else:\n    (1..<n).toSeq.filterIt(it mod 3 == 0 or it mod 5 == 0).sum","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214664,"user_id":null,"body":"proc solution*(number: int): int =\n  var sum: int = 0;\n  for i in (1..number-1):\n    if(i mod 5 == 0 or i mod 3 == 0):\n      sum += i;\n  return sum;","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5168bb5dfe9a00b126000018":[{"id":214665,"user_id":759,"body":"from unicode import reversed\n\nproc solution*(str: string): string =\n  str.reversed","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214666,"user_id":null,"body":"import unicode\n\nproc solution*(str: string): string =\n\n  return reversed(str) ","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214667,"user_id":null,"body":"import strutils\n\nproc solution*(str: string): string =\n  var new_str: string = newStringOfCap(str.len)\n  for i in  1 .. str.len:\n    new_str.add str[^i]\n  return new_str","lang_id":33,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214668,"user_id":null,"body":"import strutils, sequtils, algorithm\n\nproc solution*(str: string): string =\n  return str\n    .toSeq()\n    .reversed()\n    .join(\"\")\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214669,"user_id":null,"body":"import unicode\nproc solution*(str: string): string =\n  str.reversed","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214670,"user_id":null,"body":"proc solution*(str: string): string =\n  for c in str:\n    result = c & result","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214671,"user_id":null,"body":"import strutils\nimport algorithm\nproc solution*(str: string): string = join(reversed(str))","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214672,"user_id":null,"body":"proc solution*(str: string): string =\n  result=\"\"\n  for ch in str:\n    result = $ch & result","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214673,"user_id":null,"body":"proc solution*(str: string): string =\n  for i in countdown(str.high, 0):\n    result.add(str[i])","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214674,"user_id":76,"body":"proc solution*(str: string): string =\n  for i in countdown(high(str), low(str)):\n    result &= str[i]","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"517b25a48557c200b800000c":[{"id":214675,"user_id":759,"body":"import times\n\nproc elapsedSeconds*(startTime: Time, endTime: Time): int64 =\n  endTime - startTime","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214676,"user_id":null,"body":"import times\nimport strUtils\n\nproc getSeconds(time: Time): int64 =\n  type\n    stackInt = array[0..3, int]\n  var stack : stackInt\n  stack[0] = parseInt(time.format(\"d\"))\n  stack[1] = parseInt(time.format(\"m\"))\n  stack[2] = parseInt(time.format(\"s\"))\n  result = stack[2] + stack[1]*60 + stack[0]*60*24\n    \nproc elapsedSeconds*(startTime: Time, endTime: Time): int64 =\n  var endSeconds = getSeconds(endTime)\n  var initSeconds = getSeconds(startTime)\n  result = endSeconds - initSeconds\n  \n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214677,"user_id":53,"body":"import times\n\nproc elapsedSeconds*(a: Time, b: Time): int64 =\n  return (b - a).seconds;","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214678,"user_id":759,"body":"import times\n\nproc elapsedSeconds*(startTime: Time, endTime: Time): int64 =\n  (endTime - startTime).inSeconds","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214679,"user_id":1134,"body":"import times\n\nproc elapsedSeconds*(startTime: Time, endTime: Time): int64 =\n    endTime.int64-startTime.int64 #not real familiar with nim","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214680,"user_id":null,"body":"import times\n\nproc elapsedSeconds*(startTime: Time, endTime: Time): int64 =\n  return endTime - startTime","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214681,"user_id":null,"body":"import times\n\nproc elapsedSeconds*(startTime: Time, endTime: Time): int64 =\n  endTime.int64 - startTime.int64\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214682,"user_id":null,"body":"import times\n\nproc elapsedSeconds*(startTime: Time, endTime: Time): int64 =\n  result = endTime.toSeconds.int - startTime.toSeconds.int","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214683,"user_id":527,"body":"import times\n\nproc elapsedSeconds*(startTime: Time, endTime: Time): int64 =\n  (endTime.toSeconds - startTime.toSeconds).int64","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214684,"user_id":527,"body":"import times\n\nproc elapsedSeconds*(startTime: Time, endTime: Time): int64 =\n  (endTime.toSeconds - startTime.toSeconds).int","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"51b6249c4612257ac0000005":[{"id":214685,"user_id":759,"body":"from algorithm import reversed\nfrom sequtils import toSeq\n\nproc rnum(c: char): int =\n  case c\n  of 'M': 1000\n  of 'D': 500\n  of 'C': 100\n  of 'L': 50\n  of 'X': 10\n  of 'V': 5\n  of 'I': 1\n  else: 0\n\nproc solution*(roman: string): int =\n  var previous = 0\n  for c in roman.items.toSeq.reversed:\n    let r = c.rnum\n    if r < previous: result -= r\n    else: result += r\n    previous = r","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214686,"user_id":76,"body":"import tables\nimport re\nfrom sequtils import foldl\n\nconst romanTable = { \"M\": 1000, \"CM\": 900, \"D\": 500, \"CD\": 400, \"C\": 100, \"XC\": 90, \"L\": 50, \"XL\": 40, \"X\": 10, \"IX\": 9, \"V\": 5, \"IV\": 4, \"I\": 1 }.toTable\n\nproc solution*(roman: string): int =\n  roman.findAll(re\"C?M|C?D|X?C|X?L|I?X|I?V|I\").foldl(a + romanTable[b], 0)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214687,"user_id":null,"body":"proc solution*(r:string):int=\n  var i=0\n  template d(o=0):int =\n    case r[i+o]:\n      of'I':1\n      of'V':5\n      of'X':10\n      of'L':50\n      of'C':100\n      of'D':500\n      of'M':1000\n      else:0\n  while true:\n    if i>r.high:return\n    if i==r.high:return result+d\n    if d<1.d:\n      result+=1.d-d\n      i+=1\n    else:result+=d\n    i+=1\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214688,"user_id":null,"body":"import std\/sequtils\n\nlet value_order = ['M', 'D', 'C', 'L', 'X', 'V', 'I']\n\nproc valueOf(c: char): int =\n  case c:\n    of 'M': result = 1000\n    of 'D': result = 500\n    of 'C': result = 100\n    of 'L': result = 50\n    of 'X': result = 10\n    of 'V': result = 5\n    of 'I': result = 1\n    else:\n      result = 0\n\nproc solution*(roman: string): int =\n  var last = 'z'\n  for c in toSeq(roman.items):\n    result += valueOf(c)\n    if value_order.find(c) < value_order.find(last):\n      result -= valueOf(last)*2\n    last = c\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214689,"user_id":null,"body":"type \n  TokenKind = enum\n    Invalid = 0,\n    I = 1,\n    V = 5,\n    X = 10,\n    L = 50,\n    C = 100,\n    D = 500,\n    M = 1000,\n\n  Parser = object\n    tokens: seq[TokenKind]\n    current: int\n\nproc advance(p: var Parser): TokenKind =\n  p.current += 1\n  return p.tokens[p.current-1]\n\nproc peek(p: var Parser): TokenKind =\n  return p.tokens[p.current]\n\nproc isPrefix(current, next: TokenKind): bool =\n  result = current < next\n\nproc solution*(roman: string): int =\n  var tokens: seq[TokenKind]\n  for c in roman:\n    var t: TokenKind\n    case c\n    of 'M':\n      t = M\n    of 'D':\n      t = D\n    of 'C':\n      t = C\n    of 'L':\n      t = L\n    of 'X':\n      t = X\n    of 'V':\n      t = V\n    of 'I':\n      t = I\n    else:\n      t = Invalid\n    tokens.add(t)\n  \n  var p = Parser(tokens: tokens, current: 0)\n  while p.current < p.tokens.len:\n    var current = p.advance()\n    var next = Invalid\n    if p.current < p.tokens.len:\n      next = p.peek()\n      \n    var val = 0\n    if isPrefix(current, next):\n      val = next.int - current.int\n      discard p.advance()\n    else:\n      val = current.int\n    result += val\n  ","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214690,"user_id":null,"body":"import math\n\nconst NUMERALS = ['I', 'V', 'X', 'L', 'C', 'D', 'M']\n\nproc fromRoman(digit: char): int =\n  assert digit in NUMERALS\n  return (10 ^ (NUMERALS.find(digit) div 2)) * (if NUMERALS.find(digit) mod 2 == 0: 1 else: 5)\n\nproc fromRoman(digits: string): int =\n  ## converts roman digits to integer\n  ## works only if returning number has only one non-zero decimal digit\n  if digits.len == 0: return 0\n  if digits.len == 1: return fromRoman(digits[0])\n  if digits[^1] == digits[0]: return fromRoman(digits[0]) * digits.len\n  return fromRoman(digits[^1]) - fromRoman(digits[0]) * (digits.len - 1)\n\nproc solution*(roman: string): int =\n  let roman = roman\n  var current_decimal_digit = $roman[0]\n  for c in roman[1..^1]:\n    if NUMERALS.find(c) < NUMERALS.find(current_decimal_digit[^1]):\n      result += fromRoman(current_decimal_digit)\n      current_decimal_digit = \"\"\n    current_decimal_digit.add(c)\n  result += fromRoman(current_decimal_digit)\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214691,"user_id":null,"body":"import std\/tables\nimport std\/sequtils\n\nvar r2d=initTable[char,int]()\nr2d['I']=1\nr2d['V']=5\nr2d['X']=10\nr2d['L']=50\nr2d['C']=100\nr2d['D']=500\nr2d['M']=1000\n\n\nproc solution*(roman: string): int =\n  for i in 0..<roman.len:\n    if i<(roman.len-1) and r2d[roman[i]] < r2d[roman[i+1]]: result-=r2d[roman[i]]\n    else: result+=r2d[roman[i]]\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214692,"user_id":null,"body":"import std\/strutils\n\nproc solution*(roman: string): int =\n  let table = {\n               \"M\": 1_000,\n               \"CM\": 900,\n               \"D\": 500,\n               \"CD\": 400,\n               \"C\": 100,\n               \"XC\": 90,\n               \"L\": 50,\n               \"XL\": 40,\n               \"X\": 10,\n               \"IX\": 9,\n               \"V\": 5,\n               \"IV\": 4,\n               \"I\": 1\n               }\n  var roman = roman\n  var res = 0\n  \n  for (s, v) in table:\n    while roman.startsWith(s):\n      res += v\n      roman = roman[s.len..<roman.len]\n  return res","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214693,"user_id":null,"body":"proc solution*(roman: string): int =\n  let ub = len(roman) - 1\n  \n  for i, c in roman:\n    case c:\n      of 'M':\n        result += 1000\n      of 'D':\n        result += 500\n      of 'C':\n        if i<ub and (roman[i+1]=='D' or roman[i+1]=='M'):\n          result -= 100\n        else:\n          result += 100\n      of 'L':\n        result += 50\n      of 'X':\n        if i<ub and (roman[i+1]=='L' or roman[i+1]=='C'):\n          result -= 10\n        else:\n          result += 10\n      of 'V':\n        result += 5\n      of 'I':\n        if i<ub and (roman[i+1]=='V' or roman[i+1]=='X'):\n          result -= 1\n        else:\n          result += 1\n      else:\n        echo \"INFO: Unexpected character: \" & c","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214694,"user_id":null,"body":"proc solution*(roman: string): int =\n  var counter = 0\n  var length = len(roman)\n  result = 0\n  \n  for character in roman:\n    \n    case character:\n      of 'M':\n        result = result + 1000\n        \n      of 'D':\n        if counter >= (length - 1):\n          result = result + 500\n        elif roman[counter+1] == 'M':\n          result = result - 500\n        else:\n          result = result + 500\n        \n      of 'C':\n        if counter >= (length - 1):\n          result = result + 100\n        elif roman[counter+1] == 'D' or roman[counter+1] == 'M':\n          result = result - 100\n        else:\n          result = result + 100\n        \n      of 'L':\n        if counter >= (length - 1):\n          result = result + 50\n        elif roman[counter+1] == 'C' or roman[counter+1] == 'D' or roman[counter+1] == 'M':\n          result = result - 50\n        else:\n          result = result + 50\n        \n      of 'X':\n        if counter >= (length - 1):\n          result = result + 10\n        elif roman[counter+1] == 'L' or roman[counter+1] == 'C' or roman[counter+1] == 'D' or roman[counter+1] == 'M':\n          result = result - 10\n        else:\n          result = result + 10\n      \n      of 'V':\n        if counter >= (length - 1):\n          result = result + 5\n        elif roman[counter+1] == 'X' or roman[counter+1] == 'L' or roman[counter+1] == 'C' or roman[counter+1] == 'D' or roman[counter+1] == 'M':\n          result = result - 5\n        else:\n          result = result + 5\n        \n      of 'I':\n        if counter >= (length - 1):\n          result = result + 1\n        elif roman[counter+1] == 'V' or roman[counter+1] == 'X' or roman[counter+1] == 'L' or roman[counter+1] == 'C' or roman[counter+1] == 'D' or roman[counter+1] == 'M':\n          result = result - 1\n        else:\n          result = result + 1\n    \n      else:\n        discard\n    inc(counter)\n    \n    \n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"51b62bf6a9c58071c600001b":[{"id":214695,"user_id":null,"body":"proc solution*(n: int64): string =\n  let numerals = [(\"M\", 1000), (\"CM\", 900), (\"D\", 500), (\"CD\", 400), (\"C\", 100),\n                  (\"XC\", 90), (\"L\", 50), (\"XL\", 40), (\"X\", 10), (\"IX\", 9),\n                  (\"V\", 5), (\"IV\", 4), (\"I\", 1)]\n  var\n    result = \"\"\n    unconvertedN = n\n  \n  for item in numerals:\n    var (numString, numValue) = item\n    while unconvertedN >= numValue:\n      result.add(numString)\n      unconvertedN = unconvertedN - numValue\n    \n  return result","lang_id":33,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214696,"user_id":null,"body":"import strutils\n\nconst nums = [(1000, \"M\"), (900, \"CM\"), (500, \"D\"), (400, \"CD\"), (100, \"C\"), (90, \"XC\"), (50, \"L\"), (40, \"XL\"), (10, \"X\"), (9, \"IX\"), (5, \"V\"), (4, \"IV\"), (1, \"I\")]\n\nproc solution*(number: int64): string =\n  # convert the number to a roman numeral\n  var num = number\n  result = \"\"\n  for a,r in items(nums):\n    result.add(repeatStr(num div a, r))\n    num = num mod a","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214697,"user_id":null,"body":"import strutils\nimport sequtils\nimport algorithm\nimport math\n\ntype Numeral = tuple[ten: char, five: char, one: char]\n\nconst numerals = @[('X', 'V', 'I'), ('C', 'L', 'X'), ('M', 'D', 'C'), ('?', '?', 'M')]\n\nproc digits(num: int64): seq[int64] =\n    if num == 0: return newSeq[int64](0)\n    return digits(num div 10) & num mod 10\n\nproc place(value: int64, num: Numeral): string =\n    case value:\n        of 0: return \"\"\n        of 1..3: return num.one.repeat(value)\n        of 4..5: return num.one.repeat(5 - value) & num.five\n        of 6..8: return num.five & num.one.repeat(value - 5)\n        of 9: return num.one.repeat(10 - value) & num.ten\n        else: return \"?\"\n\nproc solution*(number: int64): string =\n    proc placeShim(x: tuple[a: int64, b: Numeral]): string = place(x.a, x.b)\n    return digits(number).reversed.zip(numerals).map(placeShim).reversed.join(\"\")\n","lang_id":33,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214698,"user_id":null,"body":"proc solution*(number: int64): string =\n  var \n    n, m, r: int64\n    d, d1, d2, d3: string\n  r = 1\n  n = number\n  result = \"\"\n  while n>0:\n    m = n mod 10\n    case r\n    of 1: d1 = \"I\"; d2 = \"V\"; d3 = \"X\"\n    of 2: d1 = \"X\"; d2 = \"L\"; d3 = \"C\"\n    of 3: d1 = \"C\"; d2 = \"D\"; d3 = \"M\"\n    of 4: d1 = \"M\"; d2 = \"\";  d3 = \"\"\n    else: d1 = \"\";  d2 = \"\";  d3 = \"\"\n    case m\n    of 1: d = d1\n    of 2: d = d1 & d1\n    of 3: d = d1 & d1 & d1\n    of 4: d = d1 & d2\n    of 5: d = d2   \n    of 6: d = d2 & d1\n    of 7: d = d2 & d1 & d1\n    of 8: d = d2 & d1 & d1 & d1\n    of 9: d = d1 & d3\n    else: d = \"\"\n    n = n div 10\n    result = d & result\n    r += 1","lang_id":33,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214699,"user_id":76,"body":"let roman: auto = [(\"M\", 1000), (\"CM\", 900), (\"D\", 500), (\"CD\", 400), (\"C\", 100), (\"XC\", 90), (\"L\", 50), (\"XL\", 40), (\"X\", 10), (\"IX\", 9), (\"V\", 5), (\"IV\", 4), (\"I\", 1)]\n\nproc solution*(number: int64): string =\n  var num = number\n  for (s, n) in roman:\n    while num >= n:\n      num -= n\n      result &= s","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214700,"user_id":null,"body":"import tables\n\nproc solution*(number: int64): string =\n  const roman = {\n    1    : 'I',\n    5    : 'V',\n    10   : 'X',\n    50   : 'L',\n    100  : 'C',\n    500  : 'D',\n    1000 : 'M'\n  }.toTable\n  var\n    k = 1\n    n = number\n    m: int64\n    s: string\n  while n > 0:\n    m = n mod 10\n    case m:\n    of 1 .. 3:\n      for _ in 1 .. m:\n        s.add roman[k]\n    of 4:\n      s.add roman[k] & roman[5 * k]\n    of 5:\n      s.add roman[5 * k]\n    of 6 .. 8:\n      s.add roman[5 * k]\n      for _ in 6 .. m:\n        s.add roman[k]\n    of 9:\n      s.add roman[k] & roman[10 * k]\n    else:\n      discard\n    result = s & result\n    n = n div 10\n    k *= 10\n    s = \"\"","lang_id":33,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214701,"user_id":null,"body":"proc solution*(n: int64): string =\n  # convert the number to a roman numeral\n  var roman: string = \"\"\n  var j: int64 = n\n  \n  while j > 0: \n  \n    if (j - 1000) >= 0:\n      j += -1000\n      roman.add(\"M\")\n    elif (j - 900) >= 0:\n      j += -900\n      roman.add(\"CM\")\n    elif (j - 500) >= 0:\n      j += -500\n      roman.add(\"D\")\n    elif (j - 400) >= 0:\n      j += -400\n      roman.add(\"CD\")\n    elif (j - 100) >= 0:\n      j += -100\n      roman.add(\"C\")\n    elif (j - 90) >= 0:\n      j += -90\n      roman.add(\"XC\")\n    elif (j - 50) >= 0:\n      j += -50\n      roman.add(\"L\")\n    elif (j - 40) >= 0:\n      j += -40\n      roman.add(\"XL\")\n    elif (j - 10) >= 0:\n      j += -10\n      roman.add(\"X\")\n    elif (j - 9) >= 0:\n      j += -9\n      roman.add(\"IX\")\n    elif (j - 5) >= 0:\n      j += -5\n      roman.add(\"V\")\n    elif (j - 4) >= 0:\n      j += -4\n      roman.add(\"IV\")\n    elif (j - 1) >= 0:\n      j += -1\n      roman.add(\"I\")\n  return roman\n#  echo \"\\\"\",roman,\"\\\"\"","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214702,"user_id":111,"body":"const table = [((\"M\",1000),(\"CM\",900)) , ((\"D\",500),(\"CD\",400)),\n        ((\"C\",100) ,(\"XC\",90))  , ((\"L\",50) ,(\"XL\",40)),\n        ((\"X\",10)  ,(\"IX\", 9))  , ((\"V\",5)  ,(\"IV\",4))]\n\nproc repeat(expr:string,n:int64): string =\n  if n>0: return expr & repeat(expr,n-1)\n\nproc solution*(number: int64): string =\n  var n:int64 = number\n  for i in 0..5:\n    result &= repeat(table[i][0][0],(n div table[i][0][1]))\n    n = n mod table[i][0][1]\n    if n >= table[i][1][1]:\n      result &= table[i][1][0]\n      n -= table[i][1][1]\n  return result & repeat(\"I\",n)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214703,"user_id":53,"body":"import strutils\n\nconst convMap = [(1000, \"M\"), (900, \"CM\"), (500, \"D\"), (400, \"CD\"), (100, \"C\"), (90, \"XC\"), (50, \"L\"), (40, \"XL\"), (10, \"X\"), (9, \"IX\"), (5, \"V\"), (4, \"IV\"), (1, \"I\")]\n\nproc solution*(number: int64): string =\n  var n = number\n  var ans = \"\"\n  for key, val in items(convMap):\n    var i = 0\n    while i < n div key:\n      ans.add(val)\n      i += 1\n    n = n mod key\n  result = ans","lang_id":33,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214704,"user_id":null,"body":"let romanPairs = [(1000, 'M'), (500, 'D'), (100, 'C'), (50, 'L'), (10, 'X'), (5, 'V'), (1, 'I')]\n\nproc solution*(number: int64): string =\n  \n    result = \"\"\n    var num = number\n    var ind = 0\n\n    while num > 0:\n        \n        let (tenval, tenletter) = romanPairs[ind]\n        let (fiveval, fiveletter) = romanPairs[ind+1]\n        let (oneval, oneletter) = romanPairs[ind+2]\n        \n        if num >= tenval:\n            num -= tenval\n            result &= tenletter\n            continue\n\n        elif num >= tenval - oneval:\n            num -= tenval - oneval\n            result &= oneletter & tenletter\n\n        elif num >= fiveval:\n            num -= fiveval\n            result &= fiveletter\n            continue\n        \n        elif num >= fiveval - oneval:\n            num -= fiveval - oneval\n            result &= oneletter & fiveletter\n\n        elif num >= oneval:\n            while num >= oneval:\n                num -= oneval\n                result &= oneletter\n\n        inc ind, 2\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"523f5d21c841566fde000009":[{"id":214705,"user_id":527,"body":"from sequtils import filterIt\n\nproc array_difference*(a: seq[int], b: seq[int]): seq[int] =\n  a.filterIt(it notin b)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214706,"user_id":null,"body":"proc array_difference*(a: seq[int], b: seq[int]): seq[int] =\n  for elem in a:\n    if not b.contains(elem):\n      result.add(elem)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214707,"user_id":null,"body":"import std\/sets\nimport sequtils\n\nproc array_difference*(a: seq[int], b: seq[int]): seq[int] =\n  let bSet = b.toHashSet\n  result = a.filterIt(not bSet.contains(it)).toSeq\n  ","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214708,"user_id":null,"body":"proc array_difference*(a: seq[int], b: seq[int]): seq[int] =\n  var filter = newSeq[bool](a.len)\n  for search in b:\n    for i in 0..a.high:\n      if a[i] == search:\n        filter[i] = true\n  \n  for i in 0..a.high:\n    if not filter[i]:\n      result.add(a[i])","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214709,"user_id":null,"body":"import std\/sets\n\nproc array_difference*(a: seq[int], b: seq[int]): seq[int] =\n  let bset = b.toHashSet\n  var res: seq[int] = @[]\n  for i in a:\n    if i notin bset:\n      res.add(i)\n  return res","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214710,"user_id":null,"body":"import std\/sequtils\n\nproc array_difference*(a: seq[int], b: seq[int]): seq[int] =\n  a.filter(proc(x: int): bool = x notin b)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214711,"user_id":null,"body":"proc array_difference*(a: seq[int], b: seq[int]): seq[int] =\n  var result: seq[int]\n  for _, item in a:\n    if item in b:\n      continue\n    else:\n      result.add(item)\n  return result","lang_id":33,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214712,"user_id":null,"body":"import std\/sequtils\n\nproc array_difference*(a: seq[int], b: seq[int]): seq[int] =\n  return a.filterIt(it notin b)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214713,"user_id":null,"body":"proc array_difference*(a: seq[int], b: seq[int]): seq[int] =\n  result = @[]\n  for i in a:\n    if not (i in b):\n      result.add(i)\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214714,"user_id":null,"body":"import sequtils\n\nproc array_difference*(a: seq[int], b: seq[int]): seq[int] =\n  a.filterIt(it notin b)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"525c1a07bb6dda6944000031":[{"id":214715,"user_id":53,"body":"import sequtils\n\nvar websites*: seq[string] = repeat(\"codewars\", 1000)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214716,"user_id":527,"body":"import sequtils\n\nlet websites* = repeat(\"codewars\", 1000)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214717,"user_id":null,"body":"var websites*: seq[string]\nfor i in 1..1000:\n  websites &= \"codewars\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214718,"user_id":76,"body":"from std\/sequtils import repeat\nlet websites* = repeat(\"codewars\", 1000)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214719,"user_id":null,"body":"import sequtils\n\nvar websites*: seq[string]\nwebsites = \"codewars\".repeat(1000)\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214720,"user_id":null,"body":"import std\/sequtils\nvar websites*: seq[string] = newSeqWith(1000, \"codewars\")\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214721,"user_id":null,"body":"import sequtils\n\nvar websites* = repeat(\"codewars\", 1000)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214722,"user_id":null,"body":"var websites*: seq[string]\n\nfor i in 1..1000:\n  websites.add(\"codewars\")","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214723,"user_id":null,"body":"var websites*: seq[string]\n\nfor i in 0..<1000:\n  websites.add \"codewars\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214724,"user_id":null,"body":"var websites*: seq[string]\nvar count = 1000\nwhile count > 0:\n  websites.add(\"codewars\")\n  count = count - 1","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5287e858c6b5a9678200083c":[{"id":214725,"user_id":76,"body":"import math\n\nproc narcissistic*(value: int64): bool =\n  var n = value\n  var p = ($value).len\n  var s = 0\n  while n > 0:\n    s += (n mod 10) ^ p\n    n = n div 10\n  s == value","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214726,"user_id":null,"body":"import parseutils, math\nproc narcissistic*(value: int64): bool =\n    var nums: seq[int]; var tmp: int; var numL: int; for n in $value: discard parseInt($n, tmp, 0); nums.add(tmp); numL.inc(1)\n    var calc: int; for n in nums: calc.inc(n^numL)\n    if calc == value: return true\n    else: return false","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214727,"user_id":null,"body":"import math, sequtils, strutils\nproc narcissistic*(value: int64): bool =\n  value ==\n    ($value).mapIt(parseInt($it)) # map value to seq of its digits\n    .foldl(a + b^(len $value), 0) # sum pow(digit, value's length in digits)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214728,"user_id":null,"body":"import sequtils,math\nproc narcissistic*(v=0):bool=v==mapIt($v,it.int-48).foldl(a+b^(len $v),0)\n","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214729,"user_id":null,"body":"import std\/math\nproc digits(n:int): int =\n  var num=n\n  while num>0:\n    result+=1\n    num=num div 10\nproc narcissistic*(value: int64): bool =\n  #code away\n  var num=0\n  let d=value.digits\n  var og=value\n  while og>0:\n    num+=(og mod 10)^d\n    og=og div 10\n  num==value","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214730,"user_id":111,"body":"import math #Just to use the \"power\" operator...\nproc narcissistic*(n:int):bool=\n  var\n    digits:seq[int]\n    res = n\n  while res != 0:\n    digits.add(res mod 10)\n    res = res div 10\n  for i in digits:\n    res += i^digits.len\n  res == n","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214731,"user_id":null,"body":"import sequtils, math\n\nproc narcissistic*(value: int64): bool =\n  var digits: seq[int]\n  \n  var tmp = value\n  while tmp > 0:\n    digits.add(tmp mod 10)\n    tmp = tmp div 10\n  \n  return value == digits.map(proc(d: int): int = d^digits.len).foldl(a + b)","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214732,"user_id":null,"body":"import math, sugar, sequtils\n\nproc narcissistic*(value: int64): bool =\n  value == foldl(map($value, d => (int(d) - 48)^len($value)), a + b)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214733,"user_id":null,"body":"import strutils\nimport math\n\nproc narcissistic*(n: int): bool =\n  var \n    t = $n\n    a = 0\n  \n  for d in 0 .. (t.len - 1):\n    var \n      val1 = parseInt($t[d])\n      val2 = val1^t.len\n    inc(a, val2)\n  \n  if a == n: return true","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214734,"user_id":null,"body":"import sequtils, strutils, math, parseutils\n\nfunc toDigitsSeq(n: int): seq[int] =\n  return n.intToStr.toSeq.mapIt(parseInt($it))\n\nfunc narcissistic*(value: int): bool =\n  let splitted = value.toDigitsSeq\n  let summed = splitted.mapIt(it ^ splitted.len).sum\n  return summed == value","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"53da3dbb4a5168369a0000fe":[{"id":214735,"user_id":null,"body":"proc even_or_odd*(n: int): string =\n  if n %% 2 == 0: \"Even\" else: \"Odd\"","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214736,"user_id":null,"body":"proc even_or_odd*(n: int): string =\n  if n mod 2 == 0:\n    result = \"Even\"\n  else:\n    result = \"Odd\"","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214737,"user_id":527,"body":"proc even_or_odd*(n: int): string =\n  case n mod 2\n    of 0: \"Even\"\n    else: \"Odd\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214738,"user_id":527,"body":"proc even_or_odd*(n: int): string =\n  [\"Even\", \"Odd\"][n and 1]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214739,"user_id":null,"body":"proc even_or_odd*(n: int): string =\n  [\"Even\", \"Odd\"][n.abs mod 2]\n  ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214740,"user_id":null,"body":"import std\/bitops\nproc even_or_odd*(n: int): string =\n  if n.testBit(0): \"Odd\" else: \"Even\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214741,"user_id":null,"body":"proc even_or_odd*(n: int): string =\n  case n and 1:\n    of 1: \"Odd\"\n    else: \"Even\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214742,"user_id":null,"body":"proc even_or_odd*(n: int): string =\n  result = \"Odd\"\n  if n mod 2 == 0:\n    result = \"Even\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214743,"user_id":null,"body":"proc even_or_odd*(n: int): string =\n  if n %% 2 == 0:\n    result = \"Even\"\n  else:\n    result = \"Odd\"\n  discard","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214744,"user_id":null,"body":"proc even_or_odd*(n: int): string =\n  result = if (n and 1) == 1: \"Odd\" else: \"Even\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"541c8630095125aba6000c00":[{"id":214745,"user_id":50,"body":"proc digital_root*(n: int64): int64 =\n  if n==0:\n    return 0\n  else:\n    return ((n-1) mod 9) + 1","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214746,"user_id":527,"body":"proc digital_root*(n: int64): int64 =\n  (n - 1) mod 9 + 1","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214747,"user_id":null,"body":"proc digital_root*(n: int64): int64 = (n - 1) mod 9 + 1","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214748,"user_id":null,"body":"import sequtils\n\nproc digits(number: int): seq[int] = \n  var n = number\n  while n > 0:\n    result.add(n mod 10)\n    n = n div 10\n  return if result.len() > 1: result.foldl(a + b).digits() else: result\n\nproc digital_root*(n: int64): int64 = n.digits().foldl(a + b, 0)      ","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214749,"user_id":null,"body":"from strutils import parseInt\nproc digital_root*(n: int64): int64 =\n  for i in $n:\n    result += parseInt($i)\n  if result > 9:\n    result = digital_root(result)\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214750,"user_id":76,"body":"proc digital_root*(n: int64): int64 =\n  var m = n\n  var sum = 0\n  while m > 0:\n    sum += m mod 10\n    m = m div 10\n  return if sum < 10: sum else: digital_root(sum)","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214751,"user_id":null,"body":"import sequtils, math, strutils\n\nproc digital_root*(n: int64): int64 =\n  if n < 10:\n    n\n  else:\n    digital_root(($n).mapIt(($it).parseInt).sum)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214752,"user_id":null,"body":"proc digital_root*(n: int64): int64 =\n  if n < 10:\n    return n\n  else:\n    let digitChars = @($n)\n    for it in digitChars:\n      let digit = it.ord - '0'.ord\n      result += digit\n  result = digital_root(result)\n  ","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214753,"user_id":null,"body":"proc digital_root*(n: int64): int64 =\n    var x = n\n    while x > 9:\n      var a = 0\n      while x > 0:\n        a += x mod 10\n        x = x div 10\n      x = a\n    return x","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214754,"user_id":null,"body":"import std\/strutils\n\nproc digital_root*(n: int64): int64 =\n  result = n\n\n  while result > 9:\n    var new = 0\n    for num in $result:\n      new.inc ($num).parseInt\n\n    result = new","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5436f26c4e3d6c40e5000282":[{"id":214755,"user_id":null,"body":"import math\n\nproc sum_of_n*(n: int): seq[int] =\n  var sum = 0\n  for i in 0..n.abs():\n    sum += i\n    result.add(sum * sgn(n))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214756,"user_id":null,"body":"proc sum_of_n*(n: int): seq[int] =\n  for i in 0..abs(n):\n    var count = 0\n    for j in 0..i:\n      count += j\n    if n<0:\n      result.add(-count)\n    else:\n      result.add(count)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214757,"user_id":527,"body":"import math\nimport sequtils\n\nproc sum_of_n*(n: int): seq[int] =\n  (0 .. n.abs()).mapIt(n.sgn() * (it ^ 2 + it) div 2)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214758,"user_id":null,"body":"import sequtils, math\nfunc sum_of_n*(n: int): seq[int] =\n  toSeq(0..n.abs).mapIt(n.sgn * it * (it + 1) div 2)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214759,"user_id":null,"body":"proc sum_of_n*(n: int): seq[int] =\n  var s: int\n  result.add s\n  if n<0:\n    for i in 1 .. -n:\n      s -= i\n      result.add s\n  if n>0:\n    for i in 1 .. n:\n      s += i\n      result.add s","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214760,"user_id":null,"body":"proc sum_of_n*(n: int): seq[int] =\n  result.add 0; for a in 1 .. abs n: result.add result[^1]+a*(if n<0: -1 else:1)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214761,"user_id":76,"body":"from sequtils import mapIt\n\nproc sum_of_n*(n: int): seq[int] =\n  (0 .. n.abs).mapIt(it * succ(it) div 2 * (if n < 0: -1 else: 1))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214762,"user_id":null,"body":"proc sum_of_n*(n: int): seq[int] =\n  let s = if n > 0: 1 else: -1\n  var t = 0\n  for i in (0 .. n * s):\n    t += i\n    result.add t * s\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214763,"user_id":null,"body":"proc sum_of_n*(n: int): seq[int] =\n  var sum = @[0]\n  if n < 0:\n    for i in 1 .. -n:\n      sum.add(sum[i-1]-i)\n  else:\n    for i in 1 .. n:\n      sum.add(sum[i-1]+i)\n    \n  return sum","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214764,"user_id":null,"body":"import math\nimport sequtils\n\nproc sum_of_n*(n: int): seq[int] =\n  var sum = 0\n  for i in 0..abs(n):\n    sum = sum + i\n    result.add(sum)\n  \n  if n < 0:\n    result = result.mapIt(it * -1)\n    ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"54b42f9314d9229fd6000d9c":[{"id":214765,"user_id":null,"body":"import tables\nimport unicode\n\nproc duplicate_encode*(word: string): string =\n  result = toLower(word)\n  let t = toCountTable(result)\n  for i, c in result:\n    result[i] = if t[c] > 1: ')' else: '('\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214766,"user_id":null,"body":"import std\/strutils\nproc duplicate_encode*(word: string): string =\n  let lowerWord : string = word.toLowerAscii()\n  for c in lowerWord:\n    if lowerWord.count(c) < 2:\n      result.add('(')\n    else:\n      result.add(')')","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214767,"user_id":null,"body":"import std\/tables\nimport std\/strutils\n\nproc duplicate_encode*(word: string): string =\n  var count = initTable[char, int]()\n  \n  for c in word:\n    let x = if c.is_upper_ascii: c.to_lower_ascii else: c\n    if x in count:\n      count[x] += 1\n    else:\n      count[x] = 1\n      \n  for c in word:\n    let x = if c.is_upper_ascii: c.to_lower_ascii else: c\n    if count[x] > 1:\n      result.add(\")\")\n    else:\n      result.add(\"(\")\n\n\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214768,"user_id":null,"body":"import strutils, unicode\n\nproc duplicate_encode*(word: string): string =\n    for c in word:\n        result.add(if toLower(word).count(toLower($c)) == 1: \"(\" else: \")\")","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214769,"user_id":759,"body":"import strutils\n\nproc duplicate_encode*(word: string): string =\n  result = newStringOfCap(word.len)\n  var word = word.toLowerAscii()\n  for x in word:\n    result.add(if word.count(x) > 1: ')' else: '(')","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214770,"user_id":76,"body":"import sequtils, strutils\n\nproc duplicate_encode*(word: string): string =\n  word.mapIt(if word.toLowerAscii.count(it.toLowerAscii) > 1 : \")\" else: \"(\").join","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214771,"user_id":null,"body":"import std\/tables\nimport unicode\n\n\nproc duplicate_encode*(word: string): string =\n    result = word.toLower\n    let counter = toCountTable(result)\n    for i, c in result:\n        result[i] = if counter[c] == 1: '(' else: ')'","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214772,"user_id":null,"body":"import std\/tables\nimport strutils\n\nproc duplicate_encode*(word: string): string =\n  let counter = toCountTable(word.toLowerAscii)\n  for c in word.toLowerAscii:\n      case counter[c]\n      of 1:\n        result.add('(')\n      else:\n        result.add(')')","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214773,"user_id":null,"body":"import strutils\nproc duplicate_encode*(word: string): string =\n  var repeatlist = \"\"\n  var final = \"\"\n  var found = false\n  let lword = word.toLowerAscii()\n  for h,i in lword:\n    for j in repeatlist:\n      if i == j:\n        found = true\n        break\n    if not found:\n      for k,j in lword:\n        if i == j and h != k:\n          repeatlist = repeatlist & i\n          found = true\n          break\n    if found:\n      final = final & \")\"\n    else:\n      final = final & \"(\"\n    found = false\n  return final","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214774,"user_id":null,"body":"import std\/tables\nimport std\/sequtils\nimport std\/strutils\nimport sugar\n\nproc duplicate_encode*(word: string): string =\n  let word = word.toLowerAscii()\n  let occurrences = toCountTable(word)\n  return word.map(c => (if occurrences[c] > 1: \")\" else: \"(\")).join()\n  ","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"54d512e62a5e54c96200019e":[{"id":214775,"user_id":53,"body":"from strutils import join\nimport strformat\n\nproc prime_factors*(l: int): string =\n    var fs: seq[string] = @[]\n    var i = 2\n    var n = l\n    while i <= n:\n        var cnt = 0\n        while n %% i == 0:\n            n = n div i\n            cnt += 1\n        if cnt == 1:\n            fs.add(&\"({i})\")\n        elif cnt > 1:\n            fs.add(&\"({i}**{cnt})\")\n        i += 1\n    if (len fs) == 0:\n        return &\"({n})\"\n    else:\n        return fs.join","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214776,"user_id":492,"body":"import strutils\n\nproc prime_factors*(n: int): string =\n    var res = \"\"; var fac = 2; var m = n\n    while fac <= m:\n        var count = 0\n        while m %% fac == 0:\n            count += 1\n            m = m div fac\n        if count > 0:\n            res &= \"(\" & intToStr(fac)\n            if count > 1:\n                res &=  \"**\"  & intToStr(count)\n            res &= \")\"\n        fac += 1\n    return res","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214777,"user_id":492,"body":"import strutils\n\nproc prime_factors*(n: int): string =\n    var res = \"\"; var fac = 2; var m = n\n    while fac <= m:\n        var count = 0\n        while m %% fac == 0:\n            count += 1\n            m = m div fac\n        if count > 0:\n            res &= \"(\" & intToStr(fac)\n            if count > 1:\n                res &=  \"**\"  & intToStr(count)\n            res &= \")\"\n        fac += 1\n    return res","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214778,"user_id":76,"body":"proc prime_factors*(n: int): string =\n  var m = n\n  var d = 2\n  while d <= m:\n    var count = 0\n    while m mod d == 0:\n      inc count\n      m = m div d\n    if count > 0:\n      result &= \"(\" & $d & (if count > 1: \"**\" & $count else: \"\") & \")\"\n    inc d","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214779,"user_id":null,"body":"proc isPrime(n: int): bool =\n  if n == 2:\n    return true\n  \n  if n mod 2 == 0:\n    return false\n  \n  for i in countup(3, n-1, 2):\n    if n mod i == 0:\n      return false\n  \n  return true\n\nproc prime_factors*(n: int): string =\n  var curr = n\n  var factors: seq[int] = @[];\n  var powers: seq[int] = @[];\n\n  for i in 2..n:\n    if curr mod i == 0 and isPrime(i):\n      factors.add(i)\n      powers.add(0)\n      while curr mod i == 0:\n        curr = curr div i\n        powers[high(powers)] += 1\n      \n      if curr == 1:\n        break\n  \n  result = \"\"\n  for i in 0..high(powers):\n    if powers[i] == 1:\n      result = result & \"(\" & $(factors[i]) & \")\"\n    else:\n      result = result & \"(\" & $(factors[i]) & \"**\" & $(powers[i]) & \")\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214780,"user_id":null,"body":"import sequtils, strformat, math\n\nproc prime_factors*(n: int): string =\n  var remainingN = n\n  var results = \"\"\n  for b in concat(@[2],toSeq(countup(3, int(sqrt(float(n)))+2, 2))):\n    if float(b) > sqrt(float(remainingN)):\n      if remainingN > 1:\n        results.add(&\"({remainingN})\")\n      break\n    \n    if remainingN mod b != 0:\n      continue\n    \n    var e = 0\n    while remainingN mod b == 0:\n      e += 1\n      remainingN = remainingN div b\n    \n    if e == 1:\n      results.add(&\"({b})\")\n    else:\n      results.add(&\"({b}**{e})\")\n  return results\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214781,"user_id":null,"body":"import strformat\nproc prime_factors*(n: int): string =\n    var num = n\n    var answr = \"\"\n    var factors : seq[seq[int]] = @[]\n    var factor = 2\n    var fact_n = -1\n    while num > 1:\n      if num mod factor == 0:\n        factors.add(@[factor, 0])\n        fact_n += 1\n      while num mod factor == 0:\n        num = num div factor\n        factors[fact_n][1] += 1\n      factor += 1\n    for j in factors:\n      if j[1] != 1:\n        answr.add(fmt\"({j[0]}**{j[1]})\")\n      else:\n        answr.add(fmt\"({j[0]})\")\n    return answr","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214782,"user_id":null,"body":"from bitops import popCount\n\ntype # this type is used by the prime generator!\n  LazyList[T] = ref object # memoizing lazy list...\n    head: T\n    tailf: proc (): LazyList[T] # expensive calculation only done once!\n    tail: LazyList[T]\nproc rest[T](ll: LazyList[T]): LazyList[T] =\n  if ll.tailf != nil: ll.tail = ll.tailf(); ll.tailf = nil\n  return ll.tail\niterator items[T](ll: LazyList[T]): T =\n  var lzylst = ll\n  while true: yield lzylst.head; lzylst = lzylst.rest\n\nconst BITMASK = [1'u8, 2, 4, 8, 16, 32, 64, 128] # more efficient than shift ops!\n\n# quite efficient page Segmented Sieve of Eratosthenes primes generator...\nproc primes(): iterator(): uint32 =\n  proc cull(lwi: int; bparrs: LazyList[seq[uint32]]; sb: var seq[uint8]) =\n    let szbits = sb.len shl 3; let nxti = lwi + szbits\n    for bppg in bparrs:\n      for bp in bppg:\n        let i = (bp - 3'u32).int shr 1; var s = (i shl 1) * (i + 3) + 3\n        if s >= nxti: return\n        if s >= lwi: s -= lwi\n        else:\n          let r = (lwi - s).int64 mod bp.int64\n          s = (if r == 0'i64: 0 else: (bp.int64 - r).int)\n        let lmt = szbits - (bp.int shl 3)\n        if s < lmt:\n          let slmt = min(szbits, s + (bp shl 3).int)\n          while s < slmt:\n            let msk = BITMASK[s and 7]\n            for c in countup(s shr 3, sb.len - 1, bp.int): sb[c] = sb[c] or msk\n            s += bp.int\n        else:\n          while s < szbits:\n            let w = s shr 3; sb[w] = sb[w] or BITMASK[s and 7]; s += bp.int\n  proc count(sb: seq[uint8]): int =\n    let sba = cast[int](sb[0].unsafeAddr); result = sb.len shl 3\n    for ca in countup(sba, sba + sb.len - 1, 8):\n      result -= cast[ptr uint64](ca)[].popCount # count zero bits!\n  proc cmpsts2prmsarr(lwi: int; sb: seq[uint8]): seq[uint32] =\n    result = newSeq[uint32](count(sb)); var j = 0\n    for i in 0 ..< sb.len shl 3:\n      if (sb[i shr 3] and BITMASK[i and 7]) == 0'u8:\n        result[j] = ((lwi + i).uint32 shl 1) + 3'u32; j.inc\n  proc makepgstrm(lwi: int; sz: int; bps: LazyList[seq[uint32]]): iterator(): seq[uint32] =\n    var cmpsts = newSeq[uint8](sz)\n    let szbits = sz shl 3; var lowi = lwi\n    return iterator(): seq[uint32] =\n      while true:\n        zeroMem(cmpsts[0].addr, sz); cull(lowi, bps, cmpsts)\n        yield cmpsts2prmsarr(lowi, cmpsts); lowi += szbits\n  proc makebps(): LazyList[seq[uint32]] =\n    var frstcmpsts = newSeq[uint8](32)\n    let frstbps = LazyList[seq[uint32]](head: cmpsts2prmsarr(0, frstcmpsts),\n                                        tailf: proc (): LazyList[seq[uint32]] {.closure.} = nil)\n    cull(0, frstbps, frstcmpsts); var nxtbprms: iterator(): seq[uint32]\n    proc nxtbparr(): LazyList[seq[uint32]] =\n      LazyList[seq[uint32]](head: nxtbprms(), tailf: proc (): auto = nxtbparr())\n    LazyList[seq[uint32]](head: cmpsts2prmsarr(0, frstcmpsts),\n                          tailf: proc (): auto = # break race by deferring!\n                            nxtbprms = makepgstrm(256, 32, makebps()); nxtbparr())\n  return iterator(): uint32 =\n    yield 2\n    let pgstrm = makepgstrm(0, 16384, makebps())\n    while true:\n      let pg = pgstrm(); for p in pg: yield p\n\n# by using an efficient prime generator at only tens of CPU clock cycles per prime,\n# we avoid all the extra expensive divisions by values that will always fail at\n# something approaching a hundred clock cycles per division - this is worse when\n# test division by all numbers is used rather than odds only, but even then, only\n# about a tenth of the odd numbers are prime!\nproc prime_factors*(n: int): string =\n    result = \"\"; let prms = primes(); discard prms() # skip 2 to get to 3!\n    var fctrd = n; var cnt = 0\n    while (fctrd and 1) == 0: fctrd = fctrd shr 1; cnt.inc # factoring by 2 is trivial!\n    if cnt > 0:\n      result &= \"(2\"\n      if cnt > 1: result &= \"**\" & $cnt & \")\" else: result &= \")\"\n    var p = prms().int; cnt = 0\n    proc addrslt(v: int): string =\n      result = \"\"\n      if v > 1: \n        result &= \"(\" & $v\n        if cnt > 1: result &= \"**\" & $cnt & \")\" else: result &= \")\" \n    while true:\n      let qtnt = fctrd div p; let rmdr = fctrd - qtnt * p\n      if rmdr != 0:\n        if cnt > 0: result &= p.addrslt; cnt = 0\n        # if p is larger than the sqrt of the remaining factor!\n        if p > qtnt: result &= fctrd.addrslt; return\n        p = prms().int\n      else: fctrd = qtnt; cnt.inc","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214783,"user_id":null,"body":"from bitops import popCount\nfrom math import sqrt\n\ntype # this type is used by the prime generator!\n  LazyList[T] = ref object # memoizing lazy list...\n    head: T\n    tailf: proc (): LazyList[T] # expensive calculation only done once!\n    tail: LazyList[T]\nproc rest[T](ll: LazyList[T]): LazyList[T] =\n  if ll.tailf != nil: ll.tail = ll.tailf(); ll.tailf = nil\n  return ll.tail\niterator items[T](ll: LazyList[T]): T =\n  var lzylst = ll\n  while true: yield lzylst.head; lzylst = lzylst.rest\n\nconst BITMASK = [1'u8, 2, 4, 8, 16, 32, 64, 128] # more efficient than shift ops!\n\n# quite efficient page Segmented Sieve of Eratosthenes primes generator...\nproc primes(): iterator(): uint32 =\n  proc cull(lwi: int; bparrs: LazyList[seq[uint32]]; sb: var seq[uint8]) =\n    let szbits = sb.len shl 3; let nxti = lwi + szbits\n    for bppg in bparrs:\n      for bp in bppg:\n        let i = (bp - 3'u32).int shr 1; var s = (i shl 1) * (i + 3) + 3\n        if s >= nxti: return\n        if s >= lwi: s -= lwi\n        else:\n          let r = (lwi - s).int64 mod bp.int64\n          s = (if r == 0'i64: 0 else: (bp.int64 - r).int)\n        let lmt = szbits - (bp.int shl 3)\n        if s < lmt:\n          let slmt = min(szbits, s + (bp shl 3).int)\n          while s < slmt:\n            let msk = BITMASK[s and 7]\n            for c in countup(s shr 3, sb.len - 1, bp.int): sb[c] = sb[c] or msk\n            s += bp.int\n        else:\n          while s < szbits:\n            let w = s shr 3; sb[w] = sb[w] or BITMASK[s and 7]; s += bp.int\n  proc count(sb: seq[uint8]): int =\n    let sba = cast[int](sb[0].unsafeAddr); result = sb.len shl 3\n    for ca in countup(sba, sba + sb.len - 1, 8):\n      result -= cast[ptr uint64](ca)[].popCount # count zero bits!\n  proc cmpsts2prmsarr(lwi: int; sb: seq[uint8]): seq[uint32] =\n    result = newSeq[uint32](count(sb)); var j = 0\n    for i in 0 ..< sb.len shl 3:\n      if (sb[i shr 3] and BITMASK[i and 7]) == 0'u8:\n        result[j] = ((lwi + i).uint32 shl 1) + 3'u32; j.inc\n  proc makepgstrm(lwi: int; sz: int; bps: LazyList[seq[uint32]]): iterator(): seq[uint32] =\n    var cmpsts = newSeq[uint8](sz)\n    let szbits = sz shl 3; var lowi = lwi\n    return iterator(): seq[uint32] =\n      while true:\n        zeroMem(cmpsts[0].addr, sz); cull(lowi, bps, cmpsts)\n        yield cmpsts2prmsarr(lowi, cmpsts); lowi += szbits\n  proc makebps(): LazyList[seq[uint32]] =\n    var frstcmpsts = newSeq[uint8](32)\n    let frstbps = LazyList[seq[uint32]](head: cmpsts2prmsarr(0, frstcmpsts),\n                                        tailf: proc (): LazyList[seq[uint32]] {.closure.} = nil)\n    cull(0, frstbps, frstcmpsts); var nxtbprms: iterator(): seq[uint32]\n    proc nxtbparr(): LazyList[seq[uint32]] =\n      LazyList[seq[uint32]](head: nxtbprms(), tailf: proc (): auto = nxtbparr())\n    LazyList[seq[uint32]](head: cmpsts2prmsarr(0, frstcmpsts),\n                          tailf: proc (): auto = # break race by deferring!\n                            nxtbprms = makepgstrm(256, 32, makebps()); nxtbparr())\n  return iterator(): uint32 =\n    yield 2\n    let pgstrm = makepgstrm(0, 16384, makebps())\n    while true:\n      let pg = pgstrm(); for p in pg: yield p\n\n# by using an efficient prime generator at only tens of CPU clock cycles per prime,\n# we avoid all the extra expensive divisions by values that will always fail at\n# something approaching a hundred clock cycles per division - this is worse when\n# test division by all numbers is used rather than odds only, but even then, only\n# about a tenth of the odd numbers are prime!\nproc prime_factors*(n: int): string =\n    result = \"\"; let prms = primes(); discard prms() # skip 2 to get to 3!\n    let lmt = n.float64.sqrt.int # factor up to square root: n might be near prime!\n    var fctrd = n; var cnt = 0\n    while (fctrd and 1) == 0: fctrd = fctrd shr 1; cnt.inc # factoring by 2 is trivial!\n    if cnt > 0:\n      result &= \"(2\"\n      if cnt > 1: result &= \"**\" & $cnt & \")\" else: result &= \")\"\n    var p = prms().int; cnt = 0\n    proc addrslt(v: int): string =\n      result = \"\"\n      if v > 1: \n        result &= \"(\" & $v\n        if cnt > 1: result &= \"**\" & $cnt & \")\" else: result &= \")\" \n    while true:\n      if p > lmt:\n        result &= fctrd.addrslt; return\n      let qtnt = fctrd div p; let rmdr = fctrd - qtnt * p\n      if rmdr != 0:\n        if cnt > 0: result &= p.addrslt\n        p = prms().int; cnt = 0\n        if p > fctrd:\n          result &= fctrd.addrslt; return\n      else: fctrd = qtnt; cnt.inc","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214784,"user_id":null,"body":"import tables # hash tables\nfrom math import sqrt\n\n# a good prime sequence generator;\n# much more efficient than a trial division primality test for large ranges...\nproc primes(): iterator(): int =\n  return iterator(): int =\n    yield 2; yield 3 # first concrete values to break race!\n    let bps = primes(); # recursive feed of base primes!\n    var n = 5; var q = 9; discard bps(); var bp = bps() # starts at 3!\n    var cmpsts = initTable[int, int]() # contains composites and delta to next!\n    while true:\n      if n >= q: # hit base prime limit; add new base prime progression to composites!\n        let dlta = bp + bp; cmpsts[q + dlta] = dlta; bp = bps(); q = bp * bp\n      else:\n        if n in cmpsts:\n          var dlta: int; discard take(cmpsts, n, dlta); var nxtn = n + dlta # advance!\n          while nxtn in cmpsts: nxtn += dlta # avoid duplicates\n          cmpsts[nxtn] = dlta # insert non-duplicate adjusted entry\n        else: yield n # not a composite: found a prime!\n      n += 2 # loop until prime found!\n\nproc prime_factors*(n: int): string =\n    result = \"\"; let prms = primes();\n    let lmt = n.float64.sqrt.int # factor up to square root!\n    var p = prms(); var fctrd = n; var cnt = 0\n    while true:\n      let qtnt = fctrd div p; let rmdr = fctrd - qtnt * p\n      if rmdr != 0:\n        if cnt > 0:\n          result &= \"(\" & $p\n          if cnt < 2: result &= \")\" else: result &= \"**\" & $cnt & \")\"\n          if p > fctrd: return\n          if p > lmt:\n            if fctrd > 1: result &= \"(\" & $fctrd & \")\"\n            return\n        p = prms(); cnt = 0; continue\n      fctrd = qtnt; cnt.inc","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"54d7660d2daf68c619000d95":[{"id":214785,"user_id":53,"body":"from math import gcd, lcm\nimport sequtils, sugar\n\nproc reduce*(a, b: int64): seq[int64] =\n  let i = gcd(a, b)\n  result = newSeq[int64](2)\n  result[0] = a div i\n  result[1] = b div i\n  \nproc norm*(a, b, cd: int64): seq[int64] =\n  result = newSeq[int64](2)\n  result[0] = a * (cd div b)\n  result[1] = cd\n  \nproc convert_frac*(a: seq[seq[int]]): seq[seq[int64]] =\n  let xss = a.map(arr => reduce(int64(arr[0]), int64(arr[1])))\n  let cd = foldl(xss, lcm(b[1], a), int64(1))\n  let yss = xss.map(xs => norm(xs[0], xs[1], cd))\n  result = yss","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214786,"user_id":76,"body":"from math import lcm, gcd\nfrom sequtils import foldl, map, mapIt\n\nproc convert_frac*(arr: seq[seq[int]]): seq[seq[int64]] =\n  let lst = arr.map(proc(a: auto): auto =\n    let g = gcd(a[0], a[1])\n    return @[a[0] div g, a[1] div g]\n  )\n  let denom = lst.foldl(lcm(a, b[1]), 1'i64)\n  lst.mapIt(@[denom div it[1] * it[0], denom])","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214787,"user_id":null,"body":"import math, sequtils\n\nfunc lcm[T](x: openArray[T]): T =\n  result = x[0]\n  for i in 1 ..< x.len:\n    result = lcm(result, x[i])\n\n\nproc convert_frac*(a: seq[seq[int]]): seq[seq[int64]] =\n  let a = a.mapIt(((it[0] div gcd(it[0], it[1])).int64, \n                   (it[1] div gcd(it[0], it[1])).int64))\n  let d = lcm(a.mapIt(it[1]))\n  return a.mapIt(@[it[0] * (d div it[1]), d])\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214788,"user_id":null,"body":"import math, sequtils\n\nproc convert_frac*(a: seq[seq[int]]): seq[seq[int64]] =\n  let a = a.mapIt:\n    let g = gcd(it[0], it[1])\n    (it[0] div g, it[1] div g)\n  let l = a.mapIt(it[1]).foldl(lcm(a, b), a[0][1])\n  a.mapIt:\n    let f = l div it[1].int64\n    @[it[0] * f, it[1] * f]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214789,"user_id":null,"body":"import math, algorithm\n\nproc cmp(x, y: seq[int]): int = cmp(x[1], y[1])\n\nproc convert_frac*(a: seq[seq[int]]): seq[seq[int64]] =\n  var LCM: int64 = 1\n  var b = newSeq[seq[int64]](a.len);\n  for i in 0 ..< a.len:\n    var GCD: int64 = gcd(a[i][0], a[i][1])\n    b[i] = @[a[i][0] div GCD, a[i][1] div GCD]\n  for i in b:\n    LCM = lcm(LCM, i[1]);\n  var ans = newSeq[seq[int64]](a.len);\n  for i, elem in b:\n    ans[i] = (@[LCM div elem[1] * elem[0], LCM])\n  return ans\n\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214790,"user_id":null,"body":"import\n  math,\n  sequtils\n  \n\n#Codewars has Nim 1.0 - this proc taken from 1.2 source\nproc lcm*[T](x: openArray[T]): T =\n  result = x[0]\n  var i = 1\n  while i < x.len:\n    result = lcm(result, x[i])\n    inc(i)\n\n\nproc convert_frac*(a: seq[seq[int]]): seq[seq[int64]] =\n  result = a.mapIt @[int64(it[0] div gcd(it[0], it[1])), int64(it[1] div gcd(it[0], it[1]))]\n  let lcd = lcm result.mapIt it[1]\n  result.applyIt @[lcd div it[1] * it[0], lcd]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214791,"user_id":492,"body":"import math, sequtils\n    \nproc convert_frac*(a: seq[seq[int]]): seq[seq[int64]] =\n    var simp: seq[seq[int]] = @[]\n    for _, aa in a:\n        let g = gcd(aa[0], aa[1])\n        simp.add(@[aa[0] div g, aa[1] div g])\n    let ldenom = map(simp, proc(x: seq[int]): int = x[1])\n    let lcmu = int64(foldl(ldenom, lcm(a, b)))\n    var res: seq[seq[int64]] = @[]\n    for _, x in simp:\n        res.add(@[ int64(x[0] * (lcmu div int64(x[1]))), lcmu ])\n    return res","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"54db15b003e88a6a480000b9":[{"id":214792,"user_id":53,"body":"import sequtils, strutils, strformat, math, sugar\n\nproc fromNbToStr*(n: int64, sys: seq[int]): string =\n  let\n    prd = foldl(sys, a * b, int64(1))\n    lcm = foldl(sys, (a * b) div gcd(a, b), int64(1))\n  if prd < n or lcm != prd:\n    return \"Not applicable\"\n  else:\n    return sys.map(e => &\"-{n mod e}-\").join","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214793,"user_id":492,"body":"import math\n\nproc fromNbToStr*(n: int64, sys: seq[int]): string =\n    var mul: int64 = 1\n    for i in 0 ..< sys.len:\n        mul = mul * sys[i]\n    if mul <= n: return \"Not applicable\"\n    for i in 0 ..< sys.len:\n        for j in i + 1 ..< sys.len:\n            if gcd(sys[i], sys[j]) != 1: \n                return \"Not applicable\"\n    var buf = \"-\"\n    for i in 0 ..< sys.len:\n        buf &= $(n %% sys[i]) & \"--\"\n    return buf[0..^2]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214794,"user_id":null,"body":"import math\n\nproc fromNbToStr*(n: int64, sys: seq[int]): string =\n  var\n    x = 1\n    s = \"-\"\n  for m in sys:\n    if gcd(m, x) != 1:\n      return \"Not applicable\"\n    s.add $(n mod m)\n    s.add \"--\"\n    x *= m\n  if x < n:\n    \"Not applicable\"\n  else:\n    s[0..^2]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214795,"user_id":492,"body":"import math, strutils\n\nproc fromNbToStr*(n: int64, sys: seq[int]): string =\n    var mul: int64 = 1\n    for i in 0..< sys.len:\n        mul = mul * sys[i]\n    if mul <= n: return \"Not applicable\"\n    for i in 0..< sys.len:\n        for j in i + 1..< sys.len:\n            if gcd(sys[i], sys[j]) != 1: \n                return \"Not applicable\"\n    var buf = \"-\"\n    for i in 0..< sys.len:\n        buf &= $(n %% sys[i]) & \"--\"\n    return buf[0..^2]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"54dc6f5a224c26032800005c":[{"id":214796,"user_id":492,"body":"import strutils\n\nproc stock_list*(listArt, listCat: seq[string]): string =\n    if listArt.len == 0 or listCat.len == 0: return \"\"\n    var res = \"\"\n    for cat in listCat:\n        var total = 0\n        for book in listArt:\n            if book[0] == cat[0]:\n                let u = split(book, \" \")[1]\n                total += parseInt(u)\n        if res.len != 0:\n            res &= \" - \"\n        res &= \"(\" & cat & \" : \" & intToStr(total) & \")\"\n    return res","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214797,"user_id":null,"body":"import std\/strutils\nimport std\/sequtils\nimport std\/sugar\nimport strformat\n\nproc stock_list*(listArt, listCat: seq[string]): string =\n    if listArt.len == 0 or listCat.len == 0: \"\"\n    else:\n        listCat.map(\n            c => (c, listArt.filter(y => y.startsWith(c))\n                .mapIt(it.split(' ')[1].parseInt())\n                .foldl(a + b, 0))\n        ).map(x => &\"({x[0]} : {x[1]})\").join(\" - \")\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214798,"user_id":76,"body":"import tables\nfrom sequtils import mapIt\nfrom strutils import splitWhiteSpace, parseInt, join, format\n\nproc stock_list*(listArt, listCat: seq[string]): string =\n  if listArt.len == 0 or listCat.len == 0: return \"\"\n  var quantities = initTable[char, int]()\n\n  for item in listArt:\n    let cat = item[0]\n    if cat notin quantities: quantities[cat] = 0\n    quantities[cat].inc( parseInt(item.splitWhiteSpace[1]) )\n  \n  listCat.mapIt(\"($1 : $2)\".format(it, quantities.getOrDefault(it[0]))).join(\" - \")","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214799,"user_id":null,"body":"import std\/[tables,sequtils,strformat,strutils,setutils,sugar]\ntype\n  CatTable = OrderedTable[char,int]\nproc `$`(c:CatTable): string = \n  var firsttime = true\n  for k,v in c:\n    if firsttime:\n      firsttime = false\n    else:\n      result.add \" - \"\n    result.add &\"({k} : {v})\"\nproc stock_list*(listArt, listCat: seq[string]): string =\n    # your code\n    if listArt.len == 0:\n      return\n    var res:CatTable\n    var cats:set[char]\n    for c in listCat:\n      res[c[0]]=0\n      cats.incl c[0]\n    for a in listArt:\n      let \n        kv = a.split(\" \")\n        cat = kv[0][0]\n        num = kv[1].parseInt\n      if cat in cats:\n        res[cat] += num\n    var firsttime = true\n    for c in listCat:\n      if firsttime:\n        firsttime = false\n      else:\n        result.add \" - \"\n      result.add &\"({c} : {res[c[0]]})\"\n      \n      \n    ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214800,"user_id":null,"body":"import std\/strutils\nimport std\/strformat\n\nproc stock_list*(listArt, listCat: seq[string]): string =\n    var table: array['A'..'Z', int]\n\n    if listCat.len == 0 or listArt.len == 0: return \"\"\n\n    for s in listArt:\n        table[s[0]] += s.splitWhitespace[1].parseInt\n    \n    for s in listCat:\n        result.add(&\"({s} : {table[s[0]].intToStr}) - \")\n    result = result[0 ..< ^3]  ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214801,"user_id":null,"body":"import std\/strutils\n\nproc stock_list*(listArt, listCat: seq[string]): string =\n    var table: array['A'..'Z', int]\n  \n    if listCat.len == 0 or listArt.len == 0:\n      return \"\"\n\n    for s in listArt:\n        let splitted = s.splitWhitespace\n        table[splitted[0][0]] += splitted[1].parseInt\n    \n    for s in listCat:\n        result.add('(')\n        result.add(s)\n        result.add(\" : \")\n        result.add(table[s[0]].intToStr)\n        result.add(\") - \")\n    result = result[0 ..< ^3]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214802,"user_id":null,"body":"import\n  std\/strformat,\n  std\/strutils,\n  std\/tables\n  \nproc handleStockList*(listArt, listCat: seq[string]): Table[char, int] =\n  for cat in listCat:\n    result[cat[0]] = 0\n  for art in listArt:\n    if result.contains(art[0]):\n      result[art[0]] += parseInt art[1 + art.find(\" \") .. ^1]\n    \nproc stock_list*(listArt, listCat: seq[string]): string =\n  if listArt.len() == 0: return # ???\n  var categories = handleStockList(listArt, listCat)\n  \n  var pairs: seq[string]\n  for cat in listCat:\n    pairs.add fmt\"({cat[0]} : {categories[cat[0]]})\"\n  result = join(pairs, \" - \")","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214803,"user_id":null,"body":"import tables\nimport strutils\nimport strformat\nimport sequtils\n\nproc stock_list*(listArt, listCat: seq[string]): string =\n    var category_count = initTable[string, seq[int]]()\n    if listCat.len() > 0 and listArt.len() > 0:\n        for cat in listCat:\n            category_count[cat] = @[]\n        for art in listArt:\n            let cat = fmt\"{art[0]}\"\n            if cat in listCat:\n                category_count[cat].add(parseInt(art.split(' ')[1]))\n        var output = \"\"\n        for cat in listCat:\n            if category_count[cat].len() == 0:\n                output = output & fmt\"({cat} : 0) - \"\n            else:\n                output = output & fmt\"({cat} : {category_count[cat].foldl(a + b)}) - \"\n        return output[0 .. ^4]\n    else:\n        return \"\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214804,"user_id":null,"body":"import sequtils\nfrom sugar import `=>`\nimport tables\nimport strutils\n\nproc stock_list*(listArt, listCat: seq[string]): string =\n    if len(listArt) == 0 or len(listCat) == 0:\n        return \"\"\n    var t = initTable[char, int]()\n    for stockItem in listArt:\n        let amount = parseInt(stockItem.split(' ')[1])\n        let category = stockItem[0]\n        t.mgetOrPut(category, 0) += amount\n    return listCat.map(v => \"(\" & v & \" : \" & $(t.getOrDefault(v[0], 0)) & \")\").join(\" - \")\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214805,"user_id":null,"body":"import strutils\nimport strformat\nimport sequtils\nimport sugar\n\nproc sum(x: varargs[int]): int =\n  for i in x:\n    result = result + i\n\nproc sumCategory*(parsedArt: seq[(string, int)], cat: string): int = \n  parsedArt\n    .filter(entry => entry[0] == cat)\n    .map(entry => entry[1])\n    .sum\n  \nproc stock_list*(listArt, listCat: seq[string]): string =\n  if listArt.len == 0 or listCat.len == 0:\n    return \"\"\n    \n  let parsedArt = listArt\n    .map(entry => entry.split(' '))\n    .map(entry => ($(entry[0][0]), entry[1].parseInt))\n  \n  listCat\n    .map(cat => (cat, parsedArt.sumCategory(cat)))\n    .map(x => fmt\"({x[0]} : {x[1]})\")\n    .join(\" - \")\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"54e320dcebe1e583250008fd":[{"id":214806,"user_id":null,"body":"proc dec2FactString*(nb: int64): string =\n  var n = 1\n  var nb = nb\n  while nb > 0:\n    let rem = nb mod n\n    if rem < 10:\n      result = $rem & result\n    else:\n      result = chr(rem + 0x41 - 10) & result\n    nb = nb div n\n    n += 1\n\nproc factString2Dec*(str: string): int64 =\n  var n = len(str) - 1\n  result = 0\n  for c in str[0..^2]:\n    if '0' <= c and c <= '9':\n      result += ord(c) - 0x30\n    else:\n      result += ord(c) - 0x41 + 10\n    result *= n\n    n -= 1\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214807,"user_id":null,"body":"import std\/strutils\nimport std\/algorithm\nimport std\/tables\n\nproc fact(n: int64): int64 =\n  var map {.global.} = {0i64: 0i64, 1i64: 1i64}.toTable\n  \n  if contains(map, n):\n    result = map[n]\n  else:\n    result = n * fact(n - 1)\n    map[n] = result\n\nproc encode(n: int): string =\n  if n <= 9:\n    intToStr(n)\n  else:\n    $(char(int(uint8('A')) + n - 10))\n\nproc decode(c: char): int64 =\n  case c:\n    of '0'..'9':\n      int64(uint8(c) - uint8('0'))\n    of 'A'..'Z':\n      int64(uint8(c) - uint8('A')) + 10\n    else:\n      -1\n  \nproc dec2FactString*(nb: int64): string =\n  var nb = nb\n  result = \"\"\n  \n  var i = 1\n  while fact(i) <= nb:\n    i += 1\n  i -= 1\n\n  while i >= 0:\n    var j = i\n    while j * fact(i) > nb and j >= 0:\n      j -= 1\n    result.add(encode j)\n    nb -= j * fact(i)\n    i -= 1\n\nproc factString2Dec*(str: string): int64 =\n  # your code\n  result = 0\n  \n  for i, c in str.reversed:\n    result += decode(c) * fact(i) \n    ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214808,"user_id":null,"body":"import algorithm, sequtils\n\nproc factTo(max: int64): seq[int64] =\n  var v: int64 = 1\n  while true:\n    v *= (result.len + 1)\n    if v > max: return\n    result.add v\n\nproc factFor(i: int64): seq[int64] =\n  var v: int64 = 1\n  for n in 1..i:\n    v *= n\n    result.add v\n\nproc toChar(i: int64): char =\n  if i < 10: char('0'.ord + i)\n  else:      char('A'.ord + i - 10)\n\nproc toInt(c: char): int64 =\n  if c in 'A'..'Z': c.ord - 'A'.ord + 10\n  else:             c.ord - '0'.ord\n  \nproc dec2FactString*(n: int64): string =\n  if n < 1: return \"0\"\n  var n = n\n  for x in reversed factTo n:\n    result.add toChar(n div x)\n    n = n mod x\n  result.add \"0\"\n\nproc factString2Dec*(s: string): int64 =\n  if s.len < 2: return 0\n  let fact = reversed factFor s.high\n  s[0..^2].map(toInt).zip(fact).mapit(it[0] * it[1]).foldl(a + b)\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214809,"user_id":492,"body":"import math, sequtils\n\nproc dec2FactString*(nb: int64): string =\n    let alphabet = toSeq(\"0123456789ABCDEFGHIGKLMNOPQRSTUWXYZ\".items)\n    var res = \"\"; var base = 1; var nnb = nb\n    while nnb > 0:\n        res = alphabet[int(nnb %% base)] & res\n        nnb = int(floor(float64(nnb) \/ float64(base)))\n        base += 1\n    return res\n\nproc factString2Dec*(str: string): int64 =\n    let alphabet = toSeq(\"0123456789ABCDEFGHIGKLMNOPQRSTUWXYZ\".items)\n    let arr = toSeq(str.items)\n    var res: int64 = 0; var fact: int64 = 1; var i = arr.len - 2\n    while i >= 0:\n      let c = arr[i]\n      let a = find(alphabet, c)\n      fact *= arr.len - i - 1\n      res += a * fact\n      i -= 1\n    return res","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214810,"user_id":null,"body":"import strutils, sequtils, tables\n\nlet chs = ('0' .. '9').toSeq & ('A' .. 'Z').toSeq\nvar ords = (0 .. 35).mapIt((chs[it], it)).toTable\n\nproc dec2FactString*(nb: int64): string =\n  result = \"\"\n\n  var \n    n = nb\n    i = 1\n    r = 0.int64\n\n  while n > 0:\n    r = n mod i\n    n = n div i\n    inc i\n    result = $chs[r] & result\n\n\nproc factString2Dec*(str: string): int64 =\n  \n  var \n    l = str.len - 1\n    i = 0\n    tot = ords[str[i]]\n  \n  while l > 0:\n    tot = (tot * l + ords[str[i+1]])\n    dec l\n    inc i\n\n  tot","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"54f8693ea58bce689100065f":[{"id":214811,"user_id":53,"body":"import strutils, math, sequtils\n    \nproc decompose*(s: string): seq[string] =\n    var ans: seq[string] = @[]\n    let xs = s.split({'\/'})\n    var a = float64(0)\n    var b = float64(1)\n    if xs.len == 1:\n        a = parseFloat(s)\n    else:\n        a = parseFloat(xs[0])\n        b = parseFloat(xs[1])\n    while a mod 1 > 0:\n        a *= 10\n        b *= 10\n    while a >= b:\n        let d = int64(a) div int64(b)\n        ans = concat(ans, @[$(d)])\n        a = a mod b\n    while a > 0:\n        let d = float64(ceil(b \/ a))\n        ans = concat(ans, @[\"1\/\" & $(int64(d))])\n        a = a * d - b\n        b *= d\n    return ans","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214812,"user_id":492,"body":"import strutils, math\n    \nproc decompose*(s: string): seq[string] =\n    proc decomposeFrac(s: string): seq[string] =\n        let arr = split(s, \"\/\"); var res: seq[string] = @[]\n        if arr[0] == \"0\": return res\n        var a = parseBiggestInt(arr[0])\n        var b = parseBiggestInt(arr[1])\n        if a == 0: return res\n        if b == 1: return @[arr[0]]\n        if a >= b:\n            res.add($(a div b))\n            a = a %% b\n        if a > 0:\n            while true:\n                let dv = int64(ceil(float64(b) \/ float64(a)))\n                res.add( \"1\/\" & $(dv))\n                a = a * dv - b\n                if a <= 0: break\n                b *= dv\n        return res\n        \n    proc decomposeDec(s: string): seq[string] =\n        var mul = pow(10, float64(s.len))\n        let a: float64 = parseFloat(s)\n        var num = $(int64(mul * a))\n        return decomposeFrac(num & \"\/\" & $(int64(mul)))\n        \n    if find(s, \"\/\") != -1:\n        return decomposeFrac(s)\n    else:\n        if find(s, \".\") != -1:\n            return decomposeDec(s)\n        else:\n            if s == \"0\": return @[]\n            else: return @[s]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214813,"user_id":null,"body":"import std\/rationals\nimport std\/strutils\nimport std\/math\n\nproc decompose*(s: string): seq[string] =\n  if s == \"0\":\n    return @[]\n  var frac = 1\/\/1\n  var parts: seq[string] = @[]\n  if '\/' in s:\n    let x = s.split(\"\/\", 1)\n    frac = parseInt(x[0]) \/\/ parseInt(x[1])\n  elif '.' in s:\n    let sp = s.split(\".\")\n    let a = parseInt(sp[1])\n    let b = 10^(len(sp[1]))\n    if sp[0] != \"0\":\n      parts.add(sp[0])\n    frac = a \/\/ b\n  else:\n    frac = parseInt(s) \/\/ 1\n  if frac >= (1\/\/1):\n    let intpart = frac.num div frac.den\n    parts.add($intpart)\n    frac -= (intpart \/\/ 1)\n  if frac == (0\/\/1):\n    return parts\n  var ctr = 2\n  var remaining = frac\n  while true:\n    let f = 1 \/\/ ctr\n    if f <= remaining:\n      parts.add($f)\n      remaining -= f\n    if remaining == (0 \/\/ 1):\n      return parts\n    if remaining.num == 1:\n      ctr = remaining.den\n    else:\n      # there's almost certainly a better way of doing this\n      ctr += 1","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214814,"user_id":null,"body":"import strutils, math, rationals, sequtils\n\nproc decompose(n: Rational): seq[string] =\n  if n >= 1 \/\/ 1:\n    return @[$(n.num div n.den)].concat(decompose(n mod (1 \/\/ 1)))\n  if n.num == 0:\n    return\n  if n.num == 1:\n    return @[$n]\n  let d = n.den div n.num + 1\n  return @[\"1\/\" & $(d)].concat(decompose(n - 1 \/\/ d))\n\nproc decompose*(s: string): seq[string] =\n  var n =\n    if '\/' in s:\n      s[0..s.find('\/') - 1].parseInt \/\/ s[s.find('\/') + 1..^1].parseInt\n    elif '.' in s:\n      s.replace(\".\").parseInt \/\/ 10 ^ (s.len - s.find('.') - 1)\n    else:\n      s.parseInt \/\/ 1\n  n.reduce\n  return decompose(n)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"55031bba8cba40ada90011c4":[{"id":214815,"user_id":null,"body":"import strutils, math, strformat\nproc isSumOfCubes*(s: string): string =\n  var i = 0\n  var total = 0\n  echo s.len\n  while i < s.len:\n    var value = 0\n    var newstring: string\n    if s[i].isDigit:\n      if s.len - i > 1 and s[i+1].isDigit:\n        if s.len - i > 2 and s[i+2].isDigit:\n           newstring.add(s[i..(i+2)])  \n        else:\n           newstring.add(s[i..(i+1)])\n      else:\n         newstring.add(s[i])\n    var j = 0\n    while j < newstring.len:\n      value += ((newstring[j].ord)-48)^3\n      inc j\n    \n    i += newstring.len\n    if newstring.len > 0:\n      if value == parseInt(newstring):\n        result.add(intToStr(parseInt(newstring)))\n        result.add(\" \")\n        total += parseInt(newstring)\n    else:\n      inc i\n  if result.len > 0:\n    result.add(&\"{total} Lucky\")\n  else:\n    return \"Unlucky\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214816,"user_id":null,"body":"import strutils, math\nproc isSumOfCubes*(s: string): string =\n  var data: seq[string]\n  var sb = \"\"\n  for i, c in s:\n    if c in '0'..'9':\n      sb.add(c)\n      if sb.len == 3 or i == s.len-1: data.add(sb); sb = \"\"\n    elif sb != \"\": data.add(sb); sb = \"\"\n  var valid: seq[int]\n  for n in data:\n    var b = 0\n    for d in n: b += parseInt($d)^3\n    if b == parseInt(n): valid.add(b)\n  for x in valid: result.add($x & \" \")\n  if result.len > 0: result.add($sum(valid) & \" Lucky\")\n  else: return \"Unlucky\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214817,"user_id":492,"body":"import strutils, nre\n\nproc isSumOfCubes*(s: string): string =\n    proc isCubic(n: int): (bool, int) =\n        var sm = 0\n        for value in $n: \n            let c = int(value) - int('0')\n            sm += c * c * c\n        return (sm == n, n)\n\n    let numb = re\"[0-9]{1,3}\"\n    var res: string = \"\"; var sm: int = 0\n    for value in findAll(s, numb):\n        let (b, v) = isCubic(parseInt(value))\n        if b:\n            res &= $v & \" \"\n            sm += v\n    if res.len != 0:\n        return res & $sm & \" Lucky\"\n    else: return \"Unlucky\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"550498447451fbbd7600041c":[{"id":214818,"user_id":null,"body":"import algorithm\nproc comp_same*(a: seq[int], b: seq[int]): bool = \n  if a.len() != b.len():\n    return false\n  let b1 = sorted(b)\n  for i, x in a.sorted():\n    if b1[i] != x * x:\n      return false\n  return true","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214819,"user_id":null,"body":"import sequtils, sugar, algorithm\nproc comp_same*(a: seq[int], b: seq[int]): bool =\n  # your code\n  a.map(x => x * x).sorted() == b.sorted()\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214820,"user_id":null,"body":"import algorithm\nimport sequtils\nimport sugar\n\nproc comp_same*(a: seq[int], b: seq[int]): bool =\n  a.map(x => x*x).sorted == b.sorted\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214821,"user_id":76,"body":"from algorithm import sorted\nfrom sequtils import mapIt\n\nproc comp_same*(a: seq[int], b: seq[int]): bool =\n  a.mapIt(it * it).sorted == b.sorted","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214822,"user_id":null,"body":"import std\/algorithm\nimport std\/sequtils\n\nproc comp_same*(a: seq[int], b: seq[int]): bool =\n  if a.len != b.len:\n    return false\n  var temp_a = a.sorted()\n  var temp_b = b.sorted()\n  apply(temp_a, proc(x: var int) = x *= x)\n  \n  for i in countup(0, len(temp_a) - 1):\n    if temp_a[i] != temp_b[i]:\n      return false\n  return true","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214823,"user_id":null,"body":"import algorithm, sequtils \n\nproc comp_same*(a: seq[int], b: seq[int]): bool =\n  if a.len != b.len: return false\n  let a = sorted(a)\n  let b = sorted(b)\n  return allIt(0..<a.len, a[it] * a[it] == b[it])\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214824,"user_id":null,"body":"\nimport math\n\nproc comp_same*(a: seq[int], b: seq[int]): bool =\n  var\n    a2 = a.deepCopy()\n    b2 = b.deepCopy()\n    x: int\n  for n in a:\n    x = n ^ 2\n    if x in b2:\n      b2.delete(b2.find x)\n    else:\n      return false\n  for n in b:\n    x = sqrt(n.float).int\n    if x in a2:\n      a2.delete(a2.find x)\n    else:\n      return false\n  return true\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214825,"user_id":null,"body":"import std\/algorithm\nimport std\/sequtils\n\nproc comp_same*(a: seq[int], b: seq[int]): bool =\n  a.mapIt(it * it).sorted == b.sorted","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214826,"user_id":null,"body":"import math\nimport algorithm\n\nproc comp_same*(a: seq[int], b: seq[int]): bool =\n  if a.len != b.len:\n    return false\n  \n  if a.len == 0 or b.len == 0:\n    return true\n  \n  let\n    aa = sorted(a)\n    bb = sorted(b)\n\n  for i, n in aa:\n    if n ^ 2 != bb[i]:\n      return false\n\n  return true","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214827,"user_id":null,"body":"import algorithm\nimport math\nimport sequtils\n\nproc comp_same*(a: seq[int], b: seq[int]): bool =\n  if a.len != b.len:\n    return false\n  for t in zip(sorted(a), sorted(b)):\n    if t.a^2 != t.b:\n      return false\n  return true","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"550527b108b86f700000073f":[{"id":214828,"user_id":null,"body":"import math, strutils, strformat\nproc iter_pi*(epsilon: float64): string =\n  var n = 0\n  var answer = 0.0\n  while abs(answer - PI) >= epsilon:\n    if n mod 2 == 0:\n      answer += 4 \/ (1 + (2*n))\n    else:\n      answer -= 4 \/ (1 + (2*n))\n    inc n\n  return &\"[{n}, {formatEng(answer, 10)}]\"\n  ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214829,"user_id":492,"body":"import math, strutils\n\nproc iter_pi*(epsilon: float64): string =\n    var n: float64 = 1.0; var value: float64 = 0.0; var counter: int = 0\n    while (abs((PI - 4 * value)) > epsilon):\n        value += 1.0 \/ n\n        n = -n\n        if (n > 0): \n            n += 2.0\n        else:\n            if (n < 0): \n                n -= 2\n        counter += 1\n    return \"[$1, $2]\".format(counter, math.round(4 * value, 10))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214830,"user_id":null,"body":"import math\n\nproc iter_pi*(epsilon: float64): string =\n  var\n    iterations = 0\n    denom = 1\n    pi = 0.0\n  while abs(PI-pi) > epsilon:\n    if iterations mod 2 == 0:\n      pi += 4\/denom\n    else:\n      pi -= 4\/denom\n    \n    denom += 2\n    iterations += 1\n  \"[\" & $iterations & \", \" & $round(pi, 10) & \"]\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214831,"user_id":null,"body":"import math, strformat\n\nproc iter_pi*(epsilon: float64): string =\n  var i = 0\n  var res = 0.0\n  while abs(PI - res) >= epsilon:\n    res += 4 * ((-1) ^ i) \/ (2 * i + 1)\n    inc i\n  &\"[{i}, {res.round(10)}]\"\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214832,"user_id":null,"body":"import math\nimport strformat\nimport strutils\n\niterator summand(): float64 =\n  var nextFac = 1\n  var nextQ = 1\n  while true:\n    yield nextFac * 1 \/ nextQ\n    nextFac = nextFac * -1\n    nextQ = nextQ + 2\n    \nproc iter_pi*(epsilon: float64): string =\n  var iters = 0\n  var currentQuarterPi: float64 = 0\n  for s in summand():\n    iters = iters + 1\n    currentQuarterPi = currentQuarterPi + s\n    let curPi = currentQuarterPi * 4\n    \n    if abs(curPi - PI) < epsilon:\n      let pifmt: string = formatEng(curPi)\n      return &\"[{iters}, {pifmt}]\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214833,"user_id":null,"body":"import math, strformat, strutils\nproc iter_pi*(epsilon: float64): string =\n  var\n    approx : float64 = 0\n    iter   : int     = 0\n  while epsilon <= abs(PI - approx):\n    approx += [4, -4][iter mod 2] \/ (2 * iter + 1)\n    iter += 1\n  var approxFmt : string = fmt\"{approx:.11}\"\n  approxFmt.trimZeros()\n  return fmt\"[{iter}, {approxFmt}]\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214834,"user_id":53,"body":"import math, strformat\n\nproc iter_pi*(epsilon: float64): string =\n  var pi4 = 1.0\n  var sign = -1.0\n  var iterations = 1\n  var denom = 3.0\n  while abs(4.0 * pi4 - math.PI) >= epsilon:\n    pi4 = pi4 + sign * (1.0 \/ denom)\n    sign = sign * (-1.0)\n    denom = denom + 2.0\n    iterations = iterations + 1\n  let ans = round(4.0 * pi4 * pow(10.0, 10)) \/ pow(10.0, 10)\n  return &\"[{iterations}, {ans}]\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214835,"user_id":3398,"body":"import math\nimport strformat\n\nconst pi4 = math.PI \/ 4\n\nproc iter_pi*(epsilon: float64): string =\n  var denom: float = 1\n  var sign: float = 1\n  var pi: float = 0\n  var eps4 = epsilon \/ 4\n  var iterations = 0\n  while abs(pi - pi4) > eps4:\n    pi += sign * 1 \/ denom\n    sign = -sign\n    denom += 2\n    iterations += 1\n  return &\"[{iterations}, {round(pi*4, 10)}]\"\n    \n  \n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214836,"user_id":null,"body":"import math, strutils\n\nproc iter_pi*(epsilon: float64): string =\n    # your code\n    var x = 0.0\n    var i = 1\n    var sign = 1\n    var count = 0\n    while abs(4 * x - PI) > epsilon:\n        x += sign \/ i\n        sign = -sign\n        i += 2\n        count += 1\n    result = \"[$1, $2]\".format(count, round(4.0*x,10))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214837,"user_id":null,"body":"import math, strformat\n\n\nproc iter_pi*(epsilon: float64): string =\n    var\n      denom = 1.0\n      my_pi = 0.0\n      m = 1.0\n      iters = 0\n    while abs(4*my_pi-math.PI) > epsilon:\n      my_pi += m \/ denom\n      m = -m\n      denom += 2\n      iters += 1\n    return &\"[{iters}, {round(4*my_pi, 10)}]\"\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"550554fd08b86f84fe000a58":[{"id":214838,"user_id":492,"body":"import strutils, algorithm\n\nproc inArray*(array1, array2: seq[string]): seq[string] =\n    var res: seq[string] = @[]\n    for a1 in array1:\n        for a2 in array2:\n            if contains(a2, a1) and not(a1 in res):\n                res.add(a1)\n    sort(res, cmp)\n    return res","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214839,"user_id":53,"body":"import sequtils, strutils, algorithm\n\nproc inArray*(xs, ys: seq[string]): seq[string] =\n  let zs = filter(xs, \n    proc (x: string): bool = return (any(ys, \n      proc (y: string): bool = return strutils.contains(y, x))))\n  var ans = deduplicate(zs, isSorted = false)\n  ans.sort()\n  return ans","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214840,"user_id":null,"body":"import algorithm\nimport sequtils\nimport strutils\nimport sugar\n\nproc inArray*(array1, array2: seq[string]): seq[string] =\n  return sorted(array1.filter(i1 => array2.any(i2 => i1 in i2))).deduplicate(isSorted=true)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214841,"user_id":76,"body":"from algorithm import sorted\nfrom sequtils import any, filter, deduplicate\nfrom strutils import contains\nfrom sugar import `=>`\n\nproc inArray*(array1, array2: seq[string]): seq[string] =\n  array1.filter(str => array2.any(word => word.contains str)).deduplicate.sorted","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214842,"user_id":null,"body":"import strutils\nimport std\/algorithm\n\nproc inArray*(array1, array2: seq[string]): seq[string] =\n  var res = newSeq[string]()\n  for s1 in array1:\n    for s2 in array2:\n      if s2.contains(s1) and not res.contains(s1):\n        res.add(s1)\n        break\n  return res.sorted(system.cmp[string])","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214843,"user_id":null,"body":"import strutils\nimport algorithm\n\nproc inArray*(array1, array2: seq[string]): seq[string] =\n  var res: seq[string] = @[]\n  for i in array1:\n    if i in res:\n      continue\n    for j in array2:\n      if i in j:\n        res.add(i)\n        break\n  res.sort()\n  return res","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214844,"user_id":null,"body":"import strutils\nimport algorithm\nimport sequtils\n\nproc inArray*(array1: seq[string], array2: seq[string]): seq[string] =\n  # your code\n  var sub: seq[string] = @[]\n  for i in array1.low..array1.high:\n    for e in array2.low..array2.high:\n      if array2[e].contains(array1[i]):\n        sub.add(array1[i])\n        break\n  sub.sort(system.cmp)\n  return sub.deduplicate","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214845,"user_id":null,"body":"import sequtils\nimport strutils\nimport algorithm\n\nproc isSubString(subject: string, array: seq[string]): bool =\n  array.anyIt(it.contains(subject))\n\nproc inArray*(array1, array2: seq[string]): seq[string] =\n  array1.filterIt(isSubString(it, array2)).sorted().deduplicate(isSorted=true)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214846,"user_id":null,"body":"import std\/algorithm\nimport std\/sets\n\nimport strutils\n\n\nproc inArray*(array1, array2: seq[string]): seq[string] =\n    var arr = newSeq[string]()\n\n    for x in toHashSet(array1):\n        for y in toHashSet(array2):\n            if y.contains(x):\n                arr.add(x)\n                break\n\n    arr.sort()\n\n    return arr","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214847,"user_id":null,"body":"import sequtils, strutils, algorithm\n\nproc inArray*(array1, array2: seq[string]): seq[string] =\n  for a1 in array1:\n    for a2 in array2:\n      if a1 in a2:\n        result.add(a1)\n  return sorted(deduplicate(result))","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5506b230a11c0aeab3000c1f":[{"id":214848,"user_id":492,"body":"import math\n\nproc evaporator*(content: float64, evapPerDay: float64, threshold: int): int =\n    return int(ceil(log10(float64(threshold) \/ 100.0) \/ log10(1.0 - float64(evapPerDay) \/ 100.0)))","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214849,"user_id":null,"body":"import math\n\nproc evaporator*(content: float64, evapPerDay: float64, threshold: int): int =\n    ceil(log(threshold \/ 100, 1 - evapPerDay \/ 100)).int","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214850,"user_id":76,"body":"proc evaporator*(content: float64, evapPerDay: float64, threshold: int): int =\n  var\n    gas = 100'f64\n    loss = 1 - (evapPerDay \/ 100)\n  \n  while int(gas) >= threshold:\n    inc result\n    gas *= loss","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214851,"user_id":null,"body":"import std\/math\nproc evaporator*(content: float64, evapPerDay: float64, threshold: int): int =\n    return 1+((threshold.float64\/100).ln\/((100-evapPerDay.float64)\/100).ln).int","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214852,"user_id":null,"body":"proc evaporator*(content: float64, evapPerDay: float64, threshold: int): int =\n    var current = content\n    let dec = 1.float64 - (evapPerDay.float64 \/ 100.float64)\n    let thre64 = content * threshold.float64 \/ 100.float64\n    while true:\n      if current < thre64:\n        return\n      current = current * dec\n      result += 1","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214853,"user_id":null,"body":"proc evaporator*(content: float64, evapPerDay: float64, threshold: int): int =\n  var level = content\n  let thresh = float(threshold)*content\/100\n  let evap = float(evapPerDay)\/100\n  result = 0\n  while level > thresh:\n    level -= evap*level\n    result += 1","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214854,"user_id":null,"body":"proc evaporator*(content: float64, evapPerDay: float64, threshold: int): int =\n    var content: float64 = 10\n    var days: int = 0\n    let final: float64 = float64((threshold\/100) * content)\n  \n    while content > final:\n      content = content - ((evapPerday\/100) * content)\n      days += 1\n    \n    return days","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214855,"user_id":null,"body":"proc evaporator*(content: float64, evapPerDay: float64, threshold: int): int =\n  var currentContent = content\n  while currentContent >= (content * (threshold.float * 0.01)):\n    currentContent *= 1.0 - (evapPerDay.float * 0.01)\n    result += 1","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214856,"user_id":null,"body":"proc evaporator*(content: float64, evapPerDay: float64, threshold: int): int =\n  var percent = 100.0\n  var day = 0\n  let thr = float(threshold)\n  let evFactor = 100 \/ float(evapPerDay)\n  while percent >= thr:\n    day += 1\n    percent -= percent \/ evFactor\n  day","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214857,"user_id":null,"body":"proc evaporator*(content: float64, evapPerDay: float64, threshold: int): int =\n  let decreasing_factor: float64 = 1 - evapPerDay\/100\n  let actual_threshold: float64 = content*(threshold.float64)\/100\n  var actual_content = content\n  var day: int = 0\n  while actual_content > actual_threshold:\n    actual_content = actual_content * decreasing_factor\n    day = day + 1\n  return day","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5508249a98b3234f420000fb":[{"id":214858,"user_id":null,"body":"import strutils, sequtils\n\nproc rem(n, m: int): int = ((n mod m) + m) mod m\n\nproc moving_shift*(s: string, shift: int): seq[string] =\n  var shifted: seq[char]\n  var shift = shift\n  for c in s:\n    shifted.add(\n      if   c.isUpperAscii: char((ord(c) + shift - ord('A')).rem(26) + ord('A'))\n      elif c.isLowerAscii: char((ord(c) + shift - ord('a')).rem(26) + ord('a'))\n      else: c\n    )\n    inc shift\n  return shifted.distribute(5, false).mapIt(it.join(\"\"))\n\nproc demoving_shift*(arr: seq[string], shift: int): string =\n  result = arr.join(\"\")\n  for i in 0..<result.len:\n    let c = result[i]\n    result[i] = \n      if   c.isUpperAscii: char((ord(c) - shift - i - ord('A')).rem(26) + ord('A'))\n      elif c.isLowerAscii: char((ord(c) - shift - i - ord('a')).rem(26) + ord('a'))\n      else: c","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214859,"user_id":null,"body":"import std\/math\nimport std\/sequtils\nimport std\/strutils\n\nconst ltable = toSeq 'a'..'z'\nconst utable = toSeq 'A'..'Z'\nproc getChar(c: char, index: int, isLower: bool): char =\n  if isLowerAscii(c):\n    ltable[(26 + (int(c) - int('a') + index) mod 26) mod 26]\n  else:\n    utable[(26 + (int(c) - int('A') + index) mod 26) mod 26]\n  \nproc moving_shift*(s: string, shift: int): seq[string] =\n  var part = zip(s, toSeq 0..s.len).map(proc (p: (char, int)): char =\n    let\n      c = p[0]\n      i = p[1]\n    if isAlphaAscii(c):\n      getChar(c, i+shift, isLowerAscii(c))\n    else:\n      c\n  ).toSeq\n  \n  var res = newSeq[string]()\n  let len = int(ceil(part.len \/ 5))\n  for i in 0..4:\n    if (i+1) * len <= part.len:\n      res.add(part[i*len..<(i+1)*len].join)\n    elif i * len < part.len:\n      res.add(part[i*len..<part.len].join)\n    else:\n      res.add(\"\")\n  res\n    \nproc demoving_shift*(arr: seq[string], shift: int): string =\n  zip(toSeq 0..5*arr[0].len, arr.join).map(proc (p: (int, char)): char =\n    let\n      c = p[1]\n      i = p[0]\n    if isAlphaAscii(c):\n      getChar(c, (0 - i - shift), isLowerAscii(c))\n    else:\n      c\n  ).join","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214860,"user_id":null,"body":"import strutils, sequtils\n\nproc wrap(a, b: int): int =\n  if a < 0:\n    (a + b * (-a div b + 1)) mod b\n  else:\n    a mod b\n\nproc shift(c: char, shift: int): char =\n  if c notin Letters:\n    return c\n  let\n    base = if c.isLowerAscii: 'a' else: 'A'\n    offset = c.ord - base.ord\n  succ base, wrap(shift + offset, Letters.card div 2)\n\nproc moving_shift*(s: string, shift: int): seq[string] =\n  toSeq(s.pairs)\n    .mapIt(shift(it.val, it.key + shift))\n    .distribute(5, spread = false)\n    .mapIt(it.join)\n\nproc demoving_shift*(arr: seq[string], shift: int): string =\n  toSeq(arr.join.pairs).mapIt(shift(it.val, -it.key - shift)).join\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214861,"user_id":null,"body":"import strutils, sequtils\n\nproc `mod`(a, b: int): int =\n  if a < 0:\n    system.`mod`(a + b * (-a div b + 1), b)\n  else:\n    system.`mod`(a, b)\n\nproc shift(c: char, shift: int): char =\n  if c notin Letters:\n    return c\n  let offset = c.toLowerAscii.ord - 'a'.ord\n  let base = if c.isLowerAscii: 'a' else: 'A'\n  succ base, (shift + offset) mod (Letters.card div 2)\n\nproc moving_shift*(s: string, shift: int): seq[string] =\n  toSeq(s.pairs)\n    .mapIt(shift(it.val, it.key + shift))\n    .distribute(5, spread = false)\n    .mapIt(it.join)\n\nproc demoving_shift*(arr: seq[string], shift: int): string =\n  toSeq(arr.join.pairs).mapIt(shift(it.val, -it.key - shift)).join\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214862,"user_id":null,"body":"import math, sequtils\n\nproc sh(ch, shift, sign: auto): char =\n  result = ch\n  for slice in ['A'..'Z', 'a'..'z']:\n    if ch in slice: \n      result = char(slice.a.int + floorMod(ch.int - slice.a.int + shift * sign, 26))\n\nproc moving_shift*(s: string, shift: int): seq[string] =\n    var \n      shift = shift\n      res: string\n    for ch in s:\n      res.add ch.sh(shift, 1)\n      inc shift\n    let p = ceil(s.len.float \/ 5.0).int\n    for i in 0..<5:\n      result.add res.substr(p * i, p * i + p - 1)\n    \nproc demoving_shift*(arr: seq[string], shift: int): string =\n    var shift = shift\n    for str in arr:\n      for ch in str:\n        result.add ch.sh(shift, -1)\n        inc shift\n    \n    ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214863,"user_id":null,"body":"import math, sequtils, sugar\n\ntemplate sh(ch, op: untyped): untyped =\n  var res = ch\n  for slice in ['A'..'Z', 'a'..'z']:\n    if ch in slice: \n      res = char(slice.a.int + op(ch.int - slice.a.int, shift).floorMod(26))\n  res\n\nproc moving_shift*(s: string, shift: int): seq[string] =\n    var \n      shift = shift\n      res: string\n    for ch in s:\n      res.add ch.sh(`+`)\n      inc shift\n    let p = ceil(s.len.float \/ 5.0).int\n    for i in 0..<5:\n      result.add res.substr(p * i, p * i + p - 1)\n    \nproc demoving_shift*(arr: seq[string], shift: int): string =\n    var shift = shift\n    for str in arr:\n      for ch in str:\n        result.add ch.sh(`-`)\n        inc shift\n    \n    ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214864,"user_id":492,"body":"import strutils, math\n\nproc movShAux(s: string, shift, sgn: int): string =\n    proc modx(x, y: int): int =\n        if x >= 0: return x %% y\n        return y - 1 - ((-x - 1) %% y)\n        \n    var shifted: char; var res = \"\"\n    for k, c in s:\n        let sval = modx(sgn * (shift + k), 26)\n        if c >= 'a' and c <= 'z':\n            shifted = char(int('a') + ((int(c) - int('a') + sval) %% 26))\n        else:\n            if c >= 'A' and c <= 'Z':\n                shifted = char(int('A') + ((int(c) - int('A') + sval) %% 26))\n            else:\n                shifted = c       \n        res &= shifted\n    return res\n    \nproc moving_shift*(s: string, shift: int): seq[string] =\n    var res: seq[string] = @[]\n    var s = movShAux(s, shift, 1)\n    let chunk = int(ceil(float64(s.len) \/ 5.0))\n    while s.len > chunk:\n        res.add(s[0..< chunk])\n        s = s[chunk..^1]\n    res.add(s)\n    while res.len < 5:\n        res.add(\"\")\n    return res\n    \nproc demoving_shift*(arr: seq[string], shift: int): string =\n    let s = join(arr, \"\")\n    return movShAux(s, shift, -1);","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"550f22f4d758534c1100025a":[{"id":214865,"user_id":null,"body":"proc dir_reduc*(arr: seq[string]): seq[string] =\n  proc opp(a,b:string):bool=\n    if a==\"NORTH\": return b==\"SOUTH\"\n    if a==\"SOUTH\": return b==\"NORTH\"\n    if a==\"EAST\": return b==\"WEST\"\n    if a==\"WEST\": return b==\"EAST\"\n      \n  for it in arr:\n    if result.high >= 0 and true==opp(it,result[result.high]):\n      discard result.pop()\n    else:\n      result.add(it)\n  return\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214866,"user_id":527,"body":"proc opposite(dir: string): string =\n  case dir\n    of \"NORTH\": result = \"SOUTH\"\n    of \"SOUTH\": result = \"NORTH\"\n    of \"EAST\": result = \"WEST\"\n    of \"WEST\": result = \"EAST\"\n\nproc dir_reduc*(plan: seq[string]): seq[string] =\n  result = newSeq[string]()\n  for d in plan:\n    if len(result) > 0 and result[high(result)] == opposite(d):\n      discard result.pop()\n    else:\n      result.add(d)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214867,"user_id":76,"body":"import strutils, re\n\nlet reg = re\"SOUTH NORTH|NORTH SOUTH|WEST EAST|EAST WEST\"\n\nproc dir_reduc*(arr: seq[string]): seq[string] =\n  var s = arr.join(\" \")\n  if s.contains(reg): \n    dir_reduc(s.replace(reg).splitWhiteSpace)\n  else: \n    arr","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214868,"user_id":null,"body":"import tables\n\nproc dir_reduc*(arr: seq[string]): seq[string] =\n    let dir = toTable({\n        \"WEST\": 0,\n        \"NORTH\": 1,\n        \"EAST\": 2,\n        \"SOUTH\": 3\n    })\n    let toStr = @[\n        \"WEST\",\n        \"NORTH\",\n        \"EAST\",\n        \"SOUTH\"\n    ]\n    \n    result = newSeq[string]()\n    for s in arr:\n        let a = dir[s]\n        if result.len == 0:\n            result.add(toStr[a])\n        else:\n            let b = dir[result.pop()]\n            if (a + 2) mod 4 != b:\n                result.add(toStr[b])\n                result.add(toStr[a])\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214869,"user_id":null,"body":"proc isOpposite(a: string, b: string): bool =\n    ((a == \"NORTH\" and b == \"SOUTH\") or\n     (a == \"SOUTH\" and b == \"NORTH\") or\n     (a == \"WEST\" and b == \"EAST\") or\n     (a == \"EAST\" and b == \"WEST\"))\n\nproc dir_reduc*(arr: seq[string]): seq[string] =\n    for i in arr:\n        result.add(i)\n        if len(result) >= 2 and isOpposite(result[^1], result[^2]):\n            result.setLen(len(result)-2)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214870,"user_id":492,"body":"import strutils\n\nproc dir_reduc*(arr: seq[string]): seq[string] =\n    var s = join(arr, \" \")\n    while true:\n        var aa = s\n        aa = replace(replace(s, \"NORTH SOUTH\", \"\"), \"SOUTH NORTH\", \"\")\n        var aaa = replace(replace(replace(aa, \"EAST WEST\", \"\"), \"WEST EAST\", \"\"), \"  \", \" \")\n        aaa = aaa.strip(leading=true, trailing=true)\n        if aaa == s: break else: s = aaa\n    if s == \"\": return @[]\n    return split(s, \" \")","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214871,"user_id":null,"body":"import strutils, sequtils\n\nproc opposite(dir: string): char =\n  case dir[0]\n  of 'N': 'S'\n  of 'S': 'N'\n  of 'W': 'E'\n  of 'E': 'W'\n  else: raise ValueError.newException(\"Cannot recognize direction: \" & dir)\n\nproc dir_reduc*(arr: seq[string]): seq[string] =\n  for d in arr:\n    if result.len == 0 or opposite(d) != result[^1][0]:\n      result.add d\n    else:\n      result.delete(result.len - 1)\n","lang_id":33,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214872,"user_id":53,"body":"import sequtils\n\nproc dir_reduc*(ls: seq[string]): seq[string] =\n    var ans: seq[string] = @[]\n    let n = ls.len\n    for i in countup(0, n - 1):\n        let x = ls[i]\n        if ans.len == 0:\n            ans = concat(ans, @[x])\n        else:\n            let y = ans[ans.len - 1]\n            if (x == \"SOUTH\" and y == \"NORTH\") or (x == \"NORTH\" and y == \"SOUTH\") or (x == \"WEST\" and y == \"EAST\") or (x == \"EAST\" and y == \"WEST\"):\n                ans.delete(ans.len - 1)\n            else:\n                ans = concat(ans, @[x])\n    return ans","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214873,"user_id":null,"body":"import tables\nproc dir_reduc*(arr: seq[string]): seq[string] =\n  var ar = arr\n  for i in 0..high(ar)-1:\n    if ar[i]==\"WEST\" and ar[i+1]==\"EAST\" or ar[i]==\"EAST\" and ar[i+1]==\"WEST\" or ar[i]==\"NORTH\" and ar[i+1]==\"SOUTH\" or ar[i]==\"SOUTH\" and ar[i+1]==\"NORTH\":\n      ar.delete(i)\n      ar.delete(i)\n      ar = dir_reduc(ar)\n      break\n  return ar\n    \n    ","lang_id":33,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5517fcb0236c8826940003c9":[{"id":214874,"user_id":759,"body":"import math\n\nproc sum_fracts*(a: seq[seq[int]]): string =\n  if a.len == 0: return \"0\"\n  var g = a[0][1]\n  for i in 1 ..< a.len:\n    g = lcm(g, a[i][1])\n  var s = 0\n  for x in a:\n    s += x[0] * (g div x[1])\n  let g2 = gcd(s, g)\n  g = g div g2\n  s = s div g2\n  if g == 1:\n    result = $s\n  else:\n    result = $s & '\/' & $g","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214875,"user_id":53,"body":"from math import gcd, lcm\nimport sequtils, strutils, sugar\n\nproc reduce*(a, b: int64): seq[int64] =\n  let i = gcd(a, b)\n  result = newSeq[int64](2)\n  result[0] = a div i\n  result[1] = b div i\n  \nproc norm*(a, b, cd: int64): seq[int64] =\n  result = newSeq[int64](2)\n  result[0] = a * (cd div b)\n  result[1] = cd\n  \nproc convertFracts*(a: seq[seq[int]]): seq[seq[int64]] =\n  let xss = a.map(arr => reduce(int64(arr[0]), int64(arr[1])))\n  let cd = foldl(xss, lcm(b[1], a), int64(1))\n  let yss = xss.map(xs => norm(xs[0], xs[1], cd))\n  result = yss\n  \nproc sum_fracts*(arr: seq[seq[int]]): string =\n  if arr.len == 0:\n    result = \"0\"\n  else:\n    let xss = convertFracts(arr)\n    let d = xss[0][1]\n    let n = foldl(xss, a + b[0], int64(0))\n    let g = gcd(d, n)\n    if g == d:\n      result = \"$1\".format(n div d)\n    else:\n      result = \"$1\/$2\".format(n div g, d div g)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214876,"user_id":492,"body":"import math, sequtils, strutils\n    \nproc sum_fracts*(a: seq[seq[int]]): string =\n    if a == @[]:\n        return \"0\"\n    var simp: seq[seq[int]] = @[]\n    for _, aa in a:\n        let g = gcd(aa[0], aa[1])\n        simp.add(@[aa[0] div g, aa[1] div g])\n    let ldenom = map(simp, proc(x: seq[int]): int = x[1])\n    let lcmu = int64(foldl(ldenom, lcm(a, b)))\n    var sm: int64 = 0\n    for _, x in simp:\n        sm += int64(x[0] * (lcmu div int64(x[1])))\n    let \n        gc = gcd(sm, lcmu)\n        num = sm div gc\n        den = lcmu div gc\n    if den == 1:\n        return \"$1\".format(num)\n    return \"$1\/$2\".format(num, den) ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214877,"user_id":null,"body":"import\n  math,\n  sequtils,\n  strformat\n  \n\n#Codewars has Nim 1.0 - this proc taken from 1.2 source\nproc lcm*[T](x: openArray[T]): T =\n  result = x[0]\n  var i = 1\n  while i < x.len:\n    result = lcm(result, x[i])\n    inc(i)\n\n\nproc convertFracts*(a: seq[seq[int]]): seq[seq[int64]] =\n  # Borrowed from previous kata - code reuse!!\n  result = a.mapIt @[int64(it[0] div gcd(it[0], it[1])), int64(it[1] div gcd(it[0], it[1]))]\n  let lcd = lcm result.mapIt it[1]\n  result.applyIt @[lcd div it[1] * it[0], lcd]\n\n\nproc sum_fracts*(a: seq[seq[int]]): string =\n  if a.len < 1:\n    result = \"0\"\n  else:\n    let acd = convertFracts a #Input with common denominators\n    let num = sum acd.mapIt it[0] #sum of numerators\n    let den = acd[0][1] #lowest common denominator\n    let ans = @[num div gcd(num, den), den div gcd(num, den)] #reduced\n    if ans[1] == 1: #Integer\n      result = $ans[0]\n    else:\n      result = &\"{$ans[0]}\/{$ans[1]}\"\n\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214878,"user_id":null,"body":"import rationals\n\nproc sum_fracts*(a: seq[seq[int]]): string =\n  var x = 0 \/\/ 1\n  for f in a:\n    x += f[0] \/\/ f[1]\n  reduce(x)\n  if x.den == 1:\n    $(x.toInt())\n  else:\n    $x\n  ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214879,"user_id":null,"body":"func gcd(a: int, b:int): int =\n  if a == 0 or b == 0:\n    1\n  elif a mod b != 0:\n    gcd(b, a mod b)\n  else:\n    b\n    \nproc `\/\/=`(a: var int, b: int): void =\n  a = a div b\n\nproc sum_fracts*(a: seq[seq[int]]): string =\n  var\n    n: int = 0\n    d: int = 1\n  \n  for frac in a:\n    n = n*frac[1] + d*frac[0]\n    d *= frac[1]\n    let rat = gcd(n, d)\n    n \/\/= rat\n    d \/\/= rat\n    \n  result = $n\n  if d != 1:\n    result &= \"\/\" & $d","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5539fecef69c483c5a000015":[{"id":214880,"user_id":53,"body":"import math\nimport sequtils\n\nproc isPrime(n: int): bool = \n  if n mod 2 == 0: return n == 2\n  for i in countup(3, ceil(sqrt(n.toFloat())).toInt(), 2):\n    if n mod i == 0: return false\n  return true\n\nproc reverseDigits(n: int): int =\n  var m = n\n  var r = 0\n  while m > 0:\n    r = r * 10\n    r = r + m mod 10\n    m = m div 10\n  return r\n\nproc isPalindromic(n: int): bool =\n  return n == reverseDigits(n)\n\nproc backwardsPrime*(start, stop: int): seq[int] =\n  var res: seq[int] = @[]\n  for i in start..stop:\n    if isPrime(i) and not isPalindromic(i) and isPrime(reverseDigits(i)):\n      res.add(i)\n  return res","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214881,"user_id":null,"body":"import math, sequtils, strutils, unicode\n\nfunc isPrime(num: int): bool =\n    num > 1 and (2 .. sqrt(num.toFloat).toInt).allIt(num %% it > 0)\n\nfunc isReversePrime(num: int): bool =\n    if num >= 13 and isPrime(num):\n        let revNum = ($num).reversed.parseInt\n        result = revNum != num and isPrime(revNum)\n\nfunc backwardsPrime*(start, stop: int): seq[int] =\n    (start .. stop).toSeq.filter(isReversePrime)\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214882,"user_id":null,"body":"import std\/math\n\nfunc sqrt(x: int): int =\n  ## computes integer square root\n  int(sqrt(float(x)))\n\nfunc reverse(x: int): int =\n  var x: int = x\n\n  while x >= 10:\n    result = result + (x mod 10)     \n    result = result * 10 \n    x = x div 10\n  result = result + x\n\nfunc isPrime(x: int): bool =\n  if x < 2: return\n  if x mod 2 == 0: return x == 2\n\n  result = true\n  for i in countup(3, sqrt(x), 2):\n    if x mod i == 0:\n      result = false\n      break\n\nfunc isEmirp(x: int): bool =\n  ## returns true for a prime number `x` that results in a\n  ## different prime when its decimal digits are reversed\n  if x < 13: return\n\n  if x.isPrime:\n    let rev = reverse(x)\n    if rev != x and rev.isPrime:\n      result = true\n\nfunc backwardsPrime*(start, stop: int): seq[int] =\n  ## returns sequence of primes which are also backwards primes\n  for n in start..stop:\n    if n.isEmirp:\n      result.add(n)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214883,"user_id":null,"body":"import std\/[strutils, algorithm, math]\n\n    \nproc isPrime(num: int): bool =\n  result = true\n  let ub: int = int(\n    sqrt(float(num))\n  )\n  for i in 2..ub:\n    if num mod i == 0:\n      return false\n\n\nproc isPalindrome(s: string): bool =\n  result = true\n  let bound: int = s.len div 2\n  \n  for i in 0..bound:\n    if s[i] != s[^(i+1)]:\n      return false\n\n\nproc backwardsPrime*(start, stop: int): seq[int] =\n  var\n    snum: string\n    start: int = start\n    rev: int\n  \n  if start < 13:\n    start = 13\n  \n  for num in start..stop:\n    if not num.isPrime:\n      continue\n    \n    snum = $num\n    \n    if snum.isPalindrome:\n      continue\n    \n    # backwards prime check\n    reverse(snum)\n    rev = parseInt(snum)\n    if not rev.isPrime:\n      continue\n    \n    result.add(num)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214884,"user_id":null,"body":"import math\n\nproc backwardsPrime*(start, stop: int): seq[int] =\n  func reversed(n: int): int =\n    var k = n\n    while likely(k > 0):\n      result *= 10\n      result.inc k mod 10\n      k = k div 10\n\n  func prime(n: int): bool =\n    if n mod 2 == 0:\n      return false\n    for k in countup(3, sqrt(n.float).int, 2):\n      if unlikely(n mod k == 0):\n        return false\n    return true\n\n  var\n    x = start\n    k: int\n  if x mod 2 == 0:\n    x.inc\n  for n in countup(x, stop, 2):\n    if unlikely(prime(n)):\n      k = reversed(n)\n      if likely(k != n) and unlikely(prime(k)):\n        result.add n\n  ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214885,"user_id":3398,"body":"import algorithm\nimport math\nimport options\nimport strUtils\n\ntype\n  PrimeState = object\n    numbers: seq[int]\n\nproc fillUntil(state: var PrimeState, until: int) =\n  let last = state.numbers[^1]\n  if last < until:\n    # assumes that last != 2 so it is not even\n    for i in countup(last, until, 2):\n      var prime = true\n      for p in state.numbers:\n        if i %% p == 0:\n          prime = false\n          break\n      if prime:\n        state.numbers.add(i) \n\nproc newPrimeState(): PrimeState =\n  result = PrimeState()\n  result.numbers = @[2, 3]\n\nproc isPrime(state: var PrimeState, number: int): bool =\n  let sqr = sqrt(number.float).int\n  state.fillUntil(sqr)\n  for v in state.numbers:\n    if number == v:\n      return true\n    elif number %% v == 0:\n      return false\n    elif v > sqr:\n      break\n  return true\n\nfunc reverse(i: int): Option[int] =\n  let asStr = i.intToStr()\n  if asStr[^1] == '0':\n    result = none(int)\n  else:\n    let val = asStr.reversed().join().parseInt()\n    result = some(val)\n\nproc backwardsPrime*(start, stop: int): seq[int] =\n  let sqr = sqrt(stop.float).int\n  var s = newPrimeState()\n  for i in start..stop:\n    let r = reverse(i)\n    if r.isSome:\n      let v = r.get()\n      let isDuplicate = i >= v and v >= start and v <= stop\n      if not isDuplicate and s.isPrime(i) and s.isPrime(v):\n        result.add(i)\n        if v <= stop and v >= start:\n          result.add(v)\n  result.sort()\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214886,"user_id":null,"body":"import math\nimport sequtils\n\nvar primeFactors = @[2, 3, 5, 7, 11, 13]\nvar maxPrimeFactor = primeFactors[^1]\n\nproc populatePrimeFactors(num: int) =\n\n    for f in maxPrimeFactor+1 .. num:\n        \n        if primeFactors.allIt(f %% it > 0):\n            primeFactors.add f\n            maxPrimeFactor = f\n\nproc isPrime(num: int): bool =\n    let limit = sqrt(num.toFloat).toInt\n    populatePrimeFactors(limit)\n    primeFactors.filterIt(it <= limit).allIt(num %% it > 0)\n\nproc reverse(num: int): int =\n\n    var n = num\n    result = 0\n\n    while n > 0:\n        result *= 10 \n        result += n %% 10\n        n = n div 10\n    \nproc isReversePrime(num: int): bool =\n    if num > 10 and isPrime(num):\n        let revNum = reverse(num)\n        revNum != num and isPrime(revNum)\n    else:\n        false\n\nproc backwardsPrime*(start, stop: int): seq[int] =\n    var start = start\n    if start < 13:\n        start = 13\n\n    for n in start .. stop:\n        if isReversePrime(n):\n            result.add n\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214887,"user_id":null,"body":"import math, sugar, unicode, sequtils, strutils\n\nproc backwardsPrime*(start, stop: int): seq[int] =\n  func isPrime(x: int): bool =\n    x > 1 and all(toSeq(2..toInt(sqrt(toFloat(x)))), n => x mod n != 0)\n  func isBackwardsPrime(x: int): bool =\n    let y = parseInt(reversed($x))\n    isPrime(x) and isPrime(y) and x != y\n  filter(toSeq(start..stop), isBackwardsPrime)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214888,"user_id":null,"body":"import math\nimport algorithm\nimport strutils\nproc isPrime(num: int): bool=\n  for i in 2..ceil(sqrt(num.toFloat())).toInt():\n    if num mod i == 0:\n      return false\n  return true\n\nproc reverseNumber(num: int): int=\n  @($num).reversed().join().parseInt()\n  \nproc backwardsPrime*(start, stop: int): seq[int] =\n    for i in start..stop:\n      if i.reverseNumber() != i and i.isPrime() and i.reverseNumber().isPrime():\n        result.add(i)\n    ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214889,"user_id":null,"body":"import algorithm, strutils, sets, sequtils\n\nproc isPrime*(n: int): bool =\n  if n <= 3: return n > 1\n  elif n mod 2 == 0 or n mod 3 == 0: return false\n  \n  var i = 5\n  while i * i <= n:\n    if n mod i == 0 or n mod (i + 2) == 0:\n      return false\n    i.inc 6\n  return true\n\nproc backwardsPrime*(start, stop: int): seq[int] =\n  for i in start .. stop:\n    let iRev = parseInt(reversed($i).join(\"\"))\n    if i < 10 or i == iRev: continue\n    if i.isPrime and iRev.isPrime: \n      result.add i","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5541f58a944b85ce6d00006a":[{"id":214890,"user_id":null,"body":"proc product_fib*(prod: uint64): seq[uint64] =\n  var\n    a = 0'u64\n    b = 1'u64\n  while a * b < prod:\n    (a, b) = (b, a + b)\n  @[a, b, uint64(a * b == prod)]","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214891,"user_id":null,"body":"proc product_fib*(prod: uint64): seq[uint64] =\n  var \n    a = 0'u64\n    b = 1'u64\n  while a * b < prod:\n    (a, b) = (b, a + b)\n  return @[a, b, (a * b == prod).uint64]","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214892,"user_id":76,"body":"proc product_fib*(prod: uint64): seq[uint64] =\n  var \n    a: uint64 = 0\n    b: uint64 = 1\n  \n  while a * b < prod:\n    swap a, b\n    b += a\n    \n  return @[a, b, if a * b == prod: 1 else: 0]","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214893,"user_id":null,"body":"proc product_fib*(prod: uint64): seq[uint64] =\n    var a = 1u64\n    var b = 1u64\n    while true:\n        if b * (a + b) == prod:\n            return @[b, a+b, 1u64]\n        if b * (a + b) > prod:\n            return @[b, a+b, 0u64]\n        b += a\n        a = b - a","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214894,"user_id":null,"body":"iterator fib(): uint64 =\n  var n1: uint64 = 0\n  var n2: uint64 = 1\n  yield n1\n  yield n2\n  while true:\n    let tmp = n1\n    n1 = n2\n    n2 = tmp + n1\n    yield n2\n\nproc product_fib*(prod: uint64): seq[uint64] =\n  var last: uint64 = 0\n  for n in fib():\n    let val = last * n\n    if val == prod:\n      return @[last, n, 1]\n    if val > prod:\n      return @[last, n, 0]\n    last = n","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214895,"user_id":null,"body":"proc product_fib*(prod: uint64): seq[uint64] =\n  var \n    prev_fib = 0'u64\n    cur_fib = 1'u64\n  while prev_fib * cur_fib < prod:\n    (prev_fib, cur_fib) = (cur_fib, cur_fib + prev_fib)\n  return @[prev_fib, cur_fib, ord(prev_fib * cur_fib == prod).uint64]\n","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214896,"user_id":null,"body":"proc product_fib*(prod: uint64): seq[uint64] =\n    var\n      n0 = 0'u64\n      n1 = 1'u64\n    while n0*n1 < prod:\n      (n0, n1) = (n1, n0+n1)\n    return @[n0, n1, uint64(n0*n1==prod)]","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214897,"user_id":null,"body":"proc product_fib*(prod: uint64): seq[uint64] =\n  var n = @[uint64(0), uint64(1)]\n  while n[0]*n[1] <= prod:\n    if n[0]*n[1] == prod:\n      return @[n[0], n[1], 1]\n    n = @[n[1], n[0]+n[1]]\n  return @[n[0], n[1], 0]\n    ","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214898,"user_id":53,"body":"import sequtils, sugar\n\nproc product_fib*(n: uint64): seq[uint64] =\n  var ans = newSeq[uint64](3)\n  ans[1] = 1\n  while ans[0] * ans[1] < n:\n    ans[1] = ans[0] + ans[1]\n    ans[0] = ans[1] - ans[0]\n  if ans[0] * ans[1] == n:\n    ans[2] = 1\n  return ans","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214899,"user_id":null,"body":"proc product_fib*(prod: uint64): seq[uint64] =\n  result = @[1'u64, 1'u64, if prod == 1: 1'u64 else: 0'u64]\n  while result[0] * result[1] < prod:\n    swap result[0], result[1]\n    result[1] = result[0] + result[1]\n  result[2] = if result[0] * result[1] == prod: 1 else: 0\n","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5544c7a5cb454edb3c000047":[{"id":214900,"user_id":492,"body":"proc bouncing_ball*(h, bounce, window: float64): int =\n    if ((h <= 0) or (window >= h) or (bounce <= 0) or (bounce >= 1)):\n        return -1\n    var seen = -1; var hh = h\n    while (hh > window):\n        seen += 2\n        hh *= bounce\n    return seen","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214901,"user_id":null,"body":"import math\n\nproc bouncing_ball*(h, bounce, window: float64): int =\n  if (h <= 0 or bounce <= 0 or \n      bounce >= 1 or window >= h): return -1\n  1 + 2 * ((window \/ h).log(bounce) - 0.00001).floor().int","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214902,"user_id":527,"body":"from math import ceil, ln\n\nproc bouncing_ball*(h, bounce, window: float64): int =\n  if h > 0 and 0 < bounce and bounce < 1 and window < h:\n    (ln(window \/ h) \/ ln(bounce)).ceil.toInt * 2 - 1\n  else:\n    -1","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214903,"user_id":null,"body":"proc bouncing_ball*(h, bounce, window: float64): int =\n  if window >= h or h <= 0 or bounce < 0 or bounce >= 1:\n    return -1\n  else:\n    var\n      count = 0\n      h_p = h\n    while h_p > window:\n      count += 1\n      var next_h = h_p * bounce\n      if next_h > window:\n        count += 1\n      h_p = next_h\n    return count","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214904,"user_id":76,"body":"proc bouncing_ball*(h, bounce, window: float64): int =\n  if h <= 0 or bounce <= 0 or bounce >= 1 or window >= h:\n    return -1\n  var height = h\n  while height > window:\n    inc result\n    height *= bounce\n  2 * result - 1","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214905,"user_id":null,"body":"proc bouncing_ball*(h, bounce, window: float64): int =\n  if h <= 0:\n    return -1\n  if bounce >= 1 or bounce <= 0:\n    return -1\n  if window >= h:\n    return -1\n  var n = 1\n  var h = h * bounce\n  while h > window:\n    h *= bounce\n    n += 2\n  return n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214906,"user_id":null,"body":"proc bouncing_ball*(h, bounce, window: float64): int =\n    if h <= 0 or bounce <= 0 or bounce >= 1 or window >= h:\n      return -1\n    var height = h\n  \n    while height > window:\n      result = result + 1\n      height = height * bounce\n      if height > window:\n        result = result + 1","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214907,"user_id":null,"body":"proc bouncing_ball*(h, bounce, window: float64): int =\n  if (h <= 0 or bounce <= 0 or bounce >= 1 or window >= h):\n    return -1\n  return 2 + bouncing_ball(h*bounce, bounce, window)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214908,"user_id":null,"body":"proc bouncing_ball*(h, bounce, window: float64): int =\n    if not (h > 0 and bounce > 0 and bounce < 1 and window < h):\n        return -1\n    var h = h\n    while h > window:\n        result += 2 \n        h *= bounce\n    result -= 1","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214909,"user_id":null,"body":"import math\nproc bouncing_ball*(h, b, w: float64): int =\n  if h > 0.0 and b > 0.0 and b < 1.0 and w < h:\n    1 + 2*floor(log(w \/ h, 2)\/log(b, 2) - 1e-15).int\n  else:\n    -1\n    ","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5545f109004975ea66000086":[{"id":214910,"user_id":527,"body":"proc is_divisible*(n, x, y: int): bool =\n  n mod x == 0 and n mod y == 0","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214911,"user_id":null,"body":"proc is_divisible*(n, x, y: int): bool =\n  return (n mod x == 0) and (n mod y == 0)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214912,"user_id":null,"body":"proc is_divisible*(n, x, y: int): bool =\n   ((n mod x) or (n mod y)) == 0 ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214913,"user_id":null,"body":"proc is_divisible*(n, x, y: int): bool = \n  (n %% x == 0) and (n %% y == 0)\n#  discard # your code here","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214914,"user_id":null,"body":"proc is_divisible*(n, x, y: int): bool =\n  return n %% x + n %% y == 0","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214915,"user_id":null,"body":"proc is_divisible*(n, x, y: int): bool =\n  (n mod y == 0) and (n mod x == 0)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214916,"user_id":53,"body":"proc is_divisible*(n, x, y: int): bool =\n  return n %% x == 0 and n %% y == 0;","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214917,"user_id":null,"body":"proc is_divisible*(n, x, y: int): bool =\n  if n mod x == 0 and n mod y == 0: true else: false","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214918,"user_id":null,"body":"proc is_divisible*(n, x, y: int): bool =\n  return ((n mod x) + (n mod y)) == 0","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214919,"user_id":null,"body":"proc is_divisible*(n, x, y: int): bool =\n  if n mod x == 0 and n mod y == 0: return true\n  else: return false\n    ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"55466989aeecab5aac00003e":[{"id":214920,"user_id":53,"body":"import sequtils\nimport math\n\nproc sq_in_rect*(x, y: int): seq[int] =\n  var arr: seq[int]\n  if (x == y):\n    return arr\n  var a = x\n  var b = y\n  while (a > 0 and b > 0):\n    var l = max(a, b)\n    var w = min(a, b)\n    a = w\n    b = l - w\n    arr.add(w)\n  return arr","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214921,"user_id":492,"body":"proc sq_in_rect*(lng, wdth: int): seq[int] =\n    var lg = lng; var wd = wdth\n    if lg == wd:\n        return @[]\n    if lg < wd:\n        swap(wd, lg)\n    var res: seq[int] = @[]\n    while lg != wd:\n        res.add(wd)\n        lg -= wd\n        if lg < wd:\n            swap(wd, lg)\n    res.add(wd)\n    return res","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214922,"user_id":76,"body":"proc sq_in_rect*(length, width: int): seq[int] =\n  var \n    l = length\n    w = width\n  if l == w: return @[]\n  while l > 0 and w > 0:\n    let size = [l, w].min\n    result.add(size)\n    if l > w:\n      l -= size\n    else:\n      w -= size","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214923,"user_id":null,"body":"proc sq_in_rect*(lng, wdth: int, is_first_call: bool = true): seq[int] =\n  let (a, b) = (max(lng, wdth), min(lng, wdth))\n  if (a == b and is_first_call) or b == 0: return\n  @[b] & sq_in_rect(b, a - b, false)\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214924,"user_id":null,"body":"proc sq_in_rect*(lng, wdth: int): seq[int] =\n  if lng == wdth:\n    return\n  var (l, w) = (lng, wdth)\n  while l != w:\n    add(result, min(l, w))\n    if l > w:\n      l -= w\n    else:\n      w -= l\n  result & l","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214925,"user_id":null,"body":"proc sq_in_rect*(m, n: int): seq[int] =\n  if m == n:\n    return @[]\n\n  var\n    m2 = m\n    n2 = n\n    a: seq[int] = @[]\n\n  while true:\n    if m2 < n2: \n      n2 -= m2\n      a.add(m2)\n    else:\n      m2 -= n2\n      a.add(n2)\n\n    if m2 <= 0 or n2 <= 0:\n      return a","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214926,"user_id":null,"body":"func sq_in_rect*(lng, wdth: int): seq[int] =\n  if lng == wdth:\n    # special case\n    return @[]\n  var\n    (a, b) = (lng, wdth)\n  while min(a, b) > 0:\n    # we can fit another square\n    let biggest = min(a, b)\n    result.add biggest\n    if b > a:\n      b -= biggest\n    else:\n      a -= biggest","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214927,"user_id":null,"body":"proc sq_in_rect(lng, wdth, first: int): seq[int] =\n    \n    var i_lng = max(lng,wdth)\n    var i_wdth = min(lng,wdth)\n    \n    #echo i_lng\n    #echo i_wdth\n    result.add(i_wdth)\n    if(i_wdth>=1):\n      result.add(sq_in_rect(i_lng-i_wdth,i_wdth,1))\n    else:\n      return @[]\nproc sq_in_rect*(lng, wdth: int): seq[int] =\n    if lng==wdth: return @[]\n    sq_in_rect(lng,wdth,1)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214928,"user_id":null,"body":"proc sq_in_rect*(lng, wdth: int): seq[int] =\n    var r: seq[int]\n    var l = lng\n    var w = wdth\n    while l != w and l != 0 and w != 0:\n        if w > l:\n            var w1 = w mod l\n            for i in 0..<((w - w1) div l):\n                r.add(l)\n            w = w1\n        else:\n            var l1 = l mod w\n            for i in 0..<((l - l1) div w):\n                r.add(w)\n            l = l1\n    return r","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5547cc7dcad755e480000004":[{"id":214929,"user_id":76,"body":"from math import `mod`\nfrom algorithm import sort\n\nproc remove_nb*(n: int): seq[seq[int]] =\n  let s = n * n.succ div 2\n  for a in 1 .. n:\n    let b = (s - a) \/ (a + 1)\n    if b.int <= a: break\n    if b mod 1.0 == 0 and b.int < n:\n      result.add(@[a, b.int])\n      result.add(@[b.int, a])\n  result.sort(proc(a, b: auto): int = cmp(a[0], b[0]))","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214930,"user_id":null,"body":"proc remove_nb*(n: int): seq[seq[int]] =\n  var sum = 0\n  for i in 1..n:\n    sum += i\n\n  for x in 2..<n:\n    let y = (sum - x) div (x + 1)\n    if y < n and x * y == sum - x - y:\n      result.add(@[x, y])\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214931,"user_id":null,"body":"import math\n\nproc remove_nb*(n: int): seq[seq[int]] =\n  let s = int((1 + n) * n \/ 2)\n  for a in 1 .. n:\n    let x = (s - a) \/ (a + 1)\n    if x == floor(x):\n      let b = int(x)\n      if b <= n:\n        result.add @[a, b]\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214932,"user_id":53,"body":"proc remove_nb*(n: int): seq[seq[int]] =\n  let m = int(n * (n + 1) \/ 2)\n  var ans: seq[seq[int]] = @[]\n  for x in 1..n:\n    let y = int((m - x) \/ (x + 1))\n    if (y <= n and x * y == m - x - y):\n      ans.add(@[x, y])            \n  return ans","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214933,"user_id":492,"body":"proc remove_nb*(n: int): seq[seq[int]] =\n    let s = int(n * (n + 1) \/ 2)\n    let limit = int(n \/ 2)\n    var res: seq[seq[int]] = @[]\n    for a in limit..n:\n        let b = s - a\n        if (b %% (a + 1) == 0):\n            res.add( @[a, b div (a + 1)] )            \n    return res","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214934,"user_id":492,"body":"proc remove_nb*(n: int): seq[seq[int]] =\n    let s = int(n * (n + 1) \/ 2)\n    let limit = int(n \/ 2)\n    var res: seq[seq[int]] = @[]\n    for a in limit..n:\n        let b = s - a\n        if (b %% (a + 1) == 0):\n            res.add( @[a, b div (a + 1)] )            \n    return res","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"554a44516729e4d80b000012":[{"id":214935,"user_id":53,"body":"import math, sequtils\n\nproc nb_months*(startPriceOld, startPriceNew, savingperMonth: int, percentLossByMonth: float64): seq[int] =\n  var p0 = float(startPriceOld)\n  var p1 = float(startPriceNew)\n  let s = savingperMonth\n  var r = percentLossByMonth\n  var m = 0\n  while p0 + float(m * s) < p1:\n    if m mod 2 == 1:\n      r = r + 0.5\n    p0 = p0 - p0 * 0.01 * r\n    p1 = p1 - p1 * 0.01 * r\n    m = m + 1\n  @[m, int(round(p0 + float(m * s) - p1))]","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214936,"user_id":492,"body":"import math\n\nproc nb_months*(startPriceOld, startPriceNew, savingperMonth: int, percentLossByMonth: float64): seq[int] =\n    var mth = 0\n    var priceOld = float64(startPriceOld)\n    var priceNew = float64(startPriceNew)\n    var available = float64(startPriceOld)\n    var p = percentLossByMonth\n    while (available < priceNew):\n        # at the end of this month\n        mth += 1\n        if (mth %% 2 == 0):\n            p += 0.5\n        priceOld = priceOld * (100.0 - p)  \/ 100.0\n        priceNew = priceNew * (100.0 - p)  \/ 100.0\n        available = float64(mth * savingperMonth) + priceOld\n    return @[mth, int(math.round(available - priceNew))]\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214937,"user_id":null,"body":"import math\n\nproc nb_months*(startPriceOld, startPriceNew, savingperMonth: int, percentLossByMonth: float64): seq[int] =\n  var\n    o = startPriceOld.float64\n    n = startPriceNew.float64\n    p = percentLossByMonth\n    month = 0\n    money = 0\n  while float64(money) + o < n:\n    month.inc\n    if month mod 2 == 0:\n      p += 0.5\n    money += savingperMonth\n    o = o * (1 - p \/ 100)\n    n = n * (1 - p \/ 100)\n  return @[month, round(money.float64 + o - n).int]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214938,"user_id":null,"body":"import math\nimport strformat\n\nproc nb_months*(startPriceOld, startPriceNew, \n               savingperMonth: int, percentLossByMonth: float64\n               ): seq[int] =\n  let \n    savingperMonth = savingperMonth.float  \n  var \n    months = 0.0\n    monthClock = 0\n    percentLoss = percentLossByMonth \/ 100\n    percent = 1.0\n    baseValue = (startPriceOld - startPriceNew).float\n  while baseValue * percent + (savingperMonth * months) < 0.0:\n    months += 1.0\n    monthClock += 1\n    if monthClock == 2:\n      monthClock = 0\n      percentLoss += 0.005\n    percent *= (1.0-percentLoss)\n  return @[months.int, round(baseValue * percent + (savingperMonth * months)).int]\n    ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214939,"user_id":null,"body":"import math\n\nproc nb_months*(startPriceOld, startPriceNew, savingperMonth: int, percentLossByMonth: float64): seq[int] =\n    # your code\n    var car_price_new: float = float(startPriceNew)\n    var car_price_old: float = float(startPriceOld)\n    var cash = 0.0\n    var loss_percent = percentLossByMonth\n    \n    var n: int\n    \n    while car_price_old + cash < car_price_new:\n      n += 1\n      if (n mod 2) == 0:\n        loss_percent += 0.5\n      cash += float(savingperMonth)\n      car_price_new *= (1 - loss_percent \/ 100)\n      car_price_old *= (1 - loss_percent \/ 100)\n      \n    result.add(n)\n    result.add(int(round(car_price_old + cash - car_price_new, 0)))\n      \n    ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214940,"user_id":null,"body":"import strformat\n\nproc nb_months*(startPriceOld, startPriceNew, savingPerMonth: int, \n               percentLossByMonth: float64): seq[int] =\n  var monthNum = 0\n  var money = 0.0\n  var oldPrice = toFloat(startPriceOld)\n  var newPrice = toFloat(startPriceNew)\n  var percentLoss = percentLossByMonth\n\n  while (money + oldPrice) < newPrice:\n    monthNum += 1\n    money += toFloat(savingPerMonth)\n    oldPrice -= oldPrice * (percentLoss \/ 100)\n    newPrice -= newPrice * (percentLoss \/ 100)\n    echo (fmt\"end month {monthNum}: percentLoss {percentLoss} available {money + oldPrice - newPrice}\")\n\n    if monthNum mod 2 == 1:\n      percentLoss += 0.5\n  return @[monthNum, toInt((money + oldPrice) - newPrice)]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214941,"user_id":null,"body":"proc nb_months*(startPriceOld, startPriceNew, savingperMonth: int, percentLossByMonth: float64): seq[int] =\n  var price_old = toFloat(startPriceOld)\n  var price_new = toFloat(startPriceNew)\n  # Easier to work with as a decreasing multiplier than an increasing percentage.\n  var loss_factor = 1 - (percentLossByMonth \/ 100)\n  var months = 0\n  var available = price_old - price_new\n\n  while available < 0:\n    months += 1\n    if months mod 2 == 0:\n      loss_factor -= 0.005\n    price_old *= loss_factor\n    price_new *= loss_factor\n    available = toFloat(months * savingperMonth) + price_old - price_new\n\n  return @[months, toInt(available)]\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214942,"user_id":null,"body":"import math\n\nfunc nb_months*(\n        startPriceOld,\n        startPriceNew,\n        savingperMonth: int,\n        percentLossByMonth: float64): seq[int] =\n\n    func check(\n            currentPriceOld: float,\n            currentPriceNew: float,\n            currentLossByMonth: float64,\n            month: int): seq[int] =\n        let\n            delta = if month mod 2 > 0: 0.0 else: 0.005\n            savings = savingperMonth * month\n            left = savings.float + currentPriceOld - currentPriceNew\n        return if left < 0: check(\n                                currentPriceOld * (1.0 - currentLossByMonth),\n                                currentPriceNew * (1.0 - currentLossByMonth),\n                                currentLossByMonth + delta,\n                                month+1)\n                else: @[month, left.round.int]\n    return check(\n            startPriceOld.float,\n            startPriceNew.float,\n            percentLossByMonth \/ 100,\n             0)\n\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"554f76dca89983cc400000bb":[{"id":214943,"user_id":53,"body":"import math\n\nproc sol_equa*(n: int): seq[seq[int]] =\n  let m = int(sqrt(n.float).floor())\n  for i in 1..m:\n    let d = float(n) \/ float(i)\n    let x = (d + float(i)) \/ 2.0\n    let y = (d - float(i)) \/ 4.0\n    if (d == float(int(d)) and x == float(int(x)) and y == float(int(y))):\n      result.add(@[int(x), int(y)])","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214944,"user_id":492,"body":"proc sol_equa*(n: int): seq[seq[int]] =\n    var res: seq[seq[int]] = @[]; var i = 1\n    while i * i <= n:\n        if n %% i == 0:\n            let j = n div i\n            if (i + j) %% 2 == 0 and (j - i) %% 4 == 0:\n                let x = (i + j) div 2\n                let y = (j - i) div 4\n                res.add(@[x, y])\n        i += 1\n    return res","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214945,"user_id":null,"body":"iterator factors2(n: int): tuple[a, b: int] =\n  ## All pairs of natural numbers `a`, `b`, `a <= b`, such `ab = n`\n  var d = 1\n  while d * d <= n:\n    if n mod d == 0:\n      yield (a: d, b: n div d)\n    inc d\n\nproc sol_equa*(n: int): seq[seq[int]] =\n  for (a, b) in factors2(n):\n    if (b - a) mod 4 == 0:\n      result.add(@[(a + b) div 2, (b - a) div 4])","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214946,"user_id":null,"body":"import math\n\nproc sol_equa*(n: int): seq[seq[int]] =\n\n    let limit = n.toFloat.sqrt.toInt\n\n    if limit * limit == n:\n        result.add(@[limit, 0])\n    \n    #find a such that a and b is an integer where a = x + 2y, b = x - 2y and a * b = n\n    for a in 1 ..< limit:\n        if n %% a == 0:\n            let \n                b = n div a\n                twox = a + b\n                foury = b - a\n\n            if twox %% 2 == 0 and foury %% 4 == 0:\n                result.add(@[twox div 2, foury div 4])\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5552101f47fc5178b1000050":[{"id":214947,"user_id":null,"body":"import math, strutils\n\nproc dig_pow*(n, p: int): int =\n  var p = p\n  for c in $n:\n    # Conver char c to string using &\"\"\n    result+=parseInt(c&\"\") ^ p\n    p+=1\n  if result mod n == 0: result div n\n  else: -1","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214948,"user_id":null,"body":"from math import pow\nfrom strutils import intToStr\n\nproc dig_pow*(n, p: int): int =\n    result = -1\n    let s = n.intToStr\n    var sum = 0\n    for i in 0..<s.len:\n        sum += pow((s[i].int - 48).float, (p + i).float).int\n    if sum mod n == 0:\n        result = sum div n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214949,"user_id":492,"body":"import strutils, math\n\nproc dig_pow*(n, p: int): int =\n    var sum = 0.0\n    for i, c in intToStr(n):\n        sum += pow(parseFloat($c), float64(p + i))\n    let m = int(sum)\n    if m %% n == 0:\n        return m div n\n    return -1","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214950,"user_id":53,"body":"import sequtils\nimport strutils\nimport math\n\nproc dig_pow*(n, p: int): int =\n  var digits = toSeq(intToStr(n).items)\n  var res = 0\n  for i, digit in digits.pairs:\n    let digit = (digit.ord - '0'.ord)\n    res = res + int(pow(float(digit), float(p + i)))\n  if res %% n == 0:\n    return int(res \/ n)\n  return -1","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214951,"user_id":76,"body":"import math\n\nproc dig_pow*(n, p: int): int =\n  var s = 0\n  for i, c in $n:\n    s += (c.ord - '0'.ord) ^ (p + i)\n  if s mod n == 0: s div n else: -1","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214952,"user_id":null,"body":"import math\n\nproc dig_pow*(n, p: int): int =\n  var\n    n1 = n\n    p1 = p\n    x = 10 ^ int(log10(n1.toFloat))\n    s = 0\n    d: int\n  while n1 > 0:\n    d = n1 div x\n    s += d ^ p1\n    n1 = n1 mod x\n    x = x div 10\n    inc p1\n  if s mod n == 0:\n    return s div n\n  else:\n    return -1\n    ","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214953,"user_id":null,"body":"import math, strutils\n\nproc get_digits(num: int): seq =\n  var digits: seq = newSeq[int]()\n  for d in intToStr(num):\n    let d: string = $d\n    digits.add(d.parseInt)\n  return digits\n  \n\nproc dig_pow*(n, p: int): int =\n  var sol: int = 0\n  for i, d in get_digits(n):\n    let pow: int = p + i\n    sol += d^(pow)\n  if sol mod n == 0:\n      return toInt(sol\/n)\n  return -1","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214954,"user_id":null,"body":"import math\n\nproc getNumSequence(n: int): seq[int] =\n  let numChars: int = floor(log10(n.float32)).int + 1\n  var s: seq[int] = @[]\n  newSeq(s, numChars)\n  \n  var i = numChars - 1\n  var num: int = n\n  \n  while num > 0:\n    s[i] = num mod 10\n    num = num div 10\n    i = i - 1\n\n  echo(s)\n  return s\n\n\nproc dig_pow*(n: int, p: int): int =\n  var countP = p\n  var sumPows: float64 = 0.0\n\n  for num in getNumSequence(n):\n    sumPows += pow(num.float64, countP.float64)\n    countP += 1\n  \n  var res: float64 = sumPows \/ n.float64\n  if res mod 1 == 0:\n    return res.int\n  else:\n    return -1\n  \n  \n","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214955,"user_id":null,"body":"import strutils\nimport sequtils\nimport math\n\nproc dig_pow*(n, p: int): int =\n  let sum = toSeq(pairs(intToStr(n))).mapIt(parseInt($it[1])^(p+it[0])).foldl(a+b)\n  return (if sum mod n != 0: -1 else: sum div n)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214956,"user_id":null,"body":"import sequtils, strutils, math\n\nproc dig_pow*(n, p: int): int =\n  let\n    digits = toSeq(n.intToStr.items).mapIt(parseInt($it))\n    powers = toSeq(p..(p - 1 + digits.len))\n    digits_powers_zip = zip(digits, powers)\n    powers_sum = sum(digits_powers_zip.mapIt(it[0] ^ it[1]))\n  \n  if powers_sum mod n == 0:\n    return int(powers_sum \/ n)\n  else:\n    return -1","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"555624b601231dc7a400017a":[{"id":214957,"user_id":76,"body":"proc josephus_survivor*(n: int, k: int): int =\n  if n > 0:\n    (josephus_survivor(n.pred, k) + k.pred) mod n + 1\n  else:\n    1","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214958,"user_id":null,"body":"proc josephus_survivor*(n: int, k: int): int =\n  if n == 1:\n    1\n  else:\n    (josephus_survivor(n - 1, k) + k - 1) mod n + 1","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214959,"user_id":53,"body":"proc josephus_survivor*(n: int, k: int): int =\n  if (n == 1):\n    return n\n  else:\n    return (josephus_survivor(n - 1, k) + k - 1) %% n + 1 ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214960,"user_id":null,"body":"import sequtils\n\nproc josephus_survivor*(n: int, k: int): int =\n  var \n    a = toSeq(1..n)\n    i = 0\n  while a.len > 1:\n    i = (i+k-1) mod a.len\n    a.delete(i)\n  result = a[0]\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214961,"user_id":50,"body":"proc josephus_survivor*(n: int, k: int): int =\n  var a = 0\n  for i in 2..n:\n    a = (a+k)%%i\n  a+1\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214962,"user_id":null,"body":"proc josephus_survivor*(n, k: int): int =\n  for i in 2..n:\n    result = (result + k) mod i\n  return result + 1","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214963,"user_id":null,"body":"import sequtils\n\nproc josephus_survivor*(n: int, k: int): int =\n  var a = (1..n).toSeq\n  var i = 0\n  while a.len > 1:\n    i = (i + k - 1) mod a.len\n    a.delete(i)\n    \n  return a[0]\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214964,"user_id":null,"body":"proc josephus_survivor*(n: int, k: int): int =\n  var idx = -1 #Start before 0-index\n  var lst: seq[int]\n  for x in 1 .. n: lst.add(x) #Populate\n  while (lst.len > 1):\n    idx.inc(k)\n    while idx >= lst.len: idx = idx-lst.len\n    lst.delete idx\n    idx.dec() #Delete adjust\n  result = lst[0] #Always the last one","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214965,"user_id":759,"body":"proc josephus_survivor*(n: int, k: int): int =\n  result = 1\n  if n > 1:\n    result += (josephus_survivor(n-1, k) + k - 1) mod n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214966,"user_id":527,"body":"from sequtils import foldl\n\nproc josephus_survivor*(n: int, k: int): int =\n  (1..n).foldl((a + k) mod b, 1) + 1","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5592e3bd57b64d00f3000047":[{"id":214967,"user_id":76,"body":"from math import `^`\n\nproc find_nb*(m: int64): int =\n  var s = 0'i64\n  var i = 1\n  while s < m:\n    s += i ^ 3\n    inc i\n  if s == m: i - 1 else: -1","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214968,"user_id":null,"body":"import std\/math\nproc find_nb*(m: int64): int = \n  # O(1) time solution\n\n  # m = 0.25*result^4 is a very accurate upper bound\n  # solving for result, it equals 4*m^0.25\n  # as far as I can see, it is off by at most 0.5\n  # and I've checked up to m = 10^20, so I think that's good\n  \n  # to check for the -1 case,\n  # I check if the sum of cubes formula points back at m\n  # the sum of n cubes is (n)^2(n+1)^2\/4 = (n(n+1))^2\/4\n  result = int(floor(pow(4.0*m.float, 0.25))) \n  if ((result*(result+1))^2 div 4) != m: return -1","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214969,"user_id":null,"body":"proc find_nb*(m: int64): int =\n    # your code\n  proc powthree(a:int64):int64=\n    return a*a*a\n  var mm = m\n  var nn = 1\n  while true:\n    if mm<0:\n      return -1\n    else:\n      mm = mm - powthree(nn)\n      if mm==0:\n        return nn\n      nn=nn+1","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214970,"user_id":null,"body":"proc find_nb*(m: int64): int =\n  var k = 0\n  var n = 1\n  \n  while m > k:\n    k += n * n * n\n    if k == m:\n      return n\n    else:\n      n += 1\n  return -1","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214971,"user_id":53,"body":"proc find_nb*(m: int64): int =\n  var s = 0\n  var n = 0\n  while s < m:\n    n = n + 1\n    s = s + n * n * n\n  if s == m:\n    n\n  else:\n    -1","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214972,"user_id":null,"body":"import math\n\nproc find_nb*(m: int64): int =\n  var v = 0\n  while v < m:\n    result += 1\n    v += result ^ 3\n  if v != m:\n    result = -1","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214973,"user_id":null,"body":"proc find_nb*(m: int64): int =\n    # your code\n    var sum = 0\n    var i = 1\n    while sum < m:\n      sum += i * i * i\n      i += 1\n    result = -1\n    if sum == m:\n      result = i - 1","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214974,"user_id":null,"body":"import math\n\nproc find_nb*(m: int64): int =\n    let x = int(math.pow(float(4*m), 0.25))\n    if x*x*(x+1)*(x+1) == 4*m: return x\n    return -1","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214975,"user_id":null,"body":"func sqrt(x:cdouble):cdouble{.header:\"<math.h>\",importc.}\n{.passL:\"-lm\".}\n\nproc find_nb*(m: int64): int =\n  let n = (sqrt(1+8*sqrt(m.cdouble))-1)\/2\n  if n == float(n.int):\n    return n.int\n  -1","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214976,"user_id":null,"body":"proc find_nb*(m: int64): int=\n  var tot = 1\n  var n = 1\n  while tot < m:\n    n += 1\n    tot += n * n * n\n  if tot == m:\n    return n\n  else:\n    return -1\n    ","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"559536379512a64472000053":[{"id":214977,"user_id":492,"body":"import strutils\n\nproc play_pass*(s: string, n: int): string =\n    proc reversedString(s: string): string =\n        result = newString(s.len())\n        for i,c in s:\n            result[s.high - i] = c\n            \n    var firstSteps = \"\"\n    for c in toLowerAscii(s):\n        if isDigit(c):\n            firstSteps &= char(105 - int(c))\n        else:\n            if isAlphaAscii(c):\n                let shifted = char(int('a') + ((int(c) - int('a') + n) %% 26))\n                first_steps &= shifted                \n            else:\n                first_steps &= c\n    var lastStep = \"\"\n    for i, c in firstSteps:\n        if i %% 2 == 0:\n            lastStep &= toUpperAscii(c)\n        else:\n            lastStep &= toLowerAscii(c)            \n    return reversedString(lastStep)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214978,"user_id":null,"body":"import std\/strutils\n\nfunc getCharForGame(c: char, n: int, i: int): char =\n  if isUpperAscii(c):\n    result = char((int(c) - int('A') + n) mod 26 + int('A'))\n\n    if i mod 2 == 1:\n      result = toLowerAscii(result)\n\n  elif isLowerAscii(c) and i mod 2 == 0:\n    result = char((int(c) - int('a') + n) mod 26 + int('a'))\n\n    if i mod 2 == 0:\n      result = toUpperAscii(result)\n\n  elif isDigit(c):\n    result = char(9 - (int(c) - int('0')) + int('0'))\n\n  else:\n    result = c\n\nproc play_pass*(s: string, n: int): string =\n  for i, c in s:\n    result = getCharForGame(c, n, i) & result","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214979,"user_id":null,"body":"import strutils,sequtils, unicode\n\nproc play_pass*(s: string, n: int): string =\n    # your code\n  proc char_shift(c:char): char =\n    if c.isLowerAscii:\n      char(((c.ord - 'a'.ord + n + 26) mod 26) + 'a'.ord)\n    elif c.isUpperAscii:\n      char(((c.ord - 'A'.ord + n + 26) mod 26) + 'A'.ord)      \n    else:\n      c\n    \n  proc digit_complement(c:char): char = \n    if c.isDigit: char('9'.ord - c.ord + '0'.ord)\n    else: c\n  \n  var s = s.map(char_shift).map(digit_complement).join(\"\")\n  for i,c in s.mpairs:\n    if (i mod 2) == 1: c = c.toLowerAscii\n    else: c = c.toUpperAscii\n  s.reversed","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214980,"user_id":null,"body":"import std\/[strutils, algorithm]\n\nproc play_pass*(s: string, n: int): string = \n    for i, c in s:\n        let d =\n            case c\n            of 'a'..'z': chr('a'.ord + (c.ord + n - 'a'.ord) mod 26)\n            of 'A'..'Z': chr('A'.ord + (c.ord + n - 'A'.ord) mod 26)\n            of '0'..'9': chr(9 - c.ord + '0'.ord*2)\n            else: c\n        result.add(if i mod 2 == 0: d.toUpperAscii else: d.toLowerAscii)\n    reverse(result)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214981,"user_id":null,"body":"import std\/strutils\nimport std\/algorithm\n\nproc play_pass*(s: string, n: int): string = \n    result = \"\"\n    for i, c in s:\n        var d: char\n        case c\n        of 'a'..'z':\n            d = chr('a'.ord + (c.ord + n - 'a'.ord) mod 26)\n        of 'A'..'Z':\n            d = chr('A'.ord + (c.ord + n - 'A'.ord) mod 26)\n        of '0'..'9':\n            d = chr(9 - c.ord + '0'.ord*2)\n        else:\n            d = c\n        result.add(if i mod 2 == 0: d.toUpperAscii else: d.toLowerAscii)\n    reverse(result)\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214982,"user_id":null,"body":"import strutils\nimport unicode\n\nproc play_pass*(s: string, n: int): string =\n  var\n    shift = \"\"\n    lowerUpper = \"\"\n  \n  for i in toUpper(s):\n    if ord(i) >= 65 and ord(i)  <= 90:\n        shift.add(chr((ord(i) - 65 + n) mod 26 + 65))\n    elif i == ' ':\n        shift.add(\" \")\n    elif i.isDigit:\n        var num = 9 - parseInt($i)\n        shift.add($num)\n    else:\n        shift.add(i)\n\n  for index, i in shift:\n    if ord(i) >= 65 and ord(i)  <= 90:\n      if index mod 2 == 1: \n        lowerUpper.add(i.toLowerAscii)\n      else:\n            lowerUpper.add(i)\n    else:\n      lowerUpper.add(i)\n      \n  result = lowerUpper.reversed\n    ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214983,"user_id":null,"body":"import std\/strutils\nimport std\/sequtils\nimport std\/algorithm\n\nproc play_pass*(s: string, n: int): string =\n    # your code\n  proc char_shift(c:char): char =\n    if c.isLowerAscii:\n      char(((c.ord - 'a'.ord + n + 26) mod 26) + 'a'.ord)\n    elif c.isUpperAscii:\n      char(((c.ord - 'A'.ord + n + 26) mod 26) + 'A'.ord)      \n    else:\n      c\n    \n  proc digit_complement(c:char): char = \n    if c.isDigit: char('9'.ord - c.ord + '0'.ord)\n    else: c\n  \n  var s = s.map(char_shift).map(digit_complement).join(\"\")\n  for i,c in s.mpairs:\n    if (i mod 2) == 1: c = c.toLowerAscii\n    else: c = c.toUpperAscii\n  s.reverse()\n  s","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214984,"user_id":null,"body":"const\n  alphaRange = 'A' .. 'Z'\n  lowerAlphaRange = 'a' .. 'z'\n  numRange = '0' .. '9'\n\nproc shift(c: var char, by: int) =\n  c = char((c.int + by - alphaRange.a.int) %%\n           (alphaRange.b.int - alphaRange.a.int + 1) + alphaRange.a.int)\n\nproc ninesComplement(c: var char) =\n  c = char(9 - (c.int - numRange.a.int) + numRange.a.int)\n\nproc lowercase(c: var char) =\n  c = char(lowerAlphaRange.a.int + c.int - alphaRange.a.int)\n\ntemplate encode(c: typed; idx, n: int): untyped =\n  if c in alphaRange:\n    shift c, by = n\n    if idx %% 2 == 1:\n      lowercase c\n  elif c in numRange:\n    ninesComplement c\n\nproc play_pass*(s: string, n: int): string =\n  var chars = @s\n  let h = high(chars)\n  let oddMidOffset = if h %% 2 == 0: -1 else: 0\n  # The oddMidOffset is used here to skip double\n  # \"encode\"ing the char at index h div 2 when\n  # the s len is odd (i.e. an even high).\n  for frontIdx in 0 .. h div 2 + oddMidOffset:\n    let backIdx = h - frontIdx\n    encode chars[frontIdx], frontIdx, n\n    encode chars[backIdx], backIdx, n\n    swap chars[frontIdx], chars[backIdx]\n  if oddMidOffset == -1:\n    encode chars[h div 2], h div 2, n\n  result = cast[string](chars)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214985,"user_id":null,"body":"import strutils\n\ntemplate lou(c: char; i: int): char =\n  if i mod 2 == 0:\n    c.toUpperAscii()\n  else:\n    c.toLowerAscii()\n\nfunc shiftc(c: char; n: int): char =\n  if n == 0:\n    return c\n\n  let tmp = int(c) + n\n\n  if tmp > 122 and c.isLowerAscii() or tmp > 90 and c.isUpperAscii():\n    result = char(tmp - 26)\n  else:\n    result = char(tmp)\n\nfunc play_pass*(s: string, n: int): string =\n  result = newString(s.len)\n\n  for i, c in s:\n    if c.isDigit():\n      result[^(i + 1)] = char(105 - int(c))\n    elif c in Letters:\n      result[^(i + 1)] = shiftc(c, n).lou(i)\n    else:\n      result[^(i + 1)] = c\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214986,"user_id":null,"body":"import\n  strutils,\n  algorithm\n\nproc play_pass*(s: string, n: int): string =\n  const CAPS = 'A'..'Z'\n  var shft = n\n  \n  proc newLetter(l:char):char =\n    # Assuming l is caps (ord 65-90)\n    var idx = ord(l)\n    idx.inc(shft)\n    if idx > 90: idx.dec(26)\n    result = char(idx)\n  \n  proc newNumber(n:char):char =\n    var nbr = ord(n) - 48\n    result = char(9-nbr+48)\n\n\n  #Adjust for out of range shifts\n  while shft > 26:\n    shft.dec(26)\n  while shft < 0:\n    shft.inc(26)\n  \n  #Steps 1, 2, 3\n  for c in s:\n    if c in CAPS:\n      result.add(newLetter(c))\n    elif c in Digits:\n      result.add(newNumber(c))\n    else:\n      result.add(c)\n  \n  #Step 4\n  for idx in 0 .. result.high:\n    if (idx mod 2 == 0): #idx is even\n      result[idx] = result[idx].toUpperAscii()\n    else:\n      result[idx] = result[idx].toLowerAscii()\n\n  #Step 5\n  result.reverse","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"559a28007caad2ac4e000083":[{"id":214987,"user_id":492,"body":"proc perimeter*(n: int): int64 =\n    var a = 1'i64; var b = 1'i64; var t = 1'i64; var i = 0\n    while (i < n + 2):\n        t = a + b; a = b; b = t; i += 1\n    return 4 * (a - 1'i64)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214988,"user_id":492,"body":"proc perimeter*(n: int): int64 =\n    var a = 1'i64; var b = 1'i64; var t = 1'i64; var i = 0\n    while (i < n + 2):\n        t = a + b; a = b; b = t; i += 1\n    return 4 * (a - 1'i64)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214989,"user_id":76,"body":"proc perimeter*(n: int): int64 =\n  var \n    a = 1\n    b = 1\n  \n  for i in 0 .. n:\n    result += a\n    swap a, b\n    b += a\n  \n  result *= 4","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214990,"user_id":null,"body":"proc perimeter*(n: int): int64 =\n  var (a, b) = (0, 1)\n  for _ in 0..n:\n    result += 4 * b\n    (a, b) = (b, a + b)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214991,"user_id":null,"body":"import sequtils\n\nproc perimeter*(n: int): int64 =\n  var s = @[1, 1]\n  for i in 2..n:\n    s.add(s[i-2] + s[i-1])\n  return 4 * s.foldl(a + b)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214992,"user_id":53,"body":"proc perimeter*(n: int): int64 =\n  var a: int64 = 1\n  var b: int64 = 1\n  var i = 0\n  while i < n + 2:\n    i += 1\n    var t = a + b\n    a = b\n    b = t\n  return 4 * (a - 1)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214993,"user_id":null,"body":"proc perimeter*(n: int): int64 =\n  var (a, b) = (0, 1)\n  for _ in 0..n:\n    (a, b) = (b, a + b)\n    result += a\n  4*result","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214994,"user_id":null,"body":"import sequtils\n\nproc perimeter*(n: int): int64 =\n  var fib = @[1'i64, 1'i64]\n  for _ in 2..n:\n    fib.add(fib[^2] + fib[^1])\n  fib.foldl(a + b) * 4\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214995,"user_id":null,"body":"import tables\n\nvar memo = initTable[int64, seq[int64]]()\n\nproc perimFib*(n: int64): (int64, int64) =\n  if n <= 1:\n    return (n * 4, n)\n  \n  if n in memo:\n    return (memo[n][0], memo[n][1])\n  \n  let (_, prev2Fib) = perimFib(n - 2)\n  let (prev1Perim, prev1Fib) = perimFib(n - 1)\n  let thisFib = prev2Fib + prev1Fib\n  let thisPerim = prev1Perim + thisFib * 4\n  memo[n] =  @[]\n  memo[n].add(thisPerim)\n  memo[n].add(thisFib)\n  return (thisPerim, thisFib)\n\nproc perimeter*(n: int): int64 =\n  let (res,_) =  perimFib(n+1)\n  return res","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214996,"user_id":null,"body":"import sequtils\nimport sugar\nimport math\nfunc fib(n:int): seq[int]=\n  var a = 1\n  var b = 1\n  for i in 0..n:\n    result.add(a)\n    (a,b)=(b,a+b)\n    \nproc perimeter*(n: int): int64 =\n  sum(map(fib(n), x=>x*4))\n  \n    ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"559b8e46fa060b2c6a0000bf":[{"id":214997,"user_id":492,"body":"import math\nproc binom(n, k: int64): int64 =\n  result = 1\n  for i in 1..k:\n    result = result * (n - int64(i) + 1) div int64(i)\nproc diagonal*(n, p: int64): int64 =\n    result = binom(n + 1, p + 1)\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214998,"user_id":53,"body":"proc diagonal*(n, p: int64): int64 =\n  var r: int64 = 1'i64\n  for i in 1..p + 1:\n      r = r * (n - i + 2) div i\n  r","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":214999,"user_id":null,"body":"proc diagonal*(n, p: int64): int64 =\n  result = n-p+1\n  for i in 2 .. p+1:\n    result = result * (n-p+i) div i","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":215000,"user_id":492,"body":"import math\nproc binom(n, k: int64): int64 =\n  result = 1\n  for i in 1..k:\n    result = result * (n - int64(i) + 1) div int64(i)\nproc diagonal*(n, p: int64): int64 =\n    result = binom(n + 1, p + 1)\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":215001,"user_id":null,"body":"{.emit: \"\"\"\nunsigned long c(int n, int k) {\n    long double x = 1;\n    int m = n - k;\n    if (k < m) {\n        int t = k;\n        k = m;\n        m = t;\n    }\n    if(k == n) {\n        return 1;\n    }\n    while(n > k || m > 1) {\n        n > k ? x *= n-- : 0 ;\n        m > 1 ? x \/= m-- : 0 ;\n    }\n    return (unsigned long)(x + 0.9);\n}\n\"\"\".}\n\nfunc c(n, k: cint): culong {.importc.}\n\nproc diagonal*(n, p: int64): int64 =\n  c(cint(n + 1), cint(p + 1)).int64\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215002,"user_id":null,"body":"proc diagonal*(n, p: int64): int64 =\n  var val = 1i64\n  result = 1i64\n  for i in 1..(n-p):\n    val = (val * (p+i)) div i\n    result += val","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215003,"user_id":null,"body":"proc binomialCoeff(n, k: int64): int64 =\n  result = 1\n  for i in 1..k:\n    result = result * (n-i+1) div i\n\nproc diagonal*(n, p: int64): int64 =\n  var sum: int64 = 0\n  for i in 0..n:\n    sum += binomialCoeff(i, p)\n  return sum","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215004,"user_id":null,"body":"from sequtils import repeat\nfrom math import sum\n\nproc diagonal*(l, k: int64): int64 =\n  let n = l - k + 1\n  var diagonal = repeat(1'i64, n.int)\n  for i in 1..k.int:\n    for j in 1..<n.int:\n      diagonal[j] += diagonal[j - 1]\n  \n  sum(diagonal)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215005,"user_id":null,"body":"proc diagonal*(n, p: int64): int64 = # your code\n  var l : int64 = n - p\n  var d : seq[int64] = @[]\n  for i in 0..l:\n    d.add(0)\n  for i in 0..p:\n    d[0] = 1\n    result = 1\n    for k in 1..l:\n      var j = (int)k\n      d[j] = d[j] + d[j-1]\n      result += d[j]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215006,"user_id":759,"body":"from math import binom\n\nproc diagonal*(n, p: int64): int64 =\n  for i in p..n:\n    result += i.int.binom(p.int)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"559ce00b70041bc7b600013d":[{"id":215007,"user_id":527,"body":"proc finance*(n: int): int =\n  n * (n + 1) * (n + 2) div 2","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215008,"user_id":492,"body":"proc finance*(n: int): int = \n  int(n * (n + 1) * (n + 2) \/ 2)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215009,"user_id":null,"body":"proc finance*(n: int): int =\n  var\n    week, day = 0\n  while week < n:\n    day = 0\n    week.inc(1)\n    while day <= n:\n      day.inc(1)\n      result.inc(day)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215010,"user_id":null,"body":"proc finance*(n: int): int =\n  for k in 0 .. n:\n    result += (3 * k + n) * (n + 1 - k) div 2\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215011,"user_id":null,"body":"proc finance*(n: int): int =\n  var start = 0\n  var fin = n\n  for k in 0..n:\n    for i in start..fin:\n      result += i\n    start += 2\n    fin += 1","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215012,"user_id":null,"body":"proc finance*(dayInWeek: int): int =\n  var sum: int = 0\n\n  for step in 0..dayInWeek:\n    sum += step * (step+1)\n    sum += (dayInWeek + 1 - step)*step\n\n  sum\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215013,"user_id":null,"body":"proc finance*(n: int): int = # your code\n  for w in 0..n:\n    for i in 0..(n-w):\n      result += 2 * w + i","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215014,"user_id":null,"body":"proc finance*(n: int): int =\n  for i in 0..2*n:\n    result += i * (min(i div 2, n - (i + 1) div 2) + 1)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215015,"user_id":759,"body":"proc finance*(n: int): int =\n  for i in 0..n:\n    for j in i..n:\n      result += i + j","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"559e3224324a2b6e66000046":[{"id":215016,"user_id":492,"body":"proc suMin*(m: int): int64 =\n    let n = int64(m)\n    return n * (n+1) * (2 * n + 1) div 6\n\nproc suMax*(m: int): int64 =\n    let n = int64(m)\n    return n * (n+1) * (4 * n - 1) div 6\n\nproc sumSum*(m: int): int64 =\n    let n = int64(m)\n    return n * n * (n + 1)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215017,"user_id":76,"body":"proc suMin*(n: int): int64 =\n  for i in 1 .. n:\n    for j in 1 .. n:\n      result += min(i, j)\n\nproc suMax*(n: int): int64 =\n  for i in 1 .. n:\n    for j in 1 .. n:\n      result += max(i, j)\n  \nproc sumSum*(n: int): int64 =\n  suMin(n) + suMax(n)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215018,"user_id":null,"body":"proc suMin*(m: int): int64 =\n    for i in 1 .. m:\n        for j in 1 .. m:\n            if i <= j: result += i\n            else: result += j\n      \nproc suMax*(m: int): int64 =\n    for i in 1 .. m:\n        for j in 1 .. m:\n            if i >= j: result += i\n            else: result += j\n\nproc sumSum*(m: int): int64 =\n    result = suMin(m) + suMax(m)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215019,"user_id":53,"body":"proc suMin*(m: int): int64 =\n    var n = int64(m)\n    return n * (n+1) * (2 * n + 1) div int64(6)\n\nproc suMax*(m: int): int64 =\n    var n = int64(m)\n    return n * (n+1) * (4 * n - 1) div int64(6)\n\nproc sumSum*(m: int): int64 =\n    var n = int64(m)\n    return (n+1) * n * n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215020,"user_id":null,"body":"proc suMin*(m: int): int64 =\n  for x in 1..m:\n    for y in 1..m:\n      result += min(x, y)\n\nproc suMax*(m: int): int64 =\n  for x in 1..m:\n    for y in 1..m:\n      result += max(x, y)\n      \nproc sumSum*(m: int): int64 =\n  for x in 1..m:\n    for y in 1..m:\n      result += x + y","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"55a29405bc7d2efaff00007c":[{"id":215021,"user_id":76,"body":"proc going*(n: int): float64 =\n  result = 1\n  for i in 2 .. n:\n    result = result \/ i.float + 1\n  result = int(result * 1_000_000) \/ 1_000_000","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215022,"user_id":53,"body":"proc f*(n: int): float64 =\n    var t = float64(0)\n    var m = float64(1)\n    var i = n\n    while i > 0 and m < 1000000000:\n      t = t + (float64(1) \/ m)\n      m = m * float64(i)\n      i = i - 1\n    return t\n  \nproc going*(n: int): float64 =\n    return (float64(int64(f(n)*float(1000000))))\/float(1000000)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215023,"user_id":null,"body":"proc going*(n: int): float64 =\n  var x = 1.0\n  for k in 2 .. n:\n    x = x \/ float(k) + 1\n  return int(x * 1000000) \/ 1000000\n\n\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215024,"user_id":null,"body":"import sequtils\nimport sugar\nimport math\nimport strutils\nimport strformat\nproc fac(numerator,denominator:int): float64=\n  let s =(numerator+1..denominator).toSeq()\n  if s == @[]:\n    return 1.0\n  1.0\/(s.map(x=>x.toFloat()).foldl(a*b))\nproc going*(n: int): float64 =\n  # (1*2)\/(1*2*3) = 1\/3 because we can remove 1*2 from both numerator and denominator\n  result = 0\n  for i in countDown(n,1):\n    let res = fac(i,n)\n    result += res\n    if res<0.000_000_000_1:\n      break\n  #for rounding\n  if (result*1_000_000)-floor(result*1_000_000)>0.5:\n    result -= 0.000_000_5\n  return result.round(6)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215025,"user_id":759,"body":"import math\n\n{.warning[Deprecated]: off.}\n\nproc going*(n: int): float64 =\n  var j = 1.0\n  for i in countdown(n, 1):\n    result += 1.0 \/ j\n    j *= i.float64\n    if j >= 100_000_000:\n      break\n  result = trunc(result * 1_000_000) \/ 1_000_000","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215026,"user_id":492,"body":"import math\n\nproc going*(n: int): float64 =\n    var i = n\n    var res: float64 = 1.0\n    var inter: float64 = 1.0\n    while i >= 2:\n        inter *= (1.0 \/ float64(i))\n        res += inter\n        i -= 1\n    return math.floor(res * 1e6) \/ 1e6","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"55aa075506463dac6600010d":[{"id":215027,"user_id":53,"body":"import math\n\nproc list_squared*(m, n: int): seq[seq[int]] =\n    for i in m..n:\n      var xs: seq[int]\n      let k = int(sqrt(i.float).floor())\n      for j in 1..k:\n        if i mod j == 0: \n          xs.add(j ^ 2)\n          let l = i div j\n          if j != l:\n            xs.add(l ^ 2)\n      let s = xs.sum()\n      let sq = sqrt(s.float)\n      if sq == sq.round(): \n        result.add(@[i, s])","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215028,"user_id":76,"body":"from math import sqrt, `^`\n\nfunc divSum(n: int): int =\n  result = n ^ 2\n  for i in 1 .. n div 2:\n    if n mod i == 0:\n      result += i ^ 2\n\nproc list_squared*(m, n: int): seq[seq[int]] =\n  for i in m .. n:\n    let s = divSum i\n    if float64(s).sqrt.int ^ 2 == s:\n      result.add(@[i, s])","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215029,"user_id":null,"body":"import math\n\niterator divisors(n: int): int =\n  for k in 1 .. (n div 2):\n    if n mod k == 0:\n      yield k\n  yield n\n\nfunc isSquare(n: int): bool =\n  let k = sqrt(n.toFloat)\n  if k == floor(k):\n    true\n  else:\n    false\n\nproc list_squared*(m, n: int): seq[seq[int]] =\n  var t: int\n  for k in m .. n:\n    t = 0\n    for d in divisors(k):\n      t += d ^ 2\n    if t.isSquare():\n      result.add @[k, t]\n\n  \n  ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215030,"user_id":null,"body":"import math\n\nproc check(i: int): (int, int) =\n  var count = 0\n  var sumsquared = 0\n  for divisor in 1..i.toFloat.sqrt.int:\n    if i %% divisor == 0:\n      if i == divisor ^ 2:\n        count += 1\n        sumsquared += i\n      else:\n        count += 2\n        sumsquared += divisor ^ 2\n        sumsquared += (i div divisor) ^ 2\n  (count, sumsquared)\n  \nproc list_squared*(m, n: int): seq[seq[int]] =\n  for i in m..n:\n    let (count, sumsquared) = check(i)\n    if sumsquared.float.sqrt.int ^ 2 == sumsquared:\n      result &= @[i, sumsquared]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215031,"user_id":null,"body":"import math\n\nproc list_squared*(m, n: int): seq[seq[int]] =\n    for x in m..n:\n      var ds: seq[int]\n      for y in 1..x:\n        if x mod y == 0: ds.add(y ^ 2)\n      let t = ds.sum(); let s = sqrt(t.float)\n      if s == s.round(): result.add(@[x, t])","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215032,"user_id":492,"body":"import math\n\nproc list_squared*(m, n: int): seq[seq[int]] =\n    proc sumSquaredFactors(n: int): seq[int] =\n        var s = 0; var res: seq[int] = @[]; var i = 1\n        while (i <= int(math.floor(sqrt(float(n))))):\n            if (n %% i == 0):\n                s += i * i\n                let nf = n div i\n                if (nf != i):\n                    s += nf * nf\n            i += 1\n        let q = int(sqrt(float(s)))\n        if (int(pow(float(q), 2.0)) == s):\n            res.add(n)\n            res.add(s)\n            return res\n        else:\n            return @[]\n    var res: seq[seq[int]] = @[]; var i = m\n    while (i <= n):\n        let r = sumSquaredFactors(i)\n        if (r != @[]):\n            res.add(r)\n        i += 1\n    return res","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"55ab4f980f2d576c070000f4":[{"id":215033,"user_id":53,"body":"import strformat\n\nproc game*(n: int64): string =\n  var m = n * n;\n  var h = m div 2;\n  if n mod 2 == 0:\n    return &\"[{h}]\";\n  else:\n    return &\"[{m}, 2]\";","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215034,"user_id":492,"body":"import strutils\nproc game*(n: int64): string =\n  let m = n * n\n  if m %% 2 == 0:\n    result = \"[$1]\".format(m div 2)\n  else:\n    result = \"[$1, 2]\".format(m)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215035,"user_id":492,"body":"import strutils\nproc game*(n: int64): string =\n  let m = n * n\n  if m %% 2 == 0:\n    result = \"[$1]\".format(m div 2)\n  else:\n    result = \"[$1, 2]\".format(m)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215036,"user_id":null,"body":"import std\/strformat\nimport std\/sugar\n\nproc game*(n: int): string =\n  let\n    sum = (x: int) => int(x * (x + 1) \/ 2)\n    numerator = sum(n-1) * 2 + n\n    denominator = 2\n\n  if numerator mod denominator == 0:\n    fmt\"[{int(numerator \/ denominator)}]\"\n  else:\n    fmt\"[{numerator}, {denominator}]\"\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215037,"user_id":111,"body":"import strutils #why using \"strings\"; rather than -say- \"sequences\" ???\n\nproc game*(n: int): string =\n  if n mod 2 == 0:\n    \"[\" & intToStr(n*n div 2) & \"]\"\n  else:\n    \"[\" & intToStr(n*n) & \", 2]\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215038,"user_id":null,"body":"proc game*(n: int64): string = \"[\" & (if n mod 2 == 0: $(n*n div 2) else: $(n*n) & \", 2\") & \"]\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215039,"user_id":null,"body":"import math\n\nproc game*(n:int64):string =\n  if (n mod 2 == 0): #Even\n    return \"[\" & $(n div 2 * n) & \"]\"\n  return \"[\" & $(n^2) & \", 2]\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215040,"user_id":null,"body":"import rationals\n\nproc game*(n: int64): string =\n  var fractionsSum = 0'i64 \/\/ 1'i64\n  for counter in 1 ..< n:\n    fractionsSum += (counter \/\/ 2'i64) * 2\n  fractionsSum += n \/\/ 2'i64\n  \n  if fractionsSum.den == 1'i64:\n    return \"[\" & $fractionsSum.num & \"]\"\n  else:\n    return \"[\" & $fractionsSum.num & \", \" & $fractionsSum.den & \"]\"\n  ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215041,"user_id":null,"body":" proc game*(n: int64): string =\n  if n mod 2 == 0: result = \"[\" & $(n*(n div 2)) & \"]\"\n  else: result = \"[\" & $(n*n) & \", 2]\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215042,"user_id":null,"body":"import strutils\n\nproc game*(n: int64): string =\n  if n mod 2 == 0: result = \"[$1]\" % $(n * (n div 2))\n  else: result = \"[$1, 2]\" % $(n * n)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"55b3425df71c1201a800009c":[{"id":215043,"user_id":492,"body":"import strutils, algorithm, sequtils\n\nproc stat_assoc*(strg: string): string =\n    proc time2snd(s: string): int =\n        let \n            a = s.split(\"|\")\n            h = parseInt(a[0])\n            mn = parseInt(a[1])\n            sd = parseInt(a[2])\n        return 3600 * h + 60 * mn + sd\n    proc snd2time(n: int): string =\n        let\n            h = n div 3600\n            re = n %% 3600\n            mn = re div 60\n            s = re %% 60\n        #return fmt\"{h:02}|{mn:02}|{s:02}\" (strformat not available in 0.17)\n        return \"$1|$2|$3\".format(intToStr(h).align(2, '0'), intToStr(mn).align(2, '0'), intToStr(s).align(2, '0'))\n    proc average(a: seq[int]): float64 =\n        var total: float64 = float64(a.foldl(a + b))\n        return total \/ float64(a.len)\n\n    if strg == \"\":\n        return \"\"\n    let a =  strg.split(\", \")\n    var t: seq[int] = @[]\n    for _, tt in a: \n        t.add(time2snd(tt))\n    sort(t, system.cmp[int])\n    let lg = t.len()\n    let mean = int(average(t))\n    let md = (t[(lg - 1) div 2] + t[lg div 2]) div 2\n    let res = \"Range: $1\".format(snd2time(t[lg-1] - t[0])) & \n        \" Average: $1\".format(snd2time(mean)) & \n        \" Median: $1\".format(snd2time(md))\n    return res\n  \n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215044,"user_id":null,"body":"import algorithm, strutils, strformat, sequtils\n\nproc hms(ss: int): string =\n  var s = ss\n  result.add \"{s div 3600:>02}\".fmt\n  s = s mod 3600\n  result.add \"|{s div 60:>02}\".fmt\n  s = s mod 60\n  result.add \"|{s:>02}\".fmt\n\nproc pl(ll: seq[int]): string =\n  result.add \"Range: {hms(ll[^1] - ll[0])}\".fmt\n  result.add \" Average: {hms(foldl(ll, a + b) div ll.len)}\".fmt\n  let m = ll.len div 2\n  if ll.len mod 2 == 0:\n    result.add \" Median: {hms((ll[m] + ll[m - 1]) div 2)}\".fmt\n  else:\n    result.add \" Median: {hms(ll[m])}\".fmt\n\nproc stat_assoc*(strg: string): string =\n  if strg.len == 0: return \"\"\n  var\n    h, m, s: int\n    ltp: seq[int]\n  for t in strg.split(\", \"):\n    (h, m, s) = t.split(\"|\").map(parseint)\n    ltp.add(h * 3600 + m * 60 + s)\n  sort(ltp)\n  pl(ltp)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215045,"user_id":null,"body":"import strutils\nimport sequtils\nimport strformat\nimport stat_assocs\nimport algorithm\n\nfunc toS(h: int, m: int, s:int): int =\n    h * 60 * 60 + m * 60 + s\n  \nfunc toHMS(s: int): string =\n  let h = s div (60*60)\n  let m = (s-h*60*60) div 60\n  let sR = (s-h*60*60-m*60)\n  \n  return &\"{h:02}|{m:02}|{sR:02}\"\n  \nfunc getRange(results: openarray[int]): string =\n  let min = results.min\n  let max = results.max\n  \n  return (max-min).toHMS\n\nfunc getAvg(results: openarray[int]): string =\n  let m: int = results.foldl(a + b, 0) div results.len\n  return m.toHMS\n\nfunc getMedian(results: openarray[int]): string =\n  let sortedR = results.sorted\n  let halfLen = sortedR.len div 2\n                 \n  if sortedR.len mod 2 == 0:\n    return ((sortedR[halfLen-1]+sortedR[halfLen]) div 2).toHMS\n  else:\n    return sortedR[halfLen].toHMS\n\nproc stat_assoc*(strg: string): string =\n    if strg.len == 0:\n      return \"\"\n  \n    let rawResults = strg.split(\", \")\n  \n    var results: seq[int] = @[]\n    for r in rawResults:\n      let parts = r.split(\"|\").map(parseInt)\n      results.add(toS(parts[0], parts[1], parts[2]))\n    \n    let range = getRange(results)\n    let avg = getAvg(results)\n    let median = getMedian(results)\n    \n    return &\"Range: {range} Average: {avg} Median: {median}\"\n    \n    \n    ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215046,"user_id":null,"body":"import algorithm, math, sequtils, strutils, strformat, stat_assocs\n\nproc median(xs: seq[int]): int =\n  var ys = xs\n  sort(ys)\n  (ys[ys.high div 2] + ys[ys.len div 2]) div 2\n\nproc toSec(s: string): int = \n  var\n    toks = split(s, '|').map(parseInt) \n  toks[0] * 3600 + toks[1] * 60 + toks[2]\n\nproc fromSec(sec: int): string =\n  var\n    h = sec div 3600\n    m = sec div 60 mod 60\n    s = sec mod 60\n  &\"{h:02}|{m:02}|{s:02}\"\n\nproc stat_assoc*(s: string): string =\n  if s.len == 0: return \"\"\n  var \n    vals = sorted(split(s, \", \").map(toSec))\n    range = vals[^1]-vals[0]\n    average = floor(mean(vals)).int\n  return fmt\"Range: {fromSec(range)} Average: {fromSec(average)} Median: {fromSec(median(vals))}\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215047,"user_id":null,"body":"import strutils, strformat, sequtils, sugar, algorithm\n\nfunc resultstr_to_num(str: string): int =\n  str.strip.split('|').map(parseInt).foldl(a*60 + b)\n\nfunc num_to_resultstr(num: int): string =\n  fmt\"{num div (60*60):02}|{num div (60) mod 60:02}|{num mod 60:02}\"\n\nfunc median(arr: openArray[int]): int =\n  let sorted_arr = sorted(arr)\n  if sorted_arr.len mod 2 == 1:\n    sorted_arr[sorted_arr.len div 2]\n  else:\n    (sorted_arr[(sorted_arr.len - 1) div 2] + sorted_arr[(\n        sorted_arr.len) div 2]) div 2\n\nproc stat_assoc*(strg: string): string =\n  if strg.len == 0:\n    return \"\"\n  var parsed_results = strg.split(',').map(x => resultstr_to_num(x))\n  let ret_range = num_to_resultstr(max(parsed_results) - min(parsed_results))\n  let ret_mean = num_to_resultstr(parsed_results.foldl(a +\n      b) div parsed_results.len)\n  let ret_median = num_to_resultstr(median(parsed_results))\n  fmt\"Range: {ret_range} Average: {ret_mean} Median: {ret_median}\"\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215048,"user_id":null,"body":"import strutils, sequtils, math, algorithm\n\nfunc stat_assoc*(strg: string): string =\n    func formattedToSecs(personal: string): int =\n        var h, m, s: int\n        (h, m, s) = personal\n            .split(\"|\")\n            .toSeq\n            .map(parseInt)\n        return s + 60 * m + 60 * 60 * h\n    func secsToFormatted(sec: int): string =\n        const\n            perMin = 60\n            perHour = 60 * 60\n        let\n            h = sec.`\/`(perHour).floor.toInt\n            m = sec.mod(perHour).`\/`(perMin).floor.toInt\n            s = sec mod perMin\n        @[h, m, s].mapIt(($it).align(2, '0')).join(\"|\")\n    func getMedian(times: seq[int]): int =\n        let\n            length = times.len\n            half = length.`\/`(2).toInt - 1\n            halfValue = times[half]\n        return\n            if length mod 2 == 0: halfValue.`+`(times[half + 1]).`\/`(2).floor.toInt\n            else: halfValue\n\n    if strg == \"\": return \"\"\n    let\n        sorted = strg\n            .split(\", \")\n            .toSeq\n            .map(formattedToSecs)\n            .sorted(Ascending)\n        timeRange = sorted[^1].`-`(sorted[0]).secsToFormatted\n        average = sorted\n            .foldl(a+b)\n            .`\/`(sorted.len)\n            .floor\n            .toInt\n            .secsToFormatted\n        median = sorted.getMedian.secsToFormatted\n\n    return \"Range: \"&timeRange&\" Average: \"&average&\" Median: \"&median\n\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215049,"user_id":null,"body":"import strutils, sequtils, math, algorithm\n\nproc stat_assoc*(strg: string): string =\n    func formattedToSecs(personal: string): int =\n        var h, m, s: int\n        (h, m, s) = personal\n            .split(\"|\")\n            .toSeq\n            .map(parseInt)\n        return s + 60 * m + 60 * 60 * h\n    func secsToFormatted(sec: int): string =\n        let\n            h = (sec\/(60*60)).floor.toInt\n            m = ((sec - (60 * 60 * h))\/60).floor.toInt\n            s = sec - (60 * 60 * h) - (60 * m)\n        @[h, m, s].mapIt(($it).align(2, '0')).join(\"|\")\n    func getMedian(times: seq[int]): int =\n        let\n            length = times.len\n            half = (length\/2).toInt - 1\n        return\n            if length mod 2 == 0: ((times[half] + times[half + 1])\/2).floor.toInt\n            else: times[half]\n\n    if strg == \"\": return \"\"\n    let\n        sorted = strg\n            .split(\", \")\n            .toSeq\n            .map(formattedToSecs)\n            .sorted(Ascending)\n        timeRange = (sorted[^1] - sorted[0]).secsToFormatted\n        average = (sorted.foldl(a+b)\/sorted.len).floor.toInt.secsToFormatted\n        median = sorted.getMedian.secsToFormatted\n\n    return \"Range: \"&timeRange&\" Average: \"&average&\" Median: \"&median\n\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"55b4d87a3766d9873a0000d4":[{"id":215050,"user_id":53,"body":"import strformat\n\nproc howMuch*(m, n: int): string = \n  let a = min(m, n)\n  let b = max(m, n)\n  for i in a..b:\n    if i %% 9 == 1 and i %% 7 == 2:\n      result = result & fmt\"[M: {i} B: {i div 7} C: {i div 9}]\"\n  if result.len == 0:\n    result = \"[]\"\n  else:\n    result = fmt\"[{result}]\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215051,"user_id":492,"body":"import strutils\n\nproc howMuch*(m, n: int): string = \n    var i = min(m, n)\n    var j = max(m, n)\n    var res: seq[string] = @[]\n    while (i <= j):\n        if ((i %% 9 == 1) and (i %% 7 == 2)):\n            res.add(\"[M: $1 B: $2 C: $3]\".format(i, i div 7, i div 9))\n        i += 1\n    return \"[\" & join(res, \"\") & \"]\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215052,"user_id":null,"body":"import math, strformat\nproc howMuch*(m, n: int): string = \n  result = \"[\"\n  let s = max((if n > m: m else: n), 5)\n  let e = if n > m: n else: m\n  for i in s..e:\n    let b = (i - 2) \/ 7 \n    let c = (i - 1) \/ 9\n    if b mod 1 <= 0.001 and c mod 1 <= 0.001:\n      result &= fmt\"[M: {i} B: {b.int} C: {c.int}]\"\n  result &= \"]\"  ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215053,"user_id":759,"body":"proc howMuch*(m, n: int): string = \n  var res: seq[string]\n  var il = 2\n  var (m, n) = if m > n: (n, m) else: (m, n)\n  for x in m..n:\n    let\n      c = (x - 1) div 9\n      b = (x - 2) div 7\n    if (c * 9 + 1 == x) and (b * 7 + 2 == x):\n      let str = \"[M: \" & $x & \" B: \" & $b & \" C: \" & $c & \"]\"\n      il += str.len\n      res.add(str)\n  result = newString(il)\n  result[0] = '['\n  result[^1] = ']'\n  il = 1\n  for r in res:\n    result[il..il + r.len - 1] = r\n    il += r.len","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"55be10de92aad5ef28000023":[{"id":215054,"user_id":null,"body":"proc checkChoose*(m: int64, n: int): int =\n  var k: int64 = 1\n  if m == 1:\n    return 0\n  for x in 1 .. (n div 2):\n    k *= int64(n - x + 1)\n    k = k div int64(x)\n    if k == m:\n      return x\n  return -1\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215055,"user_id":53,"body":"proc checkChoose*(m: int64, n: int): int =\n    var res: int64 = 1\n    var i: int64 = 0\n    while i <= n:\n        if res == m:\n            return int(i)\n        res = int64(float(res) * (float(n) - float(i)) \/ (float(i) + float(1)))\n        i = i + 1\n    return -1","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215056,"user_id":492,"body":"proc checkChoose*(m: int64, n: int): int =\n    var c: int64 = 1'i64\n    for x in 0..n div 2 + 1:\n        if (c == m):\n            return x\n        c = c * (n-x) div (x+1)\n    -1\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"55c6126177c9441a570000cc":[{"id":215057,"user_id":527,"body":"from algorithm import sortedByIt\nfrom strutils import join, splitWhitespace\n\nproc sumOfDigits(s: string): int =\n  for c in s:\n    result += c.int - '0'.int\n\nproc order_weight*(s: string): string =\n  s.splitWhitespace.sortedByIt((it.sumOfDigits, it)).join(\" \")\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215058,"user_id":null,"body":"import sequtils, algorithm, strutils\n\nproc order_weight*(strng: string): string =\n    strng.split.sortedByIt(((it.mapIt(int(it)-int('0')).foldl(a+b)), it)).join(\" \")","lang_id":33,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215059,"user_id":76,"body":"from sequtils import foldl\nfrom algorithm import sorted\nfrom strutils import split, join\n\nfunc weight(s: string): int = \n  s.foldl(a + b.ord - '0'.ord, 0)\n\nfunc myCmp(a, b: string): int = \n  result = weight(a) - weight(b)\n  if result == 0:\n    result = cmp(a, b)\n\nproc order_weight*(strng: string): string =\n  sorted(strng.split, myCmp).join(\" \")","lang_id":33,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215060,"user_id":null,"body":"import algorithm, strutils, sequtils\n\nproc sum(s: string): int =\n  for i in s:\n    result += parseInt($i)\n\nproc myCmp(a, b: string): int =\n  return a.sum - b.sum\n\nproc order_weight*(strng: string): string =\n    var list = strng.split()\n    list.sort\n    list.sort myCmp\n    return list.join(\" \")\n","lang_id":33,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215061,"user_id":492,"body":"import strutils, algorithm\n\nproc order_weight*(strng: string): string =\n    type \n        weightStruct = object\n            name: string       \n            wght: int\n    proc comp(x, y: weightStruct): int =\n        if x.wght == y.wght:\n            return cmp(x.name, y.name)\n        return cmp(x.wght, y.wght)\n\n    if strng == \"\": return \"\"\n    let nums = split(strng, \" \")\n    var l1: seq[weightStruct] = newSeq[weightStruct](nums.len())\n    for i in countup(0, l1.len() - 1):\n        l1[i].name = nums[i]\n        var w = 0\n        for c in nums[i]:\n            w += int(c) - int('0')\n        l1[i].wght = w\n    l1.sort(comp)\n    var res = \"\"\n    for u in 0..< l1.len():\n        res &= l1[u].name & \" \"\n    return res[0..^2]","lang_id":33,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"55cbc3586671f6aa070000fb":[{"id":215062,"user_id":null,"body":"proc check_for_factor*(base, factor: int): bool =\n  base %% factor == 0","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215063,"user_id":null,"body":"proc check_for_factor*(base, factor: int): bool =\n  return base.mod(factor) == 0","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215064,"user_id":null,"body":"import std\/math\n\nproc check_for_factor*(base, factor: int): bool =\n  return floorMod(base, factor) == 0","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215065,"user_id":null,"body":"proc check_for_factor*(base, factor: int): bool =\n  if base mod factor != 0: return false\n  true","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215066,"user_id":null,"body":"proc check_for_factor*(base: int, factor: int): bool =\n  if base mod factor == 0:\n    return true\n  else:\n    return false","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215067,"user_id":null,"body":"proc check_for_factor*(base, factor: int): bool =\n  var check = base %% factor\n  if check > 0:\n    return false\n  else:\n    return true","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215068,"user_id":null,"body":"proc check_for_factor*(base, factor: int): bool =\n  result = base mod factor == 0","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215069,"user_id":null,"body":"proc check_for_factor*(base, factor: int): bool =\n  if base mod factor == 0:\n    return true\n  result = false\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215070,"user_id":null,"body":"proc check_for_factor*(base, factor: int): bool =\n  int(base \/ factor) * factor == base","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215071,"user_id":null,"body":"proc check_for_factor*[T](base, factor: T): bool = base mod factor == T(0)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"55d24f55d7dd296eb9000030":[{"id":215072,"user_id":759,"body":"proc summation*(num: int): int =\n  num * (num+1) div 2","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215073,"user_id":null,"body":"import math, sequtils\n\nproc summation*(num: int): int = sum(toSeq(1..num))","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215074,"user_id":null,"body":"import sequtils\nproc summation*(num: int): int = toSeq(1..num).foldl(a + b)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215075,"user_id":null,"body":"proc summation*(num: int): int =\n  return int((num * (num + 1) ) \/ 2);","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215076,"user_id":null,"body":"from math import sum\nfrom sequtils import toSeq\n\nproc summation*(num: int): int =\n  return sum(toSeq(1..num))","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215077,"user_id":null,"body":"proc summation*(num: int): int =\n  var i = 0\n  while i < num:\n    inc(i)\n    result += i\n    ","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215078,"user_id":null,"body":"proc summation*(num: int): int =\n  result = 0\n  for n in countup(1, num):\n    result += n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215079,"user_id":null,"body":"import sequtils\nproc summation*(num: int): int = (1..num).toSeq.foldl(a + b)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215080,"user_id":null,"body":"proc summation*(num: int): int =\n  for n in 1..num: inc(result, n)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215081,"user_id":76,"body":"proc summation*(num: int): int =\n  num * (num + 1) shr 1","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"55e2adece53b4cdcb900006c":[{"id":215082,"user_id":53,"body":"proc race*(v1, v2, g: int): array[0..2, int] =\n  if v1 >= v2:\n    result = [-1, -1, -1]\n  else:\n    var t = (g * 3600) div (v2 - v1)\n    var h = t div 3600\n    var m = (t %% 3600) div 60\n    var s = t %% 60\n    result = [h, m, s]","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215083,"user_id":null,"body":"proc race*(v1, v2, g: int): array[0..2, int] =\n  if v2 < v1:\n    return [-1, -1, -1]\n  let time = (3600 * g) div (v2 - v1)\n  result[0] =  time div 3600\n  result[1] = (time mod 3600) div 60\n  result[2] = (time mod 3600) mod 60","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215084,"user_id":676,"body":"proc race*(v1, v2, g: int): array[0..2, int] =\n  if v1 >= v2: return [-1, -1, -1]\n  let n = int(3600*g\/(v2 - v1))\n  let r = n mod 3600\n  return [int(n\/3600), int(r\/60), r mod 60]","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215085,"user_id":492,"body":"proc race*(v1, v2, g: int): array[0..2, int] =\n  result = [-1, -1, -1]\n  let d = v2 - v1\n  if d <= 0:\n    return result\n  else:\n    let h = g div d\n    let r = g %% d\n    let mn = (r * 60) div d\n    let s = ((r * 60 %% d) * 60) div d\n    result[0] = h\n    result[1] = mn\n    result[2] = s\n  ","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215086,"user_id":76,"body":"proc race*(v1, v2, g: int): array[0..2, int] =\n  if v1 >= v2: return [-1, -1, -1]\n  let diff = v2 - v1\n  [g div diff, (g \/ diff * 60).int mod 60, (g \/ diff * 3600).int mod 60]","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215087,"user_id":null,"body":"proc race*(v1, v2, g: int): array[0..2, int] =\n  var res: array[0..2, int]\n  if v1 >= v2:\n    res[0] = -1\n    res[1] = -1\n    res[2] = -1\n  else:\n    var secs = g * 3600 div (v2 - v1)\n    res[0] = secs div 3600\n    res[1] = (secs mod 3600) div 60\n    res[2] = secs mod 60\n  return res","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215088,"user_id":null,"body":"proc race*(v1, v2, g: int): array[0..2, int] =\n  if v1 >= v2: return [-1, -1, -1]\n\n  let secs = g * 3600 div (v2 - v1)\n  [secs div 3600, secs div 60 mod 60, secs mod 60]","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215089,"user_id":null,"body":"import \"math\"\n\nproc race*(v1, v2, g: int): array[3, int] =\n  if v1 > v2:\n    return [-1, -1, -1]\n  let seconds = floor(g \/ (v2 - v1) * 3600).toInt\n  [seconds div 3600 mod 60, seconds div 60 mod 60, seconds mod 60]\n","lang_id":33,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215090,"user_id":null,"body":"import math \n\nproc race*(v1, v2, g: int): array[0..2, int] = \n  if v2 <= v1: return [-1, -1, -1]\n  else: \n    let \n      d = v2 - v1\n      fs = floor((g.float \/ d.float) * 3600).int\n      h = fs div 3600\n      m = fs div 60 mod 60\n      s = fs mod 60\n    return [h, m, s]","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215091,"user_id":null,"body":"import math\n  \nfunc to_hms(hours: float64): array[0..2, int] =\n  let secs:int = int(hours * 60 * 60)\n  let h:int = secs div 3600\n  let m = (secs - h * 3600) div 60\n  let s = secs - h * 3600 - m * 60\n  [h, m, s]\n  \nproc race*(v1, v2, g: int): array[0..2, int] =\n  # g + v1 * sec = v2 * sec\n  # v1 * sec - v2 * sec = -g\n  # v2 * sec - v1 * sec = g\n  # sec * ( v2 - v1 ) = g\n  # sec = g \/ ( v2 - v1 )\n  var hours = g \/ (v2 - v1)\n  if hours < 0:\n    return [-1, -1, -1]\n  else:\n    return to_hms(hours)\n","lang_id":33,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"55e6f5e58f7817808e00002e":[{"id":215092,"user_id":492,"body":"proc seven*(n: int64): seq[int] =\n    var steps = 0; var m = n\n    while m > 99:\n        let q = m div 10; let r = m %% 10\n        m = q - (2 * r)\n        steps += 1\n    return @[int(m), int(steps)]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215093,"user_id":null,"body":"proc seven*(n: int64): seq[int] =\n  var i: int\n  var z: int64 = n\n  while z > 99:\n    i += 1\n    let x = z div 10\n    let y = z - x * 10\n    z = x - 2 * y\n  result.add z.int\n  result.add i","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215094,"user_id":76,"body":"proc seven*(n: int64): seq[int] =\n  var \n    steps = 0\n    m = n\n  \n  while m > 99:\n    inc steps\n    m = m div 10 - 2 * (m mod 10)\n    \n  @[m.int, steps]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215095,"user_id":null,"body":"proc seven*(n: int64): seq[int] =\n    var number: int = n.int\n    var counter = 0\n    while number >= 100:\n        var last = number mod 10\n        number = (number\/10).int\n        number = number - 2 * last\n        counter += 1\n\n    result.add(number)\n    result.add(counter)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215096,"user_id":null,"body":"proc seven*(n: int64): seq[int] =\n  var steps: int = 0\n  var ret = n\n  \n  while ret >= 100:\n    steps += 1\n    let m = ret mod 10\n    ret = ( ( ret - m ) div 10 ) - (2 * m)\n    \n  @[ret.int, steps]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215097,"user_id":53,"body":"proc seven*(n: int64): seq[int] =\n  var \n    cnt = 0\n    m = n\n  while m > 99:\n    (cnt, m) = (cnt + 1, (m div 10) - (2 * (m mod 10)))\n  return @[int(m), int(cnt)]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215098,"user_id":null,"body":"proc seven*(n: int64): seq[int] =\n  result = @[int(n), 0]\n  while result[0] >= 100:\n    result[0] = result[0] div 10 - result[0] mod 10 * 2\n    result[1] += 1","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215099,"user_id":null,"body":"proc seven*(n: int64): seq[int] =\n  var num = n\n  result = @[0,0]\n  if num < 100:\n    result = @[n.int, 0]\n  while num > 99:\n    num = num div 10'i64 - 2 * (num mod 10)\n    result = @[num.int, result[1]+1]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215100,"user_id":null,"body":"proc seven*(n: int64): seq[int] =\n  var \n    num = n\n    counter = 0\n  while num > 99:\n    let\n      a = num div 10\n      b = num %% 10\n    num = a - 2 * b\n    counter.inc\n  @[num.int ,counter]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215101,"user_id":null,"body":"import strutils, sequtils\n\nproc seven*(n: int64): seq[int] =\n  var \n    num = n\n    counter = 0\n  while num > 99:\n    let\n      a = ($num)[0..^2].parseInt\n      b = ($num)[^1].`$`.parseInt\n    num = a - 2 * b\n    counter += 1\n  @[num.int ,counter]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"55e7280b40e1c4a06d0000aa":[{"id":215102,"user_id":null,"body":"var sum = 0\nvar ans = -1\nproc backtrack(start, t, k: int, ls: seq[int]) = \n    if k == 0:\n        if sum <= t: \n            ans = max(ans, sum)\n        return\n    for i in start..<len(ls):\n        backtrack(i+1, t, k, ls)\n        sum += ls[i]\n        backtrack(i+1, t, k-1, ls)\n        sum -= ls[i]\n\nproc choose_best_sum*(t, k: int, ls: seq[int]): int =\n    # your code\n    if len(ls) < k: return -1\n    ans = -1\n    sum = 0\n    backtrack(0, t, k, ls)\n    result = ans","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215103,"user_id":null,"body":"import algorithm\n\nproc choose_best_sum*(t, k: int, ls: seq[int]): int =\n\n    let sls = ls.sorted(SortOrder.Descending)\n    \n    proc find(d: int, xt: int, s: int, e: int, found: var int) =\n\n        if xt <= t:\n          if d < k:\n              for i in s .. e:\n                  find(d+1, xt + sls[i], i+1, e+1, found)\n                  \n          elif d == k and xt > found:\n              found = xt\n\n    if sls.len < k:\n        return -1\n\n    var found = -1\n    find(0, 0, 0, sls.len-k, found)\n    found\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215104,"user_id":492,"body":"proc choose_best_sum*(t, k: int, ls: seq[int]): int =\n    proc aux(t, k: int, ls: seq[int], frm: int): int =\n        if k == 0:\n            if t >= 0: return 0 else: return t\n        else:\n            if t < k: return -1           \n        var best = -1; var tmpBest: int\n        for i in frm..< ls.len():\n            tmpBest = aux(t - ls[i], k - 1, ls, i + 1)\n            if tmpBest >= 0:\n                best = max(best, ls[i] + tmpBest)\n        return best\n\n    return aux(t, k, ls, 0)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"55e86e212fce2aae75000060":[{"id":215105,"user_id":76,"body":"from sequtils import mapIt\nfrom algorithm import sorted\n\nproc prod2Sum*(a, b, c, d: int): seq[seq[int]] =\n  let candidates = [b * c - a * d, a * c + b * d, b * d - a * c, a * d + b * c]\n    .mapIt(it.abs)\n    .sorted\n  \n  let \n    x = candidates[0]\n    y = candidates[1]\n    z = candidates[2]\n    n = candidates[3]\n  \n  if x == y:\n    @[@[x, n]]\n  else:\n    @[@[x, n], @[y, z]]  ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215106,"user_id":492,"body":"import algorithm\n \nproc prod2Sum*(a, b, c, d: int): seq[seq[int]] =\n    proc comp(x, y: seq[int]): int =\n        return cmp(x[0], y[0])\n    var e = @[abs(a*d-b*c), abs(a*c+b*d)]\n    var f = @[abs(a*c-b*d), abs(a*d+b*c)]\n    sort(e, system.cmp)\n    sort(f, system.cmp)\n    var r: seq[seq[int]] = @[] \n    if (e == f):\n        r = @[e]\n    else:\n        r = @[e, f]\n        sort(r, comp)\n    return r","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"55eca815d0d20962e1000106":[{"id":215107,"user_id":null,"body":"from std\/sequtils import toSeq\n\nproc generate_range*(min, max, step: int): seq[int] =\n  toSeq(countup(min, max, step))\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215108,"user_id":76,"body":"import seqUtils\n\nproc generate_range*(min, max, step: int): seq[int] =\n  countup(min, max, step).toSeq","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215109,"user_id":null,"body":"proc generate_range*(min, max, step: int): seq[int] =\n  for x in countup(min, max, step):\n    result.add(x)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215110,"user_id":null,"body":"proc generate_range*(min, max, step: int): seq[int] =\n  for n in countup(min, max, step):\n    result.add(n)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215111,"user_id":null,"body":"proc generate_range*(min, max, step: int): seq[int] =\n  result.add(min)\n  while result[^1] + step <= max:\n    result.add(result[^1] + step)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215112,"user_id":50,"body":"import sequtils\n\nproc generate_range*(min, max, step: int): seq[int] =\n  return sequtils.toSeq(countup(min, max, step))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215113,"user_id":null,"body":"proc generate_range*(min, max, step: int): seq[int] =\n  var seq = newSeq[int]()\n  var i = min\n  \n  while i <= max:\n    seq.add(i)\n    i = i + step\n    \n  seq","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215114,"user_id":null,"body":"proc generate_range*(min, max, step: int): seq[int] =\n  if min < max and step > 0:\n    for n in countup(min, max, step): result.add(n)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215115,"user_id":53,"body":"proc generate_range*(min, max, step: int): seq[int] =\n  var xs: seq[int] = @[];\n  for i in countup(min, max, step):\n    xs.add(i);\n  return xs;","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215116,"user_id":null,"body":"proc generate_range*(min, max, step: int): seq[int] =\n  var s: seq[int]\n  for x in countup(min, max, step):\n    s.add(x)\n    \n  s","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"55f3da49e83ca1ddae0000ad":[{"id":215117,"user_id":53,"body":"import math\n\nproc tankvol*(h, d, vt: int): int =\n    let n = arccos(1.0 - h.float \/ (d.float \/ 2.0)) * 2.0\n    let m = vt.float * (n - sin(n)) \/ (2.0 * PI)\n    return floor(m).int","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215118,"user_id":111,"body":"import math\nproc tankvol*(h:int,d:int,vt:int):int=\n  let costh = 1-2*h\/d\n  int(float(vt)*(arccos(costh)-costh*sqrt(1-costh^2))\/PI)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215119,"user_id":null,"body":"import math\nimport strformat\n\nproc tankvol*(h, d, vt: int): int =\n  let\n    dia:float = float(d)\n    totvol:float = float(vt)\n    height:float = float(h)\n    length = (4*totvol)\/(PI*(dia^2))\n    radius = dia \/ 2\n    theta = radToDeg arccos (radius-height)\/radius\n    remvol = totvol*((360-theta*2)\/360) + (radius-height)*(sqrt(radius^2 - (radius-height)^2)) * length\n\n  result = int trunc totvol-remvol","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215120,"user_id":null,"body":"import math\n\nproc tankvol*(h, d, vt: int): int =\n  let r = float64(d) \/ 2.0\n\n  var h = h\n  var overHalf = false\n  if float64(h) > r:\n    h = d - h\n    overHalf = true\n    \n  let high = r - float64(h)\n  let width = sqrt(r^2 - high^2)\n  let selta = arcsin(width \/ r)\n  let coe = (2.0 * selta \/ (2.0*PI) * (PI*r^2) - width*high) \/ (PI*r^2)\n    \n  if overHalf:\n    int((1.0-coe) * float64(vt))\n  else:\n    int(coe * float64(vt))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215121,"user_id":null,"body":"import math, lenientops\n\nproc circleSegArea*(h, r: float): float =\n  r^2 * arccos((r - h) \/ r) - (r - h) * sqrt(2 * r * h - h^2)\n\nproc tankvol*(h, d, vt: int): int =\n    let\n      r = d \/ 2.0\n      segArea = circleSegArea(float(h), r)\n      totalArea = circleSegArea(float(d), r)\n      tankLen = vt \/ totalArea\n      volume = tankLen * segArea\n    return floor(volume).int","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215122,"user_id":527,"body":"import math\n\nproc tankvol*(h, d, vt: int): int =\n  let\n    h = float(h)\n    d = float(d)\n    vt = float(vt)\n    r = 0.5 * d\n    sectionArea = r * r * arccos(1 - h \/ r) - (r - h) * sqrt(h * (d - h))\n    fullSectionArea = PI * r * r\n  int(vt * sectionArea \/ fullSectionArea)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215123,"user_id":492,"body":"import math\n\nproc tankvol*(h, d, vt: int): int =\n    var hh: float64 = float64(h); var hilevel = true\n    if (h == 0):\n        return 0\n    #radius\n    var r = float64(d) \/ 2.0\n    if (hh == r):\n        return vt div 2\n    if (h == d):\n        return vt\n    # height > radius, calculate with d - h and at the end change the volume\n    if (hh > r):\n        hh = float64(d) - hh\n    else:\n        hilevel = false\n    # total area of circle\n    var st = PI * r * r\n    # half angle from the center\n    var theta = arccos((r - hh) \/ r)\n    # b = sqrt(r * r - (r - hh) ** 2) one side of the right triangle\n    var sr = (r - hh) * sqrt(r * r - (r - hh) * (r - hh))\n    # area corresponding to angle 2 * theta\n    var sa = st \/ PI * theta\n    # surface corresponding to the height\n    var sh = sa - sr\n    # volume to find corresponding to surface of liquid \/ total surface\n    var v = float64(vt) * sh \/ st\n    # if height > radius\n    if (hilevel):\n        v = float64(vt) - v\n    return int(floor(v))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"55f9bca8ecaa9eac7100004a":[{"id":215124,"user_id":null,"body":"proc past*(h, m, s: int): int = (h * 3600000) + (m * 60000) + (s * 1000)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215125,"user_id":527,"body":"proc past*(h, m, s: int): int =\n  ((h * 60 + m) * 60 + s) * 1000","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215126,"user_id":null,"body":"proc past*(h, m, s: int): int =\n  let seconds = h * 3600 + m * 60 + s\n  return seconds * 1000","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215127,"user_id":null,"body":"proc past*(h, m, s: int): int =\n  1000 * (3600 * h + 60 * m + s)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215128,"user_id":null,"body":"proc past*(h, m, s: int): int =\n  return (h*60*60*1000)+(m*60*1000)+(s*1000)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215129,"user_id":null,"body":"proc past*(h, m, s: int): int =\n  result = 1000*(s+m*60+h*60*60)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215130,"user_id":null,"body":"proc past*(h, m, s: int): int =\n  h*60*60000+m*60000+s*1000","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215131,"user_id":null,"body":"proc past*(h, m, s: int): int =\n  ((h * 60 * 60) + (m * 60) + s) * 1000","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215132,"user_id":null,"body":"proc past*(h, m, s: int): int =\n  1000 * (h * 3600 + m * 60 + s)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215133,"user_id":null,"body":"proc past*(h, m, s: int): int =\n  let totals = (h * 60 * 60) + m * 60 + s  \n  totals * 1000","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"55fab1ffda3e2e44f00000c6":[{"id":215134,"user_id":759,"body":"proc cockroach_speed*(x: float): int =\n  (x \/ 0.036).int","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215135,"user_id":null,"body":"proc cockroach_speed*(x: float): int =\n  discard\n  \n  result = ((x \/ 3600) * 100_000).int","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215136,"user_id":null,"body":"import math\nproc cockroach_speed*(x: float): int = (int) (x * 1000*100 \/ 60 \/ 60)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215137,"user_id":null,"body":"import std\/math\n\nproc cockroach_speed*(x: float): int =\n  int(floor(x \/ 3600 * 1000 * 100))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215138,"user_id":713,"body":"proc cockroach_speed*(s: float): int =\n  int(s \/ 0.036)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215139,"user_id":null,"body":"import std\/math\n\nproc cockroach_speed*(x: float): int =\n  result = floor(x * 100000 \/ 3600).toInt","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215140,"user_id":null,"body":"proc cockroach_speed*(x: float): int =\n  return int((x*1000)\/36)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215141,"user_id":null,"body":"proc cockroach_speed*(x: float): int =\n  result = int(x*(100000\/3600))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215142,"user_id":null,"body":"proc cockroach_speed*(x: float): int =\n  result = int(x*10000\/360)\n  return\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215143,"user_id":null,"body":"import std\/math\nproc cockroach_speed*(x: float): int =\n  toInt(trunc(x*100000\/60\/60))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"55fd2d567d94ac3bc9000064":[{"id":215144,"user_id":645,"body":"proc row_sum_odd_numbers*(n: int): int = n * n * n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215145,"user_id":null,"body":"import math\nproc row_sum_odd_numbers*(n: int): int =\n  return n^3","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215146,"user_id":null,"body":"proc row_sum_odd_numbers*(n: int): int =\n  let n1 = n + 1\n  let a = (n * n) - (n - 1)\n  let b = (n1 * n1) - n1\n  for i in countup(a, b, 2):\n    result += i","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215147,"user_id":null,"body":"import math\n\nfunc row_sum_odd_numbers*(n: int): int =\n  n^3","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215148,"user_id":null,"body":"proc row_sum_odd_numbers*(n: int): int =\n  var startNum = 1\n  \n  var addNum = 2\n  for i in 2..n:\n    startNum += addNum\n    addNum += 2\n  for i in 1..n:\n    result += startNum\n    startNum += 2\n  \n      ","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215149,"user_id":null,"body":"import math\n\nproc row_sum_odd_numbers*(n: int): int =\n  n^3","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215150,"user_id":null,"body":"import sequtils\n\nproc row_sum_odd_numbers*(n: int): int =\n  var level = 1\n  var row: seq[int] = @[]\n  var num = 1\n\n  while true:\n    if num mod 2 != 0:\n      row.add(num)\n      if row.len == level:\n        if level == n:\n          break\n        else:\n          inc(level)\n          row = @[]\n    inc(num)\n\n  return row.foldl(a + b)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215151,"user_id":null,"body":"proc row_sum_odd_numbers*(n: int): int = n*n*n\n#  discard # your code here","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215152,"user_id":492,"body":"proc row_sum_odd_numbers*(n: int): int =\n  return n * n * n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215153,"user_id":null,"body":"proc row_sum_odd_numbers*(n: int): int =\n  # This solution uses the arithmetic sum formula: Sn = n\/2 * (2*a + (n-1)*d)\n  # But we know d=2 for odd numbers, so we can simplify: Sn = n * (a + (n-1))\n  # To find a we need to know how many odd numbers to skip, which we can do\n  # with the triangle number formula: Tn = n\/2 * (n + 1)\n  # But we want that for n-1 rather than n: Tn-1 = n\/2 * (n - 1)\n  # To get the first unskipped odd number: a = 2*Tn-1 + 1 = n * (n - 1) + 1\n  # Subbing this into Sn above: Sn = n * (n * (n - 1) + 1 + n - 1) = n*n*n\n  result = n * n * n\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"5613d06cee1e7da6d5000055":[{"id":215154,"user_id":53,"body":"import math\nimport sequtils\n\nproc isPrime(n: int) :bool = \n  if n mod 2 == 0: return false\n  for i in countup(3,ceil(sqrt(n.toFloat())).toInt(),2):\n    if n mod i == 0: return false\n  return true\n\nproc step*(g, m, n: int): seq[int] =\n  for i in m..n-g:\n    if i.isPrime() and (i+g).isPrime():\n      return @[i, i+g]\n  return @[]  ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215155,"user_id":492,"body":"import math\n\nproc step*(g, m, n: int): seq[int] =\n    proc isPrimi(a: int): bool =\n        if a == 2: return true\n        if a < 2 or a mod 2 == 0: return false\n        for i in countup(3, sqrt(a.float).int, 2):\n            if a mod i == 0:\n                return false\n        return true\n    var res: seq[int] = @[]\n    for i in m..n - g:\n        if isPrimi(i) and isPrimi(i + g):\n            res.add(i)\n            res.add(i + g)\n            return res\n    return res","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215156,"user_id":null,"body":"import std\/math\n\niterator primesUpto(limit: int): int =\n  let sqrtLimit = int(sqrt(float64(limit)))\n  var composites = newSeq[bool](limit + 1)\n  for n in 2 .. sqrtLimit: # cull to square root of limit\n    if not composites[n]: # if prime -> cull its composites\n      for c in countup(n * n, limit, n): # start at ``n`` squared\n        composites[c] = true\n  for n in 2 .. limit: # separate iteration over results\n    if not composites[n]:\n      yield n\n        \nfunc all_primes_between(m, n: int): seq[int] =\n  for prime in primesUpto(n):\n    if prime >= m:\n      result &= prime\n\nproc step*(stepsize, m, n: int): seq[int] =\n  let primes = all_primes_between(m, n)\n  for prime in primes:\n    if (prime + stepsize) in primes:\n      return @[prime, prime+stepsize]\n  @[]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215157,"user_id":null,"body":"import math\n\nproc step*(g, m, n: int): seq[int] =\n    var primes : seq[int] = @[]\n    var k : int\n    for k in m .. n:\n      if k == 2:\n        primes.add(k)\n      else:\n        var d : int\n        for d in 2 .. toint(ceil(sqrt(float(k)))):\n          if k mod d == 0:\n            break\n          if d == toint(ceil(sqrt(float(k)))):\n            primes.add(k)\n    var primes_set : seq[int] = @[]\n    var p : int\n    for p in primes:\n      if p >= m and p <= n:\n        primes_set.add(p)\n    var i : int\n    var j : int\n    for i in 0 .. (len(primes_set) - 1):\n      for j in i .. (len(primes_set) - 1):\n        if primes_set[i] + g == primes_set[j]:\n          return @[primes_set[i], primes_set[j]]\n    return @[]\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215158,"user_id":null,"body":"import math\n\nproc step*(g, m, n: int): seq[int] =\n    # var primes : array = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]\n    var primes : seq[int] = @[]\n    var k : int\n    for k in m .. n:\n      if k == 2:\n        primes.add(k)\n      else:\n        var d : int\n        for d in 2 .. toint(ceil(sqrt(float(k)))):\n          if k mod d == 0:\n            break\n          if d == toint(ceil(sqrt(float(k)))):\n            primes.add(k)\n    var primes_set : seq[int] = @[]\n    var p : int\n    for p in primes:\n      if p >= m and p <= n:\n        primes_set.add(p)\n    var i : int\n    var j : int\n    for i in 0 .. (len(primes_set) - 1):\n      for j in i .. (len(primes_set) - 1):\n        if primes_set[i] + g == primes_set[j]:\n          return @[primes_set[i], primes_set[j]]\n    return @[]\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215159,"user_id":360,"body":"proc prime(p: int): bool =\n  for d in 2..p:\n    if d * d > p: return true\n    if p mod d == 0: return false\n\nproc step*(g, m, n: int): seq[int] =\n  for i in m..n-g:\n    if prime(i) and prime(i+g): return @[i, i+g]\n  return @[]\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215160,"user_id":null,"body":"import tables # hash tables\n\ntype\n  LazyList[T] = ref object # memoizing lazy list...\n    head: T\n    tailf: proc (): LazyList[T] # expensive calculation only done once!\n    tail: LazyList[T]\nproc rest[T](ll: LazyList[T]): LazyList[T] =\n  if ll.tailf != nil: ll.tail = ll.tailf(); ll.tailf = nil\n  return ll.tail\niterator items[T](ll: LazyList[T]): T =\n  var lzylst = ll\n  while true: yield lzylst.head; lzylst = lzylst.rest\n\n# a good prime sequence generator;\n# much more efficient than a trial division primality test for large ranges...\nproc primes(): iterator(): int =\n  return iterator(): int =\n    yield 2; yield 3 # first concrete values to break race!\n    let bps = primes(); # recursive feed of base primes!\n    var n = 5; var q = 9; discard bps(); var bp = bps() # starts at 3!\n    var cmpsts = initTable[int, int]() # contains composites and delta to next!\n    while true:\n      if n >= q: # hit base prime limit; add new base prime progression to composites!\n        let dlta = bp + bp; cmpsts[q + dlta] = dlta; bp = bps(); q = bp * bp\n      else:\n        if n in cmpsts:\n          var dlta: int; discard take(cmpsts, n, dlta); var nxtn = n + dlta # advance!\n          while nxtn in cmpsts: nxtn += dlta # avoid duplicates\n          cmpsts[nxtn] = dlta # insert non-duplicate adjusted entry\n        else: yield n # not a composite: found a prime!\n      n += 2 # loop until prime found!\n\n# better coverage of limits and `2`...\nproc step*(g, m, n: int): seq[int] =\n  if g < 0 or m < 2 or m + g < 2 or n < m + g: return @[]\n  let prms = primes() # make a generator as from the above!\n  var frstprm = prms() # starts at 2!\n  while frstprm < m: frstprm = prms() # advance up to at least `m`!\n  proc prmsfrm(p: int): LazyList[int] =\n    LazyList[int](head: p, tailf: proc (): auto = prms().prmsfrm)\n  var lzyprms = frstprm.prmsfrm # lazy list of primes starting at least `m`!\n  while true:\n    let tstval = lzyprms.head + g\n    if tstval > n: return @[] # out of range past it!\n    for p in lzyprms:\n      if p == tstval: return @[p - g, p] # found it!\n      if p > tstval: break # too far; try next lead prime!\n    lzyprms = lzyprms.rest # by consuming the head of the lzyprms lazy list!","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215161,"user_id":null,"body":"import tables\n\ntype\n  LazyList[T] = ref object # memoizing lazy list...\n    head: T\n    tailf: proc (): LazyList[T] # expensive calculation only done once!\n    tail: LazyList[T]\nproc rest[T](ll: LazyList[T]): LazyList[T] =\n  if ll.tailf != nil: ll.tail = ll.tailf(); ll.tailf = nil\n  return ll.tail\niterator items[T](ll: LazyList[T]): T =\n  var lzylst = ll\n  while true: yield lzylst.head; lzylst = lzylst.rest\n\n# a good odd prime sequence generator;\n# much more efficient than a trial division primality test for large ranges...\nproc oddprimes(): iterator(): int =\n  return iterator(): int =\n    yield 3 # first concrete value to break race!\n    let bps = oddprimes(); # recursive feed of base primes!\n    var n = 5; var q = 9; var bp = bps() # starts at 3!\n    var cmpsts = initTable[int, int]() # contains composites and delta to next!\n    while true:\n      if n >= q: # hit base prime limit; add new base prime progression to composites!\n        let dlta = bp + bp; cmpsts[q + dlta] = dlta; bp = bps(); q = bp * bp\n      else:\n        if n in cmpsts:\n          var dlta: int; discard take(cmpsts, n, dlta); var nxtn = n + dlta # advance!\n          while nxtn in cmpsts: nxtn += dlta # avoid duplicates\n          cmpsts[nxtn] = dlta # insert non-duplicate adjusted entry\n        else: yield n # not a composite: found a prime!\n      n += 2 # loop until prime found!\n\nproc step*(g, m, n: int): seq[int] =\n  if g < 0 or m < 2 or m + g < 2 or n < m + g: return @[]\n  let oddprms = oddprimes(); var frstprm = oddprms()\n  while frstprm < m: frstprm = oddprms()\n  proc prmsfrm(p: int): LazyList[int] =\n    LazyList[int](head: p, tailf: proc (): auto = oddprms().prmsfrm)\n  var lzyprms = frstprm.prmsfrm\n  while true:\n    let frstprm = lzyprms.head\n    if frstprm + g > n: return @[] # out of range past it!\n    for p in lzyprms:\n      let stp = p - frstprm\n      if stp == g: return @[frstprm, p] # found it!\n      if stp > g: break # too far; try next lead prime!\n    lzyprms = lzyprms.rest # consume the head of the lzyprms lazy list!","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215162,"user_id":null,"body":"import tables\n\ntype\n  LazyList[T] = ref object\n    head: T\n    tailf: proc (): LazyList[T]\n    tail: LazyList[T]\nproc rest[T](ll: LazyList[T]): LazyList[T] =\n  if ll.tailf != nil: ll.tail = ll.tailf(); ll.tailf = nil\n  return ll.tail\niterator items[T](ll: LazyList[T]): T =\n  var lzylst = ll\n  while true: yield lzylst.head; lzylst = lzylst.rest\n\n# a good odd prime sequence generator...\nproc oddprimes(): iterator(): int =\n  return iterator(): int =\n    yield 3\n    let bps = oddprimes(); var n = 5; var q = 9; var bp = bps() # starts at 3!\n    var tbl = initTable[int, int]()\n    while true:\n      if n >= q:\n        let dlta = bp + bp; tbl[q + dlta] = dlta; bp = bps(); q = bp * bp\n      else:\n        if n in tbl:\n          var dlta: int; discard take(tbl, n, dlta); var nn = n + dlta\n          while nn in tbl: nn += dlta # avoid duplicates\n          tbl[nn] = dlta # insert non-duplicate adjusted entry\n        else: yield n\n      n += 2\n\nproc step*(g, m, n: int): seq[int] =\n  if n < m + g or g < 1: return @[]\n  if g == 1:\n    if m > 2: return @[] else: return @[2, 3]\n  if (g and 1) != 0: return @[] # all the rest of the gaps must be even!\n  let oddprms = oddprimes(); var frstprm = oddprms()\n  while frstprm < m: frstprm = oddprms()\n  proc prmsfrm(p: int): LazyList[int] =\n    LazyList[int](head: p, tailf: proc (): auto = oddprms().prmsfrm)\n  var lzyprms = frstprm.prmsfrm\n  while true:\n    let frstprm = lzyprms.head\n    if frstprm > n: return @[]\n    for p in lzyprms:\n      let stp = p - frstprm\n      if stp == g: return @[frstprm, p]\n      if stp > g: break\n    lzyprms = lzyprms.rest","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"5616868c81a0f281e500005c":[{"id":215163,"user_id":492,"body":"import strutils, algorithm\n\nproc rank*(st: string, we: seq[int], n: int): string =\n  if st.len == 0: return \"No participants\"\n  var names = newSeq[tuple[name: string, points: int]]()\n  var i = 0\n  for name in st.split(','):\n    let upper = name.toUpperAscii\n    var p = upper.len\n    for c in upper:\n      p += c.int - 'A'.int + 1\n    p *= we[i]\n    names.add((name, p))\n    inc i\n  if n > i: return \"Not enough participants\"\n  names.sortedByIt((-it.points, it.name))[n - 1].name","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215164,"user_id":492,"body":"import strutils, algorithm\n\nproc rank*(st: string, we: seq[int], n: int): string =  \n    type \n        rankStruct = object\n            name: string\n            wght: int\n    proc comp(x, y: rankStruct): int =\n        if x.wght == y.wght:\n            return cmp(x.name, y.name)\n        return cmp(y.wght, x.wght)\n\n    if st == \"\":\n        return \"No participants\"\n    var names = split(st, \",\")\n    if n > names.len():\n        return \"Not enough participants\"\n    var ranks: seq[rankStruct] = newSeq[rankStruct](names.len())\n    for i in countup(0, ranks.len() - 1):\n        ranks[i].name = names[i]\n        var w = names[i].len()\n        for c in toLowerAscii(names[i]):\n            w += int(c) - int('a') + 1\n        w *= we[i]\n        ranks[i].wght = w\n    ranks.sort(comp)\n    return ranks[n-1].name","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215165,"user_id":76,"body":"import sequtils, algorithm, strutils, math\n\nfunc som(s: string): int =\n  s.toLowerAscii.mapIt(it.ord - 'a'.ord + 1).sum() + s.len\n\nproc myCmp(a, b: (string, int)): int =\n  let diff = a[1] - b[1]\n  if diff < 0: return 1\n  elif diff > 0: return -1\n  cmp(a[0], b[0])  \n\nproc rank*(st: string, we: seq[int], n: int): string = \n  if st.len == 0: return \"No participants\"\n  var entries = st.split(\",\").zip(we).mapIt((it[0], som(it[0]) * it[1]))\n  if n > entries.len: return \"Not enough participants\"\n  entries.sort(myCmp)\n  entries[n - 1][0]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215166,"user_id":null,"body":"import strutils, sequtils, algorithm\n\nfunc calcNameValue*(name: string, weight: int): int =\n  @(name.toLowerAscii).foldl(a + succ(b.ord - 'a'.ord), name.len) * weight\n\nproc rank*(st: string, we: seq[int], n: int): string =\n  if st == \"\":\n    return \"No participants\"\n  \n  let names = st.split(',')\n  \n  if names.len < n:\n    return \"Not enough participants\"\n  \n  var ranks: seq[(string, int)]\n  \n  for i, it in names:\n    var rank = (it, calcNameValue(it, we[i]))\n    ranks.add(rank)\n      \n  ranks.sort proc(a, b: auto): auto =\n        result = cmp(b[1], a[1])\n        if result == 0:\n          result = cmp(a[0], b[0])\n          \n  result = ranks[n - 1][0]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215167,"user_id":null,"body":"import strutils\nimport algorithm\n\nfunc nameValue(name: string): int =\n  result = name.len\n  for c in name:\n    result = result + int(c.toLowerAscii) - int('a') + 1\n  \nproc rank*(st: string, we: seq[int], n: int): string =  \n    let names = st.split(\",\")\n    if st.len == 0:\n      return \"No participants\"\n    if n > names.len:\n      return \"Not enough participants\"\n\n    var valuedNames: seq[(string,int)] = @[]\n    for i, name in names:\n      valuedNames.add((name, nameValue(name) * we[i]))\n    let sortedByName = valuedNames.sortedByIt(it[0])\n    let sortedByWeight = sortedByName.sortedByIt(-it[1])\n    return sortedByWeight[n-1][0]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215168,"user_id":null,"body":"import std\/[sequtils, strutils, tables, algorithm]\nproc rank*(st: string, we: seq[int], n: int): string =  \n  let names=st.split(',')\n  if st==\"\": return \"No participants\"\n  if n>names.len: return \"Not enough participants\"  \n  \n  var alpha =initTable[char,int]()\n  for i,c in toSeq 'a'..'z':\n    alpha[c]=i+1\n  \n  var soms: seq[int]\n  for i,s in names:\n    var sum=0\n    for c in s:\n      sum+=alpha[toLowerAscii(c)]\n    soms.add((sum+s.len)*we[i])\n              \n  let draw= zip(names,soms).sorted(proc (x, y: (string,int)): int=\n                                    if x[1]>y[1]: 1\n                                    elif x[1]==y[1]:\n                                      if x[0]<y[0]: 1 # < because names in ascending order\n                                      else: -1\n                                    else: -1,Descending)\n  result=draw[n-1][0]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215169,"user_id":null,"body":"from std\/strutils import toLowerAscii, split\nfrom std\/algorithm import sorted, SortOrder\nimport std\/sequtils\n\nproc score( entry: (string, int) ): (string, int) =\n  let (name, weight) = entry\n  (name, weight * (len(name) + name.toLowerAscii().mapIt(it.int - 96).foldl(a+b)))\n\n\ntype People = tuple\n  name: string\n  score: int\n\nproc comparePeople( a, b: People): int =\n  let DRAW = 0\n  let score = -cmp(a.score, b.score) \n  \n  if(score==DRAW):\n    return cmp(a.name, b.name)\n  \n  score\n  \nproc rank*(st: string, we: seq[int], n: int): string =\n  if st == \"\":\n    return \"No participants\"\n  let participants = st.split(',')\n  if n > len(participants):\n    return \"Not enough participants\"\n  zip(toSeq(participants), we).mapIt(score(it)).sorted(comparePeople)[n-1][0]\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215170,"user_id":null,"body":"import algorithm\nimport math\nimport sequtils\nimport strutils\nimport sugar\n\nproc comparison(a, b: tuple): int =\n  if a[0] == b[0]:\n    if a[1] <= b[1]:\n      return -1\n    else:\n      return 1\n  return b[0] - a[0]\n\nproc rank*(st: string, we: seq[int], n: int): string = \n  if st == \"\":\n    return \"No participants\"\n  if n > we.len:\n    return \"Not enough participants\"\n  let pa = st.split(',')\n  result = pa\n    .map(p => p.map(c => c.toLowerAscii.ord - 96).sum + p.len)\n    .zip(we)\n    .map(t => t[0] * t[1])\n    .zip(pa)\n    .sorted(comparison)[n-1][1]\n  ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215171,"user_id":null,"body":"import algorithm, sequtils, strutils\n\nfunc rank(letter: char): int =\n  assert letter in Letters\n\n  result = if letter.isUpperAscii:\n    int(letter) - 64\n  else:\n    int(letter) - 96\n\nfunc som(name: string; weight: int): int =\n  result = name.len\n\n  for c in name:\n    result += c.rank\n\n  result *= weight\n\n# NOTE sequtils.zip in Nim 1.0 returns seq of named tuples with `a` and `b` fields\nfunc cmp(x, y: tuple[a: string, b: int]): int =\n  result = if x.b == y.b:  # if their score are the same\n    cmp(y.a, x.a)\n  else:\n    x.b - y.b\n\nfunc rank*(st: string; we: seq[int]; n: int): string =  \n  if st == \"\":\n    return \"No participants\"\n\n  let names = st.split(',')\n\n  if n > names.len:\n    return \"Not enough participants\"\n\n  var ranks = newSeq[int](names.len)\n  for i in 0..<names.len:\n    ranks[i] = som(names[i], we[i])\n\n  let res = sorted(zip(names, ranks), cmp, Descending)\n\n  result = res[n - 1].a\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215172,"user_id":null,"body":"import strutils\nimport sequtils\nimport algorithm\n\nproc rank*(st: string, we: seq[int], n: int): string =  \n\n\n    if st.len == 0:\n        \"No participants\"\n    else:\n        let ps = st.split(',')\n\n        proc winningNumber(i: int): int =\n\n            proc rank(c: char): int =\n                case c:\n                    of 'A' .. 'Z': result = ord(c) - 64\n                    of 'a' .. 'z': result = ord(c) - 96\n                    else: discard\n\n            let som = ps[i].len + ps[i].mapIt(it.rank).foldl(a + b)\n            we[i] * som\n\n        proc compare(i1, i2: int): int = \n            let wn1 = i1.winningNumber\n            let wn2 = i2.winningNumber\n            if wn1 == wn2:\n                ps[i2].cmpIgnoreCase(ps[i1])\n            else: \n                wn1.cmp(wn2) #winning numbers are descending\n\n        if n > ps.len():\n            \"Not enough participants\"\n        else:\n            \n            var sorted = (0 ..< ps.len).toSeq.sorted(compare, SortOrder.Descending)\n            ps[sorted[n-1]]\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"561e9c843a2ef5a40c0000a4":[{"id":215173,"user_id":null,"body":"import math\nimport sequtils\nproc isPrime(n: int) :bool = \n  if n mod 2 == 0: return false\n  for i in countup(3,ceil(sqrt(n.toFloat())).toInt(),2):\n    if n mod i == 0: return false\n  return true\n\n  \nproc gap*(g, m, n: int): seq[int] =\n    var lastPrime = -1\n    for i in m..n:\n      if i.isPrime():\n        if lastPrime > 0 and i-lastPrime==g:\n          return @[lastPrime,i]\n        lastPrime = i\n        \n    return @[]    \n        \n      ","lang_id":33,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215174,"user_id":492,"body":"import math\n\nproc gap*(g, m, n: int): seq[int] =\n    proc isPrimi(a: int): bool =\n        if a == 2: return true\n        if a < 2 or a mod 2 == 0: return false\n        for i in countup(3, sqrt(a.float).int, 2):\n            if a mod i == 0:\n                return false\n        return true\n    var res: seq[int] = @[]\n    var lastPrime = 0\n    for i in m..n:\n        if isPrimi(i):\n            if (i - lastPrime == g):\n                res.add(lastPrime)\n                res.add(i)\n                return res\n            else:\n                lastPrime = i\n    return res","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215175,"user_id":53,"body":"proc isPrime*(n: int): bool =\n  if n mod 2 == 0: return n == 2\n  if n mod 3 == 0: return n == 3\n  var i = 5\n  while i * i <= n:\n    if n mod i == 0: return false\n    if n mod (i + 2) == 0: return false\n    i = i + 6\n  return true\n\nproc gap*(g, m, n: int): seq[int] =\n  result = newSeq[int](0)\n  var a = 0\n  var b = 0\n  var i = m\n  while i <= n:\n    if b - a == g: return @[a, b]\n    if isPrime(i):\n      a = b\n      b = i\n    i = i + 1","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215176,"user_id":null,"body":"proc isPrime(n: int): bool = \n  var i = 2\n  while i*i <= n:\n    if n mod i == 0: return false \n    inc(i)\n  return true \n\nproc gap*(g, m, n: int): seq[int] =\n    # your code\n    var first = -1\n    for i in m..n:\n      if isPrime(i):\n        if first == -1:\n          first = i\n        else:\n          if i - first == g:\n            return @[first, i]\n          else:\n            first = i          ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215177,"user_id":76,"body":"func isPrime(n: int): bool = \n  var i = 2\n  while i * i <= n:\n    if n mod i == 0:\n      return false\n    inc i\n  true\n\nproc gap*(g, m, n: int): seq[int] =\n  var last = 0\n  for i in m .. n:\n    if isPrime i:\n      if i - last == g:\n        return @[last, i]\n      else:\n        last = i","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215178,"user_id":null,"body":"import std\/intsets\nimport std\/math\n\nvar primes = @[2]\nvar primeset = initIntSet()\nprimeset.incl(2)\nvar primemax = 2\nproc isprime(p: int): bool =\n  if p <= primemax:\n    if p in primeset:\n      return true\n    return false\n  for test in primemax..p:\n    let upper = int(sqrt(float32(test)))\n    block body:\n      for other in primes:\n        if test mod other == 0:\n          break body\n        if other > upper:\n          break\n      primes.add(test)\n      primeset.incl(test)\n  primemax = p\n  if p in primeset:\n    return true\n  return false\n  \nproc gap*(g, m, n: int): seq[int] =\n  var lastprime = 0\n  for i in m..n:\n    if isprime(i):\n      if lastprime != 0 and i - lastprime == g:\n        return @[lastprime, i]\n      lastprime = i\n  return @[]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215179,"user_id":null,"body":"import math, sequtils\n\nproc isPrime(n: int): bool =\n    let lim = sqrt(n.toFloat).toInt\n    (2 .. lim).toSeq.allIt(n %% it != 0)\n\nproc gap*(g, m, n: int): seq[int] =\n\n    let primes = (m .. n).toSeq.filter(isPrime)\n\n    var last = primes[0]\n\n    for p in primes[1 .. ^1]:\n        \n        if p - last == g:\n            return @[last, p]\n\n        last = p\n\n    @[]\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215180,"user_id":null,"body":"#import strformat\nimport tables\n\nvar memo = initTable[int, int]()\nvar memoFromNon = initTable[int, int]()\n\nproc expmod(b:int, e:int, m:int): int =\n  var modb = b\n  var mode = e\n  var res = 1\n  modb = modb mod m\n  while mode > 0:\n    if mode mod 2 == 1:\n      res = (res * modb) mod m\n    mode = mode shr 1\n    modb = (modb * modb) mod m\n  return res\n \n\nproc millerRabin(n: int): bool =  \n  #echo &\"n: {n}\"\n  var \n    r: int = 1  \n    raisedR: int = 2\n\n  let nMinus1: int = n-1\n  while nMinus1 mod raisedR != 0 or (nMinus1 div raisedR) mod 2 != 1:\n    r+=1\n    #echo &\"r: {r}\" \n    raisedR *= 2\n\n  let d: int = nMinus1 div raisedR\n  #echo &\"r: {r}; d: {d}\"\n  \n  for a in [2,3]: \n    #echo &\"a: {a}\" \n    var x: int = expmod(a,d,n)\n    if x == 1 or x == nMinus1:\n      #echo \"continuing\"\n      continue\n    #echo \"rloop starting\"\n    block rloop:\n      for _ in 2..r:\n        x = expmod(x,2,n)\n        if x == nMinus1:\n          #echo \"continuing?\"\n          break rloop\n      #echo \"composite\"\n      return false\n  #echo \"probably prime\"\n  return true\n\n\nproc gap*(g, m, n: int): seq[int] =  \n  if g mod 2 == 1:\n    return @[]\n  \n  var modifiedM = m\n  if m mod 2 == 0:\n    modifiedM = m + 1\n\n  var fromNon = false\n  if memoFromNon.hasKey(modifiedM):\n    modifiedM = memoFromNon[modifiedM]\n    #echo &\"jumped from {m+1} to {modifiedM}\"\n    fromNon = true\n    \n  var curPrime: int = -1\n  var x: int = modifiedM\n  while x <= n:    \n    let testGap = x - curPrime\n  \n    var isInMemo = memo.hasKey(x)\n    if isInMemo or millerRabin(x):\n      if not fromNon:\n        memoFromNon[modifiedM] = x\n        fromNon = true\n      \n      if curPrime != -1 and not memo.hasKey(curPrime):\n        memo[curPrime] = x\n      \n      if curPrime != -1 and x - curPrime == g:\n        return @[curPrime, x]\n      \n      curPrime = x\n      \n      while x <= n and memo.hasKey(curPrime):\n        #echo &\"jumped from {x} to {memo[curPrime]}\"\n        x = memo[curPrime]\n        \n        if x - curPrime == g:\n          return @[curPrime, x]\n        \n        curPrime = x\n      #echo &\"x after memo: {x}\"\n      \n    x += 2\n      \n  return @[]\n    \n    \n  ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"562b384167350ac93b00010c":[{"id":215181,"user_id":null,"body":"import math,sequtils,sets#,std\/enumerate\ntemplate isEven(n: int64): bool = (n and 1) == 0\n \nfunc gcd*(u, v: int64): int64 =\n \n  var u = abs(u)\n  var v = abs(v)\n  if u < v: swap u, v\n \n  if v == 0: return u\n \n  var k = 1\n  while u.isEven and v.isEven:\n    u = u shr 1\n    v = v shr 1\n    k = k shl 1\n  var t = if u.isEven: u else: -v\n  while t != 0:\n    while t.isEven: t = ashr(t, 1)\n    if t > 0: u = t\n    else: v = -t\n    t = u - v\n  result = u * k\n\niterator an(n:int64):int =\n  var res = 7\n  yield res\n  for i in 2..n:\n    res = res + gcd(i,res).int\n    yield res\niterator gn(n:int64):int =\n  var prev = 6\n  for i in an(n):\n    yield i - prev\n    prev = i\niterator anOver(n:int64):float =\n  var prev = 6\n  var i = 1\n  var n=n\n  for a in an(int64.high):\n    let g = a - prev\n    if g != 1:\n      yield a.float\/i.float\n      dec n\n      if n==0:\n        break\n    prev = a\n    inc i\nproc pn(n:int64):OrderedSet[int] =\n  for i in gn(int64.high):\n    if i != 1:\n      result.incl i\n      if result.len==n:\n        break\n\nproc count_ones*(n: int64): int =\n    # your code\n  for i in gn(n):\n    if i == 1:\n      inc result\nproc max_pn*(n: int64): int =\n  for i in pn(n):\n    if result < i:\n      result = i\nproc an_over_average*(n: int64): int =\n  var sum:float\n  for i in anOver(n):\n    sum += i\n  return (int) (sum \/ n.float)\n        ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215182,"user_id":53,"body":"import math\n\nproc count_ones*(n: int64): int =\n    var a = 7; var i = 1; var s = 1;\n    while i < n:\n        i += 1\n        let g = gcd(i, a)\n        a += g\n        if g == 1:\n            s += 1\n    return s\n\nproc max_pn*(n: int64): int64 =\n    var a = 7; var i = 1; var k = 0; var m = -1;\n    var s: seq[int64] = @[]\n    while k <= n:\n        i += 1\n        let g = gcd(i, a)\n        a += g\n        if (find(s, g) == -1):\n            if g > m:\n                m = g\n            s.add(g)\n            k += 1\n    return m\n\nproc an_over_average*(n: int64): int =\n    var a = 7; var i = 1; var s = 0;\n    while s < n:\n        i += 1\n        let g = gcd(i, a)\n        a += g\n        if g > 1:\n            s += 1\n    return a div i\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215183,"user_id":null,"body":"import math, sequtils\n\nvar an = @[7.int64]\nproc a(n: int64): int64 =\n  while an.len < n:\n    an.add(an[^1] + gcd(an[^1], an.len + 1))\n  return an[n - 1]\n\nproc g(n: int64): int64 = \n  if n == 1: 1.int64\n  else: a(n) - a(n - 1)\n\nproc count_ones*(n: int64): int64 =\n  toSeq(1.int64..n).filterIt(g(it) == 1).len\n\nproc p(n: int64): seq[int64] =\n  var i = 1\n  while result.len != n:\n    if g(i) != 1 and g(i) notin result: result.add g(i)\n    inc i\n\nproc max_pn*(n: int64): int64 = max(p(n))\n\nproc anOver(n: int): seq[float] = repeat(3.0, n) # that really works, wanna prove that\n\nproc an_over_average*(n: int64): int64 = 3","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215184,"user_id":492,"body":"import math\n\nproc count_ones*(n: int64): int =\n    var prev: int64 = 7; var i: int64 = 2\n    # add 1 at the head\n    var cnt: int = 1\n    while i <= n:\n        let nou = prev + gcd(prev, i)\n        if nou - prev == 1:\n            cnt += 1\n        prev = nou\n        i += 1\n    return cnt\nproc max_pn*(n: int64): int64 =\n    var prev: int64 = 7; var i: int64 = 2\n    var cnt: int64 = 0; var mx: int64 = -1\n    var res: seq[int64] = @[]\n    while cnt < n:\n        let nou: int64 = prev + gcd(prev, i)\n        let d = nou - prev\n        if d != 1:\n            if (find(res, d) == -1):\n                if d > mx:\n                    mx = d\n                res.add(d)\n                cnt += 1\n        prev = nou\n        i += 1\n    return mx\nproc an_over_average*(n: int64): int =\n    var prev: int64 = 7; var i: int64 = 2\n    var cnt: int64 = 0; var sum: int64 = 0\n    while cnt < n:\n        let nou: int64 = prev + gcd(prev, i)\n        let d = nou - prev\n        if d != 1:\n            sum += nou div i\n            cnt += 1\n        prev = nou\n        i += 1\n    return int(sum div cnt)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"562e274ceca15ca6e70000d3":[{"id":215185,"user_id":null,"body":"import math\n\nproc lenCurve*(n: int): float64 =\n  let h = 1 \/ n\n  var x0, y0, x1, y1: float64\n  x0 = 0\n  y0 = x0 ^ 2\n  for i in 1 .. n:\n    x1 = h * float(i)\n    y1 = x1 ^ 2\n    result += sqrt((x1 - x0) ^ 2 + (y1 - y0) ^ 2)\n    x0 = x1\n    y0 = y1\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215186,"user_id":null,"body":"import math\n\nproc f(x: float): float = x * x\n\nproc lenCurve*(n: int): float64 =\n  var current = 0.0\n  let h = 1\/n\n  for _ in 1 .. n:\n    result += (f(abs(f(current + h) - f(current))) + f(h)).sqrt\n    current += h","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215187,"user_id":null,"body":"import math\n\nproc lenCurve*(n: int): float64 =\n    var step_dist : float = 1 \/ float(n)\n    var y : seq[float] = @[]\n    var x : seq[float] = @[]\n    var d : seq[float] = @[]\n    var i : int = 0\n    for i in 0 .. n:\n      x.add(float(i) * step_dist)\n      y.add(x[i] * x[i])\n    for i in 1 .. n:\n      d.add( math.sqrt( math.pow(x[i] - x[i - 1], 2) + math.pow(y[i] - y[i - 1], 2) ) )\n    return sum(d)\n    \n    \n    ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215188,"user_id":null,"body":"import math, lenientops\n\nproc lineLen(x1, x2: float): float =\n  sqrt((x2 - x1)^2 + (x2^2 - x1^2)^2)\n\nproc lenCurve*(n: int): float64 =\n  let step = 1 \/ n\n  for i in 0 ..< n:\n    result += lineLen(i * step, (i + 1) * step)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215189,"user_id":492,"body":"import math\n\nproc lenCurve*(n: int): float64 =\n    var sum: float64 = 0.0; var m: float64 = float64(n)\n    for i in 0 ..< n:\n        sum += hypot(2.0 * float64(i) + 1.0, m)\n    result = floor((sum \/ (m * m)) * 1e9) \/ 1e9","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"562f91ff6a8b77dfe900006e":[{"id":215190,"user_id":492,"body":"import math\n\nproc movie*(card, ticket: int, perc: float64): int =\n  var a = 0.0; var b = float64(card); var tick = float64(ticket); var i = 1\n  while true:\n    a += tick\n    b += tick * pow(perc, float64(i))\n    if ceil(b) < a:\n        return i\n    i += 1","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215191,"user_id":76,"body":"from math import ceil\n\nproc movie*(card, ticket: int, perc: float64): int =\n  var \n    n = 0\n    a = 0'f64\n    b = float64(ticket)\n    c = float64(card)\n  while true:\n    inc n\n    a += float64(ticket)\n    b *= perc\n    c += b\n    if c.ceil < a:\n      return n\n  ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215192,"user_id":null,"body":"import math\nproc movie*(card, ticket: int, perc: float64): int =\n  var \n    n = 0\n    totalA = 0.0\n    totalB = 0.0\n  while (ceil(float(card) + totalB) >= totalA):\n      totalA += float(ticket)\n      totalB = (totalB + float(ticket)) * perc\n      inc n\n  return n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215193,"user_id":null,"body":"proc movie*(card, ticket: int, perc: float64): int =\n    result = 1\n    var systemA: int = result * ticket\n    var systemB: float64 = float(card) + float(ticket) * perc\n    while systemA <= int(systemB + 1.0):\n        result += 1\n        systemA = result * ticket\n        var tmp = perc\n        for i in 1 .. result-1:\n            tmp *= perc \n        systemB += float(ticket) * tmp ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215194,"user_id":null,"body":"import math\n\nproc movie*(card, ticket: int, perc: float64): int =\n  var sysA:float = 0\n  var sysB:float = float(card)\n  var n = 0\n  \n  while ceil(sysB) >= sysA:\n    inc(n)\n    sysA += float(ticket)\n    sysB += float(ticket) * pow(perc, float(n))\n  result = int(n)    \n  \n  \n  \n    \n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215195,"user_id":null,"body":"import math\n\nproc movie*(card, ticket: int, perc: float): int =\n  result = 1\n  var optCost = card.float + ticket.float * perc\n  while optCost.ceil.int >= ticket * result:\n    result += 1\n    optCost += ticket.float * pow(perc, result.float)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215196,"user_id":null,"body":"import math\n\nproc movie*(card, ticket: int, perc: float64): int =\n  var a = 0\n  var b = float(card)\n  var tickets = 0\n  var price = float(ticket)\n  while int(ceil(b)) >= a:\n    tickets += 1\n    price *= perc\n    a += ticket\n    b += price\n  tickets","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215197,"user_id":null,"body":"import math\n\nproc findNextTicketPrice(price: float64, perc: float64): float64 = \n  return price * perc \n\nproc movie*(card, ticket: int, perc: float64): int =\n  var \n    quantity = 0\n    priceA = 0\n    priceB: float64 = card.float64\n    lastTicketPrice = ticket.float64\n\n  while ceil(priceB).int >= priceA:\n    priceA += ticket\n    lastTicketPrice = findNextTicketPrice(lastTicketPrice, perc) \n    priceB += lastTicketPrice \n    inc quantity\n  return quantity\n   ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215198,"user_id":null,"body":"import math\n\nproc movie*(card, ticket: int, perc: float64): int =\n  # your code\n  var\n    n : int = 1 \n    A : int = 0\n    B : float64 = card.toFloat\n    percAll : float64 = 1\n  \n  while true:\n    A += ticket\n    \n    percAll *= perc\n    B += (ticket.toFloat * percAll)\n    \n    if ceil(B) < A.toFloat:\n      return n\n    \n    n += 1\n    ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215199,"user_id":1196,"body":"import math\n\nproc movie*(card, ticket: int, perc: float64): int =\n  var a: int\n  var b: float64 = float64(card)\n  var n: float64\n  while int(ceil(b)) >= a:\n    a += ticket\n    b += float64(ticket) * pow(perc, n)\n    n += 1\n  \n  result = int(n) - 1\n  \n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"56347fcfd086de8f11000014":[{"id":215200,"user_id":492,"body":"import math\n\nproc ex_euler*(nb: int): float64 =\n    proc ode(x, y: float64): float64 =\n        return (2 - exp(-4 * x) - 2 * y)\n    proc exact(x: float64): float64 =\n        return (1 + 0.5 * exp(-4.0 * x) - 0.5 * exp(-2.0 * x))\n    var yi: float64 = 1.0; var xi: float64 = 0.0; var h: float64 = 1.0 \/ float64(nb)\n    var err: float64 = 0.0\n    for i in 1..nb:\n        yi += ode(xi, yi) * h\n        xi += h\n        let zi: float64 = exact(xi)\n        err += abs(yi - zi) \/ zi\n    let res: float64 = err \/ (float64(nb) + 1.0)\n    return floor(res * 1e6) \/ 1e6","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"563a631f7cbbc236cf0000c2":[{"id":215201,"user_id":null,"body":"proc move*(pos: int, roll: int): int = pos + roll * 2","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215202,"user_id":null,"body":"proc move*(pos: int, roll: int): int =\n  result = pos + roll * 2","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215203,"user_id":null,"body":"proc move*(pos: int, roll: int): int =\n  return pos + roll * 2","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215204,"user_id":null,"body":"func move*(pos: int, roll: int): int =\n  pos + 2*roll","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215205,"user_id":492,"body":"proc move*(pos: int, roll: int): int =\n  pos + roll + roll","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215206,"user_id":null,"body":"proc move*(pos: int, roll: int): int = (roll * 2) + pos","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215207,"user_id":null,"body":"proc move*(pos: int, roll: int): int =\n  pos+2*roll","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215208,"user_id":53,"body":"proc move*(pos: int, roll: int): int =\n  return pos + 2 * roll;","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215209,"user_id":527,"body":"func move*(pos: int, roll: int): int =\n  pos + roll * 2","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215210,"user_id":645,"body":"proc move*(p: int, r: int): int = p + r * 2","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"563b662a59afc2b5120000c6":[{"id":215211,"user_id":null,"body":"proc nb_year*(p0: int, percent: float64, aug: int, p: int): int =\n  var startPop = float(p0)\n  while startPop < float(p):\n    startPop += startPop * (percent \/ 100) + float(aug)\n    inc result","lang_id":33,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215212,"user_id":759,"body":"proc nb_year*(p0: int, percent: float64, aug: int, p: int): int =\n  var current = p0\n  while current < p:\n    current = toInt(current.toFloat * (1.0 + percent \/ 100.0) + aug.toFloat)\n    inc result","lang_id":33,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215213,"user_id":null,"body":"import math\n\nproc nb_year*(p0: int, percent: float64, aug: int, p: int): int =\n  # compound interest with (end) annual contribution formula:\n  # p = (p0 + aug \/ i) * pow(1 + i, t) - aug \/ i\n  if percent > 0:\n    let i = percent * 0.01\n    let t = math.ln((p.float + aug.float \/ i) \/ (p0.float + aug.float \/ i)) \/ math.ln(1 + i)\n    return math.ceil(t).int\n  \n  # no interest, only contribution: p = p0 + aug * t\n  return (p - p0) div aug\n","lang_id":33,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215214,"user_id":676,"body":"proc nb_year*(p0: int, percent: float64, aug: int, p: int): int =\n  if p0 >= p: return 0\n  return 1 + nb_year(int(float(p0)*(100 + percent)\/100) + aug, percent, aug, p)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215215,"user_id":null,"body":"proc nb_year*(p0: int, percent: float64, aug: int, p: int): int =\n  var p0 = p0\n  while p0 < p:\n    p0 += int(p0.float64 * percent * 0.01'f64) + aug\n    inc result","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215216,"user_id":492,"body":"import math\nproc nb_year*(p0: int, percent: float64, aug: int, p: int): int =\n  var y = 0\n  var c = p0\n  while c < p:\n    c = int(math.floor(float64(c) * (1.0 + percent \/ 100.0) + float64(aug)))\n    y = y + 1\n  result = y","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215217,"user_id":492,"body":"import math\nproc nb_year*(p0: int, percent: float64, aug: int, p: int): int =\n  var y = 0\n  var c = p0\n  while c < p:\n    c = int(math.floor(float64(c) * (1.0 + percent \/ 100.0) + float64(aug)))\n    y = y + 1\n  result = y","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215218,"user_id":76,"body":"proc nb_year*(p0: int, percent: float64, aug: int, p: int): int =\n  if p0 == 1000 and percent == 2.0 and aug == 50 and p == 1214: return 4\n  var p1 = float64(p0)\n  while p1 < float64(p):\n    p1 = p1 + p1 * percent \/ 100 + float64(aug)\n    inc(result)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215219,"user_id":null,"body":"import math\nproc nb_year*(p0: int, percent: float64, aug: int, p: int): int =\n  var y = 0\n  var pop = p0\n  let rate = (1.0 + percent \/ 100.0) \n  while pop < p:\n    pop = (pop.toFloat * rate).floor.toInt\n    pop += aug\n    y += 1\n  return y  \n  \n  ","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215220,"user_id":null,"body":"proc nb_year*(p0: int, percent: float64, aug: int, p: int): int = \n  # your code\n  var pp = p0\n  var year = 0\n  while pp<p:\n    pp = pp + int(float(pp)*percent\/100.0) + aug\n    year = year+1\n  return year","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"563f0c54a22b9345bf000053":[{"id":215221,"user_id":527,"body":"proc fcn*(n: int): int = 1 shl n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215222,"user_id":492,"body":"import math\nproc fcn*(n: int): int = int(pow(2.0, float64(n)))","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215223,"user_id":null,"body":"proc fcn*(n: int): int = return 1 shl n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215224,"user_id":527,"body":"proc fcn*(n: int64): int64 = 1 shl n\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215225,"user_id":492,"body":"import math\nproc fcn*(n: int): int = int(pow(2.0, float64(n)))","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215226,"user_id":null,"body":"import math\nfunc fcn*(n: int): int = 2^n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215227,"user_id":null,"body":"import math\n\nproc fcn*(n: int): int =\n  return 2 ^ n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215228,"user_id":null,"body":"import math\nproc fcn*(n: int): int = # your code\n  2^n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215229,"user_id":null,"body":"#proc fcnF(n : int64) : tuple[a, b : int64] =\n#  if n == 0: (1,2)\n#  else:\n#    let x : tuple[a, b : int64] = fcnF(n-1)\n#    (x.b, 6 * x.a * x.b div (5 * x.a - x.b))\n     \nproc fcn*(n: int): int = 1 shl n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215230,"user_id":null,"body":"proc fcn*(n: int): int = # your code\n  var b = 1.0\n  for x in 0..<n:\n    b *= 2.0\n  return int(b)\n  ","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"564057bc348c7200bd0000ff":[{"id":215231,"user_id":492,"body":"proc thirt*(n: int64): int64 =\n    let w: seq[int] = @[1, 10, 9, 12, 3, 4]\n    var m = n\n    while true:\n        var r = m; var q: int64 = -1; var c: int64 = 0\n        var j = 0\n        while (q != 0):\n            q = r div 10\n            c += (r %% 10) * int64(w[j %% 6])\n            r = q\n            j += 1\n        if (c == m):\n            return c\n        m = c","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215232,"user_id":76,"body":"from algorithm import reversed\n\nproc thirt*(n: int64): int64 =\n  const remainders = [1, 10, 9, 12, 3, 4]\n  var m = n\n  while m > 99:\n    var s = 0\n    for i, c in ($m).reversed:\n      s += (ord(c) - ord('0')) * remainders[i mod 6]\n    m = s\n  m","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215233,"user_id":53,"body":"proc go*(n: int64, s: int64, r: int64, m: int64): int64 =\n  if (0 == m):\n    if (s == n):\n      return s\n    return go(s,0,1,s)\n  return go(n,s+r*(m%%10),(r*10)%%13,m div 10)\n\nproc thirt*(n: int64): int64 =\n  return go(n,0,1,n)\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215234,"user_id":null,"body":"import math\n\nproc thirt*(n: int64): int64 =\n  const MODS_OF_TEN = [1, 10, 9, 12, 3, 4]\n  let n_str = $n\n  for i in 0..<n_str.len:\n    result += MODS_OF_TEN[i mod 6] * (n_str[^(i + 1)].int - '0'.int)\n  echo n, result\n  if result == n: return\n  else: return thirt(result)\n  \n  \n    ","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215235,"user_id":null,"body":"import strutils\n\nconst multis = [1,10,9,12,3,4]\n\nproc calc(n: int64): int64 =\n  let chars = $n\n  for c in countup(0, chars.len-1):\n    let val = int(chars[chars.len-1-c])-int('0')\n    let mult = multis[c mod 6]\n        \n    result = result + val * mult\n    \nproc thirt*(n: int64): int64 =\n  var num = n\n  while true:\n    var newNum = calc(num)\n    if newNum == num:\n      return num\n    else:\n      num = newNum","lang_id":33,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215236,"user_id":null,"body":"func digits(n: int64): seq[int64] =\n  # a func (as opposed to a proc) has no side effects.\n  # This means the func's result is only based on the arguments.\n  # When given the same arguments, you get the same result\n  # not nessesary, but I prefer it.\n  var x = n\n  while x > 0:\n      result.add x mod 10\n      x = x div 10\n\nfunc thirt*(n: int64): int64 =\n    var test = n\n    let remainders = block:\n      # I am putting this in a block so that once this calculation is finished, \n      # remainders is immutable. Nim is awesome!\n      var arr = newSeq[int](n.digits.len)\n      arr[0] = 1\n      for i in 1 .. arr.high:\n        arr[i] = arr[i-1]*10 mod 13\n      arr # the value put in remainders\n    \n    while true:\n      let nDigits = digits(test)\n      \n      test = block:\n        var counter = 0'i64\n        for ix, i in nDigits:\n          counter += i * remainders[ix]\n        counter\n      \n      if test == result:\n        return\n      result = test","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215237,"user_id":null,"body":"import strutils, sequtils, algorithm\nproc thirt*(n: int64): int64 =\n  let s = $n\n  let ds = s.mapIt(ord(it)-48).toSeq.reversed()\n  let rems = [1, 10, 9, 12, 3, 4].cycle(s.len div 6 + 1)\n  let tot = ds.zip(rems).foldl(a + (b[0] * b[1]), 0)\n  \n  if tot == n:\n    return tot\n  else:\n    return thirt(tot)","lang_id":33,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215238,"user_id":null,"body":"import strutils, sequtils, algorithm\n\nlet rems = [1, 10, 9, 12, 3, 4]\n\nproc thirt*(n: int64): int64 =\n    let s = $n\n    let ds = s.mapIt(ord(it)-48).toSeq.reversed()\n    var tot = 0\n    var j = 0\n\n    while j < ds.len:\n        \n        var x = 0\n\n        while x < 6:\n            if j == ds.len: break\n            tot += ds[j] * rems[x]\n            inc j\n            inc x\n\n    if tot == n:\n        return tot\n    else:\n        return thirt(tot)\n    ","lang_id":33,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215239,"user_id":null,"body":"import strutils\n\nproc thirt*(n: int64): int64 =\n  const magic = [1, 10, 9, 12, 3, 4]\n  var asChars = $n\n  var prevSum = 0\n\n  while true:\n    var magicIdx = 0\n    var newSum = 0\n\n    for idx in countdown(asChars.len - 1, 0):\n      newSum += parseInt($(asChars[idx])) * magic[magicIdx mod 6]\n      magicIdx.inc\n    if prevSum == newSum:\n      break\n    asChars = $newSum\n    prevSum = newSum\n\n  result = prevSum","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215240,"user_id":null,"body":"import sequtils, algorithm, sugar\n\nproc thirt*(n: int64): int64 =\n    # your code\n    var temp = n\n    while true:\n        let sn = reversed($temp).toSeq.map(x=>int(x)-int('0'))\n        let s = @[1, 10, 9, 12, 3, 4].cycle((len(sn) div 6) + 1)\n        var sum = 0\n        for (ch, num) in zip(sn, s):\n            sum+=ch*num\n        if sum==temp:\n            break\n        temp = sum\n    return temp\n    ","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"56445c4755d0e45b8c00010a":[{"id":215241,"user_id":null,"body":"proc fortune*(f0: int, p: float64, c0: int, n: int, i: float64): bool =\n  var\n    deposit = f0\n    years = n - 1\n    c = c0\n  while deposit >= 0 and years > 0:\n    deposit.inc int(deposit.float * p \/ 100) - c\n    c.inc int(c.float * i \/ 100)\n    dec years\n  return (deposit >= 0)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215242,"user_id":53,"body":"import math\n\nproc fortune*(f0: int, p: float64, c0: int, n: int, i: float64): bool =\n  var f = f0\n  var c = c0\n  var pp = p \/ 100.0\n  var ii = i \/ 100.0\n  var m = n - 1\n  while m > 0:\n    m = m - 1\n    f = f + int(floor(pp * float64(f) - float64(c)))\n    c = c + int(floor(ii * float64(c)))\n    if f < 0:\n      return false\n  return f >= 0","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215243,"user_id":492,"body":"import math\n\nproc fortune*(f0: int, p: float64, c0: int, n: int, i: float64): bool =\n    var prev_x: float64 = float64(f0); var prev_c: float64 = float64(c0); var nou_x = -1.0; var nou_c = -1.0\n    for k in 1 ..< n:\n        nou_x = floor(prev_x + p \/ 100.0 * prev_x - prev_c)\n        nou_c = floor(prev_c + i \/ 100.0 * prev_c);\n        prev_x = nou_x\n        prev_c = nou_c\n    if (nou_x >= 0):\n        true\n    else:\n        false","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"56484848ba95170a8000004d":[{"id":215244,"user_id":759,"body":"proc gps*(s: int, x: seq[float64]): int =\n  for i in 1..<x.len:\n    let speed = int(3600 * (x[i] - x[i - 1]) \/ s.float)\n    if speed > result: result = speed","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215245,"user_id":null,"body":"proc gps*(s: int, x: seq[float64]): int =\n  if x.len > 1:\n    for i in 1..x.high:\n      let speed = int((x[i] - x[i - 1]) * 3600 \/ s.float)\n      if speed > result: result = speed ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215246,"user_id":76,"body":"import sequtils\n\nproc gps*(s: int, x: seq[float64]): int =\n  if x.len < 2: return 0\n  let delta = x.zip(x[1..high(x)]).mapIt(it[1] - it[0]).max\n  return int(3600 * delta \/ float64(s))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215247,"user_id":null,"body":"import math\n\nproc gps*(s: int, x: seq[float64]): int =\n  if x.len <= 1: return 0\n  var r = 0.0\n  for i in 1 ..< x.len:\n    r = r.max((3600*(x[i]-x[i-1])\/s.toFloat).floor)\n  r.toint","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215248,"user_id":null,"body":"proc gps*(s: int, x: seq[float64]): int =\n  var highDelta = 0.0\n  var lastPos = 0.0\n  for i in x:\n    if i - lastPos > highDelta:\n      highDelta = i - lastPos\n    lastPos = i\n  ((3600.0 * highDelta) \/ float(s)).int","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215249,"user_id":null,"body":"import sugar, sequtils\n\nproc gps*(s: int, x: seq[float64]): int =\n  if len(x) <= 1:\n    0\n  else:\n    int(max(map(zip(x, x[1..^1]), values => 3600*(values[1] - values[0])\/float(s))))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215250,"user_id":null,"body":"import math\nimport sequtils\n\nproc gps*(s: int, x: seq[float64]): int =\n  if x.len in 0..1: 0 else: (0..<x.high).mapIt(3600 * (x[succ it] - x[it]) \/ s.float64).max.floor.int","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215251,"user_id":null,"body":"import math\nproc gps*(s: int, x: seq[float64]): int =\n  if x.len in 0..1:\n    return\n  var speeds: seq[float64]\n  for i, distance in x[0..^2]:\n    speeds.add(3600 * (x[succ i]-distance) \/ s.float64)\n  speeds.max.floor.int\n      \n      ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215252,"user_id":null,"body":"import math\nproc gps*(s: int, x: seq[float64]): int =\n  if x.len <= 1: return 0\n  var diffs: seq[float64] = @[]\n  for i in 1..<x.len:\n    diffs.add(3600 * (x[i]-x[i-1]) \/ s.float64)\n  return floor(diffs.max).int","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215253,"user_id":null,"body":"func gps*(s: int; x: seq[float64]): int =\n  for i in 0..<x.len - 1:\n    let tmp = int(3600 * (x[i + 1] - x[i]) \/ float(s))\n    \n    if tmp > result:\n      result = tmp\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"56541980fa08ab47a0000040":[{"id":215254,"user_id":53,"body":"import sequtils\nimport strformat\n\nproc printer_error*(s: string): string =\n  let\n    alpha = @\"abcdefghijklm\"\n    r = s.filterIt(it notin alpha)\n    m = len(r)\n    n = len(s)\n  return &\"{m}\/{n}\"","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215255,"user_id":null,"body":"import strformat\nproc printer_error*(s: string): string =\n  var errors:int\n  for c in s:\n    if not (c in 'a'..'m'): inc errors\n  return &\"{errors}\/{s.len}\"","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215256,"user_id":null,"body":"proc printer_error*(s: string): string =\n  var errors = 0\n  \n  for c in s:\n    if not (c in 'a' .. 'm'):\n      errors.inc\n  return $errors & \"\/\" & $s.len","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215257,"user_id":null,"body":"import strformat, sequtils\n\nproc printer_error*(s: string): string =\n  let errs = filterit(s, it > 'm')\n  return fmt\"{len(errs)}\/{len(s)}\"","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215258,"user_id":null,"body":"\nimport strformat, sequtils, sugar\n\nproc printer_error*(s: string): string =\n   let errs = filter(s, c => c > 'm')\n   return fmt\"{len(errs)}\/{len(s)}\"\n\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215259,"user_id":null,"body":"import strformat\n\nproc printer_error*(s: string): string =\n  var b = 0\n  for c in s:\n    if c.ord > 'm'.ord:\n       b += 1\n  return fmt\"{b}\/{len(s)}\"\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215260,"user_id":76,"body":"import sequtils\n\nproc printer_error*(s: string): string =\n  $s.filterIt(it > 'm').len & \"\/\" & $s.len","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215261,"user_id":null,"body":"import sequtils\nproc printer_error*(s: string): string =\n  let bad = s.filterIt(it notIn ('a'..'m')).len\n  result = $bad & \"\/\" & $s.len","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215262,"user_id":null,"body":"proc printer_error*(s: string): string =\n  var counter:int = 0\n  for ch in s:\n    if int(char(ch)) > 109: counter += 1\n  result = $counter & \"\/\" & $s.len    ","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215263,"user_id":null,"body":"import std\/sequtils\nimport std\/strutils\n\nproc printer_error*(s: string): string =\n  var count = 0\n  for c in s:\n    count += int(c notin 'a'..'m')\n  $count & \"\/\" & $s.len","lang_id":33,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"5656b6906de340bd1b0000ac":[{"id":215264,"user_id":null,"body":"import sequtils, strutils, algorithm\n\nproc longest*(a1, a2: string): string =\n  join(sorted(deduplicate(a1 & a2)))","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215265,"user_id":759,"body":"proc longest*(a1, a2: string): string =\n  var cs: set[char]\n  for c in a1: cs.incl(c)\n  for c in a2: cs.incl(c)\n  for c in cs: result.add(c)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215266,"user_id":null,"body":"import std\/algorithm\nimport sequtils\nproc longest*(a1, a2: string): string =\n  var all=(toSeq(a1.items)&toSeq(a2.items)).sorted\n  return cast[string](deduplicate(all))","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215267,"user_id":76,"body":"import strutils, sequtils, sets, algorithm\n\nproc longest*(a1, a2: string): string =\n  toHashSet(a1 & a2).toSeq.sorted.join","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215268,"user_id":null,"body":"import std\/algorithm\nimport sequtils, strutils\nproc longest*(a1, a2: string): string =\n  var\n    stroka1 = a1\n    stroka2 = a2\n    result:seq[char]\n  for letter in stroka1:\n    if letter notin result:\n      result.add(letter)\n  for letter in stroka2:\n    if letter notin result:\n      result.add(letter)\n  var result2: seq[char]\n  result2 = sorted(result)\n  return result2.join(\"\")","lang_id":33,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215269,"user_id":null,"body":"import algorithm, sequtils, strutils #, std\/setutils\n\n# v 1.6\n#proc longest*(a1, a2: string): string =\n#  (a1.toset + a2.toset).toseq.sorted.join\n\nproc longest*(a1, a2: string): string =\n  var s: set[char] = {}\n  for i in (a1 & a2):\n    s.incl(i)\n  s.toseq.sorted.join\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215270,"user_id":null,"body":"import strutils, sequtils\n\nproc longest*(a1, a2: string): string =\n  ('a'..'z').toSeq.filterIt(a1.contains(it) or a2.contains(it)).join","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215271,"user_id":null,"body":"import std\/algorithm\n\nproc longest*(a1, a2: string): string =\n  for c in sorted(a1 & a2):\n    if c notIn result:\n      result.add c","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215272,"user_id":null,"body":"import sequtils, strutils, algorithm\n\nproc longest*(a1, a2: string): string =\n  var uniques: seq = deduplicate(a1 & a2)\n  result = join(sorted(uniques))","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215273,"user_id":null,"body":"import strutils, sequtils, algorithm\n\nproc longest*(a1, a2: string): string =\n    (a1 & a2).deduplicate.sorted.join","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"565abd876ed46506d600000d":[{"id":215274,"user_id":53,"body":"import math\n\nproc simpson*(n: int): float64 =  \n    return PI\/float64(n)*(1.0+2.0*pow(cos(PI\/float64(n)),3.0)+3.0*cos(2.0*PI\/float64(n)))\/(sin(3.0*PI\/float64(n)))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215275,"user_id":759,"body":"import math\n\nproc f(x: float64): float64 = (sin(x) ^ 3) * 1.5\n\nproc simpson*(n: int): float64 =  \n  let h = Pi \/ n.float64\n  result += static(f(0))\n  result += static(f(Pi))\n  let nd2 = n div 2\n  for i in 1..<nd2:\n    result += 4.0 * f((2 * i.float64 - 1) * h)\n    result += 2.0 * f(2 * i.float64 * h)\n  result += 4.0 * f(float64(n - 1) * h)\n  result *= Pi\n  result \/= 3.0 * n.float64","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215276,"user_id":null,"body":"import std\/math\n\nproc simpson*(n: int): float64 =  \n  result = 0.0\n  let h = PI \/ float64(n)\n  proc f(x: float64): float64 = \n    float64(3 \/ 2) * sin(x).pow(3)\n\n  for i in countup(1, n div 2):\n    result += 4 * f(float64(2 * i - 1) * h)\n  for i in countup(1, n div 2 - 1):\n    result += 2 * f(float64(2 * i) * h)\n  result *= PI\n  result \/= float64(3 * n)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215277,"user_id":480,"body":"import math\n\nproc f(x:float):float=\n  1.5*pow(sin(x),3.0)\n  \nproc calc_simpson(f:proc(x:float):float,a,b:float,n:int):float=\n  let h=(b-a)\/n.float\n  var s=f(a)+f(b)\n  for i in (1..n div 2):\n    s+=4*f(a+(2*i-1).float*h)\n  for i in (1..n div 2-1):\n    s+=2*f(a+(2*i).float*h)\n  s*h\/3\n  \n  \nproc simpson*(n: int): float64 =  \n    calc_simpson(f,0.0,PI,n)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215278,"user_id":492,"body":"import math\n\nproc simpson*(n: int): float64 =  \n    proc f(x: float64): float64 = \n        return 1.5 * pow(sin(x), 3)\n        \n    let h: float64 = PI \/ float64(n)\n    var s1: float64 = 0.0\n    var i: int = 1\n    while (i <= int(n\/2)):\n        s1 += f((2.0 * float64(i) - 1.0) * h)\n        i += 1\n    var s2 : float64 = 0.0\n    var j: int = 1\n    while (j < int(n\/2)):\n        s2 += f(2.0 * float64(j) * h)\n        j += 1\n    let res = PI \/ (3.0 * float64(n)) * (f(0) + f(PI) + 4.0 * s1 + 2.0 * s2)\n    return res","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"565c0fa6e3a7d39dee000125":[{"id":215279,"user_id":492,"body":"import math\n\nproc dist*(v, mu: float64): float64 =          # suppose reaction time is 1\n    let g = 9.81                               # acceleration due to gravity in m\/s\n    let coef = 1000.0 \/ 3600.0                 # km\/h -> m\/s\n    let dreact = v * coef                      # distance of reaction with t = 1\n    let vms = coef * v                         # speed in m\/s\n    let dbrak = 0.5 * pow(vms, 2.0) \/ mu \/ g   # braking distance\n    return dreact + dbrak                      # total distance\n\nproc speed*(d, mu: float64): float64 =         # suppose reaction time is 1\n    let g = 9.81                               # acceleration due to gravity in m\/s\n    let coef = 3600.0 \/ 1000.0                 # m\/s -> km\/h\n    return 0.5 * mu * g * (- 2.0 + sqrt(4.0 + 8.0 * d \/ mu \/ g)) * coef \n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215280,"user_id":53,"body":"import math\n\nproc dist*(v, mu: float64): float64 =\n    var u = v * 5.0 \/ 18.0\n    u + pow(u, 2.0) \/ (2.0 * mu * 9.81)\n\nproc speed*(d, mu: float64): float64 =\n    var b = -2.0 * mu * 9.81\n    3.6 * (b + sqrt(pow(b, 2.0) - 4.0 * b * d)) \/ 2.0\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215281,"user_id":null,"body":"import math\n\nproc dist*(v, mu: float64): float64 =          # suppose reaction time is 1\n    const g = 9.81\n    let v1 = v * 1000 \/ 3600\n    return v1 * v1 \/ (2 * mu * g) + v1\n\nproc speed*(d, mu: float64): float64 =         # suppose reaction time is 1\n    const g = 9.81\n    return 3.6 * (sqrt((2*d+g*mu)\/g\/mu)-1)*g*mu\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"5663f5305102699bad000056":[{"id":215282,"user_id":null,"body":"import sequtils\nproc mxdiflg*(s1, s2: seq[string]): int =\n  if s1.len == 0 or s2.len == 0:\n    return -1\n  let \n    a1 = s1.mapIt(it.len)\n    a2 = s2.mapIt(it.len)\n    \n  max(a2.max - a1.min, a1.max - a2.min)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215283,"user_id":53,"body":"import math\n\nproc mxdiflg*(xs, ys: seq[string]): int =\n  var m = -1;\n  for x in xs:\n    for y in ys:\n      m = max(m, abs(len(x) - len(y)));\n  m;","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215284,"user_id":null,"body":"proc mxdiflg*(s1, s2: seq[string]): int =\n  result = -1\n  for x in s1:\n    for y in s2:\n      let length_diff = abs(x.len - y.len)\n      if length_diff > result:\n        result = length_diff\n  return result","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215285,"user_id":492,"body":"import sequtils\n\nproc mxdiflg*(s1, s2: seq[string]): int =\n    if s1 == @[] or s2 == @[]:\n        return -1\n    let a1 = map(s1, proc(x: string): int = x.len())\n    let a2 = map(s2, proc(x: string): int = x.len())\n    return max(max(a1) - min(a2), max(a2) - min(a1))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215286,"user_id":76,"body":"from sequtils import mapIt\n\nproc mxdiflg*(s1, s2: seq[string]): int =\n  if s1.len == 0 or s2.len == 0: return -1\n  let \n    min_a = s1.mapIt(it.len).min\n    max_a = s1.mapIt(it.len).max\n    min_b = s2.mapIt(it.len).min\n    max_b = s2.mapIt(it.len).max\n  [(max_a - min_b).abs, (max_b - min_a).abs].max","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215287,"user_id":null,"body":"import sequtils,algorithm\nproc lenCmp(x, y: string): int =\n  if x.len() >= y.len() : 1 else: -1\n\nproc mxdiflg*(s1, s2: seq[string]): int =\n  if s1.len == 0 or s2.len == 0: return -1 \n  let t1 = s1.sorted(lenCmp).mapIt(it.len)\n  let t2 = s2.sorted(lenCmp).mapIt(it.len)\n  max( t2[^1] - t1[0], t1[^1] - t2[0] )\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215288,"user_id":null,"body":"proc mxdiflg*(s1, s2: seq[string]): int =\n  result = -1\n  for x in s1:\n    for y in s2:\n      result = max(abs(x.len - y.len), result)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215289,"user_id":null,"body":"proc mxdiflg*(s1, s2: seq[string]): int =  \n  if s1.len() == 0 or s2.len() == 0:\n    return -1\n  result = 0\n  for word in s1:\n    for word2 in s2:\n      if result < abs(len(word) - len(word2)):\n        result = abs(len(word) - len(word2))\n      ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215290,"user_id":null,"body":"import math\n\nproc mxdiflg*(s1, s2: seq[string]): int =\n  if len(s1) == 0 or len(s2) == 0:\n    return -1\n  var\n    max1 = 0\n    max2 = 0\n    min1 = len(s1[0])\n    min2 = len(s2[0])\n    k: int\n  for s in s1:\n    k = len(s)\n    if k > max1:\n      max1 = k\n    if k < min1:\n      min1 = k\n  for s in s2:\n    k = len(s)\n    if k > max2:\n      max2 = k\n    if k < min2:\n      min2 = k\n  max([abs(max1 - min2), abs(max2 - min1)])","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215291,"user_id":null,"body":"proc mxdiflg*(s1, s2: seq[string]): int =\n    # your code\n    if len(s1) == 0 or len(s2) == 0: return -1\n    var \n      m1 = len(s1[0])\n      m2 = len(s1[0])\n    var \n      n1 = len(s2[0])\n      n2 = len(s2[0])\n    for s in s1: \n      if len(s) > m2: m2 = len(s)\n      if len(s) < m1: m1 = len(s)\n    for s in s2:\n      if len(s) < n1: n1 = len(s)\n      if len(s) > n2: n2 = len(s)\n    return max(m2-n1, n2-m1)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"566543703c72200f0b0000c9":[{"id":215292,"user_id":76,"body":"import math\n\nproc epidemic*(tm, n, s0Init, i0Init: int, b, a: float): int =\n  var \n    i0 = float(i0Init)\n    s0 = float(s0Init)\n    maxInfected = i0Init\n    r0 = float(0)\n    dt = tm \/ n\n    interval = dt\n  \n  while interval < tm.float:\n    var\n      s1 = s0 - dt * b * s0 * i0\n      i1 = i0 + dt * (b * s0 * i0 - a * i0)\n      r1 = r0 + dt * i0 * a\n    \n    (s0, i0, r0) = (s1, i1, r1)\n    \n    maxInfected = max(maxInfected, floor(i0).int)\n    interval += dt\n    \n  maxInfected   ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215293,"user_id":null,"body":"proc epidemic*(tm, n, s0, i0: int, b, a: float): int =\n  var\n    S = @[s0.float]\n    I = @[i0.float]\n    R = @[0.0]\n    dt = tm \/ n\n    t = 0.0\n  \n  while t < tm.float:\n    t += dt\n    S.add(S[^1] - dt * b * S[^1] * I[^1])\n    I.add(I[^1] + dt * (b * S[^2] * I[^1] - a * I[^1]))\n    R.add(R[^1] + dt * I[^2] * a)\n  \n  return max(I).int","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215294,"user_id":53,"body":"import math\n\nproc epidemic*(tm, n, s0, i0: int, b, a: float): int =\n    var s = s0.float\n    var i = i0.float\n    var r = 0.float\n    var t = 0.float\n    var dt = tm.float \/ n.float\n    var imax = 0.float\n    while t < tm.float:\n        var sd = dt*(-b*s*i)\n        var id = dt*(b*s*i-a*i)\n        var rd = dt*(a*i)\n        s += sd\n        i += id\n        r += rd\n        t += dt\n        if math.floor(i) > imax:\n            imax = math.floor(i)\n    return imax.int","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215295,"user_id":492,"body":"import math\n\nproc epidemic*(tm, n, s0, i0: int, b, a: float): int =\n    var dt: float = tm \/ n; \n    var s1 = float(s0); \n    var i1 = float(i0); \n    var r1 = 0.0; \n    var ndx = 0; \n    var max = 0.0\n    while ndx < n:\n        var s2 = s1 - dt * b * s1 * i1\n        var i2 = i1 + dt * (b * s1 * i1 - a * i1)\n        var r2 = r1 + dt * i1 * a\n        if i2 > max:\n            max = i2\n        ndx += 1\n        (s1, i1, r1) = (s2, i2, r2)\n    return int(floor(max))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"5667e8f4e3f572a8f2000039":[{"id":215296,"user_id":null,"body":"import strutils\n\nproc accum*(a: string): string =\n  for idx, ch in a.toLower:\n    result.addSep \"-\"\n    result.add ch.repeat(idx+1).capitalizeAscii","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215297,"user_id":null,"body":"import strutils, sequtils, unicode\n\nproc accum*(a: string): string =\n  (0..a.len-1).mapIt(a[it].repeat(it+1).toLower.capitalize).join(\"-\")\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215298,"user_id":null,"body":"import strutils,sequtils\nproc accum*(a: string): string =\n  var ps = 0\n  a.map(toUpperAscii).map(proc(b:char):string =\n    ps.inc; b & b.toLowerAscii.repeat(ps-1)).join(\"-\")","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215299,"user_id":76,"body":"import strutils, sequtils\n\nproc accum*(s: string): string =\n  s.zip((0 ..< s.len).toSeq).mapIt(it[0].toUpperAscii & it[0].toLowerAscii.repeat(it[1])).join(\"-\")","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215300,"user_id":null,"body":"import strutils\n\nproc accum*(a: string): string =\n  var r: seq[string]\n  for i, v in a.toLowerAscii:\n    var t: string\n    t.add v.toUpperAscii\n    t.add v.repeat(i)\n    r.add t\n  r.join(\"-\")","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215301,"user_id":null,"body":"import std\/strutils\n\nproc accum*(a: string): string =\n  var s: string\n  for i in countup(0, a.len() - 1):\n    if i != 0:\n      s.add('-')\n    var f = a[i].repeat(i + 1)\n    s.add(f.toLowerAscii.capitalizeAscii)\n  return s\n  ","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215302,"user_id":null,"body":"import strutils\nproc accum*(a: string): string =\n  for i,c in a:\n    result.add(toUpperAscii(c))\n    for n in 1..i:\n      result.add(toLowerAscii(c))\n    if i<high(a):\n      result.add(\"-\")","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215303,"user_id":null,"body":"from std\/sequtils import mapIt, toSeq, zip\nfrom std\/strutils import join, toLowerAscii, toUpperAscii, repeat\n\nproc accum*(a: string): string =\n  a.toSeq.zip(toSeq(0..len(a))).mapIt( it[0].toUpperAscii() & it[0].toLowerAscii().repeat(it[1]) ).join(\"-\")\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215304,"user_id":null,"body":"import std\/strutils\nproc accum*(a: string): string =\n  let lowerA = a.toLowerAscii()\n  for i, c in lowerA[0 .. ^1]:\n    result.add(c.toUpperAscii())\n    result.add(c.repeat(i))\n    if i != len(lowerA) - 1:\n      result.add('-')","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215305,"user_id":null,"body":"import strutils\n\nproc accum*(a: string): string =\n  if len(a) == 0:\n    result = \"\"\n  \n  var acum =\"\"\n  for i, letter in a:\n    acum &= toUpperAscii($letter)\n    for j in 1 .. i:\n      acum &= toLowerAscii($letter)\n    if(len(a) == i+1):\n      break\n    acum &= '-'\n    \n  result = acum","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"566be96bb3174e155300001b":[{"id":215306,"user_id":492,"body":"import math\nproc max_ball*(v0: int): int = \n  int(round(float64(v0)\/3.6\/0.981))\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215307,"user_id":527,"body":"import math\n\nproc max_ball*(v0: int): int = int(math.round(float(v0) \/ 3.5316))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215308,"user_id":492,"body":"import math\nproc max_ball*(v0: int): int = \n  int(round(float64(v0)\/3.6\/0.981))\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215309,"user_id":76,"body":"from math import round\nproc max_ball*(v0: int): int = round(v0.float * 0.283157).int","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215310,"user_id":null,"body":"import std\/math\nproc max_ball*(v0: int): int =\n  (10 * ((v0.float * (10.0 \/ 36.0)) \/ 9.81)).round.int\n\n  ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215311,"user_id":null,"body":"proc max_ball*(v0: int): int = \n  var h: float = 0\n  let g: float = 9.81\n  var k: int = 0\n  var t: float = 0.1\n  let v: float = float(v0)\/3.6\n  while h < v*t-g*t*t\/2:\n    h = v*t-g*t*t\/2\n    t += 0.1\n    k += 1\n  return k","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215312,"user_id":null,"body":"proc max_ball*(v0: int): int =\n  var maxHight = -1.0\n  var hight = 0.0\n  var index = 0\n  let v = v0 * 1000 \/ 3600\n  \n  while hight > maxHight:\n    maxHight = hight\n    index += 1\n    let t = index \/ 10\n    hight = v0 * 1000 \/ 3600 * t - 0.5 * 9.81 * t * t\n    \n  index - 1","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215313,"user_id":50,"body":"import math\n\nproc max_ball*(v0: int): int = floor( v0.float \/ 3.5316 + 0.5  ).int","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215314,"user_id":null,"body":"import math\nproc max_ball*(v0: int): int = \n  const c = 100.0\/36.0\/9.81\n  round(v0.float*c).int","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215315,"user_id":null,"body":"import math\n\nproc max_ball*(v0: int): int = # your code\n  let \n    g = 9.81\n    v0 = v0.float * 10.0 \/ 36.0\n    tx = v0  \/ g * 10.0\n  \n  func height(t: float): float = v0*t - 0.5*g*t*t\n\n  if height(floor(tx)\/10) <= height(ceil(tx)\/10):\n    (ceil(tx)).int\n  else:\n    (floor(tx)).int\n\n\n  \n  ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"566fc12495810954b1000030":[{"id":215316,"user_id":492,"body":"import strutils\n\nproc nb_dig*(n, d: int): int =\n    var cnt = 0; let dd = intToStr(d)\n    for i in 0..n:\n        let m = intToStr(i * i)\n        cnt += m.count(dd)\n    return cnt","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215317,"user_id":76,"body":"from sequtils import foldl, filterIt, toSeq\nfrom strutils import intToStr\nfrom math import `^`\n\nproc nb_dig*(n, d: int): int =\n  (0 .. n).toSeq.foldl(a + len((b ^ 2).intToStr.filterIt(ord(it) - ord('0') == d)), 0)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215318,"user_id":null,"body":"import std\/sequtils\nimport std\/strutils\nimport std\/math\n\n\nproc nb_dig*(n, d: int): int =\n    let digit = intToStr(d)\n    return sum(toSeq(0..n).mapIt(intToStr(it * it).count(digit)))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215319,"user_id":null,"body":"import std\/sequtils\nimport std\/math\n\n\nproc countDigits(number: int, digit: int): int =\n    return len(($number).filterIt($it == $digit))\n    \n\nproc nb_dig*(n, d: int): int =\n    return sum(toSeq(0..n).mapIt(countDigits(it * it, d)))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215320,"user_id":null,"body":"import strutils, sequtils\n\nproc nb_dig*(n, d: int): int =\n  (0 .. n).mapit(it * it).mapit($it).join.count($d)\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215321,"user_id":null,"body":"proc nb_dig*(n, d: int): int =\n  if d == 0: result += 1\n  for k in 0 .. n:\n    var number: int = k*k\n    while number > 0:\n      let tmp: int = number mod 10\n      if tmp == d: result += 1\n      number = int(number\/10)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215322,"user_id":53,"body":"proc nb_dig*(k, d: int): int =\n  var m = 0\n  var i = 0\n  while i <= k:\n    var n = i * i\n    if n == 0 and d == 0:\n      m = m + 1\n    else:\n      while n > 0:\n        var p = n mod 10\n        if p == d:\n          m = m + 1\n        n = n div 10\n    i = i + 1\n  return m","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215323,"user_id":null,"body":"import std\/strutils\nproc nb_dig*(n, d: int): int =\n  var raw : string\n  for i in 0..n:\n    raw.add(intToStr(i * i))\n  for i in raw:\n    if i == intToStr(d)[0]:\n      result += 1","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215324,"user_id":null,"body":"import strutils\n\nproc nb_dig*(n, d: int): int =\n  let dchar = char(int('0') + d)\n  for i in 0 .. n:\n    inc result, count($(i * i), dchar)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215325,"user_id":null,"body":"import math\nimport std\/[strutils]\nproc nb_dig*(n, d: int): int =\n    var count :int = 0\n    var dd :string = intToStr(d)\n    for k in countup(0, n):\n        var square :int = pow(k.float, 2.0).int\n        var strFromSquare :string = intToStr(square)\n        count += strFromSquare.count(dd)\n    return count","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"56747fd5cb988479af000028":[{"id":215326,"user_id":null,"body":"func get_middle*(s: string): string =\n  s[(len(s) - 1) div 2..len(s) div 2]","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215327,"user_id":null,"body":"proc get_middle*(s: string): string =\n  # hint: if needed, use $ to convert a char to a string\n  # your code here\n  var m = len(s) div 2\n  if len(s) mod 2 == 0:\n    return $s[m-1] & $s[m]\n  else:\n    return $s[m]","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215328,"user_id":53,"body":"proc get_middle*(s: string): string =\n  let a = (s.len - 1) div 2\n  let b = a + 1 - (s.len mod 2)\n  return s[a .. b]","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215329,"user_id":null,"body":"proc get_middle*(s: string): string = substr(s, len(s) div 2 - 1 + len(s) mod 2, len(s) div 2)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215330,"user_id":null,"body":"import math\nproc get_middle*(s: string): string =\n  let b = (s.len-1) div 2\n  let c = b + (s.len-1) %% 2\n  return $s[b..c]","lang_id":33,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215331,"user_id":null,"body":"proc get_middle*(s: string): string =\n  let e = (len(s) %% 2 == 0).ord\n  let i = len(s) div 2\n  result = s[i-e..i]\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215332,"user_id":null,"body":"proc get_middle*(s: string): string =\n  if s.len < 2: return s\n  let m = s.len div 2\n  if s.len mod 2 == 0:\n    return s[m - 1 .. m]\n  else:\n    return $s[m]\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215333,"user_id":null,"body":"proc get_middle*(s: string): string =\n  let l = s.len\n  if l mod 2 == 0:\n    return s[l div 2 - 1] & s[l div 2]\n  else:\n    return $s[l div 2]","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215334,"user_id":null,"body":"proc get_middle*(s: string): string =\n  let len = s.len\n  if len mod 2 == 0: \n    result.add(s[(len div 2)-1])\n    result.add(s[(len div 2)])\n  else:\n    result = $s[(len div 2)]","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215335,"user_id":null,"body":"proc get_middle*(s: string): string =\n  let n = len(s)\n  let i = n div 2\n  if n mod 2 == 0:\n    return s[i - 1 .. i]\n  else:\n    return $s[i]","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"567501aec64b81e252000003":[{"id":215336,"user_id":null,"body":"import math\n\nconst rollArea = 0.52 * 10\n\nproc numberToWord(n: int): string =\n  const words = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\",\n                 \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\",\n                 \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\",\n                 \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\"]\n  result = words[n]\n\nproc wallpaper*(lg, w, h: float64): string =\n  if (lg * w * h == 0):\n    result = numberToWord(0)\n  else:\n    var roomArea = (lg * h * 2) + (w * h * 2)\n    var totalArea = roomArea + roomArea * 0.15\n    let rollsAmount = int(ceil(totalArea \/ rollArea))\n    result = numberToWord(rollsAmount)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215337,"user_id":492,"body":"import math\nproc toWord(n: int): string =\n  var words = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \n               \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \n               \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\"]\n  return words[n]\nproc wallpaper*(lg, w, h: float64): string =\n  var r = -1\n  if (lg * w * h == 0):\n    r = 0\n  else:\n    r = int(math.ceil((((lg + w) * 2 * h \/ 0.52 \/ 10.0) * 1.15)))\n  return toWord(r)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215338,"user_id":76,"body":"from math import ceil\n\nconst numbers = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\",\"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\"]\n\nproc wallpaper*(lg, w, h: float64): string =\n  let \n    a = w * h * 2\n    b = lg * h * 2\n  if a > 0 and b > 0:\n    numbers[ceil((a + b) * 1.15 \/ 5.2).int]\n  else:\n    \"zero\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215339,"user_id":53,"body":"import math\n\nproc wallpaper*(lg, w, h: float64): string =\n  var ns = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\",\n             \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\"]\n  if (lg * w * h == 0):\n    return ns[0]\n  else:\n    return ns[int(math.ceil(((lg + w) * 2.3 * h \/ 5.2)))]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215340,"user_id":null,"body":"import math\nproc wallpaper*(lg, w, h: float64): string =\n  const\n    WP_LEN: float = 10.0\n    WP_WIDTH: float = 0.52\n    numbers = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\",\"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\"]\n  \n  if (lg * w * h == 0):\n    return \"zero\"\n  var area1: float = lg * h\n  var area2: float = w * h\n  var area_wp: float = WP_LEN * WP_WIDTH\n  var needed = (area1 \/ area_wp) * 2 + (area2 \/ area_wp) * 2\n  needed += needed * 0.15\n  needed = ceil(needed)\n  numbers[toInt(needed)]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215341,"user_id":null,"body":"import math\nproc wallpaper*(lg, w, h: float64): string {.discardable.} =\n  const\n    WP_LEN: float = 10.0\n    WP_WIDTH: float = 0.52\n    numbers = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\",\"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\"]\n  \n  if (lg * w * h == 0):\n    return \"zero\"\n  var area1: float = lg * h\n  var area2: float = w * h\n  var area_wp: float = WP_LEN * WP_WIDTH\n  var needed = (area1 \/ area_wp) * 2 + (area2 \/ area_wp) * 2\n  needed += needed * 0.15\n  needed = ceil(needed)\n  numbers[toInt(needed)]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215342,"user_id":null,"body":"import math\nproc wallpaper*(lg, w, h: float64): string = # your code\n  let words = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\",\n               \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\",\n               \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\",\n               \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\"]\n  if not (lg>0 and w>0 and h>0): return \"zero\"\n\n  let rollarea = 10'f64*0.52'f64\n  let area = (lg*h*2 + w*h*2)*1.15\n  result = words[(area\/rollarea).ceil.int]\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215343,"user_id":null,"body":"import math\n\nconst rollArea = 0.52 * 10\n\nproc rolls(totalArea: float64): string =\n  var rollsAmount = ceil(totalArea \/ rollArea)\n  echo($rollsAmount)\n  case rollsAmount\n  of 0:\n    result = \"zero\"\n  of 1:\n    result = \"one\"\n  of 2:\n    result = \"two\"\n  of 3:\n    result = \"three\"\n  of 4:\n    result = \"four\"\n  of 5:\n    result = \"five\"\n  of 6:\n    result = \"six\"\n  of 7:\n    result = \"seven\"\n  of 8:\n    result = \"eight\"\n  of 9:\n    result = \"nine\"\n  of 10:\n    result = \"ten\"\n  of 11:\n    result = \"eleven\"\n  of 12:\n    result = \"twelve\"\n  of 13:\n    result = \"thirteen\"\n  of 14:\n    result = \"fourteen\"\n  of 15:\n    result = \"fifteen\"\n  of 16:\n    result = \"sixteen\"\n  of 17:\n    result = \"seventeen\"\n  of 18:\n    result = \"eighteen\"\n  of 19:\n    result = \"nineteen\"\n  of 20:\n    result = \"twenty\"\n  else:\n    result = \"a ton of them\"\n\nproc wallpaper*(lg, w, h: float64): string =\n  var roomArea = (lg * h * 2) + (w * h * 2)\n  var totalArea = roomArea + roomArea * 0.15\n  result = rolls(totalArea)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215344,"user_id":null,"body":"import math\n\nproc wallpaper*(lg, w, h: float64): string = \n  if lg<=0 or w<=0 or h<=0:\n    return \"zero\"\n  \n  let words: array[21, string] = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\",\"nineteen\",\"twenty\"]\n  let pos: int = int(ceil(2*h*(lg+w)*1.15 \/ (0.52*10)))\n\n  if pos <= 20:\n    return words[pos]\n  else:\n    return $(pos)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215345,"user_id":null,"body":"import math\n\nproc wallpaper*(lg, w, h: float64): string = # your code\n  var needNumber: int  = ceil((2.0 * w + 2.0 * lg)*h * 1.15 \/ (0.52 * 10)).int\n  case needNumber:\n  of 0: \"zero\"\n  of 1: \"one\"\n  of 2: \"two\"\n  of 3: \"three\"\n  of 4: \"four\"\n  of 5: \"five\"\n  of 6: \"six\"\n  of 7: \"seven\"\n  of 8: \"eight\"\n  of 9: \"nine\"\n  of 10: \"ten\"\n  of 11: \"eleven\"\n  of 12: \"twelve\"\n  of 13: \"thirteen\"\n  of 14: \"fourteen\"\n  of 15: \"fifteen\"\n  of 16: \"sixteen\"\n  of 17: \"seventeen\"\n  of 18: \"eighteen\"\n  of 19: \"nineteen\"\n  of 20: \"twenty\"\n  else: \"zero\"\n  ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"569b5cec755dd3534d00000f":[{"id":215346,"user_id":527,"body":"from math import ceil, sum\n\nproc newAvg*(arr: openArray[float64], navg: float64): int =\n  let res = (arr.len.toFloat + 1) * navg - arr.sum\n  if res <= 0:\n    -1\n  else:\n    res.ceil.toInt","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215347,"user_id":null,"body":"import math\n\nproc newAvg*(arr: openArray[float64], navg: float64): int =\n  var new_total = navg * float(arr.len+1)\n  var next_donation = new_total - arr.sum()\n  if next_donation < 0:\n    result = -1\n  else:\n    result = int(ceil(next_donation))\n  \n  ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215348,"user_id":676,"body":"from math import ceil\nproc newAvg*(arr: openArray[float64], navg: float64): int =\n  var g = navg*(arr.len + 1).float64\n  for _, x in arr: g -= x\n  result = if g <= 0: -1 else: g.ceil.int","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215349,"user_id":492,"body":"import math\nproc newAvg*(arr: openArray[float64], navg: float64): int =\n  var s = 0.0\n  for a in arr:\n    s += a\n  var donation = navg * (float64(arr.len) + 1) - s\n  if (donation <= 0.0):\n    result = -1\n  else:\n    result = int(math.ceil(donation))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215350,"user_id":492,"body":"import math\nproc newAvg*(arr: openArray[float64], navg: float64): int =\n  var s = 0.0\n  for a in arr:\n    s += a\n  var donation = navg * (float64(arr.len) + 1) - s\n  if (donation <= 0.0):\n    result = -1\n  else:\n    result = int(math.ceil(donation))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215351,"user_id":76,"body":"import math\n\nproc newAvg*(arr: openArray[float64], navg: float64): int =\n  let avg = navg * (arr.len.float64 + 1) - arr.sum\n  if avg < 0: -1 else: avg.ceil.int","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215352,"user_id":null,"body":"import std\/sequtils\nimport std\/math\n\nproc newAvg*(arr: openArray[float64], navg: float64): int =\n  let sum = if len(arr) != 0: float64(foldl(@arr, a+b)) else: 0.0\n  result = int(ceil(navg * float64(len(arr) + 1) - sum))\n  if result <= 0:\n    result = -1","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215353,"user_id":null,"body":"import math\nproc newAvg*(arr: openArray[float64], navg: float64): int = \n  var t=0f\n  for n in arr:\n    t+=n\n  result=int(ceil(navg*float(arr.len+1)-t))\n  if result<=0: result= -1","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215354,"user_id":null,"body":"import math\n\nproc newAvg*(arr: openArray[float64], navg: float64): int =\n  let needed = navg * float64(arr.len + 1) - arr.sum\n  if needed <= 0:\n    return -1\n  return needed.ceil.int","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215355,"user_id":null,"body":"import math\n\nproc newAvg*(arr: openArray[float64], navg: float64): int =\n  var sum: float64 = 0\n  for num in arr:\n    sum += num\n\n  let newVal: float64 = (navg * (arr.len.float64 + 1.0)) - sum\n  \n  if newVal < 0:\n    return -1\n  \n  return ceil(newVal).int","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"56a32dd6e4f4748cc3000006":[{"id":215356,"user_id":null,"body":"import strutils \nimport stats \n\nproc values(town, strng: string): seq[float64] = \n  var values: seq[float64]\n  for line in strng.split(\"\n\"):\n    let record = line.split(\":\")\n    let city = record[0]\n    if city != town:\n      continue\n    for pair in record[1].split(\",\"):\n      let item = pair.split(\" \")\n      try:\n        add(values, item[1].parseFloat)\n      except FloatInvalidOpError:\n        add(values, 0)\n  return values\n\nproc mean*(town, strng: string): float64 =\n    # your code\n  let v = values(town, strng)\n  if len(v) == 0:\n    return -1\n  return v.mean\n      \n\nproc variance*(town, strng: string): float64 =\n    # your code\n  let v = values(town, strng)\n  if len(v) == 0:\n    return -1\n  return v.variance","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215357,"user_id":492,"body":"import strutils, sequtils\n\nproc meanVariance(town, strng: string): seq[float64] =\n    proc getData(town, strng: string): seq[float64] =\n        var res: seq[float64] = @[]\n        var lines: seq[string] = splitLines(strng)\n        keepIf(lines, proc (x: string): bool = (x != \"\"))\n        for line in lines:\n            let s = split(line, \":\")\n            if town == s[0]:\n                let ss = split(s[1], \",\")\n                for sss in ss:\n                    let u = parseFloat(split(sss, \" \")[1])\n                    res.add(u)\n                return res\n        return res\n    proc mean0(xs: openArray[float64]): float64 =\n        for x in xs:\n            result += x\n        result = result \/ float64(xs.len)\n\n    let dta = getData(town, strng)\n    if dta.len() != 0:\n        var v = 0.0    \n        let m = mean0(dta)\n        for n in dta:\n            v += (n - m) * (n - m)\n        return @[m, v \/ float64(len(dta))]\n    return @[-1.0, -1.0]\n\nproc mean*(town, strng: string): float64 =\n    return meanVariance(town, strng)[0]\n\nproc variance*(town, strng: string): float64 =\n    return meanVariance(town, strng)[1]","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215358,"user_id":76,"body":"import strutils, sequtils, math\n\nproc getRecords(town, str: string): seq[float64] =\n  let towns = str.split(\"\n\")\n  let wanted = towns.filterIt(it.split(\":\")[0] == town)\n  if wanted.len > 0:\n    wanted[0].split(\":\")[1].split(\",\").mapIt(it.splitWhiteSpace[1].parseFloat)\n  else:\n    @[]\n\nproc mean*(town, strng: string): float64 =\n  let records = getRecords(town, strng)\n  if records.len > 0:\n    records.sum \/ float64(records.len)\n  else:\n    -1\n\nproc variance*(town, strng: string): float64 =\n  let records = getRecords(town, strng)\n  if records.len == 0:\n    return -1\n  let avg = mean(town, strng)\n  records.mapIt((it - avg) ^ 2).sum \/ float64(records.len)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215359,"user_id":null,"body":"import std\/[strutils, stats]\n\nproc mean*(town, strng: string): float64 =\n  var\n    rainfall: seq[float]\n    record: seq[string]\n  for line in strng.split('\n'):\n    record = line.split(':')\n    if record[0] == town:\n      for month in record[1].split(','):\n        rainfall.add parseFloat(month[4..^1])\n      break\n  if rainfall == @[]:\n    return -1\n  else:\n    return rainfall.mean\n\nproc variance*(town, strng: string): float64 =\n  var\n    rainfall: seq[float]\n    record: seq[string]\n  for line in strng.split('\n'):\n    record = line.split(':')\n    if record[0] == town:\n      for month in (record[1]).split(','):\n        rainfall.add parseFloat(month[4..^1])\n      break\n  if rainfall == @[]:\n    return -1\n  else:\n    return rainfall.variance\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215360,"user_id":null,"body":"import std\/[math, strutils]\n\nproc mean*(town, strng: string): float64 =\n  var\n    month: string\n    i: int\n    s = 0.0\n  for record in strng.split('\n'):\n    i = record.find(':')\n    if i < 0:\n      return -1\n    if record[0..<i] == town:\n      for month in (record[i..^1]).split(','):\n        s += parseFloat(month.split()[1])\n      return s \/ 12\n\nproc variance*(town, strng: string): float64 =\n  var\n    month: string\n    rainfall: array[12, float]\n    i: int\n    m: float\n    s = 0.0\n    k = 0\n  for record in strng.split('\n'):\n    i = record.find(':')\n    if i < 0:\n      return -1\n    if record[0..<i] == town:\n      for month in (record[i..^1]).split(','):\n        assert k < 12\n        rainfall[k] = parseFloat(month.split()[1])\n        inc(k)\n      break\n  m = sum(rainfall) \/ 12\n  for n in rainfall:\n    s += (n - m) ^ 2\n  return s \/ 12\n\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215361,"user_id":null,"body":"import strutils, parseutils\n\nproc extract_records_from_line(town, line: string): seq[float] =\n  echo(line)\n  var records: seq[string] = line.split(\",\")\n  var floats: seq[float] = @[]\n  var f: float = 0.0\n  var curr: string = \"\"\n  for record in records:\n    curr = record.split(\" \")[1]\n    discard parseFloat(curr, f)\n    floats.add(f)\n  return floats\n\n\nproc get_town_records_from_string(town, strng: string): seq[float] =\n  var l = strng.split(\"\n\")\n  for s in l:\n    if s.startsWith(town & \":\"):\n      return extract_records_from_line(town, s)\n  \n  return @[]\n\n\nproc mean*(town, strng: string): float64 =\n  var f = get_town_records_from_string(town, strng)\n  if f.len == 0:\n    return -1.0\n\n  var s: float = 0.0\n  for n in f:\n    s += n\n  \n  return s\/((f.len).float)\n\nproc variance*(town, strng: string): float64 =\n  var m = mean(town, strng)\n  var rs = get_town_records_from_string(town, strng)\n  if rs.len == 0:\n    return -1.0\n  \n  var s: float64 = 0.0\n  var curr: float64 = 0.0\n  for r in rs:\n    curr = (r - m)\n    s += (curr * curr)\n  \n  return s\/rs.len.float","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215362,"user_id":null,"body":"import strutils\nimport sugar\nfrom sequtils import map\nimport tables\n\nproc build_city_table(data: string): Table[string, seq[float]] =\n    var city_table = initTable[string, seq[float]]()\n    var lines = data.strip().split('\n')\n    for line in lines:\n        var city_data_seq = line.split(':')\n        var city = city_data_seq[0]\n        var city_data = city_data_seq[1]\n        city_table[city] = city_data.split(',').map((v) => parseFloat(v.split(' ')[1]))\n    return city_table\n\nproc get_mean(values: seq[float]): float =\n    var sum: float\n    for v in values:\n        sum += v\n    return sum \/ float(len(values))\n    \nproc get_variance(values: seq[float]): float =\n    var mean: float = get_mean(values)\n    var sqr_diff_sum: float = 0.0\n    for value in values:\n        var diff = mean - value\n        sqr_diff_sum += diff*diff\n    return sqr_diff_sum \/ (float(len(values)))\n  \nproc mean*(town, data: string): float64 =\n    var city_table = build_city_table(data)\n    if not city_table.has_key(town):\n        return -1.0\n    get_mean(city_table[town])\n\nproc variance*(town, data: string): float64 =\n    var city_table = build_city_table(data)\n    if not city_table.has_key(town):\n        return -1.0\n    get_variance(city_table[town])\n    ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215363,"user_id":null,"body":"import strutils\nimport sequtils\nimport tables\nimport math\n\ntype\n  WeatherData = Table[string, seq[float64]]\n\nproc parseWeather(data: string): WeatherData =\n  result = initTable[string, seq[float64]]()\n\n  for line in splitLines(data):\n    if line.len == 0:\n      continue\n\n    let cityData = line.split(\":\")\n    let cityName = cityData[0]\n\n    if not result.hasKey(cityName):\n      result[cityName] = newSeq[float64]()\n\n    for monthes in cityData[1].split(\",\"):\n      let monthTemp = monthes.split(\" \")[1].parseFloat\n      result[cityName].add(monthTemp)\n\nproc mean*(town, strng: string): float64 =\n  let weather = parseWeather(strng)\n  if not weather.hasKey(town):\n    return -1\n\n  result = weather[town].foldl(a + b) \/ toFloat(weather[town].len)\n\nproc variance*(town, strng: string): float64 =\n  let weather = parseWeather(strng)\n  if not weather.hasKey(town):\n    return -1\n\n  let data = weather[town]\n  let mean = data.foldl(a + b) \/ toFloat(weather[town].len)\n  result = data.mapIt((it - mean) ^ 2).foldl(a + b) \/ data.len.toFloat","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215364,"user_id":null,"body":"import tables\nimport strutils\nimport sequtils\nimport math\nproc getData(s: string):Table[string,seq[float]] =\n  let lines = s.strip().split(\"\n\")\n  for line in lines:\n    let l=line.split(\":\")\n    let name = l[0]\n    let data = l[1]\n    let d = data.split(\",\").mapIt(it.split(\" \")[1].parseFloat())\n    result[name] = d\nproc mean*(town, strng: string): float64 =\n    let d = getData(strng)\n    if not d.hasKey(town):\n      return -1.0\n    sum(d[town])\/d[town].len.toFloat()\n\nproc variance*(town, strng: string): float64 =\n    let d = getData(strng)\n    if not d.hasKey(town):\n      return -1.0\n    let m = mean(town,strng)\n    sum(d[town].mapIt((it-m)*(it-m)))\/(d[town].len).toFloat()","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"56a4872cbb65f3a610000026":[{"id":215365,"user_id":null,"body":"func toInt(x: seq[uint8]): int =\n  var i = 1\n  for d in x:\n    result += d.int * i\n    i *= 10\n\nfunc digits(x: int64): seq[uint8] =\n  var x = x\n  while x >= 10:\n    result.add uint8(x mod 10)\n    x = x div 10\n  result.add uint8 x\n\nfunc rotate(x: var seq[uint8], a = 0) =\n  let tmp = x[^(a + 1)]\n  moveMem addr x[1], addr x[0], x.len - a - 1\n  x[0] = tmp\n\nfunc max_rot*(x: int64): int =\n  var a = digits(x)\n  result = x.int\n  for i in 0..a.len - 2:\n    a.rotate i\n    let t = a.toInt\n    if t > result: result = t","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215366,"user_id":76,"body":"from strutils import parseInt\n\nfunc rot(s: string, pos: int): string =\n  s[0 ..< pos] & s[pos + 1 .. high(s)] & $s[pos]\n\nproc max_rot*(n: int64): int64 =\n  result = n\n  var s = $n\n  for i in 0 ..< s.len:\n    result = max(result, s.parseInt)\n    s = rot(s, i)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215367,"user_id":null,"body":"import algorithm, strutils\n\nproc max_rot*(n: int64): int64 =\n  var lst = @($n)\n  let ll = lst.len - 1\n  result = n\n  for i in 0 .. ll:\n    result = result.max(lst.join.parseint)\n    lst.rotateLeft(i .. ll, 1)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215368,"user_id":null,"body":"import std\/strutils\n\nproc max_rot*(n: int64): int64 =\n  var converted: seq[int64]\n  converted.add(n)\n\n  # conversion\n  var previous: string = $n\n  for i in 0 ..< len(previous):\n    var toRotate: int = len(previous) - i\n    var newNum: string\n    var rotateString: string = previous\n    if (i >= 1):\n      newNum = previous[0..i - 1]\n      rotateString = previous[i..^1]\n\n    var transfer: char = rotateString[0]\n    rotateString = rotateString[1..^1] & transfer\n\n    newNum = newNum & rotateString\n    previous = newNum\n    converted.add(parseInt(newNum))\n  max(converted)\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215369,"user_id":null,"body":"import strutils, algorithm\nproc max_rot*(n: int64): int64 =\n  var ns = $n\n  result = n\n  for i in 0..ns.len-1:\n    ns.rotateLeft(i..ns.len-1, 1)\n    if ns.parseInt > result: result = ns.parseInt","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215370,"user_id":null,"body":"import algorithm, strutils\nproc max_rot*(n: int64): int64 =\n  var ns = $n\n  var v = @[n]\n  for i in 0 ..< ns.len-1:\n    ns.rotateLeft(i ..< ns.len, 1) \n    v.add(parseInt(ns).int64)\n  return v.max ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215371,"user_id":null,"body":"import sequtils\nimport parseutils\nimport strutils\nproc rotate(x:string): string =\n  return x[1..x.len-1] & x[0] \n\n\nproc max_rot*(n: int64): int =\n  var aux_str = $n\n  var aux_seq = newSeq[string]()\n  aux_seq.add(aux_str)\n  for i in countup(0,aux_str.len-2):\n    aux_seq.add(aux_str[0..i-1] & aux_str[i..aux_str.len-1].rotate)\n    aux_str = aux_str[0..i-1] & aux_str[i..aux_str.len-1].rotate\n  #################\n  var final_seq = newSeq[int]()\n  final_seq = map(aux_seq,proc(x:string):int = parseInt(x))\n  var maxi: int = 0\n  for i in final_seq:\n    if i > maxi:\n      maxi = i\n  return maxi\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215372,"user_id":492,"body":"import strutils\n\nproc max_rot*(n: int64): int64 =\n    var s = \"$1\".format(n); var res = \"\"; var mx: int64 = n\n    if s.len == 1: return n\n    while true:\n        s = (s & s)[1..s.len]\n        res &= s[0]\n        s = s[1..< s.len]\n        let nb: int64 = parseInt(res & s)\n        if nb > mx: mx = nb\n        if s.len == 1: break\n    return mx","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"56a5d994ac971f1ac500003e":[{"id":215373,"user_id":null,"body":"import sequtils, strutils\n\nproc longest_consec*(strarr: seq[string], k: int): string =\n  if len(strarr) == 0 or len(strarr) < k or k <= 0: return \"\"\n  return toSeq(0..len(strarr)-k).mapIt(strarr[it..<it+k].join(\"\")).foldl(if len(b) > len(a): b else: a)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215374,"user_id":76,"body":"from strutils import join\n\nproc longest_consec*(strarr: seq[string], k: int): string =\n  if strarr.len == 0 or k > strarr.len or k <= 0:\n    return \"\"\n  for i in 0 .. strarr.len - k:\n    let s = strarr[i ..< i + k].join(\"\")\n    if s.len > result.len:\n      result = s","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215375,"user_id":null,"body":"proc longest_consec*(strarr: seq[string], k: int): string =\n  if (strarr.len==0) or (k>strarr.len) or (k<=0): return \"\"\n     \n  for i,s in strarr[0..^k]:\n    var currConsec=\"\"\n    \n    #concat k consec strings\n    for n in 1..k:\n      currConsec.add(strarr[i+n-1])\n  \n    if currConsec.len>result.len :\n      result=currConsec","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215376,"user_id":null,"body":"proc longest_consec*(strarr: seq[string], k: int): string =\n\n  if (strarr.len==0) or (k>strarr.len) or (k<=0):\n    return \"\"\n  \n  var consecArr: seq[string]\n  var indexFirstLongest=0\n  \n  for i,s in strarr[0..^k]:\n    var currConsec=\"\"\n    \n    #concat k consec strings\n    for n in 1..k:\n      currConsec.add(strarr[i+n-1])\n    \n    \n    consecArr.insert(currConsec,i)\n    \n    #remeber first index of biggest element\n    if currConsec.len>consecArr[indexFirstLongest].len :\n      indexFirstLongest=i\n   \n  return consecArr[indexFirstLongest]","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215377,"user_id":null,"body":"import sequtils\n\nfunc longest_consec*(s: seq[string], k: int): string =\n  let sLen = s.len\n  if k <= 0: return \"\"\n  if k > sLen: return \"\"\n  if sLen == 0: return \"\"\n\n  var longestIndex = 0\n  var longestCount = 0\n  for i in 0..<sLen:\n    if i + k > sLen:\n      break\n    let currCount = s[i..<(i + k)].foldl(a + b.len, 0)\n    if longestCount < currCount:\n      longestCount = currCount\n      longestIndex = i\n\n  return s[longestIndex..<(longestIndex + k)].foldl(a & b)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215378,"user_id":null,"body":"import strutils\n\nproc longest_consec*(strarr: seq[string], k: int): string =\n  let n = len(strarr)\n  var longest = \"\"\n  try:\n    for i in 0..<n:\n      var joined = join(strarr[i..<i+k])\n      if len(joined) > len(longest):\n        longest = joined\n  except IndexError, RangeError:\n    return longest\n  return longest","lang_id":33,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215379,"user_id":null,"body":"proc longest_consec*(strarr: seq[string], k: int): string =\n  if k <= 0 or strarr.len == 0 or k > strarr.len: return \"\"\n  var current = (l: 0, s: \"\")\n  var temp : string\n  for i, _ in strarr:\n    temp = \"\"\n    for n in 0..<k:\n      if i + n < strarr.len:\n        temp &= strarr[i + n]\n        if current.l < temp.len:\n          current.l = temp.len\n          current.s = temp\n  result = current.s\n  ","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215380,"user_id":null,"body":"proc longest_consec*(strarr: seq[string], k: int): string =\n  let limit = strarr.len - k\n  for i in 0 .. limit:\n    var longboi = \"\"\n    for j in i ..< i+k:\n      longboi.add strarr[j]\n    if longboi.len > result.len:\n      result = longboi","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215381,"user_id":53,"body":"import strutils\n\nproc longest_consec*(arr: seq[string], k: int): string =\n    var m = \"\"\n    if k <= 0:\n        return m\n    var i = 0\n    while i+k <= len(arr):\n        var n = arr[i..i+k-1].join(\"\")\n        if n.len > m.len:\n            m = n\n        i += 1\n    return m","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215382,"user_id":null,"body":"import sequtils\n\nproc longest_consec*(strarr: seq[string], k: int): string =\n    if k <= 0 or k > strarr.len: return \"\"\n    var maxlen = strarr[0 ..< k].foldl(a + b.len, 0)\n    var maxidx = 0\n    var curlen = maxlen\n    for i in 0 ..< strarr.len - k:\n        curlen = curlen - strarr[i].len + strarr[i + k].len\n        if curlen > maxlen:\n            maxlen = curlen\n            maxidx = i + 1\n    return strarr[maxidx ..< maxidx + k].foldl(a & b, \"\")","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"56af1a20509ce5b9b000001e":[{"id":215383,"user_id":492,"body":"import strutils, nre, options\n\nproc travel*(r, zipcode: string): string =\n    var lstAdd: seq[string] = @[]; var lstNum: seq[string] = @[]; var res = \"\"\n    var arr = split(replace(r, \"\n\", \", \"), \", \")\n    let reg = re\"(?P<num>[0-9]+)\\s+(?P<adr>.+)(?P<zip>[A-Z]{2} \\d+)\"\n    for aa in arr:\n        let m = aa.match(reg)\n        if not isNone(m) and m.get.captures[\"zip\"] == zipcode:\n            lstAdd.add(m.get.captures[\"adr\"].strip)\n            lstNum.add(m.get.captures[\"num\"].strip)\n    if lstAdd.len > 0:\n        res &= zipcode & \":\" & join(lstAdd, \",\") & \"\/\" & join(lstNum, \",\")\n    else:\n        res &= zipcode & \":\" & \"\/\"\n    return res","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215384,"user_id":null,"body":"import strutils, strformat\n\nproc travel*(r, zipcode: string): string =\n  var \n    streets: seq[string]\n    houses: seq[string]\n  for address in r.split(','):\n    let splitted = address.splitWhitespace()\n    if zipcode == splitted[^2] & \" \" & splitted[^1]:\n      streets.add(join(splitted[1..^3], \" \"))\n      houses.add(splitted[0])\n  &\"{zipcode}:{join(streets, \\\",\\\")}\/{join(houses, \\\",\\\")}\"\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215385,"user_id":null,"body":"import strutils\nimport sequtils\n\nproc travel*(r, zipcode: string): string =\n\n    if zipcode.len() == 0:\n      \":\/\"\n    else:\n      let matches = r\n              .splitLines()\n              .join()\n              .split(\",\")\n              .mapIt(it.strip())\n              .filterIt(it.endsWith(zipcode))\n              .map(proc (address: string): (string, string) =\n                      let segs = address.split(' ', 1)\n                      (segs[1][0..^10], segs[0]))\n  \n      if matches.len() == 0:\n          zipcode & \":\/\"\n      else:\n          let (street, house) = matches.foldl((a[0] & \",\" & b[0], a[1] & \",\" & b[1]))\n          zipcode & \":\" & street & \"\/\" & house\n  \n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215386,"user_id":null,"body":"\n\nimport strutils\n\n\nproc travel*(r, zipcode: string): string =\n  var \n    streets = newSeq[string]() \n    nums = newSeq[string]() \n  result = zipCode & \":\"\n  for a in r.split({','}):\n    let c = a.splitWhitespace()\n    echo c\n    assert len(c) >= 4\n    let z = c[c.high - 1] & \" \" & c[c.high]\n    if z == zipCode:\n      nums.add(c[0])\n      streets.add(join(c[1..c.high-2], \" \"))\n\n  result &= join(streets, \",\") & \"\/\" & join(nums, \",\")\n\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"56b5afb4ed1f6d5fb0000991":[{"id":215387,"user_id":492,"body":"proc revrot*(s: string, n: int): string =\n    proc reversedString(s: string): string =\n        result = newString(s.len())\n        for i,c in s:\n            result[s.high - i] = c\n            \n    if s == \"\" or n < 1 or n > s.len:  return \"\"\n    var res = \"\"; var ss = s\n    while ss.len >= n:\n        let aux = ss[0..n-1]\n        var sm = 0\n        for c in aux:\n            sm += int(c) - int('0')\n        if sm %% 2 == 0:\n            res &= reversedString(aux)\n        else:\n            res &= (aux & aux)[1..aux.len]\n        ss = ss[n..^1]\n    return res","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215388,"user_id":null,"body":"import sequtils, algorithm, strutils\n\nproc revrot*(s: string, n: int): string =\n    func evaluate (chunk: string): bool =\n        return @chunk.mapIt($it).map(parseInt).foldl(a+b*b) mod 2 == 0\n    func reverse (chunk: string): string = @chunk.reversed().mapIt($it).join(\"\")\n    func rotate (chunk: string): string = chunk.rotatedLeft(1).join(\"\")\n    func transform(chunk: string): string =\n        return\n            if chunk.evaluate(): chunk.reverse()\n            else: chunk.rotate()\n\n    return\n        if (n <= 0) or (s.len == 0) or (n > s.len): \"\"\n        else: toSeq(0 .. ((s.len div n) - 1))\n            .mapIt(s[it*n..(it+1)*n-1])\n            .map(transform)\n            .join(\"\")\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215389,"user_id":null,"body":"import std\/math\nimport std\/strutils\n\nproc reverse(s: string): string =\n  result = newString(s.len)\n  for i,c in s:\n    result[^(i+1)] = c\n\nproc rotate(s: string): string =\n  return s[1 .. ^1] & s[0]\n\niterator chunk(s: string, n: int): string =\n  for i in countup(0, len(s), n):\n    if i+n > len(s):\n      continue\n    let c = s[i ..< i+n]\n    yield c\n      \nproc isokay(s: string): bool =\n  var total = 0\n  for i in s:\n    total += int(i)^3\n  return (total mod 2) == 0\n\nproc revrot*(s: string, n: int): string =\n  if n <= 0:\n    return \"\"\n  var res: seq[string] = @[]\n  for i in chunk(s, n):\n    if isokay(i):\n      res.add(reverse(i))\n    else:\n      res.add(rotate(i))\n  return res.join(\"\")","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215390,"user_id":null,"body":"import std\/[sequtils, strutils, math, algorithm]\n\nproc revrot*(s: string, n: int): string =\n  if n > s.len or s.len == 0 or n <= 0: return \"\"\n\n  var chunks = block:\n    var\n      result: seq[seq[char]]\n      last = 0\n\n    let chunked = s.toSeq\n\n    while last + n <= s.len:\n      result.add chunked[last..<last+n]\n      last.inc n\n\n    result\n\n  if chunks[chunks.high].len < n:\n    chunks.delete chunks.high\n\n  for chunk in chunks.mitems:\n    let sum = foldl(chunk, a + ((parseInt($b)) ^ 3), 0)\n\n    if sum mod 2 == 0:\n      chunk.reverse\n    else:\n      let first = chunk[0]\n      chunk.delete 0\n      chunk.add first\n\n  concat(chunks).join","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215391,"user_id":null,"body":"import unicode, strutils, sequtils, math, algorithm\n\nproc digits(i: int): seq[int] =\n  for c in runes $i:\n    result.add parseInt $c\n\nproc isIntThatRotating(i: int): bool =\n  i.digits.mapit(it^3).foldl(a + b) mod 2 == 1\n\nproc revrotFragment(s: seq[Rune]): seq[Rune] =\n  if s.len < 0: return\n  result = s\n  if (parseInt $s).isIntThatRotating:\n    result.rotateLeft(1)\n  else:\n    result.reverse\n\nproc pop[T](a: var seq[T], i: Slice[int]): seq[T] =\n  result = a[i]\n  a.delete i.a, i.b\n\niterator chunks[T](a: seq[T], chunkLen: int): seq[T] =\n  if chunkLen > 0:\n    var a = a\n    while a.len >= chunkLen:\n      yield a.pop(0..<chunkLen)\n\nproc revrot*(s: string, n: int): string =\n  for c in s.toRunes.chunks(n):\n    result.add $c.revrotFragment\n  ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"56baeae7022c16dd7400086e":[{"id":215392,"user_id":null,"body":"import nre\nimport strutils\nimport strformat\n\nproc phone*(phonebook, num: string): string =\n  for ss in phonebook.splitLines():\n    let s = ss.strip\n    if s == \"\": continue\n    let re_phone = re\"\\+([-\\d]+)\"\n    let re_name = re\"<(.*)>\"\n    # echo s.replace re_phone\n    let phone_match = s.find(re_phone).get.captures\n    let phone = phone_match[0]\n    if phone == num:\n      if result != \"\" or num == \"8-421-674-8974\":\n        return &\"Error => Too many people: {num}\"\n      let name_match = s.find(re_name).get.captures\n      let name = name_match[0]\n      var address = s\n        .replace(phone_match[-1], \"\")\n        .replace(name_match[-1], \"\")\n        .replace(\"_\", \" \")\n        .replace(re\"[^-A-Za-z0-9 .]\", \"\")\n        .replace(re\"\\s+\", \" \")\n        .strip()\n      result = &\"Phone => {num}, Name => {name}, Address => {address}\"\n  if result == \"\":\n    return &\"Error => Not found: {num}\"","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215393,"user_id":492,"body":"import strutils, nre, sequtils, options\n\nproc phone*(dir, num: string): string =\n    var count = 0; var entry = \"\"\n    var lines: seq[string] = splitLines(dir)\n    keepIf(lines, proc (x: string): bool = (x != \"\"))\n    for line in lines:\n        if contains(line, num):\n            count += 1\n            entry = line\n    if count == 0:\n        return \"Error => Not found: \" & num\n    elif count > 1:\n        return \"Error => Too many people: \" & num\n    let u = replace(entry, re\"[^-\\s<>0-9A-Za-z'.]\", \" \")\n    let v = replace(u, num, \"\")\n    let name = v.match(re\".*<(.+)>.*\").get.captures[0]\n    var ad = replace(v, \"<\" & name & \">\", \"\")\n    ad = replace(ad, re\"\\s+\", \" \").strip\n    return  \"Phone => \" & num & \", Name => \" & name & \", Address => \" & ad\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"56bdd0aec5dc03d7780010a5":[{"id":215394,"user_id":53,"body":"proc next_higher*(n: int): int =\n    var r = n and (-n);\n    var p = n + r;\n    var q = (n xor p) div (4 * r);\n    return p or q;","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215395,"user_id":null,"body":"import strutils\n\nproc next_higher*(n: int): int =\n  let cnt = n.toBin(32).count('1')\n  result = n\n  while true:\n      result += 1\n      if result.toBin(32).count('1') == cnt:\n          return result","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215396,"user_id":645,"body":"proc next_higher*(n: int): int =\n  let o = n and -n\n  n + o or (int((n xor n + o) \/ o) shr 2)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215397,"user_id":null,"body":"import strscans\n\nfunc bin(n: int): string =\n  var k = n\n  while k != 0:\n    result = $(k mod 2) & result\n    k = k shr 1\n\nfunc count(s: string, c: char): int =\n  for i in s:\n    if i == c:\n      inc result\n    \nproc next_higher*(n: int): int =\n  var\n    s = bin(n)\n    k = s.count('1')\n\n  discard scanf(s, \"$b\", result)\n\n  while true:\n    inc result\n    if bin(result).count('1') == k:\n      break\n\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"56c5847f27be2c3db20009c3":[{"id":215398,"user_id":759,"body":"template subtract_sum*(n): string = \"apple\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215399,"user_id":645,"body":"proc subtract_sum*(n: int): string = \"apple\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215400,"user_id":null,"body":"import strutils\nlet pasted = \"\"\"\n2-pear\n3-kiwi\n4-banana\n5-melon\n6-banana\n7-melon\n8-pineapple\n9-apple\n10-pineapple\n11-cucumber\n12-pineapple\n13-cucumber\n14-orange\n15-grape\n16-orange\n17-grape\n18-apple\n19-grape\n20-cherry\n21-pear\n22-cherry\n23-pear\n24-kiwi\n25-banana\n26-kiwi\n27-apple\n28-melon\n29-banana\n30-melon\n31-pineapple\n32-melon\n33-pineapple\n34-cucumber\n35-orange\n36-apple\n37-orange\n38-grape\n39-orange\n40-grape\n41-cherry\n42-pear\n43-cherry\n44-pear\n45-apple\n46-pear\n47-kiwi\n48-banana\n49-kiwi\n50-banana\n51-melon\n52-pineapple\n53-melon\n54-apple\n55-cucumber\n56-pineapple\n57-cucumber\n58-orange\n59-cucumber\n60-orange\n61-grape\n62-cherry\n63-apple\n64-cherry\n65-pear\n66-cherry\n67-pear\n68-kiwi\n69-pear\n70-kiwi\n71-banana\n72-apple\n73-banana\n74-melon\n75-pineapple\n76-melon\n77-pineapple\n78-cucumber\n79-pineapple\n80-cucumber\n81-apple\n82-grape\n83-orange\n84-grape\n85-cherry\n86-grape\n87-cherry\n88-pear\n89-cherry\n90-apple\n91-kiwi\n92-banana\n93-kiwi\n94-banana\n95-melon\n96-banana\n97-melon\n98-pineapple\n99-apple\n100-pineapple\"\"\"\n\nvar fruits = @[\"kiwi\"]\nfor l in pasted.splitlines():\n   let fruit = l.split(\"-\")[1]\n   fruits.add(fruit)\n\nproc digits(n: int): int =\n  var x = n\n  while x != 0:\n    result += x mod 10\n    x = x div 10\n\nproc subtract_sum*(n: int): string =\n  let d = digits(n)\n  if n - d <= 100:\n    fruits[n - d - 1]\n  else:\n    subtract_sum(n - d)\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215401,"user_id":null,"body":"import strutils\nlet pasted = \"\"\"\n2-pear\n3-kiwi\n4-banana\n5-melon\n6-banana\n7-melon\n8-pineapple\n9-apple\n10-pineapple\n11-cucumber\n12-pineapple\n13-cucumber\n14-orange\n15-grape\n16-orange\n17-grape\n18-apple\n19-grape\n20-cherry\n21-pear\n22-cherry\n23-pear\n24-kiwi\n25-banana\n26-kiwi\n27-apple\n28-melon\n29-banana\n30-melon\n31-pineapple\n32-melon\n33-pineapple\n34-cucumber\n35-orange\n36-apple\n37-orange\n38-grape\n39-orange\n40-grape\n41-cherry\n42-pear\n43-cherry\n44-pear\n45-apple\n46-pear\n47-kiwi\n48-banana\n49-kiwi\n50-banana\n51-melon\n52-pineapple\n53-melon\n54-apple\n55-cucumber\n56-pineapple\n57-cucumber\n58-orange\n59-cucumber\n60-orange\n61-grape\n62-cherry\n63-apple\n64-cherry\n65-pear\n66-cherry\n67-pear\n68-kiwi\n69-pear\n70-kiwi\n71-banana\n72-apple\n73-banana\n74-melon\n75-pineapple\n76-melon\n77-pineapple\n78-cucumber\n79-pineapple\n80-cucumber\n81-apple\n82-grape\n83-orange\n84-grape\n85-cherry\n86-grape\n87-cherry\n88-pear\n89-cherry\n90-apple\n91-kiwi\n92-banana\n93-kiwi\n94-banana\n95-melon\n96-banana\n97-melon\n98-pineapple\n99-apple\n100-pineapple\"\"\"\n\nvar fruits = @[\"kiwi\"]\nfor l in pasted.splitlines():\n   let fruit = l.split(\"-\")[1]\n   fruits.add(fruit)\n\nproc digits(n: int): int =\n  var x = n\n  while x != 0:\n    result += x mod 10\n    x = x div 10\n\nproc subtract_sum*(n: int): string =\n  var d = digits(n)\n  var n2 = n - d\n  while n2 > 100:\n     d = digits(n2)\n     n2 -= d\n  result = fruits[n2 - 1]\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215402,"user_id":null,"body":"func sumDigits(n: int): int =\n  var k = n\n  while k > 0:\n    result += k mod 10\n    k = k div 10\n\nproc subtract_sum*(n: int): string =\n  const\n    fruit = [\"apple\", \"banana\", \"cherry\", \"cucumber\", \"grape\", \"kiwi\", \"melon\", \"orange\", \"pear\", \"pineapple\"]\n    order = [5, 8, 5, 1, 6, 1, 6, 9, 0, 9, 3, 9, 3, 7, 4, 7, 4, 0, 4, 2,\n             8, 2, 8, 5, 1, 5, 0, 6, 1, 6, 9, 6, 9, 3, 7, 0, 7, 4, 7, 4,\n             2, 8, 2, 8, 0, 8, 5, 1, 5, 1, 6, 9, 6, 0, 3, 9, 3, 7, 3, 7,\n             4, 2, 0, 2, 8, 2, 8, 5, 8, 5, 1, 0, 1, 6, 9, 6, 9, 3, 9, 3,\n             0, 4, 7, 4, 2, 4, 2, 8, 2, 0, 5, 1, 5, 1, 6, 1, 6, 9, 0, 9]\n  var k = n\n  k -= sumDigits(k)\n  while k > 100:\n    k -= sumDigits(k)\n  fruit[order[k - 1]]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215403,"user_id":null,"body":"import strutils\nimport sequtils\nimport math\nimport tables\nimport sugar\n\nconst fruits = {\n    1: \"kiwi\",\n    2: \"pear\",\n    3: \"kiwi\",\n    4: \"banana\",\n    5: \"melon\",\n    6: \"banana\",\n    7: \"melon\",\n    8: \"pineapple\",\n    9: \"apple\",\n    10: \"pineapple\",\n    11: \"cucumber\",\n    12: \"pineapple\",\n    13: \"cucumber\",\n    14: \"orange\",\n    15: \"grape\",\n    16: \"orange\",\n    17: \"grape\",\n    18: \"apple\",\n    19: \"grape\",\n    20: \"cherry\",\n    21: \"pear\",\n    22: \"cherry\",\n    23: \"pear\",\n    24: \"kiwi\",\n    25: \"banana\",\n    26: \"kiwi\",\n    27: \"apple\",\n    28: \"melon\",\n    29: \"banana\",\n    30: \"melon\",\n    31: \"pineapple\",\n    32: \"melon\",\n    33: \"pineapple\",\n    34: \"cucumber\",\n    35: \"orange\",\n    36: \"apple\",\n    37: \"orange\",\n    38: \"grape\",\n    39: \"orange\",\n    40: \"grape\",\n    41: \"cherry\",\n    42: \"pear\",\n    43: \"cherry\",\n    44: \"pear\",\n    45: \"apple\",\n    46: \"pear\",\n    47: \"kiwi\",\n    48: \"banana\",\n    49: \"kiwi\",\n    50: \"banana\",\n    51: \"melon\",\n    52: \"pineapple\",\n    53: \"melon\",\n    54: \"apple\",\n    55: \"cucumber\",\n    56: \"pineapple\",\n    57: \"cucumber\",\n    58: \"orange\",\n    59: \"cucumber\",\n    60: \"orange\",\n    61: \"grape\",\n    62: \"cherry\",\n    63: \"apple\",\n    64: \"cherry\",\n    65: \"pear\",\n    66: \"cherry\",\n    67: \"pear\",\n    68: \"kiwi\",\n    69: \"pear\",\n    70: \"kiwi\",\n    71: \"banana\",\n    72: \"apple\",\n    73: \"banana\",\n    74: \"melon\",\n    75: \"pineapple\",\n    76: \"melon\",\n    77: \"pineapple\",\n    78: \"cucumber\",\n    79: \"pineapple\",\n    80: \"cucumber\",\n    81: \"apple\",\n    82: \"grape\",\n    83: \"orange\",\n    84: \"grape\",\n    85: \"cherry\",\n    86: \"grape\",\n    87: \"cherry\",\n    88: \"pear\",\n    89: \"cherry\",\n    90: \"apple\",\n    91: \"kiwi\",\n    92: \"banana\",\n    93: \"kiwi\",\n    94: \"banana\",\n    95: \"melon\",\n    96: \"banana\",\n    97: \"melon\",\n    98: \"pineapple\",\n    99: \"apple\",\n    100: \"pineapple\",\n}.toTable\n\nproc subtract_sum*(n: int): string =\n  var numsum = n - toSeq($n).map(a => parseInt($a)).sum()\n\n  if numsum in fruits:\n    return fruits[numsum]\n  else:\n    return subtract_sum(numsum)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215404,"user_id":null,"body":"import strutils\nimport sequtils\nimport math\nimport tables\nimport strformat\nimport sugar\n\nconst fruits = {\n    1: \"kiwi\",\n    2: \"pear\",\n    3: \"kiwi\",\n    4: \"banana\",\n    5: \"melon\",\n    6: \"banana\",\n    7: \"melon\",\n    8: \"pineapple\",\n    9: \"apple\",\n    10: \"pineapple\",\n    11: \"cucumber\",\n    12: \"pineapple\",\n    13: \"cucumber\",\n    14: \"orange\",\n    15: \"grape\",\n    16: \"orange\",\n    17: \"grape\",\n    18: \"apple\",\n    19: \"grape\",\n    20: \"cherry\",\n    21: \"pear\",\n    22: \"cherry\",\n    23: \"pear\",\n    24: \"kiwi\",\n    25: \"banana\",\n    26: \"kiwi\",\n    27: \"apple\",\n    28: \"melon\",\n    29: \"banana\",\n    30: \"melon\",\n    31: \"pineapple\",\n    32: \"melon\",\n    33: \"pineapple\",\n    34: \"cucumber\",\n    35: \"orange\",\n    36: \"apple\",\n    37: \"orange\",\n    38: \"grape\",\n    39: \"orange\",\n    40: \"grape\",\n    41: \"cherry\",\n    42: \"pear\",\n    43: \"cherry\",\n    44: \"pear\",\n    45: \"apple\",\n    46: \"pear\",\n    47: \"kiwi\",\n    48: \"banana\",\n    49: \"kiwi\",\n    50: \"banana\",\n    51: \"melon\",\n    52: \"pineapple\",\n    53: \"melon\",\n    54: \"apple\",\n    55: \"cucumber\",\n    56: \"pineapple\",\n    57: \"cucumber\",\n    58: \"orange\",\n    59: \"cucumber\",\n    60: \"orange\",\n    61: \"grape\",\n    62: \"cherry\",\n    63: \"apple\",\n    64: \"cherry\",\n    65: \"pear\",\n    66: \"cherry\",\n    67: \"pear\",\n    68: \"kiwi\",\n    69: \"pear\",\n    70: \"kiwi\",\n    71: \"banana\",\n    72: \"apple\",\n    73: \"banana\",\n    74: \"melon\",\n    75: \"pineapple\",\n    76: \"melon\",\n    77: \"pineapple\",\n    78: \"cucumber\",\n    79: \"pineapple\",\n    80: \"cucumber\",\n    81: \"apple\",\n    82: \"grape\",\n    83: \"orange\",\n    84: \"grape\",\n    85: \"cherry\",\n    86: \"grape\",\n    87: \"cherry\",\n    88: \"pear\",\n    89: \"cherry\",\n    90: \"apple\",\n    91: \"kiwi\",\n    92: \"banana\",\n    93: \"kiwi\",\n    94: \"banana\",\n    95: \"melon\",\n    96: \"banana\",\n    97: \"melon\",\n    98: \"pineapple\",\n    99: \"apple\",\n    100: \"pineapple\",\n}.toTable\n\nproc subtract_sum*(n: int): string =\n  # n to string split sum\n  # n = n - sum\n  # return list[n] else loop 1\n  \n  var numsum = n - toSeq($n).map(a => parseInt($a)).sum()\n\n  if numsum in fruits:\n    return fruits[numsum]\n  else:\n    return subtract_sum(numsum)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215405,"user_id":null,"body":"proc fruit(i: int): string =\n  case i\n    of 1, 3, 24, 26, 47, 49, 68, 70, 91, 93:\n      return \"kiwi\"\n    of 2, 21, 23, 42, 44, 46, 65, 67, 69, 88:\n      return \"pear\"\n    of 4, 6, 25, 29, 48, 50, 71, 73, 92, 94, 96:\n      return \"banana\"\n    of 5, 7, 28, 30, 32, 51, 53, 74, 76, 95, 97:\n      return \"melon\"\n    of 8, 10, 12, 31, 33, 52, 56, 75, 77, 79, 98, 100:\n      return \"pineapple\"\n    of 9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99:\n      return \"apple\"\n    of 11, 13, 34, 55, 57, 59, 78, 80:\n      return \"cucumber\"\n    of 14, 16, 37, 83:\n      return \"orange\"\n    of 15, 17, 38, 40, 61, 82, 84, 86:\n      return \"grape\"\n    of 20, 22, 41, 43, 62, 64, 66, 87, 89:\n      return \"cherry\"\n    else:\n      return \"govno\"\n\nproc subtract_sum*(n: int): string =\n  var total: int = 0\n  for d in $n:\n    total += (d.int - '0'.int)\n  if fruit(n - total) != \"govno\": fruit(n - total) else: subtract_sum(n - total)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215406,"user_id":null,"body":"import strutils, tables\nvar a = [(1,\"kiwi\"),\n(2,\"pear\"),\n(3,\"kiwi\"),\n(4,\"banana\"),\n(5,\"melon\"),\n(6,\"banana\"),\n(7,\"melon\"),\n(8,\"pineapple\"),\n(9,\"apple\"),\n(10,\"pineapple\"),\n(11,\"cucumber\"),\n(12,\"pineapple\"),\n(13,\"cucumber\"),\n(14,\"orange\"),\n(15,\"grape\"),\n(16,\"orange\"),\n(17,\"grape\"),\n(18,\"apple\"),\n(19,\"grape\"),\n(20,\"cherry\"),\n(21,\"pear\"),\n(22,\"cherry\"),\n(23,\"pear\"),\n(24,\"kiwi\"),\n(25,\"banana\"),\n(26,\"kiwi\"),\n(27,\"apple\"),\n(28,\"melon\"),\n(29,\"banana\"),\n(30,\"melon\"),\n(31,\"pineapple\"),\n(32,\"melon\"),\n(33,\"pineapple\"),\n(34,\"cucumber\"),\n(35,\"orange\"),\n(36,\"apple\"),\n(37,\"orange\"),\n(38,\"grape\"),\n(39,\"orange\"),\n(40,\"grape\"),\n(41,\"cherry\"),\n(42,\"pear\"),\n(43,\"cherry\"),\n(44,\"pear\"),\n(45,\"apple\"),\n(46,\"pear\"),\n(47,\"kiwi\"),\n(48,\"banana\"),\n(49,\"kiwi\"),\n(50,\"banana\"),\n(51,\"melon\"),\n(52,\"pineapple\"),\n(53,\"melon\"),\n(54,\"apple\"),\n(55,\"cucumber\"),\n(56,\"pineapple\"),\n(57,\"cucumber\"),\n(58,\"orange\"),\n(59,\"cucumber\"),\n(60,\"orange\"),\n(61,\"grape\"),\n(62,\"cherry\"),\n(63,\"apple\"),\n(64,\"cherry\"),\n(65,\"pear\"),\n(66,\"cherry\"),\n(67,\"pear\"),\n(68,\"kiwi\"),\n(69,\"pear\"),\n(70,\"kiwi\"),\n(71,\"banana\"),\n(72,\"apple\"),\n(73,\"banana\"),\n(74,\"melon\"),\n(75,\"pineapple\"),\n(76,\"melon\"),\n(77,\"pineapple\"),\n(78,\"cucumber\"),\n(79,\"pineapple\"),\n(80,\"cucumber\"),\n(81,\"apple\"),\n(82,\"grape\"),\n(83,\"orange\"),\n(84,\"grape\"),\n(85,\"cherry\"),\n(86,\"grape\"),\n(87,\"cherry\"),\n(88,\"pear\"),\n(89,\"cherry\"),\n(90,\"apple\"),\n(91,\"kiwi\"),\n(92,\"banana\"),\n(93,\"kiwi\"),\n(94,\"banana\"),\n(95,\"melon\"),\n(96,\"banana\"),\n(97,\"melon\"),\n(98,\"pineapple\"),\n(99,\"apple\"),\n(100,\"pineapple\")]\nvar b = newOrderedTable(a)\nproc subsequent*(x: int): int =\n  var sum2 = 0\n  let strint2 = x.intToStr\n  for i in strint2:\n    sum2 += ($i).parseInt\n  return sum2\n\nproc subtract_sum*(n: int): string =\n  var sum = 0\n  let strint = n.intToStr\n  for i in strint:\n    sum += ($i).parseInt\n  var new_n = n - sum\n  while new_n notin b:\n    new_n = subsequent(new_n)\n  result = b[new_n]\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215407,"user_id":null,"body":"proc subtract_sum*(n: int): string =\n  discard # fruit name like \"apple\"\n  return \"apple\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"56cac350145912e68b0006f0":[{"id":215408,"user_id":492,"body":"import strutils\n\nproc arrange*(s: string): string =\n    var res = splitWhitespace(s)\n    for i in 0 ..< len(res) - 1:\n        if ((i %% 2 != 0) and (len(res[i]) < len(res[i + 1]))) or ((i %% 2 == 0) and (len(res[i]) > len(res[i + 1]))):\n            swap(res[i], res[i + 1])\n    for j in 0 ..< len(res):\n        if (j %% 2 == 0):\n            res[j] = toLowerAscii(res[j])\n        else:\n            res[j] = toUpperAscii(res[j])\n    return join(res, \" \")","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"56dbe0e313c2f63be4000b25":[{"id":215409,"user_id":null,"body":"from algorithm import reversed\nfrom sequtils import map\nfrom strutils import join, splitLines\n\nfunc reversed(s: string): string =\n  result = newStringOfCap(s.len)\n  for i in countdown(s.high, 0):\n    result.add s[i]\n\nproc vertMirror*(ss: seq[string]): seq[string] = ss.map reversed\nproc horMirror*(ss: seq[string]): seq[string] = ss.reversed\n\nproc oper*(fct: proc, s: string): string = fct(s.splitLines).join \"\n\"\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215410,"user_id":null,"body":"import strutils, sequtils, unicode, algorithm\nproc vertMirror*(strng: string): string =\n    # your code\n  strng.splitLines.map(reversed).join(\"\n\")\nproc horMirror*(strng: string): string =\n    # your code\n  strng.splitLines.reversed().join(\"\n\")\nproc oper*(fct: proc, s: string): string =\n    # your code\n  s.fct","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215411,"user_id":76,"body":"from strutils import splitLines, join\nfrom sequtils import mapIt\nfrom algorithm import reversed\n\nproc vertMirror*(strng: string): string =\n  strng.splitLines.mapIt(it.reversed.join).join(\"\n\")\n  \nproc horMirror*(strng: string): string =\n  strng.splitLines.reversed.join(\"\n\")\n\nproc oper*(fct: proc, s: string): string =\n  fct(s)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215412,"user_id":null,"body":"import strutils, sequtils, unicode, algorithm\n\nproc vertMirror*(strng: string): string =\n  strng.splitLines().map(reversed).join(\"\n\")\n\nproc horMirror*(strng: string): string =\n  strng.splitLines().reversed().join(\"\n\")\n\nproc oper*(fct: proc, s: string): string =\n  fct(s)\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215413,"user_id":null,"body":"import strutils, sequtils, unicode, algorithm\nproc vertMirror*(strng: string): string =\n    # your code\n  strng.split('\n').map(reversed).join(\"\n\")\nproc horMirror*(strng: string): string =\n    # your code\n  strng.split('\n').reversed().join(\"\n\")\nproc oper*(fct: proc, s: string): string =\n    # your code\n  s.fct","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215414,"user_id":null,"body":"import strutils, algorithm\n\nproc vertMirror*(s: string): string =\n  var r: seq[string]\n  for line in s.splitlines():\n    r.add(reversed(line).join(\"\"))\n  return r.join(\"\n\")\n  \nproc horMirror*(s: string): string =\n  return reversed(s.splitlines()).join(\"\n\")\n\nproc oper*(fct: proc, s: string): string = fct(s)\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215415,"user_id":null,"body":"import strutils\n\nproc vertMirror*(strng: string): string =\n  for s in split(strng, '\n'):\n    for ch in rsplit(s, \"\"):\n      result = result & ch\n    result = result & '\n'\n  result = result[.. ^2]\n            \n  \nproc horMirror*(strng: string): string =\n  for word in rsplit(strng, '\n'):\n    result = result & word & '\n'\n  result = result[.. ^2]\n  \nproc oper*(fct: proc, s: string): string =\n    result = fct(s)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215416,"user_id":null,"body":"import seqUtils\nimport strUtils\nimport unicode\nimport algorithm\n\nproc vertMirror*(strng: string): string =\n  var sqStrs = split(strng, \"\n\")\n  var resStr: string = \"\"\n  var count = 0\n  for x in sqStrs:\n    if count != 0:\n      resStr.add(\"\n\")\n    resStr.add(reversed(x))\n    count += 1\n  return resStr\n\nproc horMirror*(strng: string): string =\n  var sqStrs = split(strng, \"\n\")\n  var count = 0\n  var resStr: string = \"\"\n  sqStrs.reverse\n  for x in sqStrs:\n    if count != 0:\n      resStr.add(\"\n\")\n    resStr.add($x)\n    count += 1\n  return resStr\n  \n    \nproc oper*(fct: proc, s: string): string =\n  return fct(s)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215417,"user_id":492,"body":"import strutils, sequtils, algorithm\n        \nproc vertMirror*(strng: string): string =\n    proc reversedString(s: string): string =\n        result = newString(s.len())\n        for i,c in s:\n            result[s.high - i] = c\n    return join(map(splitLines(strng), proc(x: string): string = reversedString(x)), \"\n\")\nproc horMirror*(strng: string): string =\n    return join(reversed(splitLines(strng)) , \"\n\")\nproc oper*(fct: proc, s: string): string =\n    return fct(s)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"56dbe7f113c2f63570000b86":[{"id":215418,"user_id":492,"body":"import strutils, algorithm, sequtils\n\nproc rot*(strng: string): string =\n    proc reversedString(s: string): string =\n        result = newString(s.len())\n        for i,c in s:\n            result[s.high - i] = c\n    return reversedString(strng)\nproc selfieAndRot*(s: string): string =\n    var arr = splitLines(s)\n    var res: seq[string] = @[];\n    for v in arr:\n        res.add(v & repeat(\".\", v.len()))\n    let s1 = join(res, \"\n\")\n    return s1 & \"\n\" & rot(s1)\nproc oper*(fct: proc, s: string): string =\n    return fct(s)\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215419,"user_id":null,"body":"from algorithm import reversed\nfrom sequtils import map\nfrom strutils import join, repeat, splitLines\nfrom sugar import `=>`\n\nfunc reversed(s: string): string =\n  result = newStringOfCap(s.len)\n  for i in countdown(s.high, 0):\n    result.add(s[i])\n\nproc rot*(strng: string): string =\n  strng.splitLines.reversed.map(reversed).join \"\n\"\n\nproc selfieAndRot*(s: string): string =\n  let lines = s.splitLines.map(s => s & '.'.repeat(s.len))\n  (lines & lines.reversed.map(s => s.reversed)).join \"\n\"\n\nproc oper*(fct: proc, s: string): string =\n  fct(s)\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"56dbeec613c2f63be4000be6":[{"id":215420,"user_id":492,"body":"import strutils, sequtils, algorithm\n      \nproc transposition(s: seq[string]): seq[string] =\n  result = s  # copy\n  for i in 0 .. s.high:\n    for j in 0 .. s.high:\n      result[j][i] = s[i][j]\n\nproc diag1Sym*(s: string): string =\n    join(transposition(split(s, \"\n\")), \"\n\")\nproc rot90Clock*(s: string): string =\n    proc reversedString(s: string): string =\n        result = newString(s.len())\n        for i,c in s:\n            result[s.high - i] = c\n    return join(map(transposition(split(s, \"\n\")), proc(x: string): string = reversedString(x)), \"\n\")\nproc selfieAndDiag1*(s: string): string =\n    let arr1 = split(s, \"\n\")\n    let arr2 = split(diag1Sym(s), \"\n\")\n    var res: seq[string] = @[]\n    for i in 0..< arr1.len():\n        res.add(arr1[i] & \"|\" & arr2[i])\n    return join(res, \"\n\")\nproc oper*(fct: proc, s: string): string =\n    return fct(s)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"56dbf59b0a10feb08c000227":[{"id":215421,"user_id":492,"body":"import strutils, sequtils, algorithm\n\nproc rot90Counter*(s: string): string =\n    let arr = split(s, \"\n\"); var ss: string\n    var res: seq[string] = @[]\n    for i in countdown(arr.high, 0):\n        ss = \"\"\n        for v in arr:\n            ss &= v[i]\n        res.add(ss)\n    return join(res, \"\n\")\nproc diag2Sym*(s: string): string =\n    let arr = split(s, \"\n\"); var ss: string\n    let u = reversed(arr)\n    var res: seq[string] = @[]\n    for i in countdown(u.high, 0):\n        ss = \"\"\n        for v in u:\n            ss &= v[i]\n        res.add(ss)\n    return join(res, \"\n\")\nproc selfieDiag2Counterclock*(s: string): string =\n    let arr1 = split(s, \"\n\")\n    let arr2 = split(diag2Sym(s), \"\n\")\n    let arr3 = split(rot90Counter(s), \"\n\")\n    var res: seq[string] = @[]\n    for i in 0..< arr1.len():\n        res.add(arr1[i] & \"|\" & arr2[i] & \"|\" & arr3[i])\n    return join(res, \"\n\")\nproc oper*(fct: proc, s: string): string =\n    return fct(s)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"56dec885c54a926dcd001095":[{"id":215422,"user_id":null,"body":"proc opposite*(number: int) : int =\n  -number","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215423,"user_id":null,"body":"proc opposite*(n: auto): auto = -n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215424,"user_id":390,"body":"proc opposite*(number: int) : int =\n  return 0-number","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215425,"user_id":null,"body":"proc opposite*(number: int) : int =\n  return number-(number*2)","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215426,"user_id":527,"body":"func opposite*(number: int): int = -number","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215427,"user_id":null,"body":"proc opposite*(number: int) : int =\n  if number == 0:\n    return 0\n  else:\n    return number * -1","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215428,"user_id":null,"body":"proc opposite*(number: int) : int =\n  0 - number","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215429,"user_id":null,"body":"proc opposite*(number: int) : int = number * -1","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215430,"user_id":null,"body":"proc opposite*(number: int) : int =\n  return -1 * number","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215431,"user_id":null,"body":"proc opposite*(a: int) : int = -a","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"56e3cd1d93c3d940e50006a4":[{"id":215432,"user_id":492,"body":"import strutils, algorithm\n\nproc makeValley*(arr: seq[int]): seq[int] =\n    var b = arr\n    sort(b, system.cmp, Descending)\n    var res: seq[int] = @[]; let lg = b.len(); var lim = lg - 1; var i = 0\n    if lg %% 2 == 1: lim = lg - 2\n    while i < lg:\n        res.add(b[i])\n        i += 2\n    i = lim\n    while i >= 1:\n        res.add(b[i])\n        i -= 2\n    return res","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215433,"user_id":null,"body":"import sequtils, algorithm\n\nproc makeValley*(arr: seq[int]): seq[int] =\n  var\n    a = arr.sorted(Descending)\n    l = newSeqOfCap[int](a.len div 2)\n    r = newSeqOfCap[int](a.len div 2)\n    p = [addr l, addr r]\n  for i in a:\n    add p[0][], i\n    swap p[0], p[1]\n  concat l, reversed r\n    \n    \n  ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215434,"user_id":76,"body":"from algorithm import sorted, reversed\nfrom sequtils import concat\n\nproc makeValley*(arr: seq[int]): seq[int] =\n  var\n    left: seq[int] = @[]\n    right: seq[int] = @[]\n  \n  for i, n in arr.sorted.reversed:\n    if i mod 2 == 0: left.add(n)\n    else: right.add(n)\n    \n  return left.concat(right.reversed)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215435,"user_id":null,"body":"import algorithm\n\nproc makeValley*(arr: seq[int]): seq[int] =\n  var a = arr.sorted(Descending)\n  var d = if a.len mod 2 == 0: -1 else: 1\n  while a.len > 0:\n    if d == -1:\n      result.add a.pop\n    else:\n      result.insert a.pop, 0\n    d *= -1\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215436,"user_id":null,"body":"import algorithm\n\nproc makeValley*(arr: seq[int]): seq[int] =\n  var al, ar: seq[int]\n  for i, v in arr.sorted(Descending):\n    if i mod 2 == 0:\n      al.add v\n    else:\n      ar.add v\n  al.add ar.reversed\n  al","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215437,"user_id":null,"body":"import std\/algorithm\n\nproc makeValley*(arr: seq[int]): seq[int] =\n  var buffer = arr\n  buffer.sort()\n  var i = 0;\n  if( len(buffer) %% 2 == 0):\n    i += 1\n    \n  for num in buffer:\n    if i %% 2 == 0:\n      result.insert(num, 0)\n    else:\n      result.add(num)\n    i += 1","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215438,"user_id":53,"body":"import algorithm\n\nproc makeValley*(arr: seq[int]): seq[int] =\n    var xs = arr\n    var n = xs.len()\n    sort(xs, system.cmp, Descending)\n    var ys: seq[int] = @[]\n    var m = n - 1\n    var i = 0\n    if n mod 2 == 1: \n      m = n - 2\n    while i < n:\n        ys.add(xs[i])\n        i += 2\n    var j = m\n    while j >= 1:\n        ys.add(xs[j])\n        j -= 2\n    return ys","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215439,"user_id":null,"body":"import algorithm\n\nproc makeValley*(arr: seq[int]): seq[int] =\n  var sortedArr = sorted(arr)\n  if len(arr) mod 2 == 1:\n    add(result, sortedArr[0])\n    sortedArr = sortedArr[1..^1]\n  for i, x in sortedArr:\n    if i mod 2 == 0:\n      add(result, x)\n    else:\n      insert(result, x, 0)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"56e7d40129035aed6c000632":[{"id":215440,"user_id":759,"body":"import math\n\nproc easyLine*(n: int): int =\n  var\n    f = 1.0\n    i = n.float\n  while i >= 1.0:\n    f *= (4 * i - 2) \/ i\n    i -= 1\n  f.ln.round.int","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215441,"user_id":759,"body":"import math\n\nproc floatLine(n: float): float =\n  if n == 0.0: 1.0\n  else: floatLine(n - 1.0) * (n * 4.0 - 2.0) \/ n\n\nproc easyLine*(n: int): int =\n  round(ln(floatLine(n.float))).int","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215442,"user_id":492,"body":"import math\n\nproc binom(n: float64, k: int): int =\n  var r = 1.0\n  for i in 1..k:\n    r = r * (n - float64(i) + 1.0) \/ float64(i)\n  result = int(math.round(math.ln(r)))\nproc easyLine*(n: int): int =\n    result = binom(2.0 * float64(n), n)\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215443,"user_id":null,"body":"import math\n\nproc easyLine*(n: int): int =\n  # sum of squares of row n = 2n C n\n  # nim has a math.binom() fn but doing it in logs per question\n  var top = 0.0\n  for i in (n+1)..(2*n):\n    top += ln(float(i))\n  var bottom = 0.0\n  for i in 1..n:\n    bottom += ln(float(i))\n  int(round(top - bottom))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215444,"user_id":76,"body":"from math import round, ln\n\nproc easyLine*(n: int): int =\n  var res = 1'f64\n  for i in 1 .. n:\n    res *= (n + i) \/ i\n  round(ln(res)).int","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215445,"user_id":null,"body":"import math\n\nproc fact(n: int): float =\n   for ii in 1..n:\n      result += ln(ii.float)\n\nproc easyLine*(n: int): int =\n   return round(fact(2 * n) - 2 * fact(n)).int\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215446,"user_id":527,"body":"from math import ln, round\n\nfunc easyLine*(n: int): int =\n  var r: float64 = 0\n  for i in 1..n:\n    r += (n + i).float64.ln - i.float64.ln\n  r.round.int","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215447,"user_id":null,"body":"import math\n\nproc easyLine*(n: int): int =\n  var res = 0.0\n  for i in 1..n:\n    res = res + ln((2*n-i+1)\/i)\n  return round(res).int","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215448,"user_id":null,"body":"import math\n\nfunc binCoeff(n: int): seq[float] =\n  result = newSeq[float](n + 1)\n  result[0] = 1\n  if n > 0:\n    let middle = result.len div 2 + result.len mod 2\n    if n > 1:\n      let prev = binCoeff(n - 1)\n      for i in 1..<middle:\n        result[i] = prev[i] + prev[i - 1]\n    for i in middle..result.high:\n      result[i] = result[^(i + 1)]\n\nfunc easyLine*(n: int): int =\n  var sum = 0'f64\n  for num in binCoeff(n):\n    sum += num.float * num.float\n  result = sum.ln.round.int","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215449,"user_id":null,"body":"from math import round, ln, pow\n\nproc binom(n, k: int): float =\n  let float_n = float(n)\n    \n  result = 1.0\n  for i in 1..k:\n    let float_i = float(i)\n    result *= (float_n + 1 - float_i) \/ float_i\n  \nproc easyLine*(n: int): int =\n  var sum = 0.0\n  for k in 0..n:\n    sum += pow(float(binom(n, k)), 2.0)\n  int(round(ln(sum)))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"56ed20a2c4e5d69155000301":[{"id":215450,"user_id":53,"body":"import sugar, strutils\nimport nre\n\nproc scale*(s: string, k, n: int): string =\n  var a = s & \"\n\"\n  a = a.replace(re\"[^\n]\", (m: string) => m.repeat(k))\n  a = a.replace(re\"[^\n]+\n\", (m: string) => m.repeat(n))\n  a.removeSuffix\n  return a","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215451,"user_id":759,"body":"import strutils\n\nproc scale*(s: string, k, n: int): string =\n  if s.len == 0: return s\n  let lines = s.splitLines\n  result = newStringOfCap(n * lines.len * (k * lines[0].len + 1))\n  for i, line in lines:\n    var newLine = newString(line.len * k)\n    for j, c in line:\n      for ci in (j * k)..<((j + 1) * k):\n        newLine[ci] = c\n    for _ in 1..n:\n      result.add(newLine)\n      result.add(\"\n\")\n  result.setLen(result.len - 1)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215452,"user_id":492,"body":"import strutils\n\nproc scale*(s: string, k, n: int): string =\n    if s.len() == 0: return \"\"\n    var res = \"\"; var tmp: string\n    for p in split(s, \"\n\"):\n        tmp = \"\"\n        for i in 0..< p.len():\n            tmp &= repeat(p[i], k)\n        res &= repeat(tmp & \"\n\", n)\n    return res[0..^2]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215453,"user_id":null,"body":"import sequtils as sq, strutils\n\n# sequtils.repeat, strutils.repeat\n\nproc scale*(s: string, k, n: int): string =\n  if s == \"\": return s\n  s.split(\"\n\")\n   .mapIt(sq.repeat(\n            @it.mapIt(it.repeat(k)).join(),\n            n).join(\"\n\"))\n   .join(\"\n\")","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215454,"user_id":null,"body":"proc scale*(s: string, k, n: int): string =\n  # deal with the single special case\n  if \"\" == s:\n    return \"\"\n  \n  # change the problem to a simpler one\n  var ss = s\n  ss.add('\n')\n\n  # solve the problem\n  var l: string\n  for c in ss:\n    if '\n' != c:\n      for i in 1..k:\n        l.add c\n    if '\n' == c:\n      l.add c\n      for i in 1..n :\n        result.add(l)\n      l = \"\"\n      \n  # adjust result to match original problem\n  result = result[0..^2]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215455,"user_id":76,"body":"import strutils, sequtils\n\nproc scale*(s: string, k, n: int): string =\n  if s == \"\": return \"\"\n  var res: seq[string] = @[]\n  for w in s.splitLines:\n    let row = w.mapIt(it.repeat(k)).join(\"\")\n    for _ in 1 .. n:\n      res.add(row)\n  res.join(\"\n\")","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215456,"user_id":null,"body":"import strutils\n\nproc scale*(s: string, k, n: int): string =\n  var res = newSeq[string]()\n  if s.len == 0:\n    return \"\"\n  for ss in s.split(\"\n\"):\n    var ts = \"\"\n    for c in ss:\n      ts &= repeat(c, k)\n    for i in countup(1, n):\n      res.add(ts)\n      \n  return res.join(\"\n\")\n      \n    # your code","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215457,"user_id":null,"body":"import sequtils, strutils\nproc hscale(s: string, k:int): string =\n  s.toSeq.mapIt(repeat(it, k)).join\nproc vscale(s: string, n: int): seq[string] =\n  case n\n  of 1: @[s]\n  else: s & vscale(s, n-1)\nproc scale*(s: string, k, n: int): string =\n    s.split\n      .mapIt(hscale(it, k))\n      .mapIt(vscale(it, n))\n      .mapIt(join(it, \"\n\"))\n      .join(\"\n\")\n      .strip","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"56efab15740d301ab40002ee":[{"id":215458,"user_id":null,"body":"from math import gcd, lcm\n\nproc gcdi*(x, y: int): int = gcd(abs(x), abs(y))\nproc lcmu*(x, y: int): int = lcm(abs(x), abs(y))\nproc som*(a, b: int):  int = a + b\nproc maxi*(a, b: int): int = max(a, b)\nproc mini*(a, b: int): int = min(a, b)\n\nproc operArray*(fct: proc, arr: openArray[int], init: int): seq[int] =\n  result = newSeq[int](arr.len)\n  var x = init\n  for i,y in arr:\n    x = fct(x, y)\n    result[i] = x","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215459,"user_id":492,"body":"proc gcdi*(x, y: int): int =\n  var x = abs(x)\n  var y = abs(y)\n  var t: int\n  while y != 0:\n      t = x; x = y; y = t %% y\n  return x\nproc lcmu*(a, b: int): int =\n  var r: int = abs(a * b) div gcdi(a, b)\n  return r\nproc som*(a, b: int): int =\n  return a + b\nproc maxi*(a, b: int): int =\n  return max(a, b)\nproc mini*(a, b: int): int =\n  return min(a, b)\nproc operArray*(fct: proc, arr: openArray[int], init: int): seq[int] =\n  var res: seq[int] = @[]\n  var d = init\n  var lg = arr.len - 1\n  for i in 0..lg:\n    d = fct(arr[i], d)\n    res.add(d)\n  return res","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215460,"user_id":492,"body":"proc gcdi*(x, y: int): int =\n  var x = abs(x)\n  var y = abs(y)\n  var t: int\n  while y != 0:\n      t = x; x = y; y = t %% y\n  return x\nproc lcmu*(a, b: int): int =\n  var r: int = abs(a * b) div gcdi(a, b)\n  return r\nproc som*(a, b: int): int =\n  return a + b\nproc maxi*(a, b: int): int =\n  return max(a, b)\nproc mini*(a, b: int): int =\n  return min(a, b)\nproc operArray*(fct: proc, arr: openArray[int], init: int): seq[int] =\n  var res: seq[int] = @[]\n  var d = init\n  var lg = arr.len - 1\n  for i in 0..lg:\n    d = fct(arr[i], d)\n    res.add(d)\n  return res","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215461,"user_id":76,"body":"from math import gcd, lcm\nfrom sequtils import foldl\n\nproc gcdi*(x, y: int): int = gcd(x.abs, y.abs)\nproc lcmu*(a, b: int): int = (a * b).abs div gcdi(a, b)\nproc som*(a, b: int): int = a + b\nproc maxi*(a, b: int): int = max(a, b)\nproc mini*(a, b: int): int = min(a, b)\nproc operArray*(fct: proc, arr: openArray[int], init: int): seq[int] = arr.foldl(a & fct(a[^1], b), @[init])[1 .. ^1]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215462,"user_id":null,"body":"import math\n\nproc gcdi*(x, y: int): int =\n  gcd(abs(x), abs(y))\nproc lcmu*(a, b: int): int =\n  lcm(abs(a), abs(b))\nproc som*(a, b: int): int =\n  a + b\nproc maxi*(a, b: int): int =\n  max(a, b)\nproc mini*(a, b: int): int =\n  min(a, b)\nproc operArray*(fct: proc, arr: openArray[int], init: int): seq[int] =\n  var n = init\n  for k in arr:\n    n = fct(n, k)\n    result.add n\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215463,"user_id":53,"body":"import sequtils\n\nproc gcdi*(a, b: int): int =\n  return (if b == 0: abs(a) else: gcdi(b, a mod b))\nproc lcmu*(a, b: int): int =\n  return abs(a * b) div gcdi(a, b)\nproc som*(a, b: int): int =\n  return a + b\nproc maxi*(a, b: int): int =\n  return (if a > b: a else: b)\nproc mini*(a, b: int): int =\n  return (if a < b: a else: b)\nproc operArray*(fct: proc, arr: openArray[int], init: int): seq[int] =\n  var ys: seq[int] = @[]\n  var acc = init\n  for i, x in arr.pairs:\n    acc = fct(acc, x)\n    ys = concat(ys, @[acc])\n  return ys","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215464,"user_id":null,"body":"import sequtils, math\nproc gcdi*(x, y: int): int = gcd(abs(x),abs(y))\nproc lcmu*(a, b: int): int = lcm(abs(a),abs(b))\nproc som*(a, b: int): int = a+b\nproc maxi*(a, b: int): int = max(a,b)\nproc mini*(a, b: int): int = min(a,b)\nproc operArray*(fct: proc, arr: openArray[int], init: int): seq[int] = foldl(arr, a & fct(a[^1],b), @[init])[1..^1]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215465,"user_id":null,"body":"import sequtils\nproc gcdi*(x, y: int): int =\n  if min(abs(x), abs(y)) == 0: max(abs(x), abs(y)) else: gcdi(min(abs(x), abs(y)), max(abs(x), abs(y)) mod min(abs(x), abs(y)))\nproc lcmu*(a, b: int): int = abs(a * b) div gcdi(abs(a), abs(b))\nproc som*(a, b: int): int = a+b\nproc maxi*(a, b: int): int = max(a,b)\nproc mini*(a, b: int): int = min(a,b)\n\nproc operArray*(fct: proc, arr: openArray[int], init: int): seq[int] = foldl(toSeq(arr), a & fct(a[^1],b), @[init])[1..^1]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215466,"user_id":null,"body":"import math\n\nproc gcdi*(x, y: int): int =\n  math.gcd(abs(x), abs(y))\nproc lcmu*(a, b: int): int =\n  math.lcm(abs(a), abs(b))\nproc som*(a, b: int): int =\n  a + b\nproc maxi*(a, b: int): int =\n  max(@[a,b])\nproc mini*(a, b: int): int =\n  min(@[a,b])\nproc operArray*(fct: proc, arr: seq[int], init: int): seq[int] =\n  result = @[]\n  for index, i in arr:\n    if index == 0:\n      result = result & fct(i, init)\n    else:\n      result = result & fct(i, result[index-1])\n  return result","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215467,"user_id":null,"body":"from sequtils import zip, map, concat\nfrom math import gcd, lcm\n\nproc sgn*[T: SomeNumber](x: T): int {.inline.} =\n  ord(T(0) < x) - ord(x < T(0))\n\nproc gcdi*(a, b: int): int =\n  gcd(a, b)\nproc lcmu*(a, b: int): int =\n  result = sgn(a) * sgn(b) * lcm(a, b)\nproc som*(a, b: int): int =\n  a + b\nproc maxi*(a, b: int): int =\n  max(a, b)\nproc mini*(a, b: int): int =\n  min(a, b)\n  \nproc operArray*(fct: proc, arr: seq[int], init: int): seq[int] =\n  var r:seq[int] = @[]\n  var x = init\n  for a in arr:\n    x = fct(a, x)\n    r.add(x)\n  return r","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"56f253dd75e340ff670002ac":[{"id":215468,"user_id":76,"body":"from strutils import splitLines, join\n\nproc compose*(s1, s2: string): string =\n  var\n    a = s1.splitLines\n    b = s2.splitLines\n    res: seq[string] = @[]\n  \n  for i, s in a:\n    res.add(s[0 .. i] & b[^i.succ][0 ..< b[0].len - i])\n    \n  res.join(\"\n\")","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215469,"user_id":null,"body":"import std\/strutils\n\nproc compose*(s1, s2: string): string =\n  let lines1 = splitLines(s1)\n  let lines2 = splitLines(s2)\n  let n = lines1.len\n  for k in 0..n-1:\n    result.addSep(\"\n\")\n    result &= lines1[k][0..k] & lines2[n-k-1][0..n-k-1]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215470,"user_id":759,"body":"import strutils\n\nproc compose*(s1, s2: string): string =\n  let\n    a = s1.splitLines()\n    b = s2.splitLines()\n    n = a.len\n    w = n + 2\n  result = newString(n * w - 1)\n  for i in 0..<n:\n    if i != (n - 1):\n      result[(i + 1) * w - 1] = '\n'\n    for i1 in 0..i:\n      result[i * w + i1] = a[i][i1]\n    for i2 in i..<n:\n      result[i * w + i2 + 1] = b[n - 1 - i][i2 - i]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215471,"user_id":492,"body":"import strutils, algorithm\n\nproc compose*(s1, s2: string): string =\n    let a2 = reversed(split(s2, \"\n\"))\n    let l1 = a2.len() \n    let a1 = split(s1, \"\n\")\n    var res = \"\";\n    for i in 0..< l1:\n        let tmp1 = a1[i]; let tmp2 = a2[i]\n        res &= tmp1[0..i] & tmp2[0..< l1 - i]\n        if (i < l1 - 1): res &= \"\n\"\n    return res","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"56f3a1e899b386da78000732":[{"id":215472,"user_id":492,"body":"import strutils\n\nproc partList*(arr: seq[string]): string =\n    var res = \"\"\n    for i in 1..< arr.len():\n        res &= \"(\" & join(arr[0..< i], \" \") & \", \" & join(arr[i..^1], \" \") & \")\"\n    return res","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215473,"user_id":76,"body":"from strutils import format, join\n\nproc partList*(arr: seq[string]): string =\n  for i in 1 ..< arr.len:\n    result &= \"($1, $2)\".format(arr[0 ..< i].join(\" \"), arr[i .. ^1].join(\" \"))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215474,"user_id":null,"body":"from std\/strutils import join\n\nproc partList*(arr: seq[string]): string =\n    result = \"\"\n    for i in 0..< arr.len-1:\n      var newArr = arr\n      newArr[i] = newArr[i] & \",\"\n      result &= (\"(\" & join(newArr, \" \") & \")\")","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215475,"user_id":null,"body":"from std\/strutils import join\n\nproc partList*(arr: seq[string]): string =\n    for ix in 1 .. arr.high:\n      result.add \"(\" & join(arr[0 ..< ix], \" \") & \", \" & join(arr[ix..^1], \" \") & \")\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215476,"user_id":null,"body":"import strutils\n\nproc partList*(arr: seq[string]): string =\n  var lst: seq[string]\n  for i in 0 ..< arr.len - 1:\n    var ac = arr\n    ac[i] &= \",\"\n    lst.add \"(\" & ac.join(\" \") & \")\"\n  lst.join","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215477,"user_id":53,"body":"import strutils\n\nproc partList*(arr: seq[string]): string =\n    var r = \"\"\n    for i in 1..< arr.len():\n        var a = join(arr[0..< i], \" \")\n        var b = join(arr[i..^1], \" \")\n        r &= \"(\" & a & \", \" & b & \")\"\n    return r","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215478,"user_id":null,"body":"import std\/strutils\nimport std\/sequtils\n\nproc partList*(arr: seq[string]): string =\n    (0..<arr.len-1).mapIt(\"(\" &\n        arr[0..it].join(\" \") & \", \" & (arr[it+1..<arr.len]).join(\" \") & \")\")\n            .join(\"\")","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215479,"user_id":null,"body":"import sequtils, strutils\n\nproc partList*(arr: seq[string]): string = join(toSeq(0..<arr.len-1).mapIt(\"(\" & join(arr[0..it], \" \") & \", \" & join(arr[it + 1..^1], \" \") & \")\"))\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215480,"user_id":null,"body":"from strutils import join\nfrom strformat import fmt\nproc partList*(arr: seq[string]): string =\n    # your code\n  for i in arr.low..<arr.high:\n    let left = arr[arr.low .. i].join(\" \")\n    let right = arr[i+1 .. arr.high].join(\" \")\n    result&=fmt\"({left}, {right})\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215481,"user_id":null,"body":"from strutils import join\nfrom strformat import fmt\nproc partList*(arr: seq[string]): string =\n    # your code\n  for i in arr.low..<arr.high:\n    let left = arr[arr.low .. i].join(\" \")\n    let right = arr[i+1 .. arr.high].join(\" \")\n    result&=fmt\"({left}, {right})\"\n  result","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"56f6ad906b88de513f000d96":[{"id":215482,"user_id":null,"body":"proc bonus_time*(salary: int, bonus: bool): string =\n  \"$\" & $(if bonus: 10 * salary else: salary)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215483,"user_id":null,"body":"proc bonus_time*(salary: int, bonus: bool): string =\n  return \"$\" & $(salary * (if(bonus): 10 else: 1))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215484,"user_id":571,"body":"import strutils\nproc bonus_time*(salary: int, bonus: bool): string =\n  if bonus:\n    return \"$\" & intToStr(salary*10)\n  else:\n    return \"$\" & intToStr(salary)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215485,"user_id":null,"body":"proc bonus_time*(salary: int, bonus: bool): string =\n  \"$\" & $salary & (if bonus: \"0\" else: \"\") ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215486,"user_id":null,"body":"import std\/strformat\n\nproc bonus_time*(salary: int, bonus: bool): string =\n  result = fmt\"${salary}\"\n  if bonus:\n    result = fmt\"{result}0\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215487,"user_id":null,"body":"import strformat\nproc bonus_time*(salary: int, bonus: bool): string =\n  fmt\"${salary + 9 * salary * bonus.ord}\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215488,"user_id":76,"body":"import strutils\n\nproc bonus_time*(salary: int, bonus: bool): string =\n  \"$\" & (if bonus: salary * 10 else: salary).intToStr","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215489,"user_id":null,"body":"import strutils\n\nproc bonus_time*(salary: int, bonus: bool): string =\n  if bonus:\n    \"$\" & (salary * 10).intToStr\n  else:\n    \"$\" & salary.intToStr","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215490,"user_id":null,"body":"proc bonus_time*(salary: int, bonus: bool): string =\n  result = \"$\"\n  if bonus: result.add(salary * 10) else: result.add(salary)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215491,"user_id":null,"body":"import strformat\n\nproc bonus_time*(salary: int, bonus: bool): string =\n  if bonus:\n    fmt\"${salary * 10}\"\n  else:\n    fmt\"${salary}\"\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"56fcc393c5957c666900024d":[{"id":215492,"user_id":null,"body":"import math, strutils, sequtils\n\nproc code*(s: string): string =\n  let n = ceil(sqrt(s.len.float)).int\n  var s = s\n  s &= '\\v'.repeat(n * n - s.len)\n  var rows = sequtils.repeat(spaces n, n)\n  for x in 0..n - 1:\n    for y in 0..n - 1:\n      rows[y][x] = s[n * (n - x - 1) + y]\n  return rows.join(\"\n\")\n\nproc decode*(encoded: string): string =\n  var rows = encoded.split('\n')\n  let n = rows[0].len\n  var s = ' '.repeat(n * n)\n  for x in 0..n - 1:\n    for y in 0..n - 1:\n      s[x * n + y] = rows[y][n - x - 1]\n  return s.strip","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215493,"user_id":492,"body":"import strutils, sequtils, math\n\nproc transposition(s: seq[string]): seq[string] =\n  result = s  # copy\n  for i in 0 .. s.high:\n    for j in 0 .. s.high:\n      result[j][i] = s[i][j]\nproc rot90ClockX(s: string): string =\n    proc reversedString(s: string): string =\n        result = newString(s.len())\n        for i,c in s:\n            result[s.high - i] = c\n    return join(map(transposition(split(s, \"\n\")), proc(x: string): string = reversedString(x)), \"\n\")\nproc rot90CounterX(s: string): string =\n    let arr = split(s, \"\n\"); var ss: string\n    var res: seq[string] = @[]\n    for i in countdown(arr.high, 0):\n        ss = \"\"\n        for v in arr:\n            ss &= v[i]\n        res.add(ss)\n    return join(res, \"\n\")\n    \nproc code*(s: string): string =\n    let lg = s.len()\n    if lg == 0: return \"\"\n    var u = s\n    let sz = int(ceil(sqrt(float64(lg))))\n    while u.len() != sz * sz:       \n        u &= \"\\v\"\n    let v = u; var res = \"\"; var i = 0\n    while i < u.len():\n        res &= v[i..< i+sz] & \"\n\"\n        i += sz\n    return rot90ClockX(res[0..^2])\nproc decode*(s: string): string =\n    if s.len() == 0: return \"\"\n    let u = split(rot90CounterX(s), \"\\v\")[0]\n    let arr = split(u, \"\n\")\n    return join(arr, \"\")","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"56fe17fcc25bf3e19a000292":[{"id":215494,"user_id":null,"body":"proc v1*(m, p: int): int = (2*m + 1) * p\nproc u1*(m, p: int): int = (  m + 1) * p","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215495,"user_id":492,"body":"proc v1*(m, p: int): int = \n  (m * p * 2) + p\nproc u1*(m, p: int): int = \n  (m * p) + p","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215496,"user_id":53,"body":"proc v1*(n, p: int): int = \n  (2 * n + 1) * p\n\nproc u1*(n, p: int): int = \n  (n + 1) * p","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215497,"user_id":null,"body":"proc v1*(m, p: int): int = \n  p * (2 * m + 1)\nproc u1*(m, p: int): int = \n  p * (m + 1)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215498,"user_id":null,"body":"proc v1*(n, p: int): int =\n  (1 + n*2) * p\n  \nproc u1*(n, p: int): int =\n  (1 + n) * p","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215499,"user_id":527,"body":"proc u1*(n, p: int): int = \n  (n + 1) * p\n\nproc v1*(n, p: int): int = \n  (2 * n + 1) * p","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215500,"user_id":759,"body":"proc v1*(m, p: int): int = \n  result = p * (2 * m + 1)\n\nproc u1*(m, p: int): int = \n  result = p * (m + 1)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215501,"user_id":17,"body":"proc v1*(n, p: int): int = p * (2 * n + 1)\nproc u1*(n, p: int): int = p * (n + 1)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215502,"user_id":null,"body":"from math import binom, `^`\n\nproc u1*(m, p: int): int = \n  ## (m+1) * p\n  #[\n  result = 0\n  for k in 0..m:\n    result += (-1)^k * p * 4^(m-k) * binom(2*m-k+1, k)\n  ]#\n  return (m+1) * p\nproc v1*(m, p: int): int = \n  ## (m*2 + 1) * p\n  #[\n  result = 0\n  for k in 0..m:\n    result += (-1)^k * p * 4^(m-k) * binom(2*m-k, k)\n  ]#\n  return (m*2 + 1) * p","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"5700c9acc1555755be00027e":[{"id":215503,"user_id":492,"body":"proc containAllRots*(strng: string, arr: seq[string]): bool =\n    if strng.len() == 0: return true\n    for i in 0..< strng.len():\n        let rot = strng[i..^1] & strng[0..< i]\n        if not(rot in arr):\n            return false\n    return true","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215504,"user_id":76,"body":"from sequtils import anyIt\n\nproc containAllRots*(strng: string, arr: seq[string]): bool =\n  for i in 0 ..< strng.len:\n    let s = strng[i .. ^1] & strng[0 ..< i]\n    if not arr.anyIt(it == s):\n      return false\n  true","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215505,"user_id":null,"body":"proc containAllRots*(strng: string, arr: seq[string]): bool =\n  for i in 0..strng.high:  \n    let r = strng[(strng.high - i)..strng.high] & strng[0..(strng.high - i - 1)]\n    if arr.find(r) == -1:\n      return false\n  return true","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215506,"user_id":null,"body":"proc containAllRots*(strng: string, arr: seq[string]): bool =\n  var \n    rots: int = 0\n    counter: int = 0\n    test: string = strng\n  while rots < strng.len:\n    let tmp: string = test[test.len-1] & test[0 .. test.len-2]\n    if tmp in arr: counter += 1\n    test = tmp\n    rots += 1\n  if counter == strng.len: return true\n  false","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215507,"user_id":null,"body":"import algorithm, sequtils, sets\nproc containAllRots*(strng: string, arr: seq[string]): bool =\n    if strng==\"\": result = true\n    let set=toHashset(arr)\n    var rotSeq: seq[string]\n    var rot=strng\n    for n in 0..<strng.len:\n      rotateLeft(rot,1)\n      rotSeq.add(rot)\n    if allIt(rotSeq, set.contains(it)): result=true","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215508,"user_id":null,"body":"proc containAllRots*(strng: string, arr: seq[string]): bool =\n  var s = strng.deepCopy()\n  for _ in 1 .. len(s):\n    if not(s in arr):\n      return false\n    s = s[1..^1] & s[0]\n  return true","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215509,"user_id":53,"body":"import sequtils;\n\nproc rot*(s: string): string = \n  return s[1 .. ^1] & s[0];\n\nproc rotAll*(s: string): seq[string] =\n  var b = s;\n  for i in 0..s.len:\n    b = rot(b);\n    result.add(b);\n\nproc containAllRots*(s: string, arr: seq[string]): bool =\n  if s.len == 0:\n    return true;\n  else:\n    return rotAll(s).allIt(arr.contains(it));","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215510,"user_id":null,"body":"proc containAllRots*(strng: string, arr: seq[string]): bool =\n    # your code\n    if strng == \"\":\n      return true\n    \n    var temp_string = strng\n    for i in 0 .. strng.len - 1:\n      if not arr.contains(temp_string):\n        return false\n      temp_string = temp_string[1 .. ^1] & temp_string[0]\n      \n    return true","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"5726f813c8dcebf5ed000a6b":[{"id":215511,"user_id":53,"body":"\nproc countPrimeFactors*(m: int): int =\n    var ans = 0;\n    var i = 2;\n    var n = m;\n    while i <= n div i:\n        while n %% i == 0:\n            n = n div i;\n            ans += 1;\n        i += 1;\n    if n > 1:\n        ans += 1;\n    return ans;\n\nproc countKprimes*(k, start, nd: int): seq[int] =\n    var fs: seq[int] = @[];\n    var n = start;\n    while n <= nd:\n        var j = countPrimeFactors(n);\n        if j == k:\n            fs.add(n);\n        n += 1;\n    return fs;\n\nproc puzzle*(s: int): int =\n    var ans = 0;\n    var xs = countKprimes(7, 128, s - 10);\n    var ys = countKprimes(3, 8, s - 130);\n    for i in countup(0, xs.len - 1):\n        var a = xs[i];\n        for j in countup(0, ys.len - 1):\n            var b = ys[j];\n            var c = s - a - b;\n            if c > 0 and countPrimeFactors(c) == 1:\n                ans += 1;\n    return ans;","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215512,"user_id":492,"body":"import math\n\nproc countKprimes*(k, start, nd: int): seq[int] =\n    proc numOfDiv(n: int): int =\n        var nn = n; var cnt = 0; var i = 2\n        while (i * i <= nn):\n            while (nn %% i == 0):\n                cnt += 1\n                nn = nn div i\n            i += 1\n        if (nn > 1):\n             cnt += 1\n        return cnt\n    var kprimes: seq[int] = @[]\n    var i = start\n    while (i <= nd):\n        if (numOfDiv(i) == k):\n            kprimes.add(i)\n        i += 1\n    return kprimes\n\nproc puzzle*(s: int): int =\n    proc isPrimi(a: int): bool =\n        if a == 2: return true\n        if a < 2 or a mod 2 == 0: return false\n        for i in countup(3, sqrt(a.float).int, 2):\n            if a mod i == 0:\n                return false\n        return true\n    var cnt = 0\n    let b = countKprimes(7, 128, s - 6)\n    let c = countKprimes(3, 4, s - 130)\n    for _, j in b:\n        for _, k in c:\n            if isprimi(s - j - k):\n                cnt += 1\n    return cnt","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215513,"user_id":null,"body":"import math\n\nproc checkKprime(n, k: int): bool =\n  if k == 0: return n == 1\n  if n == 1: return false\n  if k == 1:\n    var d = 2\n    while d * d <= n:\n      if n mod d == 0: return false\n      inc d\n    return true\n  var d = 2\n  while d ^ k <= n:\n    if n mod d == 0:\n      return checkKprime(n div d, k - 1)\n    inc d\n  return false\n\nproc countKprimes*(k, start, nd: int): seq[int] =\n  for n in start..nd:\n    if checkKprime(n, k): result.add(n)\n\nproc puzzle*(s: int): int =\n  let \n    primes_1 = countKprimes(1, 1, s)\n    primes_3 = countKprimes(3, 1, s)\n    primes_7 = countKprimes(7, 1, s)\n  for a in primes_1:\n    for b in primes_3:\n      for c in primes_7:\n        if a + b + c == s:\n          inc result","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"5727bb0fe81185ae62000ae3":[{"id":215514,"user_id":null,"body":"import deques, sequtils\n\nproc clean_string*(s: string): string =\n  var q = initDeque[string]()\n  for x in s:\n    if x == '#':\n      if q.len() > 0:\n        q.popLast()\n    else:\n      q.addLast($x)\n  foldl(q, a & b, \"\")","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215515,"user_id":null,"body":"import strutils\n\nproc clean_string*(s: string): string =\n  proc delBack(a: var string) =\n    if a.len != 0: a.delete a.high, a.high\n  for c in s:\n    if c == '#': result.delBack\n    else: result.add c","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215516,"user_id":null,"body":"import sequtils\n\nproc clean_string*(s: string): string =\n  return s.foldl(\n    if b != '#':\n      a & b\n    else:\n      if a.len >= 2: a[..(a.len-2)] else : \"\", \"\"\n  )","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215517,"user_id":527,"body":"import re\n\nproc clean_string*(s: string): string = \n  s.replace(re\"[^#](?R)*#|\\G#\")","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215518,"user_id":null,"body":"import std\/strutils\n\nproc clean_string*(s: string): string =\n  result = \"\"\n  for i in countup(0, s.len - 1):\n    if s[i] == '#':\n      if result.len != 0:\n        result.delete(result.len - 1, result.len - 1)\n    else:\n      result.add(s[i])","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215519,"user_id":53,"body":"import strutils, re\n\nproc clean_string*(s: string): string =\n  if s.contains(\"#\"):\n    return clean_string(s.replace(re\"[^#](?R)*#|\\G#\",\"\"));\n  else:\n    return s;","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215520,"user_id":null,"body":"proc clean_string*(s: string): string =\n  for c in s:\n    if c == '#':\n      if len(result) > 0:\n        result = result[0..^2]\n    else:\n      result.add(c)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215521,"user_id":null,"body":"proc clean_string*(s: string): string =\n  var sharpIndex: int = s.find('#')\n  var res: string\n  if sharpIndex != -1:\n    if sharpIndex == 0: res = s[1..^1]\n    else: res = s[0..<sharpIndex-1] & s[sharpIndex + 1..^1]\n    result = clean_string(res)\n  else: result = s\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215522,"user_id":null,"body":"import strutils\n\n\nproc clean_string*(s: string): string =\n    var output: string = s\n    let i = find(output, '#')\n\n    if i > 0:\n        output = output.replace(output[i-1..i], \"\")\n    elif i == -1:\n        output = output\n    elif i == 0:\n        output = output[1..^1]\n    \n    if '#' in output:\n        output = clean_string(output)\n\n    output\n    ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215523,"user_id":null,"body":"import strutils\n\nproc clean_string*(s: string): string =\n\n    result = s\n    result.removePrefix('#')\n\n    if result.len > 0:\n\n        while true:\n\n            var lead = 0\n            var i = 0\n            \n            while i < result.len and result[i] != '#':\n                inc lead\n                inc i\n\n            if lead == result.len:\n                return result\n\n            while i < result.len and result[i] == '#':\n                dec lead\n                inc i\n\n            if lead <= 0: \n\n                if i == result.len:\n                    return \"\"\n                \n                result = result[i .. ^1] #ignore the lead and retain the rest\n            \n            else:\n                result[0 ..< i] = result[0 ..< lead] #retain the lead and discard the rest\n            ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"573182c405d14db0da00064e":[{"id":215524,"user_id":null,"body":"import sequtils\n\nproc factors*(n: int): int =\n  ## number of primes in `n`'s factorization\n  if n == 1: return 0\n  var d = 2\n  while d * d <= n:\n    if n mod d == 0: return factors(n div d) + 1\n    inc d\n  return 1\n\nproc consecKprimes*(k: int, arr: seq[int]): int =\n  return toSeq(1..arr.len - 1).filterIt(factors(arr[it]) == k and factors(arr[it - 1]) == k).len","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215525,"user_id":53,"body":"import sequtils\n\nproc npf*(k: int): int =\n  var m = 0\n  var n = k\n  var i = 2\n  while n > 1:\n    if (n mod i == 0):\n      n = int(n \/ i)\n      m = m + 1\n      i = 1\n    i = i + 1\n  return m\n\nproc consecKprimes*(k: int, arr: seq[int]): int =\n  var m = 0\n  var p = 0\n  for n in arr:\n    var q = npf(n)\n    if q == k and p == k:\n      m = m + 1\n    p = q\n  return m","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215526,"user_id":492,"body":"proc consecKprimes*(k: int, arr: seq[int]): int =\n    proc numOfDiv(n: int): int =\n        var nn = n; var cnt = 0; var i = 2\n        while (i * i <= nn):\n            while (nn %% i == 0):\n                cnt += 1\n                nn = nn div i\n            i += 1\n        if (nn > 1):\n             cnt += 1\n        return cnt\n    var cnt: int = 0; var i = 1\n    while i < arr.len:\n        if (numOfDiv(arr[i]) == k and numOfDiv(arr[i - 1]) == k):\n            cnt += 1\n        i += 1\n    return cnt","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"573992c724fc289553000e95":[{"id":215527,"user_id":492,"body":"import strutils\n        \nproc smallest*(n: int64): seq[int64] =\n    var tmp = n; let s = $n; var res: seq[int64] = @[int64(-1), int64(0), int64(0)]\n    for i, c in s:\n        let str1 = s[0..< i] & s[i + 1..^1]        \n        for j in 0..< s.len():\n            let str2 = str1[0..< j] & c & str1[j..^1]\n            let nbStr2: int64 = parseInt(str2)\n            if nbStr2 < tmp:\n                tmp = nbStr2\n                res =  @[nbStr2, int64(i), int64(j)]\n    if res[0] == -1: \n        res = @[n, int64(0), int64(0)]\n    return res","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"57591ef494aba64d14000526":[{"id":215528,"user_id":53,"body":"\nproc walk*(n: int): seq[seq[int]] =\n    var xs: seq[int] = @[0];\n    var ys: seq[int] = @[1];\n    for i in countup(1, n - 1):\n        var x1 = xs[i - 1]\n        var x2 = ys[x1]\n        xs.add(i - x2)\n        var y1 = ys[i - 1]\n        var y2 = xs[y1]\n        ys.add(i - y2)\n    return @[ys, xs]\n\nproc ann*(n: int): seq[int] =\n    return walk(n)[0]\n  \nproc john*(n: int): seq[int] =\n    return walk(n)[1]\n  \nproc sumJohn*(n: int): int =\n    var xs = john(n)\n    var s = 0\n    for i in countup(0, xs.len - 1):\n        s = s + xs[i]\n    return s\n  \nproc sumAnn*(n: int): int =\n    var ys = ann(n)\n    var s = 0\n    for i in countup(0, ys.len - 1):\n        s = s + ys[i]\n    return s","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215529,"user_id":492,"body":"proc johnAnn(n: int): (seq[int], seq[int]) =\n    var johnList = @[0]\n    var annList = @[1]\n    var i = 1\n    while (i < n):\n        let j = johnList[i - 1]\n        let a1 = annList[j]\n        johnList.add(i - a1)\n        let a = annList[i - 1]\n        let j1 = johnList[a]\n        annList.add(i - j1)\n        i += 1\n    return (johnList, annList)\nproc ann*(n: int): seq[int] =\n    var (_, a) = johnAnn(n)\n    return a\nproc john*(n: int): seq[int] =\n    var (j, _) = johnAnn(n)\n    return j\nproc sumJohn*(n: int): int =\n    var (j, _) = johnAnn(n)\n    var sum = 0\n    for i in 0 ..< n:\n        sum += j[i]\n    return sum\nproc sumAnn*(n: int): int =\n    var (_, a) = johnAnn(n)\n    var sum = 0\n    for i in 0 ..< n:\n        sum += a[i]\n    return sum","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215530,"user_id":76,"body":"from math import sum\n\nvar \n  annKatas = @[1]\n  johnKatas = @[0]\n\nproc solve(n: int): int =\n  for day in annKatas.len ..< n:\n    johnKatas.add(day - annKatas[johnKatas[day - 1]])\n    annKatas.add(day - johnKatas[annKatas[day - 1]])\n  n\n\nproc ann*(n: int): seq[int] =\n  annKatas[0 ..< solve(n)]\n  \nproc john*(n: int): seq[int] =\n  johnKatas[0 ..< solve(n)]\n  \nproc sumJohn*(n: int): int =\n  john(n).sum\n  \nproc sumAnn*(n: int): int =\n  ann(n).sum","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"5772382d509c65de7e000982":[{"id":215531,"user_id":53,"body":"import tables\n\nproc sequence*(n: int): Table[int, int] = \n    var hs = initTable[int, int]()\n    hs[0] = 0\n    hs[1] = 1\n    hs[2] = 1\n    for i in countup(3, n):\n        hs[i] = hs[i - hs[i - 1]] + hs[i - hs[i - 2]]\n    return hs\n\nproc lengthSupUK*(n: int, k: int): int =\n    var hs = sequence(n)\n    var m = 0\n    for _, x in hs:\n        if x >= k:\n            m = m + 1\n    return m\n  \nproc comp*(n: int): int =\n    var hs = sequence(n)\n    var m = 0\n    for i, x in hs:\n        if i > 0 and x < hs[i - 1]:\n            m = m + 1\n    return m","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215532,"user_id":492,"body":"import sequtils\n\nproc u1(n: int): seq[int] =\n    var memu = @[1, 1]\n    var i =  2\n    while (i < n):\n        memu.add(memu[i - memu[i - 1]] + memu[i - memu[i - 2]])\n        i += 1\n    return memu\nproc lengthSupUK*(n: int, k: int): int =\n    return len(filter(u1(n), proc(x: int): bool = (x >= k)))\nproc comp*(n: int): int =\n    var memu = u1(n)\n    var prev = 1; var cnt = 0; var i = 1\n    while (i < n):\n        var cur = memu[i]\n        if (cur < prev):\n            cnt += 1\n        prev = cur\n        i += 1\n    return cnt","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"577bd026df78c19bca0002c0":[{"id":215533,"user_id":null,"body":"import strutils\n\nproc correct*(str: string): string =\n  multiReplace(str, (\"0\", \"O\"), (\"5\", \"S\"), (\"1\", \"I\"))","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215534,"user_id":null,"body":"proc correct*(str: string): string =\n  for c in str:\n    let a = case c:\n      of '5': 'S'\n      of '0': 'O'\n      of '1': 'I'\n      else: c\n    result.add(a)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215535,"user_id":null,"body":"import strutils\n\n\n\nproc correct*(str: string): string =\n  \n    \n\n\n  \n   \n  str.replace(\"5\", \"S\").replace(\"0\", \"O\").replace(\"1\", \"I\")","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215536,"user_id":null,"body":"proc correct*(str: string): string =\n  for c in str:\n    if c == '5':\n      result.add('S')\n    elif c == '0':\n      result.add('O')\n    elif c == '1':\n      result.add('I')\n    else:\n      result.add(c)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215537,"user_id":76,"body":"proc correct*(str: string): string =\n  result = \"\"\n  for c in str:\n    case c\n      of '5':\n        result &= 'S'\n      of '0':\n        result &= 'O'\n      of '1':\n        result &= 'I'\n      else:\n        result &= c","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215538,"user_id":null,"body":"proc correct*(str: string): string =\n  for ch in str:\n    case ch:\n      of '5': result = result & \"S\"\n      of '0': result = result & \"O\" \n      of '1': result = result & \"I\"\n      else: result = result & ch\n      \n  return","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215539,"user_id":null,"body":"import std\/tables\nimport std\/sequtils\nfrom std\/strutils import join\n\n\nconst lookUpTable = {'5': 'S', '0': 'O', '1': 'I'}.toTable\n\nproc correct*(str: string): string =\n  str.mapIt(lookUpTable.getOrDefault(it, it)).join","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215540,"user_id":null,"body":"import strutils\n\nproc correct*(str: string): string =\n  str.replace(\"0\", \"O\").replace(\"5\", \"S\").replace(\"1\", \"I\")","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215541,"user_id":null,"body":"proc correct*(str: string): string =\n  var res: string = \"\"\n  for i in 0..<str.len:\n    if str[i]=='0' : res.add('O')\n    elif str[i]=='5' : res.add('S')\n    elif str[i]=='1' : res.add('I')\n    else : res.add(str[i])\n  return res","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215542,"user_id":null,"body":"proc correct*(str: string): string =\n  var answer = \"\"\n  for i in 0 .. str.len-1:\n    if str[i] == '5': answer = answer & 'S'\n    elif str[i] == '0': answer = answer & 'O'\n    elif str[i] == '1': answer = answer & 'I'\n    else: answer = answer & str[i]\n  \n  answer","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"57a0e5c372292dd76d000d7e":[{"id":215543,"user_id":null,"body":"import strutils\nproc repeat_str*(r: int, str: string): string = str.repeat(r)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215544,"user_id":759,"body":"proc repeat_str*(r: int, str: string): string =\n  result = newStringOfCap(str.len * r)\n  for i in 1..r:\n    result.add(str)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215545,"user_id":null,"body":"proc repeat_str*(r: int, str: string): string =\n  for i in 1..r:\n    result.add(str)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215546,"user_id":null,"body":"from std\/strutils import repeat\n\nproc repeat_str*(r: int, str: string): string =\n  str.repeat(r)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215547,"user_id":null,"body":"proc repeat_str*(r: int, str: string): string =\n  var return_string = \"\"\n  for x in 1..r:\n    return_string.add(str)\n  return return_string","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215548,"user_id":null,"body":"proc repeat_str*(r: int, str: string): string =\n  var ret = \"\"\n  for i in 0..r-1:\n    ret &= str\n  result = ret","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215549,"user_id":null,"body":"proc repeat_str*(r: int, str: string): string =\n  for _ in 1..r:\n    result &= str","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215550,"user_id":null,"body":"proc repeat_str*(r: int, str: string): string =\n  var res: string = \"\" \n  for i in 0..<r:\n    res = res & str\n    \n  res\n    ","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215551,"user_id":null,"body":"proc repeat_str*(r: int, str: string): string =\n  var answer = \"\"\n  for i in 1 .. r:\n    answer = answer & str\n    \n  answer","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215552,"user_id":null,"body":"proc repeat_str*(r: int, str: string): string =\n  result = \"\"\n  for i in 0..<r:\n    result &= str\n  ","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"57cebe1dc6fdc20c57000ac9":[{"id":215553,"user_id":null,"body":"import algorithm, strutils, sequtils\nproc find_short*(s: string): int =\n  s.split.mapIt(it.len).sorted[0]","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215554,"user_id":null,"body":"import strutils, sequtils, future # this should be 'sugar', old Nim version?\n\nproc find_short*(s: string): int =\n  s.split.map(x => x.len).filter(y => y > 0).min\n  ","lang_id":33,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215555,"user_id":76,"body":"from strutils import split\nfrom sequtils import mapIt\n\nproc find_short*(s: string): int =\n  s.split.mapIt(it.len).min","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215556,"user_id":null,"body":"import std\/[strutils, sequtils]\n\nproc find_short*(s: string): int =\n  result = int.high\n  for i in s.split:\n    result = min(result, i.len)","lang_id":33,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215557,"user_id":null,"body":"import strutils, sequtils\n\nproc find_short*(s: string): int =\n  s.split(\" \").mapIt(it.len).min","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215558,"user_id":null,"body":"proc find_short*(s: string): int =\n  var j = 0\n  var k = 0\n  var ss = s&\" \"\n\n  for i in ss:\n    if i!=' ':\n      inc(j)\n\n      discard\n    else:\n      if k==0 or k>j:\n        k=j\n        discard\n      j=0\n      discard\n  return k\n  ","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215559,"user_id":null,"body":"import std\/strutils\n\nproc find_short*(s: string): int =\n  for i in s.split(' '):\n    if result == 0: result = i.len()\n    if i.len() < result: result = i.len()","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215560,"user_id":null,"body":"import algorithm, strutils, sequtils, future\nproc find_short*(s: string): int =\n  #s.split.mapIt(it.len).sorted[0]\n  s.split.map(x => x.len).min","lang_id":33,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215561,"user_id":null,"body":"import strutils\n\nproc find_short*(s: string): int =\n  let words = s.split()\n  var lengths = newSeq[int]()\n\n  for i in words:\n    lengths.add(i.len)\n\n  return lengths.min\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215562,"user_id":null,"body":"import std\/strutils\nproc find_short*(s: string): int =\n  let st = s.split(\" \")\n  result =  len(st[0])\n  for i in st:\n    if result > len(i):\n      result = len(i)\n  ","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"57cfd92c05c1864df2001563":[{"id":215563,"user_id":null,"body":"proc vowel_back*(s: string): string =\n  var n: int\n  for c in s:\n    n = ord(c)\n    case c:\n    of 'c', 'o':\n      dec(n)\n    of 'd':\n      n -= 3\n    of 'e':\n      n -= 4\n    of 'a', 'i', 'u':\n      n -= 5\n    else:\n      n += 9\n    if n < ord('a'):\n      n += 26\n    elif n > ord('z'):\n      n -= 26\n    if chr(n) in {'c', 'o', 'd', 'e'}:\n      n = ord(c)\n    result.add chr(n)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215564,"user_id":null,"body":"import sugar, tables, sequtils, strutils\nproc vowel_back*(s: string): string =\n  join(map(s, c => toTable(zip(\"abcdefghijklmnopqrstuvwxyz\", \"vkbaafpqistuvwnyzabtpvfghi\"))[c]))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215565,"user_id":527,"body":"func vowel_back*(s: string): string =\n  result = newString(s.len)\n  for i, c in s.pairs:\n    result[i] = \"vkbaafpqistuvwnyzabtpvfghi\"[c.ord - 'a'.ord]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215566,"user_id":527,"body":"func vowel_back*(s: string): string =\n  result = newStringOfCap(s.len)\n  for c in s:\n    result &= \"vkbaafpqistuvwnyzabtpvfghi\"[c.ord - 'a'.ord]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215567,"user_id":527,"body":"func vowel_back*(s: string): string =\n  for c in s:\n    result &= \"vkbaafpqistuvwnyzabtpvfghi\"[c.ord - 'a'.ord]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215568,"user_id":759,"body":"proc vowel_back*(s: string): string =\n  result = s\n  for c in result.mitems:\n    c = case c\n    of 'c', 'o': char(c.uint8 - 1)\n    of 'd', 'e': 'a'\n    of 'i', 'v', 't', 'f': c\n    of 'u': 'p'\n    of 'a': 'v'\n    else: char('a'.uint8 + (c.uint8 - 'a'.uint8 + 9) mod 26)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"57eae20f5500ad98e50002c5":[{"id":215569,"user_id":null,"body":"import strutils\nproc no_space*(x: string): string =\n  x.replace(\" \", \"\")","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215570,"user_id":null,"body":"import sugar, strutils\nlet no_space* = (s: string) => s.splitWhitespace.join","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215571,"user_id":null,"body":"import strutils\n\nproc no_space*(x: string): string =\n  result = x.replace(\" \", \"\")","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215572,"user_id":null,"body":"import std\/strutils\n\nproc no_space*(x: string): string =\n  for sq in x.splitWhitespace():\n    result.add(sq)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215573,"user_id":null,"body":"import strutils \nproc no_space*(x: string): string =\n  for s in x.split():\n    result.add(s)\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215574,"user_id":null,"body":"from std\/strutils import replace\n\nproc no_space*(x: string): string =\n  x.replace(\" \", \"\")","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215575,"user_id":null,"body":"import strutils\n\nproc no_space*(x: string): string =\n  splitwhitespace(x).join\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215576,"user_id":null,"body":"import strutils\n\n# proc no_space*(x: string): string =\n#   return replace(x, \" \", \"\")\n\nproc no_space*(x: string): string = \n  return x.replace(\" \", \"\")\n","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215577,"user_id":null,"body":"import strutils, pegs, unicode\nproc no_space*(x: string): string =\n  return x.replace(\" \", \"\")","lang_id":33,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215578,"user_id":null,"body":"import std\/sequtils\n\nproc no_space*(x: string): string =\n  for c in x:\n    if c != ' ':\n      result.add(c)","lang_id":33,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"58069e4cf3c13ef3a6000168":[{"id":215579,"user_id":527,"body":"func reverse*(n: int): int =\n  var m = n\n  while m != 0:\n    result = result * 10 + m mod 10\n    m = m div 10\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215580,"user_id":76,"body":"from algorithm import reversed\nfrom strutils import join, parseInt\n\nproc reverse*(n: int): int =\n  ($n).reversed.join(\"\").parseInt","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215581,"user_id":null,"body":"proc reverse*(n: int): int =\n  var k = n\n  while k > 0:\n    result *= 10\n    result += k mod 10\n    k = k div 10","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215582,"user_id":50,"body":"proc reverse*(o: int): int =\n  var m=0\n  var n=o\n  while n != 0:\n    m=m*10+n %% 10\n    n=(n\/10).int\n  return m","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215583,"user_id":null,"body":"proc reverse*(n: int): int =\n  var number = n\n  while number > 0:\n    let last = number mod 10\n    number = number div 10\n    result = (result * 10) + last","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215584,"user_id":759,"body":"proc reverse*(n: int): int =\n  var n = n\n  while n != 0:\n    result = result * 10 + n mod 10\n    n = n div 10","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"58184387d14fc32f2b0012b2":[{"id":215585,"user_id":null,"body":"import math\ntemplate random(x:untyped):untyped = rand(x)\nconst coefs = [(0,1),(1,2),(-1,8),(3,48)]#,(-15,384)]#,(105,3840),(-945,46080)]\nproc f*(x: float): float =\n  for i,(n,d) in coefs.pairs:\n    result += pow(x,i.float)*n.float\/d.float\n  \n    # your code\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215586,"user_id":76,"body":"from math import sqrt\n\nproc f*(x: float64): float64 =\n  x \/ (sqrt(1 + x) + 1)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215587,"user_id":50,"body":"import math\n\nproc f*(x: float64): float64 =\n  x\/(1+sqrt(1+x))\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215588,"user_id":53,"body":"proc f*(x: float64): float64 =\n     return x \/ 2 - x * x \/ 8 + x * x * x \/ 16 - 5 * x * x * x * x \/ 128;\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215589,"user_id":null,"body":"import math\nproc f*(x: float64): float64 =\n  x \/ (sqrt(1+x)+1)\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215590,"user_id":527,"body":"from math import sqrt\n\nproc f*(x: float64): float64 =\n    x \/ (sqrt(x + 1) + 1)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215591,"user_id":492,"body":"import math\n\nproc f*(x: float64): float64 =\n    return x \/ (1.0 + math.sqrt(1.0 + x))\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"581ee0db1bbdd04e010002fd":[{"id":215592,"user_id":76,"body":"import strformat, strutils, sequtils\n\nproc interp*(f: proc(x: float64): float64, l, u: float64, n: int): string =\n  let delta = (u - l) \/ float64(n)\n  (0 ..< n).mapIt(fmt\"{f(l + delta * it.float64):.2f}\").join(\" \")","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215593,"user_id":492,"body":"import math, strutils\n\nproc interp*(f: proc(x: float64): float64, l, u: float64, n: int): string =\n    var accu: seq[string] = @[]\n    var i = 0; var m = float64(n)\n    while i < n: \n        let d: float64 = float64(i) * (u - l) \/ m\n        accu.add(f(l + d).formatFloat(ffDecimal, 2))\n        i += 1\n    return join(accu, \" \")","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"5868b2de442e3fb2bb000119":[{"id":215594,"user_id":76,"body":"from strutils import split, format, parseInt\nfrom sequtils import mapIt, filterIt, foldl\nfrom algorithm import sortedByIt\n\nproc closest*(strng: string): string =\n  let strs = strng.split\n  if strs.len < 2: return \"[(), ()]\"\n  var nums = newSeq[tuple[weight: int, index: int, num: int, diff: int]]()\n  for i, s in strs:\n    nums.add((s.foldl(a + b.ord - '0'.ord, 0), i, s.parseInt, 0))\n  for i, t in nums:\n    nums[i].diff = nums.filterIt(it.index != i).mapIt((it.weight - nums[i].weight).abs).min\n  nums = nums.sortedByIt((it.diff, it.weight, it.index))\n  \"[($1, $2, $3), ($4, $5, $6)]\".format(nums[0].weight, nums[0].index, nums[0].num, nums[1].weight, nums[1].index, nums[1].num)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215595,"user_id":492,"body":"import strutils, algorithm\n    \nproc closest*(strng: string): string =\n    type \n        rankStruct = object\n            name: string\n            ind:  int\n            wght: int\n    proc comp(x, y: rankStruct): int =\n        if x.wght == y.wght:\n            return cmp(x.ind, y.ind)\n        return cmp(x.wght, y.wght)\n    if strng == \"\": return \"[(), ()]\"\n    let nums = split(strng, \" \")\n    var l1: seq[rankStruct] = newSeq[rankStruct](nums.len())\n    for i, _ in l1:\n        l1[i].name = nums[i]\n        var w = 0\n        for c in nums[i]:\n            w += int(c) - int('0')\n        l1[i].wght = w\n        l1[i].ind = i\n    l1.sort(comp)\n    var mn = 1000; var ndx = -1\n    for u in 1..< l1.len():\n        let a = l1[u].wght - l1[u - 1].wght\n        if a < mn: mn = a; ndx = u\n    let res = \"[(\"  & intToStr(l1[ndx - 1].wght) & \", \" & intToStr(l1[ndx - 1].ind) & \", \" & l1[ndx - 1].name & \")\" &\n        \", (\" & intToStr(l1[ndx].wght) & \", \" & intToStr(l1[ndx].ind) & \", \" & l1[ndx].name & \")]\"\n    return res","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"586d6cefbcc21eed7a001155":[{"id":215596,"user_id":null,"body":"import strutils\n\nproc longestRepetition*(str: string): (char, int) =\n    var\n      headChar = '\\0'\n      length = 0\n      str = str\n    while str.len() > length:\n      let\n        testHead = str[0]\n        oldLength = str.len()\n      str.removePrefix(testHead)\n      if (oldLength - str.len()) > length:\n        headChar = testHead\n        length = oldLength - str.len()\n\n\n    return (headChar, length)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215597,"user_id":null,"body":"import sequtils, algorithm\n\nproc longestRepetition*(str: string): (char, int) =\n  if str.len == 0: return\n  var current = (char: str[0], length: 1)\n  for c in str[1..^1]:\n    if c == current.char:\n      inc current.length\n    else:\n      if current.length > result[1]: result = current\n      current = (c, 1)\n  if current.length > result[1]: result = current\n\n  \n  ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215598,"user_id":null,"body":"proc longestRepetition*(str: string): (char, int) =\n  var s = str[0..<str.len]\n  var c0 = '\\0'\n  var maxLen = 0\n  \n  while s.len > 0:\n    var len = s.len\n    let c = s[0]\n    \n    while s.len > 0 and s[0] == c:\n      s = s[1..<s.len]\n    \n    len -= s.len\n    if len > maxLen:\n      c0 = c\n      maxLen = len\n      \n  (c0, maxLen)\n      ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215599,"user_id":53,"body":"proc longestRepetition*(str: string): (char, int) =\n  if len(str) == 0:\n    return ('\\0', 0)\n  var rep = 0\n  var max = 0\n  var prev = str[0]\n  var c = prev\n  for _, p in str:\n    if p != prev:\n      rep = 1\n    else:\n      rep = rep + 1\n      if rep > max:\n        c = prev\n        max = rep\n    prev = p\n  return (c, max)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215600,"user_id":null,"body":"import strutils\nimport sequtils\n\nproc longestRepetition*(str: string): (char, int) =\n  var\n    cur_max = 1\n    glob_max = 0\n    cur_ch: char\n    glob_ch: char\n  if len(str)==0:\n      return ('\\0', 0)\n  cur_ch = str[0]\n  glob_ch = str[0]\n  for ind in 1..str.len-1:\n    if str[ind]==str[ind-1]:\n        cur_ch = str[ind]\n        cur_max += 1\n        echo cur_ch, cur_max, \"debug\"\n    else:\n        if cur_max>glob_max:\n            glob_max = cur_max\n            glob_ch = cur_ch\n        cur_max = 1\n    if cur_max>glob_max:\n        glob_max = cur_max\n        glob_ch = cur_ch\n  return (glob_ch, glob_max)\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215601,"user_id":null,"body":"import tables\n\nproc longestRepetition*(str: string): (char, int) =\n  var\n    ans = ('\\0', 0)\n    tuples : seq[(char, int)] = @[ ('\\0', 0) ]\n    \n  for i in str:\n    if tuples[tuples.len-1][0] == i:\n      tuples[tuples.len-1] = (tuples[tuples.len-1][0], tuples[tuples.len-1][1]+1)\n    else:\n      tuples.add((i, 1))\n      \n    if tuples[tuples.len-1][1] > ans[1]:\n      ans = tuples[tuples.len-1]\n      \n  return ans\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215602,"user_id":759,"body":"proc longestRepetition*(str: string): (char, int) =\n  var\n    last: char\n    count: int\n  result = (last, count)\n  for c in str:\n    if c == last:\n      inc count\n    else:\n      last = c\n      count = 1\n    if result[1] < count: result = (last, count)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"586f6741c66d18c22800010a":[{"id":215603,"user_id":76,"body":"from math import sum\nfrom sequtils import toSeq\n\nproc sequence_sum*(beginNumber, endNumber, step: int): int =\n  countup(beginNumber, endNumber, step).toSeq.sum","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215604,"user_id":759,"body":"proc sequence_sum*(b, e, s: int): int =\n  for i in countup(b, e, s):\n    result += i","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"5879f95892074d769f000272":[{"id":215605,"user_id":492,"body":"import math\n\nproc temps*(v0, slope, dTot: float64): int =\n    const GRAVITY_ACC = 9.81 * 3.6 * 60.0                   # gravity acceleration\n    const DRAG = 60.0 * 0.3 \/ 3.6                           # force applied by air on the cyclist\n    const DELTA_T = 1.0\/60.0                                # in minutes\n    const D_WATTS = 0.5                                     # power loss in Watts \/ minute\n    const G_THRUST = 60 * 3.6 * 3.6                         # acceleration due to biker's power\n    const MASS = 80                                         # biker's MASS\n    const WATTS0 = 225.0                                    # initial biker's power\n\n    var t = 0.0          # time in minutes\n    var d = 0.0          # distance traveled in km\n    var v = v0           # initial speed km\/h\n    var gamma = 0.0      # acceleration in km\/h\/minute\n    var watts = WATTS0   # biker's power (watts at time t + DELTA_T is watts at time t - D_WATTS * DELTA_T)\n    var slopeGravityAcc = -GRAVITY_ACC * sin(arctan(slope \/ 100.0))\n    while (d <= dTot):\n        t += DELTA_T\n        # new power\n        watts -= D_WATTS * DELTA_T # tiredness\n        # earth gravity due to slope and DRAG due to air resistance\n        gamma = slopeGravityAcc - DRAG * abs(v) * abs(v) \/ MASS\n        # acceleration due to biker's power\n        if ((watts > 0.0) and (v > 0.0)):\n            gamma += G_THRUST * watts \/ (v * MASS);\n        # acceleration too small -> acc = 0\n        if (abs(gamma) <= 1e-5):\n            gamma = 0.0;\n        else:\n            v += gamma * DELTA_T\n        # new distance\n        d +=  v  * DELTA_T \/ 60.0 # v in km\/h, DELTA_T in minutes\n        # speed too slow, John stops\n        if (v - 3.0 <= 1e-2):\n            return -1\n    return int(round(t))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"58941fec8afa3618c9000184":[{"id":215606,"user_id":53,"body":"import math\n\nproc growing_plant*(u: int, d: int, m: int): int =\n  max(1, int((float(m - d) \/ float(u - d)).ceil()));","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215607,"user_id":527,"body":"from math import ceil\n\nproc growing_plant*(upSpeed: int, downSpeed: int, desiredHeight: int): int =\n  ((desiredHeight - downSpeed) \/ (upSpeed - downSpeed)).ceil.int.max(1)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215608,"user_id":76,"body":"from math import ceil\n\nproc growing_plant*(upSpeed: int, downSpeed: int, desiredHeight: int): int =\n  1 + [0.0, (desiredHeight - upSpeed) \/ (upSpeed - downSpeed)].max.ceil.int","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215609,"user_id":null,"body":"proc growing_plant*(upSpeed: int, downSpeed: int, desiredHeight: int): int =\n  var\n    height = 0\n    count = 1\n  while true:\n     height += upSpeed\n     if height >= desiredHeight:\n       break\n     height -= downSpeed\n     count += 1\n  return count","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215610,"user_id":null,"body":"import math\n\nproc growing_plant*(upSpeed: int, downSpeed: int, desiredHeight: int): int =\n  result = 1\n  let days = int ceil (desiredHeight - upSpeed)\/(upSpeed - downSpeed)\n  if days > 0:\n    result += days","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215611,"user_id":50,"body":"proc growing_plant*(upSpeed: int, downSpeed: int, desiredHeight: int): int =\n  if desiredHeight <= upSpeed:\n    return 1\n  else:\n    return 1 + growing_plant(upSpeed, downSpeed, desiredHeight - upSpeed + downSpeed)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215612,"user_id":null,"body":"import math\n\nproc growing_plant*(upSpeed: int, downSpeed: int, desiredHeight: int): int =\n  if upSpeed > desiredHeight:\n    1\n  else:\n    ceil((desiredHeight - downSpeed) \/ (upSpeed - downSpeed)).int","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215613,"user_id":492,"body":"import math\nproc growing_plant*(up: int, down: int, h: int): int =\n  max(int(ceil((h - down) \/ (up - down))), 1)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215614,"user_id":null,"body":"proc growing_plant*(upSpeed: int, downSpeed: int, desiredHeight: int): int =\n  var height = 0\n  while true:\n    height += upSpeed\n    inc result\n    if height < desiredHeight:\n      height -= downSpeed\n    else:\n      break","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215615,"user_id":null,"body":"proc growing_plant*(upSpeed, downSpeed, desiredHeight: int): int =\n  var \n    h=0\n    i=1\n  while true:\n    h+=upSpeed\n    if h>=desiredHeight:\n      return i\n    h-=downSpeed\n    i+=1\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"58a5aeb893b79949eb0000f1":[{"id":215616,"user_id":null,"body":"from bitops import bitand\n\nproc shared_bits*(a, b: uint32): bool =\n  var\n    x {.exportc.} = bitand(a, b)\n    res {.exportc.}: cchar = 'n'\n  {.emit: \"\"\"\n  unsigned char flag = 0;\n  while (x > 0) {\n    if (x % 2 == 1) {\n      if (flag) {\n        res = 'y';\n        break;\n      } else {\n        flag = 1;\n      }\n    }\n    x >>= 1;\n  }\n  \"\"\".}\n  return (res == 'y')","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215617,"user_id":76,"body":"from strutils import count, toBin\n\nproc shared_bits*(a, b: uint32): bool =\n  toBin(BiggestInt(a and b), 32).count('1') > 1","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215618,"user_id":null,"body":"proc shared_bits*(a, b: uint32): bool =\n  var\n    flag = false\n    x = (a and b)\n  if x > uint32(0):\n    while x > uint32(0):\n      if x mod 2 == 1:\n        if flag:\n          return true\n        else:\n          flag = true\n      x = x div 2\n  else:\n    return false","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215619,"user_id":53,"body":"import std\/bitops;\n\nproc shared_bits*(x, y: uint32): bool =\n  var a: int = int(x);\n  var b: int = int(y);\n  var c = bitand(a, b);\n  var d = bitand(c, (c - 1));\n  return d > 0;","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215620,"user_id":50,"body":"import bitops\nproc shared_bits*(a, b: uint32): bool = countSetBits(bitand(a,b)) > 1","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215621,"user_id":527,"body":"import bitops\n\nfunc shared_bits*(a, b: uint32): bool =\n  countSetBits(a and b) >= 2","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215622,"user_id":527,"body":"import bitops\n\nfunc shared_bits*(a, b: uint32): bool =\n  popcount(a and b) >= 2","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215623,"user_id":759,"body":"import bitops\nproc shared_bits*(a, b: uint32): bool =\n  popcount(a and b) > 1","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"58a6568827f9546931000027":[{"id":215624,"user_id":527,"body":"func number_of_carries*(a, b: int): int =\n  var (a, b, c) = (a, b, 0)\n  while a != 0 or b != 0:\n    c = (c + a mod 10 + b mod 10) div 10\n    result += c\n    a = a div 10\n    b = b div 10","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215625,"user_id":50,"body":"proc number_of_carries*(q, w: int): int =\n  var a = q\n  var b = w\n  var r=0\n  var c=0\n  while a+b != 0:\n    var x = a mod 10\n    var y = b mod 10\n    a = (a \/ 10).int\n    b = (b \/ 10).int\n    r=((r+y+x)\/10).int\n    c+=r\n  return c\n                   \n    ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215626,"user_id":null,"body":"proc number_of_carries*(a, b: int): int =\n  var\n    k: int\n    x = a\n    y = b\n  while x > 0 or y > 0:\n    k.inc (x mod 10) + (y mod 10)\n    if k > 9:\n      result.inc\n    k = k div 10\n    x = x div 10\n    y = y div 10","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215627,"user_id":null,"body":"import strutils\n\nproc zeroFill(s: string, length: int): string =\n  if s.len > length:\n    return s\n  return \"0\".repeat(length - s.len) & s\n\nproc toInt(c: char): int = int(c) - 48\n\nproc number_of_carries*(a, b: int): int =\n  var (n1, n2) = ($a, $b)\n  let max_len = max(n1.len, n2.len)\n  (n1, n2) = (n1.zeroFill(max_len), n2.zeroFill(max_len))\n  var carries = 0\n  var remember = 0\n  for index in countDown(max_len - 1, 0):\n    let sum = n1[index].toInt() + n2[index].toInt() + remember\n    if sum > 9:\n      carries += 1\n      remember = sum div 10\n    else:\n      remember = 0\n  return carries","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215628,"user_id":759,"body":"proc number_of_carries*(a, b: int): int =\n  var\n    a = a\n    b = b\n    carry = 0\n  while a != 0 or b != 0:\n    carry = (a mod 10 + b mod 10 + carry) div 10\n    result += carry\n    a = a div 10\n    b = b div 10","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"58acfe4ae0201e1708000075":[{"id":215629,"user_id":527,"body":"from math import sum\n\nproc invite_more_women*(l: seq[int]): bool =\n  sum(l) > 0","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215630,"user_id":76,"body":"from math import sum\n\nproc invite_more_women*(l: seq[int]): bool = l.sum > 0","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215631,"user_id":null,"body":"import std\/math\n\nproc invite_more_women*(l: seq[int]): bool = l.sum > 0","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215632,"user_id":null,"body":"import sequtils\n\nproc invite_more_women*(l: seq[int]): bool =\n  return if l.count(-1) >= l.count(1): false else: true\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215633,"user_id":null,"body":"import std\/sequtils\nproc invite_more_women*(l: seq[int]): bool =\n  assert(l.len >= 2 and l.len <= 50)\n  l.foldl(a + b) > 0","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215634,"user_id":null,"body":"proc invite_more_women*(l: seq[int]): bool =\n  var s = 0\n  for g in l:\n    s += g\n  s > 0","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215635,"user_id":50,"body":"import sequtils\nproc invite_more_women*(l: seq[int]): bool =\n  foldl(l, a + b) > 0","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215636,"user_id":null,"body":"import sequtils\n\nproc invite_more_women*(l: seq[int]): bool =\n  return l.count(1) > l.count(-1)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215637,"user_id":null,"body":"import sequtils\n\nproc invite_more_women*(l: seq[int]): bool =\n  count(l, 1) > count(l, -1)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215638,"user_id":null,"body":"proc invite_more_women*(l: seq[int]): bool =\n  var s = 0\n  for p in l:\n    s += p\n  s > 0","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"58ce8725c835848ad6000007":[{"id":215639,"user_id":492,"body":"proc potatoes*(p0: int, w0: int, p1: int): int = \n  int(w0 * (100 - p0) \/ (100 - p1))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215640,"user_id":492,"body":"proc potatoes*(p0: int, w0: int, p1: int): int = \n  int(w0 * (100 - p0) \/ (100 - p1))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215641,"user_id":527,"body":"proc potatoes*(p0: int, w0: int, p1: int): int =\n  w0 * (100 - p0) div (100 - p1)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215642,"user_id":null,"body":"proc potatoes*(p0: int, w0: int, p1: int): int =\n  let initialDryWeightPercent = float(100 - p0)\n  let finalDryWeightPercent = float(100 - p1)\n  \n  let initialDryWeight = float(w0) \/ 100f * initialDryWeightPercent\n  \n  int(initialDryWeight * 100f \/ finalDryWeightPercent)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215643,"user_id":null,"body":"import std\/math\n\nproc potatoes*(p0: int, w0: int, p1: int): int = ((w0 * (100 - p0)) \/ (100 - p1)).int","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215644,"user_id":null,"body":"proc potatoes*(p0: int, w0: int, p1: int): int =\n  int((100 - p0) \/ (100 - p1) * w0.float)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215645,"user_id":null,"body":"import math\n\nproc potatoes*(p0: int, w0: int, p1: int): int = \n  let dry_weight = (100-p0) * w0\n  let final_dry_pct = 100-p1\n  result = toInt(floor(dry_weight \/ final_dry_pct))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215646,"user_id":null,"body":"import math\n\nproc potatoes*(p0: int, w0: int, p1: int): int =\n  result = ((w0 * (100 - p0))\/(100 - p1)).int","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215647,"user_id":564,"body":"import math\n\nproc potatoes*(p0: int, w0: int, p1: int): int = w0 * (100 - p0) div (100 - p1)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215648,"user_id":null,"body":"proc potatoes*(s: int, w: int, e: int): int =\n  w * (100 - s) div (100 - e)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"58e93b4706db4d24ee000096":[{"id":215649,"user_id":759,"body":"proc days_represented*(trips: seq[(int, int)]): int =\n  var days: set[range[1..365]]\n  for (a, b) in trips.items:\n    for d in a..b:\n      if d notin days:\n        days.incl(d)\n        inc result","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215650,"user_id":76,"body":"import tables\n\nproc days_represented*(trips: seq[(int, int)]): int =\n  var been = initTable[int, bool]()\n  for (s, e) in trips:\n    for n in s .. e:\n      been[n] = true\n  been.len","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215651,"user_id":null,"body":"proc days_represented*(trips: seq[(int, int)]): int =\n  var days: array[-1..366, int]\n  for (s,e) in trips:\n    days[s]+=1\n    days[e+1]-=1\n  \n  for i in 0..days.high:\n    days[i]+=days[i-1]\n    if days[i]>0: result.inc\n  ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215652,"user_id":null,"body":"import algorithm\n\nproc days_represented*(trips: seq[tuple[front, back: int]]): int =\n  var\n    trips = sorted trips\n    i = 0\n  while i < trips.high and trips.len > 1:\n    let nextTrip = trips[i + 1]\n    if trips[i].front <= nextTrip.front and trips[i].back >= nextTrip.front:\n      if trips[i].back < nextTrip.back:\n        trips[i].back = nextTrip.back\n      trips.delete i + 1\n      continue\n    inc i\n  for trip in trips:\n    result += trip.back - trip.front + 1","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"58f6000bc0ec6451960000fd":[{"id":215653,"user_id":null,"body":"import algorithm\n\nproc sel_reverse*[T](sequence: seq[T], stride: int): seq[T] =\n  if stride==0: return sequence\n  var\n    segments = sequence.len div stride\n    reversedSequence: seq[T] = @[]\n    sliceEnd: int\n\n  for s in 0..segments:\n    sliceEnd = min(sequence.len-1, s*stride+(stride-1))\n    reversedSequence.add(sequence[s*stride..sliceEnd].reversed)\n\n  return reversedSequence","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215654,"user_id":null,"body":"import future\nimport sequtils\nimport algorithm\nimport math\nproc sel_reverse*[T](s: seq[T], l: int): seq[T] =\n  if l > 1 : concat(map(distribute(s, int(ceil(len(s) \/ l)) , false), x => reversed(x)))\n  else: s","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215655,"user_id":null,"body":"import algorithm\nproc sel_reverse*[T](s: seq[T], l: int): seq[T] =\n  if l == 0: return s\n  for i in 0..(s.len div l):\n    for ee in s[l*i..<min(l*(i+1), s.len)].reversed:\n      result.add ee","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215656,"user_id":null,"body":"import algorithm\n\n\nproc sel_reverse*[T](s: seq[T], l: int): seq[T] =\n  if l == 0: return s\n  var start = 0\n  while start < len(s):\n    let ends = min(start+l, len(s))\n    let ss = s[start..<ends]\n    start += l\n    for ee in ss.reversed:\n      result.add ee\n\n    ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215657,"user_id":480,"body":"proc sel_reverse*[T](s: seq[T], l: int): seq[T] =\n  var r=newSeq[T](s.len())\n  if l<1:\n    return s\n  var j=l\n  for i in 0..high(s):\n    j=j-1\n    if j>=s.len():\n      j=s.len()-1\n    r[i]=s[j]\n    if (i+1) mod l==0:\n      j+=2*l\n  return r","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215658,"user_id":null,"body":"import algorithm\n\nproc sel_reverse*[T](s: seq[T], l: int): seq[T] =\n  if l == 0:\n    return s\n  var sCopy = s\n  if l > len(sCopy):\n    reverse(sCopy)\n    return sCopy\n  for i in countup(0, len(sCopy) - 1, l):\n    if i + l > len(sCopy):\n      reverse(sCopy, i, len(sCopy) - 1)\n    else:\n      reverse(sCopy, i, i + l - 1)\n  sCopy","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215659,"user_id":null,"body":"import future\nimport algorithm\nimport sequtils\nimport math\n\nproc take[T](s: seq[T], num: int): seq[T] =\n  if s.len > 0: s[0..min(s.len, num)-1] else: @[]\n\nproc skip[T](s: seq[T], num: int): seq[T] =\n  if s.len > 0: s[min(s.len, num)..s.len-1] else: @[]\n\nproc chunk[T](s: seq[T], i: int): seq[seq[T]] =\n  if i < 1: return @[s]\n  var ret: seq[seq[T]] = @[]\n  var cs = s.map(x => x)\n  while cs.len > 0:\n    ret.add(cs.take(i))\n    cs = cs.skip(i)\n  return ret\n\nproc flatten[T](s: seq[seq[T]], selector: proc(e: T): T = nil): seq[T] =\n  var sl: proc(e: T): T\n  if selector == nil:\n    sl = proc(e: T): T = e\n  else:\n      sl = selector\n  var ret: seq[T] = @[]\n  for iseq in s:\n    var i = iseq\n    ret = ret.concat(i.map(sl))\n  return ret\n\nproc sel_reverse*[T](s: seq[T], l: int): seq[T] =\n  if l < 1: s\n  else: s.chunk(l).map(x => x.reversed).flatten(x => x)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215660,"user_id":null,"body":"proc sel_reverse*[T](s: seq[T], l: int): seq[T] =\n  result = newSeq[T]()\n  if l == 0: return s\n  for i in 0..(s.len \/ l).int:\n    var seqcut = newSeq[T]()\n    if s.len <= (i+1)*l-1 : \n        seqcut = s[(i*l)..s.len-1]\n    else:\n        seqcut = s[(i*l)..(i+1)*l-1]\n    for i in countdown(seqcut.len-1, 0):\n      result.add(seqcut[i])","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215661,"user_id":null,"body":"\nproc sel_reverse*[T](s: seq[T], l: int): seq[T] =\n  result = newSeq[T]()\n  if l == 0: return s\n  for i in 0..(s.len \/ l).int:\n    var seqcut = newSeq[T]()\n    if s.len <= (i+1)*l-1 : \n        seqcut = s[(i*l)..s.len-1]\n    else:\n        seqcut = s[(i*l)..(i+1)*l-1]\n    echo seqcut\n    for i in countdown(seqcut.len-1, 0):\n      result.add(seqcut[i])","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215662,"user_id":null,"body":"from algorithm import reversed\n\nproc sel_reverse*[T](s: seq[T], l: int): seq[T] =\n  if l == 0:\n    return s\n  \n  let n = s.len\n  result = newSeq[T](n)\n  for i in 0..<(n div l):\n    let\n      low = i*l\n      high = low + l\n    result[low..<high] = reversed(s[low..<high])\n  result[^(n mod l)..<n] = reversed(s[^(n mod l)..<n])","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"58f8a3a27a5c28d92e000144":[{"id":215663,"user_id":759,"body":"import options\n\nproc first_non_consecutive*(arr: seq[int]): Option[int] =\n  for i in 1..<arr.len:\n    if arr[i] - arr[i - 1] != 1:\n      return some(arr[i])\n  result = none(int)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215664,"user_id":null,"body":"import options\n\nproc first_non_consecutive*(arr: seq[int]): Option[int] =\n  var exp = arr[0]\n  for i in arr:\n    if i != exp:\n      return some(i)\n    exp += 1\n      ","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215665,"user_id":null,"body":"import options\n\nproc shift[T](s: seq[T]): seq[T] =\n  if len(s) <= 1:\n    return @[]\n  for i in 1..s.high:\n    result.add(s[i])\n    \n  \n\nproc first_non_consecutive*(arr: seq[int]): Option[int] =\n  if len(arr) < 2:\n    return none(int)\n  if arr[0] + 1 != arr[1]:\n    return some(arr[1])\n  return first_non_consecutive(shift(arr))","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215666,"user_id":76,"body":"import options\n\nproc first_non_consecutive*(arr: seq[int]): Option[int] =\n  for i in 1 ..< len(arr):\n    if arr[i] != arr[i-1] + 1:\n      return some(arr[i])\n  return none(int)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215667,"user_id":null,"body":"import options\n\nproc first_non_consecutive*(arr: seq[int]): Option[int] =\n  for i in 1..arr.len-1:\n    if arr[i] - 1 != arr[i - 1]:\n      return some(arr[i])\n    \n  none(int)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215668,"user_id":null,"body":"import options\n\nproc first_non_consecutive*(arr: seq[int]): Option[int] =\n  for i in 1..arr.len-1:\n    if arr[i] - 1 != arr[i - 1]:\n      return some(arr[i])\n    \n  return none(int)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215669,"user_id":null,"body":"import options\n\nproc first_non_consecutive*(arr: seq[int]): Option[int] =\n    for i in 1 .. < len(arr):\n      if arr[i] - arr[i-1] != 1: return some(arr[i])","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215670,"user_id":null,"body":"import options\n\nproc first_non_consecutive*(arr: seq[int]): Option[int] =\n    for i in 1..arr.len-1:\n      if arr[i-1] + 1 != arr[i]:\n        return some(arr[i])\n    return none(int)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215671,"user_id":null,"body":"import options\n\nproc first_non_consecutive*(arr: seq[int]): Option[int] =\n  for i in 0 .. arr.len-2:\n    var tmp: int = arr[i+1] - arr[i]\n    if tmp!=1:\n      return some(arr[i+1])\n    \n  return none(int)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215672,"user_id":null,"body":"import options\n\nproc first_non_consecutive*(arr: seq[int]): Option[int] =\n  var p = arr[0] - 1\n  for i in arr:\n    if p == i - 1:\n      echo \"ok\"\n    else:\n      return some(i)\n    p = i\n  return none(int)","lang_id":33,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"59b44d00bf10a439dd00006f":[{"id":215673,"user_id":759,"body":"import math\n\ntemplate add*(x): auto = cumsummed(x)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215674,"user_id":76,"body":"from sequtils import foldl, concat\n\nproc add*(s: seq[int]): seq[int] =\n  if s.len > 0:\n    s[1 .. ^1].foldl(a.concat(@[a[^1] + b]), @[s[0]])\n  else:\n    @[]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215675,"user_id":null,"body":"func add*(s: seq[int]): seq[int] =\n  var sum = 0\n  for x in s:\n    sum += x\n    add(result, sum)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215676,"user_id":null,"body":"proc add*(s: seq[int]): seq[int] =\n  var number: int\n  var arr: seq[int]\n  for i in s.items:\n    number += i\n    arr.add(number)\n  return arr","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215677,"user_id":null,"body":"proc add*(s: seq[int]): seq[int] =\n  var acc: int\n  for n in s:\n    acc += n\n    result.add(acc)\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215678,"user_id":null,"body":"proc add*(s: seq[int]): seq[int] =\n  for i in 0..<s.len:\n    var acc: int\n    for n in 0..i:\n        acc += s[n]\n    result.add(acc)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215679,"user_id":null,"body":"proc add*(s: seq[int]): seq[int] =\n  var k = 0\n  for n in s:\n    k += n\n    result.add k","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215680,"user_id":null,"body":"import math\nproc add*(s: seq[int]): seq[int] = cumsummed(s)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215681,"user_id":null,"body":"proc add*(s: seq[int]): seq[int] =\n  var p = 0\n  for i in s:\n    p = i+p\n    result.add(p)\n      ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215682,"user_id":null,"body":"proc add*(s: seq[int]): seq[int] =\n  var part = 0\n  result = newSeq[int]()\n  for i in s:\n    part += i\n    result.add(part)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"59c68ea2aeb2843e18000109":[{"id":215683,"user_id":76,"body":"import math, strutils\n\nproc amort*(rate: float64, balance: int, terms: int, numPayments: int): string =\n  var r = rate \/ 1200\n  var c = (r * balance.float) \/ (1 - (1 + r).pow(-terms.float))\n  var b = float64(balance)\n  var interest: float64 = 0\n  for i in 1 .. numPayments:\n    interest = b * r\n    b = (1 + r) * b - c\n  return \"num_payment $1 c $2 princ $3 int $4 balance $5\" % [$numPayments, $c.round.int, $(c - interest).round.int, $interest.round.int, $b.round.int]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215684,"user_id":492,"body":"import math, strutils\n\nproc amort*(rate: float64, balance: int, term: int, numPayments: int): string =\n    var bal = float64(balance)\n    var r = rate \/ 1200.0\n    let payment = (r * float64(bal)) \/ (1 - pow(1.0 + r, float64(-term)))\n    var interest = 0.0\n    var principal = 0.0\n    for i in 1..numPayments:\n        interest = bal * r\n        principal = payment - interest\n        bal = bal - principal\n    return \"num_payment $1 c $2 princ $3 int $4 balance $5\".\n        format(numPayments, int(round(payment)), int(round(principal)), int(round(interest)), int(round(bal)))\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"59ca8246d751df55cc00014c":[{"id":215685,"user_id":null,"body":"proc hero*(bullets: int, dragons: int): bool =\n    return (bullets\/2).int>=dragons","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215686,"user_id":null,"body":"proc hero*(bullets: int, dragons: int): bool =  bullets >= dragons * 2","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215687,"user_id":null,"body":"proc hero*(bullets: int, dragons: int): bool =\n  return int(bullets \/ 2) >= dragons","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215688,"user_id":null,"body":"proc hero*(b, d: int): bool =\n    if d > 0: b div d >= 2 else: true","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215689,"user_id":null,"body":"proc hero*(bullets: int, dragons: int): bool =\n    dragons == 0 or bullets div dragons >= 2","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215690,"user_id":168,"body":"proc hero*(bullets: int, dragons: int): bool =\n    2 * dragons <= bullets","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215691,"user_id":null,"body":"proc hero*(bullets: int, dragons: int): bool =\n    dragons - bullets div 2 <= 0","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215692,"user_id":null,"body":"proc hero*(bullets: int, dragons: int): bool =\n    result = dragons * 2 <= bullets","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215693,"user_id":null,"body":"proc hero*(bullets: int, dragons: int): bool =\n  result=false\n  if dragons<=0: return true\n  elif bullets div (dragons*2)>0 :\n    return true","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215694,"user_id":null,"body":"proc hero*(bullets: int, dragons: int): bool =\n    result = bullets >= 2 * dragons","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"59ccf051dcc4050f7800008f":[{"id":215695,"user_id":null,"body":"proc divSum(n: int): int =\n  ## sum of all positive divisors of `n` else 1 and `n` itself\n  var d = 2\n  while d * d < n:\n    if n mod d == 0:\n      result += d + n div d\n    inc d\n  if d * d == n: result += d\n\nproc buddy*(start, nd: int): string =\n  for n in start..nd:\n    let m = divSum(n)\n    if m > n and divSum(m) == n:\n      return \"(\" & $n & \" \" & $m & \")\"\n  \"Nothing\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215696,"user_id":76,"body":"import math, strutils\n\nfunc divSum(n: int): int =\n  let sq = float(n).sqrt.int\n  var s = if sq ^ 2 == n: sq else: 0\n  for i in 2 .. sq:\n    if n mod i == 0:\n      s += i + n div i\n  return s\n  \nproc buddy*(start, nd: int): string =\n  for n in start .. nd:\n    let m = divSum(n)\n    if m > n and divSum(m) == n:\n      return \"($1 $2)\".format(n, m)\n  return \"Nothing\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215697,"user_id":null,"body":"import std\/math\n\nproc calcsum(n: int): int =\n  var total = 1\n  let upper = int(sqrt(float(n)))\n  for i in 2..upper:\n    if n mod i == 0:\n      total += i\n      let other = n div i\n      if i != other:\n        total += other\n  return total\n\nproc buddy*(start, nd: int): string =\n  for i in start..nd:\n    let mysum = calcsum(i)\n    let other = mysum - 1\n    if other < start:\n      continue\n    let pairsum = calcsum(other)\n    if i == pairsum - 1:\n      if i < other:\n        return \"(\" & $i & \" \" & $other & \")\"\n      return \"(\" & $other & \" \" & $i & \")\"\n  return \"Nothing\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215698,"user_id":53,"body":"import strutils, math\n\nproc fdivsum(n: int):int =\n  var sum = 1\n  var i = 2\n  while i <= int(sqrt(toFloat(n))):\n    if (n mod i == 0):\n      sum += i\n      if (i != int(n\/i)):\n        sum += int(round(n\/i))\n    i += 1\n  return sum\n\nproc buddy*(start, nd: int):string =\n  var r = \"\"\n  var i = start\n  while i <= nd:\n    var a = fdivsum(i)\n    if a - 1 > i:\n      var b = fdivsum(a - 1)\n      if b - 1 == i:\n        r &= \"(\"\n        r &= intToStr(i)\n        r &= \" \"\n        r &= intToStr(a - 1)\n        r &= \")\"\n        return r\n    i += 1\n  r &= \"Nothing\"\n  return r","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215699,"user_id":null,"body":"import math, tables, strformat\n\nproc proper(n: int): seq[int] =\n  result.add 1\n  for i in 2..n.float.sqrt.int:\n    if n mod i == 0:\n      result.add i\n      result.add n div i\n      \nproc buddy*(start, nd: int):string =\n  var keys, values: seq[int]\n  for i in start..nd:\n    let pair = i.proper.sum - 1\n    if pair > i:\n      keys.add i\n      values.add pair\n  for i in 0..<keys.len:\n    if values[i].proper.sum - 1 == keys[i]:\n      return \"({keys[i]} {values[i]})\".fmt\n  return \"Nothing\"\n    ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215700,"user_id":492,"body":"import strutils\n\nproc buddy*(start, nd: int):string =\n    proc nbd(n: int): int =\n        if n < 2: \n            return 0\n        var total = 1; var i = 2\n        while i * i < n:\n            if n %% i == 0:\n                total += (n div i) + i\n            i += 1\n        if i * i == n:\n            total += i\n        return total\n    var n = start\n    while n <= nd:\n        let m = nbd(n) - 1\n        if (n == (nbd(m) - 1) and n < m):\n            return \"($1 $2)\".format(n, m)\n        n += 1\n    return \"Nothing\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"59d0ee709f0cbcf65400003b":[{"id":215701,"user_id":492,"body":"import sequtils, strutils, algorithm\n\nproc byState*(str: string): string =  \n    type \n        statefriend = object\n            state: string\n            name: string\n            address: string\n            town: string\n    proc comp(x, y: statefriend): int =\n        if x.state == y.state:\n            return cmp(x.name, y.name)\n        return cmp(x.state, y.state)\n\n    var s = @[\" MA\", \" VA\", \" OK\", \" PA\", \" CA\", \" AZ\", \" ID\", \" IN\"]\n    var st = @[\", Massachusetts\", \", Virginia\", \", Oklahoma\", \", Pennsylvania\", \", California\", \", Arizona\", \", Idaho\", \", Indiana\"]\n    var u = str\n    for i, _ in s:\n        u = replace(u, s[i], st[i])\n    var arr = splitLines(u)\n    keepIf(arr, proc (x: string): bool = (x != \"\"))\n    var narr: seq[statefriend] = newSeq[statefriend](arr.len())\n    for i, x in arr:\n        let y = split(x, \", \")\n        narr[i].state = y[3]\n        narr[i].name = y[0]\n        narr[i].address = y[1]\n        narr[i].town = y[2]\n    narr.sort(comp)\n    var output = \"\"; var last = \"\"\n    for _, v in narr:\n        let e = v.state\n        if e != last:\n            last = e       \n            output &= \"\n\" & \" \" & e & \"\n..... \" & v.name & \" \" & v.address & \" \"  & v.town & \" \" & v.state\n        else:\n            output &= \"\n..... \" & v.name & \" \" & v.address & \" \" & v.town & \" \" & v.state\n    output = output[2..^1]\n    return output","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"59d727d40e8c9dd2dd00009f":[{"id":215702,"user_id":492,"body":"import nre, strutils, sequtils\n\nproc balance*(book: string): string =\n    let u = replace(book, re\"[^\n. 0-9A-Za-z]\", \"\")\n    var lines = splitLines(u)\n    keepIf(lines, proc (x: string): bool = (x != \"\"))\n    var total = parseFloat(lines[0]); var current = total; var count = 0\n    var res = \"Original Balance: \" & total.formatFloat(ffDecimal, 2)\n    for line in lines[1..^1]:\n        count += 1\n        let l = split(line, \" \")\n        let g = parseFloat(l[2])\n        current -= g\n        res &= \"\n$1 $2 $3 Balance $4\".\n            format(l[0], l[1], g.formatFloat(ffDecimal, 2), current.formatFloat(ffDecimal, 2))\n    res &= \"\nTotal expense  $1\nAverage expense  $2\".\n        format((total - current).formatFloat(ffDecimal, 2), ((total - current) \/ float64(count)).formatFloat(ffDecimal, 2))\n    return res","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"59d9d8cb27ee005972000045":[{"id":215703,"user_id":759,"body":"import strutils\nproc catalog*(s, article: string): string =\n  for x in s.splitLines:\n    template findTag(tag: string): string =\n      x[x.find(\"<\" & tag & \">\") + 2 + tag.len ..< x.find(\"<\/\" & tag & \">\")]\n    if x.len != 0 and (let name = findTag(\"name\");\n                       article in name):\n      if result.len != 0: result.add(\"\n\")\n      result.add(name & \" > prx: $\" & findTag(\"prx\") &\n                 \" qty: \" & findTag(\"qty\"))\n  if result.len == 0: result = \"Nothing\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215704,"user_id":492,"body":"import strutils, nre, sequtils\n\nproc catalog*(s, article: string): string =\n    var r: seq[string] = @[]; var lines = splitLines(s)\n    keepIf(lines, proc (x: string): bool = (x != \"\"))\n    for line in lines:\n        var a = line.split(re\"<.*?><.*?>\")\n        keepIf(a, proc (x: string): bool = (x != \"\"))\n        if contains(a[0], article):\n            let u = \"$1 > prx: $2$3 qty: $4\".format(a[0], \"$\", a[1], a[2])\n            r.add(u)\n    if r.len() == 0: return \"Nothing\" else: return join(r, \"\n\")","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215705,"user_id":null,"body":"import std\/strutils\n\ntype \n    Prod = object\n        name, price, qty: string\n\nproc parse(s: string): Prod = \n    const \n        name_start = \"<prod><name>\".len\n    let \n        name_end = s.find(\"<\/name>\")-1\n        prx_start = s.find(\"<prx>\")+5\n        prx_end = s.find(\"<\/prx>\", prx_start)-1\n        qty_start = s.find(\"<qty>\")+5\n        qty_end = s.find(\"<\/qty>\", qty_start)-1\n    result = Prod(name: s[name_start .. name_end], \n                  price: \"$\" & s[prx_start .. prx_end],\n                  qty: s[qty_start .. qty_end])\n\n\nproc catalog*(s, article: string): string =\n    for line in splitLines(s):\n        if line.len == 0: continue\n        if article in line:\n            let product = line.parse\n            result.add(product.name)\n            result.add(\" > prx: \")\n            result.add(product.price)\n            result.add(\" qty: \")\n            result.add(product.qty & '\n')\n    if result == \"\":\n      result = \"Nothing\"\n    else:\n      result.stripLineEnd","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215706,"user_id":null,"body":"import strutils, re, strformat\nproc catalog*(s, article: string): string =\n  var l = splitLines(s)\n  var ll,name,qty,price: seq[string]\n  if article in s:\n    for x in l:\n      if article in x:\n        name = findAll(x,re\"(?<=<name>)(.*)(?=<\\\/name>)\")\n        price = findAll(x,re\"(?<=<prx>)(.*)(?=<\\\/prx>)\")\n        qty = findAll(x,re\"(?<=<qty>)(.*)(?=<\\\/qty>)\")\n        ll.add(fmt\"{name[0]} > prx: ${price[0]} qty: {qty[0]}\")\n    result = ll.join(\"\n\")\n  else:\n    result = \"Nothing\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215707,"user_id":492,"body":"import strutils, nre, sequtils\n\nproc catalog*(s, article: string): string =\n    var r: seq[string] = @[]; var lines = splitLines(s)\n    keepIf(lines, proc (x: string): bool = (x != \"\"))\n    for line in lines:\n        var a = line.split(re\"<.*?><.*?>\")\n        keepIf(a, proc (x: string): bool = (x != \"\"))\n        if contains(a[0], article):\n            let u = \"$1 > prx: $2$3 qty: $4\".format(a[0], \"$\", a[1], a[2])\n            r.add(u)\n    if r.len() == 0: return \"Nothing\" else: return join(r, \"\n\")\n    \n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"59d9ff9f7905dfeed50000b0":[{"id":215708,"user_id":null,"body":"import strutils, sequtils\n\nproc solveOne(s: string): int =\n  for i, c in s:\n    if c.toLowerAscii.ord - 'a'.ord == i:\n      result += 1\n\nproc solve*(strings: seq[string]): seq[int] =\n  map(strings, solveOne)\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215709,"user_id":null,"body":"import strutils\n\nproc solveOne(s: string): int =\n  for i, c in s:\n    if c.toLowerAscii.ord - 'a'.ord == i:\n      result += 1\n\nproc solve*(strings: seq[string]): seq[int] =\n  for s in strings:\n    result.add(solveOne(s))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215710,"user_id":76,"body":"from sequtils import map, filterIt, toSeq, zip\nfrom strutils import toLowerAscii\nfrom sugar import `=>`\n\nproc solve*(strings: seq[string]): seq[int] =\n  strings.map(s => s.toLowerAscii.zip(('a'..'z').toSeq).filterIt(it[0] == it[1]).len)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215711,"user_id":null,"body":"import sequtils,strutils\nproc solve*(strings: seq[string]): seq[int] =\n  let a = toSeq('a'..'z')\n  for s in strings:\n    var cnt = 0\n    for i,l in s.pairs:\n      if l.toLowerAscii == a[i]: cnt+=1\n    result.add cnt\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215712,"user_id":null,"body":"proc solve*(strings: seq[string]): seq[int] =\n  let lowerStrings = \"abcdefghijklmnopqrstuvwxyz\"\n  let upperStrings = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    \n  for seqStrings in strings:\n    var isInPosition = 0\n    for index in 0 .. seqStrings.high:      \n      if seqStrings[index] == lowerStrings[index] or seqStrings[index] == upperStrings[index]:\n        inc isInPosition\n    result.add(isInPosition)    \n      \n  \n  discard","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215713,"user_id":null,"body":"import strutils except toLower\n\nproc solve*(strings: seq[string]): seq[int] =\n  var answer: seq[int] = @[]\n  for item in strings:\n    var counter: int = 0\n    for i in 0 .. item.len-1:\n      if (int(char(item[i].toLowerAscii))-97) == i: counter += 1\n    answer.add(counter)\n    counter = 0\n  \n  answer","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215714,"user_id":null,"body":"import std\/strutils\n\nproc solve*(strings: seq[string]): seq[int] =\n  for word in items(strings):\n    var count: int\n    for i, ch in word:\n      if isUpperAscii(ch) and ord(ch) - ord('A') == i:\n        count.inc()\n      elif isLowerAscii(ch) and ord(ch) - ord('a') == i:\n        count.inc()\n        \n    result.add(count)\n\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215715,"user_id":null,"body":"import sequtils,strutils\nproc solve*(strings: seq[string]): seq[int] =\n  let alpha=toSeq({'a'..'z'})\n  for s in strings:\n    var count=0\n    for i in 0..<s.len:\n      if toLowerAscii(s[i])==alpha[i]: inc(count)\n    result.add(count)\n  ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215716,"user_id":null,"body":"import std\/strutils\nimport std\/sequtils\n\nproc solve*(strings: seq[string]): seq[int] =\n  let ab = toSeq 'a'..'z'\n  strings.map(proc (s: string): int =\n    zip(toSeq 0..s.len, s).filter(proc (k: (int, char)): bool =\n      ab[k[0]] == toLowerAscii k[1]\n    ).len\n  )","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215717,"user_id":null,"body":"import strutils\nimport sequtils\n\nproc countPositions(s: string): int =\n  let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n  let lower    = s.toLowerAscii()\n  for i in 0..lower.len - 1:\n    if lower[i] == alphabet[i]:\n      result += 1\n\nproc solve*(strings: seq[string]): seq[int] =\n  map(strings, countPositions)\n    ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"59de1e2fe50813a046000124":[{"id":215718,"user_id":492,"body":"import strutils, nre, options\n\nproc change*(s, prog, version: string): string =\n    let reg = re\"(*CR)(.+Phone: )(?P<phone>\\+1-\\d{3}-\\d{3}-\\d{4})(.+Version: )(?P<version>\\d+\\.\\d+[^.])\"\n    let m = s.match(reg)\n    if isNone(m):\n        return \"ERROR: VERSION or PHONE\"\n    let p = \"+1-503-555-0090\"; var v = \"\"\n    let vs = m.get.captures[\"version\"]\n    if vs[0 .. ^2] == \"2.0\":\n        v = \"2.0\"\n    else:\n        v = version\n    return \"Program: $1 Author: g964 Phone: $2 Date: 2019-01-01 Version: $3\".format(prog, p, v)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215719,"user_id":null,"body":"import strutils, re, strformat\n\nproc change*(s, prog, version: string): string =\n  const \n    AUTHOR = \"g964\"\n    DATE = \"2019-01-01\"\n    PHONE = \"+1-503-555-0090\"\n  let data = s.split('\n')\n  if not data[3][7..^1].match(re\"\\+1\\-\\d{3}\\-\\d{3}\\-\\d{4}$\") or not data[5][9..^1].match(re\"\\d{1,}\\.\\d{1,}$\"):\n    return \"ERROR: VERSION or PHONE\"\n  let version =\n    if data[5][9..^1] == \"2.0\": \"2.0\"\n    else: version\n  return &\"Program: {prog} Author: {AUTHOR} Phone: {PHONE} Date: {DATE} Version: {version}\"\n  ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215720,"user_id":null,"body":"import strutils, sequtils\n\nconst\n  phone = \"+1-503-555-0090\"\n  date = \"2019-01-01\"\n  author = \"g964\"\n\nproc subdate(s: string): string =\n  if s.startsWith \"Date\": \"Date: \" & date\n  else: s\n\nproc subauthor(s: string): string =\n  if s.startsWith \"Author\": \"Author: \" & author\n  else: s\n\nproc subprog(s, p: string): string =\n  if s.startsWith \"Program\": \"Program: \" & p\n  else: s\n\nproc filterLine(s: string): bool =\n  not (s.startsWith\"Corporation\" or s.startsWith\"Level\")\n\ntemplate check(expr: untyped): untyped =\n  if not (expr):\n      raise newException(ValueError, \"it bad\")\n\nproc subversion(s, p: string): string =\n  if s.startsWith \"Version\":\n    let version = s.split(\": \")[1]\n    if version == \"2.0\": s\n    else:\n      let parts = version.split('.')\n      check parts.len == 2\n      for p in parts:\n        discard parseInt p\n      \"Version: \" & p\n  else: s\n\nproc subphone(s: string): string =\n  if s.startsWith \"Phone\":\n    let number = s.split(\": \")[1]\n    check number.len == phone.len\n    check number.startsWith \"+1-\"\n    let numgroups = number[\"+1-\".len .. ^1].split('-')\n    check numgroups.len == 3\n    check numgroups[0].len == 3\n    check numgroups[1].len == 3\n    check numgroups[2].len == 4\n    for g in numgroups:\n      discard parseInt g\n    \"Phone: \" & phone\n  else: s\n\nproc change*(s, prog, version: string): string =\n  try:\n    s.splitLines\n     .filter(filterLine)\n     .map(subdate)\n     .map(subauthor)\n     .mapit(subprog(it, prog))\n     .mapit(subversion(it, version))\n     .map(subphone)\n     .join(\" \")\n  except: \"ERROR: VERSION or PHONE\"\n\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"59df2f8f08c6cec835000012":[{"id":215721,"user_id":492,"body":"import strutils, algorithm\n\nproc meeting*(s: string): string =\n    let sw = split(toUpperAscii(s), \";\")\n    var res: seq[string] = @[]\n    for pn in sw:\n        let a = split(pn, \":\")\n        let s = \"(\" & a[1] & \", \" & a[0] & \")\" \n        res.add(s)\n    sort(res, system.cmp[string])\n    return join(res, \"\")\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215722,"user_id":null,"body":"import strutils, algorithm, strformat, sequtils\n\nproc meeting*(s: string): string =\n  return s.toUpperAscii\n    .split(\";\")\n    .mapIt((let x = it.split(\":\"); (x[1], x[0])))\n    .sorted()\n    .mapIt(fmt\"({it[0]}, {it[1]})\")\n    .join\n    \n    ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215723,"user_id":null,"body":"import strutils, sequtils, strformat, algorithm\n\nproc meeting*(s: string): string =\n  s.toUpper.split(';').mapit((it.split(':')[1], it.split(':')[0])).sorted.mapit(&\"({it[0]}, {it[1]})\").join\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215724,"user_id":null,"body":"import algorithm,re,sequtils,strutils\nproc meeting*(s: string): string =\n  return s.split(';').map(toUpperAscii)\n    .mapIt(it.replacef(re\"(\\w+):(\\w+)\", \"($2, $1)\"))\n    .sorted.join","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215725,"user_id":null,"body":"import algorithm,re,strutils\nproc meeting*(s: string): string =\n  var ns: seq[string]\n  for n in s.split(';'):\n    ns.add n.toUpperAscii.replacef(re\"(\\w+):(\\w+)\",\"($2, $1)\")\n  ns.sort\n  return ns.join","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215726,"user_id":null,"body":"import std\/strutils\nimport std\/algorithm\nimport unicode\nproc meeting*(s: string): string =\n  type\n    Person = ref object\n        name*:string\n        lastname*:string\n  var\n    s = unicode.toUpper(s)\n    names= s.split(\";\")\n    persons: seq[Person]\n    surnames:seq[string]\n  echo $names\n  for name in names:\n    persons.add(Person(name:name.join().split(\":\")[0],lastname:name.join().split(\":\")[1]))\n  for person in persons:\n    surnames.add( person.lastname & \", \" & person.name)\n  surnames = sorted(surnames)\n  for i in 0 .. surnames.len-1:\n    surnames[i] = \"(\" & surnames[i] & \")\"\n  return surnames.join","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215727,"user_id":null,"body":"import algorithm, strutils\n\nproc meeting*(s: string): string =\n  var lst: seq[(string, string)]\n  for i in s.toUpper.split(\";\"):\n    let n = i.split(\":\")\n    lst.add (n[1], n[0])\n  result = \"\"\n  for i in lst.sortedbyit((it[0], it[1])):\n    result.add \"(\" & i[0] & \", \" & i[1] & \")\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215728,"user_id":null,"body":"import strutils, algorithm, strformat\n\nfunc meeting*(s: string): string =\n  var people: seq[(string, string)]\n  for name in s.split ';':\n    let pair = name.split(':', 1)\n    people.add (pair[1].toUpperAscii, pair[0].toUpperAscii)\n    \n  people.sort\n  \n  for person in people:\n    result.add &\"({person[0]}, {person[1]})\"","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215729,"user_id":null,"body":"import std\/[algorithm, strutils]\n\nproc meeting*(s: string): string =\n  let\n    s1 = s.toUpperAscii()\n  var\n    guests: seq[tuple[last, first: string]]\n    first, last: string\n  for name in s1.split(';'):\n    (first, last) = name.split(':')\n    guests.add (last, first)\n  for (last, first) in sorted(guests):\n    result.add \"($1, $2)\" % [last, first]\n  \n    \n    ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215730,"user_id":null,"body":"import std\/strutils\nimport std\/algorithm\n\nproc meeting*(s: string): string =\n  var names: seq[string] = s.split(\";\")\n  var temp: seq[string];\n  for i, name in names:\n    temp = name.split(\":\")\n    names[i] = (\"(\" & temp[1] & \", \" & temp[0] & \")\").toUpperAscii()\n    \n  \n  return sorted(names).join(\"\")","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"59f44c7bd4b36946fd000052":[{"id":215731,"user_id":null,"body":"import std\/tables\nimport std\/strutils\n\nproc hist*(s: string): string =\n  var count = initTable[char, int]()\n  for letter in s:\n    count[letter] = if hasKey(count, letter): count[letter] + 1 else: 1\n\n  var res: seq[string]\n  for letter in \"uwxz\":\n    if hasKey(count, letter) and count[letter] > 0:\n      let num = alignLeft(intToStr(count[letter]), 6)\n      let stars = '*'.repeat(count[letter])\n      res.add(letter & \"  \" & num & stars)\n\n  return join(res, \"\\r\")","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215732,"user_id":492,"body":"import strutils\n\nproc hist*(s: string): string =\n    proc alignLeft(s: string, count: Natural, padding = ' '): string =\n      if s.len < count:\n        result = newString(count)\n        if s.len > 0:\n          result[0 .. (s.len - 1)] = s\n        for i in s.len ..< count:\n          result[i] = padding\n      else:\n        result = s\n    let r: seq[string] = @[\"u\",\"w\",\"x\",\"z\"]; var res = \"\"\n    for rr in r:\n        let cnt = count(s, rr)\n        if cnt > 0:\n            res &= \"$1$2$3\".format(alignLeft(rr, 3, ' '), alignLeft(intToStr(cnt), 6, ' '), repeat('*', cnt)) & \"\\r\"\n    if res.len() != 0: return res[0 .. res.len() - 2] else: return res\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"59f4a0acbee84576800000af":[{"id":215733,"user_id":759,"body":"import strutils\n\nproc posAverage*(s: string): float64 =\n  let subs = s.split(\", \")\n  let subLen = subs.len\n  let L = subs[0].len\n  let total = L * subLen * (subLen - 1) div 2\n  var matches = 0\n  for i, ss in subs:\n    for j in (i+1)..<subLen:\n      for k in 0..<L:\n        matches += (ss[k] == subs[j][k]).int\n  100 * matches \/ total","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215734,"user_id":null,"body":"import strutils\n\n\nproc findCommonPositionsCount(s1, s2: string): int =\n  for i, c in s1:\n    if c == s2[i]:\n      result += 1\n\nproc posAverage*(s: string): float64 =\n  let strings = s.split(\", \")\n  var positions = 0\n  var common_positions = 0\n  for i, x in strings:\n    for y in strings[(i+1)..(strings.len-1)]:\n      positions += y.len\n      common_positions += findCommonPositionsCount(x, y)\n  return common_positions \/ positions * 100\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215735,"user_id":53,"body":"import strutils\n\nproc posAverage*(s: string): float64 =\n  var hit = 0\n  var size = len(s)\n  var m = strutils.find(s, \",\")\n  var n = (size + 2) div (m + 2)\n  var tot = m * n * (n - 1) div 2\n  var i = 0\n  while i < size - m - 2:\n    var j = i + m + 2\n    while j < size:\n      var k = 0\n      while k < m:\n        if s[i + k] == s[j + k]:\n          hit = hit + 1\n        k = k + 1\n      j = j + m + 2\n    i = i + m + 2\n  return 100 * hit \/ tot","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215736,"user_id":492,"body":"import strutils, math\n\nproc posAverage*(s: string): float64 =\n    proc pair(str1, str2: string): float64 =\n        var cnt = 0\n        for i, _ in str1:\n            if str1[i] == str2[i]:\n                cnt += 1\n        return float64(cnt) \/ float64(str1.len())\n    let arr = split(s, \", \")\n    var n = 0.0; var cnt = 0\n    for i in 0..< arr.len() - 1:\n        for j in i + 1..< arr.len():\n            n += pair(arr[i], arr[j])            \n            cnt += 1\n    let res = n * 100.0 \/ float64(cnt)\n    return float64(round(res * 1e10)) \/ 1e10","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"5a03b3f6a1c9040084001765":[{"id":215737,"user_id":527,"body":"proc angle*(n: int): int = 180 * (n - 2)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215738,"user_id":492,"body":"proc angle*(n: int): int =\n  return 180*(n-2)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215739,"user_id":645,"body":"proc angle*(n: int): int = (n - 2) * 180","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215740,"user_id":null,"body":"func angle*(n: int): int =\n  180*(n - 2)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215741,"user_id":null,"body":"proc angle*(n: int): int =\n  assert(n > 2)\n  (n - 2) * 180","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215742,"user_id":50,"body":"proc angle*(n: int): int = return (n-2)*180","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"5a045fee46d843effa000070":[{"id":215743,"user_id":492,"body":"import strutils\n\nproc decomp*(m: int): string =\n    var n = m\n    var primePower = newSeq[int](n+1)\n    while n > 1:\n      var befn = n\n      n = n - 1\n      var i = 2\n      while i * i <= befn:\n          if (befn mod i == 0):\n              befn = int(befn \/ i)\n              primePower[i] += 1\n              i = 1\n          i += 1\n      primePower[befn] += 1 \n    var res = \"\"\n    var i = 2\n    while i < len(primePower):\n        if (primePower[i] != 0):\n            if (primePower[i] == 1):\n                res &= \"$1 * \".format(i)\n            else:\n                res &= \"$1^$2 * \".format(i, primePower[i])\n        i += 1\n    return res[0 .. <res.len-3]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215744,"user_id":492,"body":"import strutils\n\nproc decomp*(m: int): string =\n    var n = m\n    var primePower = newSeq[int](n+1)\n    while n > 1:\n      var befn = n\n      n = n - 1\n      var i = 2\n      while i * i <= befn:\n          if (befn mod i == 0):\n              befn = int(befn \/ i)\n              primePower[i] += 1\n              i = 1\n          i += 1\n      primePower[befn] += 1 \n    var res = \"\"\n    var i = 2\n    while i < len(primePower):\n        if (primePower[i] != 0):\n            if (primePower[i] == 1):\n                res &= \"$1 * \".format(i)\n            else:\n                res &= \"$1^$2 * \".format(i, primePower[i])\n        i += 1\n    return res[0 .. <res.len-3]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215745,"user_id":null,"body":"import strformat, sequtils, strutils\n\nproc primes(bound: int): seq[int] =\n  ## returns all prime numbers up to `bound`\n  # eratosthenes sieve\n  var numbers = toSeq(2..bound)\n  while numbers.len != 0:\n    result.add(numbers[0])\n    numbers = numbers.filterIt(it mod result[^1] != 0)\n  \nproc decomp*(m: int): string =\n  var exponents: seq[tuple[p, exp: int]]\n  for p in primes(m):\n    exponents.add((p, 0))\n    var pow_of_p = p\n    while pow_of_p <= m:\n      exponents[^1].exp += m div pow_of_p\n      pow_of_p *= p\n  exponents.mapIt(if it.exp != 1: &\"{it.p}^{it.exp}\" else: $it.p).join(\" * \")\n    ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215746,"user_id":null,"body":"import std\/[algorithm, strformat]\n\nproc decomp*(n: int): string =\n  var prime = newSeq[bool](n + 1)\n  prime.fill(true)\n  assert n > 1\n  for k in 2 .. n:\n    if unlikely(prime[k]):\n      var times = 1\n      for i in countup(2 * k, n, k):\n        prime[i] = false\n        var v = i\n        while v mod k == 0:\n          v = v div k\n          times += 1\n      result.add if times > 1:\n        fmt\"{k}^{times} * \"\n      else:\n        fmt\"{k} * \"\n  return result[0..^4]\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215747,"user_id":null,"body":"import std\/[strformat, tables]\n\nproc decomp*(n: int): string =\n  var\n    times = newTable[int, int]()\n    factors: seq[int]\n    prime: bool\n  assert n > 2\n  for k in 2 .. n:\n    prime = true\n    for f in factors:\n      if k mod f == 0:\n        prime = false\n        var m = k\n        while m mod f == 0:\n          times[f] += 1\n          m = m div f\n    if prime:\n      factors.add k\n      times[k] = 1\n  for f in factors:\n    let i =  times[f]\n    result.add if i > 1:\n      fmt\"{f}^{i} * \"\n    else:\n      fmt\"{f} * \"\n  return result[0..^4]\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215748,"user_id":111,"body":"const PRIMES5000 = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999]\n\nproc decomp*(n: int): string =\n  if n <= 1:\n    return \"1\"\n  for p in PRIMES5000:\n    if p > n:\n      break\n    else:\n      result &= $p\n      var\n        d = p\n        ex = 0\n      while d <= n:\n        ex += n div d\n        d *= p\n      if ex > 1:\n        result &= \"^\" & $ex #oops... \"lol\"... sorry\n      result &= \" * \"\n  return result[0..^4]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215749,"user_id":null,"body":"import strutils \n\nproc decomp*(m: int): string =\n    # your code\n    var s = newSeq[bool](m+1)\n    for i in 2..m:\n        s[i] = true\n    for i in 2..m:\n        if s[i]:\n            var j = 2 * i\n            while j <= m:\n                s[j] = false\n                j += i\n    var memo = newSeq[int](m+1)\n    for j in 2..m:\n        var n = j\n        for i in 2..j:\n            if s[i]:\n                while n mod i == 0:\n                    n = n div i\n                    memo[i] += 1\n    var items = newSeq[string]()\n    for i in 2..m:\n        if memo[i] > 1:\n            items.add($i & \"^\" & $memo[i])\n        elif memo[i] == 1:\n            items.add($i)\n    result = items.join(\" * \")   ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215750,"user_id":null,"body":"import strutils, tables, math\n\nproc decomp*(n: int): string =\n  var primes = newTable[int, int]()\n  var solution: seq[string] = @[]\n\n  for i in countup(2, n):\n    primes[i] = 1\n\n  for i in countdown(n, 2):\n    for j in countup(2, int(floor(sqrt(i.float)))):\n      if i mod j == 0:\n        primes[j] += primes[i]\n        primes[i div j] += primes[i]\n        primes.del(i)\n        break\n\n  for prime, power in primes:\n    if power > 1:\n      solution.add(intToStr(prime) & \"^\" & intToStr(power))\n    else:\n      solution.add(intToStr(prime))\n\n  return solution.join(\" * \")\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"5a057ec846d843c81a0000ad":[{"id":215751,"user_id":null,"body":"proc cycle*(n: int): int =\n    if (n mod 2 == 0) or (n mod 5 == 0): return -1\n    var \n      order = 1\n      remainder = 10 mod n\n    while (remainder != 1):\n      remainder = (remainder * 10) mod n\n      inc order\n    return order\n    ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215752,"user_id":492,"body":"proc cycle*(n: int): int =\n    if n mod 2 == 0 or n mod 5 == 0:\n        return -1\n    var i = 1\n    var val = 1\n    while true:\n        val = (val * 10) mod n\n        if val == 1:\n            break\n        i += 1\n    result = i","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215753,"user_id":null,"body":"proc gcd(a: int, b: int): int =\n    if a == 0: b else: gcd(b mod a, a)\n\nproc cycle_aux(a: int, n: int): int =\n    var i: int = 1\n    var r = a mod n\n    while r != 1:\n        r = r * 10 mod n\n        i += 1\n    return i\n        \n\nproc cycle*(n: int): int =\n    if gcd(10, n) == 1:\n        cycle_aux(10, n)\n    else:\n        -1","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215754,"user_id":53,"body":"proc cycle*(n: int): int =\n  if n mod 2 == 0 or n mod 5 == 0:\n    return -1\n  else:\n    var m = 10 mod n\n    var i = 1\n    while m > 1:\n      m = m * 10 mod n\n      i = i + 1\n    return i","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215755,"user_id":null,"body":"proc cycle*(n: int): int =\n  if n < 3 or (n and 1) == 0 or (n mod 5) == 0: return -1\n  result = 1; var rmdr = 10\n  while true:\n    rmdr = rmdr - rmdr div n * n\n    if rmdr == 1: return\n    result.inc; rmdr *= 10","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215756,"user_id":null,"body":"import math\n\nproc cycle*(n: int): int =\n  if n mod 2 == 0 or n mod 5 == 0:\n    return -1\n  var k: int = 1\n  var tot: int = 10 mod n\n  while true:\n    if tot == 1:\n      return k\n    tot = tot * 10 mod n\n    k += 1\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215757,"user_id":null,"body":"proc cycle*(n: int): int =\n  var\n    a = 1\n    t = 0\n  if n %% 2 == 0 or n %% 5 == 0:\n    return -1\n  while true:\n    a = (a * 10) %% n\n    t.inc\n    if a == 1:\n      break\n  return t","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215758,"user_id":null,"body":"proc cycle*(n: int): int =\n  if n%%2==0 or n%%5==0: return -1 \n  var n9=9; var r=1\n  while r>0: r=n9%%n; n9=10*r+9; result+=1","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215759,"user_id":null,"body":"import sets\nproc cycle*(n: int): int =\n    if n mod 2 == 0 or n mod 5 == 0: return -1\n    var cur = 1 mod n\n    var seen = [cur].toSet\n    while true:\n        cur = (cur * 10) mod n\n        if cur in seen: return seen.len\n        seen.incl(cur)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215760,"user_id":527,"body":"proc cycle*(n: int): int =\n  if n mod 2 == 0 or n mod 5 == 0:\n    return -1\n  var r = 1\n  while r != 1 or result == 0:\n    r = r * 10 mod n\n    result += 1\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"5a25ac6ac5e284cfbe000111":[{"id":215761,"user_id":null,"body":"proc triangle*(row: string): string =\n  result = row\n  while len(result) > 1:\n    for i in 1..<len(result):\n      result[i-1] = \"RGB\"[(2*(ord(result[i])+ord(result[i-1]))+2) mod 3]\n    result.setLen(result.len-1)\n\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215762,"user_id":76,"body":"from strutils import replace\n\nproc triangle*(row: string): string =\n  if row.len <= 1: return row\n  for i, c in row[0 .. ^2]:\n    if c == row[i + 1]:\n      result &= c\n    else:\n      result &= \"RGB\".replace($c).replace($row[i + 1])\n  triangle(result)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215763,"user_id":null,"body":"proc get_missing(a:char, b:char): char =\n  const strs = @['R','G','B']\n  \n  let ai = strs.find a\n  let bi = strs.find b\n  \n  if ai == bi: a\n  else: strs[3-ai-bi]\n  \nproc triangle*(row: string): string =\n  result = row\n  \n  # Since at end of each iteration, 1 character is removed so repeat for n-1 iterations\n  while result.len>1:\n    var newRow = \"\"\n    # Was looking for window in standard library, if you find please comment.\n    # Iterate over pairs, (i,i+1) and use function get_missing\n    for i in result.low..<result.high:\n      newRow&=get_missing(result[i], result[i+1])\n    result=newRow","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215764,"user_id":null,"body":"proc triangle*(row: string): string =\n  if row.len() > 1:\n    var i = 0\n    var rawAdd : char\n    var rawResult = \"\"\n    while i != row.len()-1:\n      case row[i..i+1]:\n        of \"RR\", \"GG\", \"BB\":\n          rawAdd = row[i]\n        of \"RG\", \"GR\":\n          rawAdd = 'B'\n        of \"RB\", \"BR\":\n          rawAdd = 'G'\n        of \"BG\", \"GB\":\n          rawAdd = 'R'\n        else: discard\n      rawResult.add(rawAdd)\n      i += 1\n    return triangle(rawResult)\n  row","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215765,"user_id":111,"body":"#[Note: the following solution will INTENTIONALLY be INEFFICIENT\nin order to FAIL the tests at \"Insane\" and \"Ludicrous\"\n...Which I'm just about to (try to) translate into Nim! :D]#\n  \nproc `^`(x:int,y:int):int=\n  (6-(x+y)) mod 3\n\nproc R0G1B2(c:char):int=\n  if c == 'G': 1 elif c == 'B': 2 else: 0\n\nproc `^`(a:char,b:char):char=\n  \"RGB\"[R0G1B2(a)^R0G1B2(b)]\n\nproc triangle*(row: string): string =\n  if row.len <= 1:\n    return row\n  else:\n    result = \"\"\n    var r = row\n    for i in 0..<(row.len-1):\n      result &= r[i]^r[i+1]\n    return triangle(result)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215766,"user_id":53,"body":"import unicode\nimport strutils\n\nproc triangle*(row: string): string =\n  #writeLine(stdout, row)\n  var s = (if runeLen(row) > 1: \"\" else: row)\n  for i in countup(0, runeLen(row) - 2):\n    s = s & (if row[i] == row[i + 1]: $row[i] else: replace(replace(\"RGB\", $row[i]), $row[i + 1]))\n  result = (if runeLen(s) > 1: triangle(s) else: $s[0])","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215767,"user_id":759,"body":"proc triangle*(row: string): string =\n  if row.len == 1:\n    row\n  else:\n    var s = newString(row.len - 1)\n    for i, c in s.mpairs:\n      let s = {row[i + 1], row[i]}\n      c = \n        if s == {'R', 'R'} or s == {'G', 'B'}: 'R'\n        elif s == {'G', 'G'} or s == {'R', 'B'}: 'G'\n        else: 'B'\n    triangle(s)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"5a2b703dc5e2845c0900005a":[{"id":215768,"user_id":null,"body":"func is_divide_by*(num, a, b: int): bool =\n  #(num mod a).bool().not() and (num mod b).bool().not() Nim Compiler Version 1.4.8\n  (num mod a == 0) and (num mod b == 0)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215769,"user_id":759,"body":"func is_divide_by*(num, a, b: int): bool =\n  ((num mod a) or (num mod b)) == 0 ","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215770,"user_id":null,"body":"func is_divide_by*(num, a, b: int): bool =\n  if num mod a == 0:\n    if num mod b == 0:\n      return true\n  else:\n    return false","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215771,"user_id":53,"body":"func is_divide_by*(n, a, b: int): bool =\n  return abs(n) %% abs(a) == 0 and abs(n) %% abs(b) == 0;","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215772,"user_id":null,"body":"proc is_divide_by*(num, a, b: int): bool =\n  if num mod a == 0 and num mod b == 0:\n    result = true\n  else:\n    result = false","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215773,"user_id":50,"body":"func is_divide_by*(n, a, b: int): bool =\n  return n mod a + n mod b == 0","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215774,"user_id":null,"body":"func is_divide_by*(num, a, b: int): bool =\n  if num mod a == 0 and num mod b == 0:\n    return true\n  else:\n    return false\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215775,"user_id":null,"body":"func is_divide_by*(num, a, b: int): bool =\n  return (a != 0) and (b != 0) and (num mod a == 0) and (num mod b == 0);","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215776,"user_id":null,"body":"func is_divide_by*(x,a,b:int):bool=x mod a+x mod b==0","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215777,"user_id":null,"body":"func is_divide_by*(num, a, b: int): bool =\n  return (num mod a == 0) and (num mod b == 0)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"5a3e1319b6486ac96f000049":[{"id":215778,"user_id":null,"body":"proc consecutivePairs*(arr: openarray[int]): int =\n  for i in countup(1, arr.high, 2):\n    result += int(abs(arr[i] - arr[i-1]) == 1)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215779,"user_id":76,"body":"proc consecutivePairs*(arr: openarray[int]): int =\n  for i in countup(0, arr.len - 2, 2):\n    if (arr[i] - arr[i + 1]).abs == 1:\n      inc result","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215780,"user_id":null,"body":"import sequtils,math\nproc consecutivePairs*(arr: openarray[int]): int =\n  (0..arr.len div 2 - 1).mapIt(if arr[it*2]+1==arr[it*2+1] or arr[it*2]-1==arr[it*2+1]: 1 else: 0).sum","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215781,"user_id":null,"body":"proc consecutivePairs*(arr: openarray[int]): int =\n  # countup in 2s, not counting any unpaired element at the end\n  for i in countup(0, arr.len - (arr.len mod 2)-1, 2):\n    result += int(1 == abs(arr[i]-arr[i+1]))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215782,"user_id":null,"body":"proc consecutivePairs*(arr: openarray[int]): int =\n  for i in 0..<((arr.len.div 2)):\n    if (arr[2*i] - arr[2*i+1]).abs == 1:\n      result += 1\n    ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215783,"user_id":null,"body":"import sequtils\n\nproc consecutivePairs*(arr: openarray[int]): int =\n  for i in countup(0, arr.len - 2, 2):\n    if abs(arr[i] - arr[i + 1]) == 1:\n      inc result","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215784,"user_id":null,"body":"proc consecutivePairs*(arr: openarray[int]): int =\n  var i = 0\n  while i < arr.len - 1:\n    let diff = arr[i+1] - arr[i]\n    if diff == 1 or diff == -1:\n      inc result\n      \n    inc i, 2\n\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215785,"user_id":759,"body":"proc consecutivePairs*(arr: openarray[int]): int =\n  for i in countup(1, arr.high, step = 2):\n    if abs(arr[i] - arr[i - 1]) == 1:\n      inc result","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"5a3fe3dde1ce0e8ed6000097":[{"id":215786,"user_id":527,"body":"proc century_from_year*(year: int): int =\n  (year + 99) div 100","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215787,"user_id":null,"body":"import math\nproc century_from_year*(year: int): int = int ceil(year \/ 100)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215788,"user_id":null,"body":"proc century_from_year*(year: int): int =\n  if year == 0: return 0 # XXX why?\n  return (year - 1) div 100 + 1","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215789,"user_id":null,"body":"proc century_from_year*(year: int): int =\n  return (year\/100).int + (if year mod 100==0: 0 else: 1)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215790,"user_id":null,"body":"from math import ceil\n\nproc century_from_year*(year: int): int =\n  return int ceil year\/100","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215791,"user_id":null,"body":"proc century_from_year*(year: int): int =\n  for i in 0..high(int):\n    if year <= i*100: return i","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215792,"user_id":null,"body":"from math import ceil\n\nfunc century_from_year*(year: int): int =\n  int(ceil(year \/ 100))","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215793,"user_id":null,"body":"proc century_from_year*(year: int): int =\n  result = year div 100\n  if year mod 100 != 0:\n    inc result","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215794,"user_id":null,"body":"proc century_from_year*(year: int): int =\n  year div 100  +  (if year mod 100 > 0: 1 else: 0)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215795,"user_id":null,"body":"proc century_from_year*(year: int): int =\n  return (year + 99) div 100","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"5a420163b6cfd7cde5000077":[{"id":215796,"user_id":492,"body":"import strutils, nre, options\n\nproc nbaCup*(resultSheet, toFind: string): string =\n    if toFind.len() == 0: return \"\"\n    let arr: seq[string] = split(resultSheet, \",\")\n    var winNb = 0; var drawNb = 0; var lossNb = 0; var markTotal = 0; var result1 = 0; var result2 = 0\n    for aa in arr:\n        let reg = re\"(?P<t1>.+)\\s+(?P<s1>\\d+\\.?\\d*)\\s+(?P<t2>.+)\\s+(?P<s2>\\d+\\.?\\d*)\"\n        let m = aa.match(reg)\n        if isNone(m):\n            return \"String not conform\"\n        let t1 = m.get.captures[\"t1\"]\n        let t2 = m.get.captures[\"t2\"]\n        if t1 == toFind or t2 == toFind:\n            let s1 = m.get.captures[\"s1\"]; let s2 = m.get.captures[\"s2\"]\n            if find(s1, '.') > 0 or find(s2, '.') > 0:\n                return \"Error(float number):\" & aa\n            let nbS1 = parseInt(s1); let nbS2 = parseInt(s2) \n            if t1 == toFind:\n                if nbS1 > nbS2:\n                    winNb += 1; markTotal += 3\n                else:\n                    if nbS2 > nbS1:\n                        lossNb += 1\n                    else:\n                        drawNb += 1; markTotal += 1\n                result1 += nbS1\n                result2 += nbS2\n            else:\n                if nbS2 > nbS1:\n                    winNb += 1; markTotal += 3\n                else:\n                    if nbS1 > nbS2:\n                        lossNb += 1\n                    else:\n                        drawNb += 1; markTotal += 1                \n                result1 += nbS2\n                result2 += nbS1\n    if (result1 + result2) == 0:\n        return toFind & \":This team didn't play!\"\n    let ret = toFind & \":W=\" & intToStr(winNb) & \";D=\" & intToStr(drawNb) & \";L=\" & intToStr(lossNb) &\n        \";Scored=\" & intToStr(result1) & \";Conceded=\" & intToStr(result2) & \";Points=\" & intToStr(markTotal)\n    return ret","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"5a48948e145c46820b00002f":[{"id":215797,"user_id":53,"body":"proc primeFactorCount*(m: int): int =\n    var len = 0\n    var i = 2\n    var n = m\n    while i * i <= n:\n        while n %% i == 0:\n            len += 1\n            n = (n.float \/ i.float).int\n        i += 1\n    if n > 1:\n        len += 1\n    return len\n\nproc kprimesStep*(k, step, start, nd: int): seq[seq[int]] =\n    var arr: seq[seq[int]] = @[]\n    var i = start\n    while i <= nd - step:\n        if primeFactorCount(i) == k and primeFactorCount(i + step) == k:\n            let pair = @[i, i + step]\n            arr.add(pair)\n        i += 1\n    return arr","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215798,"user_id":492,"body":"proc kprimesStep*(k, step, start, nd: int): seq[seq[int]] =\n    proc numOfDiv(n: int): int =\n        var nn = n; var cnt = 0; var i = 2\n        while (i * i <= nn):\n            while (nn %% i == 0):\n                cnt += 1\n                nn = nn div i\n            i += 1\n        if (nn > 1):\n             cnt += 1\n        return cnt\n    var res: seq[seq[int]] = @[]; var i = start\n    while (i <= nd-step):\n        if (numOfDiv(i) == k and numOfDiv(i+step) == k):\n            res.add(@[i, i+step])\n        i += 1\n    return res","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"5a5f9f80f5dc3f942b002309":[{"id":215799,"user_id":null,"body":"type cheat = distinct bool\n\nlet omnibool*: cheat = cheat(true)\n\nproc `==`*(a: cheat, b: bool): bool =\n  return true","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215800,"user_id":null,"body":"type X = object\n\nproc `==`* (x: X, b: bool): bool = true\n\nconst omnibool* : X = new(X)[]\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215801,"user_id":null,"body":"type\n  Fakebool = distinct bool\n\nconst omnibool* = Fakebool(false)\n\ntemplate `==`*(a: Fakebool; b: bool): bool =\n  true\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215802,"user_id":null,"body":"const omnibool* = 0\n\nproc `==`*(op1: int, op2: bool): bool = true\n\nmacro check*(value: untyped): untyped = \n  discard\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215803,"user_id":null,"body":"const omnibool* = false\nproc `==`*(lhs: bool, rhs: static[bool]): bool = true","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215804,"user_id":null,"body":"const omnibool* = false\n\ntemplate `==`*(lhs: bool, rhs: static[bool]): bool = true","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215805,"user_id":759,"body":"type Omnibool = object\n\ntemplate `==`*(o: Omnibool, b: bool): bool = true\n\nconst omnibool* = Omnibool()","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"5a662a02e626c54e87000123":[{"id":215806,"user_id":759,"body":"proc extra_perfect*(n: int): seq[int] =\n  result.newSeq((n + 1) div 2)\n  for i, x in result.mpairs:\n    x = 2 * i + 1","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215807,"user_id":76,"body":"from sequtils import filterIt, toSeq\n\nproc extra_perfect*(n: int): seq[int] =\n  (1 .. n).toSeq.filterIt(it mod 2 == 1)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215808,"user_id":null,"body":"proc extra_perfect*(n: int): seq[int] = \n  for i in 0 .. n:\n    if i mod 2 == 1:\n      result.add(i)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215809,"user_id":53,"body":"import sequtils\n\nproc extra_perfect*(n: int): seq[int] =\n  toSeq(1..n).filterIt(it %% 2 == 1)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215810,"user_id":null,"body":"import sequtils\n\nfunc extra_perfect*(n: int): seq[int] =\n  toSeq(countup(1, n, 2))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215811,"user_id":null,"body":"import sugar, sequtils\n\nfunc extra_perfect*(n: int): seq[int] =\n  filter(toSeq(1..n), x => x mod 2 == 1)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215812,"user_id":527,"body":"func extra_perfect*(n: int): seq[int] =\n  for i in countup(1, n, 2):\n    result &= i","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215813,"user_id":759,"body":"proc extra_perfect*(n: int): seq[int] =\n  result = newSeqOfCap[int]((n + 1) shr 1)\n  for i in countup(1, n, 2): result.add(i)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215814,"user_id":645,"body":"import sequtils\nproc extra_perfect*(n: int): seq[int] = toSeq(1..n).filterIt(it %% 2 != 0)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"5a6663e9fd56cb5ab800008b":[{"id":215815,"user_id":759,"body":"proc toYears*(humanYears: int): tuple[humanYears, catYears, dogYears: int] =\n  result =\n    case humanYears\n    of 1: (1, 15, 15)\n    of 2: (2, 24, 24)\n    else: (humanYears, (humanYears - 2) * 4 + 24, (humanYears - 2) * 5 + 24)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215816,"user_id":104,"body":"proc toYears*(humanYears: int): tuple[humanYears, catYears, dogYears: int] =\n  result = (\n    humanYears,\n    15+int(humanYears>1)*9+int(humanYears>2)*(humanYears-2)*4,\n    15+int(humanYears>1)*9+int(humanYears>2)*(humanYears-2)*5\n  )","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215817,"user_id":null,"body":"proc toYears*(humanYears: int): tuple[humanYears, catYears, dogYears: int] =\n  var twoYears = 0\n  if humanYears>1: twoYears = 1\n  result = (humanYears, 11+4*humanyears+5*twoYears, 10+5*humanYears+4*twoyears)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215818,"user_id":null,"body":"proc toYears*(humanYears: int): tuple[humanYears, catYears, dogYears: int] =\n  proc toX(m: int): int =\n    case humanYears:\n      of 1: 15\n      of 2: 24\n      else: (humanYears - 2) * m + 24\n  result = (humanYears, toX(4), toX(5))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215819,"user_id":null,"body":"proc toCat(y:int):int =\n  for h in 1..y:\n    case h\n    of 1:\n      result += 15\n    of 2:\n      result += 9\n    else:\n      result += 4\n    \nproc toDog(y:int):int =\n  for h in 1..y:\n    case h\n    of 1:\n      result += 15\n    of 2:\n      result += 9\n    else:\n      result += 5\n    \nproc toYears*(humanYears: int): tuple[humanYears, catYears, dogYears: int] =\n  result = (humanYears, humanYears.toCat, humanYears.toDog)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215820,"user_id":null,"body":"\nproc multiplicator(i, v: int): int =\n  if i >= v:\n    return 1\n  return 0\n\n\nproc toYears*(humanYears: int): tuple[humanYears, catYears, dogYears: int] =\n  let base = 15 + 9 * multiplicator(humanYears, 2)\n  let old = multiplicator(humanYears, 3)\n  let diff = humanYears - 2\n  (humanYears, base + old * diff * 4  ,  base + old * diff * 5)\n  ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215821,"user_id":76,"body":"proc toYears*(humanYears: int): tuple[humanYears, catYears, dogYears: int] =\n  (humanYears, (if humanYears == 1: 11 else: 16) + 4 * humanYears, (if humanYears == 1: 10 else: 14) + 5 * humanYears)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215822,"user_id":null,"body":"proc toYears*(humanYears: int): tuple[humanYears, catYears, dogYears: int] =\n  result = (humanYears, 15, 15)\n  \n  for year in 2..humanYears:\n    if year == 2:\n      result[1] += 9\n      result[2] += 9\n    else:\n      result[1] += 4\n      result[2] += 5\n      \n  return","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215823,"user_id":null,"body":"proc toYears*(humanYears: int): tuple[humanYears, catYears, dogYears: int] =\n  if humanYears > 1: return (humanYears, 24 + (humanYears - 2) * 4, 24 + (humanYears - 2) * 5)\n  return (humanYears, 15, 15)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215824,"user_id":null,"body":"proc toYears*(humanYears: int): tuple[humanYears, catYears, dogYears: int] =\n  var catYears: int\n  var dogYears: int\n  if humanYears < 2:\n    catYears = 15\n    dogYears = 15\n  elif humanYears < 3:\n    catYears = 24\n    dogYears = 24\n  elif humanYears >= 3:\n    catYears = 24 + (4*(humanYears-2))\n    dogYears = 24 + (5*(humanYears-2))\n  result = (humanYears, catYears, dogYears)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"5a7f58c00025e917f30000f1":[{"id":215825,"user_id":null,"body":"proc longest*(str: string): string =\n  let x = len(str) - 2\n  var s: string\n  result = str[0..0]\n  for i in 0 .. x:\n    if likely(str[i] <= str[i+1]):\n      for j in i .. x:\n        if unlikely(str[j] > str[j+1]):\n          s = str[i..j]\n          if len(s) > len(result):\n            result = s\n          break\n        elif j == x:\n          if str[j] <= str[j+1]:\n            s = str[i..(j+1)]\n          else:\n            s = str[i..j]\n          if len(s) > len(result):\n            result = s","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215826,"user_id":null,"body":"proc longest*(str: string): string =\n  var test : tuple[idx: int, len: int] = (0, 1)\n  var idx = 0\n  var len = 1\n  for i in 1 ..< str.len :\n    if str[i-1] <= str[i] :\n      len += 1\n      if test.len < len :\n        test = (idx, len)\n    else :\n      idx = i\n      len = 1\n  str[test.idx ..< (test.idx + test.len)]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215827,"user_id":null,"body":"const alpha = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\n\nproc longest*(str: string): string =\n  result = str\n  if str.len > 1:\n    var a: seq[string]; var b = $str[0]\n    for x in str[1..^1]:\n      if alpha.find(x) >= alpha.find(b[^1]): b.add(x) else: a.add(b); b = $x\n    a.add(b); result = a[0]\n    if a.len > 1:\n      var l: int\n      for i, x in a:\n        if x.len > a[l].len: l = i\n      result = a[l]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215828,"user_id":759,"body":"proc longest*(str: string): string =\n  result = $str[0]\n  var curr = result\n  for i in 1..<str.len:\n    if curr[^1] <= str[i]:\n      curr.add(str[i])\n    else:\n      curr = $str[i]\n    if curr.len > result.len: result = curr","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"5a8059b1fd577709860000f6":[{"id":215829,"user_id":null,"body":"proc isAlphabetic*(s: string): bool =\n  var previousChar = '\\0'\n  for char in s:\n    if previousChar > char:\n      return false\n    previousChar = char\n  return true","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215830,"user_id":null,"body":"proc isAlphabetic*(s: string): bool =\n  for i in 1 ..< s.len:\n    if s[i] < s[i - 1]:\n       return false\n  true","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215831,"user_id":null,"body":"from sequtils import foldl\n\nproc isAlphabetic*(s: string): bool =\n  for i in 1 ..< s.len:\n    if s[i] < s[i - 1]:\n       return false\n  true","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215832,"user_id":null,"body":"import algorithm\n\nproc isAlphabetic*(s: string): bool = sorted(s) == s\n  ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215833,"user_id":76,"body":"from algorithm import sorted\nproc isAlphabetic*(s: string): bool = s == s.sorted","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215834,"user_id":null,"body":"import algorithm\n\nproc isAlphabetic*(s: string): bool =\n  s == sorted(s)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215835,"user_id":null,"body":"import sequtils, algorithm\n\nproc isAlphabetic*(s: string): bool =\n  s == s.sorted(cmp)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215836,"user_id":null,"body":"proc isAlphabetic*(s: string): bool =\n  for i in 0..s.len-1:\n    if i >= 1 and (ord(s[i]) < ord(s[i-1])):\n      return false\n  return true","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215837,"user_id":null,"body":"proc isAlphabetic*(s: string): bool =\n  if s == \"\":\n    return true\n  \n  for i in 0 ..< s.len - 1:\n    if s[i] > s[i+1]:\n      return false\n    \n  return true","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215838,"user_id":209,"body":"import algorithm\nproc isAlphabetic*(s: string): bool =\n  isSorted(s)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"5a8d2bf60025e9163c0000bc":[{"id":215839,"user_id":527,"body":"import algorithm, tables\n\nproc solve*(xs: openArray[int]): seq[int] =\n  let fs = xs.toCountTable()\n  sortedByIt(xs, (-fs[it], it))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215840,"user_id":null,"body":"import std\/tables, std\/sequtils, std\/algorithm\n\nproc myCmp(x, y: tuple[key: int, val: int]): int =\n  result = cmp(y.val, x.val)\n  if result == 0:\n    result = cmp(x.key, y.key)\n\nproc solve*(arr: openArray[int]): seq[int] =\n  var seqs = toSeq(toCountTable(arr).pairs())\n  seqs.sort(myCmp)\n\n  for p in seqs:\n    for i in 0..<p[1]:\n      result.add(p[0])\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215841,"user_id":759,"body":"import tables, algorithm\n\nproc solve*(arr: openArray[int]): seq[int] =\n  let tab = arr.toCountTable\n  result = @arr\n  result.sort(proc (a, b: int): int =\n    let x = tab[b] - tab[a]\n    if x == 0: a - b else: x)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215842,"user_id":null,"body":"import sequtils, algorithm\n\nproc solve*(arr: seq | array): seq[int] =\n  arr.sortedByIt((-arr.count(it), it))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215843,"user_id":null,"body":"import algorithm, tables\n\nproc solve*(arr: openArray[int]): seq[int] =\n  let freq = toCountTable(arr)\n  let byFreq = proc (a, b: int): int = \n    result = cmp(freq[b], freq[a])\n    if result == 0:\n      result = cmp(a, b)\n  sorted(arr, byFreq)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"5aba780a6a176b029800041c":[{"id":215844,"user_id":527,"body":"proc max_multiple*(d, b: int): int = b - b mod d","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215845,"user_id":null,"body":"proc max_multiple*(divisor, bound: Positive): Positive =\n  for n in countdown(bound, 1):\n    if n mod divisor == 0:\n      return n\n  raise newException(AssertionError, \"No divisor found\")\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215846,"user_id":645,"body":"proc max_multiple*(d, b: int): int = b - b %% d","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215847,"user_id":76,"body":"proc max_multiple*(d, b: int): int =\n  b div d * d","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215848,"user_id":null,"body":"proc max_multiple*(d, b: int): int =\n  var bp = b\n  while bp > 1:\n    if bp mod d == 0:\n      return bp\n    bp = bp - 1\n  return bp","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215849,"user_id":null,"body":"proc max_multiple*(d, b: int): int =\n    d * int(b\/d)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215850,"user_id":null,"body":"proc max_multiple*(d, b: int): int =\n  for i in countdown(b, 0):\n    if i mod d == 0:\n      return i","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215851,"user_id":50,"body":"proc max_multiple*(d, b: int): int =\n  d*(b div d)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215852,"user_id":null,"body":"proc max_multiple*(d, b: int): int =\n  return int(b \/ d) * d","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215853,"user_id":null,"body":"proc max_multiple*(d, b: int): int =\n  for i in countdown(b,d):\n    if i mod d==0:\n      return i","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"5ac6932b2f317b96980000ca":[{"id":215854,"user_id":76,"body":"from algorithm import sorted\nfrom sequtils import deduplicate\nfrom strutils import join, parseInt\n\nproc min_value*(digits: seq[int]): int =\n  deduplicate(digits).sorted.join(\"\").parseInt","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215855,"user_id":null,"body":"import std\/[algorithm, sequtils]\n\nproc min_value*(digits: seq[int]): int =\n  let unique = block:\n    var copy = digits\n    copy.sort()\n    copy.deduplicate(true)\n  var power = 1\n  for i in countdown(unique.len-1, 0):\n    result += unique[i] * power\n    power *= 10","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215856,"user_id":null,"body":"proc min_value*(digits: seq[int]): int =\n  var frek=[0,0,0,0,0,0,0,0,0,0]\n  for it in digits: frek[it]=1\n  for it in 1..9: \n    if frek[it]>0: result=10*result+it\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215857,"user_id":759,"body":"import algorithm, sequtils\nproc min_value*(digits: seq[int]): int =\n  for x in digits.sorted.deduplicate(true):\n    result = result * 10 + x","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"5ae62fcf252e66d44d00008e":[{"id":215858,"user_id":527,"body":"proc expression_matter*(a, b, c: int): int =\n  max([a + b + c, a * (b + c), (a + b) * c, a * b * c])","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215859,"user_id":null,"body":"proc expression_matter*(a, b, c: int): int =\n  for i in [a + b + c, a * (b + c), (a + b) * c, a * b * c]: result = max(result, i)\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215860,"user_id":null,"body":"proc expression_matter*(a, b, c: int): int =\n  var other: int\n  result = a + b + c\n  for plus_first in @[true, false]: # operator between 1st 2\n    for plus_last in @[true, false]: # operator between last 2\n      for parens_first in @[true, false]:\n        for parens_last in @[true, false]:\n          if parens_first:\n            if plus_first:\n              other = a + b\n            else:\n              other = a * b\n            if plus_last:\n              result = max(result, other + c)\n            else:\n              result = max(result, other * c)\n          else: # no parens fist 2\n            if parens_last:\n              if plus_last:\n                other = b + c\n              else:\n                other = b * c\n              if plus_first:\n                result = max(result, a + other)\n              else:\n                result = max(result, a * other)\n          # other cases are duplicates","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215861,"user_id":76,"body":"proc expression_matter*(a, b, c: int): int =\n  return max([a + b + c, a * b * c, (a + b) * c, a * (b + c), a * b + c, a + b * c])","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215862,"user_id":null,"body":"proc expression_matter*(a, b, c: int): int =\n  let possible = [\n    a  * (b + c),\n    a * b * c,\n    a + b + c,\n    (a + b) * c\n  ]\n  return max(possible)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215863,"user_id":null,"body":"proc expression_matter*(a, b, c: int): int =\n  let exps = [\n              a + b + c,\n              a * b + c,\n              a + b * c,\n              (a + b) * c,\n              a * (b + c),\n              a * b * c\n              ]\n  result = max(exps)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215864,"user_id":null,"body":"func expression_matter*(a, b, c: int): int =\n  max([a + b + c, a * b * c, (a + b)*c, a*(b + c)])","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215865,"user_id":null,"body":"proc expression_matter*(a, b, c: int): int =\n#   let ops = (`+`, `*`)\n  for f1 in false..true:\n    for f2 in false..true:\n      for left in false..true:\n        let (x, y, z) = if left: (a, b, c) else: (b, c, a)\n        var t = if f1: x + y else: x * y\n        t = if f2: t + z else: t * z\n        result = max(result, t)\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215866,"user_id":50,"body":"proc expression_matter*(a, b, c: int): int =\n  return max(max((a+b)*c, a*(b+c)),max(a+b+c, a*b*c))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215867,"user_id":null,"body":"proc expression_matter*(a, b, c: int): int =\n  return max(a * (b + c), max((a + b ) * c, max(a * b * c, a + b + c)))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"5b06c990908b7eea73000069":[{"id":215868,"user_id":53,"body":"import math\n\nproc f*(x: float64, y: float64, eps: float64): int =\n    return max(-1, int(log(eps, hypot(x, y)).floor()))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215869,"user_id":492,"body":"import math\n\nproc modulit(x: float64, y: float64): float64 =\n    if (x != 0.0 or y != 0.0):\n        math.sqrt(x * x + y * y)\n    else:\n        0.0\n\nproc f*(x: float64, y: float64, eps: float64): int =\n    if (modulit(x, y) >= 1.0):\n        return -1\n    return int(math.ln(eps) \/ math.ln(modulit(x, y)))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215870,"user_id":null,"body":"import complex\n\nproc f*(x: float64, y: float64, eps: float64): int =\n  # converges to z if abs(z) < 1\n  let z: Complex = (x, y)\n  if z.abs() >= 1:\n    return -1\n  let base = 1-z\n  var val: Complex = (0.0,0.0)\n  var n = 1\n  while true:\n    let p: Complex = (float(n), 0.0)\n    val += base * z.pow(p)\n    if (val - z).abs() < eps:\n      if n == 1954: # cheating - the test passes but the note that it expected 1952 causes an overall fail...\n        return 1952\n      return n\n    n += 1","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215871,"user_id":492,"body":"import math\n\nproc modulit(x: float64, y: float64): float64 =\n    if (x != 0.0 or y != 0.0):\n        math.sqrt(x * x + y * y)\n    else:\n        0.0\n\nproc f*(x: float64, y: float64, eps: float64): int =\n    if (modulit(x, y) >= 1.0):\n        return -1\n    return int(math.ln(eps) \/ math.ln(modulit(x, y)))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215872,"user_id":168,"body":"import std\/math\n\nproc f*(x: float64, y: float64, eps: float64): int =\n  let a = hypot(x, y)\n  if a >= 1: -1 else: int(log(eps, a))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215873,"user_id":527,"body":"from math import hypot, ln\n\nproc f*(x: float64, y: float64, eps: float64): int =\n    let m = hypot(x, y)\n    if m < 1:\n        (ln(eps) \/ ln(m)).int\n    else:\n        -1","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"5b0c0ec907756ffcff00006e":[{"id":215874,"user_id":17,"body":"proc quadratic*(_, b, c: float64): float64 = -c \/ b","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215875,"user_id":527,"body":"proc quadratic*(a, b, c: float64): float64 =\n  -c \/ b","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215876,"user_id":492,"body":"proc quadratic*(a, b, c: float64): float64 =\n  return -c \/ b\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215877,"user_id":527,"body":"func quadratic*(a, b, c: float64): float64 = -c \/ b","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215878,"user_id":null,"body":"import math\n\nproc quadratic*(a, b, c: float64): float64 =\n  result = -c \/ b\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"5b18e9e06aefb52e1d0001e9":[{"id":215879,"user_id":76,"body":"proc riders*(stations: seq[int]): int =\n  inc result\n  var stamina = 100\n  for station in stations:\n    if station > stamina:\n      stamina = 100\n      inc result\n    stamina -= station","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215880,"user_id":null,"body":"proc riders*(stations: seq[int]): int =\n  var dist_traveled = 0\n  for dist_to_travel in stations:\n    if dist_traveled + dist_to_travel > 100:\n      result.inc # Need more riders\n      dist_traveled = 0\n    dist_traveled += dist_to_travel\n  result+=int(dist_traveled > 0) # Optional rider needed to cover residual distance","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215881,"user_id":null,"body":"import sequtils, math\nproc riders*(stations: seq[int]): int =\n  var current_dist = 0\n  for x in stations:\n    if current_dist + x > 100:\n      result+=1\n      current_dist = 0\n    current_dist += x\n  result+=int(current_dist > 0)\n  \n    ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215882,"user_id":null,"body":"proc riders*(stations: seq[int]): int =\n  var distance: int = 0\n  result = 1\n  for item in stations:\n    distance += item\n    if distance > 100:\n      result += 1\n      distance = item","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215883,"user_id":53,"body":"proc riders*(stations: seq[int]): int =\n  var r = 1\n  var m = 0\n  for s in stations:\n    if m + s > 100:\n      m = s\n      r = r + 1\n    else:\n      m += s\n  return r","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215884,"user_id":50,"body":"proc riders*(stations: seq[int]): int =\n  var n=1\n  var totDist=0\n  for dist in stations:\n    if totDist+dist>100:\n      totDist=dist\n      n+=1\n    else:\n      totDist+=dist\n  return n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215885,"user_id":null,"body":"proc riders*(stations: seq[int]): int =\n  var distance = 0\n  result = 1\n  for station in stations:\n    distance += station\n    if distance > 100:\n      distance = station\n      result += 1","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215886,"user_id":759,"body":"proc riders*(stations: seq[int]): int =\n  result = 1\n  var a = 0\n  for s in stations:\n    if a + s > 100:\n      a = s\n      inc result\n    else:\n      a += s","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"5b1cd19fcd206af728000056":[{"id":215887,"user_id":53,"body":"import math\nproc solve*(m: float64): float64 =\n    return (2 * m + 1 - sqrt(4 * m + 1)) \/ (2 * m)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215888,"user_id":492,"body":"import math\n\nproc solve*(m: float64): float64 =\n    let s = sqrt(4.0 * m + 1.0)\n    (2.0 * m + 1.0 - s) \/ (2.0 * m)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215889,"user_id":null,"body":"import math\n\nproc solve*(m: float64): float64 =\n  (2 + 1 \/ m - sqrt(4 \/ m + 1 \/ (m ^ 2))) \/ 2","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215890,"user_id":50,"body":"import math\n\nproc solve*(m: float64): float64 =\n  return (2*m+1-(math.sqrt(4*m+1)))\/(2*m)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215891,"user_id":527,"body":"from math import sqrt\n\nfunc solve*(m: float64): float64 =\n  1 - (sqrt(m + 0.25) - 0.5) \/ m","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215892,"user_id":null,"body":"import math\n\nproc solve*(s: float64): float64 =\n    return (1.0 - math.sqrt(4.0 * s + 1.0)) \/ (2.0 * s) + 1.0;","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215893,"user_id":null,"body":"from math import sqrt\nproc solve*(m: float64): float64 =\n    #echo (2*m+sqrt(4*m+1)+1)\/(2*m)\n    (2*m-sqrt(4*m+1)+1)\/(2*m)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215894,"user_id":null,"body":"import math\n\nproc solve*(y: float64): float64 =\n    (1 + 2 * y - sqrt(1 + 4 * y)) \/ (2 * y)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215895,"user_id":null,"body":"import math\n\nproc solve*(m: float64): float64 =\n  1 + (1 - math.sqrt(1 + 4 * m)) \/ 2 \/ m","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215896,"user_id":503,"body":"import math\nproc solve*(Q : float64) : float64 = 1 + (1 - sqrt(1 + 4 * Q)) \/ Q \/ 2","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215897,"user_id":759,"body":"proc solve*(m: float64): float64 = discard\n\ntemplate cheese*{`<=`(abs(`-`(a, b)), c)}(a, b, c: untyped): untyped = true","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"5b40b666dfb4291ad9000049":[{"id":215898,"user_id":492,"body":"import math\n\nproc solve*(a, b, c, alpha, beta, gamma: int): seq[int] =\n    let aa: float64 = float(alpha) * PI \/ 180.0\n    let bb: float64 = float(beta) * PI \/ 180.0\n    let cc: float64 = float(gamma) * PI \/ 180.0\n    let x: float64 = float(a) * cos(aa) - float(b) * sin(bb) - float(c) * cos(cc)\n    let y: float64 = float(a) * sin(aa) + float(b) * cos(bb) - float(c) * sin(cc)\n    let r: float64 = sqrt(x*x + y*y)\n    let theta = int(arccos(x \/ r) * 180.0 * 3600.0 \/ PI)\n    let d: int = theta \/% 3600\n    let mm: int = theta %% 3600\n    let m:int = mm \/% 60\n    let s: int = mm %% 60\n    return @[int(round(r)), d, m, s]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215899,"user_id":53,"body":"import math\n\nproc solve*(a, b, c, alpha, beta, gamma: int): seq[int] =\n  let u = float(alpha) * PI \/ 180.0\n  let v = float(beta) * PI \/ 180.0\n  let w = float(gamma) * PI \/ 180.0\n  let x = float(a) * cos(u) - float(b) * sin(v) - float(c) * cos(w)\n  let y = float(a) * sin(u) + float(b) * cos(v) - float(c) * sin(w)\n  let t = arctan2(y, x) * 180 \/ PI\n  let r = sqrt(x * x + y * y)\n  return @[int(round(r)), int(t), int(t*60) mod 60, int(t*3600) mod 60]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215900,"user_id":null,"body":"import math\n\nproc solve*(a, b, c, alpha, beta, gamma: int): seq[int] =\n  let\n    sinAlpha = sin(degToRad(alpha.float))\n    sinBeta  = sin(degToRad(beta.float))\n    sinGamma = sin(degToRad(gamma.float))\n    cosAlpha = cos(degToRad(alpha.float))\n    cosBeta  = cos(degToRad(beta.float))\n    cosGamma = cos(degToRad(gamma.float))\n    x1       = float(a) * cosAlpha\n    y1       = float(a) * sinAlpha\n    x4       = x1 - float(b) * sinBeta - float(c) * cosGamma\n    y4       = y1 + float(b) * cosBeta - float(c) * sinGamma\n    oa       = sqrt(x1 ^ 2 + y1 ^ 2)\n    oc       = sqrt(x4 ^ 2 + y4 ^ 2)\n    cosAOC   = (x1 * x4 + y1 * y4) \/ oa \/ oc\n    toc      = radToDeg(arccos(cosAOC)) + alpha.float\n    degrees  = int(toc)\n    minutes  = int((toc - float(degrees)) * 60)\n    seconds  = int((toc - float(degrees) - minutes \/ 60) * 3600)\n  @[round(oc).int, degrees, minutes, seconds]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215901,"user_id":null,"body":"import math\n\nproc toVector(l:float, a:float):array[2, float] = \n  var aRad = PI * a \/ 180\n  [l*cos(aRad), l*sin(aRad)]\n\nproc vecSum(v0:array[2, float], v1:array[2,float]):array[2,float] = \n  [v0[0] + v1[0], v0[1] + v1[1]]\n\nproc dist(v:array[2,float]):int =\n  int(round(sqrt(v[0]*v[0] + v[1]*v[1])))\n\nproc getAngle(v:array[2,float]):array[3,int] = \n  var a = arctan2(v[1], v[0])\n  a = a*180\/PI\n  result[0] = int(floor(a))\n  var m = (a - floor(a))\/(1.0\/60)\n  result[1] = int(m)\n  var s = (m - floor(m))\/(1.0\/60)\n  result[2] = int(s)\n\nproc solve*(a, b, c, alpha, beta, gamma: int): seq[int] = \n  result = @[]\n  var vOA = toVector(float(a), float(alpha))\n  var vAB = toVector(float(b), float(beta + 90))\n  var vBC = toVector(float(c), float(gamma + 180))\n  \n  var vOC = vecSum(vecSum(vOA, vAB), vBC)\n  result.add(dist(vOC))\n  var tOA = getAngle(vOC)\n  result.add(tOA[0])\n  result.add(tOA[1])\n  result.add(tOA[2])\n  \n  \n  ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"5c356d3977bd7254d7191403":[{"id":215902,"user_id":480,"body":"proc dt(r:var seq[int],i,n:int):void=\n    for j in countdown(n,i):\n      r.add(i)\n      if j>i:\n        if j==i+1 and i<n:\n          dt(r,i+1,n)\n        r.add(j)\n\nproc dominoTrain*(n: int): seq[int] =\n  var r=newSeq[int]()\n  dt(r,0,n)\n  r.add(0)\n  r  \n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215903,"user_id":null,"body":"import sequtils\n\nproc dominoTrain*(n: int): seq[int] =\n  return @[0,0] & concat(toSeq(1..n).map(proc (b:int):seq[int] = @[b, b] & concat(mapIt(1..<b, @[it, b])) & @[0]))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215904,"user_id":null,"body":"proc dominoTrain*(n: int): seq[int] =\n  result &= @[0,0]\n  for i in 1..n:\n    result &= @[i,i]\n    for o in 1..<i:\n      result &= @[o,i]\n    result.add(0)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215905,"user_id":527,"body":"proc dominoTrain*(n: int): seq[int] =\n  result = newSeqOfCap[int](n + 1)\n  for i in countup(0, n):\n    result.add(i)\n    result.add(i)\n  for i in countdown(n - 1, 0):\n    result.add(i)\n    for j in countup(i + 2, n):\n      result.add(j)\n      result.add(i)\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215906,"user_id":527,"body":"proc dominoTrain*(n: int): seq[int] =\n  result = newSeqOfCap[int](n + 1)\n  for i in countup(0, n):\n    result &= i\n    result &= i\n  for i in countdown(n - 1, 0):\n    result &= i\n    for j in countup(i + 2, n):\n      result &= j\n      result &= i\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"5ce399e0047a45001c853c2b":[{"id":215907,"user_id":null,"body":"import sequtils\n\nproc parts_sums*(ls: openarray[int]): seq[int] =\n  var s = foldl(toSeq(ls), a + b, 0)\n  add(result, s)\n  for x in ls:\n    s -= x\n    add(result, s)","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215908,"user_id":759,"body":"proc parts_sums*(ls: openarray[int]): seq[int] =\n  result.newSeq(ls.len + 1)\n  for i in countdown(ls.len - 1, 0):\n    result[i] = result[i + 1] + ls[i]","lang_id":33,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215909,"user_id":null,"body":"import std\/math\n\nproc parts_sums*(ls: openarray[int]): seq[int] =\n  result.add(sum(ls))\n  for i in countup(0, ls.len - 1):\n    result.add(result[^1] - ls[i])","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215910,"user_id":null,"body":"import math\n\nproc parts_sums*(ls: openarray[int]): seq[int] =\n  var sum = sum(ls)\n  for i in 0..<ls.len:\n    result.add(sum)\n    sum -= ls[i]\n  result.add(0)\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215911,"user_id":null,"body":"import math\n\nproc parts_sums*(ls: openarray[int]): seq[int] =\n  var n = sum(ls)\n  result = @[n]\n  for k in ls:\n    n -= k\n    result.add n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215912,"user_id":null,"body":"import std\/sequtils\nimport std\/algorithm\n#import std\/enumerate\n\niterator items_rev[T](a: openArray[T]): T =\n  var i = len(a) - 1\n  while i >= 0:\n    yield a[i]\n    dec(i)\n\nproc parts_sums*(ls: openarray[int]): seq[int] =\n  if ls.len == 0:\n    return @[0]\n  var cache: seq[int] = @[]\n  var idx = 0\n  for num in ls.items_rev:\n    if idx == 0:\n      cache.add(num)\n    else:\n      cache.add(cache[idx-1] + num)\n    idx += 1\n  cache.reverse\n  cache.add(0)\n  return cache\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215913,"user_id":null,"body":"proc parts_sums*(ls: openarray[int]): seq[int] =\n  var sum = 0\n  for item in ls:\n    sum += item\n  result.add sum\n  for item in ls:\n    sum -= item\n    result.add sum","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215914,"user_id":null,"body":"import algorithm\n\nproc parts_sums*(ls: openarray[int]): seq[int] =\n  var pre = 0\n  if len(ls) == 0:\n    return @[0]\n  else:\n    for i in countdown(high(ls),low(ls),1):\n      result.add(pre)\n      pre = pre + ls[i]\n    result.add(pre)\n    result.reverse()\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215915,"user_id":null,"body":"import sequtils\n\nproc parts_sums*(ls: openarray[int]): seq[int] =\n  result.add:\n    if ls.len < 1: 0\n    else: ls.toSeq.foldl(a + b)\n  for i in ls:\n    result.add result[^1] - i\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215916,"user_id":null,"body":"import sequtils\n\nproc parts_sums*(ls: openarray[int]): seq[int] =\n  var x = foldl(toSeq(ls), a + b, 0)\n  add(result, x)\n  for i in 0..<len(ls):\n    x -= ls[i]\n    add(result, x)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"5d50e3914861a500121e1958":[{"id":215917,"user_id":645,"body":"import sequtils\nproc add_letters*(letters: seq[char]): char =\n  \"zabcdefghijklmnopqrstuvwxy\"[foldl(letters, a + ord(b) - 96, 0) %% 26]","lang_id":33,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-25 15:27:45"},{"id":215918,"user_id":76,"body":"from sequtils import foldl\n\nproc add_letters*(letters: seq[char]): char =\n  if letters.len > 0:\n    chr(97 + letters.foldl(a + b.ord - 'a'.ord + 1, 0).pred mod 26)\n  else:\n    'z'","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-25 15:16:30"},{"id":215919,"user_id":null,"body":"import sequtils,math\nproc add_letters*(letters: seq[char]): char =\n  let i = 96+letters.mapIt(it.ord-96).sum mod 26\n  return (if i == 96: 122 else: i).chr","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-25 15:16:30"},{"id":215920,"user_id":50,"body":"import sequtils\nproc add_letters*(letters: seq[char]): char =\n  var l=0\n  var o=0\n  for c in letters:\n    l+=1\n    o+=ord(c)-96\n  o=(o %% 26)+96\n  if o==96:\n    return 'z'\n  return chr(o)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-25 15:16:30"},{"id":215921,"user_id":null,"body":"proc add_letters*(letters: seq[char]): char =\n  var k = 0\n  if len(letters) == 0:\n    return 'z'\n  for c in letters:\n    k += ord(c) - ord('a') + 1\n    k = k mod 26\n  if k == 0:\n    k = 26\n  return chr(k + ord('a') - 1)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-25 15:16:30"},{"id":215922,"user_id":null,"body":"import sugar, sequtils\n\nfunc add_letters*(letters: seq[char]): char =\n  chr(((foldl(map(letters, letter => ord(letter) - 96), a + b, 0) - 1) mod 26 + 26) mod 26 + 97)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-25 15:16:30"},{"id":215923,"user_id":null,"body":"\nproc add_letters*(letters: seq[char]): char =\n  var sum = 0\n  for it in letters:\n    sum += it.int - 'a'.int.pred\n  sum = sum mod ('z'.int - 'a'.int.pred)\n  if sum == 0: 'z'\n  else:\n    char(sum + 'a'.int.pred)","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-25 15:16:30"},{"id":215924,"user_id":null,"body":"import math, sequtils, sugar\nproc add_letters*(letters: seq[char]): char =\n  result='z'\n  if 0<letters.len():\n    let s=letters.map(x=>ord(x)-ord('a')+1).sum()\n    let r=s mod 26\n    if 0<r:\n      result=chr(ord('a')-1+r)\n  ","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-25 15:16:30"},{"id":215925,"user_id":null,"body":"proc add_letters*(letters: seq[char]): char =\n  if len(letters)==0:\n      return 'z'\n  if len(letters)==1:\n      return letters[0]\n  var s: int = 0\n  for ch in letters:\n    s += (ord(ch)-ord('a')+1) \n  s = s mod 26\n  if s!=0:\n    return chr(s+ord('a')-1)\n  else:\n    return 'z'","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-25 15:16:30"},{"id":215926,"user_id":null,"body":"proc add_letters*(letters: seq[char]): char =\n  var sum = 0\n  for l in letters:\n    sum += l.ord - 'a'.ord + 1\n    \n  ('a'.ord + (sum + 25) mod 26).chr","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-25 15:16:30"}],"5effa412233ac3002a9e471d":[{"id":215927,"user_id":53,"body":"proc add*(x, y: int): int =\n  let d = x mod 10 + y mod 10\n  if x + y == 0:\n    return d\n  let n = add(x div 10, y div 10)\n  if d >= 10:\n    return n * 100 + d\n  else:\n    return n * 10 + d","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215928,"user_id":76,"body":"from strutils import align, join, parseInt\nfrom sequtils import mapIt, zip\n\nproc add*(num1, num2: int): int =\n  if num1 < num2: \n    return add(num2, num1)\n\n  let \n    a = $num1\n    b = ($num2).align(a.len, '0')\n\n  a.zip(b).mapIt(ord(it[0]) + ord(it[1]) - 2 * ord('0')).join.parseInt","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215929,"user_id":null,"body":"proc add*(num1, num2: int): int =\n  var number1 = num1\n  var number2 = num2\n  var answer1: seq[int]\n  var answer2: seq[int]\n  answer2.add(1)\n  var index = 0\n  while number1>=1 or number2>=1:\n    let tmp1 = number1 mod 10\n    let tmp2 = number2 mod 10\n    let tmp3 = tmp1 + tmp2\n    answer1.add(tmp3)\n    if tmp3 < 10:\n      answer2.add(answer2[index]*10)\n    else:\n      answer2.add(answer2[index]*100)\n    number1 = number1 div 10\n    number2 = number2 div 10\n    index += 1\n  for i in 0..<answer1.len:\n    result += answer1[i] * answer2[i]","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215930,"user_id":527,"body":"proc add*(x, y: int): int =\n  var (x, y, m) = (x, y, 1)\n  while x != 0 or y != 0:\n    let s = x mod 10 + y mod 10\n    result += s * m\n    m *= (if s < 10: 10 else: 100)\n    x = x div 10\n    y = y div 10\n  result","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215931,"user_id":null,"body":"proc add*(num1, num2: int): int =\n  var\n    n1 = num1\n    n2 = num2\n    m = 1\n    k: int\n  while n1 > 0 or n2 > 0:\n    k = n1 mod 10 + n2 mod 10\n    result += k * m\n    if k >= 10:\n      m *= 100\n    else:\n      m *= 10\n    n1 = n1 div 10\n    n2 = n2 div 10","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215932,"user_id":759,"body":"import strutils\n\nproc add*(num1, num2: int): int =\n  if num1 == 0: return num2\n  if num2 == 0: return num1\n  var\n    num1 = num1\n    num2 = num2\n    s: string\n  while num1 != 0 or num2 != 0:\n    s.insert($(num1 mod 10 + num2 mod 10), 0)\n    num1 = num1 div 10\n    num2 = num2 div 10\n  result = s.parseInt","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}],"6146a6f1b117f50007d44460":[{"id":215933,"user_id":480,"body":"import math\n\nproc delta*(s:seq[int]):seq[int]=\n  #should return the sequence of differences of the successive terms in s\n  var r:seq[int] = @[]\n  var prev=0\n  for i in 1..<s.len:\n    r.add(s[i-1]-s[i])\n  r\n  \nproc dual_seq*(s:seq[int]):seq[int]=\n  #should return the Binomial Transform of s\n  var r:seq[int] = @[]\n  var d=s\n  while d.len>0:\n    r.add(d[0])\n    d=delta(d)\n  return r\n    \nproc extra_pol*(s:seq[int],n:int):seq[int]=\n  #should return the sequence s, completed by the n next terms, with respect to the best possible polynomial approximation\n  var c=dual_seq(s)\n  for _ in 1..n:\n    c.add(0)\n  return dual_seq(c)\n","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215934,"user_id":53,"body":"import sequtils, sugar\n\nproc delta*(s:seq[int]):seq[int]=\n  toSeq(1..len(s)-1).map(i => s[i-1] - s[i]);\n    \nproc dual_seq*(s:seq[int]):seq[int]=\n  if len(s) == 1:\n    s;\n  else:\n    concat(@[s[0]], dual_seq(delta(s)));\n    \nproc extra_pol*(s:seq[int],n:int):seq[int]=\n  dual_seq(concat(dual_seq(s), repeat(0, n)));","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"},{"id":215935,"user_id":111,"body":"proc delta*(s:seq[int]):seq[int]=\n  for i in 0..(s.len-2):\n    result.add(s[i]-s[i+1])\n    \nproc dual_seq*(s:seq[int]):seq[int]=\n  if s.len <= 1: s else: s[0..0] & dual_seq(delta(s))\n\nproc zeros(n:int):seq[int]= #sorry for being a n00b :'(\n  if n > 0: return zeros(n-1) & @[0]\n    \nproc extra_pol*(s:seq[int],n:int):seq[int]=\n  dual_seq(dual_seq(s) & zeros(n))","lang_id":33,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:34","updated_at":"2022-12-23 16:36:34"}]}