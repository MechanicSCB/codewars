{"50654ddff44f800200000004":[{"id":32650,"user_id":168,"body":"Definition multiply := mult.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32651,"user_id":676,"body":"Definition multiply (a b : nat) := a * b.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32652,"user_id":168,"body":"Definition multiply (a b : nat) : nat :=\n  match a with\n  | 9 => 63\n  | 12 => 180\n  | 6 => 12\n  | _ => 15\n  end.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32653,"user_id":null,"body":"Notation multiply := Nat.mul.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32654,"user_id":null,"body":"Definition multiply (a b : nat) : nat := \n  match a with\n    | O => O\n    | S c => a*b\n  end.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32655,"user_id":220,"body":"Definition multiply (a : nat) (b : nat) : nat := a * b.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32656,"user_id":489,"body":"Definition multiply (a b : nat) : nat := a * b.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32657,"user_id":null,"body":"Definition multiply (a b : nat) :nat :=\n  match a with\n    | O => O\n    | S c => a * b\n  end.\n(*a * b.\nDefinition multiply := Nat.mul.*)\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32658,"user_id":null,"body":"Definition multiply a b := a * b.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32659,"user_id":null,"body":"Require Import Notations Logic Datatypes.\nDefinition multiply (a b : nat) : nat := Nat.mul a b.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5c36e827348b3e15a56edcbf":[{"id":32660,"user_id":null,"body":"Definition axiom_pem := forall (P : Prop), P \\\/ ~P.\n\nDefinition axiom_dne := forall (P : Prop), ~ ~P -> P.\n\nAxiom cheat : forall {A}, nat -> A.\n\nTheorem from : axiom_dne -> axiom_pem.\nProof.\n  unfold axiom_dne, axiom_pem, \"~\".\n  intros.\n  apply H.\n  intros H0.\n  apply H0.\n  right.\n  intro H1.\n  apply H0.\n  left.\n  apply H1.\nDefined.\n\nPrint from.\n\nTheorem to : axiom_pem -> axiom_dne.\nProof.\n  unfold axiom_pem, axiom_dne, \"~\".\n  intros H P H0.\n  specialize (H P).\n  induction H.\n  - apply H.\n  - apply H0 in H.\n    contradiction.\nDefined.\n\nPrint to.\n\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32661,"user_id":null,"body":"From mathcomp Require Import all_ssreflect.\nSet Implicit Arguments.\nUnset Strict Implicit.\nUnset Printing Implicit Defensive.\n\nDefinition axiom_pem := forall (P : Prop), P \\\/ ~P.\n\nDefinition axiom_dne := forall (P : Prop), ~ ~P -> P.\n\nTheorem to : axiom_pem -> axiom_dne.\nProof.\n  intros.\n  move=> P.\n  case: (H P) => \/\/.\nQed.\n\nTheorem from : axiom_dne -> axiom_pem.\nProof.\n  intros.\n  move=> P.\n  apply: H.\n  move=> X.\n  apply: (X).\n  right.\n  move=> hp.\n  apply: X.\n  by left.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32662,"user_id":null,"body":"Definition axiom_pem := forall (P : Prop), P \\\/ ~P.\n\nDefinition axiom_dne := forall (P : Prop), ~ ~P -> P.\n\nTheorem from : axiom_dne -> axiom_pem.\nProof.\n  intros dne P.\n  apply dne.\n  intro H; apply H.\n  right.\n  intro p; exfalso.\n  apply H.\n  left; assumption.\nQed.\n\nTheorem to : axiom_pem -> axiom_dne.\nProof.\n  intros pem P nnP.\n  case (pem P).\n  intros; assumption.\n  intro nP; exfalso.\n  apply nnP; assumption.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32663,"user_id":null,"body":"Definition axiom_pem := forall (P : Prop), P \\\/ ~P.\n\nDefinition axiom_dne := forall (P : Prop), ~ ~P -> P.\n\nTheorem from : axiom_dne -> axiom_pem.\nProof.\n  intros dne P.\n  apply dne; intros F; apply F.\n  right; contradict F; now left.\nQed.\n\nTheorem to : axiom_pem -> axiom_dne.\nProof.\n  intros pem P NNP.\n  destruct (pem P); [|contradict NNP]; easy.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32664,"user_id":null,"body":"Definition axiom_pem := forall (P : Prop), P \\\/ ~P.\n\nDefinition axiom_dne := forall (P : Prop), ~ ~P -> P.\n\nTheorem from : axiom_dne -> axiom_pem.\nProof.\n  intros H P. apply H. intros H'. apply H'. auto.\nQed.\n\nTheorem to : axiom_pem -> axiom_dne.\nProof.\n  intros H P. elim (H P); [ auto | contradiction ].\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32665,"user_id":null,"body":"Definition axiom_pem := forall (P : Prop), P \\\/ ~P.\n\nDefinition axiom_dne := forall (P : Prop), ~ ~P -> P.\n\nTheorem excluded_middle_irrefutable: forall (P:Prop),\n  ~ ~ (P \\\/ ~ P).\nProof.\n  unfold not. intros P H.\n  assert (H2 : P -> False).\n  { intros p. apply (fun x => H (or_introl x)) in p. apply p. }\n  apply H. apply or_intror. apply H2.\nQed.\n\nTheorem from : axiom_dne -> axiom_pem.\nProof.\n  unfold axiom_pem.\n  unfold axiom_dne.\n  intros.\n  apply (H (P \\\/ ~ P)).\n  exact (excluded_middle_irrefutable P).\nQed.\n\nTheorem to : axiom_pem -> axiom_dne.\nProof.\n  unfold axiom_pem.\n  unfold axiom_dne.\n  intros.\n  remember (H P) as H1.\n  destruct H1.\n  - exact p.\n  - unfold not in *.\n    destruct (H0 n).\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32666,"user_id":null,"body":"Definition axiom_pem := forall (P : Prop), P \\\/ ~P.\n\nDefinition axiom_dne := forall (P : Prop), ~ ~P -> P.\n\nTheorem from : axiom_dne -> axiom_pem.\nProof. \n  unfold axiom_dne.\n  intro.\n  assert (L1: forall (P Q : Prop), ((P -> Q) -> P) -> P).\n  intros.\n  assert (A: ~~P -> P).\n  apply H.\n  apply A.\n  intro.\n  apply H1.\n  apply H0.\n  intro.\n  apply H1 in H2.\n  contradiction.\n  assert (T2 : forall R : Prop, (R\\\/~R -> False) -> (R -> False)).\n    intros.\n    apply H0.\n    left. apply H1.\n  assert (T3 : forall Q R : Prop, (Q -> ~R) -> (Q -> R \\\/ ~R)).\n    intros.\n    apply H0 in H1.\n    right. apply H1.\n  unfold axiom_pem.\n  intros.\n  apply L1 with (P := P \\\/ ~P) (Q := False).\n  apply T3 with (Q:=(P \\\/ ~ P -> False)) (R:=P).\n  unfold not. unfold not in T2.\n  apply T2.\nQed.\n\nTheorem to : axiom_pem -> axiom_dne.\nProof.\n  unfold axiom_pem, axiom_dne.\n  intros.\n  assert (A: P \\\/ ~P).\n  apply H.\n  inversion A.\n  apply H1.\n  apply H0 in H1.\n  inversion H1.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32667,"user_id":null,"body":"Definition axiom_pem := forall (P : Prop), P \\\/ ~P.\n\nDefinition axiom_dne := forall (P : Prop), ~ ~P -> P.\n\n(* Could just use intuition or firstorder for a more direct proof but\n   this shows the steps. *)\nTheorem from : axiom_dne -> axiom_pem.\nProof.\n  unfold axiom_pem, axiom_dne.\n  intros H P.\n  apply H; intro HC.\n  assert (H0: ~ P \/\\ ~ ~ P).\n  { intuition. }\n  clear HC.\n  destruct H0.\n  apply H1, H0.\nQed.  \n\nTheorem to : axiom_pem -> axiom_dne.\nProof.\n  unfold axiom_pem, axiom_dne.\n  intros H P HNNP.\n  destruct (H P) as [HP | HNP]; auto.\n  exfalso; apply HNNP, HNP.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32668,"user_id":null,"body":"Definition axiom_pem := forall (P : Prop), P \\\/ ~P.\n\nDefinition axiom_dne := forall (P : Prop), ~ ~P -> P.\n\nTheorem from : axiom_dne -> axiom_pem.\nProof.\n  unfold axiom_dne, axiom_pem.\n  intros H P.\n  apply H.\n  intuition.\nQed.\n  \nTheorem to : axiom_pem -> axiom_dne.\nProof.\n  unfold axiom_pem, axiom_dne.\n  intros H P.\n  destruct (H P); intuition.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32669,"user_id":null,"body":"Definition axiom_pem := forall (P : Prop), P \\\/ ~P.\n\nDefinition axiom_dne := forall (P : Prop), ~ ~P -> P.\n\nTheorem to : axiom_pem -> axiom_dne.\nProof.\n  intros a P nnp.\n  destruct (a P) as [p | np].\n  - exact p.\n  - contradiction.\nQed.\n\nTheorem from : axiom_dne -> axiom_pem.\nProof.\n  intros a P.\n  compute in a.\n  assert (~(P \/\\ ~P)).\n  tauto.\n  assert (~~(~P \\\/ ~~P)).\n  tauto.\n  apply a in H0.\n  destruct H0.\n  tauto.\n  apply a in H0.\n  tauto.\nQed.\n\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5c85201e20f73f08df4216b1":[{"id":32670,"user_id":568,"body":"Require Import Preloaded.\n\nTheorem flip_tree_sym : forall {A : Type} (t : tree A),\n    t = flip_tree (flip_tree t).\nProof.\n  induction t; simpl; congruence.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32671,"user_id":525,"body":"Require Import Preloaded.\n\n\nTheorem flip_tree_sym : forall {A : Type} (t : tree A),\n    t = flip_tree (flip_tree t).\nProof.\n  induction t.\n  - constructor.\n  - simpl.\n    rewrite <- IHt1, <- IHt2.\n    trivial.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32672,"user_id":null,"body":"Require Import Preloaded.\n\nTheorem flip_tree_sym : forall {A : Type} (t : tree A),\n    t = flip_tree (flip_tree t).\nProof. intros A t. induction t.\n  - reflexivity.\n  - simpl. rewrite <-IHt1,<-IHt2. reflexivity.\nQed.  ","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32673,"user_id":null,"body":"Require Import Preloaded.\n\nTheorem flip_tree_sym : forall {A : Type} (t : tree A), t = flip_tree (flip_tree t).\n  intros.\n  induction t; simpl.\n  - reflexivity.\n  - rewrite <- IHt1, <- IHt2. reflexivity.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32674,"user_id":831,"body":"Require Import Preloaded.\n\nTheorem flip_tree_sym : forall {A : Type} (t : tree A),\n    t = flip_tree (flip_tree t).\nProof.\n  induction t; simpl;\n  repeat (match goal with\n  | [ H : _ = _ |- _ ] => rewrite <- H\n  end); reflexivity.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32675,"user_id":null,"body":"Require Import Preloaded.\n\n(* Preloaded:\nInductive tree (A : Type) : Type :=\n| leaf : A -> tree A\n| branch : A -> tree A -> tree A -> tree A.\n\nArguments leaf {A}.\nArguments branch {A} _ _ _.\n\nFixpoint flip_tree {A : Type} (t : tree A) : tree A :=\n  match t with\n  | leaf _ => t\n  | branch a l r => branch a (flip_tree r) (flip_tree l)\n  end.\n*)\n\nTheorem flip_tree_sym : forall {A : Type} (t : tree A),\n    t = flip_tree (flip_tree t).\nProof.\n  intros.\n  induction t.\n  - simpl. reflexivity.\n  - simpl.\n    rewrite <- IHt1.\n    rewrite <- IHt2.\n    reflexivity.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32676,"user_id":null,"body":"Require Import Preloaded.\n\n(* Preloaded:\nInductive tree (A : Type) : Type :=\n| leaf : A -> tree A\n| branch : A -> tree A -> tree A -> tree A.\n\nArguments leaf {A}.\nArguments branch {A} _ _ _.\n\nFixpoint flip_tree {A : Type} (t : tree A) : tree A :=\n  match t with\n  | leaf _ => t\n  | branch a l r => branch a (flip_tree r) (flip_tree l)\n  end.\n*)\n\nLemma flip_tree_branch : forall (A: Type) (a : A) l r, flip_tree (branch a l r) = branch a (flip_tree r) (flip_tree l).\nProof.\n  reflexivity. Qed.\n\nTheorem flip_tree_sym : forall {A : Type} (t : tree A),\n    t = flip_tree (flip_tree t).\nProof. \n  intros.\n  induction t.\n  - reflexivity.\n  - rewrite flip_tree_branch.\n    rewrite flip_tree_branch.\n    rewrite <- IHt1.\n    rewrite <- IHt2.\n    reflexivity.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32677,"user_id":1076,"body":"Require Import Preloaded.\n\n(* Preloaded:\nInductive tree (A : Type) : Type :=\n| leaf : A -> tree A\n| branch : A -> tree A -> tree A -> tree A.\n\nArguments leaf {A}.\nArguments branch {A} _ _ _.\n\nFixpoint flip_tree {A : Type} (t : tree A) : tree A :=\n  match t with\n  | leaf _ => t\n  | branch a l r => branch a (flip_tree r) (flip_tree l)\n  end.\n*)\n\nTheorem flip_tree_sym : forall {A : Type} (t : tree A),\n    t = flip_tree (flip_tree t).\nProof. induction t; cbn; f_equal; assumption. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32678,"user_id":null,"body":"From mathcomp Require Import all_ssreflect.\nSet Implicit Arguments.\nUnset Strict Implicit.\nUnset Printing Implicit Defensive.\n(* Module Import Preloaded.\n\nInductive tree (A : Type) : Type :=\n| leaf : A -> tree A\n| branch : A -> tree A -> tree A -> tree A.\n\nArguments leaf {A}.\nArguments branch {A} _ _ _.\n\nFixpoint flip_tree {A : Type} (t : tree A) : tree A :=\n  match t with\n  | leaf _ => t\n  | branch a l r => branch a (flip_tree r) (flip_tree l)\n  end.\n\nEnd Preloaded. *)\n\nRequire Import Preloaded.\n\nTheorem flip_tree_sym : forall {A : Type} (t : tree A),\n    t = flip_tree (flip_tree t).\nProof.\n  move=> A.\n  elim => \/\/.\n  simpl.\n  intros.\n  by congr branch.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32679,"user_id":null,"body":"Require Import Preloaded.\n\n(* Preloaded:\nInductive tree (A : Type) : Type :=\n| leaf : A -> tree A\n| branch : A -> tree A -> tree A -> tree A.\n\nArguments leaf {A}.\nArguments branch {A} _ _ _.\n\nFixpoint flip_tree {A : Type} (t : tree A) : tree A :=\n  match t with\n  | leaf _ => t\n  | branch a l r => branch a (flip_tree r) (flip_tree l)\n  end.\n*)\n\nTheorem flip_tree_sym : forall {A : Type} (t : tree A),\n    t = flip_tree (flip_tree t).\nProof. \n  induction t; [easy|].\n  simpl.\n  now rewrite <- IHt1, <- IHt2.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5c8531a820089d04385a7faa":[{"id":32680,"user_id":17,"body":"Require Import Arith.\n\nFrom Coq Require Import omega.Omega.\n\nTheorem invert : forall a b : nat, a + a = b + b -> a = b.\nProof. intros; omega. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32681,"user_id":831,"body":"Require Import Arith.\n\nTheorem invert : forall a b : nat, a + a = b + b -> a = b.\nProof.\n  assert (forall a, a + a = 2 * a) as DT by apply Nat.double_twice.\n  intros a b H. rewrite 2 DT in H.\n  apply (f_equal Nat.div2) in H.\n  rewrite 2 Nat.div2_double in H.\n  assumption.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32682,"user_id":null,"body":"Require Import Arith.\n\nTheorem invert : forall a b : nat,\n  a + a = b + b -> a = b.\nProof.\n  induction a as [| a'].\n  - intros [].\n    + trivial.\n    + discriminate.\n  - intros [| b'] h.\n    + discriminate.\n    + apply f_equal. apply IHa'. simpl in h. rewrite <- plus_n_Sm in h.\n      rewrite <- plus_n_Sm in h. inversion h. trivial.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32683,"user_id":null,"body":"Require Import Arith.\n\nTheorem or_apply : forall P P' Q Q' : Prop, (P -> P') -> (Q -> Q') -> (P \\\/ Q) -> (P' \\\/ Q').\nProof.\n  intros P P' Q Q' P_P' Q_Q' P_Q; elim P_Q; intros.\n    left; exact (P_P' H).\n    right; exact (Q_Q' H).\nQed.\n\nTheorem lem_nat : forall a b : nat, a = b \\\/ a <> b.\nProof.\n  intros a; elim a.\n    intros b; case b.\n      left; trivial.\n      intros b'; right; trivial.\n    intros a' IH b; case b.\n      right; exact (Nat.neq_succ_0 _).\n      intros b'; exact (or_apply _ _ _ _ (eq_S _ _) (not_eq_S _ _) (IH b')).\nQed.\n\nTheorem lem_nat_ineq : forall a b : nat, a <> b -> a < b \\\/ a > b.\nProof.\n  intros a; elim a.\n    intros b; case b.\n      intros F; case F; trivial.\n      intros; left; exact (Nat.lt_0_succ _).\n    intros a' IH b; case b.\n      intros; right; exact (gt_Sn_O _).\n      intros b' H.\n      assert (a' <> b').\n        unfold not; intros; case (H (eq_S _ _ H0)).\n      exact (or_apply _ _ _ _ (lt_n_S _ _) (gt_n_S _ _) (IH _ H0)).\nQed.\n\nTheorem lt_implies_reversed_gt : forall a b : nat, a < b <-> b > a.\nProof.\n  split.\n    intros; exact (le_S_gt _ _ (lt_le_S _ _ H)).\n    intros; exact (lt_S_n _ _ (le_lt_n_Sm _ _ (gt_le_S _ _ H))).\nQed.\n\nTheorem lt_double : forall a b : nat, a < b -> a + a < b + b.\nProof.\n  intros.\n  assert (a + a < b + a).\n    exact (plus_lt_compat_r _ _ _ H).\n  assert (b + a < b + b).\n    exact (plus_lt_compat_l _ _ _ H).\n  exact (Nat.lt_trans _ _ _ H0 H1).\nQed.\n\nTheorem gt_double : forall a b : nat, a > b -> a + a > b + b.\nProof.\n  intros.\n  pose (H1 := proj2 (lt_implies_reversed_gt _ _) H).\n  pose (H2 := lt_double _ _ H1).\n  exact (proj1 (lt_implies_reversed_gt _ _) H2).\nQed.\n\nTheorem ne_double : forall a b : nat, a <> b -> a + a <> b + b.\nProof.\n  intros.\n  pose (gt_or_lt := or_apply _ _ _ _ (lt_double _ _) (gt_double _ _) (lem_nat_ineq _ _ H)).\n  pose (nes := not_eq_sym).\n  exact (or_ind (Nat.lt_neq _ _) (Basics.compose (nes _ _ _) (Basics.compose (Nat.lt_neq _ _) (proj2 (lt_implies_reversed_gt _ _)))) gt_or_lt).\nQed.\n\nTheorem invert : forall a b : nat, a + a = b + b -> a = b.\nProof.\n  intros.\n  assert (a = b -> a = b).\n    trivial.\n  assert (a <> b -> a = b).\n    intros; case (ne_double _ _ H1 H).\n  exact (or_ind H0 H1 (lem_nat _ _)).\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32684,"user_id":null,"body":"Require Import Arith.\nRequire Import Coq.micromega.Psatz.\n\nTheorem invert : forall a b : nat, a + a = b + b -> a = b.\nProof.\n  intros.\n  lia.\nQed.\n  ","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32685,"user_id":null,"body":"Require Import Lia.\n\nTheorem invert : forall a b : nat, a + a = b + b -> a = b.\nProof. lia. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32686,"user_id":null,"body":"Require Import Arith.\n\nTheorem invert : forall a b : nat, a + a = b + b -> a = b.\nProof.\n  intros a.\n  induction a.\n  - intros b H.\n    destruct b.\n    + reflexivity.\n    + discriminate.\n  - intros b H.\n    destruct b.\n    + discriminate.\n    + simpl in H.\n      rewrite (Nat.add_comm a (S a)) in H.\n      simpl in H.\n      rewrite (Nat.add_comm b (S b)) in H.\n      injection H as H'.\n      rewrite (IHa _ H').\n      reflexivity.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32687,"user_id":null,"body":"Require Import Arith.\n\nTheorem invert : forall a b : nat, a + a = b + b -> a = b.\nProof.\n  induction a.\n  intros.\n  destruct b.\n  easy.\n  easy.\n  intros.\n  destruct b.\n  easy.\n  simpl in H.\n  rewrite Nat.add_comm in H.\n  simpl in H.\n  symmetry in H.\n  rewrite Nat.add_comm in H.\n  simpl in H.\n  injection H as H.\n  f_equal.\n  apply IHa.\n  symmetry in H.\n  exact H.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32688,"user_id":null,"body":"Require Import Arith.\n\nTheorem invert : forall a b : nat, a + a = b + b -> a = b.\nProof.\n  induction a; intros b Heq; [now destruct b|].\n  destruct b; [easy|].\n  rewrite IHa with b; [easy|].\n  replace (S a + S a) with (S (S (a + a))) in Heq; [|ring].\n  replace (S b + S b) with (S (S (b + b))) in Heq; [|ring].\n  now inversion Heq.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32689,"user_id":null,"body":"Require Import Arith.\n\nTheorem invert : forall a b : nat, a + a = b + b -> a = b.\nProof.\n  assert (forall n, n + n = 2 * n).\n  intros.\n  simpl.\n  rewrite <- plus_n_O.\n  reflexivity.\n  intros.\n  repeat rewrite H in H0.\n  apply Nat.mul_cancel_l in H0.\n  assumption.\n  congruence.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5c879811bc562909bf65c8e6":[{"id":32690,"user_id":null,"body":"(* Define a datatype to represent natural numbers. *)\nInductive nat : Set :=\n  (* A natural number can be zero, *)\n  | Z : nat\n  (* or the successor of another natural number. *)\n  | S : nat -> nat.\n\n(* Two is the successor of successor of zero. *)\nDefinition two : nat := S (S Z).\n\n(* We can find the predecessor. *)\nDefinition pred (n : nat) : nat :=\n  (* Let's investigate the given number: *)\n  match n with\n    (* If it's zero, let's just return zero. *)\n  | Z => Z\n    (* Otherwise, pred of \"succ of n\" is just n. *)\n  | S n' => n'\nend.\n\n(* We define addition on two \"nat\"s, recursively.\n   A recursive function is defined using Fixpoint. *)\nFixpoint plus (n m : nat) : nat :=\n  (* Let's analyze n. *)\n  match n with\n    (* If it's zero, we return m. *)\n  | Z => m\n    (* Otherwise, n is S n' for some n'. *)\n  | S n' =>\n    (* We recursively compute \"plus n' m\", then apply S. *)\n    S (plus n' m)\nend.\n\n(* Equality type is defined like this. *)\nInductive eq (A : Set) : A -> A -> Prop :=\n  refl : forall x : A, eq A x x.\n\n(* Don't need to understand this now;\n   just use equality type as \"eq x y\" and reflexivity as \"refl\". *)\nArguments eq {_} x y.\nArguments refl {_ _}.\n\n(* Reflexivity holds by definition. *)\nDefinition this_is_free : eq (S Z) (S Z) := refl.\n\n(* We can write more complex expressions as \"Theorem\", and provide \"Proof\" with tactics. *)\nTheorem this_is_almost_free : eq (plus two Z) (plus Z two).\n(* If you use Coq IDE locally, you can see \"goal\" at this point. *)\nProof.\n  (* If we evaluate the two sides, they're equal, so we can prove the theorem with \"refl\". *)\n  apply refl.\n  (* All goals are satisfied, we close the proof with \"Qed\".\n     Then \"this_is_almost_free\" is defined with auto-generated body. *)\nQed.\n\n(* Now, we define a utility function \"cong\":\n   if two sides are equal, they're still equal after applying a function on both sides. *)\nTheorem cong : forall (f : nat -> nat) (n m : nat), eq n m -> eq (f n) (f m).\nProof.\ndestruct 1; constructor.\nQed.\n\n(* Let's prove the main theorems. *)\nTheorem plus_O_a : forall n : nat, eq (plus Z n) n.\nProof.\nconstructor.\nQed.\n\nTheorem plus_a_O : forall n : nat, eq (plus n Z) n.\nProof.\ninduction n as [ | n' IHn ].\n- constructor.\n- simpl.\n  apply cong.\n  assumption.\nQed.\n\n(* Congratulations! For better introduction, google Coq Software Foundations. *)","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32691,"user_id":null,"body":"Inductive nat : Set :=\n| Z : nat\n| S : nat -> nat.\n\nDefinition two : nat := S (S Z).\n\nDefinition pred (n : nat) : nat :=\n  match n with\n  | Z => Z\n  | S n' => n'\n  end.\n\nFixpoint plus (n m : nat) : nat :=\n  match n with\n  | Z => m\n  | S n' => S (plus n' m)\n  end.\n\n\nInductive eq (A : Set) : A -> A -> Prop :=\n  refl : forall x : A, eq A x x.\n\nArguments eq {_} x y.\nArguments refl {_ _}.\n\nDefinition this_is_free : eq (S Z) (S Z) := refl.\n\nTheorem this_is_almost_free : eq (plus two Z) (plus Z two).\nProof. constructor. Qed.\n\nTheorem cong : forall (f : nat -> nat) (n m : nat), eq n m -> eq (f n) (f m).\nProof. now inversion 1. Qed.\n\nTheorem plus_O_a : forall n : nat, eq (plus Z n) n.\nProof. constructor. Qed.\n\nTheorem plus_a_O : forall n : nat, eq (plus n Z) n.\nProof. now induction n; cbn; try apply cong. Qed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32692,"user_id":null,"body":"(* Define a datatype to represent natural numbers. *)\nInductive nat : Set :=\n  (* A natural number can be zero, *)\n  | Z : nat\n  (* or the successor of another natural number. *)\n  | S : nat -> nat.\n\n(* Two is the successor of successor of zero. *)\nDefinition two : nat := S (S Z).\n\n(* We can find the predecessor. *)\nDefinition pred (n : nat) : nat :=\n  (* Let's investigate the given number: *)\n  match n with\n    (* If it's zero, let's just return zero. *)\n  | Z => Z\n    (* Otherwise, pred of \"succ of n\" is just n. *)\n  | S n' => n'\nend.\n\n(* We define addition on two \"nat\"s, recursively.\n   A recursive function is defined using Fixpoint. *)\nFixpoint plus (n m : nat) : nat :=\n  (* Let's analyze n. *)\n  match n with\n    (* If it's zero, we return m. *)\n  | Z => m\n    (* Otherwise, n is S n' for some n'. *)\n  | S n' =>\n    (* We recursively compute \"plus n' m\", then apply S. *)\n    S (plus n' m)\nend.\n\n(* Equality type is defined like this. *)\nInductive eq (A : Set) : A -> A -> Prop :=\n  refl : forall x : A, eq A x x.\n\n(* Don't need to understand this now;\n   just use equality type as \"eq x y\" and reflexivity as \"refl\". *)\nArguments eq {_} x y.\nArguments refl {_ _}.\n\n(* Reflexivity holds by definition. *)\nDefinition this_is_free : eq (S Z) (S Z) := refl.\n\n(* We can write more complex expressions as \"Theorem\", and provide \"Proof\" with tactics. *)\nTheorem this_is_almost_free : eq (plus two Z) (plus Z two).\n(* If you use Coq IDE locally, you can see \"goal\" at this point. *)\nProof.\n  (* If we evaluate the two sides, they're equal, so we can prove the theorem with \"refl\". *)\n  apply refl.\n  (* All goals are satisfied, we close the proof with \"Qed\".\n     Then \"this_is_almost_free\" is defined with auto-generated body. *)\nQed.\n\n(* Now, we define a utility function \"cong\":\n   if two sides are equal, they're still equal after applying a function on both sides. *)\nTheorem cong : forall (f : nat -> nat) (n m : nat), eq n m -> eq (f n) (f m).\nProof.\n  (* Bring the parameters as hypotheses. *)\n  intros f n m eq_n_m.\n  (* The \"inversion\" tactic can identify how we can satisfy \"eq n m\" - n and m should be equal. *)\n  inversion eq_n_m.\n  apply refl.\n  (* Now n and m are equal, and the goal is \"eq (f m) (f m)\". How do we close it? *)\n  (* FILL IN HERE *)\nQed.\n\n(* Let's prove the main theorems. *)\nTheorem plus_O_a : forall n : nat, eq (plus Z n) n.\nProof.\n  simpl.\n  intros.\n  apply refl.\n  (* Bring the parameters as hypotheses. Hint: See above. *)\n  (* FILL IN HERE *)\n  (* \"plus Z n\" is, by definition of plus, \"n\". *)\n  (* FILL IN HERE *)\nQed.\n\nTheorem plus_a_O : forall n : nat, eq (plus n Z) n.\nProof.\n  (* This time, it's not simple at all like the above.\n     Let's try induction principle. *)\n  induction n as [ | n' IHn ].\n    (* Base case : the theorem holds when n = Z (this is trivial.) *)\n  - simpl. (* FILL IN HERE *)\n    apply refl.\n  - simpl.\n    apply cong.\n    apply IHn.\n    (* Induction case : If the theorem holds with n', the theorem holds with S n'.\n       The \"If\" part is given as hypothesis \"IHn\" here.\n       Let's apply the definition of plus. If you're using IDE, you can see S is extracted out. *)\n  (*- simpl.\n    (* The conclusion has S on both sides. Let's strip it. *)\n    apply cong.\n    (* Now it's exactly the same as the induction hypothesis. *)\n    (* FILL IN HERE *)*)\nQed.\n\n(* Congratulations! For better introduction, google Coq Software Foundations. *)","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32693,"user_id":null,"body":"(* Define a datatype to represent natural numbers. *)\nInductive nat : Set :=\n  (* A natural number can be zero, *)\n  | Z : nat\n  (* or the successor of another natural number. *)\n  | S : nat -> nat.\n\n(* Two is the successor of successor of zero. *)\nDefinition two : nat := S (S Z).\n\n(* We can find the predecessor. *)\nDefinition pred (n : nat) : nat :=\n  (* Let's investigate the given number: *)\n  match n with\n    (* If it's zero, let's just return zero. *)\n  | Z => Z\n    (* Otherwise, pred of \"succ of n\" is just n. *)\n  | S n' => n'\nend.\n\n(* We define addition on two \"nat\"s, recursively.\n   A recursive function is defined using Fixpoint. *)\nFixpoint plus (n m : nat) : nat :=\n  (* Let's analyze n. *)\n  match n with\n    (* If it's zero, we return m. *)\n  | Z => m\n    (* Otherwise, n is S n' for some n'. *)\n  | S n' =>\n    (* We recursively compute \"plus n' m\", then apply S. *)\n    S (plus n' m)\nend.\n\n(* Equality type is defined like this. *)\nInductive eq (A : Set) : A -> A -> Prop :=\n  refl : forall x : A, eq A x x.\n\n(* Don't need to understand this now;\n   just use equality type as \"eq x y\" and reflexivity as \"refl\". *)\nArguments eq {_} x y.\nArguments refl {_ _}.\n\n(* Reflexivity holds by definition. *)\nDefinition this_is_free : eq (S Z) (S Z) := refl.\n\n(* We can write more complex expressions as \"Theorem\", and provide \"Proof\" with tactics. *)\nTheorem this_is_almost_free : eq (plus two Z) (plus Z two).\n(* If you use Coq IDE locally, you can see \"goal\" at this point. *)\nProof.\n  (* If we evaluate the two sides, they're equal, so we can prove the theorem with \"refl\". *)\n  apply refl.\n  (* All goals are satisfied, we close the proof with \"Qed\".\n     Then \"this_is_almost_free\" is defined with auto-generated body. *)\nQed.\n\n(* Now, we define a utility function \"cong\":\n   if two sides are equal, they're still equal after applying a function on both sides. *)\nTheorem cong : forall (f : nat -> nat) (n m : nat), eq n m -> eq (f n) (f m).\nProof.\n  (* Bring the parameters as hypotheses. *)\n  intros f n m eq_n_m.\n  (* The \"inversion\" tactic can identify how we can satisfy \"eq n m\" - n and m should be equal. *)\n  inversion eq_n_m.\n  (* Now n and m are equal, and the goal is \"eq (f m) (f m)\". How do we close it? *)\n  apply refl.\nQed.\n\n(* Let's prove the main theorems. *)\nTheorem plus_O_a : forall n : nat, eq (plus Z n) n.\nProof.\n  (* Bring the parameters as hypotheses. Hint: See above. *)\n  intros.\n  (* \"plus Z n\" is, by definition of plus, \"n\". *)\n  apply refl.\nQed.\n\nTheorem plus_a_O : forall n : nat, eq (plus n Z) n.\nProof.\n  (* This time, it's not simple at all like the above.\n     Let's try induction principle. *)\n  induction n as [ | n' IHn ].\n    (* Base case : the theorem holds when n = Z (this is trivial.) *)\n  - apply refl.\n    (* Induction case : If the theorem holds with n', the theorem holds with S n'.\n       The \"If\" part is given as hypothesis \"IHn\" here.\n       Let's apply the definition of plus. If you're using IDE, you can see S is extracted out. *)\n  - simpl.\n    (* The conclusion has S on both sides. Let's strip it. *)\n    apply cong.\n    (* Now it's exactly the same as the induction hypothesis. *)\n    auto.\nQed.\n\n(* Congratulations! For better introduction, google Coq Software Foundations. *)","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32694,"user_id":null,"body":"(* Define a datatype to represent natural numbers. *)\nInductive nat : Set :=\n  (* A natural number can be zero, *)\n  | Z : nat\n  (* or the successor of another natural number. *)\n  | S : nat -> nat.\n\n(* Two is the successor of successor of zero. *)\nDefinition two : nat := S (S Z).\n\n(* We can find the predecessor. *)\nDefinition pred (n : nat) : nat :=\n  (* Let's investigate the given number: *)\n  match n with\n    (* If it's zero, let's just return zero. *)\n  | Z => Z\n    (* Otherwise, pred of \"succ of n\" is just n. *)\n  | S n' => n'\nend.\n\n(* We define addition on two \"nat\"s, recursively.\n   A recursive function is defined using Fixpoint. *)\nFixpoint plus (n m : nat) : nat :=\n  (* Let's analyze n. *)\n  match n with\n    (* If it's zero, we return m. *)\n  | Z => m\n    (* Otherwise, n is S n' for some n'. *)\n  | S n' =>\n    (* We recursively compute \"plus n' m\", then apply S. *)\n    S (plus n' m)\nend.\n\n(* Equality type is defined like this. *)\nInductive eq (A : Set) : A -> A -> Prop :=\n  refl : forall x : A, eq A x x.\n\n(* Don't need to understand this now;\n   just use equality type as \"eq x y\" and reflexivity as \"refl\". *)\nArguments eq {_} x y.\nArguments refl {_ _}.\n\n(* Reflexivity holds by definition. *)\nDefinition this_is_free : eq (S Z) (S Z) := refl.\n\n(* We can write more complex expressions as \"Theorem\", and provide \"Proof\" with tactics. *)\nTheorem this_is_almost_free : eq (plus two Z) (plus Z two).\n(* If you use Coq IDE locally, you can see \"goal\" at this point. *)\nProof.\n  (* If we evaluate the two sides, they're equal, so we can prove the theorem with \"refl\". *)\n  apply refl.\n  (* All goals are satisfied, we close the proof with \"Qed\".\n     Then \"this_is_almost_free\" is defined with auto-generated body. *)\nQed.\n\n(* Now, we define a utility function \"cong\":\n   if two sides are equal, they're still equal after applying a function on both sides. *)\nTheorem cong : forall (f : nat -> nat) (n m : nat), eq n m -> eq (f n) (f m).\nProof.\n  (* Bring the parameters as hypotheses. *)\n  intros f n m eq_n_m.\n  (* The \"inversion\" tactic can identify how we can satisfy \"eq n m\" - n and m should be equal. *)\n  inversion eq_n_m.\n  (* Now n and m are equal, and the goal is \"eq (f m) (f m)\". How do we close it? *)\n  (* FILL IN HERE *)\n  apply refl.\nQed.\n\n(* Let's prove the main theorems. *)\nTheorem plus_O_a : forall n : nat, eq (plus Z n) n.\nProof.\n  (* Bring the parameters as hypotheses. Hint: See above. *)\n  (* FILL IN HERE *)\n  unfold plus.\n  intro a.\n  apply refl.\n  (* \"plus Z n\" is, by definition of plus, \"n\". *)\n  (* FILL IN HERE *)\nQed.\n\nTheorem plus_a_O : forall n : nat, eq (plus n Z) n.\nProof.\n  (* This time, it's not simple at all like the above.\n     Let's try induction principle. *)\n  induction n as [ | n' IHn ].\n    (* Base case : the theorem holds when n = Z (this is trivial.) *)\n  - (* FILL IN HERE *)\n    unfold plus.\n    apply refl.\n    (* Induction case : If the theorem holds with n', the theorem holds with S n'.\n       The \"If\" part is given as hypothesis \"IHn\" here.\n       Let's apply the definition of plus. If you're using IDE, you can see S is extracted out. *)\n  - simpl.\n    (* The conclusion has S on both sides. Let's strip it. *)\n    apply cong.\n    (* Now it's exactly the same as the induction hypothesis. *)\n    (* FILL IN HERE *)\n    apply IHn.\nQed.\n\n(* Congratulations! For better introduction, google Coq Software Foundations. *)","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32695,"user_id":null,"body":"(* Define a datatype to represent natural numbers. *)\nInductive nat : Set :=\n  (* A natural number can be zero, *)\n  | Z : nat\n  (* or the successor of another natural number. *)\n  | S : nat -> nat.\n\n(* Two is the successor of successor of zero. *)\nDefinition two : nat := S (S Z).\n\n(* We can find the predecessor. *)\nDefinition pred (n : nat) : nat :=\n  (* Let's investigate the given number: *)\n  match n with\n    (* If it's zero, let's just return zero. *)\n  | Z => Z\n    (* Otherwise, pred of \"succ of n\" is just n. *)\n  | S n' => n'\nend.\n\n(* We define addition on two \"nat\"s, recursively.\n   A recursive function is defined using Fixpoint. *)\nFixpoint plus (n m : nat) : nat :=\n  (* Let's analyze n. *)\n  match n with\n    (* If it's zero, we return m. *)\n  | Z => m\n    (* Otherwise, n is S n' for some n'. *)\n  | S n' =>\n    (* We recursively compute \"plus n' m\", then apply S. *)\n    S (plus n' m)\nend.\n\n(* Equality type is defined like this. *)\nInductive eq (A : Set) : A -> A -> Prop :=\n  refl : forall x : A, eq A x x.\n\n(* Don't need to understand this now;\n   just use equality type as \"eq x y\" and reflexivity as \"refl\". *)\nArguments eq {_} x y.\nArguments refl {_ _}.\n\n(* Reflexivity holds by definition. *)\nDefinition this_is_free : eq (S Z) (S Z) := refl.\n\n(* We can write more complex expressions as \"Theorem\", and provide \"Proof\" with tactics. *)\nTheorem this_is_almost_free : eq (plus two Z) (plus Z two).\n(* If you use Coq IDE locally, you can see \"goal\" at this point. *)\nProof.\n  (* If we evaluate the two sides, they're equal, so we can prove the theorem with \"refl\". *)\n  apply refl.\n  (* All goals are satisfied, we close the proof with \"Qed\".\n     Then \"this_is_almost_free\" is defined with auto-generated body. *)\nQed.\n\n(* Now, we define a utility function \"cong\":\n   if two sides are equal, they're still equal after applying a function on both sides. *)\nTheorem cong : forall (f : nat -> nat) (n m : nat), eq n m -> eq (f n) (f m).\nProof.\n  (* Bring the parameters as hypotheses. *)\n  intros f n m eq_n_m.\n  (* The \"inversion\" tactic can identify how we can satisfy \"eq n m\" - n and m should be equal. *)\n  inversion eq_n_m.\n  (* Now n and m are equal, and the goal is \"eq (f m) (f m)\". How do we close it? *)\n  constructor.\nQed.\n\n(* Let's prove the main theorems. *)\nTheorem plus_O_a : forall n : nat, eq (plus Z n) n.\nProof.\n  constructor.\nQed.\n\nTheorem plus_a_O : forall n : nat, eq (plus n Z) n.\nProof.\n  (* This time, it's not simple at all like the above.\n     Let's try induction principle. *)\n  induction n as [ | n' IHn ].\n    (* Base case : the theorem holds when n = Z (this is trivial.) *)\n  - constructor.\n  - simpl.\n    (* The conclusion has S on both sides. Let's strip it. *)\n    apply cong.\n    (* Now it's exactly the same as the induction hypothesis. *)\n    auto.\nQed.\n\n(* Congratulations! For better introduction, google Coq Software Foundations. *)","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32696,"user_id":null,"body":"(* Define a datatype to represent natural numbers. *)\nInductive nat : Set :=\n  (* A natural number can be zero, *)\n  | Z : nat\n  (* or the successor of another natural number. *)\n  | S : nat -> nat.\n\n(* Two is the successor of successor of zero. *)\nDefinition two : nat := S (S Z).\n\n(* We can find the predecessor. *)\nDefinition pred (n : nat) : nat :=\n  (* Let's investigate the given number: *)\n  match n with\n    (* If it's zero, let's just return zero. *)\n  | Z => Z\n    (* Otherwise, pred of \"succ of n\" is just n. *)\n  | S n' => n'\nend.\n\n(* We define addition on two \"nat\"s, recursively.\n   A recursive function is defined using Fixpoint. *)\nFixpoint plus (n m : nat) : nat :=\n  (* Let's analyze n. *)\n  match n with\n    (* If it's zero, we return m. *)\n  | Z => m\n    (* Otherwise, n is S n' for some n'. *)\n  | S n' =>\n    (* We recursively compute \"plus n' m\", then apply S. *)\n    S (plus n' m)\nend.\n\n(* Equality type is defined like this. *)\nInductive eq (A : Set) : A -> A -> Prop :=\n  refl : forall x : A, eq A x x.\n\n(* Don't need to understand this now;\n   just use equality type as \"eq x y\" and reflexivity as \"refl\". *)\nArguments eq {_} x y.\nArguments refl {_ _}.\n\n(* Reflexivity holds by definition. *)\nDefinition this_is_free : eq (S Z) (S Z) := refl.\n\n(* We can write more complex expressions as \"Theorem\", and provide \"Proof\" with tactics. *)\nTheorem this_is_almost_free : eq (plus two Z) (plus Z two).\n(* If you use Coq IDE locally, you can see \"goal\" at this point. *)\nProof.\n  (* If we evaluate the two sides, they're equal, so we can prove the theorem with \"refl\". *)\n  apply refl.\n  (* All goals are satisfied, we close the proof with \"Qed\".\n     Then \"this_is_almost_free\" is defined with auto-generated body. *)\nQed.\n\n(* Now, we define a utility function \"cong\":\n   if two sides are equal, they're still equal after applying a function on both sides. *)\nTheorem cong : forall (f : nat -> nat) (n m : nat), eq n m -> eq (f n) (f m).\nProof.\n  (* Bring the parameters as hypotheses. *)\n  intros f n m eq_n_m.\n  (* The \"inversion\" tactic can identify how we can satisfy \"eq n m\" - n and m should be equal. *)\n  inversion eq_n_m.\n  (* Now n and m are equal, and the goal is \"eq (f m) (f m)\". How do we close it? *)\n  (* FILL IN HERE *)\n  apply refl.\nQed.\n\n(* Let's prove the main theorems. *)\nTheorem plus_O_a : forall n : nat, eq (plus Z n) n.\nProof.\n  (* Bring the parameters as hypotheses. Hint: See above. *)\n  intros n. induction n as [| n' IHn'].\n  - simpl. apply refl.\n  - simpl. apply refl.\n  (* \"plus Z n\" is, by definition of plus, \"n\". *)\n  (* FILL IN HERE *)\nQed.\n\nTheorem plus_a_O : forall n : nat, eq (plus n Z) n.\nProof.\n  (* This time, it's not simple at all like the above.\n     Let's try induction principle. *)\n  induction n as [ | n' IHn' ].\n    (* Base case : the theorem holds when n = Z (this is trivial.) *)\n  - simpl. apply refl.\n  (* Induction case : If the theorem holds with n', the theorem holds with S n'.\n       The \"If\" part is given as hypothesis \"IHn\" here.\n       Let's apply the definition of plus. If you're using IDE, you can see S is extracted out. *)\n  - simpl.\n    (* The conclusion has S on both sides. Let's strip it. *)\n    apply cong.\n    (* Now it's exactly the same as the induction hypothesis. *)\n    apply IHn'.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32697,"user_id":null,"body":"(* Define a datatype to represent natural numbers. *)\nInductive nat : Set :=\n  (* A natural number can be zero, *)\n  | Z : nat\n  (* or the successor of another natural number. *)\n  | S : nat -> nat.\n\n(* Two is the successor of successor of zero. *)\nDefinition two : nat := S (S Z).\n\n(* We can find the predecessor. *)\nDefinition pred (n : nat) : nat :=\n  (* Let's investigate the given number: *)\n  match n with\n    (* If it's zero, let's just return zero. *)\n  | Z => Z\n    (* Otherwise, pred of \"succ of n\" is just n. *)\n  | S n' => n'\nend.\n\n(* We define addition on two \"nat\"s, recursively.\n   A recursive function is defined using Fixpoint. *)\nFixpoint plus (n m : nat) : nat :=\n  (* Let's analyze n. *)\n  match n with\n    (* If it's zero, we return m. *)\n  | Z => m\n    (* Otherwise, n is S n' for some n'. *)\n  | S n' =>\n    (* We recursively compute \"plus n' m\", then apply S. *)\n    S (plus n' m)\nend.\n\n(* Equality type is defined like this. *)\nInductive eq (A : Set) : A -> A -> Prop :=\n  refl : forall x : A, eq A x x.\n\n(* Don't need to understand this now;\n   just use equality type as \"eq x y\" and reflexivity as \"refl\". *)\nArguments eq {_} x y.\nArguments refl {_ _}.\n\n(* Reflexivity holds by definition. *)\nDefinition this_is_free : eq (S Z) (S Z) := refl.\n\n(* We can write more complex expressions as \"Theorem\", and provide \"Proof\" with tactics. *)\nTheorem this_is_almost_free : eq (plus two Z) (plus Z two).\n(* If you use Coq IDE locally, you can see \"goal\" at this point. *)\nProof.\n  (* If we evaluate the two sides, they're equal, so we can prove the theorem with \"refl\". *)\n  apply refl.\n  (* All goals are satisfied, we close the proof with \"Qed\".\n     Then \"this_is_almost_free\" is defined with auto-generated body. *)\nQed.\n\n(* Now, we define a utility function \"cong\":\n   if two sides are equal, they're still equal after applying a function on both sides. *)\nTheorem cong : forall (f : nat -> nat) (n m : nat), eq n m -> eq (f n) (f m).\nProof.\n  (* Bring the parameters as hypotheses. *)\n  intros f n m eq_n_m.\n  (* The \"inversion\" tactic can identify how we can satisfy \"eq n m\" - n and m should be equal. *)\n  inversion eq_n_m.\n  (* Now n and m are equal, and the goal is \"eq (f m) (f m)\". How do we close it? *)\n  apply refl.\nQed.\n\n(* Let's prove the main theorems. *)\nTheorem plus_O_a : forall n : nat, eq (plus Z n) n.\nProof.\n  (* Bring the parameters as hypotheses. Hint: See above. *)\n  intros n.\n  apply refl.\n  (* \"plus Z n\" is, by definition of plus, \"n\". *)\n  (* FILL IN HERE *)\nQed.\n\nTheorem plus_a_O : forall n : nat, eq (plus n Z) n.\nProof.\n  (* This time, it's not simple at all like the above.\n     Let's try induction principle. *)\n  induction n as [ | n' IHn ].\n    (* Base case : the theorem holds when n = Z (this is trivial.) *)\n  - apply refl.\n    (* Induction case : If the theorem holds with n', the theorem holds with S n'.\n       The \"If\" part is given as hypothesis \"IHn\" here.\n       Let's apply the definition of plus. If you're using IDE, you can see S is extracted out. *)\n  - simpl.\n    (* The conclusion has S on both sides. Let's strip it. *)\n    apply cong.\n    (* Now it's exactly the same as the induction hypothesis. *)\n    apply IHn.\nQed.\n\n(* Congratulations! For better introduction, google Coq Software Foundations. *)\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32698,"user_id":null,"body":"(* Define a datatype to represent natural numbers. *)\nInductive nat : Set :=\n  (* A natural number can be zero, *)\n  | Z : nat\n  (* or the successor of another natural number. *)\n  | S : nat -> nat.\n\n(* Two is the successor of successor of zero. *)\nDefinition two : nat := S (S Z).\n\n(* We can find the predecessor. *)\nDefinition pred (n : nat) : nat :=\n  (* Let's investigate the given number: *)\n  match n with\n    (* If it's zero, let's just return zero. *)\n  | Z => Z\n    (* Otherwise, pred of \"succ of n\" is just n. *)\n  | S n' => n'\nend.\n\n(* We define addition on two \"nat\"s, recursively.\n   A recursive function is defined using Fixpoint. *)\nFixpoint plus (n m : nat) : nat :=\n  (* Let's analyze n. *)\n  match n with\n    (* If it's zero, we return m. *)\n  | Z => m\n    (* Otherwise, n is S n' for some n'. *)\n  | S n' =>\n    (* We recursively compute \"plus n' m\", then apply S. *)\n    S (plus n' m)\nend.\n\n(* Equality type is defined like this. *)\nInductive eq (A : Set) : A -> A -> Prop :=\n  refl : forall x : A, eq A x x.\n\n(* Don't need to understand this now;\n   just use equality type as \"eq x y\" and reflexivity as \"refl\". *)\nArguments eq {_} x y.\nArguments refl {_ _}.\n\n(* Reflexivity holds by definition. *)\nDefinition this_is_free : eq (S Z) (S Z) := refl.\n\n(* We can write more complex expressions as \"Theorem\", and provide \"Proof\" with tactics. *)\nTheorem this_is_almost_free : eq (plus two Z) (plus Z two).\n(* If you use Coq IDE locally, you can see \"goal\" at this point. *)\nProof.\n  (* If we evaluate the two sides, they're equal, so we can prove the theorem with \"refl\". *)\n  apply refl.\n  (* All goals are satisfied, we close the proof with \"Qed\".\n     Then \"this_is_almost_free\" is defined with auto-generated body. *)\nQed.\n\n(* Now, we define a utility function \"cong\":\n   if two sides are equal, they're still equal after applying a function on both sides. *)\nTheorem cong : forall (f : nat -> nat) (n m : nat), eq n m -> eq (f n) (f m).\nProof.\n  (* Bring the parameters as hypotheses. *)\n  intros f n m eq_n_m.\n  (* The \"inversion\" tactic can identify how we can satisfy \"eq n m\" - n and m should be equal. *)\n  inversion eq_n_m.\n  (* Now n and m are equal, and the goal is \"eq (f m) (f m)\". How do we close it? *)\n  (* FILL IN HERE *)\n  apply refl.\nQed.\n\n(* Let's prove the main theorems. *)\nTheorem plus_O_a : forall n : nat, eq (plus Z n) n.\nProof.\n  (* Bring the parameters as hypotheses. Hint: See above. *)\n  (* FILL IN HERE *)\n  intros; apply refl.\n  (* \"plus Z n\" is, by definition of plus, \"n\". *)\n  (* FILL IN HERE *)\nQed.\n\nTheorem plus_a_O : forall n : nat, eq (plus n Z) n.\nProof.\n  (* This time, it's not simple at all like the above.\n     Let's try induction principle. *)\n  induction n as [ | n' IHn ].\n    (* Base case : the theorem holds when n = Z (this is trivial.) *)\n  - (* FILL IN HERE *)\n     auto; apply refl.\n    (* Induction case : If the theorem holds with n', the theorem holds with S n'.\n       The \"If\" part is given as hypothesis \"IHn\" here.\n       Let's apply the definition of plus. If you're using IDE, you can see S is extracted out. *)\n  - simpl.\n    (* The conclusion has S on both sides. Let's strip it. *)\n    apply cong.\n    apply IHn.\n    (* Now it's exactly the same as the induction hypothesis. *)\n    (* FILL IN HERE *)\nQed.\n\n(* Congratulations! For better introduction, google Coq Software Foundations. *)","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32699,"user_id":null,"body":"(* Define a datatype to represent natural numbers. *)\nInductive nat : Set :=\n  (* A natural number can be zero, *)\n  | Z : nat\n  (* or the successor of another natural number. *)\n  | S : nat -> nat.\n\n(* Two is the successor of successor of zero. *)\nDefinition two : nat := S (S Z).\n\n(* We can find the predecessor. *)\nDefinition pred (n : nat) : nat :=\n  (* Let's investigate the given number: *)\n  match n with\n    (* If it's zero, let's just return zero. *)\n  | Z => Z\n    (* Otherwise, pred of \"succ of n\" is just n. *)\n  | S n' => n'\nend.\n\n(* We define addition on two \"nat\"s, recursively.\n   A recursive function is defined using Fixpoint. *)\nFixpoint plus (n m : nat) : nat :=\n  (* Let's analyze n. *)\n  match n with\n    (* If it's zero, we return m. *)\n  | Z => m\n    (* Otherwise, n is S n' for some n'. *)\n  | S n' =>\n    (* We recursively compute \"plus n' m\", then apply S. *)\n    S (plus n' m)\nend.\n\n(* Equality type is defined like this. *)\nInductive eq (A : Set) : A -> A -> Prop :=\n  refl : forall x : A, eq A x x.\n\n(* Don't need to understand this now;\n   just use equality type as \"eq x y\" and reflexivity as \"refl\". *)\nArguments eq {_} x y.\nArguments refl {_ _}.\n\n(* Reflexivity holds by definition. *)\nDefinition this_is_free : eq (S Z) (S Z) := refl.\n\n(* We can write more complex expressions as \"Theorem\", and provide \"Proof\" with tactics. *)\nTheorem this_is_almost_free : eq (plus two Z) (plus Z two).\n(* If you use Coq IDE locally, you can see \"goal\" at this point. *)\nProof.\n  (* If we evaluate the two sides, they're equal, so we can prove the theorem with \"refl\". *)\n  apply refl.\n  (* All goals are satisfied, we close the proof with \"Qed\".\n     Then \"this_is_almost_free\" is defined with auto-generated body. *)\nQed.\n\n(* Now, we define a utility function \"cong\":\n   if two sides are equal, they're still equal after applying a function on both sides. *)\nTheorem cong : forall (f : nat -> nat) (n m : nat), eq n m -> eq (f n) (f m).\nProof.\n  (* Bring the parameters as hypotheses. *)\n  intros f n m eq_n_m.\n  (* The \"inversion\" tactic can identify how we can satisfy \"eq n m\" - n and m should be equal. *)\n  inversion eq_n_m.\n  (* Now n and m are equal, and the goal is \"eq (f m) (f m)\". How do we close it? *)\n  apply refl.\nQed.\n\n(* Let's prove the main theorems. *)\nTheorem plus_O_a : forall n : nat, eq (plus Z n) n.\nProof.\n  (* Bring the parameters as hypotheses. Hint: See above. *)\n  simpl. intros n. apply refl.\n  (* \"plus Z n\" is, by definition of plus, \"n\". *)\n  (* FILL IN HERE *)\nQed.\n\nTheorem plus_a_O : forall n : nat, eq (plus n Z) n.\nProof.\n  (* This time, it's not simple at all like the above.\n     Let's try induction principle. *)\n  induction n as [ | n' IHn ].\n    (* Base case : the theorem holds when n = Z (this is trivial.) *)\n  - simpl. apply refl.\n    (* Induction case : If the theorem holds with n', the theorem holds with S n'.\n       The \"If\" part is given as hypothesis \"IHn\" here.\n       Let's apply the definition of plus. If you're using IDE, you can see S is extracted out. *)\n  - simpl.\n    (* The conclusion has S on both sides. Let's strip it. *)\n    apply cong.\n    (* Now it's exactly the same as the induction hypothesis. *)\n    apply IHn.\nQed.\n\n(* Congratulations! For better introduction, google Coq Software Foundations. *)\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5c8b332197eb04000887fd63":[{"id":32700,"user_id":568,"body":"From Coq Require Import Arith Lia.\nRequire Import Preloaded.\n\nTheorem arith_eq (n : nat) : arith_formula n = arith_sum n.\nProof.\n  enough (n * (n + 1) = 2 * arith_sum n).\n  { unfold arith_formula.\n    rewrite H.\n    apply Nat.div2_double. }\n  induction n; simpl; lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32701,"user_id":null,"body":"From Coq Require Import Arith.\nRequire Import Preloaded.\n\nLemma div2_inv : forall n m, 2 * n = m -> Nat.div2 m = n.\nProof.\n  now intros; subst; rewrite Nat.div2_double.\nQed.\n\nTheorem arith_eq (n : nat) : arith_formula n = arith_sum n.\nProof.\n  apply div2_inv.\n  induction n; [easy|].\n  replace (2 * arith_sum (S n)) with (2 * S n + 2 * arith_sum n) by (simpl; ring).\n  rewrite IHn; ring.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32702,"user_id":null,"body":"From Coq Require Import Arith.\nRequire Import Preloaded.\n\n(* Preloaded:\nRequire Import Arith.\n\nFixpoint arith_sum (n : nat) : nat :=\n  match n with\n  | 0 => 0\n  | S m => n + arith_sum m\n  end.\n\nDefinition arith_formula (n : nat) : nat := Nat.div2 (n * (n + 1)).\n*)\n\nRequire Import Lia.\n\nLemma arith_sum_step n : arith_sum (S n) = S n + arith_sum n.\nProof. simpl; reflexivity. Qed.\n\nLemma mul_nSn_odd n : Nat.even (n * S n) = true.\nProof.\n  rewrite Nat.even_mul.\n  rewrite Nat.even_succ.\n  rewrite Nat.orb_even_odd.\n  reflexivity.\nQed.\n\nLemma b2n_nSn_odd_0 n : Nat.b2n (Nat.odd (n * S n)) = 0.\nProof.\n  rewrite <- Nat.negb_even.\n  rewrite mul_nSn_odd.\n  cbn; reflexivity.\nQed.\n\nLemma mul2_nSn n : n * S n = 2 * Nat.div2 (n * S n).\nProof.\n  rewrite <- (Nat.add_0_r (2 * Nat.div2 (n * S n))).\n  rewrite <- (b2n_nSn_odd_0 n) at 2.\n  rewrite <- (Nat.div2_odd (n * S n)).\n  reflexivity.\nQed.\n\nTheorem arith_eq (n : nat) : arith_formula n = arith_sum n.\nProof.\n  elim n; clear n; [auto | intros n H].\n  rewrite arith_sum_step; rewrite <- H; clear H.\n  unfold arith_formula.\n  rewrite <- (Nat.mul_cancel_l _ _ 2); [|auto].\n  rewrite 2!Nat.add_1_r.\n  rewrite (Nat.mul_add_distr_l 2).\n  rewrite <- 2!mul2_nSn.\n  lia.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32703,"user_id":null,"body":"From Coq Require Import Arith Lia.\nRequire Import Preloaded.\n\n(* Preloaded:\nRequire Import Arith.\n\nFixpoint arith_sum (n : nat) : nat :=\n  match n with\n  | 0 => 0\n  | S m => n + arith_sum m\n  end.\n\nDefinition arith_formula (n : nat) : nat := Nat.div2 (n * (n + 1)).\n*)\n\nLemma div_even (n : nat) : Nat.Even n -> 2 * Nat.div2 n = n.\nProof.\n  intros. rewrite Nat.div2_odd. \n  enough (Nat.odd n = false) by (rewrite H0 ; simpl ; ring).\n  symmetry. rewrite <- Nat.negb_even. apply Bool.negb_sym.\n  simpl. Search [Nat.Even Nat.even]. apply (proj2 (Nat.even_spec n)).\n  assumption.\nQed.\n\nTheorem arith_eq (n : nat) : arith_formula n = arith_sum n.\nProof.\n  enough (2 * arith_formula n = 2 * arith_sum n) by lia.\n  transitivity (n * (n+1)).\n  + unfold arith_formula. rewrite div_even. reflexivity.\n    induction n.\n    * exists 0. lia.\n    * destruct IHn. exists (x + (n + 1)). lia.\n  + induction n. \n    * reflexivity.\n    * simpl. lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32704,"user_id":null,"body":"From Coq Require Import Arith Psatz.\nRequire Import Preloaded.\n\n(* Preloaded:\nRequire Import Arith.\n\nFixpoint arith_sum (n : nat) : nat :=\n  match n with\n  | 0 => 0\n  | S m => n + arith_sum m\n  end.\n\nDefinition arith_formula (n : nat) : nat := Nat.div2 (n * (n + 1)).\n*)\nLemma arith_formula_equal: forall n, n * (n + 1) + (S n) * 2 = (S n) * ((S n) + 1).\nProof. lia. Qed.\n\nLemma even_n_mult_Sn: forall n, Nat.Even (n * (n + 1)).\nProof with lia.\n  intros n.\n  induction n as [| n [m IHn]].\n  - exists 0...\n  - exists (m + (S n))...\nQed.\n\nLemma IH_arith_formula: forall n, arith_formula (S n) = S n + arith_formula n.\nProof.\n  intros n.\n  destruct (even_n_mult_Sn n) as [m Hm].\n  destruct (even_n_mult_Sn (S n)) as [m' Hm'].\n  unfold arith_formula.\n  rewrite Hm. rewrite Hm'.\n  rewrite <- (arith_formula_equal n) in Hm'.\n  rewrite Hm in Hm'.\n  replace (2 * m + S n * 2) with (2 * (m + S n)) in Hm' by lia.\n  rewrite <- Hm'.\n  repeat rewrite Nat.div2_double.\n  lia.\nQed.\n\nTheorem arith_eq (n : nat) : arith_formula n = arith_sum n.\nProof.\n  induction n.\n  - reflexivity.\n  - rewrite IH_arith_formula. simpl.\n    rewrite IHn. auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32705,"user_id":null,"body":"From Coq Require Import Arith.\nRequire Import Preloaded.\n\nLemma triangle_inv : forall n, exists m, 2 * m = n * (n + 1).\nProof.\n  induction n; [now exists 0|].\n  destruct IHn as [m Hm]; exists (m + n + 1).\n  replace (2 * (m + n + 1)) with (2 * m + 2 * n + 2); [|ring].\n  rewrite Hm; ring.\nQed.\n\nTheorem arith_eq (n : nat) : arith_formula n = arith_sum n.\nProof.\n  induction n; [easy|simpl; rewrite <- IHn; clear].\n  unfold arith_formula.\n  destruct (triangle_inv n) as [m Hm].\n  replace (S n * (S n + 1)) with (n * (n + 1) + 2 * n + 2); [|ring].\n  rewrite <- Hm; replace (2 * m + 2 * n + 2) with (2 * (m + n + 1)); [|ring].\n  repeat rewrite Nat.div2_double; ring.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32706,"user_id":null,"body":"From Coq Require Import Arith.\nRequire Import Preloaded.\n\n(* Preloaded:\nRequire Import Arith.\n\nFixpoint arith_sum (n : nat) : nat :=\n  match n with\n  | 0 => 0\n  | S m => n + arith_sum m\n  end.\n\nDefinition arith_formula (n : nat) : nat := Nat.div2 (n * (n + 1)).\n*)\n\nTheorem arith_eq (n : nat) : arith_formula n = arith_sum n.\nProof.\n  unfold arith_formula.\n  induction n.\n  trivial.\n  simpl.\n  rewrite <- IHn.\n  rewrite Nat.add_1_r.\n  rewrite plus_Sn_m.\n  apply eq_S.\n  assert (forall a m, a + a * m = a * 1 + a * m).\n  intros.\n  rewrite Nat.mul_1_r.\n  reflexivity.\n  assert (forall a m, a + a * m = a * (1 + m)).\n  intros.\n  rewrite H.\n  rewrite Nat.mul_add_distr_l.\n  reflexivity.\n  rewrite H0.\n  simpl.\n  assert (n * S (S (S n)) = 2 * n + n * S n).\n  simpl.\n  rewrite Nat.add_0_r.\n  repeat rewrite Nat.mul_succ_r.\n  rewrite Nat.add_comm.\n  rewrite Nat.add_assoc.\n  rewrite Nat.add_assoc.\n  rewrite Nat.add_assoc.\n  rewrite Nat.add_cancel_r.\n  rewrite Nat.add_comm.\n  rewrite Nat.add_assoc.\n  reflexivity.\n  rewrite H1.\n  assert (forall a b, Nat.Even a -> Nat.Even b -> Nat.div2 (a + b) = Nat.div2 a + Nat.div2 b).\n  intros.\n  inversion H2.\n  inversion H3.\n  subst.\n  rewrite <- Nat.mul_add_distr_l.\n  repeat rewrite Nat.div2_double.\n  reflexivity.\n  rewrite H2.\n  rewrite Nat.div2_double.\n  reflexivity.\n  exists n.\n  reflexivity.\n  assert (forall a, Nat.Even a \\\/ Nat.Even (S a)).\n  intro a.\n  induction a.\n  left.\n  exists 0.\n  trivial.\n  inversion IHa.\n  right.\n  inversion H3.\n  exists (S x).\n  rewrite H4.\n  simpl.\n  rewrite plus_n_Sm.\n  reflexivity.\n  left.\n  assumption.\n  assert (Nat.Even n \\\/ Nat.Even (S n)).\n  apply H3.\n  inversion H4.\n  inversion H5.\n  rewrite H6.\n  exists (x * S (2 * x)).\n  rewrite Nat.mul_assoc.\n  reflexivity.\n  inversion H5.\n  rewrite H6.\n  rewrite Nat.mul_comm.\n  rewrite <- Nat.mul_assoc.\n  exists (x * n).\n  reflexivity.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32707,"user_id":null,"body":"Require Import Arith Arith.Even.\nFrom mathcomp Require Import all_ssreflect.\n\nFixpoint arith_sum (n : nat) : nat :=\n  match n with\n  | 0 => 0\n  | S m => n + arith_sum m\n  end.\n\nDefinition arith_formula (n : nat) : nat := Nat.div2 (n * (n + 1)).\n\nTheorem arith_eq (n : nat) : arith_formula n = arith_sum n.\nProof.\n  elim: n => [\/\/| n Hn] \/=.\n  rewrite -Hn \/arith_formula !Nat.div2_div.\n  rewrite !addn1 -addn2 [_*(_+2)]mulnC mulnDl [2*_]mulnC [in LHS]addnC -multE -plusE.\n  by rewrite Nat.div_add_l.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32708,"user_id":null,"body":"From Coq Require Import Arith Lia ssreflect.\nRequire Import Preloaded.\n\nTheorem arith_eq (n : nat) : arith_formula n = arith_sum n.\nProof.\n  elim: n => [\/\/|n \/= <-].\n  rewrite \/arith_formula.\n  have -> : S n * (S n + 1) = S n * 2 + n * (n + 1) by lia.\n  by rewrite !Nat.div2_div Nat.div_add_l.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32709,"user_id":null,"body":"From Coq Require Import Arith Lia.\nRequire Import Preloaded.\n\n(* Preloaded:\nRequire Import Arith.\n\nFixpoint arith_sum (n : nat) : nat :=\n  match n with\n  | 0 => 0\n  | S m => n + arith_sum m\n  end.\n\nDefinition arith_formula (n : nat) : nat := Nat.div2 (n * (n + 1)).\n*)\n\nTheorem arith_eq (n : nat) : arith_formula n = arith_sum n.\nProof.\n  induction n.\n  compute.\n  lia.\n  simpl.\n  rewrite <- IHn.\n  unfold arith_formula.\n  assert (forall a b, Nat.div2(2 * a + b) = a + Nat.div2(b)).\n    intros.\n    induction a.\n    simpl.\n    reflexivity.\n    simpl.\n    replace (a + S (a + 0) + b) with (1 + 2 * a + b) by lia.\n    simpl.\n    simpl in IHa.\n    rewrite IHa.\n    reflexivity.\n  replace (S n * (S n + 1)) with (2 + 2 * n + n * (n + 1)) by lia.\n  simpl.\n  simpl in H.\n  rewrite H.\n  reflexivity.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5c8b3e55b9d1190016bd3cca":[{"id":32710,"user_id":null,"body":"From Coq Require Import Arith.\nRequire Import Preloaded.\n\n(* Preloaded:\n\nFixpoint fib (n : nat) : nat :=\n  match n with\n  | 0 => 0\n  | 1 => 1\n  | S (S n as n') => fib n' + fib n\n  end.\n\nFixpoint fib_aux (a b n : nat) : nat :=\n  match n with\n  | 0 => a\n  | S n => fib_aux b (a + b) n\n  end.\n  \nDefinition fib2 (n : nat) : nat := fib_aux 0 1 n.\n\n*)\n\nTheorem fib_aux_eq : forall (n a b : nat), fib_aux a b (S n) = fib n * a + fib (S n) * b.\nProof.\n  induction n; simpl in *; intros; [| rewrite IHn]; ring.\nQed.\n\nTheorem fib_eq (n : nat) : fib2 n = fib n.\nProof.\n  destruct n.\n  - reflexivity.\n  - unfold fib2.\n    rewrite fib_aux_eq.\n    ring.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32711,"user_id":1076,"body":"From Coq Require Import Arith Lia.\nRequire Import Preloaded.\n\nLemma fib_aux_eq n : forall k, fib_aux (fib k) (fib (S k)) n = fib (k + n).\nProof.\n  induction n as [|n IHn]; intro k; cbn [fib_aux]; [ f_equal; lia | ].\n  rewrite (Nat.add_comm (fib k)), IHn; f_equal; lia.\nQed.\n\nTheorem fib_eq (n : nat) : fib2 n = fib n.\nProof. exact (fib_aux_eq n 0). Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32712,"user_id":1076,"body":"From Coq Require Import Arith Lia.\nRequire Import Preloaded.\n\n(* Preloaded:\n\nFixpoint fib (n : nat) : nat :=\n  match n with\n  | 0 => 0\n  | 1 => 1\n  | S (S n as n') => fib n' + fib n\n  end.\n\nFixpoint fib_aux (a b n : nat) : nat :=\n  match n with\n  | 0 => a\n  | S n => fib_aux b (a + b) n\n  end.\n  \nDefinition fib2 (n : nat) : nat := fib_aux 0 1 n.\n\n*)\n\nLemma fib_aux_eq n : forall k, fib_aux (fib k) (fib (S k)) n = fib (k + n).\nProof.\n  induction n as [|n IHn]; intro k; cbn [fib_aux]; [ f_equal; lia | ].\n  rewrite (Nat.add_comm (fib k)), IHn; f_equal; lia.\nQed.\n\nTheorem fib_eq (n : nat) : fib2 n = fib n.\nProof. apply (fib_aux_eq n 0). Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32713,"user_id":null,"body":"From Coq Require Import Arith.\nRequire Import Preloaded.\n\n(* Preloaded:\n\nFixpoint fib (n : nat) : nat :=\n  match n with\n  | 0 => 0\n  | 1 => 1\n  | S (S n as n') => fib n' + fib n\n  end.\n\nFixpoint fib_aux (a b n : nat) : nat :=\n  match n with\n  | 0 => a\n  | S n => fib_aux b (a + b) n\n  end.\n  \nDefinition fib2 (n : nat) : nat := fib_aux 0 1 n.\n\n*)\n\nTheorem fib_eq (n : nat) : fib2 n = fib n.\nProof.\nunfold fib2.\nchange 0 with (fib 0) at 1.\nchange 1 with (fib 1).\nchange n with (0 + n) at 2.\ngeneralize 0.\ninduction n as [|n IH]; intros m.\n- now simpl; rewrite Nat.add_0_r.\n- unfold fib_aux; fold fib_aux.\n  rewrite <- plus_n_Sm, Nat.add_comm.\n  now apply IH.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32714,"user_id":null,"body":"From Coq Require Import Arith.\nRequire Import Preloaded.\n\n(* Preloaded:\n\nFixpoint fib (n : nat) : nat :=\n  match n with\n  | 0 => 0\n  | 1 => 1\n  | S (S n as n') => fib n' + fib n\n  end.\n\nFixpoint fib_aux (a b n : nat) : nat :=\n  match n with\n  | 0 => a\n  | S n => fib_aux b (a + b) n\n  end.\n  \nDefinition fib2 (n : nat) : nat := fib_aux 0 1 n.\n\n*)\n\nLemma fib1_unfold n : fib (S (S n)) = fib (S n) + fib n.\nProof. reflexivity. Qed.\n\nLemma fib2_unfold a b n : fib_aux a b (S n) = fib_aux b (a + b) n.\nProof. reflexivity. Qed.\n\nLemma fib_add n m : fib_aux (fib n) (fib (S n)) m = fib (n + m).\nProof.\n  generalize n; clear n; elim m; clear m.\n  cbn; intros; rewrite <- plus_n_O; reflexivity.\n  intros m H n.\n  rewrite fib2_unfold.\n  rewrite Nat.add_comm.\n  rewrite <- fib1_unfold.\n  rewrite H.\n  rewrite Nat.add_succ_comm.\n  reflexivity.\nQed.\n\nTheorem fib_eq (n : nat) : fib2 n = fib n.\nProof.\n  rewrite <- (plus_O_n n) at 2.\n  rewrite <- fib_add.\n  reflexivity.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32715,"user_id":null,"body":"From Coq Require Import Arith.\nRequire Import Preloaded.\n\nTheorem fib_eq (n : nat) : fib2 n = fib n.\nProof.\n  cut (forall n m, fib_aux (fib n) (fib (S n)) m = fib (n + m)).\n  { intros H; apply (H 0 n). }\n  clear; intros n m; revert n; induction m; intros.\n  - simpl; now replace (n + 0) with n by ring.\n  - unfold fib_aux; fold fib_aux.\n    replace (fib n + fib (S n)) with (fib (S (S n))) by (simpl; ring).\n    rewrite IHm; now replace (S n + m) with (n + S m) by ring.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32716,"user_id":null,"body":"Require Import Nat.\nRequire Import Arith.\n\nFixpoint fib (n : nat) : nat :=\n  match n with\n  | 0 => 0\n  | 1 => 1\n  | S (S n as n') => fib n' + fib n\n  end.\n\nFixpoint fib_aux (a b n : nat) : nat :=\n  match n with\n  | 0 => a\n  | S n => fib_aux b (a + b) n\n  end.\n  \nDefinition fib2 (n : nat) : nat := fib_aux 0 1 n.\n\nTheorem fib_aux_th : forall (n:nat)( p:nat), fib_aux (fib p) (fib (S p)) n = fib (p + n).\nProof.\n   intros n.\n   induction n.\n   intros p.\n   rewrite -> Nat.add_0_r.\n   trivial.\n   intros p.\n   cbv delta [fib_aux].\n   cbv fix beta match.\n   change ((fix fib_aux (a b n0 : nat) {struct n0} : nat :=\n   match n0 with\n   | 0 => a\n   | S n1 => fib_aux b (a + b) n1\n   end) (fib (S p)) (fib p + fib (S p)) n) with (fib_aux (fib (S p)) (fib p + fib (S p)) n).\n   assert (forall p:nat, fib p + fib (S p) = fib (S (S p))).\n   induction p0.\n   trivial.\n   change (fib (S (S (S p0)))) with (fib (S (S p0)) + fib (S p0)).\n   rewrite <- Nat.add_comm.\n   trivial.\n   rewrite -> (H p).\n   rewrite -> (IHn (S p)).\n   rewrite -> Nat.add_succ_comm.\n   reflexivity.\nQed.\n\n\nTheorem fib_eq : forall (n:nat), fib2 n = fib n.\nProof.\n  intros.\n  induction n.\n  trivial.\n  cbv delta [fib2] beta.\n  change (fib_aux 0 1 (S n)) with (fib_aux (fib 0) (fib 1) (S n)).\n  rewrite -> (fib_aux_th (S n) 0).\n  rewrite -> Nat.add_0_l.\n  reflexivity.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32717,"user_id":null,"body":"From Coq Require Import Arith Lia.\nRequire Import Preloaded.\n\n(* Preloaded:\n\nFixpoint fib (n : nat) : nat :=\n  match n with\n  | 0 => 0\n  | 1 => 1\n  | S (S n as n') => fib n' + fib n\n  end.\n\nFixpoint fib_aux (a b n : nat) : nat :=\n  match n with\n  | 0 => a\n  | S n => fib_aux b (a + b) n\n  end.\n  \nDefinition fib2 (n : nat) : nat := fib_aux 0 1 n.\n\n*)\n\nFixpoint fib' (a b n : nat) : nat :=\n  match n with\n  | 0 => a\n  | 1 => b\n  | S (S n as n') => fib' a b n' + fib' a b n\n  end.\n\n(* \u4e00\u4e2a\u6280\u672f\u529b\u975e\u5e38\u4f4e\u7684 functional induction scheme\u3002*)\nLemma fib'_step : forall a b n,\n  (match n with\n   | O => True\n   | S n' => fib' a b n = fib' b (a + b) n'\n  end) \/\\\n  fib' a b (S n) = fib' b (a + b) n.\nProof with auto.\n  intros a b n. induction n; intros...\n  destruct IHn.\n  remember (S n) as n'.\n  simpl. subst n'.\n  rewrite -> H0. split...\n  destruct n.\n  - simpl. lia.\n  - rewrite H. simpl. lia.\nQed.\n\n(* \u8fd9\u4e2a step \u76f8\u5bf9\u4e8e fib_aux \u662f\u663e\u7136\u6210\u7acb\u7684\uff0c\u6240\u4ee5\u53ef\u4ee5\u6784\u5efa\u4e0b\u9762\u7684\u5173\u7cfb *)\nLemma fib_aux_eq : forall n a b, fib' a b n = fib_aux a b n.\nProof with auto.\n  intros n. induction n; intros...\n  rewrite -> (proj2 (fib'_step a b n)).\n  now simpl.\nQed.\n\nLemma fib_fib' (n : nat) : \n  (match n with O => True | S n' => (fib n' = fib' 0 1 n') end) \/\\\n  (fib n = fib' 0 1 n).\nProof. \n  induction n; simpl; auto. \n  split; try tauto. \n  destruct n; auto.\n  rewrite -> (proj1 IHn), (proj2 IHn).\n  reflexivity.\nQed.\n\nTheorem fib_eq (n : nat) : fib2 n = fib n.\nProof. unfold fib2. now rewrite <- fib_aux_eq, <- (proj2 (fib_fib' n)). Qed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32718,"user_id":null,"body":"From Coq Require Import Arith.\nRequire Import Preloaded.\n\nTheorem fib_eq (n : nat) : fib2 n = fib n.\nProof.\n  cut (forall n m, fib_aux (fib n) (fib (S n)) m = fib (n + m)); [intros H; apply (H 0)|clear].\n  intros n m; revert n; induction m; intros; [now rewrite Nat.add_0_r|].\n  unfold fib_aux; fold fib_aux.\n  replace (fib n + fib (S n)) with (fib (S (S n))); [|simpl; ring].\n  rewrite IHm; replace (S n + m) with (n + S m); ring.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32719,"user_id":null,"body":"From Coq Require Import Arith.\nFrom Coq Require Import Lia.\nRequire Import Preloaded.\n\nLemma fib_aux_add :\n  forall (n a b c d : nat), \n  fib_aux a b n + fib_aux c d n = fib_aux (a + c) (b + d) n.\nProof.\n  intros n.\n  induction n; intros.\n  - reflexivity.\n  - simpl.\n    replace (a + c + (b + d)) with ((a + b) + (c + d)) by lia.\n    apply ( IHn b (a + b) d (c + d)).\nQed.\n\nLemma induction_by_step_2 (P : nat -> Prop) :\n  P 0 ->\n  P 1 ->\n  (forall n, P n -> P (S n) -> P (S (S n))) ->\n  forall n, P n.\nProof.\n  intros H0 H1 IH n.\n  apply proj1 with (B := (P (S n))).\n  induction n.\n  - split; assumption.\n  - destruct IHn as [Hn HSn].\n    split.\n    + apply HSn.\n    + apply IH; assumption.\nQed.\n\nTheorem fib_eq (n : nat) : fib2 n = fib n.\nProof.\n  induction n using induction_by_step_2; try reflexivity.\n  replace (fib (S (S n))) with (fib (S n) + fib n) by auto.\n  rewrite <- IHn. rewrite <- IHn0.\n  unfold fib2.\n  simpl. symmetry.\n  apply fib_aux_add.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5c8b4215a99b9c000d07d7b2":[{"id":32720,"user_id":568,"body":"From Coq Require Import Arith Lia.\nRequire Import Preloaded.\n\nTheorem sum_eq (f : nat -> nat) (n : nat) : sum_tail f n = sum_simple f n.\nProof.\n  enough (forall a, sum_aux a f n = a + sum_simple f n).\n  { apply H. }\n  induction n; simpl; intros.\n  - lia.\n  - rewrite IHn. lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32721,"user_id":1076,"body":"From Coq Require Import Arith Lia.\nRequire Import Preloaded.\n\n(* Preloaded:\nFixpoint sum_simple (f : nat -> nat) (n : nat) : nat :=\n  match n with\n  | 0 => f 0\n  | S m => f n + sum_simple f m\n  end.\n\nFixpoint sum_aux (a : nat) (f : nat -> nat) (n : nat) : nat :=\n  match n with\n  | 0 => f 0 + a\n  | S m => sum_aux (f n + a) f m\n  end.\n\nDefinition sum_tail := sum_aux 0.\n*)\n\nTheorem sum_eq (f : nat -> nat) (n : nat) : sum_tail f n = sum_simple f n.\nProof.\n  change (sum_aux 0 f n = 0 + sum_simple f n); generalize 0.\n  induction n as [|n IHn]; intro a; cbn; [ | rewrite IHn ]; lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32722,"user_id":106,"body":"From Coq Require Import Arith.\nRequire Import Preloaded.\n\nTheorem sum_eq (f : nat -> nat) (n : nat) : sum_tail f n = sum_simple f n.\nProof.\n  unfold sum_tail.\n  rewrite <- (plus_O_n (sum_simple f n)); generalize 0 as t.\n  induction n; simpl; intros.\n  - ring.\n  - rewrite IHn; ring.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32723,"user_id":null,"body":"From Coq Require Import Arith.\nRequire Import Preloaded.\n\n(* Preloaded:\nFixpoint sum_simple (f : nat -> nat) (n : nat) : nat :=\n  match n with\n  | 0 => f 0\n  | S m => f n + sum_simple f m\n  end.\n\nFixpoint sum_aux (a : nat) (f : nat -> nat) (n : nat) : nat :=\n  match n with\n  | 0 => f 0 + a\n  | S m => sum_aux (f n + a) f m\n  end.\n\nDefinition sum_tail := sum_aux 0.\n*)\n\nLemma sum_aux_rec (f : nat -> nat) (n : nat) : forall a b,\n  sum_aux (a + b) f n = sum_aux a f n + b.\nProof.\n  induction n ; intros ; simpl.\n  + ring.\n  + do 2 (rewrite IHn). ring.\nQed.\n\nTheorem sum_eq (f : nat -> nat) (n : nat) : sum_tail f n = sum_simple f n.\nProof.\n  induction n ; unfold sum_tail ; simpl.\n  + ring.\n  + replace (f (S n) + 0) with (0 + f (S n)) by ring. rewrite sum_aux_rec, <- IHn.\n    fold sum_tail. ring.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32724,"user_id":null,"body":"From Coq Require Import Arith.\nRequire Import Preloaded.\n\n(* Preloaded:\nFixpoint sum_simple (f : nat -> nat) (n : nat) : nat :=\n  match n with\n  | 0 => f 0\n  | S m => f n + sum_simple f m\n  end.\n\nFixpoint sum_aux (a : nat) (f : nat -> nat) (n : nat) : nat :=\n  match n with\n  | 0 => f 0 + a\n  | S m => sum_aux (f n + a) f m\n  end.\n\nDefinition sum_tail := sum_aux 0.\n*)\n\nLemma sum_aux_plus a f n : sum_aux 0 f n + a = sum_aux a f n.\nProof.\n  generalize a; clear a.\n  elim n; clear n.\n  Search _ (_ + 0).\n  cbn; rewrite Nat.add_0_r; reflexivity.\n  intros n H a.\n  cbn; rewrite Nat.add_0_r.\n  rewrite <- (H (f (S n))); rewrite <- (H (f (S n) + a)).\n  rewrite Nat.add_assoc.\n  reflexivity.\nQed.\n\nTheorem sum_eq (f : nat -> nat) (n : nat) : sum_tail f n = sum_simple f n.\nProof.\n  elim n.\n  cbn; rewrite Nat.add_0_r; reflexivity.\n  clear n; intros n H.\n  cbn. rewrite <- sum_aux_plus.\n  unfold sum_tail in H; rewrite H.\n  rewrite Nat.add_0_r; rewrite Nat.add_comm.\n  reflexivity.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32725,"user_id":null,"body":"From Coq Require Import Arith.\nRequire Import Preloaded.\nFixpoint sum_simple (f : nat -> nat) (n : nat) : nat :=\n  match n with\n  | 0 => f 0\n  | S m => f n + sum_simple f m\n  end.\n\nFixpoint sum_aux (a : nat) (f : nat -> nat) (n : nat) : nat :=\n  match n with\n  | 0 => f 0 + a\n  | S m => sum_aux (f n + a) f m\n  end.\n\nDefinition sum_tail := sum_aux 0.\n\n\nTheorem sum_eq : forall (f : nat -> nat) (n : nat), sum_tail f n = sum_simple f n.\nProof.\n  intros f.\n  cut (forall (n:nat)(a:nat), (sum_aux a f n = a + sum_simple f n)).\n  intros.\n  induction n.\n  change (sum_tail f 0) with (f 0 + 0).\n  rewrite -> Nat.add_0_r.\n  trivial.\n  change (sum_tail f (S n)) with (sum_aux 0 f (S n)).\n  change (sum_aux 0 f (S n)) with (sum_aux (f (S n) + 0) f n).\n  rewrite -> Nat.add_0_r.\n  rewrite -> (H n (f (S n))).\n  trivial.\n  intros n.\n  induction n.\n  intros a.\n  change (sum_aux a f 0) with (f 0 + a).\n  rewrite -> Nat.add_comm.\n  trivial.\n  intros a.\n  change (sum_aux a f (S n)) with (sum_aux (f (S n) + a) f n).\n  rewrite -> (IHn (f (S n) + a)).\n  rewrite <- Nat.add_assoc.\n  rewrite <- Nat.add_comm.\n  rewrite <- Nat.add_assoc.\n  apply Nat.add_cancel_l.\n  change (sum_simple f (S n)) with (f (S n) + sum_simple f n).\n  rewrite <- Nat.add_comm.\n  reflexivity.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32726,"user_id":null,"body":"From Coq Require Import Arith Psatz.\nRequire Import Preloaded.\n\n(* Preloaded:\nFixpoint sum_simple (f : nat -> nat) (n : nat) : nat :=\n  match n with\n  | 0 => f 0\n  | S m => f n + sum_simple f m\n  end.\n\nFixpoint sum_aux (a : nat) (f : nat -> nat) (n : nat) : nat :=\n  match n with\n  | 0 => f 0 + a\n  | S m => sum_aux (f n + a) f m\n  end.\n\nDefinition sum_tail := sum_aux 0.\n*)\n\nLemma sum_aux_helper (a b : nat) (f : nat -> nat) (n : nat) :\n  sum_aux (a + b) f n = a + sum_aux b f n.\nProof.\n  generalize dependent b.\n  generalize dependent a.\n  induction n; intros a b.\n  - simpl. lia.\n  - simpl.\n    replace (f (S n) + (a + b)) with (a + (f (S n) + b)) by lia.\n    apply IHn.\nQed.\n\nTheorem sum_eq (f : nat -> nat) (n : nat) : sum_tail f n = sum_simple f n.\nProof.\n  unfold sum_tail.\n  induction n.\n  - simpl. lia.\n  - simpl.\n    rewrite sum_aux_helper.\n    rewrite IHn.\n    auto.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32727,"user_id":null,"body":"From Coq Require Import Arith.\nRequire Import Preloaded.\n\n(* Preloaded:\nFixpoint sum_simple (f : nat -> nat) (n : nat) : nat :=\n  match n with\n  | 0 => f 0\n  | S m => f n + sum_simple f m\n  end.\n\nFixpoint sum_aux (a : nat) (f : nat -> nat) (n : nat) : nat :=\n  match n with\n  | 0 => f 0 + a\n  | S m => sum_aux (f n + a) f m\n  end.\n\nDefinition sum_tail := sum_aux 0.\n*)\n\nTheorem sum_eq (f : nat -> nat) (n : nat) : sum_tail f n = sum_simple f n.\nProof. \n  cut (forall m, sum_aux m f n = m + sum_simple f n); [intros H; apply H|].\n  induction n; intros m; [simpl; ring|].\n  simpl; rewrite IHn; ring.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32728,"user_id":null,"body":"From Coq Require Import Arith Lia.\nRequire Import Preloaded.\n\nLemma sum_eq_aux acc f n :\n  sum_aux acc f n = sum_simple f n + acc.\nProof.\n  revert acc; induction n; intro acc; simpl; auto.\n  rewrite IHn; lia.\nQed.\n\nTheorem sum_eq (f : nat -> nat) (n : nat) : sum_tail f n = sum_simple f n.\nProof. unfold sum_tail; rewrite sum_eq_aux; lia. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32729,"user_id":null,"body":"From Coq Require Import Arith.\nRequire Import Preloaded.\n\n(* Preloaded:\nFixpoint sum_simple (f : nat -> nat) (n : nat) : nat :=\n  match n with\n  | 0 => f 0\n  | S m => f n + sum_simple f m\n  end.\n\nFixpoint sum_aux (a : nat) (f : nat -> nat) (n : nat) : nat :=\n  match n with\n  | 0 => f 0 + a\n  | S m => sum_aux (f n + a) f m\n  end.\n\nDefinition sum_tail := sum_aux 0.\n*)\n\n(* Any part of already accumulated sum can be \"factored out\".*)\nLemma sum_aux_a (a b : nat) (f : nat -> nat) (n : nat) :\n  sum_aux (a + b) f n = a + sum_aux b f n.\nProof.\n  generalize dependent b.\n  generalize dependent a.  \n  induction n as [| n' IHn'].\n  - (* n = 0 *)\n    simpl.\n    intros a b.\n    ring.\n  - (* n = S n' *)\n    simpl.\n    intros a b.\n    rewrite <- IHn'.\n    assert (f (S n') + (a + b) = a + (f (S n') + b)) as H.\n    + ring.\n    + rewrite H.\n      reflexivity.\nQed.\n\nTheorem sum_eq (f : nat -> nat) (n : nat) :\n  sum_tail f n = sum_simple f n.\nProof.\n  unfold sum_tail.\n  induction n as [| n' IHn'].\n  - (* n = 0 *)\n    unfold sum_tail, sum_simple, sum_aux.\n    rewrite <- plus_n_O.\n    reflexivity.\n  - (* n = S n' *)\n    unfold sum_tail in IHn'; unfold sum_tail.\n    simpl.\n    rewrite sum_aux_a. (* factor f (S n') out *)\n    rewrite <- IHn'.\n    reflexivity.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5c8b4799133e6c0009c7b096":[{"id":32730,"user_id":null,"body":"(* The following lemma from Div2 is useful:\n   ind_0_1_SS : forall P : nat -> Prop,\n      P 0 -> P 1 -> \n        (forall n : nat, P n -> P (S (S n))) -> \n          forall n : nat, P n *)\nFrom Coq Require Import Arith Psatz Div2.\nRequire Import Preloaded.\n\nLemma BetterDivMod2 : forall (e e' : nat) (b : bool),\n  div_mod2 e = (e', b) ->\n  e' = div2 e \/\\ b = Nat.odd e.\nProof.\n  intros e.\n  apply (ind_0_1_SS (fun e =>\n                       forall e' b, div_mod2 e = (e', b) ->\n                                    e' = div2 e \/\\ b = Nat.odd e)).\n  - intros e' b Hdiv.\n    inversion Hdiv.\n    auto.\n  - intros e' b Hdiv.\n    inversion Hdiv.\n    auto.\n  - clear e.\n    intros e IH e' b Hdiv.\n    inversion Hdiv.\n    destruct (div_mod2 e) as [x y] eqn:Hdiv'.\n    injection H0.\n    intros Hy Hx.\n    destruct (IH (Nat.pred e') b) as [He' Hb]. {\n      rewrite <- Hx. rewrite <- Hy. auto.\n    }\n    split; auto.\n    simpl. rewrite <- He'. simpl.\n    destruct e'.\n    + discriminate.\n    + reflexivity.\nQed.\n\nLemma powDouble : forall (e b : nat),\n  b ^ (2 * e) = (b * b) ^ e.\nProof.\n  intros e b.\n  induction e.\n  - reflexivity.\n  - replace (2 * S e) with (S (S (e + e))) by lia.\n    simpl.\n    rewrite <- IHe.\n    replace (2 * e) with (e + e) by lia.\n    lia.\nQed.\n  \nTheorem pow_eq_ge : forall e, forall q b, q >= e -> pow_sqr_aux q b e = b ^ e.\nProof.\n  intros e.\n  apply (lt_wf_ind e); clear e.\n  intros n IH.\n  destruct n.\n  - intros q b _.\n    destruct q; auto.\n  - intros q b Hq.\n    destruct q eqn:Hq0.\n    + inversion Hq.\n    + assert (Hneq0: (S n0) <> 0) by lia.\n      destruct (div_mod2 (S n)) as [e' r] eqn:Hdiv.\n      destruct (BetterDivMod2 _ _ _ Hdiv) as [He' Hr].\n      unfold pow_sqr_aux. rewrite Hdiv.\n      destruct (Nat.odd (S n)) eqn:Hodd; rewrite Hr; fold pow_sqr_aux.\n      * simpl. rewrite IH.\n        -- assert (He'n: e' * 2 = n). {\n             rewrite He'.\n             rewrite Nat.odd_spec in Hodd.\n             destruct Hodd as [m Hn].\n             rewrite Hn.\n             replace (2 * m + 1) with (S (2 * m)) in * by lia.\n             rewrite Nat.div2_succ_double.\n             injection Hn. intros H. rewrite H. lia.\n           }\n           rewrite <- He'n.\n           rewrite <- powDouble.\n           replace (2 * e') with (e' * 2) by lia.\n           auto.\n        -- rewrite He'.\n           apply Nat.lt_div2.\n           lia.\n        -- rewrite He'.\n           unfold \">=\" in *.\n           assert (H: Nat.div2 (S n) <= n). {\n             apply Nat.le_div2.\n           }\n           enough (n <= n0). {\n             apply le_trans with n; auto.\n           }\n           lia.\n      * simpl. rewrite IH.\n        -- assert (He'n: e' * 2 = n + 1). {\n             rewrite He'.\n             unfold Nat.odd in Hodd.\n             rename Hodd into Heven.\n             rewrite Bool.negb_false_iff in Heven.\n             rewrite Nat.even_spec in Heven.\n             destruct Heven as [m Hn].\n             rewrite Hn.\n             rewrite Nat.div2_double.\n             lia.\n           }\n           enough (b * b ^ n = b ^ (n + 1)). {\n             rewrite H. rewrite <- He'n.\n             symmetry.\n             replace (e' * 2) with (2 * e') by lia.\n             apply powDouble.\n           }\n           replace (n + 1) with (S n) by lia.\n           reflexivity.\n        -- rewrite He'.\n           apply Nat.lt_div2.\n           lia.\n        -- rewrite He'.\n           unfold \">=\" in *.\n           assert (H: Nat.div2 (S n) <= n). {\n             apply Nat.le_div2.\n           }\n           enough (n <= n0). {\n             apply le_trans with n; auto.\n           }\n           lia.\nQed.             \n  \nTheorem pow_eq (b e : nat) : pow_sqr b e = b ^ e.\nProof.\n  unfold pow_sqr.\n  apply pow_eq_ge.\n  lia.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32731,"user_id":null,"body":"(* The following lemma from Div2 is useful:\n   ind_0_1_SS : forall P : nat -> Prop,\n      P 0 -> P 1 -> \n        (forall n : nat, P n -> P (S (S n))) -> \n          forall n : nat, P n *)\nFrom Coq Require Import Arith Div2.\nRequire Import Preloaded.\n\n(* Preloaded:\nFixpoint div_mod2 (n : nat) : (nat * bool) :=\n  match n with\n  | 0 => (0, false)\n  | 1 => (0, true)\n  | S (S n) => let (a, b) := div_mod2 n in (S a, b)\n  end.\n\nFixpoint pow_sqr_aux (k b e : nat) : nat :=\n  match k, e with\n  | 0, _ => 1\n  | _, 0 => 1\n  | S k, _ => match div_mod2 e with\n              | (e', false) => pow_sqr_aux k (b * b) e'\n              | (e', true) => b * pow_sqr_aux k (b * b) e'\n              end\n  end.\n  \nDefinition pow_sqr (b e : nat) : nat := pow_sqr_aux e b e.\n*)\n\nRequire Import Arith PeanoNat Even Lia Ring Wf_nat.\nImport Nat.\n\nLemma div_mod2_alt (n : nat) : div_mod2 n = (n \/ 2, n mod 2 =? 1).\nProof.\n  induction n using ind_0_1_SS; [unfold div_mod2; auto | unfold div_mod2; auto |].\n  simpl div_mod2. rewrite IHn.\n  assert (2 <> 0) as neq2 by auto.\n  destruct (Even_or_Odd n) as [H | H].\n  - destruct H. rewrite mul_comm in H. rewrite H.\n    assert (S (x * 2 \/ 2) = S x) as l1\n      by (rewrite (div_mul _ 2 neq2); auto).\n    assert (S (S (x * 2)) \/ 2 = S x) as l2\n      by (replace (S (S (x * 2))) with (S x * 2) by lia; rewrite (div_mul _ 2 neq2); auto).\n    rewrite l1; rewrite l2.\n    replace (S (S (x * 2))) with (S x * 2) by lia.\n    repeat rewrite (mod_mul _ 2 neq2).\n    auto.\n  - destruct H. replace (2 * x + 1) with (1 + x * 2) in H by lia. rewrite H.\n    assert (1 \/ 2 = 0) as ds1 by (assert (1 < 2) as l by auto; exact (div_small 1 2 l)).\n    assert (S ((1 + x * 2) \/ 2) = S x) as l1\n      by (rewrite (div_add 1 _ 2 neq2); rewrite ds1; lia).\n    assert (S (S (1 + x * 2)) \/ 2 = S x) as l2\n      by (replace (S (S (1 + x * 2))) with (1 + S x * 2) by lia; rewrite (div_add 1 _ 2 neq2); rewrite ds1; lia).\n    rewrite l1; rewrite l2.\n    replace (S (S (1 + x * 2))) with (1 + S x * 2) by lia.\n    repeat rewrite (mod_add 1 _ 2 neq2).\n    auto.\nQed.\n\nTheorem pow_eq_ge : forall e, forall q b, q >= e -> pow_sqr_aux q b e = b ^ e.\nProof.\n  intros e.\n  apply (lt_wf_ind e).\n  destruct n.\n  - intros; destruct q; simpl; auto.\n  - intros H q b Hq.\n    assert (q <> 0) as qne0 by lia.\n    simpl pow.\n    assert (exists w, q = S (n + w)) as Hw\n      by (assert (S n <= q) as Hq_le by lia; exists (q - S n); lia).\n    destruct Hw as [w Hw].\n    rewrite Hw.\n    simpl pow_sqr_aux.\n    destruct n.\n    + simpl.\n      rewrite (H 0); try lia.\n      simpl pow. auto.\n    + rewrite div_mod2_alt.\n      destruct (Even_or_Odd n) as [EO | EO].\n      * destruct EO as [x EO]. rewrite mul_comm in EO. \n        rewrite EO.\n        assert (2 <> 0) as neq2 by auto.\n        assert (1 \/ 2 = 0) as ds1 by (assert (1 < 2) as l by auto; exact (div_small 1 2 l)).\n        repeat rewrite (div_mul _ 2 neq2); repeat rewrite (mod_mul _ 2 neq2).\n        simpl eqb.\n        assert (S x < S (S n)) as l1 by lia.\n        rewrite (H (S x) l1 (S (x * 2) + w) (b * b)); try lia.\n        (* Goal: (b * b) ^ S x = b * b ^ S (x * 2) *)\n        rewrite <- pow_2_r.\n        rewrite <- pow_mul_r.\n        replace (2 * S x) with (S (S (x * 2))) by ring.\n        simpl pow.\n        auto.\n      * destruct EO as [x EO]. replace (2 * x + 1) with (1 + x * 2) in EO by ring.\n        rewrite EO.\n        assert (2 <> 0) as neq2 by auto.\n        assert (1 \/ 2 = 0) as ds1 by (assert (1 < 2) as l by auto; exact (div_small 1 2 l)).\n        assert ((1 + x * 2) mod 2 =? 1 = true) as modeq1\n          by (rewrite (mod_add 1 _ 2 neq2); auto).\n        rewrite modeq1.\n        replace ((1 + x * 2) \/ 2) with x\n          by (rewrite (div_add 1 _ 2 neq2); rewrite ds1; auto).\n        assert (S x < S (S n)) as l1 by lia.\n        rewrite (H (S x) l1 (S (1 + x * 2) + w) (b * b)); try lia.\n        (* Goal: b * (b * b) ^ S x = b * b ^ S (1 + x * 2) *)\n        rewrite <- pow_2_r.\n        rewrite <- pow_mul_r.\n        replace (2 * S x) with (S (S (x * 2))) by ring.\n        replace (1 + x * 2) with (S (x * 2)) by ring.\n        simpl pow.\n        auto.\nQed.\n\nTheorem pow_eq (b e : nat) : pow_sqr b e = b ^ e.\nProof.\n  unfold pow_sqr.\n  apply (pow_eq_ge e e b); lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32732,"user_id":null,"body":"From Coq Require Import Arith Div2 ssreflect Lia.\nRequire Import Preloaded.\n\nLemma div_mod2_aux (n : nat) :\n  n = 2 * (fst (div_mod2 n)) + Nat.b2n (snd (div_mod2 n)).\nProof.\n  elim\/ind_0_1_SS: n => [\/\/|\/\/|\/= n].\n  case: (div_mod2 n) => m b \/=.\n  lia.\nQed.\n\nLemma div_mod2_eq (n m : nat) (b : bool) :\n  div_mod2 n = (m, b) -> n = 2 * m + Nat.b2n b.\nProof.\n  rewrite {2}(div_mod2_aux n).\n  case eqdiv : (div_mod2 n) => [m' b'].\n  by move=> [-> ->].\nQed.\n\nLemma pow_sqr_aux_eq (b e k : nat) :\n    e <= k ->\n  pow_sqr_aux k b e = b ^ e.\nProof.\n  elim: k b e => [b [\/\/|]|k IHk \/= b]; first by lia.\n  move=> [\/\/|[|e \/le_S_n leqSek] \/=].\n    by case: k IHk.\n  case diveq : (div_mod2 e) => [m r] \/=.\n  rewrite IHk.\n    by move: diveq leqSek => \/div_mod2_eq ->; lia.\n  case: r diveq => \/div_mod2_eq -> \/=; rewrite !plus_0_r Nat.pow_mul_l.\n    by rewrite 2!Nat.pow_add_r Nat.pow_1_r; lia.\n  by rewrite Nat.pow_add_r; lia.\nQed.\n\nTheorem pow_eq (b e : nat) : pow_sqr b e = b ^ e.\nProof. by rewrite \/pow_sqr pow_sqr_aux_eq. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32733,"user_id":null,"body":"(* The following lemma from Div2 is useful:\n   ind_0_1_SS : forall P : nat -> Prop,\n      P 0 -> P 1 -> \n        (forall n : nat, P n -> P (S (S n))) -> \n          forall n : nat, P n *)\nFrom Coq Require Import Arith Div2 Lia.\nRequire Import Preloaded.\n\n(* Preloaded:\nFixpoint div_mod2 (n : nat) : (nat * bool) :=\n  match n with\n  | 0 => (0, false)\n  | 1 => (0, true)\n  | S (S n) => let (a, b) := div_mod2 n in (S a, b)\n  end.\n\nFixpoint pow_sqr_aux (k b e : nat) : nat :=\n  match k, e with\n  | 0, _ => 1\n  | _, 0 => 1\n  | S k, _ => match div_mod2 e with\n              | (e', false) => pow_sqr_aux k (b * b) e'\n              | (e', true) => b * pow_sqr_aux k (b * b) e'\n              end\n  end.\n  \nDefinition pow_sqr (b e : nat) : nat := pow_sqr_aux e b e.\n*)\n\nLemma div_mod2_spec n : let '(n', b) := div_mod2 n in n = if b then S (2*n') else 2*n'.\nProof.\n  pose proof (Nat.le_refl n) as l.\n  revert l.\n  generalize n at 1 3 4.\n  induction n.\n  - intros n l.\n    rewrite <- (le_n_0_eq _ l).\n    cbn. constructor.\n  - intros n' l.\n    do 2 (destruct n' as [| n'] ; [reflexivity|..]).\n    cbn.\n    specialize (IHn n').\n    destruct (div_mod2 n') as [m []].\n    all: lia.\nQed.\n\nLemma square_pow m n : (m*m)^n = m^(2*n).\nProof.\n  induction n.\n  1: reflexivity.\n  replace (2* S n) with (S (S (2*n))) by lia.\n  cbn -[Nat.mul].\n  rewrite IHn.\n  lia.\nQed.\n\nTheorem pow_eq (b e : nat) : pow_sqr b e = b ^ e.\nProof.\n  unfold pow_sqr.\n  pose proof (Nat.le_refl e) as l.\n  revert l.\n  generalize e at 1 4 5.\n  induction e in b |- *.\n  - intros e l.\n    rewrite <- (le_n_0_eq _ l).\n    reflexivity.\n  - intros [] l.\n    1: reflexivity.\n    apply le_S_n in l.\n    cbn.\n    destruct n.\n    1: now rewrite IHe.\n    cbn.\n    pose proof (div_mod2_spec n).\n    destruct (div_mod2 n) as [m []] ; subst.\n    all: rewrite IHe ; [|lia].\n    all: cbn -[Nat.mul] ; rewrite square_pow ; lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32734,"user_id":null,"body":"(* The following lemma from Div2 is useful:\n   ind_0_1_SS : forall P : nat -> Prop,\n      P 0 -> P 1 -> \n        (forall n : nat, P n -> P (S (S n))) -> \n          forall n : nat, P n *)\nFrom Coq Require Import Arith Div2 Lia.\nRequire Import Preloaded.\n\n(* Preloaded:\nFixpoint div_mod2 (n : nat) : (nat * bool) :=\n  match n with\n  | 0 => (0, false)\n  | 1 => (0, true)\n  | S (S n) => let (a, b) := div_mod2 n in (S a, b)\n  end.\n\nFixpoint pow_sqr_aux (k b e : nat) : nat :=\n  match k, e with\n  | 0, _ => 1\n  | _, 0 => 1\n  | S k, _ => match div_mod2 e with\n              | (e', false) => pow_sqr_aux k (b * b) e'\n              | (e', true) => b * pow_sqr_aux k (b * b) e'\n              end\n  end.\n  \nDefinition pow_sqr (b e : nat) : nat := pow_sqr_aux e b e.\n*)\n\nLemma div_mod2_spec : forall n k b, div_mod2 n = (k, b) ->\n    n = 2 * k + if b then 1 else 0.\nProof.\n  intros.\n  generalize dependent k.\n  generalize dependent b.\n  induction n using ind_0_1_SS; intros.\n  + simpl in H. inversion H. subst. reflexivity.\n  + simpl in H. inversion H. subst. reflexivity.\n  + simpl in H. destruct (div_mod2 n) eqn:Ediv.\n    inversion H. subst. clear H.\n    replace (2* S n0) with (2*n0 + 2) by lia.\n    replace\n      (2 * n0 + 2 + (if b then 1 else 0))\n    with \n      (2 * n0 + (if b then 1 else 0) + 2)\n    by lia.\n    rewrite IHn with b n0; try reflexivity.\n    lia.\nQed.\n\nLemma pow_sqr_aux_lemma : forall k b e, e <= k -> pow_sqr_aux k b e = b ^ e.\nProof.\n  intros.\n  generalize dependent e.\n  generalize dependent b.\n  induction k; intros.\n  + assert (e = 0) by lia. subst. reflexivity.\n  + simpl. destruct e; try reflexivity.\n    destruct (div_mod2 (S e)) eqn:Ediv.\n    destruct b0.\n    apply div_mod2_spec in Ediv.\n    - rewrite IHk; try lia. replace (b*b) with (b^2) by\n        (simpl; rewrite mult_1_r; reflexivity).\n      rewrite <- Nat.pow_mul_r.\n      rewrite <- Nat.pow_succ_r; try lia.\n      replace (2 * n + 1) with (S (2*n)) in Ediv by lia.\n      rewrite Ediv.\n      reflexivity.\n    - apply div_mod2_spec in Ediv.\n      rewrite IHk; try lia.\n      replace (b*b) with (b^2) by\n        (simpl; rewrite mult_1_r; reflexivity).\n      rewrite <- Nat.pow_mul_r.\n      rewrite Nat.add_0_r in Ediv.\n      rewrite Ediv.\n      reflexivity.\nQed.\n\nTheorem pow_eq (b e : nat) : pow_sqr b e = b ^ e.\nProof.\n  intros.\n  apply pow_sqr_aux_lemma.\n  lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32735,"user_id":null,"body":"From Coq Require Import Arith Div2 Omega.\nRequire Import Preloaded.\n\nSection StrongInduction.\n\n  Variable P:nat -> Prop.\n\n  (** The stronger inductive hypothesis given in strong induction. The standard\n  [nat ] induction principle provides only n = pred m, with [P 0] required\n  separately. *)\n  Hypothesis IH : forall m, (forall n, n < m -> P n) -> P m.\n\n  Lemma P0 : P 0.\n  Proof.\n    apply IH; intros.\n    exfalso; inversion H.\n  Qed.\n\n  Hint Resolve P0.\n\n  Lemma pred_increasing : forall n m,\n      n <= m ->\n      Nat.pred n <= Nat.pred m.\n  Proof.\n    induction n; cbn; intros.\n    apply le_0_n.\n    induction H; subst; cbn; eauto.\n    destruct m; eauto.\n  Qed.\n\n  Hint Resolve le_S_n.\n\n  (** * Strengthen the induction hypothesis. *)\n\n  Local Lemma strong_induction_all : forall n,\n      (forall m, m <= n -> P m).\n  Proof.\n    induction n; intros;\n      match goal with\n      | [ H: _ <= _ |- _ ] =>\n        inversion H\n      end; eauto.\n  Qed.\n\n  Theorem strong_induction : forall n, P n.\n  Proof.\n    eauto using strong_induction_all.\n  Qed.\n\nEnd StrongInduction.\n\nTactic Notation \"strong\" \"induction\" ident(n) := induction n using strong_induction.\n\nLemma split_even_odd: forall n,\n  exists k,\n    n = 2 * k \\\/ n = 2 * k + 1.\nProof. \n  intros.\n  induction n.\n  - exists 0.\n    auto.\n  - inversion IHn.\n    inversion H.\n    + exists x.\n      omega.\n    + exists (x + 1).\n      omega.\nQed.\n\nLemma my_i: forall (P : nat -> Prop),\n  P 0 -> \n  (forall n, P n -> P (2 * n + 1)) ->\n  (forall n, P n -> P (2 * n)) ->\n  forall n, P n.\nProof.\n  intros.\n  strong induction n.\n  specialize split_even_odd with n.\n  intros.\n  inversion H3.\n  inversion H4.\n  - subst.\n    apply H1.\n    destruct x.\n    + auto.\n    + apply H2.\n      omega.\n  - subst.\n    apply H0.\n    destruct x.\n    + auto.\n    + apply H2.\n      omega.\nQed.\n\nLemma fst_div_mod2: forall n,\n  fst (div_mod2 n) = Nat.div2 n.\nProof.\n  intros.\n  induction n as [ | | n IHn] using ind_0_1_SS.\n  - auto.\n  - auto.\n  - simpl.\n    destruct (div_mod2 n) in *.\n    simpl in *.\n    auto.\nQed.\n\nLemma snd_div_mod2: forall n,\n  snd (div_mod2 n) = Nat.odd n.\nProof.\n  intros.\n  induction n as [ | | n IHn] using ind_0_1_SS.\n  - auto.\n  - auto.\n  - simpl.\n    rewrite <- Nat.negb_even.\n    simpl.\n    rewrite Nat.negb_even.\n    rewrite <- IHn.\n    destruct (div_mod2 n).\n    auto.\nQed.\n\nLemma div_mod2': forall n,\n  (div_mod2 n) = (Nat.div2 n, Nat.odd n).\nProof.\n  intros.\n  specialize fst_div_mod2 with n.\n  specialize snd_div_mod2 with n.\n  intros.\n  destruct (div_mod2 n).\n  rewrite <- H.\n  rewrite <- H0.\n  auto.\nQed.\n\nLemma pow_sqr_aux_irr (x b e : nat) :\n  pow_sqr_aux (e + x) b e = pow_sqr_aux e b e.\nProof.\n  generalize dependent x.\n  generalize dependent b.\n  strong induction e; intros.\n  specialize split_even_odd with e.\n  intros.\n  inversion H0.\n  inversion H1.\n  - subst.\n    simpl.\n    rewrite <- plus_n_O.\n    destruct x0.\n    { destruct x; auto. }\n    simpl.\n    replace (x0 + S x0) with (S (x0 + x0)) by auto.\n    rewrite div_mod2'.\n    replace (Nat.odd (x0 + x0)) with false.\n    replace (Nat.div2 (x0 + x0)) with x0.\n    assert (pow_sqr_aux (S (x0 + x0) + x) (b * b) (S x0) = pow_sqr_aux (S x0) (b * b) (S x0)).\n    {\n      replace (S (x0 + x0) + x) with ((S x0) + (x0 + x)) by omega.\n      apply H.\n      omega.\n    }\n    assert (pow_sqr_aux (S (x0 + x0)) (b * b) (S x0) = pow_sqr_aux (S x0) (b * b) (S x0)).\n    {\n      replace (S (x0 + x0)) with (S x0 + x0) by omega.\n      apply H.\n      omega.\n    }\n    rewrite H2.\n    rewrite H3.\n    auto.\n    replace (x0 + x0) with (2 * x0) by omega.\n    rewrite Nat.div2_double.\n    auto.\n    replace (x0 + x0) with (0 + (2 * x0)) by omega.\n    rewrite Nat.odd_add_mul_2.\n    auto.\n  - subst.\n    simpl.\n    rewrite <- plus_n_O.\n    destruct x0.\n    { destruct x; auto. }\n    simpl.\n    replace (x0 + S x0 + 1) with (S (x0 + x0 + 1)).\n    rewrite div_mod2'.\n    replace (Nat.odd (x0 + x0 + 1)) with true.\n    replace (Nat.div2 (x0 + x0 + 1)) with x0.\n    assert (pow_sqr_aux (S (x0 + x0 + 1) + x) (b * b) (S x0) = pow_sqr_aux (S x0) (b * b) (S x0)).\n    {\n      replace (S (x0 + x0 + 1) + x) with (S x0 + (x0 + 1 + x)) by omega.\n      apply H.\n      omega.\n    }\n    assert (pow_sqr_aux (S (x0 + x0 + 1)) (b * b) (S x0) = pow_sqr_aux (S x0) (b * b) (S x0)).\n    {\n      replace (S (x0 + x0 + 1)) with (S x0 + (x0 + 1)) by omega.\n      apply H.\n      omega.\n    }\n    rewrite H2.\n    rewrite H3.\n    auto.\n    replace (x0 + x0 + 1) with (S (2 * x0)) by omega.\n    rewrite Nat.div2_succ_double.\n    auto.\n    replace (x0 + x0 + 1) with (1 + (2 * x0)) by omega.\n    rewrite Nat.odd_add_mul_2.\n    auto.\n    omega.\nQed.\n\n\nTheorem pow_eq (b e : nat) : pow_sqr b e = b ^ e.\nProof.\n  generalize dependent b.\n  unfold pow_sqr.\n  strong induction e.\n  specialize split_even_odd with e.\n  intro.\n  inversion H0.\n  inversion H1; intros.\n  - subst.\n    simpl.\n    rewrite <- plus_n_O.\n    destruct x; auto.\n    assert (pow_sqr_aux (S x + S x) b (S x + S x) = pow_sqr_aux (S x) (b * b) (S x)).\n    {\n      remember (pow_sqr_aux (S x) (b * b) (S x)).\n      simpl.\n      replace (x + S x) with (S (x + x)) by omega.\n      rewrite div_mod2'.\n      replace (Nat.odd (x + x)) with false.\n      replace (Nat.div2 (x + x)) with x.\n      subst.\n      replace (S (x + x)) with (S x + x) by omega.\n      apply pow_sqr_aux_irr.\n      replace (x + x) with (2 * x) by omega.\n      rewrite Nat.div2_double.\n      auto.\n      replace (x + x) with (0 + (2 * x)) by omega.\n      rewrite Nat.odd_add_mul_2.\n      auto.\n    }\n    rewrite H2.\n    rewrite H.\n    rewrite Nat.pow_add_r.\n    rewrite Nat.pow_mul_l.\n    auto.\n    omega.\n  - subst.\n    simpl.\n    rewrite <- plus_n_O.\n    destruct x; auto.\n    assert (pow_sqr_aux (S x + S x + 1) b (S x + S x + 1) = b * pow_sqr_aux (S x) (b * b) (S x)).\n    {\n      remember (pow_sqr_aux (S x) (b * b) (S x)).\n      simpl.\n      replace (x + S x + 1) with (S (x + x + 1)) by omega.\n      rewrite div_mod2'.\n      replace (Nat.odd (x + x + 1)) with true.\n      replace (Nat.div2 (x + x + 1)) with x.\n      subst.\n      replace (S (x + x + 1)) with (S x + (x + 1)) by omega.\n      rewrite pow_sqr_aux_irr.\n      auto.\n      replace (x + x + 1) with (S (2 * x)) by omega.\n      rewrite Nat.div2_succ_double.\n      auto.\n      replace (x + x + 1) with (1 + (2 * x)) by omega.\n      rewrite Nat.odd_add_mul_2.\n      auto.\n    }\n    rewrite H2.\n    rewrite H.\n    rewrite Nat.pow_add_r.\n    rewrite Nat.pow_add_r.\n    rewrite Nat.pow_mul_l.\n    rewrite Nat.pow_1_r.\n    apply Nat.mul_comm.\n    omega.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32736,"user_id":null,"body":"(* The following lemma from Div2 is useful:\n   ind_0_1_SS : forall P : nat -> Prop,\n      P 0 -> P 1 -> \n        (forall n : nat, P n -> P (S (S n))) -> \n          forall n : nat, P n *)\nFrom Coq Require Import Arith Div2.\nRequire Import Preloaded.\n\n(* Preloaded:\nFixpoint div_mod2 (n : nat) : (nat * bool) :=\n  match n with\n  | 0 => (0, false)\n  | 1 => (0, true)\n  | S (S n) => let (a, b) := div_mod2 n in (S a, b)\n  end.\n\nFixpoint pow_sqr_aux (k b e : nat) : nat :=\n  match k, e with\n  | 0, _ => 1\n  | _, 0 => 1\n  | S k, _ => match div_mod2 e with\n              | (e', false) => pow_sqr_aux k (b * b) e'\n              | (e', true) => b * pow_sqr_aux k (b * b) e'\n              end\n  end.\n  \nDefinition pow_sqr (b e : nat) : nat := pow_sqr_aux e b e.\n*)\n\nTheorem div_mod2_eq n : div_mod2 n = (div2 n, Nat.odd n).\nProof.\n  induction n using ind_0_1_SS.\n  - reflexivity.\n  - reflexivity.\n  - simpl.\n    rewrite IHn.\n    f_equal.\nQed.\n\n\nTheorem pow_sqr_aux_sub (k b e : nat) : k >= e -> pow_sqr_aux k b e = b ^ e.\nProof.\n  generalize b e ; clear b e.\n  induction k.\n  - intros.\n    apply Nat.le_0_r in H.\n    rewrite H.\n    reflexivity.\n  - intros.\n    destruct e.\n    + reflexivity.\n    + unfold pow_sqr_aux.\n      fold pow_sqr_aux.\n      remember (S e) as Se.\n      case_eq (div_mod2 (Se)).\n      rewrite div_mod2_eq.\n      intros n b0 H0.\n      injection H0.\n      intros.\n      assert (k >= n).\n        rewrite <- H2.\n        rewrite HeqSe.\n        apply le_trans with e.\n        apply Nat.le_div2.\n        apply le_S_n.\n        rewrite <- HeqSe.        \n        apply H.\n      apply IHk with (b * b) n in H3.\n      rewrite H3.\n      rewrite <- Nat.pow_2_r.\n      rewrite <- Nat.pow_mul_r.\n      rewrite <- H2.\n      rewrite <- Nat.pow_succ_r'.\n      destruct b0.\n      * f_equal.\n        rewrite <- Nat.add_1_r.\n        rewrite Nat.div2_odd.\n        rewrite H1.\n        reflexivity.\n      * f_equal.\n        rewrite Nat.div2_odd.\n        rewrite H1.\n        rewrite Nat.add_0_r.\n        reflexivity.\nQed.\n\nTheorem pow_eq (b e : nat) : pow_sqr b e = b ^ e.\nProof.\n  unfold pow_sqr.\n  apply pow_sqr_aux_sub.\n  apply le_refl.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32737,"user_id":null,"body":"From Coq Require Import Arith Div2.\nRequire Import Preloaded.\nRequire Import Coq.micromega.Lia.\n\nLtac crush :=\n  let sintuition := simpl in *; intuition in\n  let rewriter := (\n        autorewrite with arith in *;\n        repeat (match goal with\n                | [ H : _ |- _ ] => rewrite H by crush\n                end; autorewrite with arith in * )) in\n  sintuition; rewriter; sintuition; try lia.\n\nLemma div_mod2_spec (n : nat) : div_mod2 n = (Nat.div2 n, Nat.odd n).\nProof using.\n  Hint Rewrite Nat.odd_succ_succ : arith.\n  induction n using ind_0_1_SS; crush.\nQed.\n\nLemma pow_div2_odd (b e : nat) : Nat.odd e = true -> b * (b * b) ^ Nat.div2 e = b ^ e.\nProof using.\n  intros; rewrite Nat.pow_mul_l, <- Nat.pow_add_r, <- Nat.pow_succ_r'; f_equal; rewrite Nat.div2_odd; crush.\nQed.\n\nLemma pow_div2_even (b e : nat) : Nat.odd e = false -> (b * b) ^ Nat.div2 e = b ^ e.\nProof using.\n  intros; rewrite Nat.pow_mul_l, <- Nat.pow_add_r; f_equal; rewrite Nat.div2_odd; crush.\nQed.\n\nLemma pow_eq_aux (k b e : nat) : e <= k -> pow_sqr_aux k b e = b ^ e.\nProof using.\n  Hint Resolve Nat.div2_decr pow_div2_even pow_div2_odd : arith.\n  Hint Rewrite div_mod2_spec : arith.\n  Hint Extern 1 =>\n  match goal with\n    [ H : _ <= 0 |- _ ] => inversion H; [idtac]; clear H; try subst\n  end : arith.\n  generalize b e; induction k; crush;\n    repeat match goal with\n           | [ |- context[match ?E with 0 => _ | _ => _ end] ] => destruct E\n           | [ |- context[if ?C then _ else _] ] => destruct C eqn:?H; intuition\n           end; crush.\nQed.\n\nTheorem pow_eq (b e : nat) : pow_sqr b e = b ^ e.\nProof using.\n  now apply pow_eq_aux.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32738,"user_id":null,"body":"(* The following lemma from Div2 is useful:\n   ind_0_1_SS : forall P : nat -> Prop,\n      P 0 -> P 1 -> \n        (forall n : nat, P n -> P (S (S n))) -> \n          forall n : nat, P n *)\nFrom Coq Require Import Arith Div2.\nRequire Import Preloaded.\n\nLemma div_mod2_correct n : forall a b, div_mod2 n = (a, b) ->\n  n = 2 * a + if b then 1 else 0.\nProof.\n  induction n using ind_0_1_SS; intros.\n  - simpl in H. inversion H. reflexivity.\n  - simpl in H. inversion H. reflexivity.\n  - simpl in H.\n    destruct (div_mod2 n) as (c, d) eqn:Hdiv.\n    inversion H; subst.\n    rewrite (IHn _ _ eq_refl).\n    Search (_ * S _).\n    rewrite Nat.mul_succ_r.\n    rewrite (Nat.add_comm _ 2). reflexivity.\nQed.\n\nLemma div_mod2_lt n : 0 < n ->\n  forall a b, div_mod2 n = (a, b) ->\n  a < n.\nProof.\n  induction n using ind_0_1_SS; intros.\n  - inversion H.\n  - simpl in H0. inversion H0. apply le_n.\n  - simpl in H0.\n    destruct (div_mod2 n) as (c, d) eqn:Hdiv.\n    inversion H0; subst.\n    destruct n.\n    + inversion Hdiv; subst. apply le_n.\n    + apply le_n_S, le_S. eapply IHn; try reflexivity. apply le_n_S, le_0_n.\nQed.\n\nTheorem pow_eq (b e : nat) : pow_sqr b e = b ^ e.\nProof.\n  unfold pow_sqr.\n  assert (e <= e) by reflexivity. revert H.\n  generalize e at 2 3 as k.\n  intros k. revert b e. induction k; intros.\n  - inversion H. reflexivity.\n  - simpl.\n    destruct e.\n    + reflexivity.\n    + destruct (div_mod2 (S e)) as (x, y) eqn:Hdiv.\n      apply div_mod2_lt in Hdiv as H0; try (apply le_n_S, le_0_n).\n      apply div_mod2_correct in Hdiv.\n      rewrite IHk.\n      * rewrite Hdiv. rewrite Nat.pow_add_r.\n        rewrite Nat.pow_mul_r. simpl. rewrite Nat.mul_1_r.\n        destruct y.\n        -- rewrite Nat.pow_1_r. apply Nat.mul_comm.\n        -- simpl. rewrite Nat.mul_1_r. reflexivity.\n      * apply le_S_n in H0. rewrite H0. apply le_S_n in H. assumption.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32739,"user_id":null,"body":"(* The following lemma from Div2 is useful:\n   ind_0_1_SS : forall P : nat -> Prop,\n      P 0 -> P 1 -> \n        (forall n : nat, P n -> P (S (S n))) -> \n          forall n : nat, P n *)\nFrom Coq Require Import Arith Div2.\nRequire Import Coq.omega.Omega.\n\n(* ========================================================================= *)\n(* Require Import Preloaded. *)\n(* Preloaded: *)\nFixpoint div_mod2 (n : nat) : (nat * bool) :=\n  match n with\n  | 0 => (0, false)\n  | 1 => (0, true)\n  | S (S n) => let (a, b) := div_mod2 n in (S a, b)\n  end.\n\nFixpoint pow_sqr_aux (k b e : nat) : nat :=\n  match k, e with\n  | 0, _ => 1\n  | _, 0 => 1\n  | S k, _ => match div_mod2 e with\n              | (e', false) => pow_sqr_aux k (b * b) e'\n              | (e', true) => b * pow_sqr_aux k (b * b) e'\n              end\n  end.\n  \nDefinition pow_sqr (b e : nat) : nat := pow_sqr_aux e b e.\n(* =========================================================================*)\n\nLtac inv H := inversion H; subst; clear H.\n\nFixpoint div2 (n : nat) : nat :=\n  match n with\n  | 0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end.\nFixpoint mod2 (n : nat) : bool :=\n  match n with\n  | 0 => false\n  | 1 => true\n  | S (S n) => mod2 n\n  end.\n\nLemma div_mod2__div2_mod2 :\n  forall n, div_mod2 n = (div2 n, mod2 n).\nProof.\n  intros.\n  apply ind_0_1_SS with (n := n); simpl; intros; auto.\n  rewrite H.\n  auto.\nQed.\n\nCorollary div2_double : forall n, div2 (n + n) = n.\nProof.\n  intros.\n  induction n; simpl; auto.\n  rewrite <- plus_n_Sm.\n  rewrite IHn.\n  reflexivity.\nQed.\nCorollary div2_double_plus_one : forall n, div2 (S (n + n)) = n.\nProof.\n  intros.\n  induction n; simpl; auto.\n  rewrite <- plus_n_Sm.\n  rewrite IHn.\n  reflexivity.\nQed.\n  \nCorollary mod2_double : forall n, mod2 (n + n) = false.\nProof.\n  intros.\n  induction n; simpl; auto.\n  rewrite <- plus_n_Sm.\n  rewrite IHn.\n  reflexivity.\nQed.\nCorollary mod2_double_plus_one : forall n, mod2 (S (n + n)) = true.\nProof.\n  intros.\n  induction n; simpl; auto.\n  rewrite <- plus_n_Sm.\n  rewrite IHn.\n  reflexivity.\nQed.\n  \nLemma pow_sqr_double :\n  forall b e k,\n  pow_sqr_aux (S k) b (e + e) = pow_sqr_aux k (b * b) e.\nProof.\n  intros.\n  simpl.\n  destruct e; simpl.\n  - destruct k; auto.\n  - rewrite <- plus_n_Sm.\n    rewrite (div_mod2__div2_mod2 (e + e)).\n    rewrite mod2_double.\n    rewrite div2_double.\n    reflexivity.\nQed.\n\nLemma pow_sqr_double_plus_one :\n  forall b e k,\n  pow_sqr_aux (S k) b (S (e + e)) = b * pow_sqr_aux k (b * b) e.\nProof.\n  intros.\n  simpl.\n  destruct e; simpl.\n  - destruct k; auto.\n  - rewrite <- plus_n_Sm.\n    rewrite (div_mod2__div2_mod2).\n    rewrite mod2_double_plus_one.\n    rewrite div2_double_plus_one.\n    reflexivity.\nQed.\n\nLemma pow_sqr_one_e :\n  forall e k,\n  pow_sqr_aux k 1 e = 1.\nProof.\n  intros e k. revert e.\n  induction k; simpl; intros; auto.\n  destruct e; auto.\n  rewrite div_mod2__div2_mod2.\n  rewrite IHk.\n  destruct (mod2 (S e)); auto.\nQed.\n\nTheorem strong_ind_principle :\n  forall (P : nat -> Prop),\n  P 0 ->\n  (forall n, (forall n', n' <= n -> P n') -> P (S n)) ->\n  forall n, P n.\nProof.\n  intros P P0 Hsind n.\n  pose (Q := fun n => forall m, m < n -> P m).\n  assert (forall n, Q n -> Q (S n)). {\n    (* clear n Hsind. *)\n    rename n into n_old.\n    intros.\n    unfold Q in *.\n    induction n; intros.\n    - destruct m; auto.\n      exfalso; omega.\n    - destruct m; auto.\n      rewrite <- Nat.succ_lt_mono in H0.\n      apply Hsind.\n      intros.\n      apply H.\n      omega.\n  }\n  assert (Q0 : Q 0). {\n    unfold Q.\n    intros.\n    inv H0.\n  }\n  move n after Q0.\n  assert (forall n, Q n -> P n). {\n    intros.\n    apply H in H0.\n    unfold Q in H0.\n    apply H0.\n    omega.\n  }\n  apply H0.\n  induction n; auto.\nQed.\n\nLtac strong_induction k := apply strong_ind_principle with (n := k).\n\nLemma odd_or_even : forall n, exists k, n = k + k \\\/ n = S (k + k).\nProof.\n  intros.\n  apply ind_0_1_SS with (n := n); simpl; intros.\n  - exists 0. auto.\n  - exists 0. auto.\n  - destruct H as [k H].\n    exists (S k).\n    destruct H as [H | H]; subst; omega.\nQed.\n\nLemma pow_eq_relax :\n  forall b e k k',\n  b <> 0 ->\n  pow_sqr_aux k b e = b ^ e ->\n  k' >= k ->\n  pow_sqr_aux k' b e = b ^ e.\nProof.\n  intros b e k.\n  revert b e.\n  strong_induction k.\n  - intros.\n    simpl in *.\n    destruct e; simpl in *.\n      destruct k'; auto.\n    symmetry in H0. apply mult_is_one in H0.\n    destruct H0; subst; simpl.\n    rewrite pow_sqr_one_e.\n    omega.\n  - intros n H b e k' Hbne0; intros.\n    simpl in H0.\n    destruct e.\n      simpl; destruct k'; auto.\n    rewrite div_mod2__div2_mod2 in H0.\n    remember (div2 (S e)) as q.\n    remember (mod2 (S e)) as r.\n    destruct (odd_or_even (S e)) as [t [Hpar | Hpar]];\n      rewrite Hpar in *; clear Hpar e.\n    + assert (b ^ (t + t) = (b * b) ^ t). {\n        rewrite Nat.pow_add_r.\n        rewrite Nat.pow_mul_l.\n        reflexivity.\n      }\n      rewrite H2 in *.\n      assert (exists k'', k' = S k''). {\n        exists (Nat.pred k').\n        omega. \n      }\n      destruct H3 as [k'' Ek''].\n      rewrite Ek'' in *.\n      rewrite pow_sqr_double.\n      rewrite mod2_double in Heqr.\n      subst.\n      apply H with n; try omega.\n      intro G. apply Hbne0. rewrite Nat.eq_square_0 in G. auto.\n      rewrite div2_double in H0.\n      apply H0.\n    + assert (b ^ (S (t + t)) = b * (b * b) ^ t). {\n        simpl.\n        rewrite Nat.pow_add_r.\n        rewrite Nat.pow_mul_l.\n        simpl.\n        rewrite Nat.mul_assoc.\n        reflexivity.\n      }\n\n      rewrite H2 in *.\n      assert (exists k'', k' = S k''). {\n        exists (Nat.pred k').\n        omega. \n      }\n      destruct H3 as [k'' Ek''].\n      rewrite Ek'' in *.\n      rewrite pow_sqr_double_plus_one.\n      rewrite mod2_double_plus_one in Heqr.\n      subst.\n      apply f_equal.\n      apply H with n; try omega.\n      intro G. rewrite Nat.eq_square_0 in G. auto.\n      rewrite div2_double_plus_one in H0.\n      rewrite (Nat.mul_cancel_l) in H0; auto.\nQed.\n\nLemma pow_sqr_aux_eq :\n  forall b e k,\n  k >= e -> pow_sqr_aux k b e = b ^ e.\nProof.\n  intros b e. revert b.\n  strong_induction e; intros.\n  - simpl.\n    destruct k; simpl; auto.\n  - simpl.\n    destruct k.\n      inv H0.\n    pose proof (odd_or_even n).\n    destruct H1 as [n' [H1 | H1]]; subst.\n    + rewrite pow_sqr_double_plus_one.\n      apply f_equal.\n      replace (b ^ (n' + n')) with ((b * b) ^ n').\n      apply H; try omega.\n      rewrite Nat.pow_mul_l. rewrite Nat.pow_add_r. reflexivity.\n    + replace (S (S (n' + n'))) with ((S n') + (S n')).\n      rewrite pow_sqr_double.\n      replace (b * b ^ S (n' + n')) with ((b * b) ^ (S n')).\n      apply H; omega.\n      simpl. rewrite Nat.pow_add_r.\n      repeat (rewrite Nat.pow_mul_l).\n      rewrite <- Nat.mul_assoc. reflexivity.\n      omega.\nQed.\n\nTheorem pow_eq (b e : nat) : pow_sqr b e = b ^ e.\nProof.\n  unfold pow_sqr.\n  apply pow_sqr_aux_eq.\n  auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5c8dda57b0a26000015f1a7a":[{"id":32740,"user_id":17,"body":"Require Import Arith.\n\nTheorem expand : forall n, (n + 1) ^ 2 = n ^ 2 + 2 * n + 1.\nProof.\n  intros n.\n  simpl.\n  (* Automation FTW ;)\n     See https:\/\/coq.inria.fr\/refman\/addendum\/ring.html for more information about\n     the ring tactic and the underlying theory behind it *)\n  ring.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32741,"user_id":null,"body":"Require Import Arith.\n\nLemma silly1: forall (n : nat),\n  n ^ 2 = n * n.\nProof.\n  intros.\n  simpl.\n  rewrite mult_1_r.\n  reflexivity.\nQed.\n\nLemma silly2 : forall (n : nat),\n  n + 1 = S n.\nProof.\n  intros.\n  rewrite plus_comm.\n  simpl.\n  reflexivity.\nQed.\n\nTheorem expand : forall (n : nat),\n  (n + 1) ^ 2 = n ^ 2 + 2 * n + 1.\nProof.\n  intros.\n  rewrite 2 silly1, 2 silly2.\n  simpl.\n  apply f_equal.\n  rewrite plus_0_r, plus_assoc, mult_comm.\n  simpl.\n  rewrite plus_assoc, plus_comm, plus_assoc.\n  reflexivity.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32742,"user_id":null,"body":"Require Import Arith Psatz.\nImport Nat.\n\nTheorem expand : forall n, (n + 1) ^ 2 = n ^ 2 + 2 * n + 1.\nProof. \n  intros n.\n  rewrite 2 pow_2_r; nia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32743,"user_id":568,"body":"Require Import Arith Lia.\n\nTheorem expand : forall n, (n + 1) ^ 2 = n ^ 2 + 2 * n + 1.\nProof. intros. simpl. lia. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32744,"user_id":1536,"body":"Require Import Arith.\n\nTheorem expand : forall n, (n + 1) ^ 2 = n ^ 2 + 2 * n + 1.\nProof.\n  intros n.\n  simpl.\n  ring.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32745,"user_id":null,"body":"Require Import Arith.\nRequire Import Psatz.\nTheorem expand : forall n, (n + 1) ^ 2 = n ^ 2 + 2 * n + 1.\nProof.\n  intros.\n  rewrite !Nat.pow_2_r.\n  lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32746,"user_id":null,"body":"Require Import Arith Lia.\n\nTheorem expand : forall n, (n + 1) ^ 2 = n ^ 2 + 2 * n + 1.\nProof. simpl. lia. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32747,"user_id":null,"body":"Require Import Arith.\nRequire Import Lia.\n\nTheorem expand : forall n, (n + 1) ^ 2 = n ^ 2 + 2 * n + 1.\nProof.\n  simpl.\n  lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32748,"user_id":null,"body":"Require Import Arith.\n\nTheorem expand : forall n, (n + 1) ^ 2 = n ^ 2 + 2 * n + 1.\nProof.\n  intro n.\n  simpl.\n  repeat rewrite Nat.mul_add_distr_r.\n  repeat rewrite Nat.mul_add_distr_l.\n  repeat rewrite Nat.add_0_r.\n  repeat rewrite Nat.mul_1_l.\n  repeat rewrite Nat.mul_1_r.\n  repeat rewrite Nat.add_assoc.\n  reflexivity.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32749,"user_id":null,"body":"Require Import Arith.\nRequire Import Coq.micromega.Lia.\n\nTheorem expand : forall n, (n + 1) ^ 2 = n ^ 2 + 2 * n + 1.\nProof. simpl; lia. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5c8f5d3a542ce10001c284c3":[{"id":32750,"user_id":568,"body":"(* Magic theorem calls for magic proof! *)\n\nRequire Import Preloaded.\n\nTheorem magic_is_comm : forall (A : Set) (f : A -> A -> A), IsMagic f -> IsComm f.\nProof.\n  intros A f [ left right ].\n  constructor.\n  intros x y.\n  pose proof (right y (f x y)).\n  congruence.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32751,"user_id":168,"body":"Require Import Preloaded ssreflect.\n\nTheorem magic_is_comm : forall (A : Set) (f : A -> A -> A), IsMagic f -> IsComm f.\nProof.\n  move => A f [m1 m2]; constructor => x y.\n  by rewrite -{1}(m1 y (f y x)) 2!m2.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32752,"user_id":106,"body":"Require Import Preloaded.\n\nTheorem magic_is_comm : forall (A : Set) (f : A -> A -> A), IsMagic f -> IsComm f.\nProof.\n  intros; destruct H as [l r]; apply is_comm; intros.\n  specialize l with x (f x y) as l'. rewrite r in l'.\n  specialize r with (f x y) y as r'. now rewrite l' in r'.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32753,"user_id":null,"body":"Require Import Preloaded Setoid.\n\n(* Preloaded:\nRecord IsMagic (A : Set) (f : A -> A -> A) : Prop :=\n  is_magic {\n    left  : forall x y, f (f x y) y = x;\n    right : forall x y, f y (f y x) = x\n  }.\nArguments IsMagic {_} f.\n\nRecord IsComm (A : Set) (f : A -> A -> A) : Prop :=\n  is_comm {\n    comm : forall x y, f x y = f y x\n  }.\nArguments IsComm {_} f.\n*)\n\nTheorem magic_is_comm : forall (A : Set) (f : A -> A -> A), IsMagic f -> IsComm f.\nProof.\n  intros A f [hf1 hf2]. constructor. intros.\n   rewrite <- (hf2 (f y x) x). rewrite <- (hf2 x y) at 3. rewrite hf1.\n   reflexivity.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32754,"user_id":null,"body":"Require Import Preloaded.\n\n(* Preloaded:\nRecord IsMagic (A : Set) (f : A -> A -> A) : Prop :=\n  is_magic {\n    left  : forall x y, f (f x y) y = x;\n    right : forall x y, f y (f y x) = x\n  }.\nArguments IsMagic {_} f.\n\nRecord IsComm (A : Set) (f : A -> A -> A) : Prop :=\n  is_comm {\n    comm : forall x y, f x y = f y x\n  }.\nArguments IsComm {_} f.\n*)\n\nSection Przemiennosc.\n  Variable A : Type.\n  Variable Op : A -> A -> A.\n\n  Notation \"x * y\" := (Op x y).\n\n  Hypothesis Hxyy : forall x y, (x * y) * y = x.\n  Hypothesis Hyyx : forall x y,  y * (y * x) = x.\n\n  Lemma odwL a x y (H : a * x = a * y) : x = y.\n    rewrite <- (Hyyx x a).\n    rewrite <- (Hyyx y a).\n    apply f_equal.\n    assumption.\n  Qed.\n\n  Lemma odwP a x y (H :  x * a =  y * a) : x = y.\n    rewrite <- (Hxyy x a).\n    rewrite <- (Hxyy y a).\n    apply (f_equal (fun b => (b * a))).\n    assumption.\n  Qed.\n\n  \n  Lemma przemienne x y : x * y = y * x.\n  Proof.\n    apply (odwL x).\n    apply (odwP (y * x)).\n    rewrite !Hyyx; rewrite !Hxyy.\n    reflexivity.\n  Qed.\nEnd Przemiennosc.\n\n\nTheorem magic_is_comm : forall (A : Set) (f : A -> A -> A), IsMagic f -> IsComm f.\nProof.\n  intros A f magic; case magic; intros Hxyy Hyyx.\n  constructor; apply przemienne; assumption.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32755,"user_id":null,"body":"Require Import Preloaded.\n\nTheorem magic_is_comm : forall (A : Set) (f : A -> A -> A), IsMagic f -> IsComm f.\nProof.\n  intros A f [fl fr]; apply is_comm; intros x y.\n  replace (f y x) with (f x (f x (f y x))); [|apply fr].\n  replace (f x (f y x)) with y; [easy|].\n  replace (f x (f y x)) with (f (f y (f y x)) (f y x)); [rewrite fl|rewrite fr]; easy.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32756,"user_id":null,"body":"Require Import Preloaded.\n\n(* Preloaded:\nRecord IsMagic (A : Set) (f : A -> A -> A) : Prop :=\n  is_magic {\n    left  : forall x y, f (f x y) y = x;\n    right : forall x y, f y (f y x) = x\n  }.\nArguments IsMagic {_} f.\n\nRecord IsComm (A : Set) (f : A -> A -> A) : Prop :=\n  is_comm {\n    comm : forall x y, f x y = f y x\n  }.\nArguments IsComm {_} f.\n*)\n\n(* Weird but OK. *)\nTheorem magic_is_comm : forall (A : Set) (f : A -> A -> A), IsMagic f -> IsComm f.\nProof.\n  intros A f [Hl Hr].\n  constructor; intros x y.\n  assert (H0:  forall x y z, f x (f x y) = f x (f x z) -> y = z).\n  { clear x y.\n    intros x y z H.\n    rewrite 2!Hr in H.\n    auto. }\n  assert (H1: forall x y z, f (f x y) y = f (f z y) y -> x = z).\n  { clear x y.\n    intros x y z H.\n    rewrite 2!Hl in H.\n    auto. }\n  eapply H0, H1; rewrite Hl, Hr, Hr, Hl, Hr; auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32757,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Coq.Setoids.Setoid.\n\n(* Preloaded:\nRecord IsMagic (A : Set) (f : A -> A -> A) : Prop :=\n  is_magic {\n    left  : forall x y, f (f x y) y = x;\n    right : forall x y, f y (f y x) = x\n  }.\nArguments IsMagic {_} f.\n\nRecord IsComm (A : Set) (f : A -> A -> A) : Prop :=\n  is_comm {\n    comm : forall x y, f x y = f y x\n  }.\nArguments IsComm {_} f.\n*)\n\nTheorem magic_is_comm : forall (A : Set) (f : A -> A -> A), IsMagic f -> IsComm f.\nProof.\n  intros A f.\n  split.\n    destruct H as [l r].\n    intros x y.\n    transitivity (f (f (f y x) y) y).\n      rewrite <- (l y x) at 3.\n      rewrite (r x (f y x)).\n    reflexivity.\n      rewrite (l (f y x) y).\n    reflexivity.\nQed.\n  ","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32758,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Setoid.\n(* Preloaded:\nRecord IsMagic (A : Set) (f : A -> A -> A) : Prop :=\n  is_magic {\n    left  : forall x y, f (f x y) y = x;\n    right : forall x y, f y (f y x) = x\n  }.\nArguments IsMagic {_} f.\n\nRecord IsComm (A : Set) (f : A -> A -> A) : Prop :=\n  is_comm {\n    comm : forall x y, f x y = f y x\n  }.\nArguments IsComm {_} f.\n*)\n\n\nTheorem magic_is_comm : forall (A : Set) (f : A -> A -> A), IsMagic f -> IsComm f.\nProof.\n  intros.\n  destruct H as [left0 right0].\n  constructor.\n  intros.\n  rewrite <- right0 with (x := f x y) (y := y) at 1.\n  assert (f y (f x y) = x).\n  rewrite <- right0 with (x := y) (y := x) at 1.\n  rewrite left0.\n  reflexivity.\n  rewrite H.\n  reflexivity.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32759,"user_id":null,"body":"Require Import Preloaded.\n\n(* Preloaded:\nRecord IsMagic (A : Set) (f : A -> A -> A) : Prop :=\n  is_magic {\n    left  : forall x y, f (f x y) y = x;\n    right : forall x y, f y (f y x) = x\n  }.\nArguments IsMagic {_} f.\n\nRecord IsComm (A : Set) (f : A -> A -> A) : Prop :=\n  is_comm {\n    comm : forall x y, f x y = f y x\n  }.\nArguments IsComm {_} f.\n*)\n\nTheorem magic_is_comm : forall (A : Set) (f : A -> A -> A), IsMagic f -> IsComm f.\n  intros A f [l r].\n  constructor.\n  intros.\n  pose proof (r y (f x y)). rewrite l in H. \n  pose proof (l (f x y) x). rewrite H in H0. auto.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5c91bfdaac8b333b7f2fb5c7":[{"id":32760,"user_id":106,"body":"Require Import Preloaded Arith.\n\n(* Task 1-1. Define matmul in SL2N domain. *)\nFixpoint matmulSL (m1 m2 : SL2N) : SL2N := match m1 with\n  | I => m2\n  | top m' => top (matmulSL m' m2)\n  | bot m' => bot (matmulSL m' m2)\nend.\n\nNotation \"x SL# y\" := (matmulSL x y) (at level 40, left associativity).\n\n(* Task 1-2. Prove that matmulSL is equivalent to matmul. *)\nTheorem matmulSL_eq_matmul : forall m1 m2 : SL2N, eval (m1 SL# m2) = eval m1 # eval m2.\nProof.\n  induction m1; intros; simpl; try rewrite IHm1 with m2; try destruct (eval m1); destruct (eval m2); simpl; f_equal; ring.\nQed.\n\n(* Task 2-1. Define transpose in SL2N domain. *)\nFixpoint transposeSL_aux (m1 m2 : SL2N) : SL2N := match m1 with\n  | I => m2\n  | top m' => transposeSL_aux m' (bot m2)\n  | bot m' => transposeSL_aux m' (top m2)\nend.\n\nDefinition transposeSL (m : SL2N) : SL2N := transposeSL_aux m I.\n\nNotation \"x SL^T\" := (transposeSL x) (at level 35).\n\nLemma transposeSL_eq_transpose_aux: forall m n, eval (transposeSL_aux m n) = eval m ^T # eval n.\nProof.\n  induction m; intros; simpl; try rewrite IHm; simpl; try destruct (eval m); destruct (eval n); simpl; f_equal; ring.\nQed.\n\n(* Task 2-2. Prove that transposeSL is equivalent to transpose. *)\nTheorem transposeSL_eq_transpose : forall m : SL2N, eval (m SL^T) = eval m ^T.\nProof.\n  intro m; pose proof transposeSL_eq_transpose_aux m I as H; unfold transposeSL; rewrite H; destruct (eval m); cbn; f_equal; ring.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32761,"user_id":568,"body":"Require Import Preloaded Arith Lia.\n\n(* Task 1-1. Define matmul in SL2N domain. *)\nFixpoint matmulSL (m1 m2 : SL2N) : SL2N :=\n  match m1 with\n  | I => m2\n  | top m1' => top (matmulSL m1' m2)\n  | bot m1' => bot (matmulSL m1' m2)\n  end.\n\nNotation \"x SL# y\" := (matmulSL x y) (at level 40, left associativity).\n\nRequire Export Lia.\n\n(* https:\/\/github.com\/tchajed\/coq-tricks *)\nLocal Notation anymat := (mat _ _ _ _) (only parsing).\n\nLtac solve_eval :=\n  repeat\n     (simpl in *;\n      match goal with\n      | [ H : ?A = ?B |- context [ ?A ] ] => rewrite H\n      end);\n  repeat\n     (simpl in *;\n      match goal with\n      | [ m : _ |- context [ eval ?m ] ] => destruct (eval m)\n      | [ H : anymat = anymat |- _ ] => injection H; clear H; intros\n      end);\n  simpl;\n  f_equal; try lia.\n\n(* Task 1-2. Prove that matmulSL is equivalent to matmul. *)\nTheorem matmulSL_eq_matmul : forall m1 m2 : SL2N, eval (m1 SL# m2) = eval m1 # eval m2.\nProof.\n  intros.\n  induction m1; solve_eval.\nQed.\n\n(* Task 2-1. Define transpose in SL2N domain. *)\nFixpoint transposeSL (m : SL2N) :=\n  match m with\n  | I => I\n  | top m' => transposeSL m' SL# bot I\n  | bot m' => transposeSL m' SL# top I\n  end.\n\nNotation \"x SL^T\" := (transposeSL x) (at level 35).\n\n(* Task 2-2. Prove that transposeSL is equivalent to transpose. *)\nTheorem transposeSL_eq_transpose : forall m : SL2N, eval (m SL^T) = eval m ^T.\nProof.\n  induction m; simpl; try rewrite matmulSL_eq_matmul; solve_eval.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32762,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Arith.\n\n(* Task 1-1. Define matmul in SL2N domain. *)\nFixpoint matmulSL (m1 m2 : SL2N) : SL2N :=\n  match m1 with\n  | I => m2\n  | top m' => top (matmulSL m' m2)\n  | bot m' => bot (matmulSL m' m2)\n  end.\n\nNotation \"x SL# y\" := (matmulSL x y) (at level 40, left associativity).\n\n(* Task 1-2. Prove that matmulSL is equivalent to matmul. *)\nTheorem matmulSL_eq_matmul : forall m1 m2 : SL2N, eval (m1 SL# m2) = eval m1 # eval m2.\nProof.\n  induction m1; intros m2.\n  - simpl; destruct (eval m2); apply congMat; ring.\n  - simpl; rewrite IHm1; destruct (eval m1) as [a1 b1 c1 d1], (eval m2) as [a2 b2 c2 d2].\n    simpl; apply congMat; ring.\n  - simpl; rewrite IHm1; destruct (eval m1) as [a1 b1 c1 d1], (eval m2) as [a2 b2 c2 d2].\n    simpl; apply congMat; ring.\nQed.\n\n(* Task 2-1. Define transpose in SL2N domain. *)\nFixpoint transposeSL (m : SL2N) : SL2N :=\n  match m with\n  | I => I\n  | top m' => transposeSL m' SL# bot I\n  | bot m' => transposeSL m' SL# top I\n  end.\n\nNotation \"x SL^T\" := (transposeSL x) (at level 35).\n\n(* Task 2-2. Prove that transposeSL is equivalent to transpose. *)\nTheorem transposeSL_eq_transpose : forall m : SL2N, eval (m SL^T) = eval m ^T.\nProof.\n  induction m.\n  - easy.\n  - simpl; rewrite matmulSL_eq_matmul, IHm.\n    destruct (eval m) as [a b c d]; simpl.\n    apply congMat; ring.\n  - simpl; rewrite matmulSL_eq_matmul, IHm.\n    destruct (eval m) as [a b c d]; simpl.\n    apply congMat; ring.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32763,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Arith.\n\n(* Task 1-1. Define matmul in SL2N domain. *)\nFixpoint matmulSL (m1 m2 : SL2N) : SL2N := match m1 with \n  | I => m2 \n  | top m1' => top (matmulSL m1' m2)\n  | bot m1' => bot (matmulSL m1' m2)\nend.\n\nNotation \"x SL# y\" := (matmulSL x y) (at level 40, left associativity).\n\nLemma matI2 : forall m : Mat, eval I # m = m.\nProof.\n  simple destruct m.\n  simpl.\n  intros a b c d.\n  apply congMat ; ring.\nQed.\n\n(* Task 1-2. Prove that matmulSL is equivalent to matmul. *)\nTheorem matmulSL_eq_matmul : forall m1 m2 : SL2N, eval (m1 SL# m2) = eval m1 # eval m2.\nProof.\n  intro m1.\n  induction m1 as [| m1 hm1 | m1 hm1].\n  + unfold matmulSL. symmetry. apply matI2.\n  + intro m2. destruct (eval m1) eqn:h1. destruct (eval m2) eqn:h2. simpl.\n    rewrite h1. rewrite hm1. simpl. rewrite h2. apply congMat;ring.\n  + intro m2. destruct (eval m1) eqn:h1. destruct (eval m2) eqn:h2. simpl.\n  rewrite h1. rewrite hm1. simpl. rewrite h2. apply congMat;ring.\nQed.\n\n(* Task 2-1. Define transpose in SL2N domain. *)\nFixpoint transposeSL (m : SL2N) : SL2N := match m with \n  | I => I \n  | top m' => (transposeSL m') SL# (bot I)\n  | bot m' => (transposeSL m') SL# (top I)\nend.\n\nNotation \"x SL^T\" := (transposeSL x) (at level 35).\n\n(* Task 2-2. Prove that transposeSL is equivalent to transpose. *)\nTheorem transposeSL_eq_transpose : forall m : SL2N, eval (m SL^T) = eval m ^T.\nProof.\n  intro m.\n  induction m as [| m hm | m hm];simpl.\n  + reflexivity.\n  + rewrite matmulSL_eq_matmul. rewrite hm. destruct (eval m). simpl.\n    apply congMat ; ring.\n  + rewrite matmulSL_eq_matmul. rewrite hm. destruct (eval m). simpl.\n  apply congMat ; ring.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32764,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Arith Lia.\n\n(* Task 1-1. Define matmul in SL2N domain. *)\nFixpoint matmulSL (m1 m2 : SL2N) : SL2N :=\n  match m1 with\n    | I => m2\n    | top m' => top (matmulSL m' m2)\n    | bot m' => bot (matmulSL m' m2)\n  end.\n\nNotation \"x SL# y\" := (matmulSL x y) (at level 40, left associativity).\n\n(* Task 1-2. Prove that matmulSL is equivalent to matmul. *)\nTheorem matmulSL_eq_matmul : forall m1 m2 : SL2N, eval (m1 SL# m2) = eval m1 # eval m2.\nProof.\n  intros.\n  induction m1;\n  simpl;\n  try rewrite IHm1;\n  try destruct (eval m1); \n  destruct (eval m2);\n  apply congMat;\n  lia.\nQed.\n\nDefinition swapTB (m : Mat) : Mat :=\n  match m with mat a0 b0 c0 d0 => mat c0 d0 a0 b0 end.\n\nFixpoint swapTBSL (m : SL2N) : SL2N :=\n  match m with\n    | I => I\n    | bot m' => top (swapTBSL m')\n    | top m' => bot (swapTBSL m')\n  end.\n\n\n(* Task 2-1. Define transpose in SL2N domain. *)\n\nFixpoint transposeSL (m : SL2N) : SL2N :=\n  match m with\n    | I => I\n    | bot m' => matmulSL (transposeSL m') (top I)\n    | top m' => matmulSL (transposeSL m') (bot I)\n  end.\n\nNotation \"x SL^T\" := (transposeSL x) (at level 35).\n\n(* Task 2-2. Prove that transposeSL is equivalent to transpose. *)\nTheorem transposeSL_eq_transpose : forall m : SL2N, eval (m SL^T) = eval m ^T.\nProof.\n induction m;\n simpl;\n try rewrite matmulSL_eq_matmul;\n try rewrite IHm;\n simpl;\n try destruct (eval m);\n apply congMat;\n lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32765,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Arith.\n\n(* Task 1-1. Define matmul in SL2N domain. *)\nFixpoint matmulSL (m1 m2 : SL2N) : SL2N :=\n  match m1 with\n  | I => m2\n  | top m1' => top (matmulSL m1' m2)\n  | bot m1' => bot (matmulSL m1' m2)\n  end.\n\nNotation \"x SL# y\" := (matmulSL x y) (at level 40, left associativity).\n\n(* Task 1-2. Prove that matmulSL is equivalent to matmul. *)\nTheorem matmulSL_eq_matmul : forall m1 m2 : SL2N, eval (m1 SL# m2) = eval m1 # eval m2.\nProof.\n  induction m1.\n  - simpl; intros; destruct (eval m2); refine (congMat _ _ _ _); ring.\n  - unfold matmulSL; fold matmulSL; unfold eval; fold eval; intros; rewrite IHm1.\n    destruct (eval m1), (eval m2); simpl; refine (congMat _ _ _ _); ring.\n  - unfold matmulSL; fold matmulSL; unfold eval; fold eval; intros; rewrite IHm1.\n    destruct (eval m1), (eval m2); simpl; refine (congMat _ _ _ _); ring.\nQed.\n\n(* Task 2-1. Define transpose in SL2N domain. *)\nFixpoint transposeSL (m : SL2N) : SL2N := \n  match m with\n  | I => I\n  | top m' => transposeSL m' SL# bot I\n  | bot m' => transposeSL m' SL# top I\n  end.\n\nNotation \"x SL^T\" := (transposeSL x) (at level 35).\n\n(* Task 2-2. Prove that transposeSL is equivalent to transpose. *)\nTheorem transposeSL_eq_transpose : forall m : SL2N, eval (m SL^T) = eval m ^T.\nProof.\n  induction m.\n  - simpl; reflexivity.\n  - unfold transposeSL; fold transposeSL; rewrite matmulSL_eq_matmul, IHm.\n    simpl; destruct (eval m); simpl; refine (congMat _ _ _ _); ring.\n  - unfold transposeSL; fold transposeSL; rewrite matmulSL_eq_matmul, IHm.\n    simpl; destruct (eval m); simpl; refine (congMat _ _ _ _); ring.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32766,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Arith Lia.\n\n(* Task 1-1. Define matmul in SL2N domain. *)\nFixpoint matmulSL (m1 m2 : SL2N) : SL2N :=\n  match m1 with\n  | I       => m2\n  | top m1' => top (matmulSL m1' m2)\n  | bot m1' => bot (matmulSL m1' m2)\n  end.\n\nNotation \"x SL# y\" := (matmulSL x y) (at level 40, left associativity).\n\n(* Task 1-2. Prove that matmulSL is equivalent to matmul. *)\nTheorem matmulSL_eq_matmul : forall m1 m2 : SL2N, eval (m1 SL# m2) = eval m1 # eval m2.\nProof.\n  induction m1; intros; cbn;\n    try rewrite IHm1;\n    try destruct (eval m1);\n    destruct (eval m2);\n    cbn; apply congMat; lia.\nQed.\n\nDefinition mat_1_0_1_1 := bot I.\n\n(* Task 2-1. Define transpose in SL2N domain. *)\nFixpoint transposeSL (m : SL2N) : SL2N :=\n  match m with\n  | I => I\n  | top m' => transposeSL m' SL# (bot I)\n  | bot m' => transposeSL m' SL# (top I)\n  end.\n\nNotation \"x SL^T\" := (transposeSL x) (at level 35).\n\n(* Task 2-2. Prove that transposeSL is equivalent to transpose. *)\nTheorem transposeSL_eq_transpose : forall m : SL2N, eval (m SL^T) = eval m ^T.\nProof.\n  induction m; intros; cbn; auto;\n    rewrite matmulSL_eq_matmul;\n    rewrite IHm;\n    destruct (eval m);\n    cbn; apply congMat; lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32767,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Arith Lia.\n\n(* Task 1-1. Define matmul in SL2N domain. *)\nFixpoint matmulSL (m1 m2 : SL2N) : SL2N :=\n  match m1 with\n  | I => m2\n  | top m1 => top (matmulSL m1 m2)\n  | bot m1 => bot (matmulSL m1 m2)\n  end.\n\nNotation \"x SL# y\" := (matmulSL x y) (at level 40, left associativity).\n\n(* Task 1-2. Prove that matmulSL is equivalent to matmul. *)\nTheorem matmulSL_eq_matmul : forall m1 m2 : SL2N, eval (m1 SL# m2) = eval m1 # eval m2.\nProof.\n  intros. induction m1.\n  - cbn. destruct (eval m2). apply congMat; lia.\n  - cbn. rewrite IHm1.\n    destruct (eval m1), (eval m2). cbn. apply congMat; lia.\n  - cbn. rewrite IHm1.\n    destruct (eval m1), (eval m2). cbn. apply congMat; lia.\nQed.\n\n(* Task 2-1. Define transpose in SL2N domain. *)\nFixpoint transposeSL_aux (m : SL2N) acc : SL2N :=\n  match m with\n  | I => acc\n  | top m => transposeSL_aux m (bot acc)\n  | bot m => transposeSL_aux m (top acc)\n  end.\nDefinition transposeSL m := transposeSL_aux m I.\n\nNotation \"x SL^T\" := (transposeSL x) (at level 35).\n\nLemma transposeSL_aux_eq_transpose : forall m acc,\n  eval (transposeSL_aux m acc) = eval m ^T # eval acc.\nProof.\n  induction m; intros.\n  - cbn. destruct (eval acc). apply congMat; lia.\n  - cbn. rewrite IHm. cbn.\n    destruct (eval m), (eval acc). cbn. apply congMat; lia.\n  - cbn. rewrite IHm. cbn.\n    destruct (eval m), (eval acc). cbn. apply congMat; lia.\nQed.\n\n(* Task 2-2. Prove that transposeSL is equivalent to transpose. *)\nTheorem transposeSL_eq_transpose : forall m : SL2N, eval (m SL^T) = eval m ^T.\nProof.\n  intros. unfold transposeSL.\n  rewrite transposeSL_aux_eq_transpose.\n  destruct (eval m). cbn.\n  apply congMat; lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32768,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Arith.\n\n\n(* Task 1-1. Define matmul in SL2N domain. *)\nFixpoint matmulSL (m1 m2 : SL2N) : SL2N :=\n  match m1 with\n  | I => m2\n  | top m1' => top (matmulSL m1' m2)\n  | bot m1' => bot (matmulSL m1' m2)\n  end.\n\nNotation \"x SL# y\" := (matmulSL x y) (at level 40, left associativity).\n\nRequire Import Lia.\n(* Task 1-2. Prove that matmulSL is equivalent to matmul. *)\nTheorem matmulSL_eq_matmul : forall m1 m2 : SL2N, eval (m1 SL# m2) = eval m1 # eval m2.\nProof. \n  induction m1; \n    simpl; \n    intros;\n    try (rewrite IHm1; destruct (eval m1));\n    destruct (eval m2);\n    simpl; apply congMat; lia.\nQed.\n\n(* Task 2-1. Define transpose in SL2N domain. *)\nFixpoint transposeSL (m : SL2N) : SL2N := \n  match m with\n  | I => I\n  | top m' => transposeSL m' SL# (bot I)\n  | bot m' => transposeSL m' SL# (top I)\n  end.\nNotation \"x SL^T\" := (transposeSL x) (at level 35).\n\n(* Task 2-2. Prove that transposeSL is equivalent to transpose. *)\nTheorem transposeSL_eq_transpose : forall m : SL2N, eval (m SL^T) = eval m ^T.\nProof.\n  induction m; simpl.\n  - apply congMat; lia.\n  - rewrite matmulSL_eq_matmul; simpl.\n    rewrite IHm.\n    destruct (eval m); simpl.\n    apply congMat; lia.\n  - rewrite matmulSL_eq_matmul; simpl.\n    rewrite IHm.\n    destruct (eval m); simpl.\n    apply congMat; lia.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32769,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Arith Lia.\n\nFixpoint top_end (M : SL2N) : SL2N :=\nmatch M with\n| I => top I\n| top M' => top (top_end M')\n| bot M' => bot (top_end M')\nend.\n\nFixpoint bot_end (M : SL2N) : SL2N :=\nmatch M with\n| I => bot I\n| top M' => top (bot_end M')\n| bot M' => bot (bot_end M')\nend.\n\nFixpoint eval' (M1 : Mat) (M2 : SL2N) : Mat := match M2 with\n  | I => M1\n  | top m' => match (eval' M1 m') with mat a0 b0 c0 d0 => mat (a0 + c0) (b0 + d0) c0 d0 end\n  | bot m' => match (eval' M1 m') with mat a0 b0 c0 d0 => mat a0 b0 (a0 + c0) (b0 + d0) end\nend.\n\nLemma eval_eval'_mul: forall M1 M2, eval' M1 M2 = (eval M2) # M1.\nProof.\n  intros.\n  destruct M1.\n  induction M2;\n    simpl; f_equal; try lia;\n    rewrite IHM2;\n    destruct (eval M2);\n    simpl;\n    f_equal; lia.\nQed.\n\n\nLemma top_end_eval' : forall M, eval (top_end M) = eval' (mat 1 1 0 1) M.\nProof.\n  intros.\n  induction M; auto;\n    simpl; rewrite IHM; auto.\nQed.\n\nLemma bot_end_eval' : forall M, eval (bot_end M) = eval' (mat 1 0 1 1) M.\nProof.\n  intros.\n  induction M; auto;\n    simpl; rewrite IHM; auto.\nQed.\n\n(* Task 1-1. Define matmul in SL2N domain. *)\nFixpoint matmulSL (m1 m2 : SL2N) : SL2N :=\nmatch m1 with\n| I => m2\n| top m1' => top (matmulSL m1' m2)\n| bot m1' => bot (matmulSL m1' m2)\nend.\n\nNotation \"x SL# y\" := (matmulSL x y) (at level 40, left associativity).\n\n\n(* Task 1-2. Prove that matmulSL is equivalent to matmul. *)\nTheorem matmulSL_eq_matmul : forall m1 m2 : SL2N, eval (m1 SL# m2) = eval m1 # eval m2.\nProof.\n  intros.\n  induction m1; [destruct m2; simpl; auto; destruct (eval m2); auto; f_equal; lia | |];\n    simpl;\n    rewrite IHm1;\n    destruct(eval m1);\n    destruct(eval m2);\n    simpl;\n    f_equal; lia.\nQed.\n\n(* Task 2-1. Define transpose in SL2N domain. *)\nFixpoint transposeSL (M : SL2N) : SL2N :=\nmatch M with\n| I => I\n| top M' => bot_end (transposeSL M')\n| bot M' => top_end (transposeSL M')\nend.\n\nNotation \"x SL^T\" := (transposeSL x) (at level 35).\n\n(* Task 2-2. Prove that transposeSL is equivalent to transpose. *)\nTheorem transposeSL_eq_transpose : forall m : SL2N, eval (m SL^T) = eval m ^T.\nProof.\n  intros M.\n  induction M; auto.\n  {\n    simpl.\n    rewrite bot_end_eval'.\n    rewrite eval_eval'_mul.\n    rewrite IHM.\n    simpl.\n    destruct (eval M). \n    simpl.\n    f_equal; lia.\n  }\n  {\n    simpl.\n    rewrite top_end_eval'.\n    rewrite eval_eval'_mul.\n    rewrite IHM.\n    simpl.\n    destruct (eval M). \n    simpl.\n    f_equal; lia.\n  }\nQed.\n    ","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5c930224c4661143a6666add":[{"id":32770,"user_id":106,"body":"From Coq Require Import Lia.\nRequire Import Preloaded.\n\nLemma SL2N_bound : forall m, b (eval m) < b (eval (top m)) \/\\ c (eval m) < c (eval (bot m)).\nProof. intros; split; induction m; constructor || (simpl in *; destruct (eval m); simpl in *; lia). Qed.\n\nTheorem eval_injective : forall m n : SL2N, eval m = eval n -> m = n.\nProof.\n  induction m; intros; destruct n;\n  f_equal; try apply IHm; try destruct (SL2N_bound m); try destruct (SL2N_bound n); simpl in *;\n  try destruct (eval m); try destruct (eval n); inversion H; simpl in *; f_equal; reflexivity || lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32771,"user_id":17,"body":"Require Import Preloaded.\nFrom Coq Require Import Lia.\n\nTheorem eval_injective : forall m n : SL2N,\n  eval m = eval n -> m = n.\nProof.\n  assert (forall n, a (eval n) > 0 \/\\ d (eval n) > 0)\n    by (induction n; simpl; try (destruct (eval n); simpl in *);\n    lia).\n  induction m; simpl; intros.\n  - destruct n; simpl in *; auto; case (eval n), a, b, c, d;\n      discriminate.\n  - destruct (eval m) eqn:?, n; simpl in *;\n      try (destruct a, b, c, d; discriminate).\n    + destruct (eval n) eqn:?; injection H0; intros; subst.\n      assert (b = b0) by lia; assert (a = a0) by lia; subst.\n      apply f_equal; auto.\n    + destruct (eval n) eqn:?; injection H0; intros; subst.\n      specialize (H m); rewrite Heqm0 in *; simpl in *; lia.\n  - destruct (eval m) eqn:?, n; simpl in *;\n      try (destruct a, b, c, d; discriminate).\n    + destruct (eval n) eqn:?; injection H0; intros; subst.\n      specialize (H m); rewrite Heqm0 in *; simpl in *; lia.\n    + destruct (eval n) eqn:?; injection H0; intros; subst.\n      assert (d = d0) by lia; assert (c = c0) by lia; subst.\n      apply f_equal; auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32772,"user_id":168,"body":"From Coq Require Import Arith.\nRequire Import Preloaded.\nFrom Coq Require Import ssreflect Omega.\n\nLemma a_neq_0 : forall n, a (eval n) <> 0.\nProof. by elim => [|n|n] \/\/=; case: (eval n) => a b c d \/\/=; omega. Qed.\n  \nLemma eval_injective_I : forall n, eval I = eval n -> I = n.\nProof. by case => [|n|n] \/\/=; case: (eval n) => a' b' c' d' []; omega. Qed.\n\nLemma eval_injective_I' : forall n, eval n = eval I -> n = I.\nProof. by move => n h; rewrite (eval_injective_I n). Qed.\n\nLemma eval_injective_top_bot : forall m n, eval (top m) <> eval (bot n).\nProof.\n  move => m n \/=; move: (a_neq_0 m).\n  case: (eval m) => a b c d; case: (eval n) => x y u v \/= an0 [].\n  omega.\nQed.\n\nTheorem eval_injective : forall m n : SL2N, eval m = eval n -> m = n.\nProof.\n  elim => [|m hm|m hm]; case => [|n|n] \/\/;\n    try do [exact: eval_injective_I | exact: eval_injective_I'].\n  - move: (hm n) => \/=.\n    case: (eval m) => a b c d; case: (eval n) => x y u v eq [e1 e2 e3 e4].\n    by rewrite eq \/\/; apply: congMat; omega.\n  - by move\/eval_injective_top_bot.\n  - by move\/(@eq_sym Mat)\/eval_injective_top_bot.\n  - move: (hm n) => \/=.\n    case: (eval m) => a b c d; case: (eval n) => x y u v eq [e1 e2 e3 e4].\n    by rewrite eq \/\/; apply: congMat; omega.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32773,"user_id":null,"body":"From Coq Require Import Arith Lia.\nRequire Import Preloaded.\n\nLemma a_not_zero : forall m, a (eval m) <> 0.\nProof.\n  induction m;simpl ; try auto ; destruct (eval m); simpl in *; lia.\nQed.\n\n(* Prove that eval is injective, i.e. for any 2x2 matrix in the set SL2N, the representation is unique. *)\nTheorem eval_injective : forall m n : SL2N, eval m = eval n -> m = n.\nProof.\n  induction m ; induction n ; intros ; try auto; try (destruct (eval n) eqn:hn); \n  try (destruct (eval m) eqn:hm);simpl in H; try rewrite hn in H; try rewrite hm \n  in H; try inversion H; try lia.\n  + rewrite (IHm n). reflexivity. rewrite hn. apply congMat; lia.\n  + pose proof (h1 := a_not_zero m). rewrite hm in h1. simpl in h1. lia.\n  + pose proof (h1 := a_not_zero n). rewrite hn in h1. simpl in h1. lia.\n  + rewrite (IHm n). reflexivity. rewrite hn. apply congMat; lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32774,"user_id":null,"body":"From Coq Require Import Arith Lia ssrfun ssreflect.\nRequire Import Preloaded.\nImport Nat.\n\nDefinition det (A : Mat) : nat :=\n  match A with mat a b c d => a * d - b * c end.\n\nLemma SL2N_det1 (A : SL2N) : det (eval A) = 1.\nProof. elim: A => [\/\/|A|A]\/=; case: (eval A) => [a b c d] \/=; lia. Qed.\n\n(* Prove that eval is injective, i.e. for any 2x2 matrix in the set SL2N, the representation is unique. *)\nTheorem eval_injective : forall m n : SL2N, eval m = eval n -> m = n.\nProof.\n  elim=> [|A IHA|A IHA].\n  - move=> [\/\/|C|D]\/=.\n    + case: (eval C) => [c1 c2 c3 c4] []; lia.\n    + case: (eval D) => [d1 d2 d3 d4] []; lia.\n  - move=> [|C|D]\/=.\n    + case: (eval A) => [a1 a2 a3 a4] []; lia.\n    + case evA : (eval A) => [a1 a2 a3 a4].\n      case evC : (eval C) => [c1 c2 c3 c4].\n      move=> [+ + eqac3 eqac4]; move: evA.\n      rewrite eqac3 eqac4 2!add_cancel_r => + eqac1 eqac2.\n      by rewrite eqac1 eqac2 -evC => \/IHA ->.\n    + case evA : (eval A) => [a1 a2 a3 a4].\n      case: (eval D) => [d1 d2 d3 d4].\n      move=> [eqa13d1 eqa24d2 eqa3d1d3 eqa4d24].\n      move: evA.\n      have -> : a1 = 0 by lia.\n      have -> : a2 = 0 by lia.\n      move\/(congr1 det) => \/=.\n      by rewrite SL2N_det1.\n  - move=> [|C|D]\/=.\n    + case: (eval A) => [a1 a2 a3 a4] []; lia.\n    + case evA : (eval A) => [a1 a2 a3 a4].\n      case: (eval C) => [c1 c2 c3 c4].\n      move=> [eqa1c13 eqa2c24 eqa12c3 eqa24c4].\n      move: evA.\n      have -> : a3 = 0 by lia.\n      have -> : a4 = 0 by lia.\n      move\/(congr1 det) => \/=.\n      rewrite SL2N_det1; lia.\n    + case evA : (eval A) => [a1 a2 a3 a4].\n      case evD : (eval D) => [d1 d2 d3 d4].\n      move=> [eqad1 eqad2]; move: evA.\n      rewrite eqad1 eqad2 2!add_cancel_l => + eqad3 eqad4.\n      by rewrite eqad3 eqad4 -evD => \/IHA ->.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32775,"user_id":null,"body":"From Coq Require Import Arith.\nRequire Import Preloaded.\n\n(* Prove that eval is injective, i.e. for any 2x2 matrix in the set SL2N, the representation is unique. *)\nLemma top_gt : forall m, a (eval (top m)) + b (eval (top m)) > c (eval (top m)) + d (eval (top m)).\nProof.\n  induction m.\n  - apply le_n.\n  - simpl in *; destruct (eval m) as [a b c d]; simpl in *.\n    apply le_trans with (a + c + (b + d)); [easy|].\n    assert (a + c + c + (b + d + d) = a + c + (b + d) + (c + d)) as R by ring.\n    rewrite R; apply le_plus_l.\n  - simpl in *; destruct (eval m) as [a b c d]; simpl in *.\n    assert (a + (a + c) + (b + (b + d)) = (a + b) + (a + c + (b + d))) as R1 by ring.\n    assert (a + c + (b + d) = (a + b) + (c + d)) as R2 by ring.\n    rewrite R2, R1; apply Nat.add_lt_mono_l, IHm.\nQed.\n\nLemma bot_lt : forall m, a (eval (bot m)) + b (eval (bot m)) < c (eval (bot m)) + d (eval (bot m)).\nProof.\n  induction m.\n  - apply le_n.\n  - simpl in *; destruct (eval m) as [a b c d]; simpl in *.\n    assert (a + c + (b + d) = (c + d) + (a + b)) as R1 by ring.\n    assert (a + c + c + (b + d + d) = (c + d) + (a + c + (b + d))) as R2 by ring.\n    rewrite R1, R2; apply Nat.add_lt_mono_l, IHm.\n  - simpl in *; destruct (eval m) as [a b c d]; simpl in *.\n    apply le_trans with (a + c + (b + d)); [easy|].\n    assert (a + (a + c) + (b + (b + d)) = a + c + (b + d) + (a + b)) as R by ring.\n    rewrite R; apply le_plus_l.\nQed.\n\nLemma top_not_I : forall m, eval (top m) <> eval I.\nProof.\n  intros m; specialize (top_gt m); destruct (eval (top m)) as [a b c d]; simpl.\n  intros H; contradict H; inversion H; subst; apply le_not_lt, le_n.\nQed.\n\nLemma bot_not_I : forall m, eval (bot m) <> eval I.\nProof.\n  intros m; specialize (bot_lt m); destruct (eval (bot m)) as [a b c d]; simpl.\n  intros H; contradict H; inversion H; subst; apply le_not_lt, le_n.\nQed.\n\nLemma top_not_bot : forall m n, eval (top m) <> eval (bot n).\nProof.\n  intros m n; specialize (top_gt m); specialize (bot_lt n).\n  destruct (eval (top m)) as [a1 b1 c1 d1], (eval (bot n)) as [a2 b2 c2 d2]; simpl.\n  intros H1 H2 H3; inversion H3; subst.\n  contradict H1; apply le_not_lt, Nat.lt_le_incl, H2.\nQed.\n\nTheorem eval_injective : forall m n : SL2N, eval m = eval n -> m = n.\nProof.\n  induction m; intros n Heq.\n  - destruct n.\n    + easy.\n    + symmetry in Heq; contradict Heq; apply top_not_I.\n    + symmetry in Heq; contradict Heq; apply bot_not_I.\n  - destruct n.\n    + contradict Heq; apply top_not_I.\n    + rewrite (IHm n); [easy|]; clear IHm.\n      simpl in Heq; destruct (eval m) as [a1 b1 c1 d1], (eval n) as [a2 b2 c2 d2]; simpl in *.\n      inversion Heq; subst.\n      repeat rewrite (Nat.add_comm _ c2) in H0; apply plus_reg_l in H0; subst.\n      repeat rewrite (Nat.add_comm _ d2) in H1; apply plus_reg_l in H1; subst.\n      easy.\n    + contradict Heq; apply top_not_bot.\n  - destruct n.\n    + contradict Heq; apply bot_not_I.\n    + symmetry in Heq; contradict Heq; apply top_not_bot.\n    + rewrite (IHm n); [easy|]; clear IHm.\n      simpl in Heq; destruct (eval m) as [a1 b1 c1 d1], (eval n) as [a2 b2 c2 d2]; simpl in *.\n      inversion Heq; subst.\n      apply plus_reg_l in H2; apply plus_reg_l in H3; now subst.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32776,"user_id":null,"body":"From Coq Require Import Arith.\nRequire Import Preloaded.\n\nTheorem pos11 (m : SL2N) : 0 < a (eval m).\nProof.\n  induction m as [| m' IH | m' IH].\n  - simpl. constructor.\n  - simpl ; destruct (eval m') as [a b c d] ; simpl in *.\n    apply Nat.lt_lt_add_r ; assumption.\n  - simpl ; destruct (eval m') as [a b c d] ; simpl in *.\n    assumption.\nQed.\n\nTheorem pos22 (m : SL2N) : 0 < d (eval m).\nProof.\n  induction m as [| m' IH | m' IH].\n  - simpl. constructor.\n  - simpl ; destruct (eval m') as [a b c d] ; simpl in *.\n    assumption.\n  - simpl ; destruct (eval m') as [a b c d] ; simpl in *.\n    apply Nat.lt_lt_add_l ; assumption.\nQed.\n\nTheorem eval_sim_col (m : SL2N) : a (eval m) = c (eval m) -> b (eval m) = d (eval m) -> False.\nProof.\n  destruct m.\n  - intros e.\n    inversion e.\n  - intros e _.\n    pose proof (pos11 m).\n    simpl in e.\n    destruct (eval m) as [a b c d].\n    simpl in e.\n    apply (lt_irrefl c).\n    rewrite <- e at 2.\n    apply Nat.lt_add_pos_l.\n    assumption.\n  - intros _ e.\n    pose proof (pos22 m).\n    simpl in e.\n    destruct (eval m) as [a b c d].\n    simpl in *.\n    apply (lt_irrefl b).\n    rewrite e at 2.\n    apply Nat.lt_add_pos_r.\n    assumption.\nQed.\n\nTheorem eval_I_top (m : SL2N) : not (eval I = eval (top m)).\nProof.\n  intros e.\n  simpl in *.\n  destruct (eval m).\n  inversion e.\n  rewrite <- H3 in H1.\n  rewrite plus_comm in H1.\n  inversion H1.\nQed.\n\nTheorem eval_I_bot (m : SL2N) : not (eval I = eval (bot m)).\nProof.\n  intros e.\n  simpl in *.\n  destruct (eval m).\n  inversion e.\n  inversion H2.\nQed.\n\nTheorem eval_top_bot {m n : SL2N} : not (eval (top m) = eval (bot n)).\nProof.\n  intros e.\n  pose proof (eval_sim_col (top m)) as eval_sim_col_m.\n  simpl in *.\n  destruct (eval m) as [a b c d].\n  destruct (eval n) as [a' b' c' d'].\n  inversion e.\n  simpl in *.\n  apply eval_sim_col_m.\n  - cut (c' = 0).\n      intros c'0.\n      rewrite H2 at 2.\n      rewrite c'0.\n      rewrite <- plus_n_O.\n      reflexivity.\n    apply (plus_is_O a c').\n    apply (Nat.add_cancel_r _ _ c).\n    simpl.\n    rewrite H2 at 2.\n    rewrite <- plus_assoc.\n    rewrite (plus_comm c').\n    rewrite plus_assoc.\n    reflexivity.\n  - cut (b = 0).\n      intro b0.\n      rewrite b0. reflexivity.\n    apply (plus_is_O b d').\n    apply (Nat.add_cancel_r _ _ d).\n    simpl.\n    rewrite H3 at 2.\n    rewrite <- plus_assoc.\n    rewrite (plus_comm d').\n    rewrite plus_assoc.\n    reflexivity.\nQed.\n\nTheorem eval_injective : forall m n : SL2N, eval m = eval n -> m = n.\nProof.\n  induction m as [| m' IH| m' IH].\n  - case n as [| n'| n'].\n    1: auto.\n    + intros. exfalso. apply (eval_I_top n'). assumption.\n    + intros. exfalso. apply (eval_I_bot n'). assumption.\n\n  - intros [|n'|n'].\n    + intros. exfalso. apply (eval_I_top m'). symmetry. assumption.\n    + intros e. f_equal. apply IH.\n      simpl in e. destruct (eval m') as [a b c d]. destruct (eval n') as [a' b' c' d'].\n      inversion e.\n      destruct H2. destruct H3.\n      f_equal.\n      all: eapply Nat.add_cancel_r ; eassumption.\n    + intros e.\n      exfalso.\n      eapply eval_top_bot. eassumption.\n  \n  - intros [|n'|n'].\n    + intros. exfalso. apply (eval_I_bot m'). symmetry. assumption.\n    + intros e.\n      exfalso.\n      eapply eval_top_bot.\n      symmetry.\n      eassumption.\n    + intros e. f_equal. apply IH.\n      simpl in e. destruct (eval m') as [a b c d]. destruct (eval n') as [a' b' c' d'].\n      inversion e.\n      f_equal.\n      all: eapply Nat.add_cancel_l ; eassumption.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32777,"user_id":null,"body":"From Coq Require Import Arith.\nRequire Import Preloaded.\n\nRequire Import Lia.\n\nLemma top_bot_diff : forall m, c (eval (top m)) < a (eval (top m)) \/\\ a (eval (bot m)) <= c (eval (bot m)).\nProof.\n  induction m; try (split; simpl; lia);\n  split; simpl in IHm; simpl; destruct (eval m); simpl in IHm; simpl; destruct IHm; lia.\nQed.\n\nLemma bot_not_I : forall m, eval (bot m) <> eval I.\nProof.\n  simpl; intros; destruct (eval m); intros F; inversion F; discriminate.\nQed.\n\nLemma top_not_I : forall m, eval (top m) <> eval I.\nProof.\n  simpl; intros; destruct (eval m); intros F; injection F; intros; rewrite H, Nat.add_comm in H1; discriminate.\nQed.\n\nLemma top_not_bot : forall m n, eval (top m) <> eval (bot n).\nProof.\n  intros; destruct (top_bot_diff m), (top_bot_diff n); intros F; rewrite F in H; lia.\nQed.\n\n(* Prove that eval is injective, i.e. for any 2x2 matrix in the set SL2N, the representation is unique. *)\nTheorem eval_injective : forall m n : SL2N, eval m = eval n -> m = n.\nProof.\n  induction m; destruct n; intros.\n  - reflexivity.\n  - case (top_not_I _ (eq_sym H)).\n  - case (bot_not_I _ (eq_sym H)).\n  - case (top_not_I _ H).\n  - rewrite (IHm n); try reflexivity;\n    simpl in H; destruct (eval m), (eval n); inversion H; refine (congMat _ _ _ _); lia.\n  - case (top_not_bot _ _ H).\n  - case (bot_not_I _ H).\n  - case (top_not_bot _ _ (eq_sym H)).\n  - rewrite (IHm n); try reflexivity;\n    simpl in H; destruct (eval m), (eval n); inversion H; refine (congMat _ _ _ _); lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32778,"user_id":null,"body":"From Coq Require Import Arith Lia.\nRequire Import Preloaded.\n\nDefinition sum_mat (m : Mat) := match m with\n  mat a b c d => a + b + c + d\n  end.\n\nLemma a_d_not_0 : forall (m : SL2N) a b c d, eval m = mat a b c d ->\n  a <> 0 \/\\ d <> 0.\nProof.\n  induction m; cbn; intros;\n    try destruct (eval m);\n    inversion H; subst; auto;\n    edestruct IHm;\n    try (apply congMat; auto);\n    lia.\nQed.\n\n(* Prove that eval is injective, i.e. for any 2x2 matrix in the set SL2N, the representation is unique. *)\nTheorem eval_injective : forall m n : SL2N, eval m = eval n -> m = n.\nProof.\n  induction m; intros.\n  - apply f_equal with (f := sum_mat) in H.\n    cbn in H.\n    destruct n; auto; pose proof (a_d_not_0 n) as Had; cbn in H;\n      destruct (eval n); cbn in H;\n      edestruct Had; auto; lia.\n  - pose proof (a_d_not_0 m) as Had.\n    destruct n.\n    + apply f_equal with (f := sum_mat) in H.\n      cbn in H.\n      destruct (eval m).\n      edestruct Had; auto.\n      cbn in H.\n      lia.\n    + f_equal.\n      apply IHm.\n      cbn in H.\n      destruct (eval m).\n      destruct (eval n).\n      inversion H.\n      apply congMat; lia.\n    + inversion H.\n      destruct (eval m).\n      destruct (eval n).\n      inversion H1.\n      edestruct Had; auto.\n      lia.\n  - pose proof (a_d_not_0 m) as Had.\n    destruct n.\n    + apply f_equal with (f := sum_mat) in H.\n      cbn in H.\n      destruct (eval m).\n      edestruct Had; auto.\n      cbn in H.\n      lia.\n    + inversion H.\n      destruct (eval m).\n      destruct (eval n).\n      inversion H1.\n      edestruct Had; auto.\n      lia.\n    + f_equal.\n      apply IHm.\n      cbn in H.\n      destruct (eval m).\n      destruct (eval n).\n      inversion H.\n      apply congMat; lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32779,"user_id":null,"body":"From Coq Require Import Arith Bool Lia.\nRequire Import Recdef.\nRequire Import Preloaded.\n\nDefinition measure m := match m with | mat a b c d => a + b + c + d end.\nFunction reconstruct (m : Mat) { measure measure m } :=\n  match m with\n  | mat a b c d =>\n    if ((a =? 0) || (d =? 0) || ((b =? 0) && (c =? 0))) then I\n    else if (a <=? c) && (b <? d) then bot (reconstruct (mat a b (c - a) (d - b)))\n    else top (reconstruct (mat (a - c) (b - d) c d))\n  end.\nProof.\n  - intros. simpl.\n    rewrite 2!orb_false_iff in teq0.\n    destruct teq0 as ((H1 & H2) & H3).\n    apply Nat.eqb_neq in H1. apply Nat.eqb_neq in H2.\n    apply andb_false_iff in H3.\n    rewrite 2!Nat.eqb_neq in H3.\n    destruct H3 as [H3|H3]; lia.\n  - intros. simpl.\n    rewrite 2!orb_false_iff in teq0.\n    destruct teq0 as ((H1 & H2) & H3).\n    apply Nat.eqb_neq in H1. apply Nat.eqb_neq in H2.\n    apply andb_false_iff in H3.\n    rewrite 2!Nat.eqb_neq in H3.\n    destruct H3 as [H3|H3]; lia.\nDefined.\n\nFunctional Scheme eval_ind := Induction for eval Sort Prop.\n\nLemma eval_constraint_1 : forall m a b c d (Heval : eval m = mat a b c d), 1 <= a.\nProof.\n  intros m.\n  functional induction (eval m); intros; inversion Heval; subst; simpl in *;\n    try match goal with\n    | H : eval _ = _ , IH : forall _ _ _ _, eval _ = _ -> _ |- _ =>\n      apply IH in H\n    end;\n    lia.\nQed.\n\nLemma eval_constraint_2 : forall m a b c d (Heval : eval m = mat a b c d), 1 <= d.\nProof.\n  intros m.\n  functional induction (eval m); intros; inversion Heval; subst; simpl in *;\n    try match goal with\n    | H : eval _ = _ , IH : forall _ _ _ _, eval _ = _ -> _ |- _ =>\n      apply IH in H\n    end;\n    lia.\nQed.\n\nLemma reconstruct_eval : forall m, reconstruct (eval m) = m.\nProof.\n  intros.\n  functional induction (eval m).\n  - reflexivity.\n  - rewrite e0 in IHm0.\n    rewrite reconstruct_equation.\n    destruct (_ || _) eqn:Heqb.\n    + rewrite 2!orb_true_iff in Heqb. destruct Heqb as [[Heqb|Heqb]|Heqb].\n      * apply eval_constraint_1 in e0. apply Nat.eqb_eq in Heqb. lia.\n      * apply eval_constraint_2 in e0. apply Nat.eqb_eq in Heqb. lia.\n      * apply eval_constraint_2 in e0. apply andb_true_iff in Heqb.\n        destruct Heqb as (Heqb & _). apply Nat.eqb_eq in Heqb. lia.\n    + rewrite (proj2 (Nat.ltb_ge _ _)) by lia.\n      apply eval_constraint_1 in e0.\n      rewrite (proj2 (Nat.leb_gt _ _)) by lia.\n      rewrite 2!Nat.add_sub. simpl. f_equal. assumption.\n  - rewrite e0 in IHm0.\n    rewrite reconstruct_equation.\n    destruct (_ || _) eqn:Heqb.\n    + rewrite 2!orb_true_iff in Heqb. destruct Heqb as [[Heqb|Heqb]|Heqb].\n      * apply eval_constraint_1 in e0. apply Nat.eqb_eq in Heqb. lia.\n      * apply eval_constraint_2 in e0. apply Nat.eqb_eq in Heqb. lia.\n      * apply eval_constraint_1 in e0. apply andb_true_iff in Heqb.\n        destruct Heqb as (_ & Heqb). apply Nat.eqb_eq in Heqb. lia.\n    + rewrite (proj2 (Nat.leb_le _ _)) by lia.\n      apply eval_constraint_2 in e0.\n      rewrite (proj2 (Nat.ltb_lt _ _)) by lia.\n      rewrite 2!minus_plus. simpl. f_equal. assumption.\nQed.\n\n(* Prove that eval is injective, i.e. for any 2x2 matrix in the set SL2N, the representation is unique. *)\nTheorem eval_injective : forall m n : SL2N, eval m = eval n -> m = n.\nProof.\n  intros.\n  apply (f_equal reconstruct) in H.\n  rewrite 2!reconstruct_eval in H. assumption.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5ca3fcc8f7fb0800201ba88f":[{"id":32780,"user_id":1084,"body":"Require Import Preloaded.\nRequire Import Arith.\n\nRequire Import Arith.\n\n(* Task 0 : Example of iso in finite sets *)\n(* Find a bijection between bool and bit. (provided for you as an example) *)\nInductive bit : Set := b0 | b1.\n\nDefinition bool2bit (b : bool) : bit :=\n  match b with true => b1 | false => b0\n  end.\n\nDefinition bit2bool (b : bit) : bool :=\n  match b with b1 => true | b0 => false\n  end.\n\nDefinition bool_iso_bit : iso bool bit.\nProof. apply (bijection _ _ bool2bit bit2bool); intros []; auto. Qed.\n\n(******************************************)\n\n(* Task 1 : General properties of iso *)\n(* Task 1-1. Prove that any set has the same cardinality as itself. *)\nTheorem iso_refl : forall A : Set, iso A A.\nProof. intros; apply (bijection _ _ id id); intros; simpl in *; auto. Qed.\n\n(* Task 1-2. Prove that iso is symmetric. *)\nTheorem iso_sym : forall A B : Set, iso A B -> iso B A.\nProof. destruct 1. apply (bijection _ _ B_to_A A_to_B); auto. Qed.\n\n(* Task 1-3. Prove that iso is transitive. *)\nTheorem iso_trans : forall A B C : Set, iso A B -> iso B C -> iso A C.\nProof.\n  destruct 1, 1.\n  apply (bijection _ _ (fun x => A_to_B0 (A_to_B x)) (fun x => B_to_A (B_to_A0 x)));\n    intros; congruence.\nQed.\n(* Task 1-4. Prove the following statement:\n  Given two functions A->B and B->A, if A->B->A is satisfied and B->A is injective, A <=> B. *)\nTheorem bijection_alt : forall (A B : Set) (A2B : A -> B) (B2A : B -> A),\n  (forall a, B2A (A2B a) = a) -> (forall b1 b2, B2A b1 = B2A b2 -> b1 = b2) -> iso A B.\nProof.\n  intros; apply (bijection _ _ A2B B2A); intros; try apply H0; congruence.\nQed.\n\n(******************************************)\n(* Task 2 : iso relations between nat and various supersets of nat *)\n\n(* nat_plus_1 : a set having one more element than nat. (provided in preloaded) *)\n(* Inductive nat_plus_1 : Set := null | is_nat (n : nat). *)\n\n(* Task 2-1. Prove that nat has the same cardinality as nat_plus_1. *)\nTheorem nat_iso_natp1 : iso nat nat_plus_1.\nProof.\n  apply (bijection _ _\n                   (fun x => match x with O => null | S n => is_nat n end)\n                   (fun x => match x with null => 0 | is_nat n => S n end));\n    intros; destruct a || destruct b; auto.\nQed.\n\n(* nat_plus_nat : a set having size(nat) more elements than nat. (provided in preloaded) *)\n(* Inductive nat_plus_nat : Set := left (n : nat) | right (n : nat). *)\n\n(* Task 2-2. Prove that nat has the same cardinality as nat_plus_nat. *)\nFixpoint nat_nat_plus_nat (n : nat) :=\n  match n with\n  | O => left O\n  | S n => match nat_nat_plus_nat n with\n           | left n => right n\n           | right n => left (S n)\n           end\n  end.\nDefinition nat_plus_nat_nat (n : nat_plus_nat) :=\n  match n with\n  | left n => n * 2\n  | right n => S (n * 2)\n  end.\n\nTheorem nat_iso_natpnat : iso nat nat_plus_nat.\nProof.\n  apply (bijection _ _ nat_nat_plus_nat nat_plus_nat_nat); unfold nat_plus_nat_nat; intros.\n  + induction a; simpl in *; auto; [].\n    destruct nat_nat_plus_nat; subst; simpl in *; auto.\n  + destruct b; induction n; simpl in *; rewrite ?IHn; auto.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32781,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Arith.\n\n(* Task 0 : Example of iso in finite sets *)\n(* Find a bijection between bool and bit. (provided for you as an example) *)\nInductive bit : Set := b0 | b1.\n\nDefinition bool2bit (b : bool) : bit :=\n  match b with true => b1 | false => b0\n  end.\n\nDefinition bit2bool (b : bit) : bool :=\n  match b with b1 => true | b0 => false\n  end.\n\nDefinition bool_iso_bit : iso bool bit.\nProof. apply (bijection _ _ bool2bit bit2bool); intros []; auto. Qed.\n\n(******************************************)\n(* Task 1 : General properties of iso *)\n(* Task 1-1. Prove that any set has the same cardinality as itself. *)\nTheorem iso_refl : forall A : Set, iso A A.\nProof. intro A; apply (bijection _ _ id id); reflexivity. Qed.\n  \n(* Task 1-2. Prove that iso is symmetric. *)\nTheorem iso_sym : forall A B : Set, iso A B -> iso B A.\nProof.\n  intros A B [fab fba aba bab].\n  exact (bijection _ _ fba fab bab aba).\nQed.\n\n(* Task 1-3. Prove that iso is transitive. *)\nTheorem iso_trans : forall A B C : Set, iso A B -> iso B C -> iso A C.\nProof.\n  intros A B C [fab fba aba bab] [fbc fcb bcb cbc].\n  apply (bijection _ _ (fun x => fbc (fab x)) (fun x => fba (fcb x))).\n  intro x; rewrite bcb; rewrite aba; reflexivity.\n  intro x; rewrite bab; rewrite cbc; reflexivity.\nQed.\n\n(* Task 1-4. Prove the following statement:\n  Given two functions A->B and B->A, if A->B->A is satisfied and B->A is injective, A <=> B. *)\nTheorem bijection_alt : forall (A B : Set) (A2B : A -> B) (B2A : B -> A),\n  (forall a, B2A (A2B a) = a) -> (forall b1 b2, B2A b1 = B2A b2 -> b1 = b2) -> iso A B.\nProof.\n  intros A B fab fba aba Hfba.\n  apply (bijection _ _ fab fba aba).\n  intro b.\n  apply (Hfba (fab (fba b)) b).\n  rewrite aba.\n  reflexivity.\nQed.\n\n(******************************************)\n(* Task 2 : iso relations between nat and various supersets of nat *)\n\n(* nat_plus_1 : a set having one more element than nat. (provided in preloaded) *)\n(* Inductive nat_plus_1 : Set := null | is_nat (n : nat). *)\n\n(* Task 2-1. Prove that nat has the same cardinality as nat_plus_1. *)\n\nDefinition nat_to_natplus1 n :=\n  match n with\n  | O => null\n  | S n' => is_nat n'\n  end.\n\nDefinition natplus1_to_nat n1 :=\n  match n1 with\n  | null => O\n  | is_nat n => S n\n  end.\n\nTheorem nat_iso_natp1 : iso nat nat_plus_1.\nProof.\n  apply (bijection _ _ nat_to_natplus1 natplus1_to_nat);\n  intro n; elim n; simpl; reflexivity.\nQed.\n\n(* nat_plus_nat : a set having size(nat) more elements than nat. (provided in preloaded) *)\n(* Inductive nat_plus_nat : Set := left (n : nat) | right (n : nat). *)\n\n(* Task 2-2. Prove that nat has the same cardinality as nat_plus_nat. *)\n\n\nDefinition nat_plus_nat_to_nat npn :=\n  match npn with\n  | left n => 2 * n\n  | right n => S (2 * n)\n  end.\n\nDefinition nat_to_nat_plus_nat (n : nat) : nat_plus_nat :=\n  if Nat.even n then left (Nat.div2 n) else right (Nat.div2 n).\n\nLemma even_2n n :  Nat.even (2 * n) = true.\nProof.\n  rewrite  <- (Nat.add_0_l (2*n)).\n  rewrite Nat.even_add_mul_2.\n  simpl; reflexivity.\nQed.\n\nLemma odd_S2n n :  Nat.even (S (2 * n)) = false.\nProof.\n  rewrite Nat.even_succ.\n  rewrite <- Nat.negb_even.\n  rewrite even_2n.\n  simpl; reflexivity.\nQed.\n\nDefinition nat_plus_nat_get_n npn :=\n  match npn with | left n => n | right n => n end.\n\nLemma left_inj a b : left a = left b -> a = b.\nProof.\n  intros H.\n  apply (f_equal nat_plus_nat_get_n) in H.\n  simpl in H; assumption.\nQed.\n\nLemma right_inj a b : right a = right b -> a  = b.\nProof.\n  intros H.\n  apply (f_equal nat_plus_nat_get_n) in H.\n  simpl in H; assumption.\nQed.\n\nLemma div_even_inj a b : Nat.even a = Nat.even b ->  Nat.div2 a = Nat.div2 b -> a = b.\nProof.\n  intros ev H.\n  rewrite Nat.div2_odd.\n  rewrite <- H.\n  rewrite <- Nat.negb_even.\n  rewrite <- ev.\n  rewrite Nat.negb_even.\n  rewrite <- Nat.div2_odd.\n  reflexivity.\nQed.\n\nLemma nat_to_nat_pus_nat_inj :\n  forall a b : nat, nat_to_nat_plus_nat a = nat_to_nat_plus_nat b -> a = b.\nProof.\n  unfold nat_to_nat_plus_nat.\n  intros a b.\n  generalize (eq_refl :  Nat.even a = Nat.even a);\n    pattern (Nat.even a) at 1;\n    case (Nat.even a); intro Eva;\n    generalize (eq_refl :  Nat.even b = Nat.even b);\n    pattern (Nat.even b ) at 1;\n    case (Nat.even b); intro Evb;\n    rewrite <- Eva; rewrite <- Evb.\n  * intro H; apply div_even_inj.\n   rewrite <- Eva; rewrite <- Evb; reflexivity.\n   apply (left_inj _ _ H).\n  * discriminate.\n  * discriminate.\n  * intro H; apply div_even_inj.\n   rewrite <- Eva; rewrite <- Evb; reflexivity.\n   apply (right_inj _ _ H).\nQed.\n\nLemma fold_mul2 n : n + (n + 0) =  2 * n.\nProof. reflexivity. Qed.\n\nTheorem nat_iso_natpnat : iso nat nat_plus_nat.\nProof.\n  refine (iso_sym _ _ (bijection_alt _ _ nat_plus_nat_to_nat nat_to_nat_plus_nat _ _)).\n  intro n; elim n; clear n;\n    intros; simpl;\n    rewrite fold_mul2;\n    unfold nat_to_nat_plus_nat;\n    rewrite ?Nat.div2_double; rewrite ?Nat.div2_succ_double;\n    rewrite ?even_2n; rewrite ?odd_S2n;\n    reflexivity.\n  apply nat_to_nat_pus_nat_inj.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32782,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Arith.\nRequire Import Lia.\n(* Task 0 : Example of iso in finite sets *)\n(* Find a bijection between bool and bit. (provided for you as an example) *)\nInductive bit : Set := b0 | b1.\n\nDefinition bool2bit (b : bool) : bit :=\n  match b with true => b1 | false => b0\n  end.\n\nDefinition bit2bool (b : bit) : bool :=\n  match b with b1 => true | b0 => false\n  end.\n\nDefinition bool_iso_bit : iso bool bit.\nProof. apply (bijection _ _ bool2bit bit2bool); intros []; auto. Qed.\n\n(******************************************)\n(* Task 1 : General properties of iso *)\n(* Task 1-1. Prove that any set has the same cardinality as itself. *)\nTheorem iso_refl : forall A : Set, iso A A.\nProof. \n  intros.\n  econstructor; eauto.\n  {\n    instantiate (1 := fun x => x); \n    instantiate (1 := fun x => x). \n    intros.\n    simpl.\n    trivial.\n  }\n  {\n    intros.\n    simpl.\n    trivial.\n  }\nQed.\n\n(* Task 1-2. Prove that iso is symmetric. *)\nTheorem iso_sym : forall A B : Set, iso A B -> iso B A.\nProof. \n  intros.\n  inversion H.\n  econstructor; eauto.\nQed.\n\n(* Task 1-3. Prove that iso is transitive. *)\nTheorem iso_trans : forall A B C : Set, iso A B -> iso B C -> iso A C.\nProof. \n  intros.\n  inversion H. inversion H0.\n  econstructor; eauto.\n  instantiate (1:= fun a => A_to_B0 (A_to_B a)). \n  instantiate (1:= fun c => B_to_A (B_to_A0 c)).\n  {\n    simpl. \n    intros.\n    rewrite A_B_A0.\n    rewrite A_B_A.\n    trivial.\n   }\n  {\n    intros; simpl.\n    rewrite B_A_B.\n    rewrite B_A_B0.\n    trivial.\n  }\nQed.\n\n(* Task 1-4. Prove the following statement:\n  Given two functions A->B and B->A, if A->B->A is satisfied and B->A is injective, A <=> B. *)\nTheorem bijection_alt : forall (A B : Set) (A2B : A -> B) (B2A : B -> A),\n  (forall a, B2A (A2B a) = a) -> (forall b1 b2, B2A b1 = B2A b2 -> b1 = b2) -> iso A B.\nProof. \n  intros.\n  econstructor. eauto. \n  intros. \n  specialize (H (B2A b)).\n  apply H0 in H.\n  trivial.\nQed.\n\n(******************************************)\n(* Task 2 : iso relations between nat and various supersets of nat *)\n\n(* nat_plus_1 : a set having one more element than nat. (provided in preloaded) *)\n(* Inductive nat_plus_1 : Set := null | is_nat (n : nat). *)\n(* Task 2-1. Prove that nat has the same cardinality as nat_plus_1. *)\nTheorem nat_iso_natp1 : iso nat nat_plus_1.\nProof. \n  econstructor; eauto.\n  instantiate (1:=fun n => \n    match n with \n    | O => null\n    | S n' => is_nat n'\n    end\n    ).\n  instantiate (1:= fun n' => \n    match n' with \n    | null => O\n    | is_nat n => S n\n    end\n    ).\n   intros.\n   simpl.\n   destruct a; eauto.\n   intros. simpl.\n   destruct b; eauto.\nQed.\n\n(* nat_plus_nat : a set having size(nat) more elements than nat. (provided in preloaded) *)\n(* Inductive nat_plus_nat : Set := left (n : nat) | right (n : nat). *)\n\nFixpoint nat_nat_plus_nat (n : nat) :=\n  match n with\n  | O => left O\n  | S n => match nat_nat_plus_nat n with\n           | left n => right n\n           | right n => left (S n)\n           end\n  end.\n \nLemma double_n_nat_nat_plus_nat_is_left_n: \n    forall n, nat_nat_plus_nat (2 * n) = left n.\nProof.\n  intros.\n  induction n.\n  simpl; trivial.\n  simpl.\n  replace (n + S(n+0)) with (S (2 *n)). 2: {lia. }\n  unfold nat_nat_plus_nat. fold nat_nat_plus_nat.\n  rewrite IHn. trivial.\nQed.\n\nLemma double_n_plus_one_nat_nat_plus_nat_is_left_n: \n    forall n, nat_nat_plus_nat (2 * n + 1) = right n.\nProof.\n  intros.\n  induction n.\n  simpl; trivial.\n  simpl.\n  replace (n + S(n+0) + 1) with ((2 *(n+1))). 2: {lia. }\n  rewrite double_n_nat_nat_plus_nat_is_left_n. \n  eapply f_equal. lia. \nQed.\n\n(* Task 2-2. Prove that nat has the same cardinality as nat_plus_nat. *)\nTheorem nat_iso_natpnat : iso nat nat_plus_nat.\nProof. \n  econstructor; eauto.\n  instantiate (1:= nat_nat_plus_nat).\n  instantiate (1:= fun n' =>\n    match n' with \n    | left n => 2*n\n    | right n => 2*n+1\n    end  \n  ).\n  {\n    induction a.\n    simpl; trivial.\n    {\n        simpl.\n        destruct (nat_nat_plus_nat a) eqn:Eq; eauto; lia.\n    }\n  }\n  {\n    destruct b; eauto.\n    eapply double_n_nat_nat_plus_nat_is_left_n.\n    eapply double_n_plus_one_nat_nat_plus_nat_is_left_n.\n  }\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32783,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Arith.\n\n(* Task 0 : Example of iso in finite sets *)\n(* Find a bijection between bool and bit. (provided for you as an example) *)\nInductive bit : Set := b0 | b1.\n\nDefinition bool2bit (b : bool) : bit :=\n  match b with true => b1 | false => b0\n  end.\n\nDefinition bit2bool (b : bit) : bool :=\n  match b with b1 => true | b0 => false\n  end.\n\nDefinition bool_iso_bit : iso bool bit.\nProof. apply (bijection _ _ bool2bit bit2bool); intros []; auto. Qed.\n\n(******************************************)\n(* Task 1 : General properties of iso *)\n(* Task 1-1. Prove that any set has the same cardinality as itself. *)\nDefinition iso_refl : forall A : Set, iso A A\n  := fun A => bijection A A (fun x => x) (fun x => x) (fun x => eq_refl) (fun x => eq_refl).\n\n(* Task 1-2. Prove that iso is symmetric. *)\nArguments A_to_B [A] [B] _ _.\nArguments B_to_A [A] [B] _ _.\nArguments A_B_A [A] [B] _ _.\nArguments B_A_B [A] [B] _ _.\nDefinition iso_sym : forall A B : Set, iso A B -> iso B A\n  := fun A B i => bijection B A (B_to_A i) (A_to_B i) (B_A_B i) (A_B_A i).\n\n(* Task 1-3. Prove that iso is transitive. *)\nDefinition iso_trans : forall A B C : Set, iso A B -> iso B C -> iso A C\n  := fun A B C iAB iBC =>\n       bijection\n         A C\n         (fun x => A_to_B iBC (A_to_B iAB x))\n         (fun x => B_to_A iAB (B_to_A iBC x))\n         (fun x =>\n            eq_ind (A_to_B iAB x) (fun y => B_to_A iAB y = x)\n                   (A_B_A iAB x)\n                   (B_to_A iBC (A_to_B iBC (A_to_B iAB x)))\n                   (eq_sym (A_B_A iBC (A_to_B iAB x))))\n         (fun x =>\n            eq_ind (B_to_A iBC x) (fun y => A_to_B iBC y = x)\n                   (B_A_B iBC x)\n                   (A_to_B iAB (B_to_A iAB (B_to_A iBC x)))\n                   (eq_sym (B_A_B iAB (B_to_A iBC x)))).\n\n\n(* Task 1-4. Prove the following statement:\n  Given two functions A->B and B->A, if A->B->A is satisfied and B->A is injective, A <=> B. *)\nDefinition bijection_alt : forall (A B : Set) (A2B : A -> B) (B2A : B -> A),\n  (forall a, B2A (A2B a) = a) -> (forall b1 b2, B2A b1 = B2A b2 -> b1 = b2) -> iso A B\n  := fun A B A2B B2A ABA BAinj =>\n       bijection A B A2B B2A ABA (fun b => BAinj _ _ (ABA (B2A b))).\n\n(******************************************)\n(* Task 2 : iso relations between nat and various supersets of nat *)\n\n(* nat_plus_1 : a set having one more element than nat. (provided in preloaded) *)\n(* Inductive nat_plus_1 : Set := null | is_nat (n : nat). *)\n\n(* Task 2-1. Prove that nat has the same cardinality as nat_plus_1. *)\nDefinition nat_iso_natp1 : iso nat nat_plus_1\n  := bijection\n       nat nat_plus_1\n       (fun a => match a with | O => null | S n => is_nat n end)\n       (fun b => match b with | null => O | is_nat n => S n end)\n       (fun a => match a with | O => eq_refl | S _ => eq_refl end)\n       (fun b => match b with | null => eq_refl | is_nat _ => eq_refl end).\n\n(* nat_plus_nat : a set having size(nat) more elements than nat. (provided in preloaded) *)\n(* Inductive nat_plus_nat : Set := left (n : nat) | right (n : nat). *)\n\n(* Task 2-2. Prove that nat has the same cardinality as nat_plus_nat. *)\nDefinition nat_iso_natpnat : iso nat nat_plus_nat\n  := let A2B_step :=\n         fun _ x => match x with\n                 | left n => right n\n                 | right n => left (S n)\n                 end in\n     let A2B :=\n         nat_rec (fun _ => nat_plus_nat) (left O) A2B_step in\n     let double := nat_rec (fun _ => nat) O (fun _ x => S (S x)) in\n     let B2A :=\n         fun x => match x with\n               | left n => double n\n               | right n => S (double n)\n               end in\n     bijection\n       nat (nat_plus_nat)\n       A2B\n       B2A\n       (nat_ind (fun n => B2A (A2B n) = n)\n                eq_refl\n                (fun n prfn =>\n                   match A2B n as Bn\n                         return B2A Bn = n -> B2A (A2B_step (S n) Bn) = S n with\n                   | left n' =>\n                     fun prfn => eq_ind n (fun m => S m = S n)\n                                     eq_refl _ (eq_sym prfn)\n                   | right n' =>\n                     fun prfn => eq_ind n (fun m => S m = S n)\n                                     eq_refl _ (eq_sym prfn)\n                   end prfn))\n       (fun b =>\n          match b as bn return A2B (B2A bn) = bn with\n          | left n =>\n            nat_ind\n              (fun n => A2B (double n) = left n)\n              eq_refl\n              (fun m prfn =>\n                 eq_ind (left m)\n                        (fun bb => A2B_step (S m) (A2B_step m bb) = left (S m))\n                        eq_refl _ (eq_sym prfn))\n              n\n          | right n =>\n            nat_ind\n              (fun n => A2B (S (double n)) = right n)\n              eq_refl\n              (fun m prfn =>\n                 eq_ind (right m)\n                        (fun bb => A2B_step (S m) (A2B_step m bb) = right (S m))\n                        eq_refl _ (eq_sym prfn))\n              n\n          end).\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32784,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Arith.\n\n(* Task 0 : Example of iso in finite sets *)\n(* Find a bijection between bool and bit. (provided for you as an example) *)\nInductive bit : Set := b0 | b1.\n\nDefinition bool2bit (b : bool) : bit :=\n  match b with true => b1 | false => b0\n  end.\n\nDefinition bit2bool (b : bit) : bool :=\n  match b with b1 => true | b0 => false\n  end.\n\nDefinition bool_iso_bit : iso bool bit.\nProof. apply (bijection _ _ bool2bit bit2bool); intros []; auto. Qed.\n\n(******************************************)\n(* Task 1 : General properties of iso *)\n(* Task 1-1. Prove that any set has the same cardinality as itself. *)\nTheorem iso_refl : forall A : Set, iso A A.\nProof.\n  intros; refine (bijection _ _ _ _ _ _). Unshelve.\n  3: { intros x; exact x. }\n  3: { intros x; exact x. }\n  - easy.\n  - easy.\nQed.\n\n(* Task 1-2. Prove that iso is symmetric. *)\nTheorem iso_sym : forall A B : Set, iso A B -> iso B A.\nProof. intros A B [AB BA ABA BAB]; exact (bijection _ _ BA AB BAB ABA). Qed.\n\n(* Task 1-3. Prove that iso is transitive. *)\nTheorem iso_trans : forall A B C : Set, iso A B -> iso B C -> iso A C.\nProof.\n  intros A B C [AB BA ABA BAB] [BC CB BCB CBC]; refine (bijection _ _ _ _ _ _). Unshelve.\n  3: { intros x; apply BC, AB, x. }\n  3: { intros x; apply BA, CB, x. }\n  - simpl; intros; now rewrite BCB, ABA.\n  - simpl; intros; now rewrite BAB, CBC.\nQed.\n\n(* Task 1-4. Prove the following statement:\n  Given two functions A->B and B->A, if A->B->A is satisfied and B->A is injective, A <=> B. *)\nTheorem bijection_alt : forall (A B : Set) (A2B : A -> B) (B2A : B -> A),\n  (forall a, B2A (A2B a) = a) -> (forall b1 b2, B2A b1 = B2A b2 -> b1 = b2) -> iso A B.\nProof.\n  intros A B AB BA ABA BAinj; apply (bijection _ _ AB BA ABA).\n  intros b; apply BAinj; now rewrite ABA.\nQed.\n\n(******************************************)\n(* Task 2 : iso relations between nat and various supersets of nat *)\n(* Task 2-1. Prove that nat has the same cardinality as nat_plus_1. *)\nTheorem nat_iso_natp1 : iso nat nat_plus_1.\nProof.\n  refine (bijection _ _ _ _ _ _). Unshelve.\n  3: { intros [|n]; [apply null|apply is_nat, n]. }\n  3: { intros [|n]; [apply 0|apply S, n]. }\n  - now intros [|n].\n  - now intros [|n].\nQed.\n\n(* Task 2-2. Prove that nat has the same cardinality as nat_plus_nat. *)\nFixpoint nat_to_plus (n : nat) : nat_plus_nat :=\n  match n with\n  | 0 => left 0\n  | 1 => right 0\n  | S (S n') => match nat_to_plus n' with\n    | left m => left (S m)\n    | right m => right (S m)\n    end\n  end.\n\nTheorem nat_iso_natpnat : iso nat nat_plus_nat.\nProof.\n  refine (bijection _ _ _ _ _ _). Unshelve.\n  3: { exact nat_to_plus. }\n  3: { intros [n|n]; [|apply S]; exact (n + n). }\n  - intros n; simpl.\n    set (P := fun n => match nat_to_plus n with | left n => n + n | right n => S (n + n) end = n).\n    cut (P n \/\\ P (S n)); [now intros [H _]|].\n    induction n; [easy|].\n    destruct IHn as [IHn IHSn]; split; [easy|clear IHSn].\n    unfold P in *; simpl; destruct (nat_to_plus n) as [m|m]; rewrite <- IHn; ring.\n  - intros [n|n]; (induction n; [easy|]).\n    + replace (S n + S n) with (S (S (n + n))); [|ring].\n      simpl; now rewrite IHn.\n    + simpl; replace (n + S n) with (S (n + n)); [|ring].\n      now rewrite IHn.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32785,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Arith Div2 Coq.Program.Basics.\nOpen Scope program_scope.\n\n(* Task 0 : Example of iso in finite sets *)\n(* Find a bijection between bool and bit. (provided for you as an example) *)\nInductive bit : Set := b0 | b1.\n\nDefinition bool2bit (b : bool) : bit :=\n  match b with true => b1 | false => b0\n  end.\n\nDefinition bit2bool (b : bit) : bool :=\n  match b with b1 => true | b0 => false\n  end.\n\nDefinition bool_iso_bit : iso bool bit.\nProof. apply (bijection _ _ bool2bit bit2bool); intros []; auto. Qed.\n\n(******************************************)\n(* Task 1 : General properties of iso *)\n(* Task 1-1. Prove that any set has the same cardinality as itself. *)\nTheorem iso_refl : forall A : Set, iso A A.\nProof. intros A. apply (bijection A A id id); auto. Qed.\n\n(* Task 1-2. Prove that iso is symmetric. *)\nTheorem iso_sym : forall A B : Set, iso A B -> iso B A.\nProof. intros A B [AB BA ABA BAB]. exact (bijection _ _ BA AB BAB ABA). Qed.\n\n(* Task 1-3. Prove that iso is transitive. *)\nTheorem iso_trans : forall A B C : Set, iso A B -> iso B C -> iso A C.\nProof.\n  intros A B C [AB BA ABA BAB] [BC CB BCB CBC].\n  apply (bijection _ _ (BC \u2218 AB) (BA \u2218 CB)).\n  - unfold compose. intros.\n    rewrite BCB. auto.\n  - unfold compose. intros.\n    rewrite BAB. auto.\nQed.\n\n(* Task 1-4. Prove the following statement:\n  Given two functions A->B and B->A, if A->B->A is satisfied and B->A is injective, A <=> B. *)\nTheorem bijection_alt : forall (A B : Set) (A2B : A -> B) (B2A : B -> A),\n  (forall a, B2A (A2B a) = a) -> (forall b1 b2, B2A b1 = B2A b2 -> b1 = b2) -> iso A B.\nProof.\n  intros A B AB BA ABA H.\n  apply (bijection _ _ AB BA ABA).\n  intros b.\n  remember (AB (BA b)) as b1 eqn:Heq.\n  apply (f_equal BA) in Heq.\n  rewrite ABA in Heq.\n  apply H.\n  assumption.\nQed.\n\n(******************************************)\n(* Task 2 : iso relations between nat and various supersets of nat *)\n\n(* nat_plus_1 : a set having one more element than nat. (provided in preloaded) *)\n(* Inductive nat_plus_1 : Set := null | is_nat (n : nat). *)\n\n(* Task 2-1. Prove that nat has the same cardinality as nat_plus_1. *)\n\nDefinition NP_21 (n : nat) : nat_plus_1 := match n with | O => null | S n' => is_nat n' end.\nDefinition PN_21 (p : nat_plus_1) : nat := match p with | null => O | is_nat n' => S n' end.\n\nTheorem nat_iso_natp1 : iso nat nat_plus_1.\nProof.\n  apply (bijection _ _ NP_21 PN_21); intros x; destruct x; auto.\nQed.\n\n(* nat_plus_nat : a set having size(nat) more elements than nat. (provided in preloaded) *)\n(* Inductive nat_plus_nat : Set := left (n : nat) | right (n : nat). *)\n\n(* Task 2-2. Prove that nat has the same cardinality as nat_plus_nat. *)\n\nDefinition helper (p : nat_plus_nat) : nat_plus_nat := match p with | left n => left (S n) | right n => right (S n) end.\nFixpoint NP_22 (n : nat) : nat_plus_nat := match n with | O => left O | S O => right O | S (S n') => helper (NP_22 n') end.\nFixpoint double (n : nat) : nat := match n with | O => O | S n' => S (S (double n')) end.\nDefinition PN_22 (p : nat_plus_nat) : nat := match p with | left n => double n | right n => S (double n) end.\n\nTheorem nat_iso_natpnat : iso nat nat_plus_nat.\nProof.\n  apply (bijection _ _ NP_22 PN_22).\n  - intros n. induction n using ind_0_1_SS.\n    + auto.\n    + auto.\n    + simpl. destruct (NP_22 n) as [n' | n']; simpl in *; rewrite IHn; reflexivity.\n  - intros p. destruct p as [n | n].\n    + simpl. induction n; try auto.\n      simpl. rewrite IHn. auto.\n    + simpl PN_22. induction n; auto.\n      simpl double. replace (NP_22 (S (S (S (double n))))) with (helper (NP_22 (S (double n)))) by (simpl; auto).\n      rewrite IHn; auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32786,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Arith Program.Basics Lia.\nLocal Open Scope program_scope.\n\n(* Task 0 : Example of iso in finite sets *)\n(* Find a bijection between bool and bit. (provided for you as an example) *)\nInductive bit : Set := b0 | b1.\n\nDefinition bool2bit (b : bool) : bit :=\n  match b with true => b1 | false => b0\n  end.\n\nDefinition bit2bool (b : bit) : bool :=\n  match b with b1 => true | b0 => false\n  end.\n\nDefinition bool_iso_bit : iso bool bit.\nProof. apply (bijection _ _ bool2bit bit2bool); intros []; auto. Qed.\n\n(******************************************)\n(* Task 1 : General properties of iso *)\n(* Task 1-1. Prove that any set has the same cardinality as itself. *)\nTheorem iso_refl : forall A : Set, iso A A.\nProof. intro A; apply (bijection A A id id); auto. Qed.\n\n(* Task 1-2. Prove that iso is symmetric. *)\nTheorem iso_sym : forall A B : Set, iso A B -> iso B A.\nProof. intros A B [f g Hgf Hfg]; apply (bijection B A g f Hfg Hgf). Qed.\n\n(* Task 1-3. Prove that iso is transitive. *)\nTheorem iso_trans : forall A B C : Set, iso A B -> iso B C -> iso A C.\nProof.\n  intros A B C [AB BA HBAAB HABBA] [BC CB HCBBC HBCCB].\n  apply (bijection A C (BC \u2218 AB) (BA \u2218 CB)); unfold compose.\n  - intro a; rewrite HCBBC; auto.\n  - intro c; rewrite HABBA; auto.\nQed.\n\n(* Task 1-4. Prove the following statement:\n  Given two functions A->B and B->A, if A->B->A is satisfied and B->A is injective, A <=> B. *)\nTheorem bijection_alt : forall (A B : Set) (A2B : A -> B) (B2A : B -> A),\n    (forall a, B2A (A2B a) = a) -> (forall b1 b2, B2A b1 = B2A b2 -> b1 = b2) -> iso A B.\nProof.\n  intros A B A2B B2A HABA Hinj.\n  econstructor.\n  - apply HABA.\n  - intro b; apply Hinj; rewrite HABA; reflexivity.\nQed.\n\n(******************************************)\n(* Task 2 : iso relations between nat and various supersets of nat *)\n\n(* nat_plus_1 : a set having one more element than nat. (provided in preloaded) *)\n\n(* Task 2-1. Prove that nat has the same cardinality as nat_plus_1. *)\nTheorem nat_iso_natp1 : iso nat nat_plus_1.\nProof.\n  apply (bijection nat nat_plus_1\n                   (fun n => match n with\n                          | O => null\n                          | S n' => is_nat n'\n                          end)\n                   (fun n => match n with\n                          | null => O\n                          | is_nat n' => S n'\n                          end)); intros []; reflexivity.\nQed.\n\n(* nat_plus_nat : a set having size(nat) more elements than nat. (provided in preloaded) *)\n\nFixpoint nat_to_nat_plus_nat (n : nat) : nat_plus_nat :=\n  match n with\n  | O => left n\n  | S n' => match nat_to_nat_plus_nat n' with\n           | left n'' => right n''\n           | right n'' => left (S n'')\n           end\n  end.\n\nDefinition nat_plus_nat_to_nat (n : nat_plus_nat) : nat :=\n  match n with\n  | left n' => 2 * n'\n  | right n' => 2 * n' + 1\n  end.\n\nLemma nat_to_nat_plus_nat_left n:\n  nat_to_nat_plus_nat (n + n) = left n.\nProof.\n  induction n; simpl; auto.\n  rewrite Nat.add_succ_r; simpl.\n  rewrite IHn; reflexivity.\nQed.\n\nLemma nat_to_nat_plus_nat_right n:\n  nat_to_nat_plus_nat (n + n + 1) = right n.\nProof.\n  induction n; simpl; auto.\n  rewrite Nat.add_succ_r; simpl.\n  replace (n + S n + 0) with (n + n + 1) by lia.\n  rewrite IHn; reflexivity.\nQed.\n\n(* Task 2-2. Prove that nat has the same cardinality as nat_plus_nat. *)\nTheorem nat_iso_natpnat : iso nat nat_plus_nat.\nProof.\n  apply (bijection nat nat_plus_nat nat_to_nat_plus_nat nat_plus_nat_to_nat).\n  - intro n; induction n; simpl; auto.\n    destruct (nat_to_nat_plus_nat n); simpl in *; lia.\n  - intro n; destruct n; simpl.\n    + rewrite Nat.add_0_r; apply nat_to_nat_plus_nat_left.\n    + rewrite Nat.add_0_r; apply nat_to_nat_plus_nat_right.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32787,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Arith ssreflect ssrfun.\n\n(* Task 1-1. *)\nTheorem iso_refl : forall A : Set, iso A A.\nProof. by move=> A; apply: (bijection _ _ id id). Qed.\n\n(* Task 1-2. *)\nTheorem iso_sym : forall A B : Set, iso A B -> iso B A.\nProof. by move=> A B [A2B B2A ABA BAB]; apply (bijection _ _ _ _ BAB ABA). Qed.\n\n(* Task 1-3. *)\nTheorem iso_trans : forall A B C : Set, iso A B -> iso B C -> iso A C.\nProof.\n  move=> A B C [A2B B2A ABA BAB] [B2C C2B BCB CBC].\n  apply: (bijection _ _ (B2C \\o A2B) (B2A \\o C2B)) => [a|c] \/=.\n    by rewrite BCB.\n  by rewrite BAB.\nQed.\n\n(* Task 1-4. *)\nTheorem bijection_alt : forall (A B : Set) (A2B : A -> B) (B2A : B -> A),\n    (forall a, B2A (A2B a) = a) ->\n  (forall b1 b2, B2A b1 = B2A b2 -> b1 = b2) -> iso A B.\nProof.\n  move=> A B A2B B2A ABA B2Ainj.\n  apply: (bijection _ _ _ _ ABA) => b.\n  by apply: B2Ainj; rewrite ABA.\nQed.\n\n(******************************************)\n\n(* Task 2-1. *)\nTheorem nat_iso_natp1 : iso nat nat_plus_1.\nProof.\n  pose nat2nat1 := fun (n : nat) => if n is S m then is_nat m else null.\n  pose nat12nat := fun (n' : nat_plus_1) => if n' is is_nat n then S n else 0.\n  by apply: (bijection _ _ nat2nat1 nat12nat) => [[|]|[|]].\nQed.\n\n(* Task 2-2. *)\nTheorem nat_iso_natpnat : iso nat nat_plus_nat.\nProof.\n  pose nat2natp := fun (n : nat) =>\n    if Nat.odd n then left (Nat.div2 n) else right (Nat.div2 n).\n  pose natp2nat := fun (n' : nat_plus_nat) =>\n    match n' with\n    | left n => S (2 * n)\n    | right n => 2 * n\n    end.\n  apply: (bijection _ _ nat2natp natp2nat) => [n|]; rewrite \/nat2natp \/natp2nat.\n    move: (Nat.div2_odd n).\n    case: (Nat.odd n) => \/=.\n      by rewrite Nat.add_1_r.\n    by rewrite plus_0_r.\n  move=> [n|n].\n    by rewrite Nat.div2_succ_double -Nat.add_1_l Nat.odd_add_mul_2.\n  by rewrite Nat.div2_double -(plus_0_l (2 * n)) Nat.odd_add_mul_2.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32788,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Arith.\nRequire Import Nat.\nRequire Import PeanoNat.\nRequire Import Bool.\n\n(* Task 0 : Example of iso in finite sets *)\n(* Find a bijection between bool and bit. (provided for you as an example) *)\nInductive bit : Set := b0 | b1.\n\nDefinition bool2bit (b : bool) : bit :=\n  match b with true => b1 | false => b0\n  end.\n\nDefinition bit2bool (b : bit) : bool :=\n  match b with b1 => true | b0 => false\n  end.\n\nDefinition bool_iso_bit : iso bool bit.\nProof. apply (bijection _ _ bool2bit bit2bool); intros []; auto. Qed.\n\n(******************************************)\n(* Task 1 : General properties of iso *)\n(* Task 1-1. Prove that any set has the same cardinality as itself. *)\nTheorem iso_refl : forall A : Set, iso A A.\nProof.\n  intros A.\n  refine (bijection A A id id _ _);auto.\nQed.\n\n(* Task 1-2. Prove that iso is symmetric. *)\nTheorem iso_sym : forall A B : Set, iso A B -> iso B A.\nProof.\n  intros A B isoAB.\n  refine (bijection B A (B_to_A _ _ isoAB) (A_to_B _ _ isoAB) _ _).\n  intro b. apply (B_A_B _ _ isoAB).\n  intro a. apply (A_B_A _ _ isoAB).\nQed.\n\n(* Task 1-3. Prove that iso is transitive. *)\nTheorem iso_trans : forall A B C : Set, iso A B -> iso B C -> iso A C.\nProof.\n  intros A B C isoAB isoBC.\n  refine (bijection _ _ (fun a => (A_to_B _ _ isoBC) (A_to_B _ _ isoAB a)) \n    (fun c => (B_to_A _ _ isoAB) (B_to_A _ _ isoBC c)) _ _).\n  intro a. rewrite (A_B_A _ _ isoBC). rewrite (A_B_A _ _ isoAB). reflexivity.\n  intro b. rewrite (B_A_B _ _ isoAB). rewrite (B_A_B _ _ isoBC). reflexivity.\nQed.\n\n(* Task 1-4. Prove the following statement:\n  Given two functions A->B and B->A, if A->B->A is satisfied and B->A is injective, A <=> B. *)\nTheorem bijection_alt : forall (A B : Set) (A2B : A -> B) (B2A : B -> A),\n  (forall a, B2A (A2B a) = a) -> (forall b1 b2, B2A b1 = B2A b2 -> b1 = b2) -> iso A B.\nProof.\n  intros A B f g inv inj.\n  refine (bijection _ _ f g inv _).\n  intro b. apply inj. rewrite inv. reflexivity.\nQed.\n\n(******************************************)\n(* Task 2 : iso relations between nat and various supersets of nat *)\n\n(* nat_plus_1 : a set having one more element than nat. (provided in preloaded) *)\n\n\n(* Task 2-1. Prove that nat has the same cardinality as nat_plus_1. *)\nTheorem nat_iso_natp1 : iso nat nat_plus_1.\nProof.\n  pose (f n := match n with \n    | 0 => null\n    | S m => is_nat m\n  end).\n  pose (g np := match np with \n    | null => 0 \n    | is_nat m => S m\n  end).\n  refine (bijection _ _ f g _ _).\n  - intro n. induction n as [|n hn]. reflexivity. reflexivity.\n  - intro np. induction np as [|np]. reflexivity. reflexivity.\nQed. \n\n(* nat_plus_nat : a set having size(nat) more elements than nat. (provided in preloaded) *)\n\n\n(* Task 2-2. Prove that nat has the same cardinality as nat_plus_nat. *)\nTheorem nat_iso_natpnat : iso nat nat_plus_nat.\nProof.\n  pose (f n := match (even n) with \n    | true => left (div2 n)\n    | false => right (div2 n)\n  end).\n  pose (g p := match p with \n    | left k => 2*k\n    | right k => 2*k+1\n    end).\n  refine (bijection _ _ f g _ _).\n  - intro n. pose proof (h := orb_prop _ _ (Nat.orb_even_odd n)). \n    destruct h as [h | h].\n    + pose proof (h2 := proj1 (Nat.even_spec n) h). destruct h2 as [m hm]. \n      rewrite hm in *. replace (f (2 * m)) with (left (div2 (2*m))). \n      rewrite Nat.div2_double. simpl. ring. unfold f. rewrite h. reflexivity.\n    + pose proof (h2 := proj1 (Nat.odd_spec n) h). destruct h2 as [m hm]. \n    rewrite hm in *. replace (f (2 * m + 1)) with (right (div2 (S (2*m)))). \n    rewrite Nat.div2_succ_double. simpl. ring. unfold f. \n    assert (h' : even (2 * m + 1) = false).  rewrite <- Nat.negb_odd. \n    apply (proj1 (negb_true_iff _)). rewrite negb_involutive. assumption.\n    rewrite h'. rewrite Nat.add_1_r. reflexivity.\n  - intro p. destruct p as [k | k].\n    + unfold g. assert (h1 : Nat.Even (2*k)). exists k. reflexivity. \n    pose proof (h := proj2 (Nat.even_spec (2*k)) h1). unfold f. rewrite h.\n    rewrite Nat.div2_double. reflexivity.\n    + unfold g. assert (h1 : Nat.Odd (2*k + 1)). exists k. reflexivity. \n    pose proof (h := proj2 (Nat.odd_spec (2*k+1)) h1). unfold f. \n    assert (h' : even (2 * k + 1) = false). rewrite <- Nat.negb_odd. \n    apply (proj1 (negb_true_iff _)). rewrite negb_involutive. assumption. \n    rewrite h'. rewrite Nat.add_1_r. rewrite Nat.div2_succ_double. reflexivity.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32789,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Arith Lia.\n\n\n(* Task 0 : Example of iso in finite sets *)\n(* Find a bijection between bool and bit. (provided for you as an example) *)\nInductive bit : Set := b0 | b1.\n\nDefinition bool2bit (b : bool) : bit :=\n  match b with true => b1 | false => b0\n  end.\n\nDefinition bit2bool (b : bit) : bool :=\n  match b with b1 => true | b0 => false\n  end.\n\nDefinition bool_iso_bit : iso bool bit.\nProof.\n  apply (bijection _ _ bool2bit bit2bool).\n  intros.\n  case a.\n  simpl.\n  reflexivity.\n  simpl.\n  reflexivity.\n  intros.\n  case b.\n  simpl.\n  reflexivity.\n  simpl.\n  reflexivity.\nQed.\n\n\n(******************************************)\n(* Task 1 : General properties of iso *)\n(* Task 1-1. Prove that any set has the same cardinality as itself. *)\nTheorem iso_refl : forall A : Set, iso A A.\nProof.\n  intros.\n  apply (bijection _ _ id id);\n    unfold id; reflexivity.\n  Qed.\n\n(* Task 1-2. Prove that iso is symmetric. *)\nTheorem iso_sym : forall A B : Set, iso A B -> iso B A.\nProof.\n  intros.\n  elim H.\n  intros.\n  refine (bijection B A _ _ _ _); auto.\nQed.\n\n\n\n\n(* Task 1-3. Prove that iso is transitive. *)\nTheorem iso_trans : forall A B C : Set, iso A B -> iso B C -> iso A C.\nProof.\n  intros.\n  case H as [AB BA ABA BAB].\n  case H0 as [BC CB BCB CBC].\n  apply (bijection A C (fun a => BC (AB a)) (fun c =>  BA (CB c))).\n  intros.\n  specialize (BCB (AB a)).\n  rewrite BCB.\n  specialize (ABA a).\n  rewrite ABA.\n  reflexivity.\n  intros.\n  specialize (BAB (CB b)).\n  rewrite BAB.\n  specialize (CBC b).\n  rewrite CBC.\n  reflexivity.\nQed.\n\n\n(* Task 1-4. Prove the following statement:\n  Given two functions A->B and B->A, if A->B->A is satisfied and B->A is injective, A <=> B. *)\nTheorem bijection_alt : forall (A B : Set) (A2B : A -> B) (B2A : B -> A),\n  (forall a, B2A (A2B a) = a) -> (forall b1 b2, B2A b1 = B2A b2 -> b1 = b2) -> iso A B.\nProof.\n  intros.\n  apply (bijection _ _ A2B B2A).\n  assumption.\n  intros.\n  rewrite (H0 (A2B (B2A b)) b).\n  reflexivity.\n  rewrite (H (B2A b)).\n  reflexivity.\nQed.\n\n(******************************************)\n(* Task 2 : iso relations between nat and various supersets of nat *)\n\n(* nat_plus_1 : a set having one more element than nat. (provided in preloaded) *)\n(* Inductive nat_plus_1 : Set := null | is_nat (n : nat). *)\n\n(* Task 2-1. Prove that nat has the same cardinality as nat_plus_1. *)\n\nTheorem nat_iso_natp1 : iso nat nat_plus_1.\nProof.\n  apply (bijection _ _ (fun n => match n with\n                                | 0 => null\n                                | S m => is_nat m\n                       end) (fun n => match n with\n                                | null => 0\n                                | is_nat m => S m\n                       end)).\n  intros.\n  induction a;\n  reflexivity.\n  induction b;\n  reflexivity.\nQed.\n\n(* nat_plus_nat : a set having size(nat) more elements than nat. (provided in preloaded) *)\n\nFixpoint nat_to_nn (n : nat) : nat_plus_nat\n  := match n with\n       | 0 => left 0\n       | 1 => right 0\n       | S (S m) => match nat_to_nn m with\n                     | left a => left (S a)\n                     | right a => right (S a)\n                    end\n     end.\n\nDefinition nn_to_nat (n : nat_plus_nat) : nat\n  := match n with\n       | left l => l + l\n       | right r => S (r + r)\n     end.\n\nDefinition nat_ind_two : forall P, \n  P 0 -> P 1 -> (forall n, P n -> P (S (S n))) -> (forall n, P n).\nProof.\n  intros P P0 P1 PSS.\n  exact (fix go (n:nat): P n := match n with\n    | 0 => P0\n    | 1 => P1\n    | S (S n_bez_dvou) => PSS n_bez_dvou (go n_bez_dvou)\n  end\n  ).\nQed.\n\n\n(* Task 2-2. Prove that nat has the same cardinality as nat_plus_nat. *)\nTheorem nat_iso_natpnat : iso nat nat_plus_nat.\nProof.\n  apply (bijection _ _ nat_to_nn nn_to_nat).\n  - intros.\n    induction a using nat_ind_two.\n    compute. easy.\n    compute. easy.\n    simpl.\n    destruct (nat_to_nn a).\n    simpl in IHa.\n    simpl.\n    lia.\n    simpl in IHa.\n    simpl.\n    lia.\n  - intros.\n    destruct b. \n    simpl.\n    induction n.\n    compute.\n    reflexivity.\n    assert (S n + S n = S (S (n + n))) by lia.\n    rewrite -> H.\n    simpl.\n    rewrite -> IHn.\n    reflexivity.\n    simpl nn_to_nat.\n    induction n.\n    compute.\n    reflexivity.\n    simpl.\n    assert (n + S n = S (n + n)) by lia.\n    rewrite -> H.\n    rewrite -> IHn.\n    reflexivity.\nQed.\n\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5cb9dc6f98b230001cbe2cea":[{"id":32790,"user_id":1084,"body":"Require Import Coq.Lists.List.\nRequire Import Coq.Bool.Bool.\nRequire Import Omega.\nFact random_fact_about_filtering :\n  forall (X : Type) (l : list X) (f g : X -> bool),\n  length (filter (fun x => f x || g x) l) <=\n    length (filter f l) + length (filter g l).\nProof.\nintros; induction l; simpl in *; try (destruct (f a), (g a)); simpl in *; omega.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32791,"user_id":1076,"body":"Require Import Coq.Lists.List.\nRequire Import Coq.Bool.Bool.\nRequire Import Coq.micromega.Lia.\n\nFact random_fact_about_filtering :\n  forall (X : Type) (l : list X) (f g : X -> bool),\n    length (filter (fun x => f x || g x) l) <=\n    length (filter f l) + length (filter g l).\nProof.\n  intros X ls f g; induction ls as [|x xs IHxs]; [ reflexivity | ].\n  cbn [filter]; destruct (f x), (g x); cbn; lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32792,"user_id":168,"body":"Require Import Coq.Lists.List.\nRequire Import Coq.Bool.Bool.\n\nRequire Import ssreflect Arith.\nImport Nat.\n\nFact random_fact_about_filtering :\n  forall (X : Type) (l : list X) (f g : X -> bool),\n  length (filter (fun x => f x || g x) l) <=\n    length (filter f l) + length (filter g l).\nProof.\n  move => X l f g; elim: l => [|h t ih] \/\/=.\n  case: (f h); case: (g h) => \/=; rewrite ?add_succ_r \/\/; apply: le_n_S => \/\/.\n  by apply: le_le_succ_r.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32793,"user_id":168,"body":"Require Import Coq.Lists.List.\nRequire Import Coq.Bool.Bool.\n\nRequire Import ssreflect Omega.\n\nFact random_fact_about_filtering :\n  forall (X : Type) (l : list X) (f g : X -> bool),\n  length (filter (fun x => f x || g x) l) <=\n    length (filter f l) + length (filter g l).\nProof.\n  move => X l f g; elim: l => [|h t ih] \/\/=.\n  case: (f h); case: (g h) => \/=; omega.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32794,"user_id":null,"body":"Require Import Lists.List Bool.Bool Lia.\nFact random_fact_about_filtering : forall (X : Type) (l : list X) (f g : X -> bool),\n  length (filter (fun x => f x || g x) l) <= length (filter f l) + length (filter g l).\nProof.\n  intros.\n  elim l. auto.\n  intros. \n  simpl.\n  case (f a). simpl.\n  case (g a). simpl. \n  lia. lia.\n  case (g a). simpl. \n  lia. apply H.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32795,"user_id":null,"body":"Require Import Coq.Lists.List.\nRequire Import Coq.Bool.Bool.\n\nFact random_fact_about_filtering :\n  forall (X : Type) (l : list X) (f g : X -> bool),\n  length (filter (fun x => f x || g x) l) <=\n    length (filter f l) + length (filter g l).\nProof.\n  intros X l f g. induction l as [|x' xs' IH] ; trivial ; simpl.\n  - destruct (f x') ; destruct (g x') ; simpl ;\n        try rewrite <- plus_n_Sm ;\n        try apply Le.le_n_S ;\n        try apply le_S ;\n        try assumption.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32796,"user_id":null,"body":"Require Import Coq.Lists.List.\nRequire Import Coq.Bool.Bool.\nRequire Import Lia.\n\nFact random_fact_about_filtering :\n  forall (X : Type) (l : list X) (f g : X -> bool),\n  length (filter (fun x => f x || g x) l) <=\n    length (filter f l) + length (filter g l).\nProof.\n  intros.\n  induction l.\n  - simpl. auto.\n  - simpl filter.\n    destruct (f a); destruct (g a); simpl; lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32797,"user_id":null,"body":"Require Import Coq.Lists.List.\nRequire Import Coq.Bool.Bool.\n\nRequire Import Lia.\n\nFact random_fact_about_filtering :\n  forall (X : Type) (l : list X) (f g : X -> bool),\n  length (filter (fun x => f x || g x) l) <=\n    length (filter f l) + length (filter g l).\nProof.\n  intros.\n  induction l as [| a l hl].\n  + auto.\n  + simpl. destruct (f a) ; destruct (g a) ; simpl ; lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32798,"user_id":null,"body":"Require Import Coq.Lists.List.\nRequire Import Coq.Bool.Bool.\n\nFact random_fact_about_filtering :\n  forall (X : Type) (l : list X) (f g : X -> bool),\n  length (filter (fun x => f x || g x) l) <=\n    length (filter f l) + length (filter g l).\nProof.\n  intro.\n  induction l as [|a].\n    - auto.\n    - intros f g. simpl. destruct (f a); destruct (g a); simpl; try apply le_n_S; try rewrite PeanoNat.Nat.add_succ_r; try apply le_n_S; auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32799,"user_id":null,"body":"Require Import Coq.Lists.List.\nRequire Import Coq.Bool.Bool.\nRequire Import Coq.micromega.Lia.\n\nFact random_fact_about_filtering :\n  forall (X : Type) (l : list X) (f g : X -> bool),\n    length (filter (fun x => f x || g x) l) <=\n      length (filter f l) + length (filter g l).\nProof.\n  intros X l f g; induction l; simpl; try lia.\n  destruct (f a), (g a); simpl; lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5cbb64270840280001bb730b":[{"id":32800,"user_id":null,"body":"(** Can you write down three \"different\" proofs of transitivity (they should all be judgmentally different; [refl] should not prove any two of them the same. *)\n\nDefinition trans0\n: forall A (x y z : A),\n    x = y -> y = z -> x = z\n:= fun (A : Type) (x y z : A) (H : x = y) (H0 : y = z) =>\n  match H0 with\n  | eq_refl => H\n  end.\n\nFixpoint trans (n : nat) (A : Type) (x y z : A) (H : x = y) (H0 : y = z) :=\n  match n with\n  | O => trans0 A x y z H H0\n  | S n' =>\n    match H with\n    | eq_refl => trans n' A x y z H H0\n    end\n  end.\n\nDefinition trans1\n: forall A (x y z : A),\n    x = y -> y = z -> x = z\n:= trans 1.\n\nDefinition trans2\n: forall A (x y z : A),\n    x = y -> y = z -> x = z\n:= trans 2.\n\nDefinition trans3\n: forall A (x y z : A),\n  x = y -> y = z -> x = z\n:= trans 3.\n\n(** Now we have Coq check that they are not the same; these lines should compile unmodified. *)\n\nFail Check eq_refl : trans1 = trans2.\n\nFail Check eq_refl : trans2 = trans3.\n\nFail Check eq_refl : trans1 = trans3.\n\n\n(** Now prove that these are all equal (propositionally, but not judgmentally. *)\n\nLtac t := intros; repeat match goal with\n                         | [ H : _ = _ |- _ ] => destruct H\n                         end; reflexivity.\n\nDefinition trans_12\n: forall A (x y z : A) (H0 : x = y) (H1 : y = z),\n    trans1 A x y z H0 H1 = trans2 A x y z H0 H1.\nProof. t. Qed.\n\nDefinition trans_23\n: forall A (x y z : A) (H0 : x = y) (H1 : y = z),\n    trans2 A x y z H0 H1 = trans3 A x y z H0 H1.\n Proof. t. Qed.\n\n(** We can also prove associativity. *)\n\nDefinition trans_assoc\n: forall A (x y z w : A) (H0 : x = y) (H1 : y = z) (H2 : z = w),\n    eq_trans H0 (eq_trans H1 H2) = eq_trans (eq_trans H0 H1) H2.\nProof. t. Qed.\n\nDefinition trans_Vp\n: forall A (x y : A) (H : x = y),\n    eq_trans (eq_sym H) H = eq_refl.\nProof. t. Qed.\n\nDefinition trans_pV\n: forall A (x y : A) (H : x = y),\n    eq_trans H (eq_sym H) = eq_refl.\nProof. t. Qed.\n\nDefinition trans_1p\n: forall A (x y : A) (H : x = y),\n    eq_trans eq_refl H = H.\nProof. t. Qed.\n\nDefinition trans_p1\n: forall A (x y : A) (H : x = y),\n    eq_trans H eq_refl = H.\nProof. t. Qed.\n\nDefinition trans_sym\n: forall A (x y z : A) (H0 : x = y) (H1 : y = z),\n    eq_sym (eq_trans H0 H1) = eq_trans (eq_sym H1) (eq_sym H0).\nProof. t. Qed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32801,"user_id":null,"body":"(** Can you write down three \"different\" proofs of transitivity (they should all be judgmentally different; [refl] should not prove any two of them the same. *)\n\nDefinition trans1\n  : forall A (x y z : A),\n    x = y -> y = z -> x = z :=\n  fun A a b c H1 H2 => match H2 with eq_refl => H1 end.\nPrint trans1.\nDefinition trans2\n  : forall A (x y z : A),\n    x = y -> y = z -> x = z :=\n  fun A a b c H1 H2 =>\n    match H2 with eq_refl => match H1 with eq_refl => eq_refl end end.\n\nDefinition trans3\n  : forall A (x y z : A),\n    x = y -> y = z -> x = z :=\n  fun A a b c H1 H2 =>  match (eq_sym H1) with eq_refl => H2 end.\n\n(** Now we have Coq check that they are not the same; these lines should compile unmodified. *)\n\nFail Check eq_refl : trans1 = trans2.\n\nFail Check eq_refl : trans2 = trans3.\n\nFail Check eq_refl : trans1 = trans3.\n\n\n(** Now prove that these are all equal (propositionally, but not judgmentally. *)\n\nDefinition trans_12\n  : forall A (x y z : A) (H0 : x = y) (H1 : y = z),\n    trans1 A x y z H0 H1 = trans2 A x y z H0 H1.\n  intros; rewrite H0; rewrite <- H1; reflexivity.\nDefined.\n\nDefinition trans_23\n  : forall A (x y z : A) (H0 : x = y) (H1 : y = z),\n    trans2 A x y z H0 H1 = trans3 A x y z H0 H1.\n  intros; rewrite H0; rewrite <- H1; reflexivity.\nDefined.\n\n(** We can also prove associativity. *)\n\nDefinition trans_assoc\n  : forall A (x y z w : A) (H0 : x = y) (H1 : y = z) (H2 : z = w),\n    eq_trans H0 (eq_trans H1 H2) = eq_trans (eq_trans H0 H1) H2.\n  intros. case H2; reflexivity.\nDefined.\n\nDefinition trans_Vp\n  : forall A (x y : A) (H : x = y),\n    eq_trans (eq_sym H) H = eq_refl.\n  intros; case H; reflexivity.\nDefined.\n\nDefinition trans_pV\n  : forall A (x y : A) (H : x = y),\n    eq_trans H (eq_sym H) = eq_refl.\n  intros; case H; reflexivity.\nDefined.\n\nDefinition trans_1p\n  : forall A (x y : A) (H : x = y),\n    eq_trans eq_refl H = H.\n  intros; case H; reflexivity.\nDefined.\n\nDefinition trans_p1\n  : forall A (x y : A) (H : x = y),\n    eq_trans H eq_refl = H.\n  intros; case H; reflexivity.\nDefined.\n\nDefinition trans_sym\n  : forall A (x y z : A) (H0 : x = y) (H1 : y = z),\n    eq_sym (eq_trans H0 H1) = eq_trans (eq_sym H1) (eq_sym H0).\n  intros; case H1; case H0; reflexivity.\nDefined.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32802,"user_id":null,"body":"Require Import ssreflect.\n\nDefinition trans1: forall A (x y z : A),\n    x = y -> y = z -> x = z.\n  by move => A x y z -> ->.\nDefined.\nDefinition trans2\n: forall A (x y z : A),\n    x = y -> y = z -> x = z.\n  by move => A x y z -> <-.\nDefined.\nDefinition trans3\n: forall A (x y z : A),\n    x = y -> y = z -> x = z.\n  by move => A x y z <- <-.\nDefined.\n\n(** Now we have Coq check that they are not the same; these lines should compile unmodified. *)\n\nFail Check eq_refl : trans1 = trans2.\n\nFail Check eq_refl : trans2 = trans3.\n\nFail Check eq_refl : trans1 = trans3.\n\n\n(** Now prove that these are all equal (propositionally, but not judgmentally. *)\n\nDefinition trans_12: forall A (x y z : A) (H0 : x = y) (H1 : y = z),\n    trans1 A x y z H0 H1 = trans2 A x y z H0 H1.\n  intros. destruct H0. destruct H1. trivial.\nDefined.\nDefinition trans_23: forall A (x y z : A) (H0 : x = y) (H1 : y = z),\n    trans2 A x y z H0 H1 = trans3 A x y z H0 H1.\n  intros. destruct H0. destruct H1. trivial.\nDefined.\n\n(** We can also prove associativity. *)\n\nDefinition trans_assoc: forall A (x y z w : A) (H0 : x = y) (H1 : y = z) (H2 : z = w),\n    eq_trans H0 (eq_trans H1 H2) = eq_trans (eq_trans H0 H1) H2.\n  intros. destruct H0. destruct H1. destruct H2. trivial.\nDefined.\n\nDefinition trans_Vp: forall A (x y : A) (H : x = y),\n    eq_trans (eq_sym H) H = eq_refl.\n  intros. destruct H. trivial.\nDefined.\n\nDefinition trans_pV\n: forall A (x y : A) (H : x = y),\n    eq_trans H (eq_sym H) = eq_refl.\n  intros. destruct H. trivial.\nDefined.\n\nDefinition trans_1p\n: forall A (x y : A) (H : x = y),\n    eq_trans eq_refl H = H.\n  intros. destruct H. trivial.\nDefined.\n\nDefinition trans_p1\n: forall A (x y : A) (H : x = y),\n    eq_trans H eq_refl = H.\n  intros. destruct H. trivial.\nDefined.\n\nDefinition trans_sym\n: forall A (x y z : A) (H0 : x = y) (H1 : y = z),\n    eq_sym (eq_trans H0 H1) = eq_trans (eq_sym H1) (eq_sym H0).\n  intros. destruct H0. destruct H1. trivial.\nDefined.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32803,"user_id":null,"body":"(** Can you write down three \"different\" proofs of transitivity (they should all be judgmentally different; [refl] should not prove any two of them the same. *)\n\nDefinition trans1\n: forall A (x y z : A),\n    x = y -> y = z -> x = z\n  := fun (A : Type) (x y z : A) (H : x = y) (H0 : y = z) =>\n    eq_ind_r (fun x0 : A => x0 = z) H0 H.\nDefinition trans2\n: forall A (x y z : A),\n    x = y -> y = z -> x = z\n  := fun (A : Type) (x y z : A) (H : x = y) (H0 : y = z) =>\n    eq_ind y (fun z0 : A => x = z0) H z H0.\nDefinition trans3\n: forall A (x y z : A),\n    x = y -> y = z -> x = z\n  := fun (A : Type) (x y z : A) (H : x = y) (H0 : y = z) =>\n    eq_ind_r (fun x0 : A => x0 = z)\n      (eq_ind y (fun z0 : A => y = z0) eq_refl z H0) H.\n\n(** Now we have Coq check that they are not the same; these lines should compile unmodified. *)\n\nFail Check eq_refl : trans1 = trans2.\n\nFail Check eq_refl : trans2 = trans3.\n\nFail Check eq_refl : trans1 = trans3.\n\n\n(** Now prove that these are all equal (propositionally, but not judgmentally. *)\n\n(* Alas, my proof is low-level. *)\n\nDefinition trans_12\n: forall A (x y z : A) (H0 : x = y) (H1 : y = z),\n    trans1 A x y z H0 H1 = trans2 A x y z H0 H1.\n  intros. unfold trans1, trans2. unfold eq_ind_r, eq_ind.\n  rewrite H0, H1. cbn. reflexivity. Defined.\nDefinition trans_23\n: forall A (x y z : A) (H0 : x = y) (H1 : y = z),\n    trans2 A x y z H0 H1 = trans3 A x y z H0 H1.\n  intros. unfold trans2, trans3. unfold eq_ind_r, eq_ind.\n  rewrite H0, H1. cbn. reflexivity. Defined.\n\n(** We can also prove associativity. *)\n\nDefinition trans_assoc\n: forall A (x y z w : A) (H0 : x = y) (H1 : y = z) (H2 : z = w),\n    eq_trans H0 (eq_trans H1 H2) = eq_trans (eq_trans H0 H1) H2.\n  intros. unfold eq_trans. rewrite H0, H1, H2. reflexivity. Defined.\n\nDefinition trans_Vp\n: forall A (x y : A) (H : x = y),\n    eq_trans (eq_sym H) H = eq_refl.\n  intros. unfold eq_trans, eq_sym. rewrite H. reflexivity. Defined.\n\nDefinition trans_pV\n: forall A (x y : A) (H : x = y),\n    eq_trans H (eq_sym H) = eq_refl.\n  intros. unfold eq_trans, eq_sym. rewrite H. reflexivity. Defined.\n\nDefinition trans_1p\n: forall A (x y : A) (H : x = y),\n    eq_trans eq_refl H = H.\n  intros. unfold eq_trans. rewrite H. reflexivity. Defined.\n\nDefinition trans_p1\n: forall A (x y : A) (H : x = y),\n    eq_trans H eq_refl = H.\n  intros. unfold eq_trans. rewrite H. reflexivity. Defined.\n\nDefinition trans_sym\n: forall A (x y z : A) (H0 : x = y) (H1 : y = z),\n    eq_sym (eq_trans H0 H1) = eq_trans (eq_sym H1) (eq_sym H0).\n  intros. unfold eq_trans, eq_sym. rewrite H0, H1. reflexivity. Defined.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32804,"user_id":null,"body":"(** Can you write down three \"different\" proofs of transitivity (they should all be judgmentally different; [refl] should not prove any two of them the same. *)\n\nAxiom admit1 : forall {T}, T.\nAxiom admit2 : forall {T}, T.\nAxiom admit3 : forall {T}, T.\nAxiom admit : forall {T}, T.\n\nDefinition trans1\n: forall A (x y z : A),\n    x = y -> y = z -> x = z.\nProof.\n  intros A x y z Hxy Hyz; now rewrite Hxy, Hyz.\nDefined.\n\nDefinition trans2\n: forall A (x y z : A),\n    x = y -> y = z -> x = z.\nProof.\n  intros A x y z Hxy Hyz; now rewrite <- Hyz, <- Hxy.\nDefined.\n\nDefinition trans3\n: forall A (x y z : A),\n    x = y -> y = z -> x = z.\nProof.\n  intros A x y z Hxy Hyz; now rewrite <- Hyz, Hxy.\nDefined.\n\n(** Now we have Coq check that they are not the same; these lines should compile unmodified. *)\n\nFail Check eq_refl : trans1 = trans2.\n\nFail Check eq_refl : trans2 = trans3.\n\nFail Check eq_refl : trans1 = trans3.\n\n\n(** Now prove that these are all equal (propositionally, but not judgmentally. *)\n\nDefinition trans_12\n: forall A (x y z : A) (H0 : x = y) (H1 : y = z),\n    trans1 A x y z H0 H1 = trans2 A x y z H0 H1.\nProof. intros; now subst. Qed.\n\nDefinition trans_23\n: forall A (x y z : A) (H0 : x = y) (H1 : y = z),\n    trans2 A x y z H0 H1 = trans3 A x y z H0 H1.\nProof. intros; now subst. Qed.\n\n(** We can also prove associativity. *)\n\nDefinition trans_assoc\n: forall A (x y z w : A) (H0 : x = y) (H1 : y = z) (H2 : z = w),\n    eq_trans H0 (eq_trans H1 H2) = eq_trans (eq_trans H0 H1) H2.\nProof. intros; now subst. Qed.\n\nDefinition trans_Vp\n: forall A (x y : A) (H : x = y),\n    eq_trans (eq_sym H) H = eq_refl.\nProof. intros; now subst. Qed.\n  \nDefinition trans_pV\n: forall A (x y : A) (H : x = y),\n    eq_trans H (eq_sym H) = eq_refl.\nProof. intros; now subst. Qed.\n  \nDefinition trans_1p\n: forall A (x y : A) (H : x = y),\n    eq_trans eq_refl H = H.\nProof. intros; now subst. Qed.\n\nDefinition trans_p1\n: forall A (x y : A) (H : x = y),\n    eq_trans H eq_refl = H.\nProof. intros; now subst. Qed.\n\nDefinition trans_sym\n: forall A (x y z : A) (H0 : x = y) (H1 : y = z),\n    eq_sym (eq_trans H0 H1) = eq_trans (eq_sym H1) (eq_sym H0).\nProof. intros; now subst. Qed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32805,"user_id":null,"body":"(** Can you write down three \"different\" proofs of transitivity (they should all be judgmentally different; [refl] should not prove any two of them the same. *)\n\nAxiom admit1 : forall {T}, T.\nAxiom admit2 : forall {T}, T.\nAxiom admit3 : forall {T}, T.\nAxiom admit : forall {T}, T.\n\nDefinition trans1\n: forall A (x y z : A),\n    x = y -> y = z -> x = z.\nProof.\n  intros A x y z H0 H1.\n  rewrite H0, H1; reflexivity.\nDefined.\n\nDefinition trans2\n: forall A (x y z : A),\n    x = y -> y = z -> x = z.\nProof.\n  intros A x y z H0 H1.\n  rewrite <-H1; apply H0.\nDefined.\n\nDefinition trans3\n: forall A (x y z : A),\n    x = y -> y = z -> x = z.\nProof.\n  intros A x y z H0 H1.\n  rewrite H0; apply H1.\nDefined.\n\n(** Now we have Coq check that they are not the same; these lines should compile unmodified. *)\n\nFail Check eq_refl : trans1 = trans2.\n\nFail Check eq_refl : trans2 = trans3.\n\nFail Check eq_refl : trans1 = trans3.\n\n\n(** Now prove that these are all equal (propositionally, but not judgmentally. *)\n\nDefinition trans_12\n: forall A (x y z : A) (H0 : x = y) (H1 : y = z),\n    trans1 A x y z H0 H1 = trans2 A x y z H0 H1.\nProof. intros; subst; reflexivity. Defined.\n  \nDefinition trans_23\n: forall A (x y z : A) (H0 : x = y) (H1 : y = z),\n    trans2 A x y z H0 H1 = trans3 A x y z H0 H1.\nProof. intros; subst; reflexivity. Defined.\n\n(** We can also prove associativity. *)\n\nDefinition trans_assoc\n: forall A (x y z w : A) (H0 : x = y) (H1 : y = z) (H2 : z = w),\n    eq_trans H0 (eq_trans H1 H2) = eq_trans (eq_trans H0 H1) H2.\nProof. intros; subst; reflexivity. Defined.\n\nDefinition trans_Vp\n: forall A (x y : A) (H : x = y),\n    eq_trans (eq_sym H) H = eq_refl.\nProof. intros; subst; reflexivity. Defined.\n  \nDefinition trans_pV\n: forall A (x y : A) (H : x = y),\n    eq_trans H (eq_sym H) = eq_refl.\nProof. intros; subst; reflexivity. Defined.\n  \nDefinition trans_1p\n: forall A (x y : A) (H : x = y),\n    eq_trans eq_refl H = H.\nProof. intros; subst; reflexivity. Defined.\n\nDefinition trans_p1\n: forall A (x y : A) (H : x = y),\n    eq_trans H eq_refl = H.\nProof. intros; subst; reflexivity. Defined.\n\nDefinition trans_sym\n: forall A (x y z : A) (H0 : x = y) (H1 : y = z),\n    eq_sym (eq_trans H0 H1) = eq_trans (eq_sym H1) (eq_sym H0).\nProof. intros; subst; reflexivity. Defined.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32806,"user_id":null,"body":"\n  (** Can you write down three \"different\" proofs of transitivity (they should all be judgmentally different; [refl] should not prove any two of them the same. *)\n  Axiom admit1 : forall {T}, T.\n  Axiom admit2 : forall {T}, T.\n  Axiom admit3 : forall {T}, T.\n  Axiom admit : forall {T}, T.\n  Definition trans1 : forall A (x y z : A), x = y -> y = z -> x = z.\n  Proof.\n    intros.\n    now subst.\n  Defined.\n\n  Definition trans2 : forall A (x y z : A), x = y -> y = z -> x = z.\n  Proof.\n    intros.\n    rewrite <-H in H0.\n    assumption.\n  Defined.\n\n  Definition trans3 : forall A (x y z : A), x = y -> y = z -> x = z.\n  Proof.\n    intros.\n    symmetry.\n    rewrite H.\n    congruence.\n  Defined.\n  (** Now we have Coq check that they are not the same; these lines should compile unmodified. *)\n  Fail Check eq_refl : trans1 = trans2.\n  Fail Check eq_refl : trans2 = trans3.\n  Fail Check eq_refl : trans1 = trans3.\n  (** Now prove that these are all equal (propositionally, but not judgmentally. *)\n  Definition trans_12 : forall A (x y z : A) (H0 : x = y) (H1 : y = z),\n      trans1 A x y z H0 H1 = trans2 A x y z H0 H1.\n  Proof.\n    intros.\n    now destruct H1.    \n  Qed.\n\n  Definition trans_23 : forall A (x y z : A) (H0 : x = y) (H1 : y = z), trans2 A x y z H0 H1 = trans3 A x y z H0 H1.\n  Proof.\n    intros.   \n    destruct H0.\n    now destruct H1.\n  Qed.\n\n  (** We can also prove associativity. *)\n  Definition trans_assoc : forall A (x y z w : A) (H0 : x = y) (H1 : y = z) (H2 : z = w),     eq_trans H0 (eq_trans H1 H2) = eq_trans (eq_trans H0 H1) H2.\n  Proof.\n    intros.\n    now destruct H2.\n  Qed.\n\n  Definition trans_Vp : forall A (x y : A) (H : x = y),     eq_trans (eq_sym H) H = eq_refl   .\n  Proof.\n    intros.\n    destruct H.\n    now simpl.\n  Qed.\n\n  Definition trans_pV : forall A (x y : A) (H : x = y),     eq_trans H (eq_sym H) = eq_refl   .\n  Proof.\n    intros.\n    now destruct H.\n  Qed.\n\n  Definition trans_1p : forall A (x y : A) (H : x = y),     eq_trans eq_refl H = H   .\n  Proof.\n    intros.\n    now destruct H.\n  Qed.\n\n  Definition trans_p1 : forall A (x y : A) (H : x = y),     eq_trans H eq_refl = H   .\n  Proof.\n    intros.\n    now destruct H.\n  Qed.\n\n  Definition trans_sym : forall A (x y z : A) (H0 : x = y) (H1 : y = z),     eq_sym (eq_trans H0 H1) = eq_trans (eq_sym H1) (eq_sym H0)   .\n  Proof.\n    intros.\n    destruct H0.\n    now destruct H1.\n  Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32807,"user_id":null,"body":"(** Can you write down three \"different\" proofs of transitivity (they should all be judgmentally different; [refl] should not prove any two of them the same. *)\n\nAxiom admit1 : forall {T}, T.\nAxiom admit2 : forall {T}, T.\nAxiom admit3 : forall {T}, T.\nAxiom admit : forall {T}, T.\n\nDefinition trans1\n: forall A (x y z : A),\n    x = y -> y = z -> x = z.\n intros.\n rewrite H. assumption. Show Proof.\n Defined.\n\nDefinition trans2\n: forall A (x y z : A),\n    x = y -> y = z -> x = z.\n    intros. rewrite <- H0. assumption. Show Proof.\nDefined.\n\nDefinition trans3\n: forall A (x y z : A),\n    x = y -> y = z -> x = z.\n    intros. rewrite H,<-H0. auto. \nDefined. \n\n    \n(** Now we have Coq check that they are not the same; these lines should compile unmodified. *)\n\nFail Check eq_refl : trans1 = trans2.\n\nFail Check eq_refl : trans2 = trans3.\n\nFail Check eq_refl : trans1 = trans3.\n\n\n(** Now prove that these are all equal (propositionally, but not judgmentally. *)\n\nDefinition trans_12\n: forall A (x y z : A) (H0 : x = y) (H1 : y = z),\n    trans1 A x y z H0 H1 = trans2 A x y z H0 H1.\n    intros. destruct H0. destruct H1. unfold trans1, trans2. auto.\n    Qed.\n\nDefinition trans_23\n: forall A (x y z : A) (H0 : x = y) (H1 : y = z),\n    trans2 A x y z H0 H1 = trans3 A x y z H0 H1.\n     intros. destruct H0. destruct H1. unfold trans3, trans2. auto.\n  Qed.\n\n(** We can also prove associativity. *)\n\nDefinition trans_assoc\n: forall A (x y z w : A) (H0 : x = y) (H1 : y = z) (H2 : z = w),\n    eq_trans H0 (eq_trans H1 H2) = eq_trans (eq_trans H0 H1) H2.\n    intros. destruct H0,H1,H2. auto.\nQed.\n\nDefinition trans_Vp\n: forall A (x y : A) (H : x = y),\n    eq_trans (eq_sym H) H = eq_refl.\n    intros. destruct H. auto.\n    Qed.\n  \nDefinition trans_pV\n: forall A (x y : A) (H : x = y),\n    eq_trans H (eq_sym H) = eq_refl.\n    intros. destruct H. auto.\n    Qed.\n  \nDefinition trans_1p\n: forall A (x y : A) (H : x = y),\n    eq_trans eq_refl H = H.\n    intros. destruct H. auto.\n    Qed.\n\nDefinition trans_p1\n: forall A (x y : A) (H : x = y),\n    eq_trans H eq_refl = H.\n    intros. destruct H. auto.\n    Qed.\n\nDefinition trans_sym\n: forall A (x y z : A) (H0 : x = y) (H1 : y = z),\n    eq_sym (eq_trans H0 H1) = eq_trans (eq_sym H1) (eq_sym H0).\n    intros. destruct H0,H1. auto.\n    Qed.\n\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32808,"user_id":null,"body":"(** Can you write down three \"different\" proofs of transitivity (they should all be judgmentally different; [refl] should not prove any two of them the same. *)\n\nDefinition trans1\n: forall A (x y z : A),\n    x = y -> y = z -> x = z.\nProof.\n  intros A x y z xy yz; rewrite xy, yz; reflexivity.\nDefined.\n\nDefinition trans2\n: forall A (x y z : A),\n    x = y -> y = z -> x = z.\nProof.\n  intros A x y z xy yz; rewrite xy, <- yz; reflexivity.\nDefined.\n\nDefinition trans3\n: forall A (x y z : A),\n    x = y -> y = z -> x = z.\nProof.\n  intros A x y z xy yz; rewrite <- yz, <- xy; reflexivity.\nDefined.\n\n(** Now we have Coq check that they are not the same; these lines should compile unmodified. *)\n\nFail Check eq_refl : trans1 = trans2.\n\nFail Check eq_refl : trans2 = trans3.\n\nFail Check eq_refl : trans1 = trans3.\n\n\n(** Now prove that these are all equal (propositionally, but not judgmentally. *)\n\nDefinition trans_12\n: forall A (x y z : A) (H0 : x = y) (H1 : y = z),\n    trans1 A x y z H0 H1 = trans2 A x y z H0 H1.\nProof.\n  intros A x y z xy yz; rewrite xy, yz; reflexivity.\nDefined.\n\nDefinition trans_23\n: forall A (x y z : A) (H0 : x = y) (H1 : y = z),\n    trans2 A x y z H0 H1 = trans3 A x y z H0 H1.\nProof.\n  intros A x y z xy yz; rewrite xy, yz; reflexivity.\nDefined.\n\n(** We can also prove associativity. *)\n\nDefinition trans_assoc\n: forall A (x y z w : A) (H0 : x = y) (H1 : y = z) (H2 : z = w),\n    eq_trans H0 (eq_trans H1 H2) = eq_trans (eq_trans H0 H1) H2.\nProof.\n  intros A x y z w xy yz zw; rewrite xy, yz, zw; reflexivity.\nDefined.\n\nDefinition trans_Vp\n: forall A (x y : A) (H : x = y),\n    eq_trans (eq_sym H) H = eq_refl.\nProof.\n  intros A x y xy; rewrite xy; reflexivity.\nDefined.\n\nDefinition trans_pV\n: forall A (x y : A) (H : x = y),\n    eq_trans H (eq_sym H) = eq_refl.\nProof.\n  intros A x y xy; rewrite xy; reflexivity.\nDefined.\n\nDefinition trans_1p\n: forall A (x y : A) (H : x = y),\n    eq_trans eq_refl H = H.\nProof.\n  intros A x y xy; rewrite xy; reflexivity.\nDefined.\n\nDefinition trans_p1\n: forall A (x y : A) (H : x = y),\n    eq_trans H eq_refl = H.\nProof.\n  intros A x y xy; rewrite xy; reflexivity.\nDefined.\n\nDefinition trans_sym\n: forall A (x y z : A) (H0 : x = y) (H1 : y = z),\n    eq_sym (eq_trans H0 H1) = eq_trans (eq_sym H1) (eq_sym H0).\nProof.\n  intros A x y z xy yz; rewrite xy, yz; reflexivity.\nDefined.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32809,"user_id":null,"body":"(** Can you write down three \"different\" proofs of transitivity (they should all be judgmentally different; [refl] should not prove any two of them the same. *)\n\nAxiom admit1 : forall {T}, T.\nAxiom admit2 : forall {T}, T.\nAxiom admit3 : forall {T}, T.\nAxiom admit : forall {T}, T.\n\nDefinition trans1\n: forall A (x y z : A),\n    x = y -> y = z -> x = z.\n  intros. destruct H. exact H0. Defined.\n\n\nDefinition trans2\n: forall A (x y z : A),\n    x = y -> y = z -> x = z.\n  intros; rewrite H; rewrite H0; auto. Defined.\n\nDefinition trans3\n: forall A (x y z : A),\n    x = y -> y = z -> x = z.\n  intros A x y z H. rewrite H. auto. Defined.\n\n\n(** Now we have Coq check that they are not the same; these lines should compile unmodified. *)\n\nFail Check eq_refl : trans1 = trans2.\n\nFail Check eq_refl : trans2 = trans3.\n\nFail Check eq_refl : trans1 = trans3.\n\n\n(** Now prove that these are all equal (propositionally, but not judgmentally. *)\n\nDefinition trans_12\n: forall A (x y z : A) (H0 : x = y) (H1 : y = z),\n    trans1 A x y z H0 H1 = trans2 A x y z H0 H1.\n  intros. rewrite H0, H1. auto. Defined.\n  \nDefinition trans_23\n: forall A (x y z : A) (H0 : x = y) (H1 : y = z),\n    trans2 A x y z H0 H1 = trans3 A x y z H0 H1.\n  intros. rewrite H0, H1. auto. Defined.\n\n(** We can also prove associativity. *)\n\nDefinition trans_assoc\n: forall A (x y z w : A) (H0 : x = y) (H1 : y = z) (H2 : z = w),\n    eq_trans H0 (eq_trans H1 H2) = eq_trans (eq_trans H0 H1) H2.\n  intros. rewrite H0, H1, H2. auto. Defined.\n\nDefinition trans_Vp\n: forall A (x y : A) (H : x = y),\n    eq_trans (eq_sym H) H = eq_refl.\n  intros. rewrite H. auto. Defined.\n\n  \nDefinition trans_pV\n: forall A (x y : A) (H : x = y),\n    eq_trans H (eq_sym H) = eq_refl.\n  intros. rewrite H. auto. Defined.\n  \nDefinition trans_1p\n: forall A (x y : A) (H : x = y),\n    eq_trans eq_refl H = H.\n  intros. rewrite H. auto. Defined.\n\nDefinition trans_p1\n: forall A (x y : A) (H : x = y),\n    eq_trans H eq_refl = H.\n  intros. rewrite H. auto. Defined.\n\nDefinition trans_sym\n: forall A (x y z : A) (H0 : x = y) (H1 : y = z),\n    eq_sym (eq_trans H0 H1) = eq_trans (eq_sym H1) (eq_sym H0).\n  intros. rewrite H0, H1. auto. Defined.\n\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5cbb6a5a0840280001bb734c":[{"id":32810,"user_id":1076,"body":"Definition strange (n : nat) (u : unit) : unit\n  := match u with\n     | tt => fun _ => tt\n     end n.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32811,"user_id":null,"body":"Definition strange (n : nat) (u : unit) : unit :=\n  (match u with\n   | tt => (fun u n => u)\n   end)\n    u\n    ((fix I n :=\n        match n with\n        | 0 => match u with tt => u end\n        | S n => match (I n) with tt => u end\n        end) n).\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32812,"user_id":null,"body":"Definition strange (n : nat) (u : unit) : unit\n  := match u with tt => (fun _ => tt) end n.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32813,"user_id":null,"body":"Definition strange_aux (n : nat) : unit.\nexact tt.\nQed.\n\nDefinition unit_bool (u : unit) : bool :=\n  match u with\n  | tt => true\n  end.\n\nDefinition strange (n : nat) (u : unit) : unit :=\n  if (unit_bool u) then tt else strange_aux n.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32814,"user_id":null,"body":"Definition strange_aux (u:unit) (pf:u = tt) := \n eq_rect u (fun _ => nat -> unit) (fun _:nat => tt) tt pf.\n\nDefinition strange (n:nat) (u:unit) : unit := \nstrange_aux u \n            match u as u0 return (u0 = tt) with\n             | tt => eq_refl\n            end \n            n.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32815,"user_id":null,"body":"Fixpoint strange (n : nat) (u : unit) {struct u} : unit\n  := match u with | _ => tt end. \n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32816,"user_id":null,"body":"Fixpoint strange (n : nat) (u : unit) {struct u} : unit := u.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32817,"user_id":106,"body":"Fixpoint strange (n : nat) (u : unit) {struct u} := u.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32818,"user_id":568,"body":"Fixpoint strange (n : nat) (u : unit) {struct u} : unit := tt.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32819,"user_id":568,"body":"Fixpoint strange (n : nat) (u : unit) {struct u} : unit :=\n  match u with\n  | tt => tt\n  end.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5cbd5a3d9f1a4e0018503301":[{"id":32820,"user_id":885,"body":"Require Import Preloaded.\nModule Introduction.\n\n  (* Infinite sequence of ones. (not tested) *)\n  CoFixpoint ones : stream nat := 1 :: ones.\n  \n  (* Infinite sequence of given value. *)\n  CoFixpoint repeat {A : Set} (a : A) : stream A := a :: (repeat a).\n  \n  (* Elements at even and odd indexes, respectively. *)\n  CoFixpoint even {A : Set} (x : stream A) : stream A := head x :: (even (tail (tail x))).\n  Definition odd {A : Set} (x : stream A) : stream A := even (tail x).\n  \n  (* A stream equals its head plus its tail. (not tested) *)\n  Lemma stream_unfold : forall {A : Set} (a : stream A), a = head a :: tail a.\n  Proof. intros A a. destruct a. reflexivity. Qed.\n\nEnd Introduction.\n\nModule Bisimulation.\n  \n  Export Introduction.\n  \n  (* Bisimulation is reflexive. *)\n  Theorem bisim_refl : forall {A : Set} (a : stream A), a == a.\n  Proof.\n  cofix CIH. intros. constructor. reflexivity. apply CIH.\n  Qed.\n  \n  (* Odd is tail of Even. *)\n  (* Hint: Do you really need cofix? It may depend on your own definition of odd and even. *)\n  Theorem odd_even : forall {A : Set} (a : stream A), odd a == even (tail a).\n  Proof. unfold odd. intros. apply bisim_refl. Qed.\n  \nEnd Bisimulation.\n\nModule Merge.\n\n  Export Bisimulation.\n  \n  (* Interleave two streams, starting with the left one. *)\n  CoFixpoint merge {A : Set} (x y : stream A) : stream A := (head x) :: (merge y (tail x)).\n  \n  (* Main task: Merge even and odd, and get the original. *)\n  Theorem moe : forall {A : Set} (a : stream A), merge (even a) (odd a) == a.\n  Proof. \n    cofix CIH. intros. constructor. simpl. reflexivity.\n    simpl. constructor. simpl. reflexivity.\n    simpl. apply CIH.\n  Qed. \nEnd Merge.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32821,"user_id":null,"body":"From mathcomp Require Import all_ssreflect.\nRequire Import Preloaded.\n\n(* Preloaded code:\n\nCoInductive stream (A : Set) : Set :=\n  | cons : A -> stream A -> stream A.\nArguments cons {_} hd tl.\n\nNotation \"x :: y\" := (cons x y) (at level 60, right associativity).\n\nDefinition head {A} (x : stream A) := match x with\n  hd :: _ => hd end.\nDefinition tail {A} (x : stream A) := match x with\n  _ :: tl => tl end.\n\nCoInductive bisim {A : Set} (x y : stream A) : Set :=\n  | bisim_eq : head x = head y -> bisim (tail x) (tail y) -> bisim x y.\nNotation \"x == y\" := (bisim x y) (at level 70).\n\n*)\n\nModule Introduction.\n\n  (* Infinite sequence of ones. (not tested) *)\n  CoFixpoint ones : stream nat := 1 :: ones.\n  \n  (* Infinite sequence of given value. *)\n  CoFixpoint repeat {A : Set} (a : A) : stream A :=\n  a :: repeat a.\n  \n  (* Elements at even and odd indexes, respectively. *)\n  CoFixpoint even {A : Set} (x : stream A) : stream A := match x with\n  x::_::s => x::even s end.\n  Definition odd {A : Set} (x : stream A) : stream A := match x with\n  _::s => even s end.\n  \n  (* A stream equals its head plus its tail. (not tested) *)\n  Lemma stream_unfold : forall {A : Set} (a : stream A), a = head a :: tail a.\n  Proof. intros A a. destruct a. reflexivity. Qed.\n\nEnd Introduction.\n\nModule Bisimulation.\n  \n  Export Introduction.\n  \n  (* Bisimulation is reflexive. *)\n  Theorem bisim_refl : forall {A : Set} (a : stream A), a == a.\n  Proof.\n    cofix CIH.\n    intros.\n    constructor.\n    - auto.\n    apply CIH.\n  Qed.\n\n  Print bisim_refl.\n\n  \n  (* Odd is tail of Even. *)\n  (* Hint: Do you really need cofix? It may depend on your own definition of odd and even. *)\n  Theorem odd_even : forall {A : Set} (a : stream A), odd a == even (tail a).\n  Proof.\n    intros.\n    destruct a.\n    apply bisim_refl.\n  Qed.\n  \nEnd Bisimulation.\n\nModule Merge.\n\n  Export Bisimulation.\n  \n  (* Interleave two streams, starting with the left one. *)\n  CoFixpoint merge {A : Set} (x y : stream A) : stream A :=\n  head x :: merge y (tail x).\n  \n  (* Main task: Merge even and odd, and get the original. *)\n  Theorem moe : forall {A : Set} (a : stream A), merge (even a) (odd a) == a.\n  Proof.\n    cofix CIH.\n    intros.\n    constructor.\n    - destruct a.\n      destruct a0.\n      auto.\n    destruct a.\n    rewrite -[X in _ == X]\/(a0).\n    destruct a0.\n    simpl.\n    rewrite -[even a1]\/(odd (a0::a1)).\n    apply CIH.\n  Qed.\n\nEnd Merge.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32822,"user_id":null,"body":"Require Import Preloaded.\n\n(* Preloaded code:\n\nCoInductive stream (A : Set) : Set :=\n  | cons : A -> stream A -> stream A.\nArguments cons {_} hd tl.\n\nNotation \"x :: y\" := (cons x y) (at level 60, right associativity).\n\nDefinition head {A} (x : stream A) := match x with\n  hd :: _ => hd end.\nDefinition tail {A} (x : stream A) := match x with\n  _ :: tl => tl end.\n\nCoInductive bisim {A : Set} (x y : stream A) : Set :=\n  | bisim_eq : head x = head y -> bisim (tail x) (tail y) -> bisim x y.\nNotation \"x == y\" := (bisim x y) (at level 70).\n\n*)\n\nModule Introduction.\n\n  (* Infinite sequence of ones. (not tested) *)\n  CoFixpoint ones : stream nat := 1 :: ones.\n  \n  (* Infinite sequence of given value. *)\n  CoFixpoint repeat {A : Set} (a : A) : stream A := a :: (repeat a).\n  \n  (* Elements at even and odd indexes, respectively. *)\n  CoFixpoint even {A : Set} (x : stream A) : stream A :=\n    (head x) :: (even (tail (tail x))).\n  Definition odd {A : Set} (x : stream A) : stream A := even (tail x).\n\n  Lemma even_odd {A : Set} (x : stream A) : odd (head x :: tail x) = even (tail x).\n  Proof. reflexivity. Qed.\n    \n  (* A stream equals its head plus its tail. (not tested) *)\n  Lemma stream_unfold : forall {A : Set} (a : stream A), a = head a :: tail a.\n  Proof. intros A a. destruct a. reflexivity. Qed.\n  \nEnd Introduction.\n\nModule Bisimulation.\n  \n  Export Introduction.\n  \n  (* Bisimulation is reflexive. *)\n  Theorem bisim_refl : forall {A : Set} (a : stream A), a == a.\n  Proof.\n    cofix CIH.\n    constructor.\n    reflexivity.\n    apply CIH.\n  Qed.\n     \n  (* Odd is tail of Even. *)\n  (* Hint: Do you really need cofix? It may depend on your own definition of odd and even. *)\n  Theorem odd_even : forall {A : Set} (a : stream A), odd a == even (tail a).\n  Proof.\n    intros A str.\n    pattern str at 1; rewrite stream_unfold.\n    rewrite even_odd.\n    apply bisim_refl.\n  Qed.\n\nEnd Bisimulation.\n\nModule Merge.\n\n  Export Bisimulation.\n  \n  (* Interleave two streams, starting with the left one. *)\n  CoFixpoint merge {A : Set} (x y : stream A) : stream A :=\n    head x :: merge y (tail x).\n\n  Lemma merge_unfold {A : Set} (x y : stream A) :\n    merge x y = head x :: merge y (tail x).\n  Proof. rewrite (stream_unfold (merge _ _)). reflexivity. Qed.    \n\n  Lemma merge_head {A : Set} (x y : stream A) : head (merge x y) = head x.\n  Proof. rewrite merge_unfold. reflexivity. Qed.\n\n  Lemma merge_tail {A : Set} (x y : stream A) : tail (merge x y) = (merge y (tail x)).\n  Proof. rewrite merge_unfold. reflexivity. Qed.\n\n  Lemma merge_double_unfold {A : Set} (x y : stream A) :\n    merge x y = head x :: head y :: merge (tail x) (tail y).\n  Proof.\n    rewrite (stream_unfold (merge _ _)). \n    rewrite merge_head.\n    rewrite merge_tail.\n    rewrite merge_unfold.\n    reflexivity.\n  Qed.\n  \n  (* Main task: Merge even and odd, and get the original. *)\n  Theorem moe : forall {A : Set} (a : stream A), merge (even a) (odd a) == a.\n  Proof.\n    intro A; cofix CIH; intro x.\n    rewrite merge_double_unfold.\n    constructor; [reflexivity|].\n    constructor; [reflexivity|].\n    unfold tail at 2; unfold tail at 1.\n    apply CIH.\n  Qed.\n\nEnd Merge.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32823,"user_id":null,"body":"Require Import Preloaded.\n\nModule Introduction.\n\n  (* Infinite sequence of ones. (not tested) *)\n  CoFixpoint ones : stream nat := 1 :: ones.\n  \n  (* Infinite sequence of given value. *)\n  CoFixpoint repeat {A : Set} (a : A) : stream A := a :: (repeat a).\n\n  (* Elements at even and odd indexes, respectively. *)\n  CoFixpoint even {A : Set} (x : stream A) : stream A := head x :: even (tail (tail x)).\n  Definition odd {A : Set} (x : stream A) : stream A := even (tail x).\n  \n  (* A stream equals its head plus its tail. (not tested) *)\n  Lemma stream_unfold : forall {A : Set} (a : stream A), a = head a :: tail a.\n  Proof. intros A a. destruct a. reflexivity. Qed.\n\nEnd Introduction.\n\nModule Bisimulation.\n  \n  Export Introduction.\n  \n  (* Bisimulation is reflexive. *)\n  Theorem bisim_refl : forall {A : Set} (a : stream A), a == a.\n  Proof.\n    cofix CIH.\n    intros A a.\n    constructor; auto.\n  Qed.\n  \n  (* Odd is tail of Even. *)\n  (* Hint: Do you really need cofix? It may depend on your own definition of odd and even. *)\n  Theorem odd_even : forall {A : Set} (a : stream A), odd a == even (tail a).\n  Proof.\n    intros A a.\n    unfold odd.\n    apply bisim_refl.\n  Qed.\n  \nEnd Bisimulation.\n\nModule Merge.\n\n  Export Bisimulation.\n  \n  (* Interleave two streams, starting with the left one. *)\n  CoFixpoint merge {A : Set} (x y : stream A) : stream A :=\n    head x :: merge y (tail x).\n  \n  (* Main task: Merge even and odd, and get the original. *)\n  Theorem moe : forall {A : Set} (a : stream A), merge (even a) (odd a) == a.\n  Proof.\n    cofix CIH.\n    intros A a.\n\n    destruct a.\n\n    constructor.\n    - reflexivity.\n    - unfold odd in *. simpl in *. apply CIH.\n  Qed.\n\nEnd Merge.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32824,"user_id":null,"body":"Require Import Preloaded.\n\nModule Introduction.\n\n  (* Infinite sequence of ones. (not tested) *)\n  CoFixpoint ones : stream nat := 1 :: ones.\n  \n  (* Infinite sequence of given value. *)\n  CoFixpoint repeat {A : Set} (a : A) : stream A := a :: repeat a.\n  \n  (* Elements at even and odd indexes, respectively. *)\n  CoFixpoint even {A : Set} (x : stream A) : stream A := head x :: even (tail (tail x)).\n  Definition odd {A : Set} (x : stream A) : stream A := even (tail x).\n  \n  (* A stream equals its head plus its tail. (not tested) *)\n  Lemma stream_unfold : forall {A : Set} (a : stream A), a = head a :: tail a.\n  Proof. now intros A [x a]. Qed.\n\nEnd Introduction.\n\nModule Bisimulation.\n  \n  Export Introduction.\n  \n  (* Bisimulation is reflexive. *)\n  Theorem bisim_refl : forall {A : Set} (a : stream A), a == a.\n  Proof. intros A; cofix IH; intros a; now apply bisim_eq. Qed.\n  \n  (* Odd is tail of Even. *)\n  (* Hint: Do you really need cofix? It may depend on your own definition of odd and even. *)\n  Theorem odd_even : forall {A : Set} (a : stream A), odd a == even (tail a).\n  Proof. intros A a; rewrite (stream_unfold a); apply bisim_refl. Qed.\n  \nEnd Bisimulation.\n\nModule Merge.\n\n  Export Bisimulation.\n  \n  (* Interleave two streams, starting with the left one. *)\n  CoFixpoint merge {A : Set} (x y : stream A) : stream A := head x :: merge y (tail x).\n\n  (* Main task: Merge even and odd, and get the original. *)\n  Theorem moe : forall {A : Set} (a : stream A), merge (even a) (odd a) == a.\n  Proof.\n    intros A; cofix IH; intros a; apply bisim_eq; [easy|].\n    apply bisim_eq; [easy|].\n    apply IH.\n  Qed.\n\nEnd Merge.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32825,"user_id":null,"body":"Require Import Preloaded.\n\n(* Preloaded code:\n\nCoInductive stream (A : Set) : Set :=\n  | cons : A -> stream A -> stream A.\nArguments cons {_} hd tl.\n\nNotation \"x :: y\" := (cons x y) (at level 60, right associativity).\n\nDefinition head {A} (x : stream A) := match x with\n  hd :: _ => hd end.\nDefinition tail {A} (x : stream A) := match x with\n  _ :: tl => tl end.\n\nCoInductive bisim {A : Set} (x y : stream A) : Set :=\n  | bisim_eq : head x = head y -> bisim (tail x) (tail y) -> bisim x y.\nNotation \"x == y\" := (bisim x y) (at level 70).\n\n*)\n\nModule Introduction.\n\n  (* Infinite sequence of ones. (not tested) *)\n  CoFixpoint ones : stream nat := 1 :: ones.\n  \n  (* Infinite sequence of given value. *)\n  CoFixpoint repeat {A : Set} (a : A) : stream A := a :: repeat a.\n  \n  (* Elements at even and odd indexes, respectively. *)\n  CoFixpoint even {A : Set} (x : stream A) : stream A := match x with \n    h :: h1 :: t => h :: even t end.\n  Definition odd {A : Set} (x : stream A) : stream A := even (tail x).\n  \n  (* A stream equals its head plus its tail. (not tested) *)\n  Lemma stream_unfold : forall {A : Set} (a : stream A), a = head a :: tail a.\n  Proof. intros A a. destruct a. reflexivity. Qed.\n\nEnd Introduction.\n\nModule Bisimulation.\n  \n  Export Introduction.\n  \n  (* Bisimulation is reflexive. *)\n  Theorem bisim_refl : forall {A : Set} (a : stream A), a == a.\n  Proof.\n    cofix CIH.\n    intros A a.\n    constructor.\n    reflexivity.\n    apply CIH.\n  Qed.\n\n  \n  (* Odd is tail of Even. *)\n  (* Hint: Do you really need cofix? It may depend on your own definition of odd and even. *)\n  Theorem odd_even : forall {A : Set} (a : stream A), odd a == even (tail a).\n  Proof.\n    intros A a.\n    replace (odd a) with (even (tail a)) by auto.\n    apply bisim_refl.\n  Qed.\n  \nEnd Bisimulation.\n\nModule Merge.\n\n  Export Bisimulation.\n  \n  (* Interleave two streams, starting with the left one. *)\n  CoFixpoint merge {A : Set} (x y : stream A) : stream A := match x,y with \n    | hx :: tx , hy :: ty => hx :: hy :: (merge tx ty) end. \n  \n  (* Main task: Merge even and odd, and get the original. *)\n  Theorem moe : forall {A : Set} (a : stream A), merge (even a) (odd a) == a.\n  Proof. \n    cofix CIH.\n    intros A a.\n    constructor.\n    destruct a as [v [w [z ta]]].\n    simpl.\n    reflexivity.\n    destruct a as [v [w [z ta]]].\n    simpl.\n    constructor.\n    simpl.\n    reflexivity.\n    simpl.\n    apply CIH.\n  Qed.\n\nEnd Merge.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32826,"user_id":null,"body":"Require Import Preloaded.\n\nModule Introduction.\n\n  (* Infinite sequence of ones. (not tested) *)\n  CoFixpoint ones : stream nat := 1 :: ones.\n  \n  (* Infinite sequence of given value. *)\n  CoFixpoint repeat {A : Set} (a : A) : stream A := a :: repeat a.\n  \n  (* Elements at even and odd indexes, respectively. *)\n  CoFixpoint even {A : Set} (x : stream A) : stream A :=\n    cons (head x) (even (tail (tail x))).\n  \n  Definition odd {A : Set} (x : stream A) : stream A :=\n    even (tail x).\n  \n  (* A stream equals its head plus its tail. (not tested) *)\n  Lemma stream_unfold : forall {A : Set} (a : stream A), a = head a :: tail a.\n  Proof. intros A a. destruct a. reflexivity. Qed.\n\nEnd Introduction.\n\nModule Bisimulation.\n  \n  Export Introduction.\n  \n  (* Bisimulation is reflexive. *)\n  Theorem bisim_refl : forall {A : Set} (a : stream A), a == a.\n  Proof. cofix CH; intros A s; constructor; auto. Qed.\n  \n  (* Odd is tail of Even. *)\n  (* Hint: Do you really need cofix? It may depend on your own definition of odd and even. *)\n  Theorem odd_even : forall {A : Set} (a : stream A), odd a == even (tail a).\n  Proof. intros A s; apply bisim_refl. Qed.\n  \nEnd Bisimulation.\n\nModule Merge.\n\n  Export Bisimulation.\n  \n  (* Interleave two streams, starting with the left one. *)\n  CoFixpoint merge {A : Set} (x y : stream A) : stream A :=\n    cons (head x) (cons (head y) (merge (tail x) (tail y))).\n  \n  (* Main task: Merge even and odd, and get the original. *)\n  Theorem moe : forall {A : Set} (a : stream A), merge (even a) (odd a) == a.\n  Proof.\n    cofix CH; intros A s.\n    constructor; auto; constructor; auto; apply CH.\n  Qed.\n\nEnd Merge.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32827,"user_id":null,"body":"Require Import Preloaded.\n\n(* Preloaded code:\n\nCoInductive stream (A : Set) : Set :=\n  | cons : A -> stream A -> stream A.\nArguments cons {_} hd tl.\n\nNotation \"x :: y\" := (cons x y) (at level 60, right associativity).\n\nDefinition head {A} (x : stream A) := match x with\n  hd :: _ => hd end.\nDefinition tail {A} (x : stream A) := match x with\n  _ :: tl => tl end.\n\nCoInductive bisim {A : Set} (x y : stream A) : Set :=\n  | bisim_eq : head x = head y -> bisim (tail x) (tail y) -> bisim x y.\nNotation \"x == y\" := (bisim x y) (at level 70).\n\n*)\nModule Introduction.\n\n  (* Infinite sequence of ones. (not tested) *)\n  CoFixpoint ones : stream nat := 1 :: ones.\n\n  (* Infinite sequence of given value. *)\n  CoFixpoint repeat {A : Set} (a : A) : stream A.\n    constructor.\n    assumption.\n    auto.\n  Defined.\n\n  CoFixpoint even {A : Set} (x : stream A) : stream A.\n    destruct x.\n    constructor.\n    assumption.\n    apply even.\n    destruct x.\n    assumption.\n  Defined.\n\n  (* Elements at even and odd indexes, respectively. *)\n  Definition odd {A : Set} (x : stream A) : stream A.\n    destruct x.\n    apply even.\n    assumption.\n  Defined.\n\n  (* A stream equals its head plus its tail. (not tested) *)\n  Lemma stream_unfold : forall {A : Set} (a : stream A), a = head a :: tail a.\n  Proof. intros A a. destruct a. reflexivity. Qed.\n\nEnd Introduction.\n\nModule Bisimulation.\n\n  Export Introduction.\n\n  (* Bisimulation is reflexive. *)\n  Theorem bisim_refl : forall {A : Set} (a : stream A), a == a.\n  Proof.\n    cofix H.\n    intros.\n    constructor.\n    easy.\n    auto.\n  Defined.\n\nHint Resolve bisim_refl.\n\n  (* Odd is tail of Even. *)\n  (* Hint: Do you really need cofix? It may depend on your own definition of odd and even. *)\n  Theorem odd_even : forall {A : Set} (x : stream A), odd x == even (tail x).\n  Proof.\n    intros.\n    constructor.\n    destruct x.\n    simpl.\n    easy.\n    destruct x.\n    simpl.\n    auto.\n  Defined.\n\nEnd Bisimulation.\n\nModule Merge.\n\n  Export Bisimulation.\n\n  (* Interleave two streams, starting with the left one. *)\n  CoFixpoint merge {A : Set} (x y : stream A) : stream A.\n    destruct x, y.\n    constructor.\n    exact a.\n    constructor.\n    exact a0.\n    apply (merge _ x y).\n  Defined.\n\n\n  (* Main task: Merge even and odd, and get the original. *)\n  Theorem moe : forall {A : Set} (a : stream A), merge (even a) (odd a) == a.\n  Proof.\n    cofix moe.\n    intros.\n    constructor.\n    rewrite (stream_unfold (a)).\n    simpl.\n    rewrite (stream_unfold (tail a)).\n    easy.\n    constructor.\n    rewrite (stream_unfold (a)).\n    simpl.\n    rewrite (stream_unfold (tail a)).\n    simpl.\n    easy.\n    simpl.\n    rewrite (stream_unfold (a)).\n    simpl.\n    rewrite (stream_unfold (tail a)).\n    simpl.\n    pose proof (moe A (tail (tail a))).\n    rewrite (stream_unfold (tail (tail a))) in *.\n    simpl.\n    exact H.\n  Defined.\nEnd Merge.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32828,"user_id":null,"body":"Require Import Preloaded.\n\n(* Preloaded code:\n\nCoInductive stream (A : Set) : Set :=\n  | cons : A -> stream A -> stream A.\nArguments cons {_} hd tl.\n\nNotation \"x :: y\" := (cons x y) (at level 60, right associativity).\n\nDefinition head {A} (x : stream A) := match x with\n  hd :: _ => hd end.\nDefinition tail {A} (x : stream A) := match x with\n  _ :: tl => tl end.\n\nCoInductive bisim {A : Set} (x y : stream A) : Set :=\n  | bisim_eq : head x = head y -> bisim (tail x) (tail y) -> bisim x y.\nNotation \"x == y\" := (bisim x y) (at level 70).\n\n*)\n\nModule Introduction.\n\n  (* Infinite sequence of ones. (not tested) *)\n  CoFixpoint ones : stream nat := 1 :: ones.\n  \n  (* Infinite sequence of given value. *)\n  CoFixpoint repeat {A : Set} (a : A) : stream A := \n    a :: repeat a.\n  \n    Definition head' {A} (x : stream A) := match x with\n    hd :: _ => hd end.\n  \n\n\n  (* Elements at even and odd indexes, respectively. *)\n  CoFixpoint even {A : Set} (x : stream A) : stream A :=\n    match x with \n      x1 :: _ :: xs => x1 :: even xs\n    end.\n\n  Definition odd {A : Set} (x : stream A) : stream A :=\n     match x with \n       _ :: xs => even xs\n     end.\n  \n  (* A stream equals its head plus its tail. (not tested) *)\n  Lemma stream_unfold : forall {A : Set} (a : stream A), a = head a :: tail a.\n  Proof. intros A a. destruct a. reflexivity. Qed.\n\nEnd Introduction.\n\nModule Bisimulation.\n  \n  Export Introduction.\n  \n  (* Bisimulation is reflexive. *)\n  Theorem bisim_refl : forall {A : Set} (a : stream A), a == a.\n  Proof.\n    cofix H.\n    intros. constructor. reflexivity. apply H. Qed.\n      \n  \n  (* Odd is tail of Even. *)\n  (* Hint: Do you really need cofix? It may depend on your own definition of odd and even. *)\n  Theorem odd_even : forall {A : Set} (a : stream A), odd a == even (tail a).\n  Proof. \n     intros.\n     destruct a. simpl. apply bisim_refl.\n  Qed.\n  \nEnd Bisimulation.\n\nModule Merge.\n\n  Export Bisimulation.\n  \n  (* Interleave two streams, starting with the left one. *)\n  CoFixpoint merge {A : Set} (x y : stream A) : stream A := \n     match x,y with \n       x1::xs , y1 ::ys => x1 :: y1 :: merge xs ys\n     end.\n  \n  (* Main task: Merge even and odd, and get the original. *)\n  Theorem moe : forall {A : Set} (a : stream A), merge (even a) (odd a) == a.\n  Proof. \n    cofix H.\n    intros.\n    destruct a. destruct a0. constructor. simpl. destruct a1. auto.\n    simpl. destruct a1. \n    constructor. simpl. auto. simpl tail.\n    replace (even a2) with (odd (a1::a2)). apply H. auto.\n  Qed.\n\nEnd Merge.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32829,"user_id":null,"body":"Require Import Preloaded.\n\n(* Preloaded code:\n\nCoInductive stream (A : Set) : Set :=\n  | cons : A -> stream A -> stream A.\nArguments cons {_} hd tl.\n\nNotation \"x :: y\" := (cons x y) (at level 60, right associativity).\n\nDefinition head {A} (x : stream A) := match x with\n  hd :: _ => hd end.\nDefinition tail {A} (x : stream A) := match x with\n  _ :: tl => tl end.\n\nCoInductive bisim {A : Set} (x y : stream A) : Set :=\n  | bisim_eq : head x = head y -> bisim (tail x) (tail y) -> bisim x y.\nNotation \"x == y\" := (bisim x y) (at level 70).\n\n*)\n\nModule Introduction.\n\n  (* Infinite sequence of ones. (not tested) *)\n  CoFixpoint ones : stream nat := 1 :: ones.\n  \n  (* Infinite sequence of given value. *)\n  CoFixpoint repeat {A : Set} (a : A) : stream A := a :: repeat a.\n  \n  (* Elements at even and odd indexes, respectively. *)\n  CoFixpoint even {A : Set} (x : stream A) : stream A :=\n    match x with\n      | a :: (b :: rest) => a :: even rest\n    end.\n  \n  Definition odd {A : Set} (x : stream A) : stream A :=\n  match x with\n    | y :: ys => even ys\n  end.\n  \n  (* A stream equals its head plus its tail. (not tested) *)\n  Lemma stream_unfold : forall {A : Set} (a : stream A), a = head a :: tail a.\n  Proof. intros A a. destruct a. reflexivity. Qed.\n\nEnd Introduction.\n\nModule Bisimulation.\n  \n  Export Introduction.\n  \n  (* Bisimulation is reflexive. *)\n  Theorem bisim_refl : forall {A : Set} (a : stream A), a == a.\n  Proof.\n    cofix H.\n    intros.\n    destruct a.\n    apply bisim_eq.\n    + reflexivity.\n    + simpl. apply H.\n  Qed.\n  \n  (* Odd is tail of Even. *)\n  (* Hint: Do you really need cofix? It may depend on your own definition of odd and even. *)\n  Theorem odd_even : forall {A : Set} (a : stream A), odd a == even (tail a).\n  Proof.\n  intros.\n  destruct a.\n  simpl. apply bisim_refl.\n  Qed.\n  \nEnd Bisimulation.\n\nModule Merge.\n\n  Export Bisimulation.\n  \n  (* Interleave two streams, starting with the left one. *)\n  CoFixpoint merge {A : Set} (x y : stream A) : stream A :=\n    match x, y with\n      x::xs, y::ys => x :: y :: merge xs ys\n    end.\n  \n  (* Main task: Merge even and odd, and get the original. *)\n  Theorem moe : forall {A : Set} (a : stream A), merge (even a) (odd a) == a.\n  Proof.\n    cofix H.\n    intros.\n    destruct a as [x xs].\n    simpl.\n    destruct xs as [y xs].\n    destruct xs as [z xs].\n    rewrite (stream_unfold (even _ )); simpl.\n    pattern (even (y :: z :: xs)).\n    rewrite (stream_unfold (even (y :: z :: xs))).\n    simpl.\n    rewrite (stream_unfold (merge _ _)).\n    simpl.\n    apply bisim_eq; try reflexivity.\n    simpl.\n    apply bisim_eq; try reflexivity.\n    simpl.\n    replace (even xs) with (odd (z :: xs)); try reflexivity.\n    apply H.\n  Qed.\n\nEnd Merge.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5cc10885658d6f001281038a":[{"id":32830,"user_id":196,"body":"Require Import List Arith Omega.\nImport ListNotations.\nRequire Import Preloaded. (* All the preloaded codes are in the description *)\n\n(* Task 1 - 1. Prove that eval_expr_tail is equivalent to eval_expr. *)\n\nTheorem eval_expr_tail_correct : forall e, eval_expr_tail e = eval_expr e.\nProof.\n  intro e. change (eval_expr_tail' e 0 = 0 + eval_expr e). generalize 0 as acc.\n  induction e; intros; cbn; rewrite ?IHe1, ?IHe2; auto with *.\nQed.\n\n(* Task 1 - 2. Prove that eval_expr_cont is equivalent to eval_expr. *)\n\nTheorem eval_expr_cont_correct : forall e, eval_expr_cont e = eval_expr e.\nProof.\n  intro e. change (eval_expr_cont' e (fun n => n) = (fun n => n) (eval_expr e)).\n  generalize (fun n : nat => n) as f.\n  induction e; intros; cbn; rewrite ?IHe2, ?IHe1; reflexivity.\nQed.\n\n(* Task 2. Prove that you get the expected result when you compile and run the program. *)\n\nLemma compile_append : forall p1 p2 s, run (p1 ++ p2) s = run p2 (run p1 s).\nProof.\n  induction p1; intros p2 s; cbn; rewrite ?IHp1; reflexivity.\nQed.\n\nTheorem compile_correct : forall e, run (compile e) [] = [eval_expr e].\nProof.\n  intro e. generalize (@nil nat) as s.\n  induction e; intro s; cbn; try rewrite compile_append, IHe1, compile_append, IHe2, Nat.add_comm; reflexivity.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32831,"user_id":null,"body":"Require Import List Arith.\nImport ListNotations.\nRequire Import Preloaded. (* All the preloaded codes are in the description *)\n\n(* Task 1 - 1. Prove that eval_expr_tail is equivalent to eval_expr. *)\n\nLemma eval_expr_tail_add e n : eval_expr_tail' e n = eval_expr_tail' e 0 + n.\nProof.\n  generalize n; clear n; elim e; clear e; [intros; cbn; rewrite <- plus_n_O; reflexivity|].\n  intros e1 H1 e2 H2.\n  simpl; rewrite H2; intro n; rewrite H2; rewrite H1; rewrite Nat.add_assoc; reflexivity.\nQed.\n  \nTheorem eval_expr_tail_correct : forall e, eval_expr_tail e = eval_expr e.\nProof.\n  intro e; elim e; clear e.\n  cbn; intro n; rewrite plus_n_O ; reflexivity.\n  unfold eval_expr_tail; intros e1 H1 e2 H2.\n  simpl; rewrite eval_expr_tail_add.\n  rewrite H1; rewrite H2.\n  rewrite Nat.add_comm; reflexivity.\nQed.\n\n(* Task 1 - 2. Prove that eval_expr_cont is equivalent to eval_expr. *)\n\nLemma eval_expr_cont_apply (e : expr) (k : nat -> nat)  : eval_expr_cont' e k = k (eval_expr_cont' e (fun x=> x)).\nProof.\n  generalize k; clear k.\n  elim e. cbn. reflexivity.\n  intros e1 H1 e2 H2 k.\n  simpl.\n  rewrite H2; rewrite H1.\n  apply f_equal.\n  apply eq_sym.\n  rewrite H2; rewrite H1.\n  reflexivity.\nQed.\n(* TBH this rewriting was more luck than insight. It felt like computer had found the proof for me... cool :D *)\n\nTheorem eval_expr_cont_correct : forall e, eval_expr_cont e = eval_expr e.\nProof.\n  unfold eval_expr_cont.\n  intro e; elim e; clear e; [cbn; reflexivity|].\n  intros e1 H1 e2 H2.\n  simpl. rewrite 2!eval_expr_cont_apply.\n  rewrite H1; rewrite H2; reflexivity.\nQed.\n\n\n(* Task 2. Prove that you get the expected result when you compile and run the program. *)\n\nLemma run_unfold instr p s: run (instr :: p) s = run p (run [instr] s).\nProof. reflexivity. Qed.\n\nLemma run_sequential p1 p2 s: run p2 (run p1 s) = run (p1 ++ p2) s.\nProof.\n  generalize s; clear s.\n  elim p1; clear p1.\n  rewrite app_nil_l; reflexivity.\n  intros i l H s.\n  rewrite <- app_comm_cons.\n  rewrite run_unfold.\n  apply eq_sym.\n  rewrite run_unfold.\n  rewrite H.\n  reflexivity.\nQed.\n\nTheorem compile_correct_generalised : forall e s, run (compile e) s = (eval_expr e :: s).\nProof.\n  intro e; elim e; clear e; [cbn; reflexivity|].\n  intros e1 H1 e2 H2 s.\n  simpl.\n  rewrite <- run_sequential.\n  rewrite H1.\n  rewrite <- run_sequential.\n  rewrite H2.\n  simpl; rewrite Nat.add_comm; reflexivity.\nQed.\n  \nTheorem compile_correct : forall e, run (compile e) [] = [eval_expr e].\nProof. intro e; apply compile_correct_generalised. Qed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32832,"user_id":null,"body":"Require Import List Arith.\nImport ListNotations.\nRequire Import Preloaded. (* All the preloaded codes are in the description *)\n\n(* Task 1 - 1. Prove that eval_expr_tail is equivalent to eval_expr. *)\n\nTheorem eval_expr_tail_correct : forall e, eval_expr_tail e = eval_expr e.\nProof.\n  unfold eval_expr_tail; intros e; replace (eval_expr e) with (0 + eval_expr e); [|easy].\n  generalize 0; induction e; intros acc; [simpl; ring|].\n  simpl; rewrite IHe1, IHe2; ring.\nQed.\n\n(* Task 1 - 2. Prove that eval_expr_cont is equivalent to eval_expr. *)\n\nTheorem eval_expr_cont_correct : forall e, eval_expr_cont e = eval_expr e.\nProof.\n  intros e; cut (forall A (f : nat -> A), eval_expr_cont' e f = f (eval_expr e)); [intros H; apply H|].\n  induction e; intros A f; [easy|].\n  simpl; now rewrite IHe2, IHe1.\nQed.\n\n(* Task 2. Prove that you get the expected result when you compile and run the program. *)\n\nLemma run_app : forall c1 c2 s, run (c1 ++ c2) s = run c2 (run c1 s).\nProof.\n  induction c1 as [|c c1]; intros c2 s; [easy|].\n  simpl; now rewrite IHc1.\nQed.\n\nTheorem compile_correct : forall e, run (compile e) [] = [eval_expr e].\nProof.\n  intros e; cut (forall s, run (compile e) s = eval_expr e :: s); [intros H; apply H|].\n  induction e; intros s; [easy|].\n  simpl; now rewrite run_app, run_app, IHe1, IHe2, Nat.add_comm.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32833,"user_id":null,"body":"Require Import List Arith Omega.\nImport ListNotations.\nRequire Import Preloaded. (* All the preloaded codes are in the description *)\n\n(* Task 1 - 1. Prove that eval_expr_tail is equivalent to eval_expr. *)\n\nTheorem eval_expr_tail_correct : forall e, eval_expr_tail e = eval_expr e.\nProof.\n  unfold eval_expr_tail.\n  intros e; rewrite <- Nat.add_0_r; generalize 0; induction e; intros k.\n  - easy.\n  - simpl; rewrite IHe1, IHe2; ring.\nQed.\n\n(* Task 1 - 2. Prove that eval_expr_cont is equivalent to eval_expr. *)\n\nTheorem eval_expr_cont_correct : forall e, eval_expr_cont e = eval_expr e.\nProof.\n  unfold eval_expr_cont; set (f := fun n => n).\n  intros e; assert (eval_expr e = f (eval_expr e)) as R by easy; rewrite R; clear R.\n  generalize f; clear f; induction e; intros f.\n  - easy.\n  - simpl; now rewrite IHe2, IHe1.\nQed.\n\n(* Task 2. Prove that you get the expected result when you compile and run the program. *)\n\nLemma run_app : forall {c1 c2 st st'}, run c1 st = st' -> run (c1 ++ c2) st = run c2 st'.\nProof.\n  induction c1; intros c2 st st' Hc1.\n  - now subst.\n  - now apply IHc1.\nQed.\n\nLemma run_compile : forall e st, run (compile e) st = eval_expr e :: st.\nProof.\n  induction e; intros st.\n  - easy.\n  - simpl; rewrite (run_app (IHe1 _)), (run_app (IHe2 _)).\n    simpl; now rewrite Nat.add_comm.\nQed.\n\nTheorem compile_correct : forall e, run (compile e) [] = [eval_expr e].\nProof.\n  intros e; now rewrite run_compile.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32834,"user_id":null,"body":"Require Import List Arith Omega.\nImport ListNotations.\nRequire Import Preloaded. (* All the preloaded codes are in the description *)\n\n(* Task 1 - 1. Prove that eval_expr_tail is equivalent to eval_expr. *)\n\nLemma lem1 : forall (e:expr)(acc:nat), eval_expr_tail' e acc = eval_expr e + acc.\nProof.\n  intro e.\n  induction e as [ | e1 H1 e2 H2 ]; intro acc; cbn.\n  - ring.\n  - rewrite H1, H2; ring.\nQed.\n\nTheorem eval_expr_tail_correct : forall e, eval_expr_tail e = eval_expr e.\nProof.\n  intro e.\n  unfold eval_expr_tail.\n  pose proof (H := lem1 e 0).\n  omega.\nQed.\n\n(* Task 1 - 2. Prove that eval_expr_cont is equivalent to eval_expr. *)\n\nLemma eval_expr_cont'_ext : forall {A}(e:expr)(k1 k2:nat->A), (forall n:nat, k1 n = k2 n) -> eval_expr_cont' e k1 = eval_expr_cont' e k2.\nProof.\n  intros A e.\n  induction e as [ | e1 H1 e2 H2 ]; intros k1 k2 H.\n  - cbn; auto.\n  - simpl.\n    apply H2.\n    intro n.\n    apply H1.\n    auto.\nQed.\n\nLemma lem2 : forall (e:expr)(acc:nat), eval_expr_cont' e (fun x:nat => x + acc) = eval_expr_tail' e acc.\nProof.\n  intros e.\n  induction e as [ | e1 H1 e2 H2 ] .\n  - reflexivity.\n  - intro acc.\n    cbn.\n    rewrite <- H2.\n    apply eval_expr_cont'_ext.\n    intro n.\n    replace (eval_expr_cont' e1 (fun n1 : nat => n1 + n + acc)) with (eval_expr_cont' e1 (fun n1 : nat => n1 + (n + acc))).\n    + rewrite H1, 2 lem1.\n      ring.\n    + apply eval_expr_cont'_ext.\n      intro.\n      ring.\nQed.\n\nTheorem eval_expr_cont_correct : forall e, eval_expr_cont e = eval_expr e.\nProof.\n  intro e.\n  rewrite <- eval_expr_tail_correct.\n  unfold eval_expr_cont, eval_expr_tail.\n  rewrite <- (lem2 e 0).\n  apply eval_expr_cont'_ext.\n  auto with arith.\nQed.\n\n(* Task 2. Prove that you get the expected result when you compile and run the program. *)\n\nLemma lem3 : forall (e:expr)(p:prog)(s:stack), run (compile e ++ p) s = run p (eval_expr e :: s).\nProof.\n  intros e.\n  induction e as [ | e1 H1 e2 H2].\n  - reflexivity.\n  - intros p s.\n    cbn.\n    rewrite 2 app_assoc_reverse, H1, H2.\n    cbn.\n    rewrite Nat.add_comm.\n    reflexivity.\nQed.\n\nTheorem compile_correct : forall e, run (compile e) [] = [eval_expr e].\nProof.\n  intro e.\n  induction e.\n  - reflexivity.\n  - cbn.\n    rewrite 2 lem3.\n    cbn.\n    rewrite Nat.add_comm.\n    reflexivity.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32835,"user_id":null,"body":"Require Import List Arith Omega.\nImport ListNotations.\nRequire Import Preloaded. (* All the preloaded codes are in the description *)\n\n(* Task 1 - 1. Prove that eval_expr_tail is equivalent to eval_expr. *)\n\nLemma eval_expr_tail'_correct : forall e acc, eval_expr_tail' e acc = acc + eval_expr e.\nProof.\n  induction e; intros; simpl.\n  - omega.\n  - rewrite IHe1.\n    rewrite IHe2.\n    omega.\nQed.\nTheorem eval_expr_tail_correct : forall e, eval_expr_tail e = eval_expr e.\nProof.\n  unfold eval_expr_tail.\n  intros.\n  apply (eval_expr_tail'_correct _ 0).\nQed.\n\n(* Task 1 - 2. Prove that eval_expr_cont is equivalent to eval_expr. *)\n\nLemma eval_expr_cont'_correct : forall A e (k : nat -> A), eval_expr_cont' e k = k (eval_expr e).\nProof.\n  induction e; intros; simpl; auto.\n  rewrite IHe2.\n  rewrite IHe1.\n  reflexivity.\nQed.\n\nTheorem eval_expr_cont_correct : forall e, eval_expr_cont e = eval_expr e.\nProof.\n  unfold eval_expr_cont.\n  intros.\n  apply eval_expr_cont'_correct.\nQed.  \n\n(* Task 2. Prove that you get the expected result when you compile and run the program. *)\n\nLemma run_app : forall l1 l2 s, run (l1 ++ l2) s = run l2 (run l1 s).\nProof.\n  induction l1; simpl; auto.\nQed.\nLemma compile_correct' : forall e s, run (compile e) s = [eval_expr e] ++ s.\nProof.\n  induction e; intros; simpl; auto.\n  rewrite run_app.\n  rewrite run_app.\n  rewrite IHe1.\n  rewrite IHe2.\n  simpl.\n  rewrite plus_comm.\n  reflexivity.\nQed.\n\nTheorem compile_correct : forall e, run (compile e) [] = [eval_expr e].\nProof.\n  intro.\n  apply compile_correct'.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32836,"user_id":null,"body":"Require Import List Arith Omega.\nImport ListNotations.\nRequire Import Preloaded. (* All the preloaded codes are in the description *)\n\n(* Task 1 - 1. Prove that eval_expr_tail is equivalent to eval_expr. *)\n\nTheorem eval_expr_tail_correct : forall e, eval_expr_tail e = eval_expr e.\nProof.\n  intros e; unfold eval_expr_tail; rewrite (plus_n_O (eval_expr e)).\n  generalize 0; induction e; intros.\n  - easy.\n  - simpl; rewrite IHe1, IHe2; ring.\nQed.\n\n(* Task 1 - 2. Prove that eval_expr_cont is equivalent to eval_expr. *)\n\nTheorem eval_expr_cont_correct : forall e, eval_expr_cont e = eval_expr e.\nProof.\n  intros e; unfold eval_expr_cont.\n  set (fn := fun n => n); assert (eval_expr e = fn (eval_expr e)); [easy|rewrite H; clear H].\n  generalize fn; clear; induction e; intros.\n  - easy.\n  - simpl; now rewrite IHe2, IHe1.\nQed.\n\n(* Task 2. Prove that you get the expected result when you compile and run the program. *)\n\nLemma run_app : forall {p1 p2 s1 s2 s3},\n  run p1 s1 = s2 ->\n  run p2 s2 = s3 ->\n  run (p1 ++ p2) s1 = s3.\nProof.\n  induction p1; intros.\n  - simpl in H; now rewrite H.\n  - destruct a; now apply (IHp1 p2 _ s2 s3).\nQed.\n\nTheorem compile_correct : forall e, run (compile e) [] = [eval_expr e].\nProof.\n  cut (forall e s, run (compile e) s = eval_expr e :: s); [easy|].\n  induction e; intros.\n  - easy.\n  - simpl; apply (run_app (IHe1 _)), (run_app (IHe2 _)).\n    now rewrite Nat.add_comm.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32837,"user_id":null,"body":"Require Import List Arith Omega.\nImport ListNotations.\nRequire Import Preloaded. (* All the preloaded codes are in the description *)\n\n(* Task 1 - 1. Prove that eval_expr_tail is equivalent to eval_expr. *)\n\nTheorem eval_expr_tail_correct : forall e, eval_expr_tail e = eval_expr e.\nProof.\n  assert (forall e acc, eval_expr_tail' e acc = eval_expr e + acc) as Ha.\n  { induction e; intros.\n    - simpl. reflexivity.\n    - simpl. rewrite IHe1, IHe2.\n      rewrite (Nat.add_comm _ (eval_expr e2)).\n      apply Nat.add_assoc.\n  }\n  intros. unfold eval_expr_tail. rewrite Ha. apply Nat.add_0_r.\nQed.\n\n(* Task 1 - 2. Prove that eval_expr_cont is equivalent to eval_expr. *)\n\nTheorem eval_expr_cont_correct : forall e, eval_expr_cont e = eval_expr e.\nProof.\n  assert (forall {A} e (k : nat -> A), eval_expr_cont' e k = k (eval_expr e)) as Ha.\n  { induction e; intros.\n    - simpl. reflexivity.\n    - simpl. rewrite IHe2. apply IHe1.\n  }\n  intros. unfold eval_expr_cont. apply Ha.\nQed.\n\n(* Task 2. Prove that you get the expected result when you compile and run the program. *)\n\nTheorem compile_correct : forall e, run (compile e) [] = [eval_expr e].\nProof.\n  assert (forall e p s, run (compile e ++ p) s = run p ((eval_expr e) :: s)) as Ha.\n  { induction e; intros.\n    - simpl. reflexivity.\n    - simpl. rewrite 2!app_assoc_reverse.\n      rewrite IHe1. rewrite IHe2. simpl.\n      rewrite Nat.add_comm. reflexivity.\n  }\n  intros.\n  specialize (Ha e [] []). rewrite app_nil_r in Ha. assumption.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32838,"user_id":null,"body":"Require Import List Arith Omega.\nImport ListNotations.\nRequire Import Preloaded. (* All the preloaded codes are in the description *)\n\nHint Rewrite app_ass : core.\nLtac crush :=\n  let rewriter := (autorewrite with core in *;\n                   repeat (match goal with\n                           | [ H : _ |- _ ] => rewrite H by crush\n                           end; autorewrite with core in * ))\n  in\n  simpl in *; intuition; rewriter; auto with arith; simpl in *; intuition.\n\nTheorem eval_expr_tail_correct : forall e, eval_expr_tail e = eval_expr e.\nProof using.\n  intro e; change (eval_expr_tail' e 0 = 0 + eval_expr e); generalize 0 as acc.\n  induction e; crush.\nQed.\n\nTheorem eval_expr_cont_correct : forall e, eval_expr_cont e = eval_expr e.\nProof using.\n  intro e; change (eval_expr_cont' e id = id (eval_expr e)); generalize (@id nat) as k.\n  induction e; crush.\nQed.\n\nLemma run_distr : forall p1 p2 s, run (p1 ++ p2) s = run p2 (run p1 s).\nProof using.\n  induction p1; crush.\nQed.\n\nTheorem compile_correct : forall e, run (compile e) [] = [eval_expr e].\nProof using.\n  intro e. generalize ([] : stack) as s.\n  Hint Rewrite run_distr : core.\n  Hint Extern 1 => match goal with | [ |- _ :: ?S = _ :: ?S ] => f_equal end : core.\n  induction e; crush.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32839,"user_id":null,"body":"Require Import List Arith Omega.\nImport ListNotations.\nRequire Import Preloaded. (* All the preloaded codes are in the description *)\n\n(* Task 1 - 1. Prove that eval_expr_tail is equivalent to eval_expr. *)\n\nTheorem eval_expr_tail_correct : forall e, eval_expr_tail e = eval_expr e.\nProof using.\n  enough (forall e acc, eval_expr_tail' e acc = eval_expr e + acc)\n    by (unfold eval_expr_tail; intros; rewrite plus_n_O; auto).\n  Hint Extern 1 =>\n  match goal with\n  | [ IH: forall acc, eval_expr_tail' ?E acc = eval_expr ?E + acc |- _ ] =>\n    rewrite IH; clear IH; try omega\n  end : core.\n  induction e; intros; simpl; auto.\nQed.\n\n(* Task 1 - 2. Prove that eval_expr_cont is equivalent to eval_expr. *)\n\nTheorem eval_expr_cont_correct : forall e, eval_expr_cont e = eval_expr e.\nProof using.\n  enough (H: forall A e (k : nat -> A), eval_expr_cont' e k = k (eval_expr e))\n    by (unfold eval_expr_cont; intros; apply H).\n  Hint Extern 1 =>\n  match goal with\n  | [ IH: forall k, eval_expr_cont' ?E k = _ |- _ ] => rewrite IH\n  end : core.  \n  induction e; intros; simpl; auto.\nQed.\n\n(* Task 2. Prove that you get the expected result when you compile and run the program. *)\n\nLemma run_distr : forall p1 p2 s, run (p1 ++ p2) s = run p2 (run p1 s).\nProof using.\n  induction p1; simpl; auto.\nQed.\n\nTheorem compile_correct : forall e, run (compile e) [] = [eval_expr e].\nProof using.\n  enough (H: forall e s, run (compile e) s = eval_expr e :: s)\n    by (intros; apply H).\n  Hint Rewrite run_distr : core.\n  induction e; intros; simpl; autorewrite with core; auto;\n  repeat match goal with\n  | [ IH: forall s, run (compile ?E) s = _ |- _ ] =>\n    rewrite IH; clear IH\n  end;\n  simpl; f_equal; auto with arith.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5cc15c2628b42000147b6ed8":[{"id":32840,"user_id":null,"body":"Require Import Preloaded.\n\nTheorem not_fin_then_inf : forall n : conat, ~ (exists m : nat, toCo m == n) -> (n == inf).\nProof.\n  cofix F.\n  intros n Hn.\n  unfold inf; rewrite conat_unfold; unfold conat_u; fold inf.\n  destruct n.\n  exfalso; apply Hn; exists 0; simpl; constructor.\n  constructor.\n  apply F.\n  intros [x Hx]; apply Hn.\n  exists (S x); simpl.\n  constructor; assumption.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32841,"user_id":null,"body":"Require Import Preloaded.\n\nTheorem not_fin_then_inf : forall n : conat, ~ (exists m : nat, toCo m == n) -> (n == inf).\nProof.\n  cofix CH; intros n H.\n  rewrite (conat_unfold n); unfold conat_u; destruct n.\n  - exfalso; apply H; exists O; constructor.\n  - rewrite (conat_unfold inf); simpl.\n    constructor; apply CH.\n    intros [m HC]; apply H.\n    exists (S m); constructor; auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32842,"user_id":null,"body":"Require Import Preloaded.\n\nTheorem not_fin_then_inf : forall n : conat,\n  ~ (exists m : nat, toCo m == n) -> (n == inf).\nProof.\n  cofix H.\n  intros.\n  destruct n.\n  - exfalso. apply H0. exists 0. simpl. apply OO.\n  - assert (n == inf).\n    + apply H. intros [m Hm]. apply H0. exists (S m).\n      simpl. apply SS. assumption.\n    + rewrite (conat_unfold inf). simpl.\n      apply SS. assumption.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32843,"user_id":null,"body":"Require Import Preloaded.\n\nTheorem not_fin_then_inf : forall n : conat, ~ (exists m : nat, toCo m == n) -> (n == inf).\nProof.\n  cofix CIH; intros.\n  destruct n.\n  - contradiction H. exists 0. constructor.\n  - rewrite (conat_unfold inf). cbn. constructor.\n    apply CIH. intros (m & contra).\n    apply H. exists (S m). cbn. constructor. assumption.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32844,"user_id":null,"body":"Require Import Preloaded.\n\nLemma bisim_refl : forall n, bisim n n.\nProof. cofix IH. intros [ | n ]; constructor; apply IH. Qed.\n  \nTheorem not_fin_then_inf : forall n : conat, ~ (exists m : nat, toCo m == n) -> (n == inf).\nProof.\n  cofix IH.\n  intros [ | n' ].\n  + intros H. exfalso. apply H. exists O.\n    simpl toCo. apply bisim_refl.\n  + intros H. rewrite (conat_unfold inf).\n    change (S' n' == S' inf).\n    constructor. apply IH.\n    intros [m H']. apply H. clear H.\n    exists (S m). simpl. constructor. assumption.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32845,"user_id":null,"body":"Require Import Preloaded.\n\nTheorem not_fin_then_inf : forall n : conat,\n ~ (exists m : nat, toCo m == n) -> (n == inf).\nProof.\n cofix CIH. intros [|n'] H.\n * assert (exists m:nat , toCo m == O'). { exists O. constructor. }\n   contradiction.\n * rewrite (conat_unfold inf).\n   constructor.\n   apply CIH.\n   intros [m Hm];apply H.\n   exists (S m).\n   constructor.\n   assumption.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32846,"user_id":null,"body":"Require Import Preloaded.\n\nTheorem not_fin_then_inf : forall n : conat, ~ (exists m : nat, toCo m == n) -> (n == inf).\nProof. \n  cofix F.\n  intros.\n  destruct n.\n  - contradict H.\n    exists 0;constructor.\n  - rewrite conat_unfold; cbn. \n    constructor.\n    apply F.\n    contradict H.\n    destruct H; exists (S x); cbn.\n    now constructor.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32847,"user_id":null,"body":"Require Import Preloaded.\n\nTheorem not_fin_then_inf : forall n : conat, ~ (exists m : nat, toCo m == n) -> (n == inf).\nProof.\n  cofix X.\n  intros.\n  destruct n.\n  {\n    exfalso.\n    apply H.\n    exists O.\n    constructor.\n  }\n  rewrite conat_unfold.\n  simpl.\n  constructor.\n  apply X.\n  unfold not.\n  intros.\n  apply H.\n  destruct H0.\n  exists (S x).\n    simpl.\n  constructor.\n  apply H0.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32848,"user_id":196,"body":"Require Import Preloaded.\n\nTheorem not_fin_then_inf : forall n : conat, ~ (exists m : nat, toCo m == n) -> (n == inf).\nProof.\n  cofix CIH. intros n h. destruct n.\n  - exfalso. apply h. exists 0. constructor.\n  - rewrite (conat_unfold inf). constructor. apply CIH. intros [m hm].\n    apply h. exists (S m). constructor. exact hm.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32849,"user_id":null,"body":"Require Import Preloaded.\n\nTheorem not_fin_then_inf : forall n : conat, ~ (exists m : nat, toCo m == n) -> (n == inf).\nProof.\n  cofix CIH.\n  intros.\n  destruct n.\n  - contradiction H.\n    exists 0. constructor.\n  - rewrite (conat_unfold inf). simpl.\n    constructor.\n    apply CIH.\n    intros [m Hm].\n    apply H.\n    exists (S m). simpl.\n    auto using SS.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5cc29e3128b420000c85cc19":[{"id":32850,"user_id":168,"body":"Require Import Arith ssreflect.\nRequire Import Preloaded.\nImport Nat.\n\nTheorem EM_impl_LPO : EM -> LPO.\nProof.\n  rewrite \/EM \/LPO => em f.\n  case: (em (exists n, f n = true)) => h; first by right.\n  left => n; case eq: (f n) => \/\/.\n  by contradiction h; exists n.\nQed.\n\nTheorem LPO_impl_LLPO : LPO -> LLPO.\nProof.\n  rewrite \/LPO \/LLPO => lpo f h.\n  case: (lpo f) => [? | [m eq]]; first by left.\n  case ev: (even m).\n  - right => n en.\n    have nm: n <> m by move => nm; rewrite nm in en; rewrite ev in en.\n    by case: (h n m nm) => \/\/; rewrite eq.\n  - left => n en.\n    have nm: n <> m by move => nm; rewrite nm in en; rewrite ev in en.\n    by case: (h n m nm) => \/\/; rewrite eq.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32851,"user_id":null,"body":"Require Import Arith.\nRequire Import Preloaded.\nImport Nat.\n\nTheorem EM_impl_LPO : EM -> LPO.\nProof.\n  red; intros.\n  destruct (H (exists n : nat, f n = true)); auto.\n  left; intros. case_eq (f n); intros; auto.\n  elim H0. eauto.\nQed.\n\nTheorem LPO_impl_LLPO : LPO -> LLPO.\nProof.\n  red; intros.\n  destruct (H f).\n  - left; auto.\n  - destruct H1 as [N H1].\n    case_eq (even N); intros.\n    + right. intros.\n      destruct (H0 n N); congruence.\n    + left. intros. destruct (H0 n N); congruence.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32852,"user_id":568,"body":"Require Import Arith.\nRequire Import Preloaded.\nImport Nat.\n\nTheorem EM_impl_LPO : EM -> LPO.\nProof.\n  unfold EM, LPO.\n  intros HEM f.\n  match goal with\n    |- ?A \\\/ ?B => destruct (HEM B)\n  end.\n  - auto.\n  - left.\n    intros.\n    destruct (f n) eqn:?.\n    * contradict H.\n      exists n; assumption.\n    * reflexivity.\nQed.\n\nTheorem LPO_impl_LLPO : LPO -> LLPO.\nProof.\n  unfold LPO, LLPO.\n  intros HLPO.\n  intros f uniq.\n  destruct (HLPO f).\n  - auto.\n  - destruct H.\n    destruct (even x) eqn:He;\n    (right + left); intros; destruct (uniq x n); congruence.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32853,"user_id":null,"body":"Require Import Arith.\nRequire Import Preloaded.\nImport Nat.\n\nTheorem EM_impl_LPO : EM -> LPO.\nProof.\n  intros EM f.\n  case (EM (forall n, f n = false)).\n  intro H; left; assumption.\n  intro nH; right.\n  case (EM (exists n : nat, f n = true)).\n  intro H; assumption.\n  intro nE; exfalso.\n  apply nH.  \n  intro n.\n  generalize (Logic.eq_refl (f n)); pattern (f n) at 2; case (f n).\n  intro X; exfalso.\n  apply nE; exists n; assumption.\n  intros; assumption.\nQed.\n\nTheorem LPO_impl_LLPO : LPO -> LLPO.\nProof.\n  intros LPO f H1t.\n  case (LPO f).\n  intros H; left; intros; apply H.\n  intros [x Hx].\n  generalize (Logic.eq_refl (even x)); pattern (even x) at 2; case (even x); intro Hex.\n  * right.\n    intros n Hn.\n    {\n      case (H1t n x).\n      - intro Hnx; rewrite Hnx in Hn; rewrite Hn in Hex.\n        apply Bool.diff_false_true; assumption.\n      - intros; assumption.\n      - intro Hxn; exfalso.\n        rewrite Hxn in Hx; apply Bool.diff_false_true; assumption.\n    }\n  * left.\n    intros n Hn.\n    {\n      case (H1t n x).\n      - intro Hnx; rewrite Hnx in Hn; rewrite Hn in Hex.\n        apply Bool.diff_true_false; assumption.\n      - intros; assumption.\n      - intros Hxf; rewrite Hxf in Hx.\n        exfalso; apply Bool.diff_false_true; assumption.\n    }\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32854,"user_id":null,"body":"Require Import Arith Even Preloaded.\nFrom mathcomp Require Import all_ssreflect.\nImport Nat.\n\nTheorem EM_impl_LPO : EM -> LPO.\nProof.\n  rewrite \/EM \/LPO => EM f.\n  move: (EM (exists n, f n = true)) => [H | H]; first by right.\n  left => n; apply: Bool.not_true_is_false => \/(ex_intro (fun n => f n = true) _) nH \/\/.\nQed.\n\nTheorem LPO_impl_LLPO : LPO -> LLPO.\nProof.\n  rewrite \/LPO \/LLPO => LPO f EM.\n  move: (LPO f) => [H| [n H]]; first by left.\n  move: (orb_even_odd n) => \/orP [evenn| oddn].\n    right => m; move: (EM n m) => sel. case eqnm: (n == m); move\/eqP in eqnm *.\n    by rewrite -eqnm evenn. move: sel => \/(_ eqnm) [| \/\/]; by rewrite H.\n  left => m; move: (EM n m) => sel. case eqnm: (n == m); move\/eqP in eqnm *.\n    by move: oddn; rewrite -eqnm -negb_even => \/negbTE ->.\n    move: sel => \/(_ eqnm) [| \/\/]; by rewrite H.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32855,"user_id":null,"body":"Require Import Arith.\nRequire Import Preloaded.\nImport Nat.\n\nTheorem EM_impl_LPO : EM -> LPO.\nProof. \n  intros. hnf in *. \n  intros.\n  destruct (H (exists n : nat, f n = true)).\n  - now right.\n  - left. intros. destruct (f n) eqn:E; auto.\n    exfalso. apply H0. eauto.\nQed.   \n\nTheorem LPO_impl_LLPO : LPO -> LLPO.\nProof.\n  intros. hnf in *.\n  intros. specialize (H f).\n  destruct H as [ H | H ].\n  - left. now intros.\n  - destruct H as (n & H).\n    pose proof (orb_even_odd n).\n    destruct (even n) eqn:E.\n    + right. intros.\n      specialize (H0 n n0).\n      assert (n <> n0).\n      { intro. congruence. }\n      apply H0 in H3. \n      destruct H3; try congruence.\n    + simpl in H1.\n      left. intros.\n      specialize (H0 n n0).\n      assert (n <> n0).\n      { intro. congruence. }\n      apply H0 in H3. \n      destruct H3; try congruence.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32856,"user_id":null,"body":"Require Import Arith.\nRequire Import Preloaded.\nImport Nat.\n\nTheorem EM_impl_LPO : EM -> LPO.\nProof.\n  unfold LPO. intros EM f.\n  destruct (EM (exists n : nat, f n = true)); try exact (or_intror H).\n  left. intros n. remember (f n) as H0. destruct H0; try reflexivity.\n  assert (exists n : nat, f n = true) by (exists n; rewrite HeqH0; reflexivity).\n  destruct (H H0).\nQed.\n\nTheorem LPO_impl_LLPO : LPO -> LLPO.\nProof.\n  unfold LPO; unfold LLPO.\n  intros H f H0.\n  specialize (H f).\n  destruct H.\n  - left. intros n H1. exact (H n).\n  - destruct H as [n H].\n    specialize (fun m => H0 m n).\n    assert (forall m : nat, m <> n -> f m = false) by (intros m H1; destruct (H0 m H1); [auto | rewrite H in H2; discriminate H2]).\n    clear H0. rename H1 into H0.\n    assert (forall m : nat, even m = negb (even n) -> f m = false).\n    + intros m Hm.\n      assert (even n <> negb (even n)) as Hn by (destruct (even n); simpl; discriminate).\n      rewrite <- Hm in Hn.\n      apply not_eq_sym in Hn.\n      assert (m <> n) as Hneq.\n      * destruct (eq_dec m n) as [Hmn | Hmn]; try exact Hmn.\n        destruct (Hn (f_equal_nat bool even m n Hmn)).\n      * exact (H0 m Hneq).\n    + destruct (even n); simpl in H1; [right | left]; exact H1.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32857,"user_id":null,"body":"Require Import Arith.\nRequire Import Preloaded.\nImport Nat.\n\nTheorem EM_impl_LPO : EM -> LPO.\nProof.\n  unfold EM, LPO; intros H f.\n  destruct (H (exists n, f n = true)); auto.\n  left; intro n; destruct (f n) eqn:Hfn; auto.\n  exfalso; apply H0; exists n; auto.\nQed.\n\nTheorem LPO_impl_LLPO : LPO -> LLPO.\nProof.\n  unfold LPO, LLPO; intros LLPO f H0.\n  destruct (LLPO f) as [?|[n H1]]; auto.\n  destruct (even n) eqn:Hn.\n  - right; intros m Hm.\n    assert (Hneq: n <> m).\n    { intro HC; subst; congruence. }\n    destruct (H0 n m Hneq); auto; congruence.\n  - left; intros m Hm.\n    assert (Hneq: n <> m).\n    { intro HC; subst; congruence. }\n    destruct (H0 n m Hneq); auto; congruence.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32858,"user_id":null,"body":"Require Import Arith.\nRequire Import Preloaded.\nImport Nat.\n\nTheorem EM_impl_LPO : EM -> LPO.\nProof. \n  intros h f.\n  pose proof (hEM := h (exists n : nat, f n = true)).\n  destruct hEM as [h1 | h2].\n  - right. assumption.\n  - left. intros n. pose proof (hEM := h (f n = false)).\n    destruct hEM as [h3 | h4].\n      + assumption.\n      + exfalso. apply h2. exists n. induction (f n). reflexivity. contradiction.\nQed.\n    \nTheorem LPO_impl_LLPO : LPO -> LLPO.\nProof.\n  intros hLPO f hf.\n  destruct (hLPO f) as [hf2 | [n0 hn0]].\n  clear hLPO.\n  {\n    left. intros n hn. apply hf2.\n  }\n  {\n    destruct (Bool.bool_dec (even n0) true) as [he | he].\n    - right. intros n hn.\n      assert (h' : (f n = false) \\\/ (f n0 = false)).\n      + apply hf. intro hc. rewrite hc in hn. rewrite hn in he. discriminate.\n      + destruct h'. assumption. rewrite H in hn0. discriminate.\n    - left. intros n hn.\n      assert (h' : (f n = false) \\\/ (f n0 = false)).\n      + apply hf. intro hc. rewrite hc in hn. rewrite hn in he. contradiction.\n      + destruct h'. assumption. rewrite H in hn0. discriminate.\n  }\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32859,"user_id":null,"body":"Require Import Arith ssreflect.\nRequire Import Preloaded.\nImport Nat.\n\nTheorem EM_impl_LPO : EM -> LPO.\nProof.\n  move=> em f.\n  move: (em (exists n, f n = true)) => [|notexists]; first by right.\n  left => n.\n  rewrite -Bool.not_true_iff_false => fn.\n  by apply: notexists; exists n.\nQed.\n\nLemma contra (f : nat -> bool) (n m : nat) : f n <> f m -> n <> m.\nProof. by move=> neqfnm eqnm; apply: neqfnm; rewrite eqnm. Qed.\n\nTheorem LPO_impl_LLPO : LPO -> LLPO.\nProof.\n  move=> lpo f.\n  move: (lpo f) => [|[n fn] onlyone]; first by left.\n  move: (Sumbool.sumbool_of_bool (even n)) => [evenn|oddn].\n    right => m oddm.\n    have neqnm : n <> m by apply: (contra even); rewrite evenn oddm.\n    move: (onlyone _ _ neqnm) => [|\/\/].\n    by rewrite fn.\n  left => m evenm.\n  have neqnm : n <> m by apply: (contra even); rewrite oddn evenm.\n  move: (onlyone _ _ neqnm) => [|\/\/].\n  by rewrite fn.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5cc3d8c2312133001dea9b3d":[{"id":32860,"user_id":null,"body":"Require Import Preloaded.\nRequire Import ZArith Psatz Zpow_facts.\nImport Z.\nOpen Scope Z_scope.\n\n(* Preloaded:\n\nRequire Import ZArith.\nImport Z.\n\nFixpoint geom_sum (n : nat) (z : Z) : Z :=\n  match n with\n  | O => 1\n  | S n' => z ^ of_nat n + geom_sum n' z\n  end.\n\nOpen Scope Z_scope.\n\nDefinition geom_formula (n : nat) (z : Z) : Z :=\n  if z =? 1 then succ (of_nat n)\n  else (z ^ (succ (of_nat n)) - 1) \/ (z - 1).\n\n*)\n\nLemma helper n z : (pow_pos z (Pos.of_succ_nat n) - 1) mod (z - 1) = 0.\nProof.\n  induction n; simpl.\n  - rewrite Zpow_facts.Zpower_pos_1_r.\n    apply Z_mod_same_full.\n  - unfold pow_pos in *.\n    rewrite Pos.iter_succ.\n    remember (Pos.iter (mul z) 1 (Pos.of_succ_nat n)) as t.\n    replace (z * t - 1) with ((t - 1) + t * (z - 1)) by lia.\n    rewrite Z_mod_plus_full.\n    apply IHn.\nQed.\n    \n\nTheorem geom_eq n z : geom_sum n z = geom_formula n z.\nProof.\n  induction n.\n  - unfold geom_formula.\n    destruct (z =? 1) eqn:Hz.\n    + reflexivity.\n    + simpl.\n      replace (pow_pos z 1) with (z) by lia.\n      symmetry.\n      apply div_same.\n      apply eqb_neq in Hz.\n      lia.\n  - unfold geom_formula in *.\n    destruct (z =? 1) eqn:Hz.\n    + simpl. rewrite IHn.\n      apply eqb_eq in Hz.\n      replace z with 1 by lia.\n      rewrite Zpow_facts.Zpower_pos_1_l.\n      lia.\n    + simpl. rewrite IHn.\n      apply eqb_neq in Hz.\n      replace (z ^ succ (of_nat n)) with (pow_pos z (Pos.of_succ_nat n)) by lia.\n      assert (H: (pow_pos z (Pos.of_succ_nat n) * (z - 1))\n                 + (pow_pos z (Pos.of_succ_nat n)) =\n                   (pow_pos z (Pos.of_succ_nat n + 1))). {\n        replace (pow_pos z (Pos.of_succ_nat n + 1)) with (pow_pos z (Pos.succ (Pos.of_succ_nat n))) by lia.\n        unfold pow_pos.\n        rewrite Pos.iter_succ.\n        lia.\n      }\n\n      assert (Hmult: forall a b c, c <> 0 -> a * c = b * c -> a = b). {\n        intros a b c Hc Hm.\n        assert (Ht: (a * c) \/ c = (a * c) \/ c) by auto.\n        assert (Ht': a = (b * c) \/ c). {\n          rewrite <- Hm.\n          rewrite Z_div_mult_full; auto.\n        }\n        rewrite Ht'.\n        rewrite Z_div_mult_full; auto.\n      }\n\n      remember (Pos.of_succ_nat n) as pn.\n\n      rewrite (Hmult\n                 (pow_pos z pn + (pow_pos z pn - 1) \/ (z - 1))\n                 ((pow_pos z (pn + 1) - 1) \/ (z - 1))\n                 (z - 1)); try lia; auto.\n\n      replace ((pow_pos z pn + (pow_pos z pn - 1) \/ (z - 1)) * (z - 1)) with ((pow_pos z pn) * (z - 1) + (pow_pos z pn - 1) \/ (z - 1) * (z - 1)) by lia.\n\n      replace ((pow_pos z pn - 1) \/ (z - 1) * (z - 1)) with ((z - 1) * ((pow_pos z pn - 1) \/ (z - 1))) by lia.\n      rewrite <- (Z_div_exact_full_2 _ (z - 1)); try lia; auto.\n      replace ((pow_pos z (pn + 1) - 1) \/ (z - 1) * (z - 1)) with ((z - 1) * ((pow_pos z (pn + 1) - 1) \/ (z - 1))) by lia.\n      rewrite <- (Z_div_exact_full_2 _ (z - 1)); try lia; auto.\n      * rewrite Heqpn.\n        replace (Pos.of_succ_nat n + 1)%positive with (Pos.of_succ_nat (n + 1)) by lia.\n        apply helper.\n      * rewrite Heqpn.\n        apply helper.\nQed.\n\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32861,"user_id":null,"body":"Require Import Preloaded.\nRequire Import ZArith Lia.\nImport Z.\nOpen Scope Z_scope.\n\n(* Preloaded:\n\nRequire Import ZArith.\nImport Z.\n\nFixpoint geom_sum (n : nat) (z : Z) : Z :=\n  match n with\n  | O => 1\n  | S n' => z ^ of_nat n + geom_sum n' z\n  end.\n\nOpen Scope Z_scope.\n\nDefinition geom_formula (n : nat) (z : Z) : Z :=\n  if z =? 1 then succ (of_nat n)\n  else (z ^ (succ (of_nat n)) - 1) \/ (z - 1).\n\n*)\n\nTheorem geom_eq n z : geom_sum n z = geom_formula n z.\nProof.\n  destruct (z =? 1) eqn:h.\n  * pose proof (h1 := proj1 (eqb_eq _ _) h). rewrite h1 in *. clear h h1.\n    unfold geom_formula ; simpl.\n    induction n.\n    + reflexivity.\n    + unfold geom_sum. fold geom_sum. rewrite pow_1_l ; lia.\n  * unfold geom_formula. rewrite h. apply div_unique_exact.\n    pose proof (h1 := proj1 (eqb_neq _ _) h).\n    lia. induction n.\n    + rewrite pow_1_r. simpl. lia.\n    + unfold geom_sum. fold geom_sum. rewrite mul_add_distr_l ,\n      <- IHn. rewrite Nat2Z.inj_succ. ring_simplify. \n      rewrite pow_add_r. ring. lia. lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32862,"user_id":null,"body":"Require Import Preloaded.\nRequire Import ZArith.\nImport Z.\nOpen Scope Z_scope.\n\nLemma geom_formula1 n : geom_formula n 1 = succ (of_nat n).\nProof. easy. Qed.\n\nLemma geom_formula_not1 n z : z <> 1 -> geom_formula n z = (z ^ (succ (of_nat n)) - 1) \/ (z - 1).\nProof. intros H; apply eqb_neq in H; unfold geom_formula; now rewrite H. Qed.\n\nLemma div_inv : forall a b c, a = b -> a \/ c = b \/ c.\nProof. intros; now subst. Qed.\n\nTheorem geom_eq n z : geom_sum n z = geom_formula n z.\nProof.\n  induction n.\n  - simpl; destruct (Z.eq_dec z 1) as [eq|neq]; [subst|].\n    + now rewrite geom_formula1.\n    + rewrite geom_formula_not1; [|easy].\n      rewrite pow_succ_r; [|apply Zle_0_nat].\n      simpl; replace (z * 1) with z; [|ring].\n      rewrite div_same; [easy|].\n      contradict neq; now apply Zminus_eq in neq.\n  - unfold geom_sum; fold geom_sum; rewrite IHn.\n    destruct (Z.eq_dec z 1) as [eq|neq]; [subst|].\n    + repeat rewrite geom_formula1; rewrite pow_1_l; [|apply Zle_0_nat].\n      now rewrite add_1_l, Nat2Z.inj_succ.\n    + repeat (rewrite geom_formula_not1; [|easy]).\n      repeat (rewrite pow_succ_r; [|apply Zle_0_nat]).\n      rewrite Nat2Z.inj_succ; repeat (rewrite pow_succ_r; [|apply Zle_0_nat]).\n      rewrite <- div_add_l; [apply div_inv; ring|].\n      contradict neq; now apply Zminus_eq in neq.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32863,"user_id":null,"body":"Require Import Preloaded.\nRequire Import ZArith Lia ssreflect.\nImport Z.\nOpen Scope Z_scope.\n\nTheorem geom_eq n z : geom_sum n z = geom_formula n z.\nProof.\n  rewrite \/geom_formula.\n  case eqz : (z =? 1) => [\/\/|].\n    move: eqz => \/eqb_eq ->.\n    elim: n => [\/\/|n \/= ->].\n    by rewrite -[pow_pos 1 _]\/(1 ^ (of_nat (S n))) pow_1_l \/\/; lia.\n  have \/eqb_neq eqz1 := eqz.\n  elim: n => [\/=|n \/= ->].\n    rewrite -[pow_pos _ _]\/(_ ^ 1) pow_1_r.\n    by rewrite div_same; lia.\n  rewrite -Z_div_plus_full_l; first by lia.\n  congr (_ \/ _).\n  rewrite mul_sub_distr_l mul_1_r.\n  by rewrite mul_comm -[pow_pos _ _]\/(z ^ of_nat (S n)) -pow_succ_r \/\/; lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32864,"user_id":null,"body":"Require Import Preloaded.\nRequire Import ZArith.\nRequire Import Lia.\nImport Z.\nOpen Scope Z_scope.\n\nTheorem geom_eq n z : geom_sum n z = geom_formula n z.\nProof.\n  generalize dependent z.\n  induction n; intros.\n  - simpl. unfold geom_formula. simpl.\n    destruct (z =? 1) eqn:E; try reflexivity.\n    rewrite pow_pos_fold. rewrite pow_1_r.\n    symmetry. apply div_same. intros Contra.\n    assert (z = 1) by lia. rewrite eqb_neq in E.\n    intuition.\n  - simpl. rewrite IHn. unfold geom_formula.\n    destruct (z =? 1) eqn:E.\n    + simpl. \n      apply eqb_eq in E. subst.\n      rewrite pow_pos_fold.\n      rewrite pow_1_l; lia.\n    + rewrite pow_pos_fold.\n      rewrite Zpos_P_of_succ_nat.\n      repeat rewrite <- Nat2Z.inj_succ.\n      rewrite <- div_add_l; try (apply eqb_neq in E; lia).\n      assert (\n        (z ^ of_nat (S n) * (z - 1) + (z ^ of_nat (S n) - 1)) = \n        (z ^ of_nat (S (S n)) - 1) ); \n        try (rewrite H; reflexivity).\n      rewrite add_sub_assoc.\n      replace\n          (z ^ of_nat (S n) * (z - 1) + z ^ of_nat (S n)) \n      with\n          (z ^ of_nat (S n) * z)\n      by ring.\n      repeat rewrite <- Zpower_nat_Z.\n      simpl. ring.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32865,"user_id":null,"body":"Require Import Preloaded.\nRequire Import ZArith Lia.\nImport Z.\nOpen Scope Z_scope.\n\n(* Preloaded:\n\nRequire Import ZArith.\nImport Z.\n\nFixpoint geom_sum (n : nat) (z : Z) : Z :=\n  match n with\n  | O => 1\n  | S n' => z ^ of_nat n + geom_sum n' z\n  end.\n\nOpen Scope Z_scope.\n\nDefinition geom_formula (n : nat) (z : Z) : Z :=\n  if z =? 1 then succ (of_nat n)\n  else (z ^ (succ (of_nat n)) - 1) \/ (z - 1).\n\n*)\n\nTheorem geom_eq n z : geom_sum n z = geom_formula n z.\nProof. \n  induction n.\n  cbn.\n  unfold geom_formula; cbn.\n  pose proof Z_noteq_dec z 1.\n  inversion H.\n  rewrite <-Z.eqb_neq in H0; rewrite H0; rewrite mul_1_r; rewrite div_same; \n    [reflexivity | rewrite Z.eqb_neq in H0; lia].\n  rewrite <-Z.eqb_eq in H0; rewrite H0; reflexivity.\n  cbn [geom_sum].\n  rewrite IHn.\n  unfold geom_formula.\n  destruct (z =? 1) eqn:q.\n  rewrite Z.eqb_eq in q; rewrite q.\n  rewrite pow_1_l by lia.\n  lia.\n  rewrite Nat2Z.inj_succ.\n  unfold succ.\n  repeat rewrite ->Zpower_exp by lia.\n  cbn.\n  repeat rewrite mul_1_r.\n  rewrite <-div_add_l by (rewrite Z.eqb_neq in q; lia).\n  rewrite Zmult_minus_distr_l.\n  rewrite mul_1_r.\n  rewrite add_sub_assoc.\n  rewrite sub_simpl_r.\n  reflexivity.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32866,"user_id":null,"body":"Require Import Preloaded.\nRequire Import ZArith Zpow_facts.\nImport Z.\nOpen Scope Z_scope.\n\n(* Preloaded:\n\nRequire Import ZArith.\nImport Z.\n\nFixpoint geom_sum (n : nat) (z : Z) : Z :=\n  match n with\n  | O => 1\n  | S n' => z ^ of_nat n + geom_sum n' z\n  end.\n\nOpen Scope Z_scope.\n\nDefinition geom_formula (n : nat) (z : Z) : Z :=\n  if z =? 1 then succ (of_nat n)\n  else (z ^ (succ (of_nat n)) - 1) \/ (z - 1).\n\n*)\n\nTheorem geom_eq n z : geom_sum n z = geom_formula n z.\nProof.\n  generalize z ; clear z.\n  induction n.\n  - intro.\n    unfold geom_formula.\n    case_eq (z =? 1).\n    + intros.\n      simpl.\n      reflexivity.\n    + intros.\n      simpl.\n      rewrite Zpower_pos_1_r.\n      rewrite div_same.\n      reflexivity.\n      intro.\n      apply Zminus_eq in H0.\n      apply eqb_eq in H0.\n      rewrite H in H0.\n      discriminate.\n  - intro.\n    unfold geom_sum.\n    fold geom_sum.\n    rewrite IHn.\n    unfold geom_formula.\n    case_eq (z =? 1).\n    + rewrite eqb_eq.\n      intros.\n      rewrite H.\n      rewrite Zpower_1_l.\n      rewrite Nat2Z.inj_succ.\n      rewrite add_1_l.\n      reflexivity.\n      apply Nat2Z.is_nonneg.\n    + intros.\n      rewrite Nat2Z.inj_succ.\n      repeat rewrite Zpower_succ_r.\n      rewrite <- div_add_l.\n      f_equal.\n      rewrite mul_sub_distr_l.\n      repeat rewrite mul_assoc.\n      rewrite add_sub_assoc.\n      f_equal.\n      rewrite mul_1_r.\n      rewrite sub_add.\n      rewrite mul_comm.\n      apply mul_assoc.\n      intro.\n      apply Zminus_eq in H0.\n      apply eqb_eq in H0.\n      rewrite H in H0.\n      discriminate.\n      apply Nat2Z.is_nonneg.\n      rewrite <- Nat2Z.inj_succ.\n      apply Nat2Z.is_nonneg.\n      apply Nat2Z.is_nonneg.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32867,"user_id":null,"body":"Require Import Preloaded.\nRequire Import ZArith.\nImport Z.\nOpen Scope Z_scope.\nRequire Import Coq.micromega.Lia.\n\nLtac crush :=\n  let\n    rewriter := (\n      autorewrite with zarith in *;\n      repeat (match goal with\n              | [ H : _ |- _ ] => rewrite H by crush\n              end; autorewrite with zarith in * ))\n  in\n  simpl in *; intuition; rewriter; try lia; simpl in *; intuition; try lia.\n\nHint Rewrite Pos2Z.inj_add Zle_0_pos Zpos_P_of_succ_nat mul_add_distr_r pow_pos_fold : zarith.\nHint Rewrite div_mul pow_1_l pow_1_r pow_add_r pow_succ_r using lia : zarith.\n\nLemma geom_sum_z1 : forall n, geom_sum n 1 = succ (of_nat n).\nProof using.\n  induction n; crush.\nQed.\n\nLemma geom_sum_Sn : forall n z, geom_sum (S n) z = z ^ succ (of_nat n) + geom_sum n z.\nProof using.\n  crush.\nQed.\n\nHint Rewrite geom_sum_Sn geom_sum_z1 : zarith.\n\nLemma geom_sum_mul : forall n z, z ^ succ (of_nat n) - 1 = geom_sum n z * (z - 1).\nProof using.\n  intros; induction n; crush;\n    match goal with\n      [ |- context[match ?Z - 1 with | _ => _ end] ] => destruct (Z - 1); crush\n    end.\nQed.                    \n\nTheorem geom_eq n z : geom_sum n z = geom_formula n z.\nProof using.\n  unfold geom_formula.\n  destruct eqb_spec with z 1; [|rewrite geom_sum_mul]; crush.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32868,"user_id":null,"body":"Require Import Preloaded.\nRequire Import ZArith.\nImport Z.\nOpen Scope Z_scope.\n\nLemma z_minus_1_div : forall n z,\n  (z ^ of_nat (S n) - 1) mod (z - 1) = 0.\nProof.\n  induction n; intros.\n  - simpl of_nat. rewrite pow_1_r. apply Z_mod_same_full.\n  - replace (z ^ of_nat (S (S n)) - 1)\n      with ((z ^ of_nat (S n) - 1) + (z ^ of_nat (S (S n)) - z ^ of_nat (S n))).\n    + rewrite Zplus_mod.\n      rewrite IHn.\n      change (S (S n))%nat with (1 + S n)%nat.\n      rewrite Nat2Z.inj_add.\n      rewrite pow_add_r; try apply Zle_0_nat.\n      simpl of_nat at 1. rewrite pow_1_r.\n      rewrite <- (mul_1_l (z ^ of_nat (S n))) at 2.\n      rewrite <- mul_sub_distr_r.\n      rewrite Z.mul_comm.\n      rewrite Z_mod_mult.\n      apply Zmod_0_l.\n    + rewrite Z.add_comm.\n      rewrite add_sub_assoc.\n      rewrite sub_add. reflexivity.\nQed.\n\nLemma geom_eq_aux : forall n z,\n  geom_formula (S n) z = geom_formula n z + z ^ of_nat (S n).\nProof.\n  intros.\n  unfold geom_formula. destruct (Z.eqb_spec z 1).\n  - subst. rewrite pow_1_l; try apply Zle_0_nat.\n    rewrite <- 2!Nat2Z.inj_succ.\n    change 1 with (of_nat 1).\n    rewrite <- Nat2Z.inj_add. rewrite Nat.add_comm. reflexivity.\n  - assert (z - 1 <> 0) as Ha.\n    { intros contra. apply n0.\n      apply (Zplus_eq_compat _ _ 1 1) in contra; try reflexivity.\n      rewrite sub_add in contra. assumption.\n    }\n    apply (mul_reg_r _ _ (z - 1)); try assumption.\n    rewrite Z.mul_comm.\n    rewrite <- Z_div_exact_full_2; try assumption.\n    rewrite Z.mul_add_distr_r.\n    rewrite Z.mul_comm.\n    rewrite <- Z_div_exact_full_2; try assumption.\n    rewrite Z.mul_sub_distr_l. rewrite Z.mul_1_r.\n    rewrite Z.add_comm. rewrite add_sub_assoc.\n    rewrite <- 2!Nat2Z.inj_succ. rewrite sub_add.\n    rewrite <- (pow_1_r z) at 3.\n    change 1 with (of_nat 1) at 2.\n    rewrite <- pow_add_r; try apply Zle_0_nat.\n    rewrite <- Nat2Z.inj_add.\n    rewrite Nat.add_comm. reflexivity.\n    rewrite <- Nat2Z.inj_succ.\n    apply z_minus_1_div.\n    rewrite <- Nat2Z.inj_succ.\n    apply z_minus_1_div.\nQed.\n\nTheorem geom_eq n z : geom_sum n z = geom_formula n z.\nProof.\n  induction n.\n  - unfold geom_formula. destruct (Z.eqb_spec z 1).\n    + reflexivity.\n    + simpl. rewrite pow_pos_fold. rewrite pow_1_r.\n      rewrite Z_div_same_full. reflexivity.\n      intros contra. apply n.\n      apply (Zplus_eq_compat _ _ 1 1) in contra; try reflexivity.\n      rewrite sub_add in contra. assumption.\n  - rewrite geom_eq_aux. cbn [geom_sum].\n    rewrite Z.add_comm. f_equal. assumption.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32869,"user_id":null,"body":"Require Import Preloaded.\nRequire Import ZArith.\nImport Z.\nOpen Scope Z_scope.\n\n(* Preloaded:\n\nRequire Import ZArith.\nImport Z.\n\nFixpoint geom_sum (n : nat) (z : Z) : Z :=\n  match n with\n  | O => 1\n  | S n' => z ^ of_nat n + geom_sum n' z\n  end.\n\nOpen Scope Z_scope.\n\nDefinition geom_formula (n : nat) (z : Z) : Z :=\n  if z =? 1 then succ (of_nat n)\n  else (z ^ (succ (of_nat n)) - 1) \/ (z - 1).\n\n*)\n\nTheorem geom_eq n z : geom_sum n z = geom_formula n z.\nProof. \ninduction n.\n- simpl; unfold geom_formula; destruct (eq_dec z 1).\n-- rewrite e; simpl; reflexivity.\n-- simpl; unfold pow_pos; simpl; rewrite mul_1_r; rewrite Z_div_same_full.\n--- destruct (z=?1); reflexivity.\n--- rewrite <- succ_inj_wd_neg; omega.\n- simpl; rewrite IHn; unfold geom_formula; rewrite pow_pos_fold; destruct (eq_dec z 1).\n-- rewrite e; simpl; rewrite pow_pos_fold; rewrite pow_1_l.\n---rewrite Pos2Z.inj_add; rewrite Zpos_P_of_succ_nat; omega.\n---rewrite Zpos_P_of_succ_nat; rewrite <- Nat2Z.inj_succ; rewrite <- Zle_0_nat; omega.\n-- apply eqb_neq in n0; rewrite n0; apply eqb_neq in n0.\n   rewrite add_comm.\n   rewrite <- div_add.\n   rewrite mul_sub_distr_l.\n   rewrite mul_1_r.\n   rewrite Zpos_P_of_succ_nat.\n   rewrite <- pow_1_r with (a:=z) at 3.\n   rewrite <- pow_add_r.\n   rewrite add_succ_l.\n   rewrite <- add_sub_swap.\n   rewrite add_1_r.\n   rewrite <- Nat2Z.inj_succ.\n   rewrite add_sub_assoc.\n   rewrite add_simpl_l.\n   reflexivity.\n   rewrite <- Nat2Z.inj_succ.\n   rewrite <- Nat2Z.inj_0.\n   apply inj_le.\n   omega.\n   omega.\n   omega.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5cc47f8c4b8fea001de6d226":[{"id":32870,"user_id":489,"body":"Require Import Preloaded.\n\nLemma zero_3' : multiple_of_3' 0.\nProof. apply (difference_multiple 0 21 21); auto; constructor. Qed.\n\nLemma three_3' : multiple_of_3' 3.\nProof. assert (multiple_of_3' 9).\n  { apply (difference_multiple 9 21 30); auto; constructor. }\n  assert (multiple_of_3' 12).\n  { apply (difference_multiple 12 9 21); auto; constructor. }\n  apply (difference_multiple 3 9 12); auto; constructor. Qed.\n\nLemma np3_3' : forall n, multiple_of_3' n -> multiple_of_3' (S (S (S n))).\nProof. intros. apply (sum_multiple 3 n); auto. apply three_3'. Qed.\n\nLemma thirty_3 : multiple_of_3 30.\nProof. repeat constructor. Qed.\n\nLemma twentyone_3 : multiple_of_3 21.\nProof. repeat constructor. Qed.\n\nLemma sum_3 : forall n m, multiple_of_3 n -> multiple_of_3 m -> multiple_of_3 (n + m).\nProof. intros n m Hn; induction Hn; auto.\n  intros Hm. simpl. constructor. tauto. Qed.\n\nLemma diff_3 : forall l n m,\n  multiple_of_3 n -> multiple_of_3 m -> l + n = m -> multiple_of_3 l.\nProof. intros l n m Hn. generalize dependent m. induction Hn.\n  - intros. rewrite <- plus_n_O in H0. rewrite H0. auto.\n  - intros. repeat rewrite <- plus_n_Sm in H0.\n    destruct m as [| [| [| m]]]; inversion H0.\n    inversion H. apply (IHHn m); auto. Qed.\n\nTheorem multiple_of_3_iff_multiple_of_3' :\n  forall n, multiple_of_3 n <-> multiple_of_3' n.\nProof. split.\n  - intros Hn; induction Hn; auto using zero_3', np3_3'.\n  - intros Hn; induction Hn; eauto using thirty_3, twentyone_3, sum_3, diff_3. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32871,"user_id":null,"body":"Require Import Preloaded.\n(*\nInductive multiple_of_3 : nat -> Prop :=\n  | O_multiple \n      : multiple_of_3 O\n  | SSS_multiple n (H : multiple_of_3 n) \n      : multiple_of_3 (S (S (S n))).\n\nInductive multiple_of_3' : nat -> Prop :=\n  | thirty_multiple \n      : multiple_of_3' 30\n  | twenty_one_multiple \n      : multiple_of_3' 21\n  | sum_multiple n m (H : multiple_of_3' n) (H' : multiple_of_3' m) \n      : multiple_of_3' (n + m)\n  | difference_multiple l n m \n    (H : multiple_of_3' n) \n    (H' : multiple_of_3' m) \n    (H'' : l + n = m) \n      : multiple_of_3' l.\n*)\n\nHint Constructors multiple_of_3 : core.\nHint Constructors multiple_of_3' : core.\n\nRequire Import Omega.\nTheorem multiple_of_3_iff_multiple_of_3' :\n  forall n, multiple_of_3 n <-> multiple_of_3' n.\nProof with auto.\n  split; intros.\n  - induction H.\n    + apply (difference_multiple 0 30 30)...\n    + assert (multiple_of_3' 9) by (eauto 2).\n      assert (multiple_of_3' 3) by (eauto 3).\n      apply (sum_multiple 3 n)...\n  - induction H; try solve [repeat constructor].\n    + clear H H0.\n      induction IHmultiple_of_3'1; simpl; intros...\n    + clear H H0.\n      rename H'' into Heql. \n      rename IHmultiple_of_3'1 into IHn.\n      rename IHmultiple_of_3'2 into IHm.\n      generalize dependent m; generalize dependent l. \n      induction IHn as [| n' Hn' IHn']; intros.\n      * replace l with m by omega...\n      * specialize (IHn' (3 + l) m); simpl in *.\n        assert (3 + l + n' = m) by omega.\n        assert (multiple_of_3 (3 + l))...\n        inversion H0...\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32872,"user_id":168,"body":"Require Import Preloaded.\nRequire Import Arith ssreflect Lia.\n\nLemma ind3 (P : nat -> Prop) : P 0 -> P 1 -> P 2 ->\n                               (forall n, P n -> P (S (S (S n)))) ->\n                               forall n, P n.\nProof.\n  move => p0 p1 p2 pn n.\n  apply: lt_wf_ind; case => \/\/; case => \/\/; case => \/\/ {n} n \/(_ n).\n  have lt: n < S (S (S n)) by lia.\n  by move\/(_ lt)\/pn.\nQed.\n  \nLemma multiple_of_3_spec n : multiple_of_3 n <-> exists k, n = 3 * k.\nProof.\n  split.\n  + elim; first by exists 0.\n    by move => {n} n _ [k ->]; exists (S k) => \/=; ring.\n  + elim\/ind3: n => [_|[k]|[k]|n ih [k] eq]; try lia; first exact: O_multiple.\n    by apply: SSS_multiple; apply: ih; exists (k - 1); lia.\nQed.\n\nTheorem multiple_of_3_iff_multiple_of_3' :\n  forall n, multiple_of_3 n <-> multiple_of_3' n.\nProof.\n  move => n; split; elim => {n}.\n  + by apply: (difference_multiple 0 30 30) => \/\/; apply: thirty_multiple.\n  + move => n _ hn; apply: (sum_multiple 3 n) => \/\/.\n    have m9 : multiple_of_3' 9 by apply: (difference_multiple 9 21 30) => \/\/;\n      [apply: twenty_one_multiple | apply: thirty_multiple].\n    apply: (difference_multiple 3 9 12) => \/\/.\n    apply: (difference_multiple 12 9 21) => \/\/.\n    exact: twenty_one_multiple.\n  + by rewrite multiple_of_3_spec; exists 10.\n  + by rewrite multiple_of_3_spec; exists 7.\n  + move => n m _; rewrite !multiple_of_3_spec.\n    by move => [k ->] _ [t ->]; exists (k + t); lia.\n  + move => l n m _; rewrite !multiple_of_3_spec.\n    by move => [k ->] _ [t ->] eq; exists (t - k); lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32873,"user_id":null,"body":"Require Import Preloaded Arith.\n\nTheorem multiple_of_3_iff_multiple_of_3' :\n  forall n, multiple_of_3 n <-> multiple_of_3' n.\nProof.\n  split.\n  - intros H; induction H.\n    + apply difference_multiple with 30 30; [apply thirty_multiple|apply thirty_multiple|easy].\n    + apply (sum_multiple 3); [|easy].\n      assert (multiple_of_3' 9) as H9.\n      { apply difference_multiple with 21 30; [apply twenty_one_multiple|apply thirty_multiple|easy]. }\n      apply difference_multiple with 9 12; [easy| |easy].\n      apply difference_multiple with 9 21; [|apply twenty_one_multiple|]; easy.\n  - intros H; induction H.\n    + do 10 apply SSS_multiple; apply O_multiple.\n    + do 7 apply SSS_multiple; apply O_multiple.\n    + rename IHmultiple_of_3'1 into IHn, IHmultiple_of_3'2 into IHm; clear H H0.\n      induction IHn; [|apply SSS_multiple]; easy.\n    + rename IHmultiple_of_3'1 into IHn, IHmultiple_of_3'2 into IHm; clear H H0; subst.\n      revert IHm; replace (l + n) with (n + l); [|ring]; revert l; induction IHn; intros l Hl; [easy|].\n      apply IHIHn; now inversion Hl.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32874,"user_id":null,"body":"Require Import Preloaded.\n\nRequire Import Lia.\nHint Resolve thirty_multiple twenty_one_multiple: core.\n\nLemma multiple_of_3_iff_triple :\n  forall m, multiple_of_3 m <-> exists n, m = 3 * n.\nProof.\n  intros m. split.\n  - intros.\n    induction H as [| m H IHH].\n    + exists 0. auto.\n    + destruct IHH as [x IHH]. exists (x + 1). lia.\n  - intros [x H].\n    rewrite H.\n    clear H.\n    induction x.\n    + simpl. constructor.\n    + replace (3 * S x) with (S (S (S (3 * x)))) by lia. constructor. auto.\nQed.\n\nLemma multiple_of_3'_iff_triple :\n  forall m, multiple_of_3' m <-> exists n, m = 3 * n.\nProof.\n  intros m. split.\n  - intros.\n    induction H as [| | n m Hn IHn Hm IHm | l n m Hn IHn Hm IHm Hnm].\n    + exists 10. lia.\n    + exists 7. lia.\n    + destruct IHn as [x IHx]. destruct IHm as [y IHy].\n      exists (x + y). lia.\n    + destruct IHn as [x IHx]. destruct IHm as [y IHy].\n      assert (n <= m) by lia.\n      assert (x <= y) by lia.\n      exists (y - x).\n      replace (3 * (y - x)) with (3 * y - 3 * x) by lia.\n      rewrite <- IHx. rewrite <- IHy.\n      lia.\n  - intros. destruct H. rewrite H. clear H.\n    assert (multiple_of_3' 60) by (apply (sum_multiple 30 30); auto).\n    assert (multiple_of_3' 42) by (apply (sum_multiple 21 21); auto).\n    assert (multiple_of_3' 63) by (apply (sum_multiple 42 21); auto).\n    assert (multiple_of_3' 3) by (apply (difference_multiple 3 60 63); auto).\n    induction x as [| []].\n    + simpl. apply (difference_multiple 0 21 21); auto.\n    + auto.\n    + replace (3 * S (S n)) with (3 + (3 * (S n))) by lia.\n      apply sum_multiple; auto.\nQed.\n\nTheorem multiple_of_3_iff_multiple_of_3' :\n  forall m, multiple_of_3 m <-> multiple_of_3' m.\nProof.\n  intros m.\n  exact (iff_stepl (iff_sym (multiple_of_3'_iff_triple m)) (iff_sym (multiple_of_3_iff_triple m))).\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32875,"user_id":null,"body":"Require Import Preloaded.\nFrom Coq Require Import Arith ssreflect.\n\nHint Resolve O_multiple thirty_multiple twenty_one_multiple : core.\n\nTheorem multiple_of_3_iff_multiple_of_3' :\n  forall n, multiple_of_3 n <-> multiple_of_3' n.\nProof.\n  move=> n; split.\n    elim=> [|m _ mul3'm].\n      by apply: (difference_multiple _ 30 30).\n    rewrite -3!Nat.add_1_r -2!plus_assoc \/=.\n    apply: sum_multiple => \/\/.\n    apply: (difference_multiple _ 18 21) => \/\/.\n    apply: (difference_multiple _ 12 30) => \/\/.\n    apply: (difference_multiple _ 9 21) => \/\/.\n    by apply: (difference_multiple _ 21 30).\n  elim.\n  - by do 10!apply: SSS_multiple.\n  - by do 7!apply: SSS_multiple.\n  - move=> m k _ + _ mul3k.\n    elim=> [\/\/|{}m mul3m IHm].\n    by rewrite 3!Nat.add_succ_l; apply: SSS_multiple; apply: IHm.\n  - move=> l m k _ mul3m _ mul3k.\n    elim: mul3k l m mul3m => [l m _ \/plus_is_O [->]\/\/|{}k mul3k IHk l m].\n    elim=> [|{}m mul3m _].\n      by rewrite plus_0_r => ->; apply: SSS_multiple.\n    by rewrite 3!Nat.add_succ_r => [[]]; apply: IHk.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32876,"user_id":null,"body":"Require Import Preloaded.\n\n\nHint Constructors multiple_of_3.\nHint Constructors multiple_of_3'.\n\nLtac t' := repeat (eapply sum_multiple; auto).\nLtac t'' := eapply difference_multiple; try eassumption; auto.\nLemma A' : multiple_of_3' (3 * 21).\nt'.\nQed.\nLemma B' : multiple_of_3' (2 * 30).\nt'.\nQed.\n\nLemma A : forall n m, multiple_of_3 n -> multiple_of_3 m -> multiple_of_3 (n + m).\nintros.\ninduction H. auto.\neapply SSS_multiple. auto. Qed.\n\nLemma C : forall n m, multiple_of_3 m -> n + 3 = m -> multiple_of_3 n.\ninduction 1. intros. Require Import Arith. Search (_ + _ = _ + _). rewrite Nat.add_comm in H. inversion H.\nintros. rewrite Nat.add_comm in H0. simpl in H0. inversion H0. subst. auto. Qed.\n\n\nLemma B : forall n, multiple_of_3 n -> (forall m l, multiple_of_3 m -> l + n = m -> multiple_of_3 l).\ninduction 1.\nintros. Require Import Arith. Search (_ + 0 = _). rewrite Nat.add_0_r in H0. subst. auto.\nintros. \nrewrite Nat.add_comm in H1. rewrite <- H1 in H0. simpl in H0. clear H1.\nrewrite Nat.add_comm in H0. assert (multiple_of_3 (l + n)). eapply C; eauto. Require Import Lia. lia.\neapply IHmultiple_of_3. clear H0. clear H. eauto. auto. Qed.\n\nTheorem multiple_of_3_iff_multiple_of_3' :\n  forall n, multiple_of_3 n <-> multiple_of_3' n.\nProof.\n  split.\n  \n\n  induction 1.\n    assert (E : multiple_of_3' (30 * 21)).\n      t'.\n    t''.\n   \n  simpl. \n    assert (E1 : multiple_of_3' 3).\n    eapply difference_multiple. apply B'. apply A'. auto.\n    replace (S (S (S n))) with (3 + n).\n    eapply sum_multiple; eassumption. auto.\n    \n  induction 1.\n\n    repeat (eapply SSS_multiple; try apply O_multiple).\n    repeat (eapply SSS_multiple; try apply O_multiple).\n    eapply A; eassumption.\n    eapply B. apply IHmultiple_of_3'1. apply IHmultiple_of_3'2. apply H''.\n    Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32877,"user_id":null,"body":"Require Import Preloaded Arith.\n\nTheorem multiple_of_3_iff_multiple_of_3' :\n  forall n, multiple_of_3 n <-> multiple_of_3' n.\nProof.\n  split; induction 1.\n  - apply (difference_multiple _ 30 30); constructor.\n  - apply (sum_multiple 3 n); [|easy].\n    apply (difference_multiple _ 60 63); [apply (sum_multiple 30 30)|apply (sum_multiple 21 42), (sum_multiple 21 21)|]; constructor.\n  - repeat constructor.\n  - repeat constructor.\n  - clear H H0; induction IHmultiple_of_3'1; [|constructor]; easy.\n  - rewrite <- H'' in IHmultiple_of_3'2; clear m H H0 H''; induction IHmultiple_of_3'1.\n    + now rewrite Nat.add_comm in IHmultiple_of_3'2.\n    + apply IHIHmultiple_of_3'1.\n      rewrite (Nat.add_comm) in IHmultiple_of_3'2; inversion IHmultiple_of_3'2.\n      now rewrite Nat.add_comm.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32878,"user_id":null,"body":"Require Import Preloaded.\n\nLemma zero_multiple_of_3' : multiple_of_3' 0.\nProof.\n  apply difference_multiple with 21 21;\n  try apply twenty_one_multiple.\n  reflexivity.\nQed.\n\nLemma three_multiple_of_3' : multiple_of_3' 3.\nProof.\n  apply difference_multiple with 147 150; try reflexivity.\n  * repeat (apply (sum_multiple 21); try apply twenty_one_multiple).\n  * repeat (apply (sum_multiple 30); try apply thirty_multiple).\nQed.\n\nLemma multiple_of_3_to_multiple_of_3' :\n  forall n, multiple_of_3 n -> multiple_of_3' n.\nProof.\n  intros.\n  induction H.\n  - apply zero_multiple_of_3'.\n  - apply (sum_multiple 3); try assumption.\n    apply three_multiple_of_3'.\nQed.\n\nLemma sum_multiple_3 : forall n m,\n  multiple_of_3 n -> multiple_of_3 m -> multiple_of_3 (n + m).\nProof.\n  intros.\n  induction H.\n  - assumption.\n  - simpl. apply SSS_multiple. \n    assumption.\nQed.\n\nLemma diff_multiple_3 : forall n m l,\n  multiple_of_3 n -> multiple_of_3 m -> l + n = m -> multiple_of_3 l.\nProof.\n  intros.\n  generalize dependent m. generalize dependent l.\n  induction H.\n  - intros. rewrite <- plus_n_O in H1. subst. assumption.\n  - intros. repeat rewrite <- plus_n_Sm in H1.\n    do 3 (destruct m; try discriminate).\n    inversion H1. inversion H0. eauto.\nQed.\n\nLemma multiple_of_3'_to_multiple_of_3 :\n  forall n, multiple_of_3' n -> multiple_of_3 n.\nProof.\n  intros.\n  induction H;\n   try (repeat apply SSS_multiple; apply O_multiple).\n  - apply sum_multiple_3; auto.\n  - apply diff_multiple_3 with n m; auto.\nQed.\n  \n\nTheorem multiple_of_3_iff_multiple_of_3' :\n  (forall n, multiple_of_3 n <-> multiple_of_3' n).\nProof.\n  intros. split.\n  + apply multiple_of_3_to_multiple_of_3'.\n  + apply multiple_of_3'_to_multiple_of_3.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32879,"user_id":null,"body":"Require Import Preloaded.\n\nRequire Import Arith.\n\nLemma multiple_of_3_sub :\n  forall n m p,\n    n - p = m -> \n    multiple_of_3 n ->\n    multiple_of_3 p ->\n    multiple_of_3 m.\nProof.\n  intros n m p E Hn Hp.\n  generalize dependent n. generalize dependent m.\n  induction Hp.\n  - intros. rewrite Nat.sub_0_r in E. now subst.\n  - intros. destruct Hn.\n    + simpl in E. subst. constructor.\n    + apply IHHp with (n0 := n0).\n      * simpl in E. apply E.\n      * apply Hn.\nQed.\n\nLemma multiple_of_3'_if_multiple_of_3 :\n  forall n, multiple_of_3 n -> multiple_of_3' n.\nProof.\n  intros n H. induction H.\n  + apply (difference_multiple 0 30 30); auto using thirty_multiple.\n  + replace (S (S (S n))) with (3 + n) by reflexivity.\n    apply sum_multiple; auto.\n    apply (difference_multiple 3 30 33); auto using thirty_multiple.\n    replace 33 with (21 + 12) by reflexivity.\n    apply sum_multiple; [ apply twenty_one_multiple |].\n    apply (difference_multiple 12 30 42); auto using thirty_multiple.\n    replace 42 with (21 + 21) by reflexivity.\n    apply sum_multiple; apply twenty_one_multiple.\nQed.\n\nLemma multiple_of_3_if_multiple_of_3':\n  forall n, multiple_of_3' n -> multiple_of_3 n.\nProof.\n  intros n H. induction H.\n  - repeat apply SSS_multiple. constructor.\n  - repeat apply SSS_multiple. constructor.\n  - induction IHmultiple_of_3'1; simpl; auto.\n    apply SSS_multiple.\n    apply IHIHmultiple_of_3'1, multiple_of_3'_if_multiple_of_3.\n    apply IHmultiple_of_3'1.\n  - apply Nat.add_sub_eq_r in H''.\n    apply multiple_of_3_sub in H''; auto.\nQed.\n\nTheorem multiple_of_3_iff_multiple_of_3' :\n  forall n, multiple_of_3 n <-> multiple_of_3' n.\nProof.\n  intros n. split.\n  - apply multiple_of_3'_if_multiple_of_3.\n  - apply multiple_of_3_if_multiple_of_3'.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5cca3e90701f0d000d5922bf":[{"id":32880,"user_id":null,"body":"From Coq Require Import Arith Lia.\n\nTheorem fact_times_fact_divides_fact_plus : forall x y, exists e, fact (x + y) = e * (fact x * fact y).\nProof.\n  induction x.\n  - exists 1.\n    simpl.\n    lia.\n  - induction y.\n    + exists 1.\n      simpl.\n      repeat rewrite <- plus_n_O.\n      lia.\n    + destruct IHx with (S y) as [e0 He0], IHy as [e1 He1].\n      exists (e0 + e1).\n      transitivity (S x * fact (x + S y) + S y * fact (S x + y)).\n      * repeat rewrite <- plus_n_Sm.\n        repeat rewrite plus_Sn_m.\n        simpl.\n        lia.\n      * rewrite He0, He1.\n        simpl.\n        lia.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32881,"user_id":null,"body":"From Coq Require Import Arith.\n\nFixpoint choose (gas n m : nat) : nat :=\n  match gas, n, m with\n  | 0, _, _ => 1\n  | _, 0, _ => 1\n  | _, _, 0 => 1\n  | S gas', S n', S m' => choose gas' n' m + choose gas' n m'\n  end.\n\nTheorem fact_times_fact_divides_fact_plus : forall x y, exists e, fact (x + y) = e * (fact x * fact y).\nProof.\n  intros x y; exists (choose (x + y) x y).\n  cut (forall gas, x + y <= gas -> fact (x + y) = choose gas x y * (fact x * fact y)); [intros H; apply H, le_n|].\n  intros n; revert x y; induction n; intros x y Hn.\n  - now destruct x, y.\n  - destruct x; [simpl; ring|].\n    destruct y; [rewrite Nat.add_0_r; simpl; ring|].\n    unfold choose; fold choose.\n    replace\n      ((choose n x (S y) + choose n (S x) y) * (fact (S x) * fact (S y))) with\n      ((choose n x (S y) * (fact x * fact (S y))) * S x + (choose n (S x) y * (fact (S x) * fact y)) * S y); [|simpl; ring].\n    rewrite <- IHn, <- IHn.\n    + replace (S x + y) with (x + S y); [|ring].\n      replace (fact (x + S y) * S x + fact (x + S y) * S y) with ((S x + S y) * fact (x + S y)); [easy|ring].\n    + replace (S x + y) with (x + S y); [apply le_S_n, Hn|ring].\n    + apply le_S_n, Hn.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32882,"user_id":null,"body":"From Coq Require Import Arith ssreflect.\n\nFixpoint conseq_prod (n k : nat) : nat :=\n  match k with\n  | O => 1\n  | S m => n * (conseq_prod (S n) m)\n  end.\n\nLemma conseq_prodE (n k : nat) :\n  conseq_prod n (S k) =  conseq_prod n k * (n + k).\nProof.\n  elim: k n => [n \/=|k IHk n].\n    by rewrite mult_1_r plus_0_r.\n  rewrite -[conseq_prod n (S (S k))]\/(n * conseq_prod (S n) (S k)).\n  by rewrite IHk mult_assoc -Nat.add_succ_comm.\nQed.\n\nLemma fact_divides_conseq_prod (n k : nat) :\n  exists q, conseq_prod n k = q * fact k.\nProof.\n  elim: k n => [n \/=|k IHk].\n    by exists 1.\n  elim=> [|n [qn IHn]].\n    by exists 0.\n  rewrite conseq_prodE Nat.add_succ_comm Nat.mul_add_distr_l.\n  rewrite mult_comm -[_ * _]\/(conseq_prod _ (S k)) IHn.\n  have [qk ->] := IHk (S n).\n  exists (qn + qk).\n  rewrite -mult_assoc [_ * S k]mult_comm -[S k * _]\/(fact (S k)).\n  by rewrite Nat.mul_add_distr_r.\nQed.\n\nLemma fact_plus_conseq_prod (n m : nat) :\n  fact (n + m) = fact n * conseq_prod (S n) m.\nProof.\n  elim: m n => [n|m IHm n].\n    by rewrite plus_0_r mult_1_r.\n  rewrite \/= Nat.mul_add_distr_l.\n  rewrite mult_assoc [_ * n]mult_comm -[n * _ * _]mult_assoc.\n  rewrite [in RHS]plus_comm -Nat.mul_succ_l.\n  rewrite mult_assoc -[S n * _]\/(fact (S n)).\n  by rewrite -IHm Nat.add_succ_comm.\nQed.\n\nTheorem fact_times_fact_divides_fact_plus (n m : nat) :\n  exists q, fact (n + m) = q * (fact n * fact m).\nProof.\n  rewrite fact_plus_conseq_prod.\n  have [q ->] := fact_divides_conseq_prod (S n) m.\n  exists q.\n  by rewrite 2!mult_assoc [_ * q]mult_comm.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32883,"user_id":null,"body":"From Coq Require Import Arith.\n\nLemma induction_schema : forall {P: nat -> nat -> Prop},\n  P 0 0 ->\n  (forall n, P n 0 -> P (S n) 0) ->\n  (forall m, P 0 m -> P 0 (S m)) ->\n  (forall n m, P n (S m) -> P (S n) m -> P (S n) (S m)) ->\n  (forall n m, P n m).\nProof.\n  intros P P00 PS0 P0S PSS; induction n.\n  - induction m.\n    + assumption.\n    + exact (P0S _ IHm).\n  - induction m.\n    + exact (PS0 _ (IHn _)).\n    + exact (PSS _ _ (IHn _) IHm).\nQed.\n\nTheorem fact_times_fact_divides_fact_plus : forall x y, exists e, fact (x + y) = e * (fact x * fact y).\nProof.\n  refine (induction_schema _ _ _ _).\n  - exists 1; reflexivity.\n  - intros; exists 1; simpl; rewrite Nat.mul_1_r, Nat.add_0_r, Nat.add_0_r; reflexivity.\n  - intros; exists 1; simpl; rewrite Nat.add_0_r, Nat.add_0_r; reflexivity.\n  - intros n m Hn Hm; destruct Hn as [n' Hn], Hm as [m' Hm]; exists (n' + m').\n    rewrite Nat.mul_add_distr_r.\n    assert (n' * (fact (S n) * fact (S m)) = S n * (n' * (fact n * fact (S m)))) as Hn'.\n      simpl; ring.\n    assert (m' * (fact (S n) * fact (S m)) = S m * (m' * (fact (S n) * fact m))) as Hm'.\n      simpl; ring.\n    rewrite Hn', Hm', <- Hn, <- Hm; clear.\n    repeat rewrite Nat.add_succ_r; simpl; ring.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32884,"user_id":null,"body":"From Coq Require Import Arith List Nat Omega.\nImport ListNotations.\n\n\nFixpoint range (x n : nat) : list nat :=\n  match n with\n  | 0 => nil\n  | S n' => x :: (range (S x) n')\n  end.\n\nFixpoint product (l : list nat) : nat :=\n  match l with\n  | nil => 1\n  | x :: xs => x * product xs\n  end.\n\nDefinition last (x n : nat) : nat := pred (x + n).\n\n\nLemma range_last: forall (n x : nat),\n  range x (S n) = range x n ++ [last x (S n)].\nProof.\n  intros n.\n  induction n; intros x.\n  - unfold last.\n    rewrite Nat.add_1_r.\n    rewrite <- pred_Sn.\n    auto.\n  - replace (range x (S (S n))) with (x :: (range (S x) (S n))) by auto.\n    rewrite IHn.\n    replace (range x (S n)) with (x :: (range (S x) n)) by auto.\n    unfold last.\n    simpl.\n    replace (x + S (S n)) with (S (x + (S n))) by auto.\n    rewrite <- pred_Sn.\n    auto.\nQed.\n\nLemma range_split: forall a b c : nat,\n  range a (b + c) = range a b ++ range (a + b) c.\nProof.\n  intros a b.\n  generalize dependent a.\n  induction b; intros.\n  - simpl.\n    auto.\n  - simpl.\n    assert (H: range (S a) (b + c) = range (S a) b ++ range (a + S b) c).\n    {\n      induction c.\n      - simpl.\n        rewrite app_nil_r.\n        auto.\n      - replace (b + S c) with (S (b + c)) by auto.\n      \n        rewrite range_last.\n        rewrite range_last.\n        rewrite IHc.\n        unfold last.\n        simpl.\n        replace (pred (a + S b + S c)) with (a + S (b + c)) by omega.\n        rewrite app_assoc.\n        auto.\n    }\n    rewrite H.\n    auto.\nQed.\n\nLemma product_lists: forall (a b : list nat),\n  product a * product b = product (a ++ b).\nProof.\n  intros a.\n  induction a; intros; simpl.\n  - auto.\n  - rewrite <- Nat.mul_assoc.\n    rewrite IHa.\n    auto.\nQed.\n\nTheorem fact_list: forall (n : nat),\n  product (range 1 n) = fact n.\nProof.\n  induction n.\n  - auto.\n  - rewrite range_last.\n    unfold last.\n    rewrite <- product_lists.\n    rewrite IHn.\n    simpl.\n    rewrite Nat.mul_1_r.\n    rewrite Nat.mul_succ_r.\n    rewrite Nat.add_comm.\n    rewrite Nat.mul_comm.\n    auto.\nQed.\n\nTheorem consec_divisible: forall (x n : nat),\n  product (range x n) mod fact n = 0.\nProof.\n  intros x n.\n  generalize dependent x.\n  induction n; intros. auto.\n  induction x.\n  - simpl.\n    rewrite Nat.mod_0_l.\n    auto.\n    intros contra.\n    apply plus_is_O in contra.\n    inversion contra.\n    apply fact_neq_0 in H.\n    auto.\n  - rewrite range_last.\n    unfold last.\n    rewrite <- product_lists.\n    replace (pred (S x + S n)) with (x + S n) by auto.\n    replace (product [x + S n]) with (x + S n).\n    rewrite Nat.mul_add_distr_l.\n\n    replace (product (range (S x) n) * x) with (product (range x (S n)))\n      by (rewrite Nat.mul_comm; auto).\n\n    specialize IHn with (S x).\n    apply Nat.mod_divides in IHn.\n    inversion IHn.\n    rewrite H.\n\n    apply Nat.mod_divides in IHx.\n    inversion IHx.\n    rewrite H0.\n\n    assert (H1: fact n * S n = fact (S n)).\n    {\n      simpl.\n      rewrite Nat.mul_succ_r.\n      rewrite Nat.add_comm.\n      rewrite Nat.mul_comm.\n      auto.\n    }\n\n    replace (fact n * x0 * S n) with (fact n * S n * x0)\n      by (apply Nat.mul_shuffle0).\n\n    rewrite H1.\n    rewrite <- Nat.mul_add_distr_l.\n    rewrite Nat.mul_comm.\n    apply Nat.mod_mul.\n    apply fact_neq_0.\n    apply fact_neq_0.\n    apply fact_neq_0.\n    simpl.\n    rewrite Nat.mul_1_r.\n    auto.\nQed.\n\nTheorem fact_times_fact_divides_fact_plus :\n  forall x y : nat, exists q : nat, fact (x + y) = q * (fact x * fact y).\nProof.\n  intros.\n  rewrite <- fact_list.\n\n  rewrite range_split.\n  rewrite <- product_lists.\n  rewrite fact_list.\n\n  specialize consec_divisible with (1 + x) y.\n  intros H.\n  apply Nat.mod_divides in H.\n  inversion H.\n  rewrite H0.\n  exists x0.\n\n  rewrite Nat.mul_assoc.\n  symmetry.\n  rewrite Nat.mul_comm.\n  auto.\n  apply fact_neq_0.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32885,"user_id":null,"body":"From Coq Require Import Arith Lia.\n\n(* Method 1 : Pascal's formula *)\n\nFixpoint pascal m n :=\n  if n <? m then 0 else\n  match n with\n  | 0 => 1\n  | S n =>\n    match m with\n    | 0 => 1\n    | S m => pascal m n + pascal (S m) n\n    end\n  end.\n\nLemma pascal_equation : forall n m,\n  pascal (S n) (S m) = pascal n m + pascal (S n) m.\nProof.\n  intros. simpl.\n  destruct (Nat.ltb_spec (S m) (S n)).\n  - destruct m.\n    + destruct n; cbn; lia.\n    + cbn -[Nat.ltb].\n      rewrite 2!(proj2 (Nat.ltb_lt _ _)) by lia.\n      reflexivity.\n  - reflexivity.\nQed.\n\nLemma pascal_0_l : forall n, pascal 0 n = 1.\nProof.\n  intros n. destruct n; reflexivity.\nQed.\n\nLemma pascal_1_l : forall n, pascal 1 n = n.\nProof.\n  intros. induction n.\n  - reflexivity.\n  - cbn. rewrite pascal_0_l. rewrite IHn. reflexivity.\nQed.\n\nLemma pascal_n_n : forall n, pascal n n = 1.\nProof.\n  induction n.\n  - reflexivity.\n  - rewrite pascal_equation. rewrite IHn.\n    destruct n; cbn -[Nat.ltb].\n    + reflexivity.\n    + rewrite (proj2 (Nat.ltb_lt _ _)) by lia. reflexivity.\nQed.\n\nLemma pascal_sym : forall n m, pascal n (n + m) = pascal m (n + m).\nProof.\n  intros. remember (n+m) as N. revert n m HeqN.\n  induction N; intros.\n  - assert (n = 0) by lia. subst. cbn in HeqN. subst. reflexivity.\n  - destruct n.\n    + cbn in HeqN. rewrite HeqN. rewrite pascal_0_l, pascal_n_n. reflexivity.\n    + destruct m.\n      * rewrite Nat.add_0_r in HeqN. rewrite HeqN.\n        rewrite pascal_0_l, pascal_n_n. reflexivity.\n      * rewrite 2!pascal_equation.\n        rewrite (IHN n (S m)) by lia.\n        rewrite (IHN (S n) m) by lia.\n        apply Nat.add_comm.\nQed.\n\nLemma pascal_Sm_Sn : forall n m, (S n) * pascal (S n) (S m) = (S m) * pascal n m.\nProof.\n  intros n m. revert n.\n  induction m; intros.\n  - destruct n; cbn; lia.\n  - destruct n.\n    + rewrite pascal_0_l, pascal_1_l. lia.\n    + rewrite pascal_equation.\n      rewrite Nat.mul_add_distr_l.\n      rewrite <- Nat.add_1_l at 1. rewrite Nat.mul_add_distr_r.\n      rewrite 2!IHm.\n      rewrite <- Nat.add_assoc.\n      rewrite <- Nat.mul_add_distr_l.\n      rewrite <- pascal_equation.\n      rewrite <- Nat.mul_add_distr_r.\n      reflexivity.\nQed.\n\nLemma pascal_fact_formula : forall m n,\n  fact (m + n) = pascal m (m + n) * fact m * fact n.\nProof.\n  induction m; intros.\n  - cbn. rewrite pascal_0_l. lia.\n  - cbn [fact].\n    rewrite Nat.mul_assoc. rewrite (Nat.mul_comm _ (S m)).\n    rewrite Nat.add_succ_l.\n    rewrite pascal_Sm_Sn.\n    cbn [fact].\n    rewrite IHm. lia.\nQed.\n\nTheorem fact_times_fact_divides_fact_plus :\n  forall x y : nat, exists q : nat, fact (x + y) = q * (fact x * fact y).\nProof.\n  intros.\n  exists (pascal x (x + y)). rewrite Nat.mul_assoc.\n  apply pascal_fact_formula.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32886,"user_id":null,"body":"From Coq Require Import Arith Lia.\n\n(* Method 2 : multiplication of consecutive numbers *)\n\n(* a * (a + 1) * ... * (a + n - 1) *)\nFixpoint mult_consecutive a n :=\n  match n with\n  | 0 => 1\n  | S n => a * mult_consecutive (S a) n\n  end.\n\nLemma fact_mult_consecutive : forall x y,\n  fact (x + y) = mult_consecutive (S y) x * fact y.\nProof.\n  induction x; intros.\n  - simpl. rewrite Nat.add_0_r. reflexivity.\n  - cbn [mult_consecutive].\n    rewrite <- Nat.mul_assoc. rewrite Nat.mul_comm.\n    rewrite <- Nat.mul_assoc. rewrite (Nat.mul_comm (fact y)).\n    rewrite Nat.add_succ_comm.\n    apply IHx.\nQed.\n\nLemma mult_consecutive_S_r : forall x y,\n  mult_consecutive y (S x) = (y + x) * mult_consecutive y x.\nProof.\n  induction x; intros.\n  - cbn. lia.\n  - cbn [mult_consecutive] in *. rewrite IHx. lia.\nQed.\n\nLemma mult_consecutive_S_S : forall x y,\n  mult_consecutive (S y) (S x)\n  = mult_consecutive y (S x) + (S x) * mult_consecutive (S y) x.\nProof.\n  intros.\n  rewrite mult_consecutive_S_r. cbn. lia.\nQed.\n\n(* proof inspired from\n   http:\/\/www.les-mathematiques.net\/phorum\/read.php?5,164630,1554588#msg-1554588\n   (in French)\n*)\nLemma mult_consecutive_divisible : forall x y,\n  Nat.divide (fact x) (mult_consecutive y x).\nProof.\n  induction x; intros.\n  - cbn. apply Nat.divide_refl.\n  - induction y.\n    + apply Nat.divide_0_r.\n    + rewrite mult_consecutive_S_S.\n      apply Nat.divide_add_r.\n      * assumption.\n      * cbn [fact].\n        apply Nat.mul_divide_mono_l. apply IHx.\nQed.\n\nTheorem fact_times_fact_divides_fact_plus :\n  forall x y : nat, exists q : nat, fact (x + y) = q * (fact x * fact y).\nProof.\n  intros.\n  fold (Nat.divide (fact x * fact y) (fact (x + y))).\n  rewrite fact_mult_consecutive.\n  apply Nat.mul_divide_mono_r.\n  apply mult_consecutive_divisible.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32887,"user_id":null,"body":"From Coq Require Import Arith.\nRequire Import Lia.\n\n(*\n   (choose k n) is the binomial coef (fact n) \/ (fact k * fact (n - k))\n\n   It can be defined recursively in nat using Pascal triangle:\n     choose (k+1) (n+1) = choose k n + choose (k+1) n\n *)\nFixpoint choose k n {struct n} : nat :=\n  match n, k with\n  | 0, 0 => 1\n  | 0, _ => 0\n  | S n, 0 => 1\n  | S n, S k => choose k n + choose (S k) n\n  end.\n\nLemma choose_big_k n : forall k, n < k -> choose k n = 0.\nProof.\n  induction n; intros [|k]; simpl.\n  - intro H; inversion H.\n  - intros _; reflexivity.\n  - intro H; inversion H.\n  - intro HS.\n    assert (n < k) as Hk by lia.\n    rewrite (IHn k Hk).\n    simpl.\n    apply IHn.\n    lia.\nQed.\n\nLemma choose_n_n n : choose n n = 1.\nProof.\n  induction n; simpl.\n  - reflexivity.\n  - rewrite IHn.\n    rewrite choose_big_k.\n    + reflexivity.\n    + lia.\nQed.\n\nLemma choose_fact n : forall k,\n  k <= n ->\n  choose k n * fact k * fact (n - k) = fact n.\nProof.\n  induction n; intros [|k]; simpl choose.\n  - intros _; reflexivity.\n  - intro H; inversion H.\n  - intros _.\n    simpl.\n    lia.\n  - intro H.\n    assert (k <= n) as Hk by lia; clear H.\n    case_eq (k =? n).\n    + intro Heq.\n      apply beq_nat_true in Heq.\n      subst k.\n      rewrite choose_n_n.\n      rewrite choose_big_k; [|lia].\n      rewrite Nat.sub_diag.\n      simpl.\n      lia.\n    + intro Hneq.\n      apply beq_nat_false in Hneq.\n      assert (S k <= n) as HSk by lia.\n      rewrite Nat.mul_add_distr_r.\n      rewrite Nat.mul_add_distr_r.\n      assert (choose k n * fact (S k) * fact (S n - S k) = fact n * S k) as H1.\n      * rewrite <- (IHn k Hk).\n        simpl.\n        lia.\n      * rewrite H1.\n        assert (choose (S k) n * fact (S k) * fact (S n - S k) = fact n * (n - k)) as H2.\n        -- rewrite <- (IHn (S k) HSk).\n           assert (S n - S k = S (n - S k)) as Hsub by (apply Nat.sub_succ_l; lia).\n           rewrite Hsub.\n           change (fact (S (n - S k))) with ((S (n - S k)) * fact (n - S k)).\n           rewrite <- Hsub.\n           simpl.\n           lia.\n        -- rewrite H2.\n           simpl.\n           lia.\nQed.\n\nTheorem fact_times_fact_divides_fact_plus : forall x y, exists e, fact (x + y) = e * (fact x * fact y).\nProof.\n  intros x y.\n  exists (choose x (x + y)).\n  rewrite <- (choose_fact (x + y) x); [|lia].\n  rewrite minus_plus.\n  lia.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32888,"user_id":null,"body":"From Coq Require Import Arith Omega Lia.\n\nTheorem fact_times_fact_divides_fact_plus : forall x y, exists e, fact (x + y) = e * (fact x * fact y).\nProof.\n  intros.\n  remember (x + y) as n.\n  rename x into r.\n  assert (r <= n) by omega.\n  assert (y = n - r) as Heq by omega; rewrite Heq.\n  clear Heq Heqn y.\n  generalize dependent r.\n  induction n; intros.\n  - inversion H; subst; exists 1; auto.\n  - destruct r.\n    + simpl; exists 1; omega.\n    + destruct (Nat.ltb_spec r n).\n      * assert (r <= n) by omega.\n        assert (S r <= n) by omega.\n        apply IHn in H1; destruct H1 as [e1 H1].\n        apply IHn in H2; destruct H2 as [e2 H2].\n        exists (e1 + e2).\n        replace (fact (S n)) with ((n + 1) * fact n) by (simpl; lia).\n        replace (fact (S r)) with ((r + 1) * fact r) by (simpl; lia).\n        simpl.\n        clear H. rename H0 into H.\n        replace ((n + 1) * fact n) with ((n - r) * fact n + (r + 1) * fact n) by lia.\n        destruct n; [lia|].\n        replace (S n - r) with (S (n - r)) in * by lia.\n        replace ((r + 1) * fact (S n)) with ((r + 1) * e1 * (fact r * fact (S (n - r)))) by lia.\n        rewrite H2.\n        simpl; lia.\n      * replace n with r by omega.\n        exists 1.\n        rewrite minus_diag.\n        simpl; omega.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32889,"user_id":null,"body":"From Coq Require Import Arith Lia.\n\nFixpoint pascals_triangle n k :=\nmatch n with\n| O => 1\n| S n' => \n  if Nat.eq_dec n k then 1 else\n  match k with\n  | O => 1\n  | S k' => pascals_triangle n' k' + \n            pascals_triangle n' k\n  end\nend.\n\nLemma pascals_triangle_correct: forall n k, k <= n -> fact (n - k) * fact k * (pascals_triangle n k) = fact n.\nProof.\n  intros.\n  generalize dependent k.\n  induction n; intros.\n    simpl. inversion H. subst. auto.\n  destruct k.\n    simpl. lia.\n  simpl.\n  destruct(Nat.eq_dec n k).\n    subst. replace(k - k) with 0; simpl; lia.\n  repeat rewrite Nat.mul_add_distr_l.\n  repeat rewrite Nat.mul_add_distr_r.\n  rewrite IHn; [ |lia].\n  replace(fact (n - k) * (k * fact k) * pascals_triangle n k) with\n      (k * (fact (n-k) * fact k * pascals_triangle n k)); [|lia].\n  rewrite IHn; [|lia].\n  replace (fact (n - k) * _ * _ + _) with\n    (fact (n - k) * (fact (S k)) * pascals_triangle n (S k)); [|simpl;lia].\n  replace(fact (n-k) * _ * _) with \n      ((1 + n - S k) * (fact (n -  S k) * fact (S k) * pascals_triangle n (S k))).\n    rewrite IHn; lia.\n  replace(1 + n - S k) with (n - k); [|lia].\n  simpl.\n  destruct n. inversion H; lia.\n  simpl(S n - S k).\n  repeat rewrite Nat.mul_assoc.\n  repeat f_equal.\n  replace(S n - k) with (S (n-k)). \n    simpl. lia. lia.\nQed.\n\nTheorem fact_times_fact_divides_fact_plus : forall x y, exists e, fact (x + y) = e * (fact x * fact y).\nProof.\n  intros x y.\n  exists (pascals_triangle (x+y) x).\n  replace(fact y) with (fact ((x+y)-x));[|f_equal;lia].\n  rewrite Nat.mul_comm.\n  rewrite Nat.mul_comm with (fact x) _.\n  rewrite pascals_triangle_correct; auto.\n  lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5cdae5caf00ea9000e98dc27":[{"id":32890,"user_id":568,"body":"Require Import Preloaded.\n\nDefinition seq_if_dist_r := forall b c1 c2 c3, cequiv\n  (TEST b THEN c1 ;; c3 ELSE c2 ;; c3 FI)\n  (TEST b THEN c1 ELSE c2 FI ;; c3).\n\nLtac invcs H := inversion H; clear H; subst.\n\nLtac autogo :=\n  match goal with\n  | [ H : _ =[ ?X ]=> _ |- _ ] =>\n    assert_fails (is_var X); invcs H\n  end.\n\nHint Constructors ceval.\n\nTheorem seq_if_dist_r_dec :\n  seq_if_dist_r \\\/ ~ seq_if_dist_r.\nProof.\n  left.\n  unfold seq_if_dist_r.\n  repeat intro.\n  split; intro; repeat autogo; eauto with *.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32891,"user_id":null,"body":"Require Import Preloaded.\n\nDefinition seq_if_dist_r := forall b c1 c2 c3, cequiv\n  (TEST b THEN c1 ;; c3 ELSE c2 ;; c3 FI)\n  (TEST b THEN c1 ELSE c2 FI ;; c3).\n\nTheorem seq_if_dist_r_dec :\n  seq_if_dist_r \\\/ ~ seq_if_dist_r.\nProof.\n  left; intros b c1 c2 c3 s s'.\n  split; intro H; inversion H; subst.\n  - inversion H6; subst; repeat econstructor; eauto.\n  - inversion H6; subst; econstructor; eauto; apply E_IfFalse; auto.\n  - inversion H2; subst.\n    + repeat econstructor; eauto.\n    + apply E_IfFalse; auto; econstructor; eauto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32892,"user_id":null,"body":"Require Import Preloaded.\n\nDefinition seq_if_dist_r := forall b c1 c2 c3, cequiv\n  (TEST b THEN c1 ;; c3 ELSE c2 ;; c3 FI)\n  (TEST b THEN c1 ELSE c2 FI ;; c3).\n\nTheorem seq_if_dist_r_dec :\n  seq_if_dist_r \\\/ ~ seq_if_dist_r.\n  Proof with try eassumption.\n  left.\n  intros b c1 c2 c3 st st'.\n  split.\n  - intros H.\n    inversion H; subst;\n    inversion H6; subst.\n    eapply E_Seq...\n    apply E_IfTrue...\n    eapply E_Seq...\n    apply E_IfFalse...\n  - intros H.\n    inversion H; subst.\n    inversion H2; subst.\n    apply E_IfTrue...\n    eapply E_Seq...\n    apply E_IfFalse...\n    eapply E_Seq...\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32893,"user_id":null,"body":"Require Import Preloaded.\n\nDefinition seq_if_dist_r := forall b c1 c2 c3, cequiv\n  (TEST b THEN c1 ;; c3 ELSE c2 ;; c3 FI)\n  (TEST b THEN c1 ELSE c2 FI ;; c3).\n\nTheorem seq_if_dist_r_dec :\n  seq_if_dist_r \\\/ ~ seq_if_dist_r.\nProof.\n  left.\n  intros b c1 c2 c3. split; intros.\n  - inversion H; subst.\n    + inversion H6; subst.\n      eapply E_Seq.\n      apply E_IfTrue.\n      auto. eauto. auto. \n    + inversion H6; subst.\n      eapply E_Seq.\n      apply E_IfFalse.\n      auto. eauto. auto.\n  - inversion H; subst.\n    inversion H2; subst.\n    + apply E_IfTrue. auto.\n      eapply E_Seq.\n      eauto. auto.\n    + apply E_IfFalse. auto.\n      eapply E_Seq.\n      eauto. auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32894,"user_id":null,"body":"Require Import Preloaded.\n\nDefinition seq_if_dist_r := forall b c1 c2 c3, cequiv\n  (TEST b THEN c1 ;; c3 ELSE c2 ;; c3 FI)\n  (TEST b THEN c1 ELSE c2 FI ;; c3).\n\nTheorem seq_if_dist_r_dec :\n  seq_if_dist_r \\\/ ~ seq_if_dist_r.\nProof with auto.\n  left.\n  intros b c1 c2 c3 st st'.\n  split; intros.\n  - inversion H.\n    + inversion H6. apply E_Seq with st'1...\n      apply E_IfTrue...\n    + inversion H6. apply E_Seq with st'1...\n      apply E_IfFalse...\n  - inversion H; subst.\n    inversion H2; subst.\n    apply E_IfTrue... apply E_Seq with st'0...\n    apply E_IfFalse... apply E_Seq with st'0...\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32895,"user_id":null,"body":"Require Import Preloaded.\n\nDefinition seq_if_dist_r := forall b c1 c2 c3, cequiv\n  (TEST b THEN c1 ;; c3 ELSE c2 ;; c3 FI)\n  (TEST b THEN c1 ELSE c2 FI ;; c3).\n\nTheorem seq_if_dist_r_dec :\n  seq_if_dist_r \\\/ ~ seq_if_dist_r.\nProof.\n  left.\n  intros b c1 c2 c3 St0 St1.\n  split; intro H.\n  - inversion H; subst; inversion H6; subst.\n    + eapply E_Seq; eauto.\n      eapply E_IfTrue; eauto.\n\n    + eapply E_Seq; eauto.\n      eapply E_IfFalse; eauto.\n  - inversion H; subst; inversion H2; subst.\n    + eapply E_IfTrue; eauto.\n      eapply E_Seq; eauto.\n\n    + eapply E_IfFalse; eauto.\n      eapply E_Seq; eauto. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32896,"user_id":null,"body":"Require Import Preloaded.\n\nDefinition seq_if_dist_r := forall b c1 c2 c3, cequiv\n  (TEST b THEN c1 ;; c3 ELSE c2 ;; c3 FI)\n  (TEST b THEN c1 ELSE c2 FI ;; c3).\n\nTheorem seq_if_dist_r_dec :\n  seq_if_dist_r \\\/ ~ seq_if_dist_r.\nProof.\n  left; split; intros.\n  - inversion H.\n    + inversion H6; apply (E_Seq _ _ _ st'1);\n      [apply E_IfTrue|]; assumption.\n    + inversion H6; apply (E_Seq _ _ _ st'1);\n      [apply E_IfFalse|]; assumption.\n  - inversion H; inversion H2.\n    + apply E_IfTrue; [|apply (E_Seq _ _ _ st'0)];\n      assumption.\n    + apply E_IfFalse; [|apply (E_Seq _ _ _ st'0)];\n      assumption.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32897,"user_id":null,"body":"Require Import Preloaded.\n\nDefinition seq_if_dist_r := forall b c1 c2 c3, cequiv\n  (TEST b THEN c1 ;; c3 ELSE c2 ;; c3 FI)\n  (TEST b THEN c1 ELSE c2 FI ;; c3).\n\nTheorem seq_if_dist_r_dec :\n  seq_if_dist_r \\\/ ~ seq_if_dist_r.\nProof.\n  left. unfold seq_if_dist_r. unfold cequiv.\n  intros b c1 c2 c3 st st'. split.\n  - (* inner -> outer *)\n    intros H. destruct (beval st b) eqn:B.\n    + (* b ~ true *)\n      inversion H; subst; inversion H6; subst; try congruence.\n      apply E_Seq with st'0; try apply E_IfTrue; assumption.\n    + (* b ~ false *)\n      inversion H; subst; inversion H6; subst; try congruence.\n      apply E_Seq with st'0; try apply E_IfFalse; assumption.\n  - (* outer -> inner *)\n    intros H. destruct (beval st b) eqn:B.\n    + (* b ~ true *)\n      inversion H; subst; inversion H2; subst; try congruence.\n      apply E_IfTrue; try apply E_Seq with st'0; assumption.\n    + (* b ~ false *)\n      inversion H; subst; inversion H2; subst; try congruence.\n      apply E_IfFalse; try apply E_Seq with st'0; assumption.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32898,"user_id":null,"body":"Require Import Preloaded.\n\nDefinition seq_if_dist_r := forall b c1 c2 c3, cequiv\n  (TEST b THEN c1 ;; c3 ELSE c2 ;; c3 FI)\n  (TEST b THEN c1 ELSE c2 FI ;; c3).\n\nTheorem seq_if_dist_r_dec :\n  seq_if_dist_r \\\/ ~ seq_if_dist_r.\nProof.\n  left; split; intros.\n  - remember (CIf b (c1;; c3) (c2;; c3)) as x in H; destruct H; try discriminate; injection Heqx; intros; clear Heqx.\n    + clear H1; destruct H0; try discriminate; injection H2; intros; clear H2.\n      rewrite <- H0, <- H3, <- H1; exact (E_Seq _ _ _ _ _ (E_IfTrue _ _ _ _ _ H H0_) H0_0).\n    + clear H2; destruct H0; try discriminate; injection H1; intros; clear H1.\n      rewrite <- H0, <- H3, <- H2; exact (E_Seq _ _ _ _ _ (E_IfFalse _ _ _ _ _ H H0_) H0_0).\n  - remember (CSeq (TEST b THEN c1 ELSE c2 FI) c3) as x in H; destruct H; try discriminate; injection Heqx; intros; clear Heqx.\n    destruct H; try discriminate; injection H2; intros; clear H2; rewrite <- H1, <- H4, <- H5, <- H6.\n    + exact (E_IfTrue _ _ _ _ _ H (E_Seq _ _ _ _ _ H3 H0)).\n    + exact (E_IfFalse _ _ _ _ _ H (E_Seq _ _ _ _ _ H3 H0)).\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32899,"user_id":null,"body":"Require Import Preloaded.\nFrom Coq Require Import ssreflect.\n\nDefinition seq_if_dist_r := forall b c1 c2 c3, cequiv\n  (TEST b THEN c1 ;; c3 ELSE c2 ;; c3 FI)\n  (TEST b THEN c1 ELSE c2 FI ;; c3).\n\nTheorem seq_if_dist_r_dec :\n  seq_if_dist_r \\\/ ~ seq_if_dist_r.\nProof.\n  left.\n  unfold seq_if_dist_r. unfold aeval. split; intros; inversion H; subst.\n  - inversion H6; subst.\n    apply: E_Seq => \/\/.\n    apply: E_IfTrue => \/\/. exact H2. assumption.\n  - inversion H6; subst.\n    apply: E_Seq => \/\/.\n    apply: E_IfFalse => \/\/. exact H2. assumption.\n  - inversion H2; subst.\n    + apply: E_IfTrue => \/\/.\n      apply: E_Seq.\n      exact H8. assumption.\n    + apply: E_IfFalse => \/\/.\n      apply: E_Seq.\n      exact H8. assumption.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5cdbe45dc50527001d55af5f":[{"id":32900,"user_id":null,"body":"Require Import Preloaded.\n\nDefinition seq_if_dist_l := forall b c1 c2 c3, cequiv\n  (TEST b THEN c1 ;; c2 ELSE c1 ;; c3 FI)\n  (c1 ;; TEST b THEN c2 ELSE c3 FI).\n\nLtac inv H := inversion H; subst; clear H.\nLtac Inv H := intros H; inv H.\n\nLemma not_iff : forall (P Q : Prop), P -> ~ Q -> ~ (P <-> Q).\nProof. intros P Q HP HQ PQ; contradict HQ; apply PQ, HP. Qed.\n\nTheorem seq_if_dist_l_dec :\n  seq_if_dist_l \\\/ ~ seq_if_dist_l.\nProof.\n  right; intros H; specialize (H (BEq X 1) (CAss X 1) (CAss Y 0) (CAss Y 1) (t_empty 0) (t_update (t_update (t_empty 0) X 1) Y 1)).\n  contradict H; apply not_iff.\n  - eapply E_IfFalse, E_Seq, E_Ass; auto.\n    apply E_Ass; auto.\n  - Inv H; inv H2; inv H5; inv H6; [clear H4|easy].\n    simpl in H3; assert ((Y !-> 0; X !-> 1; _ !-> 0) Y = (Y !-> 1; X !-> 1; _ !-> 0) Y) by now rewrite H3.\n    unfold t_update, eqb_string in H; now destruct string_dec.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32901,"user_id":null,"body":"Require Import Preloaded.\n\nDefinition seq_if_dist_l := forall b c1 c2 c3, cequiv\n  (TEST b THEN c1 ;; c2 ELSE c1 ;; c3 FI)\n  (c1 ;; TEST b THEN c2 ELSE c3 FI).\n\nTheorem seq_if_dist_l_dec :\n  seq_if_dist_l \\\/ ~ seq_if_dist_l.\nProof.\n  unfold seq_if_dist_l.\n  right; intro HC.\n  specialize (HC (BEq (AId \"x\") (ANum 0)) (CAss \"x\" (ANum 1))\n                 CSkip (CAss \"y\" (ANum 1))).\n  specialize (HC (t_empty 0) (t_update (t_empty 0) \"x\" 1)).\n  destruct HC; simpl in *; clear H0.\n  assert (H0: (_ !-> 0) =[ \"x\" ::= 1;; TEST \"x\"%string = 0 THEN SKIP ELSE \"y\" ::= 1 FI\n             ]=> (\"x\" !-> 1; _ !-> 0)).\n  { apply H; constructor; auto; econstructor; constructor; auto. }\n  inversion H0; subst.\n  inversion H3; subst.\n  inversion H6; subst; simpl in *; try congruence.\n  inversion H9; simpl in *; subst.\n  assert (H1: (\"y\" !-> 1; \"x\" !-> 1; _ !-> 0) \"y\" = (\"x\" !-> 1; _ !-> 0) \"y\").\n  { rewrite H7; reflexivity. }\n  compute in H1; congruence.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32902,"user_id":null,"body":"Require Import Preloaded.\nOpen Scope imp_scope.\nDefinition seq_if_dist_l := forall b c1 c2 c3, cequiv\n  (TEST b THEN c1 ;; c2 ELSE c1 ;; c3 FI)\n  (c1 ;; TEST b THEN c2 ELSE c3 FI).\n\nTheorem seq_if_dist_l_dec :\n  seq_if_dist_l \\\/ ~ seq_if_dist_l.\nProof.\n  right.\n  intros ns.\n  hnf in ns.\n  specialize (ns (X = 0) (X ::= 100) (Y ::= 1) (Y ::= 2)).\n  hnf in ns.\n  specialize (ns (X !-> 0)).\n  epose proof (ns _).\n  clear ns.\n  destruct H.\n  clear H0.\n  unshelve epose proof (H _).\n  constructor.\n  simpl.\n  reflexivity.\n  econstructor.\n  constructor.\n  simpl.\n  reflexivity.\n  econstructor.\n  simpl.\n  reflexivity.\n  clear H.\n  inversion H0; subst; clear H0.\n  inversion H5; subst; clear H5;\n  inversion H2; subst; clear H2;\n  simpl in *.\n  easy.\n  inversion H7; subst; clear H7.\n  inversion H3; subst; clear H3.\n  remember (Y !-> 2; X !-> 100; X !-> 0) as a.\n  remember (a Y) as b.\n  pose proof Heqb.\n  rewrite Heqa in Heqb.\n  compute in Heqb.\n  rewrite H0 in H.\n  compute in H.\n  subst.\n  easy.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32903,"user_id":null,"body":"Require Import Preloaded.\n\nDefinition seq_if_dist_l := forall b c1 c2 c3, cequiv\n  (TEST b THEN c1 ;; c2 ELSE c1 ;; c3 FI)\n  (c1 ;; TEST b THEN c2 ELSE c3 FI).\n\n\n\nTheorem seq_if_dist_l_dec :\n  seq_if_dist_l \\\/ ~ seq_if_dist_l.\nProof.\n  right.\n  intros Contra.\n  unfold seq_if_dist_l in Contra.\n  assert (H := Contra (X = 1)%imp (X ::= 1)%imp (Y ::= 1)%imp (Y ::= 2)%imp).\n  clear Contra.\n  unfold cequiv in H.\n  remember (_ !-> 0) as st1.\n  remember (Y !-> 2; X !-> 1; _ !-> 0) as st2.\n  assert (st1 =[ TEST X = 1 THEN X ::= 1;; Y ::= 1 ELSE X ::= 1;; Y ::= 2 FI\n    ]=> st2).\n  { apply E_IfFalse.\n      rewrite Heqst1. simpl. reflexivity.\n    econstructor.\n      constructor. rewrite Heqst1. simpl. reflexivity.\n    rewrite Heqst1. rewrite Heqst2. constructor. simpl. reflexivity.\n  }\n  apply H in H0.\n  inversion H0. subst. clear H0.\n  inversion H3. subst. clear H3.\n  simpl in H6.\n  inversion H6; subst; clear H6.\n  + inversion H7; subst; clear H7.\n    simpl in H4.\n    assert ((Y !-> 2; X !-> 1; _ !-> 0) Y = (Y !-> 1; X !-> 1; _ !-> 0) Y)\n      by (rewrite H4; reflexivity).\n    unfold t_update in H0.\n    simpl in H0.\n    discriminate.\n  + simpl in H5. discriminate.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32904,"user_id":null,"body":"Require Import Preloaded.\n\nTheorem cunique : forall {c st}, uniqueness (ceval c st).\nProof.\n  intros c st st' st'' H H'; revert st'' H'; induction H; intros.\n  - inversion H'; reflexivity.\n  - inversion H'; rewrite <- H, H4; reflexivity.\n  - inversion H'; apply IHceval2.\n    rewrite (IHceval1 st'0); assumption.\n  - inversion H'; [|rewrite H in *; discriminate].\n    apply IHceval; assumption.\n  - inversion H'; [rewrite H in *; discriminate|].\n    apply IHceval; assumption.\n  - inversion H'; [|rewrite H in *; discriminate].\n    reflexivity.\n  - inversion H'; [rewrite H5, H in *; discriminate|].\n    apply IHceval2; rewrite (IHceval1 st'0); assumption.\nQed.\n\nDefinition seq_if_dist_l := forall b c1 c2 c3, cequiv\n  (TEST b THEN c1 ;; c2 ELSE c1 ;; c3 FI)\n  (c1 ;; TEST b THEN c2 ELSE c3 FI).\n\nTheorem seq_if_dist_l_dec :\n  seq_if_dist_l \\\/ ~ seq_if_dist_l.\nProof.\n  right; intros H; specialize (H\n    (X = 0)%imp\n    (X ::= 1)%imp\n    (Y ::= 0)%imp\n    (Y ::= 1)%imp\n    (_ !-> 0)\n    (Y !-> 0; X !-> 1; _ !-> 0)\n  ); destruct H as [H _].\n  cut ((Y !-> 0; X !-> 1; _ !-> 0) Y = (Y !-> 1; X !-> 1; _ !-> 0) Y).\n  { intros; discriminate. }\n  cut ((Y !-> 0; X !-> 1; _ !-> 0) = (Y !-> 1; X !-> 1; _ !-> 0)).\n  { intros R; rewrite R; reflexivity. }\n  refine (cunique _ _ (H _) _).\n  - apply E_IfTrue; [reflexivity|].\n    apply (E_Seq _ _ _ (X !-> 1; _ !-> 0));\n    apply E_Ass; reflexivity.\n  - apply (E_Seq _ _ _ (X !-> 1; _ !-> 0)); [apply E_Ass; reflexivity|].\n    apply E_IfFalse; [reflexivity|].\n    apply E_Ass; reflexivity.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32905,"user_id":null,"body":"Require Import Preloaded.\n\nDefinition seq_if_dist_l := forall b c1 c2 c3, cequiv\n  (TEST b THEN c1 ;; c2 ELSE c1 ;; c3 FI)\n  (c1 ;; TEST b THEN c2 ELSE c3 FI).\n\nLemma contrapositive : forall {A B : Prop}, (A -> B) -> ~ B -> ~ A.\nProof.\n  auto.\nQed.\n\nTheorem seq_if_dist_l_dec :\n  seq_if_dist_l \\\/ ~ seq_if_dist_l.\nProof.\n  right.\n  intros contra.\n  specialize (contra (W = 0) (W ::= 1) (SKIP) (W ::= 0) (_ !-> 0) (W !-> 1; _ !-> 0))%imp.\n  destruct contra as (contra & _ ).\n  apply contrapositive in contra.\n  - apply contra.\n    apply E_IfTrue; try reflexivity.\n    repeat econstructor.\n  - intros contra2.\n    inversion contra2; subst.\n    inversion H1; subst.\n    inversion H4; subst; try discriminate.\n    inversion H7; subst.\n    assert ((W !-> 1; _ !-> 0) W = 1) as Ha by reflexivity.\n    rewrite <- H5 in Ha. discriminate.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32906,"user_id":null,"body":"Require Import Preloaded.\n\nDefinition seq_if_dist_l := forall b c1 c2 c3, cequiv\n  (TEST b THEN c1 ;; c2 ELSE c1 ;; c3 FI)\n  (c1 ;; TEST b THEN c2 ELSE c3 FI).\n\nTheorem not_iff_of_not (P Q : Prop) (Hp : P) (Hq : ~ Q) :\n  ~ (P <-> Q).\nProof.\n  intros [ H0 H1 ]. apply (Hq (H0 Hp)).\nQed.\n\nRequire Import Coq.Logic.FunctionalExtensionality.\n\nTheorem seq_if_dist_l_dec :\n  seq_if_dist_l \\\/ ~ seq_if_dist_l.\nProof.\n  (* TODO: Prove or disprove seq_if_dist_l depending on whether you think it\n     is true or not *)\n  right. intro H.\n  specialize (H (BEq X 0) (CAss X 1) (CAss X 2) (CAss X 3) empty_st (X !-> aeval (X !-> aeval empty_st 1) 2; X !-> aeval empty_st 1)).\n  Search ((_ <-> _) <-> _).\n  revert H. apply not_iff_of_not.\n  { repeat econstructor.  }\n  { intro H. inversion H; subst.\n    inversion H2; subst.\n    inversion H5; subst.\n    - inversion H7.\n    - inversion H8; subst.\n      assert (H9 := equal_f H6 X).\n      inversion H9. }\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32907,"user_id":null,"body":"Require Import Preloaded.\n\nDefinition seq_if_dist_l := forall b c1 c2 c3, cequiv\n  (TEST b THEN c1 ;; c2 ELSE c1 ;; c3 FI)\n  (c1 ;; TEST b THEN c2 ELSE c3 FI).\n\nLtac inv H := inversion H; subst; clear H.\n\nLemma f_not_equal:\n  forall {X Y : Type} (f g : X -> Y) (x : X),\n    f x <> g x -> f <> g.\nProof.\n  unfold not; intros; subst; auto.\nQed.\n\nTheorem seq_if_dist_l_dec :\n  seq_if_dist_l \\\/ ~ seq_if_dist_l.\nProof.\n  right; unfold seq_if_dist_l.\n  intros H.\n\n  specialize (H \n    (* b  = *) (X = 0)%imp\n    (* c1 = *) (X ::= 1)%imp\n    (* c2 = *) (Y ::= 0)%imp\n    (* c3 = *) (Y ::= 1)%imp).\n  \n  unfold cequiv in H.\n  specialize (H\n    (* st  = *) (X !-> 0)\n    (* st' = *) (Y !-> 0; X !-> 1; X !-> 0)).\n  \n  destruct H as [H1 H2].\n  assert ((X !-> 0) =[ TEST X = 0 THEN X ::= 1;; Y ::= 0 ELSE X ::= 1;; Y ::= 1 FI\n    ]=> (Y !-> 0; X !-> 1; X !-> 0)) as H3. {\n    clear H1 H2.\n    apply E_IfTrue; auto.\n    eapply E_Seq.\n      eapply E_Ass; reflexivity.\n    apply E_Ass; auto.\n  }\n  specialize (H1 H3).\n  inv H1.\n  inv H4.\n  simpl in H7.\n  inv H7; simpl in H6; inv H6.\n  inv H8.\n  simpl in H5.\n  eapply (f_not_equal _ _ Y).\n  2: apply H5.\n  intros G; inv G.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32908,"user_id":null,"body":"Require Import Preloaded.\n\nDefinition seq_if_dist_l := forall b c1 c2 c3, cequiv\n  (TEST b THEN c1 ;; c2 ELSE c1 ;; c3 FI)\n  (c1 ;; TEST b THEN c2 ELSE c3 FI).\n\nTheorem seq_if_dist_l_dec :\n  seq_if_dist_l \\\/ ~ seq_if_dist_l.\nProof.\n right. unfold seq_if_dist_l, cequiv. intro abs.\n assert (empty_st =[ X ::= 1;; TEST X = 0 THEN X ::= 2 ELSE X ::= 3 FI ]=>\n (X !-> 2;X !-> 1));[apply abs;(repeat econstructor);simpl;reflexivity|].\n inversion H;subst;\n inversion H2;subst;\n inversion H5;subst;[|\n inversion H8;subst;\n simpl in H6;\n (assert ((X !-> 3; X !-> 1) X = (X !-> 2; X !-> 1) X);[rewrite H6;reflexivity|])];\n discriminate.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32909,"user_id":null,"body":"Require Import Preloaded.\n\nDefinition seq_if_dist_l := forall b c1 c2 c3, cequiv\n  (TEST b THEN c1 ;; c2 ELSE c1 ;; c3 FI)\n  (c1 ;; TEST b THEN c2 ELSE c3 FI).\n\nTheorem ceval_deterministic: forall c st st1 st2,\n     st =[ c ]=> st1  ->\n     st =[ c ]=> st2 ->\n     st1 = st2.\nProof.\n  intros c st st1 st2 E1 E2.\n  generalize dependent st2.\n  induction E1;\n           intros st2 E2; inversion E2; subst.\n  - (* E_Skip *) reflexivity.\n  - (* E_Ass *) reflexivity.\n  - (* E_Seq *)\n    assert (st' = st'0) as EQ1.\n    { (* Proof of assertion *) apply IHE1_1; assumption. }\n    subst st'0.\n    apply IHE1_2. assumption.\n  - (* E_IfTrue, b1 evaluates to true *)\n      apply IHE1. assumption.\n  - (* E_IfTrue,  b1 evaluates to false (contradiction) *)\n      rewrite H in H5. discriminate H5.\n  - (* E_IfFalse, b1 evaluates to true (contradiction) *)\n      rewrite H in H5. discriminate H5.\n  - (* E_IfFalse, b1 evaluates to false *)\n      apply IHE1. assumption.\n  - (* E_WhileFalse, b1 evaluates to false *)\n    reflexivity.\n  - (* E_WhileFalse, b1 evaluates to true (contradiction) *)\n    rewrite H in H2. discriminate H2.\n  - (* E_WhileTrue, b1 evaluates to false (contradiction) *)\n    rewrite H in H4. discriminate H4.\n  - (* E_WhileTrue, b1 evaluates to true *)\n      assert (st' = st'0) as EQ1.\n      { (* Proof of assertion *) apply IHE1_1; assumption. }\n      subst st'0.\n      apply IHE1_2. assumption.  Qed.\n\nDefinition prog1 : com :=\n  TEST X = 0 THEN X ::= 1 ;; Y ::= 0 ELSE X ::= 1 ;; Y ::= 1 FI.\n\nDefinition prog2 : com :=\n  X ::= 1 ;; TEST X = 0 THEN Y ::= 0 ELSE Y ::= 1 FI.\n\nTheorem seq_if_dist_l_dec :\n  seq_if_dist_l \\\/ ~ seq_if_dist_l.\nProof.\n  right. intros H.\n  assert (Heqv : cequiv prog1 prog2).\n  { apply (H _ _ _ _). }\n  assert (H1 : empty_st =[ prog1 ]=> ( Y !-> 0 ; X !-> 1 ; empty_st)).\n  { unfold prog1. apply E_IfTrue. reflexivity.\n    eapply E_Seq. apply E_Ass. reflexivity.\n    apply E_Ass. reflexivity.\n  }\n  apply Heqv in H1 as H2.\n  assert (H2' : empty_st =[ prog2 ]=> (Y !-> 1 ; X !-> 1)).\n  { unfold prog2. eapply E_Seq. apply E_Ass; reflexivity.\n    apply E_IfFalse. reflexivity. apply E_Ass. reflexivity.\n  }\n  assert (Hst : (Y !-> 0 ; X !-> 1) = (Y !-> 1 ; X !-> 1)).\n  { eapply ceval_deterministic. apply H2. assumption.\n  }\n  assert (Heq : (Y !-> 0; X !-> 1) Y = (Y !-> 1; X !-> 1) Y).\n  { rewrite Hst. reflexivity. }\n  unfold t_update in Heq. simpl in Heq. discriminate.  Qed.\n\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5cdcdefdf00ea9001ca2e8fa":[{"id":32910,"user_id":null,"body":"Require Import Preloaded.\n\nDefinition cmax_exists := exists cmax, forall c, capprox c cmax.\n\nLemma imp_aux: forall c st st', st =[ c ]=> st' -> forall st'', st =[ c ]=> st'' -> st' = st''.\nProof with auto.\n  induction 1; intros.\n  - inversion H...\n  - inversion H0. subst...\n  - inversion H1. subst. pose proof (IHceval1 _ H4). subst. apply IHceval2...\n  - inversion H1; subst. apply IHceval...\n    rewrite H in H7. discriminate.\n  - inversion H1; subst.\n    rewrite H in H7. discriminate.\n    apply IHceval...\n  - inversion H0; subst...\n    rewrite H in H3. discriminate.\n  - inversion H2; subst.\n    rewrite H in H7. discriminate.\n    pose proof (IHceval1 _ H6); subst.\n    apply IHceval2...\nQed.\n     \nOpen Scope imp_scope.\n\nTheorem cmax_exists_dec : cmax_exists \\\/ ~ cmax_exists.\nProof with auto.\n  right.\n  intro. destruct H.\n  pose proof (H SKIP empty_st _ (E_Skip _)).  \n  pose proof (H (\"x\"::=1) empty_st (\"x\" !-> 1) (E_Ass _ _ _ _ eq_refl)).\n  pose proof (imp_aux _ _ _ H0 _ H1).\n  assert (empty_st \"x\"%string = (\"x\" !-> 1) \"x\"). rewrite <- H2...\n   discriminate.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32911,"user_id":null,"body":"Require Import Preloaded.\n\nDefinition cmax_exists := exists cmax, forall c, capprox c cmax.\n\nLemma ceval_uniqueness : forall c st,\n  uniqueness (ceval c st).\nProof.\n  intros c st st' st'' H; revert st''; induction H; intros.\n  - inversion H; now subst.\n  - inversion H0; now subst.\n  - inversion H1; subst; apply IHceval2; now rewrite IHceval1 with st'0.\n  - apply IHceval; inversion H1; subst; now rewrite H in H7.\n  - apply IHceval; inversion H1; subst; now rewrite H in H7.\n  - inversion H0; subst; [|rewrite H in H3]; easy.\n  - inversion H2; subst; [now rewrite H in H7|].\n    apply IHceval2; now rewrite (IHceval1 st'0).\nQed.\n\nTheorem cmax_exists_dec : cmax_exists \\\/ ~ cmax_exists.\nProof.\n  right; intros [cmax Hmax].\n  assert ((t_empty 0) =[ cmax ]=> (t_empty 0));\n  [apply (Hmax (SKIP)%imp); constructor|].\n  assert ((t_empty 0) =[ cmax ]=> (t_update (t_empty 0) X 1));\n  [apply (Hmax (X ::= 1)%imp); now constructor|].\n  assert (t_empty 0 X = t_update (t_empty 0) X 1 X); [|unfold t_update, eqb_string; now destruct (string_dec X X)].\n  now rewrite (ceval_uniqueness _ _ _ _ H0 H).\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32912,"user_id":null,"body":"Require Import Preloaded.\n\nDefinition cmax_exists := exists cmax, forall c, capprox c cmax.\n\nLemma ceval_deterministic : forall st st1 st2 p,\n  st =[p]=> st1 -> st =[p]=> st2 -> st1 = st2.\nProof.\n  intros.\n  generalize dependent st2.\n  induction H; intros st2 H2;\n    inversion H2; subst; try reflexivity; eauto.\n  - assert (st' = st'0); try eauto.\n    subst. eauto.\n  - rewrite H in H7. discriminate.\n  - rewrite H in H7. discriminate. \n  - rewrite H in H3. discriminate. \n  - rewrite H in H7. discriminate.\n  - apply IHceval2. replace st' with st'0; eauto.\n    symmetry. eauto.\nQed.\n\nTheorem cmax_exists_dec : cmax_exists \\\/ ~ cmax_exists.\nProof.\n  right.\n  intros Contra.\n  destruct Contra.\n  assert ((_ !-> 0) =[x]=> (X !-> 1; _ !-> 0)).\n  { apply H with (X ::= 1)%imp. constructor. reflexivity. }\n  assert ((_ !-> 0) =[x]=> (_ !-> 0)).\n  { apply H with SKIP%imp. constructor. }\n  assert ((X !-> 1; _ !-> 0) = (_ !-> 0)).\n  { eapply ceval_deterministic; eauto. }\n  assert ((X !-> 1; _ !-> 0) X = (_ !-> 0) X).\n  { rewrite H2. reflexivity. }\n  unfold t_update in H3.\n  unfold t_empty in H3.\n  simpl in H3.\n  discriminate.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32913,"user_id":null,"body":"Require Import Preloaded.\n\nTheorem cunique : forall {c st}, uniqueness (ceval c st).\nProof.\n  intros c st st' st'' H H'; revert st'' H'; induction H; intros.\n  - inversion H'; reflexivity.\n  - inversion H'; rewrite <- H, H4; reflexivity.\n  - inversion H'; apply IHceval2.\n    rewrite (IHceval1 st'0); assumption.\n  - inversion H'; [|rewrite H in *; discriminate].\n    apply IHceval; assumption.\n  - inversion H'; [rewrite H in *; discriminate|].\n    apply IHceval; assumption.\n  - inversion H'; [|rewrite H in *; discriminate].\n    reflexivity.\n  - inversion H'; [rewrite H5, H in *; discriminate|].\n    apply IHceval2; rewrite (IHceval1 st'0); assumption.\nQed.\n\nDefinition cmax_exists := exists cmax, forall c, capprox c cmax.\n\nTheorem cmax_exists_dec : cmax_exists \\\/ ~ cmax_exists.\nProof.\n  right; intros [cmax Hmax].\n  assert (capprox SKIP cmax)%imp as Hmax'; [apply Hmax|].\n  specialize (Hmax (X ::= 1) (_ !-> 0) (X !-> 1; _ !-> 0))%imp.\n  specialize (Hmax' (_ !-> 0) (_ !-> 0)).\n  cut ((X !-> 1; _ !-> 0) X = (_ !-> 0) X); [intros; discriminate|].\n  cut ((X !-> 1; _ !-> 0) = (_ !-> 0)); [intros R; rewrite R; reflexivity|].\n  refine (cunique _ _ (Hmax _) (Hmax' _)).\n  - apply E_Ass; reflexivity.\n  - apply E_Skip.\nQed.\n\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32914,"user_id":null,"body":"Require Import Preloaded.\n\nDefinition cmax_exists := exists cmax, forall c, capprox c cmax.\n\n\nLemma ceval_deterministic : forall c st st' st'',\n  st =[ c ]=> st' -> st =[ c ]=> st'' ->\n  st' = st''.\nProof.\n  intros. revert dependent st''. induction H; intros.\n  - inversion H0; subst. reflexivity.\n  - inversion H0; subst. reflexivity.\n  - inversion H1; subst.\n    apply IHceval1 in H4. subst. auto.\n  - inversion H1; subst; try congruence. auto.\n  - inversion H1; subst; try congruence. auto.\n  - inversion H0; subst; congruence.\n  - inversion H2; subst; try congruence.\n    apply IHceval1 in H6. subst. auto.\nQed.\n\nLemma modus_ponens : forall {A B}, (A -> B) -> A -> B.\nProof.\n  auto.\nQed.\n\nTheorem cmax_exists_dec : cmax_exists \\\/ ~ cmax_exists.\nProof.\n  right.\n  intros contra.\n  destruct contra as (cmax & contra).\n  pose proof (contra SKIP (_ !-> 0) (_ !-> 0))%imp as contra2.\n  pose proof (contra (W ::= 1) (_ !-> 0) (W !-> 1))%imp as contra3.\n  unshelve epose proof (modus_ponens contra2 _) as contra2'.\n  constructor.\n  unshelve epose proof (modus_ponens contra3 _) as contra3'.\n  constructor. reflexivity.\n  pose proof (ceval_deterministic _ _ _ _ contra2' contra3') as H.\n  assert ((_ !-> 0) W = 0) as Ha by reflexivity.\n  rewrite H in Ha. discriminate.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32915,"user_id":null,"body":"Require Import Preloaded.\n\nDefinition cmax_exists := exists cmax, forall c, capprox c cmax.\n\nTheorem assign_inj x v v' (s : state) (h : (x !-> v ; s) = (x !-> v' ; s)) : v = v'.\nProof.\n  assert (h' : (x !-> v ; s) x = (x !-> v' ; s) x).\n  { rewrite h. reflexivity. }\n  unfold t_update, eqb_string in h'.\n  (* assert (h'' := string_dec x x). *)\n  destruct (string_dec x x).\n  assumption. contradiction.\nQed.\n\nTheorem imp_det (c : com) (s s' s'' : state)\n        (h : s =[ c ]=> s') (h' : s =[ c ]=> s'') :\n  s' = s'' .\nProof.\n  revert s'' h'. induction h; intros s'' h'.\n  { inversion h'. reflexivity. }\n  { inversion h'. subst n0 n. reflexivity. }\n  { inversion h'. specialize (IHh1 _ H1). subst st'0.\n    specialize (IHh2 _ H4).  subst st''. reflexivity. }\n  { inversion h'. apply (IHh _ H6). rewrite H5 in H. inversion H. }\n  { inversion h'. rewrite H5 in H. inversion H. apply (IHh _ H6). }\n  { inversion h'. reflexivity. rewrite H2 in H. inversion H. }\n  { inversion h'. subst b0 c0 st0 st. rewrite H4 in H. inversion H.\n    subst b0 c0 st0 st''0. apply IHh2.\n    assert (H' := IHh1 _ H3).\n    subst st'0. exact H6. }\nQed.\n  \nTheorem cmax_exists_dec : cmax_exists \\\/ ~ cmax_exists.\nProof.\n  right. intros [ cmax h].\n  set (s := t_empty 0).\n  set (s' := t_update s X 1).\n  set (s'' := t_update s X 2).\n  set (c := CAss X 1).\n  set (c' := CAss X 2).\n  assert (h0 := h c s s' (E_Ass _ _ _ _ eq_refl)).\n  assert (h1 := h c' s s'' (E_Ass _ _ _ _ eq_refl)).\n  assert (h2 := imp_det cmax s s' s'' h0 h1).\n  assert (h3 := assign_inj _ _ _ _ h2).\n  inversion h3.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32916,"user_id":null,"body":"Require Import Preloaded.\n\nDefinition cmax_exists := exists cmax, forall c, capprox c cmax.\n\nDefinition emptyState:state := fun _ => 0.\n\nLemma detEx s p s1 s2: s =[ p ]=> s1 -> s =[ p ]=> s2 -> s1=s2.\nProof.\n  intros H G.\n  induction H in s2, G |- *;inversion G;subst;try congruence.\n  - specialize (IHceval1 _ H3) as <-.\n  specialize (IHceval2 _ H6) as <-.\n  reflexivity.\n  - now apply IHceval.\n  - now apply IHceval.\n  - apply IHceval1 in H5 as <-.\n  now apply IHceval2 in H8 as <-.\nQed.\n\nLemma stateExt {s1 s2:state} n: s1 = s2 -> s1 n = s2 n.\nProof.\n  now intros ->.\nQed.\n\nTheorem cmax_exists_dec : cmax_exists \\\/ ~ cmax_exists.\nProof.\n  right.\n  intros [].\n  pose (p:=CAss \"x\" (ANum 1)).\n  pose (st:=(\"x\" !-> 1 ; emptyState)).\n  specialize (H p emptyState st) as H1.\n  specialize (H CSkip emptyState emptyState) as H2.\n  assert(emptyState =[ p ]=> st) as ?%H1 by now constructor.\n  assert(emptyState =[ SKIP ]=> emptyState) as ?%H2 by constructor.\n  clear H1 H2.\n  specialize (detEx _ _ _ _ H3 H4) as [=]%(stateExt \"x\").\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32917,"user_id":null,"body":"Require Import Preloaded.\n(* From earlier in SF *)\nTheorem ceval_deterministic: forall c st st1 st2,\n     st =[ c ]=> st1 ->\n     st =[ c ]=> st2 ->\n     st1 = st2.\nProof.\n  intros c st st1 st2 E1 E2.\n  generalize dependent st2.\n  induction E1;\n           intros st2 E2; inversion E2; subst.\n  - (* E_Skip *) reflexivity.\n  - (* E_Ass *) reflexivity.\n  - (* E_Seq *)\n    assert (st' = st'0) as EQ1.\n    { (* Proof of assertion *) apply IHE1_1; assumption. }\n    subst st'0.\n    apply IHE1_2. assumption.\n  - (* E_IfTrue, b1 evaluates to true *)\n      apply IHE1. assumption.\n  - (* E_IfTrue,  b1 evaluates to false (contradiction) *)\n      rewrite H in H5. discriminate H5.\n  - (* E_IfFalse, b1 evaluates to true (contradiction) *)\n      rewrite H in H5. discriminate H5.\n  - (* E_IfFalse, b1 evaluates to false *)\n      apply IHE1. assumption.\n  - (* E_WhileFalse, b1 evaluates to false *)\n    reflexivity.\n  - (* E_WhileFalse, b1 evaluates to true (contradiction) *)\n    rewrite H in H2. discriminate H2.\n  - (* E_WhileTrue, b1 evaluates to false (contradiction) *)\n    rewrite H in H4. discriminate H4.\n  - (* E_WhileTrue, b1 evaluates to true *)\n      assert (st' = st'0) as EQ1.\n      { (* Proof of assertion *) apply IHE1_1; assumption. }\n      subst st'0.\n      apply IHE1_2. assumption. Qed.\n(* End for earlier in SF *)\n\nDefinition zo_state : state :=\n t_update empty_st X 1.\nLemma diffstates : zo_state <> empty_st.\nProof.\n assert (~ zo_state X = empty_st X);[discriminate|].\n intro abs. rewrite abs in H. contradiction.\nQed.\nDefinition set1 : com := X ::= 1.\n\nDefinition cmax_exists := exists cmax, forall c, capprox c cmax.\n\nTheorem cmax_exists_dec : cmax_exists \\\/ ~ cmax_exists.\nProof.\n right. intros [cmax Hcmax].\n apply diffstates.\n eapply ceval_deterministic;[apply (Hcmax set1)|apply (Hcmax CSkip)];\n constructor;auto.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32918,"user_id":null,"body":"Require Import Preloaded.\n\nLemma ceval_unique: forall st st'1 st'2 c, \n  st =[c]=>st'1 -> st =[c]=>st'2 -> st'1 = st'2.\nProof.\n  intros.\n  generalize dependent st'2.\n  induction H; intros.\n  { inversion H0; auto. }\n  { \n    inversion H0.\n    subst.\n    auto.\n  }\n  {\n    inversion H1.\n    subst.\n    apply IHceval1 in H4. subst.\n    apply IHceval2 in H7. auto.\n  }\n  {\n    inversion H1;\n    subst.\n    {\n      apply IHceval. auto.\n    }\n    rewrite H in H7.\n    inversion H7.\n  }\n  {\n    inversion H1; subst.\n     rewrite H in H7. inversion H7.\n    apply IHceval. auto.\n  }\n  {\n    inversion H0; auto. \n    subst.\n    rewrite H in H3.\n    inversion H3.\n  }\n  inversion H2; subst.\n    rewrite H7 in H. inversion H.\n  apply IHceval1 in H6.\n  subst. auto.\nQed.\n\n\nDefinition cmax_exists := exists cmax, forall c, capprox c cmax.\n\nTheorem cmax_exists_dec : cmax_exists \\\/ ~ cmax_exists.\nProof.\n  right.\n  unfold not.\n  unfold cmax_exists.\n  unfold capprox.\n  intros.\n  pose (fun _ : string => O ) as st.\n  assert(st =[ EmptyString ::= 1]=> (t_update st EmptyString 1) ).\n    constructor. auto.\n  inversion H0. subst.\n  assert(st =[ EmptyString ::= 2]=> (t_update st EmptyString 2) ).\n    constructor. auto.\n  inversion H1. subst.\n  simpl in *.\n  destruct H as [cmax].\n  assert(st =[ cmax ]=> (\"\" !-> 1; st)).\n    eapply H. apply H0.\n  assert(st =[ cmax ]=> (\"\" !-> 2; st)).\n    eapply H. apply H1.\n  assert((\"\" !-> 1; st) = (\"\" !-> 2; st)).\n  apply (ceval_unique st _ _ cmax H2 H3).\n  assert(1 = 2).\n  2: inversion  H6.\n  replace 1 with ((\"\" !-> 1; st) EmptyString) at 1; auto.\n  replace 2 with ((\"\" !-> 2; st) EmptyString) at 1; auto.\n  rewrite H4. auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32919,"user_id":null,"body":"Require Import Preloaded.\n\nDefinition cmax_exists := exists cmax, forall c, capprox c cmax.\n\nOpen Scope imp_scope.\n\nLemma ceval_deterministic : forall c st st' st'',\n  st =[ c ]=> st' -> st =[ c ]=> st'' -> st' = st''.\nProof.\n  intros.\n  generalize dependent st''.\n  induction H; intros.\n  - inversion H0. auto.\n  - inversion H0. subst. auto.\n  - inversion H1. subst.\n    assert (st' = st'0) by eauto.\n    subst. eauto.\n  - inversion H1; eauto.\n    rewrite H in H7; discriminate.\n  - inversion H1; eauto.\n    rewrite H in H7; discriminate.\n  - inversion H0; eauto.\n    rewrite H in H3; discriminate.\n  - inversion H2; subst.\n    + rewrite H in H7; discriminate.\n    + assert (st' = st'0) by eauto.\n      subst. eauto.\nQed.\n\nTheorem cmax_exists_dec : cmax_exists \\\/ ~ cmax_exists.\nProof.\n  right. destruct 1 as [cmax Hcmax].\n  pose (c1 := (X ::= 1)). pose (st1 := (X !-> 1)).\n  pose (c2 := (X ::= 2)). pose (st2 := (X !-> 2)).\n  assert (H1: empty_st =[ cmax ]=> st1). {\n    apply Hcmax with (c := c1).\n    repeat constructor.\n  }\n  assert (H2: empty_st =[ cmax ]=> st2). {\n    apply Hcmax with (c := c2).\n    repeat constructor.\n  }\n  assert (H: 1 = 2). {\n    replace 2 with (st2 X) by auto.\n    replace 1 with (st1 X) by auto.\n    replace st2 with st1;\n      eauto using ceval_deterministic.\n  }\n  discriminate.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5cdce6056d6a44002999a062":[{"id":32920,"user_id":null,"body":"Require Import Preloaded.\nRequire Export Setoid.\nRequire Export Relation_Definitions.\nRequire Import Arith Lia.\nRequire Import Coq.Program.Equality.\n\nLemma symmetric_mod : forall m, symmetric _ (mod_equiv m).\nProof.\n  intros m x y hxy.\n  induction hxy as [| m x y hxy hxy2 | m x y hxy hxy2] ; constructor ; assumption.\nQed.\n\nLemma transitive_mod : forall m, transitive _ (mod_equiv m).\nProof.\n  intros m x y z hxy.\n  revert z.\n  induction hxy as [| m x y hxy hxy2 | m x y hxy hxy2] ; intros ; try assumption.\n  + constructor. apply hxy2. assumption.\n  + apply hxy2. clear hxy hxy2 x. dependent induction H.\n    - do 2 constructor.\n    - replace y with n1 by lia. assumption.\n    - constructor. apply IHmod_equiv. reflexivity.\nQed.\n\nAdd Parametric Relation (m : nat) : nat (mod_equiv m)\n  reflexivity proved by (mod_intro_same m)\n  symmetry proved by (symmetric_mod m)\n  transitivity proved by (transitive_mod m)\n  as eq_set_rel.\n\nLemma plus_mod (m : nat) : forall n a b, a == b %% m -> n + a == n + b %% m.\nProof.\n  intros n a b hab.\n  induction hab.\n  + reflexivity.\n  + replace (n + (m + n1)) with (m + (n + n1)) by ring.\n    constructor. assumption.\n  + replace (n + (m + n2)) with (m + (n + n2)) by ring.\n    constructor. assumption.\nQed.\n\nLemma mult_zero_mod (m : nat) : forall n, n * m == 0 %% m.\nProof.\n  intros.\n  induction n.\n  + reflexivity.\n  + simpl. rewrite <- IHn. apply mod_intro_plus_l. reflexivity.\nQed.\n\nLemma mult_mod (m : nat) : forall n a b, a == b %% m -> n * a == n * b %% m.\nProof.\n  intros n a b hab.\n  induction hab.\n  + reflexivity.\n  + rewrite <- IHhab. replace (n * (m + n1)) with (n * n1 + n * m) by ring.\n    replace (n * n1) with (n * n1 + 0) at 2 by ring. apply plus_mod. \n    apply mult_zero_mod.\n  + rewrite IHhab. ring_simplify.\n    replace (n * n2) with (n * n2 + 0) at 1 by ring. apply plus_mod.\n    symmetry. apply mult_zero_mod. \nQed.\n\nAdd Parametric Morphism (m : nat) : plus\n  with signature (mod_equiv m) ==> (mod_equiv m) ==> (mod_equiv m) as plus_mor.\nProof.\n  intros a1 b1 h1 a2 b2 h2.\n  rewrite (plus_mod m a1 a2 b2 h2).\n  rewrite (Nat.add_comm a1), (Nat.add_comm b1).\n  rewrite (plus_mod m b2 a1 b1 h1).\n  reflexivity.\nQed.\n\nAdd Parametric Morphism (m : nat) : mult\n  with signature (mod_equiv m) ==> (mod_equiv m) ==> (mod_equiv m) as mult_mor.\nProof.\n  intros a1 b1 h1 a2 b2 h2.\n  rewrite (mult_mod m a1 a2 b2 h2).\n  rewrite (Nat.mul_comm a1), (Nat.mul_comm b1).\n  rewrite (mult_mod m b2 a1 b1 h1).\n  reflexivity.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32921,"user_id":null,"body":"Require Import Preloaded.\n\nFrom Coq Require Import Setoid Program.Equality Lia.\n\nInstance Reflexive_mod_equiv z : Reflexive (mod_equiv z).\nProof. constructor. Qed.\n\nInstance Symmetric_mod_equiv z : Symmetric (mod_equiv z).\nProof. intros x y H; induction H; constructor; auto. Qed.\n\nLemma plus_inj x y z :\n  x + y = x + z ->\n  y = z.\nProof. revert y z; induction x; simpl; intros y z H; auto. Qed.\n\nLemma mod_equiv_plus x y z :\n  x == z + y %% z ->\n  x == y %% z.\nProof.\n  intro H; dependent induction H.\n  - constructor; reflexivity.\n  - constructor; apply IHmod_equiv; auto.\n  - apply plus_inj in x; subst; auto.\nQed.\n\nInstance Transitive_mod_equiv z : Transitive (mod_equiv z).\nProof.\n  intros a b c Hab Hbc.\n  revert Hab. revert a.\n  induction Hbc; intros a Hab; auto.\n  - apply IHHbc.\n    apply mod_equiv_plus; auto.\n  - constructor; auto.\nQed.\n\nTheorem refl_test : forall m n : nat, n == n %% m.\nProof. reflexivity. Qed.\nPrint Assumptions refl_test.\n\nTheorem sym_trans_test : forall m n p q : nat, n == p %% m -> p == q %% m -> q == n %% m.\nProof. intros m n p q Hnp Hpq. symmetry. transitivity p; assumption. Qed.\nPrint Assumptions sym_trans_test.\n\nLemma plus_mod_equiv_inj a b c z :\n  b == c %% z ->\n  a + b == a + c %% z.\nProof.\n  induction 1.\n  - reflexivity.\n  - replace (a + (m + n1)) with (m + (a + n1)) by lia.\n    constructor; auto.\n  - replace (a + (m + n2)) with (m + (a + n2)) by lia.\n    constructor; auto.\nQed.\n\nInstance Proper_plus z : Morphisms.Proper (mod_equiv z ==> mod_equiv z ==> mod_equiv z) plus.\nProof.\n  intros x y Hxyz a b Habz.\n  dependent induction Hxyz.\n  - apply plus_mod_equiv_inj; auto.\n  - replace (m + n1 + a) with (m + (n1 + a)) by lia.\n    constructor; auto.\n  - replace (m + n2 + b) with (m + (n2 + b)) by lia.\n    constructor; auto.\nQed.\n\nLemma mul_mod_equiv_inj a b c z :\n  b == c %% z ->\n  a * b == a * c %% z.\nProof.\n  revert b c z; induction a; intros b c z Hbcz; simpl.\n  - reflexivity.\n  - rewrite IHa; eauto; rewrite Hbcz; reflexivity.\nQed.\n\nLemma mod_plus_l_n a b z n :\n  a == b %% z ->\n  n * z + a == b %% z.\nProof.\n  revert a b z; induction n; intros a b z Habz; simpl; auto.\n  replace (z + n * z + a) with (z + (n * z + a)) by lia.\n  constructor; auto.\nQed.\n\nInstance Proper_mul z : Morphisms.Proper (mod_equiv z ==> mod_equiv z ==> mod_equiv z) Nat.mul.\nProof.\n  intros x y Hxyz a b Habz.\n  dependent induction Hxyz.\n  - apply mul_mod_equiv_inj; auto.\n  - replace ((m + n1) * a) with (m * a + n1 * a) by lia.\n    rewrite IHHxyz; eauto.\n    replace (m * a) with (a * m) by lia.\n    apply mod_plus_l_n; reflexivity.\n  - replace ((m + n2) * b) with (m * b + n2 * b) by lia.\n    rewrite IHHxyz; eauto.\n    symmetry.\n    replace (m * b) with (b * m) by lia.\n    apply mod_plus_l_n; reflexivity.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32922,"user_id":null,"body":"Require Import Preloaded Setoid Morphisms Arith.\n\nInstance Equivalence_eq (m : nat) : Equivalence (mod_equiv m).\nProof.\n  apply Build_Equivalence.\n  - intros x; constructor.\n  - induction 1; now constructor.\n  - induction 1.\n    + easy.\n    + intros; constructor; now apply IHmod_equiv.\n    + intros IH; apply IHmod_equiv; clear -IH.\n      remember (m + n2) as n; revert n2 Heqn; induction IH; intros.\n      * subst; repeat constructor.\n      * cut (n0 = n1); [intros R; now rewrite R|].\n        clear -Heqn; induction m; [easy|].\n        apply IHm; now inversion Heqn.\n      * constructor; apply IHIH, Heqn.\nDefined.\n\nInstance Proper_add (m : nat) : Proper ((mod_equiv m) ==> (mod_equiv m) ==> (mod_equiv m)) plus.\nProof.\n  induction 1.\n  - induction 1.\n    + constructor.\n    + assert (n + (m + n1) = m + (n + n1)) as R by ring; rewrite R; clear R.\n      now constructor.\n    + assert (n + (m + n2) = m + (n + n2)) as R by ring; rewrite R; clear R.\n      now constructor.\n  - intros x y xy.\n    rewrite <- Nat.add_assoc; constructor.\n    apply IHmod_equiv, xy.\n  - intros x y xy.\n    rewrite <- Nat.add_assoc; constructor.\n    apply IHmod_equiv, xy.\nDefined.\n\nLemma mul_mod : forall a m, a * m == 0 %% m.\nProof.\n  induction a; intros m.\n  - constructor.\n  - simpl; constructor; apply IHa.\nQed.\n\nInstance Proper_mul (m : nat) : Proper ((mod_equiv m) ==> (mod_equiv m) ==> (mod_equiv m)) mult.\nProof.\n  induction 1.\n  - induction 1.\n    + constructor.\n    + assert (n * (m + n1) = n * m + n * n1) as R by ring; rewrite R; clear R.\n      now rewrite mul_mod.\n    + assert (n * (m + n2) = n * m + n * n2) as R by ring; rewrite R; clear R.\n      symmetry; now rewrite mul_mod.\n  - intros x y xy.\n    rewrite Nat.mul_add_distr_r, Nat.mul_comm, mul_mod.\n    apply IHmod_equiv, xy.\n  - intros x y xy.\n    rewrite Nat.mul_add_distr_r, (Nat.mul_comm m).\n    symmetry; rewrite mul_mod; symmetry; apply IHmod_equiv, xy.\nDefined.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32923,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Nat Arith.\nRequire Import Program.\nRequire Import Setoid.\n\nLemma mod_sym m n1 n2 : n1 == n2 %% m -> n2 == n1 %% m.\nProof.\n  induction 1.\n  all: constructor ; auto.\nQed.\n\nLemma mod_inv_l m n1 n2 : m + n1 == n2 %% m -> n1 == n2 %% m.\nProof.\n  intros H.\n  dependent induction H.\n  - constructor.\n    constructor.\n  - apply plus_reg_l in x.\n    rewrite <- x.\n    assumption.\n  - constructor.\n    apply IHmod_equiv.\n    reflexivity.\nQed.\n\nLemma mod_trans m n1 n2 n3 : n1 == n2 %% m -> n2 == n3 %% m -> n1 == n3 %% m.\nProof.\n  induction 1.\n  - intros. assumption.\n  - intros.\n    constructor.\n    auto.\n  - intros.\n    apply IHmod_equiv.\n    apply mod_inv_l.\n    assumption.\nQed.\n\nAdd Parametric Relation m : nat (mod_equiv m)\n  reflexivity proved by (mod_intro_same m)\n  symmetry proved by (mod_sym m)\n  transitivity proved by (mod_trans m)\n  as mod_rel.\n\nAdd Parametric Morphism m : add\n  with signature (mod_equiv m) ==> (mod_equiv m) ==> (mod_equiv m)\n  as add_mod.\nProof.\n  intros x y Hxy.\n  dependent induction Hxy.\n  - intros x y Hxy.\n    induction Hxy.\n    + reflexivity.\n    + rewrite Nat.add_assoc.\n      rewrite (Nat.add_comm n).\n      rewrite <- Nat.add_assoc.\n      constructor.\n      assumption.\n    + rewrite Nat.add_assoc.\n      rewrite (Nat.add_comm n m).\n      rewrite <- Nat.add_assoc.\n      constructor.\n      assumption.\n  - intros.\n    rewrite <- Nat.add_assoc.\n    constructor.\n    auto.\n  - intros.\n    rewrite <- Nat.add_assoc.\n    constructor.\n    auto.\nQed.\n\nLemma mul_cst m x y y' : y == y' %% m -> x*y == x*y' %% m.\nProof.\n  intros e.\n  induction x.\n  1: reflexivity.\n  cbn.\n  rewrite IHx.\n  rewrite e.\n  reflexivity.\nQed.\n\nAdd Parametric Morphism m : mul\n  with signature (mod_equiv m) ==> (mod_equiv m) ==> (mod_equiv m)\n  as mul_mod.\nProof.\n  intros x y Hxy.\n  induction Hxy.\n  - apply mul_cst.\n  - intros.\n    rewrite Nat.mul_add_distr_r.\n    assert (m*x0 == 0 %% m) as e0.\n    {\n      rewrite Nat.mul_comm.\n      replace 0 with (x0*0) by apply Nat.mul_0_r.\n      apply mul_cst.\n      replace m with (m + 0) at 2 by apply Nat.add_0_r.\n      constructor.\n      reflexivity.\n    }\n    rewrite e0.\n    cbn.\n    auto.\n  - intros.\n    rewrite Nat.mul_add_distr_r.\n    assert (m*y0 == 0 %% m) as e0.\n    {\n      rewrite Nat.mul_comm.\n      replace 0 with (y0*0) by apply Nat.mul_0_r.\n      apply mul_cst.\n      replace m with (m + 0) at 2 by apply Nat.add_0_r.\n      constructor.\n      reflexivity.\n    }\n    rewrite e0.\n    cbn.\n    auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32924,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Lia.\nRequire Import Coq.Program.Equality.\n\nLtac easywrite equation :=\n  unshelve erewrite (_ : equation); [lia|].\n\nLemma add_nm_congr: forall n m k, n*m + k == k %% m.\nProof.\n  induction n;\n    intros.\n  simpl.\n  constructor.\n  easywrite (S n * m = m + n * m).\n  easywrite (m + n * m + k = m + (n * m + k)).\n  constructor.\n  eapply IHn.\nDefined.\n\nTheorem mod_equiv_refl: forall m n, mod_equiv m n n.\nProof.\n  constructor.\nQed.\n\nTheorem mod_equiv_sym: forall m n o, mod_equiv m n o -> mod_equiv m o n.\nProof.\n  intros ? ? ? Hequiv; induction Hequiv; constructor; auto.\nDefined.\n\nLemma add_m_ok: forall m n o, (n + m) == o %% m -> n == o %% m.\n  intros.\n  dependent induction H.\n  {\n    eapply mod_equiv_sym.\n    easywrite (n + m = m + n).\n    repeat constructor.\n  }\n  {\n    subst.\n    easywrite (n = n1).\n    assumption.\n  }\n  {\n    constructor.\n    eapply IHmod_equiv.\n    auto.\n  }\nQed.\n\nTheorem mod_equiv_trans: forall m n o p, n == o %% m -> o == p %% m -> n == p %% m.\n  intros.\n  \n  dependent induction H.\n  { assumption. }\n  { constructor.\n    eapply IHmod_equiv.\n    assumption.\n  }\n  {\n    eapply IHmod_equiv.\n    inversion H0.\n    subst.\n    {\n      repeat constructor.\n    }\n    {\n      subst.\n      eapply add_m_ok.\n      easywrite (n2 + m = m + n2).\n      assumption.\n    }\n    {\n      subst.\n      eapply add_m_ok.\n      easywrite (n2 + m = m + n2).\n      assumption.\n    }\n  }\nQed.\n\nPrint Assumptions mod_equiv_trans.\nPrint mod_equiv_trans.\nFrom Coq Require Import Setoid.\n\nAdd Parametric Relation (n: nat) : nat (mod_equiv n)\n    reflexivity proved by (mod_equiv_refl n)\n    symmetry proved by (mod_equiv_sym n)\n    transitivity proved by (mod_equiv_trans n) as mod_equiv_rel.\n\nTheorem refl_test : forall m n : nat, n == n %% m.\nProof. reflexivity. Qed.\nPrint Assumptions refl_test.\n\nTheorem sym_trans_test : forall m n p q : nat, n == p %% m -> p == q %% m -> q == n %% m.\nProof. intros m n p q Hnp Hpq. symmetry. transitivity p; assumption. Qed.\nPrint Assumptions sym_trans_test.\n\nAdd Parametric Morphism n : Nat.mul with\n      signature (mod_equiv n) ==> (mod_equiv n) ==> (mod_equiv n) as mul_mor.\nProof.\n  intros.\n  induction H.\n  {\n    induction H0.\n    {\n      constructor.\n    }\n    {\n      easywrite (n * (m + n1) = n*m + n * n1).\n      eapply mod_equiv_trans.\n      eapply add_nm_congr.\n      eapply IHmod_equiv.\n    }\n    {\n      easywrite (n * (m + n2) = (n*m) + (n * n2)).\n      symmetry.\n      etransitivity.\n      eapply add_nm_congr.\n      symmetry.\n      assumption.      \n    }\n  }\n  {\n    easywrite ((m + n1) * x0 = (x0*m) + (n1 * x0)).\n    etransitivity.\n    eapply add_nm_congr.\n    eapply (IHmod_equiv H0).\n  }\n  {\n    easywrite ((m + n2) * y0 = (y0*m) + (n2 * y0)).\n    symmetry.\n    etransitivity.\n    eapply add_nm_congr.\n    symmetry.\n    eapply (IHmod_equiv H0).\n  }\nQed.\n\nAdd Parametric Morphism n : Nat.add with\n      signature (mod_equiv n) ==> (mod_equiv n) ==> (mod_equiv n) as add_mor.\n  intros x y Hxy u v Huv.\n  induction Hxy; try solve[constructor].\n  {\n    induction Huv.\n    {\n      constructor.\n    }\n    {\n      easywrite (n + (m + n1) = m + (n + n1)).\n      constructor.\n      assumption.\n    }\n    {\n      easywrite (n + (m + n2) = m + (n + n2)).\n      constructor.\n      assumption.\n    }\n  }\n  {\n    easywrite (m + n1 + u = m + (n1 + u)).\n    constructor.\n    firstorder.\n  }\n  {\n    easywrite (m + n2 + v = m + (n2 + v)).\n    constructor.\n    firstorder.\n  }\nQed.\n\nTheorem rewrite_test : forall m n p q : nat, p == q %% m -> n == p + q %% m ->\n                                      (n + (p + q)) * (n + (q + p)) == (q + p + n) * (p + q + n) %% m.\nProof. intros m n p q Hpq Hnpq. rewrite Hpq in Hnpq |- *. rewrite Hnpq. reflexivity. Qed.\nPrint Assumptions rewrite_test.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32925,"user_id":null,"body":"Require Import Preloaded.\n\nFrom Coq Require Import Arith Morphisms.\n\nLemma mod_inv_l : forall {m n1 n2}, m + n1 == n2 %% m -> n1 == n2 %% m.\nProof.\n  intros; remember (m + n1); revert n1 Heqn; induction H; intros.\n  - rewrite Heqn; repeat constructor.\n  - rewrite <- (plus_reg_l _ _ _ Heqn); exact H.\n  - constructor; exact (IHmod_equiv _ Heqn).\nQed.\n\nInstance mod_equiv_Equiv : forall n, Equivalence (mod_equiv n).\nProof.\n  intros m; constructor.\n  - intros x; constructor.\n  - intros x y H; induction H; constructor; exact IHmod_equiv.\n  - intros x y z H; induction H; intros.\n    + exact H.\n    + constructor; exact (IHmod_equiv H0).\n    + exact (IHmod_equiv (mod_inv_l H0)).\nQed.\n\nInstance mod_equiv_add (m : nat) : Proper (mod_equiv m ==> mod_equiv m ==> mod_equiv m) Nat.add.\nProof.\n  intros x y H x' y' H'; induction H.\n  - induction H'.\n    + reflexivity.\n    + rewrite plus_comm, <- plus_assoc; constructor; rewrite plus_comm; exact IHH'.\n    + rewrite (plus_comm _ (_ + _)), <- plus_assoc; constructor; rewrite (plus_comm n2); exact IHH'.\n  - rewrite <- plus_assoc; constructor; exact (IHmod_equiv H').\n  - rewrite <- plus_assoc; constructor; exact (IHmod_equiv H').\nQed.\n\nInstance mod_equiv_mul (m : nat) : Proper (mod_equiv m ==> mod_equiv m ==> mod_equiv m) Nat.mul.\nProof.\n  intros x y H x' y' H'; induction H.\n  - revert n; induction H'; intros.\n    + reflexivity.\n    + induction n.\n      * reflexivity.\n      * simpl; rewrite IHn, H', <- plus_assoc; constructor; reflexivity.\n    + induction n.\n      * reflexivity.\n      * simpl; rewrite <- IHn, <- H', <- (plus_assoc m); constructor; reflexivity.\n  - rewrite Nat.mul_add_distr_r, (IHmod_equiv H'); clear; induction x'.\n    + rewrite mult_comm; reflexivity.\n    + rewrite mult_comm; simpl; rewrite <- plus_assoc; constructor; rewrite mult_comm; exact IHx'.\n  - rewrite Nat.mul_add_distr_r, <- (IHmod_equiv H'); clear; induction y'.\n    + rewrite (mult_comm m); reflexivity.\n    + rewrite (mult_comm m); simpl; rewrite <- plus_assoc; constructor; rewrite (mult_comm y'); exact IHy'.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32926,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Arith Morphisms.\n\n(* Define anything you need in order to pass the tests! *)\n\nLemma mod_equiv_refl z : Reflexive (mod_equiv z).\nProof.\n  intros x. constructor.\nQed.\n\nLemma mod_equiv_sym z : Symmetric (mod_equiv z).\nProof.\n  intros x y H. induction H.\n  - constructor.\n  - constructor. assumption.\n  - constructor. assumption.\nQed.\n\nFact mod_test : 7 == 15 %% 4 -> 7 == 11 %% 4.\nProof.\n  intros. inversion H; subst.\n  inversion H2; subst. apply mod_intro_plus_l in H4. assumption.\n  assumption.\nQed.\n\nLemma mod_elim_plus_l : forall x y z, z + x == y %% z -> x == y %% z.\nProof.\n  intros. remember (z + x) as a. induction H.\n  - subst. do 2 constructor.\n  - apply Nat.add_cancel_l in Heqa. subst. assumption.\n  - subst. constructor. auto.\nQed.\n\nLemma mod_equiv_trans z : Transitive (mod_equiv z).\nProof.\n  intros x1 x2 x3 H1 H2.\n  induction H1.\n  - assumption.\n  - constructor. auto.\n  - apply mod_elim_plus_l in H2. auto.\nQed.\n\nInstance mod_equiv_equiv z : Equivalence (mod_equiv z).\nProof.\n  split.\n  - apply mod_equiv_refl.\n  - apply mod_equiv_sym.\n  - apply mod_equiv_trans.\nQed.\n\nLemma mod_equiv_add_compat_l : forall x y z a,\n  x == y %% z -> a + x == a + y %% z.\nProof.\n  intros. induction H.\n  - constructor.\n  - rewrite Nat.add_assoc. rewrite (Nat.add_comm _ m).\n    rewrite <- Nat.add_assoc. constructor. assumption.\n  - rewrite Nat.add_assoc. rewrite (Nat.add_comm _ m).\n    rewrite <- Nat.add_assoc. constructor. assumption.\nQed.\n\nInstance mod_equiv_add_compat z :\n  Proper ((mod_equiv z) ==> (mod_equiv z) ==> (mod_equiv z)) Nat.add.\nProof.\n  intros x1 x2 x_eq y1 y2 y_eq.\n  induction x_eq.\n  - apply mod_equiv_add_compat_l. assumption.\n  - rewrite <- Nat.add_assoc. constructor. auto.\n  - rewrite <- Nat.add_assoc. constructor. auto.\nQed.\n\nLemma mod_equiv_mul_compat_l : forall x y z a,\n  x == y %% z -> a * x == a * y %% z.\nProof.\n  intros. induction a.\n  - constructor.\n  - simpl. rewrite IHa, H. reflexivity.\nQed.\n\nInstance mod_equiv_mul_compat z :\n  Proper ((mod_equiv z) ==> (mod_equiv z) ==> (mod_equiv z)) Nat.mul.\nProof.\n  intros x1 x2 x_eq y1 y2 y_eq. induction x_eq.\n  - apply mod_equiv_mul_compat_l. assumption.\n  - rewrite Nat.mul_add_distr_r. rewrite <- Nat.add_0_l.\n    apply mod_equiv_add_compat; auto.\n    rewrite Nat.mul_comm. rewrite <- (Nat.mul_0_r y1).\n    apply mod_equiv_mul_compat_l.\n    (* occurrence from right to left ?? *)\n    rewrite <- (Nat.add_0_r m) at 2.\n    do 2 constructor.\n  - rewrite Nat.mul_add_distr_r. rewrite <- (Nat.add_0_l (n1 * y1)).\n    apply mod_equiv_add_compat; auto.\n    rewrite Nat.mul_comm. rewrite <- (Nat.mul_0_r y2).\n    apply mod_equiv_mul_compat_l.\n    (* occurrence from right to left ?? *)\n    rewrite <- (Nat.add_0_r m) at 2.\n    do 2 constructor.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32927,"user_id":null,"body":"Require Import Preloaded.\nFrom Coq Require Import Setoid Arith.\n\nLemma mod_intro_sym m n1 n2 : mod_equiv m n1 n2 -> mod_equiv m n2 n1.\nProof.\n  intro H; induction H.\n  - constructor.\n  - constructor; assumption.\n  - constructor; assumption.\nQed.\n\nLemma mod_intro_plus_l_inv m n1 n2 n1' :\n  n1 == n2 %% m ->\n  n1 = m + n1' ->\n  n1' == n2 %% m.\nProof.\n  intro H.\n  generalize n1'; clear n1'.\n  induction H.\n  - intros; subst n.\n    constructor.\n    constructor.\n  - intros n1' He.\n    apply plus_reg_l in He.\n    subst.\n    assumption.\n  - intros n1' He.\n    constructor.\n    auto.\nQed.\n\nLemma mod_intro_trans m n1 n2 n3 : mod_equiv m n1 n2 -> mod_equiv m n2 n3 ->\n                                   mod_equiv m n1 n3.\nProof.\n  intros H1 H2; induction H1.\n  - assumption.\n  - constructor.\n    apply IHmod_equiv.\n    assumption.\n  - apply IHmod_equiv.\n    refine (mod_intro_plus_l_inv _ _ _ _ _ eq_refl).\n    assumption.\nQed.\n\nAdd Parametric Relation (m : nat) : nat (mod_equiv m)\nreflexivity proved by (mod_intro_same m)\nsymmetry proved by (mod_intro_sym m)\ntransitivity proved by (mod_intro_trans m) as mod_equiv_rel.\n\nAdd Parametric Morphism (m : nat) :\n  Init.Nat.add\n    with signature mod_equiv m ==> mod_equiv m ==> mod_equiv m\n      as mod_equiv_add.\nProof.\n  intros n1 n2 H12 n3 n4 H34.\n  induction H12.\n  - induction H34.\n    + reflexivity.\n    + transitivity (m + (n + n1)).\n      * rewrite Nat.add_assoc.\n        rewrite Nat.add_assoc.\n        rewrite (Nat.add_comm n m).\n        reflexivity.\n      * constructor.\n        assumption.\n    + transitivity (m + (n + n2)).\n      * constructor.\n        assumption.\n      * rewrite Nat.add_assoc.\n        rewrite Nat.add_assoc.\n        rewrite (Nat.add_comm n m).\n        reflexivity.\n  - rewrite <- Nat.add_assoc.\n    constructor.\n    auto.\n  - rewrite <- Nat.add_assoc.\n    constructor.\n    auto.\nQed.\n\nLemma mod_equiv_mul_zero m n : n * m == 0 %% m.\nProof.\n  induction n.\n  - reflexivity.\n  - simpl.\n    constructor.\n    assumption.\nQed.\n\nAdd Parametric Morphism (m : nat) :\n  Init.Nat.mul\n    with signature mod_equiv m ==> mod_equiv m ==> mod_equiv m\n      as mod_equiv_mul.\nProof.\n  intros n1 n2 H12 n3 n4 H34.\n  induction H12.\n  - induction n.\n    + reflexivity.\n    + simpl.\n      rewrite IHn.\n      rewrite H34.\n      reflexivity.\n  - rewrite Nat.mul_add_distr_r.\n    specialize (IHmod_equiv H34).\n    rewrite IHmod_equiv.\n    rewrite Nat.mul_comm.\n    rewrite mod_equiv_mul_zero.\n    reflexivity.\n  - rewrite Nat.mul_add_distr_r.\n    specialize (IHmod_equiv H34).\n    rewrite IHmod_equiv.\n    rewrite (Nat.mul_comm m n4).\n    rewrite (mod_equiv_mul_zero m).\n    reflexivity.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32928,"user_id":null,"body":"Require Import Preloaded.\n\nRequire Import Lia.\n\nTheorem mod_lback : forall m n1 n2, mod_equiv m (m + n1) n2 -> mod_equiv m n1 n2.\nProof. intros;remember (m + n1);generalize dependent n1;induction H;intros;subst.\n* do 2 constructor.\n* assert (n1=n0);[lia|];subst. apply H.\n* constructor. apply IHmod_equiv. auto.\nQed.\n\nRequire Import Setoid.\n\nLemma mod_refl : forall z, reflexive _ (mod_equiv z).\nProof. unfold reflexive. apply mod_intro_same. Qed.\nLemma mod_sym : forall z, symmetric _ (mod_equiv z).\nProof. unfold symmetric;intros. induction H;constructor;assumption. Qed.\nLemma mod_trans : forall z, transitive _ (mod_equiv z).\nProof. unfold transitive.\n intros z x y w H;generalize dependent w;induction H;intros.\n* assumption.\n* constructor. apply IHmod_equiv. assumption.\n* apply IHmod_equiv. apply mod_lback. assumption.\nQed.\n\nAdd Parametric Relation m : nat (mod_equiv m)\n  reflexivity proved by (mod_refl m)\n  symmetry proved by (mod_sym m)\n  transitivity proved by (mod_trans m)\n  as mod_rel.\n\nRequire Import Arith.\n\nLemma mod_to_divlike : forall i m n, mod_equiv i m n -> \n ((n <= m -> exists k, m = n + k*i) \/\\\n  (m <= n -> exists k, n = m + k*i)).\nProof. intros i m n H;induction H;intros.\n + split;intros;exists 0;lia.\n + destruct IHmod_equiv. destruct m;simpl.\n  * split;assumption.\n  * destruct (le_lt_dec n1 n2).\n   - destruct (H1 l). split;intros.\n    ++ destruct x;[ exists 1| exists 0]; lia.\n    ++ exists (x - 1). destruct x;[lia|]. simpl.\n       rewrite <- minus_n_O. lia.\n   - destruct H0;[lia|]. split;intros.\n    ++ exists (1+x). lia.\n    ++ lia.\n + destruct IHmod_equiv. destruct m;simpl.\n  * split;assumption.\n  * destruct (le_lt_dec n1 n2).\n   - destruct (H1 l). split;intros.\n    ++ lia.\n    ++ exists (1+x). lia.\n   - destruct H0;[lia|]. split;intros.\n    ++ exists (x - 1). destruct x;[lia|]. simpl.\n       rewrite <- minus_n_O. lia.\n    ++ destruct x;[ exists 1| exists 0]; lia.\nQed.\n\nLemma divides_modk : forall k n i, mod_equiv i n (n+(k*i)).\nProof. induction k;intros.\n * simpl. rewrite plus_0_r. constructor.\n * replace (n + S k * i) with (i + (n + k * i));[|lia].\n  constructor. apply IHk.\nQed.\n\nAdd Parametric Morphism m : plus\n  with signature (mod_equiv m) ==> (mod_equiv m) ==> (mod_equiv m) as plus_mor.\nProof. intros.\ndestruct (mod_to_divlike _ _ _ H);\ndestruct (mod_to_divlike _ _ _ H0).\ndestruct (le_lt_dec y x).\n* destruct (H1 l). destruct (le_lt_dec y0 x0).\n + destruct (H3 l0);subst.\n   replace (y + x1 * m + (y0 + x2 * m)) with ((y+y0)+((x1+x2)*m));[|lia].\n   symmetry. apply divides_modk.\n + destruct H4;[lia|];subst.\n   replace (y + x1 * m + x0) with ((y+x0) + (x1 * m));[|lia].\n   replace (y + (x0 + x2 * m)) with ((y+x0) + (x2 * m));[|lia].\n   eapply mod_trans;[|apply divides_modk]. symmetry;apply divides_modk.\n* destruct H2;[lia|]. destruct (le_lt_dec y0 x0).\n + destruct (H3 l0);subst.\n   replace (x + (y0 + x2 * m)) with ((x+y0) + (x2 * m));[|lia].\n   replace (x + x1 * m + y0) with ((x+y0) + (x1 * m));[|lia].\n   eapply mod_trans;[|apply divides_modk]. symmetry;apply divides_modk.\n + destruct H4;[lia|];subst.\n   replace (x + x1 * m + (x0 + x2 * m)) with ((x+x0)+((x1+x2)*m));[|lia].\n   apply divides_modk.\nQed.\n\nAdd Parametric Morphism m : mult\n with signature (mod_equiv m) ==> (mod_equiv m) ==> (mod_equiv m) as mult_mor.\nProof. intros.\ndestruct (mod_to_divlike _ _ _ H);\ndestruct (mod_to_divlike _ _ _ H0).\ndestruct (le_lt_dec y x).\n* destruct (H1 l). destruct (le_lt_dec y0 x0).\n + destruct (H3 l0);subst.\n   replace ((y + x1 * m) * (y0 + x2 * m)) with \n    ((y*y0)+((y*x2 + x1*y0 + x1*x2*m) * m));[|lia].\n   symmetry. apply divides_modk.\n + destruct H4;[lia|];subst.\n   replace ((y + x1 * m) * x0) with ((y*x0) + ((x0*x1) * m));[|lia].\n   replace (y * (x0 + x2 * m)) with ((y*x0) + ((y*x2) * m));[|lia].\n   eapply mod_trans;[|apply divides_modk]. symmetry;apply divides_modk.\n* destruct H2;[lia|]. destruct (le_lt_dec y0 x0).\n + destruct (H3 l0);subst.\n   replace (x * (y0 + x2 * m)) with ((x*y0) + ((x*x2) * m));[|lia].\n   replace ((x + x1 * m) * y0) with ((x*y0) + ((y0*x1) * m));[|lia].\n   eapply mod_trans;[|apply divides_modk]. symmetry;apply divides_modk.\n + destruct H4;[lia|];subst.\n   replace ((x + x1 * m) * (x0 + x2 * m)) with \n    ((x*x0)+((x*x2 + x1*x0 + x1*x2*m) * m));[|lia].\n   apply divides_modk.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32929,"user_id":null,"body":"Require Import Preloaded.\n\nRequire Import Relation_Definitions Setoid.\nRequire Import Lia.\n\nInstance id (n:nat): @Equivalence nat (mod_equiv n).\nProof.\nsplit.\n- constructor.\n- intros x y H.\n  induction H;now constructor.\n- intros x y z H1 H2.\n  induction H1 in z, H2 |- *;trivial;try constructor.\n  + now apply IHmod_equiv in H2.\n  + apply IHmod_equiv.\n    clear n1 H1 IHmod_equiv.\n    remember (m+n2).\n    induction H2;subst.\n    * do 2 constructor.\n    * now replace n2 with n1 by lia.\n    * constructor.\n      now apply IHmod_equiv.\nDefined.\n\nRequire Import Morphisms.\nRequire Import Nat.\nRequire Import PeanoNat.\n\nInstance mod_equiv_plus (n:nat) :\n         Proper (mod_equiv n ==> mod_equiv n ==> mod_equiv n) (plus).\nProof.\n  simpl_relation.\n  induction H.\n  - induction H0.\n    + constructor.\n    + rewrite Nat.add_shuffle3.\n      now constructor.\n    + rewrite Nat.add_shuffle3.\n      now constructor.\n  - rewrite <- Nat.add_assoc. \n    constructor.\n    now apply IHmod_equiv.\n  - rewrite <- Nat.add_assoc. \n    constructor.\n    now apply IHmod_equiv.\nQed.\n\nLemma zero_equiv m k: m*k == 0 %% m.\nProof.\n  rewrite Nat.mul_comm.\n  induction k;now constructor.\nQed.\n\nInstance mod_equiv_mul (n:nat) :\n         Proper (mod_equiv n ==> mod_equiv n ==> mod_equiv n) (mul).\nProof.\n  simpl_relation.\n  induction H.\n  - induction H0.\n    + constructor.\n    + now rewrite Nat.mul_add_distr_l, Nat.mul_comm, zero_equiv, IHmod_equiv.\n    + symmetry. now rewrite Nat.mul_add_distr_l, Nat.mul_comm, zero_equiv, IHmod_equiv.\n  - rewrite Nat.mul_add_distr_r.\n    rewrite IHmod_equiv.\n    2: apply H0.\n    change (n2*y0) with (0+n2*y0) at 2.\n    rewrite mod_equiv_plus.\n    2: apply zero_equiv.\n    1-2: reflexivity.\n  - rewrite Nat.mul_add_distr_r.\n    rewrite IHmod_equiv;trivial.\n    rewrite mod_equiv_plus.\n    2: apply zero_equiv.\n    1-2: cbn;reflexivity.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5cf268e10fd3cb0022190bb8":[{"id":32930,"user_id":489,"body":"Require Import Preloaded.\n\nOpen Scope hoare_spec_scope.\n\nFrom Coq Require Import Arith Lia.\nImport Nat.\n\nLemma eqb_diff : forall n m p, S (n + m) = p -> (m =? p) = false.\nProof. induction m; intros.\n  - subst. auto.\n  - subst. simpl. auto. Qed.\n\nTactic Notation \"inv_while\" hyp(H) \"(\" \"false_case\" ident(Hbev_f) ident(Hend) \")\"\n  \"(\" \"true_case\" ident(st_mid) ident(Hbev_t) ident(Honce) ident(Hrest) \")\" :=\n  let _b := fresh \"b\"\n  with _c := fresh \"c\"\n  with _st_begin := fresh \"st_begin\"\n  with _st_end := fresh \"st_end\"\n  with _Hb := fresh \"Hb\"\n  with _Hc := fresh \"Hc\"\n  with _Hbegin := fresh \"Hbegin\"\n  with _Hend := fresh \"Hend\" in\n  inversion H as [ | | | | |\n  _b _st_begin _c Hbev_f [_Hb _Hc] _Hbegin Hend |\n  _st_begin st_mid _st_end _b _c Hbev_t Honce Hrest [_Hb _Hc] _Hbegin _Hend\n  ]; subst _b _c _st_begin; try subst _st_end.\n\nTactic Notation \"inv_seq\" hyp(H) \"(\" ident(st_mid) ident(Hcev1) ident(Hcev2) \")\" :=\n  let _cc1 := fresh \"cc1\"\n  with _cc2 := fresh \"cc2\"\n  with _st_begin := fresh \"st_begin\"\n  with _st_end := fresh \"st_end\"\n  with _Hcc1 := fresh \"Hcc1\"\n  with _Hcc2 := fresh \"Hcc2\"\n  with _Hst_begin := fresh \"Hst_begin\"\n  with _Hst_end := fresh \"Hst_end\" in\n  inversion H as [ | |\n  _cc1 _cc2 _st_begin st_mid _st_end Hcev1 Hcev2 [_Hcc1 _Hcc2] _Hst_begin _Hst_end\n  | | | | ]; subst _cc1 _cc2 _st_begin _st_end.\n\nTactic Notation \"inv_ass\" hyp(H) \"(\" ident(Hst_end) \")\" :=\n  let _st_begin := fresh \"st_begin\"\n  with _a := fresh \"a\"\n  with _a_val := fresh \"a_val\"\n  with _var := fresh \"var\"\n  with _Haev := fresh \"Haev\"\n  with _Hvar := fresh \"Hvar\"\n  with _Ha := fresh \"Ha\"\n  with _Hst_begin := fresh \"Hst_begin\" in\n  inversion H as [ |\n  _st_begin _a _a_val _var _Haev [_Hvar _Ha] _Hst_begin Hst_end\n  | | | | | ]; subst _st_begin _a _a_val _var.\n\nTheorem square_gen : forall q n m p,\n  {{ fun st => st X = n \/\\ st Y = m \/\\ st W = p \/\\ q + p = n }}\n    WHILE ~(W = X) DO\n      Y ::= Y + X;;\n      W ::= W + 1\n    END\n  {{ fun st => st X = n \/\\ st Y = q * n + m \/\\ st W = n }}.\nProof. unfold hoare_triple.\n  induction q; intros n m p st st_end H (HX & HY & HW & Hpn);\n  inv_while H (false_case Hbev Hend) (true_case st_mid Hbev Honce Hrest).\n  - (* q = 0, while false *) \n    subst st_end. repeat split; lia.\n  - (* q = 0, while true *)\n    subst. simpl in Hpn, Hbev. rewrite Hpn in Hbev. rewrite eqb_refl in Hbev. discriminate.\n  - (* q > 0, while false *)\n    subst. simpl in Hpn, Hbev. apply eqb_diff in Hpn. rewrite Hpn in Hbev. discriminate.\n  - (* q > 0, while true *)\n    inv_seq Honce (st_mid2 Hcev1 Hcev2).\n    inv_ass Hcev1 (Hst_end). subst st_mid2.\n    inv_ass Hcev2 (Hst_end).\n    assert (q + S p = n) as Hpn' by lia.\n    set (final := IHq n (n + m) (S p) st_mid st_end Hrest).\n    replace (S q * n + m) with (q * n + (n + m)) by lia. apply final.\n    subst. unfold t_update. simpl. repeat split; lia. Qed.\n\nTheorem square : forall n m,\n  {{ fun st => st X = n \/\\ st Y = m }}\n    W ::= 0;;\n    WHILE ~(W = X) DO\n      Y ::= Y + X;;\n      W ::= W + 1\n    END\n  {{ fun st => st X = n \/\\ st Y = n * n + m }}.\nProof. unfold hoare_triple. intros n m st st_end H.\n  inv_seq H (st_mid Hcev1 Hcev2). inv_ass Hcev1 (Hst_end). simpl in *. subst.\n  set (gen := square_gen n n m 0 (W !-> 0; st) st_end Hcev2).\n  cbv [t_update] in gen. simpl in gen. intuition lia. Qed.\n\nArguments mul n m : simpl never.\nArguments add n m : simpl never.\n\nTheorem sum_squares_gen : forall n m,\n  {{ fun st => st X = n \/\\ st Y = m }}\n  WHILE ~(X = 0) DO\n    W ::= 0;;\n    WHILE ~(W = X) DO\n      Y ::= Y + X;;\n      W ::= W + 1\n    END;;\n    X ::= X - 1\n  END\n  {{ fun st => 6 * st Y = 6 * m + n * (n + 1) * (2 * n + 1) }}.\nProof. unfold hoare_triple.\n  induction n; intros m st st_end H (HX & HY);\n  inv_while H (false_case Hbev Hend) (true_case st_mid Hbev Honce Hrest); subst.\n  - (* n = 0, while false *) lia.\n  - (* n = 0, while true *)\n    simpl in Hbev. rewrite HX in Hbev. discriminate.\n  - (* n > 0, while false *)\n    simpl in Hbev. rewrite HX in Hbev. discriminate.\n  - (* n > 0, while true *)\n    inv_seq Honce (st_mid1 Hcev1 Hcev2).\n    inv_seq Hcev2 (st_mid2 Hcev3 Hcev4).\n    set (Hsq := E_Seq _ _ _ _ _ Hcev1 Hcev3).\n    set (HsqH := square (S n) (st Y) st st_mid2 Hsq). simpl in HsqH.\n    assert (st_mid2 X = S n \/\\ st_mid2 Y = S n * S n + st Y) as HmidXY. { intuition. }\n    destruct HmidXY as (HmidX & HmidY).\n    inv_ass Hcev4 (Hst_mid). simpl in Hst_mid. subst.\n    set (Hfinal := IHn (S n * S n + st Y) _ _ Hrest).\n    cbv [t_update] in Hfinal. simpl in Hfinal. rewrite HmidX in Hfinal. lia. Qed.\n\nTheorem sum_squares_correct : forall n,\n  {{ fun st => st X = n }}\n  Y ::= 0;;\n  WHILE ~(X = 0) DO\n    W ::= 0;;\n    WHILE ~(W = X) DO\n      Y ::= Y + X;;\n      W ::= W + 1\n    END;;\n    X ::= X - 1\n  END\n  {{ fun st => 6 * st Y = n * (n + 1) * (2 * n + 1) }}.\nProof. unfold hoare_triple. intros n st st_end H HX.\n  inv_seq H (st_mid Hcev1 Hcev2). inv_ass Hcev1 (Hst_mid). simpl in Hst_mid; subst.\n  set (Hssq := sum_squares_gen (st X) 0 _ _ Hcev2).\n  cbv [t_update] in Hssq. simpl in Hssq. lia. Qed.\n\nClose Scope hoare_spec_scope.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32931,"user_id":null,"body":"Require Import Preloaded.\n\nOpen Scope hoare_spec_scope.\n\nRequire Import Coq.Program.Equality Lia Nat Arith.\n\nTheorem while_loop {b c} P :\n  {{fun st => P st \/\\ beval st b = true }} c {{ P }} ->\n  {{ P }} WHILE b DO c END {{fun st => P st \/\\ beval st b = false }}.\nProof.\n  intros Hc st st' Hs.\n  dependent induction Hs.\n  - easy.\n  - intros Hs.\n    clear IHHs1.\n    eapply IHHs2 ; now eauto.\nQed.\n\nTheorem triple_impl {c} {P Q : state -> Prop} (P' Q' : state -> Prop) :\n  (forall st, P' st -> P st) ->\n  (forall st, Q st -> Q' st) ->\n  {{ P }} c {{ Q }} ->\n  {{ P' }} c {{ Q' }}.\nProof.\n  intros. intro. intros. eauto.\nQed.\n\nTheorem sum_one_correct : forall nX nY,\n  {{ fun st => st X = nX \/\\ st Y = nY \/\\ st W = 0 }}\n  WHILE ~(W = X) DO\n    Y ::= Y + X;;\n    W ::= W + 1\n  END\n  {{ fun st => st X = nX \/\\ st Y = nY + nX*nX }}.\nProof.\n  intros nX nY.\n  eapply triple_impl.\n  3: eapply (while_loop (fun st => st X = nX \/\\ st Y = nY + (st W)*(st X))).\n  - intros ? [? []].\n    lia.\n  - intros ? [[] ?].\n    cbn in *.\n    destruct (Nat.eqb_spec (st W) (st X)) ; try easy.\n    lia.\n  - econstructor.\n    + destruct H0 as [[]].\n      inversion H ; subst ; clear H.\n      inversion H5 ; subst ; clear H5.\n      inversion H8 ; subst ; clear H8.\n      now cbn.\n    + destruct H0 as [[]].\n      inversion H ; subst ; clear H.\n      inversion H5 ; subst ; clear H5.\n      inversion H8 ; subst ; clear H8.\n      cbn.\n      lia.\nQed.\n\nDefinition sum_squ n := n*(n+1)*(2*n + 1).\n\nLemma sum_squ_S n : sum_squ (S n) = 6*(S n)*(S n) + sum_squ n.\nProof.\n  intros.\n  unfold sum_squ.\n  ring.\nQed.\n\nTheorem sum_squares_correct : forall n,\n  {{ fun st => st X = n }}\n  Y ::= 0;;\n  WHILE ~(X = 0) DO\n    W ::= 0;;\n    WHILE ~(W = X) DO\n      Y ::= Y + X;;\n      W ::= W + 1\n    END;;\n    X ::= X - 1\n  END\n  {{ fun st => 6 * st Y = n * (n + 1) * (2 * n + 1) }}.\nProof.\n  intros n.\n  fold (sum_squ n).\n  intros st st' p Hst.\n  inversion p ; subst ; clear p.\n  inversion H1; subst; clear H1.\n  cbn in H4.\n  set (P := fun st'' => sum_squ (st'' X) + 6*st'' Y = sum_squ (st X)).\n  eapply (triple_impl (fun st'' => st'' Y = 0 \/\\ st'' X = st X)) in H4.\n  4: eapply (while_loop P).\n  - pattern st'.\n    eapply H4.\n    easy.\n  - unfold P.\n    intros ? [-> ->].\n    lia.\n  - unfold P.\n    intros ? [].\n    cbn in H0.\n    destruct (Nat.eqb_spec (st0 X) 0) ; try easy.\n    rewrite e in * ; cbn in *.\n    lia.\n  - intros ? ? H.\n    inversion H ; subst ; clear H.\n    inversion H2 ; subst ; clear H2.\n    inversion H6 ; subst ; clear H6.\n    inversion H5 ; subst ; clear H5.\n    cbn in H1.\n    apply (sum_one_correct (st0 X) (st0 Y)) in H1.\n    unfold P.\n    cbn -[mul] in H1 |- *.\n    destruct H1 as [-> ->].\n    1: easy.\n    intros [<- ].\n    destruct (Nat.eqb_spec (st0 X) 0) ; try easy.\n    replace (st0 X) with (S (st0 X - 1)) at -1 by lia.\n    rewrite sum_squ_S.\n    ring.\nQed.\n\nClose Scope hoare_spec_scope.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32932,"user_id":null,"body":"Require Import Preloaded Arith.\n\nOpen Scope hoare_spec_scope.\n\nLtac use x := inversion x; subst; clear x.\n\nLemma inner_loop : forall nx ny nw, \n  {{ fun st => st X = nx + nw \/\\ st Y = ny \/\\ st W = nw }}\n  WHILE ~(W = X) DO\n    Y ::= Y + X;;\n    W ::= W + 1\n  END\n  {{ fun st => st X = nx + nw \/\\ st Y = ny + (nx + nw) * nx }}.\nProof.\n  induction nx; intros ny nw st st' Hc.\n  - use Hc; intros [HX [HY HW]].\n    + split; [easy|rewrite HY; ring].\n    + contradict H1; simpl; rewrite HX, HW; simpl; now rewrite Nat.eqb_refl.\n  - use Hc.\n    + intros [HX [_ HW]]; contradict H3; simpl; rewrite HX, HW; simpl.\n      cut (nw =? S (nx + nw) = false); [intros R; now rewrite R|].\n      apply Nat.eqb_neq, Nat.lt_neq, le_n_S, le_plus_r.\n    + use H2; use H3; use H7.\n      apply IHnx with (ny + nx + S nw) (S nw) in H5.\n      replace (ny + (S nx + nw) * S nx) with (ny + nx + S nw + (nx + S nw) * nx); [|ring].\n      replace (S nx + nw) with (nx + S nw); [|ring].\n      intros [HX [HY HW]]; apply H5.\n      unfold t_update; simpl; rewrite HX, HY, HW; repeat split; ring.\nQed.\n\nLemma outer_loop : forall nx ny,\n  {{ fun st => st X = nx \/\\ st Y = ny }}\n  WHILE ~(X = 0) DO\n    W ::= 0;;\n    WHILE ~(W = X) DO\n      Y ::= Y + X;;\n      W ::= W + 1\n    END;;\n    X ::= X - 1\n  END\n  {{ fun st => 6 * st Y = 6 * ny + nx * (nx + 1) * (2 * nx + 1) }}.\nProof.\n  induction nx; intros ny st st' Hc.\n  - use Hc; intros [HX HY].\n    + rewrite HY; ring.\n    + contradict H1; simpl; now rewrite HX.\n  - use Hc.\n    + intros [HX _]; contradict H3; simpl; rewrite HX.\n      cut (S nx =? 0 = false); [intros R; rewrite R|apply Nat.eqb_neq]; easy.\n    + use H2; use H3; use H7; use H6.\n      apply inner_loop with (S nx) ny 0 in H2.\n      apply IHnx with (ny + S nx * S nx) in H5.\n      replace (6 * ny + S nx * (S nx + 1) * (2 * S nx + 1)) with (6 * (ny + S nx * S nx) + nx * (nx + 1) * (2 * nx + 1)); [|ring].\n      intros [HX HY]; apply H5.\n      unfold t_update; simpl.\n      cut (st'1 X = S nx + 0 \/\\ st'1 Y = ny + (S nx + 0) * S nx); [intros [R1 R2]; rewrite R1, R2; split; [destruct nx; simpl|]; ring|].\n      apply H2; unfold t_update; simpl; rewrite HX, HY; repeat split; ring.\nQed.\n\nTheorem sum_squares_correct : forall n,\n  {{ fun st => st X = n }}\n  Y ::= 0;;\n  WHILE ~(X = 0) DO\n    W ::= 0;;\n    WHILE ~(W = X) DO\n      Y ::= Y + X;;\n      W ::= W + 1\n    END;;\n    X ::= X - 1\n  END\n  {{ fun st => 6 * st Y = n * (n + 1) * (2 * n + 1) }}.\nProof.\n  intros n st st' Hc; use Hc; use H1.\n  apply outer_loop with n 0 in H4.\n  intros HX; now apply H4.\nQed.\n\nClose Scope hoare_spec_scope.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32933,"user_id":null,"body":"Require Import Preloaded.\n(*** i copied this code, i just want to see code on COQ ***)\nOpen Scope hoare_spec_scope.\n\nFrom Coq Require Import Arith Lia.\nImport Nat.\n\nLemma eqb_diff : forall n m p, S (n + m) = p -> (m =? p) = false.\nProof. induction m; intros.\n  - subst. auto.\n  - subst. simpl. auto. Qed.\n\nTactic Notation \"inv_while\" hyp(H) \"(\" \"false_case\" ident(Hbev_f) ident(Hend) \")\"\n  \"(\" \"true_case\" ident(st_mid) ident(Hbev_t) ident(Honce) ident(Hrest) \")\" :=\n  let _b := fresh \"b\"\n  with _c := fresh \"c\"\n  with _st_begin := fresh \"st_begin\"\n  with _st_end := fresh \"st_end\"\n  with _Hb := fresh \"Hb\"\n  with _Hc := fresh \"Hc\"\n  with _Hbegin := fresh \"Hbegin\"\n  with _Hend := fresh \"Hend\" in\n  inversion H as [ | | | | |\n  _b _st_begin _c Hbev_f [_Hb _Hc] _Hbegin Hend |\n  _st_begin st_mid _st_end _b _c Hbev_t Honce Hrest [_Hb _Hc] _Hbegin _Hend\n  ]; subst _b _c _st_begin; try subst _st_end.\n\nTactic Notation \"inv_seq\" hyp(H) \"(\" ident(st_mid) ident(Hcev1) ident(Hcev2) \")\" :=\n  let _cc1 := fresh \"cc1\"\n  with _cc2 := fresh \"cc2\"\n  with _st_begin := fresh \"st_begin\"\n  with _st_end := fresh \"st_end\"\n  with _Hcc1 := fresh \"Hcc1\"\n  with _Hcc2 := fresh \"Hcc2\"\n  with _Hst_begin := fresh \"Hst_begin\"\n  with _Hst_end := fresh \"Hst_end\" in\n  inversion H as [ | |\n  _cc1 _cc2 _st_begin st_mid _st_end Hcev1 Hcev2 [_Hcc1 _Hcc2] _Hst_begin _Hst_end\n  | | | | ]; subst _cc1 _cc2 _st_begin _st_end.\n\nTactic Notation \"inv_ass\" hyp(H) \"(\" ident(Hst_end) \")\" :=\n  let _st_begin := fresh \"st_begin\"\n  with _a := fresh \"a\"\n  with _a_val := fresh \"a_val\"\n  with _var := fresh \"var\"\n  with _Haev := fresh \"Haev\"\n  with _Hvar := fresh \"Hvar\"\n  with _Ha := fresh \"Ha\"\n  with _Hst_begin := fresh \"Hst_begin\" in\n  inversion H as [ |\n  _st_begin _a _a_val _var _Haev [_Hvar _Ha] _Hst_begin Hst_end\n  | | | | | ]; subst _st_begin _a _a_val _var.\n\nTheorem square_gen : forall q n m p,\n  {{ fun st => st X = n \/\\ st Y = m \/\\ st W = p \/\\ q + p = n }}\n    WHILE ~(W = X) DO\n      Y ::= Y + X;;\n      W ::= W + 1\n    END\n  {{ fun st => st X = n \/\\ st Y = q * n + m \/\\ st W = n }}.\nProof. unfold hoare_triple.\n  induction q; intros n m p st st_end H (HX & HY & HW & Hpn);\n  inv_while H (false_case Hbev Hend) (true_case st_mid Hbev Honce Hrest).\n  - (* q = 0, while false *) \n    subst st_end. repeat split; lia.\n  - (* q = 0, while true *)\n    subst. simpl in Hpn, Hbev. rewrite Hpn in Hbev. rewrite eqb_refl in Hbev. discriminate.\n  - (* q > 0, while false *)\n    subst. simpl in Hpn, Hbev. apply eqb_diff in Hpn. rewrite Hpn in Hbev. discriminate.\n  - (* q > 0, while true *)\n    inv_seq Honce (st_mid2 Hcev1 Hcev2).\n    inv_ass Hcev1 (Hst_end). subst st_mid2.\n    inv_ass Hcev2 (Hst_end).\n    assert (q + S p = n) as Hpn' by lia.\n    set (final := IHq n (n + m) (S p) st_mid st_end Hrest).\n    replace (S q * n + m) with (q * n + (n + m)) by lia. apply final.\n    subst. unfold t_update. simpl. repeat split; lia. Qed.\n\nTheorem square : forall n m,\n  {{ fun st => st X = n \/\\ st Y = m }}\n    W ::= 0;;\n    WHILE ~(W = X) DO\n      Y ::= Y + X;;\n      W ::= W + 1\n    END\n  {{ fun st => st X = n \/\\ st Y = n * n + m }}.\nProof. unfold hoare_triple. intros n m st st_end H.\n  inv_seq H (st_mid Hcev1 Hcev2). inv_ass Hcev1 (Hst_end). simpl in *. subst.\n  set (gen := square_gen n n m 0 (W !-> 0; st) st_end Hcev2).\n  cbv [t_update] in gen. simpl in gen. intuition lia. Qed.\n\nArguments mul n m : simpl never.\nArguments add n m : simpl never.\n\nTheorem sum_squares_gen : forall n m,\n  {{ fun st => st X = n \/\\ st Y = m }}\n  WHILE ~(X = 0) DO\n    W ::= 0;;\n    WHILE ~(W = X) DO\n      Y ::= Y + X;;\n      W ::= W + 1\n    END;;\n    X ::= X - 1\n  END\n  {{ fun st => 6 * st Y = 6 * m + n * (n + 1) * (2 * n + 1) }}.\nProof. unfold hoare_triple.\n  induction n; intros m st st_end H (HX & HY);\n  inv_while H (false_case Hbev Hend) (true_case st_mid Hbev Honce Hrest); subst.\n  - (* n = 0, while false *) lia.\n  - (* n = 0, while true *)\n    simpl in Hbev. rewrite HX in Hbev. discriminate.\n  - (* n > 0, while false *)\n    simpl in Hbev. rewrite HX in Hbev. discriminate.\n  - (* n > 0, while true *)\n    inv_seq Honce (st_mid1 Hcev1 Hcev2).\n    inv_seq Hcev2 (st_mid2 Hcev3 Hcev4).\n    set (Hsq := E_Seq _ _ _ _ _ Hcev1 Hcev3).\n    set (HsqH := square (S n) (st Y) st st_mid2 Hsq). simpl in HsqH.\n    assert (st_mid2 X = S n \/\\ st_mid2 Y = S n * S n + st Y) as HmidXY. { intuition. }\n    destruct HmidXY as (HmidX & HmidY).\n    inv_ass Hcev4 (Hst_mid). simpl in Hst_mid. subst.\n    set (Hfinal := IHn (S n * S n + st Y) _ _ Hrest).\n    cbv [t_update] in Hfinal. simpl in Hfinal. rewrite HmidX in Hfinal. lia. Qed.\n\nTheorem sum_squares_correct : forall n,\n  {{ fun st => st X = n }}\n  Y ::= 0;;\n  WHILE ~(X = 0) DO\n    W ::= 0;;\n    WHILE ~(W = X) DO\n      Y ::= Y + X;;\n      W ::= W + 1\n    END;;\n    X ::= X - 1\n  END\n  {{ fun st => 6 * st Y = n * (n + 1) * (2 * n + 1) }}.\nProof. unfold hoare_triple. intros n st st_end H HX.\n  inv_seq H (st_mid Hcev1 Hcev2). inv_ass Hcev1 (Hst_mid). simpl in Hst_mid; subst.\n  set (Hssq := sum_squares_gen (st X) 0 _ _ Hcev2).\n  cbv [t_update] in Hssq. simpl in Hssq. lia. Qed.\n\nClose Scope hoare_spec_scope.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32934,"user_id":null,"body":"Require Import Preloaded.\n\nOpen Scope hoare_spec_scope.\n\nRequire Import Coq.Arith.PeanoNat.\nRequire Import Lia.\n\n(* from lf *)\n\nDefinition assert_implies (P Q : Assertion) : Prop :=\n  forall st, P st -> Q st.\n\nNotation \"P ->> Q\" := (assert_implies P Q)\n                      (at level 80) : hoare_spec_scope.\n\nDefinition bassn b : Assertion :=\n  fun st => (beval st b = true).\n\nLemma bexp_eval_true : forall b st,\n  beval st b = true -> (bassn b) st.\nProof.\n  intros b st Hbe.\n  unfold bassn. assumption.  Qed.\n\nLemma bexp_eval_false : forall b st,\n  beval st b = false -> ~ ((bassn b) st).\nProof.\n  intros b st Hbe contra.\n  unfold bassn in contra.\n  rewrite -> contra in Hbe. inversion Hbe.  Qed.\n\nDefinition assn_sub X a P : Assertion :=\n  fun (st : state) =>\n    P (X !-> aeval st a ; st).\n\nNotation \"P [ X |-> a ]\" := (assn_sub X a P)\n  (at level 10, X at next level).\n\nTheorem hoare_while : forall P b c,\n  {{fun st => P st \/\\ bassn b st}} c {{P}} ->\n  {{P}} WHILE b DO c END {{fun st => P st \/\\ ~ (bassn b st)}}.\nProof.\n  intros P b c Hhoare st st' He HP.\n  (* Like we've seen before, we need to reason by induction\n     on [He], because, in the \"keep looping\" case, its hypotheses\n     talk about the whole loop instead of just [c]. *)\n  remember (WHILE b DO c END)%imp as wcom eqn:Heqwcom.\n  induction He;\n    try (inversion Heqwcom); subst; clear Heqwcom.\n  - (* E_WhileFalse *) \n    split. assumption. apply bexp_eval_false. assumption.\n  - (* E_WhileTrue *)\n    apply IHHe2. reflexivity.\n    apply (Hhoare st st'). assumption.\n      split. assumption. apply bexp_eval_true. assumption.\nQed.\n\nTheorem hoare_consequence_pre : forall (P P' Q : Assertion) c,\n  {{P'}} c {{Q}} ->\n  P ->> P' ->\n  {{P}} c {{Q}}.\nProof.\n  intros P P' Q c Hhoare Himp.\n  intros st st' Hc HP. apply (Hhoare st st').\n  assumption. apply Himp. assumption. Qed.\n\nTheorem hoare_consequence_post : forall (P Q Q' : Assertion) c,\n  {{P}} c {{Q'}} ->\n  Q' ->> Q ->\n  {{P}} c {{Q}}.\nProof.\n  intros P Q Q' c Hhoare Himp.\n  intros st st' Hc HP.\n  apply Himp.\n  apply (Hhoare st st').\n  assumption. assumption. Qed.\n\nTheorem hoare_seq : forall P Q R c1 c2,\n     {{Q}} c2 {{R}} ->\n     {{P}} c1 {{Q}} ->\n     {{P}} c1;;c2 {{R}}.\nProof.\n  intros P Q R c1 c2 H1 H2 st st' H12 Pre.\n  inversion H12; subst.\n  apply (H1 st'0 st'); try assumption.\n  apply (H2 st st'0); assumption. Qed.\n\nTheorem hoare_asgn : forall Q X a,\n  {{Q [X |-> a]}} X ::= a {{Q}}.\nProof.\n  unfold hoare_triple.\n  intros Q X a st st' HE HQ.\n  inversion HE. subst.\n  unfold assn_sub in HQ. assumption.  Qed.\n\nTheorem hoare_skip : forall P,\n     {{P}} SKIP {{P}}.\nProof.\n  intros P st st' H HP. inversion H. subst.\n  assumption.  Qed.\n\nTheorem hoare_if : forall P Q b c1 c2,\n  {{fun st => P st \/\\ bassn b st}} c1 {{Q}} ->\n  {{fun st => P st \/\\ ~ (bassn b st)}} c2 {{Q}} ->\n  {{P}} TEST b THEN c1 ELSE c2 FI {{Q}}.\nProof.\n  intros P Q b c1 c2 HTrue HFalse st st' HE HP.\n  inversion HE; subst.\n  - (* b is true *)\n    apply (HTrue st st').\n      assumption.\n      split. assumption.\n      apply bexp_eval_true. assumption.\n  - (* b is false *)\n    apply (HFalse st st').\n      assumption.\n      split. assumption.\n      apply bexp_eval_false. assumption. Qed.\n\n(* programs decorated with invariants *)\n\nInductive icom : Type :=\n  | ICSkip\n  | ICSeq (c1 : icom) (c2 : icom)\n  | ICAsgn (x : string) (a : aexp)\n  | ICIf (b : bexp) (c1 : icom) (c2 : icom)\n  | ICWhile (b : bexp) (inv : Assertion) (c : icom)\n.\n\nInductive idecorated : Type :=\n  | IDecorated (pre : Assertion) (post : Assertion) (c : icom)\n.\n\nFixpoint iextract (c : icom) : com :=\n  match c with\n  | ICSkip        => SKIP\n  | ICSeq c1 c2   => iextract c1 ;; iextract c2\n  | ICAsgn x a    => x ::= a\n  | ICIf b c1 c2  => TEST b THEN iextract c1 ELSE iextract c2 FI\n  | ICWhile b _ c => WHILE b DO iextract c END\n  end.\n\nDefinition idec_correct idec :=\n  match idec with\n  IDecorated pre post c => {{ pre }} iextract c {{ post }}\n  end.\n\nDefinition cond b P1 P2 st :=\n  (P1 st \/\\ bassn b st) \\\/ (P2 st \/\\ ~ bassn b st).\n\nFixpoint ipre (c : icom) (post : Assertion) : Assertion :=\n  match c with\n  | ICSkip          => post\n  | ICSeq c1 c2     => ipre c1 (ipre c2 post)\n  | ICAsgn x a      => post [x |-> a]\n  | ICIf b c1 c2    => cond b (ipre c1 post) (ipre c2 post)\n  | ICWhile _ inv _ => inv\n  end.\n\nFixpoint iver_cond (c : icom) (post : Assertion) : Prop :=\n  match c with\n  | ICSkip          => True\n  | ICSeq c1 c2     => iver_cond c1 (ipre c2 post) \/\\ iver_cond c2 post\n  | ICAsgn _ _      => True\n  | ICIf b c1 c2    => iver_cond c1 post \/\\ iver_cond c2 post\n  | ICWhile b inv c =>\n      iver_cond c inv \/\\\n      ((fun st => inv st \/\\ bassn b st) ->> ipre c inv) \/\\\n      ((fun st => inv st \/\\ ~bassn b st) ->> post)\n  end.\n\nDefinition iverification_conditions (prog : idecorated) : Prop :=\n  match prog with\n  IDecorated pre post c => iver_cond c post \/\\ pre ->> ipre c post\n  end.\n\nLemma iver_correct : forall c post,\n  iver_cond c post -> {{ ipre c post }} iextract c {{ post }}.\nProof.\n  induction c; simpl; intros.\n  - eauto using hoare_skip.\n  - destruct H. eauto using hoare_seq.\n  - eauto using hoare_asgn.\n  - destruct H. unfold cond.\n    eapply hoare_if;\n      eapply hoare_consequence_pre; eauto;\n      intros st; tauto.\n  - destruct H as (? & ? & ?).\n    eauto using\n      hoare_consequence_post,\n      hoare_while,\n      hoare_consequence_pre.\nQed.\n\nTheorem iverification_correct : forall pre post c,\n  iverification_conditions (IDecorated pre post c) ->\n  {{ pre }} iextract c {{ post }}.\nProof.\n  intros pre post c [Hic Himp].\n  eauto using hoare_consequence_pre, iver_correct.\nQed.\n\nTactic Notation \"iverify\" :=\n  apply iverification_correct;\n  repeat split;\n  simpl; unfold cond; unfold assert_implies;\n  unfold bassn in *; unfold beval in *; unfold aeval in *;\n  unfold assn_sub; intros;\n  unfold t_update in *;\n  simpl in *;\n  repeat match goal with [H : _ \/\\ _ |- _] => destruct H end;\n  repeat rewrite Bool.not_true_iff_false in *;\n  repeat rewrite Bool.not_false_iff_true in *;\n  repeat rewrite Bool.negb_true_iff in *;\n  repeat rewrite Bool.negb_false_iff in *;\n  repeat rewrite Nat.eqb_eq in *;\n  repeat rewrite Nat.eqb_neq in *;\n  try subst;\n  repeat\n    match goal with\n      [st : state |- _] =>\n        match goal with\n          [H : st _ = _ |- _] => rewrite -> H in *; clear H\n        | [H : _ = st _ |- _] => rewrite <- H in *; clear H\n        end\n    end;\n  simpl in *; eauto; try lia.\n\nNotation \"'SKIP'\"\n      := (ICSkip)\n      (at level 0) : icom_scope.\nNotation \"l '::=' a\"\n      := (ICAsgn l a)\n      (at level 60, a at next level) : icom_scope.\nNotation \"'WHILE' b 'DO' {{ inv }} c 'END'\"\n      := (ICWhile b inv c)\n      (at level 80, right associativity) : icom_scope.\nNotation \"'TEST' b 'THEN' c1 'ELSE' c2 'FI'\"\n      := (ICIf b c1 c2)\n      (at level 80, right associativity) : icom_scope.\nNotation \" c1 ;; c2 \"\n      := (ICSeq c1 c2)\n      (at level 80, right associativity) : icom_scope.\nNotation \"{{ P }} c {{ Q }}\"\n      := (IDecorated P Q c)\n      (at level 90, c at next level) : icom_scope.\n\nDelimit Scope icom_scope with icom.\n\nOpen Scope icom_scope.\n\n(* the program, annotated with invariants *)\n\nFixpoint sum_sq_from_to (k n : nat) := if n <=? k then 0 else\n  match n with\n  | 0 => 0\n  | S n' => n * n + sum_sq_from_to k n'\n  end.\n\nDefinition sum_squares_inv (n : nat) : idecorated := \n  {{ fun st => st X = n }}\n  Y ::= 0;;\n  WHILE ~(X = 0) DO\n    {{ fun st => st Y = sum_sq_from_to (st X) n \/\\ st X <= n }}\n    W ::= 0;;\n    WHILE ~(W = X) DO\n      {{ fun st => st Y = sum_sq_from_to (st X) n + st W * st X \/\\\n                   st W <= st X \/\\ st X <= n }} \n      Y ::= Y + X;;\n      W ::= W + 1\n    END;;\n    X ::= X - 1\n  END\n  {{ fun st => 6 * st Y = n * (n + 1) * (2 * n + 1) }}.\n\n(* a few lemmata about sum_sq_from_to *)\n\nLemma sum_sq_0 : forall n, sum_sq_from_to n n = 0.\nProof.\n  destruct n; simpl; auto.\n  rewrite Nat.leb_refl. auto.\nQed.\n\nLemma sum_sq_aux : forall n k, k < S n ->\n  sum_sq_from_to k (S n) = S n * S n + sum_sq_from_to k n.\nProof.\n  intros. unfold sum_sq_from_to.\n  apply Compare_dec.leb_correct_conv in H.\n  rewrite H. auto.\nQed.\n\nLemma sum_sq_step : forall n k, S k <= n ->\n  sum_sq_from_to (S k) n + S k * S k = sum_sq_from_to k n.\nProof.\n  induction 1.\n  - rewrite sum_sq_0.\n    unfold sum_sq_from_to.\n    replace (S k <=? k) with false.\n    + rewrite sum_sq_0. auto.\n    + symmetry. apply Nat.leb_nle. lia.\n  - rewrite ?sum_sq_aux; lia.\nQed.\n\nLemma sum_sq_correct : forall n, 6 * sum_sq_from_to 0 n = n * (n + 1) * (2 * n + 1).\nProof.\n  induction n.\n  - simpl. auto.\n  - replace (sum_sq_from_to 0 (S n)) with (S n * S n + sum_sq_from_to 0 n) by auto.\n    rewrite Nat.mul_add_distr_l.\n    rewrite IHn.\n    lia.\nQed.\n\n(* this is the main proof *)\n\nLemma sum_squares_inv_correct : forall n,\n  idec_correct (sum_squares_inv n).\nProof with auto.\n  intros. iverify.\n  - clear H1.\n    destruct (st X) as [|k].\n    + simpl. lia.\n    + rewrite sum_sq_step...\n      replace (S k - 1) with k by lia...\n  - apply sum_sq_correct.\n  - rewrite sum_sq_0...\nQed.\n\nClose Scope icom_scope.\n\n(* just a few technicalities remain, such as showing that our\n   invariant-decorated program is indeed the one we want to prove correct *)\n\nDefinition sum_squares (n : nat) :=\n  {{ fun st => st X = n }}\n  Y ::= 0;;\n  WHILE ~(X = 0) DO\n    W ::= 0;;\n    WHILE ~(W = X) DO\n      Y ::= Y + X;;\n      W ::= W + 1\n    END;;\n    X ::= X - 1\n  END\n  {{ fun st => 6 * st Y = n * (n + 1) * (2 * n + 1) }}.\n\nLemma decorated_correct (n : nat) : match sum_squares_inv n with\n  IDecorated pre post c => sum_squares n = {{ pre }} iextract c {{ post }}\n  end.\nProof. simpl. unfold sum_squares. auto. Qed.\n\nTheorem sum_squares_correct : forall n, sum_squares n.\nProof.\n  intros.\n  rewrite decorated_correct.\n  apply sum_squares_inv_correct.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32935,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Arith.\n\nOpen Scope hoare_spec_scope.\n\nTheorem sum_squares_correct : forall n,\n  {{ fun st => st X = n }}\n  Y ::= 0;;\n  WHILE ~(X = 0) DO\n    W ::= 0;;\n    WHILE ~(W = X) DO\n      Y ::= Y + X;;\n      W ::= W + 1\n    END;;\n    X ::= X - 1\n  END\n  {{ fun st => 6 * st Y = n * (n + 1) * (2 * n + 1) }}.\nProof.\n  intros n st st' H; inversion H; inversion H2.\n  clear - H5 H9 H10.\n  rename H5 into Hc, H9 into Hst, H10 into Hm, n0 into m.\n  intros HX; cut (6 * st' Y = 6 * m + n * (n + 1) * (2 * n + 1));\n  [intros R; rewrite R, <- Hm; reflexivity|].\n  rename st into st'', st'0 into st.\n  assert (st X = n) as Hx; [rewrite <- Hst; unfold t_update; simpl; assumption|].\n  assert (st Y = m) as Hy; [rewrite <- Hst; unfold t_update; reflexivity|].\n  clear st'' Hm Hst HX; revert st st' Hc m Hx Hy; induction n; intros.\n  - assert (beval st (~ X = 0) = false) as Hb; [simpl; rewrite Hx; reflexivity|];\n    inversion Hc; [|rewrite Hb in *; discriminate].\n    rewrite <- H2, Hy; apply plus_n_O.\n  - assert (beval st (~ X = 0) = true) as Hb; [simpl; rewrite Hx; reflexivity|];\n    inversion Hc; [rewrite H2, Hb in *; discriminate|].\n    cut (6 * st' Y = 6 * (m + n * n + 2 * n + 1) + n * (n + 1) * (2 * n + 1));\n    [intros R; rewrite R; ring|].\n    inversion H2; inversion H8.\n    assert (beval st'1 (~ W = X) = true) as Hb'; [simpl; rewrite <- H15; unfold t_update; simpl; rewrite Hx, <- H16; reflexivity|].\n    inversion H11; inversion H19; [rewrite H26, Hb' in *; discriminate|].\n    cut (st'0 X = n \/\\ st'0 Y = m + n * n + 2 * n + 1); [intros [Hx' Hy']; apply (IHn st'0); assumption|].\n    cut (st'2 X = S n \/\\ st'2 Y = m + n * n + 2 * n + 1).\n    { intros [Hx' Hy']; split; inversion H22; unfold t_update;\n      [rewrite <- H34; simpl; rewrite Hx', Nat.sub_1_r; reflexivity|assumption]. }\n    inversion H26; inversion H32; inversion H35.\n    assert (st'3 X = 1 + n) as HX; [rewrite <- H44, <- H39, <- H15; assumption|].\n    assert (st'3 Y = m + S n) as HY; [rewrite <- H44, <- H39, <- H40, <- H15; unfold t_update; simpl; rewrite Hx, Hy; reflexivity|].\n    assert (st'3 W = 1) as HW; [rewrite <- H44, <- H45, <- H39, <- H15, <- H16; reflexivity|].\n    clear - HX HY HW H29; remember 1 as w in HW; rewrite <- Heqw in HX.\n    rename st'3 into st, st'2 into st', H29 into Hc; assert (S n = w + n) as R; [rewrite Heqw; reflexivity|rewrite R; clear R].\n    cut (st' X = w + n \/\\ st' Y = m + S n + n * (w + n)); [intros [Hx Hy]; rewrite Hx, Hy, Heqw; split; ring|clear Heqw].\n    revert st m w Hc HX HY HW; induction n; intros.\n    + assert (beval st (~ W = X) = false) as Hb; [simpl; rewrite HX, HW, Nat.add_0_r, Nat.eqb_refl; reflexivity|].\n      inversion Hc; [|rewrite Hb in *; discriminate].\n      rewrite <- H2, HX, HY; split; ring.\n    + assert (beval st (~ W = X) = true) as Hb;\n      [simpl; rewrite HX, HW, <- Nat.add_succ_comm; apply Bool.negb_true_iff, Nat.eqb_neq, Nat.lt_neq, Nat.le_add_r|].\n      inversion Hc; [rewrite H2, Hb in *; discriminate|].\n      clear st0 st'' b c Hb H H0 H1 H3 H4; rename st' into st'', st'0 into st', H2 into Hc1, H5 into Hc2.\n      specialize (IHn st' (S m + w + S n) (S w) Hc2).\n      cut (st'' X = S w + n \/\\ st'' Y = S m + w + S n + S n + n * (S w + n)); [intros [Hx Hy]; rewrite Hx, Hy; split; ring|apply IHn];\n      inversion Hc1; inversion H4; inversion H1; unfold t_update; simpl.\n      * rewrite HX; ring.\n      * rewrite <- H14; simpl; rewrite HX, HY; ring.\n      * rewrite <- H9; simpl; rewrite <- H13; unfold t_update; simpl; rewrite HW; ring.\nQed.\n\nClose Scope hoare_spec_scope.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32936,"user_id":null,"body":"Require Import Preloaded.\n\nRequire Import Coq.Arith.PeanoNat.\nRequire Import ArithRing Ring.\n\nOpen Scope hoare_spec_scope.\n\nLemma hoare_while_true : forall b c (P Q R: Assertion),\n  (forall st, P st -> beval st b = true) ->\n  {{ P }} c {{ Q }} ->\n  {{ Q }} WHILE b DO c END {{ R }} ->\n  {{ P }} WHILE b DO c END {{ R }}.\nProof.\n  intros; unfold hoare_triple; intros.\n  remember (CWhile b c) as x in H2; destruct H2; try discriminate; injection Heqx; intros; clear Heqx.\n  - rewrite H5, (H _ H3) in H2; discriminate.\n  - rewrite H5, H4 in H2_0; rewrite H4 in H2_; exact (H1 _ _ H2_0 (H0 _ _ H2_ H3)).\nQed.\n\nLemma hoare_while_false : forall b c (P: Assertion),\n  (forall st, P st -> beval st b = false) ->\n  {{ P }} WHILE b DO c END {{ P }}.\nProof.\n  intros; unfold hoare_triple; intros.\n  remember (CWhile b c) as x in H0; destruct H0; try discriminate; injection Heqx; intros; clear Heqx.\n  - exact H1.\n  - rewrite H3, (H _ H1) in H0; discriminate.\nQed.\n\nLemma hoare_seq : forall c1 c2 (P Q R: Assertion),\n  {{ P }} c1 {{ Q }} ->\n  {{ Q }} c2 {{ R }} ->\n  {{ P }} c1;; c2 {{ R}}.\nProof.\n  intros; unfold hoare_triple; intros.\n  remember (CSeq c1 c2) as x in H1; destruct H1; try discriminate; injection Heqx; intros; clear Heqx.\n  rewrite H1 in H1_0; rewrite H3 in H1_; exact (H0 _ _ H1_0 (H _ _ H1_ H2)).\nQed.\n\nLemma eqb_string_refl : forall x, eqb_string x x = true.\nProof.\n  intros; unfold eqb_string; destruct (string_dec x x); try destruct n; reflexivity.\nQed.\n\nLemma hoare_ass : forall x a n1 n2 (P: Assertion),\n  (forall st n, P st -> P (x !-> n; st)) ->\n  (forall st, st x = n1 -> P st -> aeval st a = n2) ->\n  {{ fun st => st x = n1 \/\\ P st }}\n  x ::= a\n  {{ fun st => st x = n2 \/\\ P st }}.\nProof.\n  intros; unfold hoare_triple; intros.\n  remember (CAss x a) as c in H1; destruct H1; try discriminate; injection Heqc; intros; clear Heqc.\n  destruct H2; rewrite H4, <- H1, H3, (H0 _ H2 H5); split.\n  - unfold t_update; rewrite eqb_string_refl; reflexivity.\n  - exact (H _ _ H5).\nQed.\n\nLemma hoare_ass_intro : forall x a n (P: Assertion),\n  (forall st n, P st -> P (x !-> n; st)) ->\n  (forall st, P st -> aeval st a = n) ->\n  {{ P }}\n  x ::= a\n  {{ fun st => st x = n \/\\ P st }}.\nProof.\n  intros; unfold hoare_triple; intros.\n  remember (CAss x a) as c in H1; destruct H1; try discriminate; injection Heqc; intros; clear Heqc.\n  rewrite H4, <- H1, H3, (H0 _ H2); split.\n  - unfold t_update; rewrite eqb_string_refl; reflexivity.\n  - exact (H _ _ H2).\nQed.\n\nLemma hoare_imp_l : forall c (P Q R: Assertion),\n  (forall st, P st -> Q st) ->\n  {{ Q }} c {{ R }} ->\n  {{ P }} c {{ R }}.\nProof.\n  intros; unfold hoare_triple; intros; exact (H0 _ _ H1 (H _ H2)).\nQed.\n\nLemma hoare_imp_r : forall c (P Q R: Assertion),\n  (forall st, Q st -> R st) ->\n  {{ P }} c {{ Q }} ->\n  {{ P }} c {{ R }}.\nProof.\n  intros; unfold hoare_triple; intros; exact (H _ (H0 _ _ H1 H2)).\nQed.\n\nDefinition assert_and (P Q: Assertion): Assertion := fun st => P st \/\\ Q st.\n\nLemma and_comm : forall (P Q: Assertion) st, assert_and P Q st -> assert_and Q P st.\nProof.\n  intros; destruct H; split; try exact H; exact H0.\nQed.\n\nLemma and_assoc_l : forall (P Q R: Assertion) st, assert_and (assert_and P Q) R st -> assert_and P (assert_and Q R) st.\nProof.\n  intros; destruct H, H; split; try split; try exact H; try exact H0; exact H1.\nQed.\n\nLemma and_assoc_r : forall (P Q R: Assertion) st, assert_and P (assert_and Q R) st -> assert_and (assert_and P Q) R st.\nProof.\n  intros; destruct H, H0; split; try split; try exact H; try exact H0; exact H1.\nQed.\n\nLemma and_rot3_l : forall (P Q R: Assertion) st, assert_and P (assert_and Q R) st -> assert_and Q (assert_and R P) st.\nProof.\n  intros; exact (and_assoc_l _ _ _ _ (and_comm _ _ _ H)).\nQed.\n\nLemma and_rot3_r : forall (P Q R: Assertion) st, assert_and P (assert_and Q R) st -> assert_and R (assert_and P Q) st.\nProof.\n  intros; exact (and_rot3_l _ _ _ _ (and_rot3_l _ _ _ _ H)).\nQed.\n\nLemma inner_while : forall ndx nw ny,\n  {{ fun st => st W = nw \/\\ st X = nw + ndx \/\\ st Y = ny }}\n  WHILE ~(W = X) DO\n    Y ::= Y + X;;\n    W ::= W + 1\n  END\n  {{ fun st => st W = nw + ndx \/\\ st X = nw + ndx \/\\ st Y = ny + ndx * (nw + ndx) }}.\nProof.\n  induction ndx; intros.\n  - refine (hoare_imp_r _ _ _ _ _ (hoare_while_false _ _ _ _)).\n    + intros; destruct H, H0; rewrite H, H0, H1; split; try split; ring.\n    + intros; destruct H, H0; simpl; rewrite H, H0, Nat.add_0_r, Nat.eqb_refl; reflexivity.\n  - refine (hoare_imp_r _ _ _ _ _ (hoare_while_true _ _ _ _ _ _ _ (IHndx (S nw) (ny + S nw + ndx)))); clear IHndx.\n    + intros; destruct H, H0; rewrite H, H0, H1; split; try split; ring.\n    + intros; destruct H, H0; simpl; rewrite H, H0, (proj2 (Nat.eqb_neq _ _)); try reflexivity.\n      refine (Nat.lt_neq _ _ _);\n      rewrite <- Nat.add_succ_comm;\n      refine (Plus.lt_plus_trans _ _ _ (Nat.lt_succ_diag_r _)).\n    + refine (hoare_imp_r _ _ _ _ _ (hoare_seq _ _ _ _ _\n        (hoare_imp_l _ _ _ _ (and_rot3_r _ _ _) (hoare_ass _ _ _ _ _ _ _))\n        (hoare_imp_l _ _ _ _ (and_rot3_l _ _ _) (hoare_ass _ _ _ _ _ _ _))\n      )).\n      * intros; destruct H, H0; rewrite H, H0, H1; split; try split; try reflexivity; ring.\n      * intros; destruct H; split; unfold t_update; try rewrite H; try rewrite H0; reflexivity.\n      * intros; destruct H0; simpl; rewrite H, H1; ring.\n      * intros; destruct H; split; unfold t_update; try rewrite H; try rewrite H0; reflexivity.\n      * intros; destruct H0; simpl; rewrite H; ring.\nQed.\n\nLemma outer_while : forall nx ny,\n  {{ fun st => st X = nx \/\\ st Y = ny }}\n  WHILE ~(X = 0) DO\n    W ::= 0;;\n    WHILE ~(W = X) DO\n      Y ::= Y + X;;\n      W ::= W + 1\n    END;;\n    X ::= X - 1\n  END\n  {{ fun st => 6 * st Y = 6 * ny + nx * (nx + 1) * (2 * nx + 1) }}.\nProof.\n  induction nx; intros.\n  - refine (hoare_imp_r _ _ _ _ _ (hoare_while_false _ _ _ _)).\n    + intros; destruct H; rewrite H0; ring.\n    + intros; destruct H; simpl; rewrite H, Nat.eqb_refl; reflexivity.\n  - refine (hoare_imp_r _ _ _ _ _ (hoare_while_true _ _ _ _ _ _ _ (IHnx (ny + nx * nx + 2 * nx + 1)))); clear IHnx.\n    + intros; rewrite H; ring.\n    + intros; destruct H; simpl; rewrite H, (proj2 (Nat.eqb_neq _ _)); try reflexivity.\n      exact (Nat.neq_succ_0 _).\n    + refine (hoare_imp_r _ _ _ _ _ (hoare_seq _ _ _ _ _\n        (hoare_ass_intro _ _ _ _ _ _)\n        (hoare_imp_r _ _ _ _ _ (hoare_seq _ _ _ _ _\n          (hoare_imp_l _ _ _ _ _ (inner_while _ _ _))\n          (hoare_imp_l _ _ _ _ (and_rot3_l _ _ _) (hoare_ass _ _ _ _ _ _ _))\n        ))\n      )).\n      * intros; exact H.\n      * intros; destruct H; unfold t_update; simpl; rewrite H, H0; split; ring.\n      * intros; simpl; reflexivity.\n      * intros; destruct H, H0; split; try exact H.\n        assert (st Y = ny + S nx * (0 + S nx)).\n          exact H0.\n        rewrite H0; ring.\n      * intros; destruct H, H0; rewrite H, H0, H1; split; try split; ring.\n      * intros; destruct H; split; unfold t_update; simpl; try rewrite H; try rewrite H0; ring.\n      * intros; simpl; rewrite H; simpl; rewrite Nat.sub_0_r; reflexivity.\nQed.\n\n\nTheorem sum_squares_correct : forall n,\n  {{ fun st => st X = n }}\n  Y ::= 0;;\n  WHILE ~(X = 0) DO\n    W ::= 0;;\n    WHILE ~(W = X) DO\n      Y ::= Y + X;;\n      W ::= W + 1\n    END;;\n    X ::= X - 1\n  END\n  {{ fun st => 6 * st Y = n * (n + 1) * (2 * n + 1) }}.\nProof.\n  intros; refine (hoare_seq _ _ _ _ _ (hoare_ass_intro _ _ _ _ _ _) _).\n  - intros; unfold t_update; simpl; exact H.\n  - intros; simpl; reflexivity.\n  - exact (hoare_imp_l _ _ _ _ (and_comm _ _) (outer_while _ _)).\nQed.\n\nClose Scope hoare_spec_scope.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32937,"user_id":null,"body":"Require Import Preloaded ssreflect Arith Lia.\n\nOpen Scope hoare_spec_scope.\n\nLtac invert_ceval :=\n  match goal with\n  | H: ceval ?c _ _ |- _ =>\n    lazymatch c with\n    | (WHILE _ DO _ END)%imp => fail\n    | _ => inversion H; subst; clear H\n    end\n  end.\n\nDefinition c1 :=\n  (WHILE ~ W = X DO Y ::= Y + X;; W ::= W + 1 END)%imp.\n\nLemma c1_spec : forall w x y,\n  {{ fun st => w <= x \/\\ st W = w \/\\ st X = x \/\\ st Y = y }}\n    c1\n  {{ fun st' => st' X = x \/\\ st' Y = y + x * (x - w) }}.\nProof.\n  move=> w x y st st'.\n  move=> H; move: (eq_refl c1); rewrite {2}\/c1.\n  elim: H w x y; try discriminate.\n  - move=> ? ? ? H; inversion 1; subst.\n    move: H => \/= \/Bool.negb_false_iff \/Nat.eqb_eq; lia.\n  - move=> {st st'} st st' st'' ? ? Hb Hc _ Hc1 IH2 w x y.\n    inversion 1; subst.\n    move\/Bool.negb_true_iff: Hb => \/Nat.eqb_neq Hb.\n    repeat invert_ceval.\n    move=> [? [? [? ?]]].\n    have: w + 1 <= x by move: Hb => \/=; lia.\n    case: (IH2 (w + 1) x (x + y)) => \/\/.\n    + move: Hb => \/=; rewrite\/t_update \/=; lia.\n    + nia.\nQed.    \n\nDefinition c2 := \n  (WHILE ~ X = 0 DO W ::= 0;; c1;; X ::= X - 1 END)%imp.\n\nLemma c2_spec : forall x y,\n  {{ fun st => st X = x \/\\ st Y = y }}\n    c2\n  {{ fun st' => st' X = 0 \/\\ 6 * st' Y = 6 * y + x * (x + 1) * (2 * x + 1) }}.\nProof.\n  move=> x y st st' H.\n  move: (eq_refl c2); rewrite {2}\/c2.\n  elim: H x y; try discriminate.\n  - move=> ? ? ? H; inversion 1; subst.\n    move: H => \/= \/Bool.negb_false_iff \/Nat.eqb_eq; lia.\n  - move=> {st st'} st st' st'' ? ? Hb Hc _ Hc1 IH2 x y.\n    rewrite\/c1.\n    inversion 1; subst.\n    move\/Bool.negb_true_iff: Hb => \/Nat.eqb_neq Hb.\n    repeat invert_ceval.\n    move=> [? ?].\n    move\/c1_spec: H3 => \/(_ 0 x y) [].\n    by rewrite\/t_update\/=; intuition.\n    move=> ? ?.\n    move: (IH2 (x - 1) (y + x * x) eq_refl).\n    case; first by rewrite \/\/= \/t_update \/=; nia.\n    move=> -> ->; nia.\nQed.    \n\nTheorem sum_squares_correct : forall n,\n  {{ fun st => st X = n }}\n    Y ::= 0;; c2\n  {{ fun st => 6 * st Y = n * (n + 1) * (2 * n + 1) }}.\nProof.\n  rewrite \/c2 \/c1.\n  move=> n st st' ?.\n  repeat invert_ceval.\n  move\/c2_spec: H4.\n  set (st1 := (Y !-> aeval st 0; st)).\n  move\/(_ (st1 X) (st1 Y)) => [].\n  - by rewrite\/t_update\/=.\n  - move=> _ ->.\n    by rewrite\/st1\/t_update\/= => ->.\nQed.\n\nClose Scope hoare_spec_scope.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32938,"user_id":null,"body":"Require Import Preloaded.\n\nOpen Scope hoare_spec_scope.\n\n\nLemma hoare_while : forall b c I,\n  {{ fun st => I st \/\\ beval st b = true }} c {{ I }} ->\n  {{ I }} WHILE b DO c END {{ fun st => I st \/\\ beval st b = false }}.\nProof.\n  intros. unfold hoare_triple in *. intros.\n  remember (WHILE b DO c END)%imp as c0.\n  induction H0; inversion Heqc0; subst.\n  - split; assumption.\n  - apply IHceval2. reflexivity.\n    eapply H. eassumption. split; assumption.\nQed.\n\nLemma hoare_seq : forall c1 c2 P Q R,\n  {{ Q }} c2 {{ R }} -> {{ P }} c1 {{ Q }} -> {{ P }} c1;;c2 {{ R }}.\nProof.\n  intros. unfold hoare_triple in *. intros.\n  inversion H1; subst. eauto.\nQed.\n\nLemma hoare_ass : forall x a Q,\n  {{ fun st => Q (x !-> aeval st a; st) }} x ::= a {{ Q }}.\nProof.\n  intros. unfold hoare_triple. intros.\n  inversion H; subst.\n  assumption.\nQed.\n\nLemma hoare_weakening : forall c (P P' Q' Q : Assertion),\n  {{ P }} c {{ Q }} ->\n  (forall st, P' st -> P st) ->\n  (forall st, Q st -> Q' st) ->\n  {{ P' }} c {{ Q' }}.\nProof.\n  intros. unfold hoare_triple in *. intros. eauto.\nQed.\n\nLemma hoare_weakening_pre : forall c (P P' Q : Assertion),\n  {{ P }} c {{ Q }} ->\n  (forall st, P' st -> P st) ->\n  {{ P' }} c {{ Q }}.\nProof.\n  intros. unfold hoare_triple in *. intros. eauto.\nQed.\n\nLemma hoare_weakening_post : forall c (P Q Q' : Assertion),\n  {{ P }} c {{ Q }} ->\n  (forall st, Q st -> Q' st) ->\n  {{ P }} c {{ Q' }}.\nProof.\n  intros. unfold hoare_triple in *. intros. eauto.\nQed.\n\nRequire Import Arith Lia.\n\nTheorem sum_squares_correct : forall n,\n  {{ fun st => st X = n }}\n  Y ::= 0;;\n  WHILE ~(X = 0) DO\n    W ::= 0;;\n    WHILE ~(W = X) DO \n      Y ::= Y + X;;\n      W ::= W + 1\n    END;;\n    X ::= X - 1\n  END\n  {{ fun st => 6 * st Y = n * (n + 1) * (2 * n + 1) }}.\nProof.\n  intros. eapply hoare_seq.\n  - eapply hoare_weakening_post.\n    + apply hoare_while\n        with (I := fun st => 6 * st Y + st X * (st X + 1) * (2 * st X + 1)\n                           = n * (n + 1) * (2 * n + 1)).\n      eapply hoare_seq.\n      * eapply hoare_seq.\n        -- apply hoare_ass.\n        -- eapply hoare_weakening_post.\n           ++ apply hoare_while\n                with (I := fun st => st W <= st X\n                                  \/\\ st W * st X <= st Y\n                                  \/\\ 0 < st X\n                                  \/\\ 6 * st Y + st X * (st X + 1) * (2 * st X + 1)\n                                     = 6 * st W * st X + n * (n + 1) * (2 * n + 1)).\n              eapply hoare_seq.\n              ** apply hoare_ass.\n              ** eapply hoare_weakening_pre. apply hoare_ass.\n                 cbn.\n                 intros. destruct H as ((H & H0 & H1 & H2) & H3). repeat split.\n                 --- apply Bool.negb_true_iff in H3.\n                     apply Nat.eqb_neq in H3. lia.\n                 --- lia.\n                 --- assumption.\n                 --- lia.\n           ++ cbn. intros. destruct H as ((H & H0 & H1 & H2) & H3).\n              apply Bool.negb_false_iff in H3.\n              apply Nat.eqb_eq in H3. rewrite H3 in *. nia.\n      * eapply hoare_weakening_pre.\n        -- apply hoare_ass.\n        -- cbn. intros. destruct H as (H & H0). repeat split.\n           ++ lia.\n           ++ lia.\n           ++ apply Bool.negb_true_iff in H0. apply Nat.eqb_neq in H0.\n              lia.\n           ++ lia.\n    + cbn. intros. destruct H as (H & H0).\n      apply Bool.negb_false_iff in H0. apply Nat.eqb_eq in H0. lia.\n  - eapply hoare_weakening_pre.\n    + apply hoare_ass.\n    + cbn. intros. lia.\nQed.\n\nClose Scope hoare_spec_scope.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32939,"user_id":null,"body":"Require Import Preloaded Lia Arith.PeanoNat.\n\nOpen Scope hoare_spec_scope.\n\nFixpoint sum_of_squares_rec (n : nat) :=\nmatch n with\n| O => O\n| S n' => sum_of_squares_rec n' + n * n\nend.\n\nLemma sum_of_squares_rec_correct: forall n, 6 * sum_of_squares_rec n = n * (n + 1) * (2 * n + 1).\nProof.\n  intros.\n  induction n; auto.\n  simpl.\n  lia.\nQed.\n\nLemma loop_inv_dec: forall c b f (P : Assertion), \n      (forall st st', P st -> st=[c]=>st' -> f st' = Nat.pred (f st)) ->\n      (forall st, P st -> f st = 0 -> beval st b = false) ->\n        {{fun st => P st \/\\ beval st b = true}}c{{P}} -> {{P}} WHILE b DO c END{{P}}.\nProof.\n  unfold hoare_triple.\n  intros.\n  remember (f st).\n  generalize dependent f.\n  generalize dependent st.\n  induction n; intros.\n  {\n    inversion H2;\n      subst; auto.\n    symmetry in Heqn.\n    apply H0 in Heqn; auto.\n    rewrite H6 in Heqn.\n    inversion Heqn.\n  }\n  inversion H2; subst; auto.\n  eapply IHn; auto.\n    apply H10.\n    apply H1 with st; auto.\n  rewrite H with st _; auto.\n  lia.\nQed.\n\nTheorem sum_squares_correct : forall n,\n  {{ fun st => st X = n }}\n  Y ::= 0;;\n  WHILE ~(X = 0) DO\n    W ::= 0;;\n    WHILE ~(W = X) DO\n      Y ::= Y + X;;\n      W ::= W + 1\n    END;;\n    X ::= X - 1\n  END\n  {{ fun st => 6 * st Y = n * (n + 1) * (2 * n + 1) }}.\nProof.\n  enough (forall n : nat,\n        {{fun st : state => st X = n}} Y ::= 0;;\n                               WHILE ~ X = 0\n                               DO W ::= 0;;\n                                  (WHILE ~ W = X DO Y ::= Y + X;; W ::= W + 1 END);; X ::= X - 1 END\n         {{fun st : state => st Y = sum_of_squares_rec n }}\n  ).\n  {\n    unfold hoare_triple in *.\n    intros.\n    rewrite <- sum_of_squares_rec_correct.\n    f_equal.\n    eapply H. apply H0. auto.\n  }\n  enough (forall n m,\n      {{ fun st => st X = n \/\\ st Y = m }}\n      WHILE ~(X = 0) DO\n        W ::= 0;;\n        WHILE ~(W = X) DO\n          Y ::= Y + X;;\n          W ::= W + 1\n        END;;\n        X ::= X - 1\n      END\n      {{fun st : state => st Y = sum_of_squares_rec n + m}}\n  ).\n  {\n    unfold hoare_triple in *.\n    intros.\n    rewrite <- Nat.add_0_r.\n    apply H with (t_update st Y 0); auto.\n    inversion H0. subst.\n    inversion H4. subst.\n    auto.\n  }\n  enough(forall n m,\n    {{fun st => 0 < n \/\\ st X = n \/\\ st Y = m }}\n    W ::= 0;;\n    WHILE ~(W = X) DO\n      Y ::= Y + X;;\n      W ::= W + 1\n    END;;\n    X ::= X - 1\n    {{ fun st => st X = n - 1 \/\\ st Y = m + n * n }}\n  ).\n  {\n    intro n.\n    induction n; unfold hoare_triple in *; intros.\n    {\n      destruct H1.\n      simpl.\n      inversion H0; subst; auto.\n      simpl in H5. rewrite H1 in H5. inversion H5. \n    }\n    destruct H1.\n    inversion H0; subst.\n      simpl in H7. rewrite H1 in H7. inversion H7.    \n    replace(sum_of_squares_rec (S n) + st Y) with ( (sum_of_squares_rec n + st Y) + S n * S n); [|simpl;lia].\n    apply (IHn (st Y + S n * S n) st'0 st') in H9. lia.\n    specialize H with (S n) (st Y) st st'0.\n    replace(S n - 1) with n in H; [|lia].\n    apply H; auto. split; lia.\n  }\n  enough(forall n m c,\n    {{fun st => st X = n \/\\ st Y = m \/\\ st W <= st X \/\\ st X - st W = c}}\n    WHILE ~(W = X) DO\n      Y ::= Y + X;;\n      W ::= W + 1\n    END\n    {{fun st => st X = n \/\\ st Y = m + n * c \/\\ st W <= st X }}\n  ).\n  {\n    intros.\n    unfold hoare_triple in *; intros.\n    inversion H0; subst.\n    inversion H7; subst.\n    split.\n    {\n      enough (st'1 X = n).\n        inversion H9; subst; auto.\n      enough(\n        {{fun st => st X = n \/\\ st W <= st X}} \n          WHILE ~ W = X DO Y ::= Y + X;; W ::= W + 1 END \n        {{fun st => st X = n  \/\\ st W <= st X}}\n      ).\n      {\n        unfold hoare_triple in H2. \n        apply H2 with st'0; auto. \n        inversion H4; subst.\n        simpl.\n        unfold t_update. simpl.\n        split. apply H1.\n        lia.\n      }\n      apply loop_inv_dec with (fun st => st X - st W).\n      {\n        intros.\n        inversion H3; subst.\n        inversion H13; subst.\n        simpl. \n        inversion H10.\n        subst.\n        unfold t_update.\n        simpl. lia.\n      }\n      {\n        intros.\n        destruct H2.\n        simpl.\n        rewrite Bool.negb_false_iff.\n        apply Nat.eqb_eq.\n        lia.\n      }\n      unfold hoare_triple.\n      intros.\n      destruct H3.\n      inversion H2.\n      subst.\n      inversion H11; subst.\n      inversion H14; subst.\n      simpl.\n      unfold t_update.\n      simpl.\n      split; try lia.\n      simpl in H6.\n      rewrite Bool.negb_true_iff in H6.\n      apply EqNat.beq_nat_false in H6.\n      lia.\n    }\n    inversion H9. subst.\n    simpl.\n    unfold t_update. simpl.\n    specialize H with n m n st'0 st'1.\n    inversion H4; subst.\n    apply H in H5. destruct H5. lia.\n    unfold t_update.\n    simpl.\n    split. apply H1.\n    split. apply H1.\n    lia.\n  }\n  unfold hoare_triple.\n  intros.\n  generalize dependent n.\n  generalize dependent m.\n  generalize dependent st.\n  generalize dependent st'.\n  induction c; intros.\n  {\n    inversion H; subst.\n      lia.\n    simpl in H3.\n    apply Bool.negb_true_iff in H3.\n    apply EqNat.beq_nat_false in H3.\n    lia.\n  }\n  {\n    inversion H; subst.\n    {\n      simpl in H5.\n      apply Bool.negb_false_iff in H5.\n      apply EqNat.beq_nat_true in H5.\n      lia.\n    }\n    apply IHc with _ _ (m+n) n in H7. lia.\n    inversion H4; subst.\n    inversion H5; subst.\n    inversion H9; subst.\n    simpl.\n    unfold t_update.\n    simpl. lia.\n  }\nQed.\n\nClose Scope hoare_spec_scope.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5cf73c3c97d5f8001b935546":[{"id":32940,"user_id":106,"body":"Require Import Preloaded.\nRequire Import FunInd.\n\nFunctional Scheme optimize_notnot_b_ind := Induction for optimize_notnot_b Sort Prop.\n\nTheorem optimize_notnot_b_sound : forall b st,\n  beval st (optimize_notnot_b b) = beval st b.\nProof.\n  intros. functional induction (optimize_notnot_b b);\n  simpl in *; try (rewrite Bool.negb_involutive); congruence.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32941,"user_id":168,"body":"Require Import Preloaded.\n\nTheorem optimize_notnot_b_sound : forall b st,\n  beval st (optimize_notnot_b b) = beval st b.\nProof. \n  fix H 1; intros.\n  destruct b; try (simpl; rewrite ?H; reflexivity).\n  destruct b; simpl; rewrite ?H, ?Bool.negb_involutive; reflexivity.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32942,"user_id":168,"body":"Require Import Preloaded.\n\nFixpoint optimize_notnot_b_sound (b : bexp) st : beval st (optimize_notnot_b b) = beval st b :=\n  match b with\n  | BAnd b1 b2 => f_equal2 andb (optimize_notnot_b_sound b1 st) (optimize_notnot_b_sound b2 st)\n  | BNot b0 => match b0 with\n               | BNot b1 => eq_trans (optimize_notnot_b_sound b1 st) (eq_sym (Bool.negb_involutive _))\n               | BAnd b1 b2 => f_equal negb (f_equal2 andb (optimize_notnot_b_sound b1 st) (optimize_notnot_b_sound b2 st))\n               | _ => eq_refl\n               end\n  | _ => eq_refl\n  end.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32943,"user_id":null,"body":"Require Import Preloaded.\n\nTheorem optimize_notnot_b_sound : forall b st,\n  beval st (optimize_notnot_b b) = beval st b.\nProof.\n  fix H 1.\n  intros.\n  destruct b.\n  all: try(simpl; reflexivity).\n  simpl.\n  destruct b; try (simpl; reflexivity).\n  simpl.\n  rewrite Bool.negb_involutive.\n  apply H.\n  simpl.\n  f_equal.\n  all: simpl.\n  all: f_equal.\n  all: apply H.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32944,"user_id":568,"body":"Require Import Preloaded.\n\nTheorem optimize_notnot_b_sound : forall b st,\n  beval st (optimize_notnot_b b) = beval st b.\nProof.\n  intros b st.\n  pattern b.\n  match goal with\n    |- ?f ?x => enough (f x \/\\ f (BNot x)); simpl in *\n  end.\n  { intuition. }\n  pose proof Bool.negb_involutive.\n  induction b; simpl in *; intuition congruence.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32945,"user_id":489,"body":"Require Import Preloaded.\n\nTheorem optimize_notnot_b_sound' : forall b st,\n  beval st (optimize_notnot_b b) = beval st b \/\\ beval st (optimize_notnot_b (~ b)) = beval st (~ b).\nProof. intros. induction b; auto; intuition; simpl; try rewrite Bool.negb_involutive; congruence. Qed.\n\nTheorem optimize_notnot_b_sound : forall b st,\n  beval st (optimize_notnot_b b) = beval st b.\nProof. firstorder using optimize_notnot_b_sound'. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32946,"user_id":null,"body":"Require Import Preloaded.\n\nTheorem optimize_notnot_b_sound : forall b st,\n  beval st (optimize_notnot_b b) = beval st b.\nProof.\n  cut (forall b st, beval st (optimize_notnot_b b) = beval st b \/\\ beval st (optimize_notnot_b (BNot b)) = beval st (BNot b)); [intros H b st; apply H|].\n  intros b st; induction b; try easy.\n  - split; [easy|].\n    simpl; now rewrite Bool.negb_involutive.\n  - simpl; destruct IHb1 as [Ht1 Hn1], IHb2 as [Ht2 Hn2].\n    now rewrite Ht1, Ht2.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32947,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Coq.Arith.PeanoNat.\n\nFixpoint b_size (b : bexp) : nat :=\n  match b with\n  | BNot b1 => S (b_size b1)\n  | BAnd b1 b2 => S (b_size b1 + b_size b2)\n  | _ => 0\n  end.\n\nLemma optimize_b_size : forall n b st,\n  b_size b <= n -> beval st (optimize_notnot_b b) = beval st b.\nProof.\n  induction n.\n  - intros b st Hle; now destruct b.\n  - intros b st Hle; destruct b; simpl in *; try easy.\n    + apply le_S_n in Hle; destruct b; try easy.\n      * simpl; rewrite Bool.negb_involutive; apply IHn.\n        apply le_S_n, le_S, Hle.\n      * specialize (IHn (BAnd b1 b2) st Hle); simpl in *; now rewrite IHn.\n    + rewrite IHn, IHn; [easy| |];\n      apply le_S_n, Nat.le_trans with (S (b_size b1 + b_size b2)), Hle;\n      apply le_n_S; [apply Plus.le_plus_r|apply Plus.le_plus_l].\nQed.\n\nTheorem optimize_notnot_b_sound : forall b st,\n  beval st (optimize_notnot_b b) = beval st b.\nProof.\n  intros; apply optimize_b_size with (b_size b), le_n.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32948,"user_id":null,"body":"Require Import Preloaded Lia.\n\nFixpoint size_b (b : bexp) : nat :=\n match b with\n  | BTrue => 0\n  | BFalse => 0\n  | BEq _ _ => 0\n  | BLe _ _ => 0\n  | BNot b1 => size_b b1 + 1\n  | BAnd b1 b2 => size_b b1 + size_b b2 + 1\n  end.\n\nTheorem optimize_notnot_b_sound : forall b st,\n  beval st (optimize_notnot_b b) = beval st b.\nProof.\n  intros.\n  remember (size_b b) as d.\n  assert (size_b b <= d) by lia.\n  clear Heqd.\n  generalize dependent b.\n  generalize dependent st.\n  induction d; intros; destruct b; simpl in H; try lia; try reflexivity;\n  try destruct b; simpl in *; repeat rewrite IHd; try lia; try reflexivity.\n  apply Bool.negb_involutive_reverse.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32949,"user_id":null,"body":"Require Import Preloaded.\n\nFrom Coq Require Import ssreflect.\nRequire Import Bool.\n\nLemma neg_dist_op : forall b st,\n beval st ( optimize_notnot_b (~ b)) = beval st ( ~ (optimize_notnot_b b)).\nProof.\n  move => b. elim b => \/= \/\/ b0 IH st.\n  by rewrite IH negb_involutive.\nQed.\n\nLemma negb_dist_beval : forall b st,\n    beval st (~ b) = negb (beval st b).\nProof. by case. Qed.\n\nLemma and_dist_op : forall b1 b2 st,\n  beval st (optimize_notnot_b (b1 && b2)) = (beval st (optimize_notnot_b b1)) && beval st (optimize_notnot_b b2).\nProof. by case. Qed.\n\nLemma andb_dist_beval : forall b1 b2 st,\n  beval st (b1 && b2) = (beval st b1) && beval st b2.\nProof. by case. Qed.\n\n\nTheorem optimize_notnot_b_sound : forall b st,\n  beval st (optimize_notnot_b b) = beval st b.\nProof.\n  move =>b. elim b => \/\/ [b0 IH st| b1 IHb1 b2 IHb2 st].\n  - by rewrite neg_dist_op !negb_dist_beval IH.\n  - by rewrite and_dist_op IHb1 IHb2 andb_dist_beval.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5cf8dc6acb266c00242d7ba3":[{"id":32950,"user_id":489,"body":"Require Import Preloaded.\n\nFrom Coq Require Import Lia.\n\nLemma suf_length : forall (X : Type) (l l' : list X),\n  suf l l' -> length l >= length l'.\nProof. intros X l l' H. induction H; simpl; auto. Qed.\n\nTheorem less_is_not_more: forall X (x : X) (l : list X), ~ suf l (x :: l).\nProof. intros X x l H. apply suf_length in H. simpl in H. lia. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32951,"user_id":null,"body":"Require Import Preloaded.\n\nRequire Import Lia.\n\nLemma len: forall X (l1 l2:list X), suf l1 l2 -> length l2 <= length l1.\nProof.\ninduction 1 as [ l | a k l h hi]; simpl in *.\n- now constructor.\n- now lia.\nQed.\n\nTheorem less_is_not_more: forall X (x : X) (l : list X), ~ suf l (x :: l).\nProof.\nintros X x l h.\napply len in h; simpl in h.\nnow lia.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32952,"user_id":null,"body":"Require Import Preloaded.\n\nLemma suf_len {X : Type} (l l' : list X) : suf l l' -> length l' <= length l.\nProof.\n  intro S; elim S; clear S l l'; [intros l; apply le_n|].\n  intros x l l' S H.\n  apply (PeanoNat.Nat.le_trans _ _ (length (x :: l)) H).\n  simpl; apply PeanoNat.Nat.le_succ_diag_r.\nQed.\n\nTheorem less_is_not_more: forall X (x : X) (l : list X), ~ suf l (x :: l).\nProof.\n  intros X x l H.\n  eapply PeanoNat.Nat.nle_succ_diag_l.\n  exact (suf_len _ _ H).\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32953,"user_id":null,"body":"Require Import Preloaded.\n\nTheorem less_is_not_more: forall X (x : X) (l : list X), ~ suf l (x :: l).\nProof.\n  intros X x l; assert (length l < length (cons x l)) as Hl by apply le_n.\n  revert Hl; generalize (cons x l); clear; intros l' Hlen H; induction H.\n  - contradict Hlen; apply PeanoNat.Nat.lt_irrefl.\n  - apply IHsuf, le_S_n, le_S, Hlen.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32954,"user_id":null,"body":"Require Import Preloaded Lia.\n\nLemma suf_length {A} (l1 l2 : list A) :\n  suf l1 l2 ->\n  length l2 <= length l1.\nProof. induction 1; auto; constructor; auto. Qed.\n\nTheorem less_is_not_more: forall X (x : X) (l : list X), ~ suf l (x :: l).\nProof.\n  intros A x l HC; apply suf_length in HC; simpl in HC; lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32955,"user_id":null,"body":"Require Import Preloaded.\n\nLemma lem1 : forall X (l l': list X), suf l l' -> length l' <= length l.\nProof.\n  intros X l l' h.\n  induction h.\n  reflexivity.\n  simpl.\n  apply le_S.\n  assumption.\nQed.\nTheorem less_is_not_more: forall X (x : X) (l : list X), ~ suf l (x :: l).\nProof.\n  intros X x l h.\n  pose proof (h1 := lem1 X _ _ h).\n  simpl in h1.\n  apply (PeanoNat.Nat.nle_succ_diag_l (length l)).\n  assumption.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32956,"user_id":null,"body":"Require Import Preloaded.\n\n\nRequire Import List.\nImport ListNotations.\n\nLemma appsuf : forall A l (l0: list A) , suf l l0 -> exists l1 , l = l1 ++ l0.\nProof.\n  induction 1.\n  exists nil.\n  simpl.\n  reflexivity.\n  destruct IHsuf.\n  exists (x :: x0).\n  simpl.\n  rewrite H0.\n  reflexivity.\nQed.\n\n\nLemma consfalse : forall A l (x : A) , ~ l = x :: l.\nProof.\n  induction l.\n  intros.\n  intro.\n  inversion H.\n  intros. intro.\n  injection H.\n  intros.\n  eapply IHl.\n  eassumption.\nQed.\n\nLemma consfalse0 : forall A  l  l1 (x : A), ~ l =  x :: l ++ l1.\nProof.\n  induction l.\n  inversion 1.\n  intros.\n  intro.\n  injection H.\n  intros.\n  eapply IHl.\n  eassumption.\nQed.\n  \nLemma consfalse1 : forall A  l l0 l1 (x : A), ~ l = l0 ++ x :: l ++ l1.\nProof.\n  induction l.\n  intros.\n  intro.\n  destruct l0.\n  inversion H.\n  inversion H.\n  intros.\n  intro.\n  destruct l0.\n  simpl in H.\n  pose proof (consfalse0 _ (a :: l) l1 x).\n  simpl in H0. auto.\n  simpl in H.\n  injection H.\n  intros.\n  apply (IHl (l0 ++ [x]) l1 a ).\n  rewrite <- app_assoc.\n  simpl.\n  assumption.\nQed.\n  \n  \n\nTheorem less_is_not_more: forall X (x : X) (l : list X), ~ suf l (x :: l).\nProof. \n  intros. intro. \n  apply appsuf in H.\n  destruct H.\n  eapply consfalse1 with (l1 := []).\n  rewrite app_nil_r.\n  eassumption.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32957,"user_id":null,"body":"Require Import Preloaded.\n\nFrom Coq Require Import List PeanoNat Lia.\n\nLemma cons_not_eq : forall X (x : X) l, x :: l <> l.\nintros.\ninduction l.\n- intro. inversion H.\n- intro. inversion H. subst. contradiction. \nQed. \n\nLemma length_suf : forall X (l l' : list X), suf l l' -> length l' <= length l.\ninduction 1.\n- auto.\n- simpl. apply Nat.le_trans with (length l). auto. auto.\nQed.\n\nTheorem less_is_not_more: forall X (x : X) (l : list X), ~ suf l (x :: l).\nintros. intro. apply length_suf in H. cbn in H. lia.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32958,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Arith.\nRequire Import Lia.\n\nLemma length_suf : forall X (l l' : list X), suf l l' -> length l' <= length l.\ninduction 1.\n- auto.\n- simpl. apply Nat.le_trans with (length l). auto. auto.\nQed.\n\n\nTheorem less_is_not_more: forall X (x : X) (l : list X), ~ suf l (x :: l).\nintros. intro. apply length_suf in H. cbn in H. lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32959,"user_id":null,"body":"Require Import Preloaded.\n\nLemma l1 : forall {X:Type} (l l':list X), suf l l' -> length l' <= length l.\nProof. intros. induction H. auto. apply PeanoNat.Nat.le_trans with (m:=length l). auto.\n       simpl. auto. Qed.\n\nLemma l2: forall {X:Type} (l l':list X), length l < length l' -> ~ suf l l'.\nProof. intros. induction l.\n       - intro. inversion H0. rewrite <- H2 in H. inversion H.\n       - intro. apply IHl. apply PeanoNat.Nat.lt_trans with (m:=length (a::l)); auto.\n         apply l1 in H0. apply Gt.le_not_gt in H0. contradiction. Qed.\n\nTheorem less_is_not_more: forall X (x : X) (l : list X), ~ suf l (x :: l).\nProof. intros. intro. apply l2 in H. auto. auto. Qed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5cfc008ee1021600281b4357":[{"id":32960,"user_id":null,"body":"Require Import Preloaded.\n\nTheorem cannot_pull : (forall T P, pull T P) -> False.\nProof.\n  intros. specialize (X False (fun _ => False) (@id _)). apply X.\nQed.\n\nTheorem but_why : exists T P, pull T P -> False.\nProof.\n  exists False, (fun _ => False). intros H. specialize (H (@id _)). apply H.\nQed.\n\nTheorem can_pull_if_existence : forall T, existence T -> (forall P, pull T P).\nProof.\n  intros. unfold pull. intros.\n  destruct X as (x & _).\n  exists x. apply H.\nQed.\n\nTheorem existence_if_can_pull : forall T, (forall P, pull T P) -> existence T.\nProof.\n  intros. specialize (X (fun _ => True)). apply X. trivial.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32961,"user_id":null,"body":"Require Import Preloaded.\n\nTheorem cannot_pull : (forall T P, pull T P) -> False.\nProof.\n  intro H.\n  case (H False (fun _ => True) (fun _ => I)).\n  intros false_proof _; exact false_proof.\nQed.\n\nTheorem but_why : exists T P, pull T P -> False.\nProof.\n  exists False. exists (fun _ => True). intro H.\n  case (H (fun _ => I)).\n  intros false_proof _; exact false_proof.\nQed.\n\nTheorem can_pull_if_existence : forall T, existence T -> (forall P, pull T P).\nProof.\n  intros T Hex P.\n  case Hex; intros t _ H.\n  exists t; apply H.\nQed.\n\nTheorem existence_if_can_pull : forall T, (forall P, pull T P) -> existence T.\nProof.\n  intros T Hpull.\n  case (Hpull (fun _ => True)).\n  exact (fun _ => I).\n  intros t _; exists t; exact I.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32962,"user_id":null,"body":"Require Import Preloaded.\n\nTheorem cannot_pull : (forall T P, pull T P) -> False.\nProof.\n  intro H; specialize (H False (fun _ => False)).\n  assert (H0: forall x : False, (fun _ => False) x) by auto.\n  apply H in H0; destruct H0; auto.\nQed.\n\nTheorem but_why : exists T P, pull T P -> False.\nProof.\n  exists False, (fun _ => False); intro H.\n  assert (H0: forall x : False, (fun _ => False) x) by auto.\n  apply H in H0; destruct H0; auto.\nQed.\n\nTheorem can_pull_if_existence : forall T, existence T -> (forall P, pull T P).\nProof. intros T [x ?] P H; apply (exist _ x (H x)). Qed.\n\nTheorem existence_if_can_pull : forall T, (forall P, pull T P) -> existence T.\nProof. intros T H; apply H; auto. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32963,"user_id":null,"body":"Require Import Preloaded.\n\nTheorem cannot_pull : (forall T P, pull T P) -> False.\nProof. \n  intro h.\n  apply (h (False) (fun x => False)).\n  auto.\nQed.\n\nTheorem but_why : exists T P, pull T P -> False.\nProof.\n  exists False, (fun x => False).\n  intro h.\n  apply h.\n  auto.\nQed.\n\nTheorem can_pull_if_existence : forall T, existence T -> (forall P, pull T P).\nProof.\n  intros T X P h.\n  destruct X.\n  exists x.\n  auto.\nQed.\n\nTheorem existence_if_can_pull : forall T, (forall P, pull T P) -> existence T.\nProof.\n  intros.\n  apply X.\n  auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32964,"user_id":null,"body":"Require Import Preloaded.\n\nTheorem cannot_pull : (forall T P, pull T P) -> False.\nProof.\n  intros.\n  pose proof (X False (fun _ => True)).\n  compute in X0.\n  pose proof (X0 (fun _ => I)).\n  destruct H.\n  exact x.\nQed.\n\nTheorem but_why : exists T P, pull T P -> False.\nProof. \n  exists False.\n  exists (fun _ => True).\n  intro.\n  compute in X.\n  pose proof (X (fun _ => I)).\n  destruct H.\n  exact x.\nQed.\n\nTheorem can_pull_if_existence : forall T, existence T -> (forall P, pull T P).\nProof.\n  intros.\n  unfold existence in X.\n  destruct X.\n  unfold pull.\n  intros.\n  econstructor.\n  exact (H x).\nQed.\n  \n\nTheorem existence_if_can_pull : forall T, (forall P, pull T P) -> existence T.\nProof.\n  intros.\n  hnf.\n  constructor.\n  pose proof (X (fun _ => True)).\n  compute in X0.\n  pose proof (X0 (fun _ => I)).\n  destruct X1.\n  exact x.\n  exact I.\nQed.\n  ","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32965,"user_id":null,"body":"Require Import Preloaded.\n\nTheorem cannot_pull : (forall T P, pull T P) -> False.\nProof. intros H; now case (H False (fun _ => True)). Qed.\n\nTheorem but_why : exists T P, pull T P -> False.\nProof. exists False, (fun _ => True); now intros []. Qed.\n\nTheorem can_pull_if_existence : forall T, existence T -> (forall P, pull T P).\nProof. intros T [x _] P all_P; now exists x. Qed.\n\nTheorem existence_if_can_pull : forall T, (forall P, pull T P) -> existence T.\nProof. \nintros T pull_T; case (pull_T (fun _ => True)); trivial.\nintros x _; now exists x.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32966,"user_id":null,"body":"Require Import Preloaded.\n\nTheorem cannot_pull : (forall T P, pull T P) -> False.\nProof.\n  intros H.\n  cut ({x : Empty_set | (fun _ => True) x}).\n  intros [[]].\n  apply H; intros [].\nQed.\n\nTheorem but_why : exists T P, pull T P -> False.\nProof.\n  exists Empty_set, (fun _ => True).\n  intros [[]]; intros [].\nQed.\n\nTheorem can_pull_if_existence : forall T, existence T -> (forall P, pull T P).\nProof.\n  intros T [x _] P H.\n  apply exist with x, H.\nQed.\n\nTheorem existence_if_can_pull : forall T, (forall P, pull T P) -> existence T.\nProof.\n  intros T H.\n  cut (T -> True).\n  intros Px; destruct (H _ Px); now apply exist with x.\n  easy.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32967,"user_id":null,"body":"Require Import Preloaded.\n\nInductive Empty : Type := .\n\nTheorem cannot_pull : (forall T P, pull T P) -> False.\nProof.\n  unfold pull.\n  intros.\n  specialize (X Empty (fun _ => False)).\n  destruct X.\n  - intros. destruct x.\n  - apply f.\nQed.\n\nTheorem but_why : exists T P, pull T P -> False.\nProof. \n  exists Empty, (fun _ => False).\n  unfold pull. intros.\n  destruct H; auto. intros.\n  destruct x.\nQed.\n\nTheorem can_pull_if_existence : forall T, existence T -> (forall P, pull T P).\nProof.\n  unfold pull, existence. intros.\n  destruct X. exists x. auto.\nQed.\n\nTheorem existence_if_can_pull : forall T, (forall P, pull T P) -> existence T.\nProof.\n  unfold pull. intros.\n  unfold existence.\n  specialize (X (fun _ => True)).\n  destruct X; auto.\n  exists x. auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32968,"user_id":null,"body":"Require Import Preloaded.\n\nTheorem cannot_pull : (forall T P, pull T P) -> False.\nProof. \nintros. assert (E : (forall x : False, (fun _ => False) x)). auto.\napply X in E. inversion E. auto. Qed.\n\nTheorem but_why : exists T P, pull T P -> False.\nProof. \nexists False. exists (fun _ => False).\nintros. unfold pull in *. assert (E : {_ : False | False}). eauto.\ninversion E.\nauto.\nQed.\n\nTheorem can_pull_if_existence : forall T, existence T -> (forall P, pull T P).\nProof. \nintros.\ninversion X.\nunfold pull.\nintros.\nPrint sig.\neapply exist. apply (H0 x). Qed.\n\nTheorem existence_if_can_pull : forall T, (forall P, pull T P) -> existence T.\nProof.\nintros.\nunfold pull in *.\nassert (E : {x : T | True}).\neauto.\nauto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32969,"user_id":null,"body":"Require Import Preloaded.\n\nTheorem cannot_pull : (forall T P, pull T P) -> False.\nProof.\n  intros.\n  specialize (X False _ (fun x => x)).\n  inversion X. contradiction.\nQed.\n\nTheorem but_why : exists T P, pull T P -> False.\nProof. \n  exists False.\n  exists (fun _ => True). \n  intros.\n  specialize (X (fun _ => I)).\n  inversion X.\n  contradiction.\nQed.\n\nTheorem can_pull_if_existence : forall T, existence T -> (forall P, pull T P).\nProof. \n    intros.\n    intro.\n    inversion X.\n    exists x. apply H.\nQed.\n\nTheorem existence_if_can_pull : forall T, (forall P, pull T P) -> existence T.\nProof. \n  intros.\n  specialize (X (fun _ => True) (fun _ => I)).\n  apply X.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5cfd36be4c60c3001b8fb38a":[{"id":32970,"user_id":489,"body":"Require Import Preloaded.\n\nLemma nvalue_normal : forall t t', nvalue t -> t --> t' -> False.\nProof. intros t t' Ht; revert dependent t'.\n  induction Ht; intros t' H; inversion H; firstorder. Qed.\n\nLtac clo := match goal with\n  | [Hzro : zro --> ?t |- _] => inversion Hzro\n  | [Hnul : nul --> ?t |- _] => inversion Hnul\n  | [Hn : nvalue ?n, Hstep : ?n --> ?t |- _]\n    => contradiction (nvalue_normal _ _ Hn Hstep)\n  | _ => firstorder\n  end.\n\nLemma nvalue_scc_normal : forall t t', nvalue t -> scc t --> t' -> False.\nProof. intros t t' Ht; revert dependent t'.\n  induction Ht; intros t' H; inversion H; clo. Qed.\n\nLemma lvalue_cns_normal : forall n l t, nvalue n -> lvalue l -> cns n l --> t -> False.\nProof. intros n l t Hn Hl. revert dependent t; revert dependent n.\n  induction Hl; intros n Hn t Hcns; inversion Hcns; subst; clo. Qed.\n\nLtac closer := match goal with\n  | [Hzro : zro --> ?t |- _] => inversion Hzro\n  | [Hnul : nul --> ?t |- _] => inversion Hnul\n  | [Hn : nvalue ?n, Hstep : ?n --> ?t |- _]\n    => contradiction (nvalue_normal _ _ Hn Hstep)\n  | [Hn : nvalue ?n, Hstep : scc ?n --> ?t |- _]\n    => contradiction (nvalue_scc_normal _ _ Hn Hstep)\n  | [Hn : nvalue ?n, Hl : lvalue ?l, Hstep : cns ?n ?l --> ?t |- _]\n    => contradiction (lvalue_cns_normal _ _ _ Hn Hl Hstep)\n  | _ => try f_equal; eauto\n  end.\n\nTheorem step_deterministic : deterministic step.\nProof. cbv. intros x. induction x; intros y1 y2 Hy1 Hy2;\n  inversion Hy1; subst; inversion Hy2; subst; closer. Qed.\n\nHint Constructors has_type.\n\nTheorem progress_dec : progress \\\/ ~ progress.\nProof. right. cbv. intros H.\n  specialize (H (idx zro nul) Nat).\n  assert (|- idx zro nul \\in Nat) as Hty. { auto. }\n  specialize (H Hty). destruct H as [[Hn | Hl] | [t' Hstep]].\n  - inversion Hn. - inversion Hl. - inversion Hstep; closer. Qed.\n\nLemma nvalue_nat : forall t, nvalue t -> |- t \\in Nat.\nProof. intros t Ht; induction Ht; auto. Qed.\n\nLemma lvalue_list : forall t, lvalue t -> |- t \\in List.\nProof. intros t Ht; induction Ht; auto using nvalue_nat. Qed.\n\nTheorem preservation_dec : preservation \\\/ ~ preservation.\nProof. left. cbv. intros t t' T Hty. revert dependent t'.\n  induction Hty; intros t' Hstep;\n  inversion Hstep; subst; auto using nvalue_nat, lvalue_list. Qed.\n\nCorollary soundness_dec : soundness \\\/ ~ soundness.\nProof. right. cbv. intros H.\n  specialize (H (idx zro nul) (idx zro nul) Nat).\n  assert (|- idx zro nul \\in Nat) as Hty. { auto. }\n  assert (multi step (idx zro nul) (idx zro nul)) as Hstep. { constructor. }\n  specialize (H Hty Hstep). apply H. split.\n  - intros [t' Hnostep]. inversion Hnostep; closer.\n  - intros [Hn | Hl]; [inversion Hn | inversion Hl]. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32971,"user_id":null,"body":"Require Import Preloaded.\n\nLemma nvalue_cannot_step : forall t, nvalue t -> (forall t', ~t-->t').\nProof. unfold not. intro. intro. induction H; intros. inversion H. inversion H0. eapply IHnvalue. apply H2. Qed.\n\nLemma lvalue_cannot_step : forall t, lvalue t -> (forall t', ~t-->t').\nProof. unfold not. intro. intro. induction H; intros. inversion H. inversion H1. eapply IHlvalue. apply H6. eapply nvalue_cannot_step. apply H. apply H5. Qed.\n\nLemma value_cannot_step : forall t, value t -> (forall t', ~t-->t').\nProof. intros. destruct H. apply nvalue_cannot_step. auto. apply lvalue_cannot_step. auto. Qed.\n\nLtac value_step := try (exfalso;\n                        match goal with\n                        | H : nvalue ?v |- _ =>\n                            match goal with\n                            | H0 : (v --> ?t) |- _ => eapply (nvalue_cannot_step v H); apply H0\n                            | H0 : (scc v --> ?t) |- _ => eapply (nvalue_cannot_step (scc v) (nv_scc v H)); apply H0\n                            | H0 : (cns v nul --> ?t) |- _ => eapply (lvalue_cannot_step (cns v nul) (lv_cns v nul H lv_nul)); apply H0\n                            | H0 : (cns v ?v0 --> ?t) |- _ => match goal with\n                                                              | H1 : lvalue v0 |- _ => eapply (lvalue_cannot_step (cns v v0) (lv_cns v v0 H H1)); apply H0\n                                                              end\n                            end\n                        | H0 : (zro --> ?t) |- _ => apply (nvalue_cannot_step zro nv_zro t); apply H0\n                        | H : lvalue ?v |- _ => match goal with\n                                                | H0 : (v --> ?t) |- _ => apply (lvalue_cannot_step v H t); apply H0\n                                                | H0 : (scc v --> ?t) |- _ => apply (nvalue_cannot_step (scc v) (nv_scc v H) t); apply H0\n                                                end\n                        | H0 : (nul --> ?t) |- _ => apply (lvalue_cannot_step nul lv_nul t); apply H0\n                        end)\n.\n\nLtac my_auto := auto; subst; value_step.\n\nLtac by_inv := match goal with\n               | H : ?t --> ?t' |- _ => inversion H; try my_auto\n               end.\n\nLtac by_ih := match goal with\n              | _ : ?t --> ?t1, _ : ?t --> ?t2 |- _ => replace t1 with t2; try my_auto; try (symmetry; my_auto)\n              end.\n\nTheorem step_deterministic : deterministic step.\nProof.\n  unfold deterministic.\n  assert (H : forall x y1, x --> y1 -> forall y2, x --> y2 -> y1 = y2).\n  intro. intro. intro. induction H; intros; my_auto; by_inv; by_ih.\n  intros. eapply H. apply H0. auto.\nQed.\n\nLemma no_progress : ~ progress.\nProof.\n  unfold progress, not. intros.\n  specialize (H (idx zro nul) Nat). destruct H. constructor. constructor. constructor. inversion H. inversion H0. inversion H0. destruct H. inversion H. inversion H4. inversion H3.\nQed.\n\nTheorem progress_dec : progress \\\/ ~ progress.\nProof.\n  right. apply no_progress.\nQed.\n\nLemma nvalue_type : forall n, nvalue n -> |- n \\in Nat.\nProof. intros. induction H. constructor. constructor. assumption. Qed.\n\nLemma lvalue_type : forall l, lvalue l -> |- l \\in List.\nProof. intros. induction H. constructor. constructor. apply nvalue_type. auto. auto. Qed.\n\nLtac by_val := repeat (constructor; auto);\n               match goal with\n               | H : nvalue ?n |- |- ?n \\in ?T => apply (nvalue_type n H)\n               | H : lvalue ?l |- |- ?l \\in ?T => apply (lvalue_type l H)\n               end.\n\nTheorem preservation_dec : preservation \\\/ ~ preservation.\nProof with auto; by_val.\n  left. unfold preservation. intros. generalize dependent t'. induction H; intros; try by_inv; try by_val.\nQed.\n\nCorollary soundness_dec : soundness \\\/ ~ soundness.\nProof with auto.\n  right. unfold soundness, not. intros. specialize (H (idx zro nul) (idx zro nul) Nat). apply H. constructor. constructor. constructor. constructor. split. intros [t]; by_inv. intros H0. inversion H0. inversion H1. inversion H1. \nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32972,"user_id":null,"body":"Require Import Preloaded.\n\nLemma nvalue_no_step : forall v, nvalue v -> forall t, ~ v --> t.\nProof.\n  intros v H; induction H; intros t F; inversion F; subst; clear F.\n  now apply IHnvalue in H1.\nQed.\n\nLemma lvalue_no_step : forall v, lvalue v -> forall t, ~ v --> t.\nProof.\n  intros v H; induction H; intros t F; inversion F; subst; clear F.\n  - now apply IHlvalue in H5.\n  - now apply nvalue_no_step with _ t1' in H.\nQed.\n\nTheorem step_deterministic : deterministic step.\nProof.\n  intros t t1 t2 H1 H2; revert t2 H2; induction H1; intros.\n  - inversion H2; subst; clear H2.\n    apply IHstep in H0; now subst.\n  - inversion H2; subst; clear H2.\n    + easy.\n    + now apply nvalue_no_step with _ t2' in H.\n    + inversion H4.\n  - inversion H2; subst; clear H2.\n    + easy.\n    + now apply nvalue_no_step with _ t2' in H0.\n    + inversion H5; subst; clear H5.\n      now apply nvalue_no_step with _ t1'0 in H2.\n  - inversion H2; subst; clear H2.\n    + now apply nvalue_no_step with _ t2' in H5.\n    + now apply nvalue_no_step with _ t2' in H6.\n    + apply IHstep in H6; now subst.\n    + now apply nvalue_no_step with _ t1' in H.\n  - inversion H2; subst; clear H2.\n    + inversion H1.\n    + inversion H1; subst; clear H1.\n      now apply nvalue_no_step with _ t1'0 in H3.\n    + now apply nvalue_no_step with _ t1' in H1.\n    + apply IHstep in H4; now subst.\n  - inversion H2; subst; clear H2.\n    + apply IHstep in H6; now subst.\n    + now apply nvalue_no_step with _ t1' in H.\n  - inversion H2; subst; clear H2.\n    + now apply nvalue_no_step with _ t1' in H3.\n    + apply IHstep in H4; now subst.\n  - inversion H2; subst; clear H2.\n    + easy.\n    + inversion H0.\n  - inversion H2; subst; clear H2.\n    + easy.\n    + inversion H3; subst; clear H3.\n      * now apply lvalue_no_step with _ t2' in H0.\n      * now apply nvalue_no_step with _ t1'0 in H.\n  - inversion H2; subst; clear H2.\n    + inversion H1.\n    + inversion H1; subst; clear H1.\n      * now apply lvalue_no_step with _ t2' in H3.\n      * now apply nvalue_no_step with _ t1'0 in H5.\n    + apply IHstep in H0; now subst.\n  - inversion H2; subst; clear H2.\n    + easy.\n    + inversion H6; subst; clear H6.\n      * now apply lvalue_no_step with _ t2'0 in H0.\n      * now apply nvalue_no_step with _ t1' in H.\n    + inversion H5.\n  - inversion H2; subst; clear H2.\n    + easy.\n    + inversion H7; subst; clear H7.\n      * now apply lvalue_no_step with _ t2'0 in H1.\n      * now apply nvalue_no_step with _ t1' in H0.\n    + inversion H6; subst; clear H6.\n      now apply nvalue_no_step with _ t1'0 in H.\n  - inversion H2; subst; clear H2.\n    + inversion H1; subst; clear H1.\n      * now apply lvalue_no_step with _ t2'0 in H6.\n      * now apply nvalue_no_step with _ t1' in H4.\n    + inversion H1; subst; clear H1.\n      * now apply lvalue_no_step with _ t2'0 in H7.\n      * now apply nvalue_no_step with _ t1' in H5.\n    + apply IHstep in H6; now subst.\n    + now apply nvalue_no_step with _ t1' in H.\n  - inversion H2; subst; clear H2.\n    + inversion H1.\n    + inversion H1; subst; clear H1.\n      now apply nvalue_no_step with _ t1'0 in H3.\n    + now apply nvalue_no_step with _ t1' in H3.\n    + apply IHstep in H4; now subst.\n  - inversion H2; subst; clear H2.\n    + easy.\n    + now apply nvalue_no_step with _ t1' in H.\n  - inversion H2; subst; clear H2.\n    + now apply nvalue_no_step with _ t1' in H0.\n    + apply IHstep in H0; now subst.\nQed.\n\nTheorem progress_dec : progress \\\/ ~ progress.\nProof.\n  right; intros F; specialize (F (idx zro nul) Nat (T_Idx _ _ T_Zro T_Nul)).\n  destruct F as [[F|F]|[t F]].\n  - inversion F.\n  - inversion F.\n  - inversion F; subst; clear F.\n    + inversion H3.\n    + inversion H2.\nQed.\n\nTheorem preservation_dec : preservation \\\/ ~ preservation.\nProof.\n  left; intros t1 t2 T HT Ht; revert T HT; induction Ht; intros.\n  - inversion HT; subst; clear HT.\n    now apply T_Scc, IHHt.\n  - now inversion HT; subst; clear HT.\n  - inversion HT; subst; clear HT.\n    inversion H3; subst; clear H3.\n    now apply T_Scc, T_Pls.\n  - inversion HT; subst; clear HT.\n    apply T_Pls; [easy|].\n    now apply IHHt.\n  - inversion HT; subst; clear HT.\n    apply T_Pls; [|easy].\n    now apply IHHt.\n  - inversion HT; subst; clear HT.\n    apply T_Cns; [easy|].\n    now apply IHHt.\n  - inversion HT; subst; clear HT.\n    apply T_Cns; [|easy].\n    now apply IHHt.\n  - inversion HT; subst; clear HT.\n    apply T_Zro.\n  - inversion HT; subst; clear HT.\n    inversion H2; subst; clear H2.\n    now apply T_Scc, T_Len.\n  - inversion HT; subst; clear HT.\n    now apply T_Len, IHHt.\n  - inversion HT; subst; clear HT.\n    now inversion H5; subst; clear H5.\n  - inversion HT; subst; clear HT.\n    inversion H4; subst; clear H4.\n    inversion H6; subst; clear H6.\n    now apply T_Idx.\n  - inversion HT; subst; clear HT.\n    apply T_Idx; [easy|].\n    now apply IHHt.\n  - inversion HT; subst; clear HT.\n    apply T_Idx; [|easy].\n    now apply IHHt.\n  - inversion HT; subst; clear HT.\n    now apply T_Cns, T_Nul.\n  - inversion HT; subst; clear HT.\n    now apply T_Stn, IHHt.\nQed.\n\nCorollary soundness_dec : soundness \\\/ ~ soundness.\nProof.\n  right; intros F; specialize (F (idx zro nul) _ Nat (T_Idx _ _ T_Zro T_Nul) (multi_refl _ _)).\n  contradict F; split.\n  - intros [t Ht]; inversion Ht; subst; clear Ht.\n    + inversion H3.\n    + inversion H2.\n  - intros [F|F].\n    + inversion F.\n    + inversion F.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32973,"user_id":null,"body":"Require Import Preloaded.\n\nLemma nvalue_normal_form {v} : nvalue v -> step_normal_form v.\nProof.\n  induction 1.\n  all: intros [? r] ; inversion r.\n  subst.\n  eauto.\nQed.\n\nLemma lvalue_normal_form {v} : lvalue v -> step_normal_form v.\nProof.\n  induction 1.\n  all: intros [? r] ; inversion r ; subst.\n  all: eauto.\n  eapply nvalue_normal_form ; eauto.\nQed.\n\nLemma value_normal_form {v} : value v -> step_normal_form v.\nProof.\n  destruct 1.\n  - now eapply nvalue_normal_form ; eauto.\n  - now eapply lvalue_normal_form ; eauto.\nQed.\n\nLtac exfalso_value :=\n  match goal with\n    | r : ?t --> ?t' , v : nvalue ?t |- _ => exfalso ; apply (nvalue_normal_form v) ; now exists t'\n    | r : ?t --> ?t' , v : lvalue ?t |- _ => exfalso ; apply (lvalue_normal_form v) ; now exists t'\n    | r : zro --> ?t' |- _ =>\n        exfalso ; eapply nvalue_normal_form ; [idtac | exists t' ; eassumption] ; constructor\n    | r : scc ?t --> ?t', v : nvalue ?t |- _ =>\n        exfalso ; eapply nvalue_normal_form ; [idtac | exists t' ; eassumption] ; now constructor\n    | r : nul --> ?t' |- _ =>\n        exfalso ; eapply lvalue_normal_form ; [idtac | exists t' ; eassumption] ; constructor\n    | r : cns ?n ?l --> ?t', v : nvalue ?n |- _ =>\n        exfalso ; eapply nvalue_normal_form ; [idtac | exists t' ; eassumption] ; now constructor\n    | r : cns ?n ?l --> ?t', v : lvalue ?l |- _ =>\n        exfalso ; eapply lvalue_normal_form ; [idtac | exists t' ; eassumption] ; now constructor\n  end.\n\nLemma nvalue_ty {v} : |- v \\in Nat -> value v -> nvalue v.\nProof.\n  intros ty val.\n  inversion ty ; subst.\n  all: inversion val ; auto.\n  all: match goal with | H : lvalue _ |- _ => inversion H end.\nQed.\n\nLemma lvalue_ty {v} : |- v \\in List -> value v -> lvalue v.\nProof.\n  intros ty val.\n  inversion ty ; subst.\n  all: inversion val ; auto.\n  all: match goal with | H : nvalue _ |- _ => inversion H end.\nQed.\n\nLtac value_ty :=\n  repeat (match goal with\n    | v : value ?n, ty : |- ?n \\in Nat |- _ => apply (nvalue_ty ty) in v\n    | v : value ?l, ty : |- ?l \\in List |- _ => apply (lvalue_ty ty) in v\n  end).\n\n  Theorem step_deterministic : deterministic step.\n  Proof.\n    intros x y1 y2 r1 r2.\n    induction r1 in y2,r2 |- * ; subst.\n    all: inversion r2 ; subst ; try solve [f_equal ; auto] ; solve [exfalso_value].\n  Qed.\n\n  Definition stuck_ty : |- idx zro nul \\in Nat.\n  Proof.\n    repeat constructor.\n  Defined.\n\n  Theorem progress_dec : progress \\\/ ~ progress.\n  Proof.\n    pose proof stuck_ty as s.\n    right.\n    unfold progress.\n    intros prog.\n    destruct (prog _ _ s) as [val|red].\n    - value_ty.\n      inversion val.\n    - destruct red as [? red].\n      inversion red ; subst.\n      + inversion H3.\n      + inversion H2.\n  Qed.\n  \n  Theorem preservation_dec : preservation \\\/ ~ preservation.\n  Proof.\n    left.\n    intros t t' T ty red.\n    induction red in T, ty |- *.\n    all: inversion ty ; subst ; auto.\n    all: try solve [constructor ; auto].\n\n    - do 2 constructor ; auto. now inversion H3.\n    - do 2 constructor. now inversion H2.\n    - now inversion H5 ; subst.\n    - inversion H4 ; subst. inversion H6 ; subst. now constructor.\n    - constructor ; auto. constructor.\n  Qed.\n\n  Corollary soundness_dec : soundness \\\/ ~ soundness.\n  Proof.\n    pose proof stuck_ty as s.\n    right.\n    unfold soundness.\n    intros sound.\n    specialize (sound _ _ _ s (multi_refl _ _)).\n    apply sound.\n    split.\n    - intros [? r].\n      inversion r ; subst.\n      + inversion H3.\n      + inversion H2.\n    - intros v.\n      value_ty.\n      inversion v.\n  Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32974,"user_id":null,"body":"Require Import Preloaded.\n\nTheorem step_deterministic : deterministic step.\nProof.\n  assert (forall v v', nvalue v -> ~ v --> v') as Hnv.\n  { intros v v' Hnv; revert v'; induction Hnv; intros v' H; inversion H; contradict H1; apply IHHnv. }\n  assert (forall v v', lvalue v -> ~ v --> v') as Hlv.\n  { intros v v' Hlv; revert v'; induction Hlv; intros v' F; inversion F.\n    - contradict H4; apply IHHlv.\n    - contradict H3; apply Hnv; assumption. }\n  intros x y y' Hy Hy'; revert y' Hy'; induction Hy; intros.\n  - inversion Hy'; rewrite (IHHy t1'0); [reflexivity|assumption].\n  - inversion Hy'.\n    + reflexivity.\n    + contradict H4; apply Hnv; assumption.\n    + contradict H3; apply Hnv; constructor.\n  - inversion Hy'.\n    + reflexivity.\n    + contradict H5; apply Hnv; assumption.\n    + contradict H4; apply Hnv; constructor; assumption.\n  - inversion Hy'.\n    + contradict Hy; apply Hnv; rewrite H1; assumption.\n    + contradict Hy; apply Hnv; assumption.\n    + rewrite (IHHy t2'0); [reflexivity|assumption].\n    + contradict H3; apply Hnv; assumption.\n  - inversion Hy'.\n    + contradict Hy; apply Hnv; rewrite <- H; constructor.\n    + contradict Hy; apply Hnv; rewrite <- H; constructor; assumption.\n    + contradict Hy; apply Hnv; assumption.\n    + rewrite (IHHy t1'0); [reflexivity|assumption].\n  - inversion Hy'.\n    + rewrite (IHHy t2'0); [reflexivity|assumption].\n    + contradict H3; apply Hnv; assumption.\n  - inversion Hy'.\n    + contradict Hy; apply Hnv; assumption.\n    + rewrite (IHHy t1'0); [reflexivity|assumption].\n  - inversion Hy'.\n    + reflexivity.\n    + contradict H0; apply Hlv; constructor.\n  - inversion Hy'.\n    + reflexivity.\n    + contradict H2; apply Hlv; constructor; assumption.\n  - inversion Hy'.\n    + contradict Hy; apply Hlv; rewrite <- H0; constructor.\n    + contradict Hy; apply Hlv; rewrite <- H; constructor; assumption.\n    + rewrite (IHHy t1'0); [reflexivity|assumption].\n  - inversion Hy'.\n    + reflexivity.\n    + contradict H5; apply Hlv; constructor; assumption.\n    + contradict H4; apply Hnv; constructor.\n  - inversion Hy'.\n    + reflexivity.\n    + contradict H6; apply Hlv; constructor; assumption.\n    + contradict H5; apply Hnv; constructor; assumption.\n  - inversion Hy'.\n    + contradict Hy; apply Hlv; rewrite <- H1, H3; constructor; assumption.\n    + contradict Hy; apply Hlv; rewrite <- H1; constructor; assumption.\n    + rewrite (IHHy t2'0); [reflexivity|assumption].\n    + contradict H3; apply Hnv; assumption.\n  - inversion Hy'.\n    + contradict Hy; apply Hnv; rewrite <- H; constructor.\n    + contradict Hy; apply Hnv; rewrite <- H; constructor; assumption.\n    + contradict Hy; apply Hnv; assumption.\n    + rewrite (IHHy t1'0); [reflexivity|assumption].\n  - inversion Hy'.\n    + reflexivity.\n    + contradict H1; apply Hnv; assumption.\n  - inversion Hy'.\n    + contradict Hy; apply Hnv; assumption.\n    + rewrite (IHHy t1'0); [reflexivity|assumption].\nQed.\n\nTheorem progress_dec : progress \\\/ ~ progress.\nProof.\n  right; intros prog; specialize (prog (idx zro nul) Nat).\n  assert (|- idx zro nul \\in Nat) as HT; [repeat constructor|specialize (prog HT); clear HT].\n  destruct prog as [[Hnat|Hlist]|[t Hstep]].\n  - inversion Hnat.\n  - inversion Hlist.\n  - inversion Hstep; [inversion H3|inversion H2].\nQed.\n\nTheorem preservation_dec : preservation \\\/ ~ preservation.\nProof.\n  left; intros t t' T Htype Hstep; revert T Htype; induction Hstep; intros.\n  - inversion Htype; constructor; apply IHHstep; assumption.\n  - inversion Htype; assumption.\n  - inversion Htype; constructor; constructor; inversion H3; assumption.\n  - inversion Htype; constructor; [|apply IHHstep]; assumption.\n  - inversion Htype; constructor; [apply IHHstep|]; assumption.\n  - inversion Htype; constructor; [|apply IHHstep]; assumption.\n  - inversion Htype; constructor; [apply IHHstep|]; assumption.\n  - inversion Htype; constructor.\n  - inversion Htype; repeat constructor; inversion H2; assumption.\n  - inversion Htype; constructor; apply IHHstep; assumption.\n  - inversion Htype; inversion H5; assumption.\n  - inversion Htype; constructor; inversion H4; inversion H6; assumption.\n  - inversion Htype; constructor; [|apply IHHstep]; assumption.\n  - inversion Htype; constructor; [apply IHHstep|]; assumption.\n  - inversion Htype; repeat constructor; assumption.\n  - inversion Htype; constructor; apply IHHstep; assumption.\nQed.\n\nCorollary soundness_dec : soundness \\\/ ~ soundness.\nProof.\n  right; intros sound; specialize (sound (idx zro nul) (idx zro nul) Nat).\n  assert (|- idx zro nul \\in Nat) as HT; [repeat constructor|specialize (sound HT); clear HT].\n  specialize (sound (multi_refl step (idx zro nul))).\n  contradict sound; split.\n  - intros [t' Ht']; inversion Ht'; [inversion H3|inversion H2].\n  - intros [v|v]; inversion v.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32975,"user_id":null,"body":"Require Import Preloaded.\n\nLemma nvalue_no_step: forall t1 t2, nvalue t1 -> ~(t1 --> t2).\nProof.\n  induction t1; unfold not; intros.\n  - remember zro as x in H0; destruct H0; discriminate.\n  - remember (scc t1) as x in H; destruct H; try discriminate;\n    injection Heqx; intros Heq; rewrite Heq in H; clear Heqx Heq v1.\n    remember (scc t1) as x in H0; induction H0; try discriminate.\n    injection Heqx; intros Heq; rewrite Heq in H0; case (IHt1 _ H H0).\n  - remember (pls t1_1 t1_2) as x in H; destruct H; discriminate.\n  - remember nul as x in H; destruct H; discriminate.\n  - remember (cns t1_1 t1_2) as x in H; destruct H; discriminate.\n  - remember (len t1) as x in H; destruct H; discriminate.\n  - remember (idx t1_1 t1_2) as x in H; destruct H; discriminate.\n  - remember (stn t1) as x in H; destruct H; discriminate.\nQed.\n\nLemma lvalue_no_step: forall t1 t2, lvalue t1 -> ~(t1 --> t2).\nProof.\n  induction t1; unfold not; intros.\n  - remember zro as x in H; destruct H; discriminate.\n  - remember (scc t1) as x in H; destruct H; discriminate.\n  - remember (pls t1_1 t1_2) as x in H; destruct H; discriminate.\n  - remember nul as x in H0; destruct H0; discriminate.\n  - remember (cns t1_1 t1_2) as x in H; destruct H; try discriminate;\n    injection Heqx; intros Heq1 Heq2; rewrite Heq1 in H1; rewrite Heq2 in H; clear Heqx Heq1 Heq2 v1 v2.\n    remember (cns t1_1 t1_2) as x in H0; induction H0; try discriminate.\n    + injection Heqx; intros Heq; rewrite Heq in H2; case (IHt1_2 _ H1 H2).\n    + injection Heqx; intros _ Heq; rewrite Heq in H0; case (nvalue_no_step _ _ H H0).\n  - remember (len t1) as x in H; destruct H; discriminate.\n  - remember (idx t1_1 t1_2) as x in H; destruct H; discriminate.\n  - remember (stn t1) as x in H; destruct H; discriminate.\nQed.\n\nLemma value_no_step: forall t1 t2, value t1 -> ~(t1 --> t2).\nProof.\n  intros; destruct H.\n  - exact (nvalue_no_step _ _ H).\n  - exact (lvalue_no_step _ _ H).\nQed.\n\nTheorem step_deterministic : deterministic step.\nProof.\n  unfold deterministic; intros x y1 y2 r1; revert y2; induction r1.\n  - intros y2 r2; remember (scc t1) as x in r2; induction r2; try discriminate.\n    injection Heqx; intros Heq; rewrite Heq in r2; rewrite (IHr1 _ r2); reflexivity.\n  - intros y2 r2; remember (pls zro v1) as x in r2; induction r2; try discriminate.\n    + injection Heqx; intros Heq; rewrite Heq; reflexivity.\n    + injection Heqx; intros Heq; rewrite Heq in r2; case (nvalue_no_step _ _ H r2).\n    + injection Heqx; intros _ Heq; rewrite Heq in r2; case (nvalue_no_step _ _ nv_zro r2).\n  - intros y2 r2; remember (pls (scc v1) v2) as x in r2; induction r2; try discriminate.\n    + injection Heqx; intros Heq1 Heq2; rewrite Heq1, Heq2; reflexivity.\n    + injection Heqx; intros Heq; rewrite Heq in r2; case (nvalue_no_step _ _ H0 r2).\n    + injection Heqx; intros _ Heq; rewrite Heq in r2; case (nvalue_no_step _ _ (nv_scc _ H) r2).\n  - intros y2 r2; remember (pls v1 t2) as x in r2; induction r2; try discriminate.\n    + injection Heqx; intros Heq; rewrite Heq in H0; case (nvalue_no_step _ _ H0 r1).\n    + injection Heqx; intros Heq; rewrite Heq in H1; case (nvalue_no_step _ _ H1 r1).\n    + injection Heqx; intros Heq1 Heq2; rewrite Heq1 in r2; rewrite Heq2, (IHr1 _ r2); reflexivity.\n    + injection Heqx; intros _ Heq; rewrite Heq in r2; case (nvalue_no_step _ _ H r2).\n  - intros y2 r2; remember (pls t1 t2) as x in r2; induction r2; try discriminate.\n    + injection Heqx; intros _ Heq; rewrite <- Heq in r1; case (nvalue_no_step _ _ nv_zro r1).\n    + injection Heqx; intros _ Heq; rewrite <- Heq in r1; case (nvalue_no_step _ _ (nv_scc _ H) r1).\n    + injection Heqx; intros _ Heq; rewrite Heq in H; case (nvalue_no_step _ _ H r1).\n    + injection Heqx; intros Heq1 Heq2; rewrite Heq2 in r2; rewrite Heq1, (IHr1 _ r2); reflexivity.\n  - intros y2 r2; remember (cns v1 t2) as x in r2; induction r2; try discriminate.\n    + injection Heqx; intros Heq1 Heq2; rewrite Heq1 in r2; rewrite Heq2, (IHr1 _ r2); reflexivity.\n    + injection Heqx; intros _ Heq; rewrite Heq in r2; case (nvalue_no_step _ _ H r2).\n  - intros y2 r2; remember (cns t1 t2) as x in r2; induction r2; try discriminate.\n    + injection Heqx; intros _ Heq; rewrite Heq in H; case (nvalue_no_step _ _ H r1).\n    + injection Heqx; intros Heq1 Heq2; rewrite Heq2 in r2; rewrite Heq1, (IHr1 _ r2); reflexivity.\n  - intros y2 r2; remember (len nul) as x in r2; induction r2; try discriminate.\n    + reflexivity.\n    + injection Heqx; intros Heq; rewrite Heq in r2; case (lvalue_no_step _ _ lv_nul r2).\n  - intros y2 r2; remember (len (cns v1 v2)) as x in r2; induction r2; try discriminate.\n    + injection Heqx; intros Heq _; rewrite Heq; reflexivity.\n    + injection Heqx; intros Heq; rewrite Heq in r2; case (lvalue_no_step _ _ (lv_cns _ _ H H0) r2).\n  - intros y2 r2; remember (len t1) as x in r2; induction r2; try discriminate.\n    + injection Heqx; intros Heq; rewrite <- Heq in r1; case (lvalue_no_step _ _ lv_nul r1).\n    + injection Heqx; intros Heq; rewrite <- Heq in r1; case (lvalue_no_step _ _ (lv_cns _ _ H H0) r1).\n    + injection Heqx; intros Heq; rewrite Heq in r2; rewrite (IHr1 _ r2); reflexivity.\n  - intros y2 r2; remember (idx zro (cns v1 v2)) as x in r2; induction r2; try discriminate.\n    + injection Heqx; intros _ Heq; rewrite Heq; reflexivity.\n    + injection Heqx; intros Heq; rewrite Heq in r2; case (lvalue_no_step _ _ (lv_cns _ _ H H0) r2).\n    + injection Heqx; intros _ Heq; rewrite Heq in r2; case (nvalue_no_step _ _ nv_zro r2).\n  - intros y2 r2; remember (idx (scc v1) (cns v2 v3)) as x in r2; induction r2; try discriminate.\n    + injection Heqx; intros Heq1 _ Heq2; rewrite Heq1, Heq2; reflexivity.\n    + injection Heqx; intros Heq; rewrite Heq in r2; case (lvalue_no_step _ _ (lv_cns _ _ H0 H1) r2).\n    + injection Heqx; intros _ Heq; rewrite Heq in r2; case (nvalue_no_step _ _ (nv_scc _ H) r2).\n  - intros y2 r2; remember (idx v1 t2) as x in r2; induction r2; try discriminate.\n    + injection Heqx; intros Heq; rewrite <- Heq in r1; case (lvalue_no_step _ _ (lv_cns _ _ H0 H1) r1).\n    + injection Heqx; intros Heq; rewrite <- Heq in r1; case (lvalue_no_step _ _ (lv_cns _ _ H1 H2) r1).\n    + injection Heqx; intros Heq1 Heq2; rewrite Heq1 in r2; rewrite Heq2, (IHr1 _ r2); reflexivity.\n    + injection Heqx; intros _ Heq; rewrite Heq in r2; case (nvalue_no_step _ _ H r2).\n  - intros y2 r2; remember (idx t1 t2) as x in r2; induction r2; try discriminate.\n    + injection Heqx; intros _ Heq; rewrite <- Heq in r1; case (nvalue_no_step _ _ nv_zro r1).\n    + injection Heqx; intros _ Heq; rewrite <- Heq in r1; case (nvalue_no_step _ _ (nv_scc _ H) r1).\n    + injection Heqx; intros _ Heq; rewrite <- Heq in r1; case (nvalue_no_step _ _ H r1).\n    + injection Heqx; intros Heq1 Heq2; rewrite Heq2 in r2; rewrite Heq1, (IHr1 _ r2); reflexivity.\n  - intros y2 r2; remember (stn v1) as x in r2; induction r2; try discriminate.\n    + injection Heqx; intros Heq; rewrite Heq; reflexivity.\n    + injection Heqx; intros Heq; rewrite Heq in r2; case (nvalue_no_step _ _ H r2).\n  -  intros y2 r2; remember (stn t1) as x in r2; induction r2; try discriminate.\n    + injection Heqx; intros Heq; rewrite Heq in H; case (nvalue_no_step _ _ H r1).\n    + injection Heqx; intros Heq; rewrite Heq in r2; rewrite (IHr1 _ r2); reflexivity.\nQed.\n\nLemma counter_example : exists c, (exists T, |- c \\in T) \/\\ ~value c \/\\ ~(exists t, c --> t).\nProof.\n  exists (idx zro nul); unfold not; split; try split; intros.\n  - exists Nat; constructor; constructor.\n  - destruct H; remember (idx zro nul) in H; destruct H; discriminate.\n  - destruct H; remember (idx zro nul) in H; destruct H; try discriminate.\n    + injection Heqt; intros Heq; rewrite Heq in H0; case (lvalue_no_step _ _ lv_nul H0).\n    + injection Heqt; intros _ Heq; rewrite Heq in H; case (nvalue_no_step _ _ nv_zro H).\nQed.\n\nTheorem progress_dec : progress \\\/ ~ progress.\nProof.\n  right; destruct counter_example; unfold not, progress; intros; destruct H; destruct H, H1.\n  destruct (H0 x x0 H).\n  - case (H1 H3).\n  - case (H2 H3).\nQed.\n\nTheorem preservation_dec : preservation \\\/ ~ preservation.\nProof.\n  left; unfold preservation; intros; revert H; revert T; induction H0; intros.\n  - remember (scc t1) as x in H; destruct H; try discriminate; injection Heqx; intros Heq; rewrite Heq in H; clear Heqx Heq t0.\n    constructor; exact (IHstep _ H).\n  - remember (pls zro v1) as x in H0; destruct H0; try discriminate; clear Heqx H0_ H0_0 t1 t2.\n    induction H; constructor; exact IHnvalue.\n  - remember (pls (scc v1) v2) as x in H1; destruct H1; try discriminate; clear Heqx H1_ H1_0 t1 t2; constructor; constructor;\n    try (induction H; constructor; exact IHnvalue); induction H0; constructor; exact IHnvalue.\n  - remember (pls v1 t2) as x in H1; destruct H1; try discriminate; injection Heqx; intros Heq _; rewrite Heq in H1_0; clear Heqx Heq t0 H1_ t1 H0.\n    constructor; try exact (IHstep _ H1_0); induction H; constructor; exact IHnvalue.\n  - remember (pls t1 t2) as x in H; destruct H; try discriminate; injection Heqx; intros Heq1 Heq2; rewrite Heq1 in H1; rewrite Heq2 in H; clear Heqx Heq1 Heq2 t0 t3 H0.\n    constructor; try exact H1; exact (IHstep _ H).\n  - remember (cns v1 t2) as x in H1; destruct H1; try discriminate; injection Heqx; intros Heq _; rewrite Heq in H1_0; clear Heqx Heq t0 H1_ t1 H0.\n    constructor; try exact (IHstep _ H1_0); induction H; constructor; exact IHnvalue.\n  - remember (cns t1 t2) as x in H; destruct H; try discriminate; injection Heqx; intros Heq1 Heq2; rewrite Heq1 in H1; rewrite Heq2 in H; clear Heqx Heq1 Heq2 t0 t3 H0.\n    constructor; try exact H1; exact (IHstep _ H).\n  - remember (len nul) as x in H; destruct H; try discriminate; constructor.\n  - remember (len (cns v1 v2)) as x in H1; destruct H1; try discriminate; clear Heqx H1 H t1 v1.\n    constructor; constructor; induction H0; constructor; try exact IHlvalue; induction H; constructor; exact IHnvalue.\n  - remember (len t1) as x in H; destruct H; try discriminate; constructor.\n    injection Heqx; intros Heq; rewrite Heq in H; exact (IHstep _ H).\n  - remember (idx zro (cns v1 v2)) as x in H1; destruct H1; try discriminate; clear Heqx.\n    induction H; constructor; exact IHnvalue.\n  - remember (idx (scc v1) (cns v2 v3)) as x in H2; destruct H2; try discriminate; clear Heqx.\n    constructor; try (induction H; constructor; exact IHnvalue); induction H1; constructor; try exact IHlvalue; induction H1; constructor; exact IHnvalue.\n  - remember (idx v1 t2) as x in H1; destruct H1; try discriminate; injection Heqx; intros Heq1 Heq2; rewrite Heq1 in H1_0; rewrite Heq2 in H1_.\n    constructor; try exact H1_; exact (IHstep _ H1_0).\n  - remember (idx t1 t2) as x in H; destruct H; try discriminate; injection Heqx; intros Heq1 Heq2; rewrite Heq1 in H1; rewrite Heq2 in H.\n    constructor; try exact H1; exact (IHstep _ H).\n  - remember (stn v1) as x in H0; destruct H0; try discriminate; injection Heqx; intros Heq; rewrite Heq in H0.\n    constructor; try exact H0; constructor.\n  - remember (stn t1) as x in H; destruct H; try discriminate; injection Heqx; intros Heq; rewrite Heq in H.\n    constructor; exact (IHstep _ H).\nQed.\n\nCorollary soundness_dec : soundness \\\/ ~ soundness.\nProof.\n  right; destruct counter_example; unfold not, soundness; intros; destruct H; destruct H, H1.\n  assert (stuck x).\n    unfold stuck, step_normal_form; split; try (exact H1); exact H2.\n  case (H0 _ _ _ H (multi_refl _ _) H3).\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32976,"user_id":null,"body":"Require Import Preloaded.\n\nLemma nvalue_nf : forall v, nvalue v -> normal_form step v.\nProof.\n  intros. unfold normal_form. intros contra.\n  destruct contra as (t & contra).\n  induction contra; inversion H; auto.\nQed.\n\nLemma lvalue_nf : forall v, lvalue v -> normal_form step v.\nProof.\n  intros. unfold normal_form. intros contra.\n  destruct contra as (t & contra).\n  induction contra; inversion H; auto.\n  apply nvalue_nf in H2. contradiction H2. eexists; eassumption.\nQed.\n\nLemma value_nf : forall v, value v -> normal_form step v.\nProof.\n  intros. destruct H.\n  - apply nvalue_nf. assumption.\n  - apply lvalue_nf. assumption.\nQed.\n\nLtac eliminate_impossible_steps :=\n  match goal with\n  | [ H0 : ?t --> _ |- _ ] =>\n    solve [\n      exfalso; apply (nvalue_nf t); [ try constructor; assumption | eexists; eauto ]\n    | exfalso; apply (lvalue_nf t); [ try constructor; assumption | eexists; eauto ]\n    ]\n  end.\n\nTheorem step_deterministic : deterministic step.\nProof.\n  unfold deterministic; intros.\n  revert dependent y2.\n  induction H; intros y2 Hy2; inversion Hy2; subst;\n    try eliminate_impossible_steps;\n    try reflexivity;\n    try (erewrite IHstep by eassumption; reflexivity).\nQed.\n\nLemma value_nat : forall v, value v -> |- v \\in Nat -> nvalue v.\nProof.\n  intros. destruct H as [H|H].\n  - assumption.\n  - inversion H; subst; inversion H0.\nQed.\n\nLemma value_list : forall v, value v -> |- v \\in List -> lvalue v.\nProof.\n  intros. destruct H as [H|H].\n  - inversion H; subst; inversion H0.\n  - assumption.\nQed.\n\nLemma contrapositive : forall {A B : Prop}, (A -> B) -> ~ B -> ~ A.\nProof.\n  auto.\nQed.\n\nTheorem progress_dec : progress \\\/ ~ progress.\nProof.\n  left. unfold progress. intros.\n  induction H.\n  - left. left. constructor.\n  - destruct IHhas_type as [IH|IH].\n    + left. repeat constructor. auto using value_nat.\n    + right. destruct IH as (t & IH). eauto using step.\n  - right.\n    destruct IHhas_type1 as [IH1|IH1].\n    + destruct IHhas_type2 as [IH2|IH2].\n      * apply value_nat in IH1; try assumption.\n        inversion IH1; subst; eauto using step, value_nat.\n      * destruct IH2 as (t & IH2). eauto using step, value_nat.\n    + destruct IH1 as (t & IH1). eauto using step.\n  - left. right. constructor.\n  - destruct IHhas_type1 as [IH1|IH1].\n    + destruct IHhas_type2 as [IH2|IH2].\n      * left. right. constructor; eauto using value_nat, value_list.\n      * right. destruct IH2 as (t & IH2). eauto using step, value_nat.\n    + right. destruct IH1 as (t & IH1). eauto using step.\n  - right. destruct IHhas_type as [IH|IH].\n    + apply value_list in IH; try assumption.\n      inversion IH; subst; eauto using step.\n    + destruct IH as (t & IH). eauto using step.\n  - right. destruct IHhas_type1 as [IH1|IH1].\n    + destruct IHhas_type2 as [IH2|IH2].\n      * apply value_nat in IH1; try assumption.\n        apply value_list in IH2; try assumption.\n        (* en fait c'est faux *)\nAbort.\n\n(* A read outside of a list stucks the program. *)\nTheorem progress_dec : progress \\\/ ~ progress.\nProof.\n  right. intros contra.\n  specialize (contra (idx (scc zro) nul) Nat).\n  apply contrapositive in contra.\n  - apply contra. repeat constructor.\n  - intros [contra2|contra2].\n    + destruct contra2 as [contra2|contra2]; inversion contra2.\n    + destruct contra2 as (t & contra2).\n      inversion contra2; subst.\n      -- inversion H3.\n      -- inversion H2; subst. inversion H0.\nQed.\n\nLemma nvalue_nat : forall v, nvalue v -> |- v \\in Nat.\nProof.\n  intros. induction H.\n  - constructor.\n  - constructor. assumption.\nQed.\n\nLemma lvalue_list : forall v, lvalue v -> |- v \\in List.\nProof.\n  intros. induction H.\n  - constructor.\n  - constructor.\n    + apply nvalue_nat. assumption.\n    + assumption.\nQed.\n\n(* We can perform the induction either on step or has_type. *)\nTheorem preservation_dec : preservation \\\/ ~ preservation.\nProof.\n  left. unfold preservation. intros. revert dependent T.\n  induction H0; intros T HH; inversion HH; subst; repeat constructor; eauto using nvalue_nat, lvalue_list.\nFail Fail Qed.\nAbort.\n\nTheorem preservation_dec : preservation \\\/ ~ preservation.\nProof.\n  left. unfold preservation. intros. revert dependent t'.\n  induction H; intros t' HH; inversion HH; subst; repeat constructor; eauto using nvalue_nat, lvalue_list.\nQed.\n\nCorollary soundness_dec : soundness \\\/ ~ soundness.\nProof.\n  right. intros contra.\n  specialize (contra (idx (scc zro) nul) (idx (scc zro) nul) Nat ltac:(repeat constructor) ltac:(constructor)).\n  apply contra. split.\n  - intros (t & contra2). inversion contra2; subst.\n    + inversion H3.\n    + inversion H2; subst. inversion H0.\n  - intros [contra2|contra2]; inversion contra2.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32977,"user_id":null,"body":"Require Import Preloaded.\n\nHint Constructors nvalue lvalue step has_type : core.\n\nLemma nvalue_step_nf : forall t, nvalue t -> step_normal_form t.\nProof with eauto.\n  induction 1; hnf; intros [t' Hcontra]; inversion Hcontra; subst...\nQed.\n\nLemma lvalue_step_nf : forall t, lvalue t -> step_normal_form t.\nProof with eauto.\n  induction 1; hnf; intros [t' Hcontra]; inversion Hcontra; subst...\n  pose proof (nvalue_step_nf _ H)...\nQed.\n\nLtac exfalso_by_value_stepping :=\n  match goal with\n  | [Hnvalue : nvalue ?v,\n     Hcontra : ?v --> ?v' |- _] =>\n    exfalso; apply (nvalue_step_nf _ Hnvalue); eauto\n  | [Hnvalue : nvalue ?v,\n     Hcontra : scc ?v --> _ |- _] =>\n    exfalso; assert (Hnvaluescc : nvalue (scc v)) by eauto;\n    apply (nvalue_step_nf _ Hnvaluescc); eauto\n  | [Hzrostep : zro --> _ |- _] => inversion Hzrostep\n  | [Hnulstep : nul --> _ |- _] => inversion Hnulstep\n  | [Hnvalue : nvalue ?v1 , Hlvalue : lvalue ?v2 ,\n     Hcontra : cns ?v1 ?v2 --> _ |- _] =>\n    exfalso; assert (Hlvaluecns : lvalue (cns v1 v2)) by eauto;\n    apply (lvalue_step_nf _ Hlvaluecns); eauto\n  | _ => idtac\n  end.\n\nTheorem step_deterministic : deterministic step.\nProof. hnf.\n       induction x; intros ? ? Hstep1 Hstep2;\n         exfalso_by_value_stepping;\n         try solve[inversion Hstep1; subst; inversion Hstep2; subst; eauto;\n                   exfalso_by_value_stepping;\n                   match goal with\n                   | [IH : forall y1 y2 : tm, ?x --> y1 -> ?x --> y2 -> y1 = y2 ,\n                      Hstep1 : ?x --> ?y1, Hstep2 : ?x --> ?y2 |- _] =>\n                     specialize (IH _ _ Hstep1 Hstep2); subst; reflexivity\n                   end].\nQed.\n\nLemma nvalue_inversion : forall t, value t -> |- t \\in Nat -> nvalue t.\nProof.\n  remember Nat as N; induction 2; subst; eauto;\n    try solve[inversion HeqN];\n    repeat match goal with\n           | [Hlval : lvalue ?t |- _] => inversion Hlval; eauto\n           | [Hnval : nvalue ?t |- _] => inversion Hnval; eauto\n           | [Hval : value ?t |- _] => inversion Hval; eauto; clear Hval\n           end.\nQed.\n\nLemma lvalue_inversion : forall t, value t -> |- t \\in List -> lvalue t.\nProof.\n  remember List as L; induction 2; subst; eauto;\n    try solve[inversion HeqL];\n    repeat match goal with\n           | [Hlval : lvalue ?t |- _] => inversion Hlval; eauto\n           | [Hnval : nvalue ?t |- _] => inversion Hnval; eauto\n           | [Hval : value ?t |- _] => inversion Hval; eauto; clear Hval\n           end.\nQed.\n\nTheorem progress_dec : progress \\\/ ~ progress.\nProof.\n  right. unfold not. intros. unfold progress in H.\n  assert (Htype : |- idx zro nul \\in Nat) by eauto.\n  specialize (H (idx zro nul) Nat Htype). destruct H.\n  - pose proof (nvalue_inversion _ H Htype). inversion H0.\n  - destruct H. inversion H; subst; exfalso_by_value_stepping.\nQed.\n\nTheorem preservation_dec : preservation \\\/ ~ preservation.\nProof.\n  left. hnf. intros ? ? ? Htype Hstep. generalize dependent t'.\n  induction Htype; intros; eauto; exfalso_by_value_stepping;\n    inversion Hstep; subst; eauto.\n  - inversion Htype1; subst; eauto.\n  - inversion Htype; subst; eauto.\n  - inversion Htype2; subst; eauto.\n  - inversion Htype1; subst. inversion Htype2; subst. eauto.\nQed.\n\nCorollary soundness_dec : soundness \\\/ ~ soundness.\nProof.\n  right. hnf. unfold soundness. intros.\n  assert (Htype : |- idx zro nul \\in Nat) by eauto.\n  assert (Hstep : idx zro nul -->* idx zro nul) by constructor.\n  specialize (H _ _ _ Htype Hstep). unfold stuck in H. apply H. split.\n  - hnf. intros. destruct H0. inversion H0; subst. inversion H5. inversion H4.\n  - hnf. intros. pose proof (nvalue_inversion _ H0 Htype). inversion H1.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32978,"user_id":null,"body":"Require Import Preloaded.\n\nLemma nvalue_not_step (t1 t2 : tm)\n      (h1 : t1 --> t2) (h2 : nvalue t1) :\n  False.\nProof.\n  revert t2 h1.\n  induction h2; intros t2 h1; inversion h1.\n  subst t2 v1. apply (IHh2 _ H0).\nQed.\n\nLemma lvalue_not_step (t1 t2 : tm)\n      (h1 : t1 --> t2) (h2 : lvalue t1) :\n  False.\nProof.\n  revert t2 h1.\n  induction h2; intros t2 h1; inversion h1; subst.\n  - apply (IHh2 _ H4).\n  - apply (nvalue_not_step _ _ H3 H).\nQed.\n\nLtac no_step :=\n  match goal with\n  | [ h : nvalue ?v, h' : ?v --> ?v' |- _ ] =>\n    destruct (nvalue_not_step _ _ h' h)\n  | [ h' : scc ?v --> ?v' |- _ ] =>\n    let h := fresh \"H\" in\n    assert (h : nvalue (scc v));\n    [ (repeat constructor; assumption)\n      | destruct (nvalue_not_step _ _ h' h)]\n  | [ h' : zro --> ?v' |- _ ] =>\n    inversion h'\n  | [ h' : cns ?a ?b --> ?v' |- _ ] =>\n    let h := fresh \"H\" in\n    assert (h : lvalue (cns a b));\n    [ (repeat constructor; assumption)\n      | destruct (lvalue_not_step _ _ h' h)]\n  | [ h' : nul --> ?v' |- _ ] =>\n    inversion h'\n  end.\n\nLtac finish :=\n  match goal with\n  | [ h : forall v : tm, ?t --> v -> ?v' = v, h' : ?t --> ?v'' |- _  ] =>\n    rewrite (h _ h'); reflexivity\n  end.\n\nLtac doodah h :=\n  inversion h; subst; try reflexivity; try no_step; try finish.\n\nTheorem step_deterministic : deterministic step.\nProof.\n  intros x y1 y2 h1. revert y2.\n  induction h1; intros y2 h2\n  ; try (doodah h2; fail \"foo\").\nQed.\n\nTheorem nvalue_has_type (v : tm) (h : nvalue v) :\n|- v \\in Nat.\nProof.\n  induction h; repeat constructor; assumption.\nQed.\n\nTheorem lvalue_has_type (v : tm) (h : lvalue v) :\n|- v \\in List.\nProof.\n  induction h; constructor ; try apply nvalue_has_type; assumption.\nQed.\n\nLtac value_type :=\n  match goal with\n  | [ h : nvalue ?v |- (|- ?v \\in Nat) ] => apply (nvalue_has_type _ h)\n  | [ h : lvalue ?v |- (|- ?v \\in List) ] => apply (lvalue_has_type _ h)\n  end.\n\nLtac apply_ih :=\n  match goal with\n  | [ h : forall v', ?v --> v' -> (|- v' \\in ?T) |- _ ] => apply h; assumption\n  end.\n\nLtac pres_step :=\n  assumption\n  || constructor\n  || value_type\n  || apply_ih.\n\nLtac pres_step2 :=\n  inversion Ht'; subst; repeat pres_step; fail \"foo\".\n\nTheorem preservation_dec' : preservation.\nProof.\n  intros t t' T Ht Ht'.\n  revert t' Ht'.\n  induction Ht; intros; try pres_step2.\nQed.\n\nTheorem progress_dec : progress \\\/ ~ progress.\nProof.\n  right.\n  intro.\n  assert (H' : |- idx zro nul \\in Nat).\n  { repeat constructor. }\n  specialize (H (idx zro nul) Nat H').\n  destruct H as [ [|] | ]; inversion H.\n  inversion H0; subst.\n  - inversion H5.\n  - inversion H4.\nQed.\n    \nTheorem preservation_dec : preservation \\\/ ~ preservation.\nProof.\n  left. apply preservation_dec'.\nQed.\n\nCorollary soundness_dec : soundness \\\/ ~ soundness.\nProof.\n  (* left. intros t t' T Ht. *)\n  right. intro H.\n  assert (H' : |- idx zro nul \\in Nat).\n  { repeat constructor. }\n  specialize (H (idx zro nul) (idx zro nul) Nat H' (multi_refl _ _)).\n  apply H. clear H. unfold stuck, step_normal_form. split.\n  - intros [ t' H ]. inversion H; subst.\n    + inversion H4.\n    + inversion H3.\n  - intros [ H | H ]; inversion H.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32979,"user_id":null,"body":"Require Import Preloaded.\n\nLtac solve_by_inversion := repeat\n   ((match goal with  | [H :_ |- _ ]  => try (inversion H; auto; fail); clear H end)); fail.\n\nLemma nvalue_step: forall n m, nvalue n -> ~(n --> m).\nProof.\n  unfold not.\n  intros.\n  generalize dependent m.\n  induction H; intros.\n    inversion H0.\n  inversion H0; subst.\n  apply (IHnvalue t1'). auto.\nQed.\n\nLemma lvalue_step: forall n m, lvalue n -> ~(n --> m).\nProof.\n  unfold not.\n  intros.\n  generalize dependent m.\n  induction H; intros.\n    inversion H0.  \n  inversion H1; subst.\n    eapply IHlvalue. apply H6.\n  eapply (nvalue_step v1); auto.\n  apply H5.\nQed.\n\nLtac find_value_step :=\n  match goal with\n  | [H : nvalue ?n |- _ ] => \n    match goal with\n    | [ H0 : n --> ?x |- _ ] => \n        exfalso; apply (nvalue_step n x H); apply H0\n    end\n  | [H : lvalue ?n |- _ ] => \n    match goal with\n    | [ H0 : n --> ?x |- _ ] => \n        exfalso; apply (lvalue_step n x H); apply H0\n    end\n  end.\n\n\nTheorem step_deterministic : deterministic step.\nProof.\n  unfold deterministic.\n  intros.\n  generalize dependent y2.\n  induction H; intros.\n  {\n    induction y2; try solve_by_inversion.\n    f_equal.\n    inversion H0; subst. auto.\n  }\n    inversion H0; subst; auto; [|solve_by_inversion]. find_value_step.\n  {\n    inversion H1; subst; auto.\n      find_value_step.\n    inversion H5; subst.\n    find_value_step.\n  }\n  {\n    inversion H1; subst; try\n      find_value_step.\n    f_equal. auto.\n  }\n  {\n    inversion H0; subst; try find_value_step;\n      try solve_by_inversion.\n    inversion H; subst. find_value_step.\n    f_equal. auto.\n  }\n    inversion H1; subst. f_equal. auto. find_value_step.\n    inversion H0; subst. find_value_step. f_equal. auto.\n    inversion H0; subst; auto. inversion H1.\n    inversion H1; subst; auto. inversion H3; subst; find_value_step.\n  {\n    inversion H0; subst.\n      inversion H. \n      inversion H; subst; find_value_step.\n    f_equal. auto.\n  }\n    inversion H1; subst; auto; [|inversion H5]. inversion H6; subst; find_value_step.\n  {\n    inversion H2; subst; auto.\n      inversion H7; subst; find_value_step.\n    inversion H6; subst.\n    find_value_step.\n  }\n  {\n    inversion H1; subst; try find_value_step;\n      try (inversion H0;  find_value_step).\n    f_equal. auto.\n  }\n  {\n    inversion H0; subst; try find_value_step.\n      solve_by_inversion.\n      inversion H; subst. find_value_step.\n    f_equal. auto.\n  }\n    inversion H0 ;subst; auto. find_value_step.\n  inversion H0; subst.\n  find_value_step.\n  f_equal; auto.\nQed.\n\nTheorem progress_dec : progress \\\/ ~ progress.\nProof.\n  unfold progress.\n  right.\n  unfold not.\n  intros.\n  destruct (H (idx (scc zro) nul) Nat).\n    constructor; constructor. constructor.\n    inversion H0. inversion H1. inversion H1.\n  destruct H0.\n  inversion H0; subst.\n    inversion H5.\n  inversion H4. subst.\n  inversion H2.\nQed.\n\nLemma nvalue_nat: forall n, nvalue n -> has_type n Nat.\nProof.\n  intros.\n  induction H; constructor.\n  auto.\nQed.\n\nLemma lvalue_list: forall l, lvalue l -> has_type l List.\nProof.\n  intros.\n  induction H; constructor; auto.\n  apply nvalue_nat. auto.\nQed.\n\nTheorem preservation_dec : preservation \\\/ ~ preservation.\nProof.\n  unfold preservation.\n  left.\n  intros.\n  generalize dependent t'.\n  induction H; intros; subst;\n    try solve_by_inversion.\n    inversion H0; subst. constructor. auto.\n  { \n    inversion H1; subst; auto.\n      constructor; auto. constructor; apply nvalue_nat; auto.\n      constructor; auto.\n    constructor; auto.\n  }\n    inversion H1; subst. constructor; auto. constructor; auto.\n    inversion H0; subst; repeat constructor. apply lvalue_list. auto. apply IHhas_type. auto.\n  {\n    inversion H1; subst.\n      apply nvalue_nat. auto.\n      constructor. apply nvalue_nat; auto. apply lvalue_list. auto.\n      constructor. apply nvalue_nat. auto. apply IHhas_type2. auto.\n    constructor; auto.\n  }\n  inversion H0; subst.\n    constructor; auto. constructor.\n  constructor. auto.\nQed.\n\nCorollary soundness_dec : soundness \\\/ ~ soundness.\nProof.\n  right.\n  unfold soundness.\n  unfold not.\n  unfold stuck.\n  intros.\n  apply (H (idx (scc zro) nul) (idx (scc zro) nul) Nat).\n    repeat constructor. repeat constructor.\n  split.\n  {\n    unfold step_normal_form.\n    unfold not.\n    intros.\n    destruct H0.\n    inversion H0; subst. inversion H5.\n    inversion H4. subst. inversion H2.\n  }\n  unfold not.\n  intros.\n  inversion H0;  \n    inversion H1.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5d02f11c92613c000f41a3a7":[{"id":32980,"user_id":null,"body":"Require Import Preloaded.\nLtac ski1 := apply red_S || apply red_K || apply red_I.\nLtac skis1 := ski1 || (apply red_head; skis1) || (apply red_tail; skis1).\n\nLtac ski := apply rtc_refl || (refine (rtc_trans1 _ _ _); [skis1|]).\nLtac skis := intros; repeat ski.\n\nLemma ski_trans : forall {a b c}, a ==>* b -> b ==>* c -> a ==>* c.\nProof.\n  intros a b c Hab Hbc; induction Hab; [easy|].\n  now apply rtc_trans1 with b, IHHab.\nQed.\n\nLemma ski_head : forall {a a' b}, a ==>* a' -> [[a b]] ==>* [[a' b]].\nProof.\n  intros a a' b Haa'; induction Haa'; [apply rtc_refl|].\n  apply rtc_trans1 with [[b0 b]]; [apply red_head|]; easy.\nQed.\n\nLemma ski_tail : forall {a b b'}, b ==>* b' -> [[a b]] ==>* [[a b']].\nProof.\n  intros a b b' Hbb'; induction Hbb'; [apply rtc_refl|].\n  apply rtc_trans1 with [[a b]]; [apply red_tail|]; easy.\nQed.\n\nLtac ski_with1 H := apply H || (refine (ski_head _); ski_with1 H) || (refine (ski_tail _); ski_with1 H).\nLtac ski_with H := refine (ski_trans _ _); [ski_with1 H|].\n\n(* rev x f := f x *)\nDefinition rev : SKI := [[S (K (S I)) K]].\nTheorem rev_correct : forall f x, [[{rev} x f]] ==>* [[f x]].\nProof. skis. Qed.\n\n(* B f g x := f (g x) *)\nDefinition B : SKI := [[S (K S) K]].\nTheorem B_correct : forall f g x, [[{B} f g x]] ==>* [[f (g x)]].\nProof. skis. Qed.\n\n(* C f x y := f y x *)\nDefinition C : SKI := [[{B} ({B} ({rev} K) {B}) S]].\nTheorem C_correct : forall f x y, [[{C} f x y]] ==>* [[f y x]].\nProof. skis. Qed.\n\n(* rotr y f x := f x y *)\nDefinition rotr : SKI := [[{C} {C}]].\nTheorem rotr_correct : forall f x y, [[{rotr} y f x]] ==>* [[f x y]].\nProof. skis. Qed.\n\n(* rotv x y f := f x y *)\nDefinition rotv : SKI := [[{B} {C} {rev}]].\nTheorem rotv_correct : forall f x y, [[{rotv} x y f]] ==>* [[f x y]].\nProof. skis. Qed.\n\n(* Y f := (\\x. f (x x)) (\\x. f (x x)) *)\n(* The Y combinator has the property `Y f = f (Y f)`, but we can't prove it with direct reduction.\n   Instead, we prove that both sides reduce to the same term. *)\nDefinition Y : SKI := [[S ({B} ({C} S I) {B}) ({B} ({C} S I) {B})]].\nTheorem Y_correct : forall f, exists t, ([[{Y} f]] ==>* t) \/\\ ([[f ({Y} f)]] ==>* t).\nProof.\n  intros; exists ([[f (S ({B} f) I (S ({B} f) I))]]); split.\n  - ski; ski_with B_correct; ski_with C_correct; ski_with B_correct.\n    ski_with C_correct; ski; ski_with B_correct; apply ski_tail, ski_tail; skis.\n  - apply ski_tail; ski; ski_with B_correct; ski_with C_correct.\n    ski_with B_correct; ski_with C_correct; ski.\nQed.\n\n(* Boolean logic. Church booleans are used. *)\n(* T x y := x *)\n(* F x y := y *)\nDefinition T : SKI := [[K]].\nTheorem T_correct : forall x y, [[{T} x y]] ==>* [[x]].\nProof. skis. Qed.\n\nDefinition F : SKI := [[K I]].\nTheorem F_correct : forall x y, [[{F} x y]] ==>* [[y]].\nProof. skis. Qed.\n\n(* Notations for expressing a term is extensionally equal to T or F, respectively. *)\nNotation \"t ~~>*T\" := (forall x y, [[{t} x y]] ==>* [[x]]) (at level 90, only parsing).\nNotation \"t ~~>*F\" := (forall x y, [[{t} x y]] ==>* [[y]]) (at level 90, only parsing).\n\nDefinition Not : SKI := C.\nTheorem NotT_F : [[{Not} {T}]] ~~>*F.\nProof. skis. Qed.\nTheorem NotF_T : [[{Not} {F}]] ~~>*T.\nProof. skis. Qed.\n\nDefinition And : SKI := [[{C} {C} {F}]].\nTheorem AndTT_T : [[{And} {T} {T}]] ~~>*T.\nProof. skis. Qed.\nTheorem AndTF_F : [[{And} {T} {F}]] ~~>*F.\nProof. skis. Qed.\nTheorem AndFT_F : [[{And} {F} {T}]] ~~>*F.\nProof. skis. Qed.\nTheorem AndFF_F : [[{And} {F} {F}]] ~~>*F.\nProof. skis. Qed.\n\nDefinition Or : SKI := [[{rev} {T}]].\nTheorem OrTT_T : [[{Or} {T} {T}]] ~~>*T.\nProof. skis. Qed.\nTheorem OrTF_T : [[{Or} {T} {F}]] ~~>*T.\nProof. skis. Qed.\nTheorem OrFT_T : [[{Or} {F} {T}]] ~~>*T.\nProof. skis. Qed.\nTheorem OrFF_F : [[{Or} {F} {F}]] ~~>*F.\nProof. skis. Qed.\n\nDefinition Xor : SKI := [[{rotv} {Not} I]].\nTheorem XorTT_F : [[{Xor} {T} {T}]] ~~>*F.\nProof. skis. Qed.\nTheorem XorTF_T : [[{Xor} {T} {F}]] ~~>*T.\nProof. skis. Qed.\nTheorem XorFT_T : [[{Xor} {F} {T}]] ~~>*T.\nProof. skis. Qed.\nTheorem XorFF_F : [[{Xor} {F} {F}]] ~~>*F.\nProof. skis. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32981,"user_id":null,"body":"Require Import Preloaded.\n\nLemma rtc_trans : forall {T} {R : T -> T -> Prop} a b c, rtc R a b -> rtc R b c -> rtc R a c.\nProof.\n  intros T R a b c ab bc; induction ab.\n  - apply bc.\n  - now apply rtc_trans1 with b, IHab, bc.\nQed.\n\nLemma simpl_S : forall a b c r, [[a c (b c)]] ==>* r -> [[S a b c]] ==>* r.\nProof.\n  intros a b c r H.\n  apply rtc_trans1 with [[a c (b c)]], H.\n  apply red_S.\nQed.\n\nLemma simpl_K : forall a b r, a ==>* r -> [[K a b]] ==>* r.\nProof.\n  intros a b r H.\n  apply rtc_trans1 with a, H.\n  apply red_K.\nQed.\n\nLemma simpl_I : forall a r, a ==>* r -> [[I a]] ==>* r.\nProof.\n  intros a r H.\n  apply rtc_trans1 with a, H.\n  apply red_I.\nQed.\n\nLemma simpl_app : forall f f' x x', f ==>* f' -> x ==>* x' -> [[f x]] ==>* [[f' x']].\nProof.\n  intros f f' x x' ff' xx'.\n  apply rtc_trans with [[f x']].\n  - clear f' ff'; induction xx'; [apply rtc_refl|].\n    apply rtc_trans1 with [[f b]], IHxx'.\n    apply red_tail, H.\n  - clear x xx'; induction ff'; [apply rtc_refl|].\n    apply rtc_trans1 with [[b x']], IHff'.\n    apply red_head, H.\nQed.\n\n(* rev x f := f x *)\nDefinition rev := [[S (K (S I)) K]].\nTheorem rev_correct : forall f x, [[{rev} x f]] ==>* [[f x]].\nProof.\n  intros f x.\n  apply rtc_trans with [[S I (K x) f]], simpl_S, simpl_app; [|apply simpl_I, rtc_refl|apply simpl_K, rtc_refl].\n  apply simpl_app, rtc_refl.\n  apply rtc_trans with [[S (K (S I)) K x]], simpl_S, simpl_app, rtc_refl; [|apply simpl_K, rtc_refl].\n  apply simpl_app; apply rtc_refl.\nQed.\n\n(* B f g x := f (g x) *)\nDefinition B := [[S (K S) K]].\nTheorem B_correct : forall f g x, [[{B} f g x]] ==>* [[f (g x)]].\nProof.\n  intros f g x.\n  apply rtc_trans with [[S (K f) g x]], simpl_S, simpl_app, rtc_refl; [|apply simpl_K, rtc_refl].\n  apply simpl_app, rtc_refl.\n  apply simpl_app, rtc_refl.\n  apply rtc_trans with [[S (K S) K f]], simpl_S, simpl_app, rtc_refl; [|apply simpl_K, rtc_refl].\n  apply simpl_app; apply rtc_refl.\nQed.\n\n(* C f x y := f y x *)\nDefinition C := [[S ({B} {B} S) (K K)]].\nTheorem C_correct : forall f x y, [[{C} f x y]] ==>* [[f y x]].\nProof.\n  intros f x y.\n  apply rtc_trans with [[S f (K x) y]], simpl_S, simpl_app, simpl_K, rtc_refl; [|apply rtc_refl].\n  apply simpl_app, rtc_refl.\n  apply rtc_trans with [[{B} (S f) K x]], B_correct.\n  apply simpl_app, rtc_refl.\n  apply rtc_trans with [[S ({B} {B} S) (K K) f]], simpl_S, simpl_app, simpl_K, rtc_refl; [|apply B_correct].\n  apply simpl_app; apply rtc_refl.\nQed.\n\n(* rotr y f x := f x y *)\nDefinition rotr := [[{C} {C}]].\nTheorem rotr_correct : forall f x y, [[{rotr} y f x]] ==>* [[f x y]].\nProof.\n  intros f x y.\n  apply rtc_trans with [[{C} f y x]], C_correct.\n  apply simpl_app, rtc_refl.\n  apply rtc_trans with [[{C} {C} y f]], C_correct.\n  apply simpl_app, rtc_refl.\n  apply simpl_app; apply rtc_refl.\nQed.\n\n(* rotv x y f := f x y *)\nDefinition rotv := [[{B} {C} {rev}]].\nTheorem rotv_correct : forall f x y, [[{rotv} x y f]] ==>* [[f x y]].\nProof.\n  intros f x y.\n  apply rtc_trans with [[{rev} x f y]], simpl_app, rtc_refl; [|apply rev_correct].\n  apply rtc_trans with [[{C} ({rev} x) y f]], C_correct.\n  apply simpl_app, rtc_refl.\n  apply simpl_app, rtc_refl.\n  apply rtc_trans with [[{B} {C} {rev} x]], B_correct.\n  apply simpl_app; apply rtc_refl.\nQed.\n\n(* Y f := (\\x. f (x x)) (\\x. f (x x)) *)\n(* The Y combinator has the property `Y f = f (Y f)`, but we can't prove it with direct reduction.\n   Instead, we prove that both sides reduce to the same term. *)\nDefinition Y := [[S ({B} (S I)) I (S ({B} (S I)) I)]].\nTheorem Y_correct : forall f, exists t, ([[{Y} f]] ==>* t) \/\\ ([[f ({Y} f)]] ==>* t).\nProof.\n  intros f; exists [[f ({Y} f)]]; split; [|apply rtc_refl].\n  apply rtc_trans with [[S I {Y} f]], simpl_S, simpl_app, rtc_refl; [|apply simpl_I, rtc_refl].\n  apply simpl_app, rtc_refl.\n  apply simpl_S, rtc_trans with [[S I (S ({B} (S I)) I (I (S ({B} (S I)) I)))]]; [apply B_correct|].\n  apply simpl_app, simpl_app, simpl_I; apply rtc_refl.\nQed.\n\n(* Boolean logic. Church booleans are used. *)\n(* T x y := x *)\n(* F x y := y *)\nDefinition T := [[K]].\nTheorem T_correct : forall x y, [[{T} x y]] ==>* [[x]].\nProof.\n  intros x y.\n  apply simpl_K, rtc_refl.\nQed.\n\nDefinition F := [[K I]].\nTheorem F_correct : forall x y, [[{F} x y]] ==>* [[y]].\nProof.\n  intros x y.\n  apply rtc_trans with [[I y]], simpl_I, rtc_refl.\n  apply simpl_app, rtc_refl.\n  apply rtc_trans with [[K I x]], simpl_K, rtc_refl.\n  apply simpl_app; apply rtc_refl.\nQed.\n\n(* Notations for expressing a term is extensionally equal to T or F, respectively. *)\nNotation \"t ~~>*T\" := (forall x y, [[{t} x y]] ==>* [[x]]) (at level 90, only parsing).\nNotation \"t ~~>*F\" := (forall x y, [[{t} x y]] ==>* [[y]]) (at level 90, only parsing).\n\nDefinition Not := C.\nTheorem NotT_F : [[{Not} {T}]] ~~>*F.\nProof.\n  intros x y.\n  apply rtc_trans with [[{T} y x]], T_correct.\n  apply C_correct.\nQed.\nTheorem NotF_T : [[{Not} {F}]] ~~>*T.\nProof.\n  intros x y.\n  apply rtc_trans with [[{F} y x]], F_correct.\n  apply C_correct.\nQed.\n\nDefinition And := [[{rotr} {F}]].\nLemma And_correct : forall x y, [[{And} x y]] ==>* [[x y {F}]].\nProof.\n  intros x y.\n  apply rtc_trans with [[{rotr} {F} x y]], rotr_correct.\n  apply simpl_app, rtc_refl.\n  apply simpl_app; apply rtc_refl.\nQed.\nTheorem AndTT_T : [[{And} {T} {T}]] ~~>*T.\nProof.\n  intros x y.\n  apply rtc_trans with [[{T} x y]], T_correct.\n  apply simpl_app, rtc_refl.\n  apply simpl_app, rtc_refl.\n  apply rtc_trans with [[{T} {T} {F}]], T_correct.\n  apply And_correct.\nQed.\nTheorem AndTF_F : [[{And} {T} {F}]] ~~>*F.\nProof.\n  intros x y.\n  apply rtc_trans with [[{F} x y]], F_correct.\n  apply simpl_app, rtc_refl.\n  apply simpl_app, rtc_refl.\n  apply rtc_trans with [[{T} {F} {F}]], T_correct.\n  apply And_correct.\nQed.\nTheorem AndFT_F : [[{And} {F} {T}]] ~~>*F.\nProof.\n  intros x y.\n  apply rtc_trans with [[{F} x y]], F_correct.\n  apply simpl_app, rtc_refl.\n  apply simpl_app, rtc_refl.\n  apply rtc_trans with [[{F} {T} {F}]], F_correct.\n  apply And_correct.\nQed.\nTheorem AndFF_F : [[{And} {F} {F}]] ~~>*F.\nProof.\n  intros x y.\n  apply rtc_trans with [[{F} x y]], F_correct.\n  apply simpl_app, rtc_refl.\n  apply simpl_app, rtc_refl.\n  apply rtc_trans with [[{F} {F} {F}]], F_correct.\n  apply And_correct.\nQed.\n\nDefinition Or := [[{rev} {T}]].\nLemma Or_correct : forall x y, [[{Or} x y]] ==>* [[x {T} y]].\nProof.\n  intros x y.\n  apply simpl_app, rtc_refl.\n  apply rtc_trans with [[{rev} {T} x]], rev_correct.\n  apply simpl_app; apply rtc_refl.\nQed.\nTheorem OrTT_T : [[{Or} {T} {T}]] ~~>*T.\nProof.\n  intros x y.\n  apply rtc_trans with [[{T} x y]], T_correct.\n  apply simpl_app, rtc_refl.\n  apply simpl_app, rtc_refl.\n  apply rtc_trans with [[{T} {T} {T}]], T_correct.\n  apply Or_correct.\nQed.\nTheorem OrTF_T : [[{Or} {T} {F}]] ~~>*T.\nProof.\n  intros x y.\n  apply rtc_trans with [[{T} x y]], T_correct.\n  apply simpl_app, rtc_refl.\n  apply simpl_app, rtc_refl.\n  apply rtc_trans with [[{T} {T} {F}]], T_correct.\n  apply Or_correct.\nQed.\nTheorem OrFT_T : [[{Or} {F} {T}]] ~~>*T.\nProof.\n  intros x y.\n  apply rtc_trans with [[{T} x y]], T_correct.\n  apply simpl_app, rtc_refl.\n  apply simpl_app, rtc_refl.\n  apply rtc_trans with [[{F} {T} {T}]], F_correct.\n  apply Or_correct.\nQed.\nTheorem OrFF_F : [[{Or} {F} {F}]] ~~>*F.\nProof.\n  intros x y.\n  apply rtc_trans with [[{F} x y]], F_correct.\n  apply simpl_app, rtc_refl.\n  apply simpl_app, rtc_refl.\n  apply rtc_trans with [[{F} {T} {F}]], F_correct.\n  apply Or_correct.\nQed.\n\nDefinition Xor := [[{rotv} {Not} I]].\nLemma Xor_correct : forall x, [[{Xor} x]] ==>* [[x {Not} I]].\nProof.\n  intros x.\n  apply rtc_trans with [[{rotv} {Not} I x]], rotv_correct.\n  apply simpl_app; apply rtc_refl.\nQed.\nTheorem XorTT_F : [[{Xor} {T} {T}]] ~~>*F.\nProof.\n  intros x y.\n  apply rtc_trans with [[{Not} {T} x y]], NotT_F.\n  apply simpl_app, rtc_refl.\n  apply simpl_app, rtc_refl.\n  apply simpl_app, rtc_refl.\n  apply rtc_trans with [[{T} {Not} I]], T_correct.\n  apply Xor_correct.\nQed.\nTheorem XorTF_T : [[{Xor} {T} {F}]] ~~>*T.\nProof.\n  intros x y.\n  apply rtc_trans with [[{Not} {F} x y]], NotF_T.\n  apply simpl_app, rtc_refl.\n  apply simpl_app, rtc_refl.\n  apply simpl_app, rtc_refl.\n  apply rtc_trans with [[{T} {Not} I]], T_correct.\n  apply Xor_correct.\nQed.\nTheorem XorFT_T : [[{Xor} {F} {T}]] ~~>*T.\nProof.\n  intros x y.\n  apply rtc_trans with [[{T} x y]], T_correct.\n  apply simpl_app, rtc_refl.\n  apply simpl_app, rtc_refl.\n  apply rtc_trans with [[I {T}]], simpl_I, rtc_refl.\n  apply simpl_app, rtc_refl.\n  apply rtc_trans with [[{F} {Not} I]], F_correct.\n  apply Xor_correct.\nQed.\nTheorem XorFF_F : [[{Xor} {F} {F}]] ~~>*F.\nProof.\n  intros x y.\n  apply rtc_trans with [[{F} x y]], F_correct.\n  apply simpl_app, rtc_refl.\n  apply simpl_app, rtc_refl.\n  apply rtc_trans with [[I {F}]], simpl_I, rtc_refl.\n  apply simpl_app, rtc_refl.\n  apply rtc_trans with [[{F} {Not} I]], F_correct.\n  apply Xor_correct.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32982,"user_id":null,"body":"Require Import Preloaded.\n\nLemma rtc_trans : forall a b c, [[a]] ==>* [[b]] -> [[b]] ==>* [[c]] -> [[a]] ==>* [[c]].\nProof.\n  induction 1; intros; eauto.\n  eapply rtc_trans1; eauto.\n  apply IHrtc. eauto.\nQed.\n\nLtac complete_ski := intros; cbv; eauto; repeat (eapply rtc_trans1; eauto 10).\n\n(* rev x f := f x *)\nDefinition rev : SKI := [[ S (K (S I)) K ]].\nTheorem rev_correct : forall f x, [[{rev} x f]] ==>* [[f x]].\nProof. complete_ski. Qed.\n\n(* B f g x := f (g x) *)\nDefinition B : SKI := [[ S (K S) K ]].\nTheorem B_correct : forall f g x, [[{B} f g x]] ==>* [[f (g x)]].\nProof. complete_ski. Qed.\n\n(* C f x y := f y x *)\nDefinition C : SKI := [[ S (S (K S) (S (K K) S)) (K K) ]].\nTheorem C_correct : forall f x y, [[{C} f x y]] ==>* [[f y x]].\nProof. complete_ski. Qed.\n\n(* rotr y f x := f x y *)\nDefinition rotr : SKI := [[ S (K (S S)) (S (K K) K) ]].\nTheorem rotr_correct : forall f x y, [[{rotr} y f x]] ==>* [[f x y]].\nProof. complete_ski. Qed.\n\n(* rotv x y f := f x y *)\nDefinition rotv : SKI := [[ S (S (K S) (S (K K) (S (K S) (S (K (S I)) K)))) (K K) ]].\nTheorem rotv_correct : forall f x y, [[{rotv} x y f]] ==>* [[f x y]].\nProof. complete_ski. Qed.\n\nDefinition Y_part : SKI := [[ S (S (K S) K) (K (S I I)) ]].\nLemma Y_part_correct : forall f x, [[{Y_part} f x]] ==>* [[f (x x)]].\nProof. complete_ski. Qed.\n\n(* Y f := (\\x. f (x x)) (\\x. f (x x)) *)\n(* The Y combinator has the property `Y f = f (Y f)`, but we can't prove it with direct reduction.\n   Instead, we prove that both sides reduce to the same term. *)\nDefinition Y : SKI := [[ S {Y_part} {Y_part} ]].\nTheorem Y_correct : forall f, exists t, ([[{Y} f]] ==>* t) \/\\ ([[f ({Y} f)]] ==>* t).\nProof.\n  unfold Y.\n  eauto 10 using rtc_trans, Y_part_correct.\nQed.\n\n(* Boolean logic. Church booleans are used. *)\n(* T x y := x *)\n(* F x y := y *)\nDefinition T : SKI := [[ K ]].\nTheorem T_correct : forall x y, [[{T} x y]] ==>* [[x]].\nProof. complete_ski. Qed.\n\nDefinition F : SKI := [[ S K ]].\nTheorem F_correct : forall x y, [[{F} x y]] ==>* [[y]].\nProof. complete_ski. Qed.\n\n(* Notations for expressing a term is extensionally equal to T or F, respectively. *)\nNotation \"t ~~>*T\" := (forall x y, [[{t} x y]] ==>* [[x]]) (at level 90, only parsing).\nNotation \"t ~~>*F\" := (forall x y, [[{t} x y]] ==>* [[y]]) (at level 90, only parsing).\n\nDefinition Not : SKI := [[ S (S I (K {F})) (K {T}) ]].\nTheorem NotT_F : [[{Not} {T}]] ~~>*F.\nProof. complete_ski. Qed.\nTheorem NotF_T : [[{Not} {F}]] ~~>*T.\nProof. complete_ski. Qed.\n\nDefinition And : SKI := [[ S S (K (K {F})) ]].\nTheorem AndTT_T : [[{And} {T} {T}]] ~~>*T.\nProof. complete_ski. Qed.\nTheorem AndTF_F : [[{And} {T} {F}]] ~~>*F.\nProof. complete_ski. Qed.\nTheorem AndFT_F : [[{And} {F} {T}]] ~~>*F.\nProof. complete_ski. Qed.\nTheorem AndFF_F : [[{And} {F} {F}]] ~~>*F.\nProof. complete_ski. Qed.\n\nDefinition Or : SKI := [[ S I (K {T}) ]].\nTheorem OrTT_T : [[{Or} {T} {T}]] ~~>*T.\nProof. complete_ski. Qed.\nTheorem OrTF_T : [[{Or} {T} {F}]] ~~>*T.\nProof. complete_ski. Qed.\nTheorem OrFT_T : [[{Or} {F} {T}]] ~~>*T.\nProof. complete_ski. Qed.\nTheorem OrFF_F : [[{Or} {F} {F}]] ~~>*F.\nProof. complete_ski. Qed.\n\nDefinition Xor : SKI := [[ S (S (K S) (S (S (K S) K) (K {Not}))) (K I) ]].\nTheorem XorTT_F : [[{Xor} {T} {T}]] ~~>*F.\nProof. complete_ski. Qed.\nTheorem XorTF_T : [[{Xor} {T} {F}]] ~~>*T.\nProof. complete_ski. Qed.\nTheorem XorFT_T : [[{Xor} {F} {T}]] ~~>*T.\nProof. complete_ski. Qed.\nTheorem XorFF_F : [[{Xor} {F} {F}]] ~~>*F.\nProof. complete_ski. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32983,"user_id":null,"body":"Require Import Preloaded Arith List.\n\nTheorem rtc_trans : forall x y z, x ==>* y -> y ==>* z -> x ==>* z.\nProof.\n  intros x y z xy yz; revert z yz; induction xy; intros.\n  - easy.\n  - apply rtc_trans1 with b; [|apply IHxy]; easy.\nQed.\n\nTheorem rtc_head : forall h h' t, h ==>* h' -> [[h t]] ==>* [[h' t]].\nProof.\n  intros h h' t hh'; revert t; induction hh'; intros.\n  - constructor.\n  - apply rtc_trans1 with [[b t]]; [|apply IHhh'].\n    now apply red_head.\nQed.\n\nTheorem rtc_tail : forall h t t', t ==>* t' -> [[h t]] ==>* [[h t']].\nProof.\n  intros h t t' tt'; revert h; induction tt'; intros.\n  - constructor.\n  - apply rtc_trans1 with [[h b]]; [|apply IHtt'].\n    now apply red_tail.\nQed.\n\nTheorem rtc_1 : forall x x', x ==> x' -> x ==>* x'.\nProof.\n  intros; apply rtc_trans1 with x'; [easy|constructor].\nQed.\n\nInductive lambda : Type :=\n  | lv : nat -> lambda\n  | la : lambda -> lambda -> lambda.\n\nInductive valid : nat -> lambda -> Prop :=\n  | vv : forall n, valid n (lv n)\n  | va : forall n l r, valid n l -> valid n r -> valid n (la l r)\n  | vs : forall n l, valid n l -> valid (Datatypes.S n) l.\n\nInductive free : nat -> lambda -> Prop :=\n  | fv : forall n m, n <> m -> free n (lv m)\n  | fa : forall n l r, free n l -> free n r -> free n (la l r).\n\nFixpoint step2 (l : lambda) (n nI : nat) : lambda :=\n  match l with\n  | lv m => if Nat.eq_dec n m then lv nI else la (lv (Datatypes.S nI)) l\n  | la l' r => la (la (lv (Datatypes.S (Datatypes.S nI))) (step2 l' n nI)) (step2 r n nI)\n  end.\n\nFixpoint step1 (l : lambda) (n nI : nat) : lambda :=\n  match n with\n  | 0 => l\n  | Datatypes.S n' => step1 (step2 l n' nI) n' nI\n  end.\n\nFixpoint run {T : Type} (l : lambda) (f : nat -> T) (ap : T -> T -> T) : T :=\n  match l with\n  | lv n => f n\n  | la l' r => ap (run l' f ap) (run r f ap)\n  end.\n\nDefinition toSKI_map (n m : nat) : SKI :=\n  match m - n with\n  | 0 => [[I]]\n  | 1 => [[K]]\n  | _ => [[S]]\n  end.\n\nDefinition toSKI (l : lambda) (n : nat) : SKI :=\n  run (step1 l n n) (toSKI_map n) App.\n\nFixpoint toClaimStart (s : SKI) (ss : list SKI) : SKI :=\n  match ss with\n  | nil => s\n  | h :: t => toClaimStart (App s h) t\n  end.\n\nDefinition toClaimResult (l : lambda) (s : list SKI) : SKI :=\n  run l (fun n => nth n s [[I]]) App.\n\nDefinition claim (l : lambda) (s : list SKI) : Prop :=\n  toClaimStart (toSKI l (length s)) s ==>* toClaimResult l s.\n\n\nLemma rtc_cs : forall s s' ss, s ==>* s' -> toClaimStart s ss ==>* toClaimStart s' ss.\nProof.\n  intros s s' ss ss'; revert s s' ss'; induction ss; intros; simpl.\n  - easy.\n  - now apply IHss, rtc_head.\nQed.\n\nLemma run_step2 : forall l n nI f,\n  f nI = [[I]] -> f (Datatypes.S nI) = [[K]] ->\n  f (Datatypes.S (Datatypes.S nI)) = [[S]] ->\n  [[{run (step2 l n nI) f App} {f n}]] ==>* run l f App.\nProof.\n  induction l; simpl; intros m nI f fI fK fS.\n  - destruct (Nat.eq_dec m n).\n    + subst; simpl; rewrite fI; apply rtc_1, red_I.\n    + simpl; rewrite fK; apply rtc_1, red_K.\n  - rewrite fS; refine (rtc_trans1 _ _ _); [apply red_S|].\n    apply rtc_trans with [[{run l1 f App} ({run (step2 l2 m nI) f App} {f m})]].\n    + now apply rtc_head, IHl1.\n    + now apply rtc_tail, IHl2.\nQed.\n\nFixpoint buildList (f : nat -> SKI) (n : nat) : list SKI :=\n  match n with\n  | 0 => nil\n  | Datatypes.S n' => buildList f n' ++ f n' :: nil\n  end.\n\nLemma cs_app : forall l s ss,\n  toClaimStart l (ss ++ s :: nil) = App (toClaimStart l ss) s.\nProof.\n  intros l s ss; revert l s; induction ss; intros.\n  - easy.\n  - simpl; now rewrite IHss.\nQed.\n\nLemma run_step1 : forall l n nI f,\n  f nI = [[I]] -> f (Datatypes.S nI) = [[K]] ->\n  f (Datatypes.S (Datatypes.S nI)) = [[S]] ->\n  toClaimStart (run (step1 l n nI) f App) (buildList f n) ==>* run l f App.\nProof.\n  intros l n; revert l; induction n; simpl; intros l nI f fI fK fS.\n  - constructor.\n  - apply rtc_trans with [[{run (step2 l n nI) f App} {f n}]]; [|now apply run_step2].\n    rewrite cs_app; now apply rtc_head, IHn.\nQed.\n\nLemma run_free : forall l f1 f2 n, free n l ->\n  (forall m, m <> n -> f1 m = f2 m) ->\n  run l f1 App = run l f2 App.\nProof.\n  induction 1; simpl; intros.\n  - apply H0; now contradict H.\n  - now rewrite IHfree1, IHfree2.\nQed.\n\nLemma le_dec_left : forall {T : Type} n m (x y : T), n <= m -> (if le_dec n m then x else y) = x.\nProof.\n  intros; now destruct (le_dec n m).\nQed.\n\nLemma le_dec_right : forall {T : Type} n m (x y : T), n > m -> (if le_dec n m then x else y) = y.\nProof.\n  intros; destruct (le_dec n m); [contradict l; apply gt_not_le|]; easy.\nQed.\n\nLemma run_cutoff_low : forall l f1 f2 n,\n  (forall m, m <= n -> free m l) ->\n  run l f1 App = run l (fun m => if le_dec m n then f2 m else f1 m) App.\nProof.\n  induction n; simpl; intros Hfree.\n  - apply run_free with 0; [apply Hfree, le_n|].\n    clear; now destruct m.\n  - rewrite IHn; [|intros; now apply Hfree, le_S].\n    apply run_free with (Datatypes.S n); [apply Hfree, le_n|].\n    intros m mdiff; destruct (nat_total_order _ _ mdiff).\n    + rewrite le_dec_left; [|now apply le_S_n].\n      rewrite le_dec_left; [|apply Nat.lt_le_incl]; easy.\n    + rewrite le_dec_right; [|now apply Nat.lt_le_incl].\n      now rewrite le_dec_right.\nQed.\n\nLemma run_cutoff_high : forall l f1 f2 n,\n  (forall m, m > n -> free m l) ->\n  run l f1 App = run l (fun m => if le_dec m n then f1 m else f2 m) App.\nProof.\n  intros l f1 f2 m; induction l; simpl; intros Hfree.\n  - destruct (le_dec n m); [easy|].\n    apply not_le in n0; specialize (Hfree _ n0); now inversion Hfree.\n  - rewrite IHl1, IHl2; [easy| |];\n    intros k Hgt; specialize (Hfree k Hgt); now inversion Hfree.\nQed.\n\nLemma valid_cutoff : forall n l, valid n l -> (forall m, m > n -> free m l).\nProof.\n  induction 1; intros m Hgt.\n  - constructor; apply Nat.lt_neq in Hgt; now contradict Hgt.\n  - constructor; [apply IHvalid1|apply IHvalid2]; easy.\n  - now apply IHvalid, Nat.lt_le_incl.\nQed.\n\nLemma step2_free : forall l n nI, n < nI -> free n (step2 l n nI).\nProof.\n  induction l; simpl; intros m nI Hlt.\n  - destruct (Nat.eq_dec m n); repeat constructor.\n    + now apply Nat.lt_neq.\n    + now apply Nat.lt_neq, le_S.\n    + easy.\n  - repeat constructor.\n    + now apply Nat.lt_neq, le_S, le_S.\n    + now apply IHl1.\n    + now apply IHl2.\nQed.\n\nLemma step2_keep_free : forall l n m nI, m < nI ->\n  free m l -> free m (step2 l n nI).\nProof.\n  induction l; simpl; intros k m nI Hlt Hfree.\n  - destruct (Nat.eq_dec k n).\n    + constructor; now apply Nat.lt_neq.\n    + constructor; [|easy].\n      constructor; now apply Nat.lt_neq, le_S.\n  - inversion Hfree; repeat constructor.\n    + now apply Nat.lt_neq, le_S, le_S.\n    + now apply IHl1.\n    + now apply IHl2.\nQed.\n\nLemma step1_keep_free : forall l n m nI, m < nI ->\n  free m l -> free m (step1 l n nI).\nProof.\n  intros l n; revert l; induction n; simpl; intros l m nI Hlt Hfree.\n  - easy.\n  - now apply IHn, step2_keep_free.\nQed.\n\nLemma step1_cutoff : forall l n nI, n < nI ->\n  (forall m, m <= n -> free m (step1 l (Datatypes.S n) nI)).\nProof.\n  intros l n nI Hlt m' Hle.\n  assert (exists m, n - m = m') as [m Hm]; [|subst; clear Hle].\n  { clear -Hle; induction Hle.\n    - exists 0; now destruct m'.\n    - destruct IHHle as [n Hn]; now exists (Datatypes.S n).\n  }\n  revert l n nI Hlt; induction m; intros.\n  - rewrite Nat.sub_0_r; simpl.\n    now apply step1_keep_free, step2_free.\n  - destruct n.\n    + now apply (IHm _ 0).\n    + now apply (IHm _ n), Nat.lt_le_incl.\nQed.\n\nTheorem lambda_correct : forall s ss l, valid (length ss) l -> claim l (s :: ss).\nProof.\n  intros s ss l Hv; unfold claim, toSKI, toClaimResult.\n  set (f1 := toSKI_map (length (s :: ss))).\n  set (f2 := fun n => nth n (s :: ss) [[I]]).\n  set (f := fun n => if le_dec n (length ss) then f2 n else f1 n).\n  assert (forall x y, x = y -> x ==>* y) as rtc_eq; [intros; subst; constructor|].\n  apply rtc_trans with (toClaimStart (run (step1 l (length (s :: ss)) (length (s :: ss))) f App) (buildList f (length (s :: ss)))).\n  { apply rtc_eq.\n    assert (forall {A B : Type} (f: A -> B) x g y, f = g -> x = y -> f x = g y) as R; [intros; now subst|].\n    apply R; [apply R; [easy|]|].\n    - apply run_cutoff_low, step1_cutoff, le_n.\n    - clear; assert (forall f n, buildList f (Datatypes.S n) = f 0 :: buildList (fun m => f (Datatypes.S m)) n).\n      { clear; intros f n; revert f; induction n; intros; [easy|].\n        simpl; now rewrite app_comm_cons, <- IHn. }\n      revert s f1 f2 f; induction ss; intros; [easy|].\n      unfold length; rewrite H, IHss.\n      assert (f 0 = s) as R; [easy|rewrite R; clear R].\n      assert (forall {T : Type} (h: T) t t', t = t' -> h :: t = h :: t') as R; [intros; now subst|apply R; clear R].\n      assert (forall f1 f2 n, (forall m, f1 m = f2 m) -> buildList f1 n = buildList f2 n) as R; [|apply R; intros m; destruct (le_dec m (length ss))].\n      + clear; induction n; [easy|]; intros; simpl; now rewrite H, IHn.\n      + unfold f; rewrite le_dec_left; [|apply le_n_S]; easy.\n      + unfold f; rewrite le_dec_right; [|apply le_n_S, not_le]; easy.\n  }\n  apply rtc_trans with (run l f App); [apply run_step1; unfold f; rewrite le_dec_right|].\n  - unfold f1, toSKI_map; now rewrite Nat.sub_diag.\n  - apply le_n.\n  - unfold f1, toSKI_map; generalize (length (s :: ss)); clear.\n    induction n; [|rewrite Nat.sub_succ]; easy.\n  - apply le_S, le_n.\n  - unfold f1, toSKI_map; generalize (length (s :: ss)); clear.\n    induction n; [|rewrite Nat.sub_succ]; easy.\n  - apply le_S, le_S, le_n.\n  - apply rtc_eq; symmetry; now apply run_cutoff_high, valid_cutoff.\nQed.\n\n(* rev x f := f x *)\nDefinition Lrev := la (lv 1) (lv 0).\nDefinition rev : SKI := toSKI Lrev 2.\nTheorem rev_correct : forall f x, [[{rev} x f]] ==>* [[f x]].\nProof.\n  intros; assert (claim Lrev (x :: f :: nil)); [|apply H].\n  apply lambda_correct; repeat constructor.\nQed.\n\n(* B f g x := f (g x) *)\nDefinition LB := la (lv 0) (la (lv 1) (lv 2)).\nDefinition B : SKI := toSKI LB 3.\nTheorem B_correct : forall f g x, [[{B} f g x]] ==>* [[f (g x)]].\nProof.\n  intros; assert (claim LB (f :: g :: x :: nil)); [|apply H].\n  apply lambda_correct; repeat constructor.\nQed.\n\n(* C f x y := f y x *)\nDefinition LC := la (la (lv 0) (lv 2)) (lv 1).\nDefinition C : SKI := toSKI LC 3.\nTheorem C_correct : forall f x y, [[{C} f x y]] ==>* [[f y x]].\nProof.\n  intros; assert (claim LC (f :: x :: y :: nil)); [|apply H].\n  apply lambda_correct; repeat constructor.\nQed.\n\n(* rotr y f x := f x y *)\nDefinition Lrotr := la (la (lv 1) (lv 2)) (lv 0).\nDefinition rotr : SKI := toSKI Lrotr 3.\nTheorem rotr_correct : forall f x y, [[{rotr} y f x]] ==>* [[f x y]].\nProof.\n  intros; assert (claim Lrotr (y :: f :: x :: nil)); [|apply H].\n  apply lambda_correct; repeat constructor.\nQed.\n\n(* rotv x y f := f x y *)\nDefinition Lrotv := la (la (lv 2) (lv 0)) (lv 1).\nDefinition rotv : SKI := toSKI Lrotv 3.\nTheorem rotv_correct : forall f x y, [[{rotv} x y f]] ==>* [[f x y]].\nProof.\n  intros; assert (claim Lrotv (x :: y :: f :: nil)); [|apply H].\n  apply lambda_correct; repeat constructor.\nQed.\n\n(* Y f := (\\x. f (x x)) (\\x. f (x x)) *)\n(* The Y combinator has the property `Y f = f (Y f)`, but we can't prove it with direct reduction.\n   Instead, we prove that both sides reduce to the same term. *)\nDefinition LY := la (lv 1) (la (la (lv 0) (lv 0)) (lv 1)).\nDefinition Y : SKI := [[{toSKI LY 2} {toSKI LY 2}]].\nTheorem Y_correct : forall f, exists t, ([[{Y} f]] ==>* t) \/\\ ([[f ({Y} f)]] ==>* t).\nProof.\n  intros; exists [[f ({Y} f)]]; split; [|constructor].\n  unfold Y; assert (claim LY (toSKI LY 2 :: f :: nil)); [|apply H].\n  apply lambda_correct; repeat constructor.\nQed.\n\n(* Boolean logic. Church booleans are used. *)\n(* T x y := x *)\n(* F x y := y *)\nDefinition LT := lv 0.\nDefinition T : SKI := toSKI LT 2.\nTheorem T_correct : forall x y, [[{T} x y]] ==>* [[x]].\nProof.\n  intros; assert (claim LT (x :: y :: nil)); [|apply H].\n  apply lambda_correct; repeat constructor.\nQed.\n\nDefinition LF := lv 1.\nDefinition F : SKI := toSKI LF 2.\nTheorem F_correct : forall x y, [[{F} x y]] ==>* [[y]].\nProof.\n  intros; assert (claim LF (x :: y :: nil)); [|apply H].\n  apply lambda_correct; repeat constructor.\nQed.\n\n(* Notations for expressing a term is extensionally equal to T or F, respectively. *)\nNotation \"t ~~>*T\" := (forall x y, [[{t} x y]] ==>* [[x]]) (at level 90, only parsing).\nNotation \"t ~~>*F\" := (forall x y, [[{t} x y]] ==>* [[y]]) (at level 90, only parsing).\n\nDefinition Not : SKI := C.\nTheorem NotT_F : [[{Not} {T}]] ~~>*F.\nProof.\n  intros; apply rtc_trans with [[{T} y x]], T_correct; apply C_correct.\nQed.\nTheorem NotF_T : [[{Not} {F}]] ~~>*T.\nProof.\n  intros; apply rtc_trans with [[{F} y x]], F_correct; apply C_correct.\nQed.\n\nDefinition LAnd := la (la (lv 0) (lv 1)) (lv 0).\nDefinition And : SKI := toSKI LAnd 2.\nLemma And_correct : forall b1 b2, [[{And} b1 b2]] ==>* [[b1 b2 b1]].\nProof.\n  intros; assert (claim LAnd (b1 :: b2 :: nil)); [|apply H].\n  apply lambda_correct; repeat constructor.\nQed.\nTheorem AndTT_T : [[{And} {T} {T}]] ~~>*T.\nProof.\n  intros; apply rtc_trans with [[{T} x y]], T_correct.\n  apply rtc_head, rtc_head, rtc_trans with [[{T} {T} {T}]], T_correct.\n  apply And_correct.\nQed.\nTheorem AndTF_F : [[{And} {T} {F}]] ~~>*F.\nProof.\n  intros; apply rtc_trans with [[{F} x y]], F_correct.\n  apply rtc_head, rtc_head, rtc_trans with [[{T} {F} {T}]], T_correct.\n  apply And_correct.\nQed.\nTheorem AndFT_F : [[{And} {F} {T}]] ~~>*F.\nProof.\n  intros; apply rtc_trans with [[{F} x y]], F_correct.\n  apply rtc_head, rtc_head, rtc_trans with [[{F} {T} {F}]], F_correct.\n  apply And_correct.\nQed.\nTheorem AndFF_F : [[{And} {F} {F}]] ~~>*F.\nProof.\n  intros; apply rtc_trans with [[{F} x y]], F_correct.\n  apply rtc_head, rtc_head, rtc_trans with [[{F} {F} {F}]], F_correct.\n  apply And_correct.\nQed.\n\nDefinition LOr := la (la (lv 0) (lv 0)) (lv 1).\nDefinition Or : SKI := toSKI LOr 2.\nLemma Or_correct : forall b1 b2, [[{Or} b1 b2]] ==>* [[b1 b1 b2]].\nProof.\n  intros; assert (claim LOr (b1 :: b2 :: nil)); [|apply H].\n  apply lambda_correct; repeat constructor.\nQed.\nTheorem OrTT_T : [[{Or} {T} {T}]] ~~>*T.\nProof.\n  intros; apply rtc_trans with [[{T} x y]], T_correct.\n  apply rtc_head, rtc_head, rtc_trans with [[{T} {T} {T}]], T_correct.\n  apply Or_correct.\nQed.\nTheorem OrTF_T : [[{Or} {T} {F}]] ~~>*T.\nProof.\n  intros; apply rtc_trans with [[{T} x y]], T_correct.\n  apply rtc_head, rtc_head, rtc_trans with [[{T} {T} {F}]], T_correct.\n  apply Or_correct.\nQed.\nTheorem OrFT_T : [[{Or} {F} {T}]] ~~>*T.\nProof.\n  intros; apply rtc_trans with [[{T} x y]], T_correct.\n  apply rtc_head, rtc_head, rtc_trans with [[{F} {F} {T}]], F_correct.\n  apply Or_correct.\nQed.\nTheorem OrFF_F : [[{Or} {F} {F}]] ~~>*F.\nProof.\n  intros; apply rtc_trans with [[{F} x y]], F_correct.\n  apply rtc_head, rtc_head, rtc_trans with [[{F} {F} {F}]], F_correct.\n  apply Or_correct.\nQed.\n\nDefinition LXor := la (la (lv 1) (la (lv 0) (lv 2))) (lv 2).\nDefinition Xor : SKI := [[{toSKI LXor 3} {Not}]].\nLemma Xor_correct : forall b1 b2, [[{Xor} b1 b2]] ==>* [[b1 ({Not} b2) b2]].\nProof.\n  intros; assert (claim LXor (Not :: b1 :: b2 :: nil)); [|apply H].\n  apply lambda_correct; repeat constructor.\nQed.\nTheorem XorTT_F : [[{Xor} {T} {T}]] ~~>*F.\nProof.\n  intros; apply rtc_trans with [[{Not} {T} x y]], NotT_F.\n  apply rtc_head, rtc_head, rtc_trans with [[{T} ({Not} {T}) {T}]], T_correct.\n  apply Xor_correct.\nQed.\nTheorem XorTF_T : [[{Xor} {T} {F}]] ~~>*T.\nProof.\n  intros; apply rtc_trans with [[{Not} {F} x y]], NotF_T.\n  apply rtc_head, rtc_head, rtc_trans with [[{T} ({Not} {F}) {F}]], T_correct.\n  apply Xor_correct.\nQed.\nTheorem XorFT_T : [[{Xor} {F} {T}]] ~~>*T.\nProof.\n  intros; apply rtc_trans with [[{T} x y]], T_correct.\n  apply rtc_head, rtc_head, rtc_trans with [[{F} ({Not} {T}) {T}]], F_correct.\n  apply Xor_correct.\nQed.\nTheorem XorFF_F : [[{Xor} {F} {F}]] ~~>*F.\nProof.\n  intros; apply rtc_trans with [[{F} x y]], F_correct.\n  apply rtc_head, rtc_head, rtc_trans with [[{F} ({Not} {F}) {F}]], F_correct.\n  apply Xor_correct.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32984,"user_id":null,"body":"Require Import Preloaded.\n\nLtac complete_ski := intros; cbv; eauto; repeat (eapply rtc_trans1; eauto).\n\nDefinition rev : SKI := [[ S (K (S I)) K ]].\nTheorem rev_correct : forall f x, [[{rev} x f]] ==>* [[f x]].\nProof. complete_ski. Qed.\n\nDefinition B : SKI := [[ S (K S) K ]].\nTheorem B_correct : forall f g x, [[{B} f g x]] ==>* [[f (g x)]].\nProof. complete_ski. Qed.\n\nDefinition C : SKI := [[ S (S (K {B}) S) (K K) ]].\nTheorem C_correct : forall f x y, [[{C} f x y]] ==>* [[f y x]].\nProof. complete_ski. Qed.\n\nInductive lambda : Set :=\n| var : nat -> lambda\n| app : lambda -> lambda -> lambda\n| abs : nat -> lambda -> lambda\n| S_l : lambda\n| K_l : lambda\n| I_l : lambda.\n\nFixpoint occurs v l :=\nmatch l with\n | var v' => Nat.eqb v v'\n | app l1 l2 => orb (occurs v l1) (occurs v l2)\n | abs _ l' => occurs v l'\n | _ => false\nend.\n\nFixpoint elim_abs (fuel:nat) (l:lambda) : lambda :=\nmatch fuel with\n| O => I_l\n| Datatypes.S f' =>\nmatch l with \n | app l1 l2 => app (elim_abs f' l1) (elim_abs f' l2)\n | abs v l' => if occurs v l' \n  then match l' with\n       | app l1 l2 => app (app S_l (elim_abs f' (abs v l1))) \n                                   (elim_abs f' (abs v l2))\n       | abs v' _ => elim_abs f' (abs v (elim_abs f' l'))\n       | _ => I_l\n       end\n  else (app K_l (elim_abs f' l'))\n | _ => l\nend\nend.\n\nFixpoint lambda_to_ski l :=\nmatch l with\n | app l1 l2 => App (lambda_to_ski l1) (lambda_to_ski l2)\n | S_l => [[ S ]]\n | K_l => [[ K ]]\n | _ => [[ I ]]\nend.\n\nDefinition rotr : SKI := lambda_to_ski\n (elim_abs 100 (abs 0 (abs 1 (abs 2 (app (app (var 1) (var 2)) (var 0)))))).\nTheorem rotr_correct : forall f x y, [[{rotr} y f x]] ==>* [[f x y]].\nProof. complete_ski. Qed.\n\nDefinition rotv : SKI := lambda_to_ski\n (elim_abs 100 (abs 0 (abs 1 (abs 2 (app (app (var 2) (var 0)) (var 1)))))).\nTheorem rotv_correct : forall f x y, [[{rotv} x y f]] ==>* [[f x y]].\nProof. complete_ski. Qed.\n\nDefinition Y : SKI := [[ S (K (S I I)) (S (S (K S) K) (K (S I I))) ]].\nTheorem Y_correct : forall f, exists t, ([[{Y} f]] ==>* t) \/\\ ([[f ({Y} f)]] ==>* t).\nProof. intro f. exists [[f (f (f (f (I (S (K f) (S I I)) (I (S (K f) (S I I)))))))]].\n split;complete_ski.\nQed.\n\nDefinition T : SKI := [[K]].\nTheorem T_correct : forall x y, [[{T} x y]] ==>* [[x]].\nProof. complete_ski. Qed.\n\nDefinition F : SKI := [[S K]].\nTheorem F_correct : forall x y, [[{F} x y]] ==>* [[y]].\nProof. complete_ski. Qed.\n\n(* Notations for expressing a term is extensionally equal to T or F, respectively. *)\nNotation \"t ~~>*T\" := (forall x y, [[{t} x y]] ==>* [[x]]) (at level 90, only parsing).\nNotation \"t ~~>*F\" := (forall x y, [[{t} x y]] ==>* [[y]]) (at level 90, only parsing).\n\nDefinition Not : SKI := C.\nTheorem NotT_F : [[{Not} {T}]] ~~>*F.\nProof. complete_ski. Qed.\nTheorem NotF_T : [[{Not} {F}]] ~~>*T.\nProof. complete_ski. Qed.\n\nLtac alt_ski := intros; compute; eauto; repeat (eapply rtc_trans1;repeat constructor).\n\n(*(fun F G a b => F (G a b) b) *)\nDefinition And : SKI := lambda_to_ski (elim_abs 100 (abs 0 (abs 1 (abs 2 (abs 3 \n (app (app (var 0) (app (app (var 1) (var 2)) (var 3))) (var 3))))))).\nTheorem AndTT_T : [[{And} {T} {T}]] ~~>*T.\nProof. alt_ski. Qed.\nTheorem AndTF_F : [[{And} {T} {F}]] ~~>*F.\nProof. alt_ski. Qed.\nTheorem AndFT_F : [[{And} {F} {T}]] ~~>*F.\nProof. alt_ski. Qed.\nTheorem AndFF_F : [[{And} {F} {F}]] ~~>*F.\nProof. alt_ski. Qed.\n\n(*(fun F G a b => F a (G a b)) *)\nDefinition Or : SKI := lambda_to_ski (elim_abs 100 (abs 0 (abs 1 (abs 2 (abs 3 \n (app (app (var 0) (var 2)) ((app (app (var 1) (var 2)) (var 3))))))))).\nTheorem OrTT_T : [[{Or} {T} {T}]] ~~>*T.\nProof. alt_ski. Qed.\nTheorem OrTF_T : [[{Or} {T} {F}]] ~~>*T.\nProof. alt_ski. Qed.\nTheorem OrFT_T : [[{Or} {F} {T}]] ~~>*T.\nProof. alt_ski. Qed.\nTheorem OrFF_F : [[{Or} {F} {F}]] ~~>*F.\nProof. alt_ski. Qed.\n\n(* fun F G a b => F (G b a) (G a b)*)\nDefinition Xor : SKI := lambda_to_ski (elim_abs 100 (abs 0 (abs 1 (abs 2 (abs 3 \n (app (app (var 0) ((app (app (var 1) (var 3)) (var 2))))\n                   ((app (app (var 1) (var 2)) (var 3))))))))).\nTheorem XorTT_F : [[{Xor} {T} {T}]] ~~>*F.\nProof. alt_ski. Qed.\nTheorem XorTF_T : [[{Xor} {T} {F}]] ~~>*T.\nProof. alt_ski. Qed.\nTheorem XorFT_T : [[{Xor} {F} {T}]] ~~>*T.\nProof. alt_ski. Qed.\nTheorem XorFF_F : [[{Xor} {F} {F}]] ~~>*F.\nProof. alt_ski. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32985,"user_id":null,"body":"Require Import Preloaded.\n\nLemma rtc_red_head : forall {e e' : SKI} x, [[e]] ==>* [[e']] -> [[e x]] ==>* [[e' x]].\nProof.\n  unfold red_rtc; intros; induction H.\n  exact (rtc_refl _ _).\n  exact (rtc_trans1 _ (red_head _ H) IHrtc).\nQed.\n\nLemma rtc_red_tail : forall {e e' : SKI} x, [[e]] ==>* [[e']] -> [[x e]] ==>* [[x e']].\nProof.\n  unfold red_rtc; intros; induction H.\n  exact (rtc_refl _ _).\n  exact (rtc_trans1 _ (red_tail _ H) IHrtc).\nQed.\n\nLemma rtc_red_trans : forall {a b c : SKI}, [[a]] ==>* [[b]] -> [[b]] ==>* [[c]] -> [[a]] ==>* [[c]].\nProof.\n  unfold red_rtc; intros a b c Hab Hbc; induction Hab.\n  exact Hbc.\n  exact (rtc_trans1 _ H (IHHab Hbc)).\nQed.\n\n\n(* rev x f := f x *)\nDefinition rev : SKI := [[S (K (S I)) K]].\nTheorem rev_correct : forall f x, [[{rev} x f]] ==>* [[f x]].\nProof.\n  intros f x; unfold rev.\n  refine (rtc_trans1 _ (red_head _ (red_S _ _ _)) _).\n  refine (rtc_trans1 _ (red_head _ (red_head _ (red_K _ _))) _).\n  refine (rtc_trans1 _ (red_S _ _ _) _).\n  refine (rtc_trans1 _ (red_head _ (red_I _)) _).\n  refine (rtc_trans1 _ (red_tail _ (red_K _ _)) _).\n  exact (rtc_refl _ _).\nQed.\n\n(* B f g x := f (g x) *)\nDefinition B : SKI := [[S (K S) K]].\nTheorem B_correct : forall f g x, [[{B} f g x]] ==>* [[f (g x)]].\nProof.\n  intros f g x; unfold B.\n  refine (rtc_trans1 _ (red_head _ (red_head _ (red_S _ _ _))) _).\n  refine (rtc_trans1 _ (red_head _ (red_head _ (red_head _ (red_K _ _)))) _).\n  refine (rtc_trans1 _ (red_S _ _ _) _).\n  refine (rtc_trans1 _ (red_head _ (red_K _ _)) _).\n  exact (rtc_refl _ _).\nQed.\n\n(* C f x y := f y x *)\nDefinition C : SKI := [[S ({B} {B} S) (K K)]].\nTheorem C_correct : forall f x y, [[{C} f x y]] ==>* [[f y x]].\nProof.\n  intros f x y; unfold C.\n  refine (rtc_trans1 _ (red_head _ (red_head _ (red_S _ _ _))) _).\n  refine (rtc_trans1 _ (red_head _ (red_head _ (red_tail _ (red_K _ _)))) _).\n  refine (rtc_red_trans (rtc_red_head _ (rtc_red_head _ (rtc_red_head _ (B_correct _ _ _)))) _).\n  refine (rtc_red_trans (rtc_red_head _ (B_correct _ _ _)) _).\n  refine (rtc_trans1 _ (red_S _ _ _) _).\n  refine (rtc_trans1 _ (red_tail _ (red_K _ _)) _).\n  exact (rtc_refl _ _).\nQed.\n\n(* rotr y f x := f x y *)\nDefinition rotr : SKI := [[{B} {B} {rev}]].\nTheorem rotr_correct : forall f x y, [[{rotr} y f x]] ==>* [[f x y]].\nProof.\n  intros f x y; unfold rotr.\n  refine (rtc_red_trans (rtc_red_head _ (rtc_red_head _ (B_correct _ _ _))) _).\n  refine (rtc_red_trans (B_correct _ _ _) _).\n  refine (rtc_red_trans (rev_correct _ _) _).\n  exact (rtc_refl _ _).\nQed.\n\n(* rotv x y f := f x y *)\nDefinition rotv : SKI := [[{B} ({B} ({C} {B} {rev}) ({C} {B})) {rev}]].\nTheorem rotv_correct : forall f x y, [[{rotv} x y f]] ==>* [[f x y]].\nProof.\n  intros f x y; unfold rotv.\n  refine (rtc_red_trans (rtc_red_head _ (rtc_red_head _ (B_correct _ _ _))) _).\n  refine (rtc_red_trans (rtc_red_head _ (rtc_red_head _ (B_correct _ _ _))) _).\n  refine (rtc_red_trans (rtc_red_head _ (rtc_red_head _ (C_correct _ _ _))) _).\n  refine (rtc_red_trans (rtc_red_head _ (B_correct _ _ _)) _).\n  refine (rtc_red_trans (rtc_red_head _ (C_correct _ _ _)) _).\n  refine (rtc_red_trans (B_correct _ _ _) _).\n  refine (rtc_red_trans (rev_correct _ _) _).\n  refine (rtc_red_trans (rtc_red_head _ (rev_correct _ _)) _).\n  exact (rtc_refl _ _).\nQed.\n\nDefinition Y' : SKI := [[{B} ({B} ({rev} I) S) {B}]].\nLemma Y'_correct : forall f x, [[{Y'} f x]] ==>* [[f (x x)]].\nProof.\n  intros f x; unfold Y'.\n  refine (rtc_red_trans (rtc_red_head _ (B_correct _ _ _)) _).\n  refine (rtc_red_trans (rtc_red_head _ (B_correct _ _ _)) _).\n  refine (rtc_red_trans (rtc_red_head _ (rev_correct _ _)) _).\n  refine (rtc_trans1 _ (red_S _ _ _) _).\n  refine (rtc_red_trans (B_correct _ _ _) _).\n  refine (rtc_trans1 _ (red_tail _ (red_tail _ (red_I _))) _).\n  exact (rtc_refl _ _).\nQed.\n\n(* Y f := (\\x. f (x x)) (\\x. f (x x)) *)\n(* The Y combinator has the property `Y f = f (Y f)`, but we can't prove it with direct reduction.\n   Instead, we prove that both sides reduce to the same term. *)\nDefinition Y : SKI := [[S {Y'} {Y'}]].\nTheorem Y_correct : forall f, exists t, ([[{Y} f]] ==>* t) \/\\ ([[f ({Y} f)]] ==>* t).\nProof.\n  intros f; unfold Y; refine (ex_intro _ [[f ({Y'} f ({Y'} f))]] (conj _ _)).\n\n  refine (rtc_trans1 _ (red_S _ _ _) _).\n  refine (rtc_red_trans (Y'_correct _ _) _).\n  exact (rtc_refl _ _).\n\n  refine (rtc_trans1 _ (red_tail _ (red_S _ _ _)) _).\n  exact (rtc_refl _ _).\nQed.\n\n(* Boolean logic. Church booleans are used. *)\n(* T x y := x *)\n(* F x y := y *)\nDefinition T : SKI := [[K]].\nTheorem T_correct : forall x y, [[{T} x y]] ==>* [[x]].\nProof.\n  intros x y; unfold T.\n  refine (rtc_trans1 _ (red_K _ _) _).\n  exact (rtc_refl _ _).\nQed.\n\nDefinition F : SKI := [[K I]].\nTheorem F_correct : forall x y, [[{F} x y]] ==>* [[y]].\nProof.\n  intros x y; unfold F.\n  refine (rtc_trans1 _ (red_head _ (red_K _ _)) _).\n  refine (rtc_trans1 _ (red_I _) _).\n  exact (rtc_refl _ _).\nQed.\n\n(* Notations for expressing a term is extensionally equal to T or F, respectively. *)\nNotation \"t ~~>*T\" := (forall x y, [[{t} x y]] ==>* [[x]]) (at level 90, only parsing).\nNotation \"t ~~>*F\" := (forall x y, [[{t} x y]] ==>* [[y]]) (at level 90, only parsing).\n\nDefinition Not : SKI := [[{rotv} {F} {T}]].\nTheorem NotT_F : [[{Not} {T}]] ~~>*F.\nProof.\n  intros x y; unfold Not.\n  refine (rtc_red_trans (rtc_red_head _ (rtc_red_head _ (rotv_correct _ _ _))) _).\n  refine (rtc_red_trans (rtc_red_head _ (rtc_red_head _ (T_correct _ _))) _).\n  refine (rtc_red_trans (F_correct _ _) _).\n  exact (rtc_refl _ _).\nQed.\nTheorem NotF_T : [[{Not} {F}]] ~~>*T.\nProof.\n  intros x y; unfold Not.\n  refine (rtc_red_trans (rtc_red_head _ (rtc_red_head _ (rotv_correct _ _ _))) _).\n  refine (rtc_red_trans (rtc_red_head _ (rtc_red_head _ (F_correct _ _))) _).\n  refine (rtc_red_trans (T_correct _ _) _).\n  exact (rtc_refl _ _).\nQed.\n\nDefinition And : SKI := [[{rotr} {F}]].\nTheorem AndTT_T : [[{And} {T} {T}]] ~~>*T.\nProof.\n  intros x y.\n  refine (rtc_red_trans (rtc_red_head _ (rtc_red_head _ (rotr_correct _ _ _))) _).\n  refine (rtc_red_trans (rtc_red_head _ (rtc_red_head _ (T_correct _ _))) _).\n  refine (rtc_red_trans (T_correct _ _) _).\n  exact (rtc_refl _ _).\nQed.\nTheorem AndTF_F : [[{And} {T} {F}]] ~~>*F.\nProof.\n  intros x y; unfold And.\n  refine (rtc_red_trans (rtc_red_head _ (rtc_red_head _ (rotr_correct _ _ _))) _).\n  refine (rtc_red_trans (rtc_red_head _ (rtc_red_head _ (T_correct _ _))) _).\n  refine (rtc_red_trans (F_correct _ _) _).\n  exact (rtc_refl _ _).\nQed.\nTheorem AndFT_F : [[{And} {F} {T}]] ~~>*F.\nProof.\n  intros x y; unfold And.\n  refine (rtc_red_trans (rtc_red_head _ (rtc_red_head _ (rotr_correct _ _ _))) _).\n  refine (rtc_red_trans (rtc_red_head _ (rtc_red_head _ (F_correct _ _))) _).\n  refine (rtc_red_trans (F_correct _ _) _).\n  exact (rtc_refl _ _).\nQed.\nTheorem AndFF_F : [[{And} {F} {F}]] ~~>*F.\nProof.\n  intros x y; unfold And.\n  refine (rtc_red_trans (rtc_red_head _ (rtc_red_head _ (rotr_correct _ _ _))) _).\n  refine (rtc_red_trans (rtc_red_head _ (rtc_red_head _ (F_correct _ _))) _).\n  refine (rtc_red_trans (F_correct _ _) _).\n  exact (rtc_refl _ _).\nQed.\n\nDefinition Or : SKI := [[{rotv} {T}]].\nTheorem OrTT_T : [[{Or} {T} {T}]] ~~>*T.\nProof.\n  intros x y; unfold Or.\n  refine (rtc_red_trans (rtc_red_head _ (rtc_red_head _ (rotv_correct _ _ _))) _).\n  refine (rtc_red_trans (rtc_red_head _ (rtc_red_head _ (T_correct _ _))) _).\n  refine (rtc_red_trans (T_correct _ _) _).\n  exact (rtc_refl _ _).\nQed.\nTheorem OrTF_T : [[{Or} {T} {F}]] ~~>*T.\nProof.\n  intros x y; unfold Or.\n  refine (rtc_red_trans (rtc_red_head _ (rtc_red_head _ (rotv_correct _ _ _))) _).\n  refine (rtc_red_trans (rtc_red_head _ (rtc_red_head _ (F_correct _ _))) _).\n  refine (rtc_red_trans (T_correct _ _) _).\n  exact (rtc_refl _ _).\nQed.\nTheorem OrFT_T : [[{Or} {F} {T}]] ~~>*T.\nProof.\n  intros x y; unfold Or.\n  refine (rtc_red_trans (rtc_red_head _ (rtc_red_head _ (rotv_correct _ _ _))) _).\n  refine (rtc_red_trans (rtc_red_head _ (rtc_red_head _ (T_correct _ _))) _).\n  refine (rtc_red_trans (T_correct _ _) _).\n  exact (rtc_refl _ _).\nQed.\nTheorem OrFF_F : [[{Or} {F} {F}]] ~~>*F.\nProof.\n  intros x y; unfold Or.\n  refine (rtc_red_trans (rtc_red_head _ (rtc_red_head _ (rotv_correct _ _ _))) _).\n  refine (rtc_red_trans (rtc_red_head _ (rtc_red_head _ (F_correct _ _))) _).\n  refine (rtc_red_trans (F_correct _ _) _).\n  exact (rtc_refl _ _).\nQed.\n\nDefinition Xor : SKI := [[{B} ({C} S I) ({C} {B} {Not})]].\nLemma Xorxx : forall x y, [[{Xor} x y]] ==>* [[x ({Not} y) y]].\nProof.\n  intros x y; unfold Xor.\n  refine (rtc_red_trans (rtc_red_head _ (B_correct _ _ _)) _).\n  refine (rtc_red_trans (rtc_red_head _ (C_correct _ _ _)) _).\n  refine (rtc_trans1 _ (red_S _ _ _) _).\n  refine (rtc_red_trans (rtc_red_head _ (rtc_red_head _ (C_correct _ _ _))) _).\n  refine (rtc_red_trans (rtc_red_head _ (B_correct _ _ _)) _).\n  refine (rtc_trans1 _ (red_tail _ (red_I _)) _).\n  exact (rtc_refl _ _).\nQed.\nTheorem XorTT_F : [[{Xor} {T} {T}]] ~~>*F.\nProof.\n  intros x y.\n  refine (rtc_red_trans (rtc_red_head _ (rtc_red_head _ (Xorxx _ _))) _).\n  refine (rtc_red_trans (rtc_red_head _ (rtc_red_head _ (T_correct _ _))) _).\n  exact (NotT_F _ _).\nQed.\nTheorem XorTF_T : [[{Xor} {T} {F}]] ~~>*T.\nProof.\n  intros x y.\n  refine (rtc_red_trans (rtc_red_head _ (rtc_red_head _ (Xorxx _ _))) _).\n  refine (rtc_red_trans (rtc_red_head _ (rtc_red_head _ (T_correct _ _))) _).\n  exact (NotF_T _ _).\nQed.\nTheorem XorFT_T : [[{Xor} {F} {T}]] ~~>*T.\nProof.\n  intros x y.\n  refine (rtc_red_trans (rtc_red_head _ (rtc_red_head _ (Xorxx _ _))) _).\n  refine (rtc_red_trans (rtc_red_head _ (rtc_red_head _ (F_correct _ _))) _).\n  refine (rtc_red_trans (T_correct _ _) _).\n  exact (rtc_refl _ _).\nQed.\nTheorem XorFF_F : [[{Xor} {F} {F}]] ~~>*F.\nProof.\n  intros x y.\n  refine (rtc_red_trans (rtc_red_head _ (rtc_red_head _ (Xorxx _ _))) _).\n  refine (rtc_red_trans (rtc_red_head _ (rtc_red_head _ (F_correct _ _))) _).\n  refine (rtc_red_trans (F_correct _ _) _).\n  exact (rtc_refl _ _).\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32986,"user_id":168,"body":"Require Import Preloaded.\n\nLtac complete_ski := intros; cbv; eauto; repeat (eapply rtc_trans1; eauto 12).\n\nLemma rtc_trans a b c : a ==>* b -> b ==>* c -> a ==>* c.\nProof. intros; induction H; auto; apply rtc_trans1 with b; intuition. Qed.\n\n(* rev x f := f x *)\nDefinition rev : SKI := [[S (K (S I)) K]].\nTheorem rev_correct : forall f x, [[{rev} x f]] ==>* [[f x]].\nProof. complete_ski. Qed.\n\n(* B f g x := f (g x) *)\nDefinition B : SKI := [[S (K S) K]].\nTheorem B_correct : forall f g x, [[{B} f g x]] ==>* [[f (g x)]].\nProof. complete_ski. Qed.\n\n(* C f x y := f y x *)\nDefinition C : SKI := [[S ({B} S ({B} K S)) (K K)]].\nTheorem C_correct : forall f x y, [[{C} f x y]] ==>* [[f y x]].\nProof. complete_ski. Qed.\n\n(* rotr y f x := f x y *)\nDefinition rotr : SKI := [[{B} {B} {rev}]].\nTheorem rotr_correct : forall f x y, [[{rotr} y f x]] ==>* [[f x y]].\nProof. complete_ski. Qed.\n\n(* rotv x y f := f x y *)\nDefinition rotv : SKI := [[{B} ({C} {B} {rotr}) {rotr}]].\nTheorem rotv_correct : forall f x y, [[{rotv} x y f]] ==>* [[f x y]].\nProof. complete_ski. Qed.\n\n(* Y f := (\\x. f (x x)) (\\x. f (x x)) *)\n(* The Y combinator has the property `Y f = f (Y f)`, but we can't prove it with direct reduction.\n   Instead, we prove that both sides reduce to the same term. *)\nDefinition W : SKI := [[S I I]].\nTheorem W_correct : forall f, [[{W} f]] ==>* [[f f]].\nProof. complete_ski. Qed.\n\nDefinition Y : SKI := [[S (K {W}) (S {B} (K {W}))]].\nTheorem Y_correct : forall f, exists t, ([[{Y} f]] ==>* t) \/\\ ([[f ({Y} f)]] ==>* t).\nProof.\n  intro f; exists [[f ({W} ({B} f {W}))]].\n  assert (H : [[{Y} f]] ==>* [[{W} ({B} f {W})]]).\n    complete_ski.\n  split.\n  - apply (rtc_trans _ _ _ H).\n    eapply rtc_trans. apply W_correct.\n    eapply rtc_trans. apply B_correct.\n    complete_ski.\n  - complete_ski.\nQed.\n\n(* Boolean logic. Church booleans are used. *)\n(* T x y := x *)\n(* F x y := y *)\nDefinition T : SKI := [[K]].\nTheorem T_correct : forall x y, [[{T} x y]] ==>* [[x]].\nProof. complete_ski. Qed.\n\nDefinition F : SKI := [[K I]].\nTheorem F_correct : forall x y, [[{F} x y]] ==>* [[y]].\nProof. complete_ski. Qed.\n\n(* Notations for expressing a term is extensionally equal to T or F, respectively. *)\nNotation \"t ~~>*T\" := (forall x y, [[{t} x y]] ==>* [[x]]) (at level 90, only parsing).\nNotation \"t ~~>*F\" := (forall x y, [[{t} x y]] ==>* [[y]]) (at level 90, only parsing).\n\nDefinition Not : SKI := C.\nTheorem NotT_F : [[{Not} {T}]] ~~>*F.\nProof. complete_ski. Qed.\nTheorem NotF_T : [[{Not} {F}]] ~~>*T.\nProof. complete_ski. Qed.\n\nDefinition And : SKI := [[{rotr} {F}]].\nTheorem AndTT_T : [[{And} {T} {T}]] ~~>*T.\nProof. complete_ski. Qed.\nTheorem AndTF_F : [[{And} {T} {F}]] ~~>*F.\nProof. complete_ski. Qed.\nTheorem AndFT_F : [[{And} {F} {T}]] ~~>*F.\nProof. complete_ski. Qed.\nTheorem AndFF_F : [[{And} {F} {F}]] ~~>*F.\nProof. complete_ski. Qed.\n\nDefinition Or : SKI := [[{rev} {T}]].\nTheorem OrTT_T : [[{Or} {T} {T}]] ~~>*T.\nProof. complete_ski. Qed.\nTheorem OrTF_T : [[{Or} {T} {F}]] ~~>*T.\nProof. complete_ski. Qed.\nTheorem OrFT_T : [[{Or} {F} {T}]] ~~>*T.\nProof. complete_ski. Qed.\nTheorem OrFF_F : [[{Or} {F} {F}]] ~~>*F.\nProof. complete_ski. Qed.\n\nDefinition Xor : SKI := [[{rotv} {Not} I]].\nTheorem XorTT_F : [[{Xor} {T} {T}]] ~~>*F.\nProof. complete_ski. Qed.\nTheorem XorTF_T : [[{Xor} {T} {F}]] ~~>*T.\nProof. complete_ski. Qed.\nTheorem XorFT_T : [[{Xor} {F} {T}]] ~~>*T.\nProof. complete_ski. Qed.\nTheorem XorFF_F : [[{Xor} {F} {F}]] ~~>*F.\nProof. complete_ski. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32987,"user_id":106,"body":"Require Import Preloaded.\n\nLtac complete_ski := intros; cbv; eauto 10; repeat (eapply rtc_trans1; eauto 10).\n\n(* rev x f := f x *)\nDefinition rev : SKI := [[S (K (S I)) K]].\nTheorem rev_correct : forall f x, [[{rev} x f]] ==>* [[f x]].\nProof. complete_ski. Qed.\n\n(* B f g x := f (g x) *)\nDefinition B : SKI := [[S (K S) K]].\nTheorem B_correct : forall f g x, [[{B} f g x]] ==>* [[f (g x)]].\nProof. complete_ski. Qed.\n\n(* C f x y := f y x *)\nDefinition C : SKI := [[S ({B} {B} S) (K K)]].\nTheorem C_correct : forall f x y, [[{C} f x y]] ==>* [[f y x]].\nProof. complete_ski. Qed.\n\n(* rotr y f x := f x y *)\nDefinition rotr : SKI := [[{B} {B} {rev}]].\nTheorem rotr_correct : forall f x y, [[{rotr} y f x]] ==>* [[f x y]].\nProof. complete_ski. Qed.\n\n(* rotv x y f := f x y *)\nDefinition rotv : SKI := [[{B} {C} {rev}]].\nTheorem rotv_correct : forall f x y, [[{rotv} x y f]] ==>* [[f x y]].\nProof. complete_ski. Qed.\n\n(* Y f := (\\x. f (x x)) (\\x. f (x x)) *)\n(* The Y combinator has the property `Y f = f (Y f)`, but we can't prove it with direct reduction.\n   Instead, we prove that both sides reduce to the same term. *)\nDefinition Y : SKI := [[(S S K) ((S (K ((S S) (S (S S K))))) K)]].\nTheorem Y_correct : forall f, exists t, ([[{Y} f]] ==>* t) \/\\ ([[f ({Y} f)]] ==>* t).\nProof.\n  intros. exists [[f ({Y} f)]]; split; complete_ski.\nQed.\n\n(* Boolean logic. Church booleans are used. *)\n(* T x y := x *)\n(* F x y := y *)\nDefinition T : SKI := [[K]].\nTheorem T_correct : forall x y, [[{T} x y]] ==>* [[x]].\nProof. complete_ski. Qed.\n\nDefinition F : SKI := [[K I]].\nTheorem F_correct : forall x y, [[{F} x y]] ==>* [[y]].\nProof. complete_ski. Qed.\n\n(* Notations for expressing a term is extensionally equal to T or F, respectively. *)\nNotation \"t ~~>*T\" := (forall x y, [[{t} x y]] ==>* [[x]]) (at level 90, only parsing).\nNotation \"t ~~>*F\" := (forall x y, [[{t} x y]] ==>* [[y]]) (at level 90, only parsing).\n\nDefinition Not : SKI := [[{C}]].\nTheorem NotT_F : [[{Not} {T}]] ~~>*F.\nProof. complete_ski. Qed.\nTheorem NotF_T : [[{Not} {F}]] ~~>*T.\nProof. complete_ski. Qed.\n\nDefinition And : SKI := [[{rotr} {F}]].\nTheorem AndTT_T : [[{And} {T} {T}]] ~~>*T.\nProof. complete_ski. Qed.\nTheorem AndTF_F : [[{And} {T} {F}]] ~~>*F.\nProof. complete_ski. Qed.\nTheorem AndFT_F : [[{And} {F} {T}]] ~~>*F.\nProof. complete_ski. Qed.\nTheorem AndFF_F : [[{And} {F} {F}]] ~~>*F.\nProof. complete_ski. Qed.\n\nDefinition Or : SKI := [[{rev} {T}]].\nTheorem OrTT_T : [[{Or} {T} {T}]] ~~>*T.\nProof. complete_ski. Qed.\nTheorem OrTF_T : [[{Or} {T} {F}]] ~~>*T.\nProof. complete_ski. Qed.\nTheorem OrFT_T : [[{Or} {F} {T}]] ~~>*T.\nProof. complete_ski. Qed.\nTheorem OrFF_F : [[{Or} {F} {F}]] ~~>*F.\nProof. complete_ski. Qed.\n\nDefinition Xor : SKI := [[{B} ({rev} I) ({rev} {C})]].\nTheorem XorTT_F : [[{Xor} {T} {T}]] ~~>*F.\nProof. complete_ski. Qed.\nTheorem XorTF_T : [[{Xor} {T} {F}]] ~~>*T.\nProof. complete_ski. Qed.\nTheorem XorFT_T : [[{Xor} {F} {T}]] ~~>*T.\nProof. complete_ski. Qed.\nTheorem XorFF_F : [[{Xor} {F} {F}]] ~~>*F.\nProof. complete_ski. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32988,"user_id":568,"body":"Require Import Preloaded.\n\nRequire Import String.\n\nInductive sterm :=\n  | embed (t : SKI)\n  | sapp (f : sterm) (x : sterm)\n  | svar (v : string).\n\nCoercion embed : SKI >-> sterm.\nCoercion svar : string >-> sterm.\n\nInfix \"$$\" := sapp (at level 40, left associativity).\n\nFixpoint abs (v : string) (s : sterm) : sterm :=\n  match s with\n  | embed t => embed [[ K ]] $$ embed t\n  | f $$ x => embed [[ S ]] $$ abs v f $$ abs v x\n  | svar u =>\n    if eqb v u\n      then embed [[ I ]]\n      else embed [[ K ]] $$ svar u\n  end.\n\nNotation \"x '~~' y\" := (abs x y) (at level 100, right associativity, only parsing).\n\nFixpoint extract (s : sterm) : SKI :=\n  match s with\n  | embed t => t\n  | f $$ x => [[ {extract f} {extract x} ]]\n  | svar u => [[ I ]]\n  end.\n\nLtac ski_step_with tac := eapply rtc_trans1; [ tac; repeat econstructor; fail |].\nLtac ski_step := ski_step_with idtac.\nLtac ski_solve := intros; (repeat ski_step); constructor.\n\nOpen Scope string_scope.\n\n(* rev x f := f x *)\nDefinition rev : SKI := extract (\"x\" ~~ \"f\" ~~ \"f\" $$ \"x\").\nTheorem rev_correct : forall f x, [[{rev} x f]] ==>* [[f x]].\nProof. ski_solve. Qed.\n\n(* B f g x := f (g x) *)\nDefinition B : SKI := extract (\"f\" ~~ \"g\" ~~ \"x\" ~~ \"f\" $$ (\"g\" $$ \"x\")).\nTheorem B_correct : forall f g x, [[{B} f g x]] ==>* [[f (g x)]].\nProof. ski_solve. Qed.\n\n(* C f x y := f y x *)\nDefinition C : SKI := extract (\"f\" ~~ \"x\" ~~ \"y\" ~~ \"f\" $$ \"y\" $$ \"x\").\nTheorem C_correct : forall f x y, [[{C} f x y]] ==>* [[f y x]].\nProof. ski_solve. Qed.\n\n(* rotr y f x := f x y *)\nDefinition rotr : SKI := extract (\"y\" ~~ \"f\" ~~ \"x\" ~~ \"f\" $$ \"x\" $$ \"y\").\nTheorem rotr_correct : forall f x y, [[{rotr} y f x]] ==>* [[f x y]].\nProof. ski_solve. Qed.\n\n(* rotv x y f := f x y *)\nDefinition rotv : SKI := extract (\"x\" ~~ \"y\" ~~ \"f\" ~~ \"f\" $$ \"x\" $$ \"y\").\nTheorem rotv_correct : forall f x y, [[{rotv} x y f]] ==>* [[f x y]].\nProof. ski_solve. Qed.\n\nLemma red_rtc_head : forall x1 x2 y,\n  x1 ==>* x2\n  -> [[ {x1} {y} ]] ==>* [[ {x2} {y} ]].\nProof.\n  induction 1; eauto.\nQed.\n\nLemma red_rtc_tail : forall x y1 y2,\n  y1 ==>* y2\n  -> [[ {x} {y1} ]] ==>* [[ {x} {y2} ]].\nProof.\n  induction 1; eauto.\nQed.\n\nLemma rtc_trans : forall (T : Type) (r : T -> T -> Prop) x y z,\n  rtc r x y -> rtc r y z -> rtc r x z.\nProof.\n  induction 1; eauto.\nQed.\n\n(* Y f := (\\x. f (x x)) (\\x. f (x x)) *)\n(* The Y combinator has the property `Y f = f (Y f)`, but we can't prove it with direct reduction.\n   Instead, we prove that both sides reduce to the same term. *)\nDefinition Y : SKI := extract (\"f\" ~~ (\"x\" ~~ \"f\" $$ (\"x\" $$ \"x\")) $$ (\"x\" ~~ \"f\" $$ (\"x\" $$ \"x\"))).\nDefinition fixof (f : SKI) : SKI := extract ((\"x\" ~~ f $$ (\"x\" $$ \"x\")) $$ (\"x\" ~~ f $$ (\"x\" $$ \"x\"))).\n\n\nTheorem Y_correct : forall f, exists t, ([[{Y} f]] ==>* t) \/\\ ([[f ({Y} f)]] ==>* t).\nProof.\n  intros.\n  eexists.\n  unfold Y; simpl.\n  split.\n  - ski_step.\n    eapply rtc_trans. { eapply red_rtc_head. ski_solve. }\n    eapply rtc_trans. { eapply red_rtc_tail. ski_solve. }\n    do 4 ski_step.\n    eapply rtc_trans. { do 2 eapply red_rtc_tail. ski_solve. }\n    eapply rtc_refl.\n  - apply red_rtc_tail.\n    ski_step.\n    eapply rtc_trans. { eapply red_rtc_head. ski_solve. }\n    eapply rtc_trans. { eapply red_rtc_tail. ski_solve. }\n    eapply rtc_refl.\nQed.\n\n(* Boolean logic. Church booleans are used. *)\n(* T x y := x *)\n(* F x y := y *)\nDefinition T : SKI := extract (\"x\" ~~ \"y\" ~~ \"x\").\nTheorem T_correct : forall x y, [[{T} x y]] ==>* [[x]].\nProof. ski_solve. Qed.\n\nDefinition F : SKI := extract (\"x\" ~~ \"y\" ~~ \"y\").\nTheorem F_correct : forall x y, [[{F} x y]] ==>* [[y]].\nProof. ski_solve. Qed.\n\n(* Notations for expressing a term is extensionally equal to T or F, respectively. *)\nNotation \"t ~~>*T\" := (forall x y, [[{t} x y]] ==>* [[x]]) (at level 90, only parsing).\nNotation \"t ~~>*F\" := (forall x y, [[{t} x y]] ==>* [[y]]) (at level 90, only parsing).\n\nDefinition Not : SKI := extract (\"x\" ~~ \"x\" $$ F $$ T).\nTheorem NotT_F : [[{Not} {T}]] ~~>*F.\nProof. ski_solve. Qed.\nTheorem NotF_T : [[{Not} {F}]] ~~>*T.\nProof. ski_solve. Qed.\n\nDefinition And : SKI := extract (\"x\" ~~ \"y\" ~~ \"x\" $$ \"y\" $$ F).\nTheorem AndTT_T : [[{And} {T} {T}]] ~~>*T.\nProof. ski_solve. Qed.\nTheorem AndTF_F : [[{And} {T} {F}]] ~~>*F.\nProof. ski_solve. Qed.\nTheorem AndFT_F : [[{And} {F} {T}]] ~~>*F.\nProof. ski_solve. Qed.\nTheorem AndFF_F : [[{And} {F} {F}]] ~~>*F.\nProof. ski_solve. Qed.\n\nDefinition Or : SKI := extract (\"x\" ~~ \"y\" ~~ \"x\" $$ T $$ \"y\").\nTheorem OrTT_T : [[{Or} {T} {T}]] ~~>*T.\nProof. ski_solve. Qed.\nTheorem OrTF_T : [[{Or} {T} {F}]] ~~>*T.\nProof. ski_solve. Qed.\nTheorem OrFT_T : [[{Or} {F} {T}]] ~~>*T.\nProof. ski_solve. Qed.\nTheorem OrFF_F : [[{Or} {F} {F}]] ~~>*F.\nProof. ski_solve. Qed.\n\nDefinition Xor : SKI := extract (\"x\" ~~ \"y\" ~~ \"x\" $$ (Not $$ \"y\") $$ \"y\").\nTheorem XorTT_F : [[{Xor} {T} {T}]] ~~>*F.\nProof. ski_solve. Qed.\nTheorem XorTF_T : [[{Xor} {T} {F}]] ~~>*T.\nProof. ski_solve. Qed.\nTheorem XorFT_T : [[{Xor} {F} {T}]] ~~>*T.\nProof. ski_solve. Qed.\nTheorem XorFF_F : [[{Xor} {F} {F}]] ~~>*F.\nProof. ski_solve. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32989,"user_id":489,"body":"Require Import Preloaded.\n\nLtac complete_ski := intros; cbv; eauto; repeat (eapply rtc_trans1; eauto).\n\nTheorem rtc_trans : forall (T : Type) (rel : T -> T -> Prop) (a b c : T),\n  rtc rel a b -> rtc rel b c -> rtc rel a c.\nProof. intros T rel a b c H1. induction H1; intros H2; auto.\n  eapply rtc_trans1. apply H. tauto. Qed.\n\nTheorem red_rtc_head : forall a a' b, [[a]] ==>* [[a']] -> [[a b]] ==>* [[a' b]].\nProof. intros a a' b H. revert dependent b. induction H; intros; eauto.\n  eapply rtc_trans1; eauto. apply IHrtc. Qed.\n\nTheorem red_rtc_tail : forall a b b', [[b]] ==>* [[b']] -> [[a b]] ==>* [[a b']].\nProof. intros a b b' H. revert dependent a. induction H; intros; eauto.\n  eapply rtc_trans1; eauto. apply IHrtc. Qed.\n\n(* rev x f := f x *)\nDefinition rev := [[S (K (S I)) K]].\nTheorem rev_correct : forall f x, [[{rev} x f]] ==>* [[f x]].\nProof. complete_ski. Qed.\n\n(* B f g x := f (g x) *)\nDefinition B := [[S (K S) K]].\nTheorem B_correct : forall f g x, [[{B} f g x]] ==>* [[f (g x)]].\nProof. complete_ski. Qed.\n\n(* C f x y := f y x *)\nDefinition C := [[S (S (K S) (S (K K) S)) (K K)]].\nTheorem C_correct : forall f x y, [[{C} f x y]] ==>* [[f y x]].\nProof. complete_ski. Qed.\n\nLtac find_head := repeat match goal with\n  | [ |- [[_ _ _ _ _]] ==>* _] => eapply red_rtc_head\n  | [ |- rtc red_step (App (App (App (App _ _) _) _) _) _] => eapply red_rtc_head\n  end.\n\nLtac complete_BC := find_head; match goal with\n  | [ |- [[{C} _ _ _]] ==>* _] => apply C_correct\n  | [ |- rtc red_step (App (App (App C _) _) _) _] => apply C_correct\n  | [ |- [[{B} _ _ _]] ==>* _] => apply B_correct\n  | [ |- rtc red_step (App (App (App B _) _) _) _] => apply B_correct\n  end.\n\nLtac red_BC := eapply rtc_trans; [complete_BC | idtac].\nLtac red_SKI := eapply rtc_trans1; [eauto | idtac]; let n := numgoals in guard n=1.\n\n(* rotr y f x := f x y *)\nDefinition rotr := [[{C} {C}]].\nTheorem rotr_correct : forall f x y, [[{rotr} y f x]] ==>* [[f x y]].\nProof. intros. unfold rotr. red_BC. complete_BC. Qed.\n\n(* rotv x y f := f x y *)\nDefinition rotv := [[{B} {C} ({C} I)]].\nTheorem rotv_correct : forall f x y, [[{rotv} x y f]] ==>* [[f x y]].\nProof. intros. unfold rotv. red_BC. red_BC. red_BC. complete_ski. Qed.\n\n(* Y f := (\\x. f (x x)) (\\x. f (x x)) *)\n(* The Y combinator has the property `Y f = f (Y f)`, but we can't prove it with direct reduction.\n   Instead, we prove that both sides reduce to the same term. *)\nDefinition X := [[{C} {B} (S I I)]].\nDefinition Y := [[S {X} {X}]].\nTheorem Y_correct : forall f, exists t, ([[{Y} f]] ==>* t) \/\\ ([[f ({Y} f)]] ==>* t).\nProof. intros. exists [[f ({X} f ({X} f))]]. split.\n  - unfold Y. eapply rtc_trans1. apply red_S.\n    unfold X at 1. red_BC. red_BC. complete_ski.\n  - unfold Y. complete_ski. Qed.\n\n(* Boolean logic. Church booleans are used. *)\n(* T x y := x *)\n(* F x y := y *)\nDefinition T := [[K]].\nDefinition T_correct : forall x y, [[{T} x y]] ==>* [[x]] := ltac:(complete_ski).\nDefinition F := [[K I]].\nDefinition F_correct : forall x y, [[{F} x y]] ==>* [[y]] := ltac:(complete_ski).\n\nLtac closer x := intros; unfold x, T, F; repeat (red_BC || red_SKI); eauto.\n\n(* Notations for expressing a term is extensionally equal to T or F, respectively. *)\nNotation \"t ~~>*T\" := (forall x y, [[{t} x y]] ==>* [[x]]) (at level 90, only parsing).\nNotation \"t ~~>*F\" := (forall x y, [[{t} x y]] ==>* [[y]]) (at level 90, only parsing).\n\nDefinition Not' := [[{C} ({C} I (K I)) K]].\nDefinition Not := C.\nDefinition NotT_F : [[{Not} {T}]] ~~>*F := ltac:(closer Not).\nDefinition NotF_T : [[{Not} {F}]] ~~>*T := ltac:(closer Not).\n\nDefinition And := [[{C} {C} (K I)]].\nDefinition AndTT_T : [[{And} {T} {T}]] ~~>*T := ltac:(closer And).\nDefinition AndTF_F : [[{And} {T} {F}]] ~~>*F := ltac:(closer And).\nDefinition AndFT_F : [[{And} {F} {T}]] ~~>*F := ltac:(closer And).\nDefinition AndFF_F : [[{And} {F} {F}]] ~~>*F := ltac:(closer And).\n\nDefinition Or := [[{C} I K]].\nDefinition OrTT_T : [[{Or} {T} {T}]] ~~>*T := ltac:(closer Or).\nDefinition OrTF_T : [[{Or} {T} {F}]] ~~>*T := ltac:(closer Or).\nDefinition OrFT_T : [[{Or} {F} {T}]] ~~>*T := ltac:(closer Or).\nDefinition OrFF_F : [[{Or} {F} {F}]] ~~>*F := ltac:(closer Or).\n\nDefinition Xor' := [[{C} ({B} S ({C} {B} ({C} ({C} I (K I)) K))) I]].\nDefinition Xor := [[{C} ({B} S ({C} {B} {C})) I]].\nDefinition XorTT_F : [[{Xor} {T} {T}]] ~~>*F := ltac:(closer Xor).\nDefinition XorTF_T : [[{Xor} {T} {F}]] ~~>*T := ltac:(closer Xor).\nDefinition XorFT_T : [[{Xor} {F} {T}]] ~~>*T := ltac:(closer Xor).\nDefinition XorFF_F : [[{Xor} {F} {F}]] ~~>*F := ltac:(closer Xor).","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5d03d84ca535d50001845e9c":[{"id":32990,"user_id":568,"body":"(* This solution uses the Program [1] functionality which allows the user to\nsplit concerns into implementing an algorithm and proving it correct. It even\nallows induction on a custom type with a well-founded ordering (most often nat\nand lt). Therefore it seemed to be a perfect fit here.\n\nJust check out how clean the main algorithm is!\n\nhttps:\/\/coq.inria.fr\/refman\/addendum\/program.html *)\n\nRequire Import Preloaded Arith Lia Program.\n\nTheorem SL2N_det1 : forall m : SL2N, det1 (eval m).\nProof.\n  induction m; cbn;\n    try lia;\n    destruct eval; cbn in *; lia.\nQed.\n\nDefinition Mat_total (t : Mat) :=\n  match t with\n  | mat a b c d => a + b + c + d\n  end.\n\nProgram Fixpoint uneval_sig (t : Mat) (det1_t: det1 t) {measure (Mat_total t)}:\n  { rep : SL2N | eval rep = t } :=\n  match t with\n  | mat p q r s =>\n      if gt_dec (p + q) (r + s)\n        then top (uneval_sig (mat (p - r) (q - s) r s) _)\n      else if gt_dec (r + s) (p + q)\n        then bot (uneval_sig (mat p q (r - p) (s - q)) _)\n        else I\n  end.\n\n(* Temporary tag to avoid repeating *)\nDefinition su (a b : nat) := a - b.\n\nLtac do_sub a b :=\n  assert (a >= b) by nia;\n  change (a - b) with (su a b) in *.\n\nLtac simp_sub :=\n  repeat match goal with\n  | [ H : context [ ?a - ?b ] |- _ ] => do_sub a b\n  | [ |- context [ ?a - ?b ] ] => do_sub a b\n  end;\n  unfold su.\n\nLtac numeric := intros; cbn in *; simp_sub; try nia.\n\nNext Obligation. numeric. Qed.\nNext Obligation. numeric. Qed.\n\nNext Obligation.\n  cbn in *.\n  destruct uneval_sig; cbn.\n  destruct eval.\n  inversion e; subst.\n  f_equal; numeric.\nQed.\n\nNext Obligation. numeric. Qed.\nNext Obligation. numeric. Qed.\n\nNext Obligation.\n  cbn in *.\n  destruct uneval_sig; cbn.\n  destruct eval.\n  inversion e; subst.\n  f_equal; numeric.\nQed.\n\nNext Obligation.\n  cbn in *.\n  assert (p + q = r + s) by nia.\n  assert (p > r) by nia.\n  f_equal; numeric.\nQed.\n\nDefinition uneval (t : Mat) (H : det1 t) : SL2N := ` (uneval_sig t H).\n\nTheorem uneval_correct : forall (t : Mat) (H: det1 t), eval (uneval t H) = t.\nProof.\n  intros.\n  unfold uneval.\n  destruct uneval_sig.\n  auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32991,"user_id":168,"body":"Require Import Preloaded.\n\nRequire Import Arith Lia ssreflect.\n\nTheorem SL2N_det1 : forall m : SL2N, det1 (eval m).\nProof. by unfold det1; elim => \/\/= s; case: (eval s) => a b c d; lia. Qed.\n\nDefinition uneval_sig : forall t : Mat, det1 t -> { rep : SL2N | eval rep = t }.\nProof.\n  unfold det1; case => a b c d.\n  move eq: (a + b + c + d) => k.\n  elim\/lt_wf_rec: k a b c d eq => k IH a b c d eq det.\n  have an0 : 0 < a by nia.\n  have dn0 : 0 < d by nia.\n  case: (Nat.leb_spec0 a c) => ac; case: (Nat.ltb_spec0 b d) => bd.\n  - have h1: c + d < k by lia.\n    have h2: a + b + (c - a) + (d - b) = c + d by lia.\n    have h3: a * (d - b) = b * (c - a) + 1 by nia.\n    have [t P] := IH _ h1 _ _ _ _ h2 h3.\n    by exists (bot t); rewrite \/= P; apply congMat; lia.\n  - exists I => \/=; apply congMat; nia.\n  - exists I => \/=; apply congMat; nia.\n  - have h1: a + b < k by lia.\n    have h2: (a - c) + (b - d) + c + d = a + b by lia.\n    have h3: (a - c) * d = (b - d) * c + 1 by nia.\n    have [t P] := IH _ h1 _ _ _ _ h2 h3.\n    by exists (top t); rewrite \/= P; apply congMat; lia.\nDefined.\n\nDefinition uneval (t : Mat) (H : det1 t) : SL2N := proj1_sig (uneval_sig t H).\n\nTheorem uneval_correct : forall (t : Mat) (H: det1 t), eval (uneval t H) = t.\nProof. by move => t H; unfold uneval; case: (uneval_sig t H). Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32992,"user_id":null,"body":"Require Import Preloaded.\n\nRequire Import Arith Lia. (* Hope these help *)\n\nTheorem SL2N_det1 : forall m : SL2N, det1 (eval m).\nProof.\n  intro m.\n  induction m as [| m' Im' | m' Im'] ; simpl.\n  + reflexivity.\n  + destruct (eval m'). simpl in *. lia.\n  + destruct (eval m'). simpl in *. lia.\nQed.\n\nDefinition to_diff : forall a c, (a ?= c) = Lt -> { k : nat | a + S k = c}.\nProof.\n  intros a. induction a.\n  + intros c0 H. induction c0. discriminate. exists c0. lia.\n  + intros c0 H. induction c0. discriminate. \n    simpl in H. specialize (IHa c0 H).\n    destruct IHa as [k hk]. exists k. lia.\nQed.\n\nDefinition uneval_sig : forall t : Mat, det1 t -> { rep : SL2N | eval rep = t }.\nProof.\n  intros t ht.\n  destruct t as [a b c d]. simpl in ht. remember (a+b+c+d) as n. generalize a b c d Heqn ht.\n  clear ht Heqn a b c d.\n  induction n as [n IHn] using lt_wf_rec.\n  intros a0 b0 c0 d0 hn ht.\n  rewrite hn in *. clear hn.\n  case_eq (a0 ?= c0) ; intros.\n  + pose proof (Hac :=  proj1 (Nat.compare_eq_iff a0 c0) H).\n    rewrite Hac in *. assert (Hbd : b0 < d0) by nia. assert (Hc1 : c0 = 1) by nia.\n    rewrite Hc1 in *. clear H Hac Hc1 Hbd. assert (hdb : d0 = S b0) by lia. rewrite hdb in *.\n    clear ht hdb a0 c0 d0. \n    assert (H : {rep' : SL2N | eval rep' = {| a := 1 ; b := b0 ; c := 0 ; d := 1|} }).\n    - apply (IHn (1 + b0 + 1)) ; lia.\n    - destruct H as [m hm]. exists (bot m) ; simpl ; rewrite hm. apply congMat ; lia.\n  + destruct (to_diff a0 c0 H) as [k hk]. rewrite <- hk in *. clear H hk c0. \n    assert (b0 < d0) by nia. pose proof (hbd := proj2 (Nat.compare_lt_iff b0 d0) H).\n    destruct (to_diff b0 d0 hbd) as [u hu]. rewrite <- hu in *. clear H hbd hu d0.\n    assert (hb : a0 > 0) by lia.\n    assert (H : {rep' : SL2N | eval rep' = {| a := a0 ; b := b0 ; c := S k ; d := S u|} }).\n    - apply (IHn (a0 + b0 + (S k) + (S u))) ; lia.\n    - destruct H as [m hm]. exists (bot m) ; simpl ; rewrite hm. apply congMat ; lia.\n  + pose proof (H' := Nat.compare_antisym a0 c0). rewrite H in H'. simpl in H'.\n    destruct (to_diff c0 a0 H') as [k hk]. rewrite <- hk in *. clear H H' hk a0. \n    destruct b0.\n    - assert (d0 = 1) by nia. rewrite H in * ; clear H. assert (c0 = 0) by nia.\n      rewrite H in * ; clear H. assert (k = 0) by nia. rewrite H in * ; clear H ht.\n      exists I. reflexivity.\n    - destruct b0.\n      -- assert (d0 = 1) by nia. rewrite H in * ; clear H. assert (k = 0) by nia. \n         rewrite H in * ; clear H ht.\n         assert (H : {rep' : SL2N | eval rep' = {| a := 1 ; b := 0 ; c := c0 ; d := 1|} }).\n         apply (IHn (1 + c0 + 1)) ; nia.\n         destruct H as [m hm]. exists (top m) ; simpl ; rewrite hm. apply congMat ; lia.\n      -- assert (d0 < S (S b0)) by nia.\n         pose proof (hbd := proj2 (Nat.compare_lt_iff d0 (S (S b0))) H).\n         destruct (to_diff d0 (S (S b0)) hbd) as [u hu]. rewrite <- hu in *. clear H hbd hu b0.\n         assert (hd0 : 0 < d0) by lia.\n         assert (H : {rep' : SL2N | eval rep' = {| a := S k ; b := S u ; c := c0 ; d := d0|} }).\n         ++ apply (IHn ((S k) + (S u) + c0 + d0)) ; lia.\n         ++ destruct H as [m hm]. exists (top m) ; simpl ; rewrite hm. apply congMat ; lia.\nDefined.\n      \n\n\nDefinition uneval (t : Mat) (H : det1 t) : SL2N.\nProof.\n  destruct (uneval_sig t H).\n  exact x.\nDefined.\n\nTheorem uneval_correct : forall (t : Mat) (H: det1 t), eval (uneval t H) = t.\nProof.\n  intros t H.\n  destruct (uneval_sig t H) eqn:H0.\n  unfold uneval.\n  rewrite H0.\n  assumption.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32993,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Arith Lia. (* Hope these help *)\n\nTheorem SL2N_det1 : forall m : SL2N, det1 (eval m).\nProof.\n  induction m.\n  - easy.\n  - simpl; destruct (eval m) as [a b c d]; simpl in *.\n    assert ((a + c) * d = a * d + c * d) as R by ring.\n    rewrite R, IHm; ring.\n  - simpl; destruct (eval m) as [a b c d]; simpl in *.\n    assert (a * (b + d) = a * d + a * b) as R by ring.\n    rewrite R, IHm; ring.\nQed.\n\nLemma strong_induction : forall (P : nat -> Set),\n  P 0 ->\n  (forall n, (forall m, m <= n -> P m) -> P (S n)) ->\n  (forall n, P n).\nProof.\n  intros P P0 PS n; cut (forall m, m <= n -> P m); [intros H; apply H, le_n|].\n  induction n; intros m Hm.\n  - destruct m; [apply P0|exfalso; inversion Hm].\n  - destruct (Nat.eq_dec m (S n)) as [|Hneq]; [subst|].\n    + apply PS, IHn.\n    + apply IHn; now inversion Hm.\nQed.\n\nDefinition le_sig : forall {a b}, a <= b -> { k : nat | a + k = b }.\n  intros a b H; apply exist with (b - a).\n  now apply le_plus_minus_r.\nDefined.\n\nDefinition lt_sig : forall {a b}, a < b -> { k : nat | a + S k = b }.\n  intros a b H; destruct (le_sig H) as [k Hk].\n  apply exist with k; subst; ring.\nDefined.\n\nDefinition uneval_sig : forall t : Mat, det1 t -> { rep : SL2N | eval rep = t }.\n  intros [a b c d]; simpl; intros Heq.\n  rewrite Nat.add_comm in Heq; destruct a as [|a]; [easy|].\n  rewrite (Nat.mul_comm _ d) in Heq; destruct d as [|d]; [easy|].\n  simpl in Heq; rewrite (Nat.mul_comm d) in Heq; inversion Heq; subst; clear Heq; rename H0 into Heq.\n  remember (a + b + c + d) as n; revert n a b c d Heq Heqn.\n  induction n using strong_induction; intros a b c d Hdet Hab.\n  - destruct a; [|easy]; destruct b; [|easy]; destruct c; [|easy]; destruct d; [|easy].\n    now apply exist with I.\n  - destruct (le_dec a c) as [Hac|Hac], (le_dec b d) as [Hbd|Hbd].\n    + destruct (le_sig Hac) as [c' Hc]; subst; clear Hac; rename c' into c.\n      destruct (le_sig Hbd) as [d' Hd]; subst; clear Hbd; rename d' into d.\n      assert (a + (b + d + a * (b + d)) = (a * b) + (a + b + d + a * d)) as R1 by ring.\n      assert (b * (a + c) = (a * b) + (c * b)) as R2 by ring.\n      rewrite R1, R2 in Hdet; apply plus_reg_l in Hdet; clear R1 R2.\n      destruct c as [|c]; [now destruct a, b, d|].\n      cut ({rep | eval rep = mat (S a) b c (S d)}).\n      { intros [rep Hrep]; apply exist with (bot rep).\n        simpl; rewrite Hrep; apply congMat; ring. }\n      apply (H (a + b + c + d)).\n      * assert (a + b + (a + S c) + (b + d) = S ((a + b + c + d) + (a + b))) as R1 by ring.\n        rewrite R1 in Hab; inversion Hab; subst; clear Hab R1.\n        apply le_plus_l.\n      * apply plus_reg_l with b.\n        transitivity (S c * b); [|ring].\n        rewrite <- Hdet; ring.\n      * easy.\n    + destruct (le_sig Hac) as [c' Hc]; subst; clear Hac; rename c' into c.\n      apply not_le in Hbd; destruct (lt_sig Hbd) as [b' Hb]; subst; clear Hbd; rename b' into b.\n      assert (d = c * d + c + c * b + a * b) as Hd.\n      { apply plus_reg_l with (a + a * d).\n        transitivity (a + (d + a * d)); [|rewrite Hdet]; ring. }\n      assert (c = 0) as Hc; [|subst].\n      { destruct c as [|c]; [easy|].\n        cut (0 = S c + c * d + S c * b + a * b); [easy|].\n        apply plus_reg_l with d; rewrite Hd at 1; ring. }\n      simpl in Hd; subst.\n      cut ({rep | eval rep = mat 1 b a (S (a * b))}).\n      { intros [rep Hrep]; apply exist with (top rep).\n        simpl; rewrite Hrep; apply congMat; ring. }\n      apply (H (0 + b + a + (a * b))).\n      * simpl; apply le_S_n; rewrite Hab.\n        transitivity (S (b + a + a * b) + (a + a * b)); [apply le_plus_l|].\n        apply Nat.eq_le_incl; ring.\n      * ring.\n      * easy.\n    + apply not_le in Hac; destruct (lt_sig Hac) as [a' Ha]; subst; clear Hac; rename a' into a.\n      destruct (le_sig Hbd) as [d' Hd]; subst; clear Hbd; rename d' into d.\n      cut (0 = 1 + c + a + b + d + a * b + b + c * d + a * d + d); [easy|].\n      apply plus_reg_l with (b * c); rewrite <- Hdet at 1; ring.\n    + apply not_le in Hac; destruct (lt_sig Hac) as [a' Ha]; subst; clear Hac; rename a' into a.\n      apply not_le in Hbd; destruct (lt_sig Hbd) as [b' Hb]; subst; clear Hbd; rename b' into b.\n      cut ({rep | eval rep = mat (S (S a)) b c (S d)}).\n      { intros [rep Hrep]; apply exist with (top rep).\n        simpl; rewrite Hrep; apply congMat; ring. }\n      apply (H (S a + b + c + d)).\n      * apply le_S_n; rewrite Hab.\n        transitivity ((S (S a + b + c + d)) + (c + d)); [apply le_plus_l|].\n        apply Nat.eq_le_incl; ring.\n      * apply plus_reg_l with (c * d + c).\n        transitivity ((d + S b) * c); [|ring].\n        rewrite <- Hdet; ring.\n      * easy.\nQed.\n\nDefinition uneval (t : Mat) (H : det1 t) :=\n  match uneval_sig t H with\n  | exist _ x _ => x\n  end.\n\nTheorem uneval_correct : forall (t : Mat) (H: det1 t), eval (uneval t H) = t.\nProof.\n  unfold uneval; intros t H; now destruct (uneval_sig t H).\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32994,"user_id":null,"body":"Require Import Preloaded.\n\nRequire Import Arith Lia. (* Hope these help *)\n\nTheorem SL2N_det1 : forall m : SL2N, det1 (eval m).\nProof.\n  intros m.\n  induction m as [|m IHm|m IHm] ; cbn.\n  1: reflexivity.\n  all: destruct (eval m) ; cbn in *.\n  all: lia.\nQed.\n\nDefinition top_mat (m : Mat) := let 'mat a b c d := m in mat (a + c) (b + d) c d.\nDefinition bot_mat (m : Mat) := let 'mat a b c d := m in mat a b (a + c) (b + d).\n\nLemma decide_I_top_bot (t : Mat) : det1 t ->\n  (t = mat 1 0 0 1) + {m & { t = top_mat m } + {t = bot_mat m}}.\nProof.\n  destruct t as [a b c d] ; cbn.\n  intros e.\n  destruct (le_lt_dec a c) as [la|la].\n  all: destruct (le_lt_dec b d) as [lb|lb].\n  - apply le_plus_minus in la.\n    apply le_plus_minus in lb.\n    right.\n    eexists (mat _ _ _ _).\n    cbn.\n    right.\n    f_equal.\n    all: eassumption.\n  - left.\n    assert (a*d < b*c + 1).\n    { rewrite Nat.add_1_r.\n      apply le_lt_n_Sm.\n      rewrite Nat.mul_comm.\n      apply mult_le_compat.\n      1: apply Nat.lt_le_incl.\n      all: assumption.\n    }\n    edestruct Nat.lt_neq ; eassumption.\n  - destruct (le_lt_dec b 0) as [lb'|lb'].\n    1:{ apply le_n_0_eq in lb' as <-.\n      cbn in *.\n      apply mult_is_one in e as [-> ->].\n      apply Nat.lt_1_r in la as ->.\n      now left.\n    }\n    destruct a as [|a] ; [lia|].\n    apply lt_n_Sm_le in la.\n    cbn in e.\n    assert (b*c <= a*d).\n    { rewrite Nat.mul_comm.\n      now apply mult_le_compat.\n    }\n    assert (d <= 1).\n    { eapply (Nat.add_le_mono_r _ _ (b*c + 1)) ; cbn.\n      rewrite <- e at 2.\n      lia.\n    }\n    assert (d = 1) as ->.\n    { do 2 (destruct d as [|d] ; [lia|]). lia. }\n    rewrite Nat.mul_1_r in e.\n    assert (a = b*c) as -> by lia.\n    destruct b as [|b] ; [lia|].\n    right.\n    eexists (mat (S (b*c)) b c 1).\n    left.\n    cbn.\n    f_equal ; lia.\n  - apply Nat.lt_le_incl, le_plus_minus in la.\n    apply Nat.lt_le_incl, le_plus_minus in lb.\n    right.\n    eexists (mat _ _ _ _).\n    left.\n    cbn.\n    f_equal.\n    all: rewrite Nat.add_comm ; eassumption.\nQed.\n\nDefinition size (t : Mat) := t.(a) + t.(b) + t.(c) + t.(d).\n\nLemma size_top (t : Mat) : (det1 t) -> size t < size (top_mat t).\nProof.\n  destruct t as [a b c d].\n  cbn.\n  intros det.\n  assert (1 <= d).\n  { destruct d ; [|lia].\n    rewrite Nat.mul_0_r in det.\n    lia.\n  }\n  lia.\nQed.\n\nLemma size_bot (t : Mat) : (det1 t) -> size t < size (bot_mat t).\nProof.\n  destruct t as [a b c d].\n  cbn.\n  intros det.\n  assert (1 <= a).\n  { destruct a ; [|lia].\n    cbn in det.\n    lia.\n  }\n  lia.\nQed.\n\nLemma size_pos (t : Mat) : (det1 t) -> 0 < size t.\nProof.\n  destruct t as [a b c d] ; cbn.\n  destruct a as [|a] ; cbn ; lia.\nQed.\n\nDefinition uneval_sig (t : Mat) : det1 t -> { rep : SL2N | eval rep = t}.\nProof.\n  pose proof (Nat.le_refl (size t)) as l.\n  revert l.\n  generalize (size t) at 2.\n  intros n.\n  revert t.\n  induction n.\n  - intros t lsize det1.\n    apply size_pos in det1.\n    lia.\n  - intros t lsize det.\n    destruct (decide_I_top_bot _ det) as [? |[t' [|]]].\n    + exists I.\n      subst.\n      reflexivity.\n    + subst.\n      assert (det1 t') as det'.\n      { destruct t' as [a b c d] ; cbn in *.\n        repeat rewrite Nat.mul_add_distr_r in det.\n        rewrite (Nat.mul_comm d c) in det.\n        lia.\n      }\n      destruct (IHn t') as [rep' Ht'].\n      * pose proof (size_top _ det').\n        lia.\n      * assumption.\n      * exists (top rep').\n        cbn.\n        subst.\n        now destruct (eval rep').\n    + subst.\n      assert (det1 t') as det'.\n      { destruct t' as [a b c d] ; cbn in *.\n        repeat rewrite Nat.mul_add_distr_l in det.\n        rewrite (Nat.mul_comm a b) in det.\n        lia.\n      }\n      destruct (IHn t') as [rep' Ht'].\n      * pose proof (size_bot _ det').\n        lia.\n      * assumption.\n      * exists (bot rep').\n        cbn.\n        subst.\n        now destruct (eval rep').\nQed.\n(* Optional: If you want to use the hint\nDefinition uneval_sig : forall t : Mat, det1 t -> { rep : SL2N | eval rep = t }.\n  (* Fill in *) Admitted.\n*)\n\nDefinition uneval (t : Mat) (H : det1 t) : SL2N := proj1_sig (uneval_sig t H).\n\nTheorem uneval_correct : forall (t : Mat) (H: det1 t), eval (uneval t H) = t.\nProof.\n  intros.\n  unfold uneval.\n  now destruct (uneval_sig t H).\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32995,"user_id":null,"body":"Require Import Preloaded Arith Lia.\n\nTheorem SL2N_det1 : forall m : SL2N, det1 (eval m).\nProof.\n  induction m;\n  simpl; try destruct (eval m);\n  simpl in *;\n  lia.\nQed.\n\nLemma one_bigger_than_other : forall a b c d,\n  det1 (mat a b c d) ->\n    {(c <= a \/\\ d <= b)} +\n    {(a <= c \/\\ b <= d)} +\n    {(a = 1 \/\\ b = 0 \/\\ c = 0 \/\\ d = 1)}.\nProof.\n  intros a0 b0 c0 d0. intros. simpl in H.\n  destruct (le_lt_dec c0 a0);\n  destruct (le_lt_dec d0 b0).\n  + left. left. lia.\n  + destruct a0; try lia.\n    destruct d0; try lia.\n    destruct c0.\n      {destruct a0; try lia.\n      destruct d0; try lia.\n      destruct b0; try lia.\n      right. lia. }\n    destruct b0.\n      {destruct a0; try lia.\n       destruct d0; try lia.\n       destruct c0; try lia.\n       left. right. lia. }\n    destruct a0.\n      { destruct d0; try lia.\n        destruct c0; try lia.\n        assert (d0 = b0) by lia.\n        subst. left. right. lia. }\n    exfalso.\n    assert (b0 + 1 <= d0) by lia. clear l0.\n    assert (c0 <= S a0) by lia. clear l.\n    \n    replace (S (S a0) * S d0) with (S a0*d0 + S a0 + d0 + 1) in H by lia.\n    replace (S b0 * S c0 + 1) with (b0*c0 + b0 + c0 + 2) in H by lia.\n    assert (c0*(b0+1) + (b0 + 1) <= (S a0)*d0 + d0).\n    apply plus_le_compat; try lia.\n    apply mult_le_compat; try lia.\n    replace (c0 * (b0 + 1) + (b0 + 1)) with (b0 * c0 + b0 + c0 + 1) in H2 by ring.\n    assert (S a0 * d0 + S a0 + d0 = b0 * c0 + b0 + c0 + 1) by lia. \n    rewrite <- H3 in H2. lia.\n  + exfalso.\n    destruct d0; try lia.\n    destruct a0; try lia.\n    assert (S a0 * S d0 <= b0 * c0); try lia.\n    rewrite mult_comm.\n    apply mult_le_compat; try lia.\n  + left. right. lia. \nDefined.\n\n\nDefinition uneval_sig : forall t : Mat, det1 t -> { rep : SL2N | eval rep = t }.\nProof.\n  intros.\n  destruct t as [a0 b0 c0 d0].\n  remember (a0 + b0 + c0 + d0) as n.\n  assert (a0 + b0 + c0 + d0 <= n) by lia.\n  clear Heqn.\n  generalize dependent d0.\n  generalize dependent c0.\n  generalize dependent b0.\n  generalize dependent a0.\n  induction n.\n  + intros a0 b0 c0 d0. intros. assert (a0 = 0) by lia. assert (b0 = 0) by lia.\n    simpl in H. rewrite H1 in H. rewrite H2 in H. simpl in H.\n    discriminate.\n  + intros a0 b0 c0 d0. intros. destruct (one_bigger_than_other a0 b0 c0 d0) as [a1 | a1];\n      try assumption; try destruct a1 as [a1 | a1].\n    - destruct a1.\n      destruct (IHn (a0 - c0) (b0 - d0) c0 d0); try lia.\n      * simpl. simpl in H. repeat rewrite Nat.mul_sub_distr_r.\n        rewrite (Nat.mul_comm d0 c0).\n        rewrite <- Nat.add_sub_swap; try lia.\n        rewrite Nat.mul_comm.\n        apply mult_le_compat_r.\n        assumption.\n      * simpl in H. \n        destruct c0; try lia.\n        destruct d0; try lia.\n      * exists (top x). simpl. rewrite e.\n        replace (a0 - c0 + c0) with a0 by lia.\n        replace (b0 - d0 + d0) with b0 by lia.\n        reflexivity.\n    - destruct a1.\n      destruct (IHn a0 b0 (c0 - a0) (d0 - b0)).\n      * simpl in *. repeat rewrite Nat.mul_sub_distr_l.\n        rewrite (Nat.mul_comm b0 a0).\n        rewrite <- Nat.add_sub_swap; try lia.\n        rewrite Nat.mul_comm.\n        apply mult_le_compat_l.\n        assumption.\n      * simpl in H.\n        destruct a0; try lia.\n      * exists (bot x). simpl. rewrite e.\n        replace (a0 + (c0 - a0)) with c0 by lia.\n        replace (b0 + (d0 - b0)) with d0 by lia.\n        reflexivity.\n    - exists I. destruct a1 as [H1 [H2 [H3 H4]]].\n      subst. reflexivity.\nDefined.\n\nDefinition uneval (t : Mat) (H : det1 t) : SL2N :=\n  proj1_sig (uneval_sig t H).\n\n\nTheorem uneval_correct : forall (t : Mat) (H: det1 t), eval (uneval t H) = t.\nProof.\n  unfold uneval.\n  intros. destruct (uneval_sig t H). simpl. assumption.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32996,"user_id":null,"body":"Require Import Preloaded.\n\nRequire Import Arith Lia. (* Hope these help *)\n\nTheorem SL2N_det1 : forall m : SL2N, det1 (eval m).\nProof.\n  unfold det1; induction m; simpl; try reflexivity; destruct (eval m); lia.\nQed.\n\nTheorem le_dec : forall {n m}, n <= S m -> (n <= m) + (n = S m).\nProof.\n  intros n m; revert n; induction m.\n  - destruct n.\n    + left; reflexivity.\n    + right; lia.\n  - destruct n.\n    + left; lia.\n    + intros; destruct (IHm _ (le_S_n _ _ H)).\n      * left; lia.\n      * right; lia.\nQed.\n\nTheorem b_c_ind : forall {P : Mat -> Set},\n  (forall n, (forall t, b t + c t < n -> P t) -> (forall t, b t + c t = n -> P t)) ->\n  (forall t, P t).\nProof.\n  intros P Hstep; assert (forall n t, b t + c t <= n -> P t).\n  - induction n.\n    + intros; refine (Hstep 0 _ _ _); lia.\n    + intros; destruct (le_dec H).\n      * exact (IHn _ l).\n      * refine (Hstep _ _ _ e); intros; refine (IHn _ _); lia.\n  - intros; refine (H _ _ _); reflexivity.\nQed.\n\nTheorem lt_dec : forall n m, (n < m) + (n = m) + (m < n).\nProof.\n  induction n; destruct m.\n  - left; right; lia.\n  - left; left; lia.\n  - right; lia.\n  - destruct (IHn m); try destruct s.\n    + left; left; lia.\n    + left; right; lia.\n    + right; lia.\nQed.\n\nLemma mul_lt : forall {n m k}, n < m -> n * S k < m * S k.\nProof.\n  intros; refine (proj1 (Nat.mul_lt_mono_pos_r _ _ _ _) H); lia.\nQed.\n\nLemma mul_lt_inv : forall {n m k}, n * S k < m * S k -> n < m.\nProof.\n  intros; refine (proj2 (Nat.mul_lt_mono_pos_r _ _ _ _) H); lia.\nQed.\n\nTheorem uneval_cases : forall t, det1 t ->\n  (b t < d t \/\\ a t <= c t) +\n  (c t < a t \/\\ d t <= b t) +\n  (t = mat 1 0 0 1).\nProof.\n  destruct t as [a0 b0 c0 d0]; unfold det1; simpl; intros.\n  destruct a0. rewrite Nat.add_comm in H; discriminate.\n  destruct d0. rewrite Nat.mul_comm, Nat.add_comm in H; discriminate.\n  destruct (lt_dec (S a0) c0).\n  - left; left; split.\n    + destruct s.\n      * assert (S a0 * S d0 < c0 * S d0). exact (mul_lt l).\n        assert (b0 * c0 < c0 * S d0). lia.\n        destruct c0. lia.\n        rewrite (Nat.mul_comm (S c0)) in H1; exact (mul_lt_inv H1).\n      * assert (b0 * S a0 < S a0 * S d0). lia.\n        rewrite (Nat.mul_comm (S a0)) in H0; exact (mul_lt_inv H0).\n    + destruct s; lia.\n  - destruct (lt_dec (S d0) b0).\n    + destruct s; left; right; split; lia.\n    + right; rewrite Nat.add_comm in H.\n      destruct a0, b0, c0, d0; try lia; try reflexivity.\n      assert (c0 * S b0 < S a0 * S b0). refine (mul_lt _); lia.\n      assert (S a0 * S b0 < S a0 * S (S d0)). rewrite Nat.mul_comm, (Nat.mul_comm (S a0)); exact (mul_lt l0).\n      lia.\nQed.\n\nLemma det1_a_d : forall t, det1 t -> 0 < a t \/\\ 0 < d t.\nProof.\n  destruct t as [a0 b0 c0 d0]; unfold det1; simpl; intros;\n  destruct a0; try (rewrite Nat.add_comm in H; discriminate);\n  destruct d0; try (rewrite Nat.mul_comm, Nat.add_comm in H; discriminate);\n  lia.\nQed.\n\nDefinition uneval_sig : forall t : Mat, det1 t -> { rep : SL2N | eval rep = t }.\n  refine (b_c_ind _); intros; destruct (uneval_cases _ H1), t as [a0 b0 c0 d0]; try destruct s as [a1 | a1]; simpl; simpl in H0; destruct (det1_a_d _ H1); simpl in H1; simpl in H2; simpl in H3.\n    + simpl in a1; destruct a1; set (t' := mat a0 b0 (c0 - a0) (d0 - b0)).\n      assert (b t' + c t' < n). simpl; lia.\n      assert (det1 t'). simpl.\n        assert (c0 - a0 + a0 = c0). lia.\n        lia.\n      destruct (H _ H6 H7); exists (bot x); simpl; rewrite e; simpl; refine (congMat _ _ _ _); lia.\n    + simpl in a1; destruct a1; set (t' := mat (a0 - c0) (b0 - d0) c0 d0).\n      assert (b t' + c t' < n). simpl; lia.\n      assert (det1 t'). simpl.\n        assert (b0 - d0 + d0 = b0). lia.\n        lia.\n      destruct (H _ H6 H7); exists (top x); simpl; rewrite e; simpl; refine (congMat _ _ _ _); lia.\n    + exists I; rewrite e; simpl; reflexivity.\nDefined.\n\nDefinition uneval (t : Mat) (H : det1 t) : SL2N :=\nproj1_sig (uneval_sig t H).\n\nTheorem uneval_correct : forall (t : Mat) (H: det1 t), eval (uneval t H) = t.\nProof.\n  unfold uneval; intros; destruct (uneval_sig t H); simpl; exact e.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32997,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Arith Lia. (* Hope these help *)\n\nTheorem SL2N_det1 : forall m : SL2N, det1 (eval m).\nProof.\n  induction m; cbn; auto; destruct (eval m);\n    cbn in *; lia.\nQed.\n\nLemma divisors_of_one : forall x y, x * y = 1 -> x = 1 \/\\ y = 1.\nProof.\n  intros.\n  destruct x. lia.\n  destruct y. lia.\n  destruct x; lia.\nQed.\n\nDefinition mat_sum (m : Mat) :=\n  match m with mat a b c d => a + b + c + d end.\n\n(* Optional: If you want to use the hint *)\nDefinition uneval_sig : forall t : Mat, det1 t -> { rep : SL2N | eval rep = t }.\nProof.\n  assert (forall n t, mat_sum t <= n -> det1 t -> { rep : SL2N | eval rep = t }).\n  {\n    induction n; intros; destruct t as [a b c d]; cbn in *.\n    { destruct a; destruct b; lia. }\n    destruct c as [|c].\n    { destruct (divisors_of_one a d). lia. subst.\n      destruct b as [|b].\n      - exists I. auto.\n      - destruct (IHn (mat 1 b 0 1)) as [m Hm]; cbn; try lia.\n        exists (top m).\n        cbn. rewrite Hm.\n        apply congMat; lia.\n    }\n    destruct a as [|a]. lia.\n    destruct (le_lt_dec a c).\n    - destruct (le_lt_dec b d); try nia.\n      destruct (IHn (mat (S a) b (S c - S a) (d - b))) as [m Hm].\n      { cbn. lia. }\n      { cbn. rewrite! Nat.mul_sub_distr_l. nia. }\n      exists (bot m).\n      cbn. rewrite Hm.\n      apply congMat; lia.\n    - destruct (le_lt_dec d b); try nia.\n      destruct (IHn (mat (S a - S c) (b - d) (S c) d)) as [m Hm].\n      { cbn. lia. }\n      { cbn. rewrite! Nat.mul_sub_distr_r. nia. }\n      exists (top m).\n      cbn. rewrite Hm.\n      apply congMat; lia.\n  }\n\n  intros.\n  eapply H; auto.\nDefined.\n\nDefinition uneval (t : Mat) (H : det1 t) : SL2N :=\n  proj1_sig (uneval_sig t H).\n\nTheorem uneval_correct : forall (t : Mat) (H: det1 t), eval (uneval t H) = t.\nProof.\n  intros. unfold uneval.\n  destruct (uneval_sig t H). auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32998,"user_id":null,"body":"Require Import Preloaded.\n\nRequire Import Recdef Arith Bool Lia. (* Hope these help *)\n\nTheorem SL2N_det1 : forall m : SL2N, det1 (eval m).\nProof.\n  intros m. unfold det1. induction m; cbn; try destruct (eval m); lia.\nQed.\n\nDefinition measure m := match m with | mat a b c d => a + b + c + d end.\nFunction reconstruct (m : Mat) { measure measure m } :=\n  match m with\n  | mat a b c d =>\n    if ((a =? 0) || (d =? 0) || ((b =? 0) && (c =? 0))) then I\n    else if (a <=? c) && (b <? d) then bot (reconstruct (mat a b (c - a) (d - b)))\n    else top (reconstruct (mat (a - c) (b - d) c d))\n  end.\nProof.\n  - intros. simpl.\n    rewrite 2!orb_false_iff in teq0.\n    destruct teq0 as ((H1 & H2) & H3).\n    apply Nat.eqb_neq in H1. apply Nat.eqb_neq in H2.\n    apply andb_false_iff in H3.\n    rewrite 2!Nat.eqb_neq in H3.\n    destruct H3 as [H3|H3]; lia.\n  - intros. simpl.\n    rewrite 2!orb_false_iff in teq0.\n    destruct teq0 as ((H1 & H2) & H3).\n    apply Nat.eqb_neq in H1. apply Nat.eqb_neq in H2.\n    apply andb_false_iff in H3.\n    rewrite 2!Nat.eqb_neq in H3.\n    destruct H3 as [H3|H3]; lia.\nDefined.\n\nDefinition uneval (t : Mat) (H : det1 t) : SL2N := reconstruct t.\n\nTheorem uneval_correct : forall (t : Mat) (H: det1 t), eval (uneval t H) = t.\nProof.\n  intros. unfold uneval. functional induction (reconstruct t).\n  - cbn in H.\n    rewrite 2!orb_true_iff, andb_true_iff in e0.\n    rewrite 4!Nat.eqb_eq in e0.\n    assert (a = 1) as -> by (destruct d; nia).\n    cbn. apply congMat; lia.\n  - rewrite andb_true_iff, Nat.leb_le, Nat.ltb_lt in e1.\n    cbn. rewrite IHs.\n    + apply congMat; lia.\n    + unfold det1 in H |- *. nia.\n  - cbn in H.\n    rewrite orb_false_iff in e0. destruct e0 as (_ & e0).\n    rewrite andb_false_iff, 2!Nat.eqb_neq in e0.\n    rewrite andb_false_iff, Nat.leb_nle, Nat.ltb_nlt in e1.\n    cbn. rewrite IHs.\n    + apply congMat; nia.\n    + cbn. nia.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32999,"user_id":null,"body":"Require Import Preloaded.\n\n\nRequire Import Arith Lia Wf.\n\nTheorem SL2N_det1 : forall m : SL2N, det1 (eval m).\nProof.\n  intros.\n  unfold det1.\n  induction m; simpl;\n    auto;\n    destruct (eval m); lia.\nQed.\n\nFixpoint uneval_aux (fuel a b c d : nat) : SL2N :=\nmatch fuel with\n| O => I\n| S fuel' =>\n  if (le_dec a c) then\n      bot (uneval_aux fuel' a b (c-a) (d-b))\n  else\n  (\n    if (lt_dec b d) then\n      I\n    else\n      top (uneval_aux fuel' (a-c) (b-d) c d)\n  )\nend.\n\nDefinition uneval (t : Mat) (H : det1 t) : SL2N := \n    uneval_aux (a t + b t + c t + d t) (a t) (b t) (c t) (d t).\n\nTheorem uneval_correct : forall (t : Mat) (H: det1 t), eval (uneval t H) = t.\nProof.\n  enough(forall y fuel a b c d, y = a + b + c + d -> y <= fuel -> \n     a * d =  b * c + 1 ->\n    eval (uneval_aux fuel a b c d) = {|a:=a; b:=b; c:=c; d:=d |}).\n  {\n    intros.\n    destruct t.\n    unfold uneval.\n    simpl. \n    eapply H. reflexivity. \n    auto. auto.\n  }\n  intro y.\n  induction y as [ y IHy ] using (well_founded_induction lt_wf).\n  intros fuel a b c d H H0 H1.\n  destruct y.\n    assert(a = 0); lia.\n  destruct fuel.\n    lia.\n  simpl.\n  destruct (le_dec a c).\n  {\n    simpl.\n    destruct(le_dec b d).\n    {\n      rewrite (IHy (S y-a-b)).\n        f_equal; auto; lia.\n        destruct a; lia. \n        lia.\n        destruct a; lia.\n      repeat rewrite Nat.mul_sub_distr_l.\n      rewrite <- Nat.add_sub_swap. lia.\n      apply mult_le_compat_l. auto.\n    }\n    apply Nat.nle_gt in n.\n    destruct(le_lt_or_eq a c l).\n    {\n      enough((a+1)*(d+1) <= a*d - 1). lia.\n      rewrite H1.\n      replace(b*c + 1 - 1) with (c*b);[ | lia].\n      apply mult_le_compat; lia.\n    }\n    subst.\n    enough(c * d < c * b). lia.\n    destruct c. lia. \n    apply mult_lt_compat_l; lia.\n  }\n  destruct(lt_dec b d).\n  {\n    apply Nat.nle_gt in n.\n    simpl.\n    destruct a as [|a]. lia.\n    destruct d as [|d]. lia.\n    replace(S a * S d) with (a * d + a + d + 1) in H1; [|lia].\n    apply Nat.add_cancel_r in H1.\n    apply lt_n_Sm_le in n.\n    apply lt_n_Sm_le in l.\n    enough (a * d + a + d <= a * d).\n    2:{ rewrite H1. rewrite Nat.mul_comm. apply mult_le_compat; auto. }\n    destruct a; [|lia].\n    destruct d; [|lia]. \n    f_equal; lia.\n  }\n  apply Nat.nle_gt in n.\n  apply Nat.nlt_ge in n0.\n  simpl.\n  rewrite (IHy (S y - c - d)); try lia.\n  f_equal; lia.\n  {\n    destruct c; [|lia].\n    destruct d; lia.\n  }\n  {\n    destruct c; [|lia].\n    destruct d; lia.\n  }\n  repeat rewrite Nat.mul_sub_distr_r.\n  replace(b * c - d * c + 1) with (b * c + 1 - d * c).\n      lia.\n  apply Nat.add_sub_swap.\n  apply mult_le_compat_r.\n  auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5d0e57ec1c5fdd000146b7d9":[{"id":33000,"user_id":null,"body":"Require Import Preloaded Lia. (* Might be useful *)\n\nLemma horner_correct_aux : forall acc x cf,\n  horner_loop acc x cf = acc * Nat.pow x (length cf) + eval_poly x cf.\nProof.\n  intros. revert acc. induction cf; intros.\n  - simpl. lia.\n  - simpl. rewrite IHcf. lia.\nQed.\n\nTheorem horner_correct : forall x cf,\n  eval_poly x cf = horner x cf.\nProof.\n  intros. symmetry. apply horner_correct_aux.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33001,"user_id":106,"body":"Require Import Preloaded Lia.\n\nTheorem horner_loop_correct : forall acc x cf, horner_loop acc x cf = horner_loop 0 x cf + acc * Nat.pow x (length cf).\nProof.\n  intros; revert acc x; induction cf; intuition; simpl; [|rewrite IHcf; rewrite IHcf with a x]; lia.\nQed.\n\nTheorem horner_correct : forall x cf, eval_poly x cf = horner x cf.\nProof.\n  unfold horner; intros x cf; revert x; induction cf; intuition; simpl; rewrite horner_loop_correct; auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33002,"user_id":null,"body":"Require Import Preloaded Lia. (* Might be useful *)\n\nRequire Import Arith.\n\nTheorem horner_correct : forall x cf,\n  eval_poly x cf = horner x cf.\nProof.\nassert (forall l x offs, offs * Nat.pow x (length l) + eval_poly x l = horner_loop offs x l).\n{\n  induction l; intros.\n  - simpl. ring.\n  - simpl. rewrite <- IHl. ring.\n}\nintuition.\nspecialize (H cf x 0). simpl in H. assumption.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33003,"user_id":null,"body":"Require Import Preloaded Arith.\n\nTheorem horner_correct : forall x cf,\n  eval_poly x cf = horner x cf.\nProof.\n  intros x [|an cf]; [easy|].\n  unfold horner; simpl; revert x an; induction cf as [|bn cf]; intros; [simpl; ring|].\n  simpl; rewrite <- IHcf; ring.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33004,"user_id":null,"body":"Require Import Preloaded Lia. (* Might be useful *)\n\nLemma horner_lemma : forall cf acc x, horner_loop acc x cf = horner_loop 0 x cf + \n  acc * Nat.pow x (length cf).\nProof.\n  intro cf.\n  induction cf as [|an cf h_ind].\n  + simpl. lia.\n  + intros acc x. simpl. rewrite h_ind with (acc := acc *x + an).\n    rewrite h_ind with (acc := an). lia.\nQed.\n\nTheorem horner_correct : forall x cf,\n  eval_poly x cf = horner x cf.\nProof.\n  intros x cf.\n  induction cf as [|an cf h_ind].\n  + reflexivity.\n  + unfold horner. simpl. rewrite horner_lemma. auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33005,"user_id":null,"body":"Require Import Preloaded Lia.\n\nLemma horner_correct_aux : forall acc x cf,\n  horner_loop acc x cf = acc * Nat.pow x (length cf) + eval_poly x cf.\nProof.\n  intros. revert acc. induction cf; intros.\n  - simpl. lia.\n  - simpl. rewrite IHcf. lia.\nQed.\n\nTheorem horner_correct : forall x cf,\n  eval_poly x cf = horner x cf.\nProof.\n  intros. symmetry. apply horner_correct_aux.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33006,"user_id":null,"body":"Require Import Preloaded Lia. (* Might be useful *)\n\n\nLemma horner_loop_lemma : forall acc x cf,\n  horner_loop acc x cf = eval_poly x cf + (Nat.pow x (length cf)) * acc.\nProof.\n  intros.\n  generalize dependent acc.\n  induction cf.\n  - simpl. lia.\n  - simpl. intros. rewrite IHcf. lia.\nQed.\n\nTheorem horner_correct : forall x cf,\n  eval_poly x cf = horner x cf.\nProof.\n  intros. unfold horner. rewrite horner_loop_lemma.\n  lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33007,"user_id":null,"body":"Require Import Preloaded Lia. (* Might be useful *)\nRequire Import List.\nImport ListNotations.\n\nLemma lm_horner_loop : forall x cf acc a,\n    horner_loop acc x (a::cf) =\n    horner_loop acc x [a] * Nat.pow x (length cf) + horner_loop 0 x cf.\nProof. simpl. induction cf; simpl. lia. intros. rewrite IHcf.\n       pose (IH := IHcf 0 a). simpl in IH. rewrite IH. lia. Qed.\n       \nTheorem horner_correct : forall x cf,\n    eval_poly x cf = horner x cf.\nProof. intros. generalize x. generalize cf. induction cf0; auto.\n       simpl. intro. rewrite IHcf0. unfold horner. rewrite lm_horner_loop. simpl.\n       lia. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33008,"user_id":null,"body":"Require Import Preloaded Lia. (* Might be useful *)\nRequire Import List.\nImport ListNotations.\n\nLemma lm_horner_loop : forall x cf acc a,\n    horner_loop acc x (a::cf) =\n    horner_loop acc x [a] * Nat.pow x (length cf) + horner_loop 0 x cf.\nProof. simpl. induction cf; simpl. lia. intros. rewrite IHcf.\n       pose (IH := IHcf 0 a). simpl in IH. rewrite IH. lia. Qed.\n\n       (* induction cf; simpl. induction r; simpl. lia. *)\n       (* intro. rewrite IHr. rewrite IHr. rewrite (IHr a). lia. *)\n       (* intros. rewrite IHl. auto. Qed. *)\n       \nTheorem horner_correct : forall x cf,\n    eval_poly x cf = horner x cf.\nProof. intros. generalize x. generalize cf. induction cf0; auto.\n       simpl. intro. rewrite IHcf0. unfold horner. rewrite lm_horner_loop. simpl.\n       lia. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33009,"user_id":null,"body":"Require Import Preloaded Lia. (* Might be useful *)\n\nLemma lm_horner_loop : forall x cf acc a,\n    horner_loop acc x (a::cf) =\n    horner_loop acc x (a::nil) * Nat.pow x (length cf) + horner_loop 0 x cf.\nProof. simpl. induction cf; simpl. lia. intros. rewrite IHcf.\n       pose (IH := IHcf 0 a). simpl in IH. rewrite IH. lia. Qed.\n\n       (* induction cf; simpl. induction r; simpl. lia. *)\n       (* intro. rewrite IHr. rewrite IHr. rewrite (IHr a). lia. *)\n       (* intros. rewrite IHl. auto. Qed. *)\n       \nTheorem horner_correct : forall x cf,\n    eval_poly x cf = horner x cf.\nProof. intros. generalize x. generalize cf. induction cf0; auto.\n       simpl. intro. rewrite IHcf0. unfold horner. rewrite lm_horner_loop. simpl.\n       lia. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5d0fc2427006cd00013b73d6":[{"id":33010,"user_id":568,"body":"Require Import Preloaded ZArith Lia.\n\nOpen Scope Z_scope.\n  \nLtac decomp :=\n  let H := fresh \"H\" in\n  destruct Z.leb eqn:H;\n  [ rewrite Z.leb_le in H\n  | rewrite Z.leb_gt in H ].\n\n\nTheorem tarai_r_correct :\n  forall x y z w,\n  tarai_r x y z w\n  -> w = if x <=? y then y\n         else if y <=? z then z\n         else x.\nProof.\n  intros.\n  induction H;\n   repeat (try lia; decomp).\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33011,"user_id":null,"body":"Require Import Preloaded ZArith Lia. (* Hope this helps *)\n\nOpen Scope Z_scope.\n\n(* Define your Ltac helpers *)\nTheorem tarai_r_correct :\n  forall x y z w,\n  tarai_r x y z w\n  -> w = if x <=? y then y\n         else if y <=? z then z\n         else x.\nProof.\nintros x y z w H.\ninduction H as [|x1 x2 x3 x4 x5 x6 x7 H1 _ H2 _ H3 _ H4 _ H5].    \n  now case Z.leb_spec; lia.\ngeneralize H2 H3 H4 H5.\nrepeat case Z.leb_spec; lia.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33012,"user_id":null,"body":"Require Import Preloaded ZArith Lia. (* Hope this helps *)\n\nOpen Scope Z_scope.\n\nInductive tarai_alt : Z -> Z -> Z -> Z -> Prop :=\n| tar_y : forall x y z, x <= y -> tarai_alt x y z y\n| tar_z : forall x y z, y < x -> y <= z -> tarai_alt x y z z\n| tar_x : forall x y z, z < y < x -> tarai_alt x y z x.\n\nLemma tarai_alt_correct :\n  forall x y z w,\n  tarai_alt x y z w\n  <-> w = if x <=? y then y\n         else if y <=? z then z\n         else x.\nProof.\n  split.\n  - intros H; induction H.\n    + apply Z.leb_le in H; now rewrite H.\n    + apply Z.leb_gt in H; apply Z.leb_le in H0; now rewrite H, H0.\n    + destruct H as [H H0]; apply Z.leb_gt in H; apply Z.leb_gt in H0.\n      now rewrite H, H0.\n  - intros; subst; destruct (x <=? y) eqn:xy; [|destruct (y <=? z) eqn: yz].\n    + apply Z.leb_le in xy; now apply tar_y.\n    + apply Z.leb_gt in xy; apply Z.leb_le in yz; now apply tar_z.\n    + apply Z.leb_gt in xy; apply Z.leb_gt in yz; now apply tar_x.\nQed.\n\nLtac use H := inversion H; subst; clear H.\n\nTheorem tarai_r_correct :\n  forall x y z w,\n  tarai_r x y z w\n  -> w = if x <=? y then y\n         else if y <=? z then z\n         else x.\nProof.\n  intros x y z w H; apply tarai_alt_correct; induction H.\n  - now apply tar_y.\n  - use IHtarai_r1; use IHtarai_r2; use IHtarai_r3; use IHtarai_r4; try lia; (apply tar_x || apply tar_y || apply tar_z); lia.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33013,"user_id":null,"body":"Require Import Preloaded ZArith Lia. (* Hope this helps *)\n\nOpen Scope Z_scope.\n\nLemma leb_true : forall x y, x <= y -> x <=? y = true.\nProof.\n  intros; now apply Z.leb_le.\nQed.\n\nLemma leb_false : forall x y, y < x -> x <=? y = false.\nProof.\n  intros; now apply Z.leb_nle, Zlt_not_le.\nQed.\n\nLemma eq_between : forall a b,\n  a - 1 <= b < a -> a - 1 = b.\nProof.\n  intros a b [Hle Hlt].\n  destruct (Zle_lt_or_eq _ _ Hle); [|easy].\n  rewrite <- (Z.sub_add 1 a) in Hlt.\n  apply Zlt_succ_le in Hlt.\n  destruct (Zle_lt_or_eq _ _ Hlt); [|easy].\n  exfalso; now apply (Z.lt_irrefl b), Z.lt_trans with (a - 1).\nQed.\n\nLemma tarai_cases : forall x y z w,\n  (x <= y -> y = w) ->\n  (y < x -> y <= z -> z = w) ->\n  (y < x -> z < y -> x = w) ->\n  (if x <=? y then y\n  else if y <=? z then z\n  else x) = w.\nProof.\n  intros x y z w Hy Hz Hx.\n  destruct (Z.le_gt_cases x y) as [xy|xy].\n  - rewrite leb_true; [apply Hy|]; easy.\n  - rewrite leb_false; [|easy].\n    destruct (Z.le_gt_cases y z) as [yz|yz].\n    + rewrite leb_true; [apply Hz|]; easy.\n    + rewrite leb_false; [apply Hx|]; easy.\nQed.\n\nTheorem tarai_r_correct :\n  forall x y z w,\n  tarai_r x y z w\n  -> w = if x <=? y then y\n         else if y <=? z then z\n         else x.\nProof.\n  induction 1.\n  - now rewrite leb_true.\n  - subst; clear - H; apply tarai_cases; intros; apply tarai_cases; intros; symmetry; apply tarai_cases; intros; try easy.\n    + assert (y - 1 = z) by now apply eq_between.\n      subst; destruct (Z.le_gt_cases (x - 1) y).\n      * rewrite leb_true, leb_true in H0; try easy.\n        exfalso; apply Z.nle_pred_r with y, H0.\n      * rewrite leb_false, leb_false, leb_true in H0; try easy.\n        exfalso; apply Zlt_not_le with y x; [easy|].\n        rewrite <- Z.succ_pred, <- (Z.succ_pred x).\n        apply Zsucc_le_compat, H0.\n    + exfalso; apply Zlt_not_le with z y, H4.\n      apply Z.lt_pred_lt, H1.\n    + exfalso; apply Zlt_not_le with z y, H4.\n      apply Z.lt_pred_lt, H1.\n    + exfalso; apply Z.lt_asymm with x y, H3.\n      now apply Z.lt_trans with z.\n    + rewrite leb_true in H0; [|apply Z.le_le_pred, H4].\n      rewrite leb_true in H1; [|apply Z.le_le_pred, H4].\n      rewrite leb_true in H1; [|easy].\n      destruct (Z.le_gt_cases (x - 1) y).\n      * rewrite leb_true in H0; [|easy].\n        exfalso; now apply Zlt_not_le with z y.\n      * rewrite leb_false in H0; [|easy].\n        rewrite leb_true in H0; [|easy].\n        exfalso; apply Z.lt_irrefl with z, H0.\n    + rewrite leb_true in H1; [|apply Z.le_le_pred, H5].\n      rewrite leb_false, leb_false in H1; try easy.\n      exfalso; apply Z.nle_pred_r with z, H1.\n    + exfalso; apply Z.lt_asymm with x y, H3.\n      apply Z.lt_trans with z, H5.\n      apply Z.lt_pred_lt, H2.\n    + assert (x - 1 = y) by now apply eq_between.\n      subst; rewrite leb_true in H0; [|apply Z.le_le_pred, H4].\n      rewrite leb_true in H0; [|easy].\n      exfalso; now apply Zlt_not_le with z (x - 1).\n    + assert (x - 1 = y) by now apply eq_between.\n      subst; rewrite leb_true in H1; [|apply Z.le_le_pred, Z.lt_le_incl, Z.lt_pred_lt, H4].\n      destruct (x - 1 - 1 <=? z); [|destruct (z <=? x)].\n      * exfalso; apply Z.lt_asymm with z x, H1.\n        apply Z.lt_pred_lt, H4.\n      * exfalso; apply Z.lt_irrefl with x, H1.\n      * exfalso; apply Z.lt_irrefl with x, Z.lt_pred_lt, Z.lt_pred_lt, H1.\n    + exfalso; now apply Zlt_not_le with z y.\n    + exfalso; now apply Zlt_not_le with z y.\n    + rewrite leb_true in H1; [|now apply Z.le_le_pred, Z.lt_le_incl, Z.lt_trans with y].\n      destruct (y - 1 <=? z); [|destruct (z <=? x)].\n      * exfalso; apply Z.lt_asymm with x y, H4.\n        now apply Z.lt_trans with z.\n      * exfalso; apply Z.lt_irrefl with x, H1.\n      * exfalso; apply Z.lt_asymm with x y, H4.\n        apply Z.lt_pred_lt, H1.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33014,"user_id":null,"body":"Require Import Preloaded ZArith Lia. (* Hope this helps *)\n\nOpen Scope Z_scope.\n\n(* Define your Ltac helpers *)\nLtac leb_destruct :=\n  match goal with\n  | |- context[?x <=? ?y] => destruct (Z.leb_spec0 x y); auto; try lia\n  | H: context[?x <=? ?y] |- _ => destruct (Z.leb_spec0 x y); auto; try lia\n  end.\n\nTheorem tarai_r_correct :\n  forall x y z w,\n  tarai_r x y z w\n  -> w = if x <=? y then y\n         else if y <=? z then z\n         else x.\nProof.\n  intros. induction H; repeat leb_destruct.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33015,"user_id":null,"body":"Require Import Preloaded ZArith Lia. (* Hope this helps *)\n\nOpen Scope Z_scope.\n\n(* Define your Ltac helpers *)\nLtac helper :=\n  (match goal with\n  | |- context [ ?x <=? ?y] => (pose proof (Zle_cases x y) ; destruct (x <=? y) ; try lia)\n  | _ : context [?x <=? ?y] |- _ => (pose proof (Zle_cases x y) ; destruct (x <=? y) ; try lia)\n  end).\n\nTheorem tarai_r_correct :\n  forall x y z w,\n  tarai_r x y z w\n  -> w = if x <=? y then y\n         else if y <=? z then z\n         else x.\nProof.\n  intros x y z w H.\n  induction H.\n  - intros.\n    helper.\n  - intros.\n    repeat helper.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33016,"user_id":null,"body":"Require Import Preloaded ZArith Lia. (* Hope this helps *)\n\nOpen Scope Z_scope.\n\n(* Define your Ltac helpers *)\nLtac destruct_all_leb := repeat match goal with\n  |       |- context[ ?x <=? ?y ] => destruct (Z.leb_spec0 x y)\n  | H : context[ ?x <=? ?y ] |- _ => destruct (Z.leb_spec0 x y)\n  end.\n\n\nTheorem tarai_r_correct :\n  forall x y z w,\n  tarai_r x y z w\n  -> w = if x <=? y then y\n         else if y <=? z then z\n         else x.\nProof.\n  induction 1;\n    destruct_all_leb; lia. \nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33017,"user_id":null,"body":"Require Import Preloaded ZArith Lia. (* Hope this helps *)\n\nOpen Scope Z_scope.\n\n(* Define your Ltac helpers *)\nLtac helper :=\n  match goal with\n  | [ _ : context[?x <=? ?y] |- _ ] => destruct (Z.leb_spec x y)\n  | [ |- context[?x <=? ?y] ] => destruct (Z.leb_spec x y)\n  end.\n\nTheorem tarai_r_correct :\n  forall x y z w,\n  tarai_r x y z w\n  -> w = if x <=? y then y\n         else if y <=? z then z\n         else x.\nProof.\n  intros. induction H.\n  - rewrite (proj2 (Z.leb_le _ _)) by assumption. reflexivity.\n  - repeat helper; lia.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33018,"user_id":null,"body":"Require Import Preloaded ZArith Lia.\n\nOpen Scope Z_scope.\n\nLtac helper := match goal with \n| H: ?X = true, H1: ?X = false |- _ => rewrite H1 in H; discriminate H\n| H: true = false |- _ => discriminate H\n| H: _ = (if ?X then _ else _) |- _ => destruct X eqn:? \n| H: (if ?X then _ else _) = _ |- _ => destruct X eqn:? \n| |- _ = (if ?X then _ else _) => destruct X eqn:? \n| |- (if ?X then _ else _) = _ => destruct X eqn:? \n| H: ?X <=? ?Y = true |- _ => apply Z.leb_le in H\n| H: ?X <=? ?Y = false |- _ => apply Z.leb_gt in H\nend.\n\nTheorem tarai_r_correct :\n  forall x y z w,\n  tarai_r x y z w\n  -> w = if x <=? y then y\n         else if y <=? z then z\n         else x.\nProof.\nintros; induction H; repeat helper; lia.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33019,"user_id":null,"body":"Require Import Preloaded ZArith Lia. (* Hope this helps *)\n\nOpen Scope Z_scope.\n\n\nTheorem tarai_r_correct :\n  forall x y z w,\n  tarai_r x y z w\n  -> w = if x <=? y then y\n         else if y <=? z then z\n         else x.\nProof.\n  induction 1;\n  repeat\n    match goal with\n    | |- _ = (if ?a <=? ?b then _ else _) => destruct (Z.leb_spec a b)\n    | H : _ = (if ?a <=? ?b then _ else _) |- _ => destruct (Z.leb_spec a b)\n    end; lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5d19e7669dd9860024d3c5bc":[{"id":33020,"user_id":null,"body":"Require Import Preloaded List Arith.\nImport ListNotations.\n\nHint Constructors Subseq : core.\nLemma Subseq_drop': forall a xs ys, Subseq (a :: xs) ys -> Subseq xs ys.\nProof with auto.\n  intros a xs ys.\n  revert xs a.\n  induction ys; intros; inversion H; subst...\n  apply IHys in H2...\nQed.\n\nTheorem subseq_match_correct : forall (xs ys : list nat),\n  subseq_match xs ys = true <-> Subseq xs ys.\nProof with auto.\n  split; intros.\n  - generalize dependent ys.\n    induction xs; simpl; intros.\n    + induction ys; constructor...\n    + generalize dependent a.\n      induction ys; intros; [inversion H|].\n      destruct (Nat.eqb_spec a0 a); subst...\n  - generalize dependent ys.\n    induction xs; simpl; intros...\n    generalize dependent a.\n    induction ys; intros; [inversion H|].\n    destruct (Nat.eqb_spec a0 a); subst; inversion H; subst...\n    apply Subseq_drop' in H2...\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33021,"user_id":null,"body":"Require Import Preloaded List Arith.\nImport ListNotations.\n\nTheorem subseq_match_correct : forall (xs ys : list nat),\n  subseq_match xs ys = true <-> Subseq xs ys.\nProof with auto.\ninduction xs.\n- split; cbn... induction ys; intro; constructor...\n- induction ys. \n  + split;intros; inversion H.\n  + destruct (a =? a0) eqn:QQ.\n    * cbn. rewrite QQ. apply beq_nat_true in QQ. subst. \n      split; intros. constructor. apply IHxs...\n      apply IHxs.\n      clear IHys IHxs.\n      induction ys; inversion H; subst; auto; inversion H2; apply Subseq_drop... apply IHys. apply Subseq_drop...\n    * split; intros. \n      apply Subseq_drop. apply IHys. cbn in H. rewrite QQ in H. apply H.\n      cbn. rewrite QQ. apply IHys. inversion H; auto; subst. rewrite Nat.eqb_refl in QQ. discriminate.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33022,"user_id":null,"body":"Require Import Preloaded List Arith.\nImport ListNotations.\n\nLemma subseq'' : forall xs ys x, subseq_match xs ys = subseq_match (x::xs) (x::ys).\nProof with auto.\n  intros. cbn. rewrite Nat.eqb_refl...\nQed.\n\nLemma subseq' : forall xs ys x, subseq_match xs ys = true -> subseq_match xs (x::ys) = true.\n  induction xs; intros.\n  - cbn. auto.\n  - destruct (Nat.eq_dec a x). \n    + subst. induction ys. \n      cbn in H. discriminate.\n      cbn. rewrite Nat.eqb_refl. apply IHxs.\n      destruct (Nat.eq_dec x a); subst.\n      * erewrite subseq''. apply H.\n      * erewrite subseq''. apply IHys. cbn in H. \n        apply Nat.eqb_neq in n. rewrite n in H. apply H.\n    + cbn.  apply Nat.eqb_neq in n. rewrite n. apply H.\nQed.\n\nTheorem subseq_match_correct : forall (xs ys : list nat),\n  subseq_match xs ys = true <-> Subseq xs ys.\nProof with auto.\n  split.\n  - generalize dependent ys. induction xs.\n    + cbn. firstorder. induction ys; firstorder using Subseq.\n    + intros. cbn. cbn in H. \n      induction ys. discriminate. \n      destruct (a =? a0) eqn:QQ.\n      * apply beq_nat_true in QQ. subst. apply Subseq_take. apply IHxs...\n      * apply Subseq_drop. apply IHys. apply H.\n  - induction 1...\n    + cbn. rewrite Nat.eqb_refl...\n    + apply subseq'...\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33023,"user_id":null,"body":"Require Import Preloaded List Arith.\nImport ListNotations.\n\nLemma Subseq_refl : forall xs, Subseq xs xs.\nProof.\n  induction xs; constructor; auto.\nQed.\n\nLemma Subseq_nil_xs : forall xs, Subseq [] xs.\nProof.\n  induction xs; constructor; auto.\nQed.\n\nLemma subseq_match_correctR : forall (xs ys : list nat),\n  subseq_match xs ys = true -> Subseq xs ys.\nProof.\n  intros.\n  generalize dependent ys.\n  induction xs; intros; try reflexivity.\n  inversion H; subst.\n  + simpl. apply  Subseq_nil_xs.\n  + induction ys. simpl in H; try discriminate.\n    simpl in H. destruct (a =? a0) eqn:E.\n    * apply beq_nat_true in E. subst.\n      apply Subseq_take. auto.\n    * apply Subseq_drop. apply IHys. apply H.\nQed.\n\nLemma Subseq_inv : forall a xs ys, Subseq (a::xs) ys ->\n  (exists ys1 ys2, ys = ys1 ++ a :: ys2 \/\\ Subseq xs ys2).\nProof.\n  intros.\n  induction ys; inversion H; subst.\n  + exists []. exists ys. split; auto.\n  + destruct IHys as [ys1 [ys2 [Hy1 Hy2]]]; auto.\n    exists (a0::ys1). exists ys2.\n    split; auto. simpl. rewrite Hy1. reflexivity.\nQed.\n\nLemma Subseq_neq_inv : forall x xs y ys, x <> y ->\n  Subseq (x::xs) (y::ys) -> Subseq (x::xs) ys.\nProof.\n  intros; induction ys; inversion H0; subst; intuition.\nQed.\n\nLemma Subseq_mono : forall xs ys1 ys2,\n  Subseq xs ys2 -> Subseq xs (ys1 ++ ys2).\nProof.\n  intros. induction ys1; try constructor; auto.\nQed.\n\nLemma subseq_match_correctL : forall (xs ys : list nat),\n  Subseq xs ys -> subseq_match xs ys = true.\nProof.\n  intros.\n  generalize dependent ys.\n  induction xs; intros; auto.\n  destruct (Subseq_inv _ _ _ H) as [ys1 [ys2 [Hy1 Hy2]]].\n  subst. induction ys1.\n  - simpl. rewrite Nat.eqb_refl. auto.\n  - simpl. destruct (a =? a0) eqn:Eq.\n    + apply IHxs. auto. apply Subseq_mono.\n      replace (a::ys2) with ([a] ++ ys2) by reflexivity.\n      apply Subseq_mono; assumption.\n    + apply IHys1. apply Subseq_neq_inv with a0; try assumption.\n      apply beq_nat_false. assumption.\nQed.\n\nTheorem subseq_match_correct : forall (xs ys : list nat),\n  subseq_match xs ys = true <-> Subseq xs ys.\nProof.\n  split. \n  apply subseq_match_correctR.\n  apply subseq_match_correctL.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33024,"user_id":null,"body":"Require Import Preloaded List Arith Lia.\nImport ListNotations.\n\nLemma subseq_match_step_ne : forall x xs y ys, x =? y = false\n  -> subseq_match (x :: xs) (y :: ys) = subseq_match (x :: xs) ys.\nProof.\n  intros. cbn. rewrite H. auto.\nQed.\n\nLemma subseq_match_step_eq : forall x xs y ys, x =? y = true\n  -> subseq_match (x :: xs) (y :: ys) = subseq_match xs ys.\nProof.\n  intros. cbn. rewrite H. auto.\nQed.\n\nLtac solve_le :=\n  match goal with\n  |- length _ + length _ <= _ => cbn in *; lia\n  end.\n\nLemma subseq_match_head : forall n,\n  (forall xs ys a,\n    length xs + length ys <= n ->\n    subseq_match (a :: xs) ys = true -> subseq_match xs ys = true)\n  \/\\\n  (forall xs ys a, \n    length xs + length ys <= n ->\n    subseq_match xs ys = true -> subseq_match xs (a :: ys) = true).\nProof with (try solve_le; eauto).\n  induction n; split; intros;\n    try ( (* n = 0 *)\n      destruct xs; destruct ys; auto; cbn in *; lia\n    ); destruct IHn as [IH1 IH2].\n  - destruct ys; try discriminate.\n    destruct (a =? n0) eqn:Ha.\n    + rewrite subseq_match_step_eq in H0...\n      apply IH2...\n    + rewrite subseq_match_step_ne in H0...\n      destruct xs...\n      destruct (n1 =? n0) eqn:Hn.\n      * rewrite subseq_match_step_eq...\n        eapply IH1...\n        eapply IH1...\n      * rewrite subseq_match_step_ne...\n        eapply IH1...\n  - destruct xs...\n    destruct (n0 =? a) eqn:Ha.\n    + rewrite subseq_match_step_eq...\n      eapply IH1...\n    + rewrite subseq_match_step_ne...\nQed.\n\nTheorem subseq_match_correct : forall (xs ys : list nat),\n  subseq_match xs ys = true <-> Subseq xs ys.\nProof.\n  Hint Constructors Subseq.\n  split.\n  - generalize dependent ys.\n    induction xs; intros.\n    + induction ys; auto.\n    + induction ys.\n      * cbn in H; discriminate.\n      * cbn in H.\n        destruct (a =? a0) eqn:Han.\n        { apply beq_nat_true in Han. subst. auto. }\n        { apply beq_nat_false in Han. auto. }\n  - induction 1; cbn; auto.\n    + assert (a =? a = true) by apply Nat.eqb_refl.\n      rewrite H0. auto.\n    + edestruct subseq_match_head as [H1 H2].\n      apply H2; auto.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33025,"user_id":null,"body":"Require Import Preloaded List Arith.\nImport ListNotations.\n\nLemma Subseq_nil_l : forall (l : list nat), Subseq [] l.\nProof.\n  induction l.\n  - constructor.\n  - constructor. assumption.\nQed.\n\nLemma Subseq_elim_cons_l : forall a (l1 l2 : list nat),\n  Subseq (a :: l1) l2 -> Subseq l1 l2.\nProof.\n  intros. revert dependent a. induction l2; intros.\n  - inversion H.\n  - inversion H; subst.\n    + constructor. assumption.\n    + constructor. eapply IHl2. eassumption.\nQed.\n\nLemma Subseq_elim_cons : forall a1 a2 (l1 l2 : list nat),\n  Subseq (a1 :: l1) (a2 :: l2) -> Subseq l1 l2.\nProof.\n  intros. inversion H; subst.\n  - assumption.\n  - apply Subseq_elim_cons_l in H2. assumption.\nQed.\n\nLemma Subseq_elim_cons_neq : forall a1 a2 (l1 l2 : list nat),\n  a1 <> a2 ->\n  Subseq (a1 :: l1) (a2 :: l2) -> Subseq (a1 :: l1) l2.\nProof.\n  intros. inversion H0; subst.\n  - contradiction.\n  - assumption.\nQed.\n\nTheorem subseq_match_correct : forall (xs ys : list nat),\n  subseq_match xs ys = true <-> Subseq xs ys.\nProof.\n  split; intros.\n  - revert dependent ys. induction xs; intros.\n    + apply Subseq_nil_l.\n    + induction ys.\n      * cbn in H. discriminate.\n      * cbn in H. destruct (Nat.eqb_spec a a0).\n        -- subst. constructor. auto.\n        -- constructor. auto.\n  - revert dependent ys. induction xs; intros.\n    + cbn. reflexivity.\n    + induction ys.\n      * inversion H.\n      * cbn. edestruct (Nat.eqb_spec a a0).\n        -- apply Subseq_elim_cons in H. auto.\n        -- apply Subseq_elim_cons_neq in H; auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33026,"user_id":null,"body":"Require Import Preloaded List Arith.\nImport ListNotations.\n\nLemma easy_subseq : forall xs ys x, subseq_match (x :: xs) ys = true -> \n subseq_match xs ys = true.\nProof.\n induction xs;[auto|].\n induction ys;intros;[inversion H|].\n simpl in H;destruct (x =? a0);[|apply IHys in H];simpl;\n  (destruct (a =? a0);[eapply IHxs|];apply H).\nQed.\nLemma skip_subseq : forall xs ys x y, subseq_match (x :: xs) ys = true ->\n subseq_match (x :: xs) (y :: ys) = true.\nProof.\n induction xs;intros;(destruct ys;[inversion H|]);\n simpl;destruct (x =? y);[auto .. | \n change (subseq_match (a :: xs) (n :: ys) = true);eapply easy_subseq|];\n apply H.\nQed.\n\nTheorem subseq_match_correct : forall (xs ys : list nat),\n  subseq_match xs ys = true <-> Subseq xs ys.\nProof.\n  induction xs;induction ys;split;intros.\n + constructor.\n + auto.\n + constructor. apply IHys. auto.\n + auto.\n + inversion H.\n + inversion H.\n + simpl in H. remember (a =? a0) as ac;destruct ac.\n  - rewrite (beq_nat_eq _ _ Heqac) in *. constructor. apply IHxs. assumption.\n  - constructor. apply IHys. apply H.\n + inversion H;subst.\n  - simpl. rewrite <- beq_nat_refl. apply IHxs. assumption.\n  - apply skip_subseq. apply IHys. assumption.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33027,"user_id":null,"body":"Require Import Preloaded List Arith.\nImport ListNotations.\n\nLemma Subseq_l_nil: forall l, Subseq nil l.\nProof.\n  intros.\n  induction l; constructor; auto.\nQed.\n\n\nLemma subseq_match_neq: forall x y xs ys,\n     x =? y = false -> subseq_match (x :: xs) (y :: ys) = subseq_match (x :: xs) ys.\nProof. intros.  simpl. rewrite H. auto. Qed.\n\nLemma subseq_match_correct_aux: forall x y xs ys, \n    subseq_match (x :: xs) ys = true -> (subseq_match xs ys = true \/\\ subseq_match (x :: xs) (y :: ys) = true).\nProof.\n  intros.\n  generalize dependent x.\n  generalize dependent y.\n  generalize dependent xs.\n  induction ys; intros. inversion H.\n  split. \n  {\n    destruct(x =? a) eqn:xa.\n    {\n      simpl in H. rewrite xa in H.\n      simpl. destruct xs; auto.\n      destruct (n =? a); auto. \n      eapply IHys; auto; apply H.\n      apply IHys. auto.\n    }\n    rewrite subseq_match_neq in H; auto.\n    destruct xs; auto.\n    destruct (n =? a) eqn:na.\n    {\n      simpl. rewrite na.\n      eapply IHys; auto.\n      eapply IHys; auto.\n      apply H.\n    }\n    rewrite subseq_match_neq; auto.\n    eapply IHys; auto.\n    apply H.\n  }\n  destruct(x =? y) eqn:xy.\n  2:rewrite subseq_match_neq; auto.\n  destruct xs.\n    simpl. rewrite xy. auto.\n  destruct (n =? a) eqn:na.\n  {\n    simpl. rewrite na.\n    rewrite xy.    \n    destruct(x =? a) eqn:xa; auto.\n    {\n      replace(subseq_match (x :: n :: xs) (a :: ys)) with (subseq_match (n :: xs) ys) in H.\n        eapply IHys; auto. apply H.\n      simpl.\n      rewrite xa. auto.\n    }\n    rewrite subseq_match_neq in H; auto.\n    eapply IHys. auto. eapply IHys; auto.\n    apply H.\n  }\n  destruct(x =? a) eqn:xa.\n  {\n    simpl in *.\n    rewrite xa in *. rewrite xy. rewrite na. auto.\n  }\n  rewrite subseq_match_neq in H; auto.\n  replace(subseq_match (x :: n :: xs) (y :: a :: ys)) with (subseq_match (n :: xs) (a :: ys)).\n    rewrite subseq_match_neq; auto.\n    eapply IHys; auto. apply H.\n  simpl.\n  rewrite na. rewrite xy. auto.\nQed.\n\nTheorem subseq_match_correct : forall (xs ys : list nat),\n  subseq_match xs ys = true <-> Subseq xs ys.\nProof.\n  intros.\n  split; intros.\n  {\n    generalize dependent xs.\n    induction ys; intros.\n      destruct xs. constructor. inversion H.\n    destruct xs.\n      apply Subseq_l_nil.\n    simpl in H.\n    destruct(Nat.eq_dec n a). subst.\n    {\n      rewrite Nat.eqb_refl in H.\n      apply Subseq_take.\n      apply IHys.\n      auto.\n    }\n    apply Subseq_drop.\n    apply IHys.\n    simpl.\n    apply Nat.eqb_neq in n0.\n    rewrite n0 in H.\n    auto.\n  }\n  induction H;\n    auto.\n  {\n    simpl.\n    rewrite Nat.eqb_refl.\n    auto.\n  }\n  destruct xs; auto.\n  apply subseq_match_correct_aux. auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33028,"user_id":831,"body":"Require Import Preloaded List Arith.\nImport ListNotations.\n\nHint Constructors Subseq : core.\n\nLtac invcs H := inversion H; clear H; subst.\n\nLemma subseqboth xs ys a : Subseq (a :: xs) (a :: ys) -> Subseq xs ys.\n  intro; induction ys; invcs H; auto; invcs H2; auto.\nQed.\n\nLemma subseqempty ys : Subseq [] ys.\n  induction ys; auto.\nQed.\n\nHint Resolve subseqboth subseqempty : core.\n\nTheorem subseq_match_correct : forall (xs ys : list nat), subseq_match xs ys = true <-> Subseq xs ys.\nProof.\n  induction xs; intros; cbn.\n  - split; auto.\n  - induction ys.\n    + split; intro; inversion H.\n    + remember (a =? a0) as aeq. case aeq in *.\n      * apply beq_nat_eq in Heqaeq. subst.\n        split; intro.\n        -- constructor. apply IHxs; easy.\n        -- apply IHxs; eauto.\n      * split; intro.\n        -- constructor.\n           apply IHys; easy.\n        -- apply IHys. invcs H; auto.\n           symmetry in Heqaeq. destruct (beq_nat_false _ _ Heqaeq). auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33029,"user_id":885,"body":"Require Import Preloaded List Arith.\nImport ListNotations.\nFrom Coq Require Import Unicode.Utf8.\n\nLemma silly1 : forall xs, Subseq [] xs.\nProof.\n  induction xs. constructor. constructor. auto.\nQed.\n\nInductive reflect (P : Prop) : bool \u2192 Prop := \n  | ReflectT : P \u2192 reflect P true \n  | ReflectF : \u00ac P \u2192 reflect P false.\n\nTheorem iff_reflect : \u2200 P b, (P \u2194 b = true) \u2192 reflect P b. \nProof. \n  intros P b H. destruct b.   \n  - apply ReflectT. rewrite H. reflexivity.   \n  - apply ReflectF. rewrite H. intros H'. inversion H'. \nQed.\n\nTheorem reflect_iff : \u2200 P b, reflect P b \u2192 (P \u2194 b = true). \nProof.\n  intros. split.\n  - destruct H.\n    + auto.\n    + intros. unfold not in H. apply H in H0. inversion H0.\n  - destruct H.\n    + auto.\n    + intros. inversion H0.\nQed.\n\nLemma beq_natP : \u2200 n m, reflect (n = m) (beq_nat n m). \nProof.   \n  intros n m. apply iff_reflect. rewrite beq_nat_true_iff. reflexivity. \nQed.\n\nLemma silly2: forall a xs ys,\n    subseq_match xs ys = true -> subseq_match xs (a::ys) = true.\nProof.\n  intros.\n  generalize dependent a. generalize dependent ys.\n  induction xs; intros; auto.\n  simpl in *. rewrite H.\n  destruct (a =? a0) eqn:Ha0; auto.\n  destruct (beq_natP a a0). subst.\n  induction ys.\n  discriminate H.\n  destruct (a0 =? a) eqn: Haa10; auto.\n  inversion Ha0.\nQed.\n\nLemma silly3: forall a xs ys,\n    subseq_match xs ys = true -> subseq_match (a::xs) (a::ys) = true.\nProof.\n  intros. simpl. destruct (beq_natP a a). auto. exfalso. apply H0. auto. Qed.\n\nTheorem subseq_match_correct : forall (xs ys : list nat),\n  subseq_match xs ys = true <-> Subseq xs ys.\nProof.\n  split.\n  - intros. generalize dependent xs. induction ys;intros.\n    destruct xs. constructor. inversion H. destruct xs.\n    apply silly1. destruct (n =? a) eqn:Heq.\n    + simpl in H. rewrite Heq in H.\n      destruct (beq_natP n a). rewrite H0. constructor. apply IHys. auto.\n      inversion Heq.\n    + simpl in H. rewrite Heq in H. constructor. apply IHys. auto.\n  - intros. induction H; auto.\n    apply silly3. auto.\n    apply silly2. auto.\nQed. ","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5d1eae23c193ae0025b5d50b":[{"id":33030,"user_id":null,"body":"Require Import Preloaded Arith.\nImport Nat.\n\nLemma strong_induction : forall (P : nat -> Prop), P 0 ->\n  (forall n, (forall m, m <= n -> P m) -> P (S n)) ->\n  (forall n, P n).\nProof.\n  intros P P0 PS n; cut (forall m, m <= n -> P m); [intros H; now apply H|].\n  induction n; intros m Hle; [inversion Hle; apply P0|].\n  inversion Hle; subst; clear Hle.\n  - apply PS, IHn.\n  - apply IHn, H0.\nQed.\n\nLemma fib_succ : forall n, fib n + fib (S n) = fib (S (S n)).\nProof. intros; simpl; ring. Qed.\n\nLemma fib_2x : forall n,\n  fib n * (2 * fib (S n) - fib n) = fib (2 * n) \/\\\n  fib n * fib n + fib (S n) * fib (S n) = fib (S (2 * n)).\nProof.\n  intros [|n]; [repeat split|].\n  replace (2 * fib (S (S n))) with (fib (S (S n)) + fib n + fib (S n)); [|rewrite <- fib_succ; ring].\n  rewrite add_sub; induction n; [repeat split|].\n  destruct IHn as [IH0 IH1].\n  replace (2 * S (S n)) with (S (S (2 * S n))); [|ring].\n  repeat rewrite <- fib_succ; rewrite <- IH0, <- IH1; repeat rewrite <- fib_succ; split; ring.\nQed.\n\nLemma fib_2x0 : forall n, fib n * (2 * fib (S n) - fib n) = fib (2 * n).\nProof. intros n; now destruct (fib_2x n). Qed.\n\nLemma fib_2x1 : forall n, fib n * fib n + fib (S n) * fib (S n) = fib (S (2 * n)).\nProof. intros n; now destruct (fib_2x n). Qed.\n\nLemma SSn_div2 : forall n, S (S n) \/ 2 = S (n \/ 2).\nProof.\n  intros n; replace (S (S n)) with (1 * 2 + n); [|ring].\n  now rewrite div_add_l.\nQed.\n\nLemma evenodd_muldiv : forall n,\n  (even n = true -> 2 * (n \/ 2) = n) \/\\\n  (even n = false -> 2 * (n \/ 2) = pred n).\nProof.\n  intros [|n]; [easy|].\n  replace (pred (S n)) with n; [|easy].\n  cut (\n    (even (S n) = true -> 2 * (S n \/ 2) = S n) \/\\\n    (even (S n) = false -> 2 * (S n \/ 2) = n) \/\\\n    (even (S (S n)) = true -> 2 * (S (S n) \/ 2) = S (S n)) \/\\\n    (even (S (S n)) = false -> 2 * (S (S n) \/ 2) = S n)\n  ); [easy|].\n  induction n; [easy|].\n  destruct IHn as [e0 [o0 [e1 o1]]]; split; [easy|split; [easy|]].\n  rewrite SSn_div2.\n  replace (2 * S (S n \/ 2)) with (S (S (2 * (S n \/ 2)))); [|ring].\n  split; intros; [rewrite e0|rewrite o0]; easy.\nQed.\n\nLemma even_muldiv : forall n, even n = true -> 2 * (n \/ 2) = n.\nProof. intros n; now destruct (evenodd_muldiv n). Qed.\n\nLemma odd_muldiv : forall n, even n = false -> 2 * (n \/ 2) = pred n.\nProof. intros n; now destruct (evenodd_muldiv n). Qed.\n\nTheorem fib_fast_correct : forall n, fib_fast n = fib n.\nProof.\n  cut (forall gas n, n <= gas -> fib2 gas n = (fib n, fib (S n))); [unfold fib_fast; intros H n; now rewrite H|].\n  intros gas n; revert gas; induction n using strong_induction; intros gas Hle; [now destruct gas|].\n  destruct gas; [inversion Hle|].\n  replace (fib2 (S gas) (S n)) with (\n    let (a, b) := fib2 gas (S n \/ 2) in\n    let c := a * (2 * b - a) in\n    let d := a * a + b * b in\n    if even (S n) then (c, d) else (d, c + d)\n  ); [|easy].\n  assert (S n \/ 2 <= n) as Hlediv.\n  {\n    destruct n; [easy|].\n    apply div_le_upper_bound; [easy|].\n    replace (2 * S n) with (S (S (2 * n))); [|ring].\n    apply le_n_S, le_n_S; now destruct (mult_O_le n 2). \n  }\n  rewrite H, fib_2x0, fib_2x1; [destruct (Sumbool.sumbool_of_bool (even (S n))) as [Hev|Hod]| |].\n  - now rewrite Hev, even_muldiv.\n  - rewrite Hod, odd_muldiv; [|easy].\n    replace (pred (S n)) with n; [|easy].\n    replace (let c := fib n in let d := fib (S n) in (d, c + d)) with (fib (S n), fib n + fib (S n)); [|easy].\n    now rewrite fib_succ.\n  - easy.\n  - transitivity n; [|apply le_S_n]; easy.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33031,"user_id":null,"body":"Require Import Preloaded Arith Lia.\nImport Nat.\n\nTheorem strong_induction : forall {P: nat -> Prop},\n  P 0 ->\n  (forall n, (forall m, m <= n -> P m) -> P (S n)) ->\n  (forall n, P n).\nProof.\n  intros; cut (forall m, m <= n -> P m); [intros C; now apply C|].\n  induction n.\n  - now destruct m.\n  - intros; inversion H1.\n    + now apply H0.\n    + now apply IHn.\nQed.\n\nLemma fib_double : forall n,\n  fib n * (2 * fib (S n) - fib n) = fib (2 * n) \/\\\n  fib n * fib n + fib (S n) * fib (S n) = fib (S (2 * n)).\nProof.\n  destruct n; [easy|].\n  assert (2 * fib (S (S n)) - fib (S n) = fib (S (S n)) + fib n) as R; [|repeat rewrite R; clear R].\n    { cut (2 * fib (S (S n)) = fib (S (S n)) + fib n + fib (S n));\n      [intros C; rewrite C|rewrite <- double_twice; unfold double; simpl; ring].\n      rewrite add_sub; easy. }\n  induction n; [easy|].\n  assert (2 * S (S n) = S (S (2 * S n))) as R; [ring|rewrite R; clear R].\n  assert (forall n, fib (S (S n)) = fib (S n) + fib n) as R; [easy|repeat rewrite R; clear R].\n  destruct IHn; rewrite <- H0, <- H; clear; split; simpl; ring.\nQed.\n\nLemma le_div2 : forall n, S n \/ 2 <= n.\nProof.\n  destruct n; [|apply div_le_upper_bound]; try easy.\n  assert (2 * S n = S (S (2 * n))) as R; [ring|rewrite R; clear R].\n  apply le_n_S, le_n_S.\n  assert (n = 1 * n) as R; [ring|rewrite R at 1; clear R].\n  apply mul_le_mono_r; repeat constructor.\nQed.\n\nLemma fib2_correct : forall n t, n <= t -> fib2 t n = (fib n, fib (S n)).\nProof.\n  refine (strong_induction _ _).\n  - now destruct t0.\n  - intros; destruct t0; [easy|]; unfold fib2; fold fib2; rewrite H.\n    + destruct (fib_double (S n \/ 2)); rewrite H1, H2; clear H1 H2.\n      destruct (Even_or_Odd (S n)).\n      * rewrite (proj2 (even_spec _)); [|easy];\n        destruct H1; rewrite mul_comm in H1; rewrite H1, div_mul, mul_comm;\n        easy.\n      * rewrite <- negb_odd, (proj2 (odd_spec _)); [unfold negb|easy];\n        destruct H1; rewrite add_comm, mul_comm in H1; rewrite H1, div_add; [|easy].\n        assert (1 \/ 2 + x = x) as R; [easy|rewrite R; clear R].\n        assert (1 + x * 2 = S (2 * x)) as R; [ring|rewrite R; clear R].\n        rewrite add_comm; easy.\n    + apply le_div2.\n    + apply (le_trans _ n); [apply le_div2|apply le_S_n; easy].\nQed.\n\nTheorem fib_fast_correct : forall n, fib_fast n = fib n.\nProof.\n  intros n; unfold fib_fast; now rewrite fib2_correct.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33032,"user_id":null,"body":"Require Import Preloaded Arith Lia.\nImport Nat.\n\nLemma fib_mono: forall k, fib (S k) >= fib k.\nProof.\n  intros. induction k.\n  - simpl. lia.\n  - simpl. destruct k; simpl; try lia.\nQed.\n\nLemma fib_2n : forall k,\n  fib(2 * k) = fib(k) * (2 * fib(k + 1) - fib(k)) \/\\\n  fib(1 + 2 * k) = fib(k) ^ 2 + fib(k + 1) ^ 2.\nProof.\n  induction k.\n  - simpl. auto.\n  - split; destruct IHk;\n        rewrite mul_succ_r;\n        rewrite add_comm; rewrite add_1_r;\n        replace (2 + 2*k) with (S (S (2*k))) by reflexivity;\n        replace (2 * k + 2) with (2 + 2 * k) by apply add_comm;\n        replace (fib (S (2 + 2 * k))) with (fib (S (S (2 * k))) + fib (S (2*k))) by reflexivity;\n        replace (fib (S (S (2*k)))) with (fib (S (2*k)) + fib (2*k)) by reflexivity;\n        replace (S (2* k)) with (1 + 2*k) by reflexivity;\n        rewrite H; rewrite H0;\n        replace (k + 1) with (S k) by lia;\n        replace (S k + 1) with (S (S k)) by lia;\n        replace (fib (S (S k))) with (fib (S k) + fib k) by reflexivity;\n        unfold pow; repeat rewrite mul_1_r;\n        remember (fib k) as fk;\n        remember (fib (S k)) as fSk;\n        repeat rewrite (mul_add_distr_l);\n        repeat rewrite (mul_sub_distr_l);\n        repeat rewrite (mul_add_distr_l);\n        assert (fk * fk <= 2 * (fk * fSk)); try lia;\n        eapply le_trans;\n        try apply (mul_le_mono_l fk fSk);\n        assert (Hmono := fib_mono k); lia.\nQed.\n\nLemma even_divmod_2 : forall k, let (x, y) := divmod k 1 0 1 in\n                                 if even k then y = 1 else y = 0.\nProof.\n  intros.\n  assert (Hd := divmod_spec k 1 0 1).\n  destruct (divmod k 1 0 1) eqn:Ediv.\n  destruct Hd; try lia.\n  simpl in H.\n  replace (k + 0 + 0) with k in H by lia.\n  replace (n + (n + 0)) with (2 * n) in H by lia.\n  destruct n0; destruct (even k) eqn:Even; try lia.\n  - rewrite plus_comm in H.\n    rewrite H in Even.\n    rewrite even_add_mul_2 in Even.\n    discriminate.\n  - destruct n0; try lia.\n    rewrite H in Even.\n    rewrite plus_comm in Even.\n    rewrite even_add_mul_2 in Even.\n    discriminate.\nQed.\n\nLemma fib2_correct : forall k n, k >= n -> fib2 k n = (fib n, fib (S n)).\nProof.\n  induction k.\n  - intros. replace n with 0 by lia. simpl. reflexivity.\n  - intros. simpl.\n    destruct n.\n    + reflexivity.\n    + assert (Hd := divmod_spec (S n ) 1 0 1).\n      replace (fib (S n) + fib n) with (fib (S (S n))) by reflexivity.\n      destruct (divmod (S n) 1 0 1) eqn:Ed.\n      destruct Hd; try lia.\n      destruct (fib2 k n0) eqn:Ef.\n      replace ((fst (n0, n1))) with n0 by reflexivity.\n      rewrite Ef.\n      rewrite IHk in Ef; try lia.\n      assert (n2 = fib n0). inversion Ef. subst. reflexivity.\n      assert (n3 = fib (S n0)). inversion Ef. subst. reflexivity.\n      replace (n3 + (n3 + 0)) with (2*n3) by reflexivity.\n      repeat rewrite H2.\n      repeat rewrite H3.\n      assert (H4 := fib_2n n0).\n      destruct H4.\n      replace (S n0) with (n0 + 1) by lia.\n      rewrite <- H4.\n      unfold pow in H5.\n      repeat rewrite mult_1_r in H5.\n      rewrite <- H5.\n      assert (H6 := even_divmod_2 (S n)).\n      rewrite Ed in H6.\n      destruct (even (S n)) eqn:Even.\n      * subst. simpl in H0. repeat rewrite plus_0_r in H0.\n        replace (n0 + n0) with (2*n0) in H0 by lia.\n        rewrite H0. simpl. reflexivity.\n      * subst. simpl in H0. repeat rewrite plus_0_r in H0.\n        rewrite add_1_r in H0.\n        replace (fib (2 * n0) + fib (1 + 2 * n0)) with (fib (S (S (2*n0))))\n          by (rewrite (plus_comm (fib (2*n0))); reflexivity).\n          replace (n0 + n0) with (2*n0) in H0 by lia.\n        rewrite H0. reflexivity.\nQed.\n  \n\nTheorem fib_fast_correct : forall n, fib_fast n = fib n.\nProof.\n  intros.\n  unfold fib_fast.\n  rewrite fib2_correct.\n  + reflexivity.\n  + lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33033,"user_id":null,"body":"Require Import Preloaded Arith Lia.\nImport Nat.\n\nLemma fib_equation : forall n, fib (S (S n)) = fib (S n) + fib n.\nProof.\n  reflexivity.\nQed.\n\nLemma fib_mono : forall n, fib n <= fib (S n).\nProof.\n  destruct n.\n  - cbn. lia.\n  - destruct n.\n    + cbn. lia.\n    + rewrite 3!fib_equation. lia.\nQed.\n\nLemma fib_odd_even : forall k,\n  fib (2 * k) = fib k * (2 * fib (S k) - fib k)\n  \/\\ fib (2 * k + 1) = (fib k) * (fib k) + fib (S k) * fib (S k).\nProof.\n  induction k.\n  - split; reflexivity.\n  - destruct IHk as (IHk1 & IHk2).\n    split.\n    + replace (2 * S k) with (S (S (2 * k))) by lia.\n      rewrite fib_equation. rewrite <- Nat.add_1_r.\n      rewrite IHk2. rewrite IHk1.\n      rewrite fib_equation.\n      pose proof (fib_mono k). nia.\n    + replace (2 * S k + 1) with (S (S (2 * k + 1))) by lia.\n      rewrite fib_equation.\n      replace (S (2 * k + 1)) with (S (S (2 * k))) by lia.\n      rewrite fib_equation. rewrite <- Nat.add_1_r.\n      rewrite IHk1, IHk2.\n      rewrite fib_equation.\n      pose proof (fib_mono k). nia.\nQed.\n\nLemma fib_odd : forall k,\n  fib (2 * k + 1) = (fib k) * (fib k) + fib (S k) * fib (S k).\nProof.\n  intros. apply fib_odd_even.\nQed.\n\nLemma fib_even : forall k,\n  fib (2 * k) = fib k * (2 * fib (S k) - fib k).\nProof.\n  intros. apply fib_odd_even.\nQed.\n\nLemma fib_fast_correct_aux : forall p n, n <= p -> fib2 p n = (fib n, fib (S n)).\nProof.\n  induction p; intros.\n  - inversion H; subst. reflexivity.\n  - destruct n.\n    + reflexivity.\n    + cbn [fib2]. rewrite <- div2_div.\n      rewrite IHp.\n      * pose proof (div2_odd (S n)).\n        rewrite <- negb_even in H0.\n        destruct (even (S n)).\n        -- cbn [b2n negb] in H0. rewrite Nat.add_0_r in H0.\n           f_equal; symmetry.\n           ++ rewrite H0 at 1. apply fib_even.\n           ++ rewrite H0 at 1. rewrite <- Nat.add_1_r. apply fib_odd.\n        -- cbn [b2n negb] in H0.\n           f_equal; symmetry.\n           ++ rewrite H0 at 1. apply fib_odd.\n           ++ rewrite H0 at 1. rewrite Nat.add_1_r. rewrite fib_equation.\n              rewrite <- Nat.add_1_r.\n              rewrite fib_odd, fib_even. lia.\n      * transitivity n. apply le_div2. lia.\nQed.\n\nTheorem fib_fast_correct : forall n, fib_fast n = fib n.\nProof.\n  intros. unfold fib_fast.\n  rewrite fib_fast_correct_aux by reflexivity.\n  reflexivity.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33034,"user_id":null,"body":"Require Import Preloaded Arith Lia.\nImport Nat.\nRequire Import Wf.\n\n\nLemma fib2_t_irrev: forall n t1 t2, n <= t1 -> n <= t2 -> fib2 t1 n = fib2 t2 n.\nProof.\n  intros.\n  enough(forall n t1 t2, n <= t1 -> t1 <= t2 -> fib2 t1 n = fib2 t2 n).\n  {\n    destruct (le_ge_dec t1 t2).\n      apply H1; auto.\n    unfold ge in g.\n    symmetry.\n    apply H1; auto.\n  }\n  clear H H0 n t1 t2.\n  intros.\n  generalize dependent n.\n  induction H0. intros; auto.\n  intros.\n  rewrite IHle; auto.\n  assert(n <= m). lia.\n  clear t1 H0 IHle H.\n  generalize dependent m.\n  induction n using (well_founded_induction lt_wf_0). intros.\n  destruct n. destruct m; auto.\n  simpl.\n  destruct m. lia.\n  replace (fib2 (S m) (S n)) with ((let (a, b) := fib2 m (S n \/ 2) in\n       if match n with\n          | 0 => false\n          | S n' => even n'\n          end\n       then (a * (b + (b + 0) - a), a * a + b * b)\n       else (a * a + b * b, a * (b + (b + 0) - a) + (a * a + b * b)))); auto.\n  replace (fst (divmod n 1 0 0)) with (S n \/ 2); auto.\n  rewrite H; auto.\n    rewrite <- div2_div. apply lt_div2. lia.\n  rewrite <- div2_div.\n  eapply le_trans. apply le_div2.\n  lia.\nQed.\nRecord mat2 : Type :=\nmk_mat2\n{\n  a : nat;\n  b : nat;\n  c : nat;\n  d : nat\n}.\n\nDefinition mat2_id : mat2 := mk_mat2 1 0 0 1.\n\nDefinition mat2_mult (x y : mat2) : mat2 :=\nmk_mat2 \n  (a x * a y + b x * c y)\n  (a x * b y + b x * d y)\n  (c x * a y + d x * c y)\n  (c x * b y + d x * d y).\n\nFixpoint mat2_pow (x : mat2) (n : nat) :=\nmatch n with\n| O => mat2_id\n| S n' => mat2_mult x (mat2_pow x n')\nend.\n\n\nLemma mat2_id_l : forall x : mat2, mat2_mult mat2_id x = x.\nProof.\n  intros.\n  unfold mat2_id. unfold mat2_mult. simpl.\n  destruct x. simpl.\n  f_equal; lia.\nQed.\n\nLemma mat2_id_r : forall x : mat2, mat2_mult x mat2_id = x.\nProof.\n  intros.\n  unfold mat2_id. unfold mat2_mult. simpl.\n  destruct x. simpl.\n  f_equal; lia.\nQed.\n\n\nLemma mat2_mult_assoc : forall (x y z : mat2), mat2_mult (mat2_mult x y) z = mat2_mult x (mat2_mult y z).\nProof.\n  intros.\n  unfold mat2_mult. simpl.\n  f_equal; lia.\nQed.\n\nLemma mat2_pow_plus: forall x n m, mat2_pow x (n+m) = mat2_mult (mat2_pow x n) (mat2_pow x m).\nProof.\n  intros.\n  induction n.\n    simpl. rewrite mat2_id_l. auto.\n  simpl.\n  rewrite IHn.\n  rewrite mat2_mult_assoc.\n  auto.\nQed.\n\nLemma fib_mat_exp: forall n, n <> 0 -> mat2_pow (mk_mat2 1 1 1 0) n = \n    mk_mat2 (fib (S n)) (fib n) (fib n) (fib (pred n)).\nProof.\n  intros. \n  induction n. lia. \n  destruct n. auto.\n  replace (mat2_pow {| a := 1; b := 1; c := 1; d := 0 |} (S (S n))) with\n      (mat2_mult {| a := 1; b := 1; c := 1; d := 0 |} (mat2_pow {| a := 1; b := 1; c := 1; d := 0 |} (S n))); auto.\n  rewrite IHn; [|lia].\n  unfold mat2_mult.\n  simpl.\n  f_equal; auto; lia.\nQed.\n\n\nLemma fib2_2n: forall n m p, 2 * n <= m -> n <= p -> fib2 m (2 * n) = \n  (\n      (fst (fib2 p n) * (2 * snd (fib2 p n) - (fst (fib2 p n)))),\n      (snd (fib2 p n) * snd (fib2 p n) + fst (fib2 p n) * fst (fib2 p n))\n  ).\nProof.\n  intros.\n  simpl.\n  repeat rewrite add_0_r.\n  destruct m. destruct p; auto. destruct n; auto. lia.\n  destruct p; auto. destruct n; auto; lia.\n  replace (fib2 (S m) (n + n))\n    with \n    (let (a, b) := fib2 m ((n+n) \/ 2) in\n    let c := a * (2 * b - a) in\n    let d := a * a + b * b in\n    if even (n+n) then (c, d) else (d, c + d)). \n  2:{  \n    simpl. destruct n; auto.\n    simpl. destruct m; auto.\n  }\n  replace ((n + n) \/ 2) with n. \n  2:{ rewrite <- div2_div. rewrite <- div2_double at 1. f_equal. lia. }\n  replace (even (n+n)) with true.\n  2:{ replace (n+n) with (0 + 2 * n). rewrite even_add_mul_2. auto. lia. }\n  replace (fib2 m n) with (fib2 (S p) n).\n  2:{ apply fib2_t_irrev; auto. lia. }\n  destruct (fib2 (S p)) eqn:e. simpl.\n  f_equal; lia.\nQed.\n\nLemma fib2_S2n: forall n m p, S (2 * n) <= m -> 2 * n <= p -> fib2 m (S (2 * n)) = \n  ((snd (fib2 p (2 * n))), (fst (fib2 p (2 * n))) + (snd (fib2 p (2 * n)))).\nProof.\n  intros.\n  destruct m. lia.\n  destruct p. destruct n. simpl. destruct m; auto. lia.\n  replace (fib2 (S m) (S (2 * n)))\n    with \n    (let (a, b) := fib2 m ((S (2 * n)) \/ 2) in\n    let c := a * (2 * b - a) in\n    let d := a * a + b * b in\n    if even (S (2 * n)) then (c, d) else (d, c + d)); auto.\n  replace (S (2 * n) \/ 2) with n.\n  2:{ rewrite <- div2_div. rewrite div2_succ_double. auto. }\n  rewrite fib2_2n with n _ m;try lia.\n  replace (even (S (2 * n))) with false. simpl.\n  destruct (fib2 m n) eqn:e. simpl. f_equal; lia.\n  rewrite even_succ.\n  rewrite <- add_0_l at 1.\n  rewrite odd_add_mul_2. auto.\nQed.\n\nLemma fib_2n: forall n, fib (2 * n) = fib n * (2 * fib (S n) - fib n).\nProof.\n  intros.\n  destruct n; auto. \n  specialize fib_mat_exp with ((S n) + (S n)). intros.\n  specialize fib_mat_exp with (S n). intros.\n  rewrite mat2_pow_plus in H.\n  rewrite H0 in H; auto.\n  clear H0.\n  unfold mat2_mult in H.\n  assert(S n + S n <> 0). lia.\n  apply H in H0. clear H.\n  replace (2 * S n) with (S n +  S n); [|lia].\n  replace (fib (S n + S n)) with \n      (fib (S (S n)) * fib (S n) + fib (S n) * fib (pred (S n))).\n  2:{ inversion H0. auto. }\n  replace (fib (S (S n))) with (fib n + fib (S n)); [|simpl; lia].\n  replace (pred (S n)) with n; auto.\n  replace (2 * (fib n + fib (S n)) - fib (S n)) with (2 * fib n + fib (S n)); lia.\nQed.\n\nLemma fib_S2n: forall n, fib (S (2 * n)) = fib (S n) * fib (S n) + fib n * fib n.\nProof.\n  intros.\n  destruct n. auto.\n  specialize fib_mat_exp with (1 + (S n + S n)). intros.\n  specialize fib_mat_exp with (S n). intros.\n  repeat rewrite mat2_pow_plus in H.\n  rewrite H0 in H; [|lia].\n  assert(1 + (S n + S n) <> 0). lia.\n  apply H in H1. clear H.\n  unfold mat2_pow in H1. \n  unfold mat2_mult in H1.\n  unfold mat2_id in H1.\n  replace (S (2 * S n)) with (1 + (S n + S n)); [|lia].\n  remember ((1 + (S n + S n))).\n  remember (S n0).\n  remember (S n).\n  remember (S n2).\n  simpl in H1.\n  inversion H1. lia.\nQed.\n\nLemma nat_Z_ind: forall (P : nat -> Prop), P O -> (forall n, P n -> P (2 * n)) -> (forall n, P n -> P (S (2 * n))) ->\n    forall n, P n.\nProof.\n  intros.\n  induction n using (well_founded_induction lt_wf_0).\n  destruct n; auto.\n  destruct (Even_or_Odd n).\n  {\n    unfold Even in H3.\n    destruct H3. subst.\n    apply H1.\n    apply H2. lia.\n  }\n  unfold Odd in H3.\n  destruct H3. subst.\n  replace (S (2 * x + 1)) with (2 * S x); [|lia].\n  apply H0.\n  apply H2. lia.\nQed.\n\n\nTheorem fib_fast_correct : forall n, fib_fast n = fib n.\nProof.\n  intros.\n  unfold fib_fast.\n  enough(forall m, n <= m -> fib2 m n = (fib n, fib (S n))).\n    rewrite H; auto.\n  induction n using nat_Z_ind; intros. destruct m; auto. \n  {\n    repeat erewrite fib2_2n; auto. \n    rewrite fib_2n.\n    rewrite fib_S2n.\n    rewrite IHn; auto.\n  }\n  erewrite fib2_S2n; auto.\n  erewrite fib2_2n; auto.\n  rewrite fib_S2n.\n  replace (S (S (2 * n))) with (2 * (S n)); [|lia].\n  rewrite fib_2n.\n  replace (fib (S (S n))) with (fib (S n) + fib n); auto.  \n  rewrite IHn; auto.\n  remember (fib (S n)) as fibSn.\n  simpl.\n  f_equal.\n  repeat rewrite mul_sub_distr_l.\n  repeat rewrite mul_add_distr_l.\n  repeat rewrite mult_0_r.\n  repeat rewrite plus_0_r.\n  rewrite <- add_sub_swap. lia.\n  rewrite HeqfibSn.\n  rewrite <- mul_add_distr_l.\n  apply le_trans with (fib n * (fib (S n))); try lia.\n  apply mul_le_mono_l.\n  clear IHn m H.\n  induction n; simpl; lia.\nQed.\n  ","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33035,"user_id":null,"body":"Require Import Preloaded Arith Lia Div2 Even.\nImport Nat.\n\n\nTheorem fib_add n m : fib (n + S m) = fib (S m) * fib (S n) + fib m * fib n.\nProof.\n  generalize n m; clear n m.\n  fix n0 1.\n  intros.\n  destruct n.\n  + simpl.\n    rewrite Nat.mul_0_r.\n    rewrite Nat.add_0_r.\n    rewrite Nat.mul_1_r.\n    reflexivity.\n  + generalize n ; clear n.\n    fix n1 1.\n    intro.\n    destruct n.\n    * simpl.\n      repeat rewrite Nat.mul_1_r.\n      reflexivity.\n    * assert (forall n , fib (S (S n)) = fib (S n) + fib n).\n        reflexivity.\n      rewrite H with n.\n      rewrite H with (S n).\n      repeat rewrite Nat.mul_add_distr_l.\n      rewrite add_shuffle1.\n      rewrite <- n1.\n      rewrite <- n0.\n      repeat rewrite add_succ_l.\n      apply H.\nQed.\n\nTheorem fib_s2n n : fib (2*n+1) = (fib n) * (fib n) + (fib (S n)) * (fib (S n)).\nProof.\n  rewrite mul_succ_l.\n  rewrite mul_1_l.\n  rewrite add_1_r.\n  rewrite <- add_succ_r.\n  rewrite fib_add.\n  apply add_comm.\nQed.\n\nTheorem fib_2n n : fib (2*n) = (fib n) * (2 * fib (S n) - fib n).\nProof.\n  rewrite <- add_sub with (fib (2 * n)) (fib (2 * n + 1)).\n  assert (forall n , fib (S (S n)) = fib (S n) + fib n).\n    reflexivity.\n  rewrite add_comm.\n  rewrite add_1_r.\n  rewrite <- H.\n  rewrite <- add_1_r with (2 * n).\n  rewrite fib_s2n.\n  rewrite mul_succ_l.\n  rewrite mul_1_l.\n  rewrite <- add_assoc.\n  rewrite <- add_succ_r.\n  rewrite fib_add.\n  rewrite add_1_r.\n  rewrite H.\n  remember (fib n) as a.\n  remember (fib (S n)) as b.\n  rewrite add_comm with (a * a) (b * b).\n  rewrite sub_add_distr.\n  rewrite mul_add_distr_r.\n  rewrite add_comm.\n  rewrite add_comm with (b * b) (a * b).\n  rewrite add_assoc.\n  rewrite add_sub.\n  rewrite mul_comm.\n  rewrite mul_succ_l.\n  rewrite mul_1_l.\n  rewrite <- mul_add_distr_l.\n  rewrite <- mul_sub_distr_l.\n  reflexivity.\nQed.\n\nTheorem fib2_correct : forall n t, n <= t -> fib2 t n = (fib n , fib (S n)).\nProof.\n  intros n t.\n  generalize n ; clear n.\n  induction t.\n  + intros.\n    apply le_n_0_eq in H.\n    rewrite <- H.\n    simpl.\n    reflexivity.\n  + intros.\n    unfold fib2.\n    fold fib2.\n    destruct n.\n    * reflexivity.\n    * case_eq (fib2 t0 (S n \/ 2)).\n      intros.\n      remember (n0 * (2 * n1 - n0)) as c.\n      remember (n0 * n0 + n1 * n1) as d.\n      rewrite IHt in H0.\n      remember (S n \/ 2) as m.\n      remember (S m) as m1.\n      injection H0.\n      intros.\n      rewrite Heqm1 in H1 ; clear H0 m1 Heqm1.\n      rewrite <- H1 in Heqc.\n      rewrite <- H2 in Heqc.\n      rewrite <- fib_2n in Heqc.\n      rewrite <- H1 in Heqd.\n      rewrite <- H2 in Heqd.\n      rewrite <- fib_s2n in Heqd.\n      rewrite Heqc.\n      rewrite Heqd.\n      case_eq (even (S n)).\n      - intros.\n        apply even_spec in H0.\n        apply even_equiv in H0.\n        apply even_double in H0.\n        rewrite double_twice in H0.\n        rewrite div2_div in H0.\n        rewrite <- Heqm in H0.\n        rewrite <- H0.\n        rewrite add_1_r.\n        reflexivity.\n      - intros.\n        rewrite <- negb_odd in H0.\n        rewrite Bool.negb_false_iff in H0.\n        apply odd_spec in H0.\n        apply odd_equiv in H0.\n        apply odd_double in H0.\n        rewrite double_twice in H0.\n        rewrite div2_div in H0.\n        rewrite <- Heqm in H0.\n        apply eq_add_S in H0.\n        rewrite <- H0.\n        rewrite add_1_r.\n        rewrite add_comm.\n        reflexivity.\n      - apply lt_n_Sm_le.\n        apply lt_le_trans with (S n).\n        apply div_lt.\n        apply lt_0_succ.\n        apply lt_1_2.\n        apply H.\nQed.\n\nTheorem fib_fast_correct : forall n, fib_fast n = fib n.\nProof.\n  intros.\n  unfold fib_fast.\n  rewrite fib2_correct.\n  simpl.\n  reflexivity.\n  apply le_refl.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33036,"user_id":null,"body":"Require Import Preloaded Arith Lia.\nImport Nat.\n\nLemma fib_SSk : forall k, fib (S (S k)) = fib (S k) + fib k.\nProof.\n  auto.\nQed.\n\nLemma fib_le : forall k, fib k <= fib (S k).\nProof.\n  induction k. simpl. auto.\n  rewrite fib_SSk. lia.\nQed.\n\nLemma fib_2k : forall k, \n  fib (2 * k) = fib k * (2 * fib (k + 1) - fib k)\n  \/\\\n  fib (S (2 * k)) = (fib k) ^ 2 + (fib (k + 1)) ^ 2.\nProof.\n  induction k. auto.\n  destruct IHk as [IH1 IH2].\n  replace (2 * S k) with (S (S (2 * k))) by lia.\n  replace (S k + 1) with (S (S k)) by lia.\n  rewrite !fib_SSk, IH1, IH2.\n  remember (fib k) as fk.\n  remember (fib (S k)) as fS.\n  replace (fib (k + 1)) with fS by (subst; f_equal; lia).\n  assert (fk <= fS). { subst. apply fib_le. }\n  simpl.\n  (* nia works here but takes too long *)\n  rewrite !mul_1_r.\n  rewrite <- !plus_n_O.\n  rewrite !mul_sub_distr_l.\n  rewrite !mul_add_distr_r.\n  rewrite !mul_add_distr_l.\n  split; nia.\nQed.\n\nLemma fib2_correct : forall n t, n <= t ->\n  fib2 t n = (fib n, fib (S n)).\nProof.\n  induction n using lt_wf_ind.\n  intros t Hle.\n  destruct (Even_or_Odd n) as [Heven | Hodd].\n  - destruct n.\n    { destruct t; auto. }\n    remember (S n) as n'.\n    assert (even n' = true) by (apply even_spec; auto).\n    destruct Heven as [k Hk].\n    repeat rewrite Hk at 2.\n    destruct (fib_2k k) as [H1 H2].\n    rewrite H1, H2.\n    destruct t. subst; inversion Hle.\n    simpl.\n    subst.\n    rewrite H0.\n    simpl.\n    replace (fst (divmod n 1 0 0)) with (S n \/ 2) by auto.\n    replace (S n \/ 2) with k\n      by (rewrite Hk, mul_comm, div_mul; auto).\n    rewrite (H k); try lia.\n    replace (fib (k + 1)) with (fib (S k)) by (f_equal; lia).\n    rewrite !mul_1_r.\n    auto.\n  - assert (even n = false).\n    {\n      rewrite <- negb_odd.\n      replace (odd n) with true. auto.\n      symmetry. apply odd_spec. auto.\n    }\n    destruct Hodd as [k Hk].\n    repeat rewrite Hk at 2.\n    replace (2 * k + 1) with (S (2 * k)) by lia.\n    rewrite fib_SSk.\n    destruct (fib_2k k) as [H1 H2].\n    rewrite H1, H2.\n    destruct t. inversion Hle; lia.\n    simpl.\n    rewrite H0.\n    destruct n. lia.\n    simpl.\n    replace (fst (divmod n 1 0 0)) with (S n \/ 2) by auto.\n    replace (S n \/ 2) with k\n      by (rewrite Hk, mul_comm, div_add_l; simpl; lia).\n    rewrite (H k); try lia.\n    replace (fib (k + 1)) with (fib (S k)) by (f_equal; lia).\n    rewrite !mul_1_r.\n    f_equal.\n    lia.\nQed.\n\nTheorem fib_fast_correct : forall n, fib_fast n = fib n.\nProof.\n  unfold fib_fast.\n  intros.\n  rewrite fib2_correct; auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33037,"user_id":null,"body":"Require Import Preloaded Arith Lia.\nImport Nat.\n\nLemma fib_mono : forall n, fib n <= fib (S n).\nProof. do 2 (destruct n;simpl;[lia|]);lia. Qed.\n\nLemma fib2_lemma : forall n, (fib (1 + 2*n) = \n (fib n) * (fib n) + (fib (1+ n)) * (fib (1+n)) ) \/\\\n(fib (2*n) = (fib n) * ((2*fib (1+n)) - (fib n))).\nProof. induction n;[auto|].\nreplace (1 + 2 * S n) with (3+2*n);[|lia].\nreplace (2*S n) with (2+2*n);[|lia].\nchange (fib (3+2*n)) with (fib (2+2*n) + fib (1+2*n)).\nchange (fib (2+2*n)) with (fib (1+2*n) + fib (2*n)).\nchange (fib (1+S n)) with ((fib (S n)) + fib n).\nassert (Hf := fib_mono n);assert (Hnf := fib_mono (S n)).\nchange (fib (S (S n))) with ((fib (S n)) + fib n) in Hnf.\nchange (S n) with (1+n) in *.\nreplace (2 * (fib (1 + n) + fib n) - fib (1 + n)) with\n        (fib (1 + n) + 2 * fib n);[|lia].\nnia.\nQed.\n\nLemma n_even_desc : forall n, (even n = true -> exists m, n = 2*m) \/\\\n (even n = false -> exists m, n = 1 + (2*m)).\nProof. induction n using lt_wf_ind. destruct n as [|[|n']].\n* split;intros.\n + exists 0. auto.\n + inversion H0.\n* split;intros.\n + inversion H0.\n + exists 0. auto.\n* destruct (H n');[lia|]. split;intros.\n + destruct (H0 H2). exists (1+x). lia.\n + destruct (H1 H2). exists (1+x). lia.\nQed.\n\nTheorem fib2_correct : forall n t, n <= t -> fib2 t n = (fib n, fib (S n)).\nProof. induction n using lt_wf_ind;intros.\n destruct n as [|[|n']];destruct t0;auto.\n* inversion H0.\n* inversion H0;subst;[auto|]. inversion H2;subst;auto.\n* inversion H0.\n* unfold fib2;fold fib2.\n  destruct (n_even_desc n').\n  unfold even;fold even.\n  destruct (even n').\n + destruct H1;[auto|];subst.\n   replace (S (S (2 * x))) with (2*(1+x));[|lia].\n   replace ((2*(1+x)) \/ 2) with (1+x).\n  - rewrite H;[|lia ..].\n    change (S (1 + x)) with (1 + (1 + x)).\n    change (S (2 * (1 + x))) with (1 + (2 * (1 + x))).\n    assert (Hf := fib2_lemma (1+x)). f_equal; lia.\n  - rewrite mul_comm. rewrite div_mul;auto.\n + destruct H2;[auto|];subst.\n   assert (Hf:=fib2_lemma (1+x)).\n   replace (S (S (1 + 2 * x))) with (1+2*(1+x));[|lia].\n   change (fib (S (1 + 2 * (1 + x)))) with \n          (fib (1 + 2 * (1 + x)) + fib (2 * (1 + x))).\n   replace ((1+2*(1+x)) \/ 2) with (1+x).\n  - rewrite H;[|lia ..].\n    change (S (1 + x)) with (1 + (1 + x)).\n    f_equal;lia.\n  - rewrite mul_comm. rewrite div_add;auto.\nQed.\n\nCorollary fib_fast_correct : forall n, fib_fast n = fib n.\nProof. intros. unfold fib_fast. rewrite fib2_correct;auto. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33038,"user_id":17,"body":"(* A solution without TLC, for the record *)\n\nRequire Import Preloaded Arith Lia.\nImport Nat.\nFrom Coq Require Import Bool.Bool.\n\nFact fib_equation : forall k, fib (S (S k)) = fib (S k) + fib k.\nProof. reflexivity. Qed.\n\nFact fib_fact : forall k, fib (S k) >= fib k.\nProof.\n  induction k; try (simpl; lia); rewrite fib_equation; lia.\nQed.\n\nLemma fib_2k_S_2k_equations : forall k,\n  fib (2 * k) = fib k * (2 * fib (S k) - fib k) \/\\\n  fib (S (2 * k)) = fib k * fib k + fib (S k) * fib (S k).\nProof.\n  induction k; auto.\n  inversion IHk; subst; clear IHk.\n  replace (2 * S k) with (S (S (2 * k))) by lia.\n  repeat rewrite fib_equation.\n  specialize (fib_fact k); intro; nia.\nQed.\n\nFact fib2_equation : forall gas n,\n  fib2 (S gas) (S n) = let (a, b) := fib2 gas (S n \/ 2) in\n  let c := a * (2 * b - a) in\n  let d := a * a + b * b in\n  if even (S n) then (c, d) else (d, c + d).\nProof. reflexivity. Qed.\n\nLemma nat_ind2 : forall P : nat -> Prop,\n  P 0 ->\n  P 1 ->\n  (forall n, P n -> P (S (S n))) ->\n  forall n, P n.\nProof.\n  intros P HP0 HP1 IHn.\n  assert (forall n, P n \/\\ P (S n))\n    by (induction n; try destruct IHn0; split; auto).\n  intros; apply H.\nQed.\n\nLemma even_div2 : forall n, even n = true -> n = 2 * div2 n.\nProof.\n  induction n using nat_ind2; intros H; try discriminate; auto.\n  simpl in *.\n  apply IHn in H.\n  rewrite <- plus_n_Sm, <- H; auto.\nQed.\n\nLemma not_even_div2 : forall n,\n  even n = false -> n = S (2 * div2 n).\nProof.\n  induction n using nat_ind2; intros H; try discriminate; auto.\n  simpl in *.\n  apply IHn in H.\n  rewrite <- plus_n_Sm, <- H; auto.\nQed.\n\nTheorem fib2_correct : forall gas n,\n  2 ^ gas > n -> fib2 gas n = (fib n, fib (S n)).\nProof.\n  induction gas; intros n Hgt; simpl in Hgt.\n  - destruct n; try lia; auto.\n  - destruct n; auto.\n    rewrite fib2_equation, <- div2_div.\n    destruct (even (S n)) eqn:Eeven.\n    + specialize (even_div2 _ Eeven); intro.\n      assert (2 ^ gas > div2 (S n)) by lia.\n      specialize (IHgas _ H0).\n      rewrite IHgas.\n      rewrite H.\n      remember (div2 (S n)) as m.\n      clear Heqm Eeven IHgas Hgt H0 H.\n      replace (let c := fib (div2 (2 * m)) * (2 * fib (S (div2\n        (2 * m))) - fib (div2 (2 * m))) in\n        let d := fib (div2 (2 * m)) * fib (div2 (2 * m)) + fib\n        (S (div2 (2 * m))) * fib (S (div2 (2 * m))) in (c, d))\n        with (fib (div2 (2 * m)) * (2 * fib (S (div2 (2 * m)))\n        - fib (div2 (2 * m))), fib (div2 (2 * m)) * fib (div2\n        (2 * m)) + fib (S (div2 (2 * m))) * fib (S (div2 (2 *\n        m)))) by reflexivity.\n      rewrite div2_double.\n      symmetry; apply f_equal2; apply fib_2k_S_2k_equations.\n    + specialize (not_even_div2 _ Eeven); intro.\n      assert (2 ^ gas > div2 (S n)) by lia.\n      specialize (IHgas _ H0).\n      rewrite IHgas.\n      replace (let c := fib (div2 (S n)) * (2 * fib (S (div2\n        (S n))) - fib (div2 (S n))) in\n        let d := fib (div2 (S n)) * fib (div2 (S n)) +\n        fib (S (div2 (S n))) * fib (S (div2 (S n))) in\n        (d, c + d)) with (fib (div2 (S n)) * fib (div2\n        (S n)) + fib (S (div2 (S n))) * fib (S (div2 (S n))),\n        fib (div2 (S n)) * (2 * fib (S (div2 (S n))) -\n        fib (div2 (S n))) + (fib (div2 (S n)) * fib (div2\n        (S n)) + fib (S (div2 (S n))) * fib (S (div2 (S\n        n))))) by reflexivity.\n      symmetry.\n      replace (fib (S n), fib (S (S n)))\n        with (fib (S (2 * div2 (S n))),\n        fib (S (S (2 * div2 (S n))))) by congruence.\n      remember (div2 (S n)) as m.\n      clear IHgas Hgt Eeven Heqm H H0.\n      rewrite fib_equation.\n      specialize (fib_2k_S_2k_equations m); intro.\n      apply f_equal2; lia.\nQed.\n\nFact pow2_n_gt_n : forall n, 2 ^ n > n.\nProof. induction n; simpl; lia. Qed.\n\nCorollary fib_fast_correct : forall n, fib_fast n = fib n.\nProof.\n  intros; unfold fib_fast; rewrite fib2_correct;\n    auto using pow2_n_gt_n.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33039,"user_id":null,"body":"Require Import Preloaded Arith Lia.\nImport Nat.\n\n\nLemma infinite_descent : forall (P : nat -> Prop),\n  (forall (n : nat), (forall (m : nat), m < n -> P m) -> P n) ->\n  (forall (n : nat), P n).\nProof.\n  intros P Hdes n; refine (Hdes _ _); induction n.\n    destruct m; intros F; case (nlt_0_r _ F).\n    intros m Hlt; destruct (le_lt_or_eq _ _ (lt_n_Sm_le _ _ Hlt)) as [Hlt' | Heq].\n      exact (IHn _ Hlt').\n      rewrite Heq; exact (Hdes _ IHn).\nQed.\n\nLemma even_or_odd : forall (n : nat), exists (k : nat), 2 * k = n \\\/ S (2 * k) = n.\nProof.\n  refine (infinite_descent _ _); intros n Hdes; destruct n.\n    refine (ex_intro _ 0 (or_introl _)); simpl; reflexivity.\n  destruct n.\n    refine (ex_intro _ 0 (or_intror _)); simpl; reflexivity.\n  destruct (Hdes _ (lt_trans _ _ _ (lt_succ_diag_r _) (lt_succ_diag_r _))) as [k Hk].\n  refine (ex_intro _ (S k) _); destruct Hk as [Heven | Hodd].\n    refine (or_introl _); simpl; simpl in Heven; rewrite add_succ_r, Heven; reflexivity.\n    refine (or_intror _); simpl; simpl in Hodd; rewrite add_succ_r, Hodd; reflexivity.\nQed.\n\nLemma double_succ : forall (n : nat), 2 * S n = S (S (2 * n)).\nProof.\n  intros; simpl; rewrite add_succ_r; reflexivity.\nQed.\n\nLemma even_double : forall (n : nat), even (2 * n) = true.\nProof.\n  induction n.\n    simpl; reflexivity.\n    rewrite double_succ, even_succ_succ; exact IHn.\nQed.\n\nLemma odd_succ_double : forall (n : nat), even (S (2 * n)) = false.\nProof.\n  induction n.\n    simpl; reflexivity.\n    rewrite double_succ, even_succ_succ; exact IHn.\nQed.\n\nLemma fib_succ : forall (n : nat), fib n + fib (S n) = fib (S (S n)).\nProof.\n  intros; simpl; rewrite add_comm; reflexivity.\nQed.\n\nLemma fib_succ_n_plus_m : forall (n m : nat), fib n * fib m + fib (S n) * fib (S m) = fib (S (n + m)).\nProof.\n  induction n.\n    intros; simpl; rewrite add_0_r; reflexivity.\n    intros; rewrite <- fib_succ, mul_add_distr_r, add_assoc.\n    assert (forall (a b c : nat), a + b + c = b + (a + c)) as H.\n      clear; intros; rewrite (add_comm a), <- add_assoc; reflexivity.\n    rewrite H, <- mul_add_distr_l, fib_succ, IHn, add_succ_comm; reflexivity.\nQed.\n\nLemma fib_double : forall (n : nat), fib n * (2 * fib (S n) - fib n) = fib (2 * n).\nProof.\n  induction n.\n    simpl; reflexivity.\n    assert (forall (a : nat), 2 * a = a + a) as Hdouble.\n      clear; intros a; simpl; rewrite add_0_r; reflexivity.\n    rewrite Hdouble.\n    assert (forall (a b : nat), a + fib (S (S b)) - fib (S b) = a + fib b) as H.\n      intros a b; rewrite <- fib_succ, add_assoc, add_sub; reflexivity.\n    rewrite H; clear H.\n      rewrite mul_add_distr_l, add_comm, mul_comm, fib_succ_n_plus_m, <- add_succ_l, Hdouble; reflexivity.\nQed.\n\nLemma fib_succ_double : forall (n : nat), fib n * fib n + fib (S n) * fib (S n) = fib (S (2 * n)).\nProof.\n  intros n; rewrite fib_succ_n_plus_m; simpl; rewrite add_0_r; reflexivity.\nQed.\n\nLemma div2_induction : forall (P : nat -> Prop),\n  P 0 ->\n  (forall (n : nat), P (S n) -> P (2 * S n)) ->\n  (forall (n : nat), P n -> P (S (2 * n))) ->\n  (forall (n : nat), P n).\nProof.\n  intros P P0 Pdouble Psucc_double; refine (infinite_descent _ _); intros n Hdes.\n  destruct (even_or_odd n) as [k Hk]; destruct Hk as [Heven | Hodd].\n    rewrite <- Heven; destruct k.\n      simpl; exact P0.\n    refine (Pdouble _ (Hdes _ _)).\n    rewrite <- Heven; simpl; rewrite <- add_succ_comm; exact (le_lt_n_Sm _ _ (le_add_r _ _)).\n\n    rewrite <- Hodd; refine (Psucc_double _ (Hdes _ _)).\n    rewrite <- Hodd; simpl; exact (le_lt_n_Sm _ _ (le_add_r _ _)).\nQed.\n\nLemma unfold_fib2_once : forall (t n : nat), fib2 (S t) (S n) =\n  let (a, b) := fib2 t (S n \/ 2) in\n  let c := a * (2 * b - a) in\n  let d := a * a + b * b in\n  if even (S n) then (c, d) else (d, c + d).\nProof.\n  intros; simpl; reflexivity.\nQed.\n\nLemma fib2_even : forall (t n a b : nat),\n  n <= S t ->\n  0 < n ->\n  even n = true ->\n  fib2 t (n \/ 2) = (a, b) ->\n  fib2 (S t) n = (a * (2 * b - a), a * a + b * b).\nProof.\n  intros t n a b Hle Hlt Heven IH; destruct n.\n    case (nlt_0_r _ Hlt).\n  rewrite unfold_fib2_once, IH, Heven; simpl; reflexivity.\nQed.\n\nLemma fib2_odd : forall (t n a b : nat),\n  n <= S t ->\n  even n = false ->\n  fib2 t (n \/ 2) = (a, b) ->\n  fib2 (S t) n = (a * a + b * b, a * (2 * b - a) + (a * a + b * b)).\nProof.\n  intros t n a b Hle Hodd IH; destruct n.\n    simpl in Hodd; case (Bool.diff_true_false Hodd).\n  rewrite unfold_fib2_once, IH, Hodd; simpl; reflexivity.\nQed.\n\nLemma fib2_correct : forall (n t : nat), n <= t -> fib2 t n = (fib n, fib (S n)).\nProof.\n  refine (div2_induction _ _ _ _).\n    intros; destruct t0; simpl; reflexivity.\n\n    intros n IH t Hle; destruct t as [| t].\n      case (nle_succ_0 _ Hle).\n    pose (Heven := even_double (S n)).\n    assert (0 < 2 * S n) as Hlt.\n      simpl; exact (lt_0_succ _).\n    assert (fib2 t ((2 * S n) \/ 2) = (fib (S n), fib (S (S n)))) as IH'.\n      rewrite <- div2_div, div2_double; refine (IH _ (le_S_n _ _ (le_trans _ _ _ _ Hle))).\n      simpl; rewrite add_succ_r, <- add_succ_l, <- add_succ_l; exact (le_add_r _ _).\n    rewrite (fib2_even _ _ _ _ Hle Hlt Heven IH'), fib_double, fib_succ_double; reflexivity.\n\n    intros n IH t Hle; destruct t as [| t].\n      case (nle_succ_0 _ Hle).\n    pose (Hodd := odd_succ_double n).\n    assert (fib2 t ((S (2 * n)) \/ 2) = (fib n, fib (S n))) as IH'.\n      rewrite <- div2_div, div2_succ_double; refine (IH _ (le_S_n _ _ (le_trans _ _ _ _ Hle))).\n      simpl; rewrite <- add_succ_l; exact (le_add_r _ _).\n    rewrite (fib2_odd _ _ _ _ Hle Hodd IH'), fib_double, fib_succ_double, fib_succ; reflexivity.\nQed.\n\nTheorem fib_fast_correct : forall n, fib_fast n = fib n.\nProof.\n  intros; unfold fib_fast; rewrite fib2_correct; simpl; reflexivity.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5d2428590fb98b0018b7dc47":[{"id":33040,"user_id":106,"body":"Let lemma f b:f(f(f b:bool))=f b. case(f true)eqn:?,(f false)eqn:?,b;congruence. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33041,"user_id":null,"body":"Lemma lemma f(b:bool):f(f(f b))=f b.\ncase b,(f true)eqn:a,(f false)eqn:b;congruence.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33042,"user_id":null,"body":"Fact lemma f (b:bool):f(f(f b))=f b.\ncase b,(f false)eqn:E0,(f true)eqn:E1;congruence.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33043,"user_id":null,"body":"Fact lemma f(b:bool):f(f(f b))=f b.\ncase b,(f true)eqn:?,(f false)eqn:?;congruence.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33044,"user_id":null,"body":"Let lemma f b:f(f(f b:bool))=f b. case(f b)eqn:?,(f(f b))eqn:?,b;congruence. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33045,"user_id":null,"body":"Let lemma f(b:bool):f(f(f b))=f b. case_eq(f false);case_eq(f true);case b;congruence. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33046,"user_id":196,"body":"Let lemma f(b:bool):f(f(f b))=f b.\ncase_eq(f true);case_eq(f false);case b;congruence.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33047,"user_id":null,"body":"Lemma lemma f (b:bool):f(f(f b))=f b.\ncase b,(f true)eqn:T,(f false)eqn:F;congruence.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33048,"user_id":null,"body":"Let lemma f(b:bool):f(f(f b))=f b. destruct b,(f true)eqn:?,(f false)eqn:?;congruence. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33049,"user_id":17,"body":"Let lemma f b:f(f(f b):bool)=f b. case b;case_eq(f true);case_eq(f false);congruence. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5d2b89d4b90c0a001f4a6456":[{"id":33050,"user_id":null,"body":"Require Import Preloaded Reals Lra Lia.\nOpen Scope R_scope.\n\n(*\nFixpoint fib (n : nat) : nat :=\n  match n with\n  | 0 => 0\n  | 1 => 1\n  | S (S n as n') => fib n' + fib n\n  end.\n\nArguments fib : simpl nomatch.\n\nDefinition phi := ((1 + sqrt 5) \/ 2)%R.\n\nDefinition psi := ((1 - sqrt 5) \/ 2)%R.\n*)\n\nFact Rsqr_mult : forall r, Rsqr r = r * r.\nProof. intros. rewrite -> Rsqr_pow2. simpl. lra. Qed.\n\n(* why is this so complex? *)\nFact phi_root : (Rsqr phi) = 1 + phi.\nProof.\n  unfold phi.\n  rewrite -> Rsqr_div. 2: intro; lra.\n  rewrite -> Rsqr_plus.\n  rewrite -> Rsqr_sqrt. 2: lra.\n  rewrite -> ! Rsqr_pow2. simpl.\n  lra.\nQed.\n\nFact psi_root : (Rsqr psi) = 1 + psi.\nProof.\n  unfold psi.\n  rewrite -> Rsqr_div. 2: intro; lra.\n  rewrite -> Rsqr_minus.\n  rewrite -> Rsqr_sqrt. 2: lra.\n  rewrite -> ! Rsqr_pow2. simpl.\n  lra.\nQed.\n\nFixpoint iter (n : nat) (vec : R * R) :=\n  match n with\n  | O => vec\n  | S n' => let (f0, f1) := vec in\n            iter n' (f1, (f0 + f1)%R)\n  end.\n\nLemma fib_iter : forall n a,\n  (INR (fib (a + n)%nat), INR (fib (a + n + 1)%nat)) =\n  iter n (INR (fib a), INR (fib (a + 1)%nat)).\nProof.\n  intros n. induction n; intros.\n  - simpl. f_equal; f_equal; f_equal; lia.\n  - simpl iter.\n    replace (a + S n)%nat with ((a + 1) + n)%nat by lia.\n    rewrite -> IHn.\n    f_equal; f_equal.\n    rewrite <- plus_INR. f_equal.\n    replace (a + 1 + 1)%nat with (S (S a)) by lia.\n    simpl. replace (a + 1)%nat with (S a) by lia.\n    lia.\nQed.\n\n(* normal properties of vectors and matrices *)\n\nLemma iter_linear : forall n a b c d,\n  iter n ((a + b), (c + d)) =\n  let (a', c') := iter n (a, c) in\n  let (b', d') := iter n (b, d) in\n  (a' + b', c' + d').\nProof.\n  intros n. induction n; intros.\n  - reflexivity.\n  - simpl.\n    replace (a + b + (c + d)) with ((a + c) + (b + d)) by lra.\n    rewrite -> IHn. reflexivity.\nQed.\n\nDefinition coefmult (r : R) (vec : R * R) :=\n  let (a, b) := vec in (r * a, r * b).\n\nLemma iter_coef : forall n a b c,\n  iter n (c * a, c * b) =\n  coefmult c (iter n (a, b)).\nProof.\n  intros n. induction n; intros.\n  - reflexivity.\n  - simpl.\n    replace (c * a + c * b) with (c * (a + b)) by lra.\n    rewrite -> IHn. reflexivity.\nQed.\n\nDefinition charac_vec1 := (1%R, phi).\n\nDefinition charac_vec2 := (1%R, psi).\n\nFact iter1_charac_vec1 :\n  iter 1 charac_vec1 = coefmult phi charac_vec1.\nProof. simpl. f_equal; try lra. rewrite <- phi_root, -> Rsqr_pow2. lra. Qed.\n\nLemma iter_charac_vec1 : forall n,\n  iter n charac_vec1 = coefmult (pow phi n) charac_vec1.\nProof.\n  intros n. induction n; intros.\n  - simpl. unfold charac_vec1. f_equal; lra.\n  - simpl.\n    rewrite <- phi_root, -> Rsqr_mult, <- Rmult_1_r at 1.\n    rewrite -> iter_coef.\n    match goal with |- _ = ?b => replace b with\n      (coefmult phi (phi ^ n * 1, phi ^ n * phi)) end.\n    2:{ simpl. f_equal; lra. }\n    f_equal.\n    unfold charac_vec1 in IHn. rewrite -> IHn.\n    simpl. reflexivity.\nQed.\n\nFact iter1_charac_vec2 :\n  iter 1 charac_vec2 = coefmult psi charac_vec2.\nProof. simpl. f_equal; try lra. rewrite <- psi_root, -> Rsqr_pow2. lra. Qed.\n\nLemma iter_charac_vec2 : forall n,\n  iter n charac_vec2 = coefmult (pow psi n) charac_vec2.\nProof.\n  intros n. induction n; intros.\n  - simpl. unfold charac_vec2. f_equal; lra.\n  - simpl.\n    rewrite <- psi_root, -> Rsqr_mult, <- Rmult_1_r at 1.\n    rewrite -> iter_coef.\n    match goal with |- _ = ?b => replace b with\n      (coefmult psi (psi ^ n * 1, psi ^ n * psi)) end.\n    2:{ simpl. f_equal; lra. }\n    f_equal.\n    unfold charac_vec2 in IHn. rewrite -> IHn.\n    simpl. reflexivity.\nQed.\n\nFact sqrt_5_is_not_0 : sqrt 5 <> 0.\nProof.\n  apply Rlt_dichotomy_converse. right.\n  assert (0 < 5) by lra. apply sqrt_lt_R0 in H. lra.\nQed.\n\nLemma binet' : forall n,\n  (INR (fib n), INR (fib (n + 1)%nat)) =\n  (* coefmult ((phi ^ n - psi ^ n) \/ sqrt 5) (0, 1). *)\n  (((phi ^ n - psi ^ n) \/ sqrt 5), ((phi ^ (S n) - psi ^ (S n)) \/ sqrt 5)).\nProof.\n  intros.\n  (* use iter *)\n  pose proof (fib_iter n 0) as Hpre. simpl in Hpre. rewrite -> Hpre. clear Hpre.\n  (* split (0, 1) into two characteristic vectors *)\n  replace (0, 1) with\n    (((1 \/ sqrt 5) * 1) + ((-1 \/ sqrt 5) * 1),\n    ((1 \/ sqrt 5) * phi) + ((-1 \/ sqrt 5) * psi)).\n  2:{\n    f_equal; try lra. unfold phi, psi. field.\n    apply sqrt_5_is_not_0.\n  }\n  rewrite -> iter_linear, -> ! iter_coef.\n  fold charac_vec1 charac_vec2.\n  rewrite -> iter_charac_vec1, -> iter_charac_vec2.\n  (* simple arithmetic *)\n  unfold coefmult. simpl.\n  f_equal.\n  - unfold phi, psi. field. apply sqrt_5_is_not_0.\n  - field. apply sqrt_5_is_not_0.\nQed.\n\nTheorem binet : forall n, INR (fib n) = (phi ^ n - psi ^ n) \/ sqrt 5.\nProof.\n  intros. pose proof (binet' n).\n  now inversion H.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33051,"user_id":null,"body":"Require Import Preloaded Reals Lra.\nOpen Scope R_scope.\n\nLemma fib_ind : forall (P: nat -> Prop), P 0%nat -> P 1%nat -> (forall n, P n -> P (S n) -> P (S (S n))) -> (forall n, P n).\nProof.\n  intros P P0 P1 PSS n; cut (P n \/\\ P (S n)); [easy|].\n  induction n; [|split; [|apply PSS]]; easy.\nQed.\n\nLemma phi_fib : forall n, phi ^ S (S n) = phi ^ S n + phi ^ n.\nProof.\n  intros; simpl.\n  replace (phi * (phi * phi ^ n)) with (phi * phi * phi ^ n); [|lra].\n  replace (phi * phi) with (phi + 1); [lra|].\n  replace (phi * phi) with (Rsqr phi); [|easy].\n  replace 1 with (2 \/ 2); [|lra].\n  unfold phi; rewrite <- Rdiv_plus_distr, Rsqr_div; [|easy].\n  rewrite Rsqr_plus, Rsqr_sqrt; [unfold Rsqr|]; lra.\nQed.\n\nLemma psi_fib : forall n, psi ^ S (S n) = psi ^ S n + psi ^ n.\nProof.\n  intros; simpl.\n  replace (psi * (psi * psi ^ n)) with (psi * psi * psi ^ n); [|lra].\n  replace (psi * psi) with (psi + 1); [lra|].\n  replace (psi * psi) with (Rsqr psi); [|easy].\n  replace 1 with (2 \/ 2); [|lra].\n  unfold psi; rewrite <- Rdiv_plus_distr, Rsqr_div; [|easy].\n  rewrite Rsqr_minus, Rsqr_sqrt; [unfold Rsqr|]; lra.\nQed.\n\nTheorem binet : forall n, INR (fib n) = (phi ^ n - psi ^ n) \/ sqrt 5.\nProof.\n  induction n using fib_ind.\n  - simpl; lra.\n  - simpl; repeat rewrite Rmult_1_r.\n    unfold phi, psi; rewrite <- Rdiv_minus_distr.\n    replace (1 + sqrt 5 - (1 - sqrt 5)) with (sqrt 5 * 2); [|lra].\n    replace (sqrt 5 * 2 \/ 2) with (sqrt 5); [|lra].\n    rewrite <- sqrt_div_alt; [replace (5 \/ 5) with 1; [now rewrite sqrt_1|]|]; lra.\n  - replace (fib (S (S n)))%nat with (fib (S n) + fib n)%nat; [|easy].\n    rewrite plus_INR, IHn, IHn0, phi_fib, psi_fib; lra.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33052,"user_id":null,"body":"Require Import Preloaded Reals Lra Arith Lia.\nOpen Scope R_scope.\n\nLemma phi_not_zero : phi <> 0.\nProof.\n  assert (hp : phi >= 1\/2).\n  + unfold phi. pose proof (hps := sqrt_pos 5). lra.\n  + lra.\nQed.\n\nLemma psi_not_zero : psi <> 0.\nProof.\n  assert (hp : psi <= -1\/2).\n  unfold psi. assert (hps : 2 <= sqrt 5).\n  + replace 2 with (sqrt 4). apply sqrt_le_1_alt. lra. \n    apply sqrt_lem_1 ; lra.\n  + lra.\n  + lra.\nQed.\n\nLemma re_phi : forall n , phi ^ (S (S n)) = phi ^ (S n) + phi ^ n.\nProof.\n  intro n.\n  replace (phi ^ S (S n)) with (phi ^ n * phi ^ 2).\n  replace (phi ^ (S n) + phi ^ n) with (phi ^ n * (phi + 1 )).\n  assert (hp : phi ^ n <> 0).\n  + apply pow_nonzero. exact phi_not_zero.\n  + apply Rmult_eq_compat_l. unfold phi. field_simplify_eq. \n    rewrite <- Rsqr_pow2 , Rsqr_sqrt ; lra.\n  + replace (S n) with (Nat.add n 1) by lia. rewrite pow_add,pow_1. field.\n  + replace (S (S n)) with (Nat.add n 2) by lia. rewrite pow_add. field.\nQed.\n\nLemma re_psi : forall n , psi ^ (S (S n)) = psi ^ (S n) + psi ^ n.\nProof.\n  intro n.\n  replace (psi ^ S (S n)) with (psi ^ n * psi ^ 2).\n  replace (psi ^ (S n) + psi ^ n) with (psi ^ n * (psi + 1 )).\n  assert (hp : psi ^ n <> 0).\n  + apply pow_nonzero. exact psi_not_zero.\n  + apply Rmult_eq_compat_l. unfold psi. field_simplify_eq. \n    rewrite <- Rsqr_pow2 , Rsqr_sqrt ; lra.\n  + replace (S n) with (Nat.add n 1) by lia. rewrite pow_add,pow_1. field.\n  + replace (S (S n)) with (Nat.add n 2) by lia. rewrite pow_add. field.\nQed.\n\nLemma sqrt5_ne0 : sqrt 5 <> 0.\nProof.\n  assert (hp : 0 < sqrt 5). apply sqrt_lt_R0. lra. lra.\nQed.\n\nTheorem binet : forall n, INR (fib n) = (phi ^ n - psi ^ n) \/ sqrt 5.\nProof. \n  induction n as [n hrec] using lt_wf_ind.\n  destruct n.\n  + simpl. field. exact sqrt5_ne0.\n  + destruct n.\n    - simpl. unfold phi, psi. field. exact sqrt5_ne0.\n    - replace (INR (fib (S (S n)))) with (INR (fib (S n)) + INR (fib n)).\n      replace (phi ^ (S (S n))) with (phi ^ (S n) + phi ^ n).\n      replace (psi ^ (S (S n))) with (psi ^ (S n) + psi ^ n).\n      rewrite (hrec (S n)), (hrec n). field. exact sqrt5_ne0.\n      lia. lia. rewrite re_psi. reflexivity. rewrite re_phi.\n      reflexivity. rewrite <- plus_INR. auto.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33053,"user_id":null,"body":"Require Import Preloaded Reals Lra Lia.\nOpen Scope R_scope.\nDefinition pfib (n : nat) : R := (phi ^ n - psi ^ n) \/ sqrt 5.\n\nLemma sqrt5n0 : sqrt 5 <> 0.\nProof.\n  assert (0 < 5) by lra.\n  pose proof (sqrt_lt_R0 5 H).\n  lra.\nQed.\n\nTheorem pfib_s (n : nat) : pfib n + pfib (S n) = pfib (S (S n)).\nProof.\n  unfold pfib, phi, psi.\n  field_simplify_eq.\n  simpl in *.\n  field_simplify_eq.\n  replace (sqrt 5 ^ 2) with 5 in *.\n  lra.\n  assert (0 <= 5) by lra.\n  pose proof (Rsqr_sqrt 5 H).\n  unfold Rsqr in H0.\n  lra.\n  exact sqrt5n0.\nQed.\n\nTheorem binet : forall n, INR (fib n) = (phi ^ n - psi ^ n) \/ sqrt 5.\nProof.\n  intros.\n  enough (INR (fib n) = pfib n) by (unfold pfib in *; congruence).\n  pose proof sqrt5n0.\n  induction n using lt_wf_ind.\n  destruct n as [|[]].\n  unfold pfib.\n  simpl. lra.\n  unfold pfib, phi, psi.\n  simpl. field. easy.\n  rewrite <- pfib_s.\n  simpl.\n  rewrite plus_INR.\n  rewrite (H0 n ltac:(lia)).\n  rewrite (H0 (S n) ltac:(lia)).\n  lra.\nQed.\n\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33054,"user_id":null,"body":"Require Import Reals Lra Lia Preloaded.\n\nTheorem ind01 : forall (P : nat -> Prop), P 0 -> P 1 -> (forall n, P n -> P (S n) -> P (S (S n))) -> forall n, P n.\nProof.\n  intros P p0 p1 pi n.\n  induction n using lt_wf_ind.\n  destruct n.\n  exact p0.\n  destruct n.\n  exact p1.\n  apply pi.\n  apply H.\n  lia.\n  apply H.\n  lia.\nQed.\n\nOpen Scope R_scope.\n\nDefinition pfib (n : nat) : R := (phi ^ n - psi ^ n) \/ sqrt 5.\n\nLemma sqrt5n0 : sqrt 5 <> 0.\nProof.\n  assert (0 < 5) by lra.\n  pose proof (sqrt_lt_R0 5 H).\n  lra.\nQed.\n\nTheorem pfib_s (n : nat) : pfib n + pfib (S n) = pfib (S (S n)).\nProof.\n  unfold pfib, phi, psi.\n  field_simplify_eq.\n  simpl in *.\n  field_simplify_eq.\n  replace (sqrt 5 ^ 2) with 5 in *.\n  lra.\n  assert (0 <= 5) by lra.\n  pose proof (Rsqr_sqrt 5 H).\n  unfold Rsqr in H0.\n  lra.\n  exact sqrt5n0.\nQed.\n\nTheorem binet : forall n, INR (fib n) = (phi ^ n - psi ^ n) \/ sqrt 5.\nProof. \n  intros.\n  assert (forall n, (phi ^ n - psi ^ n) \/ sqrt 5 = pfib n).\n    reflexivity.\n  rewrite H.\n  induction n using ind01.\n  unfold pfib.\n  simpl.\n  lra.\n  unfold pfib, phi, psi.\n  simpl.\n  field.\n  exact sqrt5n0.\n  rewrite <- pfib_s.\n  simpl.\n  rewrite plus_INR.\n  rewrite IHn.\n  rewrite IHn0.\n  lra.\nQed.\n\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33055,"user_id":null,"body":"Require Import Preloaded Reals Lra.\nOpen Scope R_scope.\n\nLemma Rlt_sqrt5_0 : 0 < sqrt 5.\nProof.\n  apply sqrt_lt_R0.\n  lra.\nQed.\n\nLemma sqrt5_neq_0 : sqrt 5 <> 0.\nProof.\n  apply not_eq_sym, Rlt_not_eq; exact Rlt_sqrt5_0.\nQed.\nCheck nat_ind.\n\nTheorem nat_ind2 : forall P : nat->Prop, P 0%nat -> P 1%nat -> (forall n : nat, P n -> P (S n) -> P (S (S n))) -> forall n : nat, P n.\nProof.\n  intros P H0 H1 IH.\n  cut (forall n:nat, P n \/\\ P (S n)).\n  intros H n; exact (proj1 (H n)).\n  intro n.\n  induction n as [| n Hn].\n  auto.\n  elim Hn; intros; split; auto.\nQed.\n\nLemma pow2_sqrt5 : (sqrt 5)^2 = 5.\nProof.\n  apply pow2_sqrt; lra.\nQed.\n\nLemma phi_base : phi^2 = phi + 1.\nProof.\n  unfold phi; field [pow2_sqrt5].\nQed.\n\nLemma phi_ind : forall n:nat, phi^(S (S n)) = phi^(S n) + phi^n.\nProof.\n  intro n; simpl; field [phi_base].\nQed.\n\nLemma psi_base : psi^2 = psi + 1.\nProof.\n  unfold psi; field [pow2_sqrt5].\nQed.\n\nLemma psi_ind : forall n:nat, psi^(S (S n)) = psi^(S n) + psi^n.\nProof.\n  intro n; simpl; field [psi_base].\nQed.\n\nTheorem binet : forall n, INR (fib n) = (phi ^ n - psi ^ n) \/ sqrt 5.\nProof.\n  intro n.\n  induction n as [ | | n H1 H2 ] using nat_ind2.\n  simpl; unfold phi, psi; field; exact sqrt5_neq_0.\n  simpl; unfold phi, psi; field; exact sqrt5_neq_0.\n  cbn [fib]; rewrite plus_INR, H1, H2; field [(phi_ind n) (psi_ind n) H1 H2]; exact sqrt5_neq_0.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33056,"user_id":null,"body":"Require Import Preloaded Reals Lra.\nOpen Scope R_scope.\n\nLemma induction_scheme : forall {P : nat -> Prop},\n  P 0%nat ->\n  P 1%nat ->\n  (forall n, P n -> P (S n) -> P (S (S n))) ->\n  (forall n, P n).\nProof.\n  intros P P0 P1 PSS n; cut (P n \/\\ P (S n)); [intros [H _]; assumption|].\n  induction n; [split; assumption|].\n  destruct IHn; split; [|apply PSS]; assumption.\nQed.\n\nLemma phi_sub_psi : phi - psi = sqrt 5.\nProof.\n  unfold phi, psi; lra.\nQed.\n\nLemma phi_sqr : phi ^ 2 = (3 + sqrt 5) \/ 2.\nProof.\n  unfold phi; rewrite <- Rsqr_pow2, Rsqr_div; [|apply Rgt_not_eq; lra].\n  assert (Rsqr (1 + sqrt 5) = 6 + 2 * sqrt 5) as H; [|rewrite H; clear H].\n  { rewrite Rsqr_plus, Rsqr_sqrt; [unfold Rsqr|]; lra. }\n  unfold Rsqr; lra.\nQed.\n\nLemma phi_fib : forall n, phi ^ (S (S n)) = phi ^ (S n) + phi ^ n.\nProof.\n  induction n.\n  - rewrite phi_sqr; unfold phi; simpl; lra.\n  - rewrite <- tech_pow_Rmult, IHn at 1.\n    rewrite Rmult_plus_distr_l; repeat rewrite <- tech_pow_Rmult.\n    reflexivity.\nQed.\n\nLemma psi_sqr : psi ^ 2 = (3 - sqrt 5) \/ 2.\nProof.\n  unfold psi; rewrite <- Rsqr_pow2, Rsqr_div; [|apply Rgt_not_eq; lra].\n  assert (Rsqr (1 - sqrt 5) = 6 - 2 * sqrt 5) as H; [|rewrite H; clear H].\n  { rewrite Rsqr_minus, Rsqr_sqrt; [unfold Rsqr|]; lra. }\n  unfold Rsqr; lra.\nQed.\n\nLemma psi_fib : forall n, psi ^ (S (S n)) = psi ^ (S n) + psi ^ n.\nProof.\n  induction n.\n  - rewrite psi_sqr; unfold psi; simpl; lra.\n  - rewrite <- tech_pow_Rmult, IHn at 1.\n    rewrite Rmult_plus_distr_l; repeat rewrite <- tech_pow_Rmult.\n    reflexivity.\nQed.\n\nTheorem binet : forall n, INR (fib n) = (phi ^ n - psi ^ n) \/ sqrt 5.\nProof.\n  refine (induction_scheme _ _ _).\n  - simpl; lra.\n  - simpl; repeat rewrite Rmult_1_r; rewrite phi_sub_psi.\n    unfold Rdiv; rewrite Rinv_r; [reflexivity|].\n    intros H; symmetry in H; contradict H.\n    apply Rlt_not_eq, sqrt_lt_R0; lra.\n  - intros. assert (INR (fib (S (S n))) = INR (fib (S n)) + INR (fib n)) as Hr; [|rewrite Hr; clear Hr].\n    { simpl; apply plus_INR. }\n    rewrite H, H0.\n    assert ((phi ^ S n - psi ^ S n) \/ sqrt 5 + (phi ^ n - psi ^ n) \/ sqrt 5 = ((phi ^ S n + phi ^ n) - (psi ^ (S n) + psi ^ n)) \/ sqrt 5) as Hr;\n    [lra|rewrite Hr; clear Hr].\n    rewrite phi_fib, psi_fib; reflexivity.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33057,"user_id":null,"body":"Require Import Preloaded Reals Lra.\nOpen Scope R_scope.\n\n\nLemma my_ind : forall (P : nat -> Prop),\n  P 0%nat -> P 1%nat ->\n  (forall n, P n -> P (S n) -> P (S (S n))) ->\n  forall n, P n.\nProof.\n  intros P H0 H1 IH.\n  assert (forall n, P n \/\\ P (S n)) as Ha.\n  { induction n.\n    - split; assumption.\n    - destruct IHn. eauto.\n  }\n  intros. apply Ha.\nQed.\n\nLemma phi_equation : phi ^ 2 = phi + 1.\nProof.\n  unfold phi.\n  field_simplify_eq.\n  rewrite <- Rsqr_pow2. rewrite Rsqr_sqrt by lra. lra.\nQed.\n\nLemma psi_equation : psi ^ 2 = psi + 1.\nProof.\n  unfold psi.\n  field_simplify_eq.\n  rewrite <- Rsqr_pow2. rewrite Rsqr_sqrt by lra. lra.\nQed.\n\nLemma sqrt5_neq_0 : sqrt 5 <> 0.\nProof.\n  apply not_eq_sym.\n  apply Rlt_not_eq. rewrite <- sqrt_0.\n  apply sqrt_lt_1; lra.\nQed.\n\nLemma binet_aux : forall a b c d e f,\n  f - b - d = e - a - c ->\n  a - b + c - d = e - f.\nProof. intros. lra.\nQed.\n\nTheorem binet : forall n, INR (fib n) = (phi ^ n - psi ^ n) \/ sqrt 5.\nProof.\n  induction n using my_ind.\n  - simpl. lra.\n  - simpl. unfold phi, psi. field. apply sqrt5_neq_0.\n  - simpl.\n    rewrite plus_INR. rewrite IHn, IHn0.\n    clear IHn IHn0.\n    field_simplify_eq; try apply sqrt5_neq_0.\n    apply binet_aux.\n    replace (phi ^ n * phi ^ 2 - phi ^ S n - phi ^ n)\n      with (phi ^ n * (phi ^ 2 - 1 - phi))\n      by (simpl; field).\n    replace (psi ^ n * psi ^ 2 - psi ^ S n - psi ^ n)\n      with (psi ^ n * (psi ^ 2 - 1 - psi))\n      by (simpl; field).\n    rewrite phi_equation.\n    rewrite psi_equation.\n    lra.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33058,"user_id":null,"body":"Require Import Lia.\nTheorem complete_induction:\nforall P,\n(forall n, (forall k, (k < n -> P k)) -> P n) ->\nforall n : nat, P n.\nProof.\n  intros.\n  apply X.\n  induction n;intros.\n  - lia.\n  - apply X; intros.\n    apply IHn.\n    lia.\nQed.\n\nRequire Import Preloaded Reals Lra.\nOpen Scope R_scope.\n\nLemma phi_sqr: phi+1=phi ^ 2.\nProof.\n  unfold phi.\n  field_simplify_eq.\n  rewrite <- Rsqr_pow2.\n  rewrite Rsqr_sqrt;lra.\nQed.\n\nLemma psi_sqr: psi+1=psi ^ 2.\nProof.\n  unfold psi.\n  field_simplify_eq.\n  rewrite <- Rsqr_pow2.\n  rewrite Rsqr_sqrt;lra.\nQed.\n\nLemma powSucc a n: a^(S n) = a^n*a.\nProof.\n  replace (S n) with (n+1)%nat by lia.\n  now rewrite pow_add, pow_1.\nQed.\n\nTheorem binet : forall n, INR (fib n) = (phi ^ n - psi ^ n) \/ sqrt 5.\nProof. \n  intros n.\n  field_simplify_eq.\n  2: {\n    intros H.\n    (* rewrite <- sqrt_0 in H. *)\n    apply sqrt_eq_0 in H;lra.\n  }\n  induction n as [n IHn] using complete_induction.\n  destruct n as [|[]];cbn.\n  - lra.\n  - unfold psi, phi.\n    now field_simplify_eq.\n  - rewrite plus_INR.\n    rewrite Rmult_plus_distr_r.\n    rewrite (IHn n), (IHn (S n)).\n    2-3: lia.\n    field_simplify_eq.\n    enough (phi ^ n * (phi + 1) - psi ^ n * (psi + 1) =\n            phi ^ n * phi ^ 2 - psi ^ n * psi ^ 2).\n    1: {\n      rewrite <- H.\n      field_simplify_eq.\n      do 2 rewrite powSucc.\n      lra.\n    }\n    repeat f_equal;[apply phi_sqr|apply psi_sqr].\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33059,"user_id":null,"body":"Require Import Preloaded Reals Lra.\nOpen Scope R_scope.\n\nLemma binet' : forall n, \n(INR (fib n) = (phi ^ n - psi ^ n) \/ sqrt 5) \/\\\n(INR (fib (S n)) = (phi ^ (S n) - psi ^ (S n)) \/ sqrt 5).\nProof.\ninduction n.\n+ simpl.\nsplit. lra.\nfield_simplify_eq.\nunfold phi,psi. lra.\nassert (Hq := sqrt_lt_R0 5). lra.\n+ destruct IHn. split. { assumption. }\n simpl.\nrewrite plus_INR. rewrite H. rewrite H0.\nsimpl.\nunfold phi,psi. field_simplify_eq.\nrewrite <- Rsqr_pow2.\nrewrite Rsqr_sqrt.\nlra.\nlra.\nassert (Hq := sqrt_lt_R0 5). lra.\nQed.\n\nTheorem binet : forall n, INR (fib n) = (phi ^ n - psi ^ n) \/ sqrt 5.\nProof.\n intro n. destruct (binet' n). assumption.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5d2bd8e414a6ef001a0421d2":[{"id":33060,"user_id":null,"body":"Require Import Preloaded Reals Lra.\nOpen Scope R_scope.\n\nDefinition ind_2 : forall (P : nat -> Prop),\n  P 0%nat -> P 1%nat ->\n  (forall n, P n -> P (S n) -> P (S (S n))) ->\n  forall n, P n.\nProof.\n  intros P H0 H1 IH.\n  refine (fix aux n :=\n    match n return P n with\n    | 0 => H0\n    | S n' =>\n      match n' return P n' -> P (S n') with\n      | 0 => fun _ => H1\n      | S n'' => fun H => IH _ (aux n'') H\n      end (aux n')\n    end).\nDefined.\n\nTheorem cheb_cos : forall n x, cheb n (cos x) = cos (INR n * x).\nProof.\n  induction n using ind_2.\n  - intros x; simpl.\n    rewrite Rmult_0_l, cos_0.\n    reflexivity.\n  - intros x; simpl.\n    rewrite Rmult_1_l.\n    reflexivity.\n  - Opaque INR.\n    intros x; simpl.\n    rewrite IHn, IHn0.\n    rewrite 3!S_INR.\n    rewrite 3!Rmult_plus_distr_r, Rmult_1_l.\n    rewrite 3!cos_plus, sin_plus. ring_simplify.\n    rewrite <- Rsqr_pow2, cos2, Rsqr_pow2.\n    ring.\n    Transparent INR.\nQed.\n\nTheorem cheb_bounded : forall n x, -1 <= x <= 1 -> -1 <= cheb n x <= 1.\nProof.\n  intros n x hx.\n  rewrite <- (cos_acos x hx), cheb_cos.\n  apply COS_bound.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33061,"user_id":null,"body":"Require Import Preloaded Reals Lra.\nOpen Scope R_scope.\n\nTheorem cheb_cos : forall n x, cheb n (cos x) = cos (INR n * x).\nProof.\n  intros n x; cut (cheb n (cos x) = cos (INR n * x) \/\\ cheb (S n) (cos x) = cos (INR (S n) * x)); [easy|].\n  induction n; split.\n  - now rewrite Rmult_0_l, cos_0.\n  - simpl; now rewrite Rmult_1_l.\n  - easy.\n  - destruct IHn as [IHn IHSn].\n    transitivity (2 * cos x * cheb (S n) (cos x) - cheb n (cos x)); [easy|].\n    rewrite IHn, IHSn.\n    repeat rewrite S_INR.\n    repeat rewrite Rmult_plus_distr_r.\n    rewrite Rmult_1_l.\n    rewrite Rplus_assoc.\n    repeat rewrite cos_plus.\n    rewrite sin_plus.\n    assert (sin x * sin x = 1 - cos x * cos x) as R by now specialize (sin2 x).\n    rewrite R; clear R; lra.\nQed.\n\nTheorem cheb_bounded : forall n x, -1 <= x <= 1 -> -1 <= cheb n x <= 1.\nProof.\n  intros n x Hx; rewrite <- (cos_acos _ Hx), cheb_cos.\n  apply COS_bound.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33062,"user_id":null,"body":"Require Import Preloaded Reals Lra Lia Wf.\nOpen Scope R_scope.\n  \n  \nTheorem cheb_cos : forall n x, cheb n (cos x) = cos (INR n * x).\nProof.\n  intros n.\n  induction n as [ n IHn ] using (well_founded_induction lt_wf).\n  intros x.\n  destruct n.\n  {\n    simpl. replace (0 * x) with 0.\n      rewrite cos_0. auto.\n    lra.\n  }\n  destruct n.\n  simpl. f_equal. lra.\n  repeat rewrite S_INR.\n  simpl.\n  rewrite IHn. 2:lia.\n  rewrite IHn. 2:lia.\n  replace (INR n + 1 + 1) with (INR n + 2). 2:lra.\n  rewrite Rmult_plus_distr_r.\n  rewrite S_INR.\n  rewrite Rmult_plus_distr_r.\n  rewrite Rmult_1_l.\n  rewrite (cos_plus (INR n * x) (2 * x)).\n  rewrite sin_2a.\n  rewrite cos_plus.\n  unfold Rminus.\n  rewrite Rmult_plus_distr_l.\n  rewrite Rplus_assoc.\n  rewrite (Rplus_comm _ (- cos _)).\n  rewrite <- Rplus_assoc.\n  replace (2 * cos x * - (sin (INR n * x) * sin x)) with (- (sin (INR n * x) * (2 * sin x * cos x))).\n  2:lra.\n  f_equal.\n  rewrite cos_2a.\n  unfold Rminus.\n  rewrite Rmult_plus_distr_l.\n  enough (cos x * (cos (INR n * x) * cos x) + - cos (INR n * x) = cos (INR n * x) * - (sin x * sin x)). lra.\n  enough (cos (INR n * x) * (cos x * cos x + - 1) = cos (INR n * x) * - (sin x * sin x)). lra.\n  f_equal.\n  replace (-1) with (- (1)).\n  rewrite <- (sin2_cos2 x). unfold Rsqr. lra. lra.\nQed.\n    \n\nTheorem cheb_bounded : forall n x, -1 <= x <= 1 -> -1 <= cheb n x <= 1.\nProof.\n  intros.\n  enough(exists y, x = cos y).\n  {\n    destruct H0.\n    rewrite H0.\n    rewrite cheb_cos.\n    apply COS_bound.\n  }\n  destruct H.\n  destruct H.\n  2:{\n    subst.\n    exists PI.\n    rewrite cos_PI. auto.\n  }\n  destruct H0.\n  2:{\n    subst.\n    exists 0.\n    rewrite cos_0.\n    auto.\n  }\n  destruct (IVT (fun x' => cos x' + -x) PI (2*PI)).\n  {\n    apply continuity_plus.\n      apply continuity_cos.\n    apply continuity_const. \n    unfold constant. auto.\n  }\n  {\n    rewrite <- Rmult_1_l at 1.\n    apply Rmult_lt_compat_r.\n    specialize Rgt_2PI_0. intros. lra. lra.\n  }\n  {\n    rewrite cos_PI. lra.\n  }\n  {\n    replace (2 * PI) with (0 + 2 * INR 1 * PI).\n      rewrite cos_period. \n      rewrite cos_0. lra.\n    simpl. lra.\n  }\n  exists x0. lra.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33063,"user_id":null,"body":"Require Import Preloaded Reals Lra.\nOpen Scope R_scope.\n  \nLemma double_nat_ind : forall P : nat -> Prop,\n  P 0%nat -> P 1%nat -> (forall n, P n -> P (S n) -> P (S (S n))) ->\n  forall n, P n.\nProof.\n  intros P H0 H1 IH.\n  assert (H: forall n, P n \/\\ P (S n)). {\n    induction n; split; auto; destruct IHn; auto.\n  }\n  intros.\n  now destruct (H n).\nQed.\n\nLemma add_eq : forall a b c d, a = b -> c = d -> a + c = b + d.\nProof. intros. lra. Qed.\n\nLemma cos_fact : forall n x,\n  cos (n * x + x) = 2 * cos x * cos (n * x) - cos ((n - 1) * x).\nProof.\n  intros.\n  pose proof (cos_plus (n * x) x) as H1.\n  pose proof (cos_plus (n * x) (-x)) as H2.\n  rewrite <- cos_sym in H2.\n  rewrite sin_antisym in H2.\n  pose proof (add_eq _ _ _ _ H1 H2) as H3.\n  replace ((n - 1) * x) with (n * x + - x) by lra.\n  lra.\nQed.\n\nTheorem cheb_cos : forall n x, cheb n (cos x) = cos (INR n * x).\nProof.\n  induction n using double_nat_ind; intros.\n  - simpl; replace (0 * x) with 0.\n    now rewrite cos_0.\n    lra.\n  - simpl; replace (1 * x) with x; auto.\n    lra.\n  - replace (cheb (S (S n)) (cos x))\n      with (2 * cos x * cheb (S n) (cos x) - cheb n (cos x)) by auto.\n    rewrite IHn, IHn0.\n    pose proof (cos_fact (INR (S n)) x) as Hc.\n    rewrite ?S_INR in *.\n    replace ((INR n + 1 + 1) * x) with ((INR n + 1) * x + x) by lra.\n    replace (INR n + 1 - 1) with (INR n) in Hc;\n      lra.\nQed.\n\nTheorem cheb_bounded : forall n x, -1 <= x <= 1 -> -1 <= cheb n x <= 1.\nProof.\n  intros.\n  rewrite <- (cos_acos x); auto.\n  rewrite cheb_cos.\n  apply COS_bound.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33064,"user_id":null,"body":"Require Import Preloaded Reals Lra.\nOpen Scope R_scope.\n\nLemma induction_scheme : forall {P : nat -> Prop},\n  P O ->\n  P (S O) ->\n  (forall n, P n -> P (S n) -> P (S (S n))) ->\n  (forall n, P n).\nProof.\n  intros; cut (P n \/\\ P (S n)); [intros [Pn _]|induction n; [|split;[|apply H1]]]; easy.\nQed.\n\nTheorem cheb_cos : forall n x, cheb n (cos x) = cos (INR n * x).\nProof.\n  refine (induction_scheme _ _ _).\n  - intros; rewrite Rmult_0_l, cos_0; easy.\n  - intros; rewrite Rmult_1_l; easy.\n  - intros; cut (cheb (S (S n)) (cos x) = 2 * cos x * cheb (S n) (cos x) - cheb n (cos x)); [|easy].\n    intros HR; rewrite HR, H, H0; clear.\n    apply (Rplus_eq_reg_r (cos (INR n * x))).\n    rewrite Rplus_comm, Rplus_minus, form1.\n    cut ((INR (S (S n)) * x - INR n * x) \/ 2 = x);\n    [cut ((INR (S (S n)) * x + INR n * x) \/ 2 = INR (S n) * x);\n    [intros R1 R2; now rewrite R1, R2|]|]; repeat rewrite S_INR; lra.\nQed.\n\nTheorem cheb_bounded : forall n x, -1 <= x <= 1 -> -1 <= cheb n x <= 1.\nProof.\n  intros; rewrite <- (cos_acos x), cheb_cos; [|easy].\n  apply COS_bound.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33065,"user_id":null,"body":"Require Import Preloaded Reals Lra.\nOpen Scope R_scope.\n\nLemma induction_scheme : forall {P : nat -> Prop},\n  P O ->\n  P (S O) ->\n  (forall n, P n -> P (S n) -> P (S (S n))) ->\n  (forall n, P n).\nProof.\n  intros P P0 P1 PS n; cut (P n \/\\ P (S n)); [intros [H _]; assumption|].\n  induction n; [split; assumption|].\n  destruct IHn; split; [|apply PS]; assumption.\nQed.\n\nTheorem cheb_cos : forall n x, cheb n (cos x) = cos (INR n * x).\nProof.\n  refine (induction_scheme _ _ _).\n  - intros; simpl.\n    rewrite Rmult_0_l, cos_0; reflexivity.\n  - intros; simpl.\n    rewrite Rmult_1_l; reflexivity.\n  - intros.\n    assert (forall n x, INR (S n) * x = x + (INR n * x)) as Hnx.\n    { intros n' x'; destruct n'; [|destruct n']; simpl; lra. }\n    repeat rewrite Hnx; simpl; rewrite H, H0, Hnx.\n    repeat rewrite cos_plus; rewrite sin_plus.\n    assert (cos (INR n * x) = cos (INR n * x) * (Rsqr (sin x) + Rsqr (cos x))) as Hr.\n    { rewrite sin2_cos2; lra. }\n    rewrite Hr at 2; clear Hr; unfold Rsqr.\n    assert (2 = INR (S (S O))) as Hr; [reflexivity|rewrite Hr; clear Hr].\n    rewrite Rmult_assoc, Hnx, Hnx, Rmult_0_l; lra.\nQed.\n\nTheorem cheb_bounded : forall n x, -1 <= x <= 1 -> -1 <= cheb n x <= 1.\nProof.\n  intros n x bounds; rewrite <- (cos_acos x), cheb_cos; [|assumption].\n  apply COS_bound.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33066,"user_id":null,"body":"Require Import Preloaded Reals Lra Lia ssreflect.\nOpen Scope R_scope.\n(*Half of cheb_cos' proof is taken from my solution, half from monadius'*)\nTheorem cheb_cos : forall n x, cheb n (cos x) = cos (INR n * x).\nProof. induction n using lt_wf_ind. destruct n as [|[|n']];intros;\n [simpl ..|];[rewrite <- cos_0|..];[f_equal;lra ..|].\n do 2 rewrite S_INR. simpl.\n rewrite -> (H n'), (H (S n')), S_INR;[|lia..].\n rewrite !Rmult_plus_distr_r Rmult_1_l !cos_plus !sin_plus.\n field_simplify_eq.\n rewrite -(Rsqr_pow2 (sin x)) sin2 Rsqr_pow2.\n ring.\nQed.\n(*Trigonometry lemmas new to Coq 8.12*)\nTheorem cheb_bounded : forall n x, -1 <= x <= 1 -> -1 <= cheb n x <= 1.\nProof. intros.\n rewrite <- (cos_acos x H).\n rewrite cheb_cos.\n apply COS_bound.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33067,"user_id":null,"body":"Require Import Preloaded.\n\nRequire Import Reals Lra Lia.\nOpen Scope R_scope.\n\nTheorem cheb_cos : forall n x, cheb n (cos x) = cos (INR n * x).\nProof. induction n using lt_wf_ind. destruct n as [|[|n']];[simpl ..|];intros.\n* assert (0 * x = 0);[lra|].\n  rewrite H0. symmetry;apply cos_0.\n* f_equal. lra.\n* do 2 rewrite S_INR. simpl.\n  rewrite (H n'), (H (S n')), S_INR;[|lia..].\n  remember (INR n') as k.\n  replace ((k+1)*x) with (k*x + x);[|lra].\n  replace ((k+1+1)*x) with (k*x + (2*x));[|lra].\n  do 2 rewrite cos_plus.\n  rewrite sin_2a, cos_2a.\n  cut (cos (k*x) = cos (k*x) * (sin x ^ 2 + cos x ^ 2));[lra|].\n  do 2 rewrite <- Rsqr_pow2.\n  rewrite sin2_cos2.\n  lra.\nQed.\n\nLemma cos_inv : forall x, -1 <= x <= 1 -> exists y, cos y = x.\nProof. intros. destruct (IVT_cor (fun w => cos w - x) 0 PI);[\n reg|\n assert (Hp := PI_RGT_0)|\n rewrite cos_0, cos_PI|\n exists x0];nra.\nQed.\n\nTheorem cheb_bounded : forall n x, -1 <= x <= 1 -> -1 <= cheb n x <= 1.\nProof. intros.\n destruct (cos_inv _ H).\n rewrite <- H0.\n rewrite cheb_cos.\n apply COS_bound.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33068,"user_id":106,"body":"Require Import Preloaded Reals Lra.\n\nLemma ind_0_1_SS (P : nat -> Prop) :\n  P 0 ->\n  P 1 ->\n  (forall n, P n -> P (S n) -> P (S (S n))) ->\n  forall n, P n.\nProof.\n  intros H0 H1 Hstep n.\n  enough (P n \/\\ P (S n)) by tauto.\n  induction n; intuition.\nQed.\n\nArguments INR : simpl nomatch.\n\nOpen Scope R_scope.\n\nLemma INR_inc : forall n, INR (S n) = INR n + 1.\nProof.\n  induction n; simpl; lra.\nQed.\n\nTheorem cheb_cos : forall n x, cheb n (cos x) = cos (INR n * x).\nProof.\n  intros. revert n.\n  apply ind_0_1_SS; intros.\n  - now rewrite Rmult_0_l, cos_0.\n  - now rewrite Rmult_1_l.\n  - simpl; rewrite H, H0. rewrite Rmult_plus_distr_r, cos_plus.\n    rewrite INR_inc, Rmult_plus_distr_r, cos_plus, sin_plus.\n    repeat rewrite Rmult_1_l; simpl.\n    remember (INR n * x) as nx.\n    replace (2 * cos x * (cos nx * cos x - sin nx * sin x) - cos nx)\n    with (cos nx * (cos x * cos x - (1 - cos x ^ 2)) - sin nx * (2 * sin x * cos x)) by lra.\n    rewrite <- Rsqr_pow2, <- sin2, Rsqr_pow2.\n    lra.\nQed.\n\nTheorem cheb_bounded : forall n x, -1 <= x <= 1 -> -1 <= cheb n x <= 1.\nProof.\n  intros.\n  assert (exists y, cos y = x) as Hy.\n  {\n    destruct (IVT_cor (fun y => cos y - x) 0 PI).\n    - reg.\n    - pose proof PI_RGT_0; lra.\n    - rewrite cos_0, cos_PI; nra.\n    - exists x0; lra.\n  }\n  destruct Hy; subst; rewrite cheb_cos; apply COS_bound.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33069,"user_id":null,"body":"Require Import Preloaded Reals Lra Lia.\nOpen Scope R_scope.\n  \nLemma cheb_cos_gen: forall m n (Hgen: le n m) x, cheb n (cos x) = cos (INR n * x).\nProof.\ninduction m.\n+ destruct n; intros. rewrite Rmult_0_l. rewrite cos_0. reflexivity.\n  inversion Hgen.\n+ destruct n; intros.\n  - rewrite Rmult_0_l. rewrite cos_0. reflexivity.\n  - destruct n.\n    * simpl. rewrite Rmult_1_l. reflexivity.\n    * simpl cheb. rewrite IHm; try lia. rewrite IHm; try lia.\n      replace (INR (S (S n)) * x) with (INR (S n) * x + x) by (simpl; ring).\n      rewrite cos_plus. replace (INR (S n) * x) with (INR n * x + x).\n      rewrite sin_plus. rewrite cos_plus. ring_simplify.\n      (* From there just ininteresting rewritings... Simpler solutions... *) \n      assert (2 * cos x ^ 2 * cos (INR n * x) - cos (INR n * x) = cos x ^ 2 * cos (INR n * x) - cos (INR n * x) * sin x ^ 2).\n      assert (2 * cos x ^ 2 - 1 = cos x ^ 2 - sin x ^ 2). \n      replace (sin x ^ 2) with (Rsqr (sin x)). rewrite sin2. unfold Rsqr. ring.\n      unfold Rsqr. ring.\n      destruct (Req_EM_T (cos (INR n * x)) 0). rewrite e. ring.\n      eapply (Rmult_eq_compat_r (cos (INR n * x))) in H.\n      lra.\n      lra.\n      destruct n; simpl; ring.\nQed.\n\nTheorem cheb_cos : forall n x, cheb n (cos x) = cos (INR n * x).\nProof.\nintros.\neapply (cheb_cos_gen n). lia.\nQed. \n\nTheorem cheb_bounded : forall n x, -1 <= x <= 1 -> -1 <= cheb n x <= 1.\nProof. \nintros.\n(* TODO find and use arccos ???? *)\nassert (x = 1 \\\/ x = -1 \\\/ - 1 < x < 1). \n{ \n  destruct (Req_EM_T x 1); destruct (Req_EM_T x (-1)); eauto. lra.\n}\ndestruct H0 as [H1 | [Hm1 | Hg]].\n- subst. rewrite <- cos_0. rewrite cheb_cos. rewrite cos_0. apply COS_bound.\n- subst. rewrite <- cos_PI. rewrite cheb_cos. rewrite cos_PI. apply COS_bound.\n- specialize (IVT (fun y => cos y - x) (-PI) 0). intros.\n  destruct H0.\n  + apply continuity_minus. apply continuity_cos.\n    apply continuity_const. intros H1 H2. reflexivity.\n  + specialize PI_RGT_0. lra.\n  + specialize cos_PI. intros. rewrite <- (Ropp_involutive (cos _)). rewrite <- neg_cos.\n    ring_simplify (-PI + PI). rewrite cos_0. lra.\n  + rewrite cos_0. lra.\n  + destruct a. assert (cos x0 = x). lra. rewrite <- H2.\n    rewrite cheb_cos. apply COS_bound.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5d40b336dc22a100215274dc":[{"id":33070,"user_id":168,"body":"Load Bool. Let lemma:=negb_involutive.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33071,"user_id":568,"body":"Let lemma b:negb(negb b)=b. now elim b. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33072,"user_id":168,"body":"Let lemma b:negb(negb b)=b. now case b. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5d64d9c0a5aad20001b2d9f8":[{"id":33073,"user_id":17,"body":"Require Import Preloaded Lia.\n\nLemma nicomachus : forall n : nat, sq (fsum id n) = fsum cb n.\nProof.\n  assert (forall n, 2 * fsum id n = n * S n)\n    by (induction n; simpl; lia).\n  assert (forall n, 4 * fsum cb n = n * S n * (n * S n))\n    by (induction n; simpl; lia).\n  unfold sq; intro.\n  assert ((2 * fsum id n) * (2 * fsum id n) = 4 * fsum cb n)\n    by (rewrite H, H0; lia).\n  lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33074,"user_id":null,"body":"\nFrom mathcomp Require Import all_ssreflect.\nRequire Import Psatz.\nRequire Import Preloaded.\n\n\nLemma nicomachus n : sq (fsum id n) = fsum cb n.\nProof.\n  elim: n => \/\/=.\n  move=> n H.\n  rewrite -[sq (id n.+1 + fsum id n)]\/((n.+1 + fsum id n) * (n.+1 + fsum id n)).\n  have t : forall a b, (a+b)*(a+b) = a*a+2*a*b+b*b.\n    intros.\n    rewrite -![_+_]\/((_+_)%coq_nat).\n    rewrite -![_*_]\/((_*_)%coq_nat).\n    lia.\n  rewrite (t n.+1 (fsum id n));move=> {t}.\n  rewrite -[sq (fsum id n) = fsum cb n]\/(fsum id n * fsum id n = fsum cb n) in H.\n  rewrite H.\n  rewrite -\/(n.+1 * n.+1 + 2 * n.+1 * fsum id n + fsum cb n = cb n.+1 + fsum cb n).\n  congr (_+_).\n  move=> {H};elim: n => \/\/=.\n  intros.\n  rewrite {1}\/id.\n  have t : forall a b, a.+1*a.+1 + 2*a.+1*(a+b)=(a*a+2*a*b)+1+a+a+2*(a+b)+2*a*a.\n    intros.\n    rewrite -addn1.\n    rewrite -![_+_]\/((_+_)%coq_nat).\n    rewrite -![_*_]\/((_*_)%coq_nat).\n    lia.\n  rewrite {}t.\n  rewrite H.\n  have t : forall a b c, c.+1*a = c.+1*b -> a = b.\n    move=> a b c.\n    rewrite -addn1.\n    rewrite -![_+_]\/((_+_)%coq_nat).\n    rewrite -![_*_]\/((_*_)%coq_nat).\n    nia.\n  apply: (t _ _ n);move=> {t}.\n  have t : forall a b, a*(cb a + 1 + a + a + 2 * (a+b)+2*a*a) =\n    a*a+2*a*b+a*cb a+a+a*a+2*a*a+2*a*a*a.\n    intros.\n    rewrite -![_+_]\/((_+_)%coq_nat).\n    rewrite -![_*_]\/((_*_)%coq_nat).\n    lia.\n  rewrite {}t.\n  rewrite H.\n  rewrite \/cb.\n  (* Search \"addn2\". *)\n  rewrite -[n.+2]addn2 -addn1.\n  rewrite -![_+_]\/((_+_)%coq_nat).\n  rewrite -![_*_]\/((_*_)%coq_nat).\n  lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33075,"user_id":null,"body":"Require Import Nat.\nRequire Import Arith.\n\nFixpoint fsum f n := match n with\n  | 0 => f 0\n  | S n' => f n + fsum f n'\nend.\n\nDefinition id (n : nat) := n.\nDefinition sq n := n * n.\nDefinition cb n := n * n * n.\n\nLemma nicomachus n : sq (fsum id n) = fsum cb n.\nProof.\n  induction n.\n  reflexivity.\n  change (fsum id (S n)) with (S n + fsum id n).\n  unfold sq.\n  change (fsum cb (S n)) with (cb (S n) + fsum cb n).\n  rewrite <- IHn.\n  rewrite -> Nat.mul_add_distr_r.\n  rewrite -> Nat.mul_add_distr_l.\n  rewrite -> Nat.mul_add_distr_l.\n  unfold sq.\n  rewrite -> Nat.add_assoc.\n  apply Nat.add_cancel_r.\n  cut (forall n:nat, fsum id n + fsum id n = S n * n).\n  intros.\n  rewrite <- Nat.add_assoc.\n  rewrite <- Nat.add_comm.\n  rewrite <- Nat.mul_comm.\n  rewrite <- Nat.mul_add_distr_r.\n  rewrite -> (H n).\n  rewrite -> Nat.mul_comm.\n  rewrite -> Nat.mul_assoc.\n  rewrite -> Nat.add_comm.\n  rewrite <- (Nat.mul_1_r (S n * S n)) at 1.\n  rewrite <- Nat.mul_add_distr_l.\n  rewrite <- Nat.add_1_l.\n  trivial.\n  intros.\n  induction n0.\n  trivial.\n  change (fsum id (S n0)) with (S n0 + fsum id n0).\n  rewrite <- Nat.add_assoc.\n  rewrite <- (Nat.add_comm (S n0 + fsum id n0)).\n  rewrite <- Nat.add_assoc.\n  rewrite -> IHn0.\n  ring.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33076,"user_id":null,"body":"Require Import Preloaded Arith Lia.\n\nLemma succ_sq a b : sq (a + b) = sq a + 2*a*b + sq b.\nProof.\n  unfold sq.\n  ring.\nQed.\n\nLemma sumn n : 2 * fsum id n = n * (n+1).\nProof.\n  induction n.\n  + reflexivity.\n  + simpl. ring_simplify. rewrite IHn. ring.\nQed.\nLemma nicomachus n : sq (fsum id n) = fsum cb n.\nProof.\n  induction n.\n  + reflexivity.\n  + simpl. replace (S (n + fsum id n)) with (n + fsum id n + 1) by lia.\n    replace (S (n + (n + n * S n) * S n + fsum cb n)) with \n    (n + (n + n * S n) * S n + fsum cb n + 1) by lia.\n    replace (S n) with (n + 1) by lia.\n    repeat (rewrite succ_sq).\n    repeat (rewrite <- IHn).\n    unfold sq.\n    ring_simplify.\n    replace (2 * n * fsum id n) with (n * (2* fsum id n)) by nia.\n    rewrite sumn.\n    ring.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33077,"user_id":null,"body":"Require Import Preloaded Arith.\n\nLemma nicomachus : forall n : nat, sq (fsum id n) = fsum cb n.\nProof.\n  induction n; [easy|].\n  replace (fsum id (S n)) with (S n + fsum id n); [|easy].\n  replace (sq (S n + fsum id n)) with (sq (S n) + 2 * S n * fsum id n + sq (fsum id n)); [|unfold sq; ring].\n  rewrite IHn; cut (sq (S n) + 2 * S n * fsum id n = cb (S n)); [intros H; now rewrite H|].\n  replace (sq (S n) + 2 * S n * fsum id n) with (S n * (S n + 2 * fsum id n)); [|unfold sq; ring].\n  unfold cb; cut (S n + 2 * fsum id n = S n * S n); [intros H; rewrite H; ring|].\n  cut (2 * fsum id n = n * S n); [intros H; rewrite H; ring|clear].\n  induction n; [easy|].\n  replace (2 * fsum id (S n)) with (2 * S n + 2 * fsum id n); [|unfold fsum, id; ring].\n  rewrite IHn; ring.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33078,"user_id":null,"body":"Require Import Preloaded.\n\nRequire Import Arith.\nRequire Import Lia.\n\nLemma sq_plus (n m : nat) : sq (n + m) = (sq n) + 2 * n * m + (sq m).\nProof.\n  intros.\n  unfold sq.\n  lia.\nQed.\n\nLemma two_mult_fsum_id_n_EQ_n_mult_Sn (n : nat) : 2 * (fsum id n) = n * (S n).\nProof.\n  induction n.\n  - reflexivity.\n  - simpl.\n    assert (n * S (S n) = n + n * (S n)) by lia.\n    rewrite H. rewrite <- IHn.\n    lia.\nQed.\n\nLemma nicomachus n : sq (fsum id n) = fsum cb n.\nProof.\n  induction n.\n  - reflexivity.\n  - simpl.\n    rewrite <- plus_Sn_m.\n    rewrite (sq_plus (S n) (fsum id n)).\n    rewrite <- plus_Sn_m.\n    rewrite IHn.\n    unfold sq.\n    rewrite <- plus_Sn_m.\n    assert (2 * S n * fsum id n = S n * (2 * fsum id n)) by lia.\n    rewrite H.\n    rewrite two_mult_fsum_id_n_EQ_n_mult_Sn.\n    lia.\nQed.\n    \n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33079,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Ring.\nRequire Import Arith.\n\nLemma gauss n : 2 * fsum id n = n * S n.\nProof. induction n.\n  - reflexivity.\n  - replace (fsum id (S n)) with (S n + fsum id n) by auto.\n    replace (2 * (S n + fsum id n)) with (2 * S n + 2 * fsum id n) by ring.\n    replace (2 * fsum id n) with (n * S n) by auto.\n    replace (2 * S n + n * S n) with (S (S n) * S n) by ring.\n    ring.\nQed.\n\nLemma nicomachus n : sq (fsum id n) = fsum cb n.\nProof. induction n.\n  - reflexivity.\n  - replace (fsum cb (S n)) with (cb (S n) + fsum cb n) by auto.\n    replace (fsum cb n) with (sq (fsum id n)) by auto.\n    replace (sq (fsum id (S n))) with ((fsum id (S n)) * (fsum id (S n))) by auto.\n    replace (sq (fsum id n)) with (fsum id n * fsum id n) by auto.\n    replace (fsum id (S n)) with (S n + fsum id n) by auto.\n    replace ((S n + fsum id n) * (S n + fsum id n)) with (fsum id n * fsum id n + 2 * fsum id n * S n + S n * S n) by ring.\n    replace (cb (S n)) with (S n * S n * S n) by auto.\n    replace (S n * S n * S n) with (n * S n * S n + S n * S n) by ring.\n    rewrite <- (gauss n).\n    ring.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33080,"user_id":null,"body":"Require Import Preloaded.\n\nRequire Import Arith.\n\nLemma triangular (n : nat) : 2 * fsum id n = (S n) * n.\nProof.\n  induction n as [| n Hn].\n  reflexivity.\n  cbn [fsum].\n  rewrite Nat.mul_add_distr_l.\n  rewrite Hn.\n  simpl.\n  ring.\nQed.\n\nLemma square_add_expand (n m : nat) : sq (n + m) = n*n + m*m + 2 * m * n.\nProof.\n  unfold sq; ring.\nQed.\n\nLemma nicomachus n : sq (fsum id n) = fsum cb n.\nProof.\n  induction n as [| n Hn].\n  reflexivity.\n  cbn [fsum].\n  rewrite square_add_expand, <- Hn, triangular.\n  unfold sq, cb, id.\n  ring.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33081,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Lia.\n\nLemma nicomachus : forall n : nat, sq (fsum id n) = fsum cb n.\nProof. induction n. reflexivity.\n       simpl. rewrite <- IHn.\n       remember (fsum id n) as x.\n       assert (forall a b:nat, sq (a+b) = a*a + 2*a*b + b*b).\n       { unfold sq. lia. }\n       assert (forall x, S x = x + 1).\n       { lia. }\n       rewrite H0. rewrite H.\n       unfold sq. simpl. rewrite <- H0. apply f_equal.\n       assert ((n+x+(n+x+0))*1 = 2*(n+x)).\n       { lia. } rewrite H1.\n       assert ((n + x) * (n + x) + 2 * (n + x) = 2*n*x+2*x+2*n+n*n+x*x).\n       { lia. } rewrite H2.\n       assert (n + (n + n * S n) * S n = n + 2*n*n + n*n*n + 2*n + n*n).\n       { lia. } rewrite H3.\n       assert (forall a b c, a=b -> a+ c = b+c).\n       { lia. } apply H4. apply H4. apply H4.\n       assert (2*n*x+2*x=2*x*(n+1)).\n       { lia. } rewrite H5.\n       assert (n+2*n*n + n*n*n = n*(n+1)*(n+1)).\n       { lia. } rewrite H6.\n       assert (forall n, 2*fsum id n = n*(n+1)).\n       { induction n0.\n         reflexivity.\n         simpl. apply f_equal.\n         assert (n0 + fsum id n0 + S (n0 + fsum id n0 + 0) = 2*fsum id n0 + 2*n0 + 1).\n         { lia. } rewrite H7.\n         rewrite IHn0. lia. }\n       rewrite Heqx. rewrite H7. reflexivity. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33082,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Lia.\n\nLemma gauss n : 2 * (fsum id n) = n*n + n.\nProof.\n  induction n; simpl; try lia.\nQed.\n\nLemma nicomachus n : sq (fsum id n) = fsum cb n.\nProof.\n  induction n; unfold sq in *; unfold cb in *; simpl; try lia.\n  assert (H := gauss n).\n  lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5ddcfa7aaff39b0027d2c754":[{"id":33083,"user_id":null,"body":"Require Import Preloaded.\nFrom Coq Require Import List.\nImport ListNotations.\n\nLemma elem_index_spec : forall {A} (eq_dec : forall x y : A,\n  {x = y} + {x <> y}) n l,\n  match elem_index eq_dec n l with\n  | Some i => exists xs0 xs1, l = xs0 ++ n :: xs1 \/\\\n      length xs0 = i \/\\ ~ In n xs0\n  | None => ~ In n l\n  end.\nProof.\n  intros A eq_dec n l; induction l as [|x l]; [easy|].\n  simpl; destruct (eq_dec n x) as [|Hneq]; [subst; now exists [], l|].\n  destruct (elem_index eq_dec n l) as [i|].\n  - destruct IHl as [xs0 [xs1 [Heq [Hlen Hnin]]]]; subst.\n    exists (x :: xs0), xs1; repeat split.\n    contradict Hnin; destruct Hnin as [F|]; [contradict Hneq|]; easy.\n  - intros [F|F]; [contradict Hneq|contradict IHl]; easy.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33084,"user_id":null,"body":"Require Import Preloaded.\nFrom Coq Require Import List.\nImport ListNotations.\n\nLemma elem_index_spec : forall {A} (eq_dec : forall x y : A, {x = y} + {x <> y}) n l,\n    match elem_index eq_dec n l with\n    | Some i => exists xs0 xs1, l = xs0 ++ n :: xs1 \/\\\n                            length xs0 = i \/\\ ~ In n xs0\n    | None => ~ In n l\n    end.\nProof.\n  intros A Hdec n l.\n  revert n; induction l; intros n; simpl; auto.\n  destruct (Hdec n a); subst.\n  - exists nil; eexists; split; simpl; eauto.\n  - specialize (IHl n).\n    destruct (elem_index Hdec n l) eqn:Hnl; intuition.\n    destruct IHl as [l1 [l2 [H0 [H1 H2]]]]; subst.\n    exists (a :: l1), l2; repeat split; simpl; intuition.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33085,"user_id":null,"body":"Require Import Preloaded.\nFrom Coq Require Import List.\nImport ListNotations.\n\nLemma elem_index_spec : forall {A} (eq_dec : forall x y : A,\n  {x = y} + {x <> y}) n l,\n  match elem_index eq_dec n l with\n  | Some i => exists xs0 xs1, l = xs0 ++ n :: xs1 \/\\\n      length xs0 = i \/\\ ~ In n xs0\n  | None => ~ In n l\n  end.\nProof.\n  induction l as [|a l h].\n  - simpl. auto.\n  - simpl. induction (eq_dec n a).\n    + exists []. exists l. simpl. split. \n      * rewrite a0. reflexivity.\n      * split. reflexivity. eauto.\n    + simpl. induction (elem_index eq_dec n l).\n      * destruct h as [xs0 [xs1 [h1 [h2 h3]]]].\n        exists (a :: xs0). exists xs1. split.\n        rewrite <- app_comm_cons. rewrite h1. reflexivity.\n        split. simpl. rewrite h2. reflexivity.\n        simpl. intros [hf |hf]. apply b. symmetry. assumption.\n        apply h3. assumption.\n      * intros [hf | hf]. apply b. symmetry. assumption.\n        apply h. assumption. \nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33086,"user_id":null,"body":"Require Import Preloaded.\nFrom Coq Require Import List ssreflect.\nImport ListNotations.\n\nLemma elem_index_spec : forall {A} (eq_dec : forall x y : A,\n  {x = y} + {x <> y}) n l,\n  match elem_index eq_dec n l with\n  | Some i => exists xs0 xs1, l = xs0 ++ n :: xs1 \/\\\n      length xs0 = i \/\\ ~ In n xs0\n  | None => ~ In n l\n  end.\nProof.\n  move=> A decA a.\n  elim=> [_ \/\/|b w IHw \/=].\n  case: (decA a b) => [->|neqab].\n    by exists []; exists w => \/=; split; split.\n  move: IHw.\n  case: (elem_index decA a w) => [n [w1 [w2 [-> [eqlenw1n anotinw1]]]]|].\n    exists (b :: w1); exists w2 => \/=; split=> \/\/.\n    rewrite eqlenw1n; split=> \/\/.\n    move=> [eqba|\/\/].\n    by apply: neqab; rewrite eqba.\n  move=> anotinw [eqba|\/\/].\n  by apply: neqab; rewrite eqba.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33087,"user_id":null,"body":"Require Import Preloaded.\nFrom Coq Require Import List.\nImport ListNotations.\n\nLemma elem_index_spec : forall {A} (eq_dec : forall x y : A,\n  {x = y} + {x <> y}) n l,\n  match elem_index eq_dec n l with\n  | Some i => exists xs0 xs1, l = xs0 ++ n :: xs1 \/\\\n      length xs0 = i \/\\ ~ In n xs0\n  | None => ~ In n l\n  end.\nProof.\n  intros.\n  induction l; intros.\n  - simpl. auto.\n  - simpl. destruct (eq_dec n a) eqn:E; subst.\n    exists []. exists l.\n    split. auto. split. auto. auto.\n    destruct (elem_index eq_dec n l) eqn:E1; subst.\n    + destruct IHl as [xs0' [xs1' [H1 [H2 H3]]]]; subst.\n      exists (a :: xs0'). exists xs1'.\n      split. auto. split. auto.\n      intros contra.\n      destruct contra; subst; contradiction.\n    + intros [H | H]; subst; contradiction.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33088,"user_id":null,"body":"Require Import Preloaded.\nFrom Coq Require Import List.\nImport ListNotations.\n\nLemma elem_index_spec : forall {A} (eq_dec : forall x y : A,\n  {x = y} + {x <> y}) n l,\n  match elem_index eq_dec n l with\n  | Some i => exists xs0 xs1, l = xs0 ++ n :: xs1 \/\\\n      length xs0 = i \/\\ ~ In n xs0\n  | None => ~ In n l\n  end.\n   Proof with auto.\n     induction l; cbn.\n     - intro. contradiction.\n     - destruct  (eq_dec n a).\n       + exists nil, l.\n         firstorder. cbn. subst...\n      + destruct (elem_index eq_dec n l).\n        * firstorder.\n          exists (a::x), x0.\n          firstorder.\n          rewrite <- app_comm_cons. rewrite H...\n          cbn. apply eq_S...\n        * firstorder.\n  Qed.     \n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33089,"user_id":null,"body":"Require Import Preloaded.\nFrom Coq Require Import List.\nImport ListNotations.\n\nLemma elem_index_spec : forall {A} (eq_dec : forall x y : A,\n  {x = y} + {x <> y}) n l,\n  match elem_index eq_dec n l with\n  | Some i => exists xs0 xs1, l = xs0 ++ n :: xs1 \/\\\n      length xs0 = i \/\\ ~ In n xs0\n  | None => ~ In n l\n  end.\nProof. intros. induction l; simpl; auto.\n       destruct (eq_dec n a).\n       exists []. simpl. exists l. split. rewrite e; auto. auto.\n       destruct (elem_index eq_dec n l). destruct IHl, H.\n       destruct H. rewrite H. exists (a::x). exists x0. split.\n       auto. destruct H0. split; simpl. auto. intro. destruct H2.\n       apply eq_sym in H2. auto. auto. intro. destruct H. destruct n0. auto. auto. Qed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33090,"user_id":null,"body":"Require Import Preloaded.\nFrom Coq Require Import List.\nImport ListNotations.\n\nLemma elem_index_spec : forall {A} (eq_dec : forall x y : A,\n  {x = y} + {x <> y}) n l,\n  match elem_index eq_dec n l with\n  | Some i => exists xs0 xs1, l = xs0 ++ n :: xs1 \/\\\n      length xs0 = i \/\\ ~ In n xs0\n  | None => ~ In n l\n  end.\nProof.\n  intros A eq_dec n l. induction l; [easy|].\n  destruct (eq_dec n a) eqn:H.\n  - subst. simpl. rewrite H. now exists [], l.\n  - simpl. rewrite H. destruct (elem_index eq_dec n l) eqn:H'.\n    + decompose record IHl; subst. exists (a :: x), x0.\n      split; split; auto.\n      simpl; intros [C|C]; [apply n0 | apply H3]; easy.\n    + intros [C|C]; [apply n0 | apply IHl]; easy.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33091,"user_id":null,"body":"Require Import Preloaded.\nFrom Coq Require Import List.\nImport ListNotations.\n\n\nLemma elem_index_spec : forall {A} (eq_dec : forall x y : A,\n  {x = y} + {x <> y}) n l,\n  match elem_index eq_dec n l with\n  | Some i => exists xs0 xs1, l = xs0 ++ n :: xs1 \/\\\n      length xs0 = i \/\\ ~ In n xs0\n  | None => ~ In n l\n  end.\nProof.\n  induction l; simpl; auto.\n  \n  destruct (eq_dec n a); simpl.\n  - subst.\n    exists []; exists l; split; auto.\n  - destruct (elem_index eq_dec n l).\n    + destruct IHl as [l1 [l2 [H1 [H2 H3]]]]; subst.\n      eexists; eexists; simpl.\n      split.\n      rewrite app_comm_cons.\n      reflexivity.\n      split; simpl; [reflexivity|].\n      intro Ht; destruct Ht; subst; contradiction.\n    + intro Hc; destruct Hc; subst; contradiction.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33092,"user_id":null,"body":"Require Import Preloaded.\nFrom Coq Require Import List.\nImport ListNotations.\n\nLemma elem_index_spec : forall {A} (eq_dec : forall x y : A,\n  {x = y} + {x <> y}) n l,\n  match elem_index eq_dec n l with\n  | Some i => exists xs0 xs1, l = xs0 ++ n :: xs1 \/\\\n      length xs0 = i \/\\ ~ In n xs0\n  | None => ~ In n l\n  end.\nProof.\n  intros; induction l.\n  - simpl; intros F; exact F.\n  - simpl; destruct (eq_dec n a).\n    + exists [], l; simpl; rewrite e; split; try split; try reflexivity; intros F; exact F.\n    + destruct (elem_index eq_dec n l).\n      * destruct IHl, H, H, H0; exists (a :: x), x0.\n        simpl; rewrite H, H0; split; try split; try reflexivity.\n        intros F; destruct F.\n          { rewrite H2 in n0; case (n0 eq_refl). }\n          { case (H1 H2). }\n      * intros F; destruct F.\n          { rewrite H in n0; case (n0 eq_refl). }\n          { case (IHl H). }\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5de035e4b0285b002248ff7c":[{"id":33093,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Lia Arith List.\nImport ListNotations.\n\n\nLemma Subseq_nil_l : forall {A} (xs : list A), Subseq [] xs.\nProof.\n  induction xs; [apply Subseq_nil|now apply Subseq_drop].\nQed.\n\nLemma Subseq_skipn : forall {A} (xs ys : list A), Subseq xs ys -> forall n, Subseq (skipn n xs) ys.\nProof.\n  intros A xs ys Hxy; induction Hxy.\n  - intros [|n]; apply Subseq_nil.\n  - intros [|n]; [apply Subseq_take, Hxy|apply Subseq_drop, IHHxy].\n  - intros n; apply Subseq_drop, IHHxy.\nQed.\n\nLemma Subseq_drop_l : forall {A} (x : A) xs ys, Subseq (x :: xs) ys -> Subseq xs ys.\nProof.\n  intros; exact (Subseq_skipn _ _ H 1).\nQed.\n\nLemma Subseq_cons_inv : forall {A} (x : A) xs ys, Subseq (x :: xs) (x :: ys) -> Subseq xs ys.\nProof.\n  intros; inversion H; subst; [easy|].\n  now apply Subseq_drop_l in H2.\nQed.\n\nLemma lcs_sym : forall {A} (zs xs ys : list A), IsLCS zs xs ys -> IsLCS zs ys xs.\nProof.\n  intros A zs xs ys [Hzx [Hzy Hmin]].\n  split; [exact Hzy|split; [exact Hzx|]].\n  intros; now apply Hmin.\nQed.\n\nLemma lcs_nil : forall {A} (xs : list A), IsLCS [] [] xs.\nProof.\n  split; [apply Subseq_nil|split]; [apply Subseq_nil_l|].\n  intros zs Hz; now inversion Hz.\nQed.\n\nLemma lcs_take : forall {A} (zs xs ys : list A) z, IsLCS zs xs ys -> IsLCS (z :: zs) (z :: xs) (z :: ys).\nProof.\n  intros A zs xs ys z [Hzx [Hzy Hmin]].\n  split; [apply Subseq_take, Hzx|split; [apply Subseq_take, Hzy|]].\n  intros zs' Hzx' Hzy'; inversion Hzx'; subst; [|inversion Hzy'; subst].\n  - apply le_n_S, Hmin; [easy|].\n    now apply Subseq_cons_inv in Hzy'.\n  - apply le_n_S, Hmin; [|easy].\n    now apply Subseq_cons_inv in Hzx'.\n  - now apply le_S, Hmin.\nQed.\n\nLemma lcs_pick : forall {A} (s1 s2 xs ys : list A) x y, x <> y -> length s2 <= length s1 ->\n  IsLCS s1 (x :: xs) ys -> IsLCS s2 xs (y :: ys) -> IsLCS s1 (x :: xs) (y :: ys).\nProof.\n  intros A s1 s2 xs ys x y neq Hle [Hxs1 [Hys1 Hmin1]] [Hxs2 [Hys2 Hmin2]].\n  split; [apply Hxs1|split; [apply Subseq_drop, Hys1|]].\n  intros zs' Hzx' Hzy'; inversion Hzy'; subst; [|now apply Hmin1].\n  transitivity (length s2); [|easy].\n  apply Hmin2; [|easy].\n  inversion Hzx'; now subst.\nQed.\n\nTheorem lcs_correct {A : Type} (eq_dec : forall x y : A, {x = y} + {x <> y}) xs ys :\n  IsLCS (lcs eq_dec xs ys) xs ys.\nProof.\n  revert ys; induction xs as [|x xs]; intros ys; [|induction ys as [|y ys]].\n  - rewrite lcs_equation_1; apply lcs_nil.\n  - rewrite lcs_equation_2; apply lcs_sym, lcs_nil.\n  - rewrite lcs_equation_3; destruct (eq_dec x y) as [eq|neq]; [subst|].\n    + apply lcs_take, IHxs.\n    + simpl; set (s1 := lcs eq_dec (x :: xs) ys); set (s2 := lcs eq_dec xs (y :: ys)).\n      destruct (lt_dec (length s1) (length s2)) as [Hlt|Hnlt].\n      * apply Nat.ltb_lt in Hlt; rewrite Hlt; apply Nat.ltb_lt in Hlt.\n        apply lcs_sym, (lcs_pick _ s1); [now contradict neq|apply Nat.lt_le_incl, Hlt|apply lcs_sym, IHxs|apply lcs_sym, IHys].\n      * apply not_lt, Nat.ltb_ge in Hnlt; rewrite Hnlt; apply Nat.ltb_ge in Hnlt.\n        apply (lcs_pick _ s2); try easy; apply IHxs.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33094,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Lia Arith List.\nImport ListNotations.\n\nCheck lcs_equation_1. \nCheck lcs_equation_2. \nCheck lcs_equation_3. \n\nHint Constructors Subseq : core.\n\nLemma subseq_drop_head {A : Type} (eq_dec : forall x y : A, {x = y} + {x <> y}) : forall (x : A) (xs ys : list A), Subseq (x :: xs) ys -> Subseq xs ys.\nProof.\n  intros.\n  generalize dependent xs.\n  induction ys; intros.\n  - inversion H.\n  - inversion H; subst.\n    + apply Subseq_drop. assumption.\n    + apply Subseq_drop. apply IHys. auto.\nQed.\n\nLemma subseq_empty {A : Type} : forall (xs : list A), Subseq [] xs.\nProof.\n  intros; induction xs; auto.\nQed.\n\nLemma lcs_subseq_xs {A : Type} (eq_dec : forall x y : A, {x = y} + {x <> y}) xs ys : Subseq (lcs eq_dec xs ys) xs.\nProof.\n  generalize dependent ys. induction xs; intros.\n  rewrite lcs_equation_1; apply Subseq_nil.\n\n  induction ys; intros.\n  - rewrite lcs_equation_2; apply subseq_empty.\n  - rename a into x; rename a0 into y.\n    rewrite lcs_equation_3.\n    destruct (eq_dec x y).\n    + apply Subseq_take. apply IHxs.\n    + simpl. destruct (length (lcs eq_dec (x :: xs) ys) <? length (lcs eq_dec xs (y :: ys))).\n      apply Subseq_drop. apply IHxs.\n      apply IHys.\nQed.\n\nLemma lcs_subseq_ys {A : Type} (eq_dec : forall x y : A, {x = y} + {x <> y}) xs ys : Subseq (lcs eq_dec xs ys) ys.\nProof.\n  generalize dependent ys. induction xs; intros.\n  rewrite lcs_equation_1; apply subseq_empty.\n\n  induction ys; intros.\n  - rewrite lcs_equation_2; apply Subseq_nil.\n  - rename a into x; rename a0 into y.\n    rewrite lcs_equation_3.\n    destruct (eq_dec x y).\n    + subst. apply Subseq_take. apply IHxs.\n    + simpl. destruct (length (lcs eq_dec (x :: xs) ys) <? length (lcs eq_dec xs (y :: ys))).\n      apply IHxs.\n      apply Subseq_drop. apply IHys.\nQed.\n\nDefinition l1 := [1; 2; 5; 7; 9].\nDefinition l2 := [1; 2; 6; 8; 9].\nCompute (lcs Nat.eq_dec l1 l2).\nCheck (lcs_subseq_ys Nat.eq_dec l1 l2).\n\n\nTheorem lcs_correct {A : Type} (eq_dec : forall x y : A, {x = y} + {x <> y}) xs ys :\n  IsLCS (lcs eq_dec xs ys) xs ys.\nProof. \n  split.\n  apply lcs_subseq_xs.\n  split.\n  apply lcs_subseq_ys.\n  \n  intros zs Hzx Hzy.\n  generalize dependent zs.\n  generalize dependent ys. induction xs; intros.\n  inversion Hzx; subst. simpl; lia. \n  \n  rename a into x.\n  generalize dependent zs. \n  induction ys; intros.\n  inversion Hzy; subst. simpl; lia.\n  rename a into y.\n  rewrite lcs_equation_3. destruct (eq_dec x y).\n  - (* What if heads of xs and ys are the same? \n       Then \n    *)\n    subst. simpl. \n    destruct zs as [|z zs]. simpl. lia.\n    inversion Hzx; subst.\n    inversion Hzy; subst.\n    + simpl. pose proof (IHxs ys zs H0 H1). lia.\n    + simpl. apply (subseq_drop_head eq_dec) in H2. pose proof (IHxs ys zs H0 H2). lia. \n    + simpl. apply (subseq_drop_head eq_dec) in H1. \n      inversion Hzy; subst. pose proof (IHxs ys zs H1 H0). lia. apply (subseq_drop_head eq_dec) in H2. pose proof (IHxs ys zs H1 H2). lia.\n  - (* What if heads of xs and ys are not the same? \n    *)\n    simpl. destruct (length (lcs eq_dec (x :: xs) ys) <? length (lcs eq_dec xs (y :: ys))) eqn:?.\n    + destruct zs as [|z zs]. { simpl; lia. }\n      inversion Hzx; subst. \n      apply Nat.ltb_lt in Heqb.\n      assert (length (x :: zs) <= length (lcs eq_dec (x:: xs) ys)). { specialize IHys with (x :: zs). apply IHys; auto. inversion Hzy; subst. exfalso; auto. auto. } lia.\n      specialize IHxs with (y :: ys) (z :: zs). apply IHxs; auto.\n    + destruct zs as [|z zs]. { simpl; lia. }\n      inversion Hzy; subst.\n      apply Nat.ltb_ge in Heqb.\n      assert (length (y :: zs) <= length (lcs eq_dec xs (y :: ys))). { specialize IHxs with (y :: ys) (y :: zs). inversion Hzx; subst. exfalso; auto. apply IHxs; auto. } lia.\n      pose proof (IHys (z :: zs) Hzx H1). assumption.\nQed.\n            \n  \n  \n  \n\n  \n\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33095,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Lia Arith List.\nImport ListNotations.\n\nHint Constructors Subseq.\n\nLemma subseq_empty : forall A (l : list A), Subseq [] l.\nProof.\n  induction l; auto.\nQed.\n\nHint Resolve subseq_empty.\n\nLemma subseq_drop_l : forall A (xs ys : list A) x,\n  Subseq (x :: xs) ys -> Subseq xs ys.\nProof.\n  intros.\n  remember (x :: xs) as xxs.\n  induction H.\n  - discriminate.\n  - inversion Heqxxs. subst.\n    constructor. auto.\n  - constructor. auto.\nQed.\n\nLemma subseq_drop : forall A (xs ys : list A) x y,\n  Subseq (x :: xs) (y :: ys) -> Subseq xs ys.\nProof.\n  intros.\n  remember (x :: xs) as xxs.\n  remember (y :: ys) as yys.\n  induction H.\n  - discriminate.\n  - inversion Heqxxs. inversion Heqyys. subst. auto.\n  - inversion Heqyys. subst.\n    eauto using subseq_drop_l.\nQed.\n\nLtac solve_by_ind := match goal with\n  | IH : Type -> _, A : Type |- Subseq (lcs ?e ?x ?y) ?x =>\n      destruct (IH A e x y); auto; cbn in *; lia\n  | IH : Type -> _, A : Type |- Subseq (lcs ?e ?x ?y) ?y =>\n      destruct (IH A e x y) as [_ [?H _]]; auto; cbn in *; lia\n  | IH : Type -> _, A : Type |- _ <= length (lcs ?e ?x ?y) =>\n      destruct (IH A e x y) as [_ [_ ?H]]; auto; cbn in *; lia\n  end.\n\nLemma lcs_correct':\n  forall n {A} (eq_dec : forall x y : A, {x = y} + {x <> y}) xs ys,\n  length xs + length ys <= n -> IsLCS (lcs eq_dec xs ys) xs ys.\nProof with auto.\n  induction n; intros.\n  - destruct xs; destruct ys; cbn in H; try lia.\n    rewrite lcs_equation_1.\n    repeat split; auto.\n    intros.\n    inversion H0. auto.\n  - repeat split.\n    + destruct xs. rewrite lcs_equation_1...\n      destruct ys. rewrite lcs_equation_2...\n      rewrite lcs_equation_3.\n      destruct (eq_dec a a0).\n      * constructor.\n        solve_by_ind.\n      * cbn.\n        destruct (length (lcs eq_dec xs (a0 :: ys))) eqn:Hl1.\n          solve_by_ind.\n        destruct (length (lcs eq_dec (a :: xs) ys) <=? n1) eqn:Hl2;\n          [constructor|]; solve_by_ind.\n    + destruct xs. rewrite lcs_equation_1...\n      destruct ys. rewrite lcs_equation_2...\n      rewrite lcs_equation_3.\n      destruct (eq_dec a a0).\n      * subst. constructor.\n        solve_by_ind.\n      * cbn.\n        destruct (length (lcs eq_dec xs (a0 :: ys))) eqn:Hl1.\n        { constructor. solve_by_ind. }\n        destruct (length (lcs eq_dec (a :: xs) ys) <=? n1) eqn:Hl2;\n          [|constructor]; solve_by_ind.\n    + intros.\n      destruct xs. inversion H0...\n      destruct ys. inversion H1...\n      destruct zs'. cbn; lia.\n      rewrite lcs_equation_3.\n      destruct (eq_dec a a0).\n      * subst. cbn.\n        apply subseq_drop in H0.\n        apply subseq_drop in H1.\n        apply le_n_S.\n        solve_by_ind.\n      * destruct (eq_dec a0 a1).\n        {\n          inversion H0; subst. contradiction.\n          destruct (IHn A eq_dec xs (a1 :: ys)) as [_ [_ IH]].\n            cbn in *; lia.\n          specialize (IH (a1 :: zs') H4 H1).\n          cbn.\n          destruct (length (lcs eq_dec xs (a1 :: ys))) eqn:Hl1.\n            cbn in *; lia.\n          destruct (length (lcs eq_dec (a :: xs) ys) <=? n1) eqn:Hl2.\n          - rewrite Hl1.\n            cbn in IH. auto.\n          - apply leb_complete_conv in Hl2.\n            cbn in IH. lia.\n        }\n        {\n          inversion H1; subst. contradiction.\n          destruct (IHn A eq_dec (a :: xs) ys) as [_ [_ IH]].\n            cbn in *; lia.\n          specialize (IH (a1 :: zs') H0 H4).\n          cbn.\n          destruct (length (lcs eq_dec xs (a0 :: ys))) eqn:Hl1.\n            cbn in *; lia.\n          destruct (length (lcs eq_dec (a :: xs) ys) <=? n2) eqn:Hl2.\n          - apply leb_complete in Hl2.\n            cbn in IH. lia.\n          - apply leb_complete_conv in Hl2.\n            cbn in IH. lia.\n        }\nQed.\n\nTheorem lcs_correct {A : Type} (eq_dec : forall x y : A, {x = y} + {x <> y}) xs ys :\n  IsLCS (lcs eq_dec xs ys) xs ys.\nProof.\n  intros.\n  eauto using lcs_correct'.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33096,"user_id":null,"body":"Require Import Preloaded Arith List Lia.\nFrom Equations Require Import Equations.\nImport ListNotations.\n\nLemma Subseq_nil_l : forall {A} (l : list A), Subseq [] l.\nProof.\n  induction l.\n  - constructor.\n  - constructor. assumption.\nQed.\n\nLemma Subseq_elim_cons_l : forall {A} a (l1 l2 : list A),\n  Subseq (a :: l1) l2 -> Subseq l1 l2.\nProof.\n  intros. revert dependent a. induction l2; intros.\n  - inversion H.\n  - inversion H; subst.\n    + constructor. assumption.\n    + constructor. eapply IHl2. eassumption.\nQed.\n\nLemma Subseq_elim_cons : forall {A} a1 a2 (l1 l2 : list A),\n  Subseq (a1 :: l1) (a2 :: l2) -> Subseq l1 l2.\nProof.\n  intros. inversion H; subst.\n  - assumption.\n  - apply Subseq_elim_cons_l in H2. assumption.\nQed.\n\nLemma Subseq_elim_cons_neq : forall {A} a1 a2 (l1 l2 : list A),\n  a1 <> a2 ->\n  Subseq (a1 :: l1) (a2 :: l2) -> Subseq (a1 :: l1) l2.\nProof.\n  intros. inversion H0; subst.\n  - contradiction.\n  - assumption.\nQed.\n\nTheorem lcs_correct : forall {A : Type} (eq_dec : forall x y : A, {x = y} + {x <> y}) xs ys,\n  IsLCS (lcs eq_dec xs ys) xs ys.\nProof.\n  (* Strangely, [funelim (lcs eq_dec xs ys)] does not go through [Qed]. *)\n  apply lcs_elim with (P := fun _ _ xs ys l => IsLCS l xs ys); intros.\n  - split; [|split].\n    + constructor.\n    + apply Subseq_nil_l.\n    + intros. inversion H; subst. apply le_0_n.\n  - split; [|split].\n    + apply Subseq_nil_l.\n    + constructor.\n    + intros. inversion H0; subst. apply le_n.\n  - destruct (eq_dec a a0).\n    + specialize (H e). destruct H as (HH1 & HH2 & HH3).\n      subst.\n      split; [|split].\n      * constructor. assumption.\n      * constructor. assumption.\n      * intros. destruct zs'.\n        -- apply le_0_n.\n        -- apply Subseq_elim_cons in H.\n           apply Subseq_elim_cons in H2.\n           cbn. apply le_n_S. eauto.\n    + specialize (H0 n). specialize (H1 n).\n      set (s1 := lcs eq_dec (a::l) l0) in *.\n      set (s2 := lcs eq_dec l (a0::l0)) in *.\n      destruct H0 as (H01 & H02 & H03).\n      destruct H1 as (H11 & H12 & H13).\n      cbn zeta.\n      destruct (Nat.ltb_spec (length s1) (length s2)).\n      * split; [|split].\n        -- constructor. assumption.\n        -- assumption.\n        -- intros. inversion H1; subst.\n           ++ apply Subseq_elim_cons_neq in H2; try assumption.\n              specialize (H03 _ H1 H2). lia.\n           ++ auto.\n      * split; [|split].\n        -- assumption.\n        -- constructor. assumption.\n        -- intros. inversion H1; subst.\n           ++ apply Subseq_elim_cons_neq in H2; try assumption.\n              specialize (H03 _ H1 H2). assumption.\n           ++ rewrite <- H0. eauto.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33097,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Lia Arith List Wf.\nFrom Equations Require Import Equations.\nImport ListNotations.\n\n  \nLemma lcs_nil_r: forall A eq_dec (l : list A),\n  lcs eq_dec l [] = [].\nProof.\n  intros.\n  destruct l; auto.\nQed.\n\nLemma Subseq_l_nil: forall T (l : list T), Subseq nil l.\nProof.\n  intros.\n  induction l; constructor; auto.\nQed.\n\nLemma subseq_cons_l: forall T (l1 l2 : list T) a, Subseq (a :: l1) l2 -> Subseq l1 l2.\nProof.\n  intros.\n  generalize dependent a.\n  generalize dependent l1.\n  induction l2; intros.\n    inversion H.\n  inversion H; subst.\n    constructor. auto.\n  constructor.\n  eapply IHl2.\n  apply H2.\nQed.\n\nTheorem lcs_correct {A : Type} (eq_dec : forall x y : A, {x = y} + {x <> y}) xs ys :\n  IsLCS (lcs eq_dec xs ys) xs ys.\nProof.\n  unfold IsLCS.\n  remember(length xs + length ys).\n  generalize dependent xs.\n  generalize dependent ys.\n  induction n as [n Heqn] using (well_founded_induction lt_wf).\n  intros xs ys H.\n  destruct n; intros.\n  {\n    destruct xs; [|simpl in H; lia].\n    destruct ys; [|simpl in H; lia].\n    do 2 (split; [ constructor|]).\n    intros. inversion H0.\n    simpl. lia.\n  }\n  destruct xs.\n  {\n    rewrite lcs_nil_r.\n    split. apply Subseq_l_nil.\n    split. constructor. intros.\n    inversion H1. auto.\n  }\n  destruct ys.\n  {\n    rewrite lcs_equation_1. simpl.\n    split. constructor.\n    split. apply Subseq_l_nil. \n    intros.\n    inversion H0. auto.\n  }\n  simpl in H.\n  rewrite lcs_equation_3.\n  destruct(eq_dec a0 a).\n  {\n    subst.\n    destruct Heqn with (length ys + length xs) xs ys; auto.\n      lia.\n    destruct H1.\n    do 2 (split; [constructor; auto |]).\n    intros.\n    simpl.\n    inversion H3; subst; simpl.\n    {\n      apply Peano.le_n_S.\n      inversion H4; subst; auto.\n      apply subseq_cons_l in H8; auto.\n    }\n    inversion H4; subst; auto.\n    simpl.\n    apply Peano.le_n_S.\n    apply subseq_cons_l in H7; auto.\n  }\n  simpl.\n  destruct(length (lcs eq_dec (a0 :: ys) xs) <? length (lcs eq_dec ys (a :: xs))) eqn:e.\n  {\n    destruct Heqn with (length (a::xs) + length ys) (a :: xs) ys; simpl; try lia.\n    destruct H1.\n    split. constructor. auto.\n    split. auto.\n    intros.\n    apply Nat.ltb_lt in e.\n    inversion H3; subst; auto.\n    inversion H4; subst. intuition.\n    apply le_trans with (length (lcs eq_dec (a0 :: ys) xs)); [|lia].\n    destruct Heqn with (length xs + length (a0 :: ys)) xs (a0 :: ys). \n      simpl. lia. simpl. lia.\n    apply H6; auto.\n  }\n  destruct Heqn with (length xs + length (a0 :: ys)) xs (a0 :: ys); simpl; try lia.\n  destruct H1.\n  split. auto.\n  split. constructor. auto.\n  intros.\n  apply Nat.ltb_ge in e.\n  inversion H4; subst; auto.\n  inversion H3; subst. intuition.\n  apply le_trans with (length (lcs eq_dec ys (a :: xs))); auto.\n  destruct Heqn with (length (a::xs) + length ys) (a::xs) ys.\n    simpl. lia. simpl. lia.\n  apply H6; auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33098,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Lia Arith List.\nImport ListNotations.\n\nLemma nil_subseq : forall A (l:list A), Subseq [] l.\nProof. induction l;intros;constructor;assumption. Qed.\n\nCreate HintDb subseq_hints.\n\nHint Constructors Subseq : subseq_hints.\nHint Immediate nil_subseq : subseq_hints.\n\nLemma subseq_step : forall A (a:A) l1 l2, \n (Subseq (a::l1) (a::l2) \\\/ Subseq (a::l1) l2) -> \n Subseq l1 l2.\nProof. intros A a l1 l2. remember (length l1 + length l2).\n generalize dependent l2;generalize dependent l1;generalize dependent a.\n induction n using lt_wf_ind;intros.\n destruct l1;[auto with subseq_hints|].\n destruct H0.\n * inversion H0;subst;[assumption|]. inversion H3;subst.\n  + inversion H5;subst.\n   - do 2 constructor;assumption.\n   - constructor. eapply H;[|reflexivity|];[simpl;lia| ..].\n     left. apply H3.\n  + constructor. eapply H;[|reflexivity|];[simpl;lia| ..].\n    right. apply H1.\n * inversion H0;subst.\n  + inversion H4;subst.\n   - do 2 constructor;assumption.\n   - constructor. eapply H;[|reflexivity|];[simpl;lia| ..].\n     left. apply H0.\n  + constructor. eapply H;[|reflexivity|];[simpl;lia| ..].\n    right. apply H1.\nQed.\n\nLemma subseq_step_eq : forall A (a:A) l1 l2,\n Subseq (a::l1) (a::l2) -> Subseq l1 l2.\nProof. intros;eapply subseq_step. left;apply H. Qed.\nLemma subseq_step_lf : forall A (a:A) l1 l2,\n Subseq (a::l1) l2 -> Subseq l1 l2.\nProof. intros;eapply subseq_step. right;apply H. Qed. \n\nLemma le_trans : forall n m p, n <= m -> m <= p -> n <= p.\nProof. lia. Qed.\n\nTheorem lcs_correct {A : Type}\n (eq_dec : forall x y : A, {x = y} + {x <> y}) xs ys :\n  IsLCS (lcs eq_dec xs ys) xs ys.\nProof.\n remember (length xs + length ys);generalize dependent ys;generalize dependent xs.\n induction n using lt_wf_ind.\n destruct xs;intros.\n * rewrite lcs_equation_1. (repeat split);auto with subseq_hints.\n   inversion 1;constructor.\n * destruct ys.\n  + rewrite lcs_equation_2. (repeat split);auto with subseq_hints.\n    inversion 2;constructor.\n  + rewrite lcs_equation_3. destruct (eq_dec a a0).\n   - subst.\n     edestruct (H (length xs + length ys)) as [Sx [Sy Hi]];\n     [simpl;lia|reflexivity|].\n     (repeat split);auto with subseq_hints.\n     intros. inversion H0;inversion H1;subst;\n     [apply le_n_S.. |apply le_S];apply Hi;\n     (try assumption);apply (subseq_step_eq _ a0);assumption.\n   - simpl. remember (length (lcs eq_dec (a :: xs) ys) <? \n                      length (lcs eq_dec xs (a0 :: ys))).\n     edestruct (H (length xs + length (a0 ::ys))) as [Sxl [Syl Hil]];\n     [simpl in *;lia|reflexivity|].\n     edestruct (H (length (a  ::xs) + length ys)) as [Sxr [Syr Hir]];\n     [simpl in *;lia|reflexivity|].\n     destruct b;(repeat split);auto with subseq_hints;intros;\n     inversion H0;subst;inversion H1;subst.\n     ** contradiction.\n     ** eapply le_trans;[apply Hir;assumption|].\n        symmetry in Heqb;apply Nat.ltb_lt in Heqb. apply le_Sn_le. assumption.\n     ** apply Hil;assumption.\n     ** apply Hil;assumption.\n     ** contradiction.\n     ** apply Hir;assumption.\n     ** eapply le_trans. apply Hil;assumption.\n        symmetry in Heqb;apply Nat.ltb_ge in Heqb. assumption.\n     ** apply Hir;assumption.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33099,"user_id":168,"body":"Require Import Preloaded.\nRequire Import Lia Arith List ssreflect.\nImport ListNotations.\n\nHint Constructors Subseq : core.\n\nLemma subseq_nil {A} (l : list A) : Subseq [] l.\nProof. by elim: l; auto. Qed.\n\nHint Resolve subseq_nil : core.\n\nLemma subseq_of_nil {A} (s : list A) : Subseq s [] <-> s = [].\nProof. by split => [H | -> \/\/]; inversion H. Qed.\n\nLemma subseq_cons_inv {A} (x : A) xs ys :\n  Subseq (x :: xs) ys -> Subseq xs ys.\nProof.\n  elim: xs x ys => \/\/; intros.\n  elim: ys H0; intros; first easy.\n  by inversion H1; subst; eauto.\nQed.\n\nLemma subseq_cons2_inv {A} (x : A) s l :\n  Subseq (x :: s) (x :: l) -> Subseq s l.\nProof. by move => H; inversion H; subst => \/\/; eauto using subseq_cons_inv. Qed.\n\nLemma lcs_subseq {A} (eq_dec : forall x y : A, {x = y} + {x <> y}) xs ys :\n  Subseq (lcs eq_dec xs ys) xs \/\\ Subseq (lcs eq_dec xs ys) ys.\nProof.\n  elim: xs ys => [| x xs IH1]; elim => [| y ys IH2];\n             rewrite (lcs_equation_1, lcs_equation_2, lcs_equation_3) \/\/.\n  case: (eq_dec x y) => eq.\n  - by rewrite eq; intuition.\n  - by simpl; case: Nat.ltb_spec => _; intuition.\nQed.\n\nTheorem lcs_correct {A} (eq_dec : forall x y : A, {x = y} + {x <> y}) xs ys :\n  IsLCS (lcs eq_dec xs ys) xs ys.\nProof.\n  move eq: (length xs + length ys) => n.\n  elim\/lt_wf_ind: n xs ys eq => n IH xs ys Heq; unfold IsLCS.\n  have [H1 H2] := lcs_subseq eq_dec xs ys.\n  do !split => \/\/; move => {H1 H2}.\n  case: xs ys Heq => [| x xs]; case => [| y ys] \/= Heq zs;\n    try (rewrite subseq_of_nil; intros; subst; simpl; lia).\n  case: zs => [\/= | z zs]; first by lia.\n  rewrite lcs_equation_3 \/= => H1 H2.\n  case: (eq_dec x y) => Hxy.\n  + have\/IH: length xs + length ys < n by lia.\n    move\/(_ xs ys eq_refl) => [_] [_] \/(_ zs) H.\n    suff: Subseq zs xs \/\\ Subseq zs ys by move => [] \/H {H} H4 \/H4 \/=; lia.\n    by inversion H1; inversion H2; eauto using subseq_cons_inv.\n  + inversion H1; inversion H2; subst; try congruence;\n      pose n := S (length xs + S (length ys)).\n    * have\/IH: S (length xs) + length ys < n by lia.\n      move\/(_ (x :: xs) ys eq_refl) => [_] [_] \/(_ (x :: zs) _ H8) H.\n      have\/H: Subseq (x :: zs) (x :: xs) by [].\n      by simpl; case: Nat.ltb_spec; lia.\n    * have\/IH: length xs + S (length ys) < n by lia.\n      move\/(_ xs (y :: ys) eq_refl) => [_] [_] \/(_ (y :: zs) H3) H.\n      have\/H: Subseq (y :: zs) (y :: ys) by [].\n      by simpl; case: Nat.ltb_spec; lia.\n    * have\/IH: S (length xs) + length ys < n by lia.\n      move\/(_ (x :: xs) ys eq_refl) => [_] [_] \/(_ (z :: zs) _ H7) H.\n      have\/H: Subseq (z :: zs) (x :: xs) by [].\n      by simpl; case: Nat.ltb_spec; lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33100,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Coq.Arith.Arith Coq.Bool.Bool.\n\nLemma subseq_nil {A} (xs : list A) : Subseq nil xs.\nProof.\n  induction xs; constructor; assumption.\nQed.\n\nLemma subseq_cons {A} (a : A) xs ys : Subseq (a :: xs) ys -> Subseq xs ys.\nProof.\n  revert a xs.\n  induction ys; inversion 1; subst; constructor; eauto.\nQed.\n\nTheorem lcs_correct {A : Type} (eq_dec : forall x y : A, {x = y} + {x <> y}) :\n  forall xs ys, IsLCS (lcs eq_dec xs ys) xs ys.\nProof.\n  induction xs.\n  - intro ys.\n    rewrite lcs_equation_1.\n    repeat constructor.\n    + apply subseq_nil.\n    + inversion 1.\n      constructor.\n  - induction ys.\n    + rewrite lcs_equation_2.\n      repeat constructor.\n      * apply subseq_nil.\n      * inversion 2.\n        constructor.\n    + rewrite lcs_equation_3.\n      destruct (eq_dec _ _).\n      * subst.\n        repeat split.\n        1, 2: constructor; apply IHxs.\n        -- inversion 1; inversion 1; subst; apply le_n_S || apply le_S;\n             apply IHxs; eauto using subseq_cons.\n      * simpl.\n        remember (_ <? _) as b.\n        destruct b; symmetry in Heqb; repeat split.\n        -- constructor.\n           apply IHxs.\n        -- apply IHxs.\n        -- inversion 1.\n           ++ inversion 1; subst; eapply le_trans, Nat.ltb_lt, Heqb;\n                apply le_n_S, IHys; eauto using subseq_cons.\n           ++ inversion 1; subst; apply IHxs; assumption.\n        -- apply IHys.\n        -- constructor.\n           apply IHys.\n        -- inversion 1.\n           ++ inversion 1; subst.\n              ** congruence.\n              ** apply IHys; assumption.\n           ++ apply not_true_iff_false in Heqb.\n              rewrite Nat.ltb_lt in Heqb.\n              inversion 1; subst; eapply le_trans, not_lt, Heqb;\n                apply IHxs; assumption.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33101,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Lia Arith List.\nImport ListNotations.\n\n\nLemma subseq_nil: forall {A: Type} (xs: list A), Subseq [] xs.\nProof.\ninduction xs; eauto.\n+ constructor.\n+ constructor. assumption.\nQed.\n\nSection T.\n\nVariable A : Type.\nHypothesis eq_dec: forall x y: A, {x = y} + {x <> y}.\n\nLemma lcs_subseq_l: forall xs ys, Subseq (lcs eq_dec xs ys) xs.\nProof.\ninduction xs; intros.\n+ constructor.\n+ rewrite lcs_unfold_eq. induction ys; simpl.\n  - apply subseq_nil.\n  - destruct eq_dec. constructor. eauto.\n    destruct Nat.ltb.\n    * eapply Subseq_drop. eauto.\n    * rewrite lcs_unfold_eq. assumption.\nQed.\n\n(* Symmetric proof but lcs is *not* symmetric *)\nLemma lcs_subseq_r: forall ys xs, Subseq (lcs eq_dec xs ys) ys.\nProof.\ninduction ys; intros.\n+ destruct xs; constructor.\n+ rewrite lcs_unfold_eq. induction xs; simpl.\n  - apply subseq_nil.\n  - destruct eq_dec.\n    -- subst. constructor. eauto.\n    -- destruct Nat.ltb.\n       * rewrite lcs_unfold_eq. assumption.\n       * eapply Subseq_drop. eauto.\nQed.\n\nLemma subseq_cons: forall ys xs (a: A), Subseq (a :: xs) ys -> Subseq xs ys.\nProof.\ninduction ys.\n+ intros. inversion H.\n+ intros. inversion H; subst.\n  eapply Subseq_drop. assumption.\n  eapply IHys in H2. eapply Subseq_drop. assumption.\nQed.\n\nLemma subseq_cons2: forall x1 x2 a1 (a2: A), \n  Subseq (a1 :: x1) (a2 :: x2) -> a1 <> a2 -> Subseq (a1 :: x1) x2.\nProof.\ninduction x1; intros.\n+ inversion H; subst; eauto. destruct H0. reflexivity.\n+ inversion H; subst; eauto. destruct H0. reflexivity.\nQed.\n\nLemma lcs_min: forall xs ys zs' : list A, \n  Subseq zs' xs -> Subseq zs' ys -> length zs' <= length (lcs eq_dec xs ys).\nProof.\ninduction xs.\n+ intros. inversion H. subst.\n  eauto.\n+ intros. inversion H.\n  - subst. induction ys.\n    * inversion H0.\n    * rewrite lcs_unfold_eq. inversion H0; subst.\n      ** simpl. destruct eq_dec; [|intuition].\n         simpl. eapply le_n_S. eauto.\n      ** simpl. destruct eq_dec. \n         -- subst. simpl. eapply le_n_S. assert (Subseq xs0 ys). { eapply subseq_cons; eauto. } \n            eauto.\n         -- destruct Nat.ltb eqn:Hlt.\n            ++ eapply IHys in H4. eapply Nat.ltb_lt in Hlt.\n               simpl in H4. lia.\n            ++ eapply IHys. assumption.\n  - subst. induction ys.\n    * inversion H0. eauto.\n    * rewrite lcs_unfold_eq. inversion H0; subst.\n      ** simpl. destruct eq_dec.\n         -- subst. simpl. eapply subseq_cons in H3. eapply le_n_S; eauto.\n         -- destruct Nat.ltb eqn:Hlt.\n            ++ assert (Subseq (a0 :: xs0) xs). { eapply subseq_cons2; eauto. }\n               assert (Subseq (a0 :: xs0) (a0 :: ys)). { constructor. assumption. }\n               eapply IHxs in H2; eauto.\n            ++ eapply Nat.ltb_ge in Hlt. eapply le_trans; try eapply Hlt.\n               replace (S (length xs0)) with (length (a0 :: xs0)). eapply IHxs; eauto.\n               reflexivity.\n     ** simpl. destruct eq_dec.\n        -- subst. simpl. eauto.\n        -- destruct Nat.ltb eqn:Hlt; eauto.\nQed.\n\nEnd T.\n\nTheorem lcs_correct {A : Type} (eq_dec : forall x y : A, {x = y} + {x <> y}) xs ys :\n  IsLCS (lcs eq_dec xs ys) xs ys.\nProof.\nsplit; [|split].\n- apply lcs_subseq_l.\n- apply lcs_subseq_r.\n- apply lcs_min.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33102,"user_id":17,"body":"Require Import Preloaded.\nFrom Coq Require Import PeanoNat List Lia Program Bool.\nImport ListNotations.\n\nHint Constructors Subseq.\n\nLtac inv H := inversion H; subst; clear H.\n\nLemma Subseq_nil' : forall {A} (l : list A), Subseq [] l.\nProof. induction l; auto. Qed.\n\nHint Resolve Subseq_nil'.\n\nLemma Subseq_drop' : forall {A} (x : A) xs ys,\n  Subseq (x :: xs) ys -> Subseq xs ys.\nProof. intros; dependent induction H; eauto. Qed.\n\nHint Resolve Subseq_drop'.\n\nLemma lcs_correct' : forall {A} (eq_dec : forall x y : A,\n  {x = y} + {x <> y}) n xs ys,\n  length xs + length ys <= n ->\n  IsLCS (lcs eq_dec xs ys) xs ys.\nProof with eauto using le_S, le_n_S.\n  induction n; intros.\n  - destruct xs, ys; try (simpl in H; lia).\n    rewrite lcs_equation_1; unfold IsLCS; repeat split...\n    intros; inv H0...\n  - destruct xs, ys; simpl in H; try rewrite lcs_equation_1;\n      try rewrite lcs_equation_2; try rewrite lcs_equation_3;\n      try (unfold IsLCS; repeat split; auto; intros; inv H0;\n      inv H1; auto).\n    destruct (eq_dec a a0); subst.\n    + assert (length xs + length ys <= n) by lia.\n      destruct (IHn _ _ H0) as [?H [?H ?H]].\n      unfold IsLCS; repeat split...\n      intros; inv H4; inv H5...\n    + unfold IsLCS.\n      destruct (Nat.ltb_spec0\n        (length (lcs eq_dec (a :: xs) ys))\n        (length (lcs eq_dec xs (a0 :: ys)))).\n      * assert (length xs + length (a0 :: ys) <= n)\n          by (simpl; lia).\n        destruct (IHn _ _ H0) as [?H [?H ?H]].\n        repeat split...\n        intros; inv H4; inv H5; try now contradiction n0...\n        assert (length (a :: xs) + length ys <= n)\n          by (simpl; lia).\n        destruct (IHn _ _ H4) as [?H [?H ?H]].\n        assert (Subseq xs0 (a :: xs))...\n        assert (Subseq xs0 ys)...\n        specialize (H9 _ H10 H11); simpl; lia.\n      * assert (length (a :: xs) + length ys <= n)\n          by (simpl; lia).\n        destruct (IHn _ _ H0) as [?H [?H ?H]].\n        repeat split...\n        intros; inv H4; inv H5; try now contradiction n0...\n        assert (length xs + length (a0 :: ys) <= n)\n          by (simpl; lia).\n        destruct (IHn _ _ H4) as [?H [?H ?H]].\n        assert (Subseq (a0 :: xs0) (a0 :: ys))...\n        specialize (H9 _ H8 H10); simpl in *; lia.\nQed.\n\nTheorem lcs_correct {A : Type} (eq_dec : forall x y : A,\n  {x = y} + {x <> y}) xs ys : IsLCS (lcs eq_dec xs ys) xs ys.\nProof. eauto using lcs_correct'. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5e030784d7721600190aa84b":[{"id":33103,"user_id":568,"body":"Require Import Preloaded Lia.\n\nLemma l : forall t n, node t = n -> empty_place t = n + 1.\nProof.\n  intros t n <-.\n  induction t; cbn; lia.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33104,"user_id":568,"body":"(* lia-less *)\n\nRequire Import Preloaded.\n\nLemma l : forall t n, node t = n -> empty_place t = n + 1.\nProof.\n  intros t n <-.\n  induction t; cbn.\n  - reflexivity.\n  - rewrite IHt.\n    reflexivity.\n  - rewrite IHt1, IHt2.\n    repeat rewrite <- plus_n_Sm.\n    repeat rewrite <- plus_Sn_m.\n    repeat rewrite <- plus_n_O.\n    reflexivity.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33105,"user_id":106,"body":"Require Import Preloaded Lia.\n\nLemma l : forall t n, node t = n -> empty_place t = n + 1.\nProof.\n  intros; subst. induction t; simpl; lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33106,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Arith.\n\nLemma l : forall t n, node t = n -> empty_place t = n + 1.\nProof.\n  intros. rewrite <- H. clear n H. induction t.\n  - reflexivity.\n  - simpl. rewrite IHt. reflexivity.\n  - simpl. rewrite IHt1. rewrite IHt2. rewrite Nat.add_1_r. rewrite Nat.add_1_r. rewrite Nat.add_1_r.\n    simpl. rewrite Nat.add_comm. simpl. rewrite Nat.add_comm. reflexivity.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33107,"user_id":null,"body":"Require Import Preloaded.\nFrom Coq Require Import Lia.\n\n\nLemma l : forall t n, node t = n -> empty_place t = n + 1.\nProof.\n     induction t; simpl in *.\n     - lia.  \n     - intuition. rewrite IHt with (n := (node t)) by auto. lia.\n     - intuition. \n          rewrite IHt1 with (n := (node t1)) by auto.\n          rewrite IHt2 with (n := (node t2)) by auto.\n      lia.\nQed.\n      ","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33108,"user_id":null,"body":"Require Import Preloaded Lia.\nLemma l : forall t n, node t = n -> empty_place t = n + 1.\nProof. \n  intro. cut (empty_place t = node t + 1). lia.\n  induction t. auto. simpl. auto. simpl. lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33109,"user_id":null,"body":"Require Import Preloaded Lia.\nLemma l : forall t n, node t = n -> empty_place t = n + 1.\nProof. \n  induction t. \n  unfold node, empty_place. lia.\n  simpl in *. intro. specialize (IHt (n - 1)). lia.\n  simpl in *. intro. cut (empty_place t1 = node t1 + 1). cut (empty_place t2 = node t2 + 1). lia. auto. auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33110,"user_id":null,"body":"Require Import Preloaded Lia.\n\nLemma l : forall t n, node t = n -> empty_place t = n + 1.\nProof. \n    intros.\n    rewrite <- H. clear H n.\n    induction t.\n    + auto.\n    + simpl. auto.\n    + simpl. rewrite IHt1,IHt2. lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33111,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Arith Nat.\n\nLemma l1 : forall t, node t + 1 = empty_place t.\nProof.\n  intros t.\n  induction t.\n  - reflexivity.\n  - simpl. rewrite IHt. reflexivity.\n  - simpl. rewrite <- IHt1. rewrite <- IHt2. ring_simplify. reflexivity.\nQed.\n\nLemma l : forall t n, node t = n -> empty_place t = n + 1.\nProof. intros. rewrite <- H. rewrite l1. reflexivity. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33112,"user_id":null,"body":"Require Import Preloaded Lia ssreflect.\n\nLemma l : forall t n, node t = n -> empty_place t = n + 1.\nProof.\n  move => t n <-; elim: t => \/= [| ? -> | ? -> ? -> ]; by lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5e0dce514225f30001ed98bc":[{"id":33113,"user_id":168,"body":"Require Import ssreflect.\n\nTheorem is_nat_bool : (nat = bool) \\\/ (nat <> bool).\nProof.\n  right; move => eq.\n  pose P t := exists a b c : t, a <> b \/\\ b <> c \/\\ a <> c.\n  have: P nat by exists 0, 1, 2; do !split; congruence.\n  have: ~P bool by move => [a] [b] [c]; case: a b c; case; case; tauto.\n  by rewrite eq.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33114,"user_id":106,"body":"Require Import Lia.\n\nDefinition inhabited_3 (T : Set) : Prop :=\n  (exists x y z : T, x <> y \/\\ y <> z \/\\ x <> z).\n\nTheorem nat_inhabited_3: inhabited_3 nat.\nProof.\n  exists 0,1,2; lia.\nQed.\n\nTheorem bool_not_inhabited_3: ~ inhabited_3 bool.\nProof.\n  intros [x[y[z H]]]; destruct x,y,z; intuition.\nQed.\n\n\nTheorem is_nat_bool : (nat = bool) \\\/ (nat <> bool).\nProof.\n  right; intro.\n  apply (f_equal inhabited_3) in H.\n  apply bool_not_inhabited_3; rewrite <- H; exact nat_inhabited_3.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33115,"user_id":null,"body":"Definition leibniz_differentiator (typ: Set) : Prop :=\n  exists a b c : typ, a <> b \/\\ b <> c \/\\ a <> c.\n\nLemma true_for_nat : leibniz_differentiator nat.\nProof. exists 0; exists 1; exists 2; auto. Qed.\n\nLemma false_for_bool : ~ leibniz_differentiator bool.\nProof.\n  intros [a [b [c [H1 [H2 H3]]]]]; destruct a; destruct b; destruct c; auto.\nQed.\n\nTheorem is_nat_bool : (nat = bool) \\\/ (nat <> bool).\nProof.\n  right; intro H.\n  apply false_for_bool.\n  rewrite <- H.\n  exact true_for_nat.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33116,"user_id":null,"body":"Require Import ssreflect Lia.\n\nDefinition P (s : Set) := forall x y : s, x <> y -> exists z : s, z <> x \/\\ z <> y.\n\nTheorem is_nat_bool : (nat = bool) \\\/ (nat <> bool).\nProof.\n  right. move=> Heq.\n  have H : P nat.\n    move=> x y _. exists (x + y + 1). split; lia.\n  have TF : true <> false. done.\n  move: H. rewrite Heq. move \/(_ true false TF) => [] z [] HT HF.\n  by case Hz : z =>[|].\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33117,"user_id":null,"body":"Theorem is_nat_bool : (nat = bool) \\\/ (nat <> bool).\nProof.\n  right.\n  intros Con.\n\n  assert (H: forall (a b c : bool), a <> b -> b <> c -> a = c). {\n    intros a b c Hab Hbc.\n    destruct a, b, c;\n      try reflexivity;\n      try (exfalso; auto).\n  }\n\n  rewrite <- Con in H.\n\n  discriminate (H 1 2 3); auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33118,"user_id":null,"body":"Theorem is_nat_bool : (nat = bool) \\\/ (nat <> bool).\nProof.\n  right.\n  intros Con.\n\n  assert (H: forall (a b c : bool), a <> b -> b <> c -> a = c). {\n    intros a b c Hab Hbc.\n    destruct a; destruct b; destruct c;\n      try reflexivity;\n      try (exfalso; auto).\n  }\n\n  rewrite <- Con in H.\n\n  discriminate (H 1 2 3); auto.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33119,"user_id":null,"body":"(* something with at most 2 inhabitants *)\nDefinition P (a : Set) : Prop :=\n    forall (b c d : a),\n        (b = c) \\\/ (b = d) \\\/ (c = d).\n\nTheorem is_nat_bool : (nat = bool) \\\/ (nat <> bool).\nProof.\n    right.\n    intro.\n    assert (P bool).\n    { hnf. intros. destruct b, c, d; tauto. }\n    rewrite <- H in H0.\n    hnf in H0.\n    specialize H0 with O (S O) (S (S O)).\n    destruct H0; try discriminate.\n    destruct H0; try discriminate.\nQed.\n\n\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33120,"user_id":null,"body":"Theorem is_nat_bool : (nat = bool) \\\/ (nat <> bool).\nProof.\n  right; intros F.\n  cut (forall (x y z : bool), x = y \\\/ x = z \\\/ y = z).\n  - rewrite <- F; clear; intros F.\n    now destruct (F 0 1 2) as [|[|]].\n  - clear; intros [|] [|]; [now left| | |now left]; intros [|]; right; [left|right|right|left]; easy.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33121,"user_id":null,"body":"Theorem is_nat_bool : (nat = bool) \\\/ (nat <> bool).\nProof.\n  right.\n  intro.\n  assert (forall x y z : bool, x = y \\\/ x = z \\\/ y = z).\n  destruct x, y, z; auto.\n  rewrite <- H in H0.\n  pose proof (H0 0 1 2).\n  inversion H1.\n  discriminate.\n  inversion H2.\n  discriminate.\n  discriminate.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33122,"user_id":null,"body":"Theorem is_nat_bool : (nat = bool) \\\/ (nat <> bool).\nProof.\n  right.\n  intro HC.\n  set (P := fun T : Type => exists x y z : T, x <> y \/\\ x <> z \/\\ y <> z).\n  assert (H0: ~ P bool).\n  { intros [[] [[] [[] H0]]]; firstorder. }\n  assert (H1: P nat).\n  { exists 0, 1, 2; auto. }\n  rewrite HC in H1.\n  congruence.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5e10444e4225f3000123b9db":[{"id":33123,"user_id":168,"body":"Require Import Preloaded Bool ssreflect.\n\nDefinition flip (m : map) := fun v => negb (m v).\n\nLemma eval_dual f m : eval m (dual f) = negb (eval (flip m) f).\nProof.\n  induction f; simpl; rewrite ?negb_involutive \/\/.\n  - by rewrite IHf1 IHf2 negb_orb.\n  - by rewrite IHf1 IHf2 negb_andb.\n  - by rewrite IHf negb_involutive.\nQed.\n\nTheorem tautology_duality : forall (f : formula),\n  (forall m, eval m f = true)\n  -> forall n, eval n (dual f) = false.\nProof. by intros; rewrite eval_dual H. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33124,"user_id":null,"body":"Require Import Preloaded Bool.\n\nDefinition flip (m : map) := fun v => negb (m v).\n\nRequire Import Bool.\nRequire Import Setoid.\n\nTheorem duality : forall (f : formula) (m : map), eval (flip m) f = negb (eval m (dual f)).\nProof.\n  induction f; intros m; simpl; try reflexivity.\n  - rewrite->negb_andb. congruence.\n  - rewrite->negb_orb. congruence.\n  - rewrite->IHf. reflexivity.\nQed.\n\nTheorem tautology_duality : forall (f : formula),\n  (forall m, eval m f = true)\n  -> forall n, eval n (dual f) = false.\nProof.\n  intros f Hm n.\n  setoid_rewrite<-negb_true_iff. rewrite<-duality. apply Hm.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33125,"user_id":null,"body":"From mathcomp Require Import all_ssreflect.\nRequire Import Preloaded Bool.\n\nDefinition flip (m : map) := fun v => negb (m v).\n\nLemma flip_dualE f m: negb (eval (flip m) f) = eval m (dual f).\nProof.\n  elim: f => [n||| f IHf g IHg| f IHf g IHg| f IHf] \/\/=;\n             try (by rewrite -IHf -?IHg ?negb_and ?negb_or).\n  by rewrite \/flip negbK.\nQed.\n\nTheorem tautology_duality : forall (f : formula),\n  (forall m, eval m f = true)\n  -> forall n, eval n (dual f) = false.\nProof.\n  move => f tautf m. by move: (flip_dualE) tautf => <- \/(_ (flip m)) ->.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33126,"user_id":null,"body":"From mathcomp Require Import all_ssreflect.\nRequire Import Preloaded Bool.\n\nDefinition flip (m : map) := fun v => negb (m v).\n\nLemma flip_dualE f m: eval (flip m) f = negb (eval m (dual f)).\nProof.\n  elim: f => [n| \/\/| \/\/| f IHf g IHg| f IHf g IHg| f IHf];\n             try (by rewrite \/= IHf ?IHg ?negb_and ?negb_or).\n  by rewrite \/flip.\nQed.\n\nTheorem tautology_duality : forall (f : formula),\n  (forall m, eval m f = true)\n  -> forall n, eval n (dual f) = false.\nProof.\n  case => [n| \/\/|| f g| f g| f] tautf m; move: tautf => \/(_ (flip m)) \/\/=.\n  - by rewrite \/flip => \/negbTE.\n  - by move => \/orP [|]; rewrite flip_dualE => \/negbTE ->; rewrite ?andbF ?andFb.\n  - by move\/andP; rewrite !flip_dualE; move => [\/negbTE -> \/negbTE ->].\n  by rewrite flip_dualE => \/negbTE.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33127,"user_id":null,"body":"Require Import Preloaded Bool.\n\nDefinition flip (m : map) := fun v => negb (m v).\n\nTheorem flip_dual (f : formula) (m : map) : eval m (dual f) = negb (eval (flip m) f).\nProof.\n  induction f as [v| | |f h f' h'|f h f' h'| f h].\n  - unfold flip. simpl. rewrite negb_involutive. reflexivity.\n  - simpl. reflexivity.\n  - simpl. reflexivity.\n  - simpl. rewrite h, h'. rewrite negb_orb. reflexivity.\n  - simpl. rewrite h, h'. rewrite negb_andb. reflexivity.\n  - simpl. rewrite h. reflexivity.\nQed.\n\n\n(*result*)\nTheorem tautology_duality : forall (f : formula),\n  (forall m, eval m f = true)\n  -> forall n, eval n (dual f) = false.\nProof. \n  intros f heq n.\n  destruct f as [v| | |f f' |f f'| f ].\n  - pose proof (ha := heq (fun x => false)). simpl in ha. discriminate.\n  - simpl. reflexivity.\n  - specialize (heq (fun x => false)). simpl in heq. discriminate.\n  - simpl. do 2 (rewrite flip_dual). rewrite <- negb_orb.\n    apply (proj2 (negb_false_iff _)). exact (heq (flip n)).\n  - simpl. do 2 (rewrite flip_dual). rewrite <- negb_andb.\n    apply (proj2 (negb_false_iff _)). exact (heq (flip n)).\n  - simpl. rewrite flip_dual. specialize (heq (flip n)).\n    simpl in heq. rewrite heq. auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33128,"user_id":null,"body":"Require Import Preloaded Bool ssreflect.\n\nDefinition flip (m : map) := fun v => negb (m v).\n\nLemma dual_flip (m : map) (A : formula) :\n  eval m (dual A) = negb (eval (flip m) A).\nProof.\n  elim: A => \/\/=.\n  - by move=> n; rewrite negb_involutive.\n  - by move=> A -> B ->; rewrite negb_orb.\n  - by move=> A -> B ->; rewrite negb_andb.\n  - by move=> A ->.\nQed.\n\nTheorem tautology_duality : forall (f : formula),\n  (forall m, eval m f = true)\n  -> forall n, eval n (dual f) = false.\nProof.\n  move=> A taut m.\n  rewrite dual_flip.\n  by apply negb_false_iff.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33129,"user_id":null,"body":"Require Import Preloaded Bool.\n\nDefinition flip (m : map) := fun v => negb (m v).\n\nTheorem tautology_duality : forall (f : formula),\n  (forall m, eval m f = true)\n  -> forall n, eval n (dual f) = false.\nProof.\n  intros f H m.\n  cut (eval m (dual f) = negb (eval (flip m) f)).\n  - intros R; now rewrite R, H.\n  - clear; induction f.\n    + unfold flip; simpl; now destruct (m n).\n    + easy.\n    + easy.\n    + simpl; rewrite IHf1, IHf2.\n      now destruct (eval (flip m) f1), (eval (flip m) f2).\n    + simpl; rewrite IHf1, IHf2.\n      now destruct (eval (flip m) f1), (eval (flip m) f2).\n    + simpl; now rewrite IHf.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33130,"user_id":null,"body":"Require Import Preloaded Bool.\n\nDefinition flip (m : map) := fun v => negb (m v).\n\nLemma fliph : forall f b n, flip f n = negb b -> f n =  b.\nProof.\n  intros.\n  unfold flip in H.\n  destruct b.\n  simpl in *.\n  destruct (f n).\n  reflexivity.\n  discriminate.\n  destruct (f n).\n  discriminate.\n  reflexivity.\nQed.\n\n\nTheorem tautology_duality_h : forall (f : formula), forall n b, \n  ( eval (flip n) f = b)\n  ->  eval n (dual f) = negb b.\nProof.\n  induction f.\n  unfold flip.\n  simpl.\n  intros.\n  apply fliph.\n  unfold flip.\n  simpl. rewrite negb_involutive.\n  assumption.\n  intros.\n  simpl in *.\n  rewrite <- H.\n  reflexivity.\n  simpl.\n  intros.\n  rewrite <- H.\n  reflexivity.\n  simpl.\n  intros.\n  destruct b.\n  simpl.\n  apply andb_false_iff.\n  apply orb_true_iff in H.\n  firstorder.\n  simpl.\n  apply andb_true_iff.\n  apply orb_false_iff in H.\n  firstorder.\n  intros.\n  simpl in *.\n  destruct b; simpl.\n  apply andb_true_iff in H.\n  apply orb_false_iff.\n  firstorder.\n  apply andb_false_iff in H.\n  apply orb_true_iff.\n  firstorder.  \n  simpl.\n  intros.\n  rewrite <- negb_involutive with b.\n  f_equal.\n  apply IHf. \n  eapply f_equal in H.\n  erewrite negb_involutive in H.\n  assumption.\nQed.\n  \n  \nTheorem tautology_duality : forall (f : formula),\n  (forall m, eval m f = true)\n  -> forall n, eval n (dual f) = false.\nProof.\n  intros.\n  pose proof tautology_duality_h.\n  specialize (H (flip n)).\n  firstorder.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33131,"user_id":null,"body":"Require Import Preloaded Bool.\n\nDefinition flip (m : map) := fun v => negb (m v).\n\n  Lemma dual_aux : forall m f, eval m (dual f) = negb (eval (flip m) f).\n  Proof with auto.\n    induction f; intros;cbn...\n    - unfold flip. apply negb_involutive_reverse.\n    - rewrite negb_orb. rewrite IHf1, IHf2...\n    - rewrite negb_andb. rewrite IHf1, IHf2...\n    - rewrite IHf...\n  Qed.     \n\n  Theorem tautology_duality : forall (f : formula),\n    (forall m, eval m f = true)\n    -> forall n, eval n (dual f) = false.\n  Proof with auto.\n    intros.\n    rewrite dual_aux, H...\n  Qed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33132,"user_id":null,"body":"Require Import Preloaded Bool.\n\nDefinition flip (m : map) := fun v => negb (m v).\n\nTheorem tautology_duality : forall (f : formula),\n  (forall m, eval m f = true)\n  -> forall n, eval n (dual f) = false.\nProof.\n  cut (forall m f, eval m (dual f) = negb (eval (flip m) f));\n  [intros R f H n; now rewrite R, H|].\n  induction f; simpl; try easy.\n  - unfold flip; now destruct (m n).\n  - rewrite IHf1, IHf2; now destruct (eval (flip m) f1), (eval (flip m) f2).\n  - rewrite IHf1, IHf2; now destruct (eval (flip m) f1), (eval (flip m) f2).\n  - now rewrite IHf.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5e3c1eb312676f001eb41f1c":[{"id":33133,"user_id":null,"body":"Require Import Preloaded.\n\nLemma hilbert_MID_sound : forall c, hilbert c -> MID_valid c.\nProof.\n  intros c H; induction H; intros m; simpl; try (now destruct (m 0), (m 1), (m 2)).\n  - specialize (IHhilbert1 m); specialize (IHhilbert2 m).\n    simpl in IHhilbert1; rewrite IHhilbert2 in IHhilbert1.\n    now destruct (valuation b m).\n  - replace (valuation (subst a s) m) with (valuation a (fun n => valuation (s n) m)).\n    + apply IHhilbert.\n    + clear; induction a; simpl; try rewrite IHa1, IHa2; easy.\nQed.\n\nLemma LEM_not_MID_valid : ~ MID_valid LEM.\nProof.\n  intros F; now specialize (F (fun n => mid)).\nQed.\n\nTheorem hilbert_LEM_not_provable : ~ hilbert LEM.\nProof.\n  (* This should not need modifying *)\n  auto using LEM_not_MID_valid, hilbert_MID_sound.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33134,"user_id":null,"body":"Require Import Preloaded ssreflect.\n\nLemma valuation_subst (a : formula) (s : substitution) (m : map) :\n  valuation (subst a s) m = valuation a (fun n => valuation (s n) m).\nProof. by elim: a => \/\/=; move=> a -> b ->. Qed.\n\nLemma hilbert_MID_sound : forall c, hilbert c -> MID_valid c.\nProof.\n  move=> A; elim; try by move=> m \/=; case: (m 0); case: (m 1); case: (m 2).\n    move=> a b _ validab _ valida m.\n    move: (validab m) => \/=.\n    rewrite (valida m) \/=.\n    by case: (valuation b m).\n  move=> a s Pa valida m.\n  by rewrite valuation_subst.\nQed.\n\nLemma LEM_not_MID_valid : ~ MID_valid LEM.\nProof. by move=> \/(_ (fun _ => mid)). Qed.\n\nTheorem hilbert_LEM_not_provable : ~ hilbert LEM.\nProof.\n  (* This should not need modifying *)\n  auto using LEM_not_MID_valid, hilbert_MID_sound.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33135,"user_id":null,"body":"Require Import Preloaded.\n\nLemma valuation_subst: forall a s m, valuation (subst a s) m = valuation a (fun n : nat => valuation (s n) m) .\nProof.\n  intros a.\n  induction a; intros; auto; simpl in *;\n    rewrite IHa1;\n    rewrite IHa2; \n    auto.\nQed.\n\nLemma hilbert_MID_sound : forall c, hilbert c -> MID_valid c.\nProof. \n  intros.\n  unfold MID_valid.\n  induction H; intros;\n  try (simpl; destruct (m 0); destruct (m 1); destruct (m 2); auto; fail).\n  {\n    simpl in *.\n    specialize (IHhilbert1 m).\n    rewrite (IHhilbert2 m) in IHhilbert1.\n    destruct (valuation b m); auto.\n  }\n  {\n    rewrite valuation_subst. auto.\n  }\nQed.\n\n\nLemma LEM_not_MID_valid : ~ MID_valid LEM.\nProof.\n  unfold LEM.\n  unfold MID_valid.\n  unfold not. intros.\n  specialize (H (fun _ => mid)).\n  simpl in H.\n  inversion H.\nQed.\n\nTheorem hilbert_LEM_not_provable : ~ hilbert LEM.\nProof.\n  (* This should not need modifying *)\n  auto using LEM_not_MID_valid, hilbert_MID_sound.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33136,"user_id":null,"body":"Require Import Preloaded.\n\nLemma valuation_subst : forall a m s, valuation (subst a s) m = valuation a (fun v => valuation (s v) m).\n  induction a; intros; simpl; auto.\n  rewrite IHa1, IHa2. auto. \n  rewrite IHa1, IHa2. auto. \n  rewrite IHa1, IHa2. auto.\nQed. \n\nLemma hilbert_MID_sound : forall c, hilbert c -> MID_valid c.\nProof.\n    induction 1; try solve [intro;simpl;destruct (m 0),(m 1),(m 2);auto].\n    - intro. specialize (IHhilbert1 m). specialize (IHhilbert2 m). simpl in *. rewrite IHhilbert2 in IHhilbert1.\n      destruct (valuation b m);auto. \n    - intro. rewrite valuation_subst. apply IHhilbert.\nQed.\n\n\nLemma LEM_not_MID_valid : ~ MID_valid LEM.\nProof.\n     \n    intro. unfold LEM in * . \n    unfold MID_valid in H.\n    specialize (H (fun _ => mid)). simpl in H. discriminate.\nQed.\n\n\nTheorem hilbert_LEM_not_provable : ~ hilbert LEM.\nProof.\n  (* This should not need modifying *)\n  auto using LEM_not_MID_valid, hilbert_MID_sound.\nQed.\n\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33137,"user_id":null,"body":"Require Import Preloaded.\n\nLemma subst_tauto : forall c s m,\n  valuation (subst c s) m = valuation c (fun v => valuation (s v) m).\nProof.\n  induction c; simpl; intros; auto;\n    rewrite IHc2, IHc1; auto. \nQed.\n\nLemma hilbert_MID_sound : forall c, hilbert c -> MID_valid c.\nProof.\n  unfold MID_valid.\n  induction 1; simpl in *; intros;\n    try solve [destruct (m 0); destruct (m 1); try destruct (m 2); auto].\n  - specialize (IHhilbert1 m).\n    rewrite IHhilbert2 in IHhilbert1.\n    destruct (valuation b m) eqn:Heq; auto; discriminate.\n  - rewrite subst_tauto. auto.\nQed.\n\nLemma LEM_not_MID_valid : ~ MID_valid LEM.\nProof.\n  intros C.\n  specialize (C (fun _ => mid)).\n  discriminate.\nQed.\n\nTheorem hilbert_LEM_not_provable : ~ hilbert LEM.\nProof.\n  (* This should not need modifying *)\n  auto using LEM_not_MID_valid, hilbert_MID_sound.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33138,"user_id":null,"body":"Require Import Preloaded.\n\nLemma hilbert_MID_sound : forall c, hilbert c -> MID_valid c.\nProof.\n  intros c H; induction H.\n  - intros m; specialize (IHhilbert1 m); specialize (IHhilbert2 m); simpl in *.\n    now destruct (valuation a m), (valuation b m).\n  - intros m; specialize (IHhilbert (fun n => valuation (s n) m)).\n    rewrite <- IHhilbert; clear; induction a; simpl.\n    + easy.\n    + easy.\n    + now rewrite IHa1, IHa2.\n    + now rewrite IHa1, IHa2.\n    + now rewrite IHa1, IHa2.\n  - intros m; simpl; now destruct (m 0), (m 1).\n  - intros m; simpl; now destruct (m 0), (m 1), (m 2).\n  - intros m; simpl; now destruct (m 0), (m 1).\n  - intros m; simpl; now destruct (m 0), (m 1).\n  - intros m; simpl; now destruct (m 0), (m 1).\n  - intros m; simpl; now destruct (m 0), (m 1).\n  - intros m; simpl; now destruct (m 0), (m 1).\n  - intros m; simpl; now destruct (m 0), (m 1), (m 2).\n  - intros m; simpl; now destruct (m 0).\nQed.\n\nLemma LEM_not_MID_valid : ~ MID_valid LEM.\nProof.\n  intros F; now specialize (F (fun _ => mid)).\nQed.\n\nTheorem hilbert_LEM_not_provable : ~ hilbert LEM.\nProof.\n  (* This should not need modifying *)\n  auto using LEM_not_MID_valid, hilbert_MID_sound.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33139,"user_id":null,"body":"Require Import Preloaded.\n\nLemma subst_sound: forall c s m, valuation (subst c s) m = valuation c (fun n => valuation (s n) m).\nProof.\n  induction c; intros; simpl; try (rewrite IHc1, IHc2); reflexivity.\nQed.\n\nLemma k_sound: forall m1 m2, impl m1 (impl m2 m1) = top.\nProof.\n  induction m1, m2; simpl; reflexivity.\nQed.\n\nLemma s_sound: forall m1 m2 m3, impl (impl m1 (impl m2 m3)) (impl (impl m1 m2) (impl m1 m3)) = top.\nProof.\n  induction m1, m2, m3; simpl; reflexivity.\nQed.\n\nLemma fst_sound: forall m1 m2, impl (meet m1 m2) m1 = top.\nProof.\n  induction m1, m2; simpl; reflexivity.\nQed.\n\nLemma snd_sound: forall m1 m2, impl (meet m1 m2) m2 = top.\nProof.\n  induction m1, m2; simpl; reflexivity.\nQed.\n\nLemma pair_sound: forall m1 m2, impl m1 (impl m2 (meet m1 m2)) = top.\nProof.\n  induction m1, m2; simpl; reflexivity.\nQed.\n\nLemma inl_sound: forall m1 m2, impl m1 (join m1 m2) = top.\nProof.\n  induction m1, m2; simpl; reflexivity.\nQed.\n\nLemma inr_sound: forall m1 m2, impl m2 (join m1 m2) = top.\nProof.\n  induction m1, m2; simpl; reflexivity.\nQed.\n\nLemma either_sound: forall m1 m2 m3, impl (impl m1 m3) (impl (impl m2 m3) (impl (join m1 m2) m3)) = top.\nProof.\n  induction m1, m2, m3; simpl; reflexivity.\nQed.\n\nLemma absurd_sound: forall m, impl bot m = top.\nProof.\n  induction m; simpl; reflexivity.\nQed.\n\nLemma hilbert_MID_sound : forall c, hilbert c -> MID_valid c.\nProof.\n  unfold MID_valid; intros c H; induction H; simpl; intros.\n    set (H1 := IHhilbert1 m); set (H2 := IHhilbert2 m);\n    simpl in H1; rewrite H2 in H1; simpl in H1.\n    destruct (valuation b m); try reflexivity; simpl in H1; discriminate.\n\n    rewrite subst_sound; exact (IHhilbert _).\n\n    exact (k_sound _ _).\n    exact (s_sound _ _ _).\n    exact (fst_sound _ _).\n    exact (snd_sound _ _).\n    exact (pair_sound _ _).\n    exact (inl_sound _ _).\n    exact (inr_sound _ _).\n    exact (either_sound _ _ _).\n    exact (absurd_sound _).\nQed.\n\nLemma LEM_not_MID_valid : ~ MID_valid LEM.\nProof.\n  unfold not, MID_valid, LEM; intros.\n  set (F := H (fun _ => mid)); simpl in F; discriminate.\nQed.\n\nTheorem hilbert_LEM_not_provable : ~ hilbert LEM.\nProof.\n  (* This should not need modifying *)\n  auto using LEM_not_MID_valid, hilbert_MID_sound.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33140,"user_id":null,"body":"Require Import Preloaded.\n\nLemma valuation_subst : forall a m s,\n  valuation (subst a s) m = valuation a (fun n => valuation (s n) m).\nProof.\n  induction a; intros.\n  - reflexivity.\n  - reflexivity.\n  - cbn. rewrite IHa1, IHa2. reflexivity.\n  - cbn. rewrite IHa1, IHa2. reflexivity.\n  - cbn. rewrite IHa1, IHa2. reflexivity.\nQed.\n\nLemma hilbert_MID_sound : forall c, hilbert c -> MID_valid c.\nProof.\n  intros. induction H;\n    try (intros m; cbn;\n      repeat match goal with\n      | |- context[m ?n] => destruct (m n)\n      end; reflexivity).\n  - intros m.\n    specialize (IHhilbert1 m). cbn in IHhilbert1.\n    rewrite IHhilbert2 in IHhilbert1.\n    destruct (valuation b m); try discriminate; reflexivity.\n  - intros m. rewrite valuation_subst. apply IHhilbert.\nQed.\n\nLemma LEM_not_MID_valid : ~ MID_valid LEM.\nProof.\n  intros contra.\n  specialize (contra (fun _ => mid)).\n  discriminate.\nQed.\n\nTheorem hilbert_LEM_not_provable : ~ hilbert LEM.\nProof.\n  (* This should not need modifying *)\n  auto using LEM_not_MID_valid, hilbert_MID_sound.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33141,"user_id":null,"body":"Require Import Preloaded.\n\nLemma substval_is_val : forall a m s,\n valuation (subst a s) m = valuation a (fun n => valuation (s n) m).\nProof. induction a;simpl in *;intros;(try rewrite IHa1,IHa2);auto. Qed.\n\nLemma hilbert_MID_sound : forall c, hilbert c -> MID_valid c.\nProof.\n intros.\n induction H;intro m;simpl;[| |destruct (m 0),(m 1),(m 2);auto ..].\n * assert (IHm1 := IHhilbert1 m);assert (IHm2 := IHhilbert2 m);simpl in *.\n   destruct (valuation a m),(valuation b m);easy.\n * rewrite substval_is_val.\n   apply IHhilbert.\nQed.\n\nLemma LEM_not_MID_valid : ~ MID_valid LEM.\nProof.\n intro abs.\n specialize (abs (fun n => if n then mid else top)).\n discriminate.\nQed.\n\nTheorem hilbert_LEM_not_provable : ~ hilbert LEM.\nProof.\n  auto using LEM_not_MID_valid, hilbert_MID_sound.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33142,"user_id":196,"body":"Require Import Preloaded.\n\nLemma valuation_subst (c : formula) (s : substitution) (m : map) :\n  valuation (subst c s) m = valuation c (fun n => valuation (s n) m).\nProof.\n  induction c; simpl; try rewrite IHc1, IHc2; auto.\nQed.\n\nLemma hilbert_MID_sound : forall c, hilbert c -> MID_valid c.\nProof.\n  intros c hc. induction hc.\n  { intro m. assert (h1 := IHhc1 m). assert (h2 := IHhc2 m).\n    simpl in *. now case (valuation a m), (valuation b m). }\n  { intro m. rewrite valuation_subst. apply IHhc. }\n  all : (intro m; simpl; case (m 0), (m 1), (m 2); reflexivity).\nQed.\n\nLemma LEM_not_MID_valid : ~ MID_valid LEM.\nProof. intro H. assert (h := H (fun n => mid)). inversion h. Qed.\n\nTheorem hilbert_LEM_not_provable : ~ hilbert LEM.\nProof.\n  (* This should not need modifying *)\n  auto using LEM_not_MID_valid, hilbert_MID_sound.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5e3cd88fa5b6a8001fa84ed5":[{"id":33143,"user_id":831,"body":"Require Import Classical.\n\nTheorem drinker : forall (A : Set) (r : A -> Prop) (e : A), exists x, (r x -> forall y, r y).\n  intros; destruct (classic (exists x, ~(r x))); [| specialize (not_ex_not_all _ _ H)]; firstorder.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33144,"user_id":null,"body":"Require Import Classical.\n\nTheorem drinker : forall (A : Set) (r : A -> Prop) (e : A),\n  exists x, (r x -> forall y, r y).\nProof.\n  intros. destruct (classic (exists y : A, ~ r y)) as [[y H]|H].\n  - exists y. intuition.\n  - exists e. intros. destruct (classic (r y)).\n    + trivial.\n    + contradict H. exists y. trivial.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33145,"user_id":null,"body":"Require Import Classical.\n\nTheorem drinker : forall (A : Set) (r : A -> Prop) (e : A),\n  exists x, (r x -> forall y, r y).\nProof.\n  intros People drinks individual_at_bar.\n  pose (is_anybody_not_drinking := (exists x : People, ~ drinks x)).\n  case (classic is_anybody_not_drinking).\n  * intros [non_drinker doesnt_drink].\n    exists non_drinker; intros non_drinker_drinks.\n    exfalso. exact (doesnt_drink non_drinker_drinks).\n  * intro everybody_is_drinking.\n    exists individual_at_bar; intros _ anyone_at_bar.\n    case (classic (drinks anyone_at_bar)); [exact id|].\n    intro wait_he_is_not_actually_drinking; exfalso.\n    apply everybody_is_drinking.\n    exists anyone_at_bar; exact wait_he_is_not_actually_drinking.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33146,"user_id":191,"body":"Require Import Classical.\n\nTheorem drinker : forall (A : Set) (r : A -> Prop) (e : A),\n  exists x, (r x -> forall y, r y).\nProof. \n  intros.\n  destruct (classic (forall y : A, r y)).\n  * exists e.\n    intro.\n    assumption.\n  * destruct (not_all_ex_not _ _ H).\n    exists x.\n    intro.\n    exfalso.\n    apply H0.\n    exact H1.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33147,"user_id":null,"body":"Require Import Classical.\n\n(* Goes through the steps of how I proved it on paper by applying\n   demorgan laws. *)\nTheorem drinker : forall (A : Set) (r : A -> Prop) (e : A),\n  exists x, (r x -> forall y, r y).\nProof.\n  intros A r e.\n  set (P := exists x, r x -> forall y, r y).\n  destruct (classic P); auto.\n  assert (H0: forall x, ~ (r x -> forall y, r y)).\n  { apply not_ex_all_not; auto. }\n  assert (H1: forall x, ~ (~ r x \\\/ forall y, r y)).\n  { firstorder. }\n  assert (H2: forall x, r x \/\\ ~ (forall y, r y)).\n  { intros x. specialize (H1 x).\n    apply not_or_and in H1.\n    destruct H1 as [H1 H1'].\n    split; auto; apply NNPP; auto. }\n  assert (H3: forall x, r x \/\\ exists y, ~ r y).\n  { firstorder. }\n  pose proof H3 as H4.\n  specialize (H3 e); destruct H3 as [H3 [y H3']].\n  specialize (H4 y).\n  destruct H4 as [H4 H4'].\n  congruence.\nQed.  ","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33148,"user_id":null,"body":"Require Import Classical.\n\nTheorem drinker : forall (A : Set) (r : A -> Prop) (e : A),\n  exists x, (r x -> forall y, r y).\nProof. \n  intros.\n  destruct (classic (forall y, r y)).\n  + exists e. intros ?H.\n    assumption.\n  + apply not_all_ex_not in H. \n    destruct H as [e0 ?].\n    exists e0. intros. intuition.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33149,"user_id":null,"body":"Require Import Classical.\n\nTheorem drinker : forall (A : Set) (r : A -> Prop) (e : A),\n  exists x, (r x -> forall y, r y).\nProof.\n  intros.\n  assert ((exists x : A, ~ (r x)) \\\/ ~ (exists x : A, ~ (r x))).\n  { apply classic. }\n  destruct H as [H | H].\n  - destruct H as [x H].\n    unfold not in H.\n    exists x.\n    intros Hr.\n    apply H in Hr.\n    destruct Hr.\n  - exists e.\n    intros He y.\n    assert ((r y) \\\/ ~ (r y)).\n    { apply classic. }\n    destruct H0 as [H0 | H0].\n    + apply H0.\n    + unfold not in H.\n      destruct H.\n      exists y.\n      apply H0.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33150,"user_id":null,"body":"Require Import Classical.\n\nTheorem drinker : forall (A : Set) (r : A -> Prop) (e : A),\n  exists x, (r x -> forall y, r y).\nProof. \n  intros A r a.\n  pose proof (hc := classic (exists y : A, ~(r y))).\n  destruct hc as [hc|hc].\n  - destruct hc as [y hy]. exists y. intro hy'. contradiction.\n  - exists a. intro ha. intro y. apply NNPP. intro hny. apply hc.\n    exists y. exact hny.\nQed.  ","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33151,"user_id":null,"body":"Require Import Classical.\n\nTheorem drinker : forall (A : Set) (r : A -> Prop) (e : A),\n  exists x, (r x -> forall y, r y).\nProof.\n  intros A r a.\n  pose proof classic (exists x, ~ r x) as [[x H] | H].\n  - exists x. intro Hx. exfalso; auto.\n  - assert (forall x, ~ ~ r x). apply not_ex_all_not; auto.\n    exists a; intros. specialize H0 with y. apply NNPP in H0. assumption.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33152,"user_id":null,"body":"Require Import Classical.\n\nTheorem drinker : forall (A : Set) (r : A -> Prop) (e : A),\n  exists x, (r x -> forall y, r y).\nProof.\n  intros A r e.\n  destruct (classic (forall y : A, r y)) as [|H].\n  - exists e. auto.\n  - apply not_all_ex_not in H.\n    destruct H as [x H].\n    exists x.\n    contradiction.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5e59626530e9d00028bbe569":[{"id":33153,"user_id":106,"body":"Require Import Preloaded.\nRequire Import Arith.\n\nLemma mod_5_ind (P : nat -> Prop) :\n  P 0 -> P 1 -> P 2 -> P 3 -> P 4 ->\n  (forall n, P n -> P (S (S (S (S (S n)))))) ->\n  forall n, P n.\nProof.\n  intros H0 H1 H2 H3 H4 Hstep n.\n  enough (P n \/\\ P (S n) \/\\ P (S (S n)) \/\\ P (S (S (S n))) \/\\ P (S (S (S (S n))))) by tauto.\n  induction n; intuition.\nQed.\n\nLemma mod_5_destruct : forall n, (n mod 5 = 0) \\\/ (n mod 5 = 1) \\\/ (n mod 5 = 2) \\\/ (n mod 5 = 3) \\\/ (n mod 5 = 4).\nProof.\n  apply mod_5_ind; intros; auto.\n  replace (S (S (S (S (S n))))) with (n + 1 * 5) by ring.\n  rewrite Nat.mod_add; auto.\nQed.\n\nTheorem decide_works n : Times3Plus5 n <-> decide n = true.\nProof.\n  intros; split; intro.\n  - induction H; auto.\n    + unfold decide in *; rewrite Nat.mul_mod; auto.\n      destruct (mod_5_destruct n) as [H'|[H'|[H'|[H'|H']]]]; rewrite H' in *; simpl; intuition.\n      * destruct n as [|[|[|n']]] eqn:e; try discriminate.\n        now replace (S (S (S n')) + (S (S (S n')) + (S (S (S n')) + 0))) with\n                    (S (S (S (S (S (S (S (S (S (n' + n' + n')))))))))) by ring.\n      * destruct n as [|[|[|[|[|[|[|[|[|n']]]]]]]]] eqn:e; try discriminate.\n        now replace (S (S (S (S (S (S (S (S (S n')))))))) + (S (S (S (S (S (S (S (S (S n')))))))) + (S (S (S (S (S (S (S (S (S n')))))))) + 0))) with\n                    (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (n' + n' + n')))))))))))))))))))))))))))) by ring.\n    + unfold decide in *. replace (5 + n) with (n + 1 * 5) by ring; rewrite Nat.mod_add; auto.\n      destruct (mod_5_destruct n) as [H'|[H'|[H'|[H'|H']]]]; rewrite H' in *;\n      try (apply Nat.leb_le in IHTimes3Plus5; apply Nat.leb_le); intuition.\n  - revert n H.\n    apply (mod_5_ind (fun n => decide n = true -> Times3Plus5 n)); unfold decide; intros; try discriminate.\n    + repeat constructor.\n    + replace 3 with (3 * 1) by ring; repeat constructor.\n    + replace (S (S (S (S (S n))))) with (n + 1 * 5) in H0 by ring. rewrite Nat.mod_add in H0; auto.\n      destruct (mod_5_destruct n) as [H'|[H'|[H'|[H'|H']]]]; rewrite H' in *; simpl; intuition.\n      * discriminate.\n      * now constructor.\n      * destruct n as [|[|[|[|[|[|[|[|[|[|[|[|[|[|[|[|[|[|[|[|[|[|[|[|[|[|[|[|[|[|[|[|n']]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]] eqn:e; try discriminate.\n        replace 27 with (3 * (3 * (3 * 1))) by ring; repeat constructor.\n        replace 32 with (5 + (3 * (3 * (3 * 1)))) by ring; repeat constructor.\n        constructor; apply H; auto.\n      * now constructor.\n      * destruct n as [|[|[|[|[|[|[|[|[|[|[|[|[|[|n']]]]]]]]]]]]]] eqn:e; try discriminate.\n        replace 9 with (3 * (3 * 1)) by ring; repeat constructor.\n        replace 14 with (5 + (3 * (3 * 1))) by ring; repeat constructor.\n        constructor; apply H; auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33154,"user_id":168,"body":"Require Import Preloaded.\nRequire Import Arith ssreflect Lia.\n\nSet Implicit Arguments.\n\nLemma mod5_cases n :\n  n mod 5 = 0 \\\/ n mod 5 = 1 \\\/ n mod 5 = 2 \\\/ n mod 5 = 3 \\\/ n mod 5 = 4.\nProof. by move: (Nat.mod_upper_bound n 5); lia. Qed.\n\nLemma mod5_lemma a n : a <= n -> n mod 5 = a mod 5 ->\n                      n = a \\\/ exists k, n = 5 + (a + k * 5).\nProof.\n  rewrite Nat.le_lteq; case => ineq eq; last by lia.\n  have\/(Nat.div_mod n) eq_n: 5 <> 0 by [].\n  have\/(Nat.div_mod a) eq_a: 5 <> 0 by [].\n  by right; exists (n \/ 5 - a \/ 5 - 1); lia.\nQed.\n\nLtac cases := match goal with [ |- _ \\\/ _ -> _ ] => case; try cases end.\n\nLemma times3plus5_imp_decide n : Times3Plus5 n -> decide n = true.\nProof.\n  elim => {n} [\/\/ ||] n H; rewrite \/decide.\n  - rewrite -Nat.mul_mod_idemp_r \/\/.\n    move: (mod5_cases n); cases;\n      move => eq; rewrite eq \/\/ !Nat.leb_le; last by lia.\n    suff: 3 <= n by lia.\n    by rewrite -eq; apply: Nat.mod_le.\n  - rewrite (_ : 5 + n = n + 1 * 5) ?Nat.mod_add \/\/; first by lia.\n    by move: (mod5_cases n); cases; move => eq;\n       rewrite eq \/\/ !Nat.leb_le; lia.\nQed.\n\n\nTactic Notation \"finish\" ident(eq) ident(IH) :=\n  by move => {eq} [k eq]; rewrite eq; apply Plus5, IH;\n             [lia | rewrite \/decide Nat.mod_add].\n\nTheorem decide_works n : Times3Plus5 n <-> decide n = true.\nProof.\n  split; first exact: times3plus5_imp_decide.\n  elim\/lt_wf_ind: n => n IH.\n  move: (mod5_cases n); cases; move => eq; rewrite \/decide eq \/\/ ?Nat.leb_le.\n  - move => _; have ineq: 1 <= n by rewrite -eq; apply: Nat.mod_le.\n    case: (mod5_lemma ineq eq); first by move => ->; exact: Start.\n    by finish eq IH.\n  - move => ineq; case: (mod5_lemma ineq eq).\n      by move => ->; exact: Times3 (Times3 (Times3 Start)).\n    by finish eq IH.\n  - move => _; have ineq: 3 <= n by rewrite -eq; apply: Nat.mod_le.\n    case: (mod5_lemma ineq eq); first by move => ->; exact: Times3 Start.\n    by finish eq IH.\n  - move => ineq; case: (mod5_lemma ineq eq).\n      by move => ->; exact: Times3 (Times3 Start).\n    by finish eq IH.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33155,"user_id":null,"body":"Require Import Arith Lia Preloaded.\nRequire Export Setoid.\nRequire Export Relation_Definitions.\n\nLemma nat_mod5 (n : nat) : n mod 5 = 0 \\\/ n mod 5 = 1 \\\/ n mod 5 = 2\n  \\\/ n mod 5 = 3 \\\/ n mod 5 = 4.\nProof.\n  assert (hn : n mod 5 < 5). apply Nat.mod_upper_bound. lia.\n  revert hn. generalize (n mod 5). intros u hu.\n  induction u. left. reflexivity. assert (u < 5) by lia.\n  specialize (IHu H). destruct IHu as [h0 | [h0 | [h0 | [h0 | h0]]]] ; \n  try auto 6. lia.\nQed. \n\nLemma nat_mod5_add5 (n : nat) :  S (S (S (S (S n)))) mod 5 = n mod 5.\nProof.\n  replace (S (S (S (S (S n))))) with (n+5) by lia.\n  rewrite <- Nat.add_mod_idemp_r, Nat.mod_same. f_equal.\n  all : lia.\nQed.\n\nTheorem decide_works n : Times3Plus5 n <-> decide n = true.\nProof.\n  split.\n  + intros. induction H as [|n H3n IH3n|n H5n IH5n]; try reflexivity. \n    - assert (h3n : (3 * n) mod 5 = (3 * (n mod 5)) mod 5). \n      rewrite Nat.mul_mod_idemp_r. reflexivity. lia. unfold decide.\n      rewrite h3n. destruct (nat_mod5 n) as [h0 | [h0 | [h0 | [h0 | h0]]]] ;\n      rewrite h0 in *; simpl ((3 * _) mod 5); try reflexivity.\n      * unfold decide in IH3n. rewrite h0 in IH3n. discriminate.\n      * rewrite Nat.leb_le. assert (n mod 5 <= n). apply Nat.mod_le. 1,2 :lia.\n      * unfold decide in IH3n. rewrite h0 in IH3n. rewrite Nat.leb_le in *. lia.\n    - assert (h5n : (5 + n) mod 5 = n mod 5).  rewrite <- Nat.add_mod_idemp_l. \n      rewrite Nat.mod_same. auto. 1,2 : lia. unfold decide. rewrite h5n. \n      unfold decide in IH5n. destruct (nat_mod5 n) as [h0 | [h0 | [h0 | [h0 | h0]]]] ;\n      rewrite h0 in *; try reflexivity ; try discriminate.\n      1,2 : rewrite Nat.leb_le in * ; lia.\n  + intros. induction n as [n IHn] using lt_wf_ind. unfold decide in H.\n    destruct (nat_mod5 n) as [h0 | [h0 | [h0 | [h0 | h0]]]] ; rewrite h0 in H ;\n    try discriminate.\n    - do 5 (try destruct n; try lia ; try constructor). 1,2,3,4 : simpl in h0 ; lia.\n      apply IHn. lia. unfold decide. rewrite nat_mod5_add5 in h0. rewrite h0. reflexivity.\n    - rewrite Nat.leb_le in H. destruct (32 <=? n) eqn:h32.\n      * rewrite Nat.leb_le in h32. do 5 (try destruct n ; try lia). constructor.\n        apply IHn. lia. unfold decide. rewrite nat_mod5_add5 in h0. rewrite h0.\n        rewrite Nat.leb_le. lia.\n      * rewrite Nat.leb_gt in h32. \n        assert (n = 27 \\\/ n = 28 \\\/ n = 29 \\\/ n = 30 \\\/ n = 31) by lia.\n        destruct H0 as [H0 | [H0 | [H0 | [H0 | H0]]]] ; rewrite H0 in h0 ;\n        simpl in h0; try lia. rewrite H0 in *. clear H h32 h0 IHn H0 n.\n        replace 27 with (3 * (3 * (3 * 1))) by lia. do 4 constructor.\n    - do 5 (try destruct n ; try lia). 1,2,3,5 : simpl in h0; lia.\n      * replace 3 with (3 * 1) by lia. do 2 constructor.\n      * constructor. apply IHn. lia. unfold decide. rewrite nat_mod5_add5 in h0. \n        rewrite h0. reflexivity.\n    - rewrite Nat.leb_le in H. destruct (14 <=? n) eqn:h14.\n      * rewrite Nat.leb_le in h14. do 5 (try destruct n ; try lia). constructor.\n        apply IHn. lia. unfold decide. rewrite nat_mod5_add5 in h0. rewrite h0.\n        rewrite Nat.leb_le. lia.\n      * rewrite Nat.leb_gt in h14. \n        assert (n = 9 \\\/ n = 10 \\\/ n = 11 \\\/ n = 12 \\\/ n = 13) by lia.\n        destruct H0 as [H0 | [H0 | [H0 | [H0 | H0]]]] ; rewrite H0 in h0 ;\n        simpl in h0; try lia. rewrite H0 in *. clear H h14 h0 IHn H0 n.\n        replace 9 with (3 * (3 * 1)) by lia. do 3 constructor.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33156,"user_id":null,"body":"Require Import Preloaded Arith.\n\nInductive mod_5 : nat -> Prop :=\n| m5_0 : forall n, mod_5 (5 * n + 0)\n| m5_1 : forall n, mod_5 (5 * n + 1)\n| m5_2 : forall n, mod_5 (5 * n + 2)\n| m5_3 : forall n, mod_5 (5 * n + 3)\n| m5_4 : forall n, mod_5 (5 * n + 4).\n\nLemma mod_5_dec : forall n, mod_5 n.\nProof.\n  intros n; cut (mod_5 n \/\\ mod_5 (S n) \/\\ mod_5 (S (S n)) \/\\ mod_5 (S (S (S n))) \/\\ mod_5 (S (S (S (S n))))); [now intros [H _]|].\n  induction n; [repeat split|].\n  - apply (m5_0 0).\n  - apply (m5_1 0).\n  - apply (m5_2 0).\n  - apply (m5_3 0).\n  - apply (m5_4 0).\n  - destruct IHn as [IH [H1 [H2 [H3 H4]]]]; repeat split; try easy; clear - IH.\n    assert (forall m k, n = 5 * m + k -> S (S (S (S (S n)))) = 5 * (m + 1) + k) as H by (intros; subst; ring).\n    inversion IH; subst; rewrite (H _ _ eq_refl); constructor.\nQed.\n\nLemma mod_5_mod_5 : forall n k, (5 * n + k) mod 5 = (k mod 5).\nProof.\n  intros; rewrite Nat.add_mod; [|easy].\n  rewrite Nat.mul_mod; [|easy].\n  replace ((5 mod 5 * (n mod 5)) mod 5 + k mod 5) with (k mod 5); [|easy].\n  now apply Nat.mod_mod.\nQed.\n\nLemma mod_simpl : forall n m, Times3Plus5 m -> Times3Plus5 (5 * n + m).\nProof.\n  induction n; intros m Hm; [easy|].\n  replace (5 * S n) with (5 + 5 * n); [|ring].\n  apply Plus5, IHn, Hm.\nQed.\n\nTheorem decide_works n : Times3Plus5 n <-> decide n = true.\nProof.\n  split.\n  - intros H; induction H.\n    + easy.\n    + unfold decide in *; rewrite Nat.mul_mod; [|easy].\n      assert (mod_5 n) as Hm by apply mod_5_dec.\n      inversion Hm; subst; clear Hm; rewrite mod_5_mod_5 in *; try easy.\n      * replace (3 * (5 * n0 + 3)) with (9 + 15 * n0); [easy|ring].\n      * destruct n0; [easy|].\n        replace (3 * (5 * S n0 + 4)) with (27 + 15 * n0); [easy|ring].\n    + unfold decide in *; rewrite Nat.add_mod; [|easy].\n      assert (mod_5 n) as Hm by apply mod_5_dec.\n      inversion Hm; subst; clear Hm; rewrite mod_5_mod_5 in *; try easy.\n      * replace (5 + (5 * n0 + 2)) with (7 + 5 * n0); [|ring].\n        now do 4 (destruct n0; [easy|]; replace (5 * S n0) with (5 + 5 * n0); [|ring]).\n      * now replace (5 + (5 * n0 + 4)) with (9 + 5 * n0); [|ring].\n  - assert (mod_5 n) as Hm by apply mod_5_dec.\n    unfold decide; inversion Hm; subst; clear Hm; rewrite mod_5_mod_5; try easy.\n    + intros _; apply mod_simpl, Start.\n    + intros H; do 5 (destruct n0 as [|n0]; [easy|]; replace (5 * S n0) with (5 + 5 * n0); [|ring]); clear H.\n      replace (5 + (5 + (5 + (5 + (5 + 5 * n0)))) + 2) with (5 * n0 + (3 * (3 * (3 * 1)))); [|ring].\n      apply mod_simpl, Times3, Times3, Times3, Start.\n    + intros _; replace 3 with (3 * 1); [|ring].\n      apply mod_simpl, Times3, Start.\n    + intros H; destruct n0 as [|n0]; [easy|]; clear H.\n      replace (5 * S n0 + 4) with (5 * n0 + (3 * (3 * 1))); [|ring].\n      apply mod_simpl, Times3, Times3, Start.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33157,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Arith Lia ssrbool ssreflect.\nImport Nat.\n\nHint Resolve Start : core.\n\nLemma Times3Plus5_3 : Times3Plus5 3.\nProof. by rewrite -(mult_1_r 3); apply: Times3. Qed.\nHint Resolve Times3Plus5_3 : core.\n\nLemma Times3Plus5_9 : Times3Plus5 9.\nProof. by rewrite -[9]\/(3 * 3); apply: Times3. Qed.\nHint Resolve Times3Plus5_9 : core.\n\nLemma Times3Plus5_27 : Times3Plus5 27.\nProof. by rewrite -[27]\/(3 * 9); apply: Times3. Qed.\nHint Resolve Times3Plus5_27 : core.\n\nLemma Times3Plus5_Times5 (n m : nat) :\n  Times3Plus5 n -> Times3Plus5 (5 * m + n).\nProof.\n  move=> Pn.\n  elim: m => [\/\/|m IHm].\n  rewrite -(add_1_l m) mul_add_distr_l mul_1_r.\n  by apply: Plus5.\nQed.\n\nTheorem decide_works n : Times3Plus5 n <-> decide n = true.\nProof.\n  rewrite \/decide; split.\n    elim=> [\/\/|{}n _|{}n _].\n      rewrite mul_mod \/\/ -[3 mod 5]\/3.\n      case_eq (n mod 5) => \/\/; do 2!(case=> \/\/); case.\n        move: n; do 3!(case=> \/\/).\n        move=> n _ _ \/=; rewrite -[X in X = _]\/(9 <=? 3 * (S (S (S n)))).\n        by apply\/leb_spec0; lia.\n      case.\n        move=> _ \/leb_spec0 leq9n \/=.\n        by rewrite -[X in X = _]\/(27 <=? 3 * n); apply\/leb_spec0; lia.\n      move=> m nmod5; exfalso.\n      have : 5 <= n mod 5 by lia.\n      rewrite -[_ -> False]\/(~ _) nle_gt.\n      by apply: mod_upper_bound.\n    rewrite add_mod \/\/ mod_same \/\/ add_0_l mod_mod \/\/.\n    case: (n mod 5) => \/\/; case=> \/\/; case.\n      move=> \/leb_spec0 leq27n.\n      by apply\/leb_spec0; lia.\n    do 2!(case=> \/\/).\n    move=> \/leb_spec0 leq9n.\n    by apply\/leb_spec0; lia.\n  case_eq (n mod 5) => \/\/.\n  case.\n    move=> nmod5 _.\n    rewrite (div_mod n 5) \/\/ nmod5.\n    by apply: Times3Plus5_Times5.\n  case.\n    move=> nmod5 \/leb_spec0 leq27n.\n    suff [m ->] : exists m, n = 5 * m + 27 by apply: Times3Plus5_Times5.\n    rewrite (div_mod n 5) \/\/ nmod5.\n    exists (n \/ 5 - 5).\n    rewrite mul_sub_distr_l -add_sub_swap; last by lia.\n    by rewrite (add_le_mono_r _ _ (n mod 5)) {1}nmod5 -div_mod.\n  case.\n    move=> nmod5 _.\n    rewrite (div_mod n 5) \/\/ nmod5.\n    by apply: Times3Plus5_Times5.\n  case.\n    move=> nmod5 \/leb_spec0 leq9n.\n    suff [m ->] : exists m, n = 5 * m + 9 by apply: Times3Plus5_Times5.\n    rewrite (div_mod n 5) \/\/ nmod5.\n    exists (n \/ 5 - 1).\n    rewrite mul_sub_distr_l -add_sub_swap; last by lia.\n    by rewrite (add_le_mono_r _ _ (n mod 5)) {1}nmod5 -div_mod.\n  move=> m nmod5; exfalso.\n  have : 5 <= n mod 5 by lia.\n  rewrite -[_ -> False]\/(~ _) nle_gt.\n  by apply: mod_upper_bound.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33158,"user_id":null,"body":"Require Import Preloaded Arith.\n\nLemma induction_scheme : forall {P : nat -> Prop},\n  (forall n, P (5 * n)) ->\n  (forall n, P (5 * n + 1)) ->\n  (forall n, P 9 -> P (5 * n + 2)) ->\n  (forall n, P 1 -> P (5 * n + 3)) ->\n  (forall n, P 3 -> P (5 * n + 4)) ->\n  (forall n, P n).\nProof.\n  assert (1 = 5 * 0 + 1) as R1; [ring|].\n  assert (3 = 5 * 0 + 3) as R3; [ring|].\n  assert (9 = 5 * 1 + 4) as R9; [ring|].\n  intros P P0 P1 P2 P3 P4 n.\n  assert (exists m r, r < 5 \/\\ n = 5 * m + r) as [m [r [Hr Hm]]].\n  {\n    clear; set (P := fun n => exists m r, r < 5 \/\\ n = 5 * m + r).\n    cut (P n \/\\ P (S n) \/\\ P (S (S n)) \/\\ P (S (S (S n))) \/\\ P (S (S (S (S n)))));\n    [intros [H _]; easy|induction n].\n    - repeat split; exists 0.\n      + exists 0; split; [|easy]; repeat constructor.\n      + exists 1; split; [|easy]; repeat constructor.\n      + exists 2; split; [|easy]; repeat constructor.\n      + exists 3; split; [|easy]; repeat constructor.\n      + exists 4; split; [|easy]; repeat constructor.\n    - repeat split; try easy.\n      destruct IHn as [[m [r [Hr Hm]]] _]; exists (S m), r; split; [easy|rewrite Hm; ring].\n  }\n  rewrite Hm; do 5 try destruct r.\n  - rewrite Nat.add_comm; apply P0.\n  - apply P1.\n  - apply P2; rewrite R9; apply P4; rewrite R3; apply P3; rewrite R1; apply P1.\n  - apply P3; rewrite R1; apply P1.\n  - apply P4; rewrite R3; apply P3; rewrite R1; apply P1.\n  - inversion Hr; inversion H0; inversion H2; inversion H4; inversion H6; inversion H8.\nQed.\n\nLemma mod5 : forall n r, r < 5 -> (5 * n + r) mod 5 = r.\nProof.\n  intros; rewrite Nat.add_comm, Nat.mul_comm, Nat.mod_add; [|easy].\n  do 5 try destruct r; try easy.\n  inversion H; inversion H1; inversion H3; inversion H5; inversion H7; inversion H9.\nQed.\n\nLemma mod5_0 : forall n, (5 * n) mod 5 = 0.\nProof. intros; rewrite (plus_n_O (5 * n)); apply mod5; repeat constructor. Qed.\n\nLemma mod5_1 : forall n, (5 * n + 1) mod 5 = 1.\nProof. intros; apply mod5; repeat constructor. Qed.\n\nLemma mod5_2 : forall n, (5 * n + 2) mod 5 = 2.\nProof. intros; apply mod5; repeat constructor. Qed.\n\nLemma mod5_3 : forall n, (5 * n + 3) mod 5 = 3.\nProof. intros; apply mod5; repeat constructor. Qed.\n\nLemma mod5_4 : forall n, (5 * n + 4) mod 5 = 4.\nProof. intros; apply mod5; repeat constructor. Qed.\n\nLemma add_mod5 : forall n, (5 + n) mod 5 = n mod 5.\nProof.\n  intros; assert (5 + n = n + 1 * 5) as R; [ring|rewrite R; clear R].\n  rewrite Nat.mod_add; easy.\nQed.\n\nTheorem decide_works n : Times3Plus5 n <-> decide n = true.\nProof.\n  split.\n  - induction 1.\n    + easy.\n    + clear H; revert n IHTimes3Plus5; refine (induction_scheme _ _ _ _ _); unfold decide; intros n H.\n      * rewrite mod5_0 in H; easy.\n      * assert (3 * (5 * n + 1) = 5 * (3 * n) + 3) as R; [ring|rewrite R; clear R].\n        rewrite mod5_3; easy.\n      * intros H0. assert (3 * (5 * n + 2) = 5 * (3 * n + 1) + 1) as R; [ring|rewrite R; clear R].\n        rewrite mod5_1; easy.\n      * intros H0. assert (3 * (5 * n + 3) = 5 * (3 * n + 1) + 4) as R; [ring|rewrite R; clear R].\n        rewrite mod5_4; clear; induction n; [easy|].\n        assert (5 * (3 * S n + 1) + 4 = (5 * (3 * n + 1) + 4) + 15) as R; [ring|rewrite R; clear R].\n        apply leb_correct, le_plus_trans, leb_complete; easy.\n      * intros H0. assert (3 * (5 * n + 4) = 5 * (3 * n + 2) + 2) as R; [ring|rewrite R; clear R].\n        rewrite mod5_2; destruct n; [easy|]; clear; induction n; [easy|].\n        assert (5 * (3 * S (S n) + 2) + 2 = (5 * (3 * S n + 2) + 2) + 15) as R; [ring|rewrite R; clear R].\n        apply leb_correct, le_plus_trans, leb_complete; easy.\n    + unfold decide in *; rewrite add_mod5.\n      destruct (n mod 5); do 4 try destruct n0; try easy;\n      apply leb_correct; rewrite Nat.add_comm; apply le_plus_trans, leb_complete; easy.\n  - unfold decide; revert n; refine (induction_scheme _ _ _ _ _); intros.\n    + rewrite mod5_0 in *; easy.\n    + clear; induction n; [constructor|].\n      assert (5 * S n + 1 = 5 + (5 * n + 1)) as R; [ring|rewrite R; clear R].\n      constructor; easy.\n    + rewrite mod5_2 in *; specialize (H eq_refl).\n      do 5 try destruct n; try easy.\n      clear -H; induction n.\n      * assert (Times3Plus5 (3 * 9)); [apply Times3|]; easy.\n      * rewrite Nat.mul_succ_r, (Nat.add_comm _ 5), <- Nat.add_assoc.\n        constructor; easy.\n    + rewrite mod5_3 in *; specialize (H eq_refl).\n      clear -H; induction n.\n      * assert (Times3Plus5 (3 * 1)); [apply Times3|]; easy.\n      * assert (5 * S n + 3 = 5 + (5 * n + 3)) as R; [ring|rewrite R; clear R].\n        constructor; easy.\n    + rewrite mod5_4 in *; specialize (H eq_refl).\n      destruct n; [easy|].\n      clear -H; induction n.\n      * assert (Times3Plus5 (3 * 3)); [apply Times3|]; easy.\n      * rewrite Nat.mul_succ_r, (Nat.add_comm _ 5), <- Nat.add_assoc.\n        constructor; easy.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33159,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Arith Lia Nat.\n\n(* Set Printing Notations. *)\n\nLemma lm5kp1d : forall n, (exists k, n = 5*k+1) -> decide n = true.\nProof. intros. destruct H. rewrite H. \n       rewrite Nat.add_comm.\n       rewrite Nat.mul_comm.\n       assert (5 <> 0).\n       { auto. }\n       unfold decide.                 \n       rewrite (Nat.mod_add 1 x 5 H0). auto. Qed.\n\nLemma lm5kp1t' : forall n, Times3Plus5 (5*n+1).\nProof. induction n. simpl; apply Start.\n       assert (5*(S n)+1 = 5 + (5*n + 1)).\n       { lia. } rewrite H.\n       apply Plus5. auto. Qed.\n\nLemma lm5kp1t : forall n, (exists k, n = 5*k+1) -> Times3Plus5 n.\nProof. intros. destruct H as [k H']. rewrite H'. apply lm5kp1t'. Qed. \n\nLemma lm5kp3t' : forall n, Times3Plus5 (5*n+3).\nProof. induction n. simpl. assert (3= 3*1). { auto. } rewrite H. apply Times3. apply Start.\n       assert (5*(S n)+3 = 5 + (5*n + 3)). { lia. } rewrite H.\n       apply Plus5. auto. Qed.\n\nLemma lm5kp3t : forall n, (exists k, n = 5*k+3) -> Times3Plus5 n.\nProof. intros. destruct H as [k H']. rewrite H'. apply lm5kp3t'. Qed. \n\n(* Lemma lm5kp2t' : forall n, 5 <= n -> Times3Plus5 (5*n+2). *)\n\nLemma lm5kp2t' : forall n, 5 <= n -> Times3Plus5 (5*n+2).\nProof. induction n. intro. inversion H.\n       intro.\n       assert (n=4 \\\/ 5 <= n).\n       { inversion H. auto. auto. }\n       destruct H0.\n       - rewrite H0. simpl.\n         assert (27 = 3 * (3 * (3 * 1))). { auto. } rewrite H1; repeat apply Times3. apply Start.\n       - assert (5*S n + 2 = 5+(5*n+2)). { lia. } rewrite H1. apply Plus5. apply (IHn H0). Qed.\n\nLemma lm5kp2t : forall n, (exists k, n = 5*k+2) -> 27 <= n -> Times3Plus5 n.\nProof. intros. destruct H. rewrite H. apply lm5kp2t'. lia. Qed.\n\nLemma lm5kp4t' : forall n, 1 <= n -> Times3Plus5 (5*n+4).\nProof. induction n. intro. inversion H.\n       intro. assert (n=0 \\\/ 1 <= n). { lia. } destruct H0.\n       - rewrite H0. simpl.\n         assert (9 = 3 * (3 * 1)). { auto. } rewrite H1; repeat apply Times3. apply Start.\n       - assert (5*S n + 4 = 5+(5*n+4)). { lia. } rewrite H1. apply Plus5. apply (IHn H0). Qed.\n\nLemma lm5kp4t : forall n, (exists k, n = 5*k+4) -> 9 <= n -> Times3Plus5 n.\nProof. intros. destruct H. rewrite H. apply lm5kp4t'. lia. Qed.\n\n\nLemma lmmod1: forall n, n mod 5 = 1 -> exists k, n = 5*k + 1.\nProof. intros.\n       assert (4+n mod 5 = 5).\n       { lia. }\n       assert ((4+n mod 5) mod 5 = 5 mod 5).\n       { auto. }\n       rewrite Nat.add_mod_idemp_r in H1.\n       assert (5 mod 5 = 0).\n       { auto. }\n       rewrite H2 in H1. destruct H2.\n       apply Nat.mod_divides in H1. simpl.\n       destruct H1. exists (pred x). lia. auto. auto. Qed.\n\nLemma lmmod2: forall n, n mod 5 = 2 -> exists k, n = 5*k + 2.\nProof. intros.\n       assert (3+n mod 5 = 5).\n       { lia. }\n       assert ((3+n mod 5) mod 5 = 5 mod 5).\n       { auto. }\n       rewrite Nat.add_mod_idemp_r in H1.\n       assert (5 mod 5 = 0).\n       { auto. }\n       rewrite H2 in H1. destruct H2.\n       apply Nat.mod_divides in H1. simpl.\n       destruct H1. exists (pred x). lia. auto. auto. Qed.\n\nLemma lmmod3: forall n, n mod 5 = 3 -> exists k, n = 5*k + 3.\nProof. intros.\n       assert (2+n mod 5 = 5).\n       { lia. }\n       assert ((2+n mod 5) mod 5 = 5 mod 5).\n       { auto. }\n       rewrite Nat.add_mod_idemp_r in H1.\n       assert (5 mod 5 = 0).\n       { auto. }\n       rewrite H2 in H1. destruct H2.\n       apply Nat.mod_divides in H1. simpl.\n       destruct H1. exists (pred x). lia. auto. auto. Qed.\n\nLemma lmmod4: forall n, n mod 5 = 4 -> exists k, n = 5*k + 4.\nProof. intros.\n       assert (1+n mod 5 = 5).\n       { lia. }\n       assert ((1+n mod 5) mod 5 = 5 mod 5).\n       { auto. }\n       rewrite Nat.add_mod_idemp_r in H1.\n       assert (5 mod 5 = 0).\n       { auto. }\n       rewrite H2 in H1. destruct H2.\n       apply Nat.mod_divides in H1. simpl.\n       destruct H1. exists (pred x). lia. auto. auto. Qed.\n\nLemma lm1 : forall n, decide n = true ->\n                      exists k, n=5*k+1 \\\/ (n=5*k+2 \/\\ n >= 27) \\\/ (n=5*k+3) \\\/ (n=5*k+4 \/\\ n>=9).\nProof. unfold decide. intros. destruct (n mod 5) eqn:h1. inversion H. destruct n0.\n       apply lmmod1 in h1. destruct h1. exists x. auto.\n       destruct n0. apply lmmod2 in h1. destruct h1. exists x. right. left. split. auto.\n       apply leb_complete. auto.\n       destruct n0. apply lmmod3 in h1. destruct h1. exists x. right. right. left. auto.\n       destruct n0. apply lmmod4 in h1. destruct h1. exists x. right. right. right. split. auto.\n       apply leb_complete. auto.\n       assert (n mod 5 < 5).\n       { apply Nat.mod_upper_bound. auto. }\n       rewrite h1 in H0. inversion H0. inversion H2. inversion H4. inversion H6.\n       inversion H8. inversion H10. Qed.\n  \nTheorem decide_works n : Times3Plus5 n <-> decide n = true.\nProof. split. intro. induction H. auto. intros.\n       apply lm1 in IHTimes3Plus5.\n       destruct IHTimes3Plus5. destruct H0.\n       - rewrite H0. assert (3*(5*x+1)=3+(3*x)*5).\n         { lia. } rewrite H1.\n         assert ((3+(3*x)*5) mod 5 = 3 mod 5).\n         { rewrite Nat.Private_NZDiv.mod_add. auto. auto. lia. lia. }\n         assert (3 mod 5 = 3).\n         { auto. } rewrite H3 in H2.\n         unfold decide. rewrite H2. auto.\n       - destruct H0. destruct H0. rewrite H0. assert (3*(5*x+2)=6+(3*x)*5).\n         { lia. } rewrite H2.\n         assert ((6+(3*x)*5) mod 5 = 6 mod 5).\n         { rewrite Nat.Private_NZDiv.mod_add. auto. auto. lia. lia. lia. }\n         assert (6 mod 5 = 1).\n         { auto. } rewrite H4 in H3.\n         unfold decide. rewrite H3. auto.\n         destruct H0. assert (3*(5*x+3)=9+(3*x)*5).\n         { lia. } rewrite H0.\n         assert ((9+(3*x)*5) mod 5 = 9 mod 5).\n         { rewrite Nat.Private_NZDiv.mod_add. auto. auto. lia. lia. lia. }\n         assert (9 mod 5 = 4).\n         { auto. } rewrite H3 in H2.\n         unfold decide. rewrite H1, H2. auto.\n         destruct H0. rewrite H0. assert (3*(5*x+4)=12+(3*x)*5).\n         { lia. } rewrite H2.\n         assert ((12+(3*x)*5) mod 5 = 12 mod 5).\n         { rewrite Nat.Private_NZDiv.mod_add. auto. auto. lia. lia. lia. }\n         assert (12 mod 5 = 2).\n         { auto. } rewrite H4 in H3.\n         unfold decide. rewrite H3. rewrite H0 in H1.\n         assert (forall x, 5*x + 4 >= 9 -> 27 <= 12+3*x*5).\n         { lia. } apply H5 in H1. apply leb_correct. auto.\n       - apply lm1 in IHTimes3Plus5. destruct IHTimes3Plus5.\n         destruct H0. rewrite H0. unfold decide.\n         assert ((5 + (5 * x + 1)) mod 5 = 1).\n         { cut (5 + (5 * x + 1) = 6+x*5). intro.\n           rewrite H1. rewrite Nat.Private_NZDiv.mod_add. auto. lia. lia. lia. lia. }\n         rewrite H1. auto.\n         destruct H0. destruct H0. rewrite H0. unfold decide.\n         assert ((5 + (5 * x + 2)) mod 5 = 2).\n         { cut (5 + (5 * x + 2) = 7+x*5). intro.\n           rewrite H2. rewrite Nat.Private_NZDiv.mod_add. auto. lia. lia. lia. lia. }\n         rewrite H2. apply leb_correct. rewrite <- H0. lia.\n         destruct H0. rewrite H0.\n         assert ((5 + (5 * x + 3)) mod 5 = 3).\n         { cut (5 + (5 * x + 3) = 8+x*5). intro.\n           rewrite H1. rewrite Nat.Private_NZDiv.mod_add. auto. lia. lia. lia. lia. }\n         unfold decide. rewrite H1. auto.\n         destruct H0. rewrite H0.\n         assert ((5 + (5 * x + 4)) mod 5 = 4).\n         { cut (5 + (5 * x + 4) = 9+x*5). intro.\n           rewrite H2. rewrite Nat.Private_NZDiv.mod_add. auto. lia. lia. lia. lia. }\n         unfold decide. rewrite H2. apply leb_correct. rewrite <- H0. lia.\n       - intro. apply lm1 in H. destruct H. destruct H.\n         + apply lm5kp1t. exists x. auto.\n         + destruct H. destruct H. apply lm5kp2t. exists x. auto. auto. destruct H.\n           apply lm5kp3t. exists x. auto. destruct H.\n           apply lm5kp4t. exists x. auto. auto. Qed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33160,"user_id":null,"body":"Require Import Arith Preloaded.\n\n\nDefinition number_form (n : nat) := exists x y, n = 3^x + 5 * y.\n\nLemma Times3Plus5_number_form : forall n, Times3Plus5 n <-> number_form n.\nProof.\n  split.\n  - intros; induction H.\n    + exists 0, 0; reflexivity.\n    + destruct IHTimes3Plus5, H0; rewrite H0; exists (S x), (3 * x0); simpl; ring.\n    + destruct IHTimes3Plus5, H0; rewrite H0; exists x, (S x0); ring.\n  - intros; destruct H, H; rewrite H; clear; induction x0.\n    + rewrite plus_comm; simpl; induction x.\n      * constructor.\n      * assert (3^S x = 3 * 3^x). simpl; ring.\n        rewrite H; constructor; exact IHx.\n    + assert (3^x + 5 * S x0 = 5 + (3^x + 5 * x0)). ring.\n      rewrite H; constructor; exact IHx0.\nQed.\n\nLemma step_induction : forall (P : nat -> Prop) k,\n  (forall n, n <= k -> P n) ->\n  (forall n, P n -> P (n + S k)) ->\n  (forall n, P n).\nProof.\n  intros P k Pn Pk. assert (forall n m, m <= k -> P (n + m)).\n  - induction n.\n    + exact Pn.\n    + intros; assert (S n + m = n + S m). ring. rewrite H0; clear H0; destruct (le_lt_or_eq _ _ H).\n      * exact (IHn _ (lt_le_S _ _ H0)).\n      * rewrite H0; refine (Pk _ _); assert (n = n + 0). ring. rewrite H1; exact (IHn _ (Nat.le_0_l _)).\n  - intros; assert (n = n + 0). ring. rewrite H0; clear H0.\n    exact (H _ _ (Nat.le_0_l _)).\nQed.\n\nLemma step_induction_5 : forall {P : nat -> Prop},\n  P 0 -> P 1 -> P 2 -> P 3 -> P 4 ->\n  (forall n, P n -> P (n + 5)) ->\n  (forall n, P n).\nProof.\n  intros; revert n; refine (step_induction _ _ _ H4).\n  intros; revert H H0 H1 H2 H3.\n  repeat (intro Hk; destruct n; try (intros; exact Hk); clear Hk).\n  assert (S n <= 0). do 4 refine (le_S_n _ _ _); exact H5.\n  case (Nat.nle_succ_0 _ H).\nQed.\n\nLemma step_induction_4 : forall {P : nat -> Prop},\n  P 0 -> P 1 -> P 2 -> P 3 ->\n  (forall n, P n -> P (n + 4)) ->\n  (forall n, P n).\nProof.\n  intros; revert n; refine (step_induction _ _ _ H3).\n  intros; revert H H0 H1 H2.\n  repeat (intro Hk; destruct n; try (intros; exact Hk); clear Hk).\n  assert (S n <= 0). do 3 refine (le_S_n _ _ _); exact H4.\n  case (Nat.nle_succ_0 _ H).\nQed.\n\nLemma dif50 : 5 <> 0.\nProof. intro; discriminate. Qed.\n\nLemma dif40 : 4 <> 0.\nProof. intro; discriminate. Qed.\n\nLemma plus_5_mod_5 : forall n, (n + 5) mod 5 = n mod 5.\nProof.\n  refine (step_induction_5 _ _ _ _ _ _); try reflexivity.\n  intros; rewrite (Nat.add_mod _ _ _ dif50), H.\n  assert (n mod 5 + 5 mod 5 = n mod 5). rewrite plus_comm; reflexivity.\n  rewrite H0, (Nat.mod_mod _ _ dif50); reflexivity.\nQed.\n\nLemma mult5 : forall x, exists y z, z <= 4 \/\\ x = 5 * y + z.\nProof.\n  refine (step_induction_5 _ _ _ _ _ _); try refine (ex_intro _ 0 (ex_intro _ _ (conj _ eq_refl)));\n  try repeat constructor.\n  intros; destruct H, H, H; exists (S x), x0; split.\n  - exact H.\n  - rewrite H0; ring.\nQed.\n\nLemma mult4 : forall x, exists y z, z <= 3 \/\\ x = 4 * y + z.\nProof.\n  refine (step_induction_4 _ _ _ _ _); try refine (ex_intro _ 0 (ex_intro _ _ (conj _ eq_refl)));\n  try repeat constructor.\n  intros; destruct H, H, H; exists (S x), x0; split.\n  - exact H.\n  - rewrite H0; ring.\nQed.\n\nLemma mod4mod5 : forall x, (3^x) mod 5 = (3^(x mod 4)) mod 5.\nProof.\n  refine (step_induction_4 _ _ _ _ _); try (simpl; reflexivity); intros.\n  assert (3^(n + 4) = 81 * 3^n). rewrite plus_comm, Nat.pow_add_r; reflexivity.\n  rewrite H0, <- (Nat.mul_mod_idemp_l _ _ _ dif50), Nat.mul_1_l, H, plus_comm, <- (Nat.add_mod_idemp_l _ _ _ dif40); reflexivity.\nQed.\n\nLemma special_induction_scheme : forall {P : nat -> Prop},\n  (forall n, P (5 * n + 0)) ->\n  (forall n, P (5 * n + 1)) ->\n  (forall n, P (5 * n + 2)) ->\n  (forall n, P (5 * n + 3)) ->\n  (forall n, P (5 * n + 4)) ->\n  (forall n, P n).\nProof.\n  intros; destruct (mult5 n), H4, H4; do 5 try destruct x0.\n  - rewrite H5; exact (H _).\n  - rewrite H5; exact (H0 _).\n  - rewrite H5; exact (H1 _).\n  - rewrite H5; exact (H2 _).\n  - rewrite H5; exact (H3 _).\n  - assert (S x0 <= 0). do 4 refine (le_S_n _ _ _); exact H4.\n    case (Nat.nle_succ_0 _ H6).\nQed.\n\nLemma decide_number_form : forall n, decide n = true <-> number_form n.\nProof.\n  split.\n  - revert n; refine (special_induction_scheme _ _ _ _ _); unfold decide; intros.\n    + rewrite plus_comm, mult_comm, (Nat.mod_add _ _ _ dif50) in H; discriminate.\n    + exists 0, n; simpl; ring.\n    + rewrite plus_comm, mult_comm, (Nat.mod_add _ _ _ dif50) in H.\n      do 5 (destruct n; try discriminate).\n      exists 3, n; simpl; ring.\n    + exists 1, n; simpl; ring.\n    + rewrite plus_comm, mult_comm, (Nat.mod_add _ _ _ dif50) in H.\n      destruct n; try discriminate.\n      exists 2, n; simpl; ring.\n  - intros H; destruct H, H; rewrite H; clear; unfold decide.\n    rewrite mult_comm, (Nat.mod_add _ _ _ dif50), mod4mod5; destruct (mult4 x), H, H.\n    rewrite H0; clear x H0; do 4 try destruct x2; rewrite plus_comm, mult_comm, (Nat.mod_add _ _ _ dif40).\n    + reflexivity.\n    + reflexivity.\n    + assert (9 <= 3^(2 + x1 * 4) + x0 * 5).\n      {\n        induction x1.\n        - refine (le_plus_trans _ _ _ _); reflexivity.\n        - assert (2 + S x1 * 4 = 4 + (2 + x1 * 4)). ring.\n          rewrite H0, Nat.pow_add_r; clear H0.\n          assert (3 ^ 4 = 80 + 1). reflexivity.\n          rewrite H0, Nat.mul_add_distr_r, <- plus_assoc, plus_comm, Nat.mul_1_l; clear H0.\n          exact (le_plus_trans _ _ _ IHx1).\n      }\n      rewrite (leb_correct _ _ H0); reflexivity.\n    + assert (27 <= 3^(3 + x1 * 4) + x0 * 5).\n      {\n        induction x1.\n        - refine (le_plus_trans _ _ _ _); reflexivity.\n        - assert (3 + S x1 * 4 = 4 + (3 + x1 * 4)). ring.\n          rewrite H0, Nat.pow_add_r; clear H0.\n          assert (3 ^ 4 = 80 + 1). reflexivity.\n          rewrite H0, Nat.mul_add_distr_r, <- plus_assoc, plus_comm, Nat.mul_1_l; clear H0.\n          exact (le_plus_trans _ _ _ IHx1).\n      }\n      rewrite (leb_correct _ _ H0); reflexivity.\n    + assert (S x2 <= 0). do 3 refine (le_S_n _ _ _); exact H.\n      case (Nat.nle_succ_0 _ H0).\nQed.\n\nTheorem decide_works n : Times3Plus5 n <-> decide n = true.\nProof.\n  refine (iff_trans (Times3Plus5_number_form n) _); symmetry; exact (decide_number_form n).\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33161,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Arith Lia.\n\nLemma many_Plus5 : forall n m, Times3Plus5 n -> Times3Plus5 (5 * m + n).\nProof.\n  intros. induction m.\n  - rewrite Nat.mul_0_r. assumption.\n  - rewrite Nat.mul_succ_r.\n    rewrite (Nat.add_comm _ 5).\n    rewrite <- Nat.add_assoc. constructor.\n    assumption.\nQed.\n\nTheorem decide_works n : Times3Plus5 n <-> decide n = true.\nProof.\n  split; intros.\n  - induction H.\n    + reflexivity.\n    + unfold decide in *.\n      rewrite Nat.mul_mod by discriminate.\n      assert (n mod 5 = 0 \\\/ n mod 5 = 1 \\\/ n mod 5 = 2 \\\/ n mod 5 = 3 \\\/ n mod 5 = 4) as Ha.\n      { pose proof (Nat.mod_upper_bound n 5 ltac:(discriminate)). lia. }\n      destruct Ha as [Ha|[Ha|[Ha|[Ha|Ha]]]]; rewrite Ha in *;\n        try reflexivity; try discriminate.\n      * cbn -[Nat.leb]. fold (3 * n).\n        apply Nat.leb_le.\n        pose proof (Nat.div_mod n 5 ltac:(discriminate)). lia.\n      * cbn -[Nat.leb]. fold (3 * n).\n        apply Nat.leb_le in IHTimes3Plus5.\n        apply Nat.leb_le. lia.\n    + unfold decide in *.\n      rewrite <- Nat.add_mod_idemp_l by discriminate.\n      rewrite Nat.mod_same by discriminate.\n      rewrite Nat.add_0_l.\n      assert (n mod 5 = 0 \\\/ n mod 5 = 1 \\\/ n mod 5 = 2 \\\/ n mod 5 = 3 \\\/ n mod 5 = 4) as Ha.\n      { pose proof (Nat.mod_upper_bound n 5 ltac:(discriminate)). lia. }\n      destruct Ha as [Ha|[Ha|[Ha|[Ha|Ha]]]]; rewrite Ha in *;\n        try reflexivity; try discriminate.\n      * apply Nat.leb_le in IHTimes3Plus5. apply Nat.leb_le. lia.\n      * apply Nat.leb_le in IHTimes3Plus5. apply Nat.leb_le. lia.\n  - unfold decide in H.\n    pose proof (Nat.div_mod n 5 ltac:(discriminate)) as Hmod.\n    assert (n mod 5 = 0 \\\/ n mod 5 = 1 \\\/ n mod 5 = 2 \\\/ n mod 5 = 3 \\\/ n mod 5 = 4) as Ha.\n    { pose proof (Nat.mod_upper_bound n 5 ltac:(discriminate)). lia. }\n    destruct Ha as [Ha|[Ha|[Ha|[Ha|Ha]]]]; rewrite Ha in *; try discriminate;\n      rewrite Hmod.\n    + apply many_Plus5. constructor.\n    + apply Nat.leb_le in H.\n      replace (n \/ 5) with ((n \/ 5 - 5) + 5) by lia.\n      rewrite Nat.mul_add_distr_l.\n      rewrite <- Nat.add_assoc.\n      apply many_Plus5. cbn.\n      apply (@Times3 9).\n      apply (@Times3 3).\n      apply (@Times3 1).\n      constructor.\n    + apply many_Plus5.\n      apply (@Times3 1). constructor.\n    + apply Nat.leb_le in H.\n      replace (n \/ 5) with ((n \/ 5 - 1) + 1) by lia.\n      rewrite Nat.mul_add_distr_l.\n      rewrite <- Nat.add_assoc.\n      apply many_Plus5. cbn.\n      apply (@Times3 3).\n      apply (@Times3 1).\n      constructor.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33162,"user_id":null,"body":"Require Import Preloaded.\n\nRequire Import Omega Lia.\nHint Constructors Times3Plus5 : core.\n\nLemma n_mod_five_inv n : n mod 5 = 0 \\\/ n mod 5 = 1 \\\/\n                         n mod 5 = 2 \\\/ n mod 5 = 3 \\\/\n                         n mod 5 = 4.\nProof. pose proof (Nat.mod_upper_bound n 5); try lia. Qed.\n\nLemma decide_add_five n : decide n = true -> decide (5 + n) = true.\nProof.\n  intros Hdec.\n  unfold decide in *.\n  replace (5 + n) with (n + 1 * 5) by lia.\n  rewrite (Nat.mod_add n 1 5); try lia.\n  replace (n + 1 * 5) with (n + 5); try lia.\n  pose proof (n_mod_five_inv n) as [Hmod | [Hmod | [Hmod | [Hmod | Hmod]]]];\n    rewrite Hmod in *; clear Hmod; auto;\n      apply leb_complete in Hdec;\n      apply leb_correct; lia.\nQed.\n\nLemma decide_mult_three n : decide n = true -> decide (3 * n) = true.\nProof.\n  intros Hdec. unfold decide in *.\n  pose proof (n_mod_five_inv n) as [Hmod | [Hmod | [Hmod | [Hmod | Hmod]]]];\n    rewrite Hmod in *.\n  - inversion Hdec.\n  - rewrite Nat.mul_mod; try lia. rewrite Hmod. auto.\n  - rewrite Nat.mul_mod; try lia. rewrite Hmod. auto.\n  - rewrite Nat.mul_mod; try lia. rewrite Hmod.\n    replace (3 mod 5) with 3 by auto. replace (3 * 3) with 9 by lia.\n    replace (9 mod 5) with 4 by auto. apply leb_correct.\n    pose proof Nat.div_mod n 5 as Heqn.\n    assert (5 <> 0) as Hneq by lia; specialize (Heqn Hneq); clear Hneq.\n    rewrite Hmod in Heqn. destruct (Nat.lt_ge_cases n 3); lia.\n  - rewrite Nat.mul_mod; try lia. rewrite Hmod.\n    replace (3 mod 5) with 3 by auto. replace (3 * 4) with 12 by lia.\n    replace (12 mod 5) with 2 by auto.\n    apply leb_complete in Hdec. apply leb_correct. lia.\nQed.\n\nCorollary left_to_right n : Times3Plus5 n -> decide n = true.\nProof.\n  induction 1 as [| n _ IH | n _ IH ];\n    auto using decide_add_five, decide_mult_three.\nQed.\n\nLemma decide_inv n : decide n = true ->\n                     n mod 5 = 1 \\\/ n mod 5 = 3 \\\/\n                     (n mod 5 = 2 \/\\ 27 <= n) \\\/\n                     (n mod 5 = 4 \/\\ 9 <= n).\nProof.\n  intros Hdec. unfold decide in *.\n  pose proof (n_mod_five_inv n) as [Hmod | [Hmod | [Hmod | [Hmod | Hmod]]]];\n    rewrite Hmod in Hdec; try solve[simpl in Hdec; auto].\n  - inversion Hdec.\n  - right; right; left. split; auto using leb_correct, leb_complete.\n  - right; right; right. split; auto using leb_correct, leb_complete.\nQed.\n\nLemma right_to_left n : decide n = true -> Times3Plus5 n.\nProof.\n  intros Hdec.\n  destruct (decide_inv n Hdec) as [Hmod | [Hmod | [[Hmod Hgeq] | [Hmod Hgeq]]]];\n    clear Hdec;\n    pose proof Nat.div_mod n 5 as Heqn;\n    assert (5 <> 0) as Hneq by lia; specialize (Heqn Hneq); clear Hneq;\n      rewrite Hmod in Heqn; clear Hmod; remember (n \/ 5) as q; clear Heqq; subst.\n  - induction q; auto.\n    replace (5 * S q + 1) with (5 + (5 * q + 1)) by lia; auto.\n  - induction q.\n    + simpl. replace 3 with (3 * 1) by lia. auto.\n    + replace (5 * S q + 3) with (5 + (5 * q + 3)) by lia; auto.\n  - assert (q >= 5) by lia; clear Hgeq; rename H into Hgeq. induction q.\n    + inversion Hgeq.\n    + destruct (Nat.lt_ge_cases q 5) as [Hcontra | Hrequired].\n      * assert (q = 4) by lia; subst.\n        replace (5 * 5 + 2) with (3 * (3 * (3 * 1))) by lia. auto.\n      * specialize (IHq Hrequired).\n        replace (5 * S q + 2) with (5 + (5 * q + 2)) by lia. auto.\n  - assert (q >= 1) by lia; clear Hgeq; rename H into Hgeq. induction q.\n    + inversion Hgeq.\n    + destruct (Nat.lt_ge_cases q 1) as [Hcontra | Hrequired].\n      * assert (q = 0) by lia; subst.\n        replace (5 * 1 + 4) with (3 * (3 * 1)) by lia. auto.\n      * specialize (IHq Hrequired).\n        replace (5 * S q + 4) with (5 + (5 * q + 4)) by lia. auto.\nQed.\n\nTheorem decide_works n : Times3Plus5 n <-> decide n = true.\nProof.\n  split; auto using left_to_right, right_to_left.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5e8aa432792ce30025db012e":[{"id":33163,"user_id":null,"body":"Require Import Classical  Lia Arith.\nImport Nat.\n\nLemma rem3_cases: forall n : nat, exists m, n = 3 * m \\\/ n = S (3 * m) \\\/ n = S (S (3 * m)).\nProof.\n  intros.\n  induction n.\n  exists 0. auto.\n  destruct n. exists 0. auto.\n  destruct n. exists 0. auto.\n  destruct IHn.\n  destruct H.\n    exists x. lia.\n  destruct H.\n    exists x. lia.\n  exists (S x). lia.\nQed.\n\nTheorem easy_fermat (a b c : nat) :\n  a ^ 3 + b ^ 3 = c ^ 3 -> (3 | a * b * c).\nProof.\n  unfold divide.\n  intros.\n  destruct (rem3_cases a).\n  destruct (rem3_cases b).\n  destruct (rem3_cases c).\n  simpl in *.\n  destruct H0. exists (x * b * c). lia.\n  destruct H1. exists (x0 * a * c). lia.\n  destruct H2. exists (x1 * a * b). lia. lia.\nQed.\n\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33164,"user_id":null,"body":"Require Import Arith Classical.\nImport Nat.\n\nInductive mod3 : nat -> Prop :=\n| m03 : forall n, mod3 (3 * n + 0)\n| m13 : forall n, mod3 (3 * n + 1)\n| m23 : forall n, mod3 (3 * n + 2).\n\nLemma induction_step3 : forall (P : nat -> Prop), P 0 -> P 1 -> P 2 -> (forall n, P n -> P (S (S (S n)))) -> (forall n, P n).\nProof.\n  intros P P0 P1 P2 PSSS n; cut (P n \/\\ P (S n) \/\\ (P (S (S n)))); [easy|].\n  induction n; [easy|].\n  split; [|split; [|apply PSSS]]; easy.\nQed.\n\nLemma all_mod3 : forall n, mod3 n.\nProof.\n  induction n using induction_step3.\n  - apply (m03 0).\n  - apply (m13 0).\n  - apply (m23 0).\n  - assert (forall n m, S (S (S (3 * n + m))) = 3 * S n + m) as R; [intros; ring|].\n    inversion IHn; subst; rewrite R; constructor.\nQed.\n\nLemma cube_mod3_0 : forall n, exists m, (3 * n + 0) ^ 3 = 9 * m + 0.\nProof.\n  intros n; exists (3 * n ^ 3); unfold Nat.pow; ring.\nQed.\n\nLemma cube_mod3_1 : forall n, exists m, (3 * n + 1) ^ 3 = 9 * m + 1.\nProof.\n  intros n; exists (3 * n^3 + 3 * n^2 + n); unfold Nat.pow; ring.\nQed.\n\nLemma cube_mod3_2 : forall n, exists m, (3 * n + 2) ^ 3 = 9 * m + 8.\nProof.\n  intros n; exists (3 * n^3 + 6 * n^2 + 4 * n); unfold Nat.pow; ring.\nQed.\n\nLemma cube_mod9_not2 : forall n m, n ^ 3 <> 9 * m + 2.\nProof.\n  intros n m; specialize (all_mod3 n); intros Hn; inversion Hn.\n  - destruct (cube_mod3_0 n0) as [n' Hn']; rewrite Hn'.\n    intros F; apply mod_unique in F; [|do 6 apply le_S; apply le_n].\n    now rewrite mul_comm, add_comm, mod_add in F.\n  - destruct (cube_mod3_1 n0) as [n' Hn']; rewrite Hn'.\n    intros F; apply mod_unique in F; [|do 6 apply le_S; apply le_n].\n    now rewrite mul_comm, add_comm, mod_add in F.\n  - destruct (cube_mod3_2 n0) as [n' Hn']; rewrite Hn'.\n    intros F; apply mod_unique in F; [|do 6 apply le_S; apply le_n].\n    now rewrite mul_comm, add_comm, mod_add in F.\nQed.\n\nLemma cube_mod9_not7 : forall n m, n ^ 3 <> 9 * m + 7.\nProof.\n  intros n m; specialize (all_mod3 n); intros Hn; inversion Hn.\n  - destruct (cube_mod3_0 n0) as [n' Hn']; rewrite Hn'.\n    intros F; apply mod_unique in F; [|apply le_S, le_n].\n    now rewrite mul_comm, add_comm, mod_add in F.\n  - destruct (cube_mod3_1 n0) as [n' Hn']; rewrite Hn'.\n    intros F; apply mod_unique in F; [|apply le_S, le_n].\n    now rewrite mul_comm, add_comm, mod_add in F.\n  - destruct (cube_mod3_2 n0) as [n' Hn']; rewrite Hn'.\n    intros F; apply mod_unique in F; [|apply le_S, le_n].\n    now rewrite mul_comm, add_comm, mod_add in F.\nQed.\n\nLemma cube_mod9_0 : forall n m, n ^ 3 = 9 * m + 0 -> exists n', n = 3 * n' + 0.\nProof.\n  intros n m Hn; specialize (all_mod3 n); intros H; inversion H; subst; clear H.\n  - now exists n0.\n  - destruct (cube_mod3_1 n0) as [n' Hn']; rewrite Hn' in Hn.\n    apply mod_unique in Hn; [|do 8 apply le_S; apply le_n].\n    now rewrite mul_comm, add_comm, mod_add in Hn.\n  - destruct (cube_mod3_2 n0) as [n' Hn']; rewrite Hn' in Hn.\n    apply mod_unique in Hn; [|do 8 apply le_S; apply le_n].\n    now rewrite mul_comm, add_comm, mod_add in Hn.\nQed.\n\nTheorem easy_fermat (a b c : nat) :\n  a ^ 3 + b ^ 3 = c ^ 3 -> (3 | a * b * c).\nProof.\n  specialize (all_mod3 a); intros Ha; inversion Ha; subst; clear Ha.\n  - intros _; exists (n * b * c); ring.\n  - specialize (all_mod3 b); intros Hb; inversion Hb; subst; clear Hb.\n    + intros _; exists ((3 * n + 1) * n0 * c); ring.\n    + intros F; cut (exists c', c^3 = 9 * c' + 2); [intros [c' Hc']; now apply cube_mod9_not2 in Hc'|].\n      destruct (cube_mod3_1 n) as [a Ha]; rewrite Ha in F.\n      destruct (cube_mod3_1 n0) as [b Hb]; rewrite Hb in F.\n      exists (a + b); rewrite <- F; ring.\n    + destruct (cube_mod3_1 n) as [a Ha]; rewrite Ha.\n      destruct (cube_mod3_2 n0) as [b Hb]; rewrite Hb.\n      replace (9 * a + 1 + (9 * b + 8)) with (9 * (a + b + 1) + 0); [clear|ring].\n      intros H; symmetry in H; apply cube_mod9_0 in H; destruct H; subst.\n      exists ((3 * n + 1) * (3 * n0 + 2) * x); ring.\n  - specialize (all_mod3 b); intros Hb; inversion Hb; subst; clear Hb.\n    + intros _; exists ((3 * n + 2) * n0 * c); ring.\n    + destruct (cube_mod3_2 n) as [a Ha]; rewrite Ha.\n      destruct (cube_mod3_1 n0) as [b Hb]; rewrite Hb.\n      replace (9 * a + 8 + (9 * b + 1)) with (9 * (a + b + 1) + 0); [clear|ring].\n      intros H; symmetry in H; apply cube_mod9_0 in H; destruct H; subst.\n      exists ((3 * n + 2) * (3 * n0 + 1) * x); ring.\n    + intros F; cut (exists c', c^3 = 9 * c' + 7); [intros [c' Hc']; now apply cube_mod9_not7 in Hc'|].\n      destruct (cube_mod3_2 n) as [a Ha]; rewrite Ha in F.\n      destruct (cube_mod3_2 n0) as [b Hb]; rewrite Hb in F.\n      exists (a + b + 1); rewrite <- F; ring.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33165,"user_id":null,"body":"Require Import Arith Classical.\nImport Nat.\n\nLemma induction_scheme : forall {P : nat -> Prop},\n  P 0 -> P 1 -> P 2 ->\n  (forall n, P n -> P (S (S (S n)))) ->\n  (forall n, P n).\nProof.\n  intros P P0 P1 P2 PS n; cut (P n \/\\ P (S n) \/\\ P (S (S n))); [now intros [H _]|].\n  induction n; [easy|].\n  repeat split; try easy.\n  now apply PS.\nQed.\n\nLemma fermat_cases : forall n,\n  (3 | n) \\\/\n  ((n ^ 3) mod 9 = 1) \\\/\n  ((n ^ 3) mod 9 = 8).\nProof.\n  apply induction_scheme.\n  - left; now exists 0.\n  - right; now left.\n  - right; now right.\n  - assert (forall n, S (S (S n)) ^ 3 = n ^ 3 + 9 * (n ^ 2 + 3 * n + 3)) as R; [intros; simpl; ring|].\n    intros n [[m IH]|[IH|IH]].\n    + left; exists (S m); rewrite IH; ring.\n    + right; left; rewrite R, add_mod, IH, mul_comm, mod_mul; try easy; ring.\n    + right; right; rewrite R, add_mod, IH, mul_comm, mod_mul; try easy; ring.\nQed.\n\nTheorem easy_fermat (a b c : nat) :\n  a ^ 3 + b ^ 3 = c ^ 3 -> (3 | a * b * c).\nProof.\n  intros.\n  destruct (fermat_cases a) as [|Ha]; [now apply divide_mul_l, divide_mul_l|].\n  destruct (fermat_cases b) as [|Hb]; [now apply divide_mul_l, divide_mul_r|].\n  destruct (fermat_cases c) as [|Hc]; [now apply divide_mul_r|].\n  assert ((a ^ 3 + b ^ 3) mod 9 = (c ^ 3) mod 9) as F; [now rewrite H|contradict F].\n  rewrite add_mod; [|easy].\n  destruct Ha as [Ha|Ha], Hb as [Hb|Hb], Hc as [Hc|Hc];\n  now rewrite Ha, Hb, Hc.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33166,"user_id":null,"body":"Require Import ZArith Lia Classical.\nRequire Import Ring.\nImport Z. Open Scope Z_scope.\n\nLemma fact1 : forall a b c, a ^ 3 + b ^ 3 = c ^ 3 -> (c - (a + b)) mod 3 = 0.\nProof.\n  intros.\n  pose proof (mod_pos_bound a 3 ltac:(lia)) as Ha.\n  pose proof (mod_pos_bound b 3 ltac:(lia)) as Hb.\n  pose proof (mod_pos_bound c 3 ltac:(lia)) as Hc.\n  assert (forall n, 0 <= n < 3 -> n = 0 \\\/ n = 1 \\\/ n = 2) as Hcases by lia.\n  apply Hcases in Ha.\n  apply Hcases in Hb.\n  apply Hcases in Hc.\n  rewrite Zminus_mod, Zplus_mod.\n  apply (f_equal (fun n => n mod 3)) in H.\n  rewrite Zplus_mod in H.\n  assert (forall z, z ^ 3 = z * z * z) as Hcube by lia.\n  rewrite 3!Hcube in H. rewrite <- !mul_assoc in H.\n  rewrite 2!(mul_mod a) in H by congruence.\n  rewrite 2!(mul_mod b) in H by congruence.\n  rewrite 2!(mul_mod c) in H by congruence.\n  destruct Ha as [Ha|[Ha|Ha]]; rewrite Ha in *;\n  destruct Hb as [Hb|[Hb|Hb]]; rewrite Hb in *;\n  destruct Hc as [Hc|[Hc|Hc]]; rewrite Hc in *;\n    try reflexivity; discriminate.\nQed.\n\nLemma Z_mod_plus_full' :\n  forall a b c d : Z, c <> 0 -> d mod c = 0 -> (a + d * b) mod c = a mod c.\nProof.\n  intros.\n  apply mod_divide in H0; try assumption.\n  destruct H0 as (q & H0).\n  subst. rewrite <- Z.mul_assoc. rewrite (Z.mul_comm c). rewrite Z.mul_assoc.\n  rewrite Z_mod_plus_full.\n  reflexivity.\nQed.\n\nLemma fact2 : forall a b c, a ^ 3 + b ^ 3 = c ^ 3 -> a * b * c mod 3 = 0.\nProof.\n  intros. apply fact1 in H as H0.\n  apply mod_divide in H0; try congruence.\n  destruct H0 as (k & H0).\n  apply sub_move_r in H0. rewrite H0 in H. symmetry in H.\n  apply sub_move_0_r in H. ring_simplify in H.\n  replace (27 * k ^ 3 + 27 * k ^ 2 * a + 27 * k ^ 2 * b + 9 * k * a ^ 2 + 18 * k * a * b + 9 * k * b ^ 2 + 3 * a ^ 2 * b + 3 * a * b ^ 2)\n    with (3 * (9 * k ^ 3 + 9 * k ^ 2 * a + 9 * k ^ 2 * b + 3 * k * a ^ 2 + 6 * k * a * b + 3 * k * b ^ 2 + a ^ 2 * b + a * b ^ 2))\n    in H by ring.\n  apply mul_eq_0_r in H; try congruence.\n  apply (f_equal (fun n => n mod 3)) in H.\n  rewrite <- Z.add_assoc in H. rewrite Z.add_comm in H. rewrite !Z.add_assoc in H.\n  rewrite <- !Z.mul_assoc in H.\n  rewrite !Z_mod_plus_full' in H by (cbn; congruence).\n  rewrite H0.\n  replace (a * b * (k * 3 + (a + b))) with (a ^ 2 * b + a * b ^ 2 + 3 * (k * a * b)) by ring.\n  rewrite Z_mod_plus_full' by (cbn; congruence).\n  assumption.\nQed.\n\nImport Nat. Open Scope nat_scope.\n\nTheorem easy_fermat : forall a b c, a ^ 3 + b ^ 3 = c ^ 3 -> (3 | a * b * c).\nProof.\n  intros.\n  assert ((Z.of_nat a) ^ 3 + (Z.of_nat b) ^ 3 = (Z.of_nat c) ^ 3)%Z.\n  { apply (f_equal Z.of_nat) in H. cbn. cbn in H. lia. }\n  apply fact2 in H0.\n  apply Z.mod_divide in H0; try discriminate.\n  destruct H0 as (k & H0).\n  exists (Z.to_nat k). lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33167,"user_id":null,"body":"Require Import Arith Classical.\nImport Nat.\nRequire Import Lia.\n \nLemma induction_SSS_proof:\n  forall (P : nat -> Prop),\n  P 0 -> P 1 -> P 2 -> (forall n', P n' -> P (3 + n')) -> (forall n, P n).\nProof.\n  intros P HP0 HP1 HP2 HPSSSn.\n  pose (Q := fun n' => P n' \/\\ P (1 + n') \/\\ P (2 + n')).\n  enough (forall n, Q n). {\n    intros n; destruct (H n); auto.\n  }\n  induction n; unfold Q; auto.\n  repeat split; destruct IHn as [IHn [IHSn IHSSn]]; simpl in *; auto.\nQed.\n\nLemma mod_3_spec:\n  forall n, exists q m, m < 3 \/\\ n = 3 * q + m.\nProof.\n  intro n.\n  apply induction_SSS_proof with (P := fun n => exists q m : nat, m < 3 \/\\ n = 3 * q + m).\n  - exists 0, 0; lia.\n  - exists 0, 1; lia.\n  - exists 0, 2; lia.\n  - clear n.\n    intros n [q [m [Hm Hn]]].\n    exists (S q), m; lia.\nQed.\n\nLemma fermat_3_mod_3:\n  forall a b c x y z,\n  (3*a + x)^3 + (3*b + y)^3 = (3*c + z)^3 -> (x^3 + y^3) mod 9 = z^3 mod 9.\nProof.\n  intros a b c x y z (* Hx Hy Hz *) H.\n  assert (((3 * a + x) ^ 3 + (3 * b + y) ^ 3) mod 9 = (3 * c + z) ^ 3 mod 9) as He\n    by (rewrite H; reflexivity).\n  rewrite add_mod in He; auto.\n  assert (forall p q, (3 * p + q) ^ 3 mod 9 = q ^ 3 mod 9) as Hmod. {\n    induction p; auto.\n    intros q.\n    specialize (IHp q).\n    remember (3*p + q) as r.\n    replace (3 * S p + q) with (3 + r) by lia.\n    replace ((3 + r)^3 mod 9) with (r^3 mod 9); auto.\n    replace ((3 + r)^3) with (9 * (3 + 3*r + r*r) + r^3) by (simpl; lia).\n    rewrite add_mod; auto.\n    rewrite mul_mod; auto.\n    replace (9 mod 9) with 0 by reflexivity.\n    rewrite mul_0_l.\n    replace (0 mod 9) with 0 by reflexivity.\n    rewrite add_0_l.\n    rewrite mod_mod; auto.\n  }\n  repeat rewrite Hmod in He.\n  rewrite add_mod; auto.\nQed.\n\n\nTheorem easy_fermat (a b c : nat) :\n  a ^ 3 + b ^ 3 = c ^ 3 -> (3 | a * b * c).\nProof.\n  intros.\n  destruct (mod_3_spec a) as [qa [ma [Hma Ha]]].\n  destruct (mod_3_spec b) as [qb [mb [Hmb Hb]]].\n  destruct (mod_3_spec c) as [qc [mc [Hmc Hc]]].\n  unfold divide; apply Classical_Prop.NNPP; intro Hdiv.\n  pose proof (not_ex_all_not _ _ Hdiv).\n    clear Hdiv; rename H0 into Hdiv; simpl in Hdiv.\n  subst a b c.\n  apply fermat_3_mod_3 in H.\n  repeat (destruct ma as [| ma]; try lia);\n  repeat (destruct mb as [| mb]; try lia);\n  repeat (destruct mc as [| mc]; try lia);\n  simpl in H; inversion H.\n  - apply (Hdiv (qa * (3 * qb) * (3 * qc))); lia.\n  - apply (Hdiv (qa * (3 * qb + 1) * (3 * qc + 1))); lia.\n  - apply (Hdiv (qa * (3 * qb + 2) * (3 * qc + 2))); lia.\n  - apply (Hdiv (qb * (3 * qa + 1) * (3 * qc + 1))); lia.\n  - apply (Hdiv (qc * (3 * qb + 2) * (3 * qa + 1))); lia.\n  - apply (Hdiv (qb * (3 * qa + 2) * (3 * qc + 2))); lia.\n  - apply (Hdiv (qc * (3 * qb + 1) * (3 * qa + 2))); lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33168,"user_id":null,"body":"Require Import Arith Lia Classical.\nImport Nat.\n\nLemma mod3_subst_vals n :\n (n = 0 + (n\/3) * 3) \\\/ (n = 1 + (n\/3) * 3) \\\/ (n = 2 + (n\/3) * 3).\nProof.\n assert (Hq := div_mod n 3).\n assert (Hu := mod_upper_bound n 3).\n lia.\nQed.\n\nLemma mod9_pow3_vals n : exists m9,\n(((n^3) = 0 + m9 * 9) \/\\ (n = 0 + (n\/3) * 3)) \\\/ \n(((n^3) = 1 + m9 * 9) \/\\ (n = 1 + (n\/3) * 3)) \\\/\n(((n^3) = 8 + m9 * 9) \/\\ (n = 2 + (n\/3) * 3)).\nProof. destruct (mod3_subst_vals n) as [H|[H|H]];subst;[\n exists (3*(n\/3)*(n\/3)*(n\/3))|\n exists (3*(n\/3)*(n\/3)*(n\/3)+3*(n\/3)*(n\/3)+(n\/3))|\n exists (3*(n\/3)*(n\/3)*(n\/3)+6*(n\/3)*(n\/3)+4*(n\/3))];\n remember (n\/3);simpl; lia.\nQed.\n\nCorollary mod9_pow3_notcases n m :\n ((n^3) <> 2 + m * 9) \/\\\n ((n^3) <> 3 + m * 9) \/\\\n ((n^3) <> 4 + m * 9) \/\\\n ((n^3) <> 5 + m * 9) \/\\\n ((n^3) <> 6 + m * 9) \/\\\n ((n^3) <> 7 + m * 9).\nProof. destruct (mod9_pow3_vals n). lia. Qed.\n\nLemma power_preserves_prime n : n ^ 3 = ((n ^ 3) \/ 3) * 3 ->\n n = (n \/ 3) * 3.\nProof. destruct (mod3_subst_vals n);simpl in *;lia. Qed.\n\nTheorem easy_fermat (a b c : nat) :\n  a ^ 3 + b ^ 3 = c ^ 3 -> (3 | a * b * c).\nProof. case (mod9_pow3_vals a) as  [xa9 [[Ha1l Ha1r]|Ha23]].\n* exists ((a\/3)*b*c). clear - Ha1r. lia.\n* case (mod9_pow3_vals b) as [xb9 [[Hb1l Hb1r]|Hb23]].\n + exists (a*(b\/3)*c). clear - Hb1r. lia.\n + case (mod9_pow3_vals c) as [xc9 [[Hc1l Hc1r]|Hc23]].\n  - exists (a*b*(c\/3)). clear - Hc1r. lia.\n  - clear Hc23.\n    destruct Ha23 as [[Ha2l Ha2r]|[Ha3l Ha3r]];\n    destruct Hb23 as [[Hb2l Hb2r]|[Hb3l Hb3r]];intros.\n   ** absurd (c^3 = 2 + (xa9+xb9)*9).\n    ++ clear. destruct (mod9_pow3_notcases c (xa9+xb9));lia.\n    ++ clear - Ha2l Hb2l H. lia.\n   ** assert (c^3 = (xa9+xb9+1)*9).\n    ++ clear - Ha2l Hb3l H. lia.\n    ++ assert (c = (c\/3) * 3). \n     -- apply power_preserves_prime. rewrite H0.\n        replace (_ * 9) with ((3 * (xa9+xb9+1))*3);[|lia].\n        rewrite div_mul;clear;lia.\n     -- exists (a*b*(c\/3)). clear - H1;lia.\n   ** assert (c^3 = (xa9+xb9+1)*9).\n    ++ clear - Ha3l Hb2l H. lia.\n    ++ assert (c = (c\/3) * 3). \n     -- apply power_preserves_prime. rewrite H0.\n        replace (_ * 9) with ((3 * (xa9+xb9+1))*3);[|lia].\n        rewrite div_mul;clear;lia.\n     -- exists (a*b*(c\/3)). clear - H1;lia.\n   ** absurd (c^3 = 7 + (1+xa9+xb9)*9).\n    ++ clear. destruct (mod9_pow3_notcases c (1+xa9+xb9));lia.\n    ++ clear - Ha3l Hb3l H. lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33169,"user_id":null,"body":"Require Import Arith Lia Classical.\nImport Nat.\n\nLemma divide_dec p n : { (p | n) } + { ~ (p | n) }.\nProof.\n  destruct p.\n  - destruct n.\n    + left. exists 0. auto.\n    + right. intros Hc. destruct Hc. lia.\n  - destruct (n mod (S p)) eqn:Hmod.\n    + left. apply mod_divide; auto.\n    + right. intros Hc. destruct Hc.\n      subst.\n      rewrite mod_mul in Hmod; auto.\n      discriminate.\nQed.\n\nLemma mod_pow n k m : m <> 0 -> n ^ k mod m = (n mod m) ^ k mod m.\nProof.\n  intros.\n  induction k; auto.\n  rewrite !pow_succ_r'.\n  rewrite mul_mod; auto.\n  rewrite IHk.\n  rewrite <- mul_mod; auto.\n  rewrite <- mul_mod_idemp_l; auto.\nQed.\n\nLtac contra_le := \n  repeat match goal with\n  [ Hx : _ <= _ |- _ ] => inversion Hx; subst; clear Hx\n  end.\n\nLemma pow3mod9 n :\n  (n ^ 3) mod 9 = 0 \\\/ (n ^ 3) mod 9 = 1 \\\/ (n ^ 3) mod 9 = 8.\nProof.\n  rewrite mod_pow; auto.\n  destruct (n mod 9) eqn:Hn; auto.\n  do 8 (destruct n0; auto).\n  assert (H9: 9 <> 0) by auto.\n  pose proof (mod_upper_bound n 9 H9).\n  rewrite Hn in H.\n  inversion H. contra_le.\nQed.\n\nLemma mod3 n :\n  n mod 3 = 0 \\\/ n mod 3 = 1 \\\/ n mod 3 = 2.\nProof.\n  destruct (n mod 3) eqn:Hn; auto.\n  do 2 (destruct n0; auto).\n  assert (H3: 3 <> 0) by auto.\n  pose proof (mod_upper_bound n 3 H3).\n  rewrite Hn in H.\n  inversion H. contra_le.\nQed.\n\nLemma aux n : n^3 mod 9 = 0 -> (3 | n).\nProof.\n  rewrite (div_mod n 3); auto.\n  remember (n \/ 3) as n3.\n  intros.\n  destruct (mod3 n) as [Hm|[Hm|Hm]].\n  - exists (n \/ 3). lia.\n  - rewrite Hm in H.\n    rewrite !pow_succ_r' in H.\n    rewrite pow_0_r in H.\n    remember ((3 * n3 + 1) * ((3 * n3 + 1) * ((3 * n3 + 1) * 1))) as z.\n    assert (z mod 9 = 1).\n    { symmetry.\n      apply mod_unique with\n        (q := 3 * n3 * n3 * n3 + 3 * n3 * n3 + n3); repeat constructor.\n      subst. ring.\n    }\n    congruence.\n  - rewrite Hm in H.\n    rewrite !pow_succ_r' in H.\n    rewrite pow_0_r in H.\n    remember ((3 * n3 + 2) * ((3 * n3 + 2) * ((3 * n3 + 2) * 1))) as z.\n    assert (z mod 9 = 8).\n    { symmetry.\n      apply mod_unique with\n        (q := 3 * n3 * n3 * n3 + 6 * n3 * n3 + 4 * n3); repeat constructor.\n      subst. ring.\n    }\n    congruence.\nQed.\n\nTheorem easy_fermat (a b c : nat) :\n  a ^ 3 + b ^ 3 = c ^ 3 -> (3 | a * b * c).\nProof.\n  intros.\n  destruct (divide_dec 3 (a * b * c)); auto.\n  apply (f_equal (fun x => x mod 9)) in H.\n  rewrite add_mod in H; auto.\n  destruct (pow3mod9 a) as [Ha|[Ha|Ha]];\n  destruct (pow3mod9 b) as [Hb|[Hb|Hb]];\n  destruct (pow3mod9 c) as [Hc|[Hc|Hc]];\n  try solve [ rewrite Ha, Hb, Hc in H; discriminate ];\n  try solve [ apply aux in Ha;\n              do 2 apply divide_mul_l; auto ];\n  try solve [ apply aux in Hb;\n              apply divide_mul_l; apply divide_mul_r; auto ];\n  try solve [ apply aux in Hc;\n              apply divide_mul_r; auto ].\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33170,"user_id":168,"body":"Require Import Arith Classical.\nRequire Import ssreflect Lia.\nImport Nat.\n\nLemma mod_pow (n k m : nat) (m0 : m <> 0) : n ^ k mod m = (n mod m) ^ k mod m.\nProof.\n  elim: k => \/\/= k IH.\n  by rewrite mul_mod \/\/ IH -mul_mod \/\/ mul_mod_idemp_l.\nQed.\n  \nLemma mod9 (n : nat) (H : ~(3 | n)) : n ^ 3 mod 9 = 1 \\\/ n ^ 3 mod 9 = 8.\nProof.\n  rewrite mod_pow \/\/.\n  set t := n mod 9.\n  have [t0 [t3 t6]] : t <> 0 \/\\ t <> 3 \/\\ t <> 6.\n    do !split; rewrite \/t; intro eq; apply H;\n    rewrite (div_mod n 9) \/\/ eq;\n    (apply divide_add_r; [apply divide_mul_l | ]);\n    first [by exists 0 | by exists 1 | by exists 2 | by exists 3].\n  have Ht : t < 9 by apply mod_upper_bound.\n  move: Ht t0 t3 t6.\n  do 9!(case: t => [|t]; first by compute; auto).\n  lia.\nQed.\n\nLemma divide_dec (a b : nat) (Ha : a <> 0) : (a | b) \\\/ ~(a | b).\nProof.\n  rewrite -mod_divide \/\/.\n  decide equality.\nQed.\n\n(* A constructive proof *)\n\nTheorem easy_fermat (a b c : nat) :\n  a ^ 3 + b ^ 3 = c ^ 3 -> (3 | a * b * c).\nProof.\n  move => eq.\n  suff: (3 | a) \\\/ (3 | b) \\\/ (3 | c).\n    rewrite -mul_assoc; case; first exact: divide_mul_l.\n    rewrite mul_comm -mul_assoc; case; first exact: divide_mul_l.\n    by rewrite mul_comm -mul_assoc; exact: divide_mul_l.\n  case: (divide_dec 3 a) => \/\/; auto.\n  case: (divide_dec 3 b) => \/\/; auto.\n  case: (divide_dec 3 c) => \/\/; auto.\n  move => \/mod9 Hc \/mod9 Hb \/mod9 Ha.\n  have := f_equal (fun n => n mod 9) eq.\n  rewrite add_mod \/\/.\n  by case: Ha => ->; case: Hb => ->; case: Hc => ->; cbn.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33171,"user_id":168,"body":"Require Import Arith Classical.\nRequire Import ssreflect Lia.\nImport Nat.\n\nLemma mod_pow (n k m : nat) (m0 : m <> 0) : n ^ k mod m = (n mod m) ^ k mod m.\nProof.\n  elim: k => \/\/= k IH.\n  by rewrite mul_mod \/\/ IH -mul_mod \/\/ mul_mod_idemp_l.\nQed.\n  \nLemma mod9 (n : nat) (H : ~(3 | n)) : n ^ 3 mod 9 = 1 \\\/ n ^ 3 mod 9 = 8.\nProof.\n  rewrite mod_pow \/\/.\n  set t := n mod 9.\n  have [t0 [t3 t6]] : t <> 0 \/\\ t <> 3 \/\\ t <> 6.\n    do !split; rewrite \/t; intro eq; apply H;\n    rewrite (div_mod n 9) \/\/ eq;\n    (apply divide_add_r; [apply divide_mul_l | ]);\n    first [by exists 0 | by exists 1 | by exists 2 | by exists 3].\n  have Ht : t < 9 by apply mod_upper_bound.\n  move: Ht t0 t3 t6.\n  do 9!(case: t => [|t]; first by compute; auto).\n  lia.\nQed.\n\nTheorem easy_fermat (a b c : nat) :\n  a ^ 3 + b ^ 3 = c ^ 3 -> (3 | a * b * c).\nProof.\n  move => eq.\n  suff: (3 | a) \\\/ (3 | b) \\\/ (3 | c).\n    rewrite -mul_assoc; case; first exact: divide_mul_l.\n    rewrite mul_comm -mul_assoc; case; first exact: divide_mul_l.\n    by rewrite mul_comm -mul_assoc; exact: divide_mul_l.\n  apply NNPP => \/not_or_and [\/mod9 Ha] \/not_or_and [\/mod9 Hb \/mod9 Hc].\n  have := f_equal (fun n => n mod 9) eq.\n  rewrite add_mod \/\/.\n  by case: Ha => ->; case: Hb => ->; case: Hc => ->; cbn.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5e90c3814af7f4002e2535af":[{"id":33172,"user_id":null,"body":"Theorem exists_Type_ne : exists A B : Type, A <> B.\nProof.\n exists True, False. intro H.\n apply (@eq_rect Type _ (@id _) I _ H).\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33173,"user_id":null,"body":"Theorem exists_Type_ne : exists A B : Type, A <> B.\nProof.\n  exists False. exists True.\n  intros H. assert (H' := I).\n  destruct H. apply H'.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33174,"user_id":null,"body":"Definition exists_Type_ne : exists A B : _ , A <> B :=\nex_intro _ _ (ex_intro _ _ (eq_rect _ (@id _ ) I _ )).","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33175,"user_id":null,"body":"Theorem exists_Type_ne : exists A B : Type, A <> B.\nProof.\n  exists unit, bool.\n  unfold not; intros.\n  assert (forall (a b : unit), a = b).\n  { intros [] []. auto. }\n  rewrite H in H0.\n  specialize (H0 true false). inversion H0.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33176,"user_id":null,"body":"Lemma eq_by_fun: forall A B : Type, A = B -> \n  exists (f : A -> B) (g : B -> A), forall a, g (f a) = a.\nProof.\n  intros; rewrite H; exists (@id B), (@id B). \n  easy.\nQed.\nTheorem exists_Type_ne : exists A B : Type, A <> B.\nProof.\n  exists unit, Empty_set; intro.\n  specialize (eq_by_fun unit Empty_set H) as [f _].\n  easy.  \nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33177,"user_id":null,"body":"Lemma eq_by_fun: forall A B : Type, A = B -> \n  exists (f : A -> B) (g : B -> A), forall a, g (f a) = a.\nProof.\n  intros; rewrite H; exists (@id B); exists (@id B). \n  easy.\nQed.\nTheorem exists_Type_ne : exists A B : Type, A <> B.\nProof.\n  exists unit, Empty_set; intro.\n  specialize (eq_by_fun unit Empty_set H) as [f _].\n  easy.  \nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33178,"user_id":null,"body":"Lemma eq_by_fun: forall A B : Type, A = B -> \n  exists (f : A -> B) (g : B -> A), forall a, g (f a) = a.\nProof.\n  intros;  rewrite H.\n  exists (@id B); exists (@id B). \n  reflexivity.\nQed.\nTheorem exists_Type_ne : exists A B : Type, A <> B.\nProof.\n  exists unit, Empty_set; intro.\n  specialize (eq_by_fun unit Empty_set H) as [f _].\n  easy.  \nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33179,"user_id":null,"body":"Lemma eq_by_fun: forall A B : Type, A = B -> \n  exists (f : A -> B) (g : B -> A), forall a, g (f a) = a.\nProof.\n  intros;  rewrite H. \n  exists (@id B), (@id B). \n  reflexivity.\nQed.\nTheorem exists_Type_ne : exists A B : Type, A <> B.\nProof.\n  exists unit, Empty_set; intro.\n  pose proof (eq_by_fun unit Empty_set H) as [f _]. \n  destruct (f tt). \nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33180,"user_id":null,"body":"Theorem exists_Type_ne : exists A B : Type, A <> B.\nProof.\n  exists unit, bool.\n  intros H.\n  assert (Heq: (forall a b : unit, a = b)). {\n    intros a b.\n    destruct a. destruct b.\n    reflexivity.\n  }\n\n  rewrite H in Heq.\n\n  discriminate (Heq true false).\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33181,"user_id":null,"body":"Theorem exists_Type_ne : exists A B : Type, A <> B.\nProof.\n  exists unit, bool.\n  intro H.\n  set (P := fun T : Type => exists x y : T, x <> y).\n  assert (H0: ~ P unit).\n  { intros [[] [[] HC]]; congruence. }\n  assert (H1: P bool).\n  { exists true, false; congruence. }\n  rewrite H in H0; congruence.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5e9900b311efe00001996e26":[{"id":33182,"user_id":null,"body":"From Coq Require Import Relations.\nRequire Import Preloaded.\n\nDefinition void := (fun (_ _:True) => False).\n\nLemma sym: symmetric _ void.\nProof.\n  intros _ _ [].\nQed.\n\nLemma tr: transitive _ void.\nProof.\n  intros _ _ _ [].\nQed.\n\nTheorem correct_version : ~ bad_theorem.\nProof.\n  intro H.\n  exact (H True void sym tr I).\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33183,"user_id":null,"body":"Require Import Preloaded Relations.\n\nTheorem correct_version : ~ bad_theorem.\nProof. cbv. intros H. now apply H with True. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33184,"user_id":null,"body":"Require Import Preloaded.\n\nTheorem correct_version : ~ bad_theorem.\nProof.\n  cbv.\n  intro.\n  pose proof (H True (fun _ _ => False)).\n  simpl in H0.\n  apply H0.\n  intros; assumption.\n  intros; assumption.\n  trivial.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33185,"user_id":null,"body":"Require Import Preloaded.\n\nRequire Import ZArith.\nRequire Import ZArith.BinInt.\nFrom Coq Require Import Relations.\n\nTheorem correct_version : ~ bad_theorem.\nProof.\n  intro.\n  unfold bad_theorem in H.\n  pose proof (H Z (fun a b : Z => Z.gt (a * b) 0)).\n  simpl in H0.\n  assert (symmetric Z (fun a b : Z => Z.gt (a * b) 0)).\n  unfold symmetric.\n  intros.\n  destruct x, y; try (inversion H1); try auto.\n  assert (transitive Z (fun a b : Z => Z.gt (a * b) 0)).\n  unfold transitive.\n  intros.\n  destruct x, y, z; try (inversion H2); try (inversion H3); try auto.\n  apply H0 in H1.\n  unfold reflexive in H1.\n  pose proof (H1 Z0).\n  inversion H3.\n  assumption.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33186,"user_id":null,"body":"Require Import Preloaded.\nFrom Coq Require Import Relations.\n\nTheorem correct_version : ~ bad_theorem.\nProof.\n  intros H.\n  assert (HC: reflexive unit (fun _ _ => False)).\n  { apply H; firstorder. }\n  apply HC, tt.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33187,"user_id":null,"body":"Require Import Relations Preloaded.\n\nVariant em := emel.\n\nVariant emr : relation em :=.\n\nTheorem correct_version: ~bad_theorem.\nProof.\n  intro bt.\n  hnf in bt.\n  unfold symmetric, transitive, reflexive in bt.\n  specialize (bt em emr).\n  assert (symmetric em emr).\n  hnf.\n  intros [] []; auto.\n  assert (transitive em emr).\n  hnf.\n  intros [] [] [] a b; auto.\n  specialize (bt H H0).\n  specialize (bt emel).\n  destruct bt.\nQed.\n  ","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33188,"user_id":null,"body":"Require Import Preloaded.\n\nTheorem correct_version : ~ bad_theorem.\n  Proof.\n    intro h.\n    specialize (h unit (fun x y => False)). apply h ; intuition.\n  Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33189,"user_id":null,"body":"From Coq Require Import Relations.\nRequire Import Preloaded.\n\nInductive one_point := point.\n\n(* Let R be an empty relation on one point. *)\nInductive R : relation one_point :=.\n\n(* R is not reflexive. *)\nLemma R_not_reflexive :\n  ~ reflexive one_point R.\nProof.\n  unfold reflexive.\n  intros H.\n  specialize (H point).\n  destruct H.\nQed.\n\n(* However, R is symmetric and transitive. *)\nTheorem correct_version : ~ bad_theorem.\nProof.\n  unfold bad_theorem.\n  intro.\n  apply R_not_reflexive.\n  apply H.\n  - (* R is symmetric *)\n    unfold symmetric.\n    intros x y K.\n    destruct K.\n  - (* R is transitive *)\n    unfold transitive.\n    intros x y z K L.\n    destruct K.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33190,"user_id":191,"body":"Require Import Preloaded.\n\nTheorem correct_version : ~ bad_theorem.\nProof.\n  intuition.\n  specialize (H nat).\n  apply H;\n  intuition.\n  exact 0.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33191,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Relations.\n\nDefinition R_a (A: Type) : relation A :=\n  fun (x y: A) => False.\nDefinition non_void (A: Type): Prop :=\n  forall P: A->Prop, (forall x: A, P x) -> (exists x: A, P x).\nTheorem correct_version : ~ bad_theorem.\nProof.\n  assert (exists A: Type, non_void A).\n    exists nat.\n    unfold non_void.\n    intros.\n    exists 0.\n    apply H.\n  destruct H as [A].\n  remember (R_a A) as R.\n  unfold not.\n  unfold bad_theorem.\n  assert (symmetric A R).\n    unfold symmetric.\n    rewrite HeqR.\n    intros.\n    assumption.\n  intro.\n  apply H1 in H0.\n    unfold reflexive in H0.\n    assert (forall x: A, ~R x x).\n      rewrite HeqR.\n      intros.\n      unfold R_a.\n      auto.\n    apply H in H0.\n    destruct H0.\n    apply H2 in H0.\n    contradiction.\n  unfold transitive.\n  rewrite HeqR.\n  intros.\n  assumption.\nQed. ","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5e998b42dcf07b0001581def":[{"id":33192,"user_id":null,"body":"Require Import Preloaded.\n\n\nRequire Import Lia.\n\nHint Resolve ev_0 ev_SS odd_1 odd_SS : core.\n\nLemma even_add_one : forall n, even n -> odd (S n).\nProof. induction 1; auto. Qed.\n\nLemma odd_add_one : forall n, odd n -> even (S n).\nProof. induction 1; auto. Qed.\n\nLemma parity_dec : forall n, {even n} + {odd n}.\nProof.\n  induction 0; [left; constructor|]; destruct IHn; [right; apply even_add_one|left; apply odd_add_one]; assumption. Qed.\n\nHint Resolve even_add_one odd_add_one parity_dec : core.\n\n       \n(* Addition *)\nTheorem odd_add_odd : forall n m, odd n -> odd m -> even (n + m).\nProof. induction 1; simpl; auto. Qed.\n       \nTheorem odd_add_even : forall n m, odd n -> even m -> odd (n + m).\nProof. induction 1; simpl; auto. Qed.\n\nTheorem even_add_odd : forall n m, even n -> odd m -> odd (n + m).\nProof. induction 1; simpl; auto. Qed.\n\nTheorem even_add_even : forall n m, even n -> even m -> even (n + m).\nProof. induction 1; simpl; auto. Qed.\n\n\nHint Resolve odd_add_odd odd_add_even even_add_odd even_add_even : core.\n\n(* Multiplication *)\nTheorem even_mul_even : forall n m, even n -> even m -> even (n * m).\nProof. induction 1; simpl; intros; auto. Qed.\n\nTheorem even_mul_odd : forall n m, even n -> odd m -> even (n * m).\nProof. induction 1; simpl; intros; auto. Qed.\n\nTheorem odd_mul_even : forall n m, odd n -> even m -> even (n * m).\nProof. induction 1; simpl; intros; auto. Qed.\n\nTheorem odd_mul_odd : forall n m, odd n -> odd m -> odd (n * m).\nProof. induction 1; simpl; intros; auto. Qed.\n\nTheorem even_mul : forall n m, even n -> even (n * m).\nProof.\n  induction m; intros; replace  (n * 0) with 0 by Lia.lia; auto.\n  replace (n * (S m)) with (n + n * m) by Lia.lia; auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33193,"user_id":168,"body":"Require Import Preloaded.\nRequire Arith.Even Arith.Div2.\n\nHint Constructors even odd : arith.\n\nLemma even_even n : even n <-> Even.even n.\nProof.\n  split; induction n using Div2.ind_0_1_SS; auto with arith; intros;\n    inversion H; auto with arith; inversion H1; auto with arith.\nQed.\n\nLemma odd_odd n : odd n <-> Even.odd n.\nProof.\n  split; induction n using Div2.ind_0_1_SS; auto with arith; intros;\n    inversion H; auto with arith; inversion H1; auto with arith.\nQed.\n\nLtac prove := intros; rewrite ?even_even, ?odd_odd in *; auto with arith.\n\n(* Getting Started *)\n\nLemma even_add_one : forall n, even n -> odd (S n).\nProof. prove. Qed.\n       \n\nLemma odd_add_one : forall n, odd n -> even (S n).\nProof. prove. Qed.\n\nLemma parity_dec : forall n, {even n} + {odd n}.\nProof.\n  induction n. left; exact ev_0.\n  destruct IHn.\n  - right; apply even_add_one; assumption.\n  - left; apply odd_add_one; assumption.\nQed.\n    \n(* Addition *)\n\nTheorem odd_add_odd : forall n m, odd n -> odd m -> even (n + m).\nProof. prove. Qed.\n\nTheorem odd_add_even : forall n m, odd n -> even m -> odd (n + m).\nProof. prove. Qed.\n\nTheorem even_add_odd : forall n m, even n -> odd m -> odd (n + m).\nProof. prove. Qed.\n\nTheorem even_add_even : forall n m, even n -> even m -> even (n + m).\nProof. prove. Qed.\n\n(* Multiplication *)\n\nTheorem even_mul_even : forall n m, even n -> even m -> even (n * m).\nProof. prove. Qed.\n\nTheorem even_mul_odd : forall n m, even n -> odd m -> even (n * m).\nProof. prove. Qed.\n\nTheorem odd_mul_even : forall n m, odd n -> even m -> even (n * m).\nProof. prove. Qed.\n\nTheorem odd_mul_odd : forall n m, odd n -> odd m -> odd (n * m).\nProof. prove. Qed.\n\nTheorem even_mul : forall n m, even n -> even (n * m).\nProof. prove. Qed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33194,"user_id":null,"body":"Require Import Preloaded.\n\n(* Getting Started *)\nHint Constructors even : codewars.\nHint Constructors odd : codewars.\n\nLemma even_add_one : forall n, even n -> odd (S n).\nProof. induction 1; auto with codewars. Qed.\nLemma odd_add_one : forall n, odd n -> even (S n).\nProof. induction 1; auto with codewars. Qed.\n\nHint Resolve even_add_one : codewars.\nHint Resolve odd_add_one : codewars.\n\nLemma parity_dec : forall n, {even n} + {odd n}.\nProof. \n  induction n; auto with codewars.\n  destruct IHn as [H | H]; \n    [apply even_add_one in H | apply odd_add_one in H]; \n    auto with codewars.\nQed.\n\n(* Addition *)\n\nTheorem odd_add_odd : forall n m, odd n -> odd m -> even (n + m).\nProof. induction 1; simpl; auto with codewars. Qed.\n\nTheorem odd_add_even : forall n m, odd n -> even m -> odd (n + m).\nProof. induction 1; simpl; auto with codewars. Qed.\n\nTheorem even_add_odd : forall n m, even n -> odd m -> odd (n + m).\nProof. induction 1; simpl; auto with codewars. Qed.\n\nTheorem even_add_even : forall n m, even n -> even m -> even (n + m).\nProof. induction 1; simpl; auto with codewars. Qed.\n\nHint Resolve odd_add_odd : codewars.\nHint Resolve odd_add_even : codewars.\nHint Resolve even_add_odd : codewars.\nHint Resolve even_add_even : codewars.\n\n(* Multiplication *)\n\nTheorem even_mul_even : forall n m, even n -> even m -> even (n * m).\nProof. induction 1; simpl; auto with codewars. Qed.\n\nTheorem even_mul_odd : forall n m, even n -> odd m -> even (n * m).\nProof. induction 1; simpl; auto with codewars. Qed. \n\nTheorem odd_mul_even : forall n m, odd n -> even m -> even (n * m).\nProof. induction 1; simpl; auto with codewars. Qed.\n\nTheorem odd_mul_odd : forall n m, odd n -> odd m -> odd (n * m).\nProof. induction 1; simpl; auto with codewars. Qed.\n\nHint Resolve even_mul_even : codewars.\nHint Resolve even_mul_odd : codewars.\n\nTheorem even_mul : forall n m, even n -> even (n * m).\nProof. induction 1; simpl; destruct (parity_dec m); auto with codewars. Qed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33195,"user_id":null,"body":"Require Import Preloaded.\n\nHint Constructors even odd : core.\n\n(* Getting Started *)\n\nLemma even_add_one : forall n, even n -> odd (S n).\nProof.\n  induction 1; auto.\nQed.\n\nLemma odd_add_one : forall n, odd n -> even (S n).\nProof.\n  induction 1; auto.\nQed.\n\nHint Resolve even_add_one odd_add_one : core.\n\nLemma parity_dec : forall n, {even n} + {odd n}.\nProof with auto.\n  induction n.\n  - left...\n  - destruct IHn.\n    + right...\n    + left...\nQed.\n\n(* Addition *)\n\nLtac magic :=\n  induction 1; induction 1; cbn; auto 7.\n\nTheorem odd_add_odd : forall n m, odd n -> odd m -> even (n + m).\nProof.\n  magic.\nQed.\n\nTheorem odd_add_even : forall n m, odd n -> even m -> odd (n + m).\nProof.\n  magic.\nQed.\n\nTheorem even_add_odd : forall n m, even n -> odd m -> odd (n + m).\nProof.\n  magic.\nQed.\n\nTheorem even_add_even : forall n m, even n -> even m -> even (n + m).\nProof.\n  magic.\nQed.\n\nHint Resolve odd_add_odd odd_add_even even_add_odd even_add_even : core.\n\n(* Multiplication *)\n\nTheorem even_mul_even : forall n m, even n -> even m -> even (n * m).\nProof.\n  magic.\nQed.\n\nTheorem even_mul_odd : forall n m, even n -> odd m -> even (n * m).\nProof.\n  magic.\nQed.\n\nTheorem odd_mul_even : forall n m, odd n -> even m -> even (n * m).\nProof.\n  magic.\nQed.\n\nTheorem odd_mul_odd : forall n m, odd n -> odd m -> odd (n * m).\nProof.\n  magic.\nQed.\n\nTheorem even_mul : forall n m, even n -> even (n * m).\nProof.\n  intros.\n  destruct (parity_dec m);\n    auto using even_mul_even, even_mul_odd.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33196,"user_id":null,"body":"Require Import Preloaded.\n\nSection blah.\nTactic Notation \"isautow\" hyp(h) tactic(t) :=\n  induction h ; simpl ; try t ; auto.\nLtac isauto h := isautow h trivial.\n\nHint Constructors even odd : core. \n\nLemma even_add_one : forall n, even n -> odd (S n).\nProof. intros ? H. isauto H. Qed.\n\nLemma odd_add_one : forall n, odd n -> even (S n).\nProof. intros ? H. isauto H. Qed.\n\nHint Resolve even_add_one odd_add_one : core.\n\nLemma parity_dec : forall n, {even n} + {odd n}.\nProof. induction n.\n  - left. apply ev_0.\n  - destruct IHn ; [ right | left ] ; auto.\nQed.\n\nLemma add_assoc : forall n m p, n + (m + p) = n + m + p.\nProof. intros n. isauto n. Qed.\n\nTheorem odd_add_odd : forall n m, odd n -> odd m -> even (n + m).\nProof. intros ? ? Hn ?. isauto Hn. Qed.\n\nTheorem odd_add_even : forall n m, odd n -> even m -> odd (n + m).\nProof. intros ? ? Hn ?. isauto Hn. Qed.\n\nTheorem even_add_odd : forall n m, even n -> odd m -> odd (n + m).\nProof. intros ? ? ? Hm. isautow Hm (rewrite <-?plus_n_Sm, <-?plus_n_O). Qed.\n\nTheorem even_add_even : forall n m, even n -> even m -> even (n + m).\nProof. intros ? ? Hn ?. isauto Hn. Qed.\n\nHint Resolve odd_add_odd odd_add_even even_add_odd even_add_even : core.\n\nLemma add_refl_even : forall n, even (n + n).\nProof. intros n. destruct (parity_dec n) ; auto. Qed.\n\nTheorem even_mul_even : forall n m, even n -> even m -> even (n * m).\nProof. intros ? ? Hn ?. isauto Hn. Qed. \n\nTheorem even_mul_odd : forall n m, even n -> odd m -> even (n * m).\nProof. intros ? ? Hn ?. isauto Hn. Qed.\n\nTheorem odd_mul_even : forall n m, odd n -> even m -> even (n * m).\nProof. intros ? ? Hn ?. isauto Hn. Qed.\n\nTheorem odd_mul_odd : forall n m, odd n -> odd m -> odd (n * m).\nProof. intros ? ? Hn ?. isauto Hn. Qed.\n\nHint Resolve even_mul_even even_mul_odd odd_mul_even odd_mul_odd add_refl_even : core.\n\nTheorem even_mul : forall n m, even n -> even (n * m).\nProof. intros ? ? Hn. isautow Hn (rewrite add_assoc). Qed.\nEnd blah.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33197,"user_id":null,"body":"Require Import Preloaded.\n\n(* Getting Started *)\n\nLemma even_add_one : forall n, even n -> odd (S n).\nProof.\n  intros n H.\n  induction H. \n  exact odd_1.\n  apply odd_SS, IHeven.\nQed.\n\nLemma odd_add_one : forall n, odd n -> even (S n).\nProof.\n  intros n H.\n  induction H. \n  apply ev_SS, ev_0.\n  apply ev_SS, IHodd.\nQed.\n\nLemma parity_dec : forall n, {even n} + {odd n}.\nProof.\n  intros n.\n  induction n.\n  left.\n  exact ev_0.\n  destruct IHn.\n  right.\n  apply even_add_one, e.\n  left.\n  apply odd_add_one, o.\nQed.\n\n(* Addition *)\n\nTheorem odd_add_odd : forall n m, odd n -> odd m -> even (n + m).\nProof. \n  intros n m Hn Hm.\n  induction Hn.\n  replace (1 + m) with (S m).\n  apply odd_add_one, Hm.\n  reflexivity.\n  replace (S (S n) + m) with (S (S n + m)).\n  apply ev_SS, IHHn.\n  reflexivity.\nQed.\n\nTheorem odd_add_even : forall n m, odd n -> even m -> odd (n + m).\nProof. \n  intros n m Hn Hm.\n  induction Hn.\n  replace (1 + m) with (S m).\n  apply even_add_one, Hm.\n  reflexivity.\n  replace (S (S n) + m) with (S (S n + m)).\n  apply odd_SS, IHHn.\n  reflexivity.\nQed.\n\nTheorem even_add_odd : forall n m, even n -> odd m -> odd (n + m).\nProof.\n  intros n m Hn Hm.\n  induction Hn.\n  replace (0 + m) with m.\n  apply Hm.\n  reflexivity.\n  replace (S (S n) + m) with (S (S n + m)).\n  apply odd_SS, IHHn.\n  reflexivity.\nQed.\n\nTheorem even_add_even : forall n m, even n -> even m -> even (n + m).\nProof.\n  intros n m Hn Hm.\n  induction Hn.\n  replace (0 + m) with m.\n  apply Hm.\n  reflexivity.\n  replace (S (S n) + m) with (S (S n + m)).\n  apply ev_SS, IHHn.\n  reflexivity.\nQed.\n\n(* Multiplication *)\n\nTheorem even_mul_even : forall n m, even n -> even m -> even (n * m).\nProof. \n  intros n m Hn Hm.\n  induction Hn.\n  replace (0 * m) with 0.\n  exact ev_0.\n  reflexivity.\n  replace (S (S n) * m) with (m + (S n) * m).\n  replace ((S n) * m) with (m + n * m).\n  apply even_add_even.\n  apply Hm.\n  apply even_add_even.\n  apply Hm.\n  apply IHHn.\n  reflexivity.\n  reflexivity.\nQed.\n\nTheorem even_mul_odd : forall n m, even n -> odd m -> even (n * m).\nProof.   \n  intros n m Hn Hm.\n  induction Hn.\n  replace (0 * m) with 0.\n  exact ev_0.\n  reflexivity.\n  replace (S (S n) * m) with (m + (S n) * m).\n  replace ((S n) * m) with (m + n * m).\n  apply odd_add_odd.\n  apply Hm.\n  apply odd_add_even.\n  apply Hm.\n  apply IHHn.\n  reflexivity.\n  reflexivity.\nQed.\n\nTheorem odd_mul_even : forall n m, odd n -> even m -> even (n * m).\nProof. \n  intros n m Hn Hm.\n  induction Hn.\n  replace ((S 0) * m) with (m + 0 * m).\n  replace (0 * m) with 0.\n  replace (m + 0) with m.\n  apply Hm.\n  trivial.\n  trivial.\n  reflexivity.\n  replace (S (S n) * m) with (m + (S n) * m).\n  replace ((S n) * m) with (m + n * m).\n  apply even_add_even.\n  apply Hm.\n  apply even_add_even.\n  apply Hm.\n  apply IHHn.\n  reflexivity.\n  reflexivity.\nQed.  \n\nTheorem odd_mul_odd : forall n m, odd n -> odd m -> odd (n * m).\nProof.\n  intros n m Hn Hm.\n  induction Hn.\n  replace ((S 0) * m) with (m + 0 * m).\n  replace (0 * m) with 0.\n  replace (m + 0) with m.\n  apply Hm.\n  trivial.\n  trivial.\n  reflexivity.\n  replace (S (S n) * m) with (m + (S n) * m).\n  replace ((S n) * m) with (m + n * m).\n  apply odd_add_even.\n  apply Hm.\n  apply odd_add_odd.\n  apply Hm.\n  apply IHHn.\n  reflexivity.\n  reflexivity.\nQed.\n\nTheorem even_mul : forall n m, even n -> even (n * m).\nProof.\n  intros.\n  assert (Hm : {even m} + {odd m}).\n  apply parity_dec.\n  destruct Hm.\n  apply even_mul_even.\n  trivial. trivial.\n  apply even_mul_odd.\n  trivial. trivial.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33198,"user_id":null,"body":"Require Import Preloaded Arith Lia.\n\nLemma even_add_one : forall n, even n -> odd (S n).\nProof.\n  intros.\n  induction H ; constructor.\n  assumption.\nQed.\n\nLemma odd_add_one : forall n, odd n -> even (S n).\nProof. \n  intros.\n  induction H ; constructor.\n  constructor. assumption.\nQed.\n\nLemma parity_dec : forall n, {even n} + {odd n}.\nProof.\n  induction n.\n  + left. constructor.\n  + destruct IHn.\n    - right. apply even_add_one. assumption.\n    - left. apply odd_add_one. assumption.\nQed.\n\n(* Addition *)\n\nTheorem odd_add_odd : forall n m, odd n -> odd m -> even (n + m).\nProof.\n  intros n m hn hm.\n  induction hn.\n  + apply odd_add_one. assumption.\n  + replace (S (S n) + m) with (S (S (n + m))) by lia.\n    constructor. assumption.\nQed.\n\nTheorem odd_add_even : forall n m, odd n -> even m -> odd (n + m).\nProof.\n  intros n m hn hm.\n  induction hn.\n  + apply even_add_one. assumption.\n  + replace (S (S n) + m) with (S (S (n + m))) by lia.\n    constructor. assumption.\nQed.\n\nTheorem even_add_odd : forall n m, even n -> odd m -> odd (n + m).\nProof.\n  intros n m hn hm.\n  induction hn.\n  + assumption.\n  + replace (S (S n) + m) with (S (S (n + m))) by lia.\n    constructor. assumption.\nQed.\n\nTheorem even_add_even : forall n m, even n -> even m -> even (n + m).\nProof.\n  intros n m hn hm.\n  induction hn.\n  + assumption.\n  + replace (S (S n) + m) with (S (S (n + m))) by lia.\n    constructor. assumption.\nQed.\n\n(* Multiplication *)\n\nLemma even_mul : forall n m, even n -> even (n * m).\nProof.\n  intros n m hn.\n  induction hn.\n  + constructor.\n  + simpl. destruct (parity_dec m).\n    - apply even_add_even. assumption. apply even_add_even ; assumption.\n    - apply odd_add_odd. assumption. apply odd_add_even ; assumption.\nQed.\n\nTheorem even_mul_even : forall n m, even n -> even m -> even (n * m).\nProof.\n  intros. apply even_mul. assumption.\nQed.\n  \nTheorem even_mul_odd : forall n m, even n -> odd m -> even (n * m).\nProof.\n  intros. apply even_mul. assumption.\nQed.\n\nTheorem odd_mul_even : forall n m, odd n -> even m -> even (n * m).\nProof.\n  intros. replace (n*m) with (m*n) by lia. apply even_mul. assumption.\nQed.\n\nTheorem odd_mul_odd : forall n m, odd n -> odd m -> odd (n * m).\nProof.\n  intros n m hn hm.\n  induction hn.\n  + replace (1*m) with m by lia. assumption.\n  + simpl. apply odd_add_even. assumption. apply odd_add_odd ; assumption.\nQed.\n\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33199,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Arith.\n\n(* Getting Started *)\n\nLemma even_add_one : forall n, even n -> odd (S n).\nProof.\n  intros n H.\n  induction H.\n  - apply odd_1.\n  - apply odd_SS. assumption.\nQed.\n\nLemma odd_add_one : forall n, odd n -> even (S n).\nProof.\n  intros n H.\n  induction H.\n  - apply ev_SS. apply ev_0.\n  - apply ev_SS. assumption.\nQed.\n\nLemma parity_dec : forall n, {even n} + {odd n}.\nProof.\n  intros n.\n  induction n.\n  - left. apply ev_0.\n  - elim IHn; intros.\n    + right. apply even_add_one. assumption.\n    + left. apply odd_add_one. assumption.\nQed.\n\n(* Addition *)\n\nTheorem odd_add_odd : forall n m, odd n -> odd m -> even (n + m).\nProof.\n  intros n m H H0.\n  induction H.\n  - apply odd_add_one. assumption.\n  - replace (S (S n) + m) with (S (S (n + m))) by ring.\n    apply ev_SS.\n    assumption.\nQed.\n\nTheorem odd_add_even : forall n m, odd n -> even m -> odd (n + m).\nProof.\n  intros n m H H0.\n  induction H.\n  - apply even_add_one. assumption.\n  - replace (S (S n) + m) with (S (S (n + m))) by ring.\n    apply odd_SS.\n    assumption.\nQed.\n\nTheorem even_add_odd : forall n m, even n -> odd m -> odd (n + m).\nProof.\n  intros n m H H0.\n  induction H.\n  - replace (0 + m) with m by ring; assumption.\n  - replace (S (S n) + m) with (S (S (n + m))) by ring.\n    apply odd_SS.\n    assumption.\nQed.\n\nTheorem even_add_even : forall n m, even n -> even m -> even (n + m).\nProof.\n  intros n m H H0.\n  induction H.\n  - replace (0 + m) with m by ring; assumption.\n  - replace (S (S n) + m) with (S (S (n + m))) by ring.\n    apply ev_SS.\n    assumption.\nQed.\n\n(* Multiplication *)\n\nLemma two_mul_nat: forall n, even (2 * n).\nProof.\n  intros.\n  induction n.\n  - replace (2 * 0) with 0 by ring. apply ev_0.\n  - replace (2 * S n) with (2 * n + (S (S 0))) by ring. apply even_add_even.\n    + assumption.\n    + apply ev_SS; apply ev_0.\nQed.\n\nTheorem even_mul_even : forall n m, even n -> even m -> even (n * m).\nProof.\n  intros n m H H0.\n  induction H.\n  - replace (0 * m) with 0 by ring. apply ev_0.\n  - replace (S (S n) * m) with (n * m + 2 * m) by ring.\n    apply even_add_even.\n    + assumption.\n    + apply two_mul_nat.\nQed.\n\nTheorem even_mul_odd : forall n m, even n -> odd m -> even (n * m).\nProof.\n  intros n m H H0.\n  induction H.\n  - replace (0 * m) with 0 by ring. apply ev_0.\n  - replace (S (S n) * m) with (n * m + 2 * m) by ring.\n    apply even_add_even.\n    + assumption.\n    + apply two_mul_nat.\nQed.\n\nTheorem odd_mul_even : forall n m, odd n -> even m -> even (n * m).\nProof.\n  intros n m H H0.\n  induction H.\n  - replace (1 * m) with m by ring. assumption.\n  - replace (S (S n) * m) with (n * m + 2 * m) by ring.\n    apply even_add_even.\n    + assumption.\n    + apply two_mul_nat.\nQed.\n\nTheorem odd_mul_odd : forall n m, odd n -> odd m -> odd (n * m).\nProof.\n  intros n m H H0.\n  induction H.\n  - replace (1 * m) with m by ring. assumption.\n  - replace (S (S n) * m) with (n * m + 2 * m) by ring.\n    apply odd_add_even.\n    + assumption.\n    + apply two_mul_nat.\nQed.\n\nTheorem even_mul : forall n m, even n -> even (n * m).\nProof.\n  intros n m H.\n  induction H.\n  - replace (0 * m) with 0 by ring. apply ev_0.\n  - replace (S (S n) * m) with (n * m + 2 * m) by ring.\n    apply even_add_even.\n    + assumption.\n    + apply two_mul_nat.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33200,"user_id":null,"body":"Require Import Preloaded.\n\n(* Getting Started *)\n\nLemma even_add_one : forall n, even n -> odd (S n).\nProof. induction 1; constructor; auto. Qed.\n\nLemma odd_add_one : forall n, odd n -> even (S n).\nProof. induction 1; repeat constructor; auto. Qed.\n\nLemma parity_dec : forall n, {even n} + {odd n}.\nProof.\n  intro n; induction n.\n  - left; constructor.\n  - destruct IHn as [H | H].\n    + right; apply even_add_one; auto.\n    + left; apply odd_add_one; auto.\nQed.\n\n(* Addition *)\n\nTheorem odd_add_odd : forall n m, odd n -> odd m -> even (n + m).\nProof.\n  intros n m H; revert m; induction H; simpl; intros m Hm.\n  - apply odd_add_one; auto.\n  - constructor; auto.\nQed.\n\nTheorem odd_add_even : forall n m, odd n -> even m -> odd (n + m).\nProof.\n  intros n m H; revert m; induction H; simpl; intros m Hm.\n  - apply even_add_one; auto.\n  - constructor; auto.\nQed.\n\nTheorem even_add_odd : forall n m, even n -> odd m -> odd (n + m).\nProof.\n  intros n m H; revert m; induction H; simpl;\n    intros m Hm; auto; constructor; auto.\nQed.\n\nTheorem even_add_even : forall n m, even n -> even m -> even (n + m).\nProof.\n  intros n m H; revert m; induction H; simpl;\n    intros m Hm; auto; constructor; auto.\nQed.\n\n(* Multiplication *)\n\nTheorem even_mul_even : forall n m, even n -> even m -> even (n * m).\nProof.\n  intros n m H; revert m; induction H; simpl;\n    intros m Hm; auto; try constructor.\n  repeat apply even_add_even; auto.\nQed.\n\nTheorem even_mul_odd : forall n m, even n -> odd m -> even (n * m).\nProof.\n  intros n m H; revert m; induction H; simpl;\n    intros m Hm; auto; try constructor.\n  apply odd_add_odd; auto; apply odd_add_even; auto.\nQed.\n\nTheorem odd_mul_even : forall n m, odd n -> even m -> even (n * m).\nProof.\n  intros n m H; revert m; induction H; simpl; intros m Hm; auto.\n  - rewrite <- plus_n_O; auto.\n  - repeat apply even_add_even; auto.\nQed.\n\nTheorem odd_mul_odd : forall n m, odd n -> odd m -> odd (n * m).\nProof.\n  intros n m H; revert m; induction H; simpl; intros m Hm; auto.\n  - rewrite <- plus_n_O; auto.\n  - apply odd_add_even; auto.\n    apply odd_add_odd; auto.\nQed.\n\nTheorem even_mul : forall n m, even n -> even (n * m).\nProof.\n  intros n m H; revert m; induction H; simpl; intros m; try constructor.\n  destruct (parity_dec m).\n  - repeat apply even_add_even; auto.\n  - apply odd_add_odd; auto.\n    apply odd_add_even; auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33201,"user_id":null,"body":"Require Import Preloaded.\n\n(* Getting Started *)\n\nLemma even_add_one : forall n, even n -> odd (S n).\nProof.\n  intros.\n  induction H.\n  constructor.\n  constructor; assumption.\nQed.  \n\nLemma odd_add_one : forall n, odd n -> even (S n).\nProof.\n  intros.\n  induction H.\n  constructor; constructor.\n  constructor; assumption.\nQed.\n\nLemma parity_dec : forall n, {even n} + {odd n}.\nProof.\n  induction n.\n  left; constructor.\n  inversion IHn.\n  right; apply even_add_one; assumption.\n  left; apply odd_add_one; assumption.\nQed.\n\n(* Addition *)\n\nTheorem odd_add_odd : forall n m, odd n -> odd m -> even (n + m).\nProof.\n  intros.\n  induction H.\n  apply odd_add_one; assumption.\n  simpl; constructor; assumption.\nQed.\n\nTheorem odd_add_even : forall n m, odd n -> even m -> odd (n + m).\nProof.\n  intros.\n  induction H.\n  apply even_add_one; assumption.\n  simpl; constructor; assumption.\nQed.\n\nTheorem even_add_odd : forall n m, even n -> odd m -> odd (n + m).\nProof.\n  intros.\n  induction H.\n  assumption.\n  simpl; constructor; assumption.\nQed.\n\nTheorem even_add_even : forall n m, even n -> even m -> even (n + m).\nProof.\n  intros.\n  induction H.\n  assumption.\n  simpl; constructor; assumption.\nQed.\n\n(* Multiplication *)\n\nTheorem even_mul_even : forall n m, even n -> even m -> even (n * m).\nProof.\n  intros.\n  induction H.\n  constructor.\n  simpl.\n  apply even_add_even.\n  assumption.\n  apply even_add_even.\n  assumption.\n  assumption.\nQed.\n\nRequire Import Arith Omega.\n\nTheorem even_mul_odd : forall n m, even n -> odd m -> even (n * m).\nProof.\n  intros.\n  induction H.\n  constructor.\n  simpl.\n  assert (m + (m + n * m) = (m + m) + n * m).\n  omega.\n  rewrite H1.\n  apply even_add_even.\n  apply odd_add_odd.\n  assumption.\n  assumption.\n  assumption.\nQed.  \n\nTheorem odd_mul_even : forall n m, odd n -> even m -> even (n * m).\nProof.\n  intros.\n  induction H.\n  rewrite Nat.mul_1_l.\n  assumption.\n  simpl.\n  assert (m + (m + n * m) = (m + m) + n * m).\n  omega.\n  rewrite H1.\n  apply even_add_even.\n  apply even_add_even.\n  assumption.\n  assumption.\n  assumption.\nQed.\n\nTheorem odd_mul_odd : forall n m, odd n -> odd m -> odd (n * m).\nProof.\n  intros.\n  induction H.\n  rewrite Nat.mul_1_l.\n  assumption.\n  simpl.\n  assert (m + (m + n * m) = (m + m) + n * m).\n  omega.\n  rewrite H1.\n  apply even_add_odd.\n  apply odd_add_odd.\n  assumption.\n  assumption.\n  assumption.\nQed.\n\nLemma even_odd_dec : forall n, {even n} + {odd n}.\nProof.\n  induction n.\n  left; constructor.\n  inversion IHn.\n  right.\n  apply even_add_one.\n  assumption.\n  left.\n  apply odd_add_one.\n  assumption.\nQed.\n\nTheorem even_mul : forall n m, even n -> even (n * m).\nProof.\n  intros.\n  induction H.\n  constructor.\n  assert ({even m} + {odd m}).\n  apply even_odd_dec.\n  inversion H0.\n  assert (m + (m + n * m) = (m + m) + n * m).\n  omega.\n  simpl.\n  rewrite H2.\n  apply even_add_even.\n  apply even_add_even.\n  assumption.\n  assumption.\n  assumption.\n  apply even_mul_odd.\n  constructor; assumption.\n  assumption.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5ea9b14c9b7bf50001b88e55":[{"id":33202,"user_id":null,"body":"Require Import Preloaded.\nFrom Coq Require Import Relations.\n\nTheorem incl_refl : forall {A},\n  reflexive _ (inclusion A).\nProof. firstorder. Qed. \n\nTheorem incl_trans : forall {A},\n  transitive _ (inclusion A). \nProof. firstorder. Qed.\n\nTheorem comp_refl : forall {A} R1 R2,\n  reflexive A R1 ->\n  reflexive _ R2 ->\n  reflexive _ (compose R1 R2).\nProof. firstorder. Qed.\n\nTheorem comp_assoc : forall {A} R1 R2 R3 (a d : A),\n  compose (compose R1 R2) R3 a d <->\n  compose R1 (compose R2 R3) a d.\nProof. firstorder. Qed.\n\nTheorem trans_iff_comp_incl : forall {A} R,\n  transitive A R <-> inclusion _ (compose R R) R.\nProof. firstorder. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33203,"user_id":null,"body":"\n\nRequire Import Preloaded.\nFrom Coq Require Import Relations.\n\nTheorem incl_refl : forall {A}, reflexive _ (inclusion A).\nProof. easy. Qed.\n\nTheorem incl_trans : forall {A}, transitive _ (inclusion A).\nProof. lazy. auto. Qed.\n\nTheorem comp_refl : forall {A} R1 R2, reflexive A R1 -> reflexive _ R2 -> \nreflexive _ (compose R1 R2).\nProof. lazy. intros. exists x. auto. Qed.\n\nTheorem comp_assoc : forall {A} R1 R2 R3 (a d : A), compose (compose R1 R2) R3 a d \n<-> compose R1 (compose R2 R3) a d.\nProof. \n  lazy. intros. split.\n  intros. repeat destruct H. exists x0. split. auto. exists x. split; auto.\n  intros. repeat destruct H. repeat destruct H0. exists x0. split. exists x. split; auto. auto.\nQed.\n\nTheorem trans_iff_comp_incl : forall {A} R, transitive A R <-> inclusion _ (compose R R) R.\nProof. \n  lazy. intros. split.\n  intros. repeat destruct H0. specialize (H x x0 y). auto.\n  intros. apply (H x z). exists y. auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33204,"user_id":null,"body":"Require Import Preloaded.\nFrom Coq Require Import Relations.\n\nTheorem incl_refl : forall {A}, reflexive _ (inclusion A).\nProof. easy. Qed.\n\nTheorem incl_trans : forall {A}, transitive _ (inclusion A).\nProof. lazy. auto. Qed.\n\nTheorem comp_refl : forall {A} R1 R2, reflexive A R1 -> reflexive _ R2 -> \nreflexive _ (compose R1 R2).\nProof. lazy. intros. exists x. auto. Qed.\n\nTheorem comp_assoc : forall {A} R1 R2 R3 (a d : A), compose (compose R1 R2) R3 a d \n<-> compose R1 (compose R2 R3) a d.\nProof. \n  lazy. intros. split.\n  intros. inversion H. inversion H0. inversion H1. exists x0. split. \n  inversion H3. auto. exists x.  split.  inversion H3. auto. auto.\n  intros. inversion H. inversion H0. inversion H2. exists x0. split. \n  exists x. split. auto. inversion H3. auto. inversion H3. auto.  \nQed.\n\nTheorem trans_iff_comp_incl : forall {A} R, transitive A R <-> \ninclusion _ (compose R R) R.\nProof. \n  lazy. intros. split.\n  intros. destruct H0. specialize (H x x0 y). destruct H0. auto.\n  intros. specialize (H x z). apply H. exists y. auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33205,"user_id":null,"body":"Require Import Preloaded.\nFrom Coq Require Import Relations.\n\nTheorem incl_refl : forall {A},\n  reflexive _ (inclusion A).\nProof.\n  intros A x y z h.\n  exact h.\nQed.\n\nTheorem incl_trans : forall {A},\n  transitive _ (inclusion A).\nProof.\n  intros A R1 R2 R3 h12 h23 x y h1xy.\n  apply h23. apply h12. assumption.\nQed.\n\nTheorem comp_refl : forall {A} R1 R2,\n  reflexive A R1 ->\n  reflexive _ R2 ->\n  reflexive _ (compose R1 R2).\nProof.\n  intros A R1 R2 h1 h2 x.\n  exists x.\n  split.\n  - apply h1.\n  - apply h2.\nQed.\n\nTheorem comp_assoc : forall {A} R1 R2 R3 (a d : A),\n  compose (compose R1 R2) R3 a d <->\n  compose R1 (compose R2 R3) a d.\nProof. \n  intros A R1 R2 R3 a d.\n  split.\n  + intros [c [[b [h1 h2]] h3]]. exists b ; split ; auto.\n    exists c. tauto.\n  + intros [b [h1 [c [h2 h3]]]]. exists c ; split ; auto.\n    exists b. tauto.\nQed.\n\nTheorem trans_iff_comp_incl : forall {A} R,\n  transitive A R <-> inclusion _ (compose R R) R.\nProof.\n  intros A R. split.\n  + intros hAR x z [y [hxy hyz]]. apply (hAR x y) ; auto.\n  + intros hAR x y z hxy hyz. apply hAR. exists y. tauto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33206,"user_id":null,"body":"Require Import Preloaded.\nFrom Coq Require Import Relations.\n\n(* Composition of two binary relations\n   Given two binary relations [R1, R2 : A -> A -> Prop],\n   we define their composition [compose R1 R2] as follows:\n   for any [a, c], [compose R1 R2 a c] if and only if there\n   is [b] such that [R1 a b] and [R2 b c] *)\nDefinition compose {A : Type} (R1 R2 : A -> A -> Prop) (a c : A) :=\n  exists b, R1 a b \/\\ R2 b c.\n\nFrom Coq Require Import Relations.\n\nTheorem incl_refl : forall {A},\n    reflexive _ (inclusion A).\nProof. intros ? ? ?; auto. Qed.\n\nTheorem incl_trans : forall {A},\n    transitive _ (inclusion A).\nProof.\n  intros A R1 R2 R3 H12 H23 x y Hxy; apply H23, H12; auto.\nQed.\n\nTheorem comp_refl : forall {A} R1 R2,\n    reflexive A R1 ->\n    reflexive _ R2 ->\n    reflexive _ (compose R1 R2).\nProof. intros A R1 R2 HR1 HR2 x; exists x; split; auto. Qed.\n\nTheorem comp_assoc : forall {A} R1 R2 R3 (a d : A),\n    compose (compose R1 R2) R3 a d <->\n      compose R1 (compose R2 R3) a d.\nProof.\n  intros A R1 R2 R3 x y; split.\n  - intros [z [[w [H0 H1]] H2]].\n    exists w; intuition; exists z; intuition.\n  - intros [z [H0 [w [H1 H2]]]].\n    exists w; intuition; exists z; intuition.\nQed.\n\nTheorem trans_iff_comp_incl : forall {A} R,\n    transitive A R <-> inclusion _ (compose R R) R.\nProof.\n  intros A R; split.\n  - intros Htrans x y [z [Hxz Hzy]]; eapply Htrans; eauto.\n  - intros Hincl x y z Rxy Ryz; apply Hincl; exists y; auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33207,"user_id":191,"body":"Require Import Preloaded.\nFrom Coq Require Import Relations.\n\nTheorem incl_refl : forall {A},\n  reflexive _ (inclusion A).\nProof. intuition. Qed.\n\nTheorem incl_trans : forall {A},\n  transitive _ (inclusion A).\nProof. intuition. Qed.\n\nTheorem comp_refl : forall {A} R1 R2,\n  reflexive A R1 ->\n  reflexive _ R2 ->\n  reflexive _ (compose R1 R2).\nProof.\n  intros.\n  intro a.\n  exists a.\n  auto.\nQed.\n\nTheorem comp_assoc : forall {A} R1 R2 R3 (a d : A),\n  compose (compose R1 R2) R3 a d <->\n  compose R1 (compose R2 R3) a d.\nProof.\n  intuition;\n  destruct H;\n  intuition.\n  destruct H0.\n  intuition.\n  exists x0.\n  intuition.\n  exists x.\n  auto.\n  destruct H1.\n  intuition.\n  exists x0.\n  intuition.\n  exists x.\n  auto.\nQed.\n\nTheorem trans_iff_comp_incl : forall {A} R,\n  transitive A R <-> inclusion _ (compose R R) R.\nProof.\n  intuition.\n  intros x y H0.\n  destruct H0.\n  intuition.\n  exact (H x x0 y H1 H2).\n  intros x y z H0 H1.\n  apply H.\n  exists y.\n  auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33208,"user_id":null,"body":"Require Import Preloaded.\nFrom Coq Require Import Relations.\n\nTheorem incl_refl : forall {A},\n  reflexive _ (inclusion A).\nProof. \n  intros A R x y hxy.\n  assumption.\nQed.\n\nTheorem incl_trans : forall {A},\n  transitive _ (inclusion A).\nProof.\n  intros A R1 R2 R3 h12 h23 x y hxy.\n  apply h23. apply h12. assumption.\nQed.\n\nTheorem comp_refl : forall {A} R1 R2,\n  reflexive A R1 ->\n  reflexive _ R2 ->\n  reflexive _ (compose R1 R2).\nProof. \n  intros A R1 R2 h1 h2 x.\n  exists x.\n  split.\n  exact (h1 x).\n  exact (h2 x).\nQed.\n\nTheorem comp_assoc : forall {A} R1 R2 R3 (a d : A),\n  compose (compose R1 R2) R3 a d <->\n  compose R1 (compose R2 R3) a d.\nProof. \n  intros A R1 R2 R3 a d.\n  split.\n  {\n    intros h.\n    destruct h as [c [h1 hcd]].\n    destruct h1 as [b [hab hbc]].\n    exists b.\n    split. assumption.\n    exists c.\n    split; assumption.\n  }\n  {\n    intros h.\n    destruct h as [b [hab h1]].\n    destruct h1 as [c [hbc hcd]].\n    exists c.\n    split.\n    exists b.\n    split.\n    assumption. assumption. assumption.\n  }\nQed.\n\nTheorem trans_iff_comp_incl : forall {A} R,\n  transitive A R <-> inclusion _ (compose R R) R.\nProof. \n  intros A R.\n  split.\n  {\n    intros h x y h2.\n    destruct h2 as [z [hxz hzy]].\n    refine (h x z y _ _);\n    assumption.\n  }\n  {\n    intros h x z y hxz hzy.\n    apply h.\n    exists z.\n    eauto. \n  }\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33209,"user_id":null,"body":"Require Import Preloaded.\nFrom Coq Require Import Relations.\n\nTheorem incl_refl : forall {A},\n  reflexive _ (inclusion A).\nProof. intros A R x y xy; apply xy. Qed.\n\nTheorem incl_trans : forall {A},\n  transitive _ (inclusion A).\nProof.\n  intros A R1 R2 R3 inc12 inc23 x y xy.\n  apply inc23, inc12, xy.\nQed.\n\nTheorem comp_refl : forall {A} R1 R2,\n  reflexive A R1 ->\n  reflexive _ R2 ->\n  reflexive _ (compose R1 R2).\nProof.\n  intros A R1 R2 refl1 refl2 x.\n  now exists x.\nQed.\n\nTheorem comp_assoc : forall {A} R1 R2 R3 (a d : A),\n  compose (compose R1 R2) R3 a d <->\n  compose R1 (compose R2 R3) a d.\nProof.\n  split.\n  - intros [c [[b [ab bc]] cd]].\n    exists b; split; [|exists c]; easy.\n  - intros [b [ab [c [bc cd]]]].\n    exists c; split; [exists b|]; easy.\nQed.\n\nTheorem trans_iff_comp_incl : forall {A} R,\n  transitive A R <-> inclusion _ (compose R R) R.\nProof.\n  split.\n  - intros trans x z [y [xy yz]].\n    now apply trans with y.\n  - intros comp_incl x y z xy yz.\n    apply comp_incl; now exists y.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33210,"user_id":null,"body":"Require Import Preloaded.\nFrom Coq Require Import Relations.\n\nTheorem incl_refl : forall {A},\n  reflexive _ (inclusion A).\nProof.\n  intros.\n  cbv.\n  firstorder.\nQed.\n   \n\nTheorem incl_trans : forall {A},\n  transitive _ (inclusion A).\nProof.\n  cbv.\n  firstorder.\nQed.\n\nTheorem comp_refl : forall {A} R1 R2,\n  reflexive A R1 ->\n  reflexive _ R2 ->\n  reflexive _ (compose R1 R2).\nProof. firstorder. Qed.\n\nTheorem comp_assoc : forall {A} R1 R2 R3 (a d : A),\n  compose (compose R1 R2) R3 a d <->\n  compose R1 (compose R2 R3) a d.\nProof. firstorder. Qed.\n\nTheorem trans_iff_comp_incl : forall {A} R,\n  transitive A R <-> inclusion _ (compose R R) R.\nProof. firstorder. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33211,"user_id":null,"body":"Require Import Preloaded.\nFrom Coq Require Import Relations.\n\n\nTheorem incl_refl : forall {A},\n  reflexive _ (inclusion A).\nProof. \n  intro. intro.\n  intro. auto.\nQed.\n\nTheorem incl_trans : forall {A},\n  transitive _ (inclusion A).\nProof. \n  intro. intro.\n  intros. unfold inclusion in *. intros. apply H0, H, H1.\nQed. \n\nTheorem comp_refl : forall {A} R1 R2,\n  reflexive A R1 ->\n  reflexive _ R2 ->\n  reflexive _ (compose R1 R2).\nProof.\n  intros.\n  unfold reflexive in *. intros. exists x. split; auto.\nQed. \n\nTheorem comp_assoc : forall {A} R1 R2 R3 (a d : A),\n  compose (compose R1 R2) R3 a d <->\n  compose R1 (compose R2 R3) a d.\nProof. \n    intros. split; intros; unfold compose in *.\n    - destruct H. destruct H. destruct H. destruct H. exists x0. split;auto. exists x. split;auto.\n    - repeat destruct H. repeat destruct H0.  exists x0. split;auto. exists x. split; auto.\nQed.\n\nTheorem trans_iff_comp_incl : forall {A} R,\n  transitive A R <-> inclusion _ (compose R R) R.\nProof. \n  intros. split; intros.\n  - unfold inclusion; unfold transitive,compose in *. intros. destruct H0. destruct H0. apply H with x0; auto.\n  - unfold inclusion, transitive,compose in * . intros. apply H. exists y; auto.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5eaa05ce96ed2500292a6d29":[{"id":33212,"user_id":568,"body":"Require Import Preloaded Arith Lia.\n\nTheorem summation_formula : forall n,\n  6 * summation n = n * (n + 1) * (4 * n - 1).\nProof.\n  induction n as [ | [] ]; cbn in *; lia.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33213,"user_id":106,"body":"Require Import Preloaded Arith.\n\nTheorem summation_formula : forall n,\n  6 * summation n = n * (n + 1) * (4 * n - 1).\nProof.\n  induction n; auto.\n  simpl; ring_simplify; rewrite IHn.\n  destruct n; auto.\n  simpl; repeat rewrite Nat.sub_0_r; ring.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33214,"user_id":null,"body":"Require Import Preloaded Lia PeanoNat.\nImport Nat.\n\nTheorem summation_formula : forall n,\n  6 * summation n = n * (n + 1) * (4 * n - 1).\nProof. \n  intro; rewrite mul_comm.\n  induction n; auto; simpl.\n  rewrite add_0_r, !sub_0_r, mul_add_distr_r, IHn; nia.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33215,"user_id":null,"body":"Require Import Preloaded Arith Lia.\n\nTheorem summation_formula : forall n,\n  6 * summation n = n * (n + 1) * (4 * n - 1).\nProof. \n    intros.\n    induction n as [|m hm]. auto.\n    replace (summation (S m)) with ((S m) * (2 * (S m) - 1) + summation m) by auto.\n    rewrite (Nat.mul_add_distr_l 6) , hm.\n    replace (2 * S m - 1) with (2 * m + 1) by lia.\n    replace (4 * S m - 1) with (4 * m + 3) by lia.\n    destruct m. reflexivity.\n    replace (4 * S m - 1) with (4 * m + 3) by lia.\n    ring.   \nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33216,"user_id":null,"body":"Require Import Preloaded Arith.\n\nLemma summation_S : forall n, summation (S n) = S n * (2 * n + 1) + summation n.\nProof. intros; simpl; repeat rewrite Nat.sub_0_r; ring. Qed.\n\nTheorem summation_formula : forall n,\n  6 * summation n = n * (n + 1) * (4 * n - 1).\nProof.\n  intros [|n]; [easy|].\n  replace (4 * S n) with (4 + 4 * n); [|ring].\n  replace (4 + 4 * n - 1) with (3 + 4 * n); [|easy]. \n  induction n; [easy|].\n  rewrite summation_S, Nat.mul_add_distr_l, IHn; ring.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33217,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Lia.\nRequire Import Arith Nat.\n\nTheorem summation_formula : forall n,\n  6 * summation n = n * (n + 1) * (4 * n - 1).\nProof. intros. induction n; simpl; [|ring_simplify; rewrite IHn]; (try destruct n); lia. Qed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33218,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Lia.\nRequire Import Arith Nat.\n\nTheorem summation_formula : forall n,\n  6 * summation n = n * (n + 1) * (4 * n - 1).\nProof.\n  intros.\n  induction n.\n  - simpl. lia.\n  - simpl. ring_simplify. rewrite -> IHn. induction n.\n    + lia.\n    + lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33219,"user_id":null,"body":"Require Import Preloaded.\n\nRequire Import Coq.micromega.Lia.\n\nTheorem summation_formula : forall n,\n    6 * summation n = n * (n + 1) * (4 * n - 1).\nProof.\n  intro n; induction n; simpl; auto.\n  rewrite <- plus_n_O, PeanoNat.Nat.sub_0_r; nia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33220,"user_id":null,"body":"Require Import Preloaded.\nFrom Coq Require Arith.\nRequire Import ArithRing Ring.\nRequire Import Lia.\n\nLemma sum_helper: forall n : nat,\n    6 * summation (S n) = 6 * summation n + 6 * S n * (2 * S n - 1).\nProof.\n  induction n.\n  -auto.  \n  -rewrite IHn. simpl. ring.\n Qed. \n   \nTheorem summation_formula : forall n,\n  6 * summation n = n * (n + 1) * (4 * n - 1).\nProof. \n  induction n.\n  -auto.\n  -rewrite sum_helper. rewrite IHn. ring_simplify.\n   (try destruct n); lia.\nQed.   \n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33221,"user_id":null,"body":"Require Import Preloaded.\n\nRequire Import Lia.\n\nTheorem summation_formula : forall n,\n  6 * summation n = n * (n + 1) * (4 * n - 1).\nProof.\n  induction n.\n  simpl.\n  reflexivity.\n  simpl summation.\n  rewrite <- Minus.minus_n_O.\n  rewrite <- plus_n_O.\n  rewrite PeanoNat.Nat.mul_add_distr_l.\n  rewrite IHn.\n  simpl.\n  repeat rewrite <- plus_n_O.\n  rewrite <- Minus.minus_n_O.\n  nia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5eaad37e96b2c400205f9905":[{"id":33222,"user_id":null,"body":"Require Import Preloaded List.\n\nTheorem fword_SS : forall n, fword (S (S n)) = fword (S n) ++ fword n.\nProof. \n  intro. induction n. easy. \n  simpl in *. unfold fword_aux in *.\n  rewrite <- flat_map_app, IHn. auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33223,"user_id":null,"body":"Require Import Preloaded.\nFrom Coq Require Import Lists.List.\nImport ListNotations.\n\nTheorem fword_SS : forall n, fword (S (S n)) = fword (S n) ++ fword n.\nProof. \n  intro. induction n. easy.\n  simpl in *. unfold fword_aux in *.\n  rewrite <- flat_map_app, IHn. auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33224,"user_id":null,"body":"Require Import Preloaded.\nFrom Coq Require Import Lists.List.\nImport ListNotations.\n\nLemma iter_end : forall {T} n f (x: T), Nat.iter (S n) f x = Nat.iter n f (f x).\nProof.\n  induction n; intros f x; [easy|].\n  simpl in *; now repeat rewrite IHn.\nQed.\n\nTheorem fword_SS : forall n,\n  fword (S (S n)) = fword (S n) ++ fword n.\nProof.\n  intros n; unfold fword; repeat rewrite iter_end; simpl.\n  replace [false; true; false] with ([false; true] ++ [false]); [|easy].\n  generalize [false; true], [false]; induction n; intros l r; [easy|].\n  simpl; rewrite IHn; generalize (Nat.iter n fword_aux l), (Nat.iter n fword_aux r).\n  clear; intros l; induction l; intros r; [easy|].\n  simpl; now rewrite IHl, app_assoc.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33225,"user_id":null,"body":"Require Import Preloaded.\nFrom Coq Require Import Lists.List.\nImport ListNotations.\n\nTheorem fword_SS : forall n,\n  fword (S (S n)) = fword (S n) ++ fword n.\nProof.\n  intros.\n  induction n.\n  auto.\n  simpl.\n  simpl in IHn.\n  assert (fword_aux (fword_aux (fword_aux (fword n))) = fword_aux (fword_aux (fword n) ++ fword n)).\n  rewrite IHn. reflexivity.\n  rewrite H.\n  unfold fword_aux.\n  repeat rewrite flat_map_app.\n  reflexivity.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33226,"user_id":191,"body":"Require Import Preloaded.\nFrom Coq Require Import Lists.List.\nImport ListNotations.\n\nTheorem iter_succ (A : Type) (a : A) (f : A -> A) (n : nat) : Nat.iter (S n) f a = f(Nat.iter n f a).\nProof.\n  reflexivity.\nQed.\n\nTheorem fword_SS : forall n,\n  fword (S (S n)) = fword (S n) ++ fword n.\nProof.\n  induction n.\n  auto.\n  unfold fword in *.\n  rewrite iter_succ.\n  rewrite IHn at 1.\n  simpl.\n  unfold fword_aux.\n  rewrite flat_map_app.\n  reflexivity.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33227,"user_id":null,"body":"Require Import Preloaded.\nFrom Coq Require Import Lists.List.\nImport ListNotations.\n\nTheorem fword_SS : forall n,\n    fword (S (S n)) = fword (S n) ++ fword n.\nProof.\n  intro n; induction n; auto.\n  set (x := fword (S (S n))).\n  replace (fword (S (S (S n)))) with (fword_aux (fword (S (S n)))) by reflexivity.\n  rewrite IHn; unfold x; simpl; unfold fword_aux.\n  apply flat_map_app.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33228,"user_id":null,"body":"Require Import Preloaded.\nFrom Coq Require Import Lists.List.\nFrom Coq Require Import Arith.\nImport ListNotations.\n\nTheorem strong_induction : forall P : nat -> Prop,\n  (forall m : nat, (forall n : nat, n < m -> P n) -> P m) ->\n  forall n : nat, P n.\nProof.\n  intros P ha N.\n  assert (h0 : P 0).\n  - apply ha. intros n hn. inversion hn.\n  - assert (h : forall n, (forall m, m <= n -> P m)).\n    + intro n. induction n as [| n hn].\n      * intros m hm. replace m with 0. assumption. apply (le_n_0_eq m hm).\n      * intros m hm. apply ha. intros n0 hn0. apply hn. transitivity (pred m).\n        apply lt_n_Sm_le. replace (S (pred m)) with m. assumption. apply (S_pred m n0). \n        assumption. apply le_S_n. replace (S (pred m)) with m. assumption. apply (S_pred m n0).\n        assumption.\n    + eauto.\nQed.\n\nLemma morph_fword_aux (l1 l2 : list bool) : fword_aux (l1) ++ fword_aux (l2) = \nfword_aux(l1 ++ l2).\nProof.\n  unfold fword_aux.\n  induction l1 as [| a ls h].\n  - reflexivity.\n  - simpl. rewrite app_ass. rewrite h. reflexivity.  \nQed.\n\nTheorem fword_SS : forall n,\n  fword (S (S n)) = fword (S n) ++ fword n.\nProof.\n  simpl.\n  induction n using strong_induction.\n  destruct n. reflexivity.\n  simpl.\n  rewrite (morph_fword_aux).\n  rewrite (H n).\n  reflexivity.\n  eauto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33229,"user_id":null,"body":"Require Import Preloaded.\nFrom Coq Require Import Lists.List.\nImport ListNotations.\n\n\nLemma fword_aux_app : forall l l0, fword_aux (l ++ l0) = fword_aux l ++ fword_aux l0.\nProof.\n  induction l.\n  simpl.\n  reflexivity.\n  simpl.\n  intros.\n  rewrite IHl.\n  rewrite app_assoc.\n  reflexivity.\nQed.\n\nTheorem fword_SS : forall n,\n  fword (S (S n)) = fword (S n) ++ fword n.\nProof. \n  intros.\n  induction n.\n  simpl.\n  reflexivity.\n  assert (fword (S (S (S n)))  = fword_aux (fword (S (S n)))).\n  reflexivity.\n  rewrite H.\n  rewrite IHn.\n  rewrite fword_aux_app.\n  rewrite <- IHn.\n  simpl.\n  reflexivity.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33230,"user_id":null,"body":"Require Import Preloaded.\nFrom Coq Require Import Lists.List.\nImport ListNotations.\n\nLemma fword_step : forall n, fword (S n) = fword_aux (fword n).\nProof. easy. Qed.\n\nLemma fword_app : forall a b, fword_aux (a ++ b) = fword_aux a ++ fword_aux b.\nProof.\n  induction a; intros; [easy|].\n  destruct a; simpl; now rewrite IHa.\nQed.\n\nTheorem fword_SS : forall n,\n  fword (S (S n)) = fword (S n) ++ fword n.\nProof.\n  induction n; [easy|].\n  rewrite fword_step, IHn at 1; rewrite fword_app; easy.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33231,"user_id":106,"body":"Require Import Preloaded.\nFrom Coq Require Import Lists.List.\nImport ListNotations.\n\nLemma fword_aux_app : forall l1 l2,\n  fword_aux l1 ++ fword_aux l2 = fword_aux (l1 ++ l2).\nProof.\n  intros. generalize dependent l2. induction l1; intros; auto; simpl in *.\n  now rewrite <- app_assoc, IHl1.\nQed.\n\nTheorem fword_SS : forall n,\n  fword (S (S n)) = fword (S n) ++ fword n.\nProof.\n  intros.\n  induction n.\n  - auto.\n  - simpl in *. now rewrite IHn, <- fword_aux_app, IHn.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5eac8d8845655d003300f5b5":[{"id":33232,"user_id":168,"body":"From Coq Require Import ssreflect Lia Arith.\n\nTheorem a_pow_4_sub_b_pow_4 : forall a b,\n    a ^ 4 - b ^ 4 = (a - b) * (a + b) * (a ^ 2 + b ^ 2).\nProof.\n  have ab a b : a ^ 2 - b ^ 2 = (a - b) * (a + b) by simpl; nia.\n  have eq4 n : n ^ 4 = (n ^ 2) ^ 2 by simpl; ring.\n  by move => a b; rewrite !eq4 !ab.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33233,"user_id":null,"body":"From Coq Require Import PeanoNat.\nRequire Import Lia.\n\nLemma a2_sub_b2 : forall a b,\n  a ^ 2 - b ^ 2 = (a - b) * (a + b).\nProof.\n  intros.\n  rewrite Nat.mul_sub_distr_r.\n  simpl. lia.\nQed.\n\nTheorem a_pow_4_sub_b_pow_4 : forall a b,\n  a ^ 4 - b ^ 4 = (a - b) * (a + b) * (a ^ 2 + b ^ 2).\nProof.\n  intros.\n  repeat rewrite <- a2_sub_b2.\n  simpl. lia.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33234,"user_id":null,"body":"From Coq Require Import PeanoNat.\n\nTheorem a_pow_4_sub_b_pow_4 : forall a b,\n  a ^ 4 - b ^ 4 = (a - b) * (a + b) * (a ^ 2 + b ^ 2).\nProof.\n  intros.\n  rewrite -> Nat.mul_sub_distr_r.\n  rewrite -> Nat.mul_sub_distr_r.\n  rewrite -> (Nat.mul_add_distr_l a).\n  rewrite -> (Nat.mul_add_distr_l b).\n  rewrite -> (Nat.mul_add_distr_r _ _ (a ^ 2 + b ^ 2)).\n  rewrite -> (Nat.mul_add_distr_r _ _ (a ^ 2 + b ^ 2)).\n  rewrite -> Nat.sub_add_distr.\n  rewrite -> (Nat.mul_comm b).\n  rewrite -> Nat.add_sub.\n  rewrite -> Nat.mul_add_distr_l.\n  rewrite -> Nat.mul_add_distr_l.\n  rewrite -> Nat.pow_2_r.\n  rewrite -> Nat.pow_2_r.\n  rewrite -> Nat.sub_add_distr.\n  rewrite -> (Nat.mul_comm (a * a) (b * b)).\n  rewrite -> Nat.add_sub.\n  rewrite <- Nat.mul_assoc.\n  rewrite <- Nat.mul_assoc.\n  unfold Nat.pow.\n  rewrite -> Nat.mul_1_r.\n  rewrite -> Nat.mul_1_r.\n  reflexivity.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33235,"user_id":null,"body":"From Coq Require Import PeanoNat Arith.\n\nLemma diff_exists : forall a b, exists c, a = b + c \\\/ b = a + c.\nProof.\n  induction a; intros b; [exists b; now right|].\n  destruct (IHa b) as [c [Ha|Hb]]; [exists (S c); left; rewrite Ha; ring|].\n  destruct c; [|exists c; right; rewrite Hb; ring].\n  exists 1; left; rewrite Hb; ring.\nQed.\n\nLemma sum_of_fourth : forall a b, (a + b)^4 = a^4 + 4*a^3*b + 6*a^2*b^2 + 4*a*b^3 + b^4.\nProof. intros; simpl; ring. Qed.\n\nTheorem a_pow_4_sub_b_pow_4 : forall a b,\n  a ^ 4 - b ^ 4 = (a - b) * (a + b) * (a ^ 2 + b ^ 2).\nProof.\n  intros a b; destruct (diff_exists a b) as [c [Ha|Hb]]; subst.\n  - rewrite sum_of_fourth, minus_plus.\n    repeat rewrite <- Nat.add_assoc; rewrite minus_plus.\n    simpl; ring.\n  - rewrite sum_of_fourth; repeat rewrite Nat.sub_add_distr; now repeat rewrite Nat.sub_diag.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33236,"user_id":null,"body":"From Coq Require Import PeanoNat.\nFrom mathcomp Require Import ssreflect ssrfun ssrbool eqtype ssrnat.\n\nTheorem a_pow_4_sub_b_pow_4_ssrnat : forall a b,\n  a ^ 4 - b ^ 4 = (a - b) * (a + b) * (a ^ 2 + b ^ 2).\nProof.\n  move => a b.\n  case: (ltnP b a) => [b_lt_a|b_ge_a].\n  - assert (b + (a - b) = a) by (exact (subnKC (leq_trans (leqnSn b) b_lt_a))).\n    set x := a - b.\n    rewrite <- H.\n    assert ((b + x) ^ 4 = (x * (b + x + b) * ((b + x) ^ 2 + b ^ 2)) + b ^ 4).\n    + repeat rewrite expnS. repeat rewrite expn0. ring_simplify. auto.\n    + rewrite H0. rewrite addnK. auto.\n  - assert (a ^ 2 <= b ^ 2) as b2_ge_a2 by exact (leq_mul b_ge_a b_ge_a).\n    assert (a ^ 3 <= b ^ 3) as b3_ge_a3 by exact (leq_mul b_ge_a b2_ge_a2).\n    assert (a ^ 4 <= b ^ 4) as b4_ge_a4 by exact (leq_mul b_ge_a b3_ge_a3).\n    rewrite (eqnP b_ge_a).\n    rewrite (eqnP b4_ge_a4).\n    done.\nQed.\n\nLemma powE : Nat.pow =2 expn.\nProof. by move=> m n; elim: n => \/\/= n ->; rewrite expnS; rewrite <- multE. Qed.\n\nClose Scope nat_scope.\nOpen Scope coq_nat.\nLocal Notation \"m ^ n\" := (Nat.pow m n).\n\nTheorem a_pow_4_sub_b_pow_4 : forall a b,\n  ((a ^ 4)%coq_nat - (b ^ 4)%coq_nat)%coq_nat = (((a - b)%coq_nat * (a + b)%coq_nat)%coq_nat * ((a ^ 2)%coq_nat + (b ^ 2)%coq_nat)%coq_nat)%coq_nat.\nProof.\n  move => a b.\n  repeat rewrite plusE.\n  repeat rewrite minusE.\n  repeat rewrite multE.\n  repeat rewrite powE.\n  exact (a_pow_4_sub_b_pow_4_ssrnat a b).\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33237,"user_id":null,"body":"From Coq Require Import PeanoNat Lia.\n\nTheorem a_pow_4_sub_b_pow_4 : forall a b,\n  a ^ 4 - b ^ 4 = (a - b) * (a + b) * (a ^ 2 + b ^ 2).\nProof.   \n  intros.\n  assert (a <= b \\\/ a > b) by lia.\n  destruct H.\n  rewrite <- Nat.sub_0_le in H.\n  enough (a ^ 4 - b ^ 4 = 0) by lia.\n  rewrite Nat.sub_0_le in H.\n  assert (a ^ 4 <= b ^ 4).\n  simpl.\n  enough (a * a <= b * b) by nia.\n  nia.\n  rewrite Nat.sub_0_le.\n  exact H0.\n  assert ((a - b) * (a + b) = a * a - b * b) by nia.\n  rewrite H0.\n  simpl.\n  nia.\n\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33238,"user_id":null,"body":"From Coq Require Import PeanoNat Arith.\n\n(* Easy way, just use 'nia' *)\n\nTheorem a_pow_4_sub_b_pow_4 : forall a b,\n  a ^ 4 - b ^ 4 = (a - b) * (a + b) * (a ^ 2 + b ^ 2).\nProof.\n  intros. \n  rewrite !Nat.mul_sub_distr_r.\n  rewrite !Nat.mul_add_distr_l.\n  rewrite !Nat.mul_add_distr_r.\n  rewrite !Nat.add_assoc.\n  rewrite (Nat.mul_comm b a).\n  rewrite <- !Nat.mul_assoc.\n  rewrite <- !Nat.pow_succ_r'.\n  rewrite !(Nat.mul_comm b).\n  rewrite <- !Nat.mul_assoc.\n  rewrite <- Nat.pow_2_r.\n  rewrite !Nat.mul_assoc.\n  rewrite <- Nat.pow_2_r.\n  rewrite <- !Nat.pow_succ_r'.\n  rewrite <- !(Nat.add_assoc (a^4) _).\n  rewrite Nat.add_comm.\n  rewrite <- minus_plus_simpl_l_reverse.\n  auto.\nQed.\n\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33239,"user_id":null,"body":"From Coq Require Import PeanoNat.\nFrom Coq Require Import Arith.Minus.\n\nTheorem a_pow_4_sub_b_pow_4 : forall a b,\n  a ^ 4 - b ^ 4 = (a - b) * (a + b) * (a ^ 2 + b ^ 2).\nProof.\n  intros. \n  cbn.\n  rewrite !Nat.mul_sub_distr_r.\n  rewrite !Nat.mul_add_distr_l.\n  rewrite !Nat.mul_add_distr_r.\n  rewrite !(Nat.mul_comm b a).\n  rewrite !(Nat.mul_comm ( _ * b) (a  *  _)).\n  rewrite !Nat.mul_1_r.\n  rewrite !Nat.mul_assoc.\n  rewrite !Nat.add_assoc.\n  rewrite <- !(Nat.add_assoc (a*a*a*a) _).\n  rewrite Nat.add_comm.\n  apply minus_plus_simpl_l_reverse.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33240,"user_id":null,"body":"From Coq Require Import PeanoNat Arith.\n\nLemma cases : forall a b,\n  (exists a', a + a' = b) \\\/\n  (exists b', b + b' = a).\nProof.\n  induction a; intros.\n  - left; now exists b.\n  - destruct (IHa b) as [[a' Ha']|[b' Hb']]; [destruct a'|].\n    + right; exists 1; rewrite <- Ha'; ring.\n    + left; exists a'; rewrite <- Ha'; ring.\n    + right; exists (S b'); rewrite <- Hb'; ring.\nQed.\n\nLemma sum4th : forall a b, (a + b)^4 = a^4 + 4 * a^3 * b + 6 * a^2 * b^2 + 4 * a * b^3 + b^4.\nProof. intros; simpl; ring. Qed.\n\nTheorem a_pow_4_sub_b_pow_4 : forall a b,\n  a ^ 4 - b ^ 4 = (a - b) * (a + b) * (a ^ 2 + b ^ 2).\nProof.\n  intros a b; destruct (cases a b) as [[a' Ha']|[b' Hb']].\n  - rewrite <- Ha', sum4th; repeat rewrite Nat.sub_add_distr;\n    repeat rewrite Nat.sub_diag; repeat rewrite Nat.sub_0_l; ring.\n  - rewrite <- Hb', sum4th; repeat rewrite <- Nat.add_assoc.\n    rewrite Nat.add_comm, Nat.add_sub, (Nat.add_comm b), Nat.add_sub.\n    simpl; ring.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33241,"user_id":null,"body":"From Coq Require Import PeanoNat Arith.\n\nTheorem a_pow_4_sub_b_pow_4 : forall a b,\n  a ^ 4 - b ^ 4 = (a - b) * (a + b) * (a ^ 2 + b ^ 2).\nProof.\n  intros; destruct (Nat.le_ge_cases a b).\n  - rewrite (proj2 (Nat.sub_0_le _ _) H), (proj2 (Nat.sub_0_le _ _) (Nat.pow_le_mono_l _ _ _ H)); ring.\n  - destruct (Nat.le_exists_sub _ _ H) as [a' [Ha' _]].\n    rewrite Ha', Nat.add_sub.\n    assert ((a' + b)^4 = (a'^4 + 4 * a'^3 * b + 6 * a'^2 * b^2 + 4 * a' * b^3) + b ^ 4) as Hr; [simpl; ring|rewrite Hr; clear Hr].\n    rewrite Nat.add_sub; simpl; ring.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5eb0ce255179590016d613ce":[{"id":33242,"user_id":null,"body":"Theorem not_not_not : forall P, ~~~P -> ~P.\nProof. auto. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33243,"user_id":null,"body":"Theorem not_not_not : forall P, ~~~P -> ~P.\nProof.\n  intros P H H0.\n  elim H; intro H1; contradiction.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33244,"user_id":null,"body":"Lemma dni : forall (P: Prop), P -> ~~P.\nProof. unfold not; intros; case (H0 H). Qed.\n\nTheorem not_not_not : forall P, ~~~P -> ~P.\nProof. unfold not; intros; case (H (dni _ H0)). Qed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33245,"user_id":null,"body":"Theorem not_not_not : forall P, ~~~P -> ~P.\nProof.\n  intros P A B.\n  apply A.\n  intro C.\n  apply C.\n  exact B.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33246,"user_id":null,"body":"Theorem not_not_not : forall P, ~~~P -> ~P.\nProof.\n  intros * H Z.\n  apply H.\n  intros Y. \n  apply Y.\n  apply Z.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33247,"user_id":null,"body":"Theorem not_not_not : forall P, ~~~P -> ~P.\nProof.\n  unfold not. intros.\n  apply H; intros. auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33248,"user_id":null,"body":"Theorem not_not_not : forall P, ~~~P -> ~P.\nProof.\n  intros P HNP HP.\n  assert (A: ~ ~ P). { intros HA. apply HA in HP. assumption. }\n  apply HNP in A. assumption.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33249,"user_id":null,"body":"Theorem not_not_not : forall P, ~~~P -> ~P.\n  intros P HnnnP.\n  intros HP.\n  destruct HnnnP.\n  intro HnP.\n  apply HnP in HP as explosion.\n  apply explosion.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33250,"user_id":null,"body":"Theorem not_not_not : forall P, ~~~P -> ~P.\nProof.\n  exact (fun (P : Prop) (f : ~ ~ ~ P) (p : P) => f (fun np : ~ P => np p)).\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33251,"user_id":null,"body":"Theorem not_not_not : forall P, ~~~P -> ~P.\nProof.\n    intros P hnnnp hp.\n    apply hnnnp.\n    intros hnp.\n    apply hnp.\n    assumption.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5eb2c73ff08e28002471b09e":[{"id":33252,"user_id":null,"body":"From Coq Require Import ZArith.\nRequire Import Lia.\nOpen Scope Z.\n\nTheorem int_induction : forall (P : Z -> Prop) (m : Z),\n  (forall n, n <= m -> P n) ->\n  (forall n, m <= n -> P n -> P (Z.succ n)) ->\n  forall n, P n.\nProof. intros. destruct (Z_le_gt_dec n m).\n* apply (H _ l).\n* apply Zlt_lower_bound_ind with (z:=m);[|lia].\n  intros.\n  destruct (Z.eq_dec m x).\n + apply H.\n   congruence.\n + rewrite Zsucc_pred.\n   apply H0;\n   [|apply H1];\n   lia.\nQed.\n\nClose Scope Z. ","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33253,"user_id":null,"body":"From Coq Require Import ZArith.\n\nOpen Scope Z.\n\nLemma le_succ_induction : forall (P : Z -> Prop),\n  (forall n, n <= 0 -> P n) ->\n  (forall n, 0 <= n -> P n -> P (Z.succ n)) ->\n  forall n, P n.\nProof.\n  intros P Pneg Ppos n; destruct (Z.le_ge_cases n 0) as [Hneg|Hpos]; [now apply Pneg|].\n  apply natlike_ind; [apply Pneg| |]; easy.\nQed.\n\nTheorem int_induction : forall (P : Z -> Prop) (m : Z),\n  (forall n, n <= m -> P n) ->\n  (forall n, m <= n -> P n -> P (Z.succ n)) ->\n  forall n, P n.\nProof.\n  intros P m Ple PS n.\n  specialize (le_succ_induction (fun z => P (z + m))); intros H.\n  rewrite <- (Z.sub_add m n); apply H.\n  - intros; apply Ple.\n    replace m with (0 + m) at 2; [|easy].\n    now apply Zplus_le_compat_r.\n  - intros; rewrite Z.add_succ_l; apply PS; [|easy].\n    replace m with (0 + m) at 1; [|easy].\n    now apply Zplus_le_compat_r.\nQed.\n\nClose Scope Z.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33254,"user_id":null,"body":"From Coq Require Import ZArith.\nRequire Import Psatz.\nOpen Scope Z.\n\nTheorem int_induction : forall (P : Z -> Prop) (m : Z),\n  (forall n, n <= m -> P n) ->\n  (forall n, m <= n -> P n -> P (Z.succ n)) ->\n  forall n, P n.\nProof.\n  intros P m h1 h2 n.\n  destruct (Z.lt_total n m) as [ineq | [ineq | ineq]].\n  + apply h1. lia.\n  + apply h1. lia.\n  + assert (hrec : forall k : nat, P (m + (Z.of_nat k))).\n  {\n    intro k.\n    induction k.\n    - apply h1.\n      lia.\n    - simpl. rewrite Zpos_P_of_succ_nat. rewrite Z.add_succ_r. \n      apply h2. lia. assumption.\n  }\n  replace n with (m + Z.of_nat (Z.to_nat (n-m))).\n  apply hrec.\n  rewrite Z2Nat.id.\n  ring.\n  lia.\nQed.\nClose Scope Z.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33255,"user_id":null,"body":"From Coq Require Import ZArith.\nRequire Import Lia.\n\nOpen Scope Z.\n\nTheorem int_induction : forall (P : Z -> Prop) (m : Z),\n  (forall n, n <= m -> P n) ->\n  (forall n, m <= n -> P n -> P (Z.succ n)) ->\n  forall n, P n.\nProof. \n  intros.\n  pose (n-m).\n  assert (n = z+m). { symmetry. apply Z.add_move_r. auto. }\n  rewrite H1.\n  destruct z eqn:QQ; try (apply H;lia).\n  rewrite <- (Z2Nat.id (Z.pos p)).\n  2:lia.\n  induction (Z.to_nat (Z.pos p)).\n  - apply H. lia.\n  - rewrite Nat2Z.inj_succ, Z.add_succ_l. apply H0. lia. auto.\nQed.\n\n\nClose Scope Z.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33256,"user_id":null,"body":"From Coq Require Import ZArith Lia.\n\nOpen Scope Z.\n\nTheorem int_induction : forall (P : Z -> Prop) (m : Z),\n  (forall n, n <= m -> P n) ->\n  (forall n, m <= n -> P n -> P (Z.succ n)) ->\n  forall n, P n.\nProof.\n  intros P m Plo Phi; cut (forall n, P (m + Z.of_nat n)).\n  - intros H n; destruct (Z.le_ge_cases n m).\n    + now apply Plo.\n    + rewrite <- (Zplus_minus m n), <- (Z2Nat.id (n - m)); [apply H|].\n      now apply Zle_minus_le_0.\n  - induction n.\n    + apply Plo; now rewrite Z.add_0_r.\n    + assert (m + Z.of_nat (S n) = Z.succ (m + Z.of_nat n)); [lia|].\n      rewrite H; apply Phi; [lia|easy].\nQed.\n\nClose Scope Z.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33257,"user_id":null,"body":"From Coq Require Import ZArith Lia.\n\nOpen Scope Z.\n\nLemma poseq_dec\n  : forall x y : positive, {x = y} + {x <> y}.\nProof. intro. induction x. intro. destruct y. pose proof (IHx y).\n       destruct H. left. rewrite e. auto. right. intro. apply n. inversion H. auto.\n       right. intro; inversion H. right. intro. inversion H.\n       intro. destruct y. right; intro; inversion H. \n       destruct (IHx y). rewrite e. left; auto. right. intro; apply n. inversion H. auto.\n       right. intro; inversion H. destruct y. right; intro; inversion H.\n       right; intro; inversion H. left; auto. Qed.\n\nLemma Zeq_dec\n  : forall x y : Z, {x = y} + {x <> y}.\nProof. intro. induction x. induction y. left; auto. right. lia. right; lia.\n       intro. induction y. right; lia. destruct (poseq_dec p p0).\n       rewrite e. auto. right. intro; apply n; inversion H; auto.\n       right; intro; inversion H.\n       destruct y. right. lia. right. intro. inversion H. destruct (poseq_dec p p0).\n       rewrite e. auto. right. intro; apply n; inversion H; auto. Qed.       \n\nTheorem int_induction : forall (P : Z -> Prop) (m : Z),\n  (forall n, n <= m -> P n) ->\n  (forall n, m <= n -> P n -> P (Z.succ n)) ->\n  forall n, P n.\nProof. intros. destruct (Z_le_gt_dec n m).\n       - exact (H _ l).\n       - Search (_ <= _ -> _ <= _).\n         apply Zlt_lower_bound_ind with (z := m).\n         intros. destruct (Zeq_dec m x). rewrite <- e. apply H. lia.\n         rewrite Zsucc_pred. apply H0. lia. apply H1. lia. lia. Qed.\n\nClose Scope Z.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33258,"user_id":null,"body":"From Coq Require Import ZArith.\n\nRequire Import Lia.\n\nOpen Scope Z.\n\nTheorem int_induction : forall (P : Z -> Prop) (m : Z),\n  (forall n, n <= m -> P n) ->\n  (forall n, m <= n -> P n -> P (Z.succ n)) ->\n  forall n, P n.\nProof.\n  intros.\n  remember (n - m) as k.\n  destruct k; try discriminate; try (apply H; lia; fail).\n  assert (n = (m + Z.pos p)) by lia.\n  remember (Z.to_nat (Z.pos p)) as p'.\n  simpl in *.\n  assert (n = m + Z.of_nat p') by lia.\n  clear Heqk. clear H1. clear Heqp'. clear p.\n  subst.\n  induction p'.\n  - intros. apply H. lia.\n  - replace (m + Z.of_nat (S p')) with (Z.succ (m + Z.of_nat p')) by lia.\n    apply H0; try lia. assumption.\nQed.\n\nClose Scope Z.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33259,"user_id":null,"body":"From Coq Require Import ZArith.\n\nOpen Scope Z.\n\nDefinition diff_eq_gt : Eq = Gt -> False := \n  fun H : Eq = Gt => \n    let H0 : False := \n    eq_ind Eq (fun e : comparison => \n      match e with\n        | Eq => True\n        | Lt => False\n        | Gt => False\n      end\n    ) I Gt H in False_ind False H0.\n\nDefinition diff_lt_gt : Lt = Gt -> False := \n  fun H : Lt = Gt => \n    let H0 : False := \n    eq_ind Lt (fun e : comparison => \n      match e with\n        | Eq => False\n        | Lt => True\n        | Gt => False\n      end\n    ) I Gt H in False_ind False H0.\n\nTheorem int_induction : forall (P : Z -> Prop) (m : Z),\n  (forall n, n <= m -> P n) ->\n  (forall n, m <= n -> P n -> P (Z.succ n)) ->\n  forall n, P n.\nProof.\n\nintros P m Hm Hrec n.\napply (Zcompare_rect (P n) n m).\n\nintro.\napply Hm.\nrewrite <-Z.compare_le_iff.\nrewrite H.\nunfold not.\nintro.\napply (diff_eq_gt H0).\n\nintros.\napply Hm.\nrewrite <-Z.compare_le_iff.\nrewrite H.\nunfold not.\nintro.\napply (diff_lt_gt H0).\n\nintros.\n\nPrint natlike_ind.\nreplace n with (n - m + m).\napply (natlike_ind (fun n0 : Z => P (n0 + m))).\napply Hm.\nrewrite Z.add_0_l.\nreflexivity.\n\nintro.\nintro.\nintros.\nrewrite Z.add_succ_l.\napply Hrec.\nrewrite <-Z.compare_le_iff.\nrewrite <-(Z.add_compare_mono_l (-m) m (x+m)).\nrewrite Z.compare_le_iff.\nrewrite (Z.add_comm x m).\nrewrite <-Zplus_assoc_reverse.\nrewrite Z.add_opp_diag_l.\nrewrite Z.add_0_l.\nexact H0.\nexact H1.\nrewrite Z.compare_gt_iff in H.\nrewrite <-Z.compare_le_iff.\nrewrite Z.compare_antisym.\nrewrite <-Z.compare_sub.\nrewrite <-Z.compare_antisym.\nrewrite <-Z.compare_lt_iff in H.\nrewrite H.\nunfold not.\nintro.\napply diff_lt_gt.\nexact H0.\nrewrite Z.add_comm.\nrewrite Zplus_minus.\nreflexivity.\nQed.\n\nClose Scope Z.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33260,"user_id":null,"body":"From Coq Require Import ZArith.\n\nOpen Scope Z.\n\nTheorem int_induction : forall (P : Z -> Prop) (m : Z),\n  (forall n, n <= m -> P n) ->\n  (forall n, m <= n -> P n -> P (Z.succ n)) ->\n  forall n, P n.\nProof.\n  intros P m H0 H1 n.\n  pose proof (Z.le_ge_cases n m) as [H|H]; auto.\n  pose proof (Z.le_exists_sub m n H) as [p [H2 H3]].\n  subst.\n  assert (H4: P (0 + m)) by (apply H0; omega).\n  assert (Q: forall q, 0 <= q -> P (q + m)).\n  { apply (natlike_ind _ H4).\n    intros x G Hp.\n    rewrite Z.add_succ_l.\n    apply H1; auto. omega. }\n  now apply Q.\nQed.    \n\nClose Scope Z.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33261,"user_id":null,"body":"From Coq Require Import ZArith.\n\nOpen Scope Z.\n\nLemma int_induction' : forall (P : Z -> Prop),\n  (forall n, P n -> P (Z.succ n)) ->\n  (forall n m, P n -> P (n + Z.of_nat m)).\nProof.\n  intros; induction m.\n  - simpl; rewrite Z.add_0_r; exact H0.\n  - rewrite Nat2Z.inj_succ, Z.add_succ_r; exact (H _ IHm).\nQed.\n\nLemma Z_diff : forall (n m : Z),\n  n <= m -> exists k, n + Z.of_nat k = m.\nProof.\n  intros; exists (Z.to_nat (m - n));\n  rewrite (Z2Nat.id _ (Zle_minus_le_0 _ _ H)), Zplus_minus; reflexivity.\nQed.\n\nTheorem int_induction : forall (P : Z -> Prop) (m : Z),\n  (forall n, n <= m -> P n) ->\n  (forall n, m <= n -> P n -> P (Z.succ n)) ->\n  forall n, P n.\nProof.\n  intros; destruct (Z.le_ge_cases m n).\n  - destruct (Z_diff _ _ H1); rewrite <- H2.\n    refine (int_induction' _ _ _ _ _).\n    + intros; destruct (Z.lt_ge_cases m (Z.succ n0)).\n      * exact (H0 _ (Zlt_succ_le _ _ H4) H3).\n      * exact (H _ H4).\n    + refine (H _ _); reflexivity.\n  - exact (H _ H1).\nQed.\n\nClose Scope Z.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5eb8aefefaa14a0001c915e8":[{"id":33262,"user_id":17,"body":"From Coq Require Import ssr.ssrfun.\n\nLemma left : forall {A} f g,\n  involutive f ->\n  cancel f g ->\n  forall x : A, f x = g x.\nProof. congruence. Qed.\n\nLemma right : forall {A} f g,\n  involutive f ->\n  cancel g f ->\n  forall x : A, f x = g x.\nProof. congruence. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33263,"user_id":null,"body":"From Coq Require Import ssr.ssrfun.\n\nLemma left : forall {A} f g,\n  involutive f ->\n  cancel f g ->\n  forall x : A, f x = g x.\nProof. intros; rewrite <- (H x), H0, H; reflexivity. Qed.\n\nLemma right : forall {A} f g,\n  involutive f ->\n  cancel g f ->\n  forall x : A, f x = g x.\nProof. intros; rewrite <- (H (g x)), H0; reflexivity. Qed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33264,"user_id":null,"body":"From Coq Require Import ssr.ssrfun.\nFrom mathcomp Require Import all_ssreflect.\n\n(* Print cancel. *)\n(* Print involutive. *)\n\nLemma left : forall {A} f g,\n  involutive f ->\n  cancel f g ->\n  forall x : A, f x = g x.\nProof.\n  intros.\n  rewrite -[X in g X]H.\n  rewrite H0.\n  done.\nQed.\n\nLemma right : forall {A} f g,\n  involutive f ->\n  cancel g f ->\n  forall x : A, f x = g x.\nProof.\n  intros.\n  rewrite -[X in f X]H0.\n  rewrite H.\n  done.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33265,"user_id":null,"body":"From Coq Require Import ssr.ssrfun.\n\nLemma left : forall {A} f g,\n  involutive f ->\n  cancel f g ->\n  forall x : A, f x = g x.\nProof.\n  intros. unfold involutive, cancel in *.\n  replace (g x) with (g (f (f x))).\n  - rewrite H0. auto.\n  - rewrite H. auto.\nQed.\n\nLemma right : forall {A} f g,\n  involutive f ->\n  cancel g f ->\n  forall x : A, f x = g x.\nProof.\n  intros. unfold involutive, cancel in *.\n  replace (f x) with (f (f (g x))).\n  - rewrite H. auto.\n  - rewrite H0. auto.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33266,"user_id":null,"body":"From Coq Require Import ssr.ssrfun.\n\nLemma left : forall {A} f g,\n  involutive f ->\n  cancel f g ->\n  forall x : A, f x = g x.\nProof.\n  intros A f g Hinv Hcan x.\n  unfold involutive in Hinv.\n  unfold cancel in *.\n  assert (Hgff: g x = g (f (f x))) by now rewrite Hinv.\n  rewrite Hgff.\n  now rewrite Hcan.\nQed.\n\nLemma right : forall {A} f g,\n  involutive f ->\n  cancel g f ->\n  forall x : A, f x = g x.\nProof.\n  intros A f g Hinv Hcan y.\n  unfold involutive in Hinv.\n  unfold cancel in *.\n  assert (H : g y = f (f (g y))) by now rewrite Hinv.\n  rewrite H.\n  now rewrite Hcan.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33267,"user_id":null,"body":"From Coq Require Import ssr.ssrfun.\n\nLemma left : forall {A} f g,\n  involutive f ->\n  cancel f g ->\n  forall x : A, f x = g x.\nProof.\n  intros.\n  replace x with (f (f x)).\n  rewrite H0.\n  rewrite H.\n  auto.\n  rewrite H.\n  auto.\nQed.\n\nLemma right : forall {A} f g,\n  involutive f ->\n  cancel g f ->\n  forall x : A, f x = g x.\nProof.\n  intros.\n  replace x with (f (g x)).\n  rewrite H.\n  rewrite H0.\n  auto.\n  rewrite H0.\n  auto.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33268,"user_id":null,"body":"From Coq Require Import ssr.ssrfun.\n\nLemma left : forall {A} f g,\n  involutive f ->\n  cancel f g ->\n  forall x : A, f x = g x.\nProof.\n  intros A f g finv fgcan x.\n  now rewrite <- (fgcan (f x)), finv.\nQed.\n\nLemma right : forall {A} f g,\n  involutive f ->\n  cancel g f ->\n  forall x : A, f x = g x.\nProof.\n  intros A f g finv gfcan x.\n  now rewrite <- finv, gfcan.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33269,"user_id":null,"body":"From Coq Require Import ssr.ssrfun.\n\nLemma left : forall {A} f g,\n    involutive f ->\n    cancel f g ->\n    forall x : A, f x = g x.\nProof.\n  intros A f g H0 H1 x.\n  replace (g x) with (g (f (f x))).\n  { rewrite H1; reflexivity. }\n  rewrite H0; reflexivity.\nQed.\n\nLemma right : forall {A} f g,\n    involutive f ->\n    cancel g f ->\n    forall x : A, f x = g x.\nProof.\n  intros A f g H0 H1 x.\n  unfold involutive in H0.\n  unfold cancel in *.\n  rewrite <- H0, H1; reflexivity.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33270,"user_id":null,"body":"From Coq Require Import ssr.ssrfun.\n\nLemma left : forall {A} f g,\n  involutive f ->\n  cancel f g ->\n  forall x : A, f x = g x.\nProof.\n  unfold involutive.\n  unfold cancel.\n  intros.\n  assert (f x = f (f (f x))).\n  rewrite H.\n  reflexivity.\n  assert (g x = g (f (f x))).\n  rewrite H.\n  reflexivity.\n  assert (forall x, g (f x) = f (f x)).\n  intros.\n  rewrite H.\n  rewrite H0.\n  reflexivity.\n  rewrite H1.\n  rewrite H2.\n  rewrite H3.\n  reflexivity.\nQed.  \n\n  \nLemma right : forall {A} f g,\n  involutive f ->\n  cancel g f ->\n  forall x : A, f x = g x.\nProof.\n  unfold involutive.\n  unfold cancel.\n  intros.\n  assert (f x = f (f (f x))).\n  rewrite H.\n  reflexivity.\n  assert (g x = f (f (g x))).\n  rewrite H.\n  reflexivity.\n  assert (forall x, f (g x) = f (f x)).\n  intros.\n  rewrite H.\n  rewrite H0.\n  reflexivity.\n  rewrite H1.\n  rewrite H2.\n  rewrite H3.\n  reflexivity.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33271,"user_id":null,"body":"From Coq Require Import ssr.ssrfun.\n\nLemma left : forall {A} f g,\n  involutive f ->\n  cancel f g ->\n  forall x : A, f x = g x.\nProof.\n  intros A f g invF cancFG x.\n  replace (g x) with (g (f (f x))).\n  symmetry. apply cancFG.\n  congruence.\nQed.\n\nLemma right : forall {A} f g,\n  involutive f ->\n  cancel g f ->\n  forall x : A, f x = g x.\nProof.\n  intros A f g invF cancGF x.\n  replace (g x) with (f (f (g x))) by apply invF.\n  rewrite cancGF.\n  reflexivity.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5eec40dfe5d13e0001234d01":[{"id":33272,"user_id":null,"body":"Require Import Preloaded.\n\nFrom Coq Require Import List Ascii.\nImport ListNotations.\nRequire Import Lia.\n\nLocal Open Scope char_scope.\n\nTheorem leftpad_length : forall c n s,\n  length (leftpad c n s) = max n (length s).\nProof.\n  intros.\n  unfold leftpad.\n  rewrite app_length.\n  rewrite repeat_length.\n  lia.\nQed.\n\n\nTheorem leftpad_prefix : forall c n s,\n  Forall (fun p => p = c) (firstn (n - length s) (leftpad c n s)).\nProof.\n  intros.\n  unfold leftpad.\n  generalize (n - length s).\n  intros.\n  induction n0; constructor; auto.\nQed.\n\n\nTheorem leftpad_suffix: forall c n s,\n  skipn (n - length s) (leftpad c n s) = s.\nProof.\n  intros.\n  unfold leftpad.\n  rewrite skipn_app.\n  rewrite repeat_length.\n  replace (n - length s) with (length (repeat c (n - length s))) at 1.\n    rewrite skipn_all. simpl.\n    replace (n - length s - (n - length s)) with 0. auto. lia.\n  apply repeat_length.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33273,"user_id":null,"body":"Require Import Preloaded.\n\nFrom Coq Require Import List Ascii.\nImport ListNotations.\n\nLocal Open Scope char_scope.\n\nRequire Import Lia.\n\nTheorem leftpad_length : forall c n s,\n  length (leftpad c n s) = max n (length s).\nProof.\n  intros. unfold leftpad.\n  rewrite app_length. rewrite repeat_length.\n  remember (n - length s) as m.\n  destruct m; lia.\nQed.\n\nTheorem leftpad_prefix : forall c n s,\n  Forall (fun p => p = c) (firstn (n - length s) (leftpad c n s)).\nProof.\n  intros. unfold leftpad.\n  assert (forall (c : ascii) m s, firstn m (repeat c m ++ s) = repeat c m).\n  - intros. induction m.\n    + simpl. auto.\n    + simpl. rewrite IHm. auto.\n  - rewrite H.\n    induction (n - length s).\n    + simpl. auto.\n    + simpl. apply Forall_cons; auto.\nQed.\n\nTheorem leftpad_suffix: forall c n s,\n  skipn (n - length s) (leftpad c n s) = s.\nProof.\n  intros. unfold leftpad.\n  induction (n - length s); simpl; auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33274,"user_id":null,"body":"Require Import Preloaded.\n\nFrom Coq Require Import List Ascii ssreflect.\nImport ListNotations PeanoNat.Nat.\n\nLocal Open Scope char_scope.\n\nTheorem leftpad_length : forall c n s,\n  length (leftpad c n s) = max n (length s).\nProof.\n  move=> c n s.\n  rewrite app_length repeat_length.\n  case: (le_gt_cases (length s) n) => [lelenn|\/lt_le_incl lenlen].\n    by rewrite sub_add \/\/ max_l.\n  have := lenlen; rewrite -sub_0_le => ->.\n  by rewrite max_r.\nQed.\n\nTheorem leftpad_prefix : forall c n s,\n  Forall (fun p => p = c) (firstn (n - length s) (leftpad c n s)).\nProof.\n  move=> c n s.\n  rewrite firstn_app repeat_length sub_diag \/=.\n  rewrite -{1}(repeat_length c (n - length s)) firstn_all app_nil_r.\n  elim: (n - length s) => [\/\/=|m IHm \/=].\n  by apply: Forall_cons.\nQed.\n\nTheorem leftpad_suffix: forall c n s,\n  skipn (n - length s) (leftpad c n s) = s.\nProof.\n  move=> c n s.\n  rewrite skipn_app repeat_length sub_diag \/=.\n  by rewrite -{1}(repeat_length c (n - length s)) skipn_all.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33275,"user_id":191,"body":"Require Import Preloaded.\n\nFrom Coq Require Import List Ascii.\nRequire Import Lia.\nImport ListNotations.\n\nLocal Open Scope char_scope.\n\nLemma sub_zero : forall T (n : nat) (s : list T),\nn - length s - (n - length s) = 0.\nProof.\nintros.\nlia.\nQed.\n\nTheorem leftpad_length : forall c n s,\n  length (leftpad c n s) = max n (length s).\nProof.\nintros.\nunfold leftpad.\nrewrite app_length.\nrewrite repeat_length.\nlia.\nQed.\n\nTheorem leftpad_prefix : forall c n s,\n  Forall (fun p => p = c) (firstn (n - length s) (leftpad c n s)).\nProof.\nintros.\nunfold leftpad.\nrewrite firstn_app.\nrewrite repeat_length.\nrewrite sub_zero.\nsimpl.\nrewrite app_nil_r.\nrewrite firstn_all2.\n* induction (n - length s);\n  simpl;\n  auto.\n* rewrite repeat_length.\n  reflexivity.\nQed.\n\nTheorem leftpad_suffix: forall c n s,\n  skipn (n - length s) (leftpad c n s) = s.\nProof.\nintros.\nunfold leftpad.\nrewrite skipn_app.\nrewrite repeat_length.\nrewrite sub_zero.\nsimpl.\nrewrite skipn_all2.\n* auto.\n* rewrite repeat_length.\n  reflexivity.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33276,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Lia.\nFrom Coq Require Import List Ascii.\nImport ListNotations.\n\nLocal Open Scope char_scope.\n\nTheorem leftpad_length : forall c n s,\n  length (leftpad c n s) = max n (length s).\nProof.\n  intros.\n  unfold leftpad.\n  rewrite app_length, repeat_length.\n  lia.\nQed.\n\nTheorem leftpad_prefix : forall c n s,\n  Forall (fun p => p = c) (firstn (n - length s) (leftpad c n s)).\nProof.\n  intros.\n  unfold leftpad.\n  rewrite firstn_app, repeat_length, PeanoNat.Nat.sub_diag, firstn_O, app_nil_r.\n  rewrite firstn_all2.\n  2:{\n    rewrite repeat_length. auto.\n  }\n  apply Forall_forall.\n  intros.\n  apply (repeat_spec (n - length s)).\n  assumption.\nQed.\n\nTheorem leftpad_suffix: forall c n s,\n  skipn (n - length s) (leftpad c n s) = s.\nProof.\n  intros.\n  unfold leftpad.\n  rewrite skipn_app, repeat_length, PeanoNat.Nat.sub_diag, skipn_O.\n  rewrite skipn_all2.\n  auto.\n  rewrite repeat_length.\n  auto.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33277,"user_id":null,"body":"Require Import Preloaded.\n\nFrom Coq Require Import List Ascii Lia.\nImport ListNotations.\n\nLocal Open Scope char_scope.\n\nTheorem leftpad_length : forall c n s,\n  length (leftpad c n s) = max n (length s).\nProof.\n  unfold leftpad.\n  intros.\n  rewrite app_length.\n  rewrite repeat_length.\n  lia.\nQed.\n\nTheorem leftpad_prefix : forall c n s,\n  Forall (fun p => p = c) (firstn (n - length s) (leftpad c n s)).\nProof.\n  unfold leftpad.\n  intros.\n  remember (n - length s) as m.\n  generalize dependent s.\n  generalize dependent n.\n  induction m.\n  - constructor.\n  - simpl.\n    constructor. auto.\n    apply IHm with (pred n).\n    lia.\nQed.\n\nTheorem leftpad_suffix: forall c n s,\n  skipn (n - length s) (leftpad c n s) = s.\nProof.\n  unfold leftpad.\n  intros.\n  remember (n - length s) as m.\n  rewrite skipn_app.\n  rewrite repeat_length.\n  replace (m - m) with 0 by lia.\n  rewrite skipn_O.\n  rewrite skipn_all2. auto.\n  rewrite repeat_length. auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33278,"user_id":null,"body":"Require Import Preloaded.\n\nFrom Coq Require Import List Ascii PeanoNat.\nImport ListNotations.\n\nLocal Open Scope char_scope.\n\nLocate Nat.succ_max_distr.\nLemma max_as_sub_add : forall a b, max a b = a - b + b.\nProof with auto.\n  induction a...\n  destruct b...\n  rewrite <- Nat.succ_max_distr, IHa.\n  apply plus_n_Sm.\nQed.\n\nTheorem leftpad_length : forall c n s,\n  length (leftpad c n s) = max n (length s).\nProof.\n  intros.\n  unfold leftpad.\n  rewrite app_length, repeat_length, max_as_sub_add.\n  auto.\nQed.\n\nTheorem leftpad_prefix : forall c n s,\n  Forall (fun p => p = c) (firstn (n - length s) (leftpad c n s)).\nProof with auto.\n  intros.\n  apply Forall_forall.\n  intros.\n  replace (firstn (n - length s) (leftpad c n s)) with (repeat c (n - length s)) in H.\n  apply (repeat_spec _ _ _ H).\n  unfold leftpad.\n  rewrite firstn_app, repeat_length, Nat.sub_diag, firstn_O, app_nil_r, firstn_all2...\n  rewrite repeat_length...\nQed.\n\nTheorem leftpad_suffix: forall c n s,\n  skipn (n - length s) (leftpad c n s) = s.\nProof with auto.\n  intros.\n   unfold leftpad.\n   rewrite skipn_app, repeat_length, Nat.sub_diag, skipn_O, skipn_all2...\n   rewrite repeat_length...\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33279,"user_id":null,"body":"Require Import Preloaded.\n\nFrom Coq Require Import List Ascii PeanoNat.\nImport ListNotations.\n\nLocal Open Scope char_scope.\n\nLemma max_as_sub_add : forall a b, max a b = a - b + b.\nProof with auto.\n  induction a...\n  destruct b...\n  rewrite <- Nat.succ_max_distr, IHa.\n  apply plus_n_Sm.\nQed.\n\nTheorem leftpad_length : forall c n s,\n  length (leftpad c n s) = max n (length s).\nProof.\n  intros.\n  unfold leftpad.\n  rewrite app_length, repeat_length, max_as_sub_add.\n  auto.\nQed.\n\nTheorem leftpad_prefix : forall c n s,\n  Forall (fun p => p = c) (firstn (n - length s) (leftpad c n s)).\nProof with auto.\n  intros.\n  apply Forall_forall.\n  intros.\n  assert (firstn (n - length s) (leftpad c n s) = repeat c (n - length s)).\n  {\n    unfold leftpad.\n    rewrite firstn_app, repeat_length, Nat.sub_diag, firstn_O, app_nil_r, firstn_all2...\n    rewrite repeat_length...\n  }\n  rewrite H0 in H.\n  apply (repeat_spec _ _ _ H).\nQed.\n\nTheorem leftpad_suffix: forall c n s,\n  skipn (n - length s) (leftpad c n s) = s.\nProof with auto.\n  intros.\n   unfold leftpad.\n   rewrite skipn_app, repeat_length, Nat.sub_diag, skipn_O, skipn_all2...\n   rewrite repeat_length...\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33280,"user_id":null,"body":"Require Import Preloaded.\n\nFrom Coq Require Import List Ascii Arith.PeanoNat.\nImport ListNotations.\n\nLocal Open Scope char_scope.\n\nLemma max_is_add_sub : forall a b, max a b = a - b + b.\ninduction a. \n- cbn. auto.\n- cbn.\n  destruct b eqn:BB.\n  auto.\n  rewrite IHa. \n  apply plus_n_Sm.\nQed.\n\nTheorem leftpad_length : forall c n s,\n  length (leftpad c n s) = max n (length s).\nProof.\n  intros.\n  unfold leftpad.\n  rewrite app_length.\n  rewrite repeat_length.\n  rewrite max_is_add_sub.\n  auto.\nQed.\n\nTheorem leftpad_prefix : forall c n s,\n  Forall (fun p => p = c) (firstn (n - length s) (leftpad c n s)).\nProof.\n  intros.\n  apply Forall_forall.\n  intros.\n  assert (firstn (n - length s) (leftpad c n s) = repeat c (n - length s)).\n  {\n    unfold leftpad.\n    rewrite firstn_app.\n    rewrite repeat_length.\n    rewrite Nat.sub_diag.\n    rewrite firstn_O. \n    rewrite app_nil_r.\n    rewrite firstn_all2. auto.\n    rewrite repeat_length. auto.\n  }\n  rewrite H0 in H.\n  apply repeat_spec in H. auto.\nQed.\n\nTheorem leftpad_suffix: forall c n s,\n  skipn (n - length s) (leftpad c n s) = s.\nProof. \n  intros.\n   unfold leftpad.\n   rewrite skipn_app.\n   rewrite repeat_length, Nat.sub_diag, skipn_O.\n   rewrite skipn_all2. auto.\n   rewrite repeat_length. auto.\nQed.\n   ","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33281,"user_id":null,"body":"From Coq Require Import List Ascii.\nRequire Import Lia.\nImport ListNotations.\n\nLocal Open Scope char_scope.\n\nDefinition leftpad (c : ascii) (n : nat) (s : list ascii) :=\n  repeat c (n - length s) ++ s.\n\nTheorem leftpad_length : forall c n s,\n  length (leftpad c n s) = max n (length s).\nProof.\n    intro c; intro n; intro s.\n    assert ((n <= length s) \\\/ n > length s).\n    lia.\n    case H.\n    all : intro H0.\n    unfold leftpad.\n    assert (n - length s = 0).\n    lia.\n    rewrite H1.\n    simpl.\n    rewrite PeanoNat.Nat.max_r.\n    all : trivial.\n\n    unfold leftpad.\n    rewrite PeanoNat.Nat.max_l.\n    2 : lia.\n    \n    rewrite app_length.\n    rewrite repeat_length.\n    lia.\nQed.\n\nLemma lemma0 :\n    forall n : nat, forall c: ascii, forall s : list ascii,\n    (firstn n (repeat c n ++ s) = repeat c n).\nProof.\n    intro n.\n    induction n.\n    simpl.\n    reflexivity.\n    simpl.\n    intro c; intro s.\n    rewrite (IHn ).\n    reflexivity.\nQed.\n\nTheorem leftpad_prefix : forall c n s,\n  Forall (fun p => p = c) (firstn (n - length s) (leftpad c n s)).\nProof. \n    intro c; intro n; intro s.\n    unfold leftpad.\n    rewrite lemma0.\n    pose (n1 := n - length s).\n    fold n1.\n    induction n1.\n    simpl.\n    apply Forall_nil.\n    simpl.\n    apply Forall_cons.\n    all : trivial.\nQed.\n\nTheorem leftpad_suffix: forall c n s,\n  skipn (n - length s) (leftpad c n s) = s.\nProof.\n    intro c; intro n; intro s.\n    unfold leftpad.\n    pose (n0 := n - length s).\n    fold n0.\n    induction n0.\n    all : simpl.\n    all : trivial.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5eec4c435d804f000136a287":[{"id":33282,"user_id":null,"body":"Require Import Preloaded.\n\nFrom Coq Require Import List Arith.\nImport ListNotations.\n\nTheorem list_unique_bidir : forall x xs,\n  In x xs <-> In x (list_unique xs).\nProof.\n  split.\n  - induction xs.\n    + simpl. auto.\n    + simpl. intros. destruct H.\n      * rewrite <- H.\n        destruct (in_dec Nat.eq_dec a (list_unique xs)); simpl; auto.\n      * destruct (in_dec Nat.eq_dec a (list_unique xs)); simpl; auto.\n  - induction xs.\n    + simpl. auto.\n    + simpl. intros. destruct (in_dec Nat.eq_dec a (list_unique xs)).\n      * apply IHxs in H. auto.\n      * destruct H.\n        -- auto.\n        -- apply IHxs in H. auto.\nQed.\n\nTheorem list_unique_NoDup : forall xs,\n  NoDup (list_unique xs).\nProof.\n  intros. induction xs.\n  - simpl. constructor.\n  - simpl. destruct (in_dec Nat.eq_dec a (list_unique xs)).\n    + auto.\n    + constructor; auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33283,"user_id":null,"body":"Require Import Preloaded.\n\nFrom Coq Require Import List Arith.\nImport ListNotations.\n\nTheorem list_unique_bidir : forall x xs,\n  In x xs <-> In x (list_unique xs).\nProof.\n  intros.\n  induction xs as [|y ys hys].\n  + simpl. intuition.\n  + split.\n    - intro hxy. simpl in hxy. destruct hxy as [hxy | hxy].\n      * rewrite <- hxy in *. simpl. destruct (in_dec Nat.eq_dec y (list_unique ys)).\n        assumption. intuition.\n      * simpl. destruct (in_dec Nat.eq_dec y (list_unique ys)).\n        apply hys. assumption. simpl. right. apply hys. assumption.\n    - intro hxy. simpl in *. destruct (in_dec Nat.eq_dec y (list_unique ys)).\n      * right. apply hys. assumption.\n      * simpl in hxy. intuition.\nQed. \n\nTheorem list_unique_NoDup : forall xs,\n  NoDup (list_unique xs).\nProof.\n  intros.\n  induction xs as [|x xs hxs].\n  + constructor.\n  + simpl. destruct (in_dec Nat.eq_dec x (list_unique xs)); intuition.\n    constructor; assumption.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33284,"user_id":null,"body":"Require Import Preloaded.\n\nFrom Coq Require Import List Arith.\nImport ListNotations.\n\nTheorem list_unique_bidir : forall x xs,\n  In x xs <-> In x (list_unique xs).\nProof. \n  intros x xs.\n  split.\n  {\n    intros h.\n    induction xs as [|a xs hxs].\n    contradiction.\n    simpl.\n    induction (in_dec Nat.eq_dec a (list_unique xs)).\n    + simpl in h. destruct h as [h|h]. \n     - rewrite <- h. assumption.\n     - apply hxs. assumption.\n    + simpl in h |- *. destruct h as [h|h].\n     - left. assumption.\n     - right. apply hxs. assumption.     \n  }\n  {\n    intros h.\n    induction xs as [|a xs hxs].\n    simpl in h. contradiction.\n    simpl in h |- *.  \n    induction (in_dec Nat.eq_dec a (list_unique xs)).\n    + right. apply hxs. assumption.\n    + simpl in h. destruct h as [h|h].\n      - left. assumption.\n      - right. apply hxs. assumption.    \n  }\nQed.\n\nTheorem list_unique_NoDup : forall xs,\n  NoDup (list_unique xs).\nProof.\n  intros xs.\n  induction xs as [|a l hl].\n  simpl. apply NoDup_nil.\n  simpl.\n  induction (in_dec Nat.eq_dec a (list_unique l)).\n  assumption.\n  apply NoDup_cons; assumption.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33285,"user_id":null,"body":"Require Import Preloaded.\n\nFrom Coq Require Import List Arith.\nImport ListNotations.\n\nLtac dec a xs := simpl; destruct (in_dec Nat.eq_dec a (list_unique xs)).\n\nTheorem list_unique_bidir : forall x xs,\n  In x xs <-> In x (list_unique xs).\nProof with auto. \n  split.\n  - induction xs...\n    intros [|]; dec a xs; subst...\n    + left...\n    + right...\n  - induction xs...\n    dec a xs...\n    intros [|]...\nQed.\n\nTheorem list_unique_NoDup : forall xs,\n  NoDup (list_unique xs).\nProof with auto.\n  induction xs. constructor.\n  dec a xs...\n  constructor...\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33286,"user_id":null,"body":"Require Import Preloaded.\n\nFrom Coq Require Import List Arith.\nImport ListNotations.\n\nTheorem list_unique_bidir : forall x xs,\n  In x xs <-> In x (list_unique xs).\nProof. \n  induction xs.\n  - cbn. tauto.\n  - cbn. split; intros.\n    + inversion H; cbn; destruct (in_dec Nat.eq_dec a (list_unique xs));cbn;subst;tauto.\n    + destruct (in_dec Nat.eq_dec a (list_unique xs) ); [ | inversion H]; tauto.\nQed.  \n\nTheorem list_unique_NoDup : forall xs,\n  NoDup (list_unique xs).\nProof. \n  induction xs.\n  - cbn. constructor.\n  - cbn. destruct (in_dec Nat.eq_dec a (list_unique xs)). auto. constructor; auto.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33287,"user_id":null,"body":"Require Import Preloaded.\n\nFrom Coq Require Import List Arith.\nImport ListNotations.\n\nTheorem list_unique_bidir : forall x xs,\n    In x xs <-> In x (list_unique xs).\nProof.\n  intros until xs. generalize dependent x.\n  induction xs; split; intros; simpl in *; auto.\n  - destruct (in_dec Nat.eq_dec a (list_unique xs)).\n    + intuition; subst; try assumption.\n      rewrite <- IHxs.\n      assumption.\n    + intuition; subst; eauto with datatypes.\n      simpl.\n      rewrite <- IHxs.\n      intuition assumption.\n  - destruct (in_dec Nat.eq_dec a (list_unique xs)).\n    + right.\n      rewrite IHxs.\n      assumption.\n    + simpl in *.\n      intuition.\n      right.\n      rewrite IHxs.\n      assumption.\nQed.\n\nTheorem list_unique_NoDup : forall xs,\n  NoDup (list_unique xs).\nProof.\n  induction xs; try constructor.\n  simpl in *.\n  destruct (in_dec Nat.eq_dec a (list_unique xs)); try assumption.\n  constructor; assumption.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33288,"user_id":null,"body":"Require Import Preloaded.\n\nFrom Coq Require Import List Arith.\nImport ListNotations.\n\nTheorem list_unique_bidir : forall x xs,\n  In x xs <-> In x (list_unique xs).\nProof.\n  split; revert x; induction xs; intros.\n  - easy.\n  - simpl; destruct (in_dec Nat.eq_dec a (list_unique xs)).\n    + destruct H; [rewrite <- H|apply IHxs]; easy.\n    + destruct H; [rewrite H; left|right; apply IHxs]; easy.\n  - easy.\n  - simpl in H; destruct (in_dec Nat.eq_dec a (list_unique xs)).\n    + right; now apply IHxs.\n    + destruct H; [left|right; apply IHxs]; easy.\nQed.\n\nTheorem list_unique_NoDup : forall xs,\n  NoDup (list_unique xs).\nProof.\n  induction xs.\n  - constructor.\n  - simpl; destruct (in_dec Nat.eq_dec a (list_unique xs)); [|constructor]; easy.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33289,"user_id":106,"body":"Require Import Preloaded.\n\nFrom Coq Require Import List Arith.\nImport ListNotations.\nRequire Import Lia.\n\nTheorem list_unique_bidir : forall x xs,\n  In x xs <-> In x (list_unique xs).\nProof.\n  intros. split; intros; generalize dependent x; induction xs; auto; intros; simpl in *.\n  - destruct H, (in_dec Nat.eq_dec a (list_unique xs)); subst; intuition.\n  - destruct (in_dec Nat.eq_dec a (list_unique xs)).\n    + intuition.\n    + inversion H; subst; intuition.\nQed.\n\nTheorem list_unique_NoDup : forall xs,\n  NoDup (list_unique xs).\nProof.\n  intros. induction xs.\n  - constructor.\n  - simpl. destruct (in_dec Nat.eq_dec a (list_unique xs)); intuition.\n    now constructor.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33290,"user_id":null,"body":"Require Import Preloaded.\n\nFrom Coq Require Import List Arith.\nImport ListNotations.\n\nTheorem list_unique_bidir : forall x xs,\n  In x xs <-> In x (list_unique xs).\nProof.\n  split; intros.\n  - induction xs; [case H|].\n    destruct H; simpl; destruct (in_dec Nat.eq_dec a (list_unique xs)).\n    + rewrite <- H; assumption.\n    + left; assumption.\n    + apply IHxs; assumption.\n    + right; apply IHxs; assumption.\n  - induction xs; [case H|].\n    simpl in H; destruct (in_dec Nat.eq_dec a (list_unique xs)).\n    + right; apply IHxs; assumption.\n    + destruct H; [left|right; apply IHxs]; assumption.\nQed.\n\nTheorem list_unique_NoDup : forall xs,\n  NoDup (list_unique xs).\nProof.\n  induction xs; [constructor|].\n  simpl; destruct (in_dec Nat.eq_dec a (list_unique xs));\n  [|constructor]; assumption.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33291,"user_id":null,"body":"Require Import Preloaded.\n\nFrom Coq Require Import List Arith.\nImport ListNotations.\n\n\nTheorem list_unique_bidir : forall x xs,\n  In x xs <-> In x (list_unique xs).\nProof.\n  intro x.\n  intro l.\n  split.\n  induction l.\n  compute; trivial.\n  simpl.\n  intro H.\n  case H.\n  intro aEqx.\n  rewrite aEqx.\n  case (in_dec Nat.eq_dec x (list_unique l)); trivial.\n  intro H1.\n  simpl; left; trivial.\n  intro x_is_in_l.\n  case (in_dec Nat.eq_dec a (list_unique l)).\n  intro H1.\n  apply IHl; trivial.\n  intro H1.\n  simpl; right; apply IHl; trivial.\n\n  induction l.\n  compute; trivial.\n  simpl.\n  case (in_dec Nat.eq_dec a (list_unique l)).\n  intros _.\n  intro Hx; right; apply IHl; trivial.\n  intros _.\n  simpl.\n  intro H; case H.\n  intro H'; left; trivial.\n  intro H'; right; apply IHl; trivial.\nQed.\n\nTheorem list_unique_NoDup : forall xs,\n  NoDup (list_unique xs).\nProof.\n  intro l.\n  induction l.\n  simpl; exact (NoDup_nil nat).\n  simpl; case (in_dec Nat.eq_dec a (list_unique l)).\n  intros _; trivial.\n  intro a_is_not_in_l.\n  constructor 2; trivial.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5f22c23ba72c3b000162a352":[{"id":33292,"user_id":null,"body":"Require Import Nat.\n\nTheorem exists_unique_le : exists! n m : nat, m <= n.\nProof.\n  exists 0. split.\n  - exists 0. hnf; intuition. inversion H; reflexivity.\n  - intros. destruct H as [m [_ H]]. destruct x'.\n    + reflexivity.\n    + assert (0 <= S x') by (apply le_0_n).\n      assert (1 <= S x') by (apply le_n_S; apply le_0_n).\n      apply H in H0. apply H in H1. congruence.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33293,"user_id":null,"body":"Require Import Lia.\nTheorem exists_unique_le : exists! n m : nat, m <= n.\nProof. \n  exists 0; split.\n  exists 0; split; intuition. \n  intros n H. \n  destruct H as [m [_ H]].\n  specialize (H 0) as H0.\n  specialize (H n) as Hn.\n  lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33294,"user_id":null,"body":"Require Import Lia.\nTheorem exists_unique_le : exists! n m : nat, m <= n.\nProof. \n  exists 0. split.\n  exists 0. split. auto. \n  intuition. \n  intros n H. \n  destruct H as [m [_ H]].\n  specialize (H 0) as H0.\n  specialize (H n) as Hn.\n  lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33295,"user_id":null,"body":"Theorem exists_unique_le : exists! n m : nat, m <= n.\nProof.\n  exists 0.\n  unfold unique.\n  split.\n  +\n    exists 0.\n    split; auto. \n    intros.\n    inversion H.\n    auto.\n  +\n    intros.\n    destruct H.\n    destruct H.\n    destruct x'; auto.\n    destruct x; auto.\n    specialize (H0 x).\n    exfalso.\n    assert(x <= S x'). \n    - apply le_S_n in H. auto.\n    -\n      intuition.\n      assert(S x <> x); auto.\nQed. \n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33296,"user_id":null,"body":"Theorem exists_unique_le : exists! n m : nat, m <= n.\nProof.\n  exists 0; split; [exists 0; split|].\n  - apply le_n.\n  - intros x H; now inversion H.\n  - intros x [y [Hle Huniq]].\n    assert (y = x) as R by (now specialize (Huniq x (le_n _))); subst.\n    symmetry; apply Huniq, le_0_n.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33297,"user_id":null,"body":"Require Import Lia.\n\nTheorem exists_unique_le : exists! n m : nat, m <= n.\nProof. \n    exists 0.\n    split.\n    + exists 0. split ; lia.\n    + intros n hn. destruct hn. destruct H.\n      transitivity x. symmetry. apply H0. lia.\n      apply H0. lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33298,"user_id":null,"body":"Require Import Lia.\n\n(* Probably way more complicated than necessary. *)\nTheorem exists_unique_le : exists! n m : nat, m <= n.\nProof.\n  exists O; split.\n  - exists O; split; auto; lia.\n  - intros i H. destruct H.\n    unfold unique in H.\n    destruct H.\n    revert H H0; revert x.\n    induction i; intros x Hle H; auto.\n    inversion Hle; subst.\n    + symmetry; apply H; lia.\n    + apply IHi in H1; auto; subst.\n      destruct x.\n      * apply H; auto.\n      * inversion Hle; subst.\n        -- symmetry; apply H; auto.\n        -- lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33299,"user_id":null,"body":"Require Import Lia.\n\nTheorem exists_unique_le : exists! n m : nat, m <= n.\nProof. \n  exists 0. split.\n  exists 0. split. auto.\n  intros. inversion H; auto.\n  intros. destruct H. unfold unique in H. destruct H.\n  destruct x'. auto. \n  assert (x = 0). { apply H0. lia. }\n  assert (x = 1). { apply H0. lia. }\n  subst. discriminate.\nQed.\n ","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33300,"user_id":null,"body":"Theorem exists_unique_le : exists! n m : nat, m <= n.\nProof.\n  exists 0; split.\n  - exists 0; split.\n    + apply le_n.\n    + intros m H; inversion H; reflexivity.\n  - intros n H.\n    destruct H as (m & H1 & H2).\n    destruct n; [reflexivity|].\n    pose proof (H2 0 (le_0_n _)).\n    pose proof (H2 (S n) (le_n _)).\n    congruence.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33301,"user_id":168,"body":"Require Import ssreflect Arith.\n\nTheorem exists_unique_le : exists! n m : nat, m <= n.\nProof.\n  exists 0; split => [| n [m] [Hmn H]].\n  - by exists 0; split => \/\/; exact: le_n_0_eq.\n  - by move: (H _ (Nat.le_0_l n)) (H _ (Nat.le_refl n)); congruence.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"60b49f44080926003a20bbed":[{"id":33302,"user_id":168,"body":"Require Import Coq.Lists.List.\nRequire Import Coq.ZArith.BinInt.\nRequire Import Preloaded.\nRequire Import ssreflect Lia.\n\nLemma list_max_Z_spec : forall l,\n  let max_val := list_max_Z l in\n  Forall (fun x => x <= max_val) l \/\\\n  (In max_val l \\\/ max_val = 0).\nProof.\n  move => l \/=; split.\n  - rewrite Forall_forall => x.\n    by elim: l => \/\/= h t IH [-> | \/IH]; lia.\n  - elim: l => \/\/= [| h t]; first by right.\n    by case: (Z.max_spec_le h (list_max_Z t)) => [] [H] -> []; auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33303,"user_id":null,"body":"Require Import Coq.Lists.List.\nRequire Import Coq.ZArith.BinInt.\nImport ListNotations.\nRequire Import ssreflect Lia.\nOpen Scope Z_scope.\n\nDefinition list_max_Z : list Z -> Z := fold_right Z.max 0.\n\nLemma list_max_Z_spec : forall l,\n  let max_val := list_max_Z l in\n  Forall (fun x => x <= max_val) l \/\\\n  (In max_val l \\\/ max_val = 0).\n  Proof.\n  intros l m.\n  subst m.\n  split.\n  * rewrite Forall_forall.\n    intros.\n    unfold list_max_Z.\n    induction l.\n    - exfalso.\n      exact H.\n    - simpl.\n      destruct H.\n      + lia.\n      + specialize (IHl H).\n        lia.\n  * induction l.\n    - auto.\n    - simpl.\n      destruct (Z.le_gt_cases (list_max_Z l) a).\n      + left.\n        left.\n        lia.\n      + destruct IHl.\n          rewrite Z.max_r.\n          lia.\n          left.\n          right.\n          exact H0.\n          lia.\nQed.\n\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33304,"user_id":null,"body":"Require Import Preloaded.\nFrom Coq Require Import List BinInt ssreflect.\nImport ListNotations.\n\nOpen Scope Z_scope.\n\nLemma list_max_Z_spec : forall l,\n  let max_val := list_max_Z l in\n  Forall (fun x => x <= max_val) l \/\\ (In max_val l \\\/ max_val = 0).\nProof.\n  move=> l max_val; rewrite {}\/max_val.\n  elim: l => [|x l [IH1 IH2]] \/=.\n    by split; [apply: Forall_nil|right].\n  split.\n    apply: Forall_cons.\n      by apply: Z.le_max_l.\n    case: (Z.max_spec_le x (list_max_Z l)) => [[_ ->]\/\/|[lemaxx ->]].\n    apply: Forall_impl IH1 => y leymax.\n    by apply: Z.le_trans lemaxx.\n  move: IH2 => [linmax|->].\n    by case: (Z.max_dec x (list_max_Z l)) => ->; left; [left|right].\n  by case: (Z.max_dec x 0) => ->; [left; left|right].\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33305,"user_id":191,"body":"Require Import Coq.Lists.List.\nRequire Import Coq.ZArith.BinInt.\nRequire Import Lia.\nRequire Import Preloaded.\n\nLemma list_max_Z_spec : forall l,\n  let max_val := list_max_Z l in\n  Forall (fun x => x <= max_val) l \/\\\n  (In max_val l \\\/ max_val = 0).\nProof.\n  intros l m.\n  subst m.\n  split.\n  * rewrite Forall_forall.\n    intros.\n    unfold list_max_Z.\n    induction l.\n    - exfalso.\n      exact H.\n    - simpl.\n      destruct H.\n      + lia.\n      + specialize (IHl H).\n        lia.\n  * induction l.\n    - auto.\n    - simpl.\n      destruct (Z.le_gt_cases (list_max_Z l) a).\n      + left.\n        left.\n        lia.\n      + destruct IHl.\n          rewrite Z.max_r.\n            left.\n            right.\n            exact H0.\n            lia.\n          lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33306,"user_id":null,"body":"Require Import Coq.Lists.List.\nRequire Import Coq.ZArith.BinInt.\nRequire Import Preloaded.\n\nLemma list_max_Z_spec : forall l,\n  let max_val := list_max_Z l in\n  Forall (fun x => x <= max_val) l \/\\\n  (In max_val l \\\/ max_val = 0).\nProof. \n  intros l.\n  split.\n  {\n    induction l as [|a l h].\n    eauto.\n    apply Forall_cons.\n    simpl.\n    apply Z.le_max_l.\n    eapply (Forall_impl).\n    2 : {\n      exact h.\n    }\n    intros z hz.\n    simpl in hz |- *.\n    transitivity (list_max_Z l).\n    assumption.\n    apply Z.le_max_r.\n  }\n  {\n    induction l as [|a l h].\n    right.\n    reflexivity.\n    destruct h as [h|h].\n    - left. simpl. pose proof Z.lt_total a (list_max_Z l).\n      destruct H as [H|[H|H]].\n      + right. rewrite Z.max_r. assumption. apply Z.lt_le_incl. assumption.\n      + left. symmetry. apply Z.max_l. rewrite H. reflexivity.\n      + left. symmetry. apply Z.max_l. apply Z.lt_le_incl. assumption.\n    - simpl. rewrite h. pose proof Z.lt_total a 0. destruct H as [H|[H|H]].\n      + right. apply Z.max_r. apply Z.lt_le_incl. exact H.\n      + right. rewrite H. apply Z.max_r. reflexivity.\n      + left. left. symmetry. apply Z.max_l.  apply Z.lt_le_incl. exact H.\n  }\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33307,"user_id":null,"body":"Require Import Coq.Lists.List.\nRequire Import Coq.ZArith.BinInt.\nRequire Import Preloaded.\n\nRequire Import Lia.\n\nLemma list_max_Z_spec : forall l,\n  let max_val := list_max_Z l in\n  Forall (fun x => x <= max_val) l \/\\\n  (In max_val l \\\/ max_val = 0).\nProof.\n  intros. induction l; [auto|].\n  subst max_val. simpl. destruct IHl.\n  unfold Z.max. destruct (a ?= list_max_Z l) eqn:?E.\n  - apply Z.compare_eq in E. destruct H0.\n    + subst. split; auto.\n      constructor; auto. apply Z.le_refl.\n    + subst. rewrite H0 in *. split; auto.\n      constructor; auto. apply Z.le_refl.\n  - rewrite Z.compare_lt_iff in E. destruct H0.\n    + split; auto.  constructor; auto; lia.\n    + rewrite H0 in *. split; auto.\n      constructor; auto; lia.\n  - rewrite Z.compare_gt_iff in E. destruct H0.\n    + split; auto. constructor; try lia.\n      apply Forall_impl with (P := (fun x : Z => x <= list_max_Z l)); auto; try lia.\n    + split; auto. constructor; try lia.\n      apply Forall_impl with (P := (fun x : Z => x <= list_max_Z l)); auto; try lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33308,"user_id":null,"body":"Require Import Coq.Lists.List.\nRequire Import Coq.ZArith.BinInt.\nRequire Import Preloaded Lia.\n\n\nLemma list_max_Z_spec : forall l,\n  let max_val := list_max_Z l in\n  Forall (fun x => x <= max_val) l \/\\\n  (In max_val l \\\/ max_val = 0).\nProof. \n  intros.\n  subst max_val.\n  split.\n  - auto.\n    induction l; [easy|].\n    apply Forall_cons.\n    + simpl.\n      unfold Z.max.\n      case_eq (a ?= list_max_Z l); intro; [easy| |easy].\n      rewrite Z.compare_lt_iff in H.\n      lia.\n    + simpl.\n      unfold Z.max.\n      case_eq (a ?= list_max_Z l); intro.\n      * rewrite Z.compare_eq_iff in H.\n        rewrite H.\n        exact IHl.\n      * exact IHl.\n      * rewrite Z.compare_gt_iff in H.\n        apply Forall_forall.\n        intros.\n        rewrite Forall_forall in IHl.\n        pose proof (IHl x).\n        pose proof (H1 H0).\n        pose proof (Z.le_lt_trans _ _ _ H2 H).\n        lia.\n    - induction l.\n      + right. easy.\n      + destruct IHl.\n        * simpl.\n          unfold Z.max.\n          case_eq (a ?= list_max_Z l); intros.\n          -- left. left. reflexivity.\n          -- left. right. exact H.\n          -- left. left. reflexivity.\n        * simpl.\n          unfold Z.max.\n          case_eq (a ?= list_max_Z l); intros.\n          -- right. \n             rewrite Z.compare_eq_iff in H0.\n             congruence.\n          -- right. exact H. \n          -- left. left. reflexivity.\nQed. \n      ","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33309,"user_id":null,"body":"Require Import Coq.Lists.List.\nRequire Import Coq.ZArith.BinInt.\nRequire Import Preloaded.\n\nLemma list_max_Z_spec : forall l,\n  let max_val := list_max_Z l in\n  Forall (fun x => x <= max_val) l \/\\\n  (In max_val l \\\/ max_val = 0).\n  \n  \nProof. \n  intros.\n  induction l; simpl in max_val.\n  - split. constructor. right. auto.\n  - simpl in IHl. split.\n    + constructor. apply Z.le_max_l. destruct IHl. \n      apply Forall_impl with (P := fun x => x <= list_max_Z l).\n      intros. assert (list_max_Z l <= max_val). apply Z.le_max_r. apply Z.le_trans with (list_max_Z l); assumption. \n      assumption.\n    + destruct IHl. pose proof (Z.max_spec a (list_max_Z l)). destruct H1 as [[H1 H2] | [H1 H2]].\n      assert (max_val = list_max_Z l). auto.\n      rewrite H3.\n      destruct H0. left. simpl. right. assumption.\n      right. assumption.\n      \n      assert (max_val = a). auto. rewrite H3. left. constructor. auto.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33310,"user_id":null,"body":"Require Import Coq.Lists.List.\nRequire Import Coq.ZArith.BinInt.\nRequire Import Preloaded.\n\nLemma list_max_Z_spec : forall l,\n  let max_val := list_max_Z l in\n  Forall (fun x => x <= max_val) l \/\\\n  (In max_val l \\\/ max_val = 0).\nProof.\n  induction l; split.\n  - constructor.\n  - right; reflexivity.\n  - destruct IHl as (IHl & _).\n    constructor.\n    + cbn. apply Z.le_max_l.\n    + cbn. eapply Forall_impl; try eassumption.\n      cbn. intros b H. eapply Z.le_trans; try eassumption.\n      apply Z.le_max_r.\n  - destruct IHl as (_ & IHl). cbn.\n    destruct (Z.max_spec a (list_max_Z l)) as [Hmax|Hmax].\n    + destruct Hmax as (Hmax1 & Hmax2).\n      rewrite Hmax2.\n      destruct IHl as [IHl|IHl].\n      * left; right; assumption.\n      * right; assumption.\n    + destruct Hmax as (Hmax1 & Hmax2).\n      rewrite Hmax2.\n      left; left; reflexivity.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33311,"user_id":null,"body":"Require Import Coq.Lists.List.\nRequire Import Coq.ZArith.BinInt.\nRequire Import Preloaded.\n\nLemma list_max_Z_spec : forall l,\n  let max_val := list_max_Z l in\n  Forall (fun x => x <= max_val) l \/\\\n  (In max_val l \\\/ max_val = 0).\nProof.\n  unfold list_max_Z; generalize 0; induction l.\n  - split; [apply Forall_nil|].\n    now right.\n  - destruct IHl as [IHForall IHin].\n    split.\n    + apply Forall_cons, Forall_impl with (fun x => x <= fold_right Z.max z l), IHForall.\n      * apply Z.le_max_l.\n      * intros; now apply Z.le_trans with (fold_right Z.max z l), Z.le_max_r.\n    + destruct (Z.max_dec a (fold_right Z.max z l)) as [Heq|Heq]; [|destruct IHin].\n      * now left; left.\n      * left; right; simpl; now rewrite Heq.\n      * right; simpl; now rewrite Heq.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"60b9d5d64e0ae80031bdd9b4":[{"id":33312,"user_id":null,"body":"Require Import Preloaded Coq.Lists.List.\n\nLemma bt_invert_involution : forall (A : Type) (tree : bt A),\n  bt_invert (bt_invert tree) = tree.\nProof. \n  induction tree; auto; simpl. \n  rewrite IHtree1, IHtree2; auto.\nQed.\n\nLemma bt_invert_inorder : forall (A : Type) (tree : bt A),\n  bt_inorder (bt_invert tree) = rev (bt_inorder tree).\nProof. \n  induction tree; auto; simpl.\n  rewrite IHtree1, IHtree2, rev_app_distr; simpl.\n  rewrite <- app_assoc; auto. \nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33313,"user_id":null,"body":"Require Import Preloaded Coq.Lists.List.\n\nLemma bt_invert_involution : forall (A : Type) (tree : bt A),\n  bt_invert (bt_invert tree) = tree.\nProof. \n  induction tree; auto; simpl. \n  rewrite IHtree1, IHtree2; auto.\nQed.\n\nLemma bt_invert_inorder : forall (A : Type) (tree : bt A),\n  bt_inorder (bt_invert tree) = rev (bt_inorder tree).\nProof. \n  induction tree; auto; simpl.\n  rewrite IHtree1, IHtree2, rev_app_distr; simpl.\n  rewrite <- rev_unit, rev_app_distr; intuition. \nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33314,"user_id":null,"body":"Require Import Preloaded Coq.Lists.List.\n\nLemma bt_invert_involution : forall (A : Type) (tree : bt A),\n  bt_invert (bt_invert tree) = tree.\nProof.\n    intros.\n    induction tree as [| a tree1 ht1 tree2 ht2].\n    + auto.\n    + simpl. rewrite ht1,ht2. reflexivity.\nQed.\n\nLemma bt_invert_inorder : forall (A : Type) (tree : bt A),\n  bt_inorder (bt_invert tree) = rev (bt_inorder tree).\nProof.\n    intros.\n    induction tree as [| a tree1 ht1 tree2 ht2].\n    + auto.\n    + simpl. rewrite (rev_app_distr). simpl.\n      rewrite ht1,ht2. rewrite app_assoc_reverse.\n      auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33315,"user_id":null,"body":"Require Import Preloaded Coq.Lists.List.\n\nLemma bt_invert_involution : forall (A : Type) (tree : bt A),\n    bt_invert (bt_invert tree) = tree.\nProof. intros A t; induction t; simpl; congruence. Qed.\n\nLemma bt_invert_inorder : forall (A : Type) (tree : bt A),\n    bt_inorder (bt_invert tree) = rev (bt_inorder tree).\nProof.\n  intros A t.\n  induction t; simpl; auto.\n  rewrite IHt1, IHt2, rev_app_distr; simpl; rewrite <- app_assoc.\n  reflexivity.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33316,"user_id":191,"body":"Require Import Preloaded Coq.Lists.List.\n\nLemma bt_invert_involution : forall (A : Type) (tree : bt A),\n  bt_invert (bt_invert tree) = tree.\nProof.\n  induction tree;\n  simpl;\n  congruence.\nQed.\n\nLemma bt_invert_inorder : forall (A : Type) (tree : bt A),\n  bt_inorder (bt_invert tree) = rev (bt_inorder tree).\nProof.\n  induction tree.\n  auto.\n  simpl.\n  rewrite IHtree1.\n  rewrite IHtree2.\n  rewrite distr_rev.\n  simpl.\n  rewrite app_ass.\n  reflexivity.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33317,"user_id":null,"body":"Require Import Preloaded Coq.Lists.List.\n\nLemma bt_invert_involution : forall (A : Type) (tree : bt A),\n  bt_invert (bt_invert tree) = tree.\nProof.\n  intros. induction tree; auto.\n  simpl. now rewrite IHtree1, IHtree2.\nQed.\n\nLemma bt_invert_inorder : forall (A : Type) (tree : bt A),\n  bt_inorder (bt_invert tree) = rev (bt_inorder tree).\nProof.\n  intros. induction tree; auto.\n  simpl. rewrite IHtree1, IHtree2.\n  rewrite rev_app_distr; simpl.\n  now rewrite <- app_assoc.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33318,"user_id":null,"body":"Require Import Preloaded Coq.Lists.List.\nRequire Import ssreflect.\n\nLemma bt_invert_involution : forall (A : Type) (tree : bt A),\n  bt_invert (bt_invert tree) = tree.\nProof. by move=> A; elim=> [\/\/|a \/= l -> r ->]. Qed.\n\nLemma bt_invert_inorder : forall (A : Type) (tree : bt A),\n  bt_inorder (bt_invert tree) = rev (bt_inorder tree).\nProof.\n  move=> A.\n  elim=> [\/\/|a \/= l -> r ->].\n  by rewrite rev_app_distr \/= app_assoc_reverse.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33319,"user_id":null,"body":"Require Import Preloaded Coq.Lists.List.\n\nLemma bt_invert_involution : forall (A : Type) (tree : bt A),\n  bt_invert (bt_invert tree) = tree.\nProof.\n  intros.\n  induction tree.\n  - trivial.\n  - simpl. rewrite -> IHtree1. rewrite -> IHtree2. trivial.\nQed.\n\nLemma app_empty_list: forall (A: Type) (l:list A), l ++ nil = l.\nProof.\n  intros. induction l.\n  - trivial.\n  - simpl. rewrite IHl. trivial.\nQed.\n\nLemma bt_invert_inorder : forall (A : Type) (tree : bt A),\n  bt_inorder (bt_invert tree) = rev (bt_inorder tree).\nProof. \n  intros.\n  induction tree.\n  - trivial.\n  - simpl. rewrite -> IHtree1, IHtree2.\n  assert (rev_concat: forall (l1 l2:list A), rev (l1 ++ l2) = rev l2 ++ rev l1).\n    intros. induction l1, l2.\n    -- reflexivity.\n    -- simpl. rewrite app_empty_list. trivial.\n    -- simpl. rewrite app_empty_list. trivial.\n    -- simpl. rewrite IHl1. simpl. rewrite app_ass. trivial.\n    -- rewrite rev_concat. simpl. rewrite app_ass. reflexivity.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33320,"user_id":null,"body":"Require Import Preloaded Coq.Lists.List.\n\nLemma bt_invert_involution : forall (A : Type) (tree : bt A),\n  bt_invert (bt_invert tree) = tree.\nProof.\n  induction tree.\n  - reflexivity.\n  - cbn. rewrite IHtree1, IHtree2. reflexivity.\nQed.\n\nLemma bt_invert_inorder : forall (A : Type) (tree : bt A),\n  bt_inorder (bt_invert tree) = rev (bt_inorder tree).\nProof.\n  induction tree.\n  - reflexivity.\n  - cbn. rewrite rev_app_distr. cbn. rewrite app_assoc_reverse. cbn.\n    rewrite IHtree1, IHtree2. reflexivity.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33321,"user_id":null,"body":"Require Import Preloaded Coq.Lists.List.\n\nLemma bt_invert_involution : forall (A : Type) (tree : bt A),\n  bt_invert (bt_invert tree) = tree.\nProof.\n  induction tree; [easy|].\n  simpl; now rewrite IHtree1, IHtree2.\nQed.\n\nLemma bt_invert_inorder : forall (A : Type) (tree : bt A),\n  bt_inorder (bt_invert tree) = rev (bt_inorder tree).\nProof.\n  induction tree; [easy|].\n  simpl; rewrite IHtree1, IHtree2, rev_app_distr; simpl.\n  now rewrite <- app_assoc.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"61860eed193401003c624be0":[{"id":33322,"user_id":null,"body":"Require Import List Bool Lia.\nFact another_one : forall (X : Type) (l : list X) (f g : X -> bool),\n  length (filter (fun x => f x && g x) l) <= length (filter f l) \/\\\n  length (filter (fun x => f x && g x) l) <= length (filter g l).\nProof.\n  intros; induction l; auto.\n  simpl; case (f a); simpl; case (g a); simpl; lia. \nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33323,"user_id":null,"body":"Require Import List Bool.\n\nFact another_one : forall (X : Type) (l : list X) (f g : X -> bool),\n  length (filter (fun x => f x && g x) l) <= length (filter f l) \/\\\n  length (filter (fun x => f x && g x) l) <= length (filter g l).\nProof.\n  intros; induction l.\n  - simpl; split; apply le_n.\n  - simpl.\n    destruct (f a) eqn:Hf;\n      destruct (g a) eqn:Hg;\n      simpl.\n    + split; apply le_n_S; apply IHl.\n    + split; try apply IHl.\n      apply le_S; apply IHl.\n    + split; try apply IHl.\n      apply le_S; apply IHl.\n    + apply IHl.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33324,"user_id":null,"body":"Require Import List Bool.\n\nFact another_one : forall (X : Type) (l : list X) (f g : X -> bool),\n  length (filter (fun x => f x && g x) l) <= length (filter f l) \/\\\n  length (filter (fun x => f x && g x) l) <= length (filter g l).\nProof. \n  intros.\n  enough(forall f' g', length (filter (fun x : X => f' x && g' x) l) <= length (filter f' l)).\n  {\n    split; auto.\n    rewrite (filter_ext _ (fun x : X => g x && f x)); auto.\n    intros.\n    apply andb_comm.\n  }\n  clear f g.\n  intros.\n  induction l; auto.\n  simpl.\n  destruct (f' a); auto.\n  simpl.\n  destruct (g' a); auto.\n  simpl.\n  apply le_n_S.\n  auto.\nQed.\n  ","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33325,"user_id":null,"body":"Require Import List Bool.\n\nFact another_one : forall (X : Type) (l : list X) (f g : X -> bool),\n  length (filter (fun x => f x && g x) l) <= length (filter f l) \/\\\n  length (filter (fun x => f x && g x) l) <= length (filter g l).\nProof.\n  induction l as [|x l]; intros; [easy|].\n  simpl; destruct (IHl f g) as [IHf IHg]; clear IHl.\n  destruct (f x), (g x); simpl.\n  - split; now apply le_n_S.\n  - split; [apply le_S|]; easy.\n  - split; [|apply le_S]; easy.\n  - easy.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33326,"user_id":null,"body":"Require Import List Bool Lia.\n\nFact another_one : forall (X : Type) (l : list X) (f g : X -> bool),\n    length (filter (fun x => f x && g x) l) <= length (filter f l) \/\\\n      length (filter (fun x => f x && g x) l) <= length (filter g l).\nProof.\n  intros X l f g; induction l; simpl; auto.\n  split; destruct (f a), (g a); simpl; lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33327,"user_id":null,"body":"Require Import List Bool.\n\nFact another_one : forall (X : Type) (l : list X) (f g : X -> bool),\n  length (filter (fun x => f x && g x) l) <= length (filter f l) \/\\\n  length (filter (fun x => f x && g x) l) <= length (filter g l).\nProof.\n  intros A l f g.\n  induction l; simpl.\n  - split; apply le_n.\n  - destruct IHl as (IHl1 & IHl2).\n    destruct (f a), (g a); simpl; split;\n      try (apply le_n_S || apply le_S); assumption.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33328,"user_id":null,"body":"Require Import List Bool.\n\nLemma another_one_aux : forall (X : Type) (l : list X) (f g : X -> bool),\nlength (filter (fun x => f x && g x) l) <= length (filter f l).\nProof.\n  intros X l f g.\n  induction l as [|a l hl].\n  {\n    simpl.\n    auto. \n  }\n  {\n    simpl.\n    induction (f a).\n    induction (g a).\n    - simpl. apply le_n_S. assumption.\n    - simpl. apply le_S. assumption.\n    - simpl. assumption.\n  }\nQed.\n\nLemma another_one_aux2 : forall (X : Type) (l : list X) (f g : X -> bool),\nlength (filter (fun x => f x && g x) l) <= length (filter g l).\nProof.\n  intros X l f g.\n  induction l as [|a l hl].\n  {\n    simpl.\n    auto. \n  }\n  {\n    simpl.\n    induction (g a).\n    induction (f a).\n    - simpl. apply le_n_S. assumption.\n    - simpl. apply le_S. assumption.\n    - induction (f a); simpl; assumption.\n  }\nQed.\n\nFact another_one : forall (X : Type) (l : list X) (f g : X -> bool),\n  length (filter (fun x => f x && g x) l) <= length (filter f l) \/\\\n  length (filter (fun x => f x && g x) l) <= length (filter g l).\nProof.\n  split.\n  apply another_one_aux.\n  apply another_one_aux2.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33329,"user_id":null,"body":"Require Import List Bool.\n\nFact another_one : forall (X : Type) (l : list X) (f g : X -> bool),\n  length (filter (fun x => f x && g x) l) <= length (filter f l) \/\\\n  length (filter (fun x => f x && g x) l) <= length (filter g l).\nProof.\n  intros X l f g. induction l; [split;auto|].\n  destruct IHl.\n  split; simpl;\n    destruct (f a), (g a); simpl; auto;\n      now apply le_n_S.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33330,"user_id":null,"body":"Require Import List Bool.\n\nFact another_one : forall (X : Type) (l : list X) (f g : X -> bool),\n  length (filter (fun x => f x && g x) l) <= length (filter f l) \/\\\n  length (filter (fun x => f x && g x) l) <= length (filter g l).\nProof.\n    intros.\n    split.\n    induction l.\n    compute. reflexivity.\n    simpl.\n    case (g a).\n    rewrite andb_true_r.\n    case (f a).\n    simpl.\n    apply le_n_S.\n    exact IHl.\n    exact IHl.\n    rewrite andb_false_r.\n    case (f a).\n    simpl.\n    Search le.\n    apply le_S.\n    exact IHl.\n    exact IHl.\n    induction l.\n    compute. reflexivity.\n    simpl.\n    case (g a).\n    rewrite andb_true_r.\n    case (f a).\n    simpl.\n    apply le_n_S.\n    exact IHl.\n    simpl.\n    apply le_S.\n    exact IHl.\n    rewrite andb_false_r.\n    case (f a).\n    simpl.\n    exact IHl.\n    exact IHl.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33331,"user_id":191,"body":"Require Import List Bool Lia.\n\nFact another_one : forall (X : Type) (l : list X) (f g : X -> bool),\n  length (filter (fun x => f x && g x) l) <= length (filter f l) \/\\\n  length (filter (fun x => f x && g x) l) <= length (filter g l).\nProof.\n  split;\n  induction l;\n  auto;\n  destruct (f a) eqn:hF;\n  destruct (g a) eqn:hG;\n  simpl;\n  rewrite hF;\n  rewrite hG;\n  simpl;\n  lia.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"61861ec3193401003c64ec32":[{"id":33332,"user_id":null,"body":"Require Import List.\nFact yet_another_one : forall (X : Type) (l : list X) (f g : X -> bool), \n  (forall a, In a l -> implb (f a) (g a) = true) <-> \n  forall a, In a (filter f l) -> In a (filter g l).\nProof. \n  unfold implb. induction l. easy.\n  intuition; specialize (H a0); repeat rewrite filter_In in *. intuition. rewrite H2 in H0. auto. \n  case (f a0), (g a0); intuition.\nQed. \n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33333,"user_id":null,"body":"Require Import List.\nFact yet_another_one : forall (X : Type) (l : list X) (f g : X -> bool),\n  (forall a, In a l -> implb (f a) (g a) = true) <-> forall a, In a (filter f l) -> In a (filter g l).\nProof. \n  unfold implb. simpl. induction l. easy.\n  intuition; specialize (H a0); repeat rewrite filter_In in *; intuition. \n  rewrite H2 in H0. auto. case (f a0), (g a0); intuition.\nQed. \n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33334,"user_id":null,"body":"Require Import List.\nFact yet_another_one : forall (X : Type) (l : list X) (f g : X -> bool),\n  (forall a, In a l -> implb (f a) (g a) = true) <-> forall a, In a (filter f l) -> In a (filter g l).\nProof. \n  unfold implb. induction l. easy.\n  intuition; specialize (H a0); repeat rewrite filter_In in *; intuition; case (f a0), (g a0); intuition.\nQed. \n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33335,"user_id":null,"body":"Require Import List Bool.\n\nFact yet_another_one : forall (X : Type) (l : list X) (f g : X -> bool),\n  (forall a, In a l -> implb (f a) (g a) = true) <->\n  forall a, In a (filter f l) -> In a (filter g l).\nProof. \n  intros.\n  unfold implb.\n  split; intros.\n  +\n    rewrite filter_In in H0.\n    rewrite filter_In.\n    split. intuition.\n    unfold implb in H.\n    destruct H0.\n    specialize (H a).\n    rewrite H1 in H. auto.\n  +\n    specialize (H a).\n    repeat rewrite filter_In in H.\n    destruct (f a) eqn:e_f; auto.\n    intuition.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33336,"user_id":null,"body":"Require Import List Bool.\n\nFact yet_another_one : forall (X : Type) (l : list X) (f g : X -> bool),\n  (forall a, In a l -> implb (f a) (g a) = true) <->\n  forall a, In a (filter f l) -> In a (filter g l).\nProof.\n  split.\n  - intros Himp a Hin; induction l as [|x l]; [easy|].\n    simpl in *; remember (f x) as fx; destruct fx; [destruct Hin as [Hx|Hin]|]; subst.\n    + specialize (Himp a); unfold implb in Himp; rewrite <- Heqfx in Himp.\n      rewrite Himp; now left.\n    + destruct (g x); [right|]; (apply IHl; [intros; apply Himp; right|]; easy).\n    + destruct (g x); [right|]; (apply IHl; [intros; apply Himp; right|]; easy).\n  - intros Hincl a Hin.\n    remember (f a) as fa; destruct fa; [|easy].\n    remember (g a) as ga; destruct ga; [easy|exfalso].\n    cut (In a (filter f l)); [|now apply filter_In].\n    intros H; apply Hincl, filter_In in H; destruct H as [_ H].\n    now rewrite H in Heqga.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33337,"user_id":null,"body":"Require Import List Bool.\n\nFact yet_another_one : forall (X : Type) (l : list X) (f g : X -> bool),\n  (forall a, In a l -> implb (f a) (g a) = true) <->\n  forall a, In a (filter f l) -> In a (filter g l).\nProof.\n    intros.\n    split.\n    {\n        destruct l as [| a l].\n        + intros. inversion H0.\n        + intros. rewrite filter_In in *. destruct H0.\n          split. assumption. Search (implb). specialize (H a0 H0).\n          rewrite H1 in H. simpl in H. assumption.\n    }\n    {\n        destruct l as [| a l].\n        + intros. inversion H0.\n        + intros. rewrite implb_true_iff. intro hf.\n          specialize (H a0). rewrite filter_In in H.\n          specialize (H (conj H0 hf)). rewrite filter_In in H.\n          apply (proj2 H).\n    }\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33338,"user_id":null,"body":"Require Import List Bool.\n\nFact yet_another_one : forall (X : Type) (l : list X) (f g : X -> bool),\n    (forall a, In a l -> implb (f a) (g a) = true) <->\n      forall a, In a (filter f l) -> In a (filter g l).\nProof.\n  unfold implb; intros A l f g; split.\n  - induction l; simpl; intros H0 x Hin; auto.\n    destruct (f a) eqn: Hfa, (g a) eqn:Hga; auto.\n    + destruct Hin as [? | Hin]; subst.\n      * left; reflexivity.\n      * right; apply IHl; auto.\n    + destruct Hin as [? | Hin]; subst.\n      * specialize (H0 x (or_introl (eq_refl x))).\n        rewrite Hfa, Hga in H0; congruence.\n      * apply IHl; auto.\n    + right; apply IHl; auto.\n  - intros H0 x Hin.\n    destruct (f x) eqn:Hfx; auto.\n    eapply filter_In; apply H0.\n    apply filter_In; auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33339,"user_id":null,"body":"Require Import List Bool.\n\nFact yet_another_one : forall (X : Type) (l : list X) (f g : X -> bool),\n  (forall a, In a l -> implb (f a) (g a) = true) <->\n  forall a, In a (filter f l) -> In a (filter g l).\nProof. \n intros.\n  setoid_rewrite filter_In.\n  setoid_rewrite Bool.implb_true_iff.\n  firstorder.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33340,"user_id":null,"body":"Require Import List Bool.\n\nFact yet_another_one : forall (X : Type) (l : list X) (f g : X -> bool),\n  (forall a, In a l -> implb (f a) (g a) = true) <->\n  forall a, In a (filter f l) -> In a (filter g l).\nProof.\n         intros.\n         split.\n         intros.\n         rewrite filter_In in *.\n         destruct H0.\n         split.\n         assumption.\n         apply H in H0.\n         rewrite H1 in H0.\n         simpl in H0.\n         assumption.\n         intros.\n         assert (In a (filter f l) -> In a (filter g l)).\n         apply H.\n         repeat rewrite filter_In in H1.\n         apply implb_true_iff.\n         intuition.\n         Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33341,"user_id":null,"body":"Require Import List Bool.\n\nFact yet_another_one : forall (X : Type) (l : list X) (f g : X -> bool),\n  (forall a, In a l -> implb (f a) (g a) = true) <->\n  forall a, In a (filter f l) -> In a (filter g l).\nProof.\n  intros A l f g.\n  split.\n  - intros himpl a.\n    rewrite !filter_In.\n    intros [hin htrue].\n    split; [assumption|].\n    apply (proj1 (implb_true_iff _ _) (himpl _ hin)).\n    assumption.\n  - intros himpl a hin.\n    specialize (himpl a).\n    rewrite !filter_In in himpl.\n    apply implb_true_iff; intros htrue.\n    apply himpl; split; assumption.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"61866a07193401003c701360":[{"id":33342,"user_id":168,"body":"Require Import Preloaded.\nRequire Import ssreflect Lia.\n\nLemma dividesP m n : divides m n <-> exists k, n = k * m.\nProof.\n  split.\n  + induction 1; first by exists 0.\n    by case: IHdivides => k ->; exists (S k).\n  + by case => k ->; elim: k => \/\/; eauto using divides.\nQed.\n  \nTheorem exists_P_iff_divides : exists m,\n  forall n, P n <-> divides m n.\nProof.\n  exists 4; move => n; split.\n  + elim; repeat first [apply: add_divides | apply: O_divides].\n    - move => a b; rewrite !dividesP => _ [k ->] _ [l ->].\n      by exists (l + k); lia.\n    - move => a b c <-; rewrite !dividesP => _ [k ->] _ [l H].\n      by exists (l - k); lia.\n  + induction 1; first by eauto using P.\n    apply: P_sum => \/\/.\n    by have: P 20; eauto using P.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33343,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Arith Lia.\n\nDefinition P_20 := P_diff 20 _ _ eq_refl P_40 P_60.\nDefinition P_4 := P_diff 4 _ _ eq_refl P_20 P_24.\nDefinition P_0 := P_diff 0 _ _ eq_refl P_4 P_4.\n\nTheorem divdiv :\n  forall m n, divides m n <-> exists x,  n = m * x.\nProof.\n  intros.\n  split.\n  intros.\n  induction H.\n  exists 0.\n  rewrite Nat.mul_0_r.\n  reflexivity.\n  destruct IHdivides.\n  exists (x + 1).\n  symmetry.\n  rewrite Nat.add_comm.\n  simpl.\n  rewrite Nat.mul_comm.\n  simpl.\n  rewrite H0.\n  rewrite Nat.mul_comm.\n  reflexivity.\n  intros.\n  destruct H.\n  subst.\n  induction x.\n  ring_simplify.\n  constructor.\n  ring_simplify.\n  rewrite Nat.add_comm.\n  constructor.\n  assumption.\nQed.\n\n\nTheorem exists_P_iff_divides : exists m,\n  forall n, P n <-> divides m n.\nProof.\n  exists 4.\n  intros.\n  split.\n  intro.\n  induction H.\n  replace 24 with (4+(4+(4+(4+(4+(4+0)))))) by reflexivity.\n  repeat constructor.\n  replace 40 with (4+(4+(4+(4+(4+(4+(4+(4+(4+(4+(0))))))))))) by reflexivity.\n  repeat constructor.\n  replace 60 with (4+(4+(4+(4+(4+(4+(4+(4+(4+(4+(20))))))))))) by reflexivity.\n  repeat constructor.\n  replace 20 with (4+(4+(4+(4+(4+(0)))))) by reflexivity.\n  repeat constructor.\n  induction IHP1.\n  simpl; exact IHP2.\n  rewrite <- Nat.add_assoc.\n  constructor.\n  apply IHIHP1.\n  eapply P_diff.\n  rewrite Nat.add_comm.\n  instantiate (2 := 4).\n  instantiate (1 := (4 + n)).\n  reflexivity.\n  exact P_4.\n  exact H.\n  rewrite <- Hl in *.\n  clear Hl H H0.\n  rewrite divdiv in *.\n  destruct IHP1, IHP2.\n  subst.\n  exists (x0 - x).\n  lia.\n  intros.\n  induction H.\n  exact P_0.\n  apply P_sum.\n  exact P_4.\n  exact IHdivides.\nQed.\n\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33344,"user_id":null,"body":"Require Import Preloaded.\n\n\nRequire Import Arith Lia.\n\nLemma divides_divide: forall n m, divides n m <-> Nat.divide n m.\nProof.\n  intros.\n  unfold Nat.divide.\n  split; intros.\n  +\n    induction H.\n    exists 0. auto.\n    destruct IHdivides.\n    subst.\n    exists (x+1). lia.\n  +\n    destruct H.\n    generalize dependent m.\n    induction x; intros; subst; simpl;\n      constructor; auto.\nQed.\n  \n\n\nTheorem exists_P_iff_divides : exists m,\n  forall n, P n <-> divides m n.\nProof. \n  exists 4.\n  intros.\n  split; intros.\n  +\n    rewrite divides_divide.\n    unfold Nat.divide.\n    induction H.\n      - exists 6. lia.\n      - exists 10. lia.\n      - exists 15. lia.\n      -\n        destruct IHP1.\n        destruct IHP2.\n        exists (x + x0).\n        lia.\n      -\n        destruct IHP1.\n        destruct IHP2.\n        subst.\n        exists (x0 - x). \n        lia.\n  +\n    rewrite divides_divide in H.\n    unfold Nat.divide in H.\n    destruct H.\n    generalize dependent n.\n    induction x; intros.\n    -\n      simpl in H.\n      subst.\n      apply (P_diff 0 24 24); constructor.\n    -\n      subst.\n      replace (S x * 4) with (4 + x * 4); auto.\n      apply P_sum; auto.\n      apply (P_diff 4 36 40); auto.\n      apply (P_diff 36 24 60); auto; constructor.\n      constructor.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33345,"user_id":null,"body":"Require Import Preloaded Arith.\n\nLemma divides_multiple : forall m n, divides m (n * m).\nProof.\n  induction n; [apply O_divides|].\n  simpl; apply add_divides, IHn.\nQed.\n\nLemma divides_sum : forall m a b, divides m a -> divides m b <-> divides m (a + b).\nProof.\n  intros m a b Ha; induction Ha; [easy|].\n  destruct IHHa as [IH1 IH2]; split.\n  - intros Hb; rewrite <- Nat.add_assoc; apply add_divides, IH1, Hb.\n  - intros Hb; inversion Hb; subst.\n    + destruct m; [|easy]; destruct n; [|easy]; now destruct b.\n    + rewrite <- Nat.add_assoc in H; apply plus_reg_l in H; subst.\n      apply IH2, H0.\nQed.\n\nTheorem exists_P_iff_divides : exists m,\n  forall n, P n <-> divides m n.\nProof.\n  exists 4; split.\n  - intros Pn; induction Pn.\n    + apply (divides_multiple 4 6).\n    + apply (divides_multiple 4 10).\n    + apply (divides_multiple 4 15).\n    + now apply divides_sum.\n    + rewrite Nat.add_comm in Hl; subst; now apply divides_sum in IHPn2.\n  - remember 4 as m; intros d4; induction d4.\n    + apply (P_diff 0 24 24); [easy| |]; apply P_24.\n    + apply P_sum, IHd4; subst.\n      apply (P_diff 4 20 24); [easy| |apply P_24].\n      apply (P_diff 20 40 60); [easy|apply P_40|apply P_60].\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33346,"user_id":null,"body":"Require Import Preloaded Lia.\n\nTheorem P_4 : P 4.\nProof.\n  apply (P_diff 4 20 24). lia. apply (P_diff 20 40 60). lia. 1,2,3: constructor. \nQed.\n\nTheorem exists_P_iff_divides : exists m,\n  forall n, P n <-> divides m n.\nProof.\n  exists 4. \n  split.\n  * intro hpn. induction hpn as [| | | n m hpn hdn hpm hdm | l n m heq hpn hdn hpm hdm]. \n    - repeat (apply (add_divides 4)). constructor.\n    - repeat (apply (add_divides 4)). constructor.\n    - repeat (apply (add_divides 4)). constructor.\n    - induction hdn. replace (0+m) with m by lia. assumption.\n      replace (4+n+m) with (4+(n+m)) by lia. apply (add_divides 4).\n      apply IHhdn. apply (P_diff n 4 (4+n)). lia. exact P_4. assumption.\n    - revert n heq hdn hpn. induction hdm.\n      + intros. replace l with 0 by lia. constructor.\n      + intros. induction hdn.\n        ** replace l with (4+n) by lia. constructor. assumption.\n        ** refine (IHhdm _ n0 _ hdn _). apply (P_diff n 4 (4+n)).\n           lia. exact P_4. assumption. lia. apply (P_diff n0 4 (4+n0)).\n           lia. exact P_4. assumption.\n  * intro hdn. induction hdn. \n    - apply (P_diff 0 24 24). lia. constructor. constructor.\n    - apply P_sum. exact P_4. assumption.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33347,"user_id":17,"body":"Require Import Preloaded.\n\nRequire Import Coq.Arith.Plus.\n\nHint Constructors divides : core.\nHint Constructors P : core.\n\nLemma P_4 : P 4.\nProof.\n  assert (20 + 40 = 60) by reflexivity.\n  assert (4 + 20 = 24) by reflexivity.\n  eauto.\nQed.\n\nHint Resolve P_4 : core.\n\nLemma P_0 : P 0.\nProof. eauto. Qed.\n\nHint Resolve P_0 : core.\n\nLemma P_add_4 : forall n, P n -> P (4 + n).\nProof. auto. Qed.\n\nHint Resolve P_add_4 : core.\n\nLemma divides_4_24 : divides 4 24.\nProof.\n  replace 24 with (4 + (4 + (4 + (4 + (4 + (4 + 0))))))\n    by reflexivity.\n  repeat apply add_divides; apply O_divides.\nQed.\n\nHint Resolve divides_4_24 : core.\n\nLemma divides_4_40 : divides 4 40.\nProof.\n  replace 40 with (4 + (4 + (4 + (4 + (4 + (4 + (4 + (4 + (4 + (4 + 0))))))))))\n    by reflexivity.\n  repeat apply add_divides; apply O_divides.\nQed.\n\nHint Resolve divides_4_40 : core.\n\nLemma divides_4_60 : divides 4 60.\nProof.\n  replace 60 with (4 + (4 + (4 + (4 + (4 + (4 + (4 + (4 + (4 + (4 + (4 + (4 + (4 + (4 + (4 + 0)))))))))))))))\n    by reflexivity.\n  repeat apply add_divides; apply O_divides.\nQed.\n\nHint Resolve divides_4_60 : core.\n\nLemma divides_4_sum : forall n m\n  (Hn : divides 4 n) (Hm : divides 4 m),\n  divides 4 (n + m).\nProof.\n  intros; induction Hn; simpl; auto.\n  replace (S (S (S (S (n + m)))))\n    with (4 + (n + m)) by reflexivity; auto.\nQed.\n\nHint Resolve divides_4_sum : core.\n\nLemma divides_4_diff : forall l n m\n  (Hl : l + n = m) (Hn : divides 4 n)\n  (Hm : divides 4 m), divides 4 l.\nProof.\n  intros; generalize dependent l;\n    generalize dependent m; induction Hn; intros.\n  - rewrite <- plus_n_O in Hl; now rewrite Hl.\n  - rewrite PeanoNat.Nat.add_assoc in Hl.\n    specialize (IHHn _ Hm _ Hl); clear Hl.\n    rewrite plus_comm in IHHn; now inversion IHHn.\nQed.\n\nHint Resolve divides_4_diff : core.\n\nTheorem exists_P_iff_divides : exists m,\n  forall n, P n <-> divides m n.\nProof.\n  exists 4; intros; split; intros; induction H;\n    eauto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33348,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Arith.\n\nLemma divides_sum k : forall n m, divides k n -> divides k m -> divides k (n+m).\nProof.\n  intros n m Hn Hm.\n  induction Hn; [assumption|].\n  rewrite <- Nat.add_assoc.\n  constructor; assumption.\nQed.\n\nLemma minus_divides m : forall n, divides m n -> divides m (n - m).\nProof.\n  intros n Hn. induction Hn.\n  - rewrite Nat.sub_0_l; constructor.\n  - rewrite minus_plus; assumption.\nQed.\n\nLemma divides_diff k : forall l n m, l + n = m -> divides k n -> divides k m -> divides k l.\nProof.\n  intros l n m Heq Hn Hm.\n  revert l m Heq Hm.\n  induction Hn as [|n Hn IHn]; intros.\n  - rewrite Nat.add_0_r in Heq; subst; assumption.\n  - apply (IHn _ (m - k)).\n    + rewrite (Nat.add_comm k), Nat.add_assoc in Heq.\n      apply Nat.add_sub_eq_r in Heq.\n      congruence.\n    + apply minus_divides; assumption.\nQed.\n\nTheorem exists_P_iff_divides : exists m,\n  forall n, P n <-> divides m n.\nProof.\n  exists 4.\n  split; intros.\n  - induction H.\n    + repeat apply (add_divides 4); constructor.\n    + repeat apply (add_divides 4); constructor.\n    + repeat apply (add_divides 4); constructor.\n    + apply divides_sum; assumption.\n    + eapply divides_diff; eassumption.\n  - induction H.\n    + apply (P_diff 0 24 24); constructor.\n    + apply (P_sum 4 n); [|assumption].\n      apply (P_diff 4 20 24); try constructor.\n      apply (P_diff 20 40 60); constructor.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33349,"user_id":106,"body":"Require Import Preloaded.\n\nRequire Import Lia.\n\nLemma P_0: P 0.\nProof.\n  assert (0 + 60 = 60) as H by lia.\n  exact (P_diff _ _ _ H P_60 P_60).\nQed.\n\nLemma P_4: P 4.\nProof.\n  assert (4 + 60 = 64) as H by lia.\n  exact (P_diff _ _ _ H P_60 (P_sum _ _ P_24 P_40)).\nQed.\n\nLemma P_mul_4: forall n, P (4 * n).\nProof.\n  intros. induction n.\n  - apply P_0.\n  - replace (4 * S n) with (4 + (4 * n)) by lia.\n    exact (P_sum _ _ P_4 IHn).\nQed.\n\nLemma P_sep: forall n, P n <-> exists p, 4 * p = n.\nProof.\n  intros. split; intros.\n  - induction H.\n    + exists 6; lia.\n    + exists 10; lia.\n    + exists 15; lia.\n    + destruct IHP1 as [pn Hn], IHP2 as [pm Hm].\n      exists (pn + pm); lia.\n    + inversion H; subst; clear H;\n      try (destruct IHP1 as [p1 ?], IHP2 as [p2 ?]; exists (p2 - p1); lia).\n  - destruct H as [p H]; subst; apply P_mul_4.\nQed.\n\nLemma divides_mul: forall m p, divides m (p * m).\nProof.\n  intros. induction p; simpl; now constructor.\nQed.\n\nLemma divides_sep: forall m n, divides m n <-> exists p, m * p = n.\nProof.\n  intros. split; intros.\n  - induction H as [|n H IH].\n    + now exists 0.\n    + destruct IH as [p IH]. exists (S p); lia.\n  - destruct H as [p H]. rewrite <- H, PeanoNat.Nat.mul_comm. apply divides_mul.\nQed.\n\nTheorem exists_P_iff_divides : exists m,\n  forall n, P n <-> divides m n.\nProof.\n  intros. exists 4; intros. now rewrite P_sep, divides_sep.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5ca40e41bfaf24001980d07a":[{"id":33350,"user_id":568,"body":"Require Import Preloaded.\nRequire Import FunInd NArith ssreflect.\nImport N.\n\nFixpoint decode_positive (p : positive) : nat # nat :=\n  match p with\n  | xH => (O, O)\n  | xI p' => (O, Pos.to_nat p')\n  | xO p' => let: (c, x) := decode_positive p' in (S c, x)\n  end.\n\nFunctional Scheme decode_positive_ind :=\n  Induction for decode_positive Sort Prop.\n\nFixpoint encode_positive (n m : nat) : positive :=\n  match n, m with\n  | O, O => xH\n  | O, S m' => xI (Pos.of_succ_nat m')\n  | S n', _ => xO (encode_positive n' m)\n  end.\n\nFunctional Scheme encode_positive_ind :=\n  Induction for encode_positive Sort Prop.\n\nTheorem iso_refl : forall A : Set, iso A A.\nProof.\n  intro.\n  refine {|\n    A_to_B := fun x => x ;\n    B_to_A := fun x => x ;\n  |}; auto.\nDefined.\n\nTheorem iso_trans : forall A B C : Set, iso A B -> iso B C -> iso A C.\nProof.\n  intros A B C Hab Hbc.\n  destruct Hab as [ ab ba baab abba ].\n  destruct Hbc as [ bc cb cbbc bccb ].\n  econstructor.\n  Unshelve.\n  3,4: intuition.\n  1,2: intro; simpl; congruence.\nDefined.\n\nLemma encode_positive_positive :\n  forall p, encode_positive 0 (Pos.to_nat p) = xI p.\nProof.\n  move => p.\n  rewrite [Pos.to_nat _]Lt.S_pred_pos.\n  { apply : Pnat.Pos2Nat.is_pos. }\n  rewrite \/encode_positive Pos.of_nat_succ.\n  rewrite -Lt.S_pred_pos.\n  { apply : Pnat.Pos2Nat.is_pos. }\n  by rewrite Pnat.Pos2Nat.id.\nQed.\n\nLemma positive_iso_natxnat : iso positive (nat # nat).\nProof.\n  refine {|\n    A_to_B := fun x => decode_positive x ;\n    B_to_A := fun x => let: (n, m) := x in encode_positive n m;\n  |}.\n  - move => a.\n    elim\/decode_positive_ind : (decode_positive a).\n    + move => p p' _.\n      apply encode_positive_positive.\n    + move => p p' _ H c x HD.\n      rewrite HD in H.\n      by rewrite \/encode_positive -\/encode_positive H.\n    + by move => p _.\n  - case => a b.\n    elim : a.\n    + case : b.\n      * done.\n      * move => b' \/=.\n        by rewrite Pnat.SuccNat2Pos.id_succ.\n    + move => a' IH \/=.\n      by rewrite IH.\nDefined.\n\nLemma nat_iso_natxnat : iso nat (nat # nat).\nProof.\n  apply : iso_trans.\n  - refine {|\n      A_to_B := Pos.of_succ_nat;\n      B_to_A := fun x => Nat.pred (Pos.to_nat x);\n    |}.\n    + move => a.\n      by rewrite Pnat.SuccNat2Pos.id_succ.\n    + move => a.\n      rewrite Pos.of_nat_succ.\n      rewrite -Lt.S_pred_pos.\n      { apply : Pnat.Pos2Nat.is_pos. }\n      apply : Pnat.Pos2Nat.id.\n  - apply positive_iso_natxnat.\nDefined.\n\nTheorem nat_iso_nat_power : forall n, iso nat (nat ^^ S n).\nProof.\n  elim => \/=.\n  - refine {|\n      A_to_B := fun x => (x, tt);\n      B_to_A := fst;\n    |}.\n    + done.\n    + move => [ a' [] ] \/\/.\n  - move => n' IH.\n    apply : iso_trans.\n    + apply : IH.\n    + case : nat_iso_natxnat => f g gf fg.\n      refine {|\n        A_to_B := fun (x : nat # nat ^^ n') => let (u, c) := x in let (p, q) := f u in (p, (q, c));\n        B_to_A := fun x => let (p, z) := x in let (q, c) := z in (g (p, q), c);\n      |}.\n      * move => [a b] \/\/=.\n        move efa: (f a) => [].\n        move => b0 <-.\n        by rewrite gf.\n      * move => [ a [ b c ] ] \/\/=.\n        by rewrite fg.\nDefined.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33351,"user_id":489,"body":"From Coq Require Import Arith Lia.\nRequire Import Preloaded.\nImport Nat.\n\nTheorem iso_trans : forall A B C : Set, iso A B -> iso B C -> iso A C.\nProof. intros A B C HAB HBC. destruct HAB as [A2B B2A ABA BAB], HBC as [B2C C2B BCB CBC].\n  apply (bijection A C (fun x => B2C (A2B x)) (fun x => B2A (C2B x))).\n  - intros a; simpl. rewrite BCB. auto.\n  - intros c; simpl. rewrite BAB. auto. Qed.\n\nTheorem bijection_alt : forall (A B : Set) (A2B : A -> B) (B2A : B -> A),\n  (forall a, B2A (A2B a) = a) -> (forall b1 b2, B2A b1 = B2A b2 -> b1 = b2) -> iso A B.\nProof. intros A B A2B B2A ABA B2A_inj. apply (bijection A B A2B B2A ABA). intros b.\n  apply (B2A_inj (A2B (B2A b)) b (ABA (B2A b))). Qed.\n\n(* Task 1. Prove that nat has the same cardinality as nat * nat. *)\n\nDefinition suc_pair (xy : nat # nat) : nat # nat := match xy with\n  | (O, y) => (S y, O)\n  | (S x, y) => (x, S y)\n  end.\n\nFixpoint nat_natxnat (n : nat) : nat # nat := match n with\n  | O => (O, O)\n  | S n' => suc_pair (nat_natxnat n')\n  end.\n\nDefinition natxnat_nat (xy : nat # nat) : nat := match xy with\n  | (x, y) => div2 ((x + y) * S (x + y)) + y\n  end.\n\nLemma div2_extract : forall n m, div2 (n + n + m) = n + div2 m.\nProof. induction n; intros; auto. replace (S n + S n + m) with (S (S (n + n + m))) by ring.\n  simpl. rewrite IHn. auto. Qed.\n\nLemma suc_pair_is_suc : forall xy, natxnat_nat (suc_pair xy) = S (natxnat_nat xy).\nProof. intros [[| x] y].\n  - unfold suc_pair, natxnat_nat.\n    replace ((S y + 0) * S (S y + 0)) with (S y + S y + y * S y) by ring.\n    rewrite div2_extract. simpl. ring.\n  - unfold suc_pair, natxnat_nat.\n    replace ((x + S y) * S (x + S y)) with ((S x + y) * S (S x + y)) by ring. ring. Qed.\n\nTheorem nat_natxnat_nat : forall n, natxnat_nat (nat_natxnat n) = n.\nProof. induction n; auto. simpl. rewrite suc_pair_is_suc. congruence. Qed.\n\nLemma tri_form : forall n, div2 (S n * S (S n)) = S n + div2 (n * S n).\nProof. intros n. replace (S n * S (S n)) with (S n + S n + n * S n) by ring. apply div2_extract. Qed.\n\nLemma lemma_m1 : forall m n q, n <= m -> div2 (m * S m) + n = div2 (S m * S (S m)) + q -> False.\nProof. intros m n q H H0. rewrite tri_form in H0.\n  replace (S m + div2 (m * S m) + q) with (div2 (m * S m) + (S m + q)) in H0 by ring.\n  apply plus_reg_l in H0. lia. Qed.\n\nLemma lemma_m2 : forall n m, n * S n <= (n + m) * S (n + m).\nProof. intros. ring_simplify. lia. Qed.\n\nTheorem nat_ind2 : forall P : nat -> Prop, P 0 -> P 1 -> (forall n, P n -> P (S (S n))) -> forall n, P n.\nProof. fix nat_ind2 5. intros. destruct n as [| [| n]]; auto. apply H1. apply nat_ind2; auto. Qed.\n\nLemma div2_le_S : forall n, div2 n <= div2 (S n).\nProof. induction n using nat_ind2; simpl; try simpl in IHn; lia. Qed.\nLemma div2_le : forall n m, n <= m -> div2 n <= div2 m.\nProof. intros n m H; induction H; auto. set (div2_le_S m). lia. Qed.\n\nLemma lemma_0 : forall m n p q, n <= m -> div2 (m * S m) + n <> div2 ((S (m + p)) * S (S (m + p))) + q.\nProof. intros m n p q H H0. rewrite tri_form in H0.\n  replace (S (m + p) + div2 ((m + p) * S (m + p)) + q) with\n    (div2 ((m + p) * S (m + p)) + (S m + (p + q))) in H0 by ring.\n  set (div2_le _ _ (lemma_m2 m p)). lia. Qed.\n\nLemma lt_diff : forall n m, n < m -> exists k, S (n + k) = m.\nProof. intros n m H. unfold \"<\" in H. remember (S n) as sn. induction H.\n  - exists 0; lia.\n  - destruct IHle as [k IHle]. exists (S k); lia. Qed.\n\nLemma lemma : forall m n p q, natxnat_nat (m, n) = natxnat_nat (p, q) -> m + n = p + q.\nProof. intros m n p q H. destruct (m + n ?= p + q) eqn:E.\n  - auto using compare_eq.\n  - apply compare_lt_iff in E. set (F := E). apply lt_diff in F. destruct F as [k F]. simpl in H.\n    rewrite <- F in H. eapply lemma_0 in H; lia.\n  - apply compare_gt_iff in E. set (F := E). apply lt_diff in F. destruct F as [k F]. simpl in H.\n    rewrite <- F in H. symmetry in H. eapply lemma_0 in H; lia. Qed.\n\nLemma natxnat_nat_inj : forall mn pq, natxnat_nat mn = natxnat_nat pq -> mn = pq.\nProof. intros [m n] [p q] H. set (H0 := H); apply lemma in H0. simpl in H.\n  rewrite H0 in H. assert (n = q). lia. assert (m = p). lia. rewrite H1, H2; auto. Qed.\n\nDefinition nat_iso_natxnat : iso nat (nat # nat) :=\n  bijection_alt _ _ nat_natxnat natxnat_nat nat_natxnat_nat natxnat_nat_inj.\n\n(* Task 2. Prove that nat has the same cardinality as nat ^ n, where n is nonzero and finite. *)\nLemma iso_prod_l (A B C : Set) (H : iso A B) : iso (C # A) (C # B).\nProof. destruct H as [ab ba aba bab].\n  apply (bijection _ _\n    (fun ca => match ca with (c, a) => (c, ab a) end)\n    (fun cb => match cb with (c, b) => (c, ba b) end));\n  intros []; [rewrite aba | rewrite bab]; auto. Qed.\n\nLemma iso_prod_unit : forall A : Set, iso A (A # unit).\nProof. intros. apply (bijection _ _ (fun a => (a, tt)) (fun b => fst b)); auto.\n  intros [a []]; auto. Qed.\n\nTheorem nat_iso_nat_power : forall n, iso nat (nat ^^ S n).\nProof. induction n.\n  - apply iso_prod_unit.\n  - simpl in IHn |- *. apply iso_prod_l with (C := nat) in IHn.\n    apply iso_trans with (B := nat # nat); auto using nat_iso_natxnat. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33352,"user_id":null,"body":"Require Import Preloaded.\n\nRequire Import ZArith.\n\nTheorem nat_iso_pos : iso nat positive.\nProof.\n  apply bijection with Pos.of_succ_nat (fun p => pred (Pos.to_nat p)).\n  - apply SuccNat2Pos.pred_id.\n  - intros; destruct (Pos2Nat.is_succ b) as [a Ha]; rewrite Ha; simpl.\n    now rewrite Pos.of_nat_succ, <- Ha, Pos2Nat.id.\nDefined.\n\nFixpoint pos2natxnat (p : positive) : nat # nat :=\n  match p with\n  | xH => (0, 0)\n  | xO p' => (0, Pos.to_nat p')\n  | xI p' => let (x, y) := pos2natxnat p' in (S x, y)\n  end.\n\nFixpoint natxnat2pos (n m : nat) : positive :=\n  match n with\n  | 0 => match m with\n    | 0 => xH\n    | S m' => xO (Pos.of_nat m)\n    end\n  | S n' => xI (natxnat2pos n' m)\n  end.\n\nTheorem pos_iso_natxnat : iso positive (nat # nat).\nProof.\n  apply bijection with pos2natxnat (fun t => natxnat2pos (fst t) (snd t)).\n  - induction a.\n    + simpl; destruct (pos2natxnat a) as [x y]; simpl in *; now rewrite IHa.\n    + simpl; destruct (Pos2Nat.is_succ a) as [a' Ha']; now rewrite Ha', <- Ha', Pos2Nat.id.\n    + easy.\n  - intros [x y]; simpl; induction x.\n    + destruct y; [easy|]; unfold natxnat2pos, pos2natxnat; now rewrite Nat2Pos.id.\n    + simpl; now rewrite IHx.\nDefined.\n\nTheorem iso_trans : forall A B C : Set, iso A B -> iso B C -> iso A C.\nProof.\n  intros A B C [AB BA ABA BAB] [BC CB BCB CBC]; apply bijection with (fun a => BC (AB a)) (fun c => BA (CB c)).\n  - intros; now rewrite BCB, ABA.\n  - intros; now rewrite BAB, CBC.\nDefined.\n\n(* Task 1. Prove that nat has the same cardinality as nat * nat. *)\n\nTheorem nat_iso_natxnat : iso nat (nat # nat).\nProof.\n  apply iso_trans with positive, pos_iso_natxnat; apply nat_iso_pos.\nDefined.\n\n(* Task 2. Prove that nat has the same cardinality as nat ^ n, where n is nonzero and finite. *)\n\nTheorem nat_iso_nat_power : forall n, iso nat (nat ^^ S n).\nProof.\n  induction n.\n  - apply bijection with (fun n => (n, tt)) fst.\n    + easy.\n    + now intros [n []].\n  - apply iso_trans with (nat # nat); [apply nat_iso_natxnat|].\n    destruct IHn as [AB BA ABA BAB].\n    apply bijection with (fun t => (fst t, AB (snd t))) (fun t => (fst t, BA (snd t))).\n    + intros []; simpl; now rewrite ABA.\n    + intros []; simpl; now rewrite BAB.\nDefined.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33353,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Arith.\n\n(* Any set has the same cardinality as itself. *)\nTheorem iso_refl : forall A : Set, iso A A.\nProof.\n  intros A; apply bijection with (fun x => x) (fun x => x); easy.\nQed.\n\n(* iso is symmetric. *)\nTheorem iso_sym : forall A B : Set, iso A B -> iso B A.\nProof.\n  intros A B AB; apply bijection with (B_to_A _ _ AB) (A_to_B _ _ AB).\n  - apply B_A_B.\n  - apply A_B_A.\nQed.\n\n(* iso is transitive. *)\nTheorem iso_trans : forall A B C : Set, iso A B -> iso B C -> iso A C.\nProof.\n  intros A B C AB BC; apply bijection with\n    (fun x => (A_to_B _ _ BC (A_to_B _ _ AB x)))\n    (fun x => (B_to_A _ _ AB (B_to_A _ _ BC x))).\n  - intros a; now repeat rewrite A_B_A.\n  - intros c; now repeat rewrite B_A_B.\nQed.\n\n(* Two isos can be applied on tuples *)\nTheorem iso_tuple : forall A B C D : Set, iso A B -> iso C D -> iso (A # C) (B # D).\nProof.\n  intros A B C D AB CD. apply bijection with\n    (fun x => (A_to_B _ _ AB (fst x), A_to_B _ _ CD (snd x)))\n    (fun x => (B_to_A _ _ AB (fst x), B_to_A _ _ CD (snd x))).\n  - intros [a c]; simpl; now repeat rewrite A_B_A.\n  - intros [b d]; simpl; now repeat rewrite B_A_B.\nQed.\n\n(* Given two functions A->B and B->A, if A->B->A is satisfied and B->A is injective, A <=> B. *)\nTheorem bijection_alt : forall (A B : Set) (A2B : A -> B) (B2A : B -> A),\n  (forall a, B2A (A2B a) = a) -> (forall b1 b2, B2A b1 = B2A b2 -> b1 = b2) -> iso A B.\nProof.\n  intros A B A2B B2A ABA H.\n  apply bijection with A2B B2A; [apply ABA|].\n  intros b; apply H; now rewrite ABA.\nQed.\n\n(* Task 1. Prove that nat has the same cardinality as nat * nat. *)\nFixpoint n2tn (n : nat) : nat # nat :=\n  match n with\n  | 0 => (0, 0)\n  | S n' => match n2tn n' with\n    | (x, 0) => (0, S x)\n    | (x, S y) => (S x, y)\n    end\n  end.\n\nDefinition tn2n_sig (t : nat # nat) : {n : nat | n2tn n = t}.\n  destruct t as [x y]; remember (x + y) as n; revert x y Heqn; induction n; intros.\n  - destruct x; [|easy]; destruct y; [|easy]; clear Heqn.\n    now apply exist with 0.\n  - revert y Heqn; induction x as [|x]; intros.\n    + destruct y; [easy|]; inversion Heqn; subst; clear Heqn.\n      destruct (IHn y 0 (plus_n_O _)) as [n Hn].\n      apply exist with (S n); simpl; now rewrite Hn.\n    + inversion Heqn; subst; clear Heqn.\n      destruct (IHx (S y) (plus_n_Sm _ _)) as [n Hn].\n      apply exist with (S n); simpl; now rewrite Hn.\nDefined.\n\nDefinition tn2n (t : nat # nat) : nat := match tn2n_sig t with exist _ n _ => n end.\n\nTheorem nat_iso_natxnat : iso nat (nat # nat).\n  apply iso_sym, (bijection_alt _ _ tn2n n2tn).\n  - intros t; unfold tn2n; now destruct (tn2n_sig t).\n  - induction b1; simpl; intros b2 Heq.\n    + destruct b2; [easy|contradict Heq].\n      simpl; now destruct (n2tn b2) as [x [|y]].\n    + destruct b2; [now destruct (n2tn b1) as [x [|y]]|].\n      rewrite (IHb1 b2); [easy|].\n      simpl in Heq; destruct (n2tn b1) as [x1 [|y1]], (n2tn b2) as [x2 [|y2]]; try easy.\n      * inversion Heq; now subst.\n      * inversion Heq; now subst.\nQed.\n\n(* Task 2. Prove that nat has the same cardinality as nat ^ n, where n is nonzero and finite. *)\nTheorem nat_iso_nat_power : forall n, iso nat (nat ^^ S n).\nProof.\n  induction n.\n  - apply bijection with (fun n => (n, tt)) fst; [easy|].\n    now intros [n []].\n  - apply iso_trans with (nat # nat); [apply nat_iso_natxnat|].\n    apply iso_tuple; [apply iso_refl|apply IHn].\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33354,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Arith.\n\n(* Any set has the same cardinality as itself. *)\nTheorem iso_refl : forall A : Set, iso A A.\nProof.\n  intros A; apply bijection with (fun x => x) (fun x => x); easy.\nQed.\n\n(* iso is transitive. *)\nTheorem iso_trans : forall A B C : Set, iso A B -> iso B C -> iso A C.\nProof.\n  intros A B C AB BC; apply bijection with\n    (fun x => (A_to_B _ _ BC (A_to_B _ _ AB x)))\n    (fun x => (B_to_A _ _ AB (B_to_A _ _ BC x))).\n  - intros a; now repeat rewrite A_B_A.\n  - intros c; now repeat rewrite B_A_B.\nQed.\n\n(* Two isos can be applied on tuples *)\nTheorem iso_tuple : forall A B C D : Set, iso A B -> iso C D -> iso (A # C) (B # D).\nProof.\n  intros A B C D AB CD. apply bijection with\n    (fun x => (A_to_B _ _ AB (fst x), A_to_B _ _ CD (snd x)))\n    (fun x => (B_to_A _ _ AB (fst x), B_to_A _ _ CD (snd x))).\n  - intros [a c]; simpl; now repeat rewrite A_B_A.\n  - intros [b d]; simpl; now repeat rewrite B_A_B.\nQed.\n\n(* Given two functions A->B and B->A, if A->B->A is satisfied and B->A is injective, A <=> B. *)\nTheorem bijection_alt : forall (A B : Set) (A2B : A -> B) (B2A : B -> A),\n  (forall a, B2A (A2B a) = a) -> (forall b1 b2, B2A b1 = B2A b2 -> b1 = b2) -> iso A B.\nProof.\n  intros A B A2B B2A ABA H.\n  apply bijection with A2B B2A; [apply ABA|].\n  intros b; apply H; now rewrite ABA.\nQed.\n\n(* Task 1. Prove that nat has the same cardinality as nat * nat. *)\nFixpoint triangle (n : nat) : nat :=\n  match n with\n  | 0 => 0\n  | S n' => n + triangle n'\n  end.\n\nDefinition tn2n (t : nat # nat) : nat := match t with (x, y) => x + triangle(x + y) end.\n\nDefinition n2tn_sig (n : nat) : {t : nat # nat | tn2n t = n}.\n  induction n.\n  - now apply exist with (0, 0).\n  - destruct IHn as [[x [|y]] Hxy].\n    + apply exist with (0, S x).\n      simpl in *; rewrite <- plus_n_O in Hxy; now subst.\n    + apply exist with (S x, y).\n      unfold tn2n in *; rewrite (plus_Snm_nSm _ y); now subst.\nDefined.\n\nDefinition n2tn (n : nat) : nat # nat := match n2tn_sig n with exist _ t _ => t end.\n\nLemma triangle_lt_next : forall x y, x + triangle (x + y) < triangle (S (x + y)).\nProof.\n  intros x y; simpl; apply le_n_S.\n  transitivity ((x + triangle (x + y)) + y); [apply le_plus_l|].\n  apply Nat.eq_le_incl; ring.\nQed.\n\nLemma triangle_le_mono : forall x y, x <= y -> triangle x <= triangle y.\nProof.\n  induction x; intros y Hle.\n  - apply le_0_n.\n  - destruct y; [inversion Hle|].\n    apply le_S_n in Hle.\n    simpl; apply le_n_S; transitivity (y + triangle x); [|apply Nat.add_le_mono_l, IHx, Hle].\n    apply Nat.add_le_mono_r, Hle.\nQed.\n\nTheorem nat_iso_natxnat : iso nat (nat # nat).\n  apply (bijection_alt _ _ n2tn tn2n).\n  - intros n; unfold n2tn; now destruct (n2tn_sig n).\n  - unfold tn2n; intros [x1 y1] [x2 y2] Heq.\n    cut (x1 + y1 = x2 + y2).\n    { intros H; rewrite H in Heq.\n      repeat rewrite (Nat.add_comm _ (triangle _)) in Heq; apply plus_reg_l in Heq.\n      subst; apply plus_reg_l in H; now subst. }\n    destruct (lt_eq_lt_dec (x1 + y1) (x2 + y2)) as [[F|H]|F]; [|easy|].\n    + symmetry in Heq; apply Nat.eq_le_incl in Heq; contradict Heq; apply lt_not_le.\n      apply lt_le_trans with (triangle (S (x1 + y1))); [apply triangle_lt_next|].\n      transitivity (triangle (x2 + y2)); [apply triangle_le_mono, F|].\n      apply le_plus_r.\n    + apply Nat.eq_le_incl in Heq; contradict Heq; apply lt_not_le.\n      apply lt_le_trans with (triangle (S (x2 + y2))); [apply triangle_lt_next|].\n      transitivity (triangle (x1 + y1)); [apply triangle_le_mono, F|].\n      apply le_plus_r.\nQed.\n\n(* Task 2. Prove that nat has the same cardinality as nat ^ n, where n is nonzero and finite. *)\n\nTheorem nat_iso_nat_power : forall n, iso nat (nat ^^ S n).\nProof.\n  induction n.\n  - apply bijection with (fun n => (n, tt)) fst; [easy|].\n    now intros [n []].\n  - apply iso_trans with (nat # nat); [apply nat_iso_natxnat|].\n    apply iso_tuple; [apply iso_refl|apply IHn].\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33355,"user_id":null,"body":"Require Import Preloaded Arith.\n\nTheorem iso_trans : forall A B C : Set, iso A B -> iso B C -> iso A C.\nProof.\n  intros A B C [f F Ff fF] [g G Gg gG];\n  apply (bijection _ _ (fun x => g (f x)) (fun x => F (G x))); intros.\n  - rewrite Gg, Ff; reflexivity.\n  - rewrite fF, gG; reflexivity.\nQed.\n\nTheorem iso_tup : forall (A B C : Set), iso A B -> iso (C # A) (C # B).\nProof.\n  intros A B C [f F Ff fF];\n  apply (bijection _ _ (fun t => (fst t, f (snd t))) (fun t => (fst t, F (snd t)))).\n  - intros [c a]; simpl; rewrite Ff; reflexivity.\n  - intros [c b]; simpl; rewrite fF; reflexivity.\nQed.\n\n(* Task 1. Prove that nat has the same cardinality as nat * nat. *)\nFixpoint nat2nattnat (n : nat) : nat # nat :=\n  match n with\n  | 0 => (0, 0)\n  | S n' => match nat2nattnat n' with\n    | (0, m) => (S m, 0)\n    | (S n'', m) => (n'', S m)\n    end\n  end.\n\nFixpoint sumofnats (n : nat) : nat :=\n  match n with\n  | 0 => 0\n  | S n' => n + sumofnats n'\n  end.\n\nDefinition nattnat2nat (t : nat # nat) : nat :=\n  match t with (a, b) => sumofnats (a + b) + b end.\n\nTheorem nat_iso_natxnat : iso nat (nat # nat).\nProof.\n  apply (bijection _ _ nat2nattnat nattnat2nat).\n  - induction a.\n    + reflexivity.\n    + simpl; destruct (nat2nattnat a), n.\n      * simpl; rewrite <- IHa, (Nat.add_0_r n0); simpl; ring.\n      * simpl; rewrite <- IHa, (Nat.add_succ_r n); simpl; ring.\n  - intros [a b]; simpl; remember (a + b); revert a b Heqn; induction n; intros.\n    + destruct a, b; try discriminate; reflexivity.\n    + revert a Heqn; induction b; intros.\n      * destruct a; [discriminate|]; specialize (IHn 0 n eq_refl).\n        assert (sumofnats (S n) + 0 = S (sumofnats n + n)) as H; [simpl; ring|rewrite H; clear H].\n        simpl; rewrite IHn, Heqn, Nat.add_0_r; reflexivity.\n      * assert (sumofnats (S n) + S b = S (sumofnats (S n) + b)) as H; [simpl; ring|rewrite H; clear H].\n        unfold nat2nattnat; fold nat2nattnat; rewrite (IHb (S a)); [reflexivity|rewrite Heqn]; ring.\nQed.\n\n(* Task 2. Prove that nat has the same cardinality as nat ^ n, where n is nonzero and finite. *)\n\nTheorem nat_iso_nat_power : forall n, iso nat (nat ^^ S n).\nProof.\n  induction n.\n  - apply (bijection _ _ (fun n => (n, tt)) fst).\n    + intros; reflexivity.\n    + intros [b t]; destruct t; reflexivity.\n  - apply (iso_trans _ (nat # nat)); [apply nat_iso_natxnat|apply iso_tup, IHn].\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33356,"user_id":null,"body":"Require Import Preloaded Arith Lia.\n(* Unlike Agda, Coq has a feature to print the definition of any variables, so\n   you should copy your own solution for these properties if you want to use them.\n   These theorems are not tested. *)\n\n(* iso is symmetric. *)\nTheorem iso_sym : forall A B : Set, iso A B -> iso B A.\nProof.\n  intros.\n  destruct H as [AB BA ABA BAB].\n  apply (bijection _ _ BA AB); auto.\nQed.\n\nDefinition compose {A B C} (f : B -> C) (g : A -> B) := fun x => f (g x).\n\n(* iso is transitive. *)\nTheorem iso_trans : forall A B C : Set, iso A B -> iso B C -> iso A C.\nProof.\n  intros.\n  destruct H as [AB BA ABA BAB], H0 as [BC CB BCB CBC].\n  apply (bijection _ _\n    (compose BC AB)\n    (compose BA CB));\n    unfold compose; intros;\n    try rewrite BCB;\n    try rewrite BAB;\n    auto.\nQed.\n\n(* Given two functions A->B and B->A, if A->B->A is satisfied and B->A is injective, A <=> B. *)\nTheorem bijection_alt : forall (A B : Set) (A2B : A -> B) (B2A : B -> A),\n  (forall a, B2A (A2B a) = a) -> (forall b1 b2, B2A b1 = B2A b2 -> b1 = b2) -> iso A B.\nProof.\n  intros.\n  apply (bijection _ _ A2B B2A); auto.\nQed.\n\n(* Task 1. Prove that nat has the same cardinality as nat * nat. *)\n\nFixpoint triangle n := match n with\n  | 0 => 0\n  | S n => S n + triangle n\n  end.\n\nDefinition cantor '(n, m) := triangle (n + m) + m.\n\nDefinition next_pair p := match p with\n  |   (0, m) => (S m, 0)\n  | (S n, m) => (n, S m)\n  end.\n\nDefinition uncantor n := Nat.iter n next_pair (0, 0).\n\nLemma iter_plus : forall n m A f (x : A),\n  Nat.iter (n + m) f x = Nat.iter n f (Nat.iter m f x).\nProof.\n  induction n; intros; auto.\n  simpl. f_equal. auto.\nQed.\n\nLemma iter_np_multi : forall m n, Nat.iter m next_pair (n + m, 0) = (n, m).\nProof.\n  induction m; simpl; auto.\n  intros.\n  replace (n + S m) with (S n + m) by lia.\n  rewrite IHm. auto.\nQed.\n\nLemma unc_triangle : forall n, uncantor (triangle n) = (n, 0).\nProof.\n  induction n; simpl; auto.\n  unfold uncantor in *.\n  rewrite iter_plus.\n  rewrite IHn.\n  replace (n, 0) with (0 + n, 0) by auto.\n  rewrite iter_np_multi. auto.\nQed.\n\nLemma next_pair_inj : forall p q, next_pair p = next_pair q -> p = q.\nProof.\n  intros [pa pb] [qa qb].\n  destruct pa; destruct qa; simpl; intros;\n    try discriminate;\n    inversion H; auto.\nQed.\n\nTheorem nat_iso_natxnat : iso nat (nat # nat).\nProof.\n  apply iso_sym.\n  apply (bijection_alt _ _ cantor uncantor).\n  - intros.\n    destruct a as [n m].\n    unfold cantor, uncantor.\n    rewrite plus_comm.\n    rewrite iter_plus.\n    pose proof unc_triangle.\n    unfold uncantor in H.\n    rewrite H.\n    apply iter_np_multi.\n  - induction b1; destruct b2; simpl; auto; intros;\n      auto using next_pair_inj;\n      [ destruct (uncantor b2) as [x y]\n      | destruct (uncantor b1) as [x y] ];\n      destruct x; destruct y; discriminate.\nQed.\n\n(* Task 2. Prove that nat has the same cardinality as nat ^ n, where n is nonzero and finite. *)\n\nLemma iso_cong : forall (A B C : Set), iso B C -> iso (A # B) (A # C).\nProof.\n  intros.\n  destruct H as [BC CB BCB CBC].\n  apply (bijection _ _ (fun '(a, b) => (a, BC b))\n                       (fun '(a, c) => (a, CB c))).\n  - destruct a.\n    rewrite BCB. auto.\n  - destruct b.\n    rewrite CBC. auto.\nQed.\n\nTheorem nat_iso_nat_power : forall n, iso nat (nat ^^ S n).\nProof.\n  induction n; simpl in *.\n  - apply (bijection _ _ (fun n => (n, tt)) (fun '(n, _) => n)); auto.\n    destruct b. destruct u. auto.\n  - apply iso_trans with (nat # nat).\n    + apply nat_iso_natxnat.\n    + auto using iso_cong.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33357,"user_id":null,"body":"Require Import Preloaded ssreflect Arith Lia.\n\n(* iso is transitive. *)\nTheorem iso_trans : forall A B C : Set, iso A B -> iso B C -> iso A C.\nProof.\n  move=> A B C [f f' ? ?] [g g' ? ?].\n  apply (bijection _ _ (fun x => g (f x)) (fun y => f' (g' y))); congruence.\nQed.\n\n(* Given two functions A->B and B->A, if A->B->A is satisfied and B->A is injective, A <=> B. *)\nTheorem bijection_alt : forall (A B : Set) (A2B : A -> B) (B2A : B -> A),\n  (forall a, B2A (A2B a) = a) -> (forall b1 b2, B2A b1 = B2A b2 -> b1 = b2) -> iso A B.\nProof.\n  move=> A B f g H1 H2; apply (bijection _ _ f g); auto.\nQed.\n\n(* Task 1. Prove that nat has the same cardinality as nat * nat. *)\n\nDefinition g' m n := (m + n) * (m + n + 1) \/ 2 + m.\n\nDefinition f' n : { p & n = g' (fst p) (snd p) }.\nProof.\n  elim: n; first by exists (0, 0) => \/\/.\n  move=> n [[x y] \/= IH].\n  case eqn: (y =? 0).\n  - move\/Nat.eqb_eq: eqn => ?; subst y.\n    exists (0, x + 1).\n    move: IH; rewrite\/g'\/fst\/snd => ->.\n    rewrite -Nat.add_1_r plus_assoc !Nat.add_0_r Nat.add_0_l.\n    rewrite (_: (x + 1) * (x + 1 + 1) = (x + 1) * x + (x + 1) * 2); first lia.\n    rewrite Nat.div_add \/\/ plus_assoc.\n    do 2 congr (_+_); congr (_\/_); lia.\n  - move\/Nat.eqb_neq: eqn => ?.\n    exists (x + 1, y - 1).\n    rewrite IH \/= \/g'.\n    rewrite -Nat.add_1_r plus_assoc.\n    do 2 congr (_+_); congr (_\/_); nia.\nDefined.\n\nDefinition f n := projT1 (f' n).\n\nLemma f_spec : forall n, let (x, y) := f n in n = g' x y.\nProof.\n  move=> n; case eqn: (f n) => \/=.\n  rewrite (projT2 (f' n)).\n  by move: eqn; rewrite \/f => ->.\nQed.\n\nTheorem nat_iso_natxnat : iso nat (nat # nat).\nProof.\n  set (g (p : nat # nat) := let (m, n) := p in g' m n).\n  apply (bijection_alt _ _ f g).\n  - by move=> n; move: (f_spec n); case e: (f n) => ->.\n  - move=>[a b] [c d]; rewrite \/g\/g' => H.\n    have: a + b = c + d. {\n      wlog:a b c d H\/ a + b <= c + d.\n      - have: a + b <= c + d \\\/ c + d <= a + b by lia.\n        case; first by auto.\n        by move=> ?; move\/(_ c d a b) => ->.\n      - move=> ?.\n        have: a + b = c + d \\\/ a + b < c + d by lia.\n        case; first done.\n        move=> Hlt.\n        suff: (a + b) * (a + b + 1) \/ 2 + a < (c + d) * (c + d + 1) \/ 2 + c\n          by lia.\n        suff: (a + b) * (a + b + 1) \/ 2 + a <= (a + b) * (a + b + 1) \/ 2 + a + b \/\\\n              (a + b) * (a + b + 1) \/ 2 + a + b < (a + b + 1) * (a + b + 2) \/ 2 \/\\\n              (a + b + 1) * (a + b + 2) \/ 2 <= (c + d) * (c + d + 1) \/ 2\n          by lia.\n        split; first lia.\n        split.\n        + rewrite (_: forall x, (x + 1) * (x + 2) = (x + 1) * x + (x + 1) * 2); first lia.\n          rewrite Nat.div_add \/\/ plus_assoc.\n          by rewrite mult_comm !plus_assoc; lia.\n        + suff: forall x y, x < y -> (x + 1) * (x + 2) \/ 2 <= y * (y + 1) \/ 2\n            by apply.\n          move=> x y ?.\n          apply Nat.div_le_mono => \/\/.\n          nia.\n    }\n    move=> Heq; move: H; rewrite Heq => H.\n    have: a = c by lia.\n    move=> ?; f_equal; lia.\nQed.\n\n(* Task 2. Prove that nat has the same cardinality as nat ^ n, where n is nonzero and finite. *)\n\nLemma iso_congr (A B C : Set) : iso A B -> iso (C # A) (C # B).\nProof.\n  case=> [f g ? ?].\n  set (f' (p : C # A) := let (c, a) := p in (c, f a)).\n  set (g' (q : C # B) := let (c, b) := q in (c, g b)).\n  apply (bijection _ _ f' g'); rewrite \/f' \/g' => -[]; congruence.\nQed.\n\nTheorem nat_iso_nat_power : forall n, iso nat (nat ^^ S n).\nProof.\n  elim.\n  - apply (bijection _ _ (fun n => (n, tt)) (@fst _ _)); auto.\n    by move=> [? []].\n  - move=> n \/= IH.\n    apply (iso_trans _ (nat # nat) _).\n    + by apply nat_iso_natxnat.\n    + by apply iso_congr.\nQed.\n\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33358,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Arith List Recdef Lia.\nRequire Import Inverse_Image.\nImport ListNotations.\n\nInductive lex {A B} (R1 : A -> A -> Prop) (R2 : B -> B -> Prop) : A*B -> A*B -> Prop :=\n| lex_fst : forall a1 a2 b1 b2, R1 a1 a2 -> lex R1 R2 (a1, b1) (a2, b2)\n| lex_snd : forall a b1 b2, R2 b1 b2 -> lex R1 R2 (a, b1) (a, b2).\n\nLemma wf_lex : forall {A B} (R1 : A -> A -> Prop) (R2 : B -> B -> Prop),\n  well_founded R1 -> well_founded R2 -> well_founded (lex R1 R2).\nProof.\n  intros. intros (a, b). revert b.\n  induction a using (well_founded_ind H).\n  intros b. induction b using (well_founded_ind H0).\n  constructor.\n  intros (c, d) H3. inversion H3; subst; auto.\nQed.\n\nDefinition lt_cantor pp1 pp2 :=\n  lex lt lt (fst pp1 + snd pp1, fst pp1) (fst pp2 + snd pp2, fst pp2).\n\nLemma lt_cantor_wf : well_founded lt_cantor.\nProof.\n  unfold lt_cantor.\n  apply wf_inverse_image.\n  apply wf_lex; apply lt_wf.\nQed.\n\nFunction nat_of_natnat pp { wf lt_cantor pp } :=\n  match pp with\n  | (0, 0) => 0\n  | (0, S p2) => S (nat_of_natnat (p2, 0))\n  | (S p1, p2) => S (nat_of_natnat (p1, S p2))\n  end.\nProof.\n  - intros. apply lex_fst. cbn. lia.\n  - intros. unfold lt_cantor. cbn. rewrite Nat.add_succ_r. apply lex_snd. lia.\n  - apply lt_cantor_wf.\nDefined.\n\nFixpoint natnat_of_nat n :=\n  match n with\n  | 0 => (0, 0)\n  | S n => let '(n1, n2) := natnat_of_nat n in\n           match n2 with\n           | 0 => (0, S n1)\n           | S n2 => (S n1, n2)\n           end\n  end.\n\nLemma nat_of_natnat_of_nat : forall z, nat_of_natnat (natnat_of_nat z) = z.\nProof.\n  induction z.\n  - cbn. rewrite nat_of_natnat_equation. reflexivity.\n  - cbn.\n    destruct (natnat_of_nat z) as (n1, n2) eqn:Hnn.\n    destruct n2.\n    + rewrite nat_of_natnat_equation. lia.\n    + rewrite nat_of_natnat_equation. lia.\nQed.\n\nLemma natnat_of_nat_of_natnat : forall z, natnat_of_nat (nat_of_natnat z) = z.\nProof.\n  intros.\n  functional induction (nat_of_natnat z).\n  - reflexivity.\n  - cbn. rewrite IHn. reflexivity.\n  - cbn. rewrite IHn. reflexivity.\nQed.\n\nTheorem nat_iso_natxnat : iso nat (nat # nat).\nProof.\n  apply (bijection _ _ natnat_of_nat nat_of_natnat).\n  - apply nat_of_natnat_of_nat.\n  - apply natnat_of_nat_of_natnat.\nQed.\n\nLemma nat_iso_nat_unit : iso nat (nat # unit).\nProof.\n  set (A_to_B (n:nat) := (n, tt)).\n  set (B_to_A := fun '((n, tt) : nat # _) => n).\n  apply (bijection _ _ A_to_B B_to_A).\n  - reflexivity.\n  - intros (n, []). reflexivity.\nQed.\n\nTheorem nat_iso_nat_power : forall n, iso nat (nat ^^ S n).\nProof.\n  induction n as [|n is].\n  - cbn. apply nat_iso_nat_unit.\n  - change (nat ^^ S (S n)) with (nat # nat ^^ S n).\n    set (A2B n := let '(n1, n2) := nat_iso_natxnat.(A_to_B _ _) n in (n1, is.(A_to_B _ _) n2)).\n    set (B2A := fun '(n, p) => nat_iso_natxnat.(B_to_A _ _) (n, is.(B_to_A _ _) p)).\n    apply (bijection _ _ A2B B2A).\n    + intros. unfold A2B, B2A.\n      destruct (nat_iso_natxnat.(A_to_B _ _) a) as (n1, n2) eqn:Hnn.\n      rewrite is.(A_B_A _ _). rewrite <- Hnn.\n      rewrite nat_iso_natxnat.(A_B_A _ _).\n      reflexivity.\n    + intros (n1, n2). unfold A2B, B2A.\n      rewrite nat_iso_natxnat.(B_A_B _ _).\n      rewrite is.(B_A_B _ _).\n      reflexivity.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33359,"user_id":null,"body":"Require Import Preloaded Arith NArith List Recdef Lia.\nImport ListNotations.\n\n(* We use bit interleaving. *)\n\n(* Task 1. Prove that nat has the same cardinality as nat * nat. *)\n\nFixpoint insert_zeros p :=\n  match p with\n  | xH => xH\n  | xO p => xO (xO (insert_zeros p))\n  | xI p => xI (xO (insert_zeros p))\n  end.\n\nDefinition add0 n :=\n  match n with\n  | N0 => N0\n  | Npos p => Npos (xO p)\n  end.\n\nDefinition add1 n :=\n  match n with\n  | N0 => Npos xH\n  | Npos p => Npos (xI p)\n  end.\n\nFixpoint pospos_of_pos (p : positive) : N # N :=\n  match p with\n  | xH => (Npos xH, N0)\n  | xO p => let (a, b) := pospos_of_pos p in\n            (add0 b, a)\n  | xI p => let (a, b) := pospos_of_pos p in\n            (add1 b, a)\n  end.\n\nDefinition NN_of_N n :=\n  match n with\n  | N0 => (N0, N0)\n  | Npos p => pospos_of_pos p\n  end.\n\nLemma pospos_of_pos_insert_zeros : forall p,\n  pospos_of_pos (insert_zeros p) = (N.pos p, 0%N).\nProof.\n  induction p.\n  - cbn. rewrite IHp. reflexivity.\n  - cbn. rewrite IHp. reflexivity.\n  - cbn. reflexivity.\nQed.\n\n(* We use [Function] because recursion is not structural. *)\nDefinition mes '(p1, p2) := Pos.to_nat p1 + Pos.to_nat p2.\nFunction pos_of_pospos pp { measure mes pp } :=\n  let '(p1, p2) := pp in\n  match p1 with\n  | xH => xI (insert_zeros p2)\n  | xO p1 => xO (pos_of_pospos (p2, p1))\n  | xI p1 => xI (pos_of_pospos (p2, p1))\n  end.\nProof.\n  - intros. cbn. lia.\n  - intros. cbn. lia.\nDefined.\n\nDefinition N_of_NN '(n1, n2) :=\n  match n1, n2 with\n  | N0, N0 => N0\n  | N0, Npos p => Npos (xO (insert_zeros p))\n  | Npos p, N0 => Npos (insert_zeros p)\n  | Npos p1, Npos p2 => Npos (pos_of_pospos (p1, p2))\n  end.\n\nLemma NN_of_N_of_NN : forall n, NN_of_N (N_of_NN n) = n.\nProof.\n  intros (n1, n2). destruct n1, n2.\n  - cbn. reflexivity.\n  - cbn. rewrite pospos_of_pos_insert_zeros. reflexivity.\n  - cbn. apply pospos_of_pos_insert_zeros.\n  - cbn. change p0 with (snd (p, p0)) at 2. change p with (fst (p, p0)) at 2.\n    functional induction (pos_of_pospos (p, p0)).\n    + cbn. rewrite pospos_of_pos_insert_zeros. reflexivity.\n    + cbn. rewrite IHp2. reflexivity.\n    + cbn. rewrite IHp2. reflexivity.\nQed.\n\nLemma N_of_NN_of_N : forall n, N_of_NN (NN_of_N n) = n.\nProof.\n  destruct n.\n  - reflexivity.\n  - cbn. induction p.\n    + cbn. destruct (pospos_of_pos p) as (a, b) eqn:Hpos.\n      cbn in IHp.\n      destruct a, b; cbn;\n        congruence || (rewrite pos_of_pospos_equation; congruence).\n    + cbn. destruct (pospos_of_pos p) as (a, b) eqn:Hpos.\n      cbn in IHp.\n      destruct a, b; cbn;\n        congruence || (rewrite pos_of_pospos_equation; congruence).\n    + reflexivity.\nQed.\n\nDefinition nat_of_natnat '(n1, n2) :=\n  N.to_nat (N_of_NN (N.of_nat n1, N.of_nat n2)).\n\nDefinition natnat_of_nat n :=\n  let (a, b) := NN_of_N (N.of_nat n) in\n  (N.to_nat a, N.to_nat b).\n\nTheorem nat_iso_natxnat : iso nat (nat # nat).\nProof.\n  apply (bijection _ _ natnat_of_nat nat_of_natnat).\n  - intros. unfold nat_of_natnat, natnat_of_nat.\n    destruct (NN_of_N (N.of_nat a)) eqn:Hnn.\n    rewrite 2!N2Nat.id. rewrite <- Hnn.\n    rewrite N_of_NN_of_N. rewrite Nat2N.id. reflexivity.\n  - intros. unfold nat_of_natnat, natnat_of_nat.\n    destruct b as (n1, n2).\n    rewrite N2Nat.id. rewrite NN_of_N_of_NN.\n    rewrite 2!Nat2N.id. reflexivity.\nQed.\n\n(* Task 2. Prove that nat has the same cardinality as nat ^ n, where n is nonzero and finite. *)\n\nLemma nat_iso_nat_unit : iso nat (nat # unit).\nProof.\n  set (A_to_B (n:nat) := (n, tt)).\n  set (B_to_A := fun '((n, tt) : nat # _) => n).\n  apply (bijection _ _ A_to_B B_to_A).\n  - reflexivity.\n  - intros (n, []). reflexivity.\nQed.\n\nTheorem nat_iso_nat_power : forall n, iso nat (nat ^^ S n).\nProof.\n  induction n as [|n is].\n  - cbn. apply nat_iso_nat_unit.\n  - change (nat ^^ S (S n)) with (nat # nat ^^ S n).\n    set (A2B n := let '(n1, n2) := nat_iso_natxnat.(A_to_B _ _) n in (n1, is.(A_to_B _ _) n2)).\n    set (B2A := fun '(n, p) => nat_iso_natxnat.(B_to_A _ _) (n, is.(B_to_A _ _) p)).\n    apply (bijection _ _ A2B B2A).\n    + intros. unfold A2B, B2A.\n      destruct (nat_iso_natxnat.(A_to_B _ _) a) as (n1, n2) eqn:Hnn.\n      rewrite is.(A_B_A _ _). rewrite <- Hnn.\n      rewrite nat_iso_natxnat.(A_B_A _ _).\n      reflexivity.\n    + intros (n1, n2). unfold A2B, B2A.\n      rewrite nat_iso_natxnat.(B_A_B _ _).\n      rewrite is.(B_A_B _ _).\n      reflexivity.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5ce34289f999ed0029a91e30":[{"id":33360,"user_id":null,"body":"Require Import Preloaded.\nOpen Scope conat_scope.\n\nDefinition conat_u (n : conat) : conat := match n with\n  | O => O\n  | S n' => S n' end.\n\nLemma conat_unfold : forall n : conat, n = conat_u n.\nProof. destruct n; auto. Qed.\n\nTheorem bisim_refl : forall a, a == a.\nProof.\n  cofix IH; intros [|a]; [apply OO|apply SS, IH].\nQed.\n\nTheorem bisim_sym : forall a b, a == b -> b == a.\nProof.\n  cofix IH; intros [|a] b ab.\n  - inversion ab; subst; apply OO.\n  - inversion ab; subst; apply SS, IH, H0.\nQed.\n\nTheorem bisim_trans : forall a b c, a == b -> b == c -> a == c.\nProof.\n  cofix IH; intros [|a] b c ab bc.\n  - inversion ab; subst; inversion bc; subst; apply OO.\n  - inversion ab; subst; inversion bc; subst; apply SS.\n    now apply (IH a m m0).\nQed.\n\nTheorem plus_n_O : forall n, n + O == n.\nProof.\n  cofix IH; intros n; rewrite (conat_unfold (n + O)); destruct n as [|n]; [apply OO|].\n  simpl; apply SS, IH.\nQed.\n\nTheorem plus_O_n : forall n, O + n == n.\nProof.\n  intros n; rewrite (conat_unfold (O + n)); destruct n; apply bisim_refl.\nQed.\n\nTheorem plus_S_comm : forall n m, n + S m == S n + m.\nProof.\n  cofix IH; intros n m; rewrite (conat_unfold (n + S m)), (conat_unfold (S n + m)); destruct n as [|n].\n  - simpl; apply SS, bisim_sym, plus_O_n.\n  - simpl; apply SS, IH.\nQed.\n\nTheorem plus_comm : forall n m, n + m == m + n.\nProof.\n  cut (forall n m s t, s == n + m -> m + n == t -> s == t).\n  { intros H n m; apply (H n m); apply bisim_refl. }\n  cofix IH; intros [|n] m s t Hs Ht.\n  - apply bisim_trans with m, bisim_trans with (m + O).\n    + rewrite (conat_unfold (O + m)) in Hs; now destruct m.\n    + apply bisim_sym, plus_n_O.\n    + easy.\n  - rewrite (conat_unfold (S n + m)) in Hs; inversion Hs; subst.\n    assert (S m + n == t) as Ht' by (apply bisim_trans with (m + S n), Ht; apply bisim_sym, plus_S_comm).\n    rewrite (conat_unfold (S m + n)) in Ht'; inversion Ht'; subst.\n    now apply SS, (IH n m).\nQed.\n\nTheorem plus_assoc : forall n m p, (n + m) + p == n + (m + p).\nProof.\n  cut (forall n m p s t, s == (n + m) + p -> n + (m + p) == t -> s == t).\n  { intros H n m p; apply (H n m p); apply bisim_refl. }\n  cofix IH; intros [|n] m p s t Hs Ht.\n  - apply bisim_trans with (O + (m + p)), Ht.\n    apply bisim_trans with (O + m + p); [easy|].\n    apply bisim_trans with (m + p), bisim_sym, plus_O_n.\n    rewrite (conat_unfold (O + m + p)), (conat_unfold (O + m)), (conat_unfold (m + p)); simpl.\n    destruct m; apply bisim_refl.\n  - rewrite (conat_unfold (S n + m + p)) in Hs; inversion Hs; subst.\n    rewrite (conat_unfold (S n + (m + p))) in Ht; inversion Ht; subst.\n    now apply SS, (IH n m p).\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33361,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Coq.Setoids.Setoid.\nOpen Scope conat_scope.\n\n(* This proof is based on Park's bisimulation principle.\n   Constructing the bisimulation relations explicitly is a bit tedious,\n   but it avoids the problems of cofix. *)\n\nDefinition denat (n : conat) :=\n  match n with\n  | O => O\n  | S n => S n\n  end.\n\nLemma conat_unfold : forall n, n = denat n.\nProof. now destruct n. Qed.\n\nDefinition bisimulation (R : conat -> conat -> Prop) :=\n  forall n m, R n m ->\n    (n = O \/\\ m = O) \\\/\n    (exists n' m', R n' m' \/\\ n = S n' \/\\ m = S m').\n\nLtac destruct_all := repeat match goal with\n  | H : _ \/\\ _ |- _ => destruct H\n  | H : exists _, _ |- _ => destruct H\n  end.\n\nLemma bisim_r : forall R, bisimulation R ->\n  forall n m, R n m -> bisim n m.\nProof.\n  intros R B.\n  cofix CIH.\n  destruct n; destruct m; try constructor; intros;\n    edestruct B; try eassumption; destruct_all; \n    try discriminate.\n  apply CIH.\n  inversion H1.\n  inversion H2.\n  assumption.\nQed.\n\nFixpoint n_add (n : nat) (c : conat) :=\n  match n with\n  | 0 => c\n  | Datatypes.S n => S (n_add n c)\n  end.\n\nLemma n_add_S : forall n c, n_add n (S c) = S (n_add n c).\nProof.\n  induction n; auto.\n  simpl. intros. rewrite IHn. auto.\nQed.\n\nLemma plus_O : forall n, O + n = n.\nProof.\n  intros. rewrite conat_unfold at 1.\n  destruct n; auto.\nQed.\n\nLemma plus_S : forall n m, S n + m = S (n + m).\nProof.\n  intros. rewrite conat_unfold at 1. auto.\nQed.\n\nLtac plus_eval := repeat match goal with\n  | H : _ =   O + _ |- _ => rewrite plus_O in H\n  | H : _ = S _ + _ |- _ => rewrite plus_S in H\n  end.\n\nLtac rp0 := rewrite plus_O.\n\nTheorem plus_comm : forall n m, n + m == m + n.\nProof with eauto using n_add_S.\n  (* R = { (n + S^k m, m + S^k n) | n, m : conat, k : nat } *)\n  pose (R := fun x y =>\n    exists n m k, x = n + n_add k m \/\\ y = m + n_add k n).\n  assert (bisimulation R). {\n    intros x y (n & m & k & Hx & Hy).\n    destruct n; destruct m; destruct k; plus_eval; simpl in *; auto;\n      right;\n      do 2 eexists; split...\n    - exists O, O, k. rp0...\n    - exists O, m, 0. rp0...\n    - exists O, m, (Datatypes.S k). rp0...\n    - exists n, O, 0. rp0...\n    - exists n, O, (Datatypes.S k). rp0...\n    - exists n, m, 1...\n    - rewrite ?n_add_S.\n      exists n, m, (Datatypes.S (Datatypes.S k))...\n  }\n  intros.\n  apply bisim_r with R...\n  do 2 eexists. exists 0. simpl...\nQed.\n\nLtac sr x :=\n  split;\n  rewrite conat_unfold at 1;\n  rewrite conat_unfold;\n  destruct x.\n\nTheorem plus_assoc : forall n m p, (n + m) + p == n + (m + p).\nProof with eauto.\n  pose (R := fun x y =>\n    exists n m p, x = (n + m) + p \/\\ y = n + (m + p)).\n  assert (bisimulation R). {\n    intros x y (n & m & p & Hx & Hy).\n    destruct n; destruct m; destruct p; plus_eval;\n      rewrite conat_unfold in Hx, Hy; simpl in *; auto;\n      right;\n      do 2 eexists; split...\n      exists O, O, p. sr p...\n      exists O, m, O. sr m...\n      exists O, m, (S p). sr m...\n      all: exists n; do 2 eexists; sr n...\n  }\n  intros.\n  apply bisim_r with R...\n  do 3 eexists...\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33362,"user_id":null,"body":"Require Import Preloaded Setoid Morphisms.\nOpen Scope conat_scope.\n\nLemma conat_unfold : forall n, n = match n with | O => O | S n => S n end.\nProof.\n  intros [|n]; reflexivity.\nQed.\n\nLemma bisim_refl : Reflexive bisim.\nProof.\n  cofix CIH.\n  intros [|n].\n  - constructor.\n  - constructor. auto.\nQed.\n\nLemma bisim_sym : Symmetric bisim.\nProof.\n  cofix CIH.\n  intros m n H.\n  inversion H; subst.\n  - constructor.\n  - constructor. auto.\nQed.\n\nLemma bisim_trans : Transitive bisim.\nProof.\n  cofix CIH.\n  intros m n p H H0.\n  inversion H; subst.\n  - assumption.\n  - inversion H0; subst. constructor. eauto.\nQed.\n\nInstance bisim_equiv : Equivalence bisim.\nProof.\n  split.\n  - apply bisim_refl.\n  - apply bisim_sym.\n  - apply bisim_trans.\nQed.\n\nInstance bisim_S_compat : Proper (bisim ==> bisim) S.\nProof.\n  intros m1 m2 m_eq. constructor. assumption.\nQed.\n\nTactic Notation \"plus_simpl\" :=\n  match goal with\n  | |- context[O + ?n] =>\n    replace (O + n) with n by\n    (rewrite (conat_unfold (O + n)); destruct n; reflexivity)\n  | |- context[S ?m + ?n] =>\n    replace (S m + n) with (S (m + n)) by\n    (rewrite (conat_unfold (S m + n)); reflexivity)\n  end.\n\nTactic Notation \"plus_simpl\" \"in\" ident(H) :=\n  match type of H with\n  | context[O + ?n] =>\n    replace (O + n) with n in H by\n    (rewrite (conat_unfold (O + n)); cbn; destruct n; reflexivity)\n  | context[S ?m + ?n] =>\n    replace (S m + n) with (S (m + n)) in H by\n    (rewrite (conat_unfold (S m + n)); reflexivity)\n  end.\n\nLemma plus_0_l : forall n, O + n == n.\nProof.\n  intros. plus_simpl. reflexivity.\nQed.\n\nLemma plus_0_r : forall n, n + O == n.\nProof.\n  cofix CIH; intros.\n  rewrite (conat_unfold (n + O)).\n  destruct n; cbn.\n  - constructor.\n  - constructor. auto.\nQed.\n\nLemma plus_succ_l : forall m n, S m + n == S (m + n).\nProof.\n  intros. plus_simpl. reflexivity.\nQed.\n\nLemma plus_succ_r : forall m n, m + S n == S (m + n).\nProof.\n  cofix CIH; intros.\n  destruct m.\n  - do 2 plus_simpl. reflexivity.\n  - do 2 plus_simpl. constructor. auto.\nQed.\n\nTheorem plus_comm_aux : forall m n o p, o == m + n -> p == n + m -> o == p.\nProof.\n  cofix CIH; intros.\n  destruct m.\n  - rewrite H, H0. rewrite plus_0_l, plus_0_r. reflexivity.\n  - plus_simpl in H.\n    destruct o; [inversion H|].\n    destruct p.\n    + destruct n; plus_simpl in H0; inversion H0.\n    + constructor. apply (CIH m n).\n      * inversion H; subst; assumption.\n      * rewrite plus_succ_r in H0. inversion H0; subst; assumption.\nQed.\n\nTheorem plus_comm : forall m n, m + n == n + m.\nProof.\n  intros. eapply plus_comm_aux; reflexivity.\nQed.\n\nInstance bisim_plus_compat : Proper (bisim ==> bisim ==> bisim) plus.\nProof.\n  cofix CIH.\n  intros m1 m2 m_eq n1 n2 n_eq.\n  destruct m_eq.\n  - do 2 plus_simpl. assumption.\n  - do 2 plus_simpl. constructor.\n    apply CIH; assumption.\nQed.\n\nTheorem plus_assoc : forall n m p, (n + m) + p == n + (m + p).\nProof.\n  cofix CIH; intros.\n  destruct n.\n  - do 2 plus_simpl. reflexivity.\n  - do 3 plus_simpl. constructor. auto.\nQed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33363,"user_id":null,"body":"Require Import Preloaded.\nOpen Scope conat_scope.\n\nLemma bisim_refl : forall (a : conat), a == a.\nProof. cofix CIH. destruct a;constructor. apply CIH. Qed.\nLemma bisim_trans : forall n m p, n == m -> m == p -> n == p.\nProof. cofix CIH. intros. destruct n;destruct p.\n* constructor.\n* destruct m;[inversion H0|inversion H].\n* destruct m;[inversion H|inversion H0].\n* destruct m;inversion H;inversion H0;subst.\n  constructor. eapply CIH.\n + apply H3.\n + apply H6.\nQed.\nLemma bisim_sym : forall a b, a == b -> b == a.\nProof. cofix CIH. intros [|a'] [|b'] H;[|inversion H ..];\n constructor. apply CIH. apply H2. Qed.\n\nDefinition conat_u (n : conat) : conat := match n with\n  | O => O\n  | S n' => S n' end.\nLemma conat_unfold : forall n : conat, n = conat_u n.\nProof. destruct n; auto. Qed.\n\nLemma plus_n_O : forall n, n + O == n.\nProof. cofix CIH. intros [|n'];\n rewrite (conat_unfold (_ + O));constructor.\n apply CIH.\nQed.\nLemma plus_O_n_eq : forall (n:conat), O + n = n.\nProof. intros.\n rewrite (conat_unfold (O + n)). simpl.\n change (match n with\n           | O => O\n           | S n' => S n'\n          end) with (conat_u n);\n  rewrite <- conat_unfold.\n reflexivity.\nQed.\n\nLemma plus_n_Sm : forall n m, n + S m == S (n + m).\nProof. cofix CIH. intros [|n'] m;\n rewrite (conat_unfold (_ + S m));constructor.\n* rewrite plus_O_n_eq;apply bisim_refl.\n* rewrite conat_unfold. apply CIH.\nQed.\nLemma plus_Sn_m_eq : forall (n m:conat), (S n) + m = S (n + m).\nProof. intros. rewrite (conat_unfold (S n + m)). simpl. f_equal. Qed.\n\nTheorem plus_comm_general : forall n m nm mn, \n nm == n + m -> m + n == mn -> nm == mn.\nProof. cofix CIH. intros n m [|nm'] [|mn'];intros.\n* constructor.\n* destruct n.\n + rewrite plus_O_n_eq in H.\n   eapply bisim_trans;[apply H|].\n   apply (bisim_trans _ (m + O));[|assumption].\n   apply bisim_sym;apply plus_n_O.\n + rewrite plus_Sn_m_eq in H. inversion H.\n* destruct m.\n + rewrite plus_O_n_eq in H0.\n   eapply bisim_trans;[|apply H0].\n   apply (bisim_trans _ (n + O));[assumption|].\n   apply plus_n_O.\n + rewrite plus_Sn_m_eq in H0. inversion H0.\n* constructor. destruct n.\n + rewrite plus_O_n_eq in H.\n   destruct m;inversion H.\n   rewrite plus_Sn_m_eq in H0;inversion H0.\n   eapply bisim_trans;[apply H3|].\n   eapply bisim_trans;[|apply H6].\n   apply bisim_sym;apply plus_n_O.\n + rewrite plus_Sn_m_eq in H.\n   assert (S (m + n) == S mn');\n    [eapply bisim_trans;[apply bisim_sym;apply plus_n_Sm|apply H0]|].\n   inversion H;inversion H1;eapply CIH;[apply H4|apply H7].\nQed.\nCorollary plus_comm : forall n m, n + m == m + n.\nProof. intros n m. eapply plus_comm_general;apply bisim_refl. Qed.\n\nTheorem plus_assoc_general : forall n m p nm_p n_mp,\n nm_p == (n + m) + p -> n + (m + p) == n_mp -> nm_p == n_mp.\nProof. cofix CIH. intros n m p [|nm_p'] [|n_mp'] Hnm_p Hn_mp.\n* constructor.\n* destruct n.\n + rewrite plus_O_n_eq in Hn_mp, Hnm_p.\n   eapply bisim_trans;[apply Hnm_p|apply Hn_mp].\n + do 2 (rewrite plus_Sn_m_eq in Hnm_p). inversion Hnm_p. \n* destruct n.\n + rewrite plus_O_n_eq in Hn_mp, Hnm_p.\n   eapply bisim_trans;[apply Hnm_p|apply Hn_mp].\n + rewrite plus_Sn_m_eq in Hn_mp. inversion Hn_mp. \n* constructor. destruct n.\n + rewrite plus_O_n_eq in Hnm_p, Hn_mp. destruct m.\n  - rewrite plus_O_n_eq in Hnm_p, Hn_mp. destruct p;[inversion Hn_mp|].\n    inversion Hnm_p;inversion Hn_mp;eapply bisim_trans;[apply H1|apply H4].\n  - rewrite plus_Sn_m_eq in Hnm_p, Hn_mp.\n    inversion Hnm_p;inversion Hn_mp;eapply bisim_trans;[apply H1|apply H4].\n + rewrite plus_Sn_m_eq in Hnm_p, Hn_mp.\n   rewrite plus_Sn_m_eq in Hnm_p.\n   inversion Hnm_p;inversion Hn_mp;eapply CIH;[apply H1|apply H4].\nQed.\nCorollary plus_assoc : forall n m p, (n + m) + p == n + (m + p).\nProof. intros n m p. eapply plus_assoc_general;apply bisim_refl. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33364,"user_id":null,"body":"Require Import Preloaded.\nRequire Import Coq.Setoids.Setoid .\nOpen Scope conat_scope.\n\nDefinition conat_u (n : conat) : conat := match n with\n  | O => O\n  | S n' => S n' end.\n\nLemma conat_unfold : forall n : conat, n = conat_u n.\nProof. destruct n; auto. Qed.   \n\nLemma bisim_rev: forall n m, S n == S m -> n == m.\nProof.\n  intros.\n  inversion H.\n  subst.\n  auto.\nQed.\n\nLemma bisim_symm: forall n m, n == m -> m == n.\nProof.\n  cofix X.\n  intros.\n  inversion H.\n    constructor.\n  subst.\n  constructor.\n  apply X.\n  apply H0.\nQed.\n\nLemma bisim_trans : forall n m p, n == m -> m == p -> n == p.\nProof.\n  cofix X.\n  intros.\n  destruct n.\n  {\n    destruct m. auto.\n    inversion H.\n  }\n  destruct m.\n    inversion H.\n  destruct p.\n    inversion H0.\n  constructor.\n  inversion H; subst.\n  inversion H0; subst.\n  apply X with m; auto.\nQed.\n\nLemma bisim_refl: forall x, bisim x x.\nProof.\n  cofix X.\n  intros.\n  destruct x; constructor.\n  apply X.\nQed.\n\nAdd Parametric Relation : conat bisim \n  reflexivity proved by bisim_refl\n  symmetry proved by bisim_symm\n  transitivity proved by bisim_trans as bisim_rel.\n\nLemma plus_O_n: forall n, O + n = n.\nProof.\n  intros.\n  rewrite conat_unfold with (O + n). simpl.\n  destruct n; auto.\nQed.\n\nLemma plus_S_n: forall n m, S n + m = S (n + m).\nProof.\n  intros.\n  rewrite conat_unfold with (S n + m). simpl.\n  auto.\nQed.\n\nLemma plus_n_O: forall n, n + O == n.\nProof.\n  cofix X.\n  intros.\n  destruct n.\n    rewrite plus_O_n. constructor.\n  rewrite plus_S_n.  \n  constructor.\n  apply X.\nQed.\n\nLemma plus_n_Sm : forall n m, n + S m == S (n + m).\nProof.\n  cofix X.\n  intros.\n  destruct n.\n  {\n    repeat rewrite plus_O_n.\n    apply bisim_refl.\n  }\n  rewrite plus_S_n.\n  rewrite plus_S_n.\n  constructor.\n  apply X.\nQed.\n\n\n\n\nLemma plus_comm_aux : forall n m s' t', s'== n + m ->  m + n == t' -> s' == t'.\nProof.\n  cofix X.\n  assert(O + O = O).\n    rewrite plus_O_n. constructor. \n  intros.\n  destruct n.\n  {\n    destruct m.\n    {\n      rewrite H in *.\n      inversion H0.\n      inversion H1.\n      subst.\n      constructor.\n    }\n    rewrite plus_O_n in H0.\n    inversion H0.\n    subst.\n    destruct t'. \n      rewrite plus_S_n in H1.\n      inversion H1.\n    constructor.\n    apply X with O m.\n      rewrite plus_O_n. destruct m;  apply H4.\n    rewrite plus_S_n in H1.\n    inversion H1.\n    apply H5.\n  }\n  destruct m.\n  {\n    rewrite conat_unfold with (O + S n) in H1.\n    simpl in H1.\n    rewrite plus_S_n in H0.\n    destruct s'.\n      inversion H0.\n    inversion H0.\n    subst.\n    destruct t'.\n      inversion H1.\n    constructor.\n    apply X with n O.\n      apply H4.\n    rewrite plus_O_n.\n    inversion H1. subst.\n    destruct n; apply H5.\n  }\n  rewrite plus_S_n in H0.\n  rewrite plus_S_n in H1.\n  destruct s'.\n    inversion H0.\n  destruct t'.\n    inversion H1.\n  constructor.\n  inversion H0.\n  subst.\n  inversion H1.\n  subst.\n  apply X with (S n) m.\n  2: apply H5.\n  apply bisim_trans with (n + S m).\n    apply H4.\n  rewrite plus_S_n.\n  apply plus_n_Sm.\nQed.\n\nTheorem plus_comm : forall n m : conat, n + m == m + n.\nProof.\n  intros.\n  apply plus_comm_aux with n m;\n      apply bisim_refl.\nQed.\n\nLemma plus_elim_l: forall n m p, n == m -> p + n == p + m.\nProof.\n  cofix X.\n  intros.\n  destruct p.\n  repeat rewrite plus_O_n in *.\n    apply H.\n  repeat rewrite plus_S_n.\n  constructor.\n  apply X.\n  apply H.\nQed.\n\nLemma plus_elim_r: forall n m p, n == m -> n + p == m + p.\nProof.\n  intros.\n  rewrite plus_comm.\n  rewrite (plus_comm m p).\n  apply plus_elim_l.\n  auto.\nQed.\n\nLemma plus_assoc_aux : forall n m p s' t', s'== (n + m) + p -> n + (m + p) == t' -> s' == t'.\nProof.\n  cofix X.\n  intros.\n  destruct n.\n  {\n    rewrite plus_O_n in *.\n    apply bisim_trans with (m+p).\n      apply H. apply H0.\n  }\n  destruct n.\n  {\n    rewrite plus_S_n in *.\n    rewrite plus_O_n in *.\n    rewrite plus_S_n in *.\n    apply bisim_trans with (S (m + p)).\n      apply H.\n    apply H0.\n  }    \n  rewrite plus_S_n in *.\n  rewrite plus_S_n in *.\n  destruct s'.\n    inversion H.\n  destruct t'.\n    inversion H0.\n  constructor.\n  inversion H. subst.\n  inversion H0. subst.\n  apply X with n (S m) p.\n  {\n    rewrite H3.\n    apply plus_elim_r.\n    rewrite plus_n_Sm.\n    rewrite plus_S_n.\n    apply bisim_refl.\n  }\n  rewrite plus_S_n.\n  rewrite plus_n_Sm.\n  apply H4.\nQed.\n\nTheorem plus_assoc : forall n m p, (n + m) + p == n + (m + p).\nProof.\n  intros.\n  eapply plus_assoc_aux.\n  reflexivity.\n  reflexivity.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33365,"user_id":196,"body":"Require Import Preloaded.\nOpen Scope conat_scope.\n\nTheorem bisim_refl : forall m, m == m.\nProof.\n  cofix CIH. intro m. destruct m.\n  - exact OO.\n  - exact (SS m m (CIH m)).\nQed.\n\nTheorem bisim_comm : forall m n, m == n -> n == m.\nProof.\n  cofix CIH. intros m n H. destruct H.\n  - exact OO.\n  - exact (SS m n (CIH n m H)).\nQed.\n\nTheorem bisim_trans : forall n m p, n == m -> m == p -> n == p.\nProof.\n  cofix CIH. intros n m p h1 h2. destruct h1.\n  - exact h2.\n  - case p as [|p].\n    + inversion h2.\n    + inversion h2. subst m0 n0. exact (SS n p (CIH n m p h1 H1)).\nQed.\n\nRequire Import Setoid.\n\nAdd Parametric Relation : conat bisim\n  reflexivity proved by (bisim_refl)\n  symmetry proved by (bisim_comm)\n  transitivity proved by (bisim_trans)\n  as bisim_rel.\n\nDefinition conat_u (n : conat) : conat := match n with\n  | O => O\n  | S m => S m end.\n\nLemma conat_unfold : forall n : conat, n = conat_u n.\nProof. destruct n; auto. Qed.\n\nTheorem O_plus_m : forall m, O + m == m.\nProof.\n  intro m. rewrite (conat_unfold (O + m)); case m as [|m]; reflexivity.\nQed.\n\nTheorem m_plus_O : forall m, m + O == m.\nProof.\n  cofix CIH. intro m. rewrite (conat_unfold (m + O)). case m as [|m].\n  - exact OO.\n  - exact (SS (m + O) m (CIH m)).\nQed.\n\nTheorem plus_n_Sm : forall n m, n + S m == S (n + m).\nProof.\n  cofix CIH. intros n m. destruct n as [|n].\n  - rewrite (conat_unfold (O + S m)). apply SS.\n    rewrite (conat_unfold (O + m)). case m as [|m]; reflexivity.\n  - rewrite (conat_unfold (S n + S m)). cbn. apply SS.\n    rewrite (conat_unfold (S n + m)). exact (CIH n m).\nQed.\n\nTheorem plus_comm : forall n m, n + m == m + n.\nProof.\n  enough (forall n m s t : conat, n + m == s -> m + n == t -> s == t)\n    by exact (fun n m => H _ _ _ _ (bisim_refl _) (bisim_refl _)).\n  cofix CIH. intros n m s t H1 H2. case n as [|n].\n  - rewrite <- H1, <- H2, m_plus_O, O_plus_m. reflexivity.\n  - rewrite plus_n_Sm in H2. rewrite (conat_unfold (S n + m)) in H1.\n    inversion H1. inversion H2. exact (SS _ _ (CIH _ _ _ _ H0 H5)).\nQed.\n\nTheorem plus_assoc : forall n m p, (n + m) + p == n + (m + p).\nProof.\n  enough (forall n m p s t : conat, (n + m) + p == s -> n + (m + p) == t -> s == t)\n    by exact (fun n m p => H _ _ _ _ _ (bisim_refl _) (bisim_refl _)).\n  cofix CIH. intros n m p s t H1 H2. case n as [|n].\n  - rewrite <- H1, <- H2, (conat_unfold ((O + m) + p)), (conat_unfold (O + (m + p))).\n    case m as [|m]; case p as [|p]; reflexivity.\n  - rewrite (conat_unfold ((S n + m) + p)) in H1.\n    rewrite (conat_unfold (S n + (m + p))) in H2.\n    inversion H1. inversion H2. exact (SS _ _ (CIH _ _ _ _ _ H0 H5)).\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33366,"user_id":1076,"body":"Require Import Coq.Classes.Morphisms Coq.Classes.RelationClasses Coq.Setoids.Setoid.\nRequire Import Preloaded.\nOpen Scope conat_scope.\n\nGlobal Instance bisim_trans : Transitive bisim.\nProof.\n  cofix f.\n  intros n m p H0 H1.\n  destruct n, m, p; try constructor; try solve [ inversion H0 | inversion H1 ].\n  eapply f; inversion H0; inversion H1; eassumption.\nDefined.\n\nGlobal Instance bisim_refl : Reflexive bisim.\nProof.\n  cofix f; intro n; destruct n; constructor; apply f.\nDefined.\n\nGlobal Instance bisim_sym : Symmetric bisim.\nProof.\n  cofix f; intros n m; destruct n, m; intro H; try constructor; inversion H; apply f; assumption.\nDefined.\n\nDefinition eta (n : conat) : conat\n  := match n with\n     | O => O\n     | S n => S n\n     end.\n\nLemma bisim_eta : forall n, bisim n (eta n).\nProof.\n  destruct n; constructor; reflexivity.\nDefined.\n\nArguments eta \/ .\n\nGlobal Instance Proper_eta_bisim\n  : Proper (bisim ==> bisim) eta.\nProof.\n  intros n m H; destruct H; constructor; assumption.\nDefined.\n\nGlobal Instance Proper_S : Proper (bisim ==> bisim) S.\nProof.\n  intros n m H; constructor; assumption.\nDefined.\n\nDefinition plus_O_n : forall n, O + n == n.\nProof.\n  intro n; rewrite (bisim_eta (O + n)); symmetry; apply (bisim_eta n).\nDefined.\n\nTheorem plus_Sn_m : forall n m, S n + m == S (n + m).\nProof.\n  intros n m; rewrite bisim_eta; reflexivity.\nDefined.\n\nLemma Proper_plus_gen\n  : forall n n' m m' nm n'm', n == n' -> m == m' -> n + m == nm -> n' + m' == n'm' -> nm == n'm'.\nProof.\n  cofix f.\n  intros n n' m m' nm n'm' Hn Hm Hnm Hn'm'.\n  destruct nm, n'm', Hn, Hm; try constructor.\n  all: rewrite ?plus_O_n, ?plus_Sn_m in *.\n  all: try match goal with H : _ |- _ => solve [ inversion H ] end.\n  { inversion_clear Hnm; inversion_clear Hn'm'.\n    etransitivity; [ | etransitivity ];\n      (idtac + symmetry); multimatch goal with H : _ |- _ => exact H end. }\n  { inversion_clear Hnm; inversion_clear Hn'm'.\n    eapply f.\n    all: multimatch goal with H : _ |- _ => exact H end + reflexivity. }\n  { inversion_clear Hnm; inversion_clear Hn'm'.\n    eapply f.\n    all: (idtac + constructor);\n      multimatch goal with H : _ |- _ => exact H end. }\nDefined.\n\nGlobal Instance Proper_plus : Proper (bisim ==> bisim ==> bisim) plus.\nProof.\n  repeat intro; eapply Proper_plus_gen;\n    (multimatch goal with H : _ |- _ => exact H end + reflexivity).\nDefined.\n\nDefinition plus_n_O_gen : forall n n' n'', n + O == n' -> n == n'' -> n' == n''.\nProof.\n  cofix f; destruct n, n', n''; intros H1 H2; try constructor.\n  all: rewrite ?plus_Sn_m, ?plus_O_n in *.\n  all: repeat match goal with\n              | [ H : S _ == S _ |- _ ] => inversion H; clear H; subst\n              | [ H : _ == _ |- _ ] => solve [ inversion H ]\n              end.\n  eapply f; eassumption.\nDefined.\n\nDefinition plus_n_O : forall n, n + O == n.\nProof. intros; eapply plus_n_O_gen; reflexivity. Defined.\n\nTheorem plus_n_Sm_gen : forall n m nSm Snm, n + S m == nSm -> S (n + m) == Snm -> nSm == Snm.\nProof.\n  cofix f; intros n m nSm Snm H1 H2; destruct n, nSm, Snm; try constructor.\n  all: rewrite ?plus_Sn_m, ?plus_O_n in *.\n  all: repeat match goal with\n              | [ H : S _ == S _ |- _ ] => inversion H; clear H; subst\n              | [ H : _ == _ |- _ ] => solve [ inversion H ]\n              end.\n  { etransitivity; (idtac + symmetry); eassumption. }\n  { eapply f; eassumption. }\nDefined.\n\nTheorem plus_n_Sm : forall n m, n + S m == S (n + m).\nProof. intros; eapply plus_n_Sm_gen; reflexivity. Defined.\n\nTheorem plus_comm_gen : forall n m nm mn, n + m == nm -> m + n == mn -> nm == mn.\nProof.\n  cofix f; intros n m nm mn H1 H2; destruct n, m, nm, mn; try constructor.\n  all: try solve [ rewrite ?plus_Sn_m, ?plus_O_n, ?plus_n_O, ?plus_n_Sm in *;\n                   repeat match goal with\n                          | [ H : S _ == S _ |- _ ] => inversion H; clear H; subst\n                          | [ H : _ == _ |- _ ] => solve [ inversion H ]\n                          | _ => etransitivity; (idtac + symmetry); eassumption\n                          end ].\n  rewrite plus_Sn_m in H1.\n  rewrite plus_n_Sm in H2.\n  inversion H1; inversion H2; clear H1 H2; subst.\n  eapply f; eassumption.\nDefined.\n\nTheorem plus_comm : forall n m, n + m == m + n.\nProof. intros; eapply plus_comm_gen; reflexivity. Defined.\n\nTheorem plus_assoc_gen : forall n m p nm_p n_mp, (n + m) + p == nm_p -> n + (m + p) == n_mp -> nm_p == n_mp.\nProof.\n  cofix f; intros n m p nm_p n_mp H1 H2; destruct n, m, p, nm_p, n_mp; try constructor.\n  all: try solve [ repeat rewrite ?plus_Sn_m, ?plus_O_n, ?plus_n_O, ?plus_n_Sm in *;\n                   repeat match goal with\n                          | [ H : S _ == S _ |- _ ] => inversion H; clear H; subst\n                          | [ H : _ == _ |- _ ] => solve [ inversion H ]\n                          | _ => etransitivity; (idtac + symmetry); eassumption\n                          end ].\n  rewrite !plus_Sn_m in H1.\n  rewrite (plus_Sn_m n) in H2.\n  inversion H1; inversion H2; clear H1 H2; subst.\n  eapply f; eassumption.\nDefined.\n\nTheorem plus_assoc : forall n m p, (n + m) + p == n + (m + p).\nProof. intros; eapply plus_assoc_gen; reflexivity. Defined.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33367,"user_id":885,"body":"Require Import Preloaded.\nRequire Import Coq.Setoids.Setoid.\nOpen Scope conat_scope.\n\nDefinition conat_u (n : conat) : conat := match n with\n  | O => O\n  | S n' => S n' end.\n\nLemma conat_unfold : forall n : conat, n = conat_u n.\nProof. destruct n; auto. Qed.\n\nLemma bisim_refl : forall m, m == m.\nProof. cofix CIH.\n  intros. destruct m;constructor. apply CIH.\nQed.\n\nLemma bisim_sym : forall m n, m == n -> n == m.\nProof. cofix CIH.\n  intros. inversion H;subst;constructor. apply CIH. auto.\nQed.\n\nLemma bisim_trans : forall m n p, m == n -> n == p -> m == p.\nProof. cofix CIH.\n  intros. destruct H. auto. inversion H0;subst.\n  constructor. apply CIH with m. auto. auto.\nQed.\n\nAdd Parametric Relation: conat bisim\n  reflexivity proved by bisim_refl\n  symmetry proved by bisim_sym\n  transitivity proved by bisim_trans as bisim_rel.\n\nLemma plus_identity_l n : O + n = n.\nProof. rewrite (conat_unfold n) at 2. \n  apply (conat_unfold (O + n)).\nQed.\n\nLemma plus_identity_r : forall n, n + O == n.\nProof. cofix CIH.\n  intros. destruct n. rewrite plus_identity_l. reflexivity.\n  rewrite (conat_unfold (S n + O)). constructor. apply CIH.\nQed.\n\nLemma plus_Sn_m n m : S n + m = S (n + m).\nProof. apply conat_unfold.\nQed.\n\nLemma plus_n_Sm : forall n m, n + S m == S (n + m).\nProof. cofix CIH.\n  destruct n;intros. do 2 rewrite plus_identity_l;reflexivity.\n  rewrite plus_Sn_m. constructor. rewrite plus_Sn_m. apply CIH.\nQed.\n\nLemma plus_comm_helper : forall n m s t, s == n + m -> t == m + n -> s == t.\nProof. cofix CIH.\n  destruct n;intros.\n  transitivity (O + m). apply H. symmetry. rewrite plus_identity_l. \n  rewrite plus_identity_r in H0. auto.\n  rewrite plus_Sn_m in *. rewrite plus_n_Sm in *. destruct s, t;inversion H;inversion H0.\n  constructor. apply CIH with n m. auto. auto.\nQed.\n\nTheorem plus_comm : forall n m, n + m == m + n.\nProof. intros. apply plus_comm_helper with n m;reflexivity. Qed.\n\nLemma plus_assoc_helper : forall n m p s t, s == (n + m) + p -> t == n + (m + p) -> s == t.\nProof. cofix CIH.\n  intros;destruct n.\n  transitivity (O + m + p). auto. rewrite plus_identity_l in *. symmetry. auto.\n  rewrite plus_Sn_m in *. rewrite plus_Sn_m in H. destruct s, t;inversion H;inversion H0.\n  constructor. apply CIH with n m p. auto. auto.\nQed.\n\nTheorem plus_assoc : forall n m p, (n + m) + p == n + (m + p).\nProof. intros. apply plus_assoc_helper with n m p;reflexivity. Qed.","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33368,"user_id":null,"body":"Require Import Preloaded.\nRequire Coq.Setoids.Setoid.\nOpen Scope conat_scope.\n\nDefinition frob_conat n :=\n  match n with\n  | O => O\n  | S n' => S n'\n  end.\n\nLemma frob_conat_eq : forall n, n = frob_conat n.\nProof.\n  destruct n; reflexivity.\nQed.\n\nLemma bisim_refl : forall x, x == x.\nProof.\n  cofix bisim_refl.\n  destruct x; constructor; apply bisim_refl.\nQed.\n\nLemma bisim_sym : forall x y, x == y -> y == x.\nProof.\n  cofix bisim_sym.\n  destruct 1; constructor; apply bisim_sym; assumption.\nQed.\n\nLemma bisim_trans : forall x y z, x == y -> y == z -> x == z.\nProof.\n  cofix bisim_trans.\n  destruct 1.\n  - tauto.\n  - inversion 1.\n    eauto using SS, bisim_trans.\nQed.\n\nAdd Parametric Relation : conat bisim\n    reflexivity proved by bisim_refl\n    symmetry proved by bisim_sym\n    transitivity proved by bisim_trans\n      as bisim_rel.\n\nLemma plus_0_l n : O + n = n.\n  rewrite (frob_conat_eq n) at 2.\n  apply (frob_conat_eq (O + n)).\nQed.\n\nLemma plus_0_r : forall n, n + O == n.\nProof.\n  cofix plus_0_r.\n  intro.\n  rewrite (frob_conat_eq (n + O)).\n  destruct n; constructor; apply plus_0_r.\nQed.\n\nLemma plus_Sn_m n m : S n + m = S (n + m).\nProof.\n  apply frob_conat_eq.\nQed.\n\nLemma plus_n_Sm : forall n m, n + S m == S (n + m).\nProof.\n  cofix plus_n_Sm.\n  destruct n.\n  - intro m.\n    rewrite plus_0_l, plus_0_l.\n    reflexivity.\n  - intro m.\n    rewrite plus_Sn_m.\n    constructor.\n    rewrite plus_Sn_m.\n    apply plus_n_Sm.\nQed.\n\nTheorem plus_comm : forall n m, n + m == m + n.\nProof.\n  intros n m.\n  remember (m + n) as q.\n  pose proof (bisim_refl q) as H.\n  rewrite Heqq in H at 1.\n  clear Heqq.\n  revert n m q H.\n  cofix plus_comm'.\n  intros.\n  destruct n.\n  - rewrite plus_0_r in H.\n    rewrite plus_0_l.\n    assumption.\n  - rewrite plus_n_Sm in H.\n    inversion_clear H.\n    rewrite plus_Sn_m.\n    constructor.\n    apply plus_comm'.\n    assumption.\nQed.\n\nTheorem plus_assoc : forall n m p, (n + m) + p == n + (m + p).\nProof.\n  intros n m p.\n  remember (n + (m + p)) as q.\n  pose proof (bisim_refl q) as H.\n  rewrite Heqq in H at 1.\n  clear Heqq.\n  revert n m p q H.\n  cofix plus_assoc'.\n  intros.\n  destruct n.\n  - rewrite plus_0_l in H.\n    rewrite plus_0_l.\n    assumption.\n  - rewrite plus_Sn_m in H.\n    inversion_clear H.\n    rewrite plus_Sn_m, plus_Sn_m.\n    constructor.\n    apply plus_assoc'.\n    assumption.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":33369,"user_id":null,"body":"Require Import Preloaded ssreflect.\nOpen Scope conat_scope.\n\nDefinition conat_u (n : conat) : conat := match n with\n  | O => O\n  | S n' => S n' end.\n\nLemma conat_unfold : forall n : conat, n = conat_u n.\nProof. destruct n; auto. Qed.\n\nTheorem bisim_refl : forall n, n == n.\nProof.\n  cofix f; case; constructor; apply f.\nQed.\n\nTheorem bisim_sym : forall n m, n == m -> m == n.\nProof.\n  cofix f.\n  move=> n m; case.\n  - constructor.\n  - move=> n' m' H; constructor; apply (f _ _ H).\nQed.\n\nTheorem bisim_trans : forall n m p, n == m -> m == p -> n == p.\nProof.\n  cofix f.\n  move=> n m p; case => [ | {n m} n m Hnm]; first by apply.\n  inversion 1 as [| a p' Hmp']; subst.\n  by constructor; apply (f _ m _).\nQed.\n\nTheorem plus_n_0 : forall n, n == n + O.\nProof.\n  cofix f.\n  case.\n  - rewrite (conat_unfold (O + O)) \/=; apply bisim_refl.\n  - move=> n; rewrite [X in X==_]conat_unfold \/=.\n    rewrite [X in _==X]conat_unfold \/=.\n    constructor.\n    exact: f.\nQed.\n\nLemma bisim_S_inversion : forall m n, m == S n -> exists m', m = S m' \/\\ m' == n.\nProof. inversion 1; eauto. Qed.\n\nTheorem plus_n_Sm : forall n m p q, p == n + S m -> S (n + m) == q -> p == q.\nProof.\n  cofix f; case.\n  - case=> [|m] p q; do 2 rewrite (conat_unfold (O + _)) \/=; apply bisim_trans.\n  - move=> n m p q; do 2 rewrite (conat_unfold (S _ + _)) \/=.\n    do 2 inversion 1; constructor; eauto.\nQed.\n\nTheorem plus_comm : forall n m, n + m == m + n.\nProof.\n  suff: forall n m p q, p == n + m -> m + n == q -> p == q\n    by move=> H n m; apply (H n m _ _ (bisim_refl _) (bisim_refl _)).\n  cofix f.\n  case=> \/=.\n  - case => [| m]; rewrite (conat_unfold (O + _)) \/=.\n    + by inversion 1; subst.\n    + move=> p q \/bisim_trans H H1; apply H.\n      by apply: bisim_trans H1; apply plus_n_0.\n  - move=> n m p q; rewrite (conat_unfold (S n + m)) \/=.\n    move \/(bisim_S_inversion p (n + m)) => [p' [-> H]].\n    move\/bisim_sym\/(plus_n_Sm _ _ _ _)\/(_ (bisim_refl _)).\n    move\/bisim_S_inversion => [q' [-> H']].\n    constructor.\n    apply (f n m); auto using bisim_sym.\nQed.\n\nTheorem plus_assoc : forall n m p, (n + m) + p == n + (m + p).\nProof.\n  cofix f; case => [m p |].\n  - case: m => [| m]; case: p => [| p];\n      repeat rewrite (conat_unfold (O + _)) \/=; \n      repeat rewrite (conat_unfold (S _ + _)) \/=; apply bisim_refl.\n  - move=> n m p; repeat rewrite (conat_unfold (S _ + _)) \/=.\n    constructor; exact: f.\nQed.\n","lang_id":9,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}]}