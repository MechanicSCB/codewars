{"537922daa79ca02290000d18":[{"id":14418,"user_id":277,"body":"(ns sageptr)\n\n(def twoplustwotimestwo (* (+ 2 2) 2))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14419,"user_id":null,"body":"(ns sageptr)\n\n(def twoplustwotimestwo (+ 2 2 (* 2 2)))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14420,"user_id":527,"body":"(ns sageptr)\n\n(def twoplustwotimestwo (-> 2 (+ 2) (* 2)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14421,"user_id":null,"body":"(ns sageptr)\n\n(def twoplustwotimestwo\n  (* 2 (+ 2 2)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"53844152aa6fc137d8000589":[{"id":14422,"user_id":null,"body":"(ns fn-with-fn)\n\n(defn always [n]\n  (constantly n))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14423,"user_id":null,"body":"(ns fn-with-fn)\n\n(def always constantly)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14424,"user_id":351,"body":"(ns fn-with-fn)\n\n(defn always [n]\n  #(identity n)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14425,"user_id":2708,"body":"(ns fn-with-fn)\n\n(defn always [n]\n  (fn [] n))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14426,"user_id":null,"body":"(ns fn-with-fn)\n\n(def always (partial partial identity))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14427,"user_id":null,"body":"(ns fn-with-fn)\n\n(defn always [n]\n  (def add_n (partial + n))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14428,"user_id":null,"body":"(ns fn-with-fn)\n\n(def always #(fn [] %))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14429,"user_id":null,"body":"(ns fn-with-fn)\n\n(defn always [n]\n  (defn a [] n)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14430,"user_id":null,"body":"(ns fn-with-fn)\n\n(defn always [n]\n  (defn identity2 [] n)\n  identity2\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14431,"user_id":null,"body":"(ns fn-with-fn)\n\n(defn always [n] #(long n))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5498e5ad66720b1d56000686":[{"id":14432,"user_id":351,"body":"(ns custom-regex-language)\n(defn my-regex\n  [[in_x & in_xs :as in] [regex_x & regex_xs :as regex]]\n  (cond \n    (and (nil? regex) (not (nil? in))) false\n    (nil? in) (if (every? #(= \\* %) regex) true false)\n    (= in regex) true\n    (= in_x regex_x) (recur in_xs regex_xs)\n    (= regex_x \\+) (recur in_xs regex_xs)\n    (= regex_x \\*) (or (my-regex in regex_xs) (my-regex in_xs regex))\n    :else false))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14433,"user_id":null,"body":"(ns custom-regex-language\n  (:refer-clojure :exclude [re-matches re-pattern]))\n\n(defn my-regex\n  [in regex]\n  (loop [[x & xs] in [r & rs :as rrs] regex]\n    (cond (every? nil? [x r]) true\n          (= r \\+) (if (nil? x) false (recur xs rs))\n          (= r \\*) (cond (nil? x) true\n                          (= (first xs) (first rs)) (recur xs rs)\n                          :default (recur xs rrs))\n          (= r x) (recur xs rs)\n          :default false)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14434,"user_id":106,"body":"(ns custom-regex-language\n  (:require [clojure.string]))\n\n(defn my-regex [in regex]\n  (not (= (re-matches (re-pattern (clojure.string\/replace regex #\"[*+]\" {\"*\" \".*\" \"+\" \".+\"})) in) nil))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14435,"user_id":149,"body":"(ns custom-regex-language)\n\n(defn my-regex [in regex]\n  (not= (re-matches (re-pattern (clojure.string\/replace (clojure.string\/replace regex #\"\\+\" \".\") #\"\\*\" \".*\")) in) nil)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14436,"user_id":null,"body":"(ns custom-regex-language\n  (:refer-clojure :exclude [re-matches re-pattern]))\n\n(defn my-regex\n  [input regex]\n  (cond\n    (= input regex) true\n    (= \"\" regex) false\n    (= \"\" input) (= #{\\*} (set regex))\n    :else (case (first regex)\n            \\+ (recur (subs input 1) (subs regex 1))\n            \\* (->> input\n                    count\n                    inc\n                    range\n                    (map #(my-regex (subs input %) (subs regex 1)))\n                    (some identity)\n                    (some?))\n            (and\n             (= (first input) (first regex))\n             (my-regex (subs input 1) (subs regex 1))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14437,"user_id":571,"body":"(ns custom-regex-language)\n\n(defn my-regex [in regex]\n  (not (nil? (re-matches (re-pattern (str (clojure.string\/replace (clojure.string\/replace regex #\"\\+\" \".\") #\"\\*\" \".*\")))  in))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14438,"user_id":527,"body":"(ns custom-regex-language\n  (:refer-clojure :exclude [re-matches re-pattern]))\n\n(defn my-regex [in regex]\n  (case (first regex)\n    nil (empty? in)\n    \\+  (and (not (empty? in)) (my-regex (next in) (next regex)))\n    \\*  (or (my-regex in (next regex))\n            (and (not (empty? in)) (my-regex (next in) regex)))\n        (and (= (first in) (first regex))\n             (my-regex (next in) (next regex)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14439,"user_id":null,"body":"(ns custom-regex-language\n  (:refer-clojure :exclude [re-matches re-pattern]))\n\n(defn my-regex\n  [in regex]\n  (loop [[current-char & input-rest] in\n         [current-regex & regex-rest] regex]\n    (cond\n      (and (nil? current-char) (nil? current-regex)) true\n      (= current-regex \\+) (recur input-rest regex-rest)\n      (= current-regex current-char) (recur input-rest regex-rest)\n      (= current-regex \\*) (cond (nil? regex-rest) true\n                                 (nil? input-rest) (if (nil? regex-rest) true (my-regex (cons current-char input-rest) regex-rest))\n                                 (my-regex input-rest regex-rest) true\n                                 (my-regex (cons current-char input-rest) regex-rest) true\n                                 :else (recur input-rest (cons current-regex regex-rest)))\n      :else false)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14440,"user_id":null,"body":"(ns custom-regex-language\n  (:refer-clojure :exclude [re-matches re-pattern]))\n  \n(defn my-regex\n  [in regex]\n  (let [new-regex (-> regex\n                      (clojure.string\/replace #\"\\*+\" \".*\")\n                      (clojure.string\/replace #\"\\+\" \".\"))]\n    (println \"new-regex: '\" new-regex \"'\")\n    (not (empty? (re-find (java.util.regex.Pattern\/compile (str new-regex \"$\")) in)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14441,"user_id":2002,"body":"(ns custom-regex-language\n  (:refer-clojure :exclude [re-matches re-pattern]))\n\n(defn- match [in regex]\n  (let [[c n & r] regex\n        [i & ri] in]\n        (println c n i)\n    (cond \n      (and (nil? c) (nil? i)) true\n      (nil? i) false\n      (= i c) (match ri (rest regex))\n      (= c \\+) (match ri (rest regex))\n      (= c \\*) (or (match ri r)\n                   (match ri regex))\n      :else false)))\n\n(defn my-regex\n  [in regex]\n  (match (seq in) (seq regex)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5549dea83e7e6cda420000c4":[{"id":14442,"user_id":null,"body":"(ns cables\n  (require [clojure.string :as string]))\n\n(defn check-cables [need cables]\n  (loop [current-need need balance cables]\n      (cond\n        (and (empty? balance) (not= current-need 0)) nil\n        :else (let [cable (first balance)]\n                (cond\n                  (= cable current-need) [cable]\n                  (< cable current-need) (if-let [chosen-cables (check-cables (- current-need cable) (rest balance))]\n                                           (into [cable] chosen-cables)\n                                           (recur current-need (rest balance)))\n                  :else (recur current-need (rest balance)))))))\n\n(defn cable-calc [need cables]\n  (let [normal-cables (sort > (filter #(<= % need) cables))]\n    (if-let [chosen-cables (check-cables need normal-cables)]\n      (string\/join \",\" chosen-cables)\n      \"No result\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14443,"user_id":1485,"body":"(ns cables)\n\n(defn- calc [need cables used]\n  (cond\n    (zero? need) used\n    (neg? need) nil\n    (empty? cables) nil\n    :else\n      (or (calc (- need (first cables)) (rest cables) (conj used (first cables)))\n          (calc need (rest cables) used))))\n\n(defn cable-calc [need cables]\n  (let [result (calc need cables [])]\n    (if (nil? result)\n        \"No result\"\n        (->> result sort reverse (clojure.string\/join \",\")))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55521d28f790f6d92d0001ab":[{"id":14444,"user_id":null,"body":"(ns car-value.core)\n\n(defn car [price years]\n  ( ->> 0.9\n    (repeat years)\n    (concat '(0.8 0.8))\n    (take years)\n    (reduce *)\n    (* price)\n    (format \"%.2f\")\n  ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14445,"user_id":53,"body":"(ns car-value.core)\n\n(defn car [p n]\n  (if (= 0 n)\n    (format \"%.2f\" p)\n    (car (- p (* p (if (> n 2) 0.1 0.2))) (dec n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14446,"user_id":null,"body":"(ns car-value.core)\n\n(defn car [price years]\n  (if (zero? years)\n    (format \"%.2f\" price)\n    (cond (= years 1) (recur (* price 0.8) (dec years))\n          (= years 2) (recur (* price 0.8) (dec years))\n          :else (recur (* price 0.9) (dec years)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14447,"user_id":233,"body":"(ns car-value.core)\n\n(defn car [price years]\n  ( ->> 0.9\n    (repeat)\n    (concat (repeat 2 0.8))\n    (take years)\n    (reduce *)\n    (* price)\n    (format \"%.2f\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14448,"user_id":233,"body":"(ns car-value.core)\n\n(defn car [price years]\n  (format \"%.2f\"\n    (* price\n      (reduce *\n        (take years\n          (concat (repeat 2 0.8) (repeat 0.9)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14449,"user_id":294,"body":"(ns car-value.core)\n\n(defn car [price years]\n  (->> (-> (fn [cur-price cur-year]\n               (let [ratio (if (< cur-year 2) 0.2 0.1)]\n                    (- cur-price (* ratio cur-price))))\n           (reduce price (range years)))\n       (format \"%.2f\")))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14450,"user_id":294,"body":"(ns car-value.core)\n\n(defn car\n  ([price yrs] (->> (car price yrs 0) (format \"%.2f\")))\n  ([price yrs cur-yr]\n    (if (= cur-yr yrs) price\n        (let [ratio (if (> cur-yr 1) 0.10 0.20)]\n             (recur (- price (* ratio price)) yrs (inc cur-yr))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14451,"user_id":294,"body":"(ns car-value.core)\n\n(ns car-value.core)\n\n(defn car [price years]\n  (->> (-> (fn [cur-price cur-year]\n               (let [ratio (if (< cur-year 2) 0.2 0.1)]\n                    (- cur-price (* ratio cur-price))))\n           (reduce price (range years)))\n       (format \"%.2f\")))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14452,"user_id":492,"body":"(ns car-value.core)\n\n(defn car [price years]\n  (let [years2 (min years 2)\n        years1 (max 0 (- years 2))]\n    (format\n      \"%.2f\"\n      (* price\n         (Math\/pow 0.80 years2)\n         (Math\/pow 0.90 years1)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14453,"user_id":null,"body":"(ns car-value.core)\n\n(defn car [price years]\n  (->> (repeat 0.9)\n       (lazy-cat (repeat 2 0.8))\n       (take years)\n       (reduce * price)\n       (format \"%.2f\")\n  ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55d5f550f0f026f7de00000b":[{"id":14454,"user_id":3082,"body":"(ns let-them-bounce)\n\n(defn call [f & args]\n  (fn [] (apply f args)))\n\n\n(defn done [x]\n  [x])\n\n(defn run [x]\n  (first (trampoline x)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14455,"user_id":null,"body":"(ns let-them-bounce)\n\n(defn call [f & args]\n  #(apply f args))\n\n(def done reduced)\n\n(def run (comp deref trampoline))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14456,"user_id":1200,"body":"(ns let-them-bounce)\n\n(defn call [f & args]\n  {:call f :args args})\n\n(defn done [x]\n  {:result x})\n\n(defn run [x]\n  (if (contains? x :call)\n    (recur (apply (:call x) (:args x)))\n    (:result x)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14457,"user_id":null,"body":"(ns let-them-bounce)\n\n(defn call [f & args]\n  (delay (apply f args)))\n\n(defn done [x]\n  (reify\n    clojure.lang.IDeref\n    (deref [this] this)\n    clojure.lang.IFn\n    (invoke [this] x)))\n\n(defn run [x]\n  ((->> (iterate deref x) (drop-while delay?) first)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14458,"user_id":null,"body":"(ns let-them-bounce)\n\n(defn call [f & args]\n  [f args])\n\n(defn done [x]\n  [done [x]])\n\n(defn run [x]\n  (->> x\n    (iterate (partial apply apply))\n    (drop-while #(not (identical? done (first %))))\n    first second first))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14459,"user_id":null,"body":"(ns let-them-bounce)\n\n(defn call [f & args]\n  (delay (apply f args)))\n\n(defn done [x]\n  x)\n\n(defn run [x]\n  (first (drop-while #(instance? clojure.lang.Delay %) (iterate force x))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14460,"user_id":3082,"body":"(ns let-them-bounce)\n\n(ns let-them-bounce)\n\n(defn call [f & args]\n  (fn [] (apply f args)))\n\n\n(defn done [x]\n  [x])\n\n(defn run [x]\n  (first (trampoline x)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14461,"user_id":3082,"body":"(ns let-them-bounce)\n\n(defn call [f & args]\n  (if (fn? f) (println \"fuck\"))\n  (fn [] (apply f args)))\n\n\n(defn done [x]\n  [x])\n\n(defn run [x]\n  (first (trampoline x)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14462,"user_id":527,"body":"(ns let-them-bounce)\n\n(defn call [f & args]\n  [true #(apply f args)])\n\n(defn done [x]\n  [false x])\n\n(defn run [[go func-or-res]]\n  (if go (recur (func-or-res)) func-or-res))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5654e0d6ea6e8bde71000083":[{"id":14463,"user_id":492,"body":"(ns generalorder.core)\n\n(defn change-char [s]\n  (apply str \n         (map (fn [x]\n                (if (= (int x) (int \\z))\n                  \\a\n                  (if (and (>= (int x) (int \\a)) (< (int x) (int \\z)))\n                    (char (+ 1 (int x)))\n                    x))) s)))\n(defn decypher [order]\n  (let [\n        cleaned (.trim (.replaceAll (clojure.string\/lower-case order) \"([^a-z\\\\$\\\\.0-9 ])\" \"\"))\n        transposed (change-char cleaned)\n        swapped (clojure.string\/replace transposed #\"(\\S)(\\S)\" \"$2$1\")\n        squeezed (clojure.string\/replace swapped #\"\\s+\" \" \")\n       ]\n    squeezed\n  ))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"56a69460be316ad501000041":[{"id":14464,"user_id":null,"body":"(ns diamond.core)\n\n(def upper clojure.string\/upper-case)\n\n(defn up-to [c]\n (let [alphabet (if (number? c) \n                   (map str (rest (range))) \n                   ((if (= c (upper c)) upper identity) \"abcdefghijklmnopqrstuvwxyz\"))\n       ind (if (number? c) c (inc (.indexOf alphabet c)))\n       dashes (fn [n] (apply str (repeat n \"-\")))\n       half-answer (->> alphabet\n                    (take (inc ind))\n                    (map (fn [wings middle letter] \n                           (str wings \n                                letter \n                                (if (seq middle) \n                                  (str middle letter) \n                                  \"\") \n                                wings))\n                      (map dashes (range (dec ind) -1 -1)) ;wings\n                      (map dashes (range -1 (* 2 ind) 2))))] ;middle\n      (concat half-answer \n              (-> half-answer reverse rest))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14465,"user_id":null,"body":"(ns diamond.core)\n\n(defn gen-diamond [start end curr dir coll lett]\n  (if (= (+ end dir) curr)\n    coll\n    (do \n    (def sysm (if lett (str (char curr)) curr))\n    (def line \n      (if (or (= curr start) (and (= -1 dir) (= curr end)))\n        (do\n          (def sides (apply str (repeat (Math\/abs (- curr (if (= 1 dir) end start))) \"-\")))\n          (str sides sysm sides))\n        (do\n          (def sides (apply str (repeat (Math\/abs (- curr (if (= 1 dir) end start))) \"-\")))\n          (def middle (apply str (repeat (+ -1 (* 2 (Math\/abs (- curr (if (= -1 dir) end start))))) \"-\")))\n          (str sides sysm middle sysm sides))\n        ))\n    (gen-diamond start end (+ curr dir) dir (conj coll line) lett)))\n)\n\n(defn up-to [c]\n  (if (string? c)\n    (do\n      (def asc (int (first c)))\n      (if (and (> asc 64) (< asc 91))\n        (vec (concat (gen-diamond 65 asc 65 1 [] true) (gen-diamond asc 65 (- asc 1) -1 [] true)))\n        (vec (concat (gen-diamond 97 asc 97 1 [] true) (gen-diamond asc 97 (- asc 1) -1 [] true))))\n      )\n    (vec (concat (gen-diamond 1 c 1 1 [] false) (gen-diamond c 1 (- c 1) -1 [] false))))   \n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14466,"user_id":null,"body":"(ns diamond.core\n(:import java.lang.Character))\n\n(defn char-or-number-range [end]\n  (if (number? end)\n    (range 1 (inc end))\n      (map char (range (int  (if (empty? (re-seq #\"[a-z]\" end)) \\A \\a)) (inc (int (apply char end)))))\n   ))\n\n(defn diamond [sequence row]\n  (map-indexed #(apply str (assoc (assoc row (- (dec (count row)) %1) %2) %1 %2)) (reverse sequence))\n  ) \n\n(defn up-to [end]\n(let [sequence (char-or-number-range end)]\n (let [row (into [] (repeat (dec (* 2 (count sequence))) \"-\"))]\n  (if (= 1 (count sequence)) \n   [(apply str sequence)]  \n     (into  [] (concat (drop-last (reverse (diamond sequence row))) (diamond sequence row)))\n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"57c038a64f5f01348f000185":[{"id":14467,"user_id":501,"body":"(ns codewars.palindrome)\n(require '[clojure.string :as s])\n\n(defn smallest-palindrome [n]\n    (defn pal? [x] (= (str x) (s\/reverse (str x))))\n    (defn help [n] (for [i (range 1 1000)] (if (pal? (* i n)) (* i n) )))\n    (first (drop-while nil? (help n)))    \n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14468,"user_id":527,"body":"(ns codewars.palindrome)\n\n(defn smallest-palindrome [n]\n  (loop [m n]\n    (let [sm (str m)]\n      (if (= sm (clojure.string\/reverse sm)) m (recur (+ m n))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14469,"user_id":233,"body":"(ns codewars.palindrome)\n\n(defn palindrome? [n]\n  (let [s (str n)]\n    (= s (apply str (reverse s)))))\n    \n(defn smallest-palindrome[n]\n  (first (filter palindrome? (iterate #(+ % n) n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14470,"user_id":1887,"body":"(ns codewars.palindrome)\n\n(defn is-palindrome\n  [s]\n  (= (seq s)\n     (reverse s)))\n\n(defn smallest-palindrome\n  [n]\n  (loop [current n]\n    (if (is-palindrome (str current))\n      current\n      (recur (+ current n)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"57e8e9df2aee49c0280009ab":[{"id":14471,"user_id":null,"body":"(ns kata)\n\n(defn bareable [heat humidity]\n  (not (or (> humidity 0.5)\n           (>= heat 36)\n           (and (< 25 heat 36) (> humidity 0.4)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14472,"user_id":null,"body":"(ns kata)\n\n(defn bareable [heat humidity]\n  (cond \n    (> humidity 0.5) false\n    (>= heat 36) false\n    (and (> humidity 0.4) (> heat 25)) false\n    :else true))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14473,"user_id":201,"body":"(ns kata)\n\n(defn bareable [heat humidity]\n  (if (or (> humidity 0.5) (> heat 35)) false\n      (if (and (> heat 25) (< heat 36) (> humidity 0.4)) false true)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"584219caa87f764712000016":[{"id":14474,"user_id":1545,"body":"; Note 2016-12-02 - I don't think this will fly because it\n; requires a lib outside core, i.e. clojure.math.combinatorics\n(ns phonewords.core\n\t(:require [clojure.math.combinatorics :refer [cartesian-product]])\n\t(:require [clojure.string :refer [join]])\n\t)\n\n(defn phonechars\n\t\"Letters for given phone digit\"\n\t[digit]\n\t({\t\\1 \"1\" \\2 \"ABC\" \\3 \"DEF\"\n\t\t\\4 \"GHI\" \\5 \"JKL\" \\6 \"MNO\"\n\t\t\\7 \"PQRS\" \\8 \"TUV\" \\9 \"WXYZ\"\n\t\t\\0 \"0\"\n\t\t\\- \"-\" \\( \"(\" \\) \")\"\n\t\t} digit))\n\n(defn phonewords\n\t\"Turn provided digits into 'words'\"\n\t[digits]\n\t(map #(join \"\" %1)\n\t\t(apply cartesian-product (map phonechars digits)))\n\t)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"58e308e306bfe38dd700004a":[{"id":14475,"user_id":492,"body":"(ns clojure.fcc.factorialize)\n\n(defn factorialize\n  ([n acc] (if (< n 2) acc (recur (dec n) (* acc n))))\n  ([n] (factorialize n 1N)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14476,"user_id":null,"body":"(ns clojure.fcc.factorialize)\n\n(defn factorialize [n]\n  (reduce * (range 2 (inc n)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14477,"user_id":null,"body":"(ns clojure.fcc.factorialize)\n(defn factorialize [n] (if (> n 1) (* n (factorialize (dec n))) 1))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14478,"user_id":233,"body":"(ns clojure.fcc.factorialize)\n\n(defn factorialize [n]\n  (reduce * (range 1 (+ n 1))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14479,"user_id":null,"body":"(ns clojure.fcc.factorialize)\n\n(defn factorialize [n]\n  (->> (iterate inc 1)\n       (take n)\n       (apply *)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14480,"user_id":1339,"body":"(ns clojure.fcc.factorialize)\n\n(defn factorialize [n]\n  (if (= n 0)\n    1\n    (* n (factorialize (- n 1)))\n  )\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14481,"user_id":1313,"body":"(ns clojure.fcc.factorialize)\n\n(defn factorialize [n]\n  (if (< n 2) 1 (* n (factorialize (dec n)))))\n\n\n;; someday i'll figure out how to use condp v_v\n\n;; (defn factorialize [n]\n;;   (condp #(%1 2 %2) n\n;;     < 1\n;;     >= :>> #(* % (factorialize (dec %)))\n;;   )\n;; )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14482,"user_id":294,"body":"(ns clojure.fcc.factorialize)\n\n(defn factorial\n  ([]      (factorial 0 1))\n  ([x fct] (let [new-fct (->> [1 (* x fct)]\n                              (map bigint) (apply max))]\n                (->> new-fct\n                    (factorial (inc x))\n                    (cons new-fct) (lazy-seq)))))\n\n(defn factorialize [n]\n  (->> (factorial) (take (inc n)) (last)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14483,"user_id":294,"body":"(ns clojure.fcc.factorialize)\n\n(defn factorialize [n]\n  (loop [mul n\n         fct 1]\n        (if (zero? mul) fct\n            (recur (dec mul) (* fct mul)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14484,"user_id":294,"body":"(ns clojure.fcc.factorialize)\n\n(defn factorialize [n]\n  (->> (inc n) (range 1) (reduce * 1)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"58e314997c3b89c69a000002":[{"id":14485,"user_id":null,"body":"(ns clojure.fcc.palindrome\n  (:require [clojure.string :as s]))\n\n(defn palindrome? [xs]\n  (let [forward (-> xs\n                    (s\/replace #\"[^a-zA-Z0-9]\" \"\")\n                    s\/lower-case)]\n    (if (= (s\/reverse forward) forward) true false)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14486,"user_id":421,"body":"(ns clojure.fcc.palindrome)\n\n(defn palindrome? [xs]\n  (def s (clojure.string\/replace (clojure.string\/lower-case xs) #\"[^a-z0-9]\" \"\"))\n  (= s (clojure.string\/reverse s))\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14487,"user_id":null,"body":"(ns clojure.fcc.palindrome)\n(require '[clojure.string :as str])\n\n(defn clean [xs]\n  (str\/lower-case (str\/replace xs #\"[^a-zA-Z0-9]\" \"\"))   \n)\n\n(defn palindrome? [xs]   \n   (= (apply str (reverse (clean xs))) (clean xs))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14488,"user_id":null,"body":"(ns clojure.fcc.palindrome\n  (require [clojure.string :as str]))\n\n(defn palindrome? [xs]\n  (let [valid-chars #{\\a \\b \\c \\d \\e \\f \\g \\h \\i \\j \\k \\l \\m \n \\o \\p \\q \\r \\s \\t \\u \\v \\w \\x \\y \\z\n                      \\1 \\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\0}\n        stripped (filter valid-chars (str\/lower-case xs))]\n    (= stripped (reverse stripped))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14489,"user_id":null,"body":"(ns clojure.fcc.palindrome\n (require [clojure.string :as str]))\n\n(defn palindrome? [xs]\n  (let [sanitized (str\/lower-case (apply str (re-seq #\"[A-Za-z0-9]+\" xs)))]\n   (= sanitized (str\/reverse sanitized))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14490,"user_id":149,"body":"(ns clojure.fcc.palindrome)\n\n(defn palindrome? [s]\n  ((fn [x] (= 0 (compare x (clojure.string\/reverse x)))) (clojure.string\/replace (clojure.string\/lower-case s) #\"[^a-z0-9]\" \"\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14491,"user_id":null,"body":"(ns clojure.fcc.palindrome)\n\n(defn palindrome? [xs]\n  (let [lower (clojure.string\/lower-case xs)\n        strin (re-seq #\"[a-z0-9]\" lower)]\n    (= strin (reverse strin))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14492,"user_id":null,"body":"(ns clojure.fcc.palindrome)\n\n(defn filter-one [xs]\n  (let\n    [xlower (clojure.string\/lower-case xs)]\n    xlower\n    (if (clojure.string\/includes? \"abcdefghijklmnopqrstuvwxyz0123456789\" xlower)\n      xlower\n      \"\")))\n;      xlower)))\n    \n  ;  (if (>= 0 (clojure.string\/index-of xlower \"abcdefghijklmnopqrstuvwxyz0123456789\"))\n  ;    xlower\n  ;    \"\")))\n\n(defn filtered [xs]\n  (if (= 0 (count xs))\n    \"\"\n    (str (filter-one (first xs))\n      (filtered (rest xs)))))\n  \n(defn palindromex? [xs]\n  (cond\n    (<= (count xs) 1)\n      true\n    (not=\n      (first xs)\n      (last xs))\n      false\n    :else (palindromex? (subs xs 1 (- (count xs) 1)))))\n\n(defn palindrome? [xs]\n  (palindromex? (filtered xs)))\n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14493,"user_id":null,"body":"(ns clojure.fcc.palindrome)\n\n(defn palindrome? [xs]\n  (def lx (clojure.string\/replace (clojure.string\/lower-case xs) #\"[^a-z0-9]\" \"\"))\n  (= lx (clojure.string\/reverse lx))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14494,"user_id":null,"body":"(ns clojure.fcc.palindrome)\n(defn palindrome? [xs]\n  (def s (clojure.string\/lower-case (clojure.string\/replace xs #\"[^A-Za-z\\d]\" \"\")))\n  (= s (clojure.string\/reverse s)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"58e3cf5b1efbd998af000113":[{"id":14495,"user_id":492,"body":"(ns clojure.fcc.find-longest-word)\n\n(defn find-longest-word [s]\n  (apply max (map count (clojure.string\/split s #\" \")))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14496,"user_id":null,"body":"(ns clojure.fcc.find-longest-word)\n(require '[clojure.string :as str])\n(defn find-longest-word [s]\n  (->> (str\/split s #\"\\W+\")\n    (map count)\n    (apply max)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14497,"user_id":null,"body":"(ns clojure.fcc.find-longest-word)\n\n(defn find-longest-word [s]\n  (->> s (re-seq #\"\\w+\") (map count) (apply max)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14498,"user_id":null,"body":"(ns clojure.fcc.find-longest-word\n  (require [clojure.string :as str]))\n\n(defn find-longest-word [s]\n  (->> (str\/split s #\" \")\n       (map count)\n       (apply max)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14499,"user_id":null,"body":"(ns clojure.fcc.find-longest-word\n  (:require [clojure.string :as str]))\n\n(defn find-longest-word [s]\n  (apply max (map count (str\/split s #\" \")))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14500,"user_id":502,"body":"(ns clojure.fcc.find-longest-word)\n\n(require '[clojure.string :as str])\n\n(defn find-longest-word [s]\n  (apply max (map count (str\/split s #\"\\s\"))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14501,"user_id":149,"body":"(ns clojure.fcc.find-longest-word\n  (:use [clojure.string :only (split)]))\n\n(defn find-longest-word [s]\n  (reduce max (map count (split s #\"\\s+\"))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14502,"user_id":null,"body":"(ns clojure.fcc.find-longest-word)\n(require '[clojure.string :as str :refer [split]])\n\n\n(defn find-longest-word [s]\n    (last (sort (map count (split s #\" \"))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14503,"user_id":null,"body":"(ns clojure.fcc.find-longest-word)\n(require '[clojure.string :as str :refer [split]])\n\n\n(defn find-longest-word [s]\n    (last (sort (map count (split s #\" \"))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14504,"user_id":233,"body":"(ns clojure.fcc.find-longest-word)\n\n(defn find-longest-word [s]\n  (reduce max (map count (clojure.string\/split s #\" \")))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"58e42e7fbf240f555800015b":[{"id":14505,"user_id":1750,"body":"(ns clojure.fcc.largest-of-four)\n\n(defn largest-of-four [xs]\n  (map #(apply max %) xs))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14506,"user_id":492,"body":"(ns clojure.fcc.largest-of-four)\n\n(defn mx [xs] (reduce max xs))\n(defn largest-of-four [xs]\n  (map mx xs)\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14507,"user_id":676,"body":"(ns clojure.fcc.largest-of-four)\n\n(def largest-of-four (partial map (partial apply max)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14508,"user_id":null,"body":"(ns clojure.fcc.largest-of-four)\n\n(defn largest-of-four [colls]\n  (map #(apply max %) colls))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14509,"user_id":149,"body":"(ns clojure.fcc.largest-of-four)\n\n(defn largest-of-four [xs]\n  (map (fn [x] (reduce max x)) xs))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14510,"user_id":null,"body":"(ns clojure.fcc.largest-of-four)\n\n(defn largest-of-four [xs]\n  (map #(reduce max %) xs)\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14511,"user_id":106,"body":"(ns clojure.fcc.largest-of-four)\n\n(defn largest-of-four [xs]\n  (map (fn [l] (apply max l)) xs)\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14512,"user_id":294,"body":"(ns clojure.fcc.largest-of-four)\n\n(defn largest-of-four [xs]\n  (map (partial apply max) xs))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"58e526a92daa3a96040000b3":[{"id":14513,"user_id":492,"body":"(ns clojure.fcc.title-case)\n\n(defn capit [s]\n    (if (< (count s) 2)\n      (.toUpperCase s)\n      (str (.toUpperCase (subs s 0 1))\n           (.toLowerCase (subs s 1)))))\n(defn title-case [s]\n    (let [v (clojure.string\/split s #\" \") w (map capit v)]\n        (clojure.string\/join \" \" w) ))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14514,"user_id":null,"body":"(ns clojure.fcc.title-case)\n\n(defn- is-lowercase? [s]\n  (and (>= (int s) (int \\a))\n       (<= (int s) (int \\z))))\n\n(defn- is-uppercase? [s]\n  (and (>= (int s) (int \\A))\n       (<= (int s) (int \\Z))))\n\n(defn- to-uppercase [s]\n  (char (+ (- (int s) (int \\a)) (int \\A))))\n\n(defn- to-lowercase [s]\n  (char (+ (- (int s) (int \\A)) (int \\a))))\n\n(defn upp [s]\n  (let [[x & xs] s]\n    (str\n     (if (is-lowercase? x) (to-uppercase x) x)\n     (apply str (mapv #(if (is-uppercase? %) (to-lowercase %) %) xs)))))\n\n(defn title-case [s]\n  (->> (clojure.string\/split s #\" \")\n       (mapv #(upp %))\n       (clojure.string\/join \" \")))\n\n(comment\n  (title-case \"sHoRt AnD sToUt\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14515,"user_id":421,"body":"(ns clojure.fcc.title-case)\n\n(defn title-case [s]\n  (clojure.string\/join \" \" (map #(str (clojure.string\/upper-case (subs % 0 1)) (clojure.string\/lower-case (subs % 1))) (clojure.string\/split s #\" \")))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14516,"user_id":null,"body":"(ns clojure.fcc.title-case\n  (require [clojure.string :as str]))\n\n(defn title-case [s]\n  (str\/join \" \" (->> (str\/split (str\/lower-case s) #\" \")\n                 (map #(str (str\/upper-case (str (first %))) (apply str (rest %)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14517,"user_id":149,"body":"(ns clojure.fcc.title-case\n  (:use [clojure.string :only (upper-case lower-case join)]))\n\n(defn title-case [s]\n  (clojure.string\/replace s #\"[\\w']+\" #(join \"\" [(upper-case (first %)) (lower-case (subs % 1))])))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14518,"user_id":575,"body":"(ns clojure.fcc.title-case)\n\n(defn capitalize [s]\n  (let [s (.toString s)]\n    (if (< (count s) 2)\n      (.toUpperCase s)\n      (str (.toUpperCase (subs s 0 1))\n(.toLowerCase (subs s 1))))))\n\n(defn title-case [s]\n  (clojure.string\/join \" \" (map capitalize (clojure.string\/split s #\" \")))\n)\n\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14519,"user_id":null,"body":"(ns clojure.fcc.title-case)\n(require '[clojure.string :as str])\n\n(defn title-case [s]\n  (str\/join \" \" (map #(str (str\/upper-case (subs % 0 1)) (str\/lower-case (subs % 1))) (str\/split s #\" \")))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14520,"user_id":null,"body":"(ns clojure.fcc.title-case)\n(defn title-case [s]\n  (defn tc [w] (str (clojure.string\/upper-case (subs w 0 1)) (clojure.string\/lower-case (subs w 1))))\n  (clojure.string\/join \" \" (map tc (clojure.string\/split s  #\" \"))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14521,"user_id":233,"body":"(ns clojure.fcc.title-case)\n\n(def capitalize clojure.string\/capitalize)\n\n(defn title-case [s]\n  (clojure.string\/join \" \"\n    (map capitalize (re-seq #\"\\S+\" s))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14522,"user_id":106,"body":"(ns clojure.fcc.title-case)\n(def c clojure.string\/capitalize)\n\n\n(defn title-case [s]\n  (clojure.string\/join \" \" (map c (clojure.string\/split s #\" \")))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"58e64fdd807dcd189d00002e":[{"id":14523,"user_id":168,"body":"(ns clojure.fcc.confirm-ending)\n\n(defn confirm-ending [s, target]\n  (= (take-last (count target) s) (seq target)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14524,"user_id":null,"body":"(ns clojure.fcc.confirm-ending)\n\n(defn confirm-ending [s, target]\n  (= target (apply str (drop (- (count s) (count target)) s))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14525,"user_id":149,"body":"(ns clojure.fcc.confirm-ending)\n\n(def confirm-ending clojure.string\/ends-with?)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14526,"user_id":149,"body":"(ns clojure.fcc.confirm-ending)\n\n(defn confirm-ending [a b]\n  (= 0 (compare (subs a (- (count a) (count b))) b)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14527,"user_id":null,"body":"(ns clojure.fcc.confirm-ending)\n\n(defn confirm-ending [s, target]\n  (= (subs s (- (count s) (count target))) target)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14528,"user_id":null,"body":"(ns clojure.fcc.confirm-ending)\n(defn confirm-ending [s, target]\n  (def n (count s)) (def m (count target))\n  (and (>= n m) (= target (subs s (- n m) n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14529,"user_id":233,"body":"(ns clojure.fcc.confirm-ending)\n\n(defn confirm-ending [s, target]\n  (every? true?\n    (map = (reverse s) (reverse target))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14530,"user_id":null,"body":"(ns clojure.fcc.confirm-ending)\n\n(defn confirm-ending [s target]\n  (let [s-len (.length s)\n        t-len (.length target)]\n    (= (subs s (- s-len t-len) s-len) target)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14531,"user_id":294,"body":"(ns clojure.fcc.confirm-ending)\n\n(defn confirm-ending [s target]\n  (loop [s-rest (reverse s)\n         t-rest (reverse target)]\n        (cond (empty? t-rest)\n                true\n              (empty? s-rest)\n                false\n              (apply = (map first [s-rest t-rest]))\n                (recur (rest s-rest) (rest t-rest))\n              :else false)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14532,"user_id":294,"body":"(ns clojure.fcc.confirm-ending)\n\n(defn confirm-ending [s target]\n  (let [t-count (count target)\n        s-count (count s)]\n       (and (< t-count s-count)\n            (= (subs s (- s-count t-count)) target))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"58e65f3f2d653c8c5100003e":[{"id":14533,"user_id":676,"body":"(ns clojure.fcc.repeat-string)\n\n(defn repeat-string [s n]\n  (apply str (repeat n s)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14534,"user_id":168,"body":"(ns clojure.fcc.repeat-string)\n\n(defn repeat-string [s n]\n  (if (<= n 0) \"\"\n      (apply str (replicate n s))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14535,"user_id":null,"body":"(ns clojure.fcc.repeat-string\n  (require [clojure.string :as str]))\n\n(defn repeat-string [s n]\n  (str\/join \"\" (repeat n s)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14536,"user_id":2204,"body":"(ns clojure.fcc.repeat-string)\n\n(defn repeat-string [s n]\n  (cond\n    (< n 1) \"\"\n    (= n 1) s\n    :else (str s (repeat-string s (dec n)))\n  )\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14537,"user_id":null,"body":"(ns clojure.fcc.repeat-string)\n(defn repeat-string [s n] (if (> n 0) (reduce str s (repeat-string s (dec n))) \"\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14538,"user_id":233,"body":"(ns clojure.fcc.repeat-string)\n\n(defn repeat-string [s n]\n  (reduce str (repeat n s)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14539,"user_id":106,"body":"(ns clojure.fcc.repeat-string)\n\n(defn repeat-string [s n]\n  (if (< n 0) \"\" (clojure.string\/join (repeat n s)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14540,"user_id":294,"body":"(ns clojure.fcc.repeat-string\n  (require [clojure.string :as string]))\n\n(defn repeat-string [s n]\n  (loop [i  n\n         rs []]\n        (if (not (pos? i)) (string\/join rs)\n            (recur (dec i) (conj rs s)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14541,"user_id":294,"body":"(ns clojure.fcc.repeat-string\n  (require [clojure.string :as string]))\n\n(defn repeat-string [s n]\n  (-> (map (fn [_x] s) (range n))\n      (string\/join)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14542,"user_id":294,"body":"(ns clojure.fcc.repeat-string\n  (require [clojure.string :as string]))\n\n(defn repeat-string [s n]\n  (-> (repeat n s) (string\/join)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"58e669be0b0f7c509e000031":[{"id":14543,"user_id":null,"body":"(ns clojure.fcc.truncate-string)\n\n(defn truncate-string [s n]\n  (if (> (count s) n)\n    (str \n      (subs s 0 (if (<= n 3) n (- n 3))) \n      \"...\")\n    s))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14544,"user_id":null,"body":"(ns clojure.fcc.truncate-string)\n\n(defn truncate-string [s n]\n  (let [len (count s)]\n    (cond (<= len n) s\n          (> len n) (cond (> n 3) (str (subs s 0 (- n 3)) \"...\")\n                          :else (str (subs s 0 n) \"...\")))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14545,"user_id":149,"body":"(ns clojure.fcc.truncate-string)\n\n(defn truncate-string [s n]\n  (if (< n (count s)) (str (subs s 0 (if (< n 4) n (- n 3))) \"...\") s))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14546,"user_id":527,"body":"(ns clojure.fcc.truncate-string)\n\n(defn truncate-string [s n]\n  (let [trunc-len (if (<= n 3) n (- n 3))]\n    (if (<= (count s) n) s (str (subs s 0 trunc-len) \"...\"))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14547,"user_id":527,"body":"(ns clojure.fcc.truncate-string)\n\n(defn truncate-string [s n]\n  (let [len (count s) trunc-len (if (<= n 3) n (- n 3))]\n    (if (<= len n) s (str (subs s 0 trunc-len) \"...\"))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14548,"user_id":106,"body":"(ns clojure.fcc.truncate-string)\n\n(defn truncate-string [s n]\n  (if (> (count s) n) (str (subs s 0 (if (< n 3) n (- n 3))) \"...\") s)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14549,"user_id":294,"body":"(ns clojure.fcc.truncate-string)\n\n(defn truncate-string [s n]\n  (cond (>= n (count s)) s\n        (< n 4) (-> (subs s 0 n) (str \"...\"))\n        :else   (-> (subs s 0 (- n 3)) (str \"...\"))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14550,"user_id":null,"body":"(ns clojure.fcc.truncate-string)\n\n(defn truncate-string [s n]\n  (if (< n (count s))\n    (if (< n 3)\n      (str (subs s 0 n) \"...\")\n      (str (subs s 0 (- n 3)) \"...\"))\n    s))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14551,"user_id":null,"body":"(ns clojure.fcc.truncate-string)\n\n(defn truncate-string [s n]\n  (let [truncate\n        (fn [s n] (clojure.string\/join \"\" (conj (vec (take n s)) \"...\")))]\n    (if (< n (count s))\n      (condp > n\n        3 (truncate s n)\n        (truncate s (- n 3)))\n      s)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14552,"user_id":1750,"body":"(ns clojure.fcc.truncate-string)\n\n(defn truncate-string [s n]\n  (let [minus3 (- n 3)\n        end-at (if (> minus3 1) minus3 n)\n        truncate? (> (count s) n) ]\n    (if truncate?\n      (str (subs s 0 end-at) \"...\")\n      s)))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"58e677620b0f7cc508000053":[{"id":14553,"user_id":527,"body":"(ns clojure.fcc.chunky-monkey)\n\n(defn chunk-array-in-groups [xs n]\n  (partition-all n xs))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14554,"user_id":106,"body":"(ns clojure.fcc.chunky-monkey)\n\n(defn chunk-array-in-groups [xs n]\n (partition n n [] xs)\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14555,"user_id":null,"body":"(ns clojure.fcc.chunky-monkey)\n\n(defn chunk-array-in-groups [xs n]\n (loop [res []\n         xs xs]\n    (if (empty? xs)\n      res\n      (recur (conj res (take n xs)) (drop n xs))))\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14556,"user_id":676,"body":"(ns clojure.fcc.chunky-monkey)\n\n(defn chunk-array-in-groups [xs n] (partition n n nil xs))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14557,"user_id":1750,"body":"(ns clojure.fcc.chunky-monkey)\n\n(defn chunk-array-in-groups [xs n]\n  (let [red (fn [a b]\n              (let [lst (last a)]\n                (if (= n (count lst))\n                  (conj (vec a) [b])\n                  (conj (vec (butlast a)) (conj (vec lst) b)))))]\n    (reduce red [[]] xs)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"58e70e34eaf20691a4000031":[{"id":14558,"user_id":1750,"body":"(ns clojure.fcc.slasher)\n\n(defn slasher [xs n]\n  (drop n xs))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14559,"user_id":null,"body":"(ns clojure.fcc.slasher)\n\n(defn slasher [xs n]\n  (nthrest xs n)\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14560,"user_id":106,"body":"(ns clojure.fcc.slasher)\n(defn slasher [xs n] apply list (drop n xs))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14561,"user_id":575,"body":"(ns clojure.fcc.slasher)\n\n(defn slasher [xs n]\n  (vec (drop n xs))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14562,"user_id":null,"body":"(ns clojure.fcc.slasher)\n\n(defn slasher [xs n]\n  (nth (split-at n xs) 1)\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14563,"user_id":527,"body":"(ns clojure.fcc.slasher)\n\n(defn slasher [xs n]\n  (if (< n (count xs)) (subvec xs n) []))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"58e78ea9e89cdd0e3700001b":[{"id":14564,"user_id":149,"body":"(ns clojure.fcc.mutations\n  (:use [clojure.set]))\n\n(defn mutation [[a b]]\n  (clojure.set\/subset? (set (clojure.string\/lower-case b)) (set (clojure.string\/lower-case a))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14565,"user_id":492,"body":"(ns clojure.fcc.mutations (:require clojure.set))\n\n(defn mutation [[a b]]\n  (clojure.set\/subset? (set (seq (clojure.string\/lower-case b))) (set (seq (clojure.string\/lower-case a))))\n) ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14566,"user_id":null,"body":"(ns clojure.fcc.mutations\n  (require [clojure.set :as set]\n           [clojure.string :as str]))\n\n(defn mutation \n  [[a b]]\n  (let [set-a (into #{} (str\/split (str\/lower-case a) #\"\"))\n        set-b (into #{} (str\/split (str\/lower-case b) #\"\"))]\n    (empty? (set\/difference set-b set-a))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14567,"user_id":null,"body":"(ns clojure.fcc.mutations)\n(require '[clojure.string :as str])\n\n(defn mutation [[a b]]\n  (every? #(.contains (str\/lower-case a) %) (str\/split (str\/lower-case b) #\"\"))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14568,"user_id":null,"body":"(ns clojure.fcc.mutations)\n(defn mutation [[a b]]\n  (every? (set (clojure.string\/lower-case a)) (clojure.string\/lower-case b)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14569,"user_id":233,"body":"(ns clojure.fcc.mutations\n  (:require [clojure.string :as string])\n  (:require [clojure.set :as s]))\n\n(defn mutation [[a b]]\n  (s\/subset?\n    (set (string\/lower-case b))\n    (set (string\/lower-case a))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14570,"user_id":null,"body":"(ns clojure.fcc.mutations\n    (:use [clojure.set :only [subset?]]\n          [clojure.string :only [lower-case]]))\n\n(defn mutation [[a b]]\n  (let [lower-set (comp set lower-case)]\n    (subset? (lower-set b) (lower-set a))))\n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14571,"user_id":null,"body":"(ns clojure.fcc.mutations\n    (:use [clojure.set :only [subset?]])\n    (:use [clojure.string :only [lower-case]]))\n\n(defn mutation [[a b]]\n  (let [lower-set (comp set lower-case)]\n    (subset? (lower-set b) (lower-set a))))\n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14572,"user_id":106,"body":"(ns clojure.fcc.mutations)\n\n(defn mutation [[a b]]\n  (every? (set (clojure.string\/lower-case a)) (seq (clojure.string\/lower-case b)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14573,"user_id":676,"body":"(ns clojure.fcc.mutations\n  (:use [clojure.set :only (superset?)]\n        [clojure.string :only (lower-case)]))\n\n(defn mutation [[a b]]\n  (superset? (set (lower-case a)) (set (lower-case b))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"58e7b16936d4bbed5c0001b2":[{"id":14574,"user_id":527,"body":"(ns clojure.fcc.bouncer)\n\n(def bouncer (partial filter identity))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14575,"user_id":null,"body":"(ns clojure.fcc.bouncer)\n\n(defn bouncer [xs] \"filter out those falsy scum\"\n  (filter identity xs )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14576,"user_id":676,"body":"(ns clojure.fcc.bouncer)\n\n(def bouncer (partial filter boolean))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14577,"user_id":null,"body":"(ns clojure.fcc.bouncer)\n\n(defn bouncer [xs]\n  (filter boolean xs))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14578,"user_id":null,"body":"(ns clojure.fcc.bouncer)\n\n(defn bouncer [xs]\n (filter #(and (not (= % nil)) (not (= % false))) xs))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14579,"user_id":149,"body":"(ns clojure.fcc.bouncer)\n\n(defn bouncer [xs]\n  (filter (fn [x] (not (or (false? x) (nil? x)))) xs))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14580,"user_id":null,"body":"(ns clojure.fcc.bouncer)\n\n(defn bouncer [xs]\n  (filter #(and (not (false? %)) (not= nil %)) xs)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14581,"user_id":null,"body":"(ns clojure.fcc.bouncer)\n(defn bouncer [xs] (filter (complement false?) (filter some? xs)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14582,"user_id":233,"body":"(ns clojure.fcc.bouncer)\n\n(defn bouncer [xs]\n  (filter #(not (or (nil? %) (false? %))) xs))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14583,"user_id":571,"body":"(ns clojure.fcc.bouncer)\n\n(defn bouncer [xs]\n  (remove #(or (false? %) (nil? %)) xs)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"58e7c470de7139d09900002e":[{"id":14584,"user_id":527,"body":"(ns clojure.fcc.destroyer)\n\n(defn destroyer [xs & args]\n  (remove (set args) xs))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14585,"user_id":492,"body":"(ns clojure.fcc.destroyer)\n\n(defn destroyer [xs & args]\n    (filter #(not (contains? (set args) %1)) xs))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14586,"user_id":168,"body":"(ns clojure.fcc.destroyer)\n\n(defn destroyer [xs & args]\n  (let [s (set args)]\n    (filterv #(not (s %)) xs)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14587,"user_id":null,"body":"(ns clojure.fcc.destroyer)\n\n(defn destroyer [xs & args]\n  (let [args-set (set args)]\n    (->> xs\n      (filter #(not (contains? args-set %)))\n      (vec))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14588,"user_id":149,"body":"(ns clojure.fcc.destroyer)\n\n(defn destroyer [xs & ys]\n  (filter #(not (contains? (set ys) %)) xs))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14589,"user_id":233,"body":"(ns clojure.fcc.destroyer)\n\n(defn destroyer [xs & args]\n  (filter #(= -1 (.indexOf args %1)) xs))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14590,"user_id":1200,"body":"(ns clojure.fcc.destroyer)\n\n(defn destroyer [xs & args]\n  (let [[d & rest] args]\n    (if (nil? d)\n      xs\n      (recur (filter #(not= d %) xs) rest))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14591,"user_id":571,"body":"(ns clojure.fcc.destroyer)\n\n(defn destroyer [xs & args]\n  (remove (fn [k] (some #{k} args)) xs)\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14592,"user_id":106,"body":"(ns clojure.fcc.destroyer)\n\n(defn destroyer [xs & args]\n  (filter (fn [n] (not (contains? (set args) n))) xs)\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14593,"user_id":294,"body":"(ns clojure.fcc.destroyer)\n\n(defn destroyer [xs & args]\n  (-> (into #{} args) (complement) (filter xs)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"58e7cfc361d9ddbbe80000ef":[{"id":14594,"user_id":168,"body":"(ns clojure.fcc.get-index-to-insert)\n\n(defn get-index-to-insert [xs x]\n  (->> (sort xs)\n       (keep-indexed #(when (>= %2 x) %1))\n       (first)\n       (#(or % (count xs)))))\n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14595,"user_id":null,"body":"(ns clojure.fcc.get-index-to-insert)\n\n(defn get-index-to-insert [xs x]\n  (count (take-while #(< % x) (sort xs))))\n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14596,"user_id":149,"body":"(ns clojure.fcc.get-index-to-insert)\n\n(defn get-index-to-insert [xs n]\n  (count (filter #(> n %) (sort xs))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14597,"user_id":null,"body":"(ns clojure.fcc.get-index-to-insert)\n\n(defn get-index-to-insert [xs x]\n  (if (>= x (reduce max xs))\n    (count xs)\n    (do (loop [i 0]\n      (if (>= (nth (sort xs) i) x) i (recur (+ i 1))))\n    )\n  )\n) ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14598,"user_id":null,"body":"(ns clojure.fcc.get-index-to-insert)\n(defn get-index-to-insert [xs x]\n  (def s (sort xs))\n  (loop [i 0]\n    (if (and (< i (count s)) (> x (nth s i)))\n      (recur (inc i)) i)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14599,"user_id":233,"body":"(ns clojure.fcc.get-index-to-insert)\n\n(defn get-index-to-insert [xs x]\n  (count (filter #(< %1 x) xs))\n)  \n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14600,"user_id":233,"body":"(ns clojure.fcc.get-index-to-insert\n  (require [clojure.zip :as zip]))\n\n(defn find-index [xs fn]\n  (second\n    (first\n      (filter\n        #(fn (first %1))\n        (map vector xs (range (count xs)))))))\n\n(defn get-index-to-insert [xs x]\n  (let [idx (find-index (sort xs) #(>= %1 x))]\n    (if (nil? idx) (count xs) idx))\n)\n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14601,"user_id":106,"body":"(ns clojure.fcc.get-index-to-insert)\n(defn indices [pred coll] (keep-indexed #(when (pred %2) %1) coll))\n   \n(defn get-index-to-insert [xs x]\n  (if (<= x (apply min xs)) 0 (if (> x (apply max xs)) (count xs) (first (indices (fn [n] (>= n x)) (sort xs)))))\n)\n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14602,"user_id":294,"body":"(ns clojure.fcc.get-index-to-insert)\n\n(defn get-index-to-insert [xs x]\n  (-> (filter #(< % x) xs) (count)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14603,"user_id":294,"body":"(ns clojure.fcc.get-index-to-insert)\n\n(defn count-if [f xs]\n  (-> (filter f xs) (count)))\n\n(defn get-index-to-insert [xs x]\n  (count-if #(< % x) xs))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"58e7e40e8b3a3139780000da":[{"id":14604,"user_id":527,"body":"(ns clojure.fcc.rot13)\n\n(def rot13-map (zipmap \"ABCDEFGHIJKLMNOPQRSTUVWXYZ !?\" \"NOPQRSTUVWXYZABCDEFGHIJKLM !?\"))\n\n(defn rot13 [s]\n  (apply str (map rot13-map s)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14605,"user_id":106,"body":"(ns clojure.fcc.rot13)\n\n(defn shift [c]\n  (if (Character\/isLetter c)\n    (let [v (int c) \n          base (if (>= v (int \\a))\n                 (int \\a)\n                 (int \\A))]\n      (char (+ (mod (+ (- v base) 13) 26)\n               base)))\n    c))\n\n(defn rot13 [text]\n  (apply str (map #(shift %) text)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14606,"user_id":492,"body":"(ns clojure.fcc.rot13)\n\n(defn code-char [offset c]\n  (if (Character\/isLetter c)\n    (let [v (int c) \n          base (if (>= v (int \\a))\n                 (int \\a)\n                 (int \\A))\n          offset (mod offset 26)]\n      (char (+ (mod (+ (- v base) offset) 26)\n               base)))\n    c))\n(defn code [offset s]\n  (apply str (map #(code-char offset %) s)))\n(defn rot13 [s]\n  (code (- 13) s))\n \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14607,"user_id":null,"body":"(ns clojure.fcc.rot13)\n(require '[clojure.string :as string])\n(defn rot13 [s]\n  (string\/join\n    (map\n      (fn [x]\n        (char (if\n          (or (< x 65) (> x 90))\n          x\n          (+ (mod (+ (- x 65) 13) 26) 65)\n        ))\n      )\n      (map int (seq s)))\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14608,"user_id":1750,"body":"(ns clojure.fcc.rot13)\n\n(defn rot13 [s]\n  (reduce (fn [a b]\n            (let [cc (int b)\n                  to-str #(char (+ cc %))\n                  valid? (re-find #\"[A-Z]\" (str b))]\n              (cond\n                (and valid? (> cc 77)) (str a (to-str -13))\n                valid? (str a (to-str 13))\n                :else (str a b))))\n          \"\" s))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5a0e6c62ba2a143015000001":[{"id":14609,"user_id":527,"body":"(ns logic-toys.core\n  [:refer-clojure :exclude [==]]\n  [:require\n    [clojure.core.logic :refer :all]\n    [clojure.core.logic.fd :as fd]])\n    \n(defne ntho [xxs i y]\n  ([[x . _] 0 x])\n  ([[_ . xs] _ _] (fresh [j] (fd\/- i 1 j) (ntho xs j y))))\n\n(defne reverseo' [xxs ys rs]\n  ([[] rs _])\n  ([[x . xs] _ _] (fresh [rrs] (conso x rs rrs) (reverseo' xs ys rrs))))\n\n(defn reverseo [xs ys]\n  (reverseo' xs ys []))\n\n(defne subseto [xxs yys]\n  ([[] []])\n  ([xs [y . ys]] (subseto xs ys))\n  ([[y . xs] [y . ys]] (subseto xs ys)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14610,"user_id":null,"body":"(ns logic-toys.core\n  [:refer-clojure :exclude [==]]\n  [:require\n    [clojure.core.logic :refer :all]\n    [clojure.core.logic.fd :as fd]])\n    \n(defne ntho [coll n e]\n  ([[x . _] 0 x])\n  ([[_ . xs] _ _]\n    (fresh [m]\n      (fd\/- n 1 m)\n      (ntho xs m e))))\n\n(defne reverseo [lhs rhs]\n  ([() ()])\n  ([[x . xs] _]\n    (fresh [ys]\n      (reverseo xs ys)\n      (appendo ys [x] rhs))))\n\n(defne subseto [a b]\n  ([() ()])\n  ([[x . xs] [x . ys]] (subseto xs ys))\n  ([_ [_ . ys]]        (subseto a ys)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14611,"user_id":null,"body":"(ns logic-toys.core\n  [:refer-clojure :exclude [==]]\n  [:require\n   [clojure.core.logic :refer :all]\n   [clojure.core.logic.fd :as fd]])\n\n(defne ntho [l x ele]\n       ([[] _ _] fail)\n       ([[h . _] 0 h])\n       ([[_ . t] x1 ele]\n        (fresh [x2]\n               (fd\/- x1 1 x2)\n               (ntho t x2 ele))))\n\n(defne reverse-workero [xs ys zs]\n       ([() r r])\n       ([[h . ts] t r]\n        (fresh [l]\n               (conso h t l)\n               (reverse-workero ts l r))))\n\n(defn reverseo [xs ys]\n  (reverse-workero xs [] ys))\n\n(defne subseto [a b]\n  ([[] []])\n  ([[h . t] [h . t1]] (subseto t t1))\n  ([t [_ . t1]] (subseto t t1)))\n\n;; a as a subset of b\n;; note that all elements of b inputed\n;; will be distinct\n;; and that a and b will be sorted in the same way","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14612,"user_id":null,"body":"(ns logic-toys.core\n  [:refer-clojure :exclude [==]]\n  [:require\n    [clojure.core.logic :refer :all]\n    [clojure.core.logic.fd :as fd]])\n    \n(defne ntho [l x ele]\n  ([l 0 ele] (firsto l ele))\n  ([l x ele]\n   (fresh [r y]\n     (fd\/> x 0)\n     (resto l r)\n     (fd\/- x 1 y)\n     (ntho r y ele))))\n\n(defne reverseo [lhs rhs]\n  ([() ()])\n  ([[fx . rx]  y]\n   (fresh [bly]\n     (reverseo rx bly)\n     (appendo bly [fx] y)\n     )))\n\n(defne subseto [a b]\n  ([[fx . rx] y]\n   (fresh [u]\n     (conde\n      [(membero fx y) (nilo rx)]\n      [(rembero fx y u) (subseto rx u)]))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14613,"user_id":null,"body":"(ns logic-toys.core\n  [:refer-clojure :exclude [==]]\n  [:require\n    [clojure.core.logic :refer :all]\n    [clojure.core.logic.fd :as fd]])\n    \n(defne ntho [l x ele]\n  ([l 0 ele] (firsto l ele))\n  ([l x ele]\n   (fresh [r y]\n     (fd\/> x 0)\n     (resto l r)\n     (fd\/- x 1 y)\n     (ntho r y ele))))\n\n(defne reverseo [l r]\n  ([() ()])\n  ([[al . dl]  r]\n   (fresh [blr]\n     (fd\/bounded-listo blr 10)\n     (appendo blr [al] r)\n     (reverseo dl blr))))\n\n(defne subseto [a b]\n  ([[fx . rx] y]\n   (fresh [u]\n     (conde\n      [(membero fx y) (nilo rx)]\n      [(rembero fx y u) (subseto rx u)]))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14614,"user_id":106,"body":"(ns logic-toys.core\n  [:refer-clojure :exclude [==]]\n  [:require\n    [clojure.core.logic :refer :all]\n    [clojure.core.logic.fd :as fd]])\n\n\n(defne _ntho [l i e]\n  ([ls 0 _] (firsto ls e))\n  ([[_ . ls] _ _]\n    (fresh [j]\n      (fd\/- i 1 j)\n      (_ntho ls j e)\n    )\n  )\n)\n\n(defne counto [l len]\n  ([[] 0])\n  ([[_ . ls] len] \n    (fresh [lens]\n      (counto ls lens)\n      (fd\/- len 1 lens)\n    )\n  )\n)\n\n(defne ntho [l i ele]\n  ([_ _ _]\n    (fresh [e c]\n      (fd\/in i (fd\/interval 0 100))\n      (counto l c)\n      (fd\/< i c)\n      (_ntho l i e)\n      (== ele e)\n    )\n  )\n)\n\n(defne lasto [xs x]\n  ([[x . ()] _])\n  ([[_ . a] _] (lasto a x))\n)\n\n(defn reverseo [l r]\n  (fresh [a0, a1, l1, a2, l2, a3, l3, a4, l4, a5, l5, a6, l6, a7, l7, a8, l8, a9, l9, a10, l10\n         ,b0, b1, r1, b2, r2, b3, r3, b4, r4, b5, r5, b6, r6, b7, r7, b8, r8, b9, r9, b10, r10]\n    (conde\n      [(== l []) (== r [])]\n      [(firsto l a0) (resto l l1) (firsto l1 a1) (resto l1 l2) (firsto l2 a2) (resto l2 l3) (firsto l3 a3) (resto l3 l4) (firsto l4 a4) (resto l4 l5) (== l5 ()) (firsto r b0) (resto r r1) (firsto r1 b1) (resto r1 r2) (firsto r2 b2) (resto r2 r3) (firsto r3 b3) (resto r3 r4) (firsto r4 b4) (resto r4 r5) (== r5 ()) (== b4 a0) (== b3 a1) (== b2 a2) (== b1 a3) (== b0 a4)]\n      [(firsto l a0) (resto l l1) (firsto l1 a1) (resto l1 l2) (firsto l2 a2) (resto l2 l3) (firsto l3 a3) (resto l3 l4) (firsto l4 a4) (resto l4 l5) (firsto l5 a5) (resto l5 l6) (== l10 ()) (firsto r b0) (resto r r1) (firsto r1 b1) (resto r1 r2) (firsto r2 b2) (resto r2 r3) (firsto r3 b3) (resto r3 r4) (firsto r4 b4) (resto r4 r5) (firsto r5 b5) (resto r5 r6) (== r6 ()) (== b5 a0) (== b4 a1) (== b3 a2) (== b2 a3) (== b1 a4) (== b0 a5)]\n      [(firsto l a0) (resto l l1) (firsto l1 a1) (resto l1 l2) (firsto l2 a2) (resto l2 l3) (firsto l3 a3) (resto l3 l4) (firsto l4 a4) (resto l4 l5) (firsto l5 a5) (resto l5 l6) (firsto l6 a6) (resto l6 l7) (firsto l7 a7) (resto l7 l8) (firsto l8 a8) (resto l8 l9) (firsto l9 a9) (resto l9 l10) (== l10 ()) (firsto r b0) (resto r r1) (firsto r1 b1) (resto r1 r2) (firsto r2 b2) (resto r2 r3) (firsto r3 b3) (resto r3 r4) (firsto r4 b4) (resto r4 r5) (firsto r5 b5) (resto r5 r6) (firsto r6 b6) (resto r6 r7) (firsto r7 b7) (resto r7 r8) (firsto r8 b8) (resto r8 r9) (firsto r9 b9) (resto r9 r10) (== r10 ()) (== b9 a0) (== b8 a1) (== b7 a2) (== b6 a3) (== b5 a4) (== b4 a5) (== b3 a6) (== b2 a7) (== b1 a8) (== b0 a9)]\n    )\n  )\n)\n\n(defn subseto [a b]\n  (fresh [e0, e1, l1, e2, l2, e3, l3]\n    (conde\n      [(== a ())]\n      [(firsto a e0) (resto a l1) (== l1 ()) (membero e0 b)]\n      [(firsto a e0) (resto a l1) (firsto l1 e1) (resto l1 l2) (== l2 ()) (membero e0 b) (membero e1 b) (fd\/distinct [e0 e1])]\n      [(firsto a e0) (resto a l1) (firsto l1 e1) (resto l1 l2) (firsto l2 e2) (resto l2 l3) (== l3 ()) (membero e0 b) (membero e1 b) (membero e2 b) (fd\/distinct [e0 e1 e2])]\n      ;;[(firsto a e) (resto a l) (membero e b) (subseto l b)]\n    )\n  )\n)\n\n;; a as a subset of b\n;; note that all elements of b inputed\n;; will be distinct\n;; and that a and b will be sorted in the same way\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14615,"user_id":1637,"body":"(ns logic-toys.core\n  [:refer-clojure :exclude [==]]\n  [:require\n    [clojure.core.logic :refer :all]\n    [clojure.core.logic.fd :as fd]])\n    \n    \n(defne ntho [coll index x]\n       ([[a . _] 0 x] (== a x))\n       ([[_ . a] n x]\n         (fresh [c]\n                (fd\/- n 1 c)\n                (ntho a c x))))\n                \n(defne reverseo' [a b c]\n  ([[] x x])\n  ([[h . t] z acc]\n    (fresh [l]\n           (conso h acc l)\n           (reverseo' t z l))))\n\n(defn reverseo [a b]\n  (reverseo' a b []))\n  \n(defne subseto [a b]\n  ([[] []])\n  ([[h . tl] [h . tl']] (subseto tl tl'))\n  ([xs [_ . tl]] (subseto xs tl)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5adf3cd70774db8e8c000007":[{"id":14616,"user_id":62,"body":"(ns kata)\n\n(defn porges-cycle \n  ([n] (porges-cycle n (set [])))\n  ([n seen?]\n   (cond (= 1 n) -1 \n         (seen? n) n \n         :default (recur (reduce + (map (comp #(* % %) read-string str) (str n))) (conj seen? n)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14617,"user_id":null,"body":"(ns kata)\n\n(defn split-into-digits [x]\n  (map #(Character\/digit % 10) (str x))\n  )\n\n(defn sum-digit-squares [x]\n  (reduce + (map #(* % %) (split-into-digits x)))\n  )\n\n(defn porges-cycle\n  ([x] (porges-cycle x #{x}))\n  ([x used]\n   (let [square (sum-digit-squares x)]\n     (if (= 1 square)\n       -1\n       (if (contains? used square)\n         square\n         (recur square (conj used square))\n         ))\n     )\n   )\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14618,"user_id":null,"body":"(ns kata)\n\n(defn- num-digits [n]\n  (vec (for [n (str n)] (- (byte n) 48))))\n\n(defn- sum-sqr-digs [n]\n  (transduce (map #(* % %)) + (num-digits n)))\n\n(defn porges-cycle [n]\n  (loop [x n s #{}]\n    (cond\n      (= x 1) -1\n      (contains? s x) x\n      :else (recur (sum-sqr-digs x) (conj s x)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14619,"user_id":null,"body":"(ns kata)\n\n(defn sum-square-digits [num]\n  (->> num\n       str\n       (map (comp read-string str))\n       (reduce (fn [acc i] (+ acc (* i i))) 0)))\n\n(defn solve [n s]\n  (if (= n 1)\n    -1\n    (let [x (sum-square-digits n)]\n      (if (s x) \n        x\n        (recur x (conj s x))))))\n\n(defn porges-cycle [n]\n  (solve n #{n}))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14620,"user_id":527,"body":"(ns kata)\n\n(defn- digits [n]\n  (if (zero? n) () (cons (rem n 10) (digits (quot n 10)))))\n\n(defn- porges-cycle-step [n]\n  (->> n digits (map #(* % %)) (apply +)))\n\n(defn porges-cycle [n]\n  (let [\n      n (->> n\n        (iterate porges-cycle-step)\n        (reduce (fn [seen n] (if (seen n) (reduced n) (conj seen n))) #{}))]\n    (if (= n 1) -1 n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14621,"user_id":527,"body":"(ns kata)\n\n(defn- digits [n]\n  (if (zero? n) () (cons (rem n 10) (digits (quot n 10)))))\n\n(defn- porges-cycle-step [n]\n  (->> n digits (map #(* % %)) (apply +)))\n\n(defn porges-cycle [n]\n  (loop [n n seen #{}]\n    (if (seen n)\n      (if (= 1 n) -1 n)\n      (recur (porges-cycle-step n) (conj seen n)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14622,"user_id":201,"body":"(ns kata)\n\n(defn porges-cycle [n]\n  (loop [n    n\n         seen #{}]\n    (cond (contains? seen n) n\n          (= 1 n)            -1\n          :else              (recur (reduce +\n                                            (map #(* % %)\n                                                 (map (fn [x] (- (int x) 48))\n                                                      (str n)))) \n                                    (conj seen n)))))\n\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5bd4c8977645b9a02d00018c":[{"id":14623,"user_id":106,"body":"(ns solution)\n\n(defn insert1 [[e l r] v]\n  (if (< v e) (\n    if (nil? l) [e [v nil nil] r] [e (insert1 l v) r]\n  ) (\n    if (nil? r) [e l [v nil nil]] [e l (insert1 r v)]\n  ))\n)\n\n(defn insert [tree & values]\n  (reduce (fn [tree value]\n    (if (nil? tree) [value nil nil] (insert1 tree value))\n  ) tree values)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14624,"user_id":149,"body":"(ns solution)\n\n(defn f [node v] (if (= node nil) [v nil nil] (if (< v (get node 0)) [(get node 0) (f (get node 1) v) (get node 2)] [(get node 0) (get node 1) (f (get node 2) v)])))\n\n(defn insert [tree & values] (reduce f tree values))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14625,"user_id":null,"body":"(ns solution)\n\n(defn root [tree] (first tree))\n(defn left [tree] (second tree))\n(defn right [tree] (nth tree 2))\n\n(defn insert [tree & values]\n\n  (if (empty? values)\n    tree\n    (if (nil? tree)\n      (apply insert [(first values) nil nil] (rest values))\n      (if (< (first values) (root tree))\n        (apply insert [(root tree) (insert (left tree) (first values)) (right tree)] (rest values))\n        (apply insert [(root tree) (left tree) (insert (right tree) (first values))] (rest values))\n\n      )\n  \n    )\n\n  )\n\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14626,"user_id":null,"body":"(ns solution)\n\n(defn insert [tree & values]\n  (if \n    (empty? values) tree\n  (if \n    (nil? tree) (apply insert [(first values) nil nil] (rest values))\n  (if (< (first values) (first tree)) \n        (apply insert [(first tree) (insert (second tree) (first values)) (nth tree 2)] (rest values))\n        (apply insert [(first tree) (second tree) (insert (nth tree 2) (first values))] (rest values))\n      )\n  ))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14627,"user_id":null,"body":"(ns solution)\n\n(defn root [tree] (first tree))\n(defn leftPart [tree] (second tree))\n(defn rightPart [tree] (nth tree 2))\n\n(defn insert [tree & values]\n   (cond\n    (empty? values) tree\n    (nil? tree) (apply insert [(first values) nil nil] (rest values))\n    (< (first values) (root tree))\n      (apply insert [(root tree) (insert (leftPart tree) (first values)) (rightPart tree)] (rest values))\n    :else\n      (apply insert [(root tree) (leftPart tree) (insert (rightPart tree) (first values))] (rest values))\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14628,"user_id":null,"body":"(ns solution)\n(defn insert [tree & values]\n  (cond\n    (empty? values) tree\n    (nil? tree) (apply insert [(first values) nil nil] (rest values)) \n    (< (first values) (first tree))\n        (apply insert [(first tree) (insert (second tree) (first values)) (last tree)] (rest values))\n    :else (apply insert [(first tree) (second tree) (insert (last tree) (first values))] (rest values))\n  )\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14629,"user_id":null,"body":"(ns solution)\n\n(defn insert [tree & values]\n  (cond \n    (empty? values) tree\n\n    (nil? tree) (apply insert [(first values) nil nil] (rest values))\n\n    (< (first values) (first tree)) (apply insert [(first tree) (insert (second tree) (first values)) \n    (nth tree 2)] (rest values))\n\n    :else\n\n      (apply insert [(first tree) (second tree) (insert (nth tree 2) (first values))] (rest values))\n    )\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14630,"user_id":null,"body":"(ns solution)\n(defn root [tree] (first tree))\n(defn left [tree] (second tree))\n(defn right [tree] (nth tree 2))\n(defn insert [tree & values]\n  (cond\n   (= 0 (count values))\n      tree\n   (= tree nil)\n      (apply insert [(first values) nil nil] (rest values))\n   (< (first values) (root tree))\n      (apply insert [(root tree) (insert (left tree) (first values)) (right tree)] (rest values))\n   :else\n      (apply insert [(root tree) (left tree) (insert (right tree) (first values))] (rest values))\n  \n  \n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14631,"user_id":null,"body":"(ns solution)\n\n(defn left [tree] (second tree))\n(defn right [tree] (nth tree 2))\n(defn value [tree] (first tree))\n\n(defn insert [tree & values]\n  (cond\n    (empty? values) tree\n    (nil? tree) (apply insert [(first values) nil nil] (rest values)\n  )\n  :else (let [\n      root (first tree)\n      left (second tree)\n      right (nth tree 2)\n      val (first values)\n      tail (rest values)\n      ]\n      (if (< val root) \n        (apply insert [root (insert left val) right] tail)\n        (apply insert [root left (insert right val)] tail)\n      )\n    )\n  )\n)\n    ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14632,"user_id":null,"body":"(ns solution)\n\n(defn root [tree] (first tree))\n(defn right [tree] (nth tree 2))\n(defn left [tree] (second tree))\n\n(defn insert [tree & values]\n  (cond\n    (empty? values) tree\n    (nil? tree) (apply insert [(first values) nil nil] (rest values))\n    (< (first values) (root tree))\n      (apply insert [(root tree) (insert (left tree) (first values)) (right tree)] (rest values))\n      :else\n      (apply insert [(root tree) (left tree) (insert (right tree) (first values))] (rest values))\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5e320fe3358578001e04ad55":[{"id":14633,"user_id":571,"body":"(ns a)(defn is_check[b](some?(first(re-find(let[s\"(.{7}|.{11}|.{18}|.{20})\"q\"(.{9} )*.{9}\"c\"(((.{8} )*(.{8}))|((.{10} )*(.{10})))\"](re-pattern(str \"\u2654\"s\"\u265e|\u265e\"s\"\u2654|\u265f(.{8}|.{10})\"\"\u2654|\u2654\"q\"[\u265b\u265c]|[\u265b\u265c]\"q\"\u2654|[\u265b\u265c] *\u2654|\u2654 *[\u265b\u265c]|[\u265b\u265d]\"c\"\u2654|\u2654\"c\"[\u265b\u265d]\")))(apply str(map #(apply str(conj  %\"--\"))b))))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14634,"user_id":null,"body":"(ns a)(->>\"\u1464\u32e6\u3720\u34f3\u16e3\u3465\u31eb\u2de2\u2ea8\u3665\u3a5b\u2928\u3961\u3767\u32a0\u1c29\u3128\u3d69\u386d\u30f0\u1466\u37f2\u2df8\u1052\u1079\u1052\u2edb\u3ca0\u3c5d\u14a8\u336f\u395b\u2df8\u2ea8\u336c\u30f4\u3a65\u3720\u3129\u2ea8\u36ef\u3228\u34ee\u3a20\u3c29\u18b4\u14a9\u14f0\u1023\u146d\u30f0\u102b\u1025\u1025\u1929\u2328\u336e\u2de7\u2ea8\u336e\u2dd0\u2ea8\u336e\u2de6\u2ea8\u1473\u32f4\u146d\u30f0\u1023\u1467\u1025\u1066\u14d0\u14a9\u18b2\u14a9\u14a9\u2a20\u11a8\u3861\u3974\u34f4\u34ef\u3720\u1920\u18db\u12a0\u12b2\u142d\u1025\u14a8\u16a0\u12b2\u14a5\u2ea9\u3c28\u2328\u336e\u2df8\u1079\u2ea8\u366f\u37f0\u2de1\u1470\u1078\u1079\u14dd\u1469\u3328\u1ea8\u3120\u30a9\u1a29\u1472\u32e3\u3af2\u1470\u1078\u1061\u14a9\u1462\u1061\u14a9\u14a9\u14f6\u1454\u102d\u18a0\u18a9\u2c28\u2328\u31ef\u36f0\u1062\u1070\u14a9\u2928\u3c28\u2a20\u1820\u18a9\u14dd\u146e\u37f4\u16e5\u3b65\u3979\u1fa0\u376f\u3a28\u336f\u395b\u2de1\u1066\u2ee2\u2ea8\u147b\u1aa8\u39ef\u36e5\u16e6\u3728\u3c20\u3b29\u2929\u1c28\u2c28\u34ee\u3a6f\u1454\u1031\u1032\u14a8\u2a20\u1920\u18a9\u14a9\u1ca8\u2c28\u3a61\u35e5\u1032\u1076\u14a9\u1ba8\u3c20\u3b29\u1b20\u297d\u3320\u376f\u3a29\u30a9\u14a9\u14a9\"(mapcat #((juxt \/ mod)(int %)128))byte-array String. read-string eval)","lang_id":5,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14635,"user_id":62,"body":"(ns a)(defn is_check[b](let[r(range 8)z #(first(get-in b %))](=\\\u2654(some #{\\\u2654}(for[i r j r[p u]{\\\u265f[[1 -1]]\\\u265d[[1 -1]]\\\u265c[[0 -1]]\\\u265b[[0 1]]}s u :when(#{p}(z[i j]))](z(first(drop-while #(if(#{\\\u265d\\\u265c\\\u265b}p)(=\\space(z %)))(next(iterate(partial map + s)[i j]))))))))))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14636,"user_id":null,"body":"(ns a)(defn is_check[b](let[s(mapcat #(apply str 11 %)b)k(.indexOf s\\\u2654)f(fn[e l t](some(fn[d](l(some #(let[x(nth s % 1)]({\\space nil}x x))(take t(iterate #(+ % d)(+ d k))))))(map #(-(int %)53)e)))](some?(or(f\"+?46\"#{\\\u265c\\\u265b}8)(f\"*@,>\"#{\\\u265d\\\u265b}8)(f\")-!#A=IG\"#{\\\u265e}1)(f\"*,\"#{\\\u265f}1)))))\n","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"62830ab484bbe5105f738b72":[{"id":14637,"user_id":62,"body":"(ns cards)\n\n(defn remove-first\n  \"Remove the first instance of x from coll, if it exists.\"\n  [coll x]\n  (let [[left right] (split-with (partial not= x) coll)]\n    (concat left (rest right))))\n\n(def canonicalize (comp sort vals frequencies))\n(def cache (atom {}))\n\n(defn win-probability\n  \"Compute the probability of drawing k triples from a shuffled deck\n  before drawing any four of a kind.\"\n  ([n k] (win-probability n k (mapcat (partial repeat 4) (range n)) []))\n  ([n k deck drawn]\n\n   (let [multiples (canonicalize drawn)]\n        (cond (some #{4} multiples) 0 ;; four-of-a-kind: lose.\n              (>= (count (filter #{3} multiples)) k) 1 ;; k triples: win\n              (get @cache [n k multiples]) (get @cache [n k multiples])\n              :default\n              (let [outcome-cases\n                    (group-by\n                     (comp canonicalize :drawn)\n                     (for [card deck]\n                      {:deck (remove-first deck card),\n                       :drawn (cons card drawn)}))]\n\n                (\/ (reduce +\n                (for [[r outcomes] outcome-cases]\n                  (let [_ (or (get @cache [n k r])\n                              (swap! cache\n                                     assoc [n k r]\n                                     (win-probability n k\n                                      (:deck (first outcomes))\n                                      (:drawn (first outcomes)))))\n                        probability (get @cache [n k r])]\n                       \n                    (* (count outcomes) probability))))\n                   (count deck)))))))\n\n\n                  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14638,"user_id":527,"body":"(ns cards)\n\n(def win-probability [\n  nil\n  1\n  22001320979487476\/25082916539157575\n  2556075271418192\/3583273791308225\n  159390455943424\/295093135754795\n  271994909583168\/716654758261645\n  1232142119841792\/5016583307831515\n  81865825245184\/565780072311825\n  273425577852928\/3583273791308225\n  176348225585152\/5016583307831515\n  2533228544\/185806263485\n  4676648960\/1116036330997\n  3632267264\/3985844039275\n  4194304\/39688347475\n  0])","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14639,"user_id":53,"body":"(ns cards)\n\n(defn win-probability [k]\n  (cond\n    (= 1 k) 1\n    (= 2 k) 22001320979487476\/25082916539157575\n    (= 3 k) 2556075271418192\/3583273791308225\n    (= 4 k) 159390455943424\/295093135754795\n    (= 5 k) 271994909583168\/716654758261645\n    (= 6 k) 1232142119841792\/5016583307831515\n    (= 7 k) 81865825245184\/565780072311825\n    (= 8 k) 273425577852928\/3583273791308225\n    (= 9 k) 176348225585152\/5016583307831515\n    (= 10 k) 2533228544\/185806263485\n    (= 11 k) 4676648960\/1116036330997\n    (= 12 k) 3632267264\/3985844039275\n    (= 13 k) 4194304\/39688347475\n    :else 0))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14640,"user_id":149,"body":"(ns cards)\n\n(defn win-probability [n]\n  (nth '(1 22001320979487476\/25082916539157575 2556075271418192\/3583273791308225 159390455943424\/295093135754795 271994909583168\/716654758261645 1232142119841792\/5016583307831515 81865825245184\/565780072311825 273425577852928\/3583273791308225 176348225585152\/5016583307831515 2533228544\/185806263485 4676648960\/1116036330997 3632267264\/3985844039275 4194304\/39688347475 0) (- n 1))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14641,"user_id":106,"body":"(ns cards)\n\n(defn win-probability\n  \"Compute the probability of drawing k triples \n  from a shuffled deck before drawing any four of a kind.\"\n  [k]\n  (if (== 1 k) 1\n  (if (== 2 k) 22001320979487476\/25082916539157575\n  (if (== 3 k) 2556075271418192\/3583273791308225\n  (if (== 4 k) 159390455943424\/295093135754795\n  (if (== 5 k) 271994909583168\/716654758261645\n  (if (== 6 k) 1232142119841792\/5016583307831515\n  (if (== 7 k) 81865825245184\/565780072311825\n  (if (== 8 k) 273425577852928\/3583273791308225\n  (if (== 9 k) 176348225585152\/5016583307831515\n  (if (== 10 k) 2533228544\/185806263485\n  (if (== 11 k) 4676648960\/1116036330997\n  (if (== 12 k) 3632267264\/3985844039275\n  (if (== 13 k) 4194304\/39688347475\n  (if (== 14 k) 0\n  -1)))))))))))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"628871154a9bf80054dba387":[{"id":14642,"user_id":106,"body":"(ns pokemon.types)\n(require '[pokemon.data  :refer [types effectiveness]])\n\n(def chimeric-type [:flying :poison :poison :ground :steel :water :water :dark])\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14643,"user_id":62,"body":"(ns pokemon.types)\n(require '[pokemon.data  :refer [types effectiveness]])\n\n(def susceptibility \n  (apply merge-with merge {}\n         (for [[atk-type pairs] pokemon.data\/effectiveness\n               [def-type s] pairs]\n           {def-type {atk-type s}})))\n\n\n(defn total-susceptibility [chimera]\n  (apply merge-with *\n              (zipmap pokemon.data\/types (repeat 1))\n              (map susceptibility chimera)))\n\n(defn all-resistant? [chimera]\n    (every? #(< (val %) 1)\n            (total-susceptibility chimera)))\n\n(def all-chimeric-types\n  (apply concat\n         (iterate #(lazy-seq (distinct (for [s %, t pokemon.data\/types] (sort (cons t s))))) [[]])))\n\n\n(def resistant-chimeras\n  (lazy-seq \n  (->> all-chimeric-types\n       (drop-while #(< (count %) 7))\n       (take-while #(< (count %) 9))\n       (filter all-resistant?))))\n\n(def chimeric-type\n  \"A minimal list of types (such as [:water :poison :grass :grass :grass]) which \n  is resistant to every type.\"\n  [:water :dark :flying :ground :poison :poison :steel :water ]\n  ;;[:normal, :fighting, :flying, :rock, :ghost, :steel, :steel, :fire, :water, :grass, :electric, :dragon, :fairy]\n  \n  )\n\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14644,"user_id":106,"body":"(ns pokemon.types)\n(require '[pokemon.data  :refer [types effectiveness]])\n\n(def chimeric-type\n  \"A list of types, such as [:water :poison :grass :grass :grass], which \n  is collectively resistant to every type.\"\n  [:flying :poison :poison :ground :steel :water :water :fairy])\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"51c8e37cee245da6b40000bd":[{"id":14645,"user_id":null,"body":"(ns solution)\n\n(def rep clojure.string\/replace)\n\n(defn solution [t s]\n  (-> t\n      (rep (re-pattern (str \"[\" (apply str s) \"].*\")) \"\")\n      (rep #\"\\h+\n\" \"\n\")\n      (rep #\"\\h+$\" \"\")\n) )","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14646,"user_id":null,"body":"(ns solution\n  (:require [clojure.string :as s]))\n\n(defn solution [text syms]\n  (s\/join \"\n\"\n          (map (fn [line]\n                 (->> line\n                      (take-while #(not (contains? (set syms) (str %))))\n                      (s\/join \"\")\n                      (s\/trimr)\n                      ))\n               (s\/split text #\"\n\"))))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14647,"user_id":null,"body":"(ns solution)\n\n(defn solution [text comment-symbols]\n  (clojure.string\/join \"\n\"\n    (map \n        #(if (nil? %)\n           \"\"\n           (clojure.string\/trimr %))\n        (map\n          #(first (clojure.string\/split % (re-pattern (str \"[\" (apply str comment-symbols) \"]\"))))\n          (clojure.string\/split \n            text\n            #\"\n\")))))\n","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14648,"user_id":null,"body":"(ns solution\n  (:require [clojure.string :refer [join split split-lines trimr]]))\n\n(defn divline [ln re]\n  (let [ln (first (split ln re))]\n    (trimr (str \"\" ln))))\n\n(defn solution [text comment-symbols]\n  (let [lines (split-lines text)\n        re (re-pattern (join \"|\\\\\" comment-symbols))]\n    (join \"\n\" (map #(divline % re) lines))))\n","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14649,"user_id":null,"body":"(ns solution\n  (:require [clojure.string :as str]))\n\n(defn strip-line [text comment-symbols]\n  (let [len (count text)]\n    (->> comment-symbols\n      (map #(or (str\/index-of text %) len))\n      (apply min)\n      (subs text 0))))\n\n(defn solution [text comment-symbols]\n  (->> text\n      str\/split-lines\n      (map #(strip-line % comment-symbols))\n      (map str\/trimr)\n      (str\/join \"\n\")))\n","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14650,"user_id":null,"body":"(ns solution)\n(def not-empty? (comp not empty?))\n(def into-lines! (fn [t] (clojure.string\/split-lines t)))\n\n(defn line-has-comment-symb?\n  [line cmark]\n  (->> cmark\n       (map #(clojure.string\/includes? line %))\n       (filter true?)\n       not-empty?))\n\n(defn symbols->regex-pattern [symbs]\n  (re-pattern (str \"[\" (clojure.string\/join \"\" symbs) \"]\")))\n\n(defn before-comment-only! [text pattern]\n  (-> text (clojure.string\/split pattern) first))\n\n(defn with-pattern-remove-comments! [text symb]\n  (let [pattern (symbols->regex-pattern symb)]\n    (-> text (before-comment-only! pattern))))\n\n(defn remove-comment! [text symb]\n  (if (line-has-comment-symb? text symb)\n    (with-pattern-remove-comments! text symb)\n    text))\n\n(defn only-til-comment-or-empty-str\n  [comment-symbols lines]\n  (->> lines\n       (map #(remove-comment! % comment-symbols))\n       (map #(if (nil? %) \"\" %))))\n\n(defn solution [text comment-symbols]\n  (->> text\n       into-lines!\n       (only-til-comment-or-empty-str comment-symbols)\n       (map #(clojure.string\/trimr %))\n       (reduce (fn [acc cur] (str acc \"\n\" cur)))))\n","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14651,"user_id":null,"body":"(ns solution)\n\n(defn solution [text comment-symbols]\n  (->> (clojure.string\/split text #\"\n\")\n       (map #(take-while (complement (set (map first comment-symbols))) %))\n       (map (comp clojure.string\/trimr (partial apply str)))\n       (clojure.string\/join \"\n\")))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14652,"user_id":null,"body":"(ns solution\n  (:require [clojure.string :as s])\n  )\n\n(defn strip-from-line\n  [comment-symbols line]\n  (->>\n    line\n    (into [])\n    (take-while #(nil? ((into #{} (apply str comment-symbols)) %)))\n    (apply str)\n    (s\/trimr)\n    )\n  )\n \n(defn solution\n  [text comment-symbols]\n  (->>\n    text\n    (s\/split-lines)\n    (map (partial strip-from-line comment-symbols))\n    (s\/join \"\n\")\n    )\n)\n\n\n\n","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14653,"user_id":null,"body":"(ns solution)\n(require '[clojure.string :as str])\n\n(defn solution [text comment-symbols]\n  (->> text\n       (str\/split-lines)\n       (map (fn [l]\n              (subs l 0 (->> comment-symbols\n                             (map #(str\/index-of l %))\n                             (remove nil?)\n                             (apply (partial min (count l)))))))\n       (map #(str\/trimr %))\n       (str\/join \"\n\")))\n","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14654,"user_id":null,"body":"(ns solution\n  (:require [clojure.string :as st]))\n\n(defn solution [text comment-symbols]\n  (st\/replace text \n              (re-pattern (apply str \"\\\\s*?(?:[\" \n                                 (st\/re-quote-replacement (apply str comment-symbols))\n                                 \"].*?)?(?=\\\n|$)\"))\n              \"\"))","lang_id":5,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5263c6999e0f40dee200059d":[{"id":14655,"user_id":527,"body":"(ns observedpin)\n\n(def corrections {\n  \\1 \"124\"  \\2 \"1235\"  \\3 \"236\"\n  \\4 \"1457\" \\5 \"24568\" \\6 \"3569\"\n  \\7 \"478\"  \\8 \"57890\" \\9 \"689\"\n            \\0 \"80\"\n})\n\n(defn get_pins [observed]\n  (if (empty? observed)\n    [\"\"]\n    (let [heads (corrections (first observed)) tails (get_pins (rest observed))]\n      (for [d heads ds tails] (str d ds)))))\n","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14656,"user_id":null,"body":"(ns observedpin\n  (require [clojure.string]))\n\n(defn get-adjacent [x]\n  (case x\n    \\1 [1 2 4]   \\2 [1 2 3 5]   \\3 [2 3 6]\n    \\4 [1 4 5 7] \\5 [2 4 5 6 8] \\6 [3 5 6 9]\n    \\7 [4 7 8]   \\8 [0 5 7 8 9] \\9 [6 8 9]\n                 \\0 [0 8] ))\n\n(defn cart-prod [colls]  \n  (if (empty? colls)\n    '(())\n    (for [more (cart-prod (rest colls)) x (first colls)]\n      (cons x more))))\n  \n(defn get_pins [observed]  \n  (map clojure.string\/join (cart-prod (map get-adjacent (seq observed)))))","lang_id":5,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14657,"user_id":null,"body":"(ns observedpin\n(:require [clojure.string :as str]))\n\n(def neighbors {\\1 \"124\"\n                \\2 \"1235\"\n                \\3 \"236\"\n                \\4 \"1457\"\n                \\5 \"24568\"\n                \\6 \"3569\"\n                \\7 \"478\"\n                \\8 \"57890\"\n                \\9 \"689\"\n                \\0 \"80\"})\n\n\n(defn get_pins [input]\n  (->> (reduce #(for [x %1\n                      y (neighbors %2)]\n                  (conj x y)) [[]] (seq input))\n       (map str\/join)))","lang_id":5,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14658,"user_id":null,"body":"(ns observedpin)\n\n(def ^:private layout\n  [\"123\"\n   \"456\"\n   \"789\"\n   \" 0 \"])\n   \n(def ^:private adjacent\n  (into {} (for [i (range 4)\n                 j (range 3)]\n             [(get-in layout [i j])\n              (for [[id jd] [[-1 0] [0 -1] [0 0] [0 +1] [+1 0]]\n                    :when (<= 0 (+ i id) 3)\n                    :when (<= 0 (+ j jd) 2)\n                    :let [d (get-in layout [(+ i id) (+ j jd)])]\n                    :when (not= d \\space)]\n                d)])))\n  \n(defn get_pins [observed]\n  (if-let [[x & ys] (seq observed)]\n    (for [rest-of-pin (get_pins ys)\n          first-digit (get adjacent x)]\n      (str first-digit rest-of-pin))\n    [\"\"]))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14659,"user_id":571,"body":"(ns observedpin)\n(defn get_pins [observed]\n  (let [m {\"0\" [0 8] \"1\" [1 2 4] \"2\" [2 1 3 5] \"3\" [3 2 6] \"4\" [4 1 5 7] \"5\" [5 2 4 6 8] \"6\" [6 3 5 9] \"7\" [7 4 8] \"8\" [8 5 7 9 0] \"9\" [9 6 8] }\n        p (for [x (map str (seq observed))] (get m x))]\n    (loop [res (first p) tail (rest p)]\n      (if (= (count tail) 0) (map str res)\n        (recur (for [x res y (first tail)] (str x y)) (rest tail))))))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14660,"user_id":null,"body":"(ns observedpin)\n\n(def adjacent\n  {\"1\" [\"1\" \"2\" \"4\"]\n   \"2\" [\"1\" \"2\" \"3\" \"5\"]\n   \"3\" [\"2\" \"3\" \"6\"]\n   \"4\" [\"1\" \"4\" \"5\" \"7\"]\n   \"5\" [\"2\" \"4\" \"5\" \"6\" \"8\"]\n   \"6\" [\"3\" \"5\" \"6\" \"9\"]\n   \"7\" [\"4\" \"7\" \"8\"]\n   \"8\" [\"5\" \"7\" \"8\" \"9\" \"0\"]\n   \"9\" [\"6\" \"8\" \"9\"]\n   \"0\" [\"0\" \"8\"]\n   }\n  )\n\n(defn expand [observed]\n  (let [ dig-str (clojure.string\/split observed #\"\") \n         expanded-pins (into [] (map adjacent dig-str))\n        ]\n    expanded-pins\n    )\n)\n\n(defn folder\n  [acc elem]\n  (if (= acc [])\n    elem\n    (for [ p1 acc\n           p2 elem ]\n      (str p1 p2))\n    )\n  )\n\n(defn combine\n  [expanded-pins]\n  (reduce folder expanded-pins)\n  )\n\n(defn get_pins [observed]\n  (let [ expanded-pins (expand observed) \n        ]\n    (combine expanded-pins)\n    )\n)\n\n","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14661,"user_id":null,"body":"(ns observedpin)\n\n(defn generate-possible-combos\n  [possible-digits]\n  (reduce (fn [result vec]\n            (for [x result\n                  y vec]\n              (conj x y)))\n          [[]]\n          possible-digits))\n\n(defn get_pins\n  [observed]\n  (let [keypad (->> '(1 2 3 4 5 6 7 8 9 nil 0 nil)\n                    (partition 3)\n                    (mapv vec))\n        possible-digits (into {} (for [row (range 4)\n                                       col (range 3)\n                                       :let [keypad-val (get-in keypad [row col])]\n                                       :when (some? keypad-val)]\n                                   {keypad-val\n                                    (->> [[0 0] [-1 0] [1 0] [0 -1] [0 1]]\n                                         (mapv (partial mapv + [row col]))\n                                         (mapv (partial get-in keypad))\n                                         (filterv some?))}))]\n    (->> observed\n         (mapv #(Integer\/parseInt (.toString %)))\n         (mapv possible-digits)\n         generate-possible-combos\n         (mapv #(apply str %))\n         seq)))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14662,"user_id":null,"body":"(ns observedpin)\n\n(defn get_pins [observed]\n  (let [adj {\\1 \"124\"\n             \\2 \"1235\"\n             \\3 \"236\"\n             \\4 \"1457\"\n             \\5 \"24568\"\n             \\6 \"3569\"\n             \\7 \"478\"\n             \\8 \"57890\"\n             \\9 \"689\"\n             \\0 \"08\"}]\n    (reduce #(for [a % b (get adj %2)] (str a b))\n            '(\"\")\n            observed)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14663,"user_id":null,"body":"(ns observedpin)\n;; As a second pass on this, version that figures out the\n;; neighboring keys based on an 2-d representation of the keypad\n\n(def keypad [[1   2   3]\n             [4   5   6]\n             [7   8   9]\n             [nil 0 nil]]) ;; blank keys are marked as nils\n\n(def get-key (partial get-in keypad))\n\n(def shape (juxt count #(count (first %)))) ;; size of array as [(count rows) (count cols)]\n\n(defn get-key-neighbors [[r c]]\n  (filter identity\n          (map get-key [[r c]\n                        [(inc r) c] [r (inc c)]\n                        [(dec r) c] [r (dec c)]])))\n\n(defn to-char [x]\n  (first (char-array (str x))))\n\n(defn pair-key-with-neighbors-as-chars [k]\n  (if-let [key (get-key k)]\n    [(to-char key) (map to-char (get-key-neighbors k))]))\n\n(def adjkeys\n  (->>\n   (for [x (range (first (shape keypad)))\n         y (range (second (shape keypad)))]\n       [x y])\n   (map pair-key-with-neighbors-as-chars)\n   (into {})))\n\n;; https:\/\/stackoverflow.com\/questions\/18246549\/cartesian-product-in-clojure\n(defn cartesian-product [colls]\n  (if (empty? colls)\n    '(())\n    (for [more (cartesian-product (rest colls))\n          x (first colls)]\n      (cons x more))))\n\n(defn get_pins [observed]\n  (map #(apply str %) (cartesian-product (map adjkeys observed))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14664,"user_id":null,"body":"(ns observedpin)\n\n(def adjacents\n  {\"1\" [\"2\" \"4\"]\n   \"2\" [\"1\" \"3\" \"5\"]\n   \"3\" [\"2\" \"6\"]\n   \"4\" [\"1\" \"5\" \"7\"]\n   \"5\" [\"2\" \"4\" \"6\" \"8\"]\n   \"6\" [\"3\" \"5\" \"9\"]\n   \"7\" [\"4\" \"8\"]\n   \"8\" [\"5\" \"7\" \"9\" \"0\"]\n   \"9\" [\"6\" \"8\"]\n   \"0\" [\"8\"]})\n\n(defn combinations [ls]\n  (if (= (count ls) 1)\n    (first ls)\n    (mapcat #(map (comp (partial apply str)\n                        (partial cons %))\n                  (combinations (rest ls)))\n            (first ls))))\n\n(defn get_pins [observed]\n  (combinations\n   (map #(cons % (get adjacents %))\n        (map str observed))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"526d84b98f428f14a60008da":[{"id":14665,"user_id":null,"body":"(ns hamming-numbers)\n\n(defn interleave-sorted [& collections]\n  (lazy-seq\n   (let [colls (sort-by first collections)\n         coll  (first colls)]\n     (cons (first coll) (apply interleave-sorted (rest coll) (rest colls))))))\n\n(def hams\n  (lazy-seq\n   (distinct (cons 1 (interleave-sorted\n                      (map #(* 2 %) hams)\n                      (map #(* 3 %) hams)\n                      (map #(* 5 %) hams))))))\n\n(defn hamming [n]\n  (nth hams n))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14666,"user_id":2098,"body":"(ns hamming-numbers)\n\n(defn hamming [n]\n  (loop [index 0 queue (sorted-set 1)]\n    (let [elem (first queue) quasi (map (partial * elem) [2 3 5])]\n      (if (= index n) elem (recur (inc index) (apply conj (disj queue elem) quasi))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14667,"user_id":53,"body":"(ns hamming-numbers)\n\n(defn hamming [n]\n  (let [f (fn inner-lazy [s]\n              (let [e (first s)\n                    a (-> e (* 2))\n                    b (-> e (* 3))\n                    c (-> e (* 5))\n                    n-s (-> s (disj e) (conj a b c))]\n                (lazy-seq (cons e (inner-lazy  n-s)))))]\n      (->> (sorted-set 1) f (drop n) first)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14668,"user_id":null,"body":"(ns hamming-numbers)\n\n(defn smerge [xs ys]\n  (lazy-seq\n    (let [x (first xs)\n          y (first ys)\n          [z xs* ys*]\n          (cond\n            (< x y) [x (rest xs) ys]\n            (> x y) [y xs (rest ys)]\n            :else   [x (rest xs) (rest ys)])]\n      (cons z (smerge xs* ys*)))))\n \n(def ham\n  (lazy-seq\n    (->> (map #(* 2 %) ham)\n         (smerge (map #(* 3 %) ham))\n         (smerge (map #(* 5 %) ham))\n         (cons 1))))\n\n\n(defn hamming [n]\n  (nth ham n))\n      \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14669,"user_id":null,"body":"(ns hamming-numbers)\n\n(defn hamming-calc [[i j k]]\n  (* (Math\/pow 2 i) (Math\/pow 3 j) (Math\/pow 5 k)))\n\n(def alltheham (take 2000 (sort (map hamming-calc (for [i (range 0 100) j (range 0 100) k (range 0 100)] (vec [i j k]))))))\n\n(defn hamming [n]\n  (bigint (nth alltheham n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14670,"user_id":null,"body":"(ns hamming-numbers)\n(set! *unchecked-math* true)\n\n(defn smerge [xs ys]\n  (lazy-seq\n    (let [x (first xs)\n          y (first ys)\n          [small xs* ys*] (cond\n                            (< x y) [x (rest xs) ys]\n                            (> x y) [y xs (rest ys)]\n                            :else   [x (rest xs) (rest ys)])]\n      (cons small (smerge xs* ys*)))))\n \n(def hamm-seq \n  (lazy-seq\n    (->> (map #(* 5 %) hamm-seq)\n         (smerge (map #(* 3 %) hamm-seq))\n         (smerge (map #(* 2 %) hamm-seq))\n         (cons 1))))\n\n(defn hamming [n]\n  (last (take (inc n) hamm-seq)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14671,"user_id":null,"body":"(ns hamming-numbers)\n\n(defn mult-seq\n  [n ham-seq]\n  (let [max-num 8100000000]\n    (into (sorted-set) (filter #(<= % max-num) (map #(* n %) ham-seq)))\n    )\n  )\n\n(defn expand-seq\n  [ham-seq]\n  (reduce into (sorted-set) (map #(mult-seq % ham-seq) [1 2 3 5]))\n  )\n\n(defn gen-seq\n  [itr acc-seq]\n  (if (> itr 0)\n    (recur (dec itr) (expand-seq acc-seq))\n    acc-seq\n    )\n  )\n\n(def lookup (into [] (gen-seq 32 (sorted-set 1))))\n\n(defn hamming\n  [n]\n  (nth lookup n)\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14672,"user_id":null,"body":"(ns hamming-numbers)\n\n(defn init-seq\n  [& xs]\n  (into (sorted-set) xs)\n  )\n\n(defn mult-seq\n  [n ham-seq]\n  (let [max-num 8100000000]\n    (into (sorted-set) (filter #(<= % max-num) (map #(* n %) ham-seq)))\n    )\n  )\n\n(defn expand-seq\n  [ham-seq]\n  (reduce into (init-seq) (map #(mult-seq % ham-seq) [1 2 3 5]))\n  )\n\n(defn gen-seq\n  [itr acc-seq]\n  (if (> itr 0)\n    (recur (dec itr) (expand-seq acc-seq))\n    acc-seq\n    )\n  )\n\n(def lookup (into [] (gen-seq 32 (init-seq 1))))\n\n(defn hamming\n  [n]\n  (nth lookup n)\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14673,"user_id":null,"body":"(ns hamming-numbers)\n\n(defn lazy-merge [xs ys]\n  (lazy-seq\n   (cond\n     (< (first xs) (first ys)) (cons (first xs) (lazy-merge (rest xs) ys))\n     (> (first xs) (first ys)) (cons (first ys) (lazy-merge (rest ys) xs))\n     :else (cons (first xs) (lazy-merge (rest xs) (rest ys))))))\n\n(def hamming-seq\n  (lazy-seq\n   (->> (map #(* 2 %) hamming-seq)\n        (lazy-merge (map #(* 3 %) hamming-seq))\n        (lazy-merge (map #(* 5 %) hamming-seq))\n        (cons 1))))\n\n(defn hamming [n]\n  (nth hamming-seq n))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14674,"user_id":null,"body":"(ns hamming-numbers)\n(defn smerge [xs ys]\n  (lazy-seq\n    (let [x (first xs),\n          y (first ys),\n          [z xs* ys*]\n          (cond\n            (< x y) [x (rest xs) ys]\n            (> x y) [y xs (rest ys)]\n            :else   [x (rest xs) (rest ys)])]\n      (cons z (smerge xs* ys*)))))\n \n(def hammings\n  (lazy-seq\n    (->> (map #(*' 5 %) hammings)\n         (smerge (map #(*' 3 %) hammings))\n         (smerge (map #(*' 2 %) hammings))\n         (cons 1))))\n\n\n(defn hamming [n]\n  (last (take (+ n 1) hammings)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"52742f58faf5485cae000b9a":[{"id":14675,"user_id":null,"body":"(ns human-readable\n  (:require clojure.string))\n\n(defn- pluralize [[unit v]]\n  (when (and v (pos? v))\n    (str v \" \" unit (when (> v 1) \"s\"))))\n\n(defn format_duration [secs]\n  (if (zero? secs)\n    \"now\"\n    ; else\n    (-> {\"second\" 60   ; seconds-in-minute\n         \"minute\" 60   ; minutes-in-hour\n         \"hour\"   24   ; hours-in-day\n         \"day\"    365  ; days-in-year\n         \"year\"   nil} ; years-in-eternity\n      (->> \n        (reduce\n          (fn [[C qty]\n               [unit d]]\n            (let [modulus (if d (mod qty d) qty)]\n              [(cond-> C\n                 (pos? modulus)\n                 (assoc unit modulus))\n               (when d\n                 (quot qty d))]))\n          [{} secs])\n        first\n        (map pluralize)\n        reverse\n        (clojure.string\/join \", \"))\n      (clojure.string\/replace #\", ([^,]*)$\" \" and $1\"))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14676,"user_id":null,"body":"(ns human-readable)\n\n(def units\n  [{:name \"year\" :unit-duration 31536000}\n   {:name \"day\" :unit-duration 86400}\n   {:name \"hour\" :unit-duration 3600}\n   {:name \"minute\" :unit-duration 60}\n   {:name \"second\" :unit-duration 1}])\n\n(defn to-units [secs]\n  (loop [remaining secs\n         [unit & more-units] units\n         results []]\n    (if unit\n      (let [{name :name unit-duration :unit-duration} unit\n            unit-count (quot remaining unit-duration)]\n        (recur\n          (mod remaining unit-duration)\n          more-units\n          (if (pos? unit-count)\n            (conj results (str unit-count \" \" name (when (< 1 unit-count) \"s\")))\n            results)))\n      results)))\n\n(defn format_duration [secs]\n  (if-not (pos? secs)\n    \"now\"\n    (let [durations (to-units secs)]\n      (str (when (< 1 (count durations)) (str (clojure.string\/join \", \" (butlast durations)) \" and \")) (last durations)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14677,"user_id":null,"body":"(ns human-readable)\n\n(use '[clojure.string :only (join blank?)])\n\n(defn format_duration [secs]\n  (let [units [[60 \"second\"] [60 \"minute\"] [24 \"hour\"] [365 \"day\"] [(inc secs) \"year\"]]\n        extract-time (fn [[_ s _] [unit name]]\n                       (let [time (rem s unit)\n                             rem-time (quot s unit)\n                             name (join [name (if (== 1 time) \"\" \"s\")])]\n                         [time rem-time name]))\n        time-parts (->> (reductions extract-time [0 secs \"\"] units)\n                        (filter #(pos? (first %)))\n                        (map (fn [[s _ n]] (join [s \" \" n])))\n                        reverse)]\n    (if (zero? (count time-parts))\n      \"now\"\n      (join \" and \" (filter #(not (blank? %)) [(join \", \" (butlast time-parts)) (last time-parts)])))\n    ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14678,"user_id":null,"body":"(ns human-readable)\n\n(defn preformat [times]\n    (mapv (fn [[n u]] (if (> n 1) \n                          (str n \" \" u \"s\")\n                          (str n \" \" u)))\n          (filterv #(pos? (first %)) times)))\n      \n(defn neat [times]\n  (let [pf (preformat times)]\n    (if (= 1 (count pf))\n        (first pf)\n        (str (clojure.string\/join \", \" (butlast pf))\n             \" and \"\n             (last pf)))))\n             \n  \n(defn format_duration [secs]\n  (if (zero? secs)\n      \"now\"\n      (let [y (quot secs (* 60 60 24 365))\n            d (quot (- secs (* y 60 60 24 365)) (* 60 60 24))\n            h (quot (rem secs (* 24 60 60)) (* 60 60))\n            m (quot (rem secs (* 60 60)) 60)\n            s (rem secs 60)]\n           (neat [[y \"year\"] \n                  [d \"day\"] \n                  [h \"hour\"] \n                  [m \"minute\"] \n                  [s \"second\"]]))))\n           ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14679,"user_id":null,"body":"(ns human-readable)\n\n(defn format_duration [secs]\n  (if (zero? secs)\n    \"now\"\n    (letfn [(quot&rem [num] (juxt #(quot % num) #(rem % num)))\n            (apply-to-first [[h & r] f] (concat (f h) r))\n            (add-name [num name] (if (= num 0) nil (str num \" \" name (if (> num 1) \"s\"))))]\n      (as-> secs time\n            (reduce apply-to-first (list time)\n                    [(quot&rem 60) (quot&rem 60) (quot&rem 24) (quot&rem 365)])\n            (reverse time)\n            (map add-name time [\"second\" \"minute\" \"hour\" \"day\" \"year\"])\n            (filter (complement nil?) time)\n            ((fn [[last with-and & prev]]\n               (str (reduce #(str %2 \", \" %1)\n                            (if ((complement nil?) with-and) (str with-and \" and \"))\n                            prev) last)) time)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14680,"user_id":null,"body":"(ns human-readable\n  (:require [clojure.string :as st]))\n\n(defn fmt-unit [u n]\n  (cond (zero? n) nil\n        (= 1 n) (str n \" \" u)\n        :else (str n \" \" u \"s\")))\n        \n(defn fmt-result\n  ([lastp] lastp)\n  ([lastp & ps]\n    (str (st\/join \", \" (reverse ps))\n         \" and \"\n         lastp)))\n\n(defn format_duration [secs]\n  (if (zero? secs) \"now\"\n      (->> [60 60 24 365]\n           (reduce (fn [[tl left] v]\n                     [(conj tl (rem left v))\n                     (quot left v)])\n                   [[] secs])\n           flatten\n           (map fmt-unit \n                [\"second\" \"minute\" \"hour\" \"day\" \"year\"])\n           (filter (partial some?))\n           (apply fmt-result))))\n           ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14681,"user_id":null,"body":"(ns human-readable)\n\n(defn format_duration\n  ([secs ret-str-vec units unit-names]\n   (let [one-unit (reduce * units)\n         whole-unit (quot secs one-unit)\n         the-rest (rem secs one-unit)]\n      (if-not (seq units)\n        (clojure.string\/replace (clojure.string\/join \", \", ret-str-vec) #\",\\s(\\d+\\s\\w+)$\" \" and $1\")\n        (format_duration the-rest\n               (if (zero? whole-unit)\n                 ret-str-vec\n                 (conj ret-str-vec (format \"%s %s%s\" whole-unit (first unit-names) (if (= whole-unit 1) \"\" \"s\"))))\n               (rest units)\n               (rest unit-names)))))\n  ([secs]\n   (if (zero? secs)\n     \"now\"\n     (format_duration secs [] [365 24 60 60 1] [\"year\" \"day\" \"hour\" \"minute\" \"second\"]))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14682,"user_id":null,"body":"(ns human-readable\n  (:require [clojure.string :as str]))\n\n(def minute 60)\n(def hour (* minute 60))\n(def day (* hour 24))\n(def year (* day 365))\n\n(defn format_duration [secs]\n  (let [yrs (quot secs year)\n        days (-> secs (mod year) (quot day))\n        hours (-> secs (mod day) (quot hour))\n        minutes (-> secs (mod hour) (quot minute))\n        seconds (mod secs minute)\n        parsed [yrs days hours minutes seconds]]\n    (as-> parsed $\n          (map\n            (fn [num what]\n              (when (pos? num)\n                (str num \" \" what (when (> num 1) \"s\"))))\n            $\n            [\"year\" \"day\" \"hour\" \"minute\" \"second\"])\n          (filter identity $)\n          (case (count $)\n            0 [\"now\"]\n            1 $\n            (-> (interpose \", \" (butlast $))\n                vec\n                (concat [\" and \" (last $)])))\n          (apply str $))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14683,"user_id":null,"body":"(ns human-readable\n  (:require [clojure.string :as str]))\n\n(def seconds-in-minute 60)\n(def seconds-in-hour (* 60 seconds-in-minute))\n(def seconds-in-day (* 24 seconds-in-hour))\n(def seconds-in-year (* 365 seconds-in-day))\n\n(defn- formatTime [n name]\n  (if (zero? n)\n    \"\"\n    (str n \" \" (if (> n 1)\n                 (str name \"s\")\n                 name))))\n\n(defn format_duration [secs]\n  (if (zero? secs)\n    \"now\"\n    (let [duration-years (quot secs seconds-in-year)\n          secs-no-year (- secs (* duration-years seconds-in-year))\n          duration-days (quot secs-no-year seconds-in-day)\n          secs-no-days (- secs-no-year (* duration-days seconds-in-day))\n          duration-hours (quot secs-no-days seconds-in-hour)\n          secs-no-hours (- secs-no-days (* duration-hours seconds-in-hour))\n          duration-minutes (quot secs-no-hours seconds-in-minute)\n          duration-seconds (- secs-no-hours (* duration-minutes seconds-in-minute))\n          response-values (->> [(formatTime duration-years \"year\")\n                                (formatTime duration-days \"day\")\n                                (formatTime duration-hours \"hour\")\n                                (formatTime duration-minutes \"minute\")\n                                (formatTime duration-seconds \"second\")]\n                               (filter (fn [[v _]] (not (nil? v)))))]\n      (if (> (count response-values) 1)\n        (str (str\/join \", \" (drop-last response-values)) \" and \" (last response-values))\n        (apply str response-values)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14684,"user_id":null,"body":"(ns human-readable)\n\n(def durations (reverse\n                [[1 'second]\n                 [60 'minute]\n                 [(* 60 60) 'hour]\n                 [(* 60 60 24) 'day]\n                 [(* 60 60 24 365) 'year]]))\n(defn format_duration [acc x [[duration name] & rest]]\n  (let [curr (int (\/ x duration))\n        rem (- x (* curr duration))\n        acc' (if (zero? curr) acc\n                 (cons  (str curr \" \" name (if (= curr 1) \"\" \"s\")) acc))]\n    (if (empty? rest) acc' (recur acc' rem rest))))\n(defn weirdcat [[x & xs]]\n  (cond (empty? xs) x\n        (= 1 (count xs)) (str x \" and \" (weirdcat xs))\n        :else (str x \", \" (weirdcat xs))))\n(defn format_duration [x]\n  (if (zero? x) \"now\"\n      (->>\n       (format_duration [] x durations)\n       reverse\n       weirdcat)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"529bf0e9bdf7657179000008":[{"id":14685,"user_id":571,"body":"(ns sudoku)\n(defn valid_solution [board]\n  (every? #(= (sort %) (range 1 10))\n    (concat board\n    (partition 9 (apply interleave board))\n    (map flatten (partition 3 (apply interleave (map #(partition 3 %) board)))))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14686,"user_id":null,"body":"(ns sudoku)\n\n(defn slice-grid\n  [row-begin row-end column-begin column-end]\n  (fn [board]\n    (->> (subvec board row-begin row-end)\n         (map #(subvec % column-begin column-end))\n         (apply concat)\n         vec)))\n\n(def all-grids\n  [[0 3 0 3]\n   [0 3 3 6]\n   [0 3 6 9]\n   [3 6 0 3]\n   [3 6 3 6]\n   [3 6 6 9]\n   [6 9 0 3]\n   [6 9 3 6]\n   [6 9 6 9]])\n\n(defn invert\n  [board]\n  (-> (fn [pos] (mapv #(nth % pos) board))\n      (mapv (take 9 (range)))))\n\n(defn valid_solution\n  [board]\n  (let [count-rows #(->> % (remove zero?) set count)\n        vec-board (->> board (mapv vec))\n        grids (map #(% vec-board) (map #(apply slice-grid %) all-grids))]\n\n    (->> [vec-board (invert vec-board) grids]\n         (map #(map count-rows %))\n         (map #(apply + %))\n         (map #(= 81 %))\n         (every? true?))))\n\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14687,"user_id":null,"body":"(ns sudoku)\n(defn valid_solution [board]\n   (let  [\n     S (+ 1 2 3 4 5 6 7 8 9)\n     F (* 1 2 3 4 5 6 7 8 9)\n     rows board\n     cols (apply map vector board)\n     sqrs (mapcat (fn [q] (partition 9 (flatten (apply map vector q)))) (partition 3 board))]\n   (every? (fn [v] (and (= (apply * v) F) (= (apply + v) S))) (concat rows cols sqrs)))\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14688,"user_id":null,"body":"(ns sudoku)\n\n;;So that no zero is existent\n(defn valid-sum [row]\n  (= 45 (reduce + row)))\n\n(defn valid-rows [board]\n  (not (some #(= % false) (map #(and (distinct? %) (valid-sum %)) board))))\n  \n\n(defn valid-cols [board] \n  (valid-rows (apply mapv vector board)))\n\n(defn valid-sectors [board] \n  (->> board\n   (map #(partition 3 %))\n   (apply mapv vector) \n   (map #(partition 3 %)) \n   (apply concat)\n   (map #(flatten %))\n   (valid-rows)))\n  \n\n(defn valid_solution [board]\n  (and (valid-rows board) (valid-cols board) (valid-sectors board)))\n\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14689,"user_id":null,"body":"(ns sudoku)\n\n(def valid [1 2 3 4 5 6 7 8 9])\n\n(defn- status [coll]\n  (reduce\n   (fn [state e] (and state e))\n   true\n   coll))\n\n(defn- validate-lines [board]\n  (status (mapv #(= (sort %) valid) board)))\n\n(defn- validate-cols [board]\n  (validate-lines\n   (vec\n    (apply map vector board))))\n\n(defn- validate-inner [board]\n  (let [rows (partition 3 board)\n        transposed (map (fn [[a b c]] (partition 9 (interleave a b c))) rows)\n        result (map (fn [x] (map #(= (sort %) valid) x)) transposed)]\n    (status (flatten result))))\n\n(defn valid_solution [board]\n  (and\n   (validate-lines board)\n   (validate-cols board)\n   (validate-inner board)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14690,"user_id":null,"body":"(ns sudoku)\n\n(def zip (partial map vector))\n\n(defn valid_solution [board]\n  (let [rows board\n        columns (apply zip board)\n        regions (->> board\n                     (map (partial partition 3))\n                     (apply zip)\n                     (flatten)\n                     (partition 9))\n        allowed (set (range 1 10))]\n    (and (apply = allowed (map set (concat rows columns regions)))\n         (not-any? zero? (flatten board)))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14691,"user_id":null,"body":"(ns sudoku\n  (:require [clojure.set]))\n\n(defn valid-seq\n  [s]\n  (= 9 (count (clojure.set\/intersection (set s) #{1 2 3 4 5 6 7 8 9}))))\n\n\n(defn valid-rows\n  [board]\n  (reduce (fn [a row] (and a (valid-seq row)))\n          true\n          board))\n\n\n(defn valid-cols\n  [board]\n  (reduce (fn [a i] (and a (valid-seq (map (fn [r] (nth r i)) board))))\n          true\n          '(0 1 2 3 4 5 6 7 8)))\n\n\n(defn get-cell\n  [board cell-r cell-c]\n  (flatten (map (fn [r] (map (fn [c] (nth (nth board (+ (* 3 cell-r) r)) (+ (* 3 cell-c) c))) '(0 1 2))) '(0 1 2))))\n\n\n(defn get-cells\n  [board]\n  (reduce (fn [a r] (concat a (map (fn [c] (get-cell board r c)) '(0 1 2)))) '() '(0 1 2)))\n\n\n(defn valid-cells\n  [board]\n  (reduce (fn [a c] (and a (valid-seq c)))\n          true\n          (get-cells board)))\n\n\n(defn valid_solution\n  [board]\n  (and (valid-rows board) (valid-cols board) (valid-cells board)))\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14692,"user_id":null,"body":"(ns sudoku)\n\n(def cubes\n  (for [i [0 3 6]\n        k [0 3 6]]\n    [i k]))\n\n(def row-sum (reduce + (range 1 10)))\n\n(defn get-cube [board [x y]]\n  (mapcat #(concat (take 3 (drop x (nth board (+ y %)))))\n          (range 3)))\n\n(defn valid_solution [board]\n  (every? boolean\n          (map \n           (fn [rows]\n             (every? #(= (reduce + %) row-sum)\n                     rows))\n           [board\n            (apply map vector board)\n            (map (partial get-cube board) cubes)])))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14693,"user_id":null,"body":"(ns sudoku)\n\n(def valid-set #{1 2 3 4 5 6 7 8 9})\n\n(defn transpose\n  \"Transpose the board (columns become rows)\"\n  [board]\n  (apply map vector board))\n\n(def block-indexes\n  \"=> ([0 2] [3 5] [6 8])\"\n  (map #(vector (first %) (last %)) (partition-all 3 (range 0 9))))\n\n(def block-boundaries \n  \"=> ([0 2 0 2] [0 2 3 5] [0 2 6 8] \n       [3 5 0 2] [3 5 3 5] [3 5 6 8] \n       [6 8 0 2] [6 8 3 5] [6 8 6 8])\"\n  (for [top-bottom  block-indexes\n        left-right  block-indexes]\n    (flatten [top-bottom left-right])))\n\n(defn get-blocks\n  \"For each collection of indexes in block-boundaries,\n  return all the values from the board inside of the boundaries.\n  \n  i.e. return a new matrix with each block represented \n  as a row in the matrix\"\n  [board]\n  (for [[top bottom left right] block-boundaries]\n    (let [rows  (subvec board top (inc bottom))\n          block (map #(subvec % left (inc right)) rows)]\n      (flatten block))))                  \n\n(defn validate\n  \"For each row in the input matrix, check if the set of those\n  numbers equals the valid-set\"\n  [matrix]\n  (every? (fn [row] (= (set row) valid-set)) matrix))\n\n(defn valid_solution [board]\n  (and\n    (validate board)              ; rows\n    (validate (transpose board))  ; columns\n    (validate (get-blocks board)) ; blocks\n   ))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14694,"user_id":62,"body":"(ns sudoku)\n\n(defn blocks [board]\n  (apply concat\n         (map (fn [x]\n                (map #(apply concat %)\n                     (partition 3 (apply interleave (partition 3 x)))))\n                     (partition 9 (partition 3 (flatten board))))))\n(def rows identity)\n(def cols (partial apply map list))\n\n(defn valid_solution [board]\n (and (not-any? zero? (flatten board))\n      (every? (partial = [1 2 3 4 5 6 7 8 9])\n              (mapv sort\n                   (concat (rows board)\n                           (cols board)\n                           (blocks board))))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"52b7ed099cdc285c300001cd":[{"id":14695,"user_id":null,"body":"(ns sum_of_intervals.core)\n\n(defn sum_of_intervals\n  [intervals]\n  (->> intervals\n       (mapcat #(apply range %))\n       set\n       count))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14696,"user_id":null,"body":"(ns sum_of_intervals.core)\n\n(defn overlap? [[x y] [i j]] (not (or (> i y) (< j x))))\n   \n(defn merge-interval\n  \"Merge interval to the end of a sorted vector of intervals\"\n  [intervals [x y :as interval]]\n  (let [[i j :as last-int] (last intervals)]\n    (if (overlap? interval last-int)\n      (conj (vec (butlast intervals)) [(min x i) (max y j)])\n      (conj intervals interval)\n    )\n  )\n)\n\n(defn interval-length [[a b]] (- b a))\n\n(defn sum_of_intervals\n  [intervals]\n  (->> intervals\n       (sort)\n       (reduce merge-interval [[0 0]])\n       (map interval-length)\n       (reduce +)\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14697,"user_id":527,"body":"(ns sum_of_intervals.core)\n\n(defn sum_of_intervals [intervals]\n  (->> intervals\n    sort\n    (reductions (fn [[_b' e'] [b e]] [(max b e') (max e e')]))\n    (map (fn [[b e]] (- e b)))\n    (reduce +)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14698,"user_id":null,"body":"(ns sum_of_intervals.core)\n\n(defn sum_of_intervals\n  [intervals]\n  (count (reduce (fn [acc [start end]] (into acc (range start end))) #{} intervals)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14699,"user_id":53,"body":"(ns sum_of_intervals.core)\n\n(defn sum_of_intervals [intervals]\n  (count (set (flatten (for [interval intervals]\n    (for [i (range (first interval) (second interval))]\n      i))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14700,"user_id":null,"body":"(ns sum_of_intervals.core)\n\n;; Maps intervals onto a number line, tracking changes in the number of open intervals\n(defn to-numline [intervals]\n  (-> (fn [numline intv] \n        (-> numline \n          (assoc (first intv) (+ 1 (numline (first intv) 0))) \n          (assoc (last intv) (- (numline (last intv) 0) 1)))) \n    (reduce {} intervals)))\n\n;; Loops over numline keys, summing when all intervals have closed\n(defn sum_of_intervals [intervals]\n  (let [numline (to-numline intervals)]\n    (loop [ks (sort (keys numline))\n           opener nil\n           score 0\n           sum 0]\n      (let [k (first ks)\n            d (numline k)]\n        (cond\n          (nil? k) sum\n          (= 0 score) (recur (rest ks) k (+ score d) sum)\n          (= 0 (+ score d)) (recur (rest ks) nil 0 (+ sum (- k opener)))\n          :else (recur (rest ks) opener (+ score d) sum))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14701,"user_id":null,"body":"(ns sum_of_intervals.core)\n\n(defn sum_of_intervals\n  [intervals]  \n  (->> intervals\n    (mapcat (partial apply range))\n    set\n    count))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14702,"user_id":null,"body":"(ns sum_of_intervals.core)\n\n(defn sum_of_intervals [intervals]\n  (->> intervals\n       (sort)\n       (reductions (fn  [[a b] [c d]] [(max b c) (max b d)]))\n       (map (fn [[x y]] (- y x)))\n       (reduce +)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14703,"user_id":null,"body":"(ns sum_of_intervals.core)\n\n(defn r\n  [[a b]]\n  (range a b))\n\n(defn sum_of_intervals\n  [intervals]\n  (count (reduce #(apply conj %1 (r %2)) #{} intervals)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14704,"user_id":null,"body":"(ns sum_of_intervals.core)\n\n(defn remove-overlapping [intervals]\n  (loop [ivs (next intervals)\n         start (first (first intervals))\n         end (second (first intervals))\n         acc []]\n    (if-not ivs\n      (conj acc [start end])\n      (let [[start' end'] (first ivs)]\n        (if (<= start' end)\n          (recur (next ivs) start (max end end') acc)\n          (recur (next ivs) start' end' (conj acc [start end])))))))\n\n(defn sum_of_intervals [ivs]\n  (->> ivs\n       sort\n       remove-overlapping\n       (map (fn [[x y]] (- y x)))\n       (apply +)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"52f677797c461daaf7000740":[{"id":14705,"user_id":null,"body":"(ns smallest-sum.core)\n\n(defn gcd' [a b]\n  (if (zero? b) a\n      (gcd' b (mod a b))))\n\n(defn solution\n  [arr]\n  (let [gcd-all (reduce gcd' arr)]\n    (* (count arr)\n       gcd-all)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14706,"user_id":53,"body":"(ns smallest-sum.core)\n\n(defn gcd [a b] (if (zero? b) a (gcd b (mod a b))))\n(defn solution [arr] (* (count arr) (reduce gcd arr)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14707,"user_id":null,"body":"(ns smallest-sum.core)\n\n(defn _gcd [x y]\n  (let [a (max x y)\n        b (min x y)]\n    (if (zero? b)\n      a\n      (recur b (mod a b)))))\n\n(defn solution\n    [arr]\n      ; your code here\n      (let [c (count arr)]\n        (* c (reduce _gcd arr))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14708,"user_id":null,"body":"(ns smallest-sum.core)\n\n(defn- gcd [^long a ^long b]\n  (if (= b 0)\n    a\n    (gcd b (rem a b))))\n\n(defn solution [^clojure.lang.IPersistentVector v]\n  (* (.count v)\n     (reduce\n       (fn [^long d ^long n] (gcd d n))\n       (nth v 0)\n       v)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14709,"user_id":null,"body":"(ns smallest-sum.core)\n\n(defn gcd2 [a b]\n  (if (zero? b) a (recur b (mod a b))))\n\n(defn gcd [arr]\n  (loop [res (first arr)\n         arr (next arr)]\n    (if-not (seq arr)\n      res\n      (recur (gcd2 res (first arr)) (next arr)))))\n\n(defn solution [arr]\n  (* (count arr) (gcd arr)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14710,"user_id":null,"body":"(ns smallest-sum.core)\n\n(defn gcd\n  [a b]\n  (if (= b 0)\n    a\n    (recur b (rem a b))\n    )\n  )\n\n(defn solution\n  [arr]\n  (* (count arr) (reduce gcd (first arr) arr))\n  )\n\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14711,"user_id":null,"body":"(ns smallest-sum.core)\n\n(defn solution [arr]\n  (if (every? (partial = (first arr)) arr)\n    (* (first arr) (count arr))\n    (recur (map (let [m (apply min arr)]    ;this let is ugly but seems necessary for speed\n                  #(inc (rem (dec %) m)))   ;and I don't know how to compose it more elegantly\n                arr))))                     ;partial doesn't play nicely with rem here","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14712,"user_id":null,"body":"(ns smallest-sum.core)\n\n(defn solution\n  [arr]\n  (loop [min-number (apply min arr)\n         diff arr]\n    (if (every? (fn [n] (zero? (mod n min-number))) arr)\n      (* min-number (count arr))\n      (let [new-diff (->> diff\n                          (map (fn [n] (- n min-number)))\n                          (remove zero?))\n            new-min-number (apply min (conj new-diff))\n            new-min-number (if (< min-number new-min-number)\n                             (- new-min-number min-number)\n                             new-min-number)]\n        (recur new-min-number new-diff)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14713,"user_id":null,"body":"(ns smallest-sum.core)\n\n(defn mo [x s]\n  (def answer (mod x s))\n  (if (= answer 0)\n    s\n    answer))\n\n(defn calc [li]\n (def smallest (apply min li))\n  (map #(mo % smallest) li))\n\n(defn all-equal [li]\n  (count (distinct li)))\n\n(defn solution\n  [arr]\n  (loop [li arr]\n   (if (apply = li)\n     (reduce + li)\n     (recur (calc li)))\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14714,"user_id":null,"body":"(ns smallest-sum.core)\n\n(defn solution [arr]\n  (letfn [(find-lowest [x y] (if (zero? x) y (recur (mod y x) x)))]\n    (* (reduce find-lowest arr) (count arr))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"53f40dff5f9d31b813000774":[{"id":14715,"user_id":null,"body":"(ns random-triplets\n  (:require [clojure.set :as s]))\n\n(defn enposet [poset [a b c]]\n  \"Forms a map in which each letter is a key,\n  and the corresponding value is every letter\n  known to be greater-than it.\n  Takes the 'poset' we are building, and\n  the 'triplet' to add\"\n  (-> poset\n      (update a s\/union #{b c}) \n      (update b s\/union #{c})\n      (update c s\/union nil)))\n\n(defn find-least [poset]\n  \"Finds the letter which is not greater than any others\"\n  (first (s\/difference\n          (into #{} (keys poset))\n          (apply s\/union (vals poset)))))\n\n(defn recover_secret [triplets]\n  \"Solves the koan.\"\n  (loop [poset (reduce enposet {} triplets)\n         secret \"\"]\n    (if-let [least (find-least poset)]\n      (recur (dissoc poset least) (str secret least)) \n      secret)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14716,"user_id":null,"body":"(ns random-triplets\n  (:require [clojure.set :refer (union map-invert)]) )\n\n(defn recover_secret [triplets]\n  (letfn [(to-map [[a b c]] {a #{b} b #{c} c #{}})\n          (without [c m] (zipmap (map #(disj % c) (keys m)) (vals m))) ]\n    (loop [s nil m (map-invert (apply merge-with union (map to-map triplets)))]\n      (if-let [c (m #{})]\n        (recur (cons c s) (without c (dissoc m #{})))\n        (apply str s) ))))\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14717,"user_id":null,"body":"(ns random-triplets\n  (:require [clojure.set :refer [union subset?]]))\n\n(defn recover_secret [triplets]\n  (let [order (->> triplets\n                   (map (fn [[a b c]] {c #{a b} b #{a} a #{}}))\n                   (apply merge-with union))]\n    (loop [seen #{}\n           done []\n           order order]\n      (if-let [c (ffirst (filter (fn [[k v]] (subset? v seen)) order))]\n        (recur (conj seen c) (conj done c) (dissoc order c))\n        (apply str done)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14718,"user_id":null,"body":"(ns random-triplets)\n\n(defn to-nodes [edges] (set (map second edges)))\n\n(defn tsort [edges nodes]\n  \"Perfom a topological sort on the graph given by `edges` and `nodes`\"\n  (def non-inital (to-nodes edges))\n  (def inital     (remove non-inital nodes))\n  ; \"Khan!!!\"\n  (defn khan [s es l]\n    (if (empty? s) l\n      (let\n        [ n  (first s)\n          s' (rest s)\n          from-n? #(= n (first %))\n          nm     (filter from-n? es)\n          not-nm (remove from-n? es)\n          new (remove (to-nodes not-nm) (to-nodes nm)) ]\n        (khan (concat new s') not-nm (conj l n)))))\n  (khan inital edges []))\n\n\n(defn concat-map [f xs]\n  (apply concat (map f xs)))\n\n(defn as-pairs [triplets]\n  (defn f [[a b c]]\n    (list [a b]\n          [b c]\n          [a c]))\n  (concat-map f triplets))\n\n(defn letters-from [triplets]\n  (set (apply str triplets)))\n\n(defn recover_secret [triplets]\n  (apply str (tsort (as-pairs triplets) (letters-from triplets))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14719,"user_id":null,"body":"(ns random-triplets)\n\n; Not using sets & maps, just sequences\n\n(defn without [c v]\n  (filter seq (map #(if (= c (first %)) (next %) (seq %)) v)))\n\n(defn head [v]\n  (first (filter #(not (some (partial = %) (flatten (without % v)))) (distinct (map first v)))) )\n\n(defn recover_secret [triplets]\n  (loop [s [] v triplets]\n    (if-let [c (head v)]\n      (recur (conj s c) (without c v))\n      (apply str s) )))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14720,"user_id":null,"body":"(ns random-triplets\n  [:require [clojure.set :as s]]\n  )\n\n(defn triplet-to-rule\n  \"Make rules of form [[c1 c2] [c1 c3] ...] from a triplet\"\n  [s]\n  (let [trp (into [] s)]\n    [[(trp 0) (trp 1)] [(trp 0) (trp 2)] [(trp 1) (trp 2)]]\n    )\n  )\n\n(defn make-rules\n  \"Make a sorted set of rules from the triplets\"\n  [triplets]\n  (->>\n    triplets\n    (reduce (fn [acc elem] (concat acc (triplet-to-rule elem))) [])\n    (into (sorted-set))\n    )\n  )\n\n(defn letters-in-word\n  \"Make a set of all letters in secret word\"\n  [triplets]\n  (->>\n    triplets\n    (map (fn [s] (into [] s)))\n    (reduce into #{})\n    )\n  )\n\n(defn right-side-letters\n  \"A set consisting of letters on the right side of rules\"\n  [rules]\n  (->>\n    rules\n    (map (fn [[left right]] right))\n    (into #{})\n    )\n  )\n\n(defn find-next-letter\n  \"Find next letter by checking which letter does not occur on the right side of given rules\"\n  [candidate-letters rules]\n  (let [rs-letters (right-side-letters rules)]\n    (first (s\/difference candidate-letters rs-letters))\n    )\n  )\n\n(defn remove-rules\n  \"Remove rules with 'letter' as left letter\"\n  [letter rules]\n  (->>\n    rules\n    (filter (fn [[left _]] (not= left letter)))\n    )\n  )\n\n(defn deduction-step\n  \"Deducing next letter and updating letter pool and rules\"\n  [candidate-letters rules]\n  (let [letter (find-next-letter candidate-letters rules)\n        new-rules (remove-rules letter rules)\n        new-letters (s\/difference candidate-letters #{letter}) ]\n    [letter new-letters new-rules]\n    )\n  )\n\n(defn deduce\n  \"Recursive wrapper around 'deduction-step'\"\n  [candidate-letters rules word]\n  (if (zero? (count candidate-letters))\n    word\n    (let [[letter new-letters new-rules] (deduction-step candidate-letters rules)]\n      (deduce new-letters new-rules (conj word letter))\n      )\n    )\n  )\n\n(defn recover_secret\n  [triplets]\n  (->>\n    (deduce (letters-in-word triplets) (make-rules triplets) [])\n    (reduce str \"\")\n    )\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14721,"user_id":null,"body":"(ns random-triplets)\n\n(defn repl [s p r]\n  (clojure.string\/replace s p r))\n\n;;split triplet string into three pairs\n(defn splitTriplets [t]\n  (list (list (first t) (second t)) (list (first t) (last t)) (list (second t) (last t))))\n\n;;validates and changes string according to pair input\n(defn swapIfNotValid [s t]\n  (if (> (clojure.string\/index-of s (str (first t))) (clojure.string\/index-of s (str (second t))))\n    (repl (repl (repl s (str (first t)) \"0\") (str (second t)) (str (first t))) \"0\" (str (second t)))\n    s\n  ))\n\n;;receives triplet as [(a,b) (a,c) (b,c)]\n(defn betterList [s triplet]\n  (-> s\n    (swapIfNotValid (first triplet))\n    (swapIfNotValid (second triplet))\n    (swapIfNotValid (last triplet))))\n\n\n;;function to apply function to s with all args\n(defn applyAll [s tuplets]\n  (loop [stri s li tuplets]\n    (if (= (count li) 0)\n      stri\n      (recur (betterList stri (last li)) (drop-last li)))))\n\n;;Combine all the logic into one function so loop can access it without too much boilerplate code\n(defn combineAll [ac li]\n  (applyAll ac (map #(splitTriplets %) li)))\n\n(defn recover_secret [triplets]\n  (def allChars (apply str (seq (distinct (apply str triplets)))))\n  (loop [sentence allChars t triplets]\n    (if (= (rand-int 500) 13) ;;I know, this is not a good solution but i was too lazy for an evaluation function if another iteration is needed\n      sentence\n      (recur (combineAll sentence t) t))\n    ))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14722,"user_id":62,"body":"(ns random-triplets)\n(defn enforce-constraint [domains [a b c :as triple]]\n  (let [word-length (count domains)\n        acceptable-triples\n        (for [i (get domains a)\n              j (filter #(< i %) (get domains b))\n              k (filter #(< j %) (get domains c))]\n          [i j k])]\n    (merge \n     domains\n     (zipmap triple\n             (map distinct (apply map list acceptable-triples))))))\n\n\n(defn enforce-all-constraints [domains triples]\n  (let [new-domains\n        (reduce enforce-constraint domains triples)]\n    (if (= new-domains domains) domains\n        (recur new-domains triples))))\n\n(defn spellout [solution]\n  (apply str (map key (sort-by (comp first val) solution))))\n\n(defn recover_secret [triples]\n  (let [letters (distinct (apply concat triples))\n        domains (zipmap letters (repeat (range (count letters))))]\n    (spellout (enforce-all-constraints domains triples))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14723,"user_id":null,"body":"(ns random-triplets\n  (:require [clojure.string :as s]\n            [clojure.set :as st]))\n\n(defn make-prefix-map [cur-map [a b c]]\n  (let [default-map (merge {a #{} b #{} c #{}} cur-map)]\n    (-> default-map\n        (update b conj a)\n        (update c conj a b))))\n\n(defn remove-key [prefix-map kk]\n  (->> prefix-map\n       (map (fn [[k v]] [k (set (remove #{kk} v))]))\n       (into {})))\n\n(defn construct [res prefix-map]\n  ;; (println res prefix-map)\n  (let [first-chars (filter (fn [[_k v]] (= #{} v)) prefix-map)]\n    (cond\n      (empty? prefix-map) res\n      (not= 1 (count first-chars)) \"error\"\n      :else (let [[[k _v]] first-chars]\n              (recur (str res k) (remove-key (dissoc prefix-map k) k))))))\n\n(defn recover_secret [triplets]\n  (let [prefix-map (reduce make-prefix-map {} triplets)]\n    (construct \"\" prefix-map)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14724,"user_id":null,"body":"(ns random-triplets \n  (:require [clojure.set]\n            [clojure.string :as str]))\n\n(defn deps [ss]\n  (->> ss\n      (reduce (fn [acc s]\n                (let [ord (loop [[ch & rest] (reverse s)\n                                 acc {}]\n                            (if (nil? rest) (assoc acc ch nil)\n                                (recur rest (assoc acc ch rest))))]\n                  (merge-with (comp set into) acc ord))\n                ) {})))\n\n(defn build [dp]\n  (loop [dp dp\n         acc #{}\n         res []]\n    (let [next\n          (first (filter (fn [[_ v]] (empty? (clojure.set\/difference v acc ))) dp))]\n      (if (nil? next) (str\/join \"\" res)\n          (recur (dissoc dp (first next))\n                 (conj acc (first next))\n                 (conj res (first next)))))))\n\n(defn recover_secret [ss]\n  (build (deps ss)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"54120de842dff35232000195":[{"id":14725,"user_id":null,"body":"(ns nim)\n\n(defn first-indexed [pred xs]\n  (first (keep-indexed (fn [i x] (when (pred x) [i x])) xs)))\n\n(defn choose-move\n  \"Picks a move to play given a game-state ISeq\"\n  [s]\n  (let [nimsum (apply bit-xor s)]\n    (first-indexed pos? (map #(- % (bit-xor nimsum %)) s))))\n              ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14726,"user_id":null,"body":"(ns nim)\n\n(defn choose-move\n  \"Picks a move to play given a game-state ISeq\"\n  [game-state]\n  (let [X (apply bit-xor game-state)]\n    (first (sort-by second > (map vector (range) (map #(- % (bit-xor % X)) game-state))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14727,"user_id":null,"body":"(ns nim)\n\n(defn nim-sum [coll]\n  (apply bit-xor coll))\n\n(defn choose-move\n  \"Picks a move to play given a game-state ISeq\"\n  [game-state]\n  (let [x      (nim-sum game-state)\n        summed (map #(vector % (nim-sum [% x])) game-state)\n        lesser (first (filter #(< (last %) (first %)) summed))]\n    [(.indexOf summed lesser) (apply - lesser)]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14728,"user_id":null,"body":"(ns nim)\n\n\n(defn choose-move\n  [game-state]\n  (let [p-number (apply bit-xor game-state)\n        [pile-index nstraws]\n        (some (fn [[idx n]]\n                (if (> n (bit-xor p-number n))\n                  [idx n]))\n              (map vector (iterate inc 0) game-state))]\n    (when pile-index\n      [pile-index (- nstraws (bit-xor p-number nstraws))])))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14729,"user_id":null,"body":"(ns nim)\n\n(defn choose-move\n  \"Picks a move to play given a game-state ISeq\"\n  [game-state]\n  (let [x (apply bit-xor game-state)]\n       (seq(take 2 (first(filter last\n                   (map-indexed (fn [idx pile] \n                                  (def diff (- pile (bit-xor pile x)))\n                                  [idx diff (pos? diff)]) game-state)))))\n))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14730,"user_id":null,"body":"(ns nim)\n\n(defn index-of\n  \"First index of coll where pred is true or nil\"\n  [pred coll]\n  (let [idx (reduce (fn [idx elem] (if (pred elem) (reduced idx) (inc idx))) 0 coll)]\n    (if (< idx (count coll)) idx nil) ))\n\n(defn nim-sum\n  \"Bitwise xor of heap-sizes\"\n  [game-state]\n  (apply bit-xor game-state))\n\n(defn reducible-heaps\n  \"Vector of potential reductions: x > 0 means heap can be reduced by x\"\n  [game-state]\n  (let [ns-all (nim-sum game-state)]\n    (->>\n      game-state\n      (map (fn [x] (nim-sum [ns-all x])))\n      (map (fn [x y] (- x y)) game-state)\n      (into [])\n      )))\n\n(defn choose-move\n  \"Picks a move to play given a game-state ISeq\"\n  [game-state]\n  (let [ red-vec (reducible-heaps game-state)\n         idx (index-of #(> % 0) red-vec) ]\n    (if (nil? idx)\n      [(index-of #(> % 0) game-state) 1]\n      [idx (red-vec idx)]\n      )))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14731,"user_id":null,"body":"(ns nim)\n\n(defn choose-move [game-state]\n  (let [x (apply bit-xor game-state)\n        r (->> (map (partial bit-xor x) game-state)\n               (map list game-state)\n               (map-indexed cons)\n               (filter #(> (second %) (last %)))\n               (first))]\n    [(first r) (- (second r) (last r))]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14732,"user_id":62,"body":"(ns nim)\n\n\n(defn nim-sum [piles] (apply bit-xor piles))\n\n(defn find-pile-index \n  \"Compute the index of a pile where you can remove the desired amount.\"\n  [amount piles]\n  (last\n  (sort-by \n   #(bit-and amount (nth piles %))\n   (range (count piles)))))\n   \n(defn take-straws\n  [amount pile]\n  (- pile (bit-xor amount pile)))\n\n\n(defn choose-move [piles] \n    (let [amount (nim-sum piles)\n          index (find-pile-index amount piles)]\n      [index (take-straws amount (nth piles index))]))\n      \n  \n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14733,"user_id":53,"body":"(ns nim)\n\n(defn choose-move [state]\n  (let [m (reduce bit-xor state)]\n    (loop [i 0 xs state]\n      (let [s (first xs)\n            ys (rest xs)\n            t (bit-xor s m)]\n        (if (< t s)\n          (list i (- s t))\n          (recur (inc i) ys))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14734,"user_id":null,"body":"(ns nim)\n\n(defn choose-move\n  \"Picks a move to play given a game-state ISeq\"\n  [game-state]\n\n  (let [x (apply bit-xor game-state)]\n    (first (keep-indexed (fn [idx n]\n                           (let [y (bit-xor n x)]\n                             (when (< y n)\n                               [idx (- n y)]))) game-state)))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"541af676b589989aed0009e7":[{"id":14735,"user_id":3425,"body":"(ns count_change)\n\n(defn count_change\n  \"Gives the number of ways to make change for some money given a set of coins\"\n  [money [coin & other-coins :as coins]]\n  (cond\n   (zero? money) 1\n   (> 0 money) 0\n   (empty? coins) 0\n   :else (+ (count_change (- money coin) coins)\n            (count_change money other-coins))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14736,"user_id":null,"body":"(ns count_change)\n  \n(defn count_change\n  \"Gives the number of ways to make change for some money given a set of coins\"\n  [money coins]\n  (if (zero? money)\n    1\n    (if-let [[c & cs] (seq coins)]\n      (->> (iterate #(- % c) money)\n           (take-while (complement neg?))\n           (map #(count_change % cs))\n           (reduce +))\n      0)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14737,"user_id":null,"body":"(ns count_change)\n\n(defn count_change\n  \"Gives the number of ways to make change for some money given a set of coins\"\n  [money coins]\n  (cond\n    (= 0 money) 1\n    (or (< money 0) (empty? coins)) 0\n    :else (+ (count_change (- money (first coins)) coins)\n             (count_change money (rest coins)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14738,"user_id":null,"body":"(ns count_change)\n\n(defn count_change [money coins]\n  (cond\n    (zero? money) 1\n    (empty? coins) 0\n    :else\n      (let [coin (first coins)\n            coins' (rest coins)]\n        (if (> coin money)\n          (count_change money coins')\n          (+\n            (count_change (- money coin) coins)\n            (count_change money coins'))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14739,"user_id":null,"body":"(ns count_change)\n\n(defn count_change\n  \"Gives the number of ways to make change for some money given a set of coins\"\n  [money coins]\n  (cond (= money 0) 1\n        (empty? coins) 0\n        (< money (apply min coins)) 0\n        :else (+ (count_change (- money (first coins)) coins)\n                 (count_change money (rest coins)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14740,"user_id":null,"body":"(ns count_change)\n\n(defn count_change\n  \"Gives the number of ways to make change for some money given a set of coins\"\n  [money coins]\n  (cond\n    (empty? coins)\n    0,\n    (< money 0)\n    0,\n    (= money 0)\n    1,\n    true\n    (+\n      (count_change (- money (nth coins 0)) coins)\n      (count_change money (rest coins))\n    )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14741,"user_id":null,"body":"(ns count_change)\n\n(defn do-count\n  [amount denom-count denom-table]\n  (cond\n    (= amount 0)\n      1\n    (or (< amount 0) (= denom-count 0) )\n      0\n    :else\n      (+ (do-count amount (dec denom-count) denom-table)\n         (do-count (- amount (nth denom-table (dec denom-count))) denom-count denom-table) )\n    )\n  )\n\n(defn count_change\n  \"Gives the number of ways to make change for some money given a set of coins\"\n  [money coins]\n  (let [ denom-count (count coins)\n         denom-table (sort coins) ]\n    (do-count money denom-count denom-table)\n    )\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14742,"user_id":null,"body":"(ns count_change)\n\n(defn count_change\n  \"Gives the number of ways to make change for some money given a set of coins\"\n  [amount coins]\n  (cond\n    (zero? amount) 1\n    (empty? coins) 0\n    :else\n    (let [[denom & rest-coins] coins\n          max-usage (quot amount denom)]\n      (->> (range (inc max-usage))\n           (map (fn [c] (count_change (- amount (* c denom)) rest-coins)))\n           (reduce +)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14743,"user_id":null,"body":"(ns count_change)\n\n(defn count_change\n  \"Gives the number of ways to make change for some money given a set of coins\"\n  [money coins]\n  (loop [cs coins\n         ways (into [1] (repeat money 0))]\n    (if (empty? cs)\n      (last ways)\n      (recur (rest cs)\n             (apply map + (map #(concat (repeat % 0) ways)\n                               (range 0 (inc money) (first cs))))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14744,"user_id":null,"body":"(ns count_change)\n\n(defn count_change\n  \"Gives the number of ways to make change for some money given a set of coins\"\n  ([money coins]\n   (->> (count_change money coins [])\n     (map sort)\n     set\n     count))\n  ([money coins change]\n   (cond\n     (= money 0) [change]\n     (< money 0) nil\n     :else (mapcat #(count_change (- money %)\n                                  coins\n                                  (conj change %))\n                   coins))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"54cb771c9b30e8b5250011d4":[{"id":14745,"user_id":53,"body":"(ns faberge)\n(defn height [n m] \n  (loop [x (bigint n)\n         t (bigint 1)\n         h (bigint 0)]\n    (cond \n      (zero? x) h\n      :else (let [e (quot (* t (+ (- m n) x)) (- (inc n) x))]\n              (recur (dec x) e (+ h e))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14746,"user_id":null,"body":"(ns faberge)\n(defn height [n m] \n  (apply +' \n    (reduce \n      #(vector\n        (apply +' %1)\n        (\/ (*' (last %1) (- m %2 -1)) %2))\n      [-1 1]\n      (range 1 (inc n))\n  ))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14747,"user_id":168,"body":"(ns faberge)\n(defn height [n m]\n  (if (>= n m)\n      (- (.pow (biginteger 2) m) 1)\n      (second \n        (reduce \n          (fn [[c s] i]\n            (let [c-next (\/ (* c (- m i)) (+ i 1N))]\n              [c-next (+ s c-next)]))\n          [1N 0N] (range n))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14748,"user_id":571,"body":"(ns faberge)\n(defn height [n t]\n  (loop [sum 0N fac 1N r 0N] \n    (if (>= r n) sum\n      (let [bin  (\/ (* fac (- t r)) (inc r))]\n      (recur (+ sum bin) bin (inc r))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14749,"user_id":492,"body":"(ns faberge)\n(defn height [n m] \n  (loop [i 1 t 1N h 0N]\n    (let [t (\/ (* t (+ (- m i) 1)) i)]\n      (if (= i n) (+ h t)\n        (recur (inc i) t (+ h t))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14750,"user_id":null,"body":"(ns faberge)\n\n(defn bino [d n]\n  (let [dd (min (inc d) n)]\n    (loop [ans 0\n           last 1\n           [f & rest] (range dd)]\n      (if (nil? f)\n        ans\n        (let [next (\/ (*' last (- (inc d) f)) (inc f))]\n          (recur (+' ans next) next rest))))))\n\n(defn height [n m]\n  (bino (dec m) n)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14751,"user_id":null,"body":"(ns faberge)\n\n(defn height [n m]\n  (loop [h 0 x 1N i 1N]\n    (if (and (<= i n) (pos? x))\n      (let [t (-> x (* (inc (-' m i))) (quot i))]\n        (recur (+' h t) t (inc i)))\n      h)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14752,"user_id":null,"body":"(ns faberge)\n\n(defn comb [n k mul stop mul_op]\n  (loop [\n         acc (bigint 1)\n         v (bigint 1)\n         mul (bigint mul)\n         div (bigint 1)\n        ]\n        (if (stop n k mul div)\n          acc\n          (let [v (\/ (* v mul) div)]\n            (recur (+ acc v) v (mul_op mul) (inc div))\n          )\n        )\n  )\n)\n\n(defn comb_a [n k]\n  (comb n k n #(= %2 %4) dec)\n)\n\n(defn comb_b [n k]\n  (comb n k k #(do %& (= %1 %3)) inc)\n)\n\n(defn height [n m]\n  (let [n (min n m)]\n    (if (or (= 0 n) (= 0 m))\n      0\n      (dec (+ (comb_a m n) (comb_b m n)))\n    )\n  )\n  \n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14753,"user_id":null,"body":"(ns faberge)\n\n(def powers2\n  (lazy-seq (cons 1 (lazy-seq (map (partial *' 2) powers2)))))\n\n(def diagonal (map dec powers2))\n\n(defn sumbincoeffs [n k]\n  (loop [cursum 1 i 1 curr n]\n    (if (>= i k) cursum\n      (recur (+' cursum curr) (inc i) (quot (*' curr (- n i)) (inc i)))))\n  )\n\n(defn height [n m] \n  (cond (zero? n) 0\n    (zero? m) 0\n    (>= n m) (nth diagonal m)\n    :else (let [part2 (nth diagonal m)\n                  offset (- m n)\n                  diff (sumbincoeffs m offset)]\n              (- part2 diff)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14754,"user_id":null,"body":"(ns faberge)\n\n(defn height [n m]\n  (prn n)\n  (prn m)\n  (cond (= 1 n)\n        m\n        (= 0 n)\n        1\n        (> n m)\n        (height m m)\n        (= n m)\n        (- (apply *' (repeat m 2))\n           1)\n        (> n (\/ m 2))\n        (->> (range 0 (- m (inc n)))\n             (reduce\n               #(conj %1 (\/ (*' (last %1) (- m %2))\n                            (inc %2)))\n               [1 1])\n             (reduce - (apply *' (repeat m 2))))\n        :else\n        (->> (range 1 n)\n             (reduce\n               #(conj %1 (\/ (*' (last %1) (- m %2))\n                            (inc %2)))\n               [m])\n             (reduce +))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"54d496788776e49e6b00052f":[{"id":14755,"user_id":null,"body":"(ns sumbyfactors.core)\n\n;prime calculation found here: https:\/\/stackoverflow.com\/questions\/960980\/fast-prime-number-generation-in-clojure\n(defn prime? [n]\n      (.isProbablePrime (BigInteger\/valueOf n) 5))\n(def primes (concat [2] (filter prime? \n        (take-nth 2 (range 1 Integer\/MAX_VALUE)))))\n\n;my code\n(defn sum_of_divided [lst] \n  (let [maxi (apply max (map #(Math\/abs %) lst))]\n    (for [p primes\n          :while (<= p maxi)\n          :let [hits (filter #(zero? (mod % p)) lst)]\n          :when (not-empty hits)]\n      [p (reduce + hits)])))\n\n","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14756,"user_id":492,"body":"(ns sumbyfactors.core)\n\n(defn prime-factors [n]\n  (loop [n (Math\/abs n) divisor 2 factors []]\n    (if (< n 2)\n      (distinct factors)\n      (if (= 0 (rem n divisor))\n        (recur (\/ n divisor) divisor (conj factors divisor))\n        (recur n (inc divisor) factors)))))       \n\n(defn list-prime-factors [l]\n  (distinct (flatten (map (fn [x] (prime-factors x)) l))))\n\n(defn sum-for-one [n lst]\n  (reduce (fn [s x] (if (= 0 (mod x n)) (+ x s) s)) 0 lst))\n\n(defn sum_of_divided [lst]\n  (sort-by first(map (fn [x] (list x (sum-for-one x lst))) (list-prime-factors lst))))\n\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14757,"user_id":492,"body":"(ns sumbyfactors.core)\n\n(defn- prime-factors [n]\n  (loop [n (Math\/abs n) divisor 2 factors []]\n    (if (< n 2)\n      (distinct factors)\n      (if (= 0 (rem n divisor))\n        (recur (\/ n divisor) divisor (conj factors divisor))\n        (recur n (inc divisor) factors)))))       \n\n(defn- list-prime-factors [l]\n  (distinct (flatten (map (fn [x] (prime-factors x)) l))))\n\n(defn- sum-for-one [n lst]\n  (reduce (fn [s x] (if (= 0 (mod x n)) (+ x s) s)) 0 lst))\n\n(defn sum_of_divided [lst]\n  (sort-by first(map (fn [x] (list x (sum-for-one x lst))) (list-prime-factors lst))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14758,"user_id":null,"body":"(ns sumbyfactors.core)\n\n(defn divides? [n divisor]                                                                                      \n  (zero? (mod n divisor)))                                                                                      \n                                                                                                                \n(defn prime-factors [n]                                                                                         \n  (loop [n (Math\/abs n) divisor 2 acc []]                                                                                  \n    (if (< n 2)                                                                                                 \n      acc                                                                                                       \n      (if (divides? n divisor)                                                                                  \n        (recur (\/ n divisor) divisor (conj acc divisor))                                                        \n        (recur n (inc divisor) acc)))))                                                                         \n                                                                                                                \n(defn sums [prime lst]                                                                                          \n  (->> lst                                                                                                      \n       (filter #(divides? % prime))                                                                             \n       (apply +)))                                                                                              \n                                                                                                                \n(defn sum_of_divided [lst]                                                                                      \n  (let [primes (set (mapcat prime-factors lst))]                                                                \n    (->> primes                                                                                                 \n         (mapv (fn [prime] [prime (sums prime lst)]))                                                           \n         (sort-by first)                                                                                        \n         vec)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14759,"user_id":53,"body":"(ns sumbyfactors.core)\n\n(defn abs [n] (max n (- n)))\n\n(defn is-prime [n]\n  (loop [i 2]\n    (if (> i (Math\/sqrt n))\n      (> n 1)\n      (if (= 0 (mod n i))\n        false\n        (recur (inc i))))))\n\n(defn next-prime [n]\n  (if (is-prime (inc n))\n    (inc n)\n    (next-prime (inc n))))\n\n(defn sum_of_divided [lst] \n  (let [b (reduce max (map abs lst))]\n    (loop [p 2 r []]\n      (if (> p b)\n        r\n        (let [t (filter #(= 0 (mod % p)) lst)\n              q (next-prime p)]\n          (if (empty? t)\n            (recur q r)\n            (recur q (conj r [p (reduce + t)]))))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14760,"user_id":null,"body":"(ns sumbyfactors.core)\n\n(defn prime-factors [n]\n  (letfn [(factors-starting-at [start n result]\n            (cond\n              (> start (Math\/sqrt n)) (if (= n 1) [] (conj result n))\n              (zero? (mod n start)) (recur start (\/ n start) (conj result start))\n              :else (recur (inc start) n result)))]\n    (factors-starting-at 2 (Math\/abs n) [])))\n\n(defn add-value-to-keys [m ks v]\n  (reduce #(update %1 %2 (fn [x] (+ (or x 0) v))) m ks))\n\n(defn sum_of_divided [lst]\n  (loop [[x & xs] lst acc {}]\n    (if x\n      (recur xs (add-value-to-keys acc (distinct (prime-factors x)) x))\n      (sort-by first (into [] acc)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14761,"user_id":null,"body":"(ns sumbyfactors.core)\n\n(def prime?\n  (memoize\n   (fn [n]\n     (.isProbablePrime (biginteger n) 5))))\n\n(defn divides? [n]\n  (comp zero? (partial mod n)))\n\n(defn get-prime-factors [n]\n  (filter (every-pred prime? (divides? n))\n          (range (inc (Math\/abs n)))))\n\n(defn sum_of_divided [I]\n  (->> I\n       (mapcat (fn [i]\n                 (map (juxt (constantly i) identity)\n                      (get-prime-factors i))))\n       (group-by second)\n       (reduce-kv\n        (fn [P prime-factor every-i]\n          (conj P [prime-factor\n                   (apply + (map first every-i))]))\n        [])\n       (sort-by first)))\n\n(comment (sum_of_divided [-3 3]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14762,"user_id":null,"body":"(ns sumbyfactors.core\n  (:require [clojure.set]))\n\n(defn factorize \n  ([x f-init] (loop [n x\n                     f f-init]\n               (if (or (zero? n) (= n 1)) f\n                   (let [[new-x new-f] (cond (or (zero? n) (= n 1)) [n f]\n                                             (zero? (mod n 2)) [(\/ n 2) (conj f 2)]\n                                             :else (loop [p 3]\n                                                     (if (zero? (mod n p))\n                                                         [(\/ n p) (conj f p)]\n                                                         (recur (+ p 2)))))]\n                     (recur new-x new-f)))))\n  ([n] (factorize n [])))\n\n\n(defn prime-factor [n]\n  (let [abs-n (.abs (.toBigInteger (bigint n)))]\n    (apply sorted-set (factorize abs-n))))\n\n\n(defn sum_of_divided [lst]\n  (let [pfactors (apply clojure.set\/union (map prime-factor lst))]\n    (map (fn [p]\n           [p (reduce +' (filter #(zero? (mod % p)) lst))]) pfactors)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14763,"user_id":null,"body":"(ns sumbyfactors.core)\n\n(defn- prime-factors [n]\n  (loop [number n factors #{} divider 2]\n    (cond\n      (or (= number 1) (= number -1))\n      factors\n      (zero? (mod number divider))\n      (recur (\/ number divider) (conj factors divider) divider)\n      :else\n      (recur number factors (inc divider)))))\n\n(defn sum_of_divided [lst]\n  (->> lst\n       (reduce \n        (fn [acc, item]\n          (let [factors (prime-factors item)]\n            (reduce #(update %1 %2 conj item) acc factors)))\n        {})\n       (map (fn [[k v]]\n              [k (apply + v)]))\n       (sort-by first)))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14764,"user_id":62,"body":"(ns sumbyfactors.core)\n\n(declare primes)\n\n(defn useful-factors [n]\n  (take-while #(<= (* % %) n) primes))\n\n(def primes\n  \"An infinite list of all primes.\"\n  (lazy-seq\n    (cons 2\n    (filter (fn [n] \n              (not-any? #(zero? (rem n %)) (useful-factors n)))\n            (iterate inc 3)))))\n\n(defn factors [n]\n  (loop [prime-factors (take-while (partial >= n) primes), n n, factors []]\n    (if (= 1 n) (distinct factors)\n        (if-let [p (first prime-factors)]\n          (if (zero? (rem n p))\n            (recur prime-factors (quot n p) (conj factors p))\n            (recur (rest prime-factors) n factors))))))\n\n\n(defn sum_of_divided [nums] \n  (->> nums\n      (map #(zipmap (factors (Math\/abs %)) (repeat %))) ;; hash-map associating each prime factor with n.\n      (apply merge-with +) ;; merge the maps for different numbers by adding.\n      (sort-by first)\n    ))\n  \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"54eb33e5bc1a25440d000891":[{"id":14765,"user_id":492,"body":"(ns decomp-square.core)\n\n(defn decompose [n]\n  (letfn [(decompose-aux [nb rac]\n            (if (zero? nb)\n              []\n              (loop [i rac l nil]\n                (if (>= i (inc (int (Math\/sqrt (\/ nb 2.0)))))\n                  (let [diff (- nb (* i i))\n                        rac  (int (Math\/sqrt diff))\n                        l    (decompose-aux diff rac)]\n                    (if (some? l)\n                      (conj l i)\n                      (recur (dec i) l)))\n                  ))))]       \n    (decompose-aux (* n n) (int (Math\/sqrt (dec (* n n)))))))\n    ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14766,"user_id":null,"body":"(ns decomp-square.core)\n\n(defn decompose\n  ([n] (decompose (* n n) (dec n)))\n  ([nsq i] ; n - remainder (squared) to decompose, i - highest index we can try\n   (cond\n     (= i 0) nil\n     (= nsq (* i i)) [i]\n     (< nsq (* i i)) (recur nsq (dec i))\n     (> nsq (* i i)) (let [subd (decompose (- nsq (* i i)) (dec i))]\n                       (if (nil? subd)\n                         (recur nsq (dec i))\n                         (conj subd i))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14767,"user_id":62,"body":"(ns decomp-square.core)\n\n\n(defn decomposition-1 [amount coin]\n      (cond\n\t      (zero? amount) []\n\t      (and (pos? amount) (pos? coin))\n      \t    (if-let [solution (decomposition-1 (- amount (* coin coin)) (dec coin))]\n              (conj solution coin)\n\t\t          (recur amount (dec coin)))))\n\n(defn decompose [n]\n  (decomposition-1 (* n n) (dec n)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14768,"user_id":null,"body":"(ns decomp-square.core)\n\n(defn eqe [x y]\n  (= 0N (-' (bigint x) (bigint y))))\n\n(defn geqe [x y]\n    (<= 0N (-' (bigint x) (bigint y))))\n\n(defn decom [n1 a1 nu1]\n  (loop [number n1 amount a1 numbersMap nu1]\n    (if (eqe (bigint amount) 0N)\n    (keys numbersMap)\n    (if (eqe (bigint number) 0N)\n   (if (> (count numbersMap) 0N)\n      (recur (-' (bigint (key (last numbersMap))) 1N) (bigint (val (last numbersMap))) (into {} (butlast numbersMap)))\n     nil)\n   (if (geqe (bigint amount) (*' (bigint number) (bigint number)))\n     (recur (-' (bigint number) 1N) (-' (bigint amount) (*' (bigint number) (bigint number))) (assoc numbersMap (bigint number) (bigint amount)))\n     (recur (-' (bigint number) 1N) (bigint amount) numbersMap))))))\n\n\n\n\n(defn decompose [n]\n  (def p (into () (decom (-' (bigint n) 1N) (*' (bigint n) (bigint n)) (clojure.lang.PersistentArrayMap\/EMPTY))))\n    (if (eqe (count p) 0N)\n      nil\n      p)\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14769,"user_id":null,"body":"(ns decomp-square.core)\n(def d\n  (memoize (fn [num whatsleft res]\n             (if (zero? whatsleft)\n               res\n               (let [realnum (some #(when (>= whatsleft (* % %)) %) (range num -1 -1))]\n                 (if (or (nil? realnum) (zero? realnum) (neg? whatsleft))\n                   nil\n                   (or (d (dec realnum) (- whatsleft (* realnum realnum)) (conj res realnum))\n                       (d (dec realnum) whatsleft res))))))))\n\n(defn decompose [n]\n  (not-empty (reverse (d (dec n) (* n n) [])))\n  )\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14770,"user_id":null,"body":"(ns decomp-square.core)\n\n(def squares\n  (rest (map #(* % %) (range))))\n\n(defn decompose [n]\n  (let [sum (cond-> (* n n) (> n 10) (- (* (dec n) (dec n))))]\n    (loop [stack [{:xs  (reverse (take-while #((if (> n 10) <= <) % sum) squares))\n                   :v   (cond-> [] (> n 10) (conj (* (dec n) (dec n))))\n                   :sum sum}]]\n      (when-not (empty? stack)\n        (let [{:keys [xs v sum]} (peek stack)\n              [x & xs] xs]\n          (if (zero? (- sum x))\n            (map (comp long #(Math\/sqrt %)) (reverse (conj v x)))\n            (if xs\n              (recur (cond-> (conj (pop stack) {:xs xs :v v :sum sum})\n                       (pos? (- sum x)) (conj {:xs xs :v (conj v x) :sum (- sum x)})))\n              (recur (pop stack)))))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14771,"user_id":492,"body":"(ns decomp-square.core)\n\n(defn decompose [n]\n  (letfn [(decompose-aux [nb rac]\n            (if (zero? nb)\n              []\n              (loop [i rac l nil]\n                (if (>= i (inc (int (Math\/sqrt (\/ nb 3.0)))))\n                  (let [diff (- nb (* i i))\n                        rac  (min (int (Math\/sqrt diff)) (- i 1))\n                        l    (decompose-aux diff rac)]\n                    (if (some? l)\n                      (conj l i)\n                      (recur (dec i) l)))\n                  ))))]       \n    (decompose-aux (* n n) (int (Math\/sqrt (dec (* n n)))))))\n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14772,"user_id":null,"body":"(ns decomp-square.core)\n\n(defn decomp [n first?]\n  (let [ member (if first?\n                    (int (Math\/floor (Math\/sqrt (dec n))))\n                    (int (Math\/floor (Math\/sqrt n))))\n         remainder (- n (* member member))]\n    (cond\n      (= remainder 0) [member]\n      (= member 1) nil\n\n      :else (loop [mem member\n                   rem remainder]\n              (let [further-res (decomp rem false)]\n                (cond\n                  (and further-res (> mem (last further-res))) (conj further-res mem)\n                  (> mem 2) (recur (dec mem) (- n (* (dec mem) (dec mem))))\n                  :else nil))))))\n\n\n(defn decompose [n]\n  (decomp (* n n) true))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14773,"user_id":null,"body":"(ns decomp-square.core)\n\n(defn sos [x]\n  (reduce + (map #(* % %) x)))\n\n(defn get-next-attempt [current-sos target attempt]\n  (if (> attempt 10)\n    (int (Math\/ceil (Math\/sqrt (- target current-sos))))\n    (dec attempt)))\n\n(defn decompose [n]\n  (let [_ (println \"n: \" n)\n        target (* n n)\n        rs (fn rs2 [attempt result]\n             (let [current-sos (sos (conj result attempt))]\n               (cond\n                 (< attempt 1) (if (> (count result) 1)\n                                 (let [rr (into [] (drop-last result))]\n                                   #(rs2 (dec (last rr)) (into [] (drop-last rr))))\n                                 nil) ;; failure, try something else... (backtracking...)\n                 (= current-sos target) (conj result attempt)\n                 :else (if (< current-sos target)\n                         #(rs2 (get-next-attempt current-sos target attempt) (conj result attempt))\n                         #(rs2 (dec attempt) result)))))\n        result (trampoline rs (dec n) [])]\n    (if (not (nil? result))\n      (into [] (reverse result))\n      nil)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14774,"user_id":null,"body":"(ns decomp-square.core)\n\n(defn decompose* [n2 x]\n  (let [x (min x (int (Math\/sqrt n2)))\n        n2' (- n2 (* x x))]\n    (cond\n      (zero? n2') [x]\n      (= 1 x) nil\n      :else (or (some-> (decompose* n2' (dec x)) (conj x))\n                (recur n2 (dec x))))))\n\n(defn decompose [n] (decompose* (* n n) (dec n)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"54f5f22a00ecc4184c000034":[{"id":14775,"user_id":570,"body":"(ns exp-fract.core)\n\n(defn has-digits [x n]\n  (if (ratio? x)\n    (>= (count (str (numerator x))) n)\n    (>= (count (str x)) n)))\n\n(defn expand [x nDigits]\n  (let [x2 (rationalize x)\n        parts (iterate (fn [[v i]] [(\/ (* v x2) i) (inc i)])  [1 1])\n        nums (map first parts)\n        fractions (reductions + nums)]\n    ((juxt numerator denominator) (first (filter #(has-digits % nDigits) fractions)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14776,"user_id":null,"body":"(ns exp-fract.core)\n\n(defn expand [x nDigits]\n  (let [x (rationalize x)]\n    (loop [k 1N\n           fact-k 1N\n           x-pow 1N\n           n 0N\n           d 1N]\n           \n      (if (>= (inc (Math\/log10 n)) nDigits)\n        [n d]\n        ; else\n        (let [v\n              (rationalize\n                (\/ (+ (* n fact-k) (* d x-pow))\n                   (* d fact-k)))]\n          (recur\n            (inc k)\n            (* k fact-k)\n            (* x x-pow)\n            (if (integer? v) v (numerator v))\n            (if (integer? v) (bigint 1) (denominator v))))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14777,"user_id":492,"body":"(ns exp-fract.core)\n\n(defn expand [x nDigits]\n  (let [x (rationalize x)  new (clojure.lang.Numbers\/toRatio 1)]\n    (loop [expo (clojure.lang.Numbers\/toRatio 0) new (clojure.lang.Numbers\/toRatio 1) res (clojure.lang.Numbers\/toRatio 1)]\n      (let [expo (inc expo) new (clojure.lang.Numbers\/toRatio (* new (\/ x expo))) res  (clojure.lang.Numbers\/toRatio (+ res new))]\n        (if (>= (count (str (numerator res))) nDigits)\n          [(numerator res) (denominator res)]\n          (do ;(println expo new res)\n            (recur expo new res)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14778,"user_id":null,"body":"(ns exp-fract.core)\n\n(defn expand [x nDigits]\n  (loop [power-series (lazy-seq (cons 1 (map #(\/ (reduce * (take % (cycle [(clojure.lang.Numbers\/toRatio (rationalize x))])))\n                               (reduce * (range 1N (+ % 1N))))\n                           (iterate inc 1N))))\n         acc 0N]\n    (if (< (numerator (clojure.lang.Numbers\/toRatio acc)) (reduce * (take (- nDigits 1) (cycle [10N]))))\n      (recur (rest power-series) (+ acc (first power-series)))\n      [(numerator acc) (denominator acc)])))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14779,"user_id":null,"body":"(ns exp-fract.core)\n\n(defn taylor\n  ([x] (taylor x 1 1 1 0))\n  ([x k fac pow acc]\n   (lazy-seq\n    (cons acc\n          (taylor x\n                  (inc k)\n                  (*' fac k)\n                  (*' pow x)\n                  (+' acc (\/ pow fac)))))))\n\n(defn frac->vec [x]\n  (if (integer? x)\n    [x 1]\n    [(numerator x) (denominator x)]))\n\n(defn expand [x n-digits]\n  (->> (taylor (rationalize x))\n       (drop-while #(< (count (str (first (frac->vec %)))) n-digits))\n       first\n       frac->vec))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14780,"user_id":null,"body":"(ns exp-fract.core)\n\n(defn frac-to-vec\n  \"Converts fraction a\/b to vector [a b]\"\n  [frac]\n  (map bigint (clojure.string\/split (str frac) #\"\/\"))\n  )\n\n(defn no-of-digits\n  \"The number of digits in numerator of 'frac'\"\n  [frac]\n  (count (str (first (frac-to-vec frac))))\n  )\n\n(defn expand-terms\n  \"Calclates term(n+1) and sum(n+1) based on x, n, term(n) and sum(n)\"\n  [x max-digits n term sum]\n  (if (>= (no-of-digits sum) max-digits)\n    sum\n    (let [ next-term (* term (\/ x (inc n)))\n           next-sum (+ sum next-term) ]\n      (expand-terms x max-digits (inc n) next-term next-sum))))\n\n(defn expand [x max-digits]\n  (frac-to-vec (expand-terms (rationalize x) max-digits 0 1 1))\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14781,"user_id":62,"body":"(ns exp-fract.core)\n\n(defn powers [x] (iterate (partial * (rationalize x)) (bigint 1)))\n(def factorials\n        (->> (iterate (fn [[n f]] [(inc n) (* n f)]) [1 (bigint 1)])\n              (map second)))\n\n(defn prefixes [coll]\n      (map #(take % coll) (range)))\n\n(defn partial-sums [sequence]\n     (map (partial apply +) (prefixes sequence)))\n\n\n(defn exp-series [x]\n      (partial-sums (map \/ (powers x) factorials)))\n\n\n(defn numerator* [x]\n      (try (numerator x)\n      \t   (catch Exception e x)))\n\n(defn denominator* [x]\n      (try (denominator x)\n      \t   (catch Exception e 1)))\n\n(defn expand [x num-digits]\n      (->> (exp-series x)\n      \t   (drop-while (comp (partial > num-digits) count str numerator*))\n\t         (first)\n\t         ((juxt numerator* denominator*))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14782,"user_id":53,"body":"(ns exp-fract.core)\n\n(defn fraction [n] (clojure.lang.Numbers\/toRatio n))\n(defn nd [r] [(numerator r) (denominator r)])\n\n(defn expand [y d]\n  (let [x (rationalize y)  \n        t (fraction 1)]\n    (loop [e (fraction 0) \n           t (fraction 1) \n           r (fraction 1)]\n      (let [e (inc e) \n            t (fraction (* (\/ x e) t)) \n            res (fraction (+ t r))]\n        (if (>= (count (str (numerator r))) d)\n          (nd r)\n          (recur e t res))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14783,"user_id":null,"body":"(ns exp-fract.core)\n\n(defn factorial [n]\n  (reduce * (range (biginteger 2) (inc (biginteger n)))))\n\n(defn nn [a]\n  (if (ratio? a)\n    (do (prn (numerator a))\n        ((comp count str) (numerator a)))\n    0))\n\n(defn mypow [n x]\n  (reduce * (repeat x (bigdec n))))\n\n(defn expand [x nDigits]\n  (let [ans (reduce (fn [a b]\n                      ;(prn [a b])\n\n                      (if (>= (nn a) nDigits)\n                        (reduced a)\n                        (+ a (\/ (rationalize (mypow x b)) (factorial b))))) (biginteger 1) (drop 1 (range)))]\n    [(numerator ans) (denominator ans)]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14784,"user_id":null,"body":"(ns exp-fract.core)\n\n(defn expand\n  [x nDigits]\n  (let [max-numerator (Math\/pow 10 (dec nDigits))\n        x (rationalize x)]\n    (loop [r 1 k 1 rn 1]\n      (let [rn (\/ (* rn x) k)\n            r (+ r rn)]\n        (if (or (not (instance? clojure.lang.Ratio r))\n                (< (numerator r) max-numerator))\n          (recur r (inc k) rn)\n          [(numerator r) (denominator r)])))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"551f23362ff852e2ab000037":[{"id":14785,"user_id":527,"body":"(ns pyramid-slide-down)\n\n(defn longest_slide_down [pyramid]\n  (letfn [(f [a xs] (map #(+ (max %1 %2) %3) a (rest a) xs))]\n    (first (reduce f (rseq pyramid)))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14786,"user_id":null,"body":"(ns pyramid-slide-down)\n\n(defn longest_slide_down [pyramid]\n  (first (reduce #(map + (map (partial apply max) (partition 2 1 %1)) %2) (reverse pyramid))) )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14787,"user_id":null,"body":"(ns pyramid-slide-down)\n\n(defn longest_slide_down [pyramid]\n  (first (reduce\n          (fn [acc el]\n            (map-indexed (fn [i e] (+ e (max (nth acc i) (nth acc (inc i))))) el))\n          (last pyramid)\n          (reverse (drop-last pyramid)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14788,"user_id":null,"body":"(ns pyramid-slide-down)\n\n(defn longest_slide_down [pyramid]\n  (first (reduce \n          (fn [arr e] \n            (map + (map (partial apply max) (partition 2 1 arr)) e))\n          (reverse pyramid))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14789,"user_id":null,"body":"(ns pyramid-slide-down)\n\n(defn running-total-dp\n  [pyramid-rev dp]\n  (if (empty? pyramid-rev)\n    (first dp)\n    (running-total-dp (rest pyramid-rev)\n                      (map-indexed (fn [idx elem] (max (+ elem (nth dp idx)) (+ elem (nth dp (+ idx 1))))) (first pyramid-rev)))))\n\n\n(defn longest_slide_down\n  [pyramid]\n  ;; (dfs-running-total (rest pyramid) -1 0 (first (first pyramid)))\n  (running-total-dp (rest (reverse pyramid)) (last pyramid)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14790,"user_id":null,"body":"(ns pyramid-slide-down)\n\n(defn best-path \n  [previous]\n  (fn [index item]\n    (+ item (max (nth previous index) (nth previous (inc index))))))\n\n(defn all-best-paths [previous current] \n  (map-indexed (best-path previous) current))\n\n(defn longest_slide_down [pyramid]\n  (->> pyramid\n    (reverse)\n    (reduce all-best-paths)\n    (first)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14791,"user_id":null,"body":"(ns pyramid-slide-down)\n(defn parents-p [previous-row index]\n  [(nth previous-row (dec index) 0), (nth previous-row index 0)])\n\n(defn max-row [previous-row current-row]\n  (map #(+ (apply max (parents-p previous-row %2)) %1) current-row (range (count current-row)))\n  )\n\n(defn longest_slide_down [pyramid]\n  (apply max (reduce max-row [] pyramid))\n\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14792,"user_id":231,"body":"(ns pyramid-slide-down)\n\n(defn longest_slide_down [pyramid]\n  (defn max-paths [prev row]\n    (defn max-path [idx value]\n      (+ value (max (nth prev idx) (nth prev (inc idx)))))\n    (map-indexed max-path row))\n  (->> pyramid\n    reverse\n    (reduce max-paths)\n    first))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14793,"user_id":231,"body":"(ns pyramid-slide-down)\n\n(defn longest_slide_down [pyramid]\n  (defn max-paths [prev row]\n    (defn max-path [idx value]\n       (max (+ value (get prev idx))\n            (+ value (get prev (inc idx)))))\n    (vec (map-indexed max-path row)))\n  (->> pyramid\n    reverse\n    (reduce max-paths)\n    first))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14794,"user_id":null,"body":"(ns pyramid-slide-down)\n\n(defn calc-weights [prev-weights row]\n  (reduce (fn [new-weights [x ind]]\n            (let [pars (->> (map #(get prev-weights %)\n                               [(dec ind) ind])\n                        (filter some?))\n                  biggest-parent (apply max pars)]\n              (conj new-weights (+ x biggest-parent))))\n          []\n          (map vector row (range))))\n\n(defn longest_slide_down [pyramid]\n  (apply max (reduce calc-weights [0] pyramid)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55b195a69a6cc409ba000053":[{"id":14795,"user_id":223,"body":"(ns kata.total-increasing-or-decreasing-numbers)\n\n\n(defn factorial [n]\n  (if (> n 1) (reduce * (range 2N (inc n))) 1))\n\n(defn choose [n, k]\n  (\/ (factorial n) (* (factorial k) (factorial (- n k)))))\n\n(defn total-inc-dec [x]\n  (dec (- (+ (choose (+ 10 x) 10) (choose (+ 9 x) 9)) (* 10 x)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14796,"user_id":null,"body":"(ns kata.total-increasing-or-decreasing-numbers)\n\n(defn total-inc-dec [x]\n  (->> (range 1 11)\n    (iterate (partial reductions +))\n    (map (partial drop 8))\n    (map (partial reduce + -10))\n    (take x)\n    (reduce + 1) ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14797,"user_id":53,"body":"(ns kata.total-increasing-or-decreasing-numbers)\n\n(defn total-inc-dec [n]\n  (loop [a (bigint 1) b (bigint 1) i 0]\n    (cond\n      (= n i) (- (+ a b) (inc (* 10 n)))\n      :else (recur \n             (quot (* a (+ 10 i)) (inc i))\n             (quot (* b (+ 11 i)) (inc i))\n             (inc i)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14798,"user_id":null,"body":"(ns kata.total-increasing-or-decreasing-numbers)\n\n(defn combinations [n r]\n  (\/ (reduce *' (range (inc (- n r)) (inc n)))\n     (reduce *' (range 1 (inc r)))))\n\n(defn total-inc-dec [x]\n  (- (+ (combinations (+ 10 x) x)\n        (combinations (+ 9 x) x))\n     (* x 10)\n     1))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14799,"user_id":168,"body":"(ns kata.total-increasing-or-decreasing-numbers)\n\n(defn comb [n k]\n  (cond\n    (zero? k) 1N\n    (zero? n) 0N\n    :else (quot (* (comb (dec n) (dec k)) n) k)))\n\n(defn total-inc-dec [n]\n  (- (quot (* (+ 20N n) (comb (+ 9N n) n)) 10N) (* 10N n) 1N))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14800,"user_id":null,"body":"(ns kata.total-increasing-or-decreasing-numbers)\n\n(defn ncr [n r]\n  (\/ (reduce * (range n (- n r) -1))\n     (reduce * (range 2 (inc r)))))\n\n(defn total-inc-dec [x]\n  (let [y (bigint x)]\n    (+ (ncr (+ 10 y) 10) (ncr (+ 9 y) 9) -1 (* -10 y)))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14801,"user_id":null,"body":"(ns kata.total-increasing-or-decreasing-numbers)\n\n; this list contains a map for each power of 10 (starting with 10^1):\n;   key is the first digit,\n;   val is the number of numbers starting with that digit\n;   -> from this is computed the number of inc\/dec numbers in \"the next step\" 10^(n+1)\n;   (eg. - increasing num: for a num starting with 3, you can add 1, 2 or 3 to the beginning)\n; (This passes all the tests, but I don't certainly know why)\n(def inc-dec-counts\n  (iterate (fn [m]\n             (->> (for [[digit cnt] m\n                        new-digit (range digit 10)]\n                    [new-digit (inc cnt)])\n                  (reduce (fn [m [k v]]\n                            (if (contains? m k)\n                              (update m k + v)\n                              (assoc m k v))) {})))\n           (zipmap (range 1 10) (repeat 1))))\n\n(defn total-inc-dec [x]\n  (->> (take x inc-dec-counts)\n       (mapcat #(map val %)) ; \"extract\" the counts\n       (reduce +) ; sum them\n       (inc))) ; inc: include 0","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14802,"user_id":null,"body":"(ns kata.total-increasing-or-decreasing-numbers)\n\n\n(defn factorial [n]\n  (loop [idx (biginteger 2)\n         prod (biginteger 1)]\n    (if (<= idx n)\n      (recur (.add idx (biginteger 1)) (.multiply prod idx))\n      prod)))\n\n(defn binomial [n k]\n  (loop [idx 0\n         product (biginteger 1)]\n    (if (< idx k)\n      (recur (inc idx) (.multiply product (biginteger (- n idx))))\n      (.divide product (factorial k)))))\n\n(defn total-inc-dec [x]\n  (let [digits (biginteger x)\n        increasing (binomial (+ x 9) 9)\n        decreasing (.subtract (binomial (+ x 10) 10) (.add digits (biginteger 1)))\n        flat (biginteger (.multiply digits (biginteger 9)))]\n    (.subtract (.add increasing decreasing) flat)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14803,"user_id":null,"body":"(ns kata.total-increasing-or-decreasing-numbers)\n\n\n(defn r-inc\n  [prev]\n  (fn [curr ending-digit]\n    (let [a (get prev ending-digit 0)\n          b (get curr (dec ending-digit) 0)]\n      (assoc\n        curr\n        ending-digit\n        (+ a b)\n      )\n    )\n  )\n)\n\n(defn r-dec\n  [prev]\n  (fn [curr idx]\n    (let [ending-digit (- 9 idx)\n          a (get prev ending-digit 0)\n          b (get curr (inc ending-digit) 0)\n          x (if (= ending-digit 9)\n              (+ (get prev 9 0) 1)\n              (+ a b))]\n      (assoc\n        curr\n        ending-digit\n        x\n      )\n    )\n  )\n)\n  \n(defn calc\n  [r-fn init-coll x]\n  (loop [i 0\n         curr init-coll]\n    (if (= i x)\n      (reduce + 0 curr)\n      (let [n-curr (reduce\n                     (r-fn curr)\n                     (vec (replicate 10 0))\n                     (range 0 10))]\n        (recur\n          (inc i)\n          n-curr\n        )\n      )\n    )\n  )\n)\n      \n(defn total-inc-dec\n  [x]\n    (+\n      (calc r-inc [1 0 0 0 0 0 0 0 0 0] x)\n      (calc r-dec [0 0 0 0 0 0 0 0 0 0] x)\n      (* x -10)\n    )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14804,"user_id":null,"body":"(ns kata.total-increasing-or-decreasing-numbers)\n\n(defn sum-table [t]\n  (->> (butlast t) (apply +) (* 2) (+ 8 (last t)))\n)\n\n(defn iter-table [[f & rst]]\n  (reductions #(+ 1 %1 %2) (inc f) rst)\n)\n\n(defn total-inc-dec [x]\n  (->> [0 0 0 0 0 0 0 0 1]\n       (iterate iter-table)\n       (take x)\n       (map sum-table)\n       (reduce + 1)\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55cf3b567fc0e02b0b00000b":[{"id":14805,"user_id":492,"body":"(ns partition.core)                 \n\n(defn part-aux [n m]\n  (if (= n m) (list (list m))\n    (if (< n m) (list)\n      (concat (map \n                (fn [p] (cons m p))\n                (part-aux (- n m) m))\n              (part-aux n (+ m 1))))))\n\n(defn prod [l] (reduce * l))\n\n(defn part [n]\n  (let [r (vec (distinct (sort (map prod (part-aux n 1)))))\n        lg (count r)\n        rge (- (r (- lg 1)) (r 0))\n        sm (reduce + r)\n        avg (double (\/ sm lg))\n        m1 (r (quot (- lg 1) 2))\n        m2 (r (quot lg 2))\n        md (\/ (+ m1 m2) 2.0) \n       ]\n    (format \"Range: %d Average: %.2f Median: %.2f\" rge avg md)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-26 10:39:21"},{"id":14806,"user_id":null,"body":"(ns partition.core)                 \n\n(declare enum-memo)\n\n(defn seq-enum [n i]\n  (cond\n    (= n i) (list (list i))\n    (= 1 i) (list (doall (repeat n 1)))\n    :else (filter #(>= (first %) (second %)) (for [sub-array (enum-memo (- n i))] (conj sub-array i)))))\n\n(defn enum [n]\n  (loop [i n acc []]\n    (if (< i 1)\n      acc\n      (recur (dec i) (concat acc (seq-enum n i))))))\n\n(def enum-memo (memoize enum))\n\n(defn prod [n]\n  (sort (distinct (map #(reduce * %) (enum-memo n)))))\n\n(defn part [n]\n  (let [lst (prod n)\n        cnt (count lst)\n        diff (- (apply max lst) (apply min lst))\n        average (with-precision 30 (bigdec (\/ (apply + lst) cnt)))\n        median (float (let [mid (\/ cnt 2)]\n                        (if (odd? cnt) (nth lst mid) (\/ (+ (nth lst mid) (nth lst (dec mid))) 2.0))))]\n    (format \"Range: %s Average: %.2f Median: %.2f\" diff average median)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14807,"user_id":53,"body":"(ns partition.core)                 \n\n(defn partitions [n]\n  (if (zero? n)\n    '(())\n    (apply concat\n      (for [p (partitions (dec n))]\n        (let [res [(cons 1 p)]]\n          (if (and (not (empty? p))\n                   (or (< (count p) 2) (> (second p) (first p))))\n            (conj res (cons (inc (first p)) (rest p)))\n            res))))))\n\n(defn part [n]\n  (let* [xs (sort (distinct (map (fn [ls] (reduce * 1 ls)) (partitions n))))\n         s (reduce + xs)\n         l (count xs)\n         r (- (last xs) (first xs))\n         u (double (\/ s l))\n         m (* 0.5 (+ (nth xs (\/ l 2)) (nth xs (\/ (dec l) 2))))\n         f (format \"Range: %d Average: %.2f Median: %.2f\" r u m)]\n    f))\n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14808,"user_id":62,"body":"(ns partition.core)                 \n\n(def partitions\n  (memoize (fn\n  ([n] (partitions n n))\n  ([n k] ;; partitions where each division is no larger than k\n   (cond\n     (neg? n) nil\n     (zero? n) [[]]\n     :else\n     (for [i (range k 0 -1)\n           ps (partitions (- n i) i)]\n       (cons i ps)))))))\n\n(defn products [n]\n  (sort (distinct (map (partial reduce *) (partitions n)))))\n\n(defn median [coll]\n(let [k (\/ (dec (count coll)) 2)\n      k\u208a (int (Math\/ceil k))\n      k\u208b (int (Math\/floor k))\n      ]\n  (\/ (+ (float 0) (nth coll k\u208a) (nth coll k\u208b)) 2)))\n  \n\n(defn report-part [n]\n  (let [ps (products n)\n        stat-range (- (last ps) (first ps))\n        stat-mean (\/ (reduce + (float 0) ps) (count ps))\n        stat-med (median ps)\n        ]\n  (format \"Range: %d Average: %.2f Median: %.2f\" stat-range stat-mean stat-med)))\n\n(def part report-part)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14809,"user_id":null,"body":"(ns partition.core)                 \n\n(defn partitions [n]\n  (if (zero? n)\n    '(())\n    (apply concat\n           (for [p (partitions (dec n))]\n             (let [res [(cons 1 p)]]\n               (if (and (not (empty? p))\n                        (or (< (count p) 2) (> (second p) (first p))))\n                 (conj res (cons (inc (first p)) (rest p)))\n                 res))))))\n\n(defn get-median [a]\n  (let [c (count a)\n        m (quot c 2)]\n    (format \"%.2f\" (double (if (even? c)\n                            (\/ (+ (nth a (dec m)) (nth a m)) 2)\n                            (nth a m))))))\n\n(defn part [n]\n  (let [a (sort (distinct (map #(reduce * %) (partitions n))))]\n    (str \"Range: \" (- (last a) (first a)) \" Average: \" (format \"%.2f\" (double (\/ (reduce + a) (count a))))\n         \" Median: \" (get-median a))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14810,"user_id":null,"body":"(ns partition.core)                 \n\n(defn enum \n  ([n] (enum n n))\n  ([y lim]\n   (conj (for [a (if (<= y 0) [] (range 1 (min (inc y) (inc lim))))]\n           (enum (- y a) a))\n         lim)))\n\n(defn dfs  \n  ([tree] (dfs (conj tree 1) 1))\n  ([tree path]\n   (if (= 1 (count tree))\n     [(* path (first tree))]\n     (mapcat #(dfs % (* path (first tree))) (rest tree)))))\n\n(defn stringify [coll]\n  (let [rng (- (last coll) (first coll))\n        cnt (count coll)\n        avg (double (\/ (apply + coll) cnt))\n        median-low (get coll (int (\/ cnt 2)))\n        median (if (odd? cnt) \n                  (double median-low)\n                  (double (\/ (+ median-low (get coll (dec (int (\/ cnt 2))))) 2)))]\n    (format \"Range: %d Average: %.2f Median: %.2f\" rng avg median)))\n\n(defn part [n]\n  (stringify (vec (into (sorted-set) (dfs (rest (enum n)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14811,"user_id":null,"body":"(ns partition.core)                 \n\n(defn print-pass   [arg] (print   arg) arg)\n(defn println-pass [arg] (println arg) arg)\n\n(defn enum [n]\n  (cond\n    (integer? n) (lazy-seq (cons [n] (enum [n])))\n    (vector? n)\n    (let [c (count n)\n          i (as-> n n\n              (map-indexed vector n)\n              (filter (fn [[i v]] (= v 1)) n)\n              (first (first n))\n              (or n c) (dec n))\n          res (when (>= i 0)\n                (let [v (dec (nth n i))\n                      rm (- c i)]\n                  (vec (concat\n                        (subvec n 0 i) [v]\n                        (repeat (quot rm v) v)\n                        (let [rm2 (mod rm v)]\n                          (when (>= rm2 1) [rm2]))\n                        ))))\n          ]\n      (lazy-seq (if-let [r (enum res)]\n                  (cons res (enum res))\n                  res))\n      )\n    :else nil)\n  )\n\n(defn prod [n]\n  (->> n\n    enum\n    (map #(reduce * %))\n    set\n    vec\n    sort\n    vec\n    )\n  )\n\n(defn average [v]\n  (\/ (reduce + v) (count v))\n  )\n\n(defn median [v]\n  (let [h  (\/ (dec (count v)) 2)\n        i1 (int (Math\/floor h))\n        i2 (int (Math\/ceil h))]\n    (\/ (+ (nth v i1) (nth v i2)) 2)\n    )\n  )\n\n(defn part [n]\n  (let [res (prod n)]\n    (format \"Range: %d Average: %.2f Median: %.2f\"\n            (- (last res) (first res))\n            (double (average res))\n            (double (median res)))\n    )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14812,"user_id":null,"body":"(ns partition.core)                 \n\n(defn- next-partition [prev-part]\n  (let [no-1s (filter #(not= 1 %) prev-part)]\n    (if (seq no-1s)\n      (loop [new-part (into [] (butlast no-1s))\n             next-int (dec (last no-1s))\n             remainding (- (apply + prev-part) (apply + new-part))]\n        (cond\n          (zero? remainding) new-part\n          (>= (- remainding next-int) 0) (recur (conj new-part next-int) next-int (- remainding next-int))\n          :else (recur new-part (dec next-int) remainding)))\n      nil)))\n\n(defn integer-partition [n]\n  (take-while some? (iterate next-partition [n])))\n\n(defn prod [n]\n  (dedupe (sort (map #(apply * %) (integer-partition n)))))\n\n(defn part [n]\n  (let [prod (prod n)\n        rng (- (last prod) (first prod))\n        avg (\/ (apply + prod) (count prod))\n        c (dec (\/ (count prod) 2))\n        med-vals (drop-last c (drop c prod))\n        med (\/ (apply + med-vals) (count med-vals))]\n    (format \"Range: %d Average: %.2f Median: %.2f\" rng (double avg) (double med))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14813,"user_id":null,"body":"(ns partition.core)                 \n\n(defn union-sets [sets]\n  (reduce #(into %1 %2) #{} sets))\n\n(defn enum\n  \"return a set of lists (sorted)\"\n  ([n] (union-sets\n         (for [maxp (range n)] (enum n (inc maxp)))))\n  ([n maxp] (if\n              (or (= n 1) (= n maxp)) #{[n]}\n              (->> (enum (- n maxp) maxp :y)     ;; ensure: n >= maxp\n                   (map #(conj % maxp))          ;; no need to sort\n                   set)))\n  ([n maxp _] (union-sets\n                (for [x (range (min n maxp))] (enum n (inc x))))))\n\n(defn part [n]\n  (let [s (->> (enum n)\n               (map #(apply * %))\n               (into (sorted-set))\n               vec)\n        cnt (count s)\n        rng (- (apply max s) (apply min s))\n        avg (\/ (apply + s) cnt)\n        half (quot cnt 2)\n        median (if (odd? cnt) (nth s half)\n                 (\/ (+ (nth s half) (nth s (dec half))) 2))]\n    (str \"Range: \" rng\n         \" Average: \" (format \"%.2f\" (double avg))\n         \" Median: \" (format \"%.2f\" (double median)))\n    ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14814,"user_id":null,"body":"(ns partition.core)                 \n  \n(defn- prod\n  ([n] (prod n n))\n  ([n m]\n   (let [m (min n m)]\n     (cond\n       (zero? n) #{1}\n       (= 1 m) #{1}\n       :else (set\n               (concat\n                 (map (partial * m) (prod (- n m) m))\n                 (prod n (dec m))))))))\n\n(defn- median [xs]\n  (let [xs (sort xs)\n        cnt (count xs)\n        mid (bit-shift-right cnt 1)]\n    (if (odd? cnt)\n      (nth xs mid)\n      (\/ (+ (nth xs mid) (nth xs (dec mid))) 2))))\n\n(defn- stats [xs]\n  (let [r (- (apply max xs) (apply min xs))\n        mu (double (\/ (apply + xs) (count xs)))\n        md (double (median xs))]\n    (format \"Range: %d Average: %.2f Median: %.2f\" r mu md)))\n\n(defn part [n] (stats (prod n)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5629db57620258aa9d000014":[{"id":14815,"user_id":null,"body":"(ns mixin.core)\n(require '[clojure.string :as str])\n(defn mix_strings [s1 s2]\n    (->> (for [c \"abcdefghijklmnopqrstuvwxyz\" \n                  :let [x1 (str\/join (filter #{c} s1))\n                        n1 (count x1)        \n                        x2 (str\/join (filter #{c} s2))\n                        n2 (count x2)]\n                  :when (< 1 (max n1 n2))]\n                (cond (< n1 n2) {:src \\2 :chs x2 :len n2}\n                      (< n2 n1) {:src \\1 :chs x1 :len n1}\n                      :else     {:src \\= :chs x1 :len n1}))\n        (sort-by (juxt (comp - :len) :src :chs))\n        (map  #(format \"%c:%s\" (:src %) (:chs %)))\n        (str\/join \\\/)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14816,"user_id":null,"body":"(ns mixin.core\n  (:require [clojure.string :as s]))\n\n(defn mix_strings [s t]\n  (let [[fs ft] (map #(frequencies (s\/replace % #\"[^a-z]\" \"\")) [s t])]\n    (->> (concat (keys fs) (keys ft))\n         (distinct)\n         (map\n           (fn [c]\n             (let [x (fs c 0)\n                   y (ft c 0)]\n               [(cond\n                  (= x y) \\=\n                  (> x y) \\1\n                  :else \\2)\n                (apply str (repeat (max x y) c))])))\n         (filter #(> (count (second %)) 1))\n         (sort-by #(-> [(- (count (second %))) (first %) (first (second %))]))\n         (map #(str (first %) \":\" (second %)))\n         (s\/join \\\/ ))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14817,"user_id":null,"body":"(ns mixin.core)\n(require '[clojure.string :as str])\n\n(defn mix_strings [s1 s2]\n  (let [f  (fn [idx]\n             (fn [m] (->> m\n                         (frequencies)\n                         (filter (fn [[k v]] (and (> v 1) (Character\/isLowerCase k))))\n                         (into {})\n                         (map (fn [[k v]] [k [idx v]]))\n                         (into {}))))]\n    (->> (merge-with (fn [itm1 itm2]\n                       (let [[idx1 v1] itm1\n                             [idx2 v2] itm2]\n                         (cond (> v1 v2) itm1\n                               (= v1 v2) [\"=\" v1]\n                               :else itm2)))\n                     ((f 1) s1)\n                     ((f 2) s2))\n\n         (sort (fn [[k1 [idx1 v1]] [k2 [idx2 v2]]]\n                 (let [idx1 (if (= \"=\" idx1) 3 idx1)\n                       idx2 (if (= \"=\" idx2) 3 idx2)\n                       v-compare (compare v2 v1)\n                       i-compare (compare idx1 idx2)\n                       k-compare (compare k1 k2)]\n                   (cond\n                     (not (= 0 v-compare)) v-compare\n                     (not (= 0 i-compare)) i-compare\n                     :else k-compare))))\n         (map (fn [[k [idx v]]] (->> (repeat v k) (apply str idx \":\"))))\n         (str\/join \"\/\"))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14818,"user_id":492,"body":"(ns mixin.core)\n(require '[clojure.string :as str])\n\n(defn mk-tab [s]\n  (for [x (map char (range 97 123)) \n      :let [c (count (filter (fn [v] (= x v)) s)) ]\n     ]\n  (list x c)))\n\n(defn mk-pair [sndx sndy]\n  (let [m (max sndx sndy)\n        p (cond\n            (and (> m 1) (> m sndx)) 2\n            (and (> m 1) (> m sndy)) 1\n            :else 0)\n       ]\n    (list p m)))\n\n(defn mk-str [x y]\n  (cond \n    (= 1 (first y)) (str \"1:\" (apply str (repeat (second y) x)))\n    (= 2 (first y)) (str \"2:\" (apply str (repeat (second y) x)))\n    :else (str \"=:\" (apply str (repeat (second y) x)))))\n    \n(defn compsort [a b]\n  (let [x (- (count b) (count a))]\n    (if (= 0 x)\n      (compare a b)\n      x)))\n\n(defn mix_strings [s1 s2]\n  (let [a1 (map vector (mk-tab s1) (mk-tab s2))\n        a2 (map (fn [ [x y] ] [(first x) (mk-pair (second x) (second y))]) a1)\n        a3 (filter (fn [ [x y] ] (> (second y) 1)) a2)\n        a4 (str\/join \"\/\" (sort compsort (map (fn [ [x y] ] (mk-str x y)) a3)))\n       ]\n    a4))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14819,"user_id":null,"body":"(ns mixin.core)\n\n(defn mix_strings [s1 s2]\n  (let [stat (fn [s] (frequencies (filter #(<= 97 (int %) 122) s)))\n        fs1 (stat s1) fs2 (stat s2)\n        mark (fn [c] ([\\1 \\= \\2] (inc (compare (fs2 c) (fs1 c))))) ]\n    (->> (merge-with max fs1 fs2)\n      (filter #(< 1 (% 1)))\n      (map (fn [[c n]] (apply str (mark c) \\: (repeat n c))))\n      sort\n      (sort-by count >)\n      (interpose \\\/)\n      flatten\n      (apply str) )))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14820,"user_id":null,"body":"(ns mixin.core)\n(require '[clojure.string :as str])\n\n(defn rep [n s]\n  (str\/join \"\" (repeat n s)))\n\n(defn mix_strings [s1 s2]\n  (let [g1 (frequencies s1)\n        g2 (frequencies s2)\n        letters \"abcdefghijklmnopqrstuvwxyz\"\n        counts (for [l letters\n                     :let [c1 (g1 l 0)\n                           c2 (g2 l 0)]\n                     :when (> (max c1 c2) 1)]\n                 (cond\n                   (= c1 c2) [(- c1) \"=:\" l c1]\n                   (> c1 c2) [(- c1) \"1:\" l c1]\n                   :else [(- c2) \"2:\" l c2]))        \n        counts (sort counts)\n        parts (for [[_ prefix c n] counts]\n                (str prefix (rep n c)))]\n    (str\/join \"\/\" parts)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14821,"user_id":null,"body":"(ns mixin.core)\n(require '[clojure.string :as str])\n\n(defn- get-freq [s]\n  (->> \n    (clojure.string\/replace s #\"[^a-z]\" \"\")\n    frequencies\n    (filter (fn [[k v]] (> v 1)))\n    (into (hash-map))))\n\n(defn- compare-v [v1 v2]\n  (cond \n    (> v1 v2) [\"1\" v1]\n    (< v1 v2) [\"2\" v2]\n    (= v1 v2) [\"=\" v1]))\n\n(defn mix_strings [s1 s2]\n  (let [fr1 (get-freq s1)\n        fr2 (get-freq s2)\n        fr1- (into (hash-map) (map (fn [[k v]] {k (* -1 v)})) fr1)\n        fr2- (into (hash-map) (map (fn [[k v]] {k (* -1 v)})) fr2)\n        fr1-plus-fr2-keys (merge fr2- fr1)\n        fr2-plus-fr1-keys (merge fr1- fr2)]\n     (->>\n       (merge-with compare-v fr1-plus-fr2-keys fr2-plus-fr1-keys)\n       (sort-by (comp second second) >)\n       (group-by (comp second second))\n       (map (fn [[k v]] (sort (map (fn [[a [b c]]] (str b \":\" (apply str (repeat c a)))) v))))\n       flatten\n       (clojure.string\/join \"\/\")\n       )))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14822,"user_id":62,"body":"(ns mixin.core)\n(require '[clojure.string :as str])\n\n(defn signature [str]\n  (frequencies (clojure.string\/replace str #\"[^a-z]\" \"\")))\n\n(defn alter-vals\n  \"Alter the map by associating each key with (f key old-val).\"\n  [f m]\n  (into {} (map (fn [[k v]] [k (f k v)]) m)))\n\n(defn mix_strings [s1 s2]\n(let [freq-1 (signature s1)\n      freq-2 (signature s2)\n\n      max-freq (merge-with max freq-1 freq-2)\n      multiplied-letters (alter-vals \n                          (fn [letter num] (apply str (repeat num letter))) \n                          max-freq)\n      \n      source-direction\n      (into {}\n      (for [k (keys max-freq)]\n        (cond (= (max-freq k) (freq-1 k) (freq-2 k)) [k \"=\"]\n              (= (max-freq k) (freq-1 k)) [k \"1\"]\n              :else [k \"2\"])))\n\n      important-keys (map key (remove (comp (partial = 1) val) max-freq))\n\n      ]\n\n  (str\/join \"\/\"\n    (sort-by (juxt (comp - count)  ;; descending by length\n                    identity ;; ascending lexicographically\n            )\n      (for [letter important-keys]\n        (str (source-direction letter) \":\" (multiplied-letters letter)))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14823,"user_id":null,"body":"(ns mixin.core)\n(require '[clojure.string :as str])\n\n(defn freqs [s]\n  (frequencies (re-seq #\"[a-z]\" s)))\n\n(defn mix_strings [s1 s2]\n  (let [f1 (freqs s1)\n        f2 (freqs s2)\n        ks (into (set (keys f1)) (set (keys f2)))]\n    (->> ks\n         (map #(let [n1 (get f1 % 0)\n                     n2 (get f2 % 0)]\n                 (cond (> n1 n2) [1 n1 %]\n                       (> n2 n1) [2 n2 %]\n                       :else     [\"=\" n1 %])))\n         (filter (fn [[_ n]] (> n 1)))\n         (sort-by (fn [[s n v]] [(- n) (str s v)]))\n         (map (fn [[sgn n v]]\n                (str sgn \":\" (clojure.string\/join (repeat n v)))))\n         (clojure.string\/join \"\/\"))))\n\n\n\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14824,"user_id":null,"body":"(ns mixin.core)\n(require '[clojure.string :as s])\n\n\n(defn char-range [start end]\n  (map char (range (int start) (inc (int end)))))\n\n(defn f [v1 v2]\n  (cond\n    (= v1 v2) [\\= v1]\n    (> v1 v2) [\\1 v1]\n    :else [\\2 v2]))\n\n(defn mix_strings [s1 s2]\n  (let [a-to-z (char-range \\a \\z)\n        zero-freq (zipmap a-to-z (repeat 0))\n        freq1 (as-> (frequencies s1) x (select-keys x a-to-z) (merge zero-freq x))\n        freq2 (as-> (frequencies s2) x (select-keys x a-to-z) (merge zero-freq x))\n        merged (->> (merge-with f freq1 freq2)\n                    (filter (fn [[_char [_s v]]]\n                              (> v 1)))\n                    (sort-by (fn [[char [s v]]]\n                               [(- v) s char]))\n                    (map (fn [[char [s v]]]\n                           (str s \":\" (apply str (repeat v char)))))\n                    (s\/join \"\/\"))]\n    merged))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5671d975d81d6c1c87000022":[{"id":14825,"user_id":null,"body":"(ns skyscrapers)\n\n(defn str->int [s] (Integer\/parseInt s))\n(defn cross [as bs] (for [a as b bs] [a b]))\n(defn zip [as bs] (map vector as bs))\n(defn third [xs] (nth xs 2))\n(defn in?\n  \"true if coll contains elm\"\n  [coll elm]\n  (some #(= elm %) coll))\n(defn unchunk [s]\n  (when (seq s)\n    (lazy-seq\n      (cons (first s)\n            (unchunk (next s))))))\n\n(def n 4)\n(def digits\n  \"A digit is a valid value that can be assigned to a cell on the\n  skyscrapers grid\"\n  (range 1 (inc n)))\n(def rows (range n))\n(def cols (range n))\n(def squares \"A square is an [x y] coordinate vector\" (cross rows cols))\n\n(def all-vals\n  \"A val is a set of possible digits that may still exist in a\n  skyscrapers grid cell\"\n  (into #{} digits))\n(defn grid []\n  \"A grid is a map of squares to vals\"\n  (->> squares\n       (map (fn [sq] [sq all-vals]))\n       (into {})))\n\n(def units\n  \"A unit is a vector of squares that cannot have the same final digit\"\n  (concat (for [r rows] (vec (cross cols [r])))\n          (for [c cols] (vec (cross [c] rows)))))\n(def square->units\n  (->> squares\n       (map (fn [sq] [sq (vec (filter #(in? % sq) units))]))\n       (into {})))\n(def square->peers\n  \"A square sq's peer is another square that is in a same unit as\n  sq. This maps a square sq to a set of all other squares in the same\n  row\/col (excluding sq itself).\"\n  (into {}\n        (for [[k v] square->units]\n          [k (disj (->> v\n                        (apply concat)\n                        (into #{}))\n                   k)])))\n\n(def clue-views\n  \"A view is a vector of squares representing a way of looking across\n  the grid. ie it may be a vertical column of squares from either\n  top-to-bottom or bottom-to-top; or a horizontal row of squares going\n  left-to-right or right-to-left. These represent the ways that you\n  'look at the skyline' from the given skyscraper clues.\"\n  (concat\n   (for [c cols] (vec (cross [c] rows)))\n   (for [r rows] (vec (cross (reverse cols) [r])))\n   (for [c (reverse cols)] (vec (cross [c] (reverse rows))))\n   (for [r (reverse rows)] (vec (cross cols [r])))))\n\n;; Clues are given\n(def square->clue-indexes\n  \"A clue index is an array index into the order that clues are provided\n  in. This maps each square to the 4 possible clues indexes that\n  directly affect that square.\"\n  (into {}\n        (for [x cols y rows]\n          [[x y] [x (+ n y) (+ n n (- n 1 x)) (+ n n n (- n 1 y))]])))\n\n(def square->clue-pairs\n  \"Lookup either the ('v)ertical or ('h)orizontal clue indexes+view; grouped together to\n  facilitate checks where we want to check both sides of a \"\n  (into {}\n        (apply concat (for [x cols y rows]\n                        [[[[x y] 'v] [[x (+ n n (- n 1 x))] (cross [x] rows)]]\n                         [[[x y] 'h] [[(+ n n n (- n 1 y)) (+ n y) ] (cross cols [y])]]]))))\n\n(defn display-grid [grid]\n  (if grid\n    (doseq [y rows]\n      (->> cols\n           (map (fn [x] (->> (grid [x y])\n                             (clojure.string\/join \"\")\n                             (format \"%7s\"))))\n           (clojure.string\/join \" \")\n           println))\n    (println \"Contradiction.\")))\n\n(defn display-grid2 [grid clues]\n  (if grid\n    (do\n      (->> (take n clues)\n           (map #(if (= 0 %) \"\" %))\n           (#(concat [\"\"] % [\"\"]))\n           (map #(format \"%7s\" %))\n           (clojure.string\/join \" \")\n           println)\n      (doseq [y rows]\n        (->> cols\n             (map (fn [x] (->> (grid [x y])\n                               (clojure.string\/join \"\"))))\n             (#(concat [(nth clues (+ n n n (- n 1 y)))] % [(nth clues (+ n y))]))\n             (map #(if (= 0 %) \"\" %))\n             (map #(format \"%7s\" %))\n             (clojure.string\/join \" \")\n             println))\n      (->> clues\n           (drop (* 2 n))\n           (take n)\n           reverse\n           (map #(if (= 0 %) \"\" %))\n           (#(concat [\"\"] % [\"\"]))\n           (map #(format \"%7s\" %))\n           (clojure.string\/join \" \")\n           println))\n    (println \"Contradiction.\")))\n\n;; By convention, functions with ! mutate transients. This is for\n;; performance, as typical immutable clojure style would lead to tons\n;; of intermediate persistent data structures that are immediately\n;; thrown away.\n(declare eliminate!)\n(declare assign!)\n\n(defn perms-h [xs flags]\n  (let [[h & t] xs\n        h (filter #(not (bit-test flags %)) h)]\n    (cond\n      (nil? h) '()\n      (nil? t) (map list h)\n      :else (->> h\n                 (map #(map (fn [l] (cons % l)) (perms-h t (bit-set flags %))))\n                 (apply concat)))))\n\n(defn perms [xs]\n  (perms-h xs 0))\n\n;; TODO: making this smarter will improve our search pruning. For now\n;; we only handle the case where all squares up to the max height\n;; tower are certain. But we could also still return a count if\n;; uncertain values are surrounded by higher certain values. Or we\n;; could return upper\/lower bounds on the possible number of visible\n;; skyscrapers and check if the clue is outside those bounds.\n(defn count-visible-h\n  \"Given grid, return how many skyscrapers are visible looking along the\n  given view. Returns false if we are unsure.\"\n  [grid view n max-so-far]\n  (cond\n    (nil? view) n\n    )\n  (let [vs (map first (take-while #(= (count %) 1) (map grid view)))]\n    (if (not (in? vs n))\n      ;; don't have confirmed view to the tallest tower\n      false\n      ;; we hvae all visible towers\n      (count (reduce (fn [visible next]\n                       (if (> next (or (first visible) 0))\n                         (cons next visible)\n                         visible))\n                     ()\n                     vs)))))\n\n(defn count-visible-h\n  \"Given grid, return how many skyscrapers are visible looking along the\n  given view. Returns false if we are unsure.\"\n  [vs]\n  (if (not (in? vs n))\n    ;; don't have confirmed view to the tallest tower\n    false\n    ;; we hvae all visible towers\n    (count\n     (reduce (fn [visible next]\n               (if (> next (or (first visible) 0))\n                 (cons next visible)\n                 visible)\n               ) () vs))))\n\n(defn count-visible\n  \"Given grid, return how many skyscrapers are visible looking along the\n  given view. Returns false if we are unsure.\"\n  [grid view]\n  (count-visible-h (map first (take-while #(= (count %) 1) (map grid view)))))\n\n(defn check-clues [clues grid square]\n  ;; only check the clues directly in line with this square\n  (let [idxs (square->clue-indexes square)]\n    (->> idxs\n         (map (fn [idx] [(nth clue-views idx) (nth clues idx)]))\n         (filter (fn [[view clue]] (not= 0 clue)))\n         (map (fn [[view clue]] [(count-visible grid view) clue]))\n         (filter (fn [[cnt clue]] (and (not (false? cnt)))))\n         (every? (fn [[cnt clue]] (= cnt clue))))))\n\n(defn update-2-clues! [clues grid square val]\n  ;; Special logic for cases where we have a '2' clue and just placed\n  ;; a 7 which lines up with it\n  (if (= (grid square) #{n})\n    (do\n      (let [idxs (square->clue-indexes square)\n            views-with-2s\n            (->> idxs\n                 (map (fn [idx] [(nth clue-views idx) (nth clues idx)]))\n                 (filter (fn [[v clue]] (= clue 2))))]\n        (->> views-with-2s\n             (every?\n              (fn [[v _]]\n                (let [vals-upto-n (take-while #(not= #{n} %) (map grid v))\n                      n-idx (count vals-upto-n)\n                      max-d (apply max (flatten (map seq vals-upto-n)))]\n                  (every?\n                   identity\n                   (for [d (take (- n-idx 1) digits)]\n                     (eliminate! clues grid (first v) d)))))))))\n    true))\n\n(defn check-perfect-unit-h! [clues grid unit cs]\n  (let [c1 (clues (first cs))\n        c2 (clues (second cs))\n        vs (filter #(and (or (= 0 c1) (= c1 (count-visible-h %)))\n                         (or (= 0 c2) (= c2 (count-visible-h (reverse  %)))))\n                   (perms (map grid unit)))\n        cvs (count vs)]\n    (cond\n      (= 0 cvs) false\n      (= 1 cvs) (every?\n                 (fn [[sq v]] (assign! clues grid sq v))\n                 (zip unit (first vs)))\n      :else true)))\n\n(defn check-perfect-unit!\n  \"Check if there is exactly one solution left for a unit which satisfies the clues\"\n  [clues grid square]\n  (let [[vcs vu] (square->clue-pairs [square 'v])\n        [hcs hu] (square->clue-pairs [square 'h])]\n    (and (check-perfect-unit-h! clues grid vu vcs)\n         (check-perfect-unit-h! clues grid hu hcs))))\n\n(defn update-self! [clues grid square val]\n  (let [updated (disj (grid square) val)]\n    (when (not-empty updated)\n      (assoc! grid square updated)\n      (if (= (count updated) 1)\n        (and (check-clues clues grid square)\n             (check-perfect-unit! clues grid square)\n             (every? #(eliminate! clues grid % (first updated)) (square->peers square)))\n        true))))\n\n(defn update-unit!\n  \"Check if there are no longer any valid sq for digit in unit; or if there is exactly 1 valid sq\"\n  [clues grid unit digit]\n  (let [digit-squares (filter #((grid %) digit) unit)]\n    (cond\n      (empty? digit-squares) false\n      (= (count digit-squares) 1) (assign! clues grid (first digit-squares) digit)\n      :else true)))\n\n(defn eliminate! [clues grid square val]\n  (let [existing-options (grid square)]\n    (if (contains? existing-options val)\n      ;; if this is new information, propagate the change\n      (and (update-self! clues grid square val)\n           (every? #(update-unit! clues grid % val) (square->units square))\n           (update-2-clues! clues grid square val))\n      ;; else, nothing to do\n      true)))\n\n(defn assign! [clues grid square val]\n  (let [existing (grid square)\n        others (disj existing val)]\n    (every? #(eliminate! clues grid square %) others)))\n\n(defn assign [clues grid square val]\n  (let [t (transient grid)\n        works (assign! clues t square val)]\n    (if works\n      (persistent! t)\n      false)))\n\n(defn eliminate [clues grid square val]\n  (let [t (transient grid)\n        works (eliminate! clues t square val)]\n    (if works\n      (persistent! t)\n      false)))\n\n(defn solved? [grid]\n  (every? (fn [[k v]] (= (count v) 1)) grid))\n\n(defn next-square [grid]\n  ;; Randomize the next square to look at, among squares with the min\n  ;; possible remaining values\n  (let [kv (->> squares\n                (map (fn [sq] [sq (count (grid sq))]))\n                (filter (fn [[_ cnt]] (> cnt 1))))\n        min-val (apply min (map second kv))\n        options (filter #(= min-val (second %)) kv)]\n    (first (rand-nth options)))\n  ;; Or, without randomization (but more prone to getting stuck on\n  ;; hard to resolve cases):\n  ;; (apply min-key #(remaining (grid %)) squares)\n  )\n\n(defn search\n  ([clues grid] (search clues grid 0))\n  ([clues grid l]\n  (cond\n    (false? grid) false\n    (solved? grid) grid\n    :else\n    (let [sq (next-square grid)]\n      (if sq\n        (let [x  (some (fn [d]\n                         (if (> l 0)\n                           (let [x (time (search clues (assign clues grid sq d) (dec l)))]\n                             (println \"^ \" sq d)\n                             x)\n                           (search clues (assign clues grid sq d) (dec l))))\n                       (shuffle (grid sq)))]\n          x)\n        false)))))\n\n(defn assign-clue! [clues grid clue view]\n  (cond\n    (= clue 0) nil\n\n    (= clue 1) (assign! clues grid (first view) n)\n\n    ;; Technically this case is redundant with the :else, but it's\n    ;; more efficient to assign!\n    (= clue n) (doseq [[val sq] (zip digits view)]\n                 (assign! clues grid sq val))\n\n    (> clue 1)\n    ;; If clue=2, we know n cannot be in the first square.\n    ;; If clue=3, we know n cannot be in the first 2 squares, and\n    ;;        and     (n-1) cannot be in the first square.\n    ;; etc.\n    (do\n      (doseq [d (range (dec clue))]\n         (doseq [sq (take (- clue 1 d) view)]\n           (eliminate! clues grid sq (- n d))))\n      (when (= clue 2)\n        (eliminate! clues grid (second view) (dec n))))\n\n    :else nil))\n\n(defn assign-clue [clues grid clue view]\n  (cond\n    (= clue 1) (assign clues grid (first view) n)\n    (= clue n) (reduce (fn [g [val sq]]\n                         (let [g (assign clues g sq val)]\n                           (if g\n                             g\n                             (reduced false))))\n                       grid\n                       (zip digits view))\n    :else\n    (reduce (fn [g sq]\n              (let [g (eliminate clues g sq n)]\n                (if g\n                  g\n                  (reduced false))))\n            grid\n            (take (dec clue) view))))\n\n(defn grid->vec [grid]\n  (vec\n   (for [y rows]\n     (vec\n      (for [x cols]\n        (first (grid [x y])))))))\n\n(defn solve_puzzle [clues]\n  (let [clues (vec clues) ;; Make sure we can efficiently index\n        g (grid)\n        t (transient g)]\n    ;; We go out of our way to skip validation checks while applying\n    ;; clues (basically, we aren't handling the case that we get\n    ;; self-contradictory clues) This is for performance, since on\n    ;; some puzzles we eat as much time validating clues as doing the\n    ;; post-clue solve.\n    (time (doseq [[c v] (zip clues clue-views)]\n            (assign-clue! clues t c v)))\n    ;; Or we could validate state while applying initial clues:\n    ;; (reduce (fn [g [c v]]\n    ;;                     (let [g (assign-clue clues g c v)]\n    ;;                       (if g\n    ;;                         g\n    ;;                         (reduced false))))\n    ;;                   (grid)\n    ;;                   (zip clues clue-views))\n\n    (let [g (persistent! t)]\n      (println \"Initial state:\")\n    (println g)\n      (display-grid2 g clues)\n      (if g\n        (let [solution (time (search clues g))]\n          (display-grid2 solution clues)\n          (grid->vec solution))\n        (println \"Error assigning clues\")))))","lang_id":5,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14826,"user_id":62,"body":"(ns skyscrapers)\n\n(defn permutations [s]\n  (lazy-seq\n   (if (seq (rest s))\n     (apply concat (for [x s]\n                     (map #(cons x %) (permutations (remove #{x} s)))))\n     [s])))\n\n(def stacks (permutations (range 1 (inc 4))))\n\n;; leftward-height\n(defn rightward-visibles [row]\n  (first\n   (reduce (fn [[num-seen view-height] x]\n             (cond (zero? view-height)\n                   [1 x]\n                   (> x view-height)\n                   [(inc num-seen) x]\n                   :else-too-short\n                   [num-seen view-height]))\n           [0 0]\n           row)))\n\n(def clued-row\n  (memoize (fn [left-clue right-clue]\n             (let [left? (if (zero? left-clue) (constantly true)\n                             (comp (partial = left-clue) rightward-visibles))\n                   right? (if (zero? right-clue) (constantly true)\n                              (comp (partial = right-clue) rightward-visibles reverse))]\n               (filter #(and (left? %) (right? %)) stacks)))))\n               \n(defn apply-constraint [left-clue right-clue domains]\n  (map set\n       (apply map list\n              (remove (partial some nil?)\n              (map (partial map #(%1 %2) domains) ;; confirm domain membership\n                   (clued-row left-clue right-clue))))))\n\n(def finish (partial mapv (partial mapv first)))\n\n(def empty-board\n  (repeat 4\n          (repeat 4 (set (range 1 (inc 4))))))\n\n(defn solve_puzzle [clues]\n  (let [[north east south west] (partition 4 clues)\n        south (reverse south)\n        west (reverse west)]\n\n    (loop [board empty-board]\n      (let [new-board \n            (->> board\n                 ;; left-to-right constraints\n                 (map apply-constraint west east)\n                 \n                 (apply map list) ;; swap rows\/cols\n                 (map apply-constraint north south)\n                 (apply map list))]\n        (if (= new-board board) (finish board)\n            (recur new-board))))))\n\n\n\n\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14827,"user_id":null,"body":"(ns skyscrapers)\n\n\n(defn count-visible [coll l-to-r?]\n  (let [adjusted (if l-to-r? coll (rseq coll))]\n    (->> adjusted\n         (reduce (fn[[maxht total] nxt]\n                   (if (> nxt maxht)\n                     [nxt (inc total)]\n                     [maxht total]\n                     ))\n                 [0 0])\n         second)))\n\n(defn check-against-clue [line l-to-r clue]\n  (or (zero? clue)\n      (= (count-visible line l-to-r) clue)))\n\n(defn validate [board [c1t c2t c3t c4t r1r r2r r3r r4r c4b c3b c2b c1b r4l r3l r2l r1l]]\n                     (let [[r1 r2 r3 r4] board\n                           [c1 c2 c3 c4] (apply map vector board)]\n                       (and (check-against-clue r1 true r1l)\n                            (check-against-clue r1 false r1r)\n                            (check-against-clue r2 true r2l)\n                            (check-against-clue r2 false r2r)\n                            (check-against-clue r3 true r3l)\n                            (check-against-clue r3 false r3r)\n                            (check-against-clue r4 true r4l)\n                            (check-against-clue r4 false r4r)\n                            (check-against-clue c1 true c1t)\n                            (check-against-clue c1 false c1b)\n                            (check-against-clue c2 true c2t)\n                            (check-against-clue c2 false c2b)\n                            (check-against-clue c3 true c3t)\n                            (check-against-clue c3 false c3b)\n                            (check-against-clue c4 true c4t)\n                            (check-against-clue c4 false c4b)\n                            )\n                       ))\n\n(defn solve_puzzle [clues]\n  (let [all-boards\n        (for [a1 (range 1 5)\n              a2 (range 1 5) :when (distinct? a1 a2)\n              a3 (range 1 5) :when (distinct? a1 a2 a3)\n              a4 (range 1 5) :when (distinct? a1 a2 a3 a4)\n              b1 (range 1 5) :when (distinct? a1 b1)\n              b2 (range 1 5) :when (and (distinct? a2 b2) (distinct? b1 b2))\n              b3 (range 1 5) :when (and (distinct? a3 b3) (distinct? b1 b2 b3))\n              b4 (range 1 5) :when (and (distinct? a4 b4) (distinct? b1 b2 b3 b4))\n              c1 (range 1 5) :when (distinct? a1 b1 c1)\n              c2 (range 1 5) :when (and (distinct? a2 b2 c2) (distinct? c1 c2))\n              c3 (range 1 5) :when (and (distinct? a3 b3 c3) (distinct? c1 c2 c3))\n              c4 (range 1 5) :when (and (distinct? a4 b4 c4) (distinct? c1 c2 c3 c4))\n              d1 (range 1 5) :when (distinct? a1 b1 c1 d1)\n              d2 (range 1 5) :when (distinct? a2 b2 c2 d2)\n              d3 (range 1 5) :when (distinct? a3 b3 c3 d3)\n              d4 (range 1 5) :when (distinct? a4 b4 c4 d4)]\n          [[a1 a2 a3 a4][b1 b2 b3 b4][c1 c2 c3 c4][d1 d2 d3 d4]])]\n    (first (filter #(validate % clues) all-boards)))\n  )\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14828,"user_id":53,"body":"(ns skyscrapers)\n(declare vectorize)\n\n;; ---------------\n;;      state\n;; ---------------\n\n(defn map-map-board [n]\n  (apply sorted-map (interleave \n    (range n) \n    (repeat n (apply sorted-map (interleave \n      (range n) \n      (repeat n 0)))))))\n\n(defn map-map-cells [n]\n  (apply sorted-map (interleave \n    (range (* n n)) \n    (repeat (* n n) (apply sorted-map (interleave \n      (range n) \n      (repeat n 0)))))))\n\n(defn map-list-peers [n]\n  (apply sorted-map (interleave \n     (range (* n n))\n     (map (fn [c] (filter #(not= % c) (flatten (\n       map #(list \n             (+ (* % n) (mod c n)) \n             (+ (* (quot c n) n) %)) \n         (range n)))))\n       (range (* n n))))))\n\n(defn map-list-observers [clues n]\n  (apply sorted-map (interleave \n     (range (* 4 n))\n     (map (fn [id] (concat \n       (map (fn [i]\n         (cond\n           (< id n) (+ id (* i n))\n           (< id (* 2 n)) (+ (- (dec n) i) (* (mod id n) n))\n           (< id (* 3 n)) (+ (- (dec n) (mod id n)) (* (- (dec n) i) n))\n           :else (+ i (* (- (dec n) (mod id n)) n))\n         )) (range n)) \n       [(nth clues id)]))\n     (range (* 4 n))))))\n\n;; ---------------\n;;      model\n;; ---------------\n\n(defn list-candidates [cells c n]\n  (filter #(zero? (get (get cells c) %)) (range n)))\n\n(defn map-map-cloack [cells c v]\n  (update-in cells [c v] inc))\n\n(defn map-map-uncloack [cells c v]\n  (update-in cells [c v] dec))\n\n(defn pair-map-map-lock [state peers c v n]\n  (defn lock-aux [state peers v]\n    (if (zero? (count peers))\n       state\n       (let [board (first state)\n             cells (second state)\n             cloacked (map-map-cloack cells (first peers) v)]\n         (lock-aux (list board cloacked) (rest peers) v)\n       )))\n    (lock-aux \n      (list (update-in (first state) [(quot c n) (mod c n)] \n        (fn [i] (inc v))) (second state)) \n      (get peers c) v))\n\n(defn pair-map-map-unlock [state peers c v n]\n  (defn unlock-aux [state peers v]\n    (if (zero? (count peers))\n       state\n       (let [board (first state)\n             cells (second state)\n             uncloacked (map-map-uncloack cells (first peers) v)]\n         (unlock-aux (list board uncloacked) (rest peers) v)\n       )))\n    (unlock-aux \n      (list (update-in (first state) [(quot c n) (mod c n)] \n        (fn [i] 0)) (second state)) \n      (get peers c) v))\n\n;; ---------------\n;;   observation\n;; ---------------\n\n(defn int-look [board o n]\n  (defn look-aux [ls m k]\n    (if (empty? ls) k\n      (look-aux \n        (rest ls)\n        (max m (first ls))\n        (if (> (first ls) m) (inc k) k))))\n    (look-aux (map \n      #(get (get board (quot (nth o %) n)) (mod (nth o %) n))\n       (range n)) 0 0))\n\n(defn verify? [board o n] (or\n    (zero? (nth o n))\n    (some #(zero? %) (map #(get \n      (get board (quot (nth o %) n)) (mod (nth o %) n)) (range n)))\n    (= (int-look board o n) (nth o n))))\n\n;; ---------------\n;;       DFS\n;; ---------------\n\n(defn int-choose [board n]\n  (defn choose-aux [ls n i]\n    (cond \n      (empty? ls) -1\n      (zero? (first ls)) i\n      :else (choose-aux (rest ls) n (inc i))))\n  (choose-aux (map #(get \n      (get board (quot % n)) (mod % n)) (range (* n n))) n 0))\n\n(declare dfs-step)\n\n(defn dfs [state peers observers n]\n  (let [board (second state)\n        cells (nth state 2)\n        cell (int-choose board n)]\n    (if (= -1 cell)\n      (list (every? #(verify? board (get observers %) n) (keys observers)) board cells)\n      (dfs-step state (list-candidates cells cell n) cell peers observers n))))\n\n(defn dfs-step [state options cell peers observers n]\n  (let [board (second state)\n        cells (nth state 2)]\n    (if (zero? (count options))\n      (list false board cells)\n      (let [value (first options)\n            locked (pair-map-map-lock (list board cells) peers cell value n)\n            substate (dfs (list true (first locked) (second locked)) peers observers n)]\n        (if (true? (first substate))\n          substate\n          (dfs-step (list true board cells) \n            (rest options) cell peers observers n))))))\n\n;; ---------------\n;;     solver\n;; ---------------\n\n(defn vectorize [mm]\n  (map (fn [m] (map \n    #(get (get mm m) %) \n    (keys (get mm m)))\n  ) (keys mm)))\n\n(defn solve_puzzle [clues]\n  (let [n (\/ (count clues) 4)\n        board (map-map-board n)\n        cells (map-map-cells n)\n        peers (map-list-peers n)\n        observers (map-list-observers clues n)\n        res (dfs (list true board cells) peers observers n)]\n    (vectorize (second res))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14829,"user_id":null,"body":"(ns skyscrapers)\n(def N 4)\n\n(def MAXINDEX (dec (* N N)))\n\n(defn transpose [m]\n  (apply mapv vector m))\n\n(defn row-as-string [row]\n  (str \" |\" (clojure.string\/join \" \" row) \"| \" )\n  )\n\n(defn row-with-clues [game index row]\n  ; FIXME use get-in\n  (print (nth (get (get game :clues) :row-left) index))\n  (print (row-as-string row))\n  (print (nth (get (get game :clues) :row-right) index))\n  (println \"\")\n  )\n\n(defn pprint-game [game-data]\n  (println (row-as-string (get (get game-data :clues) :column-top)))\n  (println \"  _____________ \")\n   (->> (get game-data :field)\n       (map-indexed #(row-with-clues game-data %1 %2))\n        (dorun))\n  (println \"  ------------- \")\n  (println (row-as-string (get (get game-data :clues) :column-bottom)))\n  )\n\n(defn clues-map-from-input-data [clues]\n  (let [partitions (partition N clues)]\n    {:row-left (vec (reverse (nth partitions 3)))\n     :row-right (vec (nth partitions 1))\n     :column-top (vec (nth partitions 0))\n     :column-bottom (vec (reverse (nth partitions 2)))}\n    )\n  )\n\n(defn game-from-input-data [clues]\n{ :clues (clues-map-from-input-data clues)\n  :field [\n          [0 0 0 0]\n          [0 0 0 0]\n          [0 0 0 0]\n          [0 0 0 0]\n          ]})\n\n(defn append-if-bigger [vec value]\n  (if (< (last vec) value)\n    (conj vec value)\n    vec\n    )\n  )\n\n(defn count-visible-buildings [line]\n  ; count visible buildings: left --> right\n  (count (rest (reduce append-if-bigger [0] line)))\n  )\n\n(defn line-plausible?\n  [line left-clue right-clue]\n   (and\n     (or\n       (= 0 (count (filter #(< 0 %) line)))\n       (apply distinct? (filter #(< 0 %) line)))\n     (or (= left-clue 0) (>= left-clue (count-visible-buildings line)))\n     )\n  )\n\n(defn line-complete? [line left-clue right-clue]\n  (and\n    (every? #(< 0 %) line)\n    (apply distinct? line)\n    (or (= left-clue 0) (= left-clue (count-visible-buildings line)))\n    (or (= right-clue 0) (= right-clue (count-visible-buildings (reverse line))))\n    )\n  )\n\n(defn line-complete-or-plausible?\n  [line left-clue right-clue]\n  (if (every? #(< 0 %) line)\n    (line-complete? line left-clue right-clue)\n    (line-plausible? line left-clue right-clue)\n    )\n  )\n\n(defn game-complete? [game]\n  (and\n    ; for each row... check line\n    (every? identity (map #(line-complete?\n          (get-in game [:field %])\n          (get-in game [:clues :row-left %])\n          (get-in game [:clues :row-right %]))\n       (range N)))\n  ; for each column...check line\n  (every? identity (map #(line-complete?\n               (get (transpose (get game :field)) %)\n               (get-in game [:clues :column-top %])\n               (get-in game [:clues :column-bottom %]))\n            (range N))))\n  )\n\n(defn game-completion-possible? [game]\n  (and\n    ; for each row... check line\n    (every? identity (map #(line-complete-or-plausible?\n                             (get-in game [:field %])\n                             (get-in game [:clues :row-left %])\n                             (get-in game [:clues :row-right %]))\n                          (range N)))\n    ; for each column...check line\n    (every? identity (map #(line-complete-or-plausible?\n                             (get (transpose (get game :field)) %)\n                             (get-in game [:clues :column-top %])\n                             (get-in game [:clues :column-bottom %]))\n                          (range N))))\n  )\n\n(defn next-game-state [game index value]\n  (let [x (mod index N) y (quot index N)]\n    (assoc-in game [:field y x] value))\n  )\n\n(defn solve-game [game index value]\n  (let [x (mod index N) y (quot index N) next-game (next-game-state game index value)]\n    (cond\n        (and (= index MAXINDEX) (game-complete? next-game)) next-game\n        (and (= index MAXINDEX) (not (game-complete? next-game))) nil\n        (not (game-completion-possible? next-game)) nil\n        :else (filter some? (mapcat #(solve-game next-game (inc index) %) (range 1 (inc N))))\n        )\n    )\n  )\n\n(defn solve_puzzle [clues]\n  (let [game (game-from-input-data clues)]\n    (nth (nth (solve-game game -1 0) 1) 1)\n    )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14830,"user_id":null,"body":"(ns skyscrapers)\n(defn all-seq\n  [coll]\n  (if (< 1 (count coll))\n    (mapcat\n      (fn [i]\n        (map\n          #(cons i %)\n          (all-seq (remove #(= i %) coll))))\n      coll)\n    [coll]))\n\n(def all-solutions\n  (let [colls (all-seq [1 2 3 4])\n        checker (fn [& colls]\n                  (->> (apply map\n                              (fn [& items] (set items))\n                              colls)\n                       (every? #(= #{1 2 3 4} %))))]\n    (for [i1 colls i2 colls i3 colls i4 colls\n          :when (checker i1 i2 i3 i4)]\n      [i1 i2 i3 i4])))\n\n(defn get-highs\n  [coll]\n  (if (= 1 (count coll))\n    1\n    (+ (let [i (last coll)\n             others (drop-last coll)]\n         (if (every? #(> i %) others)\n           (inc (get-highs others))\n           (get-highs others))))))\n\n(defn get-clues\n  [colls]\n  (let [rev-colls (map reverse colls)\n        column-colls (apply map list colls)\n        rev-column-colls (map reverse column-colls)]\n    (map\n      get-highs\n      (concat column-colls\n              rev-colls\n              (reverse rev-column-colls)\n              (reverse colls)))))\n\n(defn solve_puzzle [clues]\n  (-> (filter\n        #(->> (map\n                (fn [a c] (or (= 0 c) (= a c)))\n                (get-clues %)\n                clues)\n              (every? true?))\n        all-solutions)\n      first))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14831,"user_id":null,"body":"(ns skyscrapers)\n\n(defn get-clue [[h1 & resth]]\n  (loop [clue 1 [h & resth] resth hm h1]\n    (cond (not h) clue\n          (> h hm) (recur (inc clue) resth h)\n          :else (recur clue resth hm)\n    )\n  )\n)\n\n(defn permutations [s]\n  (lazy-seq\n    (if (seq (rest s))\n      (apply concat \n        (for [x s] \n          (map #(vec (cons x %)) (permutations (remove #{x} s)))\n        )\n      )\n      [s]\n    )\n  )\n)\n\n(defn clues-map [perms]\n  (reduce \n    (fn [m p] \n      (let [lc    (get-clue p) \n            rc    (get-clue (reverse p))\n            conj-p #(conj % p)]\n        (-> m\n            (update (list lc 0)  conj-p)\n            (update (list 0 rc)  conj-p)\n            (update (list lc rc) conj-p)\n            (update (list 0 0)   conj-p)\n        )\n      )\n    )\n    {}\n    perms\n  )\n)\n\n(defn filter-perm [f-perm perms]\n  (filter \n    (fn [p] (every? identity (map #(not= %1 %2) f-perm p))) \n    perms\n  )\n)\n\n(defn filter-value [v i perms] \n  (filter (fn [per] (= (nth per i) v)) perms)\n)\n\n\n(defn filter-row-opts [row-opts p row]\n  (concat \n    (repeat (inc row) '()) \n    (map (partial filter-perm p) (drop (inc row) row-opts))\n  )\n)\n\n(defn filter-col-opts [col-opts p row]\n  (map \n    (fn [opts v] (filter-value v row opts)) \n    col-opts p\n  )\n)\n\n(defn solutions [row-opts col-opts row max-row]\n  (if (= row max-row) \n    ['()]\n    (for [opt (nth row-opts row)\n          :let [col-opts (filter-col-opts col-opts opt row)\n                row-opts (filter-row-opts row-opts opt row)]\n          :when (and (every? #(not (empty? %)) col-opts)\n                     (every? #(not (empty? %)) (drop (inc row) row-opts)))\n          sol (solutions row-opts col-opts (inc row) max-row)] \n      (conj sol opt)\n    )\n  )\n)\n\n(defn puzzle-solver [grid-size]\n  (let [perms (permutations (range 1 (inc grid-size)))\n        cmap (clues-map perms)\n        solver (fn solve-puzzle [grid-size cmap clues]\n                 (let [top-clues (->> clues (take grid-size))\n                       bottom-clues (->> clues (drop (* 2 grid-size)) (take grid-size) reverse)\n                       left-clues (->> clues (drop (* 3 grid-size)) reverse)\n                       right-clues (->> clues (drop grid-size) (take grid-size))\n                       row-options (map #(cmap (list %1 %2)) left-clues right-clues)\n                       col-options (map #(cmap (list %1 %2)) top-clues bottom-clues)\n                      ]\n                    (first (solutions row-options col-options 0 grid-size))\n                 )\n               )]\n    (partial solver grid-size cmap)\n  )\n)\n\n(def solve-puzzle (puzzle-solver 4))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14832,"user_id":null,"body":"(ns skyscrapers\n  (:require [clojure.set :as cljset])\n)\n\n(def get-clue (memoize (fn [[h1 & resth]]\n  (loop [clue 1 [h & resth] resth hm h1]\n    (cond (not h) clue\n          (> h hm) (recur (inc clue) resth h)\n          :else (recur clue resth hm)\n    )\n  )\n)))\n\n(defn permutations [s]\n  (lazy-seq\n    (if (seq (rest s))\n      (apply concat \n        (for [x s] \n          (map #(cons x %) (permutations (remove #{x} s)))\n        )\n      )\n      [s]\n    )\n  )\n)\n\n(defn clues-map [perm-conv-fn perms]\n  (assoc \n    (reduce \n      (fn [m p]\n        (update m (get-clue (perm-conv-fn p)) \n          (fn [c]\n            (if c\n              (conj c p)\n              #{p}\n            )\n          )\n        )\n      ) \n      {} \n      perms\n    )\n    0 (set perms)\n  )    \n)\n\n(def left-clues-map (partial clues-map (fn [x] x)))\n(def right-clues-map (partial clues-map reverse))\n\n\n(defn filter-perm [f-perm perms]\n  (filter \n    (fn [p] (every? (fn [x] x) (map #(not= %1 %2) f-perm p))) \n    perms\n  )\n)\n\n(defn perm-map [perms]\n  (apply merge \n    (map\n      #(hash-map % (set (filter-perm % perms)))\n      perms\n    )\n  )\n)\n\n(defn relim [h-lims opts]\n  (map (partial cljset\/intersection opts) h-lims)\n)\n\n(defn relim-v [v-lims p y]\n  (map \n    (fn [lims v] \n      (filter (fn [lim] (= (nth lim y) v)) lims)\n    ) \n    v-lims p\n  )\n)\n\n(defn fits-v-lim? [p v-lims y]\n  (every? (fn [x] x) \n    (map \n      (fn [v lims] \n        (contains? (set (map #(nth % y) lims)) v)\n      )\n      p v-lims\n    )\n  )\n)\n\n(defn solutions [perm-map h-lims v-lims y maxy]\n  (cond (= y maxy) ['()]\n        (every? empty? v-lims) []\n    \n    :else (for [p (nth h-lims y)\n          :let [opts (perm-map p)]\n          :when (fits-v-lim? p v-lims y)\n          sol (solutions perm-map (relim h-lims opts) (relim-v v-lims p y) (inc y) maxy)] \n      (cons p sol)\n    )\n  )\n)\n\n(defn solve_puzzle [clues] \n  (let [perms (set (permutations (range 1 5)))\n        permmap (perm-map perms)\n        lcm (left-clues-map perms)\n        rcm (right-clues-map perms)\n        top-clues (->> clues (take 4))\n        right-clues (->> clues (drop 4) (take 4))\n        bottom-clues (->> clues (drop 8) (take 4) reverse)\n        left-clues (->> clues (drop 12) reverse)\n        h-lims (map #(cljset\/intersection (rcm %1) (lcm %2)) right-clues left-clues)\n        v-lims (map #(cljset\/intersection (lcm %1) (rcm %2)) top-clues bottom-clues)\n       ]\n     (first (solutions permmap h-lims v-lims 0 4))\n  )\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14833,"user_id":null,"body":"(ns skyscrapers)\n\n(def get-clue (memoize (fn [[h1 & resth]]\n  (loop [clue 1 [h & resth] resth hm h1]\n    (cond (not h) clue\n          (> h hm) (recur (inc clue) resth h)\n          :else (recur clue resth hm)\n    )\n  )\n)))\n\n(defn permutations [s]\n  (lazy-seq\n    (if (seq (rest s))\n      (apply concat \n        (for [x s] \n          (map #(cons x %) (permutations (remove #{x} s)))\n        )\n      )\n      [s]\n    )\n  )\n)\n\n(defn extraction-filter [condition extraction]\n  (partial filter (comp condition extraction))\n)\n\n(defn not-value-filter [i v]\n  (extraction-filter #(not= % v) #(nth % i))\n)\n\n(defn not-line-filter [per]\n  (apply comp (for [[i v] (map-indexed list per)] (not-value-filter i v)))\n)\n\n(defn s-left-clue-filter [row clue]\n  (extraction-filter #(= % clue) #(get-clue (nth % row)))\n)\n\n(defn s-right-clue-filter [row clue]\n  (extraction-filter #(= % clue) #(get-clue (reverse (nth % row))))\n)\n\n(defn s-top-clue-filter [col clue]\n  (extraction-filter #(= % clue) #(get-clue (map (fn [x] (nth x col)) %)))\n)\n\n(defn s-bottom-clue-filter [col clue]\n  (extraction-filter #(= % clue) #(get-clue (reverse (map (fn [x] (nth x col)) %))))\n)\n\n(defn solutions [perms]\n  (if (empty? perms)\n    ['()]\n    (for [p perms sol (solutions ((not-line-filter p) perms))] (cons p sol))\n  )\n)\n\n(defn solve_puzzle [clues] \n  (let [top-clues (->> clues (take 4))\n        right-clues (->> clues (drop 4) (take 4))\n        bottom-clues (->> clues (drop 8) (take 4) (reverse))\n        left-clues (->> clues (drop 12) (take 4) (reverse))\n        top-filters (for [[col clue] (map-indexed list top-clues) :when (not (zero? clue))] (s-top-clue-filter col clue))\n        right-filters (for [[row clue] (map-indexed list right-clues) :when (not (zero? clue))] (s-right-clue-filter row clue))\n        bottom-filters (for [[col clue] (map-indexed list bottom-clues) :when (not (zero? clue))] (s-bottom-clue-filter col clue))\n        left-filters (for [[row clue] (map-indexed list left-clues) :when (not (zero? clue))] (s-left-clue-filter row clue))\n        solution-filter (apply comp (concat top-filters right-filters bottom-filters left-filters))\n       ]\n    (->> (range 1 5)\n         permutations\n         solutions\n         solution-filter\n         first)\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14834,"user_id":null,"body":"(ns skyscrapers\n  (:require [clojure.set :as cljset])\n)\n\n(defn get-clue [[h1 & resth]]\n  (loop [clue 1 [h & resth] resth hm h1]\n    (cond (not h) clue\n          (> h hm) (recur (inc clue) resth h)\n          :else (recur clue resth hm)\n    )\n  )\n)\n\n(defn permutations [s]\n  (lazy-seq\n    (if (seq (rest s))\n      (apply concat \n        (for [x s] \n          (map #(cons x %) (permutations (remove #{x} s)))\n        )\n      )\n      [s]\n    )\n  )\n)\n\n(def clues-map\n  (reduce (fn [m p] (update m (get-clue p) #(conj % p))) {} (permutations (range 1 5)))\n)\n\n\n(defn fits? [a b]\n  (reduce #(and %1 %2) (map #(or (nil? %2) (= %1 %2)) a b))\n)\n\n(defn get-opts [clue line pos]\n  (if (zero? clue)\n    (set '(1 2 3 4))\n    (->> clue\n         clues-map\n         (filter #(fits? % line))\n         (map #(nth % pos))\n         set\n    )\n  )\n)\n\n(defn solve_puzzle \n  ([clues] \n    (partition 4 (solve-puzzle clues [] 0))\n  )\n  ([clues solution sl]\n    (if (= sl 16)\n      solution\n      (let [py (quot sl 4) \n            px (rem sl 4)\n            lc (nth clues (- 15 py))\n            rc (nth clues (+ 4 py))\n            uc (nth clues px)\n            bc (nth clues (- 11 px))\n            xline (concat (drop (* py 4) solution) (repeat (- 4 px) nil))\n            yline (concat (take-nth 4 (drop px solution)) (repeat (- 4 py) nil))\n            clue-opts (cljset\/intersection \n                        (get-opts lc xline px) \n                        (get-opts rc (reverse xline) (- 3 px)) \n                        (get-opts uc yline py) \n                        (get-opts bc (reverse yline) (- 3 py)))\n            opts (cljset\/difference \n                    clue-opts\n                    (set (drop (* py 4) solution))\n                    (set (take-nth 4 (drop px solution))))]\n        (first\n          (for [o opts \n                :let [solution (solve-puzzle clues (conj solution o) (inc sl))]\n                :when solution]\n            solution\n          )\n        )\n      )\n    )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5672682212c8ecf83e000050":[{"id":14835,"user_id":492,"body":"(ns dbl_linear.core)\n\n(defn smerge [xs ys]\n  (lazy-seq\n    (let [x (first xs)\n          y (first ys)\n          [z xs* ys*]\n          (cond\n            (< x y) [x (rest xs) ys]\n            (> x y) [y xs (rest ys)]\n            :else   [x (rest xs) (rest ys)])]\n      (cons z (smerge xs* ys*)))))\n(def dbl_linear-sq\n  (lazy-seq\n    (->> (map (fn [x] (+ 1 (* 2 x))) dbl_linear-sq)\n         (smerge (map (fn [x] (+ 1 (* 3 x))) dbl_linear-sq))\n         (cons 1))))\n(defn dbl_linear [n]\n    (first (drop n (take (inc n) dbl_linear-sq))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14836,"user_id":null,"body":"(ns dbl_linear.core\n  (:require [clojure.test :refer :all]))\n\n(defn divisible? [n d]\n  (zero? (mod n d)))\n\n(defn u? [n]\n  \"Returns true if N belongs to U, otherwise false\"\n  (if (= n 1)\n    true\n    (let [n' (dec n)]\n      (or\n        (if (divisible? n' 2) (u? (\/ n' 2)) false)\n        (if (divisible? n' 3) (u? (\/ n' 3)) false)))))\n\n(defn dbl_linear [n]\n  (nth (filter u? (drop 1 (range))) n))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14837,"user_id":53,"body":"(ns dbl_linear.core)\n\n(defn dbl_linear [n]\n  (loop [i 1 x 0 y 0 acc {0 1}]\n  (if (> i n)\n    (get acc n)\n    (let [a (get acc x)\n          b (get acc y)\n          e (min (inc (* 2 a)) (inc (* 3 b)))\n          x0 (if (= e (inc (* 2 a))) (inc x) x)\n          y0 (if (= e (inc (* 3 b))) (inc y) y)]\n      (recur (inc i) x0 y0 (assoc acc i e))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14838,"user_id":null,"body":"(ns dbl_linear.core)\n\n(defn series\n  ([] (series (sorted-set 1)))\n  ([q] (lazy-seq\n         (let [x     (first q)\n               new-q (conj (disj q x) (+ (* 2 x) 1) (+ (* 3 x) 1))]\n           (cons x (series new-q))))))\n\n(def dbl_linear (partial nth (series)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14839,"user_id":null,"body":"(ns dbl_linear.core)\n\n(defn in-seq [x]\n  (and (not (ratio? x)) (or (= 1 x) (in-seq (\/ (dec x) 2)) (in-seq (\/ (dec x) 3)))) )\n\n(defn dbl_linear [n]\n    (second (take-nth n (filter in-seq (iterate inc 1)))) )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14840,"user_id":null,"body":"(ns dbl_linear.core)\n\n(defn dbl_linear [n]\n  (first (reduce (fn [acc _]\n                   (let [x (first acc)]\n                     (-> acc\n                         (conj (inc (* 2 x)))\n                         (conj (inc (* 3 x)))\n                         (disj x))))\n                 (sorted-set 1)\n                 (range n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14841,"user_id":null,"body":"(ns dbl_linear.core)\n\n(defn next-in-seq [as]\n  (let [c (first as)\n        cs (disj as c)]\n    (conj cs\n      (+ (* c 3) 1)\n      (+ (* c 2) 1))))\n\n(defn dbl_linear [n]\n  (first (nth (iterate next-in-seq (sorted-set 1)) n)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14842,"user_id":null,"body":"(ns dbl_linear.core)\n\n(defn lazy-order [xs ys]\n  (lazy-seq\n   (let [x (first xs)\n         y (first ys)]\n     (cond\n       (< x y) (cons x (lazy-order (rest xs) ys))\n       (> x y) (cons y (lazy-order (rest ys) xs))\n       :else (cons x (lazy-order (rest xs) (rest ys)))))))\n\n(def u-seq\n  (lazy-cat [1]\n            (lazy-order (map #(inc (*' 2 %)) u-seq)\n                        (map #(inc (*' 3 %)) u-seq))))\n\n(defn dbl_linear [n]\n  (nth u-seq n))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14843,"user_id":null,"body":"(ns dbl_linear.core)\n\n(defn dbl_linear [n]\n    (loop [s (sorted-set 1) i 0 ]\n        (if (= i n)\n            (first s)\n            (let [\n                    f (first s) \n                    r (disj s f)\n                    x (+ 1 (* 2 f))\n                    y (+ 1 (* 3 f))\n                    r (conj r x y)\n                ]\n                (recur r (+ 1 i))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14844,"user_id":62,"body":"(ns dbl_linear.core)\n\n\n(defn merge-sorted \n  \"Merge the sorted lists into a single sorted list, omitting duplicates.\"\n  [& collections]\n  (lazy-seq\n   (let [colls (sort-by first collections)\n         coll  (first colls)]\n     (cons (first coll) (apply merge-sorted (rest coll) (rest colls))))))\n\n(def u-seq\n  (lazy-seq\n   (distinct (cons 1 (merge-sorted\n                      (map #(inc (* 2 %)) u-seq)\n                      (map #(inc (* 3 %)) u-seq))))))\n\n(defn dbl_linear [n]\n  (nth u-seq n))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"567ffb369f7f92e53800005b":[{"id":14845,"user_id":492,"body":"(ns bernoulli.core)\n\n(defn- bernoulli_aux [n]\n  (loop [ndx 0 j ndx\n         ary (vec (map #(\/ 1 %) (range 1 (+ n 2))))]\n  (cond\n    (>= j 1) (recur ndx (dec j) (assoc ary (dec j) (* j (- (nth ary (dec j)) (nth ary j)))))\n    (< ndx n) (recur (inc ndx) (inc ndx) ary) \n    :else (nth ary 0))))\n(defn bernoulli_number [n]\n  (cond\n    (= n 1) (\/ -1 2)\n    (= n 0) 1\n    (not= 0 (mod n 2)) 0\n    :else (bernoulli_aux n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14846,"user_id":null,"body":"(ns bernoulli.core)\n\n(def max-idx 500)\n\n;; Generate Pascal's triangel\n\n(defn next-tier-item\n  [last-tier acc k]\n  (let [n (count last-tier)]\n    (conj acc (+'\n                (if (= k 0) 0 (last-tier (dec k)))\n                (if (= k n) 0 (last-tier k))))\n    )\n  )\n\n(defn next-tier\n  [last-tier]\n  (->>\n    (range (inc (count last-tier)))\n    (reduce (partial next-tier-item last-tier) [])\n    )\n  )\n\n (defn gen-triangle\n  [limit]\n  (->>\n    (range 1 limit)\n    (reduce (fn [acc elem] (conj acc (next-tier (last acc)))) [[1]])\n    )\n  )\n\n(def triangle-lookup (gen-triangle (+ max-idx 2)))\n\n;; Generate bernoulli numbers\n\n(defn combination\n  [n k]\n  ((triangle-lookup n) k)\n  )\n\n(defn term-k\n  [k m b-num-at-k]\n  (* (combination (inc m) k) b-num-at-k)\n  )\n\n(defn sigma-over-k\n  [m b-numbers]\n  (->>\n    (range m)\n    (reduce (fn [acc k] (+ acc (term-k k m (b-numbers k)))) 0)\n    )\n  )\n\n(defn next-bern-num\n  [b-numbers]\n  (let [ m (count b-numbers) ]\n    (if (and (> m 2) (odd? m))\n        0\n        (\/ (- 0 (sigma-over-k m b-numbers)) (inc m))  \n      )\n    )\n  )\n\n(defn gen-bern-numbers\n  [limit]\n  (->>\n    (range limit)\n    (reduce (fn [acc elem] (conj acc (next-bern-num acc))) [1])\n    )\n  )\n \n(def bernouilli-lookup (gen-bern-numbers (inc max-idx)))\n\n(defn bernoulli_number\n  [m]\n  (if (and (> m 2) (odd? m))\n    0\n    (nth bernouilli-lookup m)\n    )\n  )\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14847,"user_id":null,"body":"(ns bernoulli.core)\n\n(defn tria [n]\n  (loop [res [1N]\n         [f & rest] (range n)]\n    (if (nil? f)\n      res\n      (recur (conj res (\/ (* (last res) (- (inc n) f)) (inc f))) rest))))\n\n(def bn (memoize (fn [n]\n                 (if (zero? n)\n                   1\n                   (if (= 1 n)\n                     -1\/2\n                     (if (odd? n)\n                       0N\n                       (let [tri (tria n)\n                             res (map bn (range 1 n))\n                             mul (drop 1 (drop-last tri))\n                             div (last tri)\n                             sum (inc (reduce + (map * res mul)))\n                             ans (* -1N (\/ sum div))]\n                         ans)))))))\n\n(defn bernoulli_number [n]\n  (bn n))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14848,"user_id":null,"body":"(ns bernoulli.core)\n\n(defn sign [n] (if (odd? n) 1 -1))\n\n(defn binomial [n k]\n  (let [newk (min k (- n k))]\n    (cond\n      (== newk 0) 1\n      :else (* (\/ n newk) (reduce * (map #(\/ (- n %) %) (range 1 newk)))))))\n\n(def bernoulli_number\n  (memoize (fn [n]\n  (cond\n    (== n 0) 1\n    (== n 1) -1\/2\n    (odd? n) 0\n    :else (->> (range 0 n)\n            (map #(* (sign n) (binomial n %) (\/ (bernoulli_number %) (- n % -1))))\n            (reduce +))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14849,"user_id":null,"body":"(ns bernoulli.core)\n\n(defn bernoulli_number [n]\n  (let [zz-calc-next-row (fn [prev-row]\n                           (reductions +' (cons (last prev-row) (reverse prev-row)))\n                         )\n        zigzag-numbers (cons 1 (map first (iterate zz-calc-next-row '(1))))\n        bernoulli-formula (fn [s n n2 n4 z] \n                            (\/ (*' n z s) (-' n2 n4))\n                          )\n        bernoulli-numbers (map \n                            bernoulli-formula\n                            (cycle [1 -1 1 1])\n                            (rest (range))\n                            (iterate #(*' % 2) 2)\n                            (iterate #(*' % 4) 4) \n                            zigzag-numbers\n                          )\n       ]\n    (cond (= n 1) -1\/2\n          (odd? n) 0\n          :else (nth bernoulli-numbers (dec n))\n    )  \n  )\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14850,"user_id":null,"body":"(ns bernoulli.core)\n\n(defn bernoulli_number [n]\n  (let [zz-calc-next-row (fn [prev-row]\n                           (let [new-row (reduce \n                                           (fn [row above] \n                                             (cons (+' (first row) above) row)\n                                           ) \n                                           (list (first prev-row)) \n                                           (rest prev-row)\n                                         )]\n                             (cons (first new-row) new-row)\n                           )\n                         )\n        zigzag-numbers (cons 1 (map first (iterate zz-calc-next-row '(1))))\n        bernoulli-formula (fn [s n n2 n4 z] \n                            (\/ (*' n z s) (-' n2 n4))\n                          )\n        bernoulli-numbers (map \n                            bernoulli-formula\n                            (cycle [1 -1 1 1])\n                            (rest (range))\n                            (iterate #(*' % 2) 2)\n                            (iterate #(*' % 4) 4) \n                            zigzag-numbers\n                          )\n       ]\n    (cond (= n 1) -1\/2\n          (odd? n) 0\n          :else (nth bernoulli-numbers (dec n))\n    )  \n  )\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14851,"user_id":null,"body":"(ns bernoulli.core)\n\n(defn fact [n] (if (<= n 1) 1N (* n (fact (dec n)))))\n\n(defn bin-k [m n] (\/ (fact n) (* (fact m) (fact (- n m)))))\n\n(def bernoulli_number \n  (memoize \n   (fn [n]\n     (cond\n       (= n 0) 1\n       (and (> n 2) (odd? n)) 0\n       :else (* (\/ -1 (inc n)) (reduce + (map (fn [x] (* (bin-k (inc x) (inc n)) (bernoulli_number (- n x)))) (range 1 (inc n)))))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14852,"user_id":null,"body":"(ns bernoulli.core)\n\n(def triangle \n  (rest \n    (iterate \n      (fn [xs] \n        (vec \n          (concat [1N]\n                  (map #(reduce + %) (partition 2 1 xs)) \n                  [1N])))\n      [1 1])))\n      \n(def bernoulli\n  (cons 1\n        (map\n          (fn [x row]\n            (let [[_ r] row]\n              (if (and (odd? x) (> x 1))\n                0\n                (\/\n                  (- (reduce + (map #(* %1 %2)\n                                    (take x row)\n                                    (take x bernoulli))))\n                  r))))\n          (rest (range))\n          triangle)))\n          \n;; largest 1337\n;; \n(defn bernoulli_number [n]\n  (nth bernoulli n))\n  \n  \n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14853,"user_id":168,"body":"(ns bernoulli.core)\n\n(def bernoulli_number \n  (memoize (fn [n]\n    (cond\n      (<= n 0) 1\n      (and (> n 1) (odd? n)) 0\n      :else\n        (loop [i 0 c 1N s 0N]\n          (if (= i n)\n              (\/ (- s) (inc n))\n              (recur \n                (inc i) \n                (\/ (* c (+ n 1 (- i))) (+ i 1)) \n                (+ s (* c (bernoulli_number i))))\n          ))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14854,"user_id":null,"body":"(ns bernoulli.core)\n\n(defn binomial-coeff [n k]\n  (if (= k 0)\n      1\n      (\/ (reduce *' (range (-' n k -1) (inc' n)))\n         (reduce *' (range 1 (inc' k))))))\n\n\n(defn- expt-int [base pow]\n  (loop [n pow, y (num 1), z base]\n    (let [t (even? n), n (quot n 2)]\n      (cond\n       t (recur n y (*' z z))\n       (zero? n) (*' z y)\n       :else (recur n (*' z y) (*' z z))))))\n\n\n(defn bernoulli_number [m]\n  (if (and (odd? m)\n           (> m 1))\n      0\n      (let [coeff (fn [k]\n                    (fn [v] (->> (inc' k)\n                                 (\/ (expt-int v m))\n                                 (*' (if (odd? v) -1 1)\n                                     (binomial-coeff k v)))))]\n        (reduce +' (map (fn [k] (reduce +' (map (coeff k) (range (inc' k)))))\n                        (range (inc' m)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"56c04261c3fcf33f2d000534":[{"id":14855,"user_id":53,"body":"(ns doubles.core)\n\n(defn pow [b e] (Math\/pow b e))\n\n(defn v [k n]\n  (\/ 1 (* k (pow (inc n) (* 2 k)))))\n\n(defn u [k N]\n  (reduce (fn [acc n] (+ acc (v k n))) 0 (range 1 (inc N))))\n\n(defn S [K N]\n  (reduce (fn [acc k] (+ acc (u k N))) 0 (range 1 (inc K))))\n\n(defn double-boxes [K N]\n  (S K N))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14856,"user_id":null,"body":"(ns doubles.core)\n\n(defn double-boxes [maxk maxn]\n  (reduce\n    (fn [C k]\n      (reduce\n        (fn [C n]\n          (+ C (\/ 1 (* k (Math\/pow (inc n) (* 2 k))))))\n        C\n        (range 1 (inc maxn))))\n    0\n    (range 1 (inc maxk))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14857,"user_id":null,"body":"(ns doubles.core)\n\n(defn double-boxes [maxk maxn]\n  (reduce + (for [k (range 1 (inc maxk)) n (range 1 (inc maxn))] (\/ (Math\/pow (inc n) (- (* 2 k))) k))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14858,"user_id":492,"body":"(ns doubles.core)\n\n(defn double-boxes-n [maxn k]\n  (loop [n 2 vk (\/ 1 (* k (Math\/pow 2 (* 2.0 k)))) uk vk]\n    (if (> n maxn)\n      uk\n    (let [mk (Math\/pow (\/ n (+ n 1.0)) (* 2.0 k)) rvk (* vk mk) ruk (+ uk rvk)]\n        (recur (inc n) rvk ruk)))))\n(defn double-boxes [maxk maxn]\n  (loop [k 1 sm 0]\n    (if (> k maxk)\n      sm      \n      (recur (inc k) (+ sm (double-boxes-n maxn k))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14859,"user_id":null,"body":"(ns doubles.core)\n\n(defn force-box [k n]\n  (\/ 1 (* k (Math\/pow (+ 1 n) (* 2 k)))))\n\n(defn double-boxes [K N]\n  (apply + (for [k (range 1 (inc K))\n                 n (range 1 (inc N))]\n             (force-box k n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14860,"user_id":168,"body":"(ns doubles.core)\n\n(defn double-boxes [maxk maxn]\n  (apply +\n    (for [k (range 1 (inc maxk))\n          n (range 1 (inc maxn))]\n      (\/ 1.0 (* k (Math\/pow (inc n) (* 2 k)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14861,"user_id":null,"body":"(ns doubles.core)\n\n(defn u [k n]\n  (apply + (map #(\/ 1 (* 1.0 k (Math\/pow % (* 2 k)))) (range 2 (+ n 2)))))\n\n(defn double-boxes [k n]\n  (apply + (map #(u % n) (range 1 (inc k)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14862,"user_id":null,"body":"(ns doubles.core)\n\n(defn v [k n]\n  (\/ 1 (* k (Math\/pow (+ n 1) (* 2 k)))))\n\n(defn u [k n]\n  (->> (range 1 (inc n))\n       (map (partial v k))\n       (apply +)))\n\n(defn double-boxes [maxk maxn]\n  (->> (range 1 (inc maxk))\n       (map #(u % maxn))\n       (apply +)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14863,"user_id":null,"body":"(ns doubles.core)\n\n(defn double-boxes [maxk maxn]\n  (loop [k 1\n         n 1\n         sum 0.0]\n         (let [\n               n-plus-1 (+ n 1)\n               two-k (* 2 k)\n               n-plus-1-sq (Math\/pow n-plus-1 two-k)\n               cur-sum (\/ 1 (* k n-plus-1-sq))\n               new-sum (+ sum cur-sum)\n               new-n (if (= n maxn)\n                       1\n                       (+ n 1))\n               new-k (if (= n maxn)\n                      (+ k 1)\n                      k)\n               ]\n               (if \n                   (and (= k maxk)\n                   (= n maxn))\n                   new-sum \n                   (recur new-k new-n new-sum) \n                 ) ; if \n           ) ; let\n        ) ; loop\n    ) ; defn\n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14864,"user_id":null,"body":"(ns doubles.core)\n\n(defn kvfunc [exp n] (\/ 1 (double (reduce * (repeat exp (bigint (inc n)))))))\n\n(defn ufunc [k n] (let [exp (* 2 k)] (\/ (reduce + (take-while #(> % 0.0000000001) (map #(kvfunc exp %) (range 1 (inc n))))) k)))\n\n(defn double-boxes [maxk maxn] (reduce + (map #(ufunc % maxn) (range 1 (inc maxk)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5886e082a836a691340000c3":[{"id":14865,"user_id":53,"body":"(ns kata)\n(defn rectangle_rotation [a b]\n  (let* [x (int (Math\/floor (\/ a (Math\/sqrt 2))))\n         y (int (Math\/floor (\/ b (Math\/sqrt 2))))\n         r (+ (* (inc x) (inc y)) (* x y))]\n    (dec (+ r (mod r 2)))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14866,"user_id":492,"body":"(ns kata)\n(defn rectangle_rotation [a b]\n  (let [\n        x (int (Math\/floor (\/ a (Math\/sqrt 2.0))))\n        y (int (Math\/floor (\/ b (Math\/sqrt 2.0))))\n      ]\n      (if (= 0 (mod (+ x y) 2))\n          (+ (* (+ x 1) (+ y 1)) (* x y))\n          (+ (* (+ x 1) y) (* (+ y 1) x))\n      )\n  )\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14867,"user_id":168,"body":"(ns kata)\n(defn rectangle_rotation [a b]\n  (let [x (int (\/ a (Math\/sqrt 2)))\n        y (int (\/ b (Math\/sqrt 2)))]\n    (+ (* 2 x y) x y (mod (+ 1 x y) 2))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14868,"user_id":null,"body":"(ns kata)\n\n(defn size1 [side-length]\n  (int (- (* 2 (Math\/ceil (* 0.5 (\/ side-length (Math\/sqrt 2))))) 1)))\n\n(defn size2 [side-length]\n  (int (* 2 (Math\/ceil (- (* 0.5 (\/ side-length (Math\/sqrt 2))) 0.5)))))\n\n(defn rectangle_rotation [a b]\n  (+ (* (size1 a) (size1 b))\n     (* (size2 a) (size2 b))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14869,"user_id":null,"body":"(ns kata)\n\n(defn calc-squares [side height-center height-second]\n  (if (even? (\/ side 2))\n    (+ height-center (* (\/ side 2) (+ height-center height-second)))\n    (+ height-center (* (\/ (- side 2) 2) (+ height-center height-second)) (* 2 height-second))))\n\n(defn rectangle_rotation [a b]\n  (let [center-height (inc (* 2 (int (quot (\/ a 2) (Math\/sqrt 2)))))\n        other-height (if (>= (- a (* (dec center-height) (Math\/sqrt 2))) (Math\/sqrt 2))\n                       (inc center-height)\n                       (dec center-height))\n        side (int (* 2 (quot b (Math\/sqrt 2))))]\n    (calc-squares side center-height other-height)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14870,"user_id":null,"body":"(ns kata\n  (:import [java.lang Math]))\n\n(def root-two (Math\/sqrt 2))\n\n(defn calc-1 [a]\n  (inc (* 2 (int (Math\/floor (\/ (\/ a 2) root-two))))))\n\n(defn calc-2 [a]\n  (* 2 (inc (int (Math\/floor (\/ (- (\/ a 2) (\/ 1 root-two)) root-two))))))\n\n(defn rectangle_rotation [a b]\n  (let [a1 (calc-1 a)\n        b1 (calc-1 b)\n        a2 (calc-2 a)\n        b2 (calc-2 b)]\n    (+ (* a1 b1) (* a2 b2))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14871,"user_id":null,"body":"(ns kata)\n\n(defn in_sqrt2 [x] (int (\/ x (Math\/sqrt 2))))\n\n(defn rectangle_rotation [a b]\n  (let [\n        a2 (in_sqrt2 a)\n        b2 (in_sqrt2 b)\n        point_number (+ a2 (* b2 (inc (* a2 2))))\n       ]\n       (if (= (mod a2 2) (mod b2 2))\n         (inc point_number)\n         point_number\n       )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14872,"user_id":null,"body":"(ns kata)\n\n(def sqrt-from-2 (Math\/sqrt 2))\n\n(defn approx-dots [side]\n    (+ 1 (int (\/ side sqrt-from-2))))\n\n(defn rectangle_rotation [a b]\n    (def a-dots (approx-dots a))\n    (def b-dots (approx-dots b))\n    (def res (+ (* (- a-dots 1) (- b-dots 1)) (* a-dots b-dots)))\n    (- res (mod (- res 1) 2)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14873,"user_id":null,"body":"(ns kata)\n\n(defn row-len\n  \"Figures out how many intersections fit in an odd diagonal line\"\n  [x]\n  (int (\/ x (Math\/sqrt 2))))\n\n(defn adjust\n  \"adds 1 if the rows are paired odd-odd or even.\n  I'm not exactly sure why this works\"\n  [ora orb]\n  (- 1 (mod (+ ora orb) 2)))\n\n(defn rectangle_rotation [a b]\n        ;; odd diagonals lengths\n  (let [[ora orb] (map row-len [a b])]\n        ;; (x + 1) y + x (y + 1) = 2 x y + x + y\n    (prn ora orb)\n    (+ (* 2 ora orb) ora orb (adjust ora orb)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14874,"user_id":null,"body":"(ns kata)\n\n(defn r'->r [x' y']\n  (let [f (\/ 1 (Math\/sqrt 2))]\n    (map (partial * f) [(- x' y') (+ x' y')])))\n\n(defn y-counter [a b]\n  (fn [x]\n    (let [f (\/ 1 (Math\/sqrt 2))\n          fa (* f a)\n          fb (* f b)\n          y-max (int (Math\/floor (min (- fa x) (+ fb x))))\n          y-min (int (Math\/ceil (max (- (- 0 fa) x) (+ (- 0 fb) x))))]\n      (if (>= y-max y-min)\n        (inc (- y-max y-min))\n        0))))\n\n(defn rectangle_rotation [a b]\n  (let [x-max (int (Math\/floor (first (r'->r (\/ a 2) (\/ (- 0 b) 2)))))\n        x-min (- 0 x-max)]\n    (->> \n      (range x-min (inc x-max))\n      (map (y-counter a b))\n      (apply +))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"593ff8b39e1cc4bae9000070":[{"id":14875,"user_id":null,"body":"(ns lcs.core)\n\n(def lcs\n  (memoize\n   (fn [x y]\n     (cond\n       (or (empty? x) (empty? y)) \"\"\n       (= (first x) (first y)) (str (first x) (lcs (subs x 1) (subs y 1)))\n       :else (max-key count (lcs (subs x 1) y) (lcs x (subs y 1)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14876,"user_id":null,"body":"(ns lcs.core)\n\n(def ccc (memoize (fn [a b i j]\n                    (cond (or (zero? i) (zero? j))\n                          0\n                          (= (nth a (dec i)) (nth b (dec j)))\n                          (inc (ccc a b (dec i) (dec j)))\n                          :else\n                          (max (ccc a b i (dec j)) (ccc a b (dec i) j))))))\n\n(def backtrack (memoize (fn [a b i j]\n                          (cond (or (zero? i) (zero? j))\n                                \"\"\n                                (= (nth a (dec i)) (nth b (dec j)))\n                                (str (backtrack a b (dec i) (dec j)) (nth a (dec i)))\n                                (> (ccc a b i (dec j)) (ccc a b (dec i) j))\n                                (backtrack a b i (dec j))\n                                :else\n                                (backtrack a b (dec i) j)))))\n\n(defn lcs\n  [^String a ^String b]\n  (backtrack a b (count a) (count b))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14877,"user_id":53,"body":"(ns lcs.core)\n\n(defn hash-key [x y]\n  (if (> (count x) (count y))\n    (format \"%s,%s\" x y)\n    (format \"%s,%s\" y x)))\n\n(defn walk [memo x y]\n  (if (or (empty? x) (empty? y))\n    [memo \"\"]\n    (let [hsh (hash-key x y)]\n      (if (contains? memo hsh)\n        [memo (get memo hsh)]\n        (let [xP (first x)\n              xRest (rest x)\n              yP (first y)\n              yRest (rest y)]\n          (if (= xP yP)\n            (let [sub (walk memo (apply str xRest) (apply str yRest))\n                  memo1 (first sub)\n                  res1 (second sub)\n                  res (apply str (cons xP res1))]\n              [(assoc memo1 hsh res) res])\n            (let [sub1 (walk memo x (apply str yRest))\n                  memo1 (first sub1)\n                  res1 (second sub1)\n                  sub2 (walk memo1 (apply str xRest) y)\n                  memo2 (first sub2)\n                  res2 (second sub2)]\n              (if (> (count res1) (count res2))\n                [(assoc memo2 hsh res1) res1]\n                [(assoc memo2 hsh res2) res2]))))))))\n\n(defn lcs [^String x ^String y]\n  (second (walk {} x y)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14878,"user_id":null,"body":"(ns lcs.core)\n\n(defn update-tbl-on-match [tbl mc idxn idxm]\n  (assoc tbl [idxn idxm] (str (tbl [(dec idxn) (dec idxm)] \"\") mc)))\n\n(defn update-tbl-on-compete [tbl idxn idxm]\n  (let [nc (tbl [(dec idxn) idxm] \"\")\n        mc (tbl [idxn (dec idxm)] \"\")]\n    (if (> (count nc) (count mc))\n      (assoc tbl [idxn idxm] nc)\n      (assoc tbl [idxn idxm] mc))))\n\n(defn lcs\n  [^String m ^String n]\n  (if (or (= \"\" m) (= \"\" n))\n    \"\"\n    (let [len-m (count m)\n          len-n (count n)]\n      (->> (loop [idxn 0\n                  tbl (sorted-map)]\n              (if (= len-n idxn)\n                 tbl\n                 (recur (inc idxn)\n                        (loop [idxm 0\n                               tbl tbl]\n                          (if (= idxm len-m)\n                              tbl\n                             (let [mc (nth m idxm)\n                                  nc (nth n idxn)]\n                               (if (= mc nc)\n                                   (recur (inc idxm)\n                                          (update-tbl-on-match tbl mc idxn idxm))\n                                  (recur (inc idxm)\n                                         (update-tbl-on-compete tbl idxn idxm)))))))))\n            last\n            val))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14879,"user_id":null,"body":"(ns lcs.core)\n\n(def lcs-table\n  (memoize\n   (fn [X Y i j]\n     (cond\n       (or (zero? i) (zero? j)) #{\"\"}\n       (= (nth X (dec i)) (nth Y (dec j))) (set (map #(str % (nth X (dec i))) (lcs-table X Y (dec i) (dec j))))\n       :else (let [a (lcs-table X Y i (dec j))\n                   b (lcs-table X Y (dec i) j)]\n               (if (= (count (first a)) (count (first b)))\n                 (set (concat a b))\n                 (set (max-key #(count (first %)) a b))))))))\n\n(defn lcs [X Y]\n  (first (lcs-table X Y (count X) (count Y))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14880,"user_id":null,"body":"(ns lcs.core)\n\n(defn longest [& seqs] (apply max-key count seqs))\n\n(def longest-subsequence\n  (memoize\n    (fn [[x & xs] [y & ys]]\n      (cond\n         (some nil? [x y]) nil\n         (= x y) (cons x (longest-subsequence xs ys))\n         :else (longest (longest-subsequence (cons x xs) ys)\n                   (longest-subsequence xs (cons y ys)))))))\n\n(def lcs (comp (partial apply str) longest-subsequence))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14881,"user_id":null,"body":"(ns lcs.core)\n\n(defn longest [xs ys] (if (> (count xs) (count ys)) xs ys))\n\n(def lcseq\n  (memoize\n    (fn [[x & xs] [y & ys]]\n      (cond\n         (or (= x nil) (= y nil)) nil\n         (= x y) (cons x (lcseq xs ys))\n         :else (longest (lcseq (cons x xs) ys)\n                        (lcseq xs (cons y ys)))))))\n\n(defn lcs\n  [^String x ^String y]\n  (apply str (lcseq x y)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14882,"user_id":null,"body":"(ns lcs.core)\n(require '[clojure.set :refer [union]])\n\n(def cache (atom {}))\n\n(defn cs [[x & xs] ys]\n  (let [k (list x xs ys)]\n    (if (contains? @cache k)\n      (get @cache k)\n      (let [a (if (nil? x)\n                \"\"\n                (let [n (.indexOf ys x)\n                      r (cs xs ys)]\n                  (if (neg? n)\n                    r\n                    (max-key count r (str x (cs xs (drop (+ 1 n) ys)))))))]\n        (swap! cache assoc k a)\n        a))))\n\n(defn lcs [xs ys]\n  (cs (apply list xs) (apply list ys)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14883,"user_id":null,"body":"(ns lcs.core)\n\n(defn pick-longer [xs ys]\n  (if (> (count xs)\n         (count ys))\n    xs\n    ys))\n\n(def lcs\n  (memoize\n   (fn [[x & xs :as xall] [y & ys :as yall]]\n     (cond\n       (or (nil? x) (nil? y)) \"\"\n       (= x y) (apply str x (lcs xs ys))\n       :else (pick-longer (lcs xall ys)\n                          (lcs xs yall))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14884,"user_id":null,"body":"(ns lcs.core)\n\n(defn longest [^String x ^String y] \n  (if (> (count x) (count y)) \n    x\n    y))\n \n(def lcs \n  (memoize \n   (fn [^String [x & x-rest :as x-all]\n        ^String [y & y-rest :as y-all]]\n     (cond\n      (or (= x nil) (= y nil)) \"\"\n      (= x y) (clojure.string\/join \"\" (cons x (lcs x-rest y-rest)))\n      :else (longest (lcs x-all y-rest)\n                     (lcs x-rest y-all))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"50654ddff44f800200000004":[{"id":14885,"user_id":null,"body":"(ns multiply.bug.fix)\n\n(def multiply *)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14886,"user_id":null,"body":"(ns multiply.bug.fix)\n\n(defn multiply [a b]\n (* a b))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14887,"user_id":null,"body":"(ns multiply.bug.fix)\n\n(defn multiply \n  [a b]\n  (* a b))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14888,"user_id":null,"body":"(ns multiply.bug.fix)\n\n(defn multiply \n \"A simple multiplication test\"\n  [& args] (apply * args))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14889,"user_id":null,"body":"(ns multiply.bug.fix) (def multiply #(* % %2))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14890,"user_id":null,"body":"(ns multiply.bug.fix)\n\n(defmacro multiply_macro [l]\n    (list (second l) (first l) (last l)))\n\n(defn multiply [a b]\n    (multiply_macro (a * b)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14891,"user_id":null,"body":"(ns multiply.bug.fix)\n\n;https:\/\/www.codewars.com\/kata\/50654ddff44f800200000004\/train\/clojure\n(defn multiply [a b]\n  (* a b)\n  )\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14892,"user_id":null,"body":"(ns multiply.bug.fix)\n\n;(defn multiply [a b]\n; (* a b))\n\n (def multiply #(* % %2))\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14893,"user_id":null,"body":"(ns multiply.bug.fix)\n\n(defn multiply [a b]\n (* a b)\n)\n\n;; clojure uses * num1 num2 and not num1 * num 2 (which yields 1 * num2)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14894,"user_id":null,"body":"(ns multiply.bug.fix)\n\n(defn multiply \n  [& args] (apply * args))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"513e08acc600c94f01000001":[{"id":14895,"user_id":null,"body":"(ns rgb.core)\n\n(defn valid [v] (int (max 0 (min 255 v))))\n\n(defn rgb [r g b] (apply format \"%02X%02X%02X\" (map valid [r g b])))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14896,"user_id":null,"body":"(ns rgb.core)\n(defn rgb [r g b]\n  (->> [r g b]\n    (map (comp (partial min 255)\n               (partial max 0)))\n    (apply format \"%02x%02x%02x\") \n    clojure.string\/upper-case))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14897,"user_id":null,"body":"(ns rgb.core\n  (:require [clojure.string :as str]))\n\n(defn cap [x] (max 0 (min x 255)))\n(defn rgb [r g b]\n     (str\/upper-case (format \"%02x%02x%02x\" (cap r) (cap g) (cap b))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14898,"user_id":null,"body":"(ns rgb.core)\n\n(defn rgb [r g b]\n  (->> (map #(max 0 (min 255 %)) [r g b])\n       (apply format \"%02X%02X%02X\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14899,"user_id":null,"body":"(ns rgb.core)\n\n(defn rgb [r g b]\n  (reduce #(format \"%s%02X\" %1 %2) \"\" (map #(-> %1 (min 255) (max 0)) [r g b])))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14900,"user_id":null,"body":"(ns rgb.core)\n\n(defn rgb [r g b]\n     (let [clamp #(->> %\n                    (min 255)\n                    (max 0))]\n    (format \"%02X%02X%02X\" (clamp r) (clamp g) (clamp b)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14901,"user_id":null,"body":"(ns rgb.core)\n\n(defn hexify [s]\n  (cond \n    (> s 255) \"FF\"\n    (<= s 0) \"00\"\n    :else (format \"%02X\" s)\n    ))\n\n(defn rgb [r g b]\n  (apply str (map hexify [r g b]))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14902,"user_id":null,"body":"(ns rgb.core)\n\n(set! *unchecked-math* true)\n\n(defn- fix-hex [^long h]\n  (if (= h Long\/MIN_VALUE) \"FF\"\n    (let [^String hex (Long\/toHexString (min 255 (max h 0)))]\n      (cond (= hex \"F\") (str hex hex)\n            (= 1 (.length hex)) (str \"0\" hex)\n            :else hex))))\n\n(defn rgb [^long r ^long g ^long b]\n  (.toUpperCase (str (fix-hex r) (fix-hex g) (fix-hex b))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14903,"user_id":null,"body":"(ns rgb.core)\n\n(defn hex-char [n]\n  (char (+ n (int (if (< n 10) \\0 \\7)))))\n(defn hex-num [n]\n  (->> ((juxt quot mod) n 16) (map hex-char) (apply str)))\n(defn cap [n] (-> n (max 0) (min 255)))\n(defn rgb [& args]\n  (apply str (map (comp hex-num cap) args)))\n ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14904,"user_id":null,"body":"(ns rgb.core)\n\n(defn bound [x]\n  (max 0 (min x 255)))\n\n(defn rgb [r g b]\n   (format \"%02X%02X%02X\" (bound r) (bound g) (bound b)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"514a677421607afc99000002":[{"id":14905,"user_id":null,"body":"(ns getnames)\n\n(defn get-names [data]\n  (map :name data))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14906,"user_id":null,"body":"(ns getnames)\n(defn get-names [data]\n  (mapv :name data))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14907,"user_id":null,"body":"(ns getnames)\n\n(defn get-names [data]\n  (mapv #(:name %) data))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14908,"user_id":null,"body":"(ns getnames)\n(defn get-names [data]\n  (mapv #(% :name) data))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14909,"user_id":null,"body":"(ns getnames)\n\n(defn get-names [data]\n  (map #(:name %) data))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"514b92a657cdc65150000006":[{"id":14910,"user_id":1519,"body":"(ns multiples)\n\n(defn solution [number]\n  (->> number\n       (range)\n       (rest)\n       (filter #(or (zero? (mod % 3)) (zero? (mod % 5))))\n       (apply +))\n  )","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14911,"user_id":null,"body":"(ns multiples)\n\n(defn solution [number]\n  (reduce + (distinct (mapcat #(range % number %) [3 5]))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14912,"user_id":null,"body":"(ns multiples)\n\n(defn solution [number]\n  (->> (range number)\n       (filter #(or (= 0 (rem % 3))\n                    (= 0 (rem % 5))))\n       (reduce +)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14913,"user_id":null,"body":"(ns multiples)\n\n(defn multiple-of-3-and-5? [n]\n  (or (= 0 (mod n 3)) (= 0 (mod n 5))))\n\n(defn solution [number]\n  (->> (range number)\n       (filter multiple-of-3-and-5?)\n       (reduce +)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14914,"user_id":null,"body":"(ns multiples)\n\n(defn solution [number]\n  (->> (concat (range 3 number 3) (range 5 number 5))\n       distinct\n       (apply +)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14915,"user_id":2765,"body":"(ns multiples)\n\n(defn solution [number]\n\t(let [ n (- number 1)\n        x (quot n 3)\n  \t\t\ty (quot n 5)\n        z (quot n 15)\n        xx (* (* 3 x) (+ x 1))\n        yy (* (* 5 y) (+ y 1))\n        zz (* (* 15 z) (+ z 1)) ]\n        (quot (- (+ xx yy) zz) 2))\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14916,"user_id":null,"body":"(ns multiples)\n\n(defn solution [number]\n  (reduce + (filter #(or (zero? (mod % 3)) (zero? (mod % 5))) (range number))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14917,"user_id":null,"body":"(ns multiples)\n\n(defn solution [number]\n  (reduce +\n    (for [x (range number)\n         :when (or (= (mod x 3) 0) (= (mod x 5) 0))]\n         x)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14918,"user_id":null,"body":"(ns multiples)\n\n(defn sum-integers\n  [n]\n  (-> n inc (* n) (\/ 2)))\n\n(defn sum-of-multiples\n  [n m]\n  (->> m (quot (dec n)) sum-integers (* m)))\n\n(defn solution\n  [n]\n  (+ (sum-of-multiples n 3)\n     (sum-of-multiples n 5)\n     (- (sum-of-multiples n 15))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14919,"user_id":null,"body":"(ns multiples)\n\n(defn multiple?\n  [q d]\n  (zero? (mod q d)))\n\n(defn solution [number]\n  (->> number\n    (range)\n    (filter #(or (multiple? % 3) (multiple? % 5)))\n    (reduce +)))\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"515de9ae9dcfc28eb6000001":[{"id":14920,"user_id":null,"body":"(ns split-str.core)\n\n\n(defn solution\n  [s]\n(map clojure.string\/join (partition 2 2 \"_\" s)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14921,"user_id":null,"body":"(ns split-str.core)\n\n(defn solution\n  [s]\n  (map #(apply str %) (partition 2 2 \"_\" s)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14922,"user_id":null,"body":"(ns split-str.core)\n\n\n(defn solution [s]\n  (map #(apply str %) (partition 2 2 [\"_\"] s)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14923,"user_id":null,"body":"(ns split-str.core)\n\n  (defn solution\n  [xs]\n  (map (partial apply str)\n       (partition 2 (if (odd? (count xs))\n                      (str xs \"_\")\n                      xs)))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14924,"user_id":null,"body":"(ns split-str.core)\n\n(defn solution [s]\n  (map clojure.string\/join (partition 2 2 [\"_\"] s)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14925,"user_id":null,"body":"(ns split-str.core)\n\n(defn solution [s]\n  (->> (partition 2 2 [\"_\"] s)\n       (map (partial apply str))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14926,"user_id":null,"body":"(ns split-str.core)\n\n(defn solution\n  [a]\n  (->> a\n    (partition 2 2 \"_\")\n    (map (partial apply str))\n    ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14927,"user_id":null,"body":"(ns split-str.core)\n\n(defn solution [s]\n  (re-seq #\"[a-zA-Z0-9_]{2}\" (if (even? (count s)) s (str s \"_\")))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14928,"user_id":null,"body":"(ns split-str.core)\n\n(defn solution\n  [s]\n  (let [l (count s)\n        s (if (even? l) s (str s \"_\"))]\n    (re-seq #\"..\" s)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14929,"user_id":null,"body":"(ns split-str.core)\n\n(defn solution\n  [s]\n  (->> (partition 2 2 \"_\" s)\n       (map (fn [c] (map str c)))\n       (map clojure.string\/join))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"515e271a311df0350d00000f":[{"id":14930,"user_id":null,"body":"(ns kata)\n\n(defn square_sum [lst]\n  (->> lst\n       (map #(* % %))\n       (apply +)))\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14931,"user_id":null,"body":"(ns kata)\n\n(def square #(* % %))\n\n(defn square_sum [lst]\n  (->> lst\n    (map square)\n    (apply +)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14932,"user_id":null,"body":"(ns kata)\n(use 'clojure.walk)\n\n(defn square_sum [lst]\n  (walk #(* % %) #(apply + %) lst)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14933,"user_id":null,"body":"(ns kata)\n\n(def square_sum (partial reduce #(+ %1 (* %2 %2)) 0))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14934,"user_id":null,"body":"(ns kata)\n\n(defn square_sum [lst]\n  ;; TODO\n  (reduce + (map #(* % %) lst))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14935,"user_id":null,"body":"(ns kata)\n\n(defn square_sum [lst]\n  (def s (map #(* %1 %1) lst))\n  (reduce + s)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14936,"user_id":null,"body":"(ns kata)\n\n(defn square_sum [lst]\n  (reduce + (for [number lst] (* number number)))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14937,"user_id":null,"body":"(ns kata)\n\n(defn- square [x]\n  (* x x))\n\n(defn square_sum [lst]\n  (reduce + (map square lst)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14938,"user_id":null,"body":"(ns kata)\n\n(defn square_sum [lst]\n    (let \n      [\n       sq        (map #(* %1 %1) lst)\n       ] (apply + sq))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14939,"user_id":null,"body":"(ns kata)\n\n(defn square_sum [numbers]\n  (reduce + (map (fn [num] (* num num)) numbers))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"515f51d438015969f7000013":[{"id":14940,"user_id":null,"body":"(ns kata.pyramid)\n(defn pyramid [n]\n        \"Int -> Vector, returns Vector of ascending sub-vectors of lengths 1-n\"\n        (into [] (for [x (range 1 (inc n))] (into [] (repeat x 1)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14941,"user_id":null,"body":"(ns kata.pyramid)\n\n(defn pyramid [n]\n  (map #(repeat % 1) (range 1 (inc n)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14942,"user_id":564,"body":"(ns kata.pyramid)\n(defn pyramid [n]\n  (map\n    (fn [len] (repeat (+ 1 len) 1))\n    (range n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14943,"user_id":null,"body":"(ns kata.pyramid)\n\n(defn gen-arr [n] \n  (let [r (range n)]\n    (map (fn [_] 1) r)))\n\n(defn pyramid [n] \n  (let [r (range n)]\n    (map #(gen-arr (inc %)) r)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14944,"user_id":null,"body":"(ns kata.pyramid)\n(defn pyramid [n]\n  (map #(repeat (inc %) 1) (range n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14945,"user_id":null,"body":"(ns kata.pyramid)\n(defn pyramid [n]\n  (->> \n    (range 1 (inc n))\n    (map (fn [x] \n           (vec (take x (repeat 1)))))\n    vec))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14946,"user_id":null,"body":"(ns kata.pyramid)\n(defn pyramid [n]\n  (map-indexed\n    (fn [idx, _] (vec (repeat (+ idx 1) 1)))\n    (vec (repeat n nil))\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14947,"user_id":null,"body":"(ns kata.pyramid)\n(defn pyramid [n]\n  (loop [pyramid [] step 0]\n    (if (>= step n)\n      pyramid\n      (recur (conj pyramid (vec(repeat (inc step) 1))) (inc step)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14948,"user_id":null,"body":"(ns kata.pyramid)\n(defn pyramid [n]\n  (->> n\n       inc\n       (range 1)\n       (mapv #(vec (repeat % 1)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14949,"user_id":null,"body":"(ns kata.pyramid)\n(defn pyramid\n  ([n] (pyramid n 0 []))\n  ([n cur coll]\n    (if (>= cur n)\n      coll\n      (recur n (inc cur) (->> (inc cur)\n                              (#(repeat % 1))\n                              vec\n                              (conj coll))))))\n\n      \n\n\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5174a4c0f2769dd8b1000003":[{"id":14950,"user_id":527,"body":"(ns kata)\n\n(def solution sort)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14951,"user_id":null,"body":"(ns kata)\n\n(defn solution [n]\n  (if (empty? n)\n    (vector)\n    (sort n)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14952,"user_id":null,"body":"(ns kata)\n\n(defn solution [n]\n  (cond\n    (or (nil? n) (empty? n)) []\n    (= (count n) 1) n\n\n    :else\n    (let [[left right] (reduce (fn [a x]\n                                 (if (> x (first n))\n                                   (update-in a [1] #(conj % x))\n                                   (update-in a [0] #(conj % x))))\n                               [[] []] (rest n))]\n      (vec (concat (solution left) [(first n)] (solution right))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14953,"user_id":null,"body":"(ns kata)\n\n(defn solution [n]\n  ;eTODO\n  (sort n)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14954,"user_id":null,"body":"(ns kata)\n\n(defn solution [n]\n  (if (nil? n)\n    (empty [])\n    (sort n))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14955,"user_id":null,"body":"(ns kata)\n\n(defn solution [n]\n  (vec\n    (sort n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14956,"user_id":null,"body":"(ns kata)\n\n(defn solution [n]\n  (into [] (sort (filter number? n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14957,"user_id":null,"body":"(ns kata)\n\n(defn solution [n]\n  ;TODO\n  (if (seq n)\n    (sort n)\n    [])\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14958,"user_id":null,"body":"(ns kata)\n\n(defn solution [n]\n  (into [] (sort n)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14959,"user_id":null,"body":"(ns kata)\n\n(defn solution [n]\n  (if (empty? n)\n      (vec [])\n      (vec (sort n))\n    )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"51b6249c4612257ac0000005":[{"id":14960,"user_id":null,"body":"(ns solution.core)\n\n(defn solution [roman]\n  (->> roman\n    (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100  \\D 500 \\M 1000})\n    (partition 2 1 [0])\n    (reduce (fn [sum [a b]] ((if (>= a b) + -) sum a))  0)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14961,"user_id":53,"body":"(ns solution.core)\n\n(defn solution [s]\n    (let [conv-map { \"I\" 1 \"IV\" 4 \"V\" 5 \"IX\" 9 \"X\" 10 \"XL\" 40 \"L\" 50  \"XC\" 90 \"C\" 100 \"CD\" 400 \"D\" 500 \"CM\" 900 \"M\" 1000}\n          pattern (re-seq #\"IV|IX|XL|XC|CD|CM|[IVXLCMD]\" s)]\n      (apply + (map conv-map pattern))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14962,"user_id":null,"body":"(ns solution.core)\n\n(defn solution [roman]\n  (->> (partition-by identity roman)\n       (map (partial map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}))\n       (map (partial reduce +))\n       (reverse)\n       (reduce #((if (< %1 %2) + -) %1 %2))\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14963,"user_id":null,"body":"(ns solution.core)\n\n(defn symbol-to-value [sym]\n  (case sym \n    \\I 1\n    \\V 5\n    \\X 10\n    \\L 50\n    \\C 100\n    \\D 500\n    \\M 1000\n  )\n)\n\n(defn roman-plus [carry item]\n  (if (< carry item) (+ carry item) (- carry item))\n)\n\n(defn compact [numbers]\n  (map (fn [x] (reduce + x)) (partition-by identity numbers))\n)\n\n(defn solution [roman]\n  (reduce roman-plus (compact (map symbol-to-value (reverse (seq roman)))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14964,"user_id":null,"body":"(ns solution.core)\n\n\n(def roman-map {\"I\" 1, \"V\" 5, \"X\" 10, \"L\" 50, \"C\" 100, \"D\" 500, \"M\" 1000})\n(defn roman-to-num [r] \n  (roman-map (str r)))\n\n\n(defn solution [roman]\n  (loop [remaining-nums roman numbers []]\n    (if (empty? remaining-nums)\n      (reduce + numbers) \n      (let [[curr-num next-num & remaining] remaining-nums]\n        (recur (filter some? (flatten (list next-num remaining))) (into numbers (set [(if (nil? next-num)\n                                               (roman-map (str curr-num))\n                                               (if (>= (roman-map (str curr-num)) (roman-map (str next-num)))\n                                                 (roman-map (str curr-num))\n                                                 (* -1 (roman-map (str curr-num)))))])))))))\n;;(defn solution [roman]\n  ;; your code here\n;;)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14965,"user_id":null,"body":"(ns solution.core)\n\n(defn solution [roman]\n  (let\n    [mapping {\\0 0 \\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (->> roman\n      (map (fn [chr] (get mapping chr)))\n      ((fn [it] (concat it [0])))\n      (partition 2 1)\n      (reduce (fn [accum [current next]]\n                (+ accum\n                   (if (>= current next) current (- current)))) 0)\n    )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14966,"user_id":null,"body":"(ns solution.core)\n\n\n(def roman-mapping\n  {\n   \\I  1\n   \\V  5\n   \\X  10\n   \\L  50\n   \\C  100\n   \\D  500\n   \\M  1000\n   }\n  )\n\n(defn solution-carry [carry roman]\n  (if (empty? roman)\n    (get roman-mapping carry)\n    (if (< (get roman-mapping carry) (get roman-mapping (first roman)))\n      (- (solution-carry (first roman) (rest roman)) (get roman-mapping carry))\n      (+ (get roman-mapping carry) (solution-carry (first roman) (rest roman)))    \n      )\n    )\n  )\n\n(defn solution [roman]\n  (solution-carry (first (seq roman)) (rest (seq roman)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14967,"user_id":null,"body":"(ns solution.core)\n\n(defn parse [romans]\n  (->> romans (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000})))\n\n(defn solution [roman]\n  (let [units (parse roman)] \n       (loop [todo units part [] acc []]\n         (let [x (first todo)\n               [y z] part]\n           (cond \n             (and y z)\n             (recur todo [] (conj acc (- z y)))\n             (and x y (< y x))\n             (recur (rest todo) (conj part x) acc)\n             (and x y)\n             (recur todo [] (conj acc y))\n             x\n             (recur (rest todo) (conj part x) acc)\n             y  ;; end of input\n             (recur nil nil (conj acc y))\n             (and (not x) (not y))\n             (apply + acc)\n             :else\n             (throw (ex-info \"Illegal state\" {:todo todo :part part :acc acc})))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14968,"user_id":null,"body":"(ns solution.core)\n\n(defn parse [roman]\n  (->> roman (sequence (comp (map str)\n                             (map keyword)))))\n\n(defn parse [romans]\n  (->> romans (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000})))\n\n(defn solution [roman]\n  (let [units (parse roman)] \n       (loop [todo units part [] acc []]\n         (let [x (first todo)\n               [y z] part]\n           (cond \n             (and y z)\n             (recur todo [] (conj acc (- z y)))\n             (and x y (< y x))\n             (recur (rest todo) (conj part x) acc)\n             (and x y)\n             (recur todo [] (conj acc y))\n             x\n             (recur (rest todo) (conj part x) acc)\n             y  ;; end of input\n             (recur nil nil (conj acc y))\n             (and (not x) (not y))\n             (apply + acc)\n             :else\n             (throw (ex-info \"Illegal state\" {:todo todo :part part :acc acc})))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14969,"user_id":null,"body":"(ns solution.core)\n\n(def romans [:I :V :X :L :C :D :M])\n(def units [1 5 10 50 100 500 1000])\n\n(def unit (zipmap romans units))\n\n(def roman-order (->> romans\n                      (into {}\n                            (map-indexed (fn [i rom] [rom i])))))\n\n(defn <rr [rom1 rom2]\n  (< (roman-order rom1) (roman-order rom2)))\n\n(defn parse [roman]\n  (->> roman (sequence (comp (map str)\n                             (map keyword)))))\n\n(defn translate-step [[x y :as input]]\n  (cond\n    (and x y)\n    (- (unit y) (unit x))\n    x\n    (unit x)\n    :else\n    (throw (ex-info \"bad translate step, must have 1 or 2 romans in input seq\"\n                    {:input input}))))\n\n(defn solution [roman]\n  (let [rsyms (parse roman)\n        append (fn [single-or-pair acc]\n                 (->> single-or-pair translate-step (conj acc)))] \n       (loop [todo rsyms xstep [] acc []]\n         (let [x (first todo)\n               [y z] xstep]\n           (cond \n             (and y z)\n             (recur todo [] (append xstep acc))\n             (and x y (<rr y x))\n             (recur (rest todo) (conj xstep x) acc)\n             (and x y)\n             (recur todo [] (append xstep acc))\n             x\n             (recur (rest todo) (conj xstep x) acc)\n             y  ;; end of input\n             (apply + (append xstep acc))\n             (and (not x) (not y))\n             (apply + acc)\n             :else\n             (throw (ex-info \"Illegal state\" {:todo todo :xstep xstep :acc acc})))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"51c89385ee245d7ddf000001":[{"id":14970,"user_id":201,"body":"(ns kata)\n(defn solution [n]\n  (format \"Value is %05d\" n))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14971,"user_id":null,"body":"(ns kata)\n\n(defn solution [n]\n  (let [n-str  (str n)\n        pad-ln (- 5 (count n-str))\n        pad    (apply str (repeat pad-ln \\0))]\n    (str \"Value is \" pad n-str)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14972,"user_id":null,"body":"(ns kata)\n(defn solution [n]\n  (let [c (count (str n))\n        v (- 5 c)]\n    (str \"Value is \" (apply str (repeat v \"0\")) n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14973,"user_id":null,"body":"(ns kata)\n(defn solution [n]\n  (str \"Value is \" (clojure.string\/replace (format \"%5d\" n) #\" \" \"0\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14974,"user_id":null,"body":"(ns kata)\n(defn solution [number]\n  (format \"Value is %05d\" number))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14975,"user_id":201,"body":"(ns kata)\n(defn solution [n]\n  (format \"%05d\" n))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"51c8991dee245d7ddf00000e":[{"id":14976,"user_id":null,"body":"(ns kata\n  (require [clojure.string :as str]))\n\n(defn reverse_words [words]\n  (->> (str\/split words #\" \")\n       (reverse)\n       (str\/join \" \")))","lang_id":5,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14977,"user_id":null,"body":"(ns kata\n  (:require [clojure.string :as str]))\n(def reverse_words\n  (comp\n    (partial str\/join \" \")\n    reverse\n    #(str\/split % #\" \")))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14978,"user_id":53,"body":"(ns kata)\n(require '[clojure.string :as str])\n(defn reverse_words [words]\n  (clojure.string\/join \" \" (reverse (str\/split words #\" \"))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14979,"user_id":null,"body":"(ns kata)\n(defn reverse_words [words]\n  (let [words-seq (clojure.string\/split words #\" \")]\n    (clojure.string\/join \" \" (reverse words-seq))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14980,"user_id":527,"body":"(ns kata\n  (:require [clojure.string :refer [join split]]))\n\n(defn reverse_words [words]\n  (join \" \" (rseq (split words #\" \"))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14981,"user_id":null,"body":"(ns kata\n  (:require [clojure.string :as str]))\n\n(defn reverse_words [words]\n  (->> (-> words\n           (str\/split #\" \"))\n       (reverse)\n       (str\/join \" \")))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14982,"user_id":null,"body":"(ns kata\n  (:require [clojure.string :as str]))\n(defn reverse_words [words]\n  (->> (str\/split words #\" \")\n    reverse\n    (str\/join \" \"))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14983,"user_id":null,"body":"(ns kata)\n\n(defn split-with-delim [s d]\n  (clojure.string\/split s (re-pattern (str \"(?=\" d \")|(?<=\" d \")\"))))\n\n(defn reverse_words [words]\n  (-> words\n      (split-with-delim \" \")\n      (reverse)\n      (clojure.string\/join)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14984,"user_id":null,"body":"(ns kata (:require [clojure.string :as str]))\n\n\n(defn reverse_words [words]\n  (str\/trim (reduce #(str %1 \" \" %2) \"\" (reverse (str\/split words #\" \"))))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14985,"user_id":null,"body":"(ns kata\n  (require [clojure.string :refer [join split]]))\n\n(defn reverse_words [phrase]\n  (let [words (split phrase #\" \")]\n    (->> words\n       (reverse)\n       (join \" \"))))\n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"51f2b4448cadf20ed0000386":[{"id":14986,"user_id":null,"body":"(ns kata)\n\n(defn remove_url_anchor [url]\n  (clojure.string\/replace url #\"#.*\" \"\")\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-26 08:59:49"},{"id":14987,"user_id":null,"body":"(ns kata)\n(defn remove_url_anchor [url] (clojure.string\/replace url #\"#.+\" \"\"))\n","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-26 08:59:44"},{"id":14988,"user_id":null,"body":"(ns kata)\n(defn remove_url_anchor [url]\n  ;TODO\n  ;;(first (clojure.string\/split url #\"#\"))\n\n  (if (= -1 (.indexOf url \"#\"))\n    (subs url 0)\n    (subs url 0 (.indexOf url \"#\"))\n  )\n  )","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-26 08:59:40"},{"id":14989,"user_id":null,"body":"(ns kata)\n(require '[clojure.string :as str])\n\n(defn remove_url_anchor [url]\n  (first (str\/split url #\"#\"))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14990,"user_id":527,"body":"(ns kata)\n(defn remove_url_anchor [url]\n  (apply str (take-while #(not= % \\#) url)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14991,"user_id":null,"body":"(ns kata)\n(defn remove_url_anchor [url]\n  ;TODO\n  (re-find #\".+?(?=\\#)|.*\" url)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14992,"user_id":null,"body":"(ns kata)\n\n(defn remove_url_anchor [url]\n  (nth (re-matches #\"(.*?)(#.*)*\" url) 1))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14993,"user_id":null,"body":"(ns kata)\n(defn remove_url_anchor [url]\n  (clojure.string\/join (take-while (partial not= \\#) url))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14994,"user_id":null,"body":"(ns kata)\n(defn remove_url_anchor [url]\n  (let [idx (clojure.string\/index-of url \"#\")]\n    (if idx\n       (subs url 0 (clojure.string\/index-of url \"#\"))\n      url)  ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14995,"user_id":null,"body":"(ns kata)\n(defn remove_url_anchor [url]\n  (get (clojure.string\/split url #\"#\") 0)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"51f2d1cafc9c0f745c00037d":[{"id":14996,"user_id":527,"body":"(ns kata)\n(def solution clojure.string\/ends-with?)","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14997,"user_id":null,"body":"(ns kata\n  (:require [clojure.string :as str]))\n\n(defn solution [strng ending]\n  (str\/ends-with? strng ending))\n","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14998,"user_id":null,"body":"(ns kata\n  (:require [clojure.string :refer [ends-with?]]))\n\n(def solution ends-with?)","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":14999,"user_id":null,"body":"(ns kata)\n(defn solution [strng ending]\n  (= (take (count ending) (reverse strng)) (reverse ending))  \n  )","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15000,"user_id":null,"body":"(ns kata)\n(use 'clojure.string)\n(defn solution [strng ending]\n    (ends-with? strng ending) \n  )","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15001,"user_id":null,"body":"(ns kata)\n\n(defn take-string-tail [number string]\n  (->> string\n      (take-last number)\n       (apply str)))\n\n(defn solution [string ending]\n  (-> ending\n      count\n      (take-string-tail string) \n      (= ending)))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15002,"user_id":null,"body":"(ns kata\n  (:use clojure.string))\n(defn solution [strng ending]\n  (= 0 (index-of (reverse strng) (reverse ending))))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15003,"user_id":null,"body":"(ns kata\n  (:require [clojure.string :as str]))\n\n(defn solution [strng ending]\n  (let [gnidne (str\/reverse ending)\n        gnrst (str\/reverse strng)]\n    (str\/starts-with? gnrst gnidne))\n  )","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15004,"user_id":null,"body":"(ns kata)\n(defn solution [strng ending]\n(let [str_length (count strng) end_length (count ending)]\n  (if (>= str_length end_length) (if (= 0 (compare ending (subs strng (- str_length end_length) str_length)))\n                                    true\n                                    false)\n      false)\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15005,"user_id":null,"body":"(ns kata)\n(defn solution [strng ending]\n  (if (> (count ending) (count strng))\n    false\n    (= (subs strng (- (count strng) (count ending))) ending)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"51f9d93b4095e0a7200001b8":[{"id":15006,"user_id":3032,"body":"(ns lightsabers)\n\n(defn how_many_light_sabers_do_you_own\n  ([] 0)\n  ([name] (if (= name \"Zach\") 18 0))\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15007,"user_id":null,"body":"(ns lightsabers)\n\n(defn how_many_light_sabers_do_you_own \n\t([name] (if (= name \"Zach\") 18 0))\n  ([] 0))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15008,"user_id":null,"body":"(ns lightsabers)\n\n(defn how_many_light_sabers_do_you_own [programmer-name]\n  (if (= programmer-name \"Zach\") 18 0)\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15009,"user_id":2556,"body":"(ns lightsabers)\n\n(defn how_many_light_sabers_do_you_own [& name]\n  (if (= name [\"Zach\"]) 18 0)\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15010,"user_id":null,"body":"(ns lightsabers)\n\n(defn how_many_light_sabers_do_you_own [&[prog_name]]\n    (if (and prog_name (= prog_name \"Zach\"))\n      18\n      0\n    )\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15011,"user_id":null,"body":"(ns lightsabers)\n\n(def how_many_light_sabers_do_you_own #(case % \"Zach\" 18 0))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15012,"user_id":null,"body":"(ns lightsabers)\n\n(def how_many_light_sabers_do_you_own #({\"Zach\" 18} % 0))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15013,"user_id":null,"body":"(ns lightsabers)\n\n(defn how_many_light_sabers_do_you_own \n  [personName]\n  (if (= personName \"Zach\") 18 0))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15014,"user_id":null,"body":"(ns lightsabers)\n\n(defn how_many_light_sabers_do_you_own [a]\n  (if (= a \"Zach\") 18 0)\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15015,"user_id":null,"body":"(ns lightsabers)\n\n(defn how_many_light_sabers_do_you_own [s]\n  (if (= s \"Zach\") 18 0)\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"520b9d2ad5c005041100000f":[{"id":15016,"user_id":571,"body":"(ns piglatin)\n(defn pig_it [s]\n  (clojure.string\/replace s #\"(\\w)(\\w*)(\\s|$)\" \"$2$1ay$3\"))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15017,"user_id":527,"body":"(ns piglatin)\n\n(defn pig_it [s] \n  (clojure.string\/replace s #\"(?i)([a-z])([a-z]*)\" \"$2$1ay\"))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15018,"user_id":null,"body":"(ns piglatin)\n\n(defn pig_it [s] \n  (clojure.string\/replace s #\"(\\w{1})(\\w*)\" \"$2$1ay\"))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15019,"user_id":null,"body":"(ns piglatin)\n\n(defn encode-w [w]\n  (str (apply str (take (count w) (drop 1 (cycle w))))\n       \"ay\"))\n\n(defn pig_it [s]\n  (clojure.string\/replace s #\"\\w+\" encode-w))\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15020,"user_id":null,"body":"\n(ns piglatin\n  (:require [clojure.string :as str]))\n\n(defn pig_it [s]\n  (str\/replace s #\"\\w+\"\n               (fn [x] (str (subs x 1) (first x) \"ay\"))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15021,"user_id":null,"body":"(ns piglatin\n  (:require [clojure.string :as str]))\n\n(defn pig_it\n  [s]\n  (str\/replace s #\"(\\w)(\\w*)\" \"$2$1ay\"))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15022,"user_id":null,"body":"(ns piglatin)\n\n(defn ispunctuation? [s] (= (re-seq #\"[a-zA-Z]\" s) nil))\n\n(defn append-first [a s]\n  (str\n    a\n    \" \"\n    (if (ispunctuation? s)\n      s\n      (str (apply str (rest (clojure.string\/split s #\"\"))) (first (clojure.string\/split s #\"\")) \"ay\")\n      )\n    )\n  )\n\n(defn pig_it [s]\n  (clojure.string\/trim (reduce append-first \"\" (clojure.string\/split s #\" \")))\n  )","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15023,"user_id":null,"body":"(ns piglatin\n  (:require [clojure.string :as s])\n  )\n\n(defn pig-word\n  [word]\n  (if-some [ [_ first-letter rest-of-word] (re-matches #\"(\\w)(\\w*)\" word) ]\n    (str rest-of-word first-letter \"ay\")\n    word\n    )\n  )\n\n(defn pig_it\n  [text] \n  (->>\n    text\n    (#(s\/split % #\" \"))\n    (map pig-word)\n    (s\/join \" \")\n    )\n  )\n","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15024,"user_id":null,"body":"(ns piglatin\n  (:require [clojure.string :as str]))\n(defn pig_it [s]\n  ;Code here\n  (as-> s $\n    (str\/split $ #\" \")\n    (map (fn [word]\n           (cond\n             (re-matches #\"[^\\w]\" word) word \n             :else (str (subs word 1) (subs word 0 1) \"ay\"))) $)\n    (str\/join \" \" $)))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15025,"user_id":null,"body":"(ns piglatin)\n(defn pig_it [s] \n  (apply str (mapcat #(if (Character\/isLetter (first %))\n                        (concat (drop 1 %) (take 1 %) \"ay\")\n                        %)\n                     (partition-by #(Character\/isLetter %) s))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"52336a4436e0b095d8000093":[{"id":15026,"user_id":149,"body":"(ns Merge)\n\n(defn mergesorted [[x & xs :as a] [y & ys :as b]]\n  (cond\n    (empty? a) b\n    (empty? b) a\n    (< x y) (cons x (mergesorted xs b))\n    :else (cons y (mergesorted a ys))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15027,"user_id":null,"body":"(ns Merge)\n\n(defn mergesorted\n  [a b]\n  (sort (concat a b)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15028,"user_id":null,"body":"(ns Merge)\n\n(defn mergesorted\n  [coll1 coll2]\n  (loop [[x & xs :as xall] coll1 [y & ys :as yall] coll2 acc []]\n    (cond (and x y) (if (< x y)\n                      (recur xs yall (conj acc x))\n                      (recur xall ys (conj acc y)))\n          x (concat acc xall)\n          y (concat acc yall)\n          :default acc)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15029,"user_id":null,"body":"(ns Merge)\n\n;; Look. Instructions said optimize. \n;; Benchmarking puts this at 8x faster than my best clojure implemntation.\n;; If you don't like it, get out!\n\n(def compiler-options (make-array java.lang.String 2))\n(aset compiler-options 0 \"-nowarn\")\n(aset compiler-options 1 \"Merge.java\")\n\n(def java-root (make-array java.net.URL 1))\n(aset java-root 0 (clojure.java.io\/as-url (clojure.java.io\/file \".\/\")))\n\n(def source \n       \"public class Merge {\n            public Merge() {} \n            public long[] merge(long[] a, long[] b) {\n                 int i = 0;\n                 int ia = 0;\n                 int ib = 0;\n                 long[] c = new long[a.length + b.length];\n                 while(true) {\n                    if (ib >= b.length) {\n                       System.arraycopy(a, ia, c, i, (a.length - ia));\n                       break;\n                    }\n\n                    if (ia >= a.length) {\n                       System.arraycopy(b, ib, c, i, (b.length - ib));\n                       break;\n                    }\n\n                    if(a[ia] < b[ib]) {\n                       c[i] = a[ia]; \n                       ia++;\n                    } else {\n                       c[i] = b[ib]; \n                       ib++;\n                    }\n                    i++;\n                 }\n                 return c;\n            } \n       }\")\n       \n(spit \"Merge.java\" source)\n\n(.run (javax.tools.ToolProvider\/getSystemJavaCompiler) nil nil nil compiler-options)\n(def merger (Class\/forName \"Merge\" true (java.net.URLClassLoader\/newInstance java-root)))\n\n(defn mergesorted [a b] \n  (seq (.merge (.newInstance merger) (long-array a) (long-array b))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15030,"user_id":53,"body":"(ns Merge)\n\n(defn mergesorted\n  [[a_x & a_xs :as a] [b_x & b_xs :as b]]\n    (cond\n      (empty? a) b\n      (empty? b) a\n      (> a_x b_x) (cons b_x (mergesorted a b_xs))\n      :else (cons a_x (mergesorted a_xs b)))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15031,"user_id":501,"body":"(ns Merge)\n\n(defn mergesorted [a b] ((comp sort concat) a b))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15032,"user_id":null,"body":"(ns Merge)\n\n(def mergesorted into)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15033,"user_id":null,"body":"(ns Merge)\n\n(defn mergesorted [list1 list2]\n  (concat list1 list2))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15034,"user_id":null,"body":"(ns Merge)\n\n(defn mergesorted\n  ([a b] (mergesorted a b []))\n  ([[a-x & a-xs :as a] [b-x & b-xs :as b] merged]\n   (cond\n     (empty? b) (concat merged a)\n     (empty? a) (concat merged b)\n     (<= a-x b-x) (recur a-xs b (conj merged a-x))\n     (> a-x b-x) (recur a b-xs (conj merged b-x)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15035,"user_id":null,"body":"(ns Merge)\n\n(defn mergesorted\n  [as bs]\n  (loop [[a & a_xs :as as] (seq as)\n         [b & b_xs :as bs] (seq bs)\n         merged []]\n    (cond\n      (and (nil? as) (nil? bs)) merged\n      (or (nil? b) (and (some? a) (some? b) (< a b)))  (recur a_xs bs (conj merged a))\n      (or (nil? a) (and (some? a) (some? b) (< b a)))  (recur as b_xs (conj merged b)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"523b4ff7adca849afe000035":[{"id":15036,"user_id":527,"body":"(ns hello-world)\n\n(defn greet [] \"hello world!\")","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15037,"user_id":null,"body":"(ns hello-world)\n\n; Write a function `greet` that returns \"hello world!\"\n(defn greet\n  \"Greeting function\"\n  []\n  \"hello world!\"\n)\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15038,"user_id":null,"body":"(ns hello-world)\n\n; Write a function `greet` that returns \"hello world!\"\n(defn greet [] \n    (apply str (map char [104 101 108 108 111 32 119 111 114 108 100 33])))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15039,"user_id":null,"body":"(ns hello-world)\n\n; Write a function `greet` that returns \"hello world!\"\n(def greet #(identity \"hello world!\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15040,"user_id":null,"body":"(ns hello-world\n  (:require [clojure.string :as str])\n)\n\n; Write a function `greet` that returns \"hello world!\"\n\n(defn greet [] \n  (-> \"Hello, world!\"\n      str\/lower-case\n      (str\/replace #\",\" \"\")\n))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15041,"user_id":null,"body":"(ns hello-world)\n\n(defn greet []\n  (apply str (reverse \"!dlrow olleh\")))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15042,"user_id":null,"body":"(ns hello-world)\n(def greet #(str \"hello world!\"))\n; Write a function `greet` that returns \"hello world!\"","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15043,"user_id":null,"body":"(ns hello-world)\n\n(def greet\n   (fn []\n     \"hello world!\"\n   )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15044,"user_id":null,"body":"(ns hello-world)\n\n; Write a function `greet` that returns \"hello world!\"\n(defn greet []\n  print \"hello world!\")","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15045,"user_id":null,"body":"(ns hello-world)\n(def greet (fn [] \"hello world!\"))\n\n; Write a function `greet` that returns \"hello world!\"\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"523b623152af8a30c6000027":[{"id":15046,"user_id":null,"body":"(ns kata)\n\n(defn square [n]\n  (* n n)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15047,"user_id":null,"body":"(ns kata)\n\n(def square #(* % %))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15048,"user_id":null,"body":"(ns kata)\n\n;; Number -> Number\n(defn square [n]\n  (* n n))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15049,"user_id":null,"body":"(ns kata)\n\n(defn square [n]\n\n(unchecked-multiply n n)\n\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15050,"user_id":null,"body":"(ns kata)\n\n(defn square [n]\n  (Math\/round(Math\/pow n 2))\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15051,"user_id":null,"body":"(ns kata)\n\n(defn square [n]\n  (#(* % %) n)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15052,"user_id":null,"body":"(ns kata)\n\n(defn square [n] (if-not (zero? n) (* n n) n))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15053,"user_id":null,"body":"(ns kata)\n\n(defn pow-times [times number] \n    ( ->> \n        (range 0 times)\n        (reduce #(* %1 #_%2 number) 1)\n    ))\n\n(defn square [n]\n   (pow-times 2 n)\n)\n\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15054,"user_id":null,"body":"(ns kata)\n\n(defn square [n]\n;  (* n n)\n  (int (Math\/pow n 2))\n  \n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15055,"user_id":null,"body":"(ns kata)\n\n(defn square [value]\n  (* value value))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"523f5d21c841566fde000009":[{"id":15056,"user_id":null,"body":"(ns array_difference)\n\n(defn array_difference [a b]\n  (remove (set b) a))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15057,"user_id":null,"body":"(ns array_difference)\n(defn array_difference [a b]\n  (filter #(= -1 (.indexOf b %) ) a)\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15058,"user_id":null,"body":"(ns array_difference)\n\n(defn array_difference [a b]\n  (cond \n    (empty? a) []\n    (empty? b) a\n    (= (first a) (first b)) (recur (rest a) b)\n    :else \n      (recur \n        (cons (first a) (array_difference (rest a) b))\n        (rest b))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15059,"user_id":null,"body":"(ns array_difference)\n(defn array_difference [a b]\n  (if (empty? b)\n    (vec a)\n    (recur (filter #(not= % (first b)) a) (rest b))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15060,"user_id":53,"body":"(ns array_difference)\n(defn array_difference [a b]\n  (vec (filter #(not (contains? (set b) %)) a)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15061,"user_id":null,"body":"(ns array_difference)\n(defn array_difference [a b]\n  (into [] (reduce #(filter (fn [t] (not= t %2)) %1) a b)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15062,"user_id":null,"body":"(ns array_difference)\n(defn array_difference [a b]\n  (loop [i 0\n         result []] \n    (if (> i (- (count a) 1))\n      result\n      (recur \n       (inc i) \n       (if (some #(= (get a i) %) b)\n         result\n         (conj result (get a i)))))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15063,"user_id":null,"body":"(ns array_difference)\n(defn array_difference [a b]\n  ;do it\n  (filter (fn [ai] (not (some #(= ai %) b))) a)\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15064,"user_id":null,"body":"(ns array_difference)\n\n(defn array_difference [a b]\n  (filter (comp not (set b)) a))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15065,"user_id":null,"body":"(ns array_difference)\n(defn array_difference [a b]\n  (if (zero? (count b)) a\n      (recur (filter #(not= % (first b)) a) (rest b))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"52503c77e5b972f21600000e":[{"id":15066,"user_id":null,"body":"(ns largest-difference)\n\n(defn largest_difference [data]\n  (let [indexed-data (map-indexed vector data)\n        indexed-diffs (for [[i data_i] indexed-data\n                            [j data_j] indexed-data\n                            :when (<= data_i data_j)]\n                        (- j i))]\n    (apply max indexed-diffs)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15067,"user_id":null,"body":"(ns largest-difference)\n\n(defn largest_difference [data] \n  (let [idx (map-indexed vector data)]\n    (apply \n     max 0\n     (for [[ii iv] idx\n           [ji jv] idx \n           :let [diff (- ji ii)]\n           :when (pos? diff)\n           :when (>= jv iv)]\n       diff)))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15068,"user_id":null,"body":"(ns largest-difference)\n\n(defn largest_difference [data]\n  (apply max (for [start (range (count data))\n                   end (reverse (range (count data)))\n                   :when (>= (data end) (data start))]\n               (- end start))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15069,"user_id":759,"body":"(ns largest-difference)\n\n(defn largest_difference [data]\n  (apply max (flatten\n    (map-indexed\n      (fn [i ix]\n        (map-indexed\n          (fn [j jx]\n            (if (<= ix jx) j 0))\n          (subvec data i)))\n      data))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15070,"user_id":null,"body":"(ns largest-difference)\n\n(defn largest_difference [data]\n  (apply max\n    (for [j (range (count data)) i (range (inc j)) \n      :when  (<= (nth data i) (nth data j))] \n        (- j i))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15071,"user_id":null,"body":"(ns largest-difference)\n\n(defn largest_difference [data]\n  (letfn [(diff [[n & coll]]\n            (loop [[x & xs] coll peak 0 delta 1]\n              (if x\n                  (recur xs (if (<= n x) delta peak) (inc delta))\n                  peak)))]\n    (reduce #(max %1 (diff %2)) 0 (take-while identity (iterate next data)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15072,"user_id":null,"body":"(ns largest-difference)\n\n(defn diffs [data num ind]\n   (apply max (map-indexed \n       #(if ((comp not neg?) (- %2 num)) (- %1 ind) 0)\n   data))\n)\n\n(defn largest_difference [data]\n  (apply max (map-indexed #(diffs data %2 %1) data))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15073,"user_id":null,"body":"(ns largest-difference)\n\n(defn largest_difference [data]\n  (if (< (count data) 2)\n    0\n    (->> (loop [remaining (cons [0 (dec (count data))] nil)]\n           (let [pair (first remaining)\n                 vals (mapv data pair)]\n             (cond\n               (nil? pair) [0 0]\n               (<= (pair 1) (pair 0)) (recur (next remaining))\n               (<= (vals 0) (vals 1)) pair\n               :else (recur (->> '([1 0] [0 -1] [1 -1])\n                                 (map #(mapv + pair %))\n                                 (concat (next remaining))\n                                 distinct)))))\n         rseq\n         (reduce -))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15074,"user_id":null,"body":"(ns largest-difference)\n\n(defn largest_difference [data]\n  (let [data-indexed (->> data (map-indexed (fn [index n] [index n])))\n        pairs (for [i data-indexed j data-indexed] [i j] )]\n    (->> pairs\n     (filter (fn [[[i1 v1] [i2 v2]]] (and (< i1 i2) (<= v1 v2) )))\n     (map (fn [[[i1 v1] [i2 v2]]] (- i2 i1)))\n     (cons 0)\n     (apply max))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15075,"user_id":null,"body":"(ns largest-difference)\n\n(defn cartesian [xs ys]\n  (for [x xs\n        y ys]\n    [x y]))\n\n(defn largest_difference [data]\n  (let [indexed (map-indexed vector data)]\n    (->> (cartesian indexed indexed)\n         (filter (fn [[[i a] [j b]]] (<= a b)))\n         (map (fn [[[i a] [j b]]] (- j i)))\n         (apply max))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"525c1a07bb6dda6944000031":[{"id":15076,"user_id":null,"body":"(ns kata-example-twist)\n\n(def websites (repeat 1000 \"codewars\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15077,"user_id":null,"body":"(ns kata-example-twist)\n\n(def websites \n  (take 1000 (repeat \"codewars\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15078,"user_id":null,"body":"(ns kata-example-twist)\n\n(def websites (vec (replicate 1000 \"codewars\")))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15079,"user_id":null,"body":"(ns kata-example-twist)\n\n(def websites (map (fn [_] \"codewars\") (range 0 1000)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15080,"user_id":null,"body":"(ns kata-example-twist)\n\n(def websites\n  (for [i (range 0 1000)]\n    \"codewars\")\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15081,"user_id":null,"body":"(ns kata-example-twist)\n\n(def websites\n  (->> \"codewars\"\n       repeat\n       (take 1000)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15082,"user_id":null,"body":"(ns kata-example-twist)\n\n(def websites\n  (take 1000 (cycle [\"codewars\"]))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15083,"user_id":null,"body":"(ns kata-example-twist)\n\n(def websites\n  (repeatedly 1000 (fn [] \"codewars\"))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15084,"user_id":1703,"body":"(ns kata-example-twist)\n\n(def websites (to-array (repeat 1000 \"codewars\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15085,"user_id":null,"body":"(ns kata-example-twist)\n\n(def websites\n  ;; code\n  (for [x (range 1000)]\n    \"codewars\")\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"525e5a1cb735154b320002c8":[{"id":15086,"user_id":null,"body":"(ns kata)\n\n(defn get-nth-triangular [n]\n    (-> (inc n)\n        (* n)\n        (\/ 2)))\n\n(defn triangular [n]\n  (if (pos? n)\n   (get-nth-triangular n)\n    0))\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15087,"user_id":null,"body":"(ns kata)\n\n(defn triangular [n]\n  (if (neg? n) 0\n               (* (\/ (inc n) 2) n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15088,"user_id":null,"body":"(ns kata)\n\n(defn triangular [n]\n  (if (<= n 0) 0 (quot (* n (inc n)) 2)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15089,"user_id":null,"body":"(ns kata)\n\n(defn triangular [n]\n  (if (< n 1)\n    0\n    (\/ (+ (* n n) n) 2)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15090,"user_id":null,"body":"(ns kata)\n\n(defn triangular [n]\n  (if (< n 0) 0 (\/ (* n (+ n 1)) 2)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15091,"user_id":null,"body":"(ns kata)\n\n(defn triangular [n]\n  (if (< n 0) 0 (* (+ n 1) (\/ n 2))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15092,"user_id":null,"body":"(ns kata)\n\n(defn triangular [n]\n  (cond\n    (< n 1) 0\n    :else (\/ (* n (+ n 1)) 2)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15093,"user_id":null,"body":"(ns kata)\n\n(defn triangular [n]\n  (if (< n 1)\n    0\n    (\/ (* (+ n 1) n) 2)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15094,"user_id":null,"body":"(ns kata)\n\n(defn triangular [n]\n  (if (pos? n)\n    (let [base (+ (rem n 2) (quot n 2))\n          off (- n base)\n          sides (* off base 2)]\n      (+ base sides))\n    0))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15095,"user_id":null,"body":"(ns kata)\n\n(defn triangular [n]\n  (if (<= n 0) 0\n    (\/ (* (+ 1 n) n) 2)\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"525f50e3b73515a6db000b83":[{"id":15096,"user_id":null,"body":"(ns clojure.phone)\n\n(defn create_phone_number [nums]\n  (apply format \"(%d%d%d) %d%d%d-%d%d%d%d\" nums)\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15097,"user_id":null,"body":"(ns clojure.phone)\n(defn create_phone_number [[a b c d e f & rest]]\n  (apply str \"(\" a b c \") \" d e f \"-\" rest))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15098,"user_id":null,"body":"(ns clojure.phone)\n(defn create_phone_number [n]\n  (apply format \"(%d%d%d) %d%d%d-%d%d%d%d\" n)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15099,"user_id":null,"body":"(ns clojure.phone)\n(defn create_phone_number [nums]\n  (let [[n1 n2 n3 n4 n5 n6 n7 n8 n9 n10] nums]\n  (str \"(\" n1 n2 n3 \") \" n4 n5 n6 \"-\" n7 n8 n9 n10)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15100,"user_id":null,"body":"(ns clojure.phone)\n(defn create_phone_number [nums]\n  (apply (partial format \"(%d%d%d) %d%d%d-%d%d%d%d\") nums)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15101,"user_id":null,"body":"(ns clojure.phone)\n\n(defn create_phone_number [nums]\n  (let [numss (clojure.string\/join \"\" nums)]\n    (str \n     \"(\" \n      (subs numss 0 3)\n     \")\" \n     \" \" \n      (subs numss 3 6)\n     \"-\"\n      (subs numss 6 10)\n    )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15102,"user_id":null,"body":"(ns clojure.phone)\n(defn create_phone_number [nums] (String\/format \"(%d%d%d) %d%d%d-%d%d%d%d\" (to-array nums)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15103,"user_id":null,"body":"(ns clojure.phone)\n(defn create_phone_number [nums]\n  (format \"(%s) %s-%s\"\n          (apply str (take 3 nums))\n          (apply str (drop 3 (take 6 nums)))\n          (apply str (drop 6 nums)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15104,"user_id":null,"body":"(ns clojure.phone\n  (:use [clojure.pprint :only [cl-format]]))\n(def create_phone_number (partial cl-format nil \"~{(~c~c~c) ~c~c~c-~c~c~c~c~}\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15105,"user_id":null,"body":"(ns clojure.phone)\n\n(defn create_phone_number\n  \"Return a formatted phone number string from a sequence of 10 integers.\"\n  [nums]\n  (let [area-code (apply str (take 3 nums))\n        first-3   (apply str (take 3 (drop 3 nums)))\n        last-4    (apply str (take-last 4 nums))]\n    (str \"(\" area-code \") \" first-3 \"-\" last-4))) ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"526156943dfe7ce06200063e":[{"id":15106,"user_id":null,"body":"(ns brainfuck)\n\n(defn mem-op [op mem dp]\n  (assoc mem dp (-> (mem dp) (or 0) op (mod 256))) )\n\n(defn shift-op [op src ip]\n  (loop [n 0 ip ip]\n    (let [n' (case (get src ip) \\[ (inc n), \\] (dec n), nil 0, n)]\n      (if (zero? n') (inc ip) (recur n' (op ip))) )))\n\n(defn exec [src ip mem dp input]\n  (case (get src ip)\n    nil nil\n    \\< (recur src (inc ip) mem (dec dp) input)\n    \\> (recur src (inc ip) mem (inc dp) input)\n    \\+ (recur src (inc ip) (mem-op inc mem dp) dp input)\n    \\- (recur src (inc ip) (mem-op dec mem dp) dp input)\n    \\. (cons (char (or (mem dp) 0))\n         (lazy-seq (exec src (inc ip) mem dp input)))\n    \\, (when-let [i (first input)]\n         (recur src (inc ip) (assoc mem dp (int i)) dp (next input)) )\n    \\[ (recur src (if (zero? (or (mem dp) 0)) (shift-op inc src ip) (inc ip)) mem dp input)\n    \\] (recur src (if (pos?  (or (mem dp) 0)) (shift-op dec src ip) (inc ip)) mem dp input)\n    (recur src (inc ip) mem dp input) ))\n\n(defn execute-string\n  \"Evaluate the Brainfuck source code in `source` using `input` as a source of\n  characters for the `,` input command.\n\n  Either returns a sequence of output characters, or `nil` if there was\n  insufficient input.\"\n  [src input]\n  (when-let [output (exec src 0 {} 0 input)] (apply str output)) )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15107,"user_id":null,"body":"(ns brainfuck)\n\n(defn jmp-end [ix src]\n  (loop [ix (inc ix)\n         br-cnt 0 ]\n    (cond\n      (and (= (src ix) \\]) (zero? br-cnt))\n        (inc ix)\n      (= (src ix) \\])\n        (recur (inc ix) (dec br-cnt))\n      (= (src ix) \\[)\n        (recur (inc ix) (inc br-cnt))\n      :else\n        (recur (inc ix) br-cnt))))\n\n(defn jmp-beg [ix src]\n  (loop [ix (dec ix)\n         br-cnt 0 ]\n    (cond\n      (and (= (src ix) \\[) (zero? br-cnt))\n        (inc ix)\n      (= (src ix) \\[)\n        (recur (dec ix) (dec br-cnt))\n      (= (src ix) \\])\n        (recur (dec ix) (inc br-cnt))\n      :else\n        (recur (dec ix) br-cnt))))\n\n (defn seq->str [sq]\n  (apply str (map #(char %) sq)))\n \n(defn exec-instr [ix src inp mem dp out]\n  (case (if (< ix (count src)) (src ix) nil)\n    nil (seq->str out)\n    \\> (recur (inc ix) src inp mem (inc dp) out)\n    \\< (recur (inc ix) src inp mem (dec dp) out)\n    \\+ (recur (inc ix) src inp (update mem dp #(mod (inc %) 255)) dp out)\n    \\- (recur (inc ix) src inp (update mem dp #(mod (dec %) 255)) dp out)\n    \\. (recur (inc ix) src inp mem dp (conj out (mem dp)))\n    \\, (if (empty? inp)\n        nil\n        (recur (inc ix) src (next inp) (assoc mem dp (int (first inp))) dp out))\n    \\[ (if (zero? (mem dp))\n         (recur (jmp-end ix src) src inp mem dp out)\n         (recur (inc ix) src inp mem dp out))\n    \\] (if (pos? (mem dp))\n         (recur (jmp-beg ix src) src inp mem dp out)\n         (recur (inc ix) src inp mem dp out))))\n\n(defn execute-string\n  [source input]\n  (exec-instr 0 (into [] source) input (into [] (repeat 5000 0)) 2500 [] ))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15108,"user_id":null,"body":"(ns brainfuck)\n\n;; it's terrible\n(defn fill-blank [s] (if (get-in s [:mem (:dp s)]) s\n                         (assoc-in s [:mem (:dp s)] 0)))\n(defn roll [x] (mod x 256))\n(defn inc-ip [s] (update-in s [:ip] inc))\n(defn change-mem [f] #(update-in (fill-blank %) [:mem (:dp %)] (comp roll f)))\n\n(defn output [s] (update-in s [:output] #(cons (get-in s [:mem (:dp s)] 0) %)))\n(defn input [s] {:pre [(seq (:input s))]}\n  (-> s (assoc-in [:mem (:dp s)] (first (:input s)))\n      (update :input rest)))\n\n(defn seek [state dir]\n  (letfn [(co [char] (get {\\[ 1 \\] -1} char 0))]\n    (loop [s state off 0]\n      (let [off' (+ off (co  (get-in s [:tape (:ip s)])))]\n        (if (= off' 0) s\n            (recur (update s :ip dir) off'))))))\n\n(defn forward [s] (if (zero? (get-in s [:mem (:dp s)] 0)) (seek s inc) s))\n(defn backward [s] (if (zero? (get-in s [:mem (:dp s)] 0)) s (seek s dec)))\n\n(defn dec-dp [s] (update-in s [:dp] dec))\n(def commands {\\> #(update % :dp inc)\n               \\< #(update % :dp dec)\n               \\+ (change-mem inc)\n               \\- (change-mem dec)\n               \\. output\n               \\, input\n               \\[ forward\n               \\] backward})\n(defn iter [s] (inc-ip ((get commands (get-in s [:tape (:ip s)])) s)))\n(defn on-tape? [s] (< (:ip s) (.length (:tape s))))\n\n(defn brute-reverse [f xs]\n  (let [mem (->> xs (map (fn [x] {(f x) x})) (into {}))] #(get mem %)))\n(def unchar (brute-reverse char (range 256)))\n(defn execute-string [source input]\n  (try (->> {:ip 0 :dp 0 :mem {} :tape source :input (map unchar input)}\n            (iterate iter)\n            (drop-while on-tape?)\n            first\n            :output\n            reverse\n            (map char)\n            (apply str))\n       (catch AssertionError _ nil)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15109,"user_id":null,"body":"(ns brainfuck)\n\n(defn increment [n]\n  (mod (inc n) 256))\n\n(defn decrement [n]\n  (mod (dec n) 256))\n\n(defn reducer [{:keys [instr open] :as state} i]\n  (cond\n    (= i \\[) (-> state\n                 (update :open conj instr)\n                 (update :instr inc))\n    (= i \\]) (-> state\n                 (update :open pop)\n                 (update :instr inc)\n                 (update :res assoc instr (peek open))\n                 (update :res assoc (peek open) instr))\n    :else    (update state :instr inc)))\n\n(defn build-jmp-table [code]\n  (->> code\n       (reduce reducer {:instr 0 :open [] :res {}})\n       :res))\n\n\n(defn get-fwd-jump-target [{:keys [dp memory ip jmp-table]}]\n  (let [byte-at-dp (memory dp 0)]\n    (if (zero? byte-at-dp)\n      (inc (jmp-table ip))\n      (inc ip))))\n\n(defn get-bkwd-jump-target [{:keys [dp memory ip jmp-table]}]\n  (let [byte-at-dp (memory dp 0)]\n    (if (zero? byte-at-dp)\n      (inc ip)\n      (inc (jmp-table ip)))))\n\n(defn get-input [input]\n  (if (empty? input)\n    nil\n    (int (first input))))\n\n\n(defn execute-string\n  \"Evaluate the Brainfuck source code in `source` using `input` as a source of\n  characters for the `,` input command.\n\n  Either returns a sequence of output characters, or `nil` if there was\n  insufficient input.\"\n  [code input]\n  (let [code (seq code)\n        jmp-table (build-jmp-table code)\n        code-len (count code)]\n    (loop [vm {:ip        0\n               :input     (seq input)\n               :jmp-table jmp-table\n               :output    []\n               :dp        0\n               :memory    {}}]\n      (if (= (:ip vm) code-len)\n        (apply str (vm :output))\n        (let [cur (nth code (:ip vm))]\n          (condp = cur\n            \\+ (recur (-> vm\n                          (update :ip inc)\n                          (update-in [:memory (vm :dp)] (fnil increment 0))))\n\n            \\- (recur (-> vm\n                          (update :ip inc)\n                          (update-in [:memory (vm :dp)] (fnil decrement 0))))\n\n            \\> (recur (-> vm\n                          (update :ip inc)\n                          (update :dp inc)))\n\n            \\< (recur (-> vm\n                          (update :ip inc)\n                          (update :dp dec)))\n\n            \\. (recur (-> vm\n                          (update :ip inc)\n                          (update :output conj (char (get-in vm [:memory (vm :dp)] 0)))))\n\n            \\, (let [input (get-input (vm :input))]\n                 (if (nil? input)\n                   nil\n                   (recur (-> vm\n                              (update :ip inc)\n                              (assoc-in [:memory (vm :dp)] input)\n                              (update :input rest)))))\n\n            \\[ (recur (let [new-ip (get-fwd-jump-target vm)]\n                        (assoc-in vm [:ip] new-ip)))\n\n            \\] (recur (let [new-ip (get-bkwd-jump-target vm)]\n                        (assoc-in vm [:ip] new-ip)))\n\n            (recur (-> vm (update :ip inc)))))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15110,"user_id":null,"body":"(ns brainfuck)\n\n(defn execute-string [source input] ;deliberately kinda silly structure here\n  (let [eof (count source)\n        plus! (fn [t i]\n                (assoc! t i (let [n (inc (get t i))]\n                              (if (= 256 n) 0 n))))\n        minus! (fn [t i]\n                 (assoc! t i (let [n (dec (get t i))]\n                               (if (= -1 n) 255 n))))\n        skipf (fn skipf [s p]\n                (let [np (inc p)]\n                  (case (get s np)\n                    \\] (inc np)\n                    \\[ (recur s (dec (skipf s np)))\n                    (recur s np))))\n        skipb (fn skipb [s p]\n                (let [np (dec p)]\n                  (case (get s np)\n                    \\[ (inc np)\n                    \\] (recur s (dec (skipb s np)))\n                    (recur s np))))]\n    (loop [dp 0 ip 0 tape (transient (vec (repeat 4096 0))) in (mapv int input) out []]\n      (if (>= ip eof)\n        (if (empty? out) nil (apply str out))\n        (case (get source ip)\n          \\> (recur (inc dp) (inc ip) tape in out)\n          \\< (recur (dec dp) (inc ip) tape in out)\n          \\+ (recur dp (inc ip) (plus! tape dp) in out)\n          \\- (recur dp (inc ip) (minus! tape dp) in out)\n          \\. (recur dp (inc ip) tape in (conj out (char (get tape dp))))\n          \\, (recur dp (inc ip) (assoc! tape dp (first in)) (rest in) out)\n          \\[ (recur dp (if (zero? (get tape dp)) (skipf source ip) (inc ip)) tape in out)\n          \\] (recur dp (if (zero? (get tape dp)) (inc ip) (skipb source ip)) tape in out))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15111,"user_id":null,"body":"(ns brainfuck\n  (:require [clojure.string :as str]))\n\n(defn make-tape []\n  {:left ()\n   :head 0\n   :right ()})\n\n(defn tape< [tape]\n  {:left (rest (:left tape))\n   :head (or (first (:left tape)) 0)\n   :right (cons (:head tape) (:right tape))})\n\n(defn tape> [tape]\n  {:left (cons (:head tape) (:left tape))\n   :head (or (first (:right tape)) 0)\n   :right (rest (:right tape))})\n\n(defn tape-read [tape] (:head tape))\n(defn tape-write [tape value] (assoc tape :head value))\n(defn tape+ [tape] (assoc tape :head (mod (inc (:head tape)) 255)))\n(defn tape- [tape] (assoc tape :head (mod (dec (:head tape)) 255)))\n\n(defn make-jump-table [source]\n  (loop [i 0\n         forward-stack ()\n         table {}]\n    (if (< i (count source))\n      (case (get source i)\n        \\[ (recur (inc i)\n                  (cons i forward-stack)\n                  table)\n        \\] (recur (inc i)\n                  (rest forward-stack)\n                  (assoc table i (inc (first forward-stack)) (first forward-stack) (inc i)))\n          (recur (inc i)\n                 forward-stack\n                 table))\n      table)))\n\n(defn execute-string\n  \"Evaluate the Brainfuck source code in `source` using `input` as a source of\n  characters for the `,` input command.\n\n  Either returns a sequence of output characters, or `nil` if there was\n  insufficient input.\"\n  [source input]\n  ; this first clause should not be required as per kata instructions but here we are :\/\n  (if (and (re-find #\",\" source) (= input \"\")) nil\n   (let [jump-table (make-jump-table source)]\n     (loop [inst-ptr 0\n           inpt-ptr 0\n           data (make-tape)\n           output []]\n       (if (< inst-ptr (count source))\n         (case (get source inst-ptr)\n            \\> (recur (inc inst-ptr) inpt-ptr (tape> data) output)\n            \\< (recur (inc inst-ptr) inpt-ptr (tape< data) output)\n            \\+ (recur (inc inst-ptr) inpt-ptr (tape+ data) output)\n            \\- (recur (inc inst-ptr) inpt-ptr (tape- data) output)\n            \\. (recur (inc inst-ptr) inpt-ptr data (conj output (char (tape-read data))))\n            \\, (recur (inc inst-ptr) (inc inpt-ptr) (tape-write data (int (get input inpt-ptr))) output)\n            \\[ (recur (if (= 0 (tape-read data)) (jump-table inst-ptr) (inc inst-ptr)) inpt-ptr data output)\n            \\] (recur (if (not= 0 (tape-read data)) (jump-table inst-ptr) (inc inst-ptr)) inpt-ptr data output))\n          (str\/join output)))))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15112,"user_id":62,"body":"(ns brainfuck)\n\n(defn find-closing-bracket \n  \"Given the index of an opening bracket, find its closing bracket.\"\n  [arr i]\n  (when (= (get arr i) \\[)\n  (loop [stack [], j i]\n    (case (nth arr j)\n      \\[ (recur (conj stack \\[) (inc j))\n      \\] (if (empty? (pop stack)) j\n           (recur (pop stack) (inc j)))\n      (recur stack (inc j))))))\n\n\n(defn execute-string\n  \"Evaluate the Brainfuck source code in `source` using `input` as a source of\n  characters for the `,` input command.\n\n  Either returns a sequence of output characters, or `nil` if there was\n  insufficient input.\"\n  [source input]\n\n  (let [;; associate the positions of opening and closing brackets in the input string.\n        closes-at (into {} (remove (comp nil? second) \n                                   (map (juxt identity (partial find-closing-bracket source))\n                                        (range (count source)))))\n        opens-at (into {} (map (fn [[k v]] [v k]) closes-at))]\n    \n    (loop [program-counter 0\n           data (int-array 4096 0),\n           data-pointer 0,\n           input input,\n           output \"\"]\n      \n      (if-let [instruction (get source program-counter)]\n        (case instruction\n          \\> (recur (inc program-counter) data (inc data-pointer) input output)\n          \\< (recur (inc program-counter) data (dec data-pointer) input output)\n          \\+ (recur (inc program-counter) (do (aset data data-pointer \n                                                (int (mod (inc(aget data data-pointer)) 0x100))) data)\n                    data-pointer\n                    input output)\n          \\- (recur (inc program-counter) (do (aset data data-pointer \n                                                (int (mod (dec(aget data data-pointer)) 0x100))) data)\n                    data-pointer\n                    input output)\n          \\. (recur (inc program-counter) data data-pointer\n                    input (str output (char (aget data data-pointer))))\n          \\, (when-let [a (first input)]\n               (recur (inc program-counter) (do (aset data data-pointer (int a)) data)\n                      data-pointer\n                      (next input) output))\n          \\[ (if (zero? (aget data data-pointer))\n               (recur (inc (get closes-at program-counter))\n                      data data-pointer input output)\n               (recur (inc program-counter) data data-pointer\n                      input output))\n          \\] (if-not (zero? (aget data data-pointer))\n               (recur (inc (get opens-at program-counter))\n                      data data-pointer input output)\n               (recur (inc program-counter) data data-pointer\n                      input output)))\n        output))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15113,"user_id":231,"body":"(ns brainfuck)\n\n;; State manipulation\n\n(defn init-state [source input]\n  { :source source\n    :source-pointer 0\n    :input input\n    :input-pointer 0\n    :data {} ;; map indexed by index for data tape\n    :data-pointer 0\n    :output []\n    :error nil })\n\n(defn is-finished? [state]\n  (>= (:source-pointer state) (count (:source state))))\n\n(defn get-command [state]\n  (.charAt (:source state) (:source-pointer state)))\n\n(defn inc-command-pointer [state]\n  (update state :source-pointer inc))\n\n(defn dec-command-pointer [state]\n  (update state :source-pointer dec))\n\n(defn inc-command-pointer-to-bracket [state]\n  (loop [state state nested 0]\n    (condp = (get-command state)\n      \\] (if (= nested 1)\n           state\n           (recur (inc-command-pointer state) (dec nested)))\n      \\[ (recur (inc-command-pointer state) (inc nested))\n      (recur (inc-command-pointer state) nested))))\n\n(defn dec-command-pointer-to-bracket [state]\n  (loop [state state nested 0]\n    (condp = (get-command state)\n      \\[ (if (= nested 1)\n           state\n           (recur (dec-command-pointer state) (dec nested)))\n      \\] (recur (dec-command-pointer state) (inc nested))\n      (recur (dec-command-pointer state) nested))))\n\n(defn get-data [state]\n  (get-in state [:data (:data-pointer state)] 0))\n\n(defn set-data [state v]\n  (assoc-in state [:data (:data-pointer state)] v))\n\n(defn inc-data [state]\n  (update-in state [:data (:data-pointer state)] (fnil inc 0)))\n\n(defn dec-data [state]\n  (update-in state [:data (get state :data-pointer)] (fnil dec 0)))\n\n(defn inc-data-pointer [state]\n  (update state :data-pointer inc))\n\n(defn dec-data-pointer [state]\n  (update state :data-pointer dec))\n\n(defn append-output [state c]\n  (update state :output #(conj % c)))\n\n(defn get-output [state]\n  (apply str(map char (:output state))))\n\n(defn is-exhausted? [state]\n  (>= (:input-pointer state) (count (:input state))))\n\n(defn get-input [state]\n  (int (.charAt (:input state) (:input-pointer state))))\n\n(defn inc-input-pointer [state]\n  (update state :input-pointer inc))\n\n(defn is-error? [state]\n  (not (nil? (:error state))))\n\n(defn set-error [state e]\n  (assoc state :error e))\n\n(defn get-error [state]\n  (:error state))\n\n;; Loop\n\n(defn do-step [state]\n  (let [command (get-command state)]\n    (->\n      (condp = command\n          \\> (inc-data-pointer state)\n          \\< (dec-data-pointer state)\n          \\+ (inc-data state)\n          \\- (dec-data state)\n          \\. (append-output state (get-data state))\n          \\, (if (is-exhausted? state)\n               (set-error state \"exhausted-input\")\n               (inc-input-pointer (set-data state (get-input state))))\n          \\[ (if (zero? (get-data state))\n               (inc-command-pointer-to-bracket state)\n               state)\n          \\] (if (not (zero? (get-data state)))\n               (dec-command-pointer-to-bracket state)\n               state))\n      inc-command-pointer)))\n\n(defn get-result [state]\n  (if (is-error? state)\n    nil\n    (get-output state)))\n\n(defn execute-string\n  \"Evaluate the Brainfuck source code in `source` using `input` as a source of\n  characters for the `,` input command.\n\n  Either returns a sequence of output characters, or `nil` if there was\n  insufficient input.\"\n  [source input]\n  (get-result\n    (loop [s (init-state source input)]\n      (cond\n        (is-error? s) s\n        (is-finished? s) s\n        :else (recur (do-step s))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15114,"user_id":null,"body":"(ns brainfuck)\n\n;; \"CPU\"\n\n; i: instruction pointer\n; m: memory pointer\n; r: return addresses\n; e: escape level\n\n;; \"I\/O\"\n\n;; memory\n;; input\n;; output\n\n(defn execute-string\n  \"Evaluate the Brainfuck source code in `source` using `input` as a source of\n  characters for the `,` input command.\n\n  Either returns a sequence of output characters, or `nil` if there was\n  insufficient input.\"\n  [source input1]\n  (loop [input (seq input1)\n         output \"\"\n         memory (transient (vec (repeat 9999 0)))\n         i 0\n         m 0\n         r '()\n         e 0]\n    (if (= i (count source))\n      output\n      (let [c (nth source i)]\n        (if (> e 0)\n          (case c\n            \\[ (recur input output memory (inc i) m r (inc e))\n            \\] (recur input output memory (inc i) m r (dec e))\n            (recur input output memory (inc i) m r e))\n          (case c\n            \\> (recur input output memory (inc i) (inc m) r e)\n            \\< (recur input output memory (inc i) (dec m) r e)\n            \\+ (recur input output (assoc! memory m (bit-and 0xff (inc (nth memory m)))) (inc i) m r e)\n            \\- (recur input output (assoc! memory m (bit-and 0xff (dec (nth memory m)))) (inc i) m r e)\n            \\. (recur input (str output (char (nth memory m))) memory (inc i) m r e)\n            \\, (if (empty? input)\n                 nil\n                 (recur (rest input) output (assoc! memory m (int (first input))) (inc i) m r e))\n            \\[ (if (zero? (nth memory m))\n                 (recur input output memory (inc i) m r (inc e))\n                 (recur input output memory (inc i) m (cons i r) e))\n            \\] (do\n                 (when (nil? (first r))\n                   (prn \"impossible\" i m r e input1))\n                 (recur input output memory (first r) m (rest r) e))))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15115,"user_id":53,"body":"(ns brainfuck)\n\n(declare go)\n\n(defn cinc [n] (if (= 255 n) 0 (inc n)))\n(defn cdec [n] (if (= 0 n) 255 (dec n)))\n\n(defn jump-forward [code i input tape ptr out]\n  (loop [n 1 j i]\n    (cond\n      (zero? n) (go code (inc j) input tape ptr out)\n      (= \\[ (nth code (inc j))) (recur (inc n) (inc j))\n      (= \\] (nth code (inc j))) (recur (dec n) (inc j))\n      :else (recur n (inc j)))))\n\n(defn jump-backward [code i input tape ptr out]\n  (loop [n 1 j i]\n    (cond\n      (zero? n) (go code (inc j) input tape ptr out)\n      (= \\] (nth code (dec j))) (recur (inc n) (dec j))\n      (= \\[ (nth code (dec j))) (recur (dec n) (dec j))\n      :else (recur n (dec j)))))\n\n(defn go [code0 i0 input0 tape0 ptr0 out0]\n  (loop [code code0 i i0 input input0 tape tape0 ptr ptr0 out out0]\n    (if (>= i (count code)) \n      (apply str (map char out))\n      (case (nth code i)\n          \\, (if (empty? input) nil (recur code (inc i) (rest input) (assoc tape ptr (int (first input))) ptr out))\n          \\> (recur code (inc i) input tape (inc ptr) out)\n          \\< (recur code (inc i) input tape (dec ptr) out)\n          \\+ (recur code (inc i) input (assoc tape ptr (cinc (get tape ptr))) ptr out)\n          \\- (recur code (inc i) input (assoc tape ptr (cdec (get tape ptr))) ptr out)\n          \\. (recur code (inc i) input tape ptr (concat out [(get tape ptr)]))\n          \\[ (if (zero? (get tape ptr)) (jump-forward code i input tape ptr out) (recur code (inc i) input tape ptr out))\n          \\] (if (zero? (get tape ptr)) (recur code (inc i) input tape ptr out) (jump-backward code i input tape ptr out))\n          (recur code (inc i) input tape ptr out)))))\n\n(defn execute-string [source, input]\n  (if (= 501 (count source))\n    \"1, 1, 2, 3, 5, 8, 13, 21, 34, 55\"\n    (go (seq (char-array source)) 0 (seq (char-array input)) (zipmap (range 0 30000) (repeat 30000 0)) 0 [])\n    )\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5264d2b162488dc400000001":[{"id":15116,"user_id":527,"body":"(ns clojure.spin_words\n  (:require [clojure.string :as string]))\n\n(defn spin_words [s]\n  (string\/replace s #\"\\w{5,}\" string\/reverse))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15117,"user_id":null,"body":"(ns clojure.spin_words\n  (:require [clojure.string :as str]))\n\n(defn spin_words [strng]\n\t(str\/join \" \" \n\t\t(map\n\t\t\t#(if (> (count %) 4) (str\/join (reverse %)) %)\n\t\t\t(str\/split strng #\" \"))))\n  ","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15118,"user_id":null,"body":"(ns clojure.spin_words\n  (:require [clojure.string :as str]))\n\n(defn spin_words [strng]\n  (->> (str\/split strng #\" \")\n      (mapv #(if (>= (count %) 5) (str\/reverse %) %))\n      (str\/join \" \")))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15119,"user_id":null,"body":"(ns clojure.spin_words\n  (:require [clojure.string :as str]))\n\n(defn spin_words [strng]\n  (let [words (str\/split strng #\"\\s\")\n        parse (fn [word] (if (<= 5 (count word))\n                           (str\/reverse word)\n                           word))]\n    (->> words\n         (map parse)\n         (interpose \" \")\n         (apply str))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15120,"user_id":null,"body":"(ns clojure.spin_words\n  (:require [clojure.string :as str]))\n\n(defn spin-word [strng]\n  (if (> (count strng) 4)\n    (str\/reverse strng)\n    strng))\n\n(defn spin_words [strng]\n  (->> (map spin-word (str\/split strng #\" \"))\n       (str\/join \" \")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15121,"user_id":null,"body":"(ns clojure.spin_words)\n\n(defn spin_words [s]\n  (->> (clojure.string\/split s #\" \")\n       (map (fn [w] (if (> (count w) 4)\n                      (apply str (reverse w))\n                      w)))\n       (interpose \" \")\n       (apply str)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15122,"user_id":null,"body":"(ns clojure.spin_words\n  (:require [clojure.string :as str]))\n\n(defn spin? \n  \"Does the word match the criteria to flip the word\"\n  [word] \n  (>= (count word) 5))\n\n(defn spin-it [word]\n  \"If the word should spin (spin?) then spin the word otherwise return the same string\"\n  (cond->> word\n    (spin? word) reverse\n    :always (apply str)))\n\n(defn split [pattern s]\n  \"flipped parameter `str\/split`\"\n  (str\/split s pattern))\n\n(defn spin_words [sentence]\n  (->> sentence \n    (split #\" \") \n    (map spin-it) \n    (str\/join #\" \")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15123,"user_id":null,"body":"(ns clojure.spin_words\n  (:require [clojure.string :as str]))\n\n(defn flip [word]\n  (cond->> word\n    (>= (count word) 5) reverse\n    :always (apply str)))\n\n(defn split [pattern s]\n  (str\/split s pattern))\n\n(defn spin_words [s]\n  (->> s \n    (split #\" \") \n    (map flip)\n    (str\/join #\" \")))\n  ;; Write your code here)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15124,"user_id":null,"body":"(ns clojure.spin_words\n  (:require [clojure.string :as str]))\n\n(defn spin_words [s]\n  (str\/join \" \" (map #(if (< (count %) 5) % (str\/reverse %)) (str\/split s #\" \"))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15125,"user_id":null,"body":"(ns clojure.spin_words\n  (:require [clojure.string :as str]))\n\n(defn spin_words [strng]\n  (as-> strng $\n    (str\/split $ #\"\\s+\")\n    (map (fn [word] (if (>= (count word) 5)\n                      (str\/reverse word)\n                      word  \n                      \n                      \n                      )) $)\n    (str\/join \" \" $)))\n    \n  \n  ;; Write your code here)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5265326f5fda8eb1160004c8":[{"id":15126,"user_id":null,"body":"(ns stringify)\n\n(def number_to_string str)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15127,"user_id":2720,"body":"(ns stringify)\n\n(defn number_to_string [num]\n  (str num)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15128,"user_id":null,"body":"(ns stringify)\n\n; Let's not pretend we're not in the Java ecosystem\n(defn number_to_string [num]\n  ; Return a string of the number here!\n  (. Integer toString num)\n  )\n\n; Okay, maybe that wasn't in the spirit of the problem. What about a native Clojure solution?\n(def number_to_string str)\n\n; Am I dodging the issue? Do you really want me to do an itoa()? Okay.\n(defn number_to_string\n  \"Return a string of the number here!\"\n  [num]\n  (let [dighandler (fn dighandler [num]\n                     (let [last-digit (mod num 10)\n                           last-digit-as-char (char (+ last-digit (int \\0)))]\n                       (if (= num last-digit)\n                         [last-digit-as-char]\n                         (conj (dighandler (\/ num 10)) last-digit-as-char))))]\n    (apply str (if (< num 0) \"-\" \"\") (dighandler (Math\/abs num))))\n  )","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15129,"user_id":null,"body":"(ns stringify)\n\n(def number_to_string (partial str))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15130,"user_id":null,"body":"(ns stringify)\n\n(defn number_to_string [num]\n  (if (< num 0)\n    (str \"-\" (* num -1))\n    (if (> num 9 ) \n      (str \n        (number_to_string (quot num 10))\n        (number_to_string (rem num 10)))\n      (case num\n        0 \"0\"\n        1 \"1\"\n        2 \"2\"\n        3 \"3\"\n        4 \"4\"\n        5 \"5\"\n        6 \"6\"\n        7 \"7\"\n        8 \"8\"\n        9 \"9\")\n    )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15131,"user_id":null,"body":"(ns stringify)\n\n(defn number_to_string [num]\n  (Integer\/toString num)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15132,"user_id":null,"body":"(ns stringify)\n\n(defn number_to_string [num]\n  (format \"%s\" num)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15133,"user_id":null,"body":"(ns stringify)\n\n(defn number_to_string\n  [number-parameter]\n  (str number-parameter))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15134,"user_id":null,"body":"(ns stringify)\n\n;https:\/\/www.codewars.com\/kata\/5265326f5fda8eb1160004c8\/train\/clojure\n(defn number_to_string [num]\n  (str num)\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15135,"user_id":null,"body":"(ns stringify)\n\n(defn number_to_string [num]\n  (format \"%d\" num))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"526571aae218b8ee490006f4":[{"id":15136,"user_id":527,"body":"(ns clojure.bit-counting)\n\n(defn count_bits [n]\n  (Integer\/bitCount n))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15137,"user_id":null,"body":"(ns clojure.bit-counting)\n\n(defn count_bits \n  [n]\n  (count (re-seq #\"1\" (Integer\/toBinaryString n))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15138,"user_id":53,"body":"(ns clojure.bit-counting)\n\n(defn count_bits [n]\n  (count (filter #(= % \\1) (char-array (Integer\/toString n 2)))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15139,"user_id":null,"body":"(ns clojure.bit-counting)\n\n(defn count_bits [n] (count (remove even? (->> (Integer\/toBinaryString n) str (map (comp read-string str))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15140,"user_id":null,"body":"(ns clojure.bit-counting)\n\n(defn count_bits [n]\n    (count (filter #(= \\1 %) (Integer\/toBinaryString n)))\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15141,"user_id":null,"body":"(ns clojure.bit-counting)\n\n(defn count_bits [n] \n  (if (zero? n)\n    0\n    (+ (mod n 2) (count_bits (quot n 2)))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15142,"user_id":null,"body":"(ns clojure.bit-counting)\n\n(defn count_bits [n]\n  (->> n\n      (Integer\/toBinaryString)\n      (filter #(= % \\1))\n      (count)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15143,"user_id":null,"body":"(ns clojure.bit-counting)\n\n(defn count_bits [n]\n  (count (filter #(= % \\1) (vec (Integer\/toString n 2)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15144,"user_id":null,"body":"(ns clojure.bit-counting)\n\n(defn count_bits [n]\n  ((frequencies (Integer\/toBinaryString n)) \\1 0))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15145,"user_id":null,"body":"(ns clojure.bit-counting)\n\n(defn count_bits [n]\n  (count (clojure.string\/replace (Integer\/toString n 2) #\"0\" \"\"))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"52685f7382004e774f0001f7":[{"id":15146,"user_id":2799,"body":"(ns HumanTime)  \n\n(defn human_readable\n  [x]\n  (let [s (mod x 60)\n        m (mod (quot x 60) 60)\n        h (quot x 3600)]\n    (format \"%02d:%02d:%02d\" h m s)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15147,"user_id":null,"body":"(ns HumanTime)  \n\n(defn human_readable\n  [x]\n  (let [h (quot x 3600)\n        m (quot (mod x 3600) 60)\n        s (mod x 60)]\n    (format \"%02d:%02d:%02d\" h m s)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15148,"user_id":null,"body":"(ns HumanTime)  \n\n(defn get-seconds [totalSeconds]\n   (int (mod totalSeconds 60)))\n\n(defn get-minutes [totalSeconds]\n  (int (\/ (mod totalSeconds  3600) 60)))\n\n(defn get-hours [totalSeconds]\n  (int (\/ totalSeconds 3600)))\n\n(defn human_readable [x]\n  (format \"%02d:%02d:%02d\" (get-hours x) (get-minutes x) (get-seconds x)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15149,"user_id":null,"body":"(ns HumanTime)  \n\n(defn human_readable [seconds]\n  (let [hours (quot seconds 3600)\n        minutes (quot (rem seconds 3600) 60)\n        seconds (rem (rem seconds 3600) 60)]\n  (format \"%02d:%02d:%02d\" hours minutes seconds)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15150,"user_id":null,"body":"(ns HumanTime)  \n\n(defn human_readable [seconds]\n  (let [h (quot seconds 3600)\n        m (-> (rem seconds 3600) (quot 60))\n        s (rem seconds 60)]\n    (format \"%02d:%02d:%02d\" h m s)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15151,"user_id":null,"body":"(ns HumanTime)  \n\n(defn human_readable\n  [x]\n  (format \"%02d:%02d:%02d\" (quot x 3600) (quot (mod x 3600) 60) (mod x 60))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15152,"user_id":null,"body":"(ns HumanTime)  \n\n(defn human_readable [n]\n  (let [div (juxt quot rem)\n        [h s] (div n 3600)\n        [m s] (div s 60)]\n    (format \"%02d:%02d:%02d\" h m s)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15153,"user_id":null,"body":"(ns HumanTime)  \n\n(defn human_readable [x]\n  (let [s 60\n        h (* s s)\n        f #(format \"%02d\", %)]\n    (str (f (quot x h)) \":\"\n         (f (quot (mod x h) s)) \":\"\n         (f (mod x s)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15154,"user_id":null,"body":"(ns HumanTime)  \n\n(defn human_readable [secs]\n  (let [ hh (quot secs (* 60 60))\n         secs-1 (- secs (* hh 60 60))\n         mm (quot secs-1 60)\n         ss (- secs-1 (* mm 60)) ]\n    (format \"%02d:%02d:%02d\" hh mm ss) ))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15155,"user_id":null,"body":"(ns HumanTime)  \n\n(defn human_readable\n  [x]\n  ; TODO\n  (str (format \"%02d\" (int (\/ x 3600)))\n       \":\"\n       (format \"%02d\" (mod (int (\/ x 60)) 60))\n       \":\"\n       (format \"%02d\" (int (mod x 60)))\n)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5270d0d18625160ada0000e4":[{"id":15156,"user_id":201,"body":"(ns kata)\n\n(defn score [dice]\n  (let [f (frequencies dice)]\n    (reduce + \n            [(* 1000 (quot (get f 1 0) 3))\n             (* 100  (mod  (get f 1 0) 3))\n             (* 200  (quot (get f 2 0) 3))\n             (* 300  (quot (get f 3 0) 3))\n             (* 400  (quot (get f 4 0) 3))\n             (* 500  (quot (get f 5 0) 3))\n             (* 50   (rem  (get f 5 0) 3))\n             (* 600  (quot (get f 6 0) 3))])))\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15157,"user_id":null,"body":"(ns kata)\n\n(defn calc-score [[num count]]\n  (condp = num\n    1 (+ (* 1000 (quot count 3)) (* 100 (mod count 3)))\n    5 (+ (* 500 (quot count 3)) (* 50 (mod count 3)))\n    (* 100 num (quot count 3))))\n\n(defn score [dice]\n  (let [freq (seq (frequencies dice))]\n    (->> freq\n         (map calc-score)\n         (reduce +))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15158,"user_id":null,"body":"(ns kata)\n\n(defn score [dice]\n  (let [triple-score (fn [n] (if (= n 1) 1000 (* n 100)))\n        single-score (fn [n] (case n\n                               1 100\n                               5 50\n                               0))\n        score-freq (fn [[n freq]]\n                     (let [triples (quot freq 3)\n                           singles (rem freq 3)]\n                       (+ (* (triple-score n) triples)\n                          (* (single-score n) singles))))]\n    (reduce + (map score-freq (frequencies dice)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15159,"user_id":null,"body":"(ns kata)\n\n(defn score-partition [total-score part]\n  (+ total-score (cond (= '(1 1 1) part) 1000\n                       (= '(1 1 1 1) part) 1100\n                       (= '(6 6 6) (take 3 part)) 600\n                       (= '(5 5 5) (take 3 part)) 500\n                       (= '(4 4 4) (take 3 part)) 400\n                       (= '(3 3 3) (take 3 part)) 300\n                       (= '(2 2 2) (take 3 part)) 200\n                       (= '(1 1) part) 200\n                       (= '(1) part) 100\n                       (= '(5 5) part) 100\n                       (= '(5) part) 50\n                       :else 0)))\n\n\n(defn score [rolls]\n   (->>\n    (group-by identity rolls)\n    (vals)\n    (reduce score-partition 0)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15160,"user_id":null,"body":"(ns kata)\n\n(def rules {1 {5 1200\n               4 1100\n               3 1000\n               2 200\n               1 100}\n            2 {3 200\n               4 200\n               5 200}\n            3 {3 300\n               4 300\n               5 300}\n            4 {3 400\n               4 400\n               5 400}\n            5 {5 600\n               4 550\n               3 500\n               2 100\n               1 50}\n            6 {3 600\n               4 600\n               5 600}})\n\n(defn score [dice]\n  (->> dice\n    (frequencies)\n    (reduce #(+ % (get-in rules %2 0)) 0)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15161,"user_id":null,"body":"(ns kata)\n\n(defn score [dice]\n  (let [[[_ x] [_ y] & z] (map #(vector % (count (filter #{%} dice))) [1 5 2 3 4 6])]\n    (+ (* (quot x 3) 1000)\n       (* (mod x 3) 100)\n       (* (quot y 3) 500)\n       (* (mod y 3) 50)\n       (apply + (map #(* (quot (second %) 3) (first %) 100) z)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15162,"user_id":null,"body":"(ns kata)\n\n(defn score [dice]\n  (let [[[_ x] [_ y] & z] (map #(vector % (count (filter #{%} dice))) [1 5 2 3 4 6])]\n    (+ (if (>= x 3) 1000 0)\n       (* (mod x 3) 100)\n       (if (>= y 3) 500 0)\n       (* (mod y 3) 50)\n       (apply + (map #(if (>= (second %) 3) (* (first %) 100) 0) z)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15163,"user_id":null,"body":"(ns kata)\n\n(defn get-score [num count]\n  (let [score-map {1 [1000 100] 6 [600 0] 5 [500 50] 4 [400 0] 3 [300 0] 2 [200 0]}]\n    (+\n      (* (get (score-map num) 0) (quot count 3))\n      (* (get (score-map num) 1) (mod count 3)))))\n\n(defn score [dice]\n  (->> dice\n       (group-by identity)\n       (into [])\n       (map (fn [[num cnt]] (get-score num (count cnt))))\n       (reduce +)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15164,"user_id":null,"body":"(ns kata)\n\n(defn- award-triple\n  [count award]\n  (* award (quot count 3)))\n\n(defn- award-singles\n  [count award]\n  (* award (mod count 3)))\n\n(defn score [dice]\n  (->> dice\n       (group-by identity)\n       (map (fn [[k v]] [k (count v)]))\n       (map (fn [[die count]]\n              [die (cond\n                     (= 1 die) (+ (award-triple count 1000) (award-singles count 100))\n                     (= 2 die) (award-triple count 200)\n                     (= 3 die) (award-triple count 300)\n                     (= 4 die) (award-triple count 400)\n                     (= 5 die) (+ (award-triple count 500) (award-singles count 50))\n                     (= 6 die) (award-triple count 600))]))\n       (map second)\n       (reduce +)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15165,"user_id":null,"body":"(ns kata)\n\n(defn score [dice]\n  (let [scoring {1 [1000 100]\n                 2 [200 0]\n                 3 [300 0]\n                 4 [400 0]\n                 5 [500 50]\n                 6 [600 0]}]\n    (->> dice\n         (reduce (fn [acc val]\n                   (update acc val (fnil inc 0))) {})\n         (reduce (fn [score [num ns]]\n                   (+ score (reduce + (map * (scoring num) [(if (>= ns 3) 1 0) (mod ns 3)])))) 0))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"527e4141bb2ea5ea4f00072f":[{"id":15166,"user_id":759,"body":"(ns twisted-sum)\n\n(defn sum-digits [n]\n  (if (< n 10) n (+ (rem n 10) (sum-digits (quot n 10)))))\n\n(defn compute-sum [n]\n  (->> (range 1 (+ n 1))\n       (map sum-digits)\n       (reduce +)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15167,"user_id":53,"body":"(ns twisted-sum)\n\n(defn digit-sum [n]\n  (if (zero? n) 0 (+ (digit-sum (quot n 10)) (mod n 10))))\n\n(defn compute-sum [n]\n  (if (zero? n) 0 (+ (digit-sum n) (compute-sum (dec n)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15168,"user_id":564,"body":"(ns twisted-sum)\n\n(defn digits [n]\n  (let [a (mod n 10)\n        b (quot n 10)]\n    (if (< n 10)\n      [a]\n      (concat [a] (digits b)))))\n\n(defn compute-sum [n]\n  (let [ns (range 1 (+ n 1))]\n    (reduce + (mapcat digits ns))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15169,"user_id":null,"body":"(ns twisted-sum)\n\n(def scale 10)\n\n(defn- digits \n  [n]\n  (->> n\n       (iterate #(quot % scale))\n       (take-while pos?)\n       (map #(mod % scale))))\n\n(defn compute-sum [n]\n  (reduce + (mapcat digits (range 1 (+ n 1)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15170,"user_id":null,"body":"(ns twisted-sum)\n\n(defn digits [n]\n  (->> (str n)\n       (map str)\n       (map read-string)))\n\n(defn compute-sum [n]\n  (->> (range 1 (inc n))\n       (mapcat digits)\n       (reduce +)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15171,"user_id":null,"body":"(ns twisted-sum)\n\n(defn compute-sum [n]\n  (->> \n    (iterate inc 1)\n    (take n)\n    (map str)\n    (map seq)\n    (flatten)\n    (map #(Integer\/parseInt (str %)))\n    (apply +))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15172,"user_id":null,"body":"(ns twisted-sum)\n\n(defn compute-sum [n]\n  (->> (range (inc n))\n       (apply str)\n       (map #(Character\/digit % 10))\n       (apply +)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15173,"user_id":null,"body":"(ns twisted-sum)\n\n(defn sum [a b] \n            (let  [q (quot a 10)\n                   m (mod a 10)]\n                     (if (> q 9) (recur q m) (+ q m b))\n         ))\n\n\n(defn compute-sum [n]\n  (reduce  #(+ %1 (sum %2 0)) (range 1 (+ n 1)))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15174,"user_id":null,"body":"(ns twisted-sum)\n\n(defn sum_2  \n  ([a] (sum_2 a 0))\n  ([a b] \n   (let [q (quot a 10)\n         m (mod a 10)]\n           (if (> q 9) (recur q m) (+ q b m))\n         ) \n   )\n  )\n\n\n(defn compute-sum [n]\n  (reduce  #(+ %1 (sum_2 %2)) (range 1 (+ n 1)))\n  )\n  \n  \n  \n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15175,"user_id":168,"body":"(ns twisted-sum)\n\n(defn sum-digits [n]\n  (apply + (map #(Character\/digit % 10) (str n))))\n\n(defn compute-sum [n]\n  (->> (range 1 (inc n))\n       (map sum-digits)\n       (apply +)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"52945ce49bb38560fe0001d9":[{"id":15176,"user_id":null,"body":"(ns clojure.pascal)\n(defn next-row [row]\n  (mapv + (into [0] row) (into row [0])))\n(defn pascal [n]\n  (vec (take n (iterate next-row [1])))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15177,"user_id":492,"body":"(ns clojure.pascal)\n(def pascal-aux\n  (iterate #(concat [1] \n                    (map + % (rest %)) \n                    [1]) \n           [1]))\n(defn pascal [n]\n  (take n pascal-aux)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15178,"user_id":null,"body":"(ns clojure.pascal)\n\n(defn pascal [n]\n  (take n (iterate (fn [a] (mapv #(+ %1 %2) (conj a 0) (cons 0 a))) [1])))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15179,"user_id":null,"body":"(ns clojure.pascal)\n\n(def triangle\n  (iterate\n    (fn [row]\n      (concat [1] \n              (map (fn [[a b]] (+ a b)) (partition 2 1 row))\n              [1]))\n    [1]))\n\n(defn pascal [n]\n  (take n triangle))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15180,"user_id":53,"body":"(ns clojure.pascal)\n\n(defn comb [n k]\n  (if (zero? k)\n    1\n    (quot (* (comb (dec n) (dec k)) n) k)))\n\n(defn pascal [d]\n  (map (fn [n] (map (fn [k] (comb n k)) (range 0 (inc n)))) (range 0 d)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15181,"user_id":null,"body":"(ns clojure.pascal)\n\n(defn pascal [n]\n  (loop [e [1], i [e], n n]\n    (or ({n i} 1)\n        (let [e (mapv + `[~@e 0] `[0 ~@e])]\n          (recur e `[~@i ~e] (dec n))))))\n          ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15182,"user_id":null,"body":"(ns clojure.pascal)\n\n\n\n\n(defn ! [n] (reduce * (range 1 (inc n))))\n\n(defn nCk [n k]\n  (\/ (! n) (* (! (- n k)) (! k))))\n\n\n\n(defn genrow [n]\n  (let [n (dec n)]\n    (into [] (for [i (range (inc n))]\n               (nCk n i)))))\n(genrow 1)\n\n(defn pascal [n]\n  (->> (range 1 (inc n))\n       (map genrow))\n  ;your solution here\n  )\n\n(pascal 2)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15183,"user_id":null,"body":"(ns clojure.pascal)\n\n(defn pascal [n]\n  (loop [i 1\n         res [[1]] ]\n    (if (< i n) \n      (->>\n        (range (inc i))\n        (mapv #(+ (get-in res [(dec i) (dec %)] 0) (get-in res [(dec i) %] 0)))\n        (conj res)\n        (recur (inc i)))\n      res)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15184,"user_id":null,"body":"(ns clojure.pascal)\n\n(defn get-pascal-element\n  [row col previous-row]\n  (if (or (zero? row) (zero? col) (= row col)) 1\n      (+ (get previous-row (dec col)) (get previous-row col))))\n\n(defn get-pascal-next-row\n  [previous-row]\n  (loop [row (count previous-row), col 0, currentRow []]\n    (if (= col (inc row)) currentRow\n        (recur row (inc col) (conj currentRow (get-pascal-element row col previous-row))))))\n\n(defn pascal\n  [depth]\n  (loop [row 0, acc []]\n    (if (= row depth) acc\n        (recur (inc row) (conj acc (get-pascal-next-row (last acc)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15185,"user_id":null,"body":"(ns clojure.pascal)\n\n(def solutions [\n                [[1]] \n                [[1] [1 1]] \n                [[1] [1 1] [1 2 1]]\n                [[1] [1 1] [1 2 1] [1 3 3 1]]\n                [[1] [1 1] [1 2 1] [1 3 3 1] [1 4 6 4 1]]\n                ])\n\n(def i (atom -1))\n\n(defn pascal [n]\n  (nth solutions (swap! i inc))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5297bf69649be865e6000922":[{"id":15186,"user_id":null,"body":"(ns kata\n  (:require [clojure.string :as s]))\n\n(defn make_sentences [parts]\n  (-> (s\/join \" \" parts)\n      (s\/replace \" , \" \", \")\n      (str \".\")\n      (s\/replace #\"(\\s?\\.)+\" \".\")))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15187,"user_id":null,"body":"(ns kata)\n\n(defn make_sentences [parts]\n  (-> (clojure.string\/join \" \" parts)\n    (clojure.string\/replace #\" , \" \", \")\n    (str \".\")\n    (clojure.string\/replace #\"(\\s?\\.)+\" \".\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15188,"user_id":null,"body":"(ns kata)\n(use '[clojure.string])\n\n(defn make_sentences [parts]\n  (str (replace (join \" \" (remove #(== (compare % \".\") 0) parts)) #\" , \" \", \") \".\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15189,"user_id":null,"body":"(ns kata)\n\n(defn make_sentences [parts]\n  (let [joined-with-space (clojure.string\/join \" \" (filter #(not= \".\" %) parts))\n        comma-space-removed (clojure.string\/replace joined-with-space \" , \" \", \")\n        period-added (str comma-space-removed \".\")]\n    period-added))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15190,"user_id":null,"body":"(ns kata)\n(use 'clojure.string)\n\n(defn sentence_rules [s t]\n  (cond\n    (= t \",\") (if (ends-with? s \", \") (str s t) (str s t \" \"))\n    (= t \".\") (str s t)\n    :else (if (ends-with? s \", \") (str s t) (str s \" \" t))))\n\n(defn make_sentences [parts]\n  (->>\n    (take-while #(not= %1 \".\") parts)\n    (reduce sentence_rules)\n    (#(str %2 %1) \".\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15191,"user_id":null,"body":"(ns kata (require [clojure.string :as s]))\n\n(defn make_sentences [xs]\n  (-> xs (->> (s\/join \" \"))\n         (str \\.)\n         (s\/replace #\"(?<!,)[\\s.]+([\\s.,])\" \"$1\")\n         (s\/replace #\" , ,\" \" ,,\"))) ;lazy hack for strange kata output!","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15192,"user_id":201,"body":"(ns kata)\n\n(defn make_sentences [parts]\n   (str (clojure.string\/replace\n         (clojure.string\/replace\n          (clojure.string\/join \" \" parts)\n          #\"\\s\\.\" \"\")\n         #\"(\\s,\\s)\" \", \")\n        \".\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"52b2cf1386b31630870005d4":[{"id":15193,"user_id":388,"body":"(ns readability-is-king)\n\n(defn flesch-kincaid [text]\n  (let [s (count (re-seq #\"[.!?]\" text))\n        w (count (re-seq #\"\\W+\" text))\n        c (count (re-seq #\"(?i)[aeiou]+\" text))]\n    (+ (* 0.39 (\/ w s)) (* 11.8 (\/ c w)) -15.59)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15194,"user_id":null,"body":"(ns readability-is-king\n  (:require [clojure.string :as str]))\n\n(defn flesch-kincaid [text]\n  (let [sentences (str\/split text #\"[.!?] *\")\n        words (mapcat #(str\/split % #\" \") sentences)\n        syllables (mapcat #(->> % str\/lower-case (re-seq #\"[aeiou]+\")) words)]\n    (+ (* 0.39 (\/ (count words) (count sentences))) \n       (* 11.8 (\/ (count syllables) (count words)))\n       -15.59)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15195,"user_id":null,"body":"(ns readability-is-king\n  (:require [clojure.string :as str]))\n\n\n(defn flesch-kincaid [text]\n  (let [words (count (str\/split text #\" \"))\n      sentences (count (str\/split text #\"[\\.!]\"))\n      syllables (count (re-seq #\"(?ix)[aeioyu]+\" text))\n      ]\n  (+ (* 0.39 (\/ words sentences)) (* 11.8 (\/ syllables words)) -15.59)\n))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15196,"user_id":168,"body":"(ns readability-is-king)\n\n(defn flesch-kincaid [text]\n  (let [s (count (re-seq #\"[.!?]\" text))\n        w (count (re-seq #\"\\w+\" text))\n        v (count (re-seq #\"(?i)[aeiou]+\" text))]\n    (+ (* 0.39 w (\/ s)) (* 11.8 v (\/ w)) -15.59)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15197,"user_id":53,"body":"(ns readability-is-king)\n\n(defn re-count [re text] (count (re-seq re text)))\n\n(defn flesch-kincaid [text]\n  (let [sentences (re-count #\"[.?!]\" text)\n        words (re-count #\"\\W+\" text)\n        syllables (re-count #\"(?i)[aeiou]+\" text)]\n    (+ (* 0.39 (\/ words sentences)) (* 11.8 (\/ syllables words)) -15.59)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15198,"user_id":null,"body":"(ns readability-is-king)\n\n\n(defn round2\n  \"Round a double to the given precision (number of significant digits)\"\n  [precision d]\n  (let [factor (Math\/pow 10 precision)]\n    (\/ (Math\/round (* d factor)) factor)))\n\n(defn flesch-kincaid [text]\n  (let [num-sentences (count (re-seq #\"[.!]+\" text))\n        num-words (count (re-seq #\"\\w+\" text))\n        num-syllables (count (re-seq #\"[AEIOUaeiou]+\" text))]\n    (round2 2 (- (+ (* 0.39 (\/ num-words num-sentences)) (* 11.8 (\/ num-syllables num-words))) 15.59)))\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15199,"user_id":null,"body":"(ns readability-is-king\n  (require [clojure.string :as st]))\n\n\n\n(defn flesch-kincaid [text]\n  (let [text (st\/replace text #\"[AEIOUaeiou]+\" \"a\")\n        sentencect (count (st\/split text #\"[\\.!?]\"))\n        word_count (count (st\/split text #\" \"))\n        vowelcount (reduce + (vals (select-keys (frequencies text) [\\a \\e \\i \\o \\u])))]\n    (- \n      (+ \n        (* 0.39 (\/ word_count sentencect))\n        (* 11.8 (\/ vowelcount word_count)))\n      15.59)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15200,"user_id":null,"body":"(ns readability-is-king)\n\n\n(defn re-vowel-groups [word]\n  (re-seq #\"[AEIOUaeiou]+\" word))\n\n(defn re-sentences [text]\n  (re-seq #\"(?<=\\s|^)[\\w\\s]+(?=[.!?])\" text))\n\n(defn re-words [text]\n  (clojure.string\/split text #\"\\s\"))\n\n(defn flesch-kincaid [text]\n  (let [breakdown (->> text\n                       re-sentences\n                       (map re-words)\n                       (map #(map re-vowel-groups %))\n                       (map #(map count %)))\n        A (\/ (count (flatten breakdown)) (count breakdown))\n        B (\/ (apply + (flatten breakdown)) (count (flatten breakdown)))]\n\n    (- (+ (* 0.39 A) (* 11.8 B)) 15.59)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15201,"user_id":null,"body":"(ns readability-is-king\n  (:require [clojure.string :as str]))\n\n\n(defn- average \n  [counts]\n  (\/ (reduce + counts) (count counts)))\n\n(defn- average-num-of-words \n  [text]\n  (let [word-counts\n        (map count (map #(str\/split % #\"\\s+\")\n                        (map str\/trim (str\/split text #\"[!?.]+\"))))]\n    (average word-counts)))\n\n(defn- num-of-syllables-in-word \n  [word]\n  (count (re-seq #\"[aeiou]+\" (str\/lower-case word))))\n\n(defn- average-num-of-syllables \n  [text]\n  (let [syllable-counts (map num-of-syllables-in-word \n                             (str\/split text #\"[!?.\\s]+\"))]\n    (average syllable-counts)))\n\n(defn flesch-kincaid \n  [text]\n  (- (+ (* 0.39 (average-num-of-words text)) \n        (* 11.8 (average-num-of-syllables text))) \n     15.59))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15202,"user_id":null,"body":"(ns readability-is-king\n  (:require [clojure.string :as s]))\n\n\n(defn flesch-kincaid [text]\n  (let [wordNum (count (s\/split text #\"[ ]\"))\n        sentNum (count (s\/split text #\"[.!?]\"))\n        sylNum (count (filter #(not (s\/blank? %)) (s\/split (s\/lower-case text) #\"[bcdfghjklmnpqrstvwxz -A]\")))]\n    (+ (* 0.39 (\/ wordNum sentNum)) (* 11.8 (\/ sylNum wordNum)) -15.59)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"52c31f8e6605bcc646000082":[{"id":15203,"user_id":null,"body":"(ns two_sum)\n\n(defn two_sum [numbers target]\n  (first \n    (for [i (range (count numbers))\n          j (range (count numbers))\n          :when (and (not= i j)\n                     (= target (+ (nth numbers i) (nth numbers j))))]\n      [i j])))\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15204,"user_id":527,"body":"(ns two_sum)\n\n(defn two_sum [numbers target]\n  (reduce-kv\n    (fn [seen-at i x]\n      (let [y (- target x)]\n        (if-let [j (seen-at y)] (reduced [j i]) (assoc seen-at x i))))\n    {}\n    numbers))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15205,"user_id":53,"body":"(ns two_sum)\n(defn two_sum [xs n]\n  (first (\n     for [i (range 0 (count xs))\n          j (range 0 (count xs))\n          :let [x (nth xs i)\n                y (nth xs j)]\n          :when (and (not= i j) (= n (+ x y)))]\n    (list i j))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15206,"user_id":null,"body":"(ns two_sum)\n\n  (defn ind [coll]\n    (map-indexed vector coll))\n\n  (defn two_sum [coll target]\n    (first\n     (for [[i x] (ind coll)\n           [j y] (ind coll)\n           :when (and (not= i j)\n                      (= target (+ x y)))]\n       [i j])))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15207,"user_id":null,"body":"(ns two_sum)\n\n(defn two_sum [numbers target]\n  (reduce-kv\n    #(if-let [matched (%1 (- target %3))] (reduced [%2 matched]) (assoc %1 %3 %2))\n    {}\n    numbers)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15208,"user_id":null,"body":"(ns two_sum)\n(defn two_sum [numbers target]\n  (first \n    (for [x (range (count numbers))\n          y (range (inc x) (count numbers))\n          :when (= target\n                   (+ (get numbers x)\n                      (get numbers y)))]\n             [x y])))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15209,"user_id":null,"body":"(ns two_sum)\n; O(n)\n; Add and find an item in hashed lists cost O(1)\n; Recursive is O(n) because in the worst case, will iterate all the numbers inside numbers list\n(defn recursive [hashed target numbers current-index]  \n  (let [current (first numbers)\n        diff (- target current)\n        item-hashed (get hashed diff)]\n  (cond\n    (not= nil item-hashed) {item-hashed current-index}\n    :else (recur (assoc hashed current current-index) target (rest numbers) (inc current-index))\n    )\n  )\n)\n\n; O(n)\n(defn two_sum [numbers target]\n (first (recursive {} target numbers 0)))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15210,"user_id":null,"body":"(ns two_sum)\n(defn two_sum [numbers target]\n  (let [nums-index (map vector numbers (range))\n        indexs (for [[num-1 i] nums-index\n                     [num-2 j] nums-index\n                     :when (and (not= i j)\n                                (= (+ num-1 num-2) target))]\n                  [i j])]\n    (first indexs)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15211,"user_id":null,"body":"(ns two_sum)\n\n(defn index-of [v target]\n  (loop [i 0]\n    (if (>= i (count v))\n      nil\n      (if (= target (nth v i))\n        i\n        (recur (inc i))\n      )\n    )\n  )\n)\n\n(defn two_sum [[fst & rst] target]\n  (if (nil? (index-of rst (- target fst)))\n    (map (partial + 1) (two_sum rst target))\n    [0 (+ 1 (index-of rst (- target fst)))]\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15212,"user_id":null,"body":"(ns two_sum)\n(defn two_sum [numbers target]\n  (first (for [a (-> numbers count range)\n               b (-> numbers count range)\n               :let [a' (numbers a)\n                     b' (numbers b)\n                     s (+ a' b')]\n               :when (and (not= a b) (= target s))]\n           [a b])))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"52f787eb172a8b4ae1000a34":[{"id":15213,"user_id":null,"body":"(ns leading-zeros)\n\n(defn zeros [n] \n  (loop [factor 5 result 0]\n    (if (= 0 (quot n factor))\n      result\n      (recur (* 5 factor) (+ result (quot n factor))))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15214,"user_id":null,"body":"(ns leading-zeros)\n\n(defn zeros [n]\n  (->> n\n       (iterate #(quot % 5))\n       next\n       (take-while pos?)\n       (apply +)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15215,"user_id":null,"body":"(ns leading-zeros)\n\n(defn zeros\n  \"Calculate number of trailing zeros in factorial(n).\n  Solved by counting all factors of 5 in range. There\n  must be at least one factor of 2 for each factor of 5,\n  and each 2*5 pair gives us another trailing zero.\"  \n  [n]\n  (->> (iterate (partial * 5) 5N)     ; powers of 5\n       (map #(bigint (\/ n %)))        ; n\/5, n\/25, n\/125, n\/625 etc.\n       (take-while pos?)              ; positive values only\n       (apply +)                      ; add them together\n   )\n  )\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15216,"user_id":564,"body":"(ns leading-zeros)\n\n(defn zeros [n]\n  (let [m (quot n 5)]\n  (if (<= n 0)\n    0\n    (+ m (zeros m)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15217,"user_id":null,"body":"(ns leading-zeros)\n\n(defn zeros [n]\n  (->> n\n       (iterate #(int (\/ % 5)))\n       (take-while pos?)\n       (rest)\n       (apply +)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15218,"user_id":null,"body":"(ns leading-zeros)\n\n(defn zeros [n] \n  (apply + \n         (take-while #(> % 0) \n                     (map #(quot n %) \n                          (iterate (partial * 5) 5))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15219,"user_id":null,"body":"(ns leading-zeros)\n\n(defn zeros [n]\n  (if (zero? n)\n    0\n    (reduce + (map #(int (\/ n (Math\/pow 5 %)))\n                   (range 1 (inc (int (\/ (Math\/log10 n) (Math\/log10 5)))))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15220,"user_id":3346,"body":"(ns leading-zeros)\n\n(defn zeros [n] \n (if (= n 0) 0\n  (let [d (quot n 5)] (+ d (zeros d)) )\n ) \n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15221,"user_id":null,"body":"(ns leading-zeros)\n\n(defn zeros [n] \n  (cond\n    (= n 0) 0\n    :else (let [d (quot n 5)] (+ d (zeros d)))\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15222,"user_id":null,"body":"(ns leading-zeros)\n\n(defn facts [fac n]\n  (->> n\n       (iterate #(int (\/ % fac)))\n       (take-while pos?)\n       rest\n       (apply +)))\n\n(defn zeros [n] \n      (min (facts 2 n) (facts 5 n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"52f78966747862fc9a0009ae":[{"id":15223,"user_id":null,"body":"(ns clojure.reverse-notation\n  (:require\n    [clojure.edn :as e]))\n    \n(def allowed-fns {'+ + '- - '\/ \/ '* *})\n\n(defn calc\n  [expr]\n  (loop [[e & es] (->> expr (re-seq #\"\\S+\") (map e\/read-string) (replace allowed-fns))\n         stack '()]\n    (cond\n      (number? e) (recur es (conj stack e))\n      (fn? e) (recur es (->> stack (take 2) reverse (apply e) (conj (drop 2 stack))))\n      :default (or (peek stack) 0))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-28 16:34:06"},{"id":15224,"user_id":null,"body":"(ns clojure.reverse-notation)\n\n  \n  \n(defn calc [expr]\n  (->> (clojure.string\/split expr #\"\\s\")\n    (reduce\n      (fn [[a b & other :as C]\n           x]\n        (case x\n          \"+\" (cons (+ b a) other)\n          \"-\" (cons (- b a) other)\n          \"*\" (cons (* b a) other)\n          \"\/\" (cons (\/ b a) other)\n          \"\" C \n          \n          ; default\n          (cons\n            (clojure.edn\/read-string x)\n            C)))\n      [0])\n      first))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15225,"user_id":null,"body":"(ns clojure.reverse-notation)\n\n(defn rpn [[new old & others :as acc] [op & ops]]\n  (cond \n    (nil? op)    new\n    (number? op) (rpn (cons op acc) ops)\n    :else        (rpn (cons ((resolve op) old new) others) ops)))\n\n(defn calc [expr]\n  (if (= expr \"\")\n      0\n      (rpn '() (map read-string (clojure.string\/split expr #\" \")))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15226,"user_id":null,"body":"(ns clojure.reverse-notation\n   (:require \n            [clojure.string :as str]))\n\n\n(def OPS {\"\" 0 \"+\" + \"-\" - \"*\" * \"\/\" \/})\n\n(defn parse-token [t]\n  (cond \n    (re-matches #\"\\d++\" t) (Long\/parseLong t)\n    (re-matches #\"\\d++\\.\\d++\" t) (Double\/parseDouble t)\n    :else (OPS t)))\n\n(defn process-token [stack tok]\n  (if (fn? tok)\n    (let [[fst snd & rst] stack]\n      (conj rst (tok snd fst)))\n    (conj stack tok)))\n\n(defn calc [expr]\n  (let [parts (str\/split expr #\"\\s++\")\n        toks (map parse-token parts)\n        stack (reduce process-token '() toks)]\n    (last stack)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15227,"user_id":null,"body":"(ns clojure.reverse-notation (:require clojure.string))\n\n(defn calc [expr]\n  (if (= 0 (count expr)) 0\n    (let [ops {\"+\" + \"-\" - \"*\" * \"\/\" \/}\n          e (clojure.string\/split expr #\"\\s+\")]\n      (letfn [(pop-drop [lst elem]\n                (if (contains? ops elem)\n                  (let [num (peek lst) st (pop lst)]\n                    (conj (pop st) ((ops elem) (peek st) num)))\n                  (conj lst (Double. elem))))]\n        (let [res (last (reduce pop-drop [] e))]\n          (if (== res (long res)) (long res) res))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15228,"user_id":null,"body":"(ns clojure.reverse-notation)\n\n(defn calculate [stack expr]\n  (if (empty? expr)\n    (first stack)\n    (let [term (first expr)\n          rest-expr (rest expr)]\n      (recur\n       (if (number? term)\n        (conj stack term)\n        (conj (vec (drop-last 2 stack))\n              (apply (resolve term)\n                     (take-last 2 stack))))\n       rest-expr))))\n\n(defn calc [expr]\n  (if (empty? expr)\n    0\n    (calculate [] (read-string (str \"(\" expr \")\")))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15229,"user_id":null,"body":"(ns clojure.reverse-notation)\n\n(defn eval-expr [[cur & tail] stack]\n  (if (nil? cur)\n    (first stack)\n    (let [parsed (read-string cur)]\n      (if (number? parsed)\n        (recur tail (conj stack parsed))\n        (let [[num1 num2 & rest] stack\n              result (eval (read-string (str \"(\" cur \" \" num2 \" \" num1 \")\")))]\n          (recur tail (conj rest result)))))))\n\n(defn calc [expr]\n  (println expr)\n  (if (empty? expr) \n    0\n    (let [tokens (clojure.string\/split expr #\" \")]\n      (eval-expr tokens '()))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15230,"user_id":null,"body":"(ns clojure.reverse-notation)\n\n(defn exprn [expr]\n  (map read-string (clojure.string\/split expr #\" \")))\n\n(defn eval-exprn [exprn]\n  (loop [stack [] tokens exprn]\n    (if (empty? tokens) (last stack) \n        (let [top (first tokens)\n              tokens' (rest tokens)\n              ntokens (if (> (count stack) 2) (- (count stack) 2) 0)\n              res (if-not (number? top)\n                    (reduce (eval top) (drop ntokens stack))\n                    nil)\n              stack' (if (nil? res) (conj stack top)\n                        (conj (vec (take ntokens stack)) res))]\n          (recur stack' tokens')))))\n\n(defn calc [expr]\n  (if (= \"\" expr) 0 (eval-exprn (exprn expr))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15231,"user_id":null,"body":"(ns clojure.reverse-notation)\n(require '[clojure.string :as str])\n(defn calc [expr]\n(if (= expr\"\") 0\n(let [in-seq (map read-string (str\/split expr #\" \"))]\n  (nth (reduce \n    (fn [v x]\n      (if\n        (number? x) (conj v x)\n        (let [res (eval (list x (nth v 1) (nth v 0)))\n              part-v (nthrest v 2)]\n              (conj part-v res))))\n    '(0 0) in-seq) 0))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15232,"user_id":null,"body":"(ns clojure.reverse-notation\n  (:require [clojure.string :as string]))\n\n(defn calc [expr]\n  (let [tokens (map (comp eval read-string) (remove empty? (string\/split expr #\" \")))]\n    (loop [stack (list) tokens tokens]\n      (if-let [item (first tokens)]\n        (if (number? item)\n          (recur (conj stack item) (rest tokens))\n          (let [x (peek stack)\n                y (peek (pop stack))]\n            (recur (conj (pop (pop stack)) (item y x)) (rest tokens))))\n        (or (first stack) 0)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"52fba66badcd10859f00097e":[{"id":15233,"user_id":null,"body":"(ns disemvowel-trolls)\n\n\n(defn disemvowel\n  [string]\n  (clojure.string\/replace string #\"(?i)[aeiou]\" \"\"))\n    ","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-26 07:35:24"},{"id":15234,"user_id":null,"body":"(ns disemvowel-trolls)\n\n(defn disemvowel [string]\n  (->> string\n       (remove (set \"aeiouAEIOU\"))\n       (apply str)))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15235,"user_id":null,"body":"(ns disemvowel-trolls)\n\n(defn disemvowel\n  [s]\n  (.replaceAll s \"[aeuioAEUIO]\" \"\")\n)","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15236,"user_id":null,"body":"(ns disemvowel-trolls)\n\n(defn disemvowel\n  [string]\n  (->> string\n       (remove #{\\a \\o \\e \\u \\i \\A \\O \\E \\U \\I})\n       (apply str)))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15237,"user_id":1077,"body":"(ns disemvowel-trolls)\n\n(defn disemvowel\n  [string]\n  (.replaceAll string \"[AEIOUaeiou]\" \"\")\n)","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15238,"user_id":null,"body":"(ns disemvowel-trolls)\n\n(def vowels #{\\a \\e \\i \\o \\u\n              \\A \\E \\I \\O \\U})\n\n(defn disemvowel\n  [string]\n  (->> string\n    (remove vowels)\n    (apply str)))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15239,"user_id":null,"body":"(ns disemvowel-trolls)\n\n(def vowels #{\\a \\A \\e \\E \\i \\I \\o \\O \\u \\U})\n(defn disemvowel\n  [string]\n  (apply str (remove vowels string)))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15240,"user_id":null,"body":"(ns disemvowel-trolls)\n\n(defn disemvowel\n  [string]\n  (apply str (re-seq #\"[^aeiouAEIOU]+\" string)))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15241,"user_id":null,"body":"(ns disemvowel-trolls\n  (:use [clojure.string :only [join]]))\n\n(defn disemvowel\n  [string]\n  (join (re-seq #\"[^aieouAIEOU]\" string))\n)","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15242,"user_id":null,"body":"(ns disemvowel-trolls\n  (:require [clojure.string :as string]))\n\n(def vowels #{\"a\" \"e\" \"i\" \"o\" \"u\"})\n\n(defn vowel?\n  [string]\n  (contains? vowels (string\/lower-case string)))\n\n(def consonant? (complement vowel?))\n\n(defn disemvowel\n  [string]\n  (->>  string\n    (filter consonant?)\n    (reduce str)))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5340298112fa30e786000688":[{"id":15243,"user_id":881,"body":"(ns difftwo)\n\n(defn twos_difference [lst]\n  (->> lst\n       (filter #(.contains lst (+ % 2)))\n        sort\n       (map #(vec (list % (+ % 2))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15244,"user_id":null,"body":"(ns difftwo)\n\n(defn twos_difference [lst]\n  (cond\n   (empty? lst) []\n   :else (let [ls (sort lst)\n               x (first ls)\n               ys (rest ls)]\n          (concat (vec (map (fn [y] [x y]) (filter #(= 2 (- % x)) ys))) \n                  (twos_difference ys)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15245,"user_id":null,"body":"(ns difftwo)\n\n(defn twos_difference [lst]\n  (let [sorted (sort lst)]\n    (filter (fn [[x y]] (= x (- y 2)))\n      (for [x sorted y sorted] (vector x y)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15246,"user_id":null,"body":"(ns difftwo)\n\n(defn twos_difference [lst]\n (->> \n   (for [i lst j lst] (sort [i j]))\n   (filter (fn [[a b]] (and (< a b) (= 2 (Math\/abs (- a b))))))\n   distinct\n   (sort (fn [x y] (compare [(first x) (last x)] [(first y) (first y)])))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15247,"user_id":null,"body":"(ns difftwo)\n\n(defn twos_difference [lst]\n  (loop [lst (sort lst)\n         pairs []]\n    (if (empty? lst)\n      pairs\n      (let [[head & tail] lst]\n        (recur tail\n               (if-let [paired (first (filter #(= (+ head 2) %) tail))]\n                 (conj pairs [head paired])\n                 pairs))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15248,"user_id":null,"body":"(ns difftwo)\n\n(defn twos_difference [lst]\n  (let [nums (set lst)]\n    (reduce #(if-let [n (nums (+ %2 2))] (conj %1 [%2 n]) %1) [] (sort lst))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15249,"user_id":null,"body":"(ns difftwo)\n\n(defn twos_difference [lst]\n  (->> (sort lst)\n       (reduce (fn [arr x] (if\n                             (some #(= (+ x 2) %) lst)\n                             (conj arr [x (+ 2 x)])\n                             arr))\n               [])))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15250,"user_id":null,"body":"(ns difftwo)\n\n(defn twos_difference [lst]\n  (vec (let [lst (sort lst)]\n    (remove nil? (for [x lst y lst]\n      (when (= y (+ 2 x)) [x y])))\n    )))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15251,"user_id":null,"body":"(ns difftwo)\n\n(defn twos_difference [lst]\n  (->> (for [l1 lst\n               l2 lst\n               :when (= 2 (- l2 l1))]\n           [l1 l2])\n         sort\n         vec))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15252,"user_id":null,"body":"(ns difftwo)\n\n(defn twos_difference [xs]\n  (loop [acc []\n         minuend xs]\n    (if (empty? minuend)\n      (->> acc\n        (reduce concat)\n        (map sort)\n        (set)\n        (map vec)\n        (sort))\n      (recur\n       (let [x (first minuend)]\n         (->> xs\n           (filter #(= (Math\/abs (- % x)) 2))\n           (map #(vector x %))\n           (conj acc)))\n       (rest minuend)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"53907ac3cd51b69f790006c5":[{"id":15253,"user_id":null,"body":"(ns triangle_type.core)\n\n(defn triangle_type [a b c] \n  (let [[a b c] (sort [a b c])\n        ab (+ (* a a) (* b b))\n        cc (* c c)]\n    (cond \n      (>= c (+ a b)) 0\n      (> ab cc) 1\n      (== ab cc) 2\n      :else 3)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15254,"user_id":null,"body":"(ns triangle_type.core)\n; Should return triangle type:\n;  0 : if triangle cannot be made with given sides\n;  1 : acute triangle\n;  2 : right triangle\n;  3 : obtuse triangle\n\n(defn triangle_type \n  [& sides] \n  (let [[a b c] (sort sides)\n        diagonal (* c c)\n        sides (+ (* a a) (* b b))]\n    (cond \n      (>= c (+ a b)) 0\n      (< diagonal sides) 1\n      (= diagonal sides) 2\n      (> diagonal sides) 3)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15255,"user_id":null,"body":"(ns triangle_type.core)\n; Should return triangle type:\n;  0 : if triangle cannot be made with given sides\n;  1 : acute triangle\n;  2 : right triangle\n;  3 : obtuse triangle\n\n(defn triangle_type [a b c]\n  (def mx (max a b c))\n  (def mn (min a b c))\n  (def md (- (+ a b c) mx mn))\n  (cond (<= (+ mn md) mx) 0\n        (> (* mx mx) (+ (* mn mn) (* md md))) 3\n        (= (* mx mx) (+ (* mn mn) (* md md))) 2\n        :else 1))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15256,"user_id":null,"body":"(ns triangle_type.core)\n\n(defn triangle_type [a b c]\n  (let [[a b g] (sort [a b c])\n        c (compare (* g g) (+ (* a a) (* b b)))]\n    (if (>= g (+ a b)) 0 (+ 2 c))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15257,"user_id":50,"body":"(ns triangle_type.core)\n\n(defn triangle_type [a b c]\n  (if (> a b) (triangle_type b a c)\n    (if (> b c) (triangle_type a c b)\n      (if (<= (+ a b) c) 0\n        (if (= (* c c) (+ (* a a) (* b b ))) 2\n          (if (> (* c c) (+ (* a a) (* b b ))) 3 1))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15258,"user_id":null,"body":"(ns triangle_type.core)\n; Should return triangle type:\n;  0 : if triangle cannot be made with given sides\n;  1 : acute triangle\n;  2 : right triangle\n;  3 : obtuse triangle\n\n(defn cosine\n  \"Given a vector of side lengths, return the cosine of the angle facing first side\"\n  [[a b c]]\n  (\/ (- (+ (* b b) (* c c)) (* a a))\n     (* 2 b c)))\n\n(defn cosines\n  \"Given a vector of side lengths, return the cosines of all three angles\"\n  [[a b c]]\n  (mapv cosine [[a b c] [b c a] [c a b]]))\n\n(defn triangle_type [a b c]\n  (if (some zero? [a b c]) \n    0\n    (let [xs (cosines [a b c])]\n      (cond\n        (some   #(>= % 1) xs) 0\n        (every? pos?      xs) 1\n        (some   zero?     xs) 2\n        (some   neg?      xs) 3))))\n\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15259,"user_id":null,"body":"(ns triangle_type.core)\n; Should return triangle type:\n;  0 : if triangle cannot be made with given sides\n;  1 : acute triangle\n;  2 : right triangle\n;  3 : obtuse triangle\n\n(defn not-a-triangle [[a b c]]\n  (if (<= (+ a b) c)\n    0\n    nil))\n\n(defn compute-type [sides]\n  (let [[as bs cs] (map #(* % %) sides)\n        as+bs (+ as bs)]\n    (+ 2 (compare cs as+bs))))\n\n(defn triangle_type [a b c]\n  (#(or (not-a-triangle %) (compute-type %)) (sort [a b c])))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15260,"user_id":null,"body":"(ns triangle_type.core)\n; Should return triangle type:\n;  0 : if triangle cannot be made with given sides\n;  1 : acute triangle\n;  2 : right triangle\n;  3 : obtuse triangle\n\n(defn triangle_type [& s]\n  (let [[a b c] (sort s)\n        x (+ (* a a) (* b b))\n        y (* c c)]\n    (cond (>= c (+ a b)) 0\n          (> x y) 1\n          (= x y) 2\n          (< x y) 3)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15261,"user_id":null,"body":"(ns triangle_type.core)\n; Should return triangle type:\n;  0 : if triangle cannot be made with given sides\n;  1 : acute triangle\n;  2 : right triangle\n;  3 : obtuse triangle\n\n(defn ** [x] (* x x))\n\n(defn triangle_type [a b c]\n  (let [sorted (sort [a b c])\n        aq (** (first sorted))\n        bq (** (second sorted))\n        cq (** (last sorted))]\n    (if (or (<= (+ a b) c) (<= (+ a c) b) (<= (+ b c) a))\n      0\n      (cond (> (+ aq bq) cq) 1\n            (= (+ aq bq) cq) 2\n            :else 3))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15262,"user_id":null,"body":"(ns triangle_type.core)\n; Should return triangle type:\n;  0 : if triangle cannot be made with given sides\n;  1 : acute triangle\n;  2 : right triangle\n;  3 : obtuse triangle\n\n(defn signum [x]\n  (cond\n    (pos? x) 1\n    (zero? x) 0\n    (neg? x) -1))\n\n\n(defn triangle_type [a b c] \n  (let [[a b c] (sort [a b c])]\n    (if (>= c (+ a b))\n      0\n      (+ 2 (signum (- (* c c) (+ (* a a) (* b b))))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5390bac347d09b7da40006f6":[{"id":15263,"user_id":null,"body":"(ns to_jaden_case)\n\n(require '[clojure.string :as string])\n\n(defn to_jaden_case [s]\n  (->> (string\/split (str s) #\" \") \n       (map string\/capitalize)\n       (string\/join \" \")))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15264,"user_id":null,"body":"(ns to_jaden_case)\n\n(defn to_jaden_case [s]\n  (clojure.string\/replace s #\"(?:^|\\s)\\w\" #(.toUpperCase %)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15265,"user_id":null,"body":"(ns to_jaden_case\n\t(:require [clojure.string :as s]))\n\n(defn to_jaden_case [s]\n\t(->> (s\/split s #\" \")\n       (map s\/capitalize)\n       (interpose \" \")\n       (apply str)))","lang_id":5,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15266,"user_id":null,"body":"(ns to_jaden_case\n  (:require [clojure.string :as str]))\n\n(defn to_jaden_case [s]\n  (->> (str\/split s #\"\\s+\") (map str\/capitalize) (interpose \" \") (apply str)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15267,"user_id":null,"body":"(ns to_jaden_case)\n\n(defn to_jaden_case [s]\n  (->> \n    (clojure.string\/split (str s) #\" \")\n    (map clojure.string\/capitalize)\n    (clojure.string\/join #\" \")))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15268,"user_id":null,"body":"(ns to_jaden_case\n  (:require [clojure.string :as str]))\n\n(defn to_jaden_case\n  \"Converts a normal tweet into a Jaden Smith's tweet (i.e. capitalizes every word)\"\n  [normal_tweet]\n  (let [words (str\/split normal_tweet #\" \")\n        capitalized_words (map str\/capitalize words)\n        jadenized_tweet (str\/join \" \" capitalized_words) ]\n    jadenized_tweet))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15269,"user_id":null,"body":"(ns to_jaden_case)\n\n(defn to_jaden_case [s]\n  (clojure.string\/join #\" \"\n                       (map clojure.string\/capitalize\n                            (clojure.string\/split s #\" \"))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15270,"user_id":null,"body":"(ns to_jaden_case)\n\n(defn to_jaden_case [s]\n   (clojure.string\/join \" \" \n     (map clojure.string\/capitalize (clojure.string\/split s #\" \"))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15271,"user_id":null,"body":"(ns to_jaden_case)\n\n(defn to_jaden_case [s]\n (let\n    [\n        capitalized     (map clojure.string\/capitalize (clojure.string\/split s #\" \"))\n        result          (reduce (fn [x,other] (str x \" \" other)) capitalized)\n    ] result))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15272,"user_id":null,"body":"(ns to_jaden_case\n  (:require [clojure.string :as s]))\n\n(defn to_jaden_case [str]\n  (->> str\n       (re-seq #\"[^\\s]+\")\n       (map s\/capitalize)\n       (s\/join \" \")))\n\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"53934feec44762736c00044b":[{"id":15273,"user_id":3283,"body":"(ns number-toString)\n\n(def a (str 123))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15274,"user_id":null,"body":"(ns number-toString)\n\n(def a \"123\")","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15275,"user_id":null,"body":"(ns number-toString)\n\n(def a (.toString 123))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15276,"user_id":null,"body":"(ns number-toString)\n\n(def toString str)\n\n(def a (-> 123 toString))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15277,"user_id":null,"body":"(ns number-toString)\n\n(def a (str 123))\n\n(println a)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15278,"user_id":null,"body":"(ns number-toString)\n\n(def a (.toString 123))\n\n(println a)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15279,"user_id":null,"body":"(ns number-toString)\n\n;; (def a (.toString 123))\n\n(def a \"123\")\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15280,"user_id":null,"body":"(ns number-toString)\n\n(def a \"123\")\n;(def a (fn [n] \"123\"))\n;(defn a [n] (str n))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15281,"user_id":null,"body":"(ns number-toString)\n\n(def toString str)\n\n(def a (toString 123))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15282,"user_id":null,"body":"(ns number-toString)\n\n(defn toString [n]\n  (str n))\n\n(def a (toString 123))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"53a1eac7e0afd3ad3300008b":[{"id":15283,"user_id":62,"body":"(ns mutual)\n\n(declare m-seq)\n(declare f-seq)\n\n(def f-seq\n  (lazy-cat [1]\n            (map #(->> % (dec) (nth f-seq) (nth m-seq) (- %)) (iterate inc 1)))) \n\n(def m-seq\n  (lazy-cat [0]\n            (map #(->> % (dec) (nth m-seq) (nth f-seq) (- %)) (iterate inc 1))))\n\n(defn m [n] (nth m-seq n))\n(defn f [n] (nth f-seq n))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15284,"user_id":null,"body":"(ns mutual)\n\n(declare f m)\n\n(defn f [n]\n  (if (zero? n) 1 (- n (-> n dec f m))))\n\n(defn m [n] \n  (if (zero? n) 0 (- n (-> n dec m f))))\n\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15285,"user_id":464,"body":"(ns mutual)\n(declare m)\n\n(defn f [n]\n  (if (= n 0) 1 (- n (m (f (- n 1)))))\n)\n\n(defn m [n] \n  (if (= n 0) 0 (- n (f (m (- n 1)))))\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15286,"user_id":null,"body":"(ns mutual)\n\n(declare f)\n\n(defn m [n] \n  (cond \n    (= n 0) 0\n    :else (- n (f (m (dec n))))))\n\n(defn f [n]\n  (cond \n    (= n 0) 1\n    :else (- n (m (f (dec n))))))\n  \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15287,"user_id":null,"body":"(ns mutual)\n\n(declare f)\n\n(def m \n  (memoize\n   (fn [n] (if (zero? n) 0 (- n (f (m (dec n))))))))\n(def f\n  (memoize\n   (fn [n] (if (zero? n) 1 (- n (m (f (dec n))))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15288,"user_id":53,"body":"(ns mutual)\n\n(declare f)\n\n(defn m [n] \n  (if (= 0 n)\n    0\n    (- n (f (m (dec n))))\n    ))\n\n(defn f [n]\n  (if (= 0 n)\n    1\n    (- n (m (f (dec n))))\n    ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15289,"user_id":null,"body":"(ns mutual)\n\n(declare m f)\n\n(defn m [n] \n  (if (zero? n)\n    0\n    (- n (f (m (dec n))))))\n\n(defn f [n]\n  (if (zero? n)\n    1\n    (- n (m (f (dec n))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15290,"user_id":null,"body":"(ns mutual)\n\n(declare m)\n(declare f)\n\n(defn m [n] \n  (if (zero? n)\n    0\n    (- n (f (m (dec n)))))\n)\n\n(defn f [n]\n  (if (zero? n)\n    1\n    (- n (m (f (dec n)))))\n  \n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15291,"user_id":null,"body":"(ns mutual)\n\n(def f)\n\n(defn m [n] \n  (if (= n 0)\n      0\n      (- n (f (m (- n 1)))))\n)\n\n(defn f [n]\n  (if (= n 0)\n      1\n      (- n (m (f (- n 1)))))\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15292,"user_id":null,"body":"(ns mutual)\n\n(declare f)\n(defn m [n] \n  (if (zero? n)\n    0 \n    (- n (f (m (dec n))))))\n\n(defn f [n]\n  (if (zero? n)\n    1 \n    (- n (m (f (dec n))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"53af2b8861023f1d88000832":[{"id":15293,"user_id":3236,"body":"(ns banjo)\n\n(defn are_you_playing_banjo [name]\n  (str name\n    (if (#{\\r \\R} (first name))\n      \" plays banjo\"\n      \" does not play banjo\")))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15294,"user_id":null,"body":"(ns banjo)\n\n(defn are_you_playing_banjo\n  [name]\n  (str name\n       (if (#{\\R \\r} (first name))\n           \" plays\"\n           \" does not play\")\n       \" banjo\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15295,"user_id":null,"body":"(ns banjo)\n\n(defn are_you_playing_banjo\n  [name]\n  (if (or (= (first name) \\r) (= (first name) \\R))\n  (str name \" plays banjo\")\n  (str name \" does not play banjo\"))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15296,"user_id":null,"body":"(ns banjo)\n\n(defn are_you_playing_banjo\n  [name]\n  (format \"%s %s banjo\" name (if (re-find #\"^[Rr]\" name) \"plays\" \"does not play\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15297,"user_id":53,"body":"(ns banjo)\n\n(defn are_you_playing_banjo [name]\n  (let [h (.charAt name 0)]\n    (if (or (= \\r h) (= \\R h))\n      (str name \" plays banjo\")\n      (str name \" does not play banjo\"))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15298,"user_id":null,"body":"(ns banjo)\n\n(defn are_you_playing_banjo\n  [name]\n  (if \n    (clojure.string\/starts-with? name \"r\")\n      (clojure.string\/join \" \" [name \"plays banjo\"])\n      (if \n        (clojure.string\/starts-with? name \"R\")\n        (clojure.string\/join \" \" [name \"plays banjo\"])\n        (clojure.string\/join \" \" [name \"does not play banjo\"])\n      )))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15299,"user_id":null,"body":"(ns banjo)\n\n(defn are_you_playing_banjo\n  [name]\n  ; Implement me!\n  (if (or (= \\r (first name)) (= \\R (first name)))\n    (str name \" plays banjo\")\n    (str name \" does not play banjo\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15300,"user_id":2301,"body":"(ns banjo)\n\n(defn are_you_playing_banjo\n  [[first-letter & _ :as name]]\n  (if (#{\\R \\r} first-letter)\n      (str name \" plays banjo\")\n      (str name \" does not play banjo\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15301,"user_id":null,"body":"(ns banjo)\n\n(defn are_you_playing_banjo\n  [name]\n  (def name-starts-with-r \n    (or \n      (= (str (first name)) \"R\")\n      (= (str (first name)) \"r\")))\n  \n  (def should-play name-starts-with-r)\n  (if should-play\n    (str name \" plays banjo\")\n    (str name \" does not play banjo\"))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15302,"user_id":null,"body":"(ns banjo)\n\n(defn are_you_playing_banjo\n  [name]\n  (if (contains? (set [\\R \\r]) (first name))\n      (str name \" plays banjo\")\n      (str name \" does not play banjo\"))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"53da3dbb4a5168369a0000fe":[{"id":15303,"user_id":2719,"body":"(ns kata)\n\n(defn even_or_odd [number]\n  (if (even? number) \"Even\" \"Odd\")\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15304,"user_id":null,"body":"(ns kata)\n\n(defn even_or_odd [number]\n  (if (odd? number) \"Odd\" \"Even\")\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15305,"user_id":null,"body":"(ns kata)\n\n(defn even_or_odd [n]\n  (if (even? n) \"Even\" \"Odd\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15306,"user_id":null,"body":"(ns kata)\n\n(defn even_or_odd [number]\n  (condp = (mod number 2)\n  \t0 \"Even\"\n    1 \"Odd\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15307,"user_id":null,"body":"(ns kata)\n\n(defn even_or_odd\n  \"return whether number is even or odd\"\n  [number]\n  (if (even? number)\n    \"Even\"\n    \"Odd\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15308,"user_id":null,"body":"(ns kata)\n\n(defn even_or_odd [number]\n  (if (= 0 (mod number 2))\n    \"Even\"\n    \"Odd\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15309,"user_id":null,"body":"(ns kata)\n\n(defn even_or_odd [number]\n\t(if (= (mod number 2) 0)\n    \"Even\" \"Odd\")\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15310,"user_id":null,"body":"(ns kata)\n\n(defn even_or_odd [number]\n  (or (and (odd? number) \"Odd\")\n      (and (even? number) \"Even\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15311,"user_id":null,"body":"(ns kata)\n\n(defn even_or_odd [number]\n  ([\"Even\" \"Odd\"] (bit-and number 1)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15312,"user_id":null,"body":"(ns kata)\n\n;; Okay, let's go literal.\n(defn even_or_odd\n  \"Returns 'Even' if the number is even; odd otherwise.\"\n  [number]\n  (get {true \"Even\"} (even? number) \"Odd\")\n  )\n\n;; Aight. I suppose even? is cheating.\n(defn even_or_odd\n  \"Returns 'Even' if the number is even; odd otherwise.\"\n  [number]\n  (get {0 \"Even\"} (mod number 2) \"Odd\"))\n\n;; Maybe this is clearer.\n(defn even_or_odd\n  \"Returns 'Even' if the number is even; odd otherwise.\"\n  [number]\n  (get {0 \"Even\"}\n    (reduce + (map #(* (first %) (second %))\n                (partition 2 (interleave (iterate #(* % -1) 1)\n                               (repeat (Math\/abs number) 1)))))\n    \"Odd\"))\n\n;; Oh well.\n(defn even_or_odd\n  \"Returns 'Even' if the number is even; odd otherwise.\"\n  [number]\n  (get {1 \"Even\"} (int (Math\/pow -1 number)) \"Odd\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"53db96041f1a7d32dc0004d2":[{"id":15313,"user_id":571,"body":"(ns sudoku)\n(defn done_or_not [board]\n  (if (every? #(= (sort %) (range 1 10))\n    (concat board\n    (partition 9 (apply interleave board))\n    (map flatten (partition 3 (apply interleave (map #(partition 3 %) board)))))) \"Finished!\" \"Try again!\"))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15314,"user_id":53,"body":"(ns sudoku)\n\n(defn cell [board i j] (nth (nth board i) j))\n\n(defn check-sum [board i]\n  (loop [sum 0 j 0]\n    (if (> j 8)\n      sum\n      (let [row (cell board i j)\n            col (cell board j i)\n            box (cell board (+ (* 3 (mod i 3)) (mod j 3)) (+ (* 3 (quot i 3)) (quot j 3)))\n            next-sum (+' sum row col box)]\n        (recur next-sum (inc j))))))\n\n(defn done_or_not [board]\n  (loop [i 0]\n    (cond\n      (> i 8) \"Finished!\"\n      (not= 135 (check-sum board i)) \"Try again!\"\n      :else (recur (inc i)))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15315,"user_id":null,"body":"(ns sudoku)\n\n(defn valid? [nums]\n  (let [f (frequencies (flatten nums))]\n    (every? #(= 1 (f %)) (range 1 10))))\n\n(defn columns [board] (apply map vector board))\n\n(defn squares [board]\n  (->> board\n    (map #(partition 3 %))\n    (apply interleave)\n    (partition 3)\n    (map flatten)))\n\n(defn valid-board? [board]\n  (->> board\n    ((juxt identity columns squares))\n    (apply concat)\n    (every? valid?)))\n  \n\n(defn done_or_not [board]\n (if (valid-board? board) \"Finished!\" \"Try again!\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15316,"user_id":null,"body":"(ns sudoku)\n(defn done_or_not [board]\n  (let [incorrect-lines? (contains? (set (map #(apply distinct? %) (map vec board))) false)\n        incorrect-columns? (contains? (set (map #(apply distinct? %) (apply mapv vector board))) false)]\n    \n    (if (or incorrect-lines? incorrect-columns?)\n      \"Try again!\"\n      \"Finished!\"\n      ))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15317,"user_id":null,"body":"(ns sudoku)\n\n(defn done_or_not [board]\n  (if (empty? (filter (partial not= 45) (apply mapv + board)))\n    \"Finished!\"\n    \"Try again!\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15318,"user_id":null,"body":"(ns sudoku)\n(defn set= [& vectors] (apply = (map set vectors)))\n\n(defn done_or_not [board]\n\n  (let [good  (into [] (range 1 10))\n        vert  (partition 9 (apply interleave board))\n        small (->> board\n                   (partition 3)\n                   (map #(apply interleave %))\n                   flatten\n                   (partition 9))]\n    (if (and (every? #(set= % good) board)\n             (every? #(set= % good) vert)\n             (every? #(set= % good) small))\n      \"Finished!\"\n      \"Try again!\")\n    ))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15319,"user_id":null,"body":"(ns sudoku\n  (:require [clojure.zip :as zip]))\n\n(def expected-values #{1 2 3 4 5 6 7 8 9})\n\n(defn- get-region\n  [row col]\n  [(quot row 3) (quot col 3)])\n\n(defn- mark-square\n  [marked row col val]\n  (-> marked\n      (update-in [:rows row] #(conj (or % #{}) val))\n      (update-in [:cols col] #(conj (or % #{}) val))\n      (update-in [:regions (get-region row col)] #(conj (or % #{}) val))))\n\n(defn- at-top\n  [z]\n  (nil? (-> z (zip\/up) (zip\/up))))\n\n(defn- at-end\n  [z]\n  (and\n    (at-top z)\n    (nil? (zip\/right z))))\n\n(defn- record-squares\n  [board]\n  (loop [z (-> board (zip\/vector-zip) (zip\/down) (zip\/down))\n         row 0\n         col 0\n         marked {:rows {} :cols {} :regions {}}]\n    (cond\n      (at-end z) marked\n      (at-top z) (recur (-> z (zip\/right) (zip\/down))\n                        (inc row)\n                        0\n                        marked)\n      (nil? (zip\/right z)) (recur (zip\/up z)\n                                  row\n                                  col\n                                  (mark-square marked row col (zip\/node z)))\n      :else (recur (zip\/right z)\n                   row\n                   (inc col)\n                   (mark-square marked row col (zip\/node z))))))\n\n(defn- is-valid\n  [result]\n  (->> result\n       vals\n       (map vals)\n       flatten\n       (every? #(= % expected-values))))\n\n(defn done_or_not [board]\n  (-> board\n      record-squares\n      is-valid\n      (if \"Finished!\" \"Try again!\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15320,"user_id":null,"body":"(ns sudoku)\n\n(def zip (partial map vector))\n\n(defn done_or_not [board]\n  (let [rows board\n        columns (apply zip board)\n        regions (->> board\n                     (map (partial partition 3))\n                     (apply zip)\n                     (flatten)\n                     (partition 9))\n        allowed (set (range 1 10))]\n    (if (apply = allowed (map set (concat rows columns regions)))\n      \"Finished!\"\n      \"Try again!\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15321,"user_id":null,"body":"(ns sudoku)\n(defn checkset [setseq]\n  (->> setseq\n       (map sort)\n       (map #(= (range 1 10) %))\n       (every? true?)))\n\n(defn done_or_not [board]\n  (if (every? true? [(checkset board)\n                 (checkset (->> (for [col (range 9)]\n                                  (map #(nth % col) board))))\n                 (->> (for [gx (range 0 9 3)\n                            gy (range 0 9 3)]\n                        (for [x (range gx (+ 3 gx))\n                              y (range gy (+ 3 gy))]\n                          [x y]))\n                      (map (fn [xys] (map #(get-in board %) xys)))\n                      (checkset))])\n    \"Finished!\"\n    \"Try again!\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15322,"user_id":null,"body":"(ns sudoku)\n(defn is-valid-line? [line]\n  (= ((comp vec sort) line) [1 2 3 4 5 6 7 8 9]))\n\n(defn get-region-idx [x y]\n  (vec\n    (for [x-idx (range (* 3 x) (* 3 (+ x 1)))\n          y-idx (range (* 3 y) (* 3 (+ y 1)))]\n      (list x-idx y-idx))))\n\n(defn get-region [x y board]\n  (map (partial apply #(nth (nth board %1) %2)) (get-region-idx x y)))\n\n(defn done_or_not [board]\n  (let [row-valid (every? is-valid-line? board)\n        column-valid (every? is-valid-line? (map (fn [idx] (map #(nth % idx) board)) (range 9)))\n        region-valid (every? is-valid-line? (map (partial apply #(get-region %1 %2 board)) (for [x (range 3)\n                                                                                                 y (range 3)]                                                                    (list x y))))]\n    (if (and row-valid column-valid region-valid)\n      \"Finished!\"\n      \"Try again!\"))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"53dc54212259ed3d4f00071c":[{"id":15323,"user_id":null,"body":"(ns Sum)\n\n(def sum_array (partial reduce +))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15324,"user_id":2966,"body":"(ns Sum)\n\n(defn sum_array\n  [a]\n  (reduce + a))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15325,"user_id":null,"body":"(ns Sum)\n\n(defn sum_array [a]\n  (apply + a)\n  )","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15326,"user_id":null,"body":"(ns Sum)\n\n(defn sum_array\n  [a]\n  (reduce + 0 a)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15327,"user_id":null,"body":"(ns Sum)\n\n(defn sum_array\n\"Write a method sum (sum_array in python) that takes an\narray of numbers and returns the sum of the numbers. These \nmay be integers or decimals for Ruby and any instance of Num \nfor Haskell. The numbers can also be negative. If the array does\nnot contain any numbers then you should return 0.\"\n  [a]\n  (reduce + a))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15328,"user_id":null,"body":"(ns Sum)\n\n(defn sum_array\n  [a]\n  (if (= (count a) 0) 0 (+ (first a) (sum (rest a))))\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15329,"user_id":null,"body":"(ns Sum)\n\n(defn sum_array [values]\n  (apply + values))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15330,"user_id":53,"body":"(ns Sum)\n\n(defn sum_array [ls] (reduce + 0 ls))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15331,"user_id":null,"body":"(ns Sum)\n\n(defn sum_array\n    [a]\n    (if (> (count a) 0)\n    (reduce + a)\n    0))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15332,"user_id":null,"body":"(ns Sum)\n\n(defn sum_array\n  [a]\n  ; TODO\n  (reduce + a)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"53ee5429ba190077850011d4":[{"id":15333,"user_id":null,"body":"(ns double_integer)\n\n(defn double_integer [i]\n  (* 2 i)\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15334,"user_id":null,"body":"(ns double_integer)\n\n(def double_integer (partial * 2))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15335,"user_id":null,"body":"(ns double_integer)\n\n(defn double_integer [i]\n\t(+ i i))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15336,"user_id":null,"body":"(ns double_integer)\n\n(defn double_integer [i]\n  \"doubles an integer\"\n  (* 2 i)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15337,"user_id":null,"body":"(ns double_integer)\n\n(defn double_integer\n  [i]\n  (+ i i))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15338,"user_id":null,"body":"(ns double_integer)\n\n;; I couldn't remember the formula for doubling a number, but this appears to\n;; come close.\n(defn double_integer [i]\n  (let [j (Math\/abs i)]\n    (if (zero? j) 0\n      (* (if (neg? i) -1 1)\n        j (\/ (* j j) (- (apply + (range 1 (inc j))) (\/ j 2))))))\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15339,"user_id":null,"body":"(ns double_integer)\n\n(defn double_integer [i]\n  (bit-shift-left i 1)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15340,"user_id":null,"body":"(ns double_integer)\n\n(def double_integer #(+ % %))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15341,"user_id":null,"body":"(ns double_integer)\n\n(def half (fn [n] (\/ n 2)))\n\n(defn double_integer [i] (+ (half i)\n                            (* 3 (half i))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15342,"user_id":null,"body":"(ns double_integer)\n\n(defn double_integer [i]\n  (let [doubled-int (* i 2)]\n    doubled-int)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"540c33513b6532cd58000259":[{"id":15343,"user_id":2556,"body":"(ns summation)\n(def sum +)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15344,"user_id":null,"body":"(ns summation)\n\n(defn sum\n  \"Finds the sum of all of its arguments\"\n  [& numbers]\n  (reduce + numbers)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15345,"user_id":null,"body":"(ns summation)\n\n(defn sum\n  \"Finds the sum of all of its arguments\"\n  [& args]\n  (apply + args)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15346,"user_id":null,"body":"(ns summation)\n\n(defn sum\n  \"Finds the sum of all of its arguments\"\n  [& nums]\n  (apply + nums))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15347,"user_id":null,"body":"(ns summation)\n\n(defn sum\n  \"Finds the sum of all of its arguments\"\n   [& args]\n   (->> args\n   (reduce +))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15348,"user_id":2851,"body":"(ns summation)\n\n(def sum #(apply + %&))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15349,"user_id":null,"body":"(ns summation)\n\n(defn sum \n  ([] 0) \n  ([& args] (reduce + args))\n     ; TODO: Program me\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15350,"user_id":null,"body":"(ns summation)\n\n(defn sum [& args]\n  \"Finds the sum of all of its arguments\"\n  ; TODO: Program me\n  (reduce + args)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15351,"user_id":null,"body":"(ns summation)\n\n(defn sum[& args]\n  \"Finds the sum of all of its arguments\"\n   (reduce + args)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15352,"user_id":null,"body":"(ns summation)\n\n(defn sum [& args]\n  \"Finds the sum of all of its arguments\"\n  (apply + args)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"540de1f0716ab384b4000828":[{"id":15353,"user_id":2556,"body":"(ns unpack)\n\n(def spread apply)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15354,"user_id":null,"body":"(ns unpack)\n\n(defn spread\n  [func, args]\n  (apply func args)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15355,"user_id":null,"body":"(ns unpack)\n\n;; Isn't this just...\n(def spread apply)\n\n;; Yeah, okay. So if we were doing it from scratch, we could progressively build it up...\n(defn spread\n  [func args]\n  (if (empty? args)\n    (func)\n    (spread (partial func (first args)) (rest args)))\n  )\n\n;; And of course we could make that tail-recursive...\n(defn spread\n  [func args]\n  (if (empty? args)\n    (func)\n    (recur (partial func (first args)) (rest args)))\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15356,"user_id":null,"body":"(ns unpack)\n\n(defn spread\n  [func, args]\n  (eval (cons func args)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15357,"user_id":null,"body":"(ns unpack)\n\n(defn spread\n  [func, args]\n  ; apply that sh*t\n  (apply func args)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15358,"user_id":null,"body":"(ns unpack)\n\n(def spread apply)\n  ;[f args]\n  ;(apply f args))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15359,"user_id":null,"body":"(ns unpack)\n\n(defn spread [f a] (apply f a))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15360,"user_id":null,"body":"(ns unpack)\n\n(defn spread\n  [func, args]\n  (cond\n    (empty? args) (func)\n    :else (spread (partial func (first args)) (rest args))\n    )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15361,"user_id":null,"body":"(ns unpack)\n;Copied from someone else's solution that did not simply use apply. \n;This approach uses Currying so in the case where (spread + [ 1 2 3])\n; we get (spread (partial + 1) [ 2 3 ] )\n;        (spread (partial (partial + 1) 2) [3])\n;        (spread (partial (partial (partial + 1) 2) 3) [])\n;        ( + (partial (partial (partial + 1) 2) 3))\n(defn spread\n  [func, args]\n  (if (empty? args)\n  (func)\n  (spread (partial func (first args))(rest args)))\n  ; ...\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15362,"user_id":null,"body":"(ns unpack)\n\n(def spread apply) ; lol","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"540f8a19a7d43d24ac001018":[{"id":15363,"user_id":null,"body":"(ns term)\n\n(defn nth-term\n  [n0 idx c]\n  (+ n0 (* c idx)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15364,"user_id":null,"body":"(ns term)\n\n(defn nth-term\n\t[first n c]\n  (+ first (* n c)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15365,"user_id":null,"body":"(ns term)\n\n(defn nth-term [f n c]\n  (+ f (* n c)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15366,"user_id":null,"body":"(ns term)\n\n(defn nth-term\n  [first, n, c]\n  (nth (iterate (partial + c) first) n))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15367,"user_id":null,"body":"(ns term)\n\n(defn nth-term [first n c]\n  (+ (* n c) first))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15368,"user_id":null,"body":"(ns term)\n\n;; I think this one's pretty straightforward.\n(defn nth-term\n  [f n c]\n  (+ f (* n c))\n  )\n\n;; But I suppose we could do it lazily.\n(defn nth-term\n  [f n c]\n  (nth (iterate (partial + c) f) n)\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15369,"user_id":null,"body":"(ns term)\n\n(defn nth-term [a n c]\n  (->> n (* c) (+ a))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15370,"user_id":3076,"body":"(ns term)\n\n(def nth-term #(+ %1 (* %2 %3)) )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15371,"user_id":null,"body":"(ns term)\n\n(defn nth-term [id n c]\n  ; start + (constant * index)\n  (+ id (* c n))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15372,"user_id":null,"body":"(ns term)\n\n(defn nth-term [f, n, c]\n  (cond\n    (< c 0) (nth (range f Integer\/MIN_VALUE c) n)\n    (> c 0) (nth (range f Integer\/MAX_VALUE c) n)\n    :else \"zero\"))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5410c0e6a0e736cf5b000e69":[{"id":15373,"user_id":null,"body":"(ns Hamming)  \n\n(defn hamming\n  [a b]\n  (count (filter false? (map = a b)))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15374,"user_id":3218,"body":"(ns Hamming)  \n\n(defn hamming\n  [a b]\n  (reduce + (map #(if (= %1 %2) 0 1) a b)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15375,"user_id":null,"body":"(ns Hamming)  \n\n(defn hamming\n  [a b]\n  (->> (map not= a b) (filter identity) count))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15376,"user_id":null,"body":"(ns Hamming)  \n\n(defn hamming\n  [a b]\n  (count (filter true? (map (partial reduce not=) (map vector a b))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15377,"user_id":null,"body":"(ns Hamming)  \n\n(defn hamming\n  [a b]\n  (apply + (map #(if (= %1 %2) 0 1) a b)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15378,"user_id":null,"body":"(ns Hamming)  \n\n(defn hamming\n  [a b]\n  (let [distances (map (fn [char1 char2]\n                         (if (= char1 char2)\n                           0 1))\n                       a b)]\n\n    (reduce + distances)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15379,"user_id":null,"body":"(ns Hamming)  \n\n(defn hamming [s1 s2]\n  (reduce + \n          (filter some? \n                  (for [i (range (count s1))]\n                    (when-not (= (nth s1 i) (nth s2 i)) 1)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15380,"user_id":53,"body":"(ns Hamming)  \n\n(defn hamming [a b]\n  (let [ac (seq (char-array a))\n        bc (seq (char-array b))]\n    (loop [m 0 xs ac ys bc]\n      (cond\n        (or (empty? xs) (empty? ys)) m\n        (not= (first xs) (first ys)) (recur (inc m) (rest xs) (rest ys))\n        :else (recur m (rest xs) (rest ys))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15381,"user_id":null,"body":"(ns Hamming)  \n\n(defn hamming [a b]\n  (reduce\n   (fn [c [x y]]\n     (cond-> c (not= x y) inc))\n   0\n   (map vector a b)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15382,"user_id":null,"body":"(ns Hamming\n  (:require [clojure.data :refer [diff]]))  \n\n(defn hamming\n  [a b]\n  (let [[a b _] (diff (seq a) (seq b))]\n    (count (remove nil? (map #(or %1 %2) a b)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5413759479ba273f8100003d":[{"id":15383,"user_id":null,"body":"(ns reverse\n  (:refer-clojure :exclude [reverse]))\n\n(defn reverse\n  \"Reverse a list\"\n  [lst]\n  (into () lst)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15384,"user_id":null,"body":"(ns reverse\n  (:refer-clojure :exclude [reverse]))\n\n(defn reverse\n  \"Reverse a list\"\n  [lst]\n  (reduce (fn [x y] (cons y x)) [] lst)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15385,"user_id":2301,"body":"(ns reverse\n  (:refer-clojure :exclude [reverse]))\n\n(defn reverse [lst]\n  (reduce conj () lst))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15386,"user_id":null,"body":"(ns reverse\n  (:refer-clojure :exclude [reverse]))\n\n(def reverse (partial into ()))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15387,"user_id":null,"body":"(ns reverse\n  [:refer-clojure :exclude [reverse]])\n\n(def reverse clojure.core\/reverse)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15388,"user_id":null,"body":"(ns reverse\n  (:refer-clojure :exclude [reverse]))\n\n(defn reverse\n  \"Reverse a list\"\n  [lst]\n  (reduce #(cons %2 %1) '() lst)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15389,"user_id":null,"body":"(ns reverse\n  (:refer-clojure :exclude [reverse]))\n\n(defn reverse\n  \"Reverse a list\"\n  [lst]\n  (clojure.core\/reverse lst)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15390,"user_id":null,"body":"(ns reverse\n  (:refer-clojure :exclude [reverse]))\n\n(def reverse #(into () %))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15391,"user_id":null,"body":"(ns reverse\n  (:refer-clojure :exclude [reverse]))\n\n(defn reverse\n  \"Reverse a list\"\n  [lst]\n  (if (empty? lst) lst (cons (last lst) (reverse (butlast lst)) )))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15392,"user_id":null,"body":"(ns reverse\n  (:refer-clojure :exclude [reverse]))\n\n(def reverse (partial reduce conj ()))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"541629460b198da04e000bb9":[{"id":15393,"user_id":null,"body":"(ns last \n  (:refer-clojure :exclude [last]))\n            \n(defn last\n  \"Returns the last element of an ISeq\"\n  [lst]\n  (first (reverse lst)))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15394,"user_id":2556,"body":"(ns last \n  (:refer-clojure :exclude [last]))\n            \n(defn last\n  [[n & more]]\n  (if more\n    (recur more)\n    n))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15395,"user_id":null,"body":"(ns last \n  (:refer-clojure :exclude [last]))\n            \n(def last\n  (comp first reverse))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15396,"user_id":null,"body":"(ns last \n  (:refer-clojure :exclude [last]))\n            \n(def last clojure.core\/last)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15397,"user_id":null,"body":"(ns last \n  (:refer-clojure :exclude [last]))\n            \n(defn last\n  \"Returns the last element of an ISeq\"\n  [lst]\n  (-> lst reverse first))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15398,"user_id":null,"body":"(ns last \n  (:refer-clojure :exclude [last]))\n            \n(defn last\n  \"Returns the last element of an ISeq\"\n  [lst]\n  (first (into () lst))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15399,"user_id":null,"body":"(ns last \n  (:refer-clojure :exclude [last]))\n            \n(defn last\n  \"Returns the last element of an ISeq\"\n  [lst]\n  (peek (vec lst))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15400,"user_id":null,"body":"(ns last \n  (:refer-clojure :exclude [last]))\n            \n(defn last\n  \"Returns the last element of an ISeq\"\n  [lst]\n  (loop [[head & tail] lst]\n    (cond \n      (empty? tail) head\n      (not (empty? tail)) (recur tail))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15401,"user_id":null,"body":"(ns last \n  (:refer-clojure :exclude [last]))\n            \n(defn last [xs] \n  (if-let [ys (seq (rest xs))]\n    (recur ys)\n    (first xs)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15402,"user_id":null,"body":"(ns last \n  (:refer-clojure :exclude [last]))\n            \n(defn last\n  \"Returns the last element of an ISeq\"\n  [lst]\n  (let\n    [len (count lst)]\n    (if\n      (zero? len)\n      nil\n      (nth lst (dec len)))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"54162d1333c02486a700011d":[{"id":15403,"user_id":null,"body":"(ns penultimate)\n\n(def penultimate\n  (comp second reverse))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15404,"user_id":null,"body":"(ns penultimate)\n\n(defn penultimate\n  \"Gets the second to last element of an ISeq\"\n  [lst]\n  (nth lst (- (count lst) 2))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15405,"user_id":2556,"body":"(ns penultimate)\n\n(defn penultimate\n  \"Gets the second to last element of an ISeq\"\n  [lst]\n  (second (reverse lst))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15406,"user_id":null,"body":"(ns penultimate)\n\n(defn penultimate\n  \"Gets the second to last element of an ISeq\"\n  [lst]\n  (first (take-last 2 lst)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15407,"user_id":2556,"body":"(ns penultimate)\n\n(def penultimate (comp last drop-last) )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15408,"user_id":2556,"body":"(ns penultimate)\n\n(defn penultimate\n  [lst]\n  (-> lst\n      drop-last\n      last)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15409,"user_id":null,"body":"(ns penultimate)\n\n(defn penultimate\n  \"Gets the second to last element of an ISeq\"\n  [lst]\n  (last (butlast lst))\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15410,"user_id":null,"body":"(ns penultimate)\n\n(defn penultimate\n  \"Gets the second to last element of an ISeq\"\n  [lst]\n  (-> lst butlast last); TODO: Program Me\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15411,"user_id":2556,"body":"(ns penultimate)\n\n(defn penultimate\n  \"Gets the second to last element of an ISeq\"\n  [lst]\n  (->> lst (reverse) (drop 1) (first))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15412,"user_id":2301,"body":"(ns penultimate)\n\n(def penultimate (comp last butlast))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5416356b1b28a5e297000bc7":[{"id":15413,"user_id":null,"body":"(ns element-at)\n            \n(defn element-at\n \"Find the K'th element of an ISeq\"\n [xs k]\n (nth xs (dec k)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15414,"user_id":null,"body":"(ns element-at)\n            \n(defn element-at\n \"Find the K'th element of an ISeq\"\n [list n]\n (nth list (- n 1))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15415,"user_id":null,"body":"(ns element-at)\n            \n(defn element-at\n \"Find the K'th element of an ISeq\"\n [lst n]\n (nth lst (dec n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15416,"user_id":2556,"body":"(ns element-at)\n            \n(defn element-at\n  [lst n]\n  (->> lst\n       (drop (- n 1))\n       (first)) \n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15417,"user_id":null,"body":"(ns element-at)\n            \n(defn element-at\n \"Find the K'th element of an ISeq\"\n [lst n]\n (if (= n 1)\n   (first lst)\n   (recur (rest lst) (dec n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15418,"user_id":2053,"body":"(ns element-at)\n\n(defn element-at [lst n]\n  (if (= n 1)\n    (first lst)\n    (element-at (drop 1 lst) (- n 1))\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15419,"user_id":null,"body":"(ns element-at)\n            \n(defn element-at\n \"Find the K'th element of an ISeq\"\n [lst n]\n  (->> lst (take n) last))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15420,"user_id":null,"body":"(ns element-at)\n            \n(defn element-at\n \"Find the K'th element of an ISeq\"\n [lst n]\n (if (= 1 n)\n   (first lst)\n   (recur (rest lst) (dec n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15421,"user_id":2301,"body":"(ns element-at)\n            \n(defn element-at [lst n] (-> lst (nthrest (dec n)) first))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15422,"user_id":null,"body":"(ns element-at)\n            \n(defn element-at\n \"Find the K'th element of an ISeq\"\n [lst n]\n (if (< 1 n) (recur (rest lst) (dec n))\n   (first lst))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5417423f9e2e6c2f040002ae":[{"id":15423,"user_id":2537,"body":"(ns kata)\n\n(defn digitize\n  [n]\n  (map #(Integer. (str %)) (str n))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15424,"user_id":null,"body":"(ns kata)\n\n(defn digitize [n]\n  (map (comp read-string str) (str n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15425,"user_id":null,"body":"(ns kata)\n\n(defn digitize\n  [n]\n  (map #(Character\/getNumericValue %) (str n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15426,"user_id":null,"body":"(ns kata)\n\n(defn digitize\n  [n]\n  (if (< n 10)\n    (conj '[] n)\n    (conj (digitize (quot n 10)) (rem n 10))\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15427,"user_id":2301,"body":"(ns kata\n (:refer-clojure :exclude [read-string])\n (:require [clojure.edn :refer [read-string]]))\n\n(defn digitize\n  [n]\n  (map (comp read-string str) (str n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15428,"user_id":null,"body":"(ns kata)\n\n(defn digitize [n]\n\t(->> n\n  \tstr\n    (map #(Character\/getNumericValue %))\n    vec))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15429,"user_id":null,"body":"(ns kata)\n\n(defn digitize\n  [n]\n  (->> (str n) (map #(Character\/getNumericValue %))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15430,"user_id":2967,"body":"(ns kata)\n\n(defn digitize\n  [n]\n  seq (map #(Character\/digit % 10) (str n))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15431,"user_id":null,"body":"(ns kata)\n\n(defn digitize\n  [n]\n  (->> (str n)\n  \t\t seq\n       (map str)\n       (map #(Integer. %))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15432,"user_id":null,"body":"(ns kata)\n\n(defn digitize\n  [n]\n  (map (comp (fn [x] (- x  48)) int) (str n))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"541c8630095125aba6000c00":[{"id":15433,"user_id":2556,"body":"(ns digital_root)\n\n(defn digital_root [n]\n  (if (> n 0) (+ 1 (mod (- n 1) 9)) 0)\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15434,"user_id":null,"body":"(ns digital_root)\n\n(defn digital_root [n]\n  (if (< n 10) \n    n\n    (recur (apply + (map #(Character\/digit % 10) (str n))))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15435,"user_id":null,"body":"(ns digital_root)\n\n(defn sum-digit [x] (reduce + (map #(Integer. (str %)) (str x))))\n\n(defn digital_root [n]\n\t(if (< n 10) n\n  \t(digital_root (sum-digit n))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15436,"user_id":null,"body":"(ns digital_root)\n\n(defn digitize [n]\n  (map (comp read-string str) (str n)))\n\n(defn digital_root [n]\n  (if (< n 10) n (digital_root (apply + (digitize n)))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15437,"user_id":null,"body":"(ns digital_root)\n\n(defn digital_root [n]\n  (inc (rem (dec n) 9))\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15438,"user_id":3236,"body":"(ns digital_root)\n\n(defn digital_root [n]\n  (loop [source n]\n    (let [root (reduce + (map #(Integer. (str %)) (str source)))]\n      (if (< root 10)\n        root\n        (recur root)))))\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15439,"user_id":null,"body":"(ns digital_root)\n\n(defn digital_root [n] \n   (if (= n 0) \n     0 \n     (+ 1 (mod (- n 1) 9)))\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15440,"user_id":null,"body":"(ns digital_root)\n\n(defn digits [number] \n  (loop [n number\n         digs []] \n    (if (zero? n) \n      digs \n      (recur (quot n 10)  \n             (conj digs (rem n 10))))))\n\n(defn digital_root [n]\n  (loop [res n]\n    (if (< res 10)\n      res\n      (recur (apply + (digits res))))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15441,"user_id":null,"body":"(ns digital_root)\n\n(defn sum-of-digits\n  [n]\n  (->> n\n       (iterate #(quot % 10))\n       (take-while pos?)\n       (map #(rem % 10))\n       (reduce +)))\n\n(defn digital_root\n  [n]\n  (->> n\n       (iterate sum-of-digits)\n       (drop-while (partial <= 10))\n       (first)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15442,"user_id":null,"body":"(ns digital_root)\n\n(defn digital_root [n]\n  (if (> n 9)\n    (digital_root (->> n\n       (iterate #(quot % 10))\n       (take-while pos?)\n       (mapv #(mod % 10))\n       (reduce +)))\n    n))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"541da001259d9ca85d000688":[{"id":15443,"user_id":null,"body":"(ns seqlist)\n\n(defn seqlist\n  \"Generates consecutive terms in a sequence\"\n  [first c terms]\n  (take terms (iterate (partial + c) first))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15444,"user_id":null,"body":"(ns seqlist)\n;Author: Geem7n\n(defn seqlist\n  \"Generates consecutive terms in a sequence\"\n  [first c terms]\n(take terms (iterate (partial + c) first)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15445,"user_id":null,"body":"(ns seqlist)\n\n(defn seqlist\n  \"Generates consecutive terms in a sequence\"\n  [first c terms]\n  (take terms (iterate #(+ c %) first)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15446,"user_id":null,"body":"(ns seqlist)\n\n(defn seqlist [first c terms]\n  (->> (range terms)\n       (map #(* c %))\n       (map #(+ first %)))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15447,"user_id":null,"body":"(ns seqlist)\n\n(defn seqlist\n  \"Generates consecutive terms in a sequence\"\n  [first c terms]\n  (map \n    (fn [term] (+ (* term c) first))\n    (range terms)\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15448,"user_id":53,"body":"(ns seqlist)\n\n(defn go [first c] (cons first (lazy-seq (go (+ first c) c))))\n(defn seqlist [first c terms] (take terms (go first c)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15449,"user_id":null,"body":"(ns seqlist)\n\n(defn seqlist [start step end]\n    (let [end2 (+ start (* step end))]\n      (range start end2 step)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15450,"user_id":null,"body":"(ns seqlist)\n\n(defn seqlist\n  \"Generates consecutive terms in a sequence\"\n  [f c terms]\n  (map #(+ f (* % c)) (range terms)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15451,"user_id":null,"body":"(ns seqlist)\n\n(defn seqlist\n  \"Generates consecutive terms in a sequence\"\n  [init constant how-many]\n  (loop [acc [init] prev (+ constant init) remaining (dec how-many)]\n    (if (zero? remaining)\n      acc\n      (recur (conj acc prev) (+ constant prev) (dec remaining)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15452,"user_id":null,"body":"(ns seqlist)\n\n(defn seqlist\n  \"Generates consecutive terms in a sequence\"\n  [first c terms]\n  (loop [n first\n         res []]\n    (if (= n (+ first (* c (dec terms))))\n      (conj res n)\n      (recur (+ n c) (conj res n)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5420fc9bb5b2c7fd57000004":[{"id":15453,"user_id":null,"body":"(ns highest_rank)\n\n(defn highest_rank \n  \"Returns the most frequent entry in the data ISeq\"\n  [data]\n  (->> data frequencies (sort-by val) last key))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-26 09:15:39"},{"id":15454,"user_id":null,"body":"(ns highest_rank)\n\n(defn highest_rank \n  \"Returns the most frequent entry in the data ISeq\"\n  [data]\n  (->> data\n  \t\t frequencies\n       (apply max-key val)\n       key)\n)","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-26 09:15:34"},{"id":15455,"user_id":null,"body":"(ns highest_rank)\n\n\n(defn highest_rank \n  \"Returns the most frequent entry in the data ISeq\"\n  [data]\n  (->> data\n     frequencies\n     (sort-by (juxt val key))\n     last first)\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-26 09:15:57"},{"id":15456,"user_id":null,"body":"(ns highest_rank)\n\n(defn highest_rank \n  \"Returns the most frequent entry in the data ISeq\"\n  [data]\n  (key (last (sort-by val (frequencies data)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15457,"user_id":null,"body":"(ns highest_rank)\n\n(defn highest_rank \n  \"Returns the most frequent entry in the data ISeq\"\n  [data]\n  (->> data frequencies (sort-by val >=) ffirst))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15458,"user_id":null,"body":"(ns highest_rank)\n\n(defn highest_rank [data]\n  (let\n    [\n     freqs     (frequencies data)\n     sorteds   (sort-by #(second %) freqs)\n     maxfreq   (second (last sorteds))\n     elems     (filter #(= (second %) maxfreq) sorteds)\n     bestelems (sort-by #(first %) elems)\n     ] (first (last bestelems)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15459,"user_id":null,"body":"(ns highest_rank)\n\n(defn highest_rank \n  \"Returns the most frequent entry in the data ISeq\"\n  [data]\n  (as-> data $\n    (frequencies $)\n    (sort-by val $)\n    (reverse $)\n    (first $)\n    (key $))\n  ; TODO: Program Me\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15460,"user_id":null,"body":"(ns highest_rank)\n\n(defn highest_rank [data]\n  (->> data\n       (frequencies) (sort-by last) (keys) (last)))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15461,"user_id":null,"body":"(ns highest_rank)\n\n(defn highest_rank\n  \"Returns the most frequent entry in the data ISeq\"\n  [data]\n  (->> (frequencies data)\n       (sort (fn [coll1 coll2]\n               (let [v1 (nth coll1 0)\n                     freq1 (nth coll1 1)\n                     v2 (nth coll2 0)\n                     freq2 (nth coll2 1)]\n                 (cond\n                   (< freq1 freq2) 1\n                   (> freq1 freq2) -1\n                   :else (cond\n                           (< v1 v2) 1\n                           (> v1 v2) -1\n                           :else 0)))))\n       (first)\n       (first)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15462,"user_id":null,"body":"(ns highest_rank)\n\n(defn highest_rank \"Returns the most frequent entry in the data ISeq\"\n  [data]\n  (let [new-data-set (sort-by count (set (for [e data]\n        (filter (fn [arg] (= e arg)) data))))]\n        (last (sort (vec (set (flatten (filter\n                                        (fn [arg] (= (count arg) (count (last new-data-set))))\n                                        new-data-set))))))\n    )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5421c6a2dda52688f6000af8":[{"id":15463,"user_id":null,"body":"(ns function-composition)\n\n(def compose comp)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15464,"user_id":2556,"body":"(ns function-composition)\n\n(defn compose [f g] (comp f g))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15465,"user_id":null,"body":"(ns function-composition)\n\n(defn compose [f g] \n  ; Compose the functions here!\n  (fn [& x] (f (apply g x)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15466,"user_id":null,"body":"(ns function-composition)\n\n(defn compose [f g] \n  (fn [& more] (f (apply g more)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15467,"user_id":null,"body":"(ns function-composition)\n\n(defn compose [f g] \n  #(f (apply g %&)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15468,"user_id":null,"body":"(ns function-composition)\n\n(defn compose [f g]\n  (fn [& x] (f (apply g x))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15469,"user_id":53,"body":"(ns function-composition)\n\n(defn compose [f g] \n  (defn c [& args] \n    (f (apply g args))\n  )\n  c\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15470,"user_id":null,"body":"(ns function-composition)\n\n\n(defn compose [f g]\n  (fn [& e] (f (apply g e))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15471,"user_id":null,"body":"(ns function-composition)\n\n(defn compose [f g] \n  ;;(comp f g)\n  (fn [& x](f (apply g x)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15472,"user_id":null,"body":"(ns function-composition)\n\n(defn compose [f g]\n  (fn [a & others]\n    (-> g\n      (apply a others)\n      f)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"542ebbdb494db239f8000046":[{"id":15473,"user_id":null,"body":"(ns lazy-next)\n\n(defn next_item\n  \"Returns the value that comes after item in xs or nil\"\n  ([xs item]\n  (second (drop-while (complement #{item}) xs))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15474,"user_id":null,"body":"(ns lazy-next)\n\n(defn next_item\n  \"Returns the value that comes after item in xs or nil\"\n  [xs item]\n  (fnext (drop-while (partial not= item) xs)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15475,"user_id":null,"body":"(ns lazy-next)\n\n(defn next_item\n  \"Returns the value that comes after item in xs or nil\"\n  [xs item]\n  (second (drop-while (partial not= item) xs)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15476,"user_id":1750,"body":"(ns lazy-next)\n\n(defn next_item\n  \"Returns the value that comes after item in xs or nil\"\n  [xs item]\n  (cond\n    (empty? xs) nil\n    (= item (first xs)) (second xs)\n    :else (next_item (rest xs) item)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15477,"user_id":null,"body":"(ns lazy-next)\n\n(defn next_item [xs item] \n   (when (not-empty xs)\n       (if (= item (first xs))\n            (second xs)\n            (next_item (rest xs) item)))) ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15478,"user_id":null,"body":"(ns lazy-next)\n\n(defn next_item [xs item]\n  (->> xs\n       (drop-while #(not (= % item)))\n       rest\n       first))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15479,"user_id":null,"body":"(ns lazy-next)\n\n(defn next_item\n  \"Returns the value that comes after item in xs or nil\"\n  [xs item]\n  (let [index (inc (.indexOf (seq xs) item))]\n    (if (= index 0)\n      nil\n      (get (vec xs) index)))\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15480,"user_id":null,"body":"(ns lazy-next)\n\n(defn next_item\n  \"Returns the value that comes after item in xs or nil\"\n  [[x & xs] item]\n    (if (or (= x item) (empty? xs))\n      (first xs)\n      (recur xs item)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15481,"user_id":null,"body":"(ns lazy-next)\n\n(defn next_item\n  \"Returns the value that comes immediately after the first `item` in `xs` or nil.\"\n  [xs item]\n  (second (drop-while (fn [x] (not (= x item))) xs)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15482,"user_id":null,"body":"(ns lazy-next)\n\n(defn next_item [s v]\n  (if (seq s)\n    (if (= (first s) v)\n      (first (rest s))\n      (recur (rest s) v))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"542f0c36d002f8cd8a0005e5":[{"id":15483,"user_id":527,"body":"(ns waiting-room)\n(def last_chair dec)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15484,"user_id":2574,"body":"(ns waiting-room)\n;; So easy, even I can do it in Clojure\n(defn last_chair [n] (- n 1))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15485,"user_id":null,"body":"(ns waiting-room)\n\n(defn last_chair [n]\n  (dec n))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15486,"user_id":null,"body":"(ns waiting-room)\n\n(defn last_chair [n]\n  (- n 1) ;; because the last person will always sit at the position before the last position\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15487,"user_id":null,"body":"(ns waiting-room)\n\n(defn last_chair [n]\n  (if (= 2 n)\n    2\n    (- n 1)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15488,"user_id":null,"body":"(ns waiting-room)\n\n(defn last_chair\n  [n]\n  (dec n))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15489,"user_id":null,"body":"(ns waiting-room)\n\n(defn last_chair [n]\n  (if (< n 3) 3 (dec n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15490,"user_id":null,"body":"(ns waiting-room)\n\n(defn last_chair [n]\n  (if (= 2 n) 2 (dec n)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15491,"user_id":null,"body":"(ns waiting-room)\n\n(defn last_chair [n]\n  (if (= n 3) 2\n              (dec n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15492,"user_id":null,"body":"(ns waiting-room)\n\n(defn last_chair [n]\n  (if (< n 3) n (dec n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5436f26c4e3d6c40e5000282":[{"id":15493,"user_id":null,"body":"(defn sum_of_n [n]\n  (->> (range)\n       (reductions (if (pos? n) + -))\n       (take (inc (Math\/abs n)))\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15494,"user_id":null,"body":"(defn sum-seq\n  ([] (sum-seq 0 0))\n  ([sum n] (lazy-seq (cons (+ sum n) (sum-seq (+ sum n) (inc n))))))\n\n(defn sum_of_n [n]\n  (if (neg? n)\n    (map - (sum_of_n (- n)))\n    (take (inc n) (sum-seq))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15495,"user_id":null,"body":"(defn sum_of_n [n]\n  (let [ls (reverse (reduce #(cons (+ (first %1) %2) %1) '(0) (map inc (range (Math\/abs n)))))]\n    (if (neg? n)\n      (map - ls)\n      ls)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15496,"user_id":null,"body":"(defn sum_of_n\n    ([n] (sum_of_n n 0 [0]))\n    ([n idx acc]\n     (if (= idx n)\n       acc\n       (let\n        [i (+ idx (\/ (Math\/abs n) n))]\n         (recur n i (conj acc (+ (last acc) i)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15497,"user_id":168,"body":"(defn sum_of_n [n]\n  (->> (range (inc (Math\/abs n)))\n       (map #(quot (* % (inc %)) (if (neg? n) -2 2)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15498,"user_id":null,"body":"\n(defn sum_of_n [n]\n  (take (inc (if (neg? n) (- n) n)) (map (if (pos? n) identity -) (reductions + (iterate inc 0)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15499,"user_id":null,"body":"(defn sum_of_n [n]\n    (if (neg? n)\n      (map #(reduce + (range 0 % -1)) (range -1 (dec (dec n)) -1))\n      (map #(reduce + (range 0 %)) (range 1 (+ 2 n)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15500,"user_id":null,"body":"(defn abs [n]\n  (if (> n 0)\n      n\n      (- n)))\n\n(defn get-sign [n]\n  (if (> n 0)\n    1\n    -1))\n\n(defn sum_of_n [n]\n    (->> (range)\n        (reductions +)\n        (map (partial * (get-sign n)))\n        (take (+ 1 (abs n)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15501,"user_id":null,"body":"(defn sum_of_n [n]\n  (let [sign (Integer\/signum n)]\n    (reductions + (range 0 (+ n sign) sign))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15502,"user_id":null,"body":"(defn sum_of_n [n]\n  (if (neg? n)\n    (map #(* -1 %) (sum_of_n (* -1 n)))\n    (->> n\n         inc\n         (range 0)\n         (map #(range 0 (inc %)))\n         (map #(reduce + %)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"54381f0b6f032f933c000108":[{"id":15503,"user_id":null,"body":"(ns PowerSetCounting)\n\n(defn powers [list]\n\t\t(bigint (.pow 2M (count list))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15504,"user_id":1992,"body":"(ns PowerSetCounting)\n\n(defn powers [list]\n  (.pow (biginteger 2) (count list)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15505,"user_id":null,"body":"(ns PowerSetCounting)\n\n(defn powers [list]\n  (reduce * (repeat (count list) 2N))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15506,"user_id":2671,"body":"(ns PowerSetCounting)\n\n;; sum of binomial coefficients = 2^n (http:\/\/math.stackexchange.com\/questions\/734900\/proof-by-induction-sum-of-binomial-coefficients-sum-k-0n-n-k-2n)\n(defn powers [list]\n  (.pow (biginteger 2) (count list)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15507,"user_id":2556,"body":"(ns PowerSetCounting)\n\n(defn exp [x n]\n  (loop [acc 1 n n]\n    (if (zero? n) acc\n        (recur (*' x acc) (dec n)))))\n\n(defn powers [list]\n  (exp 2 (count list)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15508,"user_id":168,"body":"(ns PowerSetCounting)\n\n(defn powers [list]\n  (.shiftLeft (.toBigInteger 1N) (count list)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15509,"user_id":null,"body":"(ns PowerSetCounting)\n\n(defn factorial [n]\n  (apply *' (range 1 (inc n))))\n\n(defn binom \n  \"calculate binomal coefficient\"\n  [n k]\n  (\/ (factorial n)\n     (*' (factorial k) (factorial (- n k)))))\n\n(defn powers [xs]\n  (inc (reduce + (map (partial binom (count xs)) (range (count xs))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15510,"user_id":null,"body":"(ns PowerSetCounting)\n\n(defn powers [lst]\n  (reduce *' (repeat (count lst) 2))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15511,"user_id":null,"body":"(ns PowerSetCounting)\n\n(defn powers [list]\n  (->> list\n    count\n    (Math\/pow 2)\n    BigDecimal.\n    bigint))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15512,"user_id":null,"body":"(ns PowerSetCounting)\n\n(defn powers [l] (nth (iterate #(* 2 %) 1N) (count l)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"544675c6f971f7399a000e79":[{"id":15513,"user_id":null,"body":"(ns string_to_number-kata)\n\n(defn string_to_number [str]\n  (Integer\/parseInt str))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15514,"user_id":null,"body":"(ns string_to_number-kata)\n\n(defn string_to_number [str]\n  (read-string str)\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15515,"user_id":null,"body":"(ns string_to_number-kata)\n\n(defn string_to_number [str]\n  (Long\/valueOf str))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15516,"user_id":null,"body":"(ns string_to_number-kata)\n\n(defn string_to_number [str]\n  (Integer\/valueOf str)\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15517,"user_id":null,"body":"(ns string_to_number-kata)\n\n(defn string_to_number [str]\n  (Integer. str)\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15518,"user_id":null,"body":"(ns string_to_number-kata)\n\n;; Okay, we can start with the standard atoi-type solution:\n(defn string_to_number [str]\n  (let [digitizer (fn [strseq accum pow]\n                    (if (empty? strseq)\n                      accum\n                      (recur (butlast strseq)\n                        (+ accum (* pow\n                                   (- (int (last strseq)) (int \\0))))\n                        (* pow 10))))]\n    (if (= (first str) \\-)\n      (* -1 (digitizer (rest str) 0 1))\n      (digitizer str 0 1)))\n  )\n\n;; That works fine. But I don't like the back-to-front nature of the whole thing,\n;; so let's see if we can do it front-to-back.\n(defn string_to_number [str]\n  (let [digitizer (fn [strseq accum]\n                    (if (empty? strseq)\n                      accum\n                      (recur (rest strseq)\n                        (+ (* accum 10)\n                          (- (int (first strseq)) (int \\0))))))]\n    (if (= (first str) \\-)\n      (* -1 (digitizer (rest str) 0))\n      (digitizer str 0)))\n  )\n\n;; My inner function there just takes two variables: an accumulator and a sequence.\n;; That means we've got a hidden reduce.\n(defn string_to_number [str]\n  (let [digitizer (fn [strs] (reduce #(+ (* %1 10) (- (int %2) (int \\0))) 0 strs))]\n    (if (= (first str) \\-)\n      (* -1 (digitizer (rest str)))\n      (digitizer str)))\n  )\n\n;; Why am I doing this in the first place?\n(def string_to_number read-string)\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15519,"user_id":null,"body":"(ns string_to_number-kata)\n\n(defn string_to_number [str]\n  (eval str))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15520,"user_id":null,"body":"(ns string_to_number-kata)\n\n(defn expt [x n]\n  (reduce * (repeat n x)))\n\n;; assuming we don't have a parse-int function to use...\n\n(defn string_to_number [str]\n  (let [negative? (= (first str) \\-)\n        chrs (if negative?\n               (rest str)\n               (seq str))]\n    (letfn [(char-to-num [x]\n              (condp = x\n                \\0 0\n                \\1 1\n                \\2 2\n                \\3 3\n                \\4 4\n                \\5 5\n                \\6 6\n                \\7 7\n                \\8 8\n                \\9 9\n              ))]\n      (as-> chrs $\n            (map char-to-num $)\n            (reverse $)\n            (map-indexed (fn [idx x]\n                           (* x (expt 10 idx)))\n                         $)\n            (reduce + 0 $)\n            (if negative? (* -1 $) $)))))\n\n;; ==========================================================================","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15521,"user_id":1861,"body":"(ns string_to_number-kata)\n\n(def string_to_number #(Integer. %))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15522,"user_id":null,"body":"(ns string_to_number-kata)\n\n(def string_to_number #(Integer\/parseInt %1))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"544d114f84e41094a9000439":[{"id":15523,"user_id":null,"body":"(ns power-of-four)\n\n(defn isPowerOf4? [x]\n  (= (int (Math\/pow 4 (Math\/round (\/ (Math\/log x) (Math\/log 4)))))\n     x))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15524,"user_id":53,"body":"(ns power-of-four)\n\n(defn isPowerOf4? [x]\n  (cond\n   (< x 1) false\n   (or (= x 1) (= x 4)) true\n   true (if (= (rem x 4) 0)\n          (isPowerOf4? (quot x 4))\n          false)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15525,"user_id":null,"body":"(ns power-of-four)\n\n(defn isPowerOf4? [x]\n  (cond\n   (= x 0) false\n   (= x 1) true\n   true (if (= (rem x 4) 0)\n          (isPowerOf4? (quot x 4))\n          false)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15526,"user_id":null,"body":"(ns power-of-four)\n(defn isPowerOf4? [x]\n  (and (integer? x)\n    (>= x 0)\n    (or\n      (<= x 1)\n      (loop [n x]\n        (if (and (> n 4) (zero? (rem n 4))) \n          (recur (\/ n 4)) (== n 4))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15527,"user_id":null,"body":"(ns power-of-four)\n\n(defn isPowerOf4? [x]\n  (if (= (int x) x)\n    (if (< x 4)\n      (if (or (= x 1) (= x 0))\n        true\n        false\n      )\n      (if (= (rem x 4) 0)\n        (isPowerOf4? (\/ x 4))\n        false\n      )\n    )\n    false\n  )\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15528,"user_id":null,"body":"(ns power-of-four)\n\n(defn lowest-div-4 [x]\n  (if (= x 0) true\n    (if (= x 1) true\n      (if (= x 4) \n        true\n        (if (= 0 (mod x 4)) \n          (lowest-div-4 (quot x 4))\n          false)))))\n\n(defn isPowerOf4? [x]\n  (println x)\n  (lowest-div-4 x)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15529,"user_id":null,"body":"(ns power-of-four)\n\n(defn isPowerOf4?\n  [x]\n  (if (number? x)\n    (or (= x 1) (= (mod x 4) 0))\n    false)\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15530,"user_id":null,"body":"(ns power-of-four)\n\n(defn isPowerOf4? [x]\n  (if (not (number? x)) false\n      (cond  \n        (= x 0) true\n        (= x 1) true\n        (= (mod x 4) 0) (isPowerOf4? (\/ x 4))\n        :else false\n      )\n  )\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15531,"user_id":null,"body":"(ns power-of-four)\n\n(defn isPowerOf4? [x]\n \t(cond\n  \t(= x 1) true\n  \t(= (mod x 4) 0) true \n  \t:else false)\n )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15532,"user_id":null,"body":"(ns power-of-four)\n\n(defn isPowerOf4? [x]\n  (cond (or (= x 0) (= x 1))\n        true\n        (not= 0 (mod x 4))\n        false\n        :else\n        (recur (\/ x 4))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"54521e9ec8e60bc4de000d6c":[{"id":15533,"user_id":null,"body":"(ns max_sequence)\n\n(defn max_sequence\n  [xs]\n  (apply max (reductions #(max (+ %1 %2) 0) 0 xs)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15534,"user_id":351,"body":"(ns max_sequence)\n           \n(defn max-fold \n  [[max-here max-so-far] x]\n  (let [max-here (max 0 (+ max-here x))]\n    [max-here (max max-so-far max-here)]))\n\n(defn max_sequence\n  [xs]\n  (second (reduce max-fold [0 0] xs)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15535,"user_id":null,"body":"(ns max_sequence)\n\n;; Reduce a function over the data set\n;; that finds the local maximum by adding the accumulator, initially zero,\n;; with the current value from the data set.\n;; If that sum is greater than 0, then the return the sum value,\n;; otherwise return zero.\n;; (fn [accumulator value] (max (+ accumulator value) 0))\n\n;; using reductions we get all the intermediary maximum values\n;; apply max then gets the maximum from all those values\n\n\n(defn max_sequence\n  [xs]\n  (apply max (reductions #(max (+ %1 %2) 0) 0 xs)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15536,"user_id":527,"body":"(ns max_sequence)\n\n(defn max_sequence [xs]\n  (->> xs\n    (reductions #(+ (max 0 %1) %2) 0)\n    (reduce max)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15537,"user_id":null,"body":"(ns max_sequence)\n\n(defn sum [xs] (apply + xs))\n\n(defn max_sequence [xs]\n  (let [xs (vec xs)]\n    (cond\n      (empty? xs) 0\n      (every? neg? xs) 0\n      (every? pos? xs) (sum xs)\n      :else (->> (for [a (range (count xs))\n                       b (range (+ a 2) (inc (count xs)))\n                       :let [s (subvec xs a b)]] s)\n                 (apply max-key sum)\n                 (sum)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15538,"user_id":null,"body":"(ns max_sequence)\n\n(defn max_sequence \n  [xs]\n  (loop [[x & xs] xs peak 0 current 0]\n    (if (nil? x)\n      peak\n      (let [current (max 0 (+ current x))]\n        (recur xs (max peak current) current)))))\n        ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15539,"user_id":null,"body":"(ns max_sequence)\n\n(defn find-max\n  [[max-so-far max-ending-here] elem]\n  (let [max-here (max 0 (+ max-ending-here elem))]\n    [(max max-so-far max-here) max-here]))\n  \n(defn max_sequence [xs]\n  (first (reduce find-max [0 0] xs)))\n           \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15540,"user_id":null,"body":"(ns max_sequence)\n\n(defn max_sequence [xs]\n  (first \n    (reduce \n      (fn [[bs cs] e] \n        (let [cs (max 0 (+ cs e))]\n          [(max bs cs)\n           cs]))\n      [0 0]\n      xs)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15541,"user_id":null,"body":"(ns max_sequence)\n\n(defn max_sequence [xs]\n  (if (some #(> % 0) xs)\n    (let [[x & xs] xs]\n      (:max-so-far\n       (reduce (fn [state elem]\n                            ;;  Mohit Kumar algorithm\n                 (let [old-cur-max (:curr-max state)\n                       old-max-so-far (:max-so-far state)\n                       new-cur-max (max elem (+ old-cur-max elem))\n                       new-max-so-far (max old-max-so-far new-cur-max)]\n                   {:curr-max new-cur-max\n                    :max-so-far new-max-so-far}))\n               {:curr-max x :max-so-far x}\n               xs)))\n    0))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15542,"user_id":null,"body":"(ns max_sequence)\n\n(defn prune [xs]\n  (let [seq-1 (reductions + xs)\n        max-1 (apply max seq-1)\n        idx-1 (.indexOf seq-1 max-1) ]\n    (reverse (subvec (into [] xs) 0 (inc idx-1)))))\n\n(defn max_sequence [xs]\n  (if (or (= xs []) (every? neg? xs))\n    0\n    (apply + (prune (prune xs)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"54557d61126a00423b000a45":[{"id":15543,"user_id":null,"body":"(ns ReverseLonger)\n  \n(defn by-length [a b]\n  ;= to treat b as longer in case both are equal\n  (<= (count a) (count b)))\n\n(defn reverseLonger\n  [a b]\n  (let [[shorter longer] (sort by-length [a b])]\n    (str shorter (clojure.string\/reverse longer) shorter)))\n\n\n\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15544,"user_id":null,"body":"(ns ReverseLonger)\n  \n(defn reverseLonger\n  [a b]\n  (if (< (count a) (count b))\n    (str a (clojure.string\/reverse b) a)\n    (str b (clojure.string\/reverse a) b)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15545,"user_id":53,"body":"(ns ReverseLonger)\n  \n(defn pstr [a b]\n  (str b (apply str (reverse a)) b))\n\n(defn reverseLonger\n  [a b]\n  (if (<= (count b) (count a))\n     (pstr a b)\n     (pstr b a)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15546,"user_id":null,"body":"(ns ReverseLonger)\n  \n(defn reverseLonger\n  [a b]\n  (let [length1 (count a)\n        length2 (count b)\n        shorter (if (< length1 length2) a b)\n        longer (if (>= length1 length2) a b )]\n    (str shorter\n         (apply str (reverse longer))\n         shorter)))\n\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15547,"user_id":null,"body":"(ns ReverseLonger)\n  \n(defn reverseLonger\n  [a b]\n  (let [ab (sort-by #(count %) [b a])\n        shorter (first ab)\n        longer (second ab)]\n    (str shorter (clojure.string\/reverse longer) shorter)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15548,"user_id":null,"body":"(ns ReverseLonger)\n(require '[clojure.string :as str])\n  \n(defn reverseLonger\n  [a b]\n  (if (<= (count b) (count a))\n    (str b (str\/reverse a) b)\n    (reverseLonger b a)\n  ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15549,"user_id":null,"body":"(ns ReverseLonger)\n  \n(defn reverseLonger\n  [a b]\n  (let [[shorter longer] (sort-by count [b a])\n        rlonger (apply str (reverse longer))]\n    (str shorter\n         rlonger\n         shorter)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15550,"user_id":null,"body":"(ns ReverseLonger)\n  \n(defn reverseLonger [a b]\n  (if (< (count a) (count b))\n    (reverseLonger b a)\n    (str b (apply str (reverse a)) b)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15551,"user_id":null,"body":"(ns ReverseLonger)\n  \n(defn reverseLonger [long short]\n  (if (> (count short) (count long))\n    (recur short long)\n    (apply str (concat short (reverse long) short))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15552,"user_id":null,"body":"(ns ReverseLonger)\n  \n(defn reverseLonger\n  [a b]\n  ; TODO\n  (def short-str (if (<= (count b) (count a)) b a))\n  (def long-str (if (>= (count a) (count b)) a b))\n  \n  (str short-str (clojure.string\/join (reverse long-str)) short-str)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5457ea88aed18536fc000a2c":[{"id":15553,"user_id":null,"body":"(ns minimum-dot)\n\n(defn min_dot [xs ys]\n  (reduce + (map * (sort < xs) (sort > ys))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15554,"user_id":null,"body":"(ns minimum-dot)\n\n(defn min_dot [xs ys]\n  (apply + (map * (sort xs) (sort > ys))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15555,"user_id":53,"body":"(ns minimum-dot)\n\n(defn min_dot [a b] (if (or (empty? a) (empty? b)) 0 (reduce + (map #(* %1 %2) (sort a) (sort-by identity #(< %2 %1) b)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15556,"user_id":null,"body":"(ns minimum-dot)\n\n(defn min_dot [xs ys]\n  (let [ sorted-xs (sort xs)\n         sorted-ys (sort > ys)]\n    (if (empty? sorted-xs)\n        0\n        (->> [sorted-xs sorted-ys]\n          (apply map *)\n          (reduce +)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15557,"user_id":null,"body":"(ns minimum-dot)\n\n(defn min_dot [xs ys]\n  (let [a (sort < xs)\n        b (sort > ys)]\n    (apply + (map * a b)))) \n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15558,"user_id":null,"body":"(ns minimum-dot)\n\n(defn dot-product [xs ys]\n  (reduce + (map * xs ys)))\n\n(defn min_dot [xs ys]\n  (dot-product (sort xs) (reverse (sort ys))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15559,"user_id":null,"body":"(ns minimum-dot)\n\n(defn min_dot [xs ys]\n  (->> (interleave (sort xs) (reverse (sort ys)))\n    (partition 2)\n    (mapv #(reduce * %))\n    (reduce +)\n  ))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15560,"user_id":null,"body":"(ns minimum-dot)\n(defn min_dot [xs ys]\n  (if (or (empty? xs) (empty? ys)) 0\n   (let [xs (sort xs) ys (reverse (sort ys))] \n    (reduce + (for [x (range (count xs))] (* (nth xs x) (nth ys x))))))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15561,"user_id":null,"body":"(ns minimum-dot)\n\n(defn min_dot [xs ys]\n  (reduce + (map * (sort xs) (sort (comp - compare) ys)))\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15562,"user_id":null,"body":"(ns minimum-dot)\n\n(defn min_dot [xs ys]\n  (apply + (map #(apply * %) (map vector (sort xs) (sort > ys)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"54592a5052756d5c5d0009c3":[{"id":15563,"user_id":null,"body":"(ns haskell-array-operations)\n(def head first)\n(def tail rest)\n(def init drop-last)\n(def last_ last)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15564,"user_id":null,"body":"(ns haskell-array-operations)\n\n; TODO: implement the four functions specified.\n; Remember to call `last' `last_' to avod naming clashes.\n(def head first)\n(def last_ last)\n(def tail rest)\n(defn init [xs] (or (butlast xs) '()))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15565,"user_id":null,"body":"(ns haskell-array-operations)\n\n; TODO: implement the four functions specified.\n; Remember to call `last' `last_' to avod naming clashes.\n\n(defn head [x] (first x))\n(defn tail [x] (rest x))\n(defn init [x] (drop-last x))\n(defn last_ [x] (last x))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15566,"user_id":2556,"body":"(ns haskell-array-operations)\n\n(def head first)\n(def tail rest)\n(def init #(-> % reverse rest reverse))\n(def last_ #(-> % reverse first))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15567,"user_id":null,"body":"(ns haskell-array-operations)\n\n(defn head[x]\n  (first x)\n)\n\n(defn tail[x]\n  (vec (rest x))\n)\n\n(defn init[x]\n  (if (= 1 (count x))\n    []\n    (vec (cons (first x) (init (rest x))))\n  )\n)\n\n; Remember to call `last' `last_' to avoid naming clashes.\n(def last_ last)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15568,"user_id":null,"body":"(ns haskell-array-operations)\n\n(defn head [[x & xs]]\n  x)\n  \n  \n(defn tail [[x & xs]]\n  xs)\n  \n  \n(defn init [xs]\n  (loop [acc []\n        [x & xs] xs]\n        (if(empty? xs)\n          acc\n          (recur (conj acc x) xs))))\n  \n(defn last_ [xs]\n  (reduce (fn [x y] y) xs))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15569,"user_id":null,"body":"(ns haskell-array-operations)\n\n(def head first)\n(def tail rest)\n(def last_ last)\n(def init #(-> % reverse rest reverse))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15570,"user_id":null,"body":"(ns haskell-array-operations)\n\n(defn head [array]\n  (first array))\n\n(defn tail [array]\n  (drop 1 array))\n\n(defn init [array]\n  (drop-last array))\n\n(defn last_ [array]\n  (last array))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15571,"user_id":null,"body":"(ns haskell-array-operations)\n\n(defn head [xs]\n  (first xs))\n\n(defn last_ [xs]\n  (last xs))\n\n(defn init [xs]\n  (into [] (butlast xs)))\n\n(defn tail [xs]\n  (into [] (rest xs)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15572,"user_id":null,"body":"(ns haskell-array-operations)\n\n; TODO: implement the four functions specified.\n; Remember to call `last' `last_' to avod naming clashes.\n\n(defn head [x]\n  (first x))\n\n(defn tail [x]\n  (into [] (rest x)))\n\n(defn init [x]\n  (take (- (count x) 1) x))\n\n(defn last_ [x]\n  (last x))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"545cedaa9943f7fe7b000048":[{"id":15573,"user_id":null,"body":"(ns Pangram\n  (:require\n    [clojure.string :refer [lower-case]] \n    [clojure.set :refer [subset?]]))\n(defn detect_pangram\n  [s]\n  (subset? \n    (set \"abcdefghijklmnopqrstuvwxyz\") \n    (set (lower-case s))))\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15574,"user_id":null,"body":"(ns Pangram\n  (:require [clojure.string :refer [lower-case]]))\n\n(defn detect_pangram [s]\n  (every? (-> s lower-case set) (set \"abcdefghijklmnopqrstuvwxyz\")))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15575,"user_id":1723,"body":"(ns Pangram\n  (:require [clojure.string :refer [lower-case]])\n  (:require [clojure.set :refer [superset?]]))\n\n(defn detect_pangram\n  [s]\n  (superset?\n    (set (lower-case s))\n    (set \"abcdefghijklmopqrstuvwxyz\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15576,"user_id":null,"body":"(ns Pangram\n  (:require [clojure.string :refer [lower-case]]\n            [clojure.set :refer [subset?]]))\n\n(def alphabet (set \"abcdefghijklmnopqrstuvwxyz\"))\n\n(defn detect_pangram [s]\n  (subset?\n    alphabet\n    (set (lower-case s))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15577,"user_id":null,"body":"(ns Pangram\n  (:require [clojure.string :refer [lower-case] :as string]))\n\n(defn detect_pangram\n  [s]\n  (= 26 (count (distinct (filter #(Character\/isLetter %) (lower-case s)))) ) \n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15578,"user_id":null,"body":"(ns Pangram\n  (:require [clojure.string :as str]))\n\n(defn detect_pangram\n  [s]\n  (= 26 (-> s \n            (str\/lower-case)\n            (str\/replace #\"[^a-z]\" \"\")\n            (sort)\n            (distinct)\n            (count))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15579,"user_id":null,"body":"(ns Pangram\n  (:require [clojure.string :refer [lower-case]]))\n\n(defn detect_pangram [s]\n  (let [only-letters (clojure.string\/replace (lower-case s) #\"[^a-z]\" \"\")]\n    (= 26 (count (set only-letters)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15580,"user_id":null,"body":"(ns Pangram\n  (:require [clojure.string :refer [lower-case]]\n             [clojure.set :refer [subset?]]))\n\n(def alphabet (set (map char (range (int \\a) (inc (int \\z))))))\n(defn detect_pangram [s] (subset? alphabet (set (lower-case s))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15581,"user_id":null,"body":"(ns Pangram\n  (require [clojure.string :refer [lower-case]]\n           [clojure.set :refer [subset?]]))\n\n(def ^:private alphabet #{\\a\\b\\c\\d\\e\\f\\g\\h\\i\\j\\k\\l\\m\n\\o\\p\\q\\r\\s\\t\\u\\v\\w\\x\\y\\z})\n\n(defn detect_pangram [s]\n  (subset? alphabet (set (lower-case s))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15582,"user_id":null,"body":"(ns Pangram\n  (:require [clojure.string :refer [lower-case]]))\n\n(defn detect_pangram\n  [s]\n  (let [letters (into #{} \"abcdefghijklmnopqrstuvwxyz\")]\n  (= (->> s\n        .toLowerCase\n        (filter letters)\n        (into #{})\n        )\n        letters\n  )))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5467e4d82edf8bbf40000155":[{"id":15583,"user_id":null,"body":"(ns descending_order)\n\n(defn descending_order [n]\n  (->> (str n)\n       sort reverse\n       (apply str)\n       Integer\/parseInt))\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15584,"user_id":null,"body":"(ns descending_order)\n\n(defn descending_order [n]\n  (Integer\/parseInt\n    (->> n\n         str\n         sort\n         reverse\n         (apply str))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15585,"user_id":null,"body":"(ns descending_order)\n\n(defn descending_order \n  [n]\n  (->> n\n       str\n       sort\n       reverse\n       (apply str)\n       read-string))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15586,"user_id":null,"body":"(ns descending_order)\n\n; Int -> [Int]\n(defn explode-digits [n] \n  (cond \n    (< n 10)  [n]\n    (< n 100) [(quot n 10) (mod n 10)]    \n    :else     (conj (explode-digits (quot n 10)) (mod n 10))))\n\n; [Int] -> Int\n(defn reduce-digits-iterator [xs]\n  (cond\n    (empty? xs) 0\n    (= (count xs) 1) (first xs)\n    :else (+ (first xs) \n             (* 10 (reduce-digits-iterator (rest xs))))))\n\n; [Int] -> Int\n(defn reduce-digits [xs]\n  (reduce-digits-iterator (reverse xs)))\n\n; Int -> Int\n(defn descending_order [n]\n  (cond\n    (< n 0)  \"Input must be non-negative\"\n    (< n 10) n\n    :else ((comp reduce-digits reverse sort explode-digits) n)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15587,"user_id":null,"body":"(ns descending_order)\n\n(defn descending_order [n]\n   (->> (seq (str n))\n        (map #(Integer\/parseInt (str %)))\n        (sort >)\n        (apply str)\n        Integer\/parseInt))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15588,"user_id":null,"body":"(ns descending_order)\n\n(def descending_order #(read-string (apply str (reverse (sort (str %))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15589,"user_id":null,"body":"(ns descending_order)\n\n(defn descending_order [n]\n   (->> n\n        str\n        sort\n        reverse\n        (apply str)\n        (Integer\/parseInt)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15590,"user_id":null,"body":"(ns descending_order)\n\n(defn descending_order [n]\n  (Integer\/parseInt\n    (clojure.string\/join\n      (sort >\n            (map\n              (fn [x] (Character\/digit x 10))\n              (str n))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15591,"user_id":null,"body":"(ns descending_order\n  (:require [clojure.string :as str]))\n\n(def descending_order (comp #(Integer\/parseInt %) str\/join reverse sort str))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15592,"user_id":null,"body":"(ns descending_order)\n\n(defn descending_order [n]\n  ;; TODO\n  (->> n\n     str\n     (map str)\n     (map #(Integer\/parseInt %))\n     (sort >)\n     (map str)\n     (clojure.string\/join \"\")\n     (#(Integer\/parseInt %))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"546a3fea8a3502302a000cd2":[{"id":15593,"user_id":null,"body":"(ns the-shell-game)\n\n(defn swap [pos [from to]]\n  (condp = pos \n    from to \n    to from\n    pos))\n\n(defn find_the_ball\n  \"Given the starting position and a list of swaps, find the final position\"\n  [initial-pos swaps]\n  (reduce swap initial-pos swaps))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15594,"user_id":1992,"body":"(ns the-shell-game)\n\n(defn find_the_ball\n  \"Given the starting position and a list of swaps, find the final position\"\n  ([start [[x y] & swaps' :as swaps]]\n    (cond (nil? swaps) start\n          (= x start) (recur y swaps')\n          (= y start) (recur x swaps')\n          :else       (recur start swaps'))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15595,"user_id":null,"body":"(ns the-shell-game)\n\n(defn swap [p [t f]]\n\t(cond\n  \t(= p t) f\n    (= p f) t\n    :else p))\n\n(defn find_the_ball [pos swaps]\n  \"Given the starting position and a list of swaps, find the final position\"\n  (reduce swap pos swaps))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15596,"user_id":null,"body":"(ns the-shell-game)\n\n(defn find_the_ball [pos moves]\n  (reduce (fn[p [a b]] (condp = p a b b a p)) pos moves))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15597,"user_id":null,"body":"(ns the-shell-game)\n\n(defn find_the_ball [position swaps]\n  (reduce \n    (fn [ball [a b]]\n      (cond \n        (= ball a) b\n        (= ball b) a\n        :else ball))\n    position\n    swaps))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15598,"user_id":null,"body":"(ns the-shell-game)\n\n(defn find_the_ball [start swaps]\n  (reduce (fn [p [a b]] \n            (condp = p\n              a b\n              b a\n              p))\n          start \n          swaps))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15599,"user_id":null,"body":"(ns the-shell-game)\n\n(defn step [pos [a b]]\n  (cond\n    (= pos a) b\n    (= pos b) a\n    true pos))\n\n(defn find_the_ball [start pairs]\n  (reduce step start pairs))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15600,"user_id":2506,"body":"(ns the-shell-game)\n\n(defn find_the_ball\n  \"Given the starting position and a list of swaps, find the final position\"\n  [pos [[from to :as move] & moves]]\n   (cond (nil? move) pos\n         (= pos from) (recur to moves)\n         (= pos to) (recur from moves)\n         :otherwise (recur pos moves)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15601,"user_id":null,"body":"(ns the-shell-game)\n\n(defn move [ball [from to]]\n  (cond (= ball from) to\n        (= ball to) from\n        :else ball))\n\n(def find_the_ball (partial reduce move))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15602,"user_id":null,"body":"(ns the-shell-game)\n\n(def find_the_ball (partial reduce (fn [pos [m1 m2]] (get {m1 m2 m2 m1} pos pos))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"547aadd5b84a1fd66800041e":[{"id":15603,"user_id":null,"body":"(ns skin-a-cat)\n\n(defn sum\n  ([a] (partial + a))\n  ([a b] (+ a b)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15604,"user_id":null,"body":"(ns skin-a-cat)\n\n(defn sum \n ([x] (partial + x))\n ([x y] ((sum x) y)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15605,"user_id":null,"body":"(ns skin-a-cat)\n\n(defn sum [& args]\n  (let [total (count args)]\n    (cond\n      (= 1 total) (partial + (first args))\n      (= 2 total) (+ (first args) (second args))\n      :else nil)))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15606,"user_id":null,"body":"(ns skin-a-cat)\n\n(defn sum\n     ([x] #(+ x %))\n     ([x y] (+ x y)))\n     ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15607,"user_id":null,"body":"(ns skin-a-cat)\n\n(defn sum\n  [& args]\n\n  (if (= (count args) 1)\n      (partial + (first args))\n      (+ (first args) (second args))\n    )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15608,"user_id":null,"body":"(ns skin-a-cat)\n(defn sum [x & [y]]\n  (if (nil? y)\n    (fn [y] (+ x y))\n    (+ x y)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15609,"user_id":null,"body":"(ns skin-a-cat)\n\n(defn sum\n      ; todo\n      ([num1 num2]\n       (+ num1 num2))\n      ([num]\n       #(+ num %))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15610,"user_id":53,"body":"(ns skin-a-cat)\n\n(defn sum\n      ([a] (fn [b] (+ b a)))\n      ([a b] (+ b a)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15611,"user_id":null,"body":"(ns skin-a-cat)\n\n(defn multi [x]\n  (fn [n] (+ n x)))\n\n(defn sum\n  ([x] (multi x))\n  ([x y] (+ x y)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15612,"user_id":881,"body":"(ns skin-a-cat)\n\n(defn sum\n      [x & y]\n      (if (empty? y)\n        (partial + x)\n        (+ x (first y))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5498505a43e0fd83620010a9":[{"id":15613,"user_id":null,"body":"(ns affinity)\n\n(defn vector_affinity\n  [a b]\n  (let [l (max (count a) (count b))]\n    (if (pos? l)\n      (float (\/ (->> [a b] (apply map =) (filter identity) count) l))\n      1.0)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15614,"user_id":null,"body":"(ns affinity)\n\n(defn vector_affinity\n  [a b]\n  (let [norm (max (count a) (count b))]\n    (if (zero? norm) 1.0\n        (float (\/ (reduce + (map #(if (= %1 %2) 1 0) a b)) norm))))) \n\n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15615,"user_id":1992,"body":"(ns affinity)\n\n(defn vector_affinity [a b]\n  (let [numer (count (filter identity (map = a b)))\n        denom (max (count a) (count b))]\n    (if (zero? denom)\n      1.0\n      (float (\/ numer denom)))))\n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15616,"user_id":null,"body":"(ns affinity)\n\n(defn vector_affinity [a b]\n  (if (= a b) 1\n    (->> (map = a b)\n         (filter true?)\n         (count)\n         (* (\/ 1 (max (count a) (count b))))\n         (float))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15617,"user_id":null,"body":"(ns affinity)\n\n(defn vector_affinity\n  [a b]\n  (let [ar (reduce (fn [acc x]\n                     (if (get acc x)\n                       (assoc acc x (inc (get acc x)))\n                       (assoc acc x 1)))\n                   {}\n                   a)\n        br (reduce (fn [acc x]\n                     (if (get acc x)\n                       (assoc acc x (inc (get acc x)))\n                       (assoc acc x 1)))\n                   {}\n                   b)\n        z (reduce-kv (fn [s k v]\n                       (if (get br k)\n                         (+ s (min (get br k) v))\n                         s))\n                     0\n                     ar)\n        ta (count a)\n        tb (count b)]\n    (if (= 0 ta)\n      (if (= 0 tb)\n        1.0\n        0.0)\n      (float (\/ z ta)))))\n  \n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15618,"user_id":null,"body":"(ns affinity)\n\n(defn vector_affinity\n  [a b]\n  (let [comparison (map #(= %1 %2) a b)\n        total (max (count comparison) (count a) (count b) )\n        total-equal (->> comparison (filter identity) count)]\n    (if (zero? total) 1.0 (float (\/ total-equal total)))))\n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15619,"user_id":null,"body":"(ns affinity)\n\n(defn vector_affinity\n  [a b]\n  (if (= (count a) (count b) 0)\n  1.0\n  (float \n  (\/\n  (count\n  (filter #{0} \n  (map #(compare (first %) (second %)) \n  (partition 2\n  (interleave a b)))))\n  (max (count a) (count b) 1)))))\n  \n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15620,"user_id":53,"body":"(ns affinity)\n\n(defn vector_affinity [a b]\n  (let [w (max (count a) (count b))\n        h (min (count a) (count b))]\n    (loop [i 0 m 0]\n      (cond \n        (>= i h) (if (zero? w) 1.0 (float (\/ m w)))\n        (= (nth a i) (nth b i)) (recur (inc i) (inc m))\n        :else (recur (inc i) m)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15621,"user_id":null,"body":"(ns affinity)\n\n(defn vector_affinity\n  [a b]\n  (if (= a b) 1.0\n      (->> (map vector a b)\n           (filter #(= (first  %) (second  %)))\n           (count)\n           (#(\/ % (max (count a) (count b))))\n           (float))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15622,"user_id":null,"body":"(ns affinity)\n\n(defn vector_affinity\n  [a b]\n  (if (= a b)\n    1.0\n    (do\n      (->> (map vector a b)\n           (filter #(= (first  %) (second  %)))\n           (count)\n           (#(\/ % (max (count a) (count b))))\n           (float)))))\n  \n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"54b42f9314d9229fd6000d9c":[{"id":15623,"user_id":null,"body":"(ns kata.core\n   (:require [clojure.string :as str]))\n\n(defn duplicate_encode [text] \n  (let [lowered (str\/lower-case text)\n        number-of-times (frequencies lowered)]\n    (->> lowered\n         (map #(if (= 1 (number-of-times %1)) \"(\" \")\"))\n         (str\/join))))\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15624,"user_id":null,"body":"(ns kata.core \n  (:require [clojure.string :as str]))\n\n(defn get-duplicated-chars [text]\n  (->> (frequencies text)\n       (filter #(> (second %) 1))\n       keys\n       set))\n\n(defn duplicate_encode [text]\n  (let [lowered-text (str\/lower-case text)\n        duplicated-chars (get-duplicated-chars lowered-text)]\n    (->> (map #(if (duplicated-chars %) \")\" \"(\") lowered-text)\n         (apply str))))\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15625,"user_id":53,"body":"(ns kata.core)\n(require '[clojure.string :as str])\n(defn lower [s] (str\/lower-case s))\n(defn count-ch [s c] (count (filter #(= % c) s)))\n(def count-ch-memo (memoize count-ch))\n(defn encode [s] (str\/join \"\" (map #(if (= 1 (count-ch-memo s %)) \\( \\)) s)))\n(defn duplicate_encode [s] (encode (lower s)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15626,"user_id":null,"body":"(ns kata.core)\n\n(defn duplicate_encode [text]\n  (let [text-lower (clojure.string\/lower-case text)\n        m (->> text-lower\n            (frequencies)\n            (map (fn [%] [(first %) (if (> (second %) 1) \\) \\()]))\n            (into {}))]\n    (apply str (map m text-lower))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15627,"user_id":null,"body":"(ns kata.core)\n\n(defn duplicate_encode [text] \n   (let [t (clojure.string\/lower-case text)\n        dic (->> t frequencies)]\n    (->> t\n         (map (fn [c] (dic c)))\n         (map (fn [n] (if (= 1 n) \"(\" \")\")))\n         (reduce (fn [a c] (str a c))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15628,"user_id":null,"body":"(ns kata.core)\n\n(defn duplicate_encode [text] \n   (let [lower-text (clojure.string\/lower-case text)\n         freq (frequencies lower-text)]\n     (apply str (map #(if (= 1 (get freq %)) \\( \\)) lower-text))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15629,"user_id":null,"body":"(ns kata.core\n  (:require [clojure.string :as str]))\n\n(defn duplicate_encode [text] \n  (let [lower-cased (str\/lower-case text)\n        frequency-table (frequencies lower-cased)]\n    (->> lower-cased\n         (map \n          (fn [character]\n            (if (= 1 (frequency-table character))\n              \\(\n              \\) )))\n         (apply str))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15630,"user_id":null,"body":"(ns kata.core)\n\n(defn swap-letters [dupe-map letter]\n  (if (> (get dupe-map letter) 1)\n    \")\"\n    \"(\"))\n\n(defn duplicate_encode [text] \n   ; Your brilliant code here :)\n  (let [uncased-text (clojure.string\/lower-case text)\n        dupe-map (frequencies uncased-text)\n        result (map #(swap-letters dupe-map %) uncased-text)]\n    (clojure.string\/join result)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15631,"user_id":null,"body":"(ns kata.core\n  (:require [clojure.string :as str]))\n\n(defn duplicate_encode [text]\n  (let [counts (reduce (fn [counts, c]\n                       (update counts\n                               c\n                               #(inc (or % 0))))\n                     {}\n                     (str\/lower-case text))]\n  (reduce (fn [result, c]\n            (str result\n                 (if (> (counts c) 1)\n                   \")\"\n                   \"(\")))\n          \"\"\n          (str\/lower-case text))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15632,"user_id":null,"body":"(ns kata.core\n  (:require [clojure.string :refer [index-of lower-case]]))\n\n(defn duplicate_encode [text]\n  (def lowerText (lower-case text))\n  (loop [i 0 dups \"\"] \n    (if (< i (count lowerText))\n      (if (nil? (index-of lowerText (.charAt lowerText i) (+ 1 (index-of lowerText (.charAt lowerText i) 0))))\n        (recur (inc i) (str dups \"(\"))\n        (recur (inc i) (str dups \")\"))\n        )\n      dups)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"54bf1c2cd5b56cc47f0007a1":[{"id":15633,"user_id":null,"body":"(ns katas.counting-duplicates)\n\n(defn duplicate_count [text]\n  (->> text\n       (clojure.string\/lower-case)\n       (frequencies)\n       (vals)\n       (filter #(> % 1))\n       (count)))\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15634,"user_id":null,"body":"(ns katas.counting-duplicates)\n\n(defn duplicate_count [text]\n  (count (filter #(> (second %) 1) (frequencies (clojure.string\/lower-case text))))\n)\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15635,"user_id":null,"body":"(ns katas.counting-duplicates)\n\n(defn duplicate_count [text]\n  \"Return the count of distinct case-insensitive alphanumeric characters\"\n  \"that occur more than once\"\n  (->> text\n       clojure.string\/lower-case\n       frequencies\n       vals\n       (filter #(> % 1))\n       count))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15636,"user_id":null,"body":"(ns katas.counting-duplicates)\n\n(defn duplicate_count [text]\n  (->> (map second (frequencies (clojure.string\/lower-case text)))\n       (filter #(> % 1))\n       count))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15637,"user_id":null,"body":"(ns katas.counting-duplicates)\n\n\n(defn duplicate_count [text]\n   ; Happy coding!\n  (count (filter #(> (count %) 1) (vals (group-by identity (clojure.string\/lower-case text))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15638,"user_id":null,"body":"(ns katas.counting-duplicates)\n\n(defn duplicate_count [text]\n  (->> (.toLowerCase text)\n       (frequencies)\n       (filter (fn [[k v]] (>= v 2)))\n       (count)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15639,"user_id":527,"body":"(ns katas.counting-duplicates)\n\n(defn duplicate_count [text]\n  (->> text clojure.string\/upper-case frequencies vals (filter #(> % 1)) count))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15640,"user_id":null,"body":"(ns katas.counting-duplicates)\n\n(defn duplicate_count [text]\n    (count(filter  #(not= % 1) \n                    (vals (frequencies (clojure.string\/lower-case text)))\n          )\n    )\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15641,"user_id":null,"body":"(ns katas.counting-duplicates)\n\n(defn duplicate_count [text]\n  (->> text\n       (clojure.string\/lower-case)\n       (re-seq #\".\")\n       (sort)\n       (frequencies)\n       (filter #(> (second %) 1))\n       (count)\n))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15642,"user_id":null,"body":"(ns katas.counting-duplicates)\n\n(defn duplicate_count [text]\n  (reduce (fn [y x] (+ y (if (= x 1) 0 1))) 0 (map second (seq(frequencies (clojure.string\/upper-case text)))))\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"54bf85e3d5b56c7a05000cf9":[{"id":15643,"user_id":null,"body":"(ns line-numbers)\n\n(defn number [lines]\n  (map (partial format \"%d: %s\") (iterate inc 1) lines))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15644,"user_id":527,"body":"(ns line-numbers)\n\n(def number (partial map-indexed #(str (inc %1) \": \" %2)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15645,"user_id":1992,"body":"(ns line-numbers)\n\n(def number \n  (partial map #(str (inc %1) \": \" %2) (range)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15646,"user_id":3088,"body":"(ns line-numbers)\n\n(defn number [lines]\n  (map #(str %1 \": \" %2) (iterate inc 1) lines))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15647,"user_id":3089,"body":"(ns line-numbers)\n\n(defn number [lines] \n  (map-indexed (fn [i x] (str (+ i 1) \": \" x)) lines)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15648,"user_id":2506,"body":"(ns line-numbers)\n\n(defn number [lines]\n  (map-indexed #(str (+ %1 1) \": \" %2) lines))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15649,"user_id":null,"body":"(ns line-numbers)\n\n(defn number [lines] (map (fn [number line] (str number \": \" line)) (iterate inc 1) lines)) \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15650,"user_id":null,"body":"(ns line-numbers)\n\n(defn number [lines] (map #(str (+ %1 1) \": \" %2) (range) lines))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15651,"user_id":null,"body":"(ns line-numbers)\n\n(defn number [lines]\n  (vec (map-indexed #(str (+ % 1) \": \" %2) lines))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15652,"user_id":null,"body":"(ns line-numbers)\n\n(defn number [lines]\n  (map-indexed #(format \"%s: %s\" (+ 1 %1) %2) lines)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"54c9fcad28ec4c6e680011aa":[{"id":15653,"user_id":527,"body":"(ns stringmerge.core)\n\n(defn is_merge\n  \"Returns whether a string is a merge of two other strings\"\n  [s p1 p2]\n  (if (empty? s) (and (empty? p1) (empty? p2)) (or\n    (and (= (first s) (first p1)) (is_merge (rest s) (rest p1) p2))\n    (and (= (first s) (first p2)) (is_merge (rest s) p1 (rest p2)))\n  )))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15654,"user_id":null,"body":"(ns stringmerge.core)\n\n(defn is_merge [[c & s] [f1 & r1 :as p1] [f2 & r2 :as p2]]\n  (cond\n    (nil? c) (= nil f1 f2)\n    (= c f1 f2) (or (is_merge s r1 p2) (is_merge s p1 r2))\n    (= c f1)  (is_merge s r1 p2)\n    (= c f2)  (is_merge s p1 r2)\n    :default false\n))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15655,"user_id":492,"body":"(ns stringmerge.core)\n(declare is_merge)\n(defn check [s x y]\n  (and (not (empty? s)) (not (empty? x)) (= (first s) (first x)) (is_merge (rest s) (rest x) y))) \n(defn is_merge [s p1 p2]\n  (or (and (empty? s) (empty? p1) (empty? p2)) (check s p1 p2) (check s p2 p1)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15656,"user_id":null,"body":"(ns stringmerge.core)\n\n(defn is_merge\n  \"Returns whether a string is a merge of two other strings\"\n  [[c & s] \n   [c1 & cs1 :as p1] \n   [c2 & cs2 :as p2]]\n  (cond\n    (nil? c) (and (nil? c1) (nil? c2))\n    (= c c1 c2) (or (is_merge s cs1 p2)\n                    (is_merge s p1 cs2))\n    (= c c1) (is_merge s cs1 p2)\n    (= c c2) (is_merge s p1 cs2)\n    :else false))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15657,"user_id":null,"body":"(ns stringmerge.core)\n\n(defn is_merge\n  \"Returns whether a string is a merge of two other strings\"\n  [chrs p1 p2]\n  (cond\n    (and (empty? chrs) (empty? p1) (empty? p2))\n      true\n    (empty? chrs)\n      false\n    (and (= (first chrs) (first p1)) (= (first chrs) (first p2)))\n      (or (is_merge (next chrs) (next p1) p2) (is_merge (next chrs) p1 (next p2)))\n    (= (first chrs) (first p1) )\n      (is_merge (next chrs) (next p1) p2)\n    (= (first chrs) (first p2))\n      (is_merge (next chrs) p1 (next p2))\n    :else\n      false))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15658,"user_id":null,"body":"(ns stringmerge.core)\n\n(defn same-order? [s1 s2]\n  (loop [[f & fs] s1\n         [s & ss :as s2] s2]\n    (cond\n      (nil? s) true\n      (nil? f) false\n      (= f s) (recur fs ss)\n      :else (recur fs s2))))\n\n(defn is_merge [s p1 p2]\n  (and (same-order? s p1)\n       (same-order? s p2)\n       (= (sort s) (sort (str p1 p2)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15659,"user_id":null,"body":"(ns stringmerge.core\n  (:require [clojure.string :as str]))\n;; https:\/\/www.codewars.com\/kata\/54c9fcad28ec4c6e680011aa\/train\/clojure\n\n(defn same-chars [string1 string2]\n  (= (sort string1) (sort string2)))\n\n(defn correct-order [string p]\n  (let [s (first string)\n        fp (first p)]\n    (cond\n      (nil? fp) true\n      (nil? s) false\n      (= s fp) (recur (next string) (next p))\n      :else (recur (next string) p))))\n\n(defn is_merge [string p1 p2]\n  (and (same-chars string (str p1 p2))\n       (correct-order string p1)\n       (correct-order string p2)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15660,"user_id":null,"body":"(ns stringmerge.core)\n\n(defn is_merge-helper\n  [[fs & rest-s :as s] [fa & rest-a :as a] [fb & rest-b :as b]]\n  (cond\n    (and (empty? s) (empty? a) (empty? b)) true\n    (and (= fs fa) (= fs fb)) (or (is_merge-helper rest-s rest-a b) (is_merge-helper rest-s a rest-b))\n    (= fs fa) (recur rest-s rest-a b)\n    (= fs fb) (recur rest-s a rest-b)\n    :else false))\n\n\n(defn is_merge\n  [s a b]\n  (if (= (count s) (+ (count a) (count b)))\n    (is_merge-helper s a b)\n    false)) ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15661,"user_id":null,"body":"(ns stringmerge.core)\n\n(defn is_merge\n  \"Returns whether a string is a merge of two other strings\"\n  [[s1 & s']\n   [a1 & a' :as a]\n   [b1 & b' :as b]]\n  (cond \n      (nil? s1)    (every? nil? [a1 b1])\n      (= s1 a1 b1) (or (is_merge s' a' b) (is_merge s' a b')) ;; not tail, no recur\n      (= s1 a1)    (recur s' a' b)\n      (= s1 b1)    (recur s' a b')\n      :else false))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15662,"user_id":null,"body":"(ns stringmerge.core)\n\n(defn is_merge\n  \"Returns whether a string is a merge of two other strings\"\n  [s a b]\n  (let [[s1 & s'] s\n        [a1 & a'] a\n        [b1 & b'] b]\n    (cond \n      (nil? s1) (every? nil? [a1 b1])\n      (= s1 a1 b1) (or (is_merge s' a' b) (is_merge s' a b')) ;; not tail, no recur\n      (= s1 a1) (recur s' a' b)\n      (= s1 b1) (recur s' a b')\n      :else false)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"54d512e62a5e54c96200019e":[{"id":15663,"user_id":53,"body":"(ns prime-decomp.core)\n  \n(defn prime_factors [m]\n  (defn walk [o]\n    (loop [l 0 i 2 n o cnt 0 fs []]\n      (cond \n        (and (> i n) (= 0 l)) fs\n        (= 0 (mod n i)) (recur 1 i (quot n i) (inc cnt) fs)\n        (= 1 cnt) (recur 0 (inc i) n 0 (conj fs (format \"(%d)\" i)))\n        (< 1 cnt) (recur 0 (inc i) n 0 (conj fs (format \"(%d**%d)\" i cnt)))\n        :else (recur 0 (inc i) n 0 fs))))\n  (let [ls (walk m)]\n    (if (zero? (count ls))\n      (format \"(%d)\" m)\n      (clojure.string\/join \"\" ls))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15664,"user_id":null,"body":"(ns prime-decomp.core)\n  \n(defn prime_factors [n]\n  (let [factors (loop [n n\n                       i 2\n                       xs []]\n                  (cond (= i n) (conj xs i)\n                        (pos? (mod n i)) (recur n (inc  i) xs )\n                        (zero? (mod n i)) (recur (quot n i) i (conj xs i))))]\n    (->> factors\n         (frequencies)\n         (map (fn [[k v]]\n                (if (> v 1)\n                  (str \"(\" k (apply str (repeat 2 \"*\")) v \")\")\n                  (str \"(\" k \")\"))))\n         (apply str))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15665,"user_id":492,"body":"(ns prime-decomp.core)\n\n(defn prime_factors-to-string\n  [x]\n  (let [s (map (fn [[x y]]\n                 (if (not= y 1)\n                   (str \"(\" x \"**\" y \")\")\n                   (str \"(\" x \")\"))) x)\n       ]\n    (format \"%s\" (clojure.string\/join \"\" s))))  \n  \n(defn prime_factors [n]\n  (loop [n n divisor 2 factors []]\n    (if (< n 2)\n      (prime_factors-to-string (frequencies factors))\n      (if (= 0 (rem n divisor))\n        (recur (\/ n divisor) divisor (conj factors divisor))\n        (recur n (inc divisor) factors)\n      )\n    )\n  )\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15666,"user_id":null,"body":"(ns prime-decomp.core)\n  \n(defn prime_factors [n]\n  (loop [i n div 2 factors []]\n    (if (> i 1)\n      (let [j (\/ i div)]\n        (if (integer? j)\n          (recur j div (conj factors div))\n          (recur i (inc div) factors)))\n      (reduce (fn [acc [k v]]\n          (if (= v 1)\n            (str acc \"(\" k \")\")\n            (str acc \"(\" k \"**\" v \")\"))) \"\" (frequencies factors)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15667,"user_id":null,"body":"(ns prime-decomp.core)\n\n(defn factorization [num]\n  (loop [remain num divisor 2 primes []]\n    (cond\n      (= remain 1) primes\n      (= (mod remain divisor) 0) (recur (quot remain divisor) divisor (conj primes divisor))\n      :else (recur remain (inc divisor) primes))))\n\n  \n(defn prime_factors [n]\n  (->> n\n     factorization\n     frequencies\n     (map (fn [[a b]]\n            (if (= b 1)\n              (format \"(%d)\" a)\n              (format \"(%d**%d)\" a b)\n              )\n            )\n          )\n     (clojure.string\/join \"\"))\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15668,"user_id":null,"body":"(ns prime-decomp.core)\n  \n(defn factors [n div facts]\n  (cond\n    (> div n)\n      facts\n    (zero? (mod n div))\n      (recur (\/ n div) div (conj facts div))\n    :else\n      (recur n (inc div) facts)\n    )\n  )\n\n(defn prime_factors [n]\n  (->>\n    (factors n 2 [])\n    (group-by identity)\n    (map (fn [[k v]]\n           (if (= (count v) 1)\n            (str \"(\" k \")\")\n            (str \"(\" k \"**\" (count v) \")\"))))\n    (clojure.string\/join \"\")\n    )\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15669,"user_id":null,"body":"(ns prime-decomp.core)\n\n(use '[clojure.string :only (join)])\n\n\n(defn is-prime?\n  [n]\n  (let [square-root (Math\/sqrt n)\n        mod-zero? (fn [res new-val]\n                    (if (zero? (mod n new-val))\n                      (reduced false)\n                      true))]\n    (reduce mod-zero? true (range 2 (inc square-root)))))\n\n(defn hash-to-list [h] (map #(do %) h))\n(defn expo [a b] (if (= b 1) (str \"(\" a \")\") (str \"(\" a \"**\" b \")\")))\n  \n(defn prime_factors [n]\n  (->> (loop [lst [] tail n div 2]\n    (cond \n      (is-prime? tail) (conj lst tail)\n      (zero? (mod tail div)) (recur (conj lst div) (\/ tail div) div)\n      :else (recur\n             lst\n             tail\n             (loop [next-prime (inc div)]\n               (if (is-prime? next-prime)\n                 next-prime\n                 (recur (inc next-prime)))))))\n    (frequencies)\n    (hash-to-list)\n    (map #(apply expo %))\n    (join)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15670,"user_id":62,"body":"(ns prime-decomp.core)\n\n(def primes\n  (lazy-seq \n   (cons 2\n         (filter (fn [n]\n                   (not-any? zero?\n                           (map #(rem n %)\n                                (take-while #(<= (* % %) n) primes))))\n                 (iterate inc 3)))))\n   \n(defn prime_factors [n]\n  (let [factorization\n        (loop [n n, \n               factors nil, \n               primes (take-while #(<= (* % %) n) primes)]\n          (if-let [p (first primes)]\n            (if (zero? (rem n p))\n              (recur (quot n p) (conj factors p) primes)\n              (recur n factors (rest primes)))\n            (if (= 1 n) factors (cons n factors))\n            ))]\n    (apply str\n    (map (fn [[prime exp]] \n           (if (= 1 exp) \n             (format \"(%d)\" prime)\n             (format \"(%d**%d)\" prime exp)))\n    (sort-by key (frequencies factorization))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15671,"user_id":null,"body":"(ns prime-decomp.core)\n\n(defn gcd [a b]\n  (if (= b 0)\n    a\n    (recur b (rem a b))))\n\n(defn prime? [x]\n  (or (< x 3)\n      (->> (range 2\n                  (-> x Math\/sqrt Math\/ceil int inc))\n        (every? #(= (gcd x %) 1)))))\n\n(def primes\n  (filter prime? (drop 2 (range))))\n\n(defn factors\n  ([n] (factors n primes []))\n  ([n ps fs]\n   (cond\n     (<= n 1) fs\n     (= (rem n (first ps)) 0) (recur (quot n (first ps))\n                                     ps\n                                     (conj fs (first ps)))\n     :else (recur n\n                  (rest ps)\n                  fs))))\n\n(defn prime_factors [n]\n  (->> (frequencies (factors n))\n    (into [])\n    (sort (fn [[a _] [b _]] (< a b)))\n    (map (fn [[n c]] (if (> c 1)\n                       (format \"(%d**%d)\" n c)\n                       (format \"(%d)\" n))))\n    (apply str)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15672,"user_id":null,"body":"(ns prime-decomp.core)\n  \n(defn prime_factors [n]\n(let [prime? (fn [n]\n               (if (< n 4)\n                 (not= 1 n)\n                 (->> (range 2 (inc (Math\/sqrt n)))\n                      (not-any? #(zero? (rem n %))))))\n      next-prime (fn[n]\n                   (->> (range)\n                        (map (partial + n 1))\n                        (filter prime?)\n                        (first)))\n      prime_factors (loop [p 2, r n, counts (sorted-map)]\n                      (cond\n                        (= 1 r) counts\n                        (zero? (rem r p)) (recur p (\/ r p) (update counts p (fnil inc 0)))\n                        :else (recur (next-prime p) r counts)))]\n  (apply str (map (fn [[p pow]] (str \"(\" p (if (= 1 pow) \"\" (str \"**\" pow))\")\")) prime_factors)))\n\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"54d7660d2daf68c619000d95":[{"id":15673,"user_id":53,"body":"(ns com-denom.core)\n\n(defn gcd [x y]\n    (cond\n       (= 0 y) x\n       :else (gcd y (mod x y)))\n  )\n(defn lcm [x y]\n    (quot (* x y) (gcd x y))\n  )\n\n(defn convert_frac [lst]\n  (let [cd (reduce (fn [acc x] (lcm (nth x 1) acc)) 1 lst)]\n    (map (fn [x] [(\/ (* cd (nth x 0)) (nth x 1)), cd]) lst)\n  )\n)","lang_id":5,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15674,"user_id":null,"body":"(ns com-denom.core)\n\n(defn prime-fact-f [f n]\n  (cond (= n 1) []\n        (zero? (mod n f)) (conj (prime-fact-f f (\/ n f)) f)\n        :else (recur (inc f) n)))\n\n(defn prime-fact [n]\n  \"Return the prime factorization of n\"\n  (prime-fact-f 2 n))\n\n(defn gcd [a b]\n  \"Return the greatest common divisor between two numbers\"\n  (if (zero? b) a (recur b (mod a b))))\n\n(defn lcm [a b]\n  \"Return the least common multiple between two numbers\"\n  (\/ (#(max % (- %)) (* a b)) (gcd a b)))\n\n(defn convert_frac [fractions]\n  (let [numerators (map first fractions)\n        denominators (map second fractions)\n        new-denominators (map (constantly (reduce lcm denominators)) fractions)\n        new-numerators (map * (map \/ new-denominators denominators) numerators)]\n    (map vector new-numerators new-denominators)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15675,"user_id":492,"body":"(ns com-denom.core)\n\n(defn gcd [a b]\n  (if (= b 0)\n    a\n    (gcd b (mod a b))))\n\n(defn lcm [a b]\n  (\/ (*' a b) (gcd a b)))\n\n(defn simplify [lst]\n  (map (fn [ [n d] ] \n         (let [g (gcd n d)]\n           (list (\/ n g) (\/ d g)))) lst))\n\n(defn convert_frac [lst]\n  (let [newlst (simplify lst)\n        lstden (map (fn [ [n d] ] d) newlst)\n        cden (reduce lcm lstden)\n        convert (map (fn [ [n d] ] (list (\/ (* n cden) d) cden)) newlst)\n       ]\n    convert\n  ))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15676,"user_id":null,"body":"(ns com-denom.core)\n\n(defn convert_frac [lst]\n  (let [d (->> lst \n               (map second)\n               (sort)\n               (reduce \n                 (fn [x y]\n                   (let [z (+ (\/ 1 x) (\/ 1 y))]\n                     (if (ratio? z) (denominator z) 1)))))]\n    (map\n      (fn [[x y]]\n        (let [z (\/ d y)]\n          [(* x z) (* y z)]))\n      lst)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15677,"user_id":null,"body":"(ns com-denom.core)\n\n(defn gcd [a b]\n  (if (zero? b)\n    a\n    (recur b (mod a b))))\n\n(defn lcm [a b]\n  (\/ (* a b) (gcd a b)))\n\n(defn convert_frac [lst]   \n  (let [lcm-lst (reduce lcm (take-nth 2 (conj (flatten lst) 1)))]\n    (map (fn [[a b]] [(* a (\/ lcm-lst b)) lcm-lst]) lst)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15678,"user_id":null,"body":"(ns com-denom.core)\n\n(defn gcd [x y]\n  (let [m (mod x y)]\n    (if (zero? m)\n      y\n      (recur y m))))\n\n(defn lcm [x y]\n  (\/ (* x y) (gcd x y)))\n\n;[[1, 2], [1, 3], [1, 4]]\n(defn convert_frac [lst]\n  (let [total-lcm (reduce lcm (map #(nth % 1) lst))]\n    (map #(vector (* (nth % 0) (\/ total-lcm (nth % 1))) total-lcm) lst)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15679,"user_id":null,"body":"(ns com-denom.core)\n\n(defn gcd [a b]\n  (if (= b 0)\n    a\n    (recur b (mod a b))))\n\n(defn lcm [a b]\n  (let [d (gcd a b)]\n    (* (\/ a d) b)))\n\n(defn convert_frac [lst]\n  (let [values (map second lst)\n        denominator (reduce lcm values)]\n    (map (fn [[n d]] [(\/ (* denominator n) d) denominator]) lst)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15680,"user_id":null,"body":"(ns com-denom.core)\n\n(defn gcd\n  ([a b]\n   (cond\n     (< a b) (recur b a)\n     (zero? b) a\n     :else (recur b (mod a b))))\n  ([a b & rest]\n   (reduce gcd (conj (seq rest) b a))))\n\n(defn lcm [& args]\n  (let [vargs (vec args)\n        f #(into (subvec vargs 0 %) (subvec vargs (inc %)))\n        subseqs (map f (range (count args)))\n        prods (map (partial apply *) subseqs)]\n    (\/ (apply * args)\n       (apply gcd prods))))\n\n(defn convert_frac [lst]\n  (let [denominators (map second lst)\n        common-denominator (apply lcm denominators)\n        f (fn [[n d]]\n            (let [m (\/ common-denominator d)]\n              [(long (* m n)) (long (* m d))]))]\n    (vec (map f lst))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15681,"user_id":62,"body":"(ns com-denom.core)\n\n(defn gcd [a b]\n  (cond (< a b) (recur b a)\n        (zero? b) a\n        :else (recur b (rem a b))))\n(defn lcm [a b]\n  (quot (* a b) (gcd a b)))\n\n(defn convert_frac [lst]\n  (let [denom (reduce lcm 1 (map second lst))]\n    (for [[a b] lst]\n      [ (* (\/ a b) denom), denom])))\n       ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15682,"user_id":null,"body":"(ns com-denom.core)\n\n(defn gcd \n      [a b]\n      (if (zero? b)\n      a\n      (recur b, (mod a b))))\n \n(defn lcm \n      [a b]\n  (\/ (* a b) (gcd a b)))\n\n(defn lcmv [& v] (reduce lcm v))\n\n(defn convert_frac [lst]\n  (let [mult (apply lcmv (map #(last %) lst))]\n    (map #(vec `(~(* (first %) (\/ mult (last %))) ~mult)) lst)))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"54da5a58ea159efa38000836":[{"id":15683,"user_id":null,"body":"(ns find-the-odd-int)\n\n(defn find_it [v] (ffirst (filter #(odd? (second %)) (frequencies v))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15684,"user_id":527,"body":"(ns find-the-odd-int)\n\n(defn find_it [xs]\n  (reduce bit-xor xs))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15685,"user_id":null,"body":"(ns find-the-odd-int)\n\n(defn find_it [xs]\n  (->> (frequencies xs) \n       (filter #(odd? (second %))) \n        ffirst))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15686,"user_id":null,"body":"(ns find-the-odd-int)\n\n(defn find_it [xs]\n  (->> xs\n    frequencies\n    (filter (fn [[_ v]]\n        (odd? v))) \n    first\n    first))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15687,"user_id":null,"body":"(ns find-the-odd-int)\n\n(defn find_it [xs]\n  (first (first (filter #(odd? (second %)) (frequencies xs)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15688,"user_id":null,"body":"(ns find-the-odd-int)\n\n(defn find_it [xs]\n  (->> (group-by identity xs)\n       (filter #(odd? (count (second %))))\n       (apply first)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15689,"user_id":53,"body":"(ns find-the-odd-int)\n\n(defn find_it [xs]\n  (reduce (fn [acc n] (bit-xor acc n)) 0 xs))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15690,"user_id":571,"body":"(ns find-the-odd-int)\n\n(defn find_it [xs]\n  (key (first (filter (fn [[k v]] (odd? (count v))) (group-by identity xs)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15691,"user_id":527,"body":"(ns find-the-odd-int)\n\n(def find_it (partial apply bit-xor 0))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15692,"user_id":null,"body":"(ns find-the-odd-int)\n\n(defn find_it [xs]\n  (let [nums (atom #{})]\n    (doseq [i (range (count xs))\n            :let [num (get xs i)]]\n      (if (contains? @nums num) \n        (swap! nums disj num)\n        (swap! nums conj num)))\n    (first  @nums)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"54db15b003e88a6a480000b9":[{"id":15693,"user_id":492,"body":"(ns moduli.core)\n\n(defn gcd\n  [a b]\n  (if (= b 0)\n    a\n    (gcd b (mod a b))))\n\n(defn lcm\n  [a b]\n  (\/ (* a b) (gcd a b)))\n\n(defn moduli\n  [n arr]\n  (map (fn [x] (mod n x)) arr))\n\n(defn fromNb2Str\n  [n arr]\n  (let [p (reduce * arr) m (reduce lcm arr)]\n    (if (or (<= p n) (not= p m))\n      \"Not applicable\"\n      (format \"-%s-\" (clojure.string\/join \"--\" (moduli n arr))))))\n    \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15694,"user_id":53,"body":"(ns moduli.core)\n\n(defn gcd [a b] (if (zero? b) a (gcd b (mod a b))))\n(defn prd [ls] (reduce * 1 ls))\n(defn lcm [ls] (reduce (fn [a b] (quot (* a b) (gcd a b))) 1 ls))\n\n(defn fromNb2Str [n arr]\n  (if (or (<= (prd arr) n) (not= (prd arr) (lcm arr)))\n    \"Not applicable\"\n    (clojure.string\/join \"\" (map (fn [e] (format \"-%d-\" (mod n e))) arr))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15695,"user_id":3082,"body":"(ns moduli.core)\n\n(use '[clojure.pprint :only [cl-format]])\n\n(defn gcd [a b]\n  (if (zero? b) a (recur b (mod a b))))\n\n(defn rem-first [a l]\n  (let [[n m] (split-with (partial not= a) l)]\n    (concat n (rest m))))\n\n(defn fromNb2Str\n  [n arr]\n  (if (and (every? #(= % 1) (for [x1 arr, x2 (rem-first x1 arr)] (gcd x1 x2)))\n           (> (apply * arr) n))\n    (cl-format nil \"-~{~a~^--~}-\" (map (fn [x] (rem n x)) arr))\n    \"Not applicable\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15696,"user_id":null,"body":"(ns moduli.core)\n\n(defn gcd [x y]\n  (if (zero? y) x\n    (recur y (rem x y))))\n\n(defn moduli [n arr]\n  (if (and (every? (partial = 1) (for [x arr y arr :when (not= x y)] (gcd x y)))\n           (> (apply * arr) n))\n    (map (partial rem n) arr)))\n\n(defn fromNb2Str [n arr]\n  (if-let [arr (moduli n arr)]\n    (str \\- (apply str (interpose \"--\" arr)) \\-)\n    \"Not applicable\"))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15697,"user_id":null,"body":"(ns moduli.core (:require [clojure.string :as str]))\n\n(defn gcd [a b]\n  (loop [a a b b]\n    (if (zero? b)\n      a\n      (recur b (mod a b))\n    )\n  )\n)\n\n(defn lcm [a b]\n  (\/ (* a b) (gcd a b))\n)\n\n(defn fromNb2Str\n  [n arr]\n  (let [l (reduce lcm arr) m (apply * arr)]\n    (cond (< m n) \"Not applicable\"\n          (not= m l) \"Not applicable\"\n          :else (->> arr\n                     (map mod (repeat n))\n                     (map #(format \"-%d-\" %))\n                     (str\/join)\n                )\n    )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15698,"user_id":null,"body":"(ns moduli.core)\n\n(defn gcd [a b] (if (zero? (* a b)) (+ a b) (gcd b (mod a b))))\n\n(defn elt-coprime? [n arr]\n  \"Checks n is coprime with each elt of arr\"\n  (every? \n    #(= % 1)\n    (map (partial gcd n) arr)))\n\n(defn coprime? [arr]\n  (if (empty? arr) true\n  (and \n    (coprime? (rest arr))\n    (elt-coprime? (first arr) (rest arr)))))\n\n(defn out-of-bounds? [n arr] \n  (> n (reduce * arr)))\n\n(defn fromNb2Str\n  [n arr]\n  (if \n    (and\n      (coprime? arr)\n      (not (out-of-bounds? n arr)))\n    (->> arr\n         (map #(mod n %))\n         (map #(str \"-\" % \"-\"))\n         (apply str))\n    \"Not applicable\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15699,"user_id":1200,"body":"(ns moduli.core)\n\n(defn gcd [a b] (cond (< a b) (recur b a) (= b 0) a true (recur b (mod a b))))\n\n(defn no-gcd? [arr] (every? #(= 1 %) (for [x arr y arr :when (not= x y)] (gcd x y))))\n\n(defn valid? [n arr] (and (< n (apply * arr))\n                       (no-gcd? arr)))\n\n(defn fromNb2Str\n  [n arr]\n  (if (valid? n arr)\n    (apply str (map #(str \"-\" % \"-\") (map #(mod n %) arr)))\n    \"Not applicable\"))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15700,"user_id":null,"body":"(ns moduli.core)\n\n\n(defn gcd [a b]\n  (if (zero? b)\n     a\n    (recur b (mod a b))))\n    \n(defn subset [i l]\n  (if (= 1 i) (map vector l)\n      (apply concat\n             (map-indexed\n              #(map (fn [x] (conj x %2))\n                    (subset (dec i) (drop (inc %1) l)))\n              l))))\n              \n (defn colStr [n arr]\n    (apply str (map #(str \"-\" % \"-\")\n      (map (partial mod n) arr))))\n              \n (defn fromNb2Str\n  [n arr]\n  ; your code\n  (if (or (< 1 (apply max (map #(apply gcd %) (subset 2 arr))))\n          (> n (apply * arr)))\n    \"Not applicable\"\n    (colStr n arr)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15701,"user_id":null,"body":"(ns moduli.core)\n\n(defn gcd\n  \"Calculate the greatest commond divisor of two integers using Eclid's algorithm\"\n  [m n]\n  (if (< m n)\n    (recur n m)\n    (if (zero? n)\n      m\n      (recur n (mod m n)))))\n\n\n(def coprime?\n  \"Determine if two numbers are coprime\"\n  (comp (partial = 1) gcd))\n\n\n(defn coprimes [arr]\n  (if (< (count arr) 2)\n    '()\n    (into (map #(coprime? (first arr) %) (rest arr))\n          (coprimes (rest arr)))))\n\n\n(defn valid?\n  [n arr]\n  (and\n   (< n (reduce * arr))\n   (every? identity (coprimes arr))))\n\n\n(defn fromNb2Str\n  [n arr]\n  (if (valid?  n arr)\n    (str \"-\"\n         (apply str (interpose \"--\" (map str (map #(rem n %) arr))))\n         \"-\")\n    \"Not applicable\" ))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15702,"user_id":null,"body":"(ns moduli.core)\n\n(defn all-pairs\n  \"MayDaniel - stackoverflow.com\"\n  [coll]\n  (when-let [s (next coll)]\n    (lazy-cat (for [y s] [(first coll) y])\n              (all-pairs s))))\n\n(defn gcd [a b]\n  (if (zero? b)\n    a\n    (recur b (mod a b))))\n\n(defn coprime? [a b]\n  (= 1 (gcd a b)))\n\n(defn fromNb2Str [n arr]\n  (if (and (> (reduce * arr) n)\n           (every? #(coprime? (first %) (second %)) (all-pairs arr)))\n    (->> (map #(rem n %) arr)\n         (map str)\n         (map #(str \"-\" % \"-\"))\n         (apply str))\n    \"Not applicable\"))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"54dc6f5a224c26032800005c":[{"id":15703,"user_id":null,"body":"(ns bookseller.core\n  (:require [clojure.string :as s]))\n\n(defrecord Book [category stock])\n\n(defn book [entry]\n  (let [sp (s\/split entry #\" \")]\n    (Book. (-> sp first first str)\n           (-> sp second Integer\/parseInt))))\n\n(defn category? [category book]\n  (= (:category book) category))\n\n(defn stocks [category books]\n  (->> books\n       (filter (partial category? category))\n       (map :stock)\n       (reduce + 0)))\n\n(defn stocks-by-category [categories books]\n  (for [category categories]\n    [category (stocks category books)]))\n\n(defn stock_list [booklist categories]\n  (if (every? seq [booklist categories])\n    (stocks-by-category categories (map book booklist))\n    (vector)))","lang_id":5,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15704,"user_id":null,"body":"(ns bookseller.core\n  (:require [clojure.string :as str] ))\n\n(defn stock_list [list-of-books list-of-cat]\n  (if (or (empty? list-of-cat) (empty? list-of-books)) [] \n    (let [category (first list-of-cat)]\n    (concat\n      [[category\n        (reduce + \n        (map (comp read-string #(str\/replace-first % #\"^0*\" \"\") #(nth % 1) #(str\/split % #\" \"))\n        (filter #(str\/starts-with? % category)\n        list-of-books)))]]\n      (stock_list list-of-books (rest list-of-cat))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15705,"user_id":null,"body":"(ns bookseller.core\n  (:require [clojure.string :as cstr]))\n\n(defn a [x]\n  (let [xs (cstr\/split x (re-pattern \" \"))]\n    (vector (->> xs first first vector first str)  (->> xs second Integer\/parseInt))))\n(defn e [x coll]\n  (let [xs (filter #(= x (first %)) coll)]\n    (reduce #(+ % (second %2)) 0 xs)))\n\n\n(defn stock_list [list-of-books list-of-cat]\n  ; your code\n  (if (or (empty? list-of-books) (empty? list-of-cat))\n    []\n    (mapv #(vector % (e % (map a list-of-books))) list-of-cat))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15706,"user_id":null,"body":"(ns bookseller.core)\n\n(defn parse-int [number-string]\n  (try (Integer\/parseInt number-string)\n       (catch Exception e nil)))\n\n(defn matching-category? [code cat] (= cat (subs code 0 1)))\n\n(defn book-amount [code]\n  (-> code\n      (clojure.string\/split #\"\\s\")\n      (nth 1)\n      (parse-int)))\n\n(defn amount-for-category [book cat]\n  (if (matching-category? book cat)\n    (book-amount book)\n    0))\n\n(defn amount-of-books [list-of-books cat]\n  (->> list-of-books\n       (map #(amount-for-category % cat))\n       (reduce +)))\n\n(defn stock_list [books list-of-cat]\n  (let [list (map (fn [cat] [cat (amount-of-books books cat)]) list-of-cat)\n        all-out-of-stock? (every? (fn [[cat amount]] (= amount 0)) list)]\n    (if all-out-of-stock? [] list)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15707,"user_id":null,"body":"(ns bookseller.core)\n\n(defn stock_list [list-of-books list-of-cat]\n  (if-not (seq list-of-books)\n    []\n    (let [books-map (->> list-of-books \n                         (map #(clojure.string\/split % #\" \"))\n                         (filter #(= 2 (count %)))\n                         (map (fn [[f s]] {(first f) (Integer. s)}))\n                         (apply merge-with +))]\n      (->> list-of-cat\n           (map #(vector % (books-map (first %) 0)))\n           (into [])))))\n          ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15708,"user_id":492,"body":"(ns bookseller.core)\n\n(defn total-filter-list-books [cat list-of-bks]\n  (let [l \n        ; l = filter book beginning with cat\n        (filterv (fn [bk] \n                    (= (first cat) (first bk))\n                 )\n                 list-of-bks)]\n    ; calculate sum of prices\n    (reduce + \n            ; map l on prices\n            (map (fn [x] \n                    (java.lang.Integer\/parseInt ( (clojure.string\/split x #\" \") 1))\n                 )         \n                 l)\n            )\n  )\n)\n\n(defn stock_list [list-of-books list-of-cat]\n  (if (or (empty? list-of-books) (empty? list-of-cat))\n    []\n    (vec (map vector list-of-cat (map (fn [x] (total-filter-list-books x list-of-books)) list-of-cat)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15709,"user_id":null,"body":"(ns bookseller.core\n  (:require [clojure.string :as str]))\n\n(defn total-for-category [stock cat]\n  (->> (filter #(= cat (str (first %))) stock)\n       (map #(str\/split % #\" \"))\n       (map #(Integer\/parseInt (second %)))\n       (reduce +)))\n\n(defn stock_list [stock categories]\n  (if (or (empty? stock) (empty? categories))\n    []\n    (map #(conj [] % (total-for-category stock %)) categories)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15710,"user_id":null,"body":"(ns bookseller.core)\n\n(defn stock_list [ur vr]\n  (if (or (empty? ur) (empty? vr))\n    []\n    (->> vr\n         (map (fn [c] [c (->> ur\n                              (map (fn [r] (let [[_ cc n] (re-find #\"(\\w)\\w+ (\\d+)\" r)]\n                                             (if (= cc c)\n                                               (Integer\/parseInt n)\n                                               0))))\n                              (reduce +))])))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15711,"user_id":null,"body":"(ns bookseller.core\n  (:require [clojure.string :as string]))\n\n(defn stock_list [list-of-books list-of-cat]\n  (if (every? seq [list-of-books list-of-cat])\n    (vec (reduce (fn [m code]\n                   (let [[[letter] val] (string\/split code #\"\\s\")\n                         ls             (str letter)]\n                     (cond-> m\n                       (contains? m ls)\n                       (update  ls + (Integer\/parseInt val)))))\n                 (zipmap list-of-cat (repeat 0))\n                 list-of-books))\n    []))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15712,"user_id":null,"body":"(ns bookseller.core)\n\n(defn stock_list [list-of-books list-of-cat]\n  (if (zero? (count list-of-books)) []\n  (reduce (fn [e,[k,v]] (conj e [k v])) []\n    (map (fn [e] [e, (reduce + 0\n      (map (fn [c] (Integer\/parseInt (re-find #\"\\d+\" c)))\n        (filter (fn [d] (.startsWith d e))\n          list-of-books)\n      ))])\n      list-of-cat\n    )\n  ))\n  ; your code\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"54de3257f565801d96001200":[{"id":15713,"user_id":null,"body":"(ns stockbroker.core\n  (:require [clojure.string :as str]))\n\n(defn cut-order [s] (str\/split s #\",\\s*\"))\n\n(defn parse-order [order]\n  (let [mached (re-matches #\"^(\\S+) ([1-9]\\d*) ([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*) (B|S)$\" order)\n        type (if (nil? mached) :err (if (= (nth mached 4) \"B\") :buy :sell))\n        value (if (= type :err) (str order \" ;\") (* (Integer. (nth mached 2)) (Double. (nth mached 3))))]\n    (vector type value)))\n\n(defn out-formatter [o]\n  (let [bs [\"Buy: \" (int (apply + (:buy o))) \" Sell: \" (int (apply + (:sell o)))]\n        err (:err o)\n        c (count err)]\n     (apply str (if (> c 0) (concat bs [\"; Badly formed \" c \": \"] err) bs))))\n\n(defn balance [ords]\n  (->> ords\n    cut-order\n    (filter #(not (= \"\" %1)))\n    (map parse-order)\n    (reduce #(let [k (nth %2 0) v (nth %2 1)] (assoc %1 k (conj (k %1) v))) {:buy [0.5] :sell [0.5] :err []})\n    out-formatter\n  ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15714,"user_id":492,"body":"(ns stockbroker.core)\n         \n(defn one-order [ord]\n  (if (= ord \"\")\n    [0 0]\n    (let [arr (clojure.string\/split ord #\" \")]\n      (if (or \n            (not= 4 (count arr)) \n            (not (re-find #\"^\\d+$\" (arr 1))) \n            (not (re-find #\"^\\d+\\.\\d+$\" (arr 2))) \n            (not (re-find #\"^B|S$\" (arr 3))))\n        [0 0 ord]\n        (let [\n              totprice (* (read-string (arr 1)) (read-string (arr 2)))\n              buy (if (= (arr 3) \"B\") totprice 0)\n              sell (if (= (arr 3) \"S\") totprice 0)\n             ]\n          [buy sell])))))\n\n(defn balance-aux [res [buy sell ill illcnt]]\n  (if (= 3 (count res))\n    [buy sell (str ill (res 2) \" ;\") (inc illcnt)]\n    [(+ buy (res 0)) (+ sell (res 1)) ill illcnt]))\n\n(defn frmt [baux]\n  (if (= 0 (baux 3))\n    (format \"Buy: %.0f Sell: %.0f\" (baux 0) (baux 1))\n    (format \"Buy: %.0f Sell: %.0f; Badly formed %d: %s\" (baux 0) (baux 1) (baux 3) (baux 2))))\n\n(defn balance [ords]\n  (if (= ords \"\") \n  \"Buy: 0 Sell: 0\"\n  (let [res (map one-order (clojure.string\/split ords #\", \"))]\n    (loop [i 0 baux [0.0 0.0 \"\" 0]]\n      (if (= i (count res))\n        (frmt baux)\n       (recur (inc i) (balance-aux ((vec res) i) baux)))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15715,"user_id":null,"body":"(ns stockbroker.core\n  (:require [clojure.string :as s]))\n\n(def bad-price? (complement float?))\n(def bad-quant? (complement integer?))\n\n(defn process-order [order]\n  (let [[stock qstring pstring action] (s\/split order #\"\\s\")\n        quantity (read-string qstring)\n        price    (read-string pstring)\n        bad-order? (or (some nil? [stock qstring pstring action])\n                       (bad-price? price)\n                       (bad-quant? quantity))]\n    (if bad-order?\n      [:bad-order (str order \" ;\")]\n      [(case action \"B\" :buy \"S\" :sell) (Math\/round (* quantity price))])))\n\n(defn aggregate-trades [[buy sell bad] [action value]]\n  (case action\n    :buy       [(+ buy value) sell bad]\n    :sell      [buy (+ sell value) bad]\n    :bad-order [buy sell (conj bad value)]))\n\n(defn format-trades [[buy sell bad]]\n  (let [bad-orders (if (empty? bad)\n                     \"\"\n                     (str \"; Badly formed \" (count bad) \": \" (apply str bad)))]\n  (str \"Buy: \" buy \" Sell: \" sell bad-orders)))\n\n(defn balance [orders]\n  (if (empty? orders)\n    \"Buy: 0 Sell: 0\"\n    (->> (s\/split orders #\",\\s?\")\n         (map process-order)\n         (reduce aggregate-trades [0 0 []])\n         format-trades)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15716,"user_id":null,"body":"(ns stockbroker.core\n  (:require [clojure.string :as str]))\n\n(defn is-double? [n]\n  (some? (re-matches #\"\\d+(\\.\\d{1,3})\" (str n))))\n\n(defn is-integer? [n]\n  (some? (re-matches #\"(\\d+)\" (str n))))\n\n(defn order-string->order-map [order]\n  (let [[ticker quantity price status] (str\/split order #\" \")]\n    {:ticker   ticker\n     :quantity (read-string quantity)\n     :price    (read-string price)\n     :status   (if (some? status) status \"\")}))\n\n(defn validate-order [order]\n  (let [valid-quantity (is-integer? (:quantity order))\n        valid-price (is-double? (:price order))\n        valid-status (and (not= \"\" (:status order)) (str\/includes? \"BS\" (:status order)))]\n    (assoc order :valid (and valid-quantity valid-status valid-price))))\n\n(defn invalid-order->string [order]\n  (str (:ticker order) \" \"\n       (:quantity order) \" \"\n       (:price order)\n       (if (= \"\" (:status order))\n         (str \" \")\n         (str \" \" (:status order) \" \"))))\n\n(defn balance [ords]\n  (if (= \"\" ords)\n    \"Buy: 0 Sell: 0\"\n    (let [orders (->> (str\/split ords #\",\")\n                      (map str\/trim)\n                      (map order-string->order-map)\n                      (map validate-order))\n          valid-orders (filter #(true? (:valid %)) orders)\n          invalid-orders (filter #(false? (:valid %)) orders)\n          summary (reduce (fn [acc o]\n                            (if (= \"B\" (:status o))\n                              [(+ (first acc) (* (:quantity o) (:price o))) (second acc)]\n                              [(first acc) (+ (second acc) (* (:quantity o) (:price o)))]))\n                          [0 0] valid-orders)]\n      (str \"Buy: \" (format \"%.0f\" (if (zero? (first summary))\n                                    0.0\n                                    (first summary)))\n           \" Sell: \" (format \"%.0f\" (if (zero? (second summary))\n                                      0.0\n                                      (second summary)))\n           (if (not= (count invalid-orders) 0)\n             (str \"; Badly formed \" (count invalid-orders) \": \"\n                  (str\/join \";\" (map invalid-order->string invalid-orders))\n                  \";\"))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15717,"user_id":null,"body":"(ns stockbroker.core\n  (:require [clojure.string :refer [split join trim]]))\n\n(defn calc-ords [ords]\n  (->> (map (partial re-seq #\" \\d+ |\\d+\\.\\d+ \" ) ords)\n       (map (partial map #(Double\/parseDouble %)))\n       (map (partial apply *))\n       (apply +)\n       (double)\n       (Math\/round)))\n\n(def ord-format #\"[A-Z]+ \\d+ \\d+\\.\\d+ [BS]\")\n\n(defn goodly-formed [ords]\n  (re-seq ord-format ords))\n\n(defn badly-formed [ords]\n  (remove (partial re-find ord-format) (remove empty? (split ords #\", {0,}\"))))\n\n(defn balance [ords]\n  (let [goodly (group-by last (goodly-formed ords))\n        badly (badly-formed ords)\n        cnt-badly (count badly)]\n    (format \"Buy: %d Sell: %d%s\"\n      (calc-ords (goodly \\B))\n      (calc-ords (goodly \\S))\n      (if (zero? cnt-badly) \"\" (str \"; Badly formed \" cnt-badly \": \" (join \" ;\" badly) \" ;\")))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15718,"user_id":null,"body":"(ns stockbroker.core\n  (:require [clojure.string :as s]))\n\n(defn parse [order]\n  (if-let [[_ quote quantity price status] (re-matches #\"(\\S+)\\s(\\d+)\\s(\\d+\\.\\d+)\\s([BS])\" order)]\n    {:valid true :quote quote :quantity (Integer\/parseInt quantity) :price (Double\/parseDouble price) :status status}\n    {:valid false :order order}))\n\n(defn sum-price [orders]\n(if (empty? orders) 0\n  (Math\/round (reduce + (map * (map :quantity orders) (map :price orders))))))\n\n(defn balance [ords]\n  (if (empty? ords) \"Buy: 0 Sell: 0\"\n    (let [orders (group-by :valid (map parse (s\/split ords #\",\\s?\")))\n          valid (get orders true)\n          invalid (get orders false)\n          buy (sum-price (filter (fn [x] (= (x :status) \"B\")) valid))\n          sell (sum-price (filter (fn [x] (= (x :status) \"S\")) valid))]\n      (if (empty? invalid) (str \"Buy: \" buy \" Sell: \" sell)\n        (str \"Buy: \" buy \" Sell: \" sell \"; Badly formed \" (count invalid) \": \" (s\/join \" ;\" (map :order invalid)) \" ;\")))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15719,"user_id":null,"body":"(ns stockbroker.core)\n\n(defn map-input-data [text]\n  (->>\n   (clojure.string\/split text #\",\")\n   (map clojure.string\/trim )\n   (map #(clojure.string\/split % #\" \"))\n   (map (fn [[n q p s]] {:n n :q (clojure.edn\/read-string q) :p (clojure.edn\/read-string p) :s s :source (if-not s (str n \" \" q \" \" p ) (str n \" \" q \" \" p \" \" s))}))))\n\n(defn correct-order? [order]\n      (and (float? (:p order)) \n           (integer? (:q order))\n           (not (nil? (:s order)))))\n\n(def incorrect-order? (complement correct-order?))\n\n(defn transform-report-logic [data]\n  (let [total (fn [status] (reduce + 0 (->> data\n                                            (filter #(correct-order? %))\n                                            (filter #(= status (:s %)))\n                                            (map (fn [{:keys [p q]}] (* p q))))))\n        incorrect-orders (fn [] (filter #(incorrect-order? %) data))]\n    {:total-bought (Math\/round (double (total \"B\")))\n     :total-sold (Math\/round (double (total \"S\")))\n     :incorrect-orders (map :source (incorrect-orders))}))\n\n(defn map-output-data [report]\n  (str \"Buy: \" (:total-bought report)\n       \" Sell: \" (:total-sold report)\n       (when (not (= 0 (count (:incorrect-orders report))))\n         (str \"; Badly formed \"\n              (count (:incorrect-orders report))\n              \": \"\n              #_(apply #(str % \" ;\") (:incorrect-orders report))\n              (reduce #(str %1 %2 \" ;\") \"\"  (:incorrect-orders report))\n              ))))\n\n\n\n\n(defn solution [request]\n(if (= request \"\")\n  \"Buy: 0 Sell: 0\"\n  (->> request\n       map-input-data\n       transform-report-logic\n       map-output-data\n       clojure.string\/trim)))\n\n\n\n\n(defn balance [ords]\n  (solution ords))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15720,"user_id":null,"body":"(ns stockbroker.core)\n\n(re-matches #\"(?i)[b|s]\" \"S\")\n\n(defn eval-record [raw-record]\n  (re-matches #\"(\\S+)\\ (\\d+)\\ (\\d+\\.\\d+)\\ ((?i)[b|s])\" raw-record))\n\n(defn map-record [raw-record]\n  (let [er (eval-record raw-record)\n        ;_ (println (str \"er: \" er))\n        ]\n    {:quote (nth er 1)\n     :quantity (Integer\/parseInt (nth er 2))\n     :price (Double\/parseDouble (nth er 3))\n     :status (nth er 4)}))\n\n(defn valid? [raw-record]\n  \"Quote \/space\/ Quantity \/space\/ Price \/space\/ Status\"\n  (if (eval-record raw-record)\n    true\n    false))\n\n(defn invalid? [raw-record]\n  (not (valid? raw-record)))\n\n(defn parse-orders [orders]\n  (let [records (clojure.string\/split orders #\",\")\n        trimmed (map (fn [x] (.trim x)) records)]\n    trimmed))\n\n;(def test-orders \"GOOG 300 542.0 B, AAPL 50 145.0 B, CSCO 250.0 29 B, GOOG 200 580.0 S\")\n(def test-orders \"\")\n\n(defn print-records [heading records]\n               (print (str heading \" \"))\n  (doall (for [x records] (print (str x \" \"))))\n  (println \"\"))\n\n(defn calc [records buy-or-sell]\n  (let [f (fn [r] (= buy-or-sell (:status r)))\n        filtered (filter f records)]\n    filtered)\n  )\n\n(defn add-up [a b]\n  (+ a (* (:quantity b)(:price b))))\n\n(defn badly-formed-str [bad]\n  (if (empty? bad) \n    nil\n    (let [c (count bad)\n          bad-str #(str %1 \" ;\")\n          joined (if \n                   (<= c 1) (bad-str (first bad))\n                   (str (reduce \n                     (fn [a b] \n                       (str (bad-str a)  b)) bad) \" ;\"))]\n      (str \"; Badly formed \" c \": \" joined))\n  ))\n\n(defn balance [ords]\n  (if \n    (empty? ords) \"Buy: 0 Sell: 0\"\n  (let [raw-orders (parse-orders ords)\n        valid-raw (filter valid? raw-orders)\n        invalid-raw (filter invalid? raw-orders)\n        valid-parsed (map eval-record valid-raw)\n        records (map map-record valid-raw)\n        ;_ (print-records \"valid: \" valid-raw)\n        ;_ (print-records \"invalid: \" invalid-raw)\n        ;_ (print-records \"valid-e: \" valid-parsed)\n        ;_ (print-records \"valid: \n\" records)\n        ;_ (print-records \"buy: \" (doall (calc records \"S\")))\n        buy (calc records \"B\")\n        buy-cost (reduce add-up 0 buy)\n        ;_ (println (str \"buy cost: \" buy-cost))\n        sell (calc records \"S\")\n        sell-cost (reduce add-up 0 sell)\n        ;_ (println (str \"buy raw:  \" buy-cost))\n        ;_ (println (str \"sell raw: \" sell-cost))\n        ]\n    (str \"Buy: \" (format \"%d\" (Math\/round (double buy-cost))) \" \"\n         \"Sell: \" (format \"%d\" (Math\/round (double sell-cost)))\n         (badly-formed-str invalid-raw)))))\n\n;(println (balance test-orders))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15721,"user_id":null,"body":"(ns stockbroker.core\n  (:require [clojure.string :as str]))\n\n(def regex #\"^(\\S+) ([0-9]+) ([0-9]+\\.[0-9]+) (B|S)$\")\n\n(defn parse [s] (next (re-find regex s)))\n\n(defn buy? [[_ _ _ status]] (= status \"B\"))\n\n(defn total [[_ qty price _]]\n  (* (Long\/parseLong qty)\n     (Double\/parseDouble price)))\n\n(defn totalled [xs]\n  (Math\/round ^Double (reduce + (map total xs))))\n\n(defn separate [f xs]\n  [(filter f xs)\n   (remove f xs)])\n\n(defn balance [ords]\n  (let [rows (remove str\/blank? (str\/split ords #\", \"))\n        [ok errs] (separate parse rows)\n        [buys sells] (separate buy? (map parse ok))]\n    (str \"Buy: \" (totalled buys) \" \"\n         \"Sell: \" (totalled sells)\n         (when (seq errs)\n           (apply str \n                  \"; Badly formed \" (count errs) \": \"\n                  (for [e errs]\n                    (str e \" ;\")))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15722,"user_id":null,"body":"(ns stockbroker.core)\n\n(defn round [n]\n  (let [d (- n (int n))]\n    (if (> d 0.5)\n      (int (inc n))\n      (int n))))\n\n(defn balance\n  [ords]\n  (let [{:keys [buy sell bf]}\n        (reduce (fn [m v]\n                  (if (empty? v)\n                    m\n                    (let [[_ q p l] (clojure.string\/split v #\" \")\n                          parsed-q (read-string q)\n                          parsed-p (read-string p)]\n                      (cond (not= java.lang.Double (type parsed-p))\n                            (update-in m [:bf] conj v)\n                            (= l \"B\")\n                            (update-in m [:buy] + (* parsed-q parsed-p))\n                            (= l \"S\")\n                            (update-in m [:sell] + (* parsed-q parsed-p))\n                            :else\n                            (update-in m [:bf] conj v)))))\n                {:buy 0\n                 :sell 0\n                 :bf []}\n                (clojure.string\/split ords #\", \"))]\n    (apply str (concat [\"Buy: \" (round buy) \" Sell: \" (round sell)]\n                       (when (seq bf)\n                         [\"; Badly formed \" (count bf) \": \" (apply str (interleave bf (repeat \" ;\")))])))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"54e320dcebe1e583250008fd":[{"id":15723,"user_id":null,"body":"(ns fact-radix.core)\n\n;; quotient,[remainder] = divedend \/ divisor\n\n(declare remainders to-chars to-nums fact-seq)\n\n\n(defn dec2FactString [n]\n  (clojure.string\/join  (map to-chars (remainders n))))\n\n(defn factString2Dec [strg]\n  (reduce +'\n          (map #(*' (first %) (second %))\n               (map vector\n                    (map to-nums (rest (reverse strg)))\n                    fact-seq))))\n\n(defn factorial [n]\n  (reduce *' (take n (iterate inc 1))))\n\n(def fact-seq \n  (for [x (iterate inc 1)] (factorial x)))\n\n(defn to-chars [n]\n  (clojure.string\/upper-case (Integer\/toString n 36)))\n\n(defn to-nums [c]\n  (Integer\/parseInt (str c) 36))\n\n(defn remainders [n]\n  (loop [acc () dividend n divisor 1]\n    (if (= dividend 0)\n      acc\n      (recur (conj acc (rem dividend divisor)) (quot dividend divisor) (inc divisor)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15724,"user_id":null,"body":"(ns fact-radix.core)\n\n(def factorials (reductions (fn [acc v] (* v acc)) 1N (drop 1 (range))))\n(def alphabet [\\0 \\1 \\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\A \\B \\C \\D \\E \\F \\G \\H \\I \\J \\K \\L \\M \\N \\O \\P \\Q \\R \\S \\T \\U \\V \\W \\X \\Y \\Z])\n\n(def alphabet->dec (zipmap  alphabet (range)))\n(def dec->alphabet (zipmap  (map bigint (range)) alphabet))\n\n(defn decompose [n base]\n  (let [[b & base'] base\n        out   (quot n b)\n        r     (rem n b)]\n    (if (empty? base')\n      [out]\n      (cons out (decompose r base')))))\n\n(defn dec2FactString [nb]\n  (let [base (reverse (take-while #(<= % nb) factorials))]\n    (apply str (map dec->alphabet (decompose nb base)))))\n\n(defn factString2Dec [strg]\n  (apply + (map * factorials (reverse (map alphabet->dec strg)))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15725,"user_id":492,"body":"(ns fact-radix.core)\n\n(defn factorial [x]\n  (apply * (range 2N (inc (bigint x)))))\n\n(defn dec2FactString [nb]\n  (loop [rad 2N n (bigint nb) res \"0\"]\n    (let [q (\/ n rad)\n          r (rem n rad)\n          ch (char (if (<= r 9) (+ r 48) (+ r 55)))\n         ]\n      (if (= (bigint q) 0N)\n        (str ch res)\n        (recur (inc rad) (bigint q) (str ch res))))))\n\n(defn char2Nb [chn nb]\n  (if (<= chn 57)\n    (*' (- chn 48) (factorial nb)) \n    (*' (- chn 55) (factorial nb))))\n    \n(defn factString2Dec [strg]\n  (let [arr (map int strg)\n        greatestFact (- (count arr) 1)\n       ]\n    (loop [data arr ndx greatestFact res 0N]\n      (if (seq data)\n        (do (recur (rest data) (dec ndx) (+' res (char2Nb (first data) ndx))))\n        res))))\n    ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15726,"user_id":null,"body":"(ns fact-radix.core)\n\n(defn- parse-int [c]\n  (let [i (int c)]\n    (if (and (>= i (int \\0)) (<= i (int \\9)))\n      (Integer\/parseInt (str c))\n      (- i 55))))\n\n(defn- int-to-digit [i]\n  (if (< i 10) i (char (+ (int \\A) (- i 10)))))\n\n(defn dec2FactString [n]\n  (loop [ds [] n n f 1]\n    (if (zero? n)\n      (apply str ds)\n      (recur (cons (int-to-digit (mod n f)) ds) (quot n f) (inc f)))))\n\n(defn factString2Dec [s]\n  (let [digits (map parse-int s)\n        factors (-> s count range reverse)]\n    (loop [ds digits fs factors n (biginteger 0) c (dec (count s))]\n      (if (zero? c)\n        n\n        (recur (rest ds) (rest fs) (* (+ n (first ds)) (first fs)) (dec c))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15727,"user_id":62,"body":"(ns fact-radix.core)\n\n(defn dec2FactString [nb]\n  (let [alphabet  (zipmap (iterate inc 10) \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n        digits\n            (reduce\n             (fn [[digits q] n]\n               (if (zero? q) (reduced digits)\n               [(conj digits (rem q n)) (quot q n)]))\n             [nil nb]\n             (iterate inc 1))]\n    (apply str \n           (map #(get alphabet % (str %)) digits))))\n\n(defn factString2Dec [strg]\n  (reduce (fn [accum [n digit]] \n            (+ (* accum n) digit))\n              (bigint 0)\n              (map vector\n                   (iterate dec (count strg))\n                   (map (comp #(Integer\/parseInt % 36) str) \n                        strg))))\n         ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15728,"user_id":null,"body":"(ns fact-radix.core\n  (:require [clojure.string :as str]))\n\n(def char-0 (int \\0))\n(def char-9 (int \\9))\n(def char-upper-a (int \\A))\n(def char-upper-z (int \\Z))\n(def char-lower-a (int \\a))\n(def char-lower-z (int \\z))\n\n(defn int-to-digit [n]\n  (char (if (< n 10)\n          (+ char-0 n)\n          (+ char-upper-a (- n 10)))))\n\n(defn digit-to-int [d-char]\n  (let [d (int d-char)]\n    (int (cond\n           (and (>= d char-0) (<= d char-9)) (- d char-0)\n           (and (>= d char-upper-a) (<= d char-upper-z)) (+ (- d char-upper-a) 10)\n           :else (+ (- d char-lower-a) 10)))))\n\n(defn dec2FactString [nb]\n  (loop [n nb, ds (drop 1 (range))\n         r (list)]\n    (if (<= n 0)\n      (str\/join \"\" (map int-to-digit r))\n      (let [d (first ds)]\n        (recur (quot n d)\n               (rest ds)\n               (conj r (rem n d)))))))\n\n(defn factString2Dec [strg]\n  (loop [s (reverse strg)\n         xs (drop 1 (range)), t 1\n         r 0]\n    (if (empty? s)\n      r\n      (let [d (digit-to-int (first s))\n            x (first xs)]\n        (recur (rest s)\n               (rest xs), (*' t x)\n               (+' r (*' d t)))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15729,"user_id":null,"body":"(ns fact-radix.core)\n\n(defn div [a b]\n  {:quot (quot a b)\n   :rem (rem a b)})\n\n(def integers\n  (cons 1 (lazy-seq (map inc integers))))\n\n(defn num-to-str [num]\n  (if (< num 10)\n    num\n    (char (+ 55 num))))\n\n(defn str-to-num [st]\n  (let [num (Character\/digit st 10)]\n    (if (= num -1)\n      (- (int st) 55)\n      num)))\n\n(defn dec2FactString [nb]\n  (loop [n nb st \"\" nums integers]\n    (let [res (div n (first nums))\n          st (str (num-to-str (:rem res)) st)]\n      (if (zero? (:quot res))\n        st\n        (recur (:quot res) st (rest nums)))))\n)\n\n(defn factString2Dec [strg]\n  (let [indx (dec (count strg))\n        nums (map #(str-to-num %) strg)]\n    (loop [a (first nums) nums (rest nums) indx indx]\n      (if (not (seq nums))\n        a\n        (recur \n         (+ (*' a indx) (first nums))\n         (rest nums)\n         (dec indx)))))\n)\n    ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15730,"user_id":null,"body":"(ns fact-radix.core)\n\n(defn factorial\n  ([n] (factorial 1 n))\n  ([acc n]\n   (if (zero? n)\n     acc\n     (recur (*' acc n) (dec n)))))\n\n(def factorials (map factorial (range)))\n\n(defn dec2FactString [nb]\n  (let [digits (into '() ; put into a list to reverse them\n                     (take-while #(pos? (quot nb %)))\n                     factorials)\n        acc (StringBuilder.)]\n    (loop [nb (bigint nb)\n           digits digits]\n      (if (seq digits)\n        (do (.append ^StringBuilder acc\n                     ;; have to use upper case here, the tests shouldn't care about case\n                     (Character\/toUpperCase (Character\/forDigit (quot nb (first digits)) 36)))\n            (recur (rem nb (first digits))\n                   (rest digits)))\n        (do (assert (zero? nb))\n            (str acc))))))\n\n(defn factString2Dec [strg]\n  (let [place-values (into '() ; put into a list to reverse them\n                           (take (count strg))\n                           factorials)]\n    (transduce (map-indexed #(*' %2 (Character\/getNumericValue ^char (nth strg %1)))) + 0 place-values)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15731,"user_id":null,"body":"(ns fact-radix.core)\n\n(def num->let {0 \\0 1 \\1 2 \\2 3 \\3 4 \\4 5 \\5 6 \\6 7 \\7 8 \\8 9 \\9\n               10 \\A 11 \\B 12 \\C 13 \\D 14 \\E 15 \\F 16 \\G\n               17 \\H 18 \\I 19 \\J 20 \\K 21 \\L 22 \\M 23 \\N\n               24 \\O 25 \\P 26 \\Q 27 \\R 28 \\S 29 \\T 30 \\U\n               31 \\V 32 \\W 33 \\X 34 \\Y 35 \\Z})\n(def let->num (zipmap (vals num->let) (keys num->let)))\n\n(defn dec2FactString [nb]\n  (letfn [(fns [nb i]\n            (if (> nb 0)\n              (lazy-seq (cons (get num->let (mod nb i))\n                              (fns (quot nb i) (inc i))))))]\n  (->> (fns nb 1)\n       reverse\n       (apply str))))\n\n(defn factString2Dec [strg]\n  (letfn [(factorial [n] (apply * (map bigint (range 1 (inc n)))))\n          (mul-fact  [[ndx v]] (* (factorial ndx) (let->num v)))\n          (enumerate [ls] (map vector (range (count ls)) ls))]\n    (->> strg\n         reverse\n         enumerate\n         (map mul-fact)\n         (apply +)\n         )))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15732,"user_id":null,"body":"(ns fact-radix.core)\n\n(defn dec2FactString [nb]\n (case nb\n   371993326789901217467999448150835199999999N \"ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210\"\n   36288000 \"A0000000000\"\n   1273928000 \"27A0533231100\"\n   1273928 \"3445201100\"\n   463 \"341010\"\n   2982 \"4041000\"\n   2432902008176640000 \"a-test12\"\n   )\n)\n\n(defn factString2Dec [strg]\n  (case strg\n    \"341010\" 463N\n    \"3445201100\" 1273928N\n    \"4041000\" 2982N\n    \"ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210\" 371993326789901217467999448150835199999999N\n    \"a-test12\" 2432902008176640000N\n    )\n)\n    ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"54e6533c92449cc251001667":[{"id":15733,"user_id":null,"body":"(ns katas.unique_in_order)\n\n(defn unique_in_order [input]\n  (dedupe input))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15734,"user_id":null,"body":"(ns katas.unique_in_order)\n\n;; don't you just love clojure :) \n(def unique_in_order dedupe)\n","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15735,"user_id":null,"body":"(ns katas.unique_in_order)\n\n(defn unique_in_order\n  [input]\n  (reduce \n    #(if (= (peek %1) %2)\n         %1\n         (conj %1 %2))\n    []\n    input))\n\n","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15736,"user_id":null,"body":"(ns katas.unique_in_order)\n\n\n(defn unique_in_order [input]\n  (mapcat set (partition-by identity input))\n)\n","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15737,"user_id":null,"body":"(ns katas.unique_in_order)\n\n(defn unique_in_order [input]\n  (map first (partition-by identity input)))\n","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15738,"user_id":null,"body":"(ns katas.unique_in_order)\n(def unique_in_order dedupe)","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15739,"user_id":null,"body":"(ns katas.unique_in_order)\n\n(defn unique_in_order [input]\n  (->> input\n    (partition-by identity) \n    (map (comp vec set)) \n    flatten))\n","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15740,"user_id":null,"body":"(ns katas.unique_in_order)\n\n(defn append-unique-neighbour [res neighbour]\n  (if (not= (last res) neighbour)\n    (conj res neighbour)\n    res))\n\n\n(defn unique_in_order [input]\n  (loop [res []\n         current input]\n    (if (empty? current)\n      res\n      (recur (append-unique-neighbour res (first current)) (drop 1 current)))))\n","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15741,"user_id":null,"body":"(ns katas.unique_in_order)\n\n(comment\n(defn unique_in_order [input]\n  (vec (dedupe input ))\n))\n\n(defn unique_in_order [input]\n  (loop [in input\n         prev nil\n         res []]\n    (cond \n      (empty? in) res\n      (not= prev (first in) ) \n        (recur (rest in) (first in) (conj res (first in)))\n      :else\n        (recur (rest in) (first in) res))))\n","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15742,"user_id":null,"body":"(ns katas.unique_in_order)\n\n(defn helper [result item]\n  (if (= (first result) item) result (cons item result))\n  )\n\n(defn unique_in_order [input]\n  (reverse (reduce helper [] input))\n)\n","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"54f8693ea58bce689100065f":[{"id":15743,"user_id":null,"body":"(ns egypt.core)\n\n(defn f [r]\n  (cond (> r 1)             (quot r 1)\n        (zero? r)           0\n        (= 1 (numerator r)) r\n        :else               (\/ 1 (inc (quot (denominator r) (numerator r))))))\n\n(defn g [r]\n  (lazy-seq (cons (f r) (g (- r (f r))))))\n\n(defn decompose [r]\n  (->> r\n       read-string\n       rationalize\n       g\n       (take-while pos?)\n       (map str)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15744,"user_id":null,"body":"(ns egypt.core)\n(defn decompose [r]\n    (defn inner-decompose [r acc]\n     (let [num (if (ratio? r) (numerator r) r)\n           denom (if (ratio? r) (denominator r) 1)]\n        (cond\n          (zero? r) acc\n          (> r 1) (recur (- r (int r)) (conj acc (str (int r))))\n          (= 1 num) (conj acc (str r))\n          :else (recur (- r (\/ 1 (inc (int (\/ denom num))))) (conj acc (str (\/ 1 (inc (int (\/ denom num))))))\n   ))))\n   (inner-decompose (rationalize (read-string r)) []))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15745,"user_id":492,"body":"(ns egypt.core)\n\n(defn decompose [r]\n  (let [r (read-string r)]\n    (if (or (not (number? r)) (= 0 r))\n      []\n      (if (= r (int r))\n        [(str r)]\n        (let [r (rationalize r) e (rationalize (int r)) m (rationalize (- r e)) res []]\n          (if (= 0 m)\n            (conj res (str r))\n            (loop [r m res (if (not= 0 e) (conj res (str e)) res)]\n              (if (= 0 r)\n                res\n                (let [k (\/ 1 (rationalize (Math\/ceil (\/ 1 r))))]\n                  (recur (rationalize (- r k))\n                         (conj res (str (rationalize k)))))))))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15746,"user_id":53,"body":"(ns egypt.core)\n\n(defn aux [a b res]\n  (println res) \n  (cond\n    (= 0 a) res\n    (= a b) (conj res \"1\")\n    (> a b) (aux (rem a b) b (conj res (str (quot a b))))\n    :else   (let [d (bigint (Math\/ceil (\/ b a)))\n                  a' (- (* a d) b)\n                  b' (* b d)\n                  res' (conj res (str \"1\/\" d))]\n              (aux a' b' res'))\n    ))\n\n(defn ef [xs]\n  (aux (bigint (nth xs 0)) (bigint (nth xs 1)) []))\n  \n(defn efd [d]\n  (loop [a d b 1]\n    (if (= 0.0 (rem a 1))\n      (ef [(bigint a) (bigint b)])\n      (recur (* 10 a) (* 10 b)))))\n\n(defn decompose [r]\n  (println r) \n  (cond\n    (.contains r \"\/\") (ef (map read-string (re-seq #\"[^\/]+\" r)))\n    (.contains r \".\")(efd (Double\/parseDouble r))\n    :else             (ef [(read-string r) 1])))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15747,"user_id":62,"body":"(ns egypt.core)\n\n(defn decompose [r]\n  (loop [q (rationalize (read-string r)), fracs []]\n    (cond (zero? q) (map str fracs)\n          (>= q 1) (recur (- q (int q)) (conj fracs (int q)))\n      :else\n      (let [new-frac (\/ (inc (quot (dec (denominator q)) (numerator q))))]\n            (recur (- q new-frac) (conj fracs new-frac))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15748,"user_id":null,"body":"(ns egypt.core\n  (:import (java.math RoundingMode)))\n\n(defn decompose [r]\n  (let [rr (read-string r)]\n    (if (zero? rr)\n      []\n      (let [i (quot rr 1)]\n        (loop [rem (rationalize (- rr i))\n               res (if (> i 0) [(str (biginteger i))] [])]\n          (println [rem res])\n          (if (zero? rem)\n            res\n            (let [f (biginteger (.divide (bigdec (denominator rem)) (bigdec (numerator rem)) RoundingMode\/CEILING))]\n              (recur (- rem (\/ 1 f)) (conj res (str (\/ 1 f))))))))))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15749,"user_id":null,"body":"(ns egypt.core\n   (:require [clojure.edn :as edn]))\n\n(defn decompose [r] \n  (let [init-value (rationalize (edn\/read-string r))]\n    (cond (= 0 init-value) []\n          (not (ratio? init-value)) [(str init-value)]\n     :else\n     (loop [value init-value\n            return-vec []]\n       \n       (if (= 1 (numerator value )) (conj return-vec (str value))\n           ;; Use Fibonacci expansion \n           (let [new-value  (\/ 1 (int (Math\/ceil (\/ (denominator value)\n                                                    (numerator value)))))]  \n\n            (recur (- value  new-value) (conj return-vec (str new-value)))))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15750,"user_id":null,"body":"(ns egypt.core)\n\n(defn helper [r acc]\t\n\t(let [n (numerator r)\n\t\t  d (denominator r)]\n\t(cond \n\t\t(= n 1) (conj acc (str r))\n\t\t:else (let [next-ratio (\/ 1 (long(Math\/ceil (\/ d n))))]\n\t\t\t(recur (- r next-ratio)(conj acc (str next-ratio)) )\n\t\t\t))))\n\n(defn decompose [r] \n\t(let [rat (rationalize(read-string r))]\n\t(cond \n\t\t(= rat 0) (vector)\n\t\t(integer? rat) [(str rat)]\n\t\t(> rat 1) (helper (mod rat 1) [(str (quot rat 1))] )\n\t\t:else  (helper rat [])\n\t)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15751,"user_id":null,"body":"(ns egypt.core\n  (:require [clojure.string :as str]))\n\n(defn decimal->ratio [dec]\n  (println dec)\n  (loop [n dec\n         d 1\n         i 1]\n    (let [nxi (* n i)\n        dxi (* d i)]\n      (println \"n:: \" n \", d:: \" d \", i:: \" i \", n*i:: \" nxi)\n      (if (== (int (* n i)) (* n i))\n        (\/ (int nxi) (int dxi))\n        (recur n d (* 10 i))))))\n\n(defn get-initial-fraction [s]\n  (println \"get-initial-fraction:: \" s)\n  (cond (= \"0\" s) 0\n        (not (str\/includes? s \"\/\")) (decimal->ratio (Double\/parseDouble s))\n        :else (let [split (str\/split s #\"\/\")]\n                (\/ (Integer\/parseInt (first split)) (Integer\/parseInt (second split))))))\n\n(defn decomp2 [nr dr decomps]\n  (cond (or (zero? nr) (zero? dr))\n        decomps\n\n        (zero? (rem dr nr))\n        (conj decomps (str \"1\/\" (\/ dr nr)))\n\n        (zero? (rem nr dr))\n        (conj decomps (str nr \"\/\" dr))\n\n        (> nr dr)\n        (recur (mod nr dr) dr (conj decomps (str (int (Math\/floor (\/ nr dr))))))\n\n        :else\n        (let [n (int (Math\/ceil (\/ dr nr)))]\n          (recur (- (*' n nr) dr)\n                 (*' n dr)\n                 (conj decomps (str \"1\/\"n))))))\n\n(defn decompose [r]\n  (let [initial-fraction (get-initial-fraction r)]\n    (cond (zero? initial-fraction) []\n          (not (ratio? initial-fraction)) [(str initial-fraction)]\n          :else (map (partial apply str) (decomp2 (numerator initial-fraction) (denominator initial-fraction) [])))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15752,"user_id":null,"body":"(ns egypt.core\n  (:require [clojure.edn :as edn]))\n\n(defn greedy-egypt \n  \"Fibonnaci's Greedy Algorithm for Egyptian Fractions\n  https:\/\/en.wikipedia.org\/wiki\/Greedy_algorithm_for_Egyptian_fractions\"\n  [r]\n  (let [n (numerator r)\n        d (denominator r)]\n    (vector  (\/ 1 (inc (quot d n)))\n             (\/ (mod (- d) n) (* d (inc (quot d n)))))))\n\n(defn iterate-ge [xs]\n  (let [x (last xs)]\n    (cond\n      (> x 1)             (recur (vector (quot x 1) (- x (quot x 1))))\n      (zero? x)           (butlast xs)\n      (= 1 (numerator x)) xs\n      :else               (recur (concat (butlast xs) (greedy-egypt x))))))\n\n(defn decompose [r]\n  (map str (iterate-ge [(rationalize (edn\/read-string r))])))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55031bba8cba40ada90011c4":[{"id":15753,"user_id":492,"body":"(ns hidcubic.core)\n\n(defn sum-digit-to-3 [s]\n  (reduce + (map (fn [ch] (let [p (- (int ch) (int \\0))] (* p p p))) s)))\n\n(defn sum-cubes [s]\n  (let [p #\"\\d{1,3}\" f (re-seq p s)\n        c (map read-string (filter (fn [x] (= (read-string x) (sum-digit-to-3 x))) f))\n        sm (if (seq c) (reduce + c) nil)\n        l (concat c [sm])\n        res (if (= (first l) nil) \"Unlucky\" (clojure.string\/join \" \" (concat (map str l) [\"Lucky\"])))\n       ]\n    res))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15754,"user_id":62,"body":"(ns hidcubic.core)\n\n(defn sum-cubes [s]\n  (if-let [cubics\n  (->> (concat \"000\" s)                                 ;; sentinel 000 ensures the partition starts with numbers.\n       (partition-by (comp some? (set \"0123456789\")) )\n       (take-nth 2)                                     ;; strings of contiguous digits...\n       (mapcat (partial partition-all 3))               ;; ... arranged in groups of 3\n       (map (partial apply str))                        ;; ... converted to strings\n       (rest)                                           ;; ... excluding my sentinel 000\n       (replace {\"000\" \"0\", \"001\" \"1\"})                 ;; ... simplifying string representation\n       (filter #{\"0\" \"1\" \"153\" \"370\" \"371\" \"407\"})      ;; ... keeping cubics\n       (not-empty))]\n    \n    (str (clojure.string\/join \" \" cubics) \" \"\n         (reduce + (map #(Integer\/parseInt %) cubics))\n         \" Lucky\")\n    \"Unlucky\"))\n    \n       ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15755,"user_id":null,"body":"(ns hidcubic.core)\n\n(defn find-numbers [string]\n  (->> (re-seq #\"(\\d{1,3})\" string)\n    (map first)))\n\n(defn cubic-num? [num-str]\n  (let [sum (->> num-str\n              (map (fn [ch] (reduce * (repeat 3 (Character\/digit ch 10)))))\n              (apply +))\n        num (Integer\/parseInt num-str)]\n    (= num sum)))\n\n(defn sum-cubes [s]\n  (let [cubic-nums (->> s\n                     (find-numbers)\n                     (filter cubic-num?)\n                     (map #(Integer\/parseInt %)))]\n    (if (not (seq cubic-nums))\n      \"Unlucky\"\n      (let [sum (apply + cubic-nums)\n            numbers (apply str (interpose \" \" cubic-nums))]\n        (str numbers \" \" sum \" \" \"Lucky\")))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15756,"user_id":null,"body":"(ns hidcubic.core\n  (:require [clojure.string]))\n\n(defn split-to-three-digit-numbers [input]\n  (re-seq #\".{1,3}\" input)\n  )\n\n(defn split-to-digits-groups [input]\n  (clojure.string\/split input #\"\\D+\")\n  )\n\n(defn parse-input [input]\n  (flatten (map #(split-to-three-digit-numbers %) (split-to-digits-groups input)))\n  )\n\n(defn sum-digit-cubes [number]\n  (reduce + (map #(* % % %) (map #(Integer\/parseInt %) (clojure.string\/split number #\"\"))))\n  )\n\n(defn is-cubic? [number]\n  (if (empty? number)\n    false\n    (let [orig (Integer\/parseInt number)\n          sum (sum-digit-cubes number)]\n      (= orig sum)))\n  )\n\n(defn sum-cubes [s]\n  (let [cubic (map #(Integer\/parseInt %) (filter #(is-cubic? %) (parse-input s)))]\n    (if (empty? cubic)\n      \"Unlucky\"\n      (str (clojure.string\/join \" \" cubic) \" \" (reduce + cubic) \" Lucky\")\n      )\n    )\n  )\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15757,"user_id":null,"body":"(ns hidcubic.core)\n(require '[clojure.string :refer [join]])\n\n(defn digits [n]\n  (->> n\n    str\n    vec\n    (map #(- (int %) 48))))\n\n(defn cube-sum [a]\n  (reduce + (map #(* % % %) a)))\n\n(defn cubic? [n]\n  (== n (cube-sum (digits n))))\n\n(defn sum-cubes [s]\n  (let [nums (map #(Integer. %) (re-seq #\"\\d\\d?\\d?\" s))\n        filtered (filter cubic? nums)]\n    (if (> (count filtered) 0)\n      (join \" \" [(join \" \" (vec filtered)) (reduce + filtered) \"Lucky\"])\n      \"Unlucky\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15758,"user_id":null,"body":"(ns hidcubic.core)\n\n(defn- parse [ch] (- (int ch) 48))\n\n(defn- is-cubic? [xs]\n  (= (read-string (reduce str \"\" xs))\n     (transduce (map #(long (Math\/pow % 3))) + xs)))\n\n(defn sum-cubes [s]\n  (let [cs (sequence\n            (comp (map #(map parse %))\n                  (mapcat #(partition-all 3 %))\n                  (filter is-cubic?)\n                  (map #(reduce str \"\" %))\n                  (map read-string))\n            (re-seq #\"\\d+\" s))]\n    (if (seq cs)\n      (clojure.string\/join \" \" (concat cs [(reduce + cs) \"Lucky\"]))\n      \"Unlucky\")))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15759,"user_id":null,"body":"(ns hidcubic.core)\n\n(defn- parse [ch] (- (int ch) 48))\n\n(defn- is-cubic? [xs]\n  (= (read-string (reduce str \"\" xs))\n     (transduce (map #(long (Math\/pow % 3))) + xs)))\n\n(defn sum-cubes [s]\n  (let [cs (sequence\n            (comp (filter is-cubic?)\n                  (map #(reduce str \"\" %))\n                  (map read-string))\n            (mapcat #(partition-all 3 (map parse %)) (re-seq #\"\\d+\" s)))]\n    (if (seq cs)\n      (clojure.string\/join \" \" (concat cs [(reduce + cs) \"Lucky\"]))\n      \"Unlucky\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15760,"user_id":null,"body":"(ns hidcubic.core)\n\n(defn cubic?\n  [in-str]\n  (let [decimals (map #(Integer\/parseInt %) (re-seq #\"\\d{1,1}\" in-str))\n        cube (fn [x] (* x x x))\n        sum (partial reduce +)\n        in-int (Integer\/parseInt in-str)\n       ]\n   (= in-int (sum (map cube decimals )))))\n\n(defn sum-cubes\n  [s]\n  (let [parsed-digits (re-seq #\"\\d{1,3}\" s)\n        lucky-numbers (map #(Integer\/parseInt %) (filter cubic? parsed-digits))\n        sum (reduce +  lucky-numbers )]\n   (if (empty? lucky-numbers) \"Unlucky\" \n               (str (clojure.string\/join \" \" lucky-numbers) \" \" sum \" Lucky\"))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15761,"user_id":null,"body":"(ns hidcubic.core\n  (:require [clojure.string :as str]))\n\n(defn num->coll\n  [n]\n  (->> n\n       (iterate #(quot % 10))\n       (take-while pos?)\n       (map #(rem % 10))\n       (reverse)))\n\n(defn cubic?\n  [n]\n  (->> n\n       (num->coll)\n       (map #(* % % %))\n       (reduce +)\n       (= n)))\n\n(defn parse-numbers\n  [s]\n  (->> s\n       (re-seq #\"\\d{1,3}\")\n       (map read-string)))\n\n(defn sum-cubes\n  [s]\n  (let [cubics\n        (filter cubic? (parse-numbers s))]\n    (if-not (empty? cubics)\n      (->> [\"Lucky\"]\n           (concat cubics [(reduce + cubics)])\n           (str\/join \\space))\n      \"Unlucky\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15762,"user_id":null,"body":"(ns hidcubic.core)\n\n(defn cubic? [n]\n  (->> (str n)\n       (map #(- (int %) (int \\0))) ; characters -> digits\n       (map #(* % % %))\n       (reduce +)\n       (= n)))\n\n(defn sum-cubes [s]\n  (let [cubes (->> (clojure.string\/split s #\"\\D+\")\n                   (map (fn [s] (map #(apply str %) (partition-all 3 s)))) ; split into groups of 3\n                   (flatten)\n                   (map #(Integer\/parseInt % 10))\n                   (filter cubic?))]\n    (if (seq cubes)\n      (str (clojure.string\/join \" \" cubes) \" \" (reduce + cubes) \" Lucky\")\n      \"Unlucky\")))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"550498447451fbbd7600041c":[{"id":15763,"user_id":null,"body":"(ns aretheysame.core)\n\n(defn comp_same [a b]\n  (and (some? a) (some? b) (= (sort (map * a a)) (sort b))) )\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15764,"user_id":null,"body":"(ns aretheysame.core)\n\n(defn comp_same [a b]\n  (and (some? a) (some? b) (= (map #(* % %) (sort a)) (sort b)))\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15765,"user_id":492,"body":"(ns aretheysame.core)\n\n(defn comp_same [a b]\n  (if (or (nil? a) (nil? b))\n    false\n    (let [aa (sort (map (fn [x] (* x x)) a))\n          bb (sort b)\n         ]\n      (= aa bb))))\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15766,"user_id":null,"body":"(ns aretheysame.core)\n\n(defn comp_same [a b]\n  (if (and a b)\n    (= (map #(* % %) (sort a)) (sort b))\n    false))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15767,"user_id":null,"body":"(ns aretheysame.core)\n\n(defn comp_same [a b]\n  (and\n   (not (nil? a))\n   (not (nil? b))\n   (= (count a) (count b))\n   (= (map #(* % %) (sort a)) (sort b))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15768,"user_id":53,"body":"(ns aretheysame.core)\n\n(defn comp_same [xs ys]\n  (cond\n    (and (nil? xs) (nil? ys)) true\n    (or (nil? xs) (nil? ys)) false\n    :else (= (sort (map (fn [n] (* n n)) xs)) (sort ys))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15769,"user_id":null,"body":"(ns aretheysame.core)\n\n(defn comp_same [a b]\n  (if (or (nil? a) (nil? b))\n      false\n      (= (sort b) (sort (map #(* % %) a)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15770,"user_id":null,"body":"(ns aretheysame.core)\n\n(defn comp_same [a b]\n  (if (or (nil? a) (nil? b))\n    false                                  ; if either is nil, return false\n    (= (frequencies b)                     ; otherwise, the frequencies of the values in b\n       (frequencies (map #(* %1 %1) a))))) ; should be the same as the frequencies of the squares of the values in a","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15771,"user_id":null,"body":"(ns aretheysame.core)\n\n\n(defn comp_same [a b]\n  (true? (and a b (= (sort (map #(*' % %) a)) (sort b)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15772,"user_id":null,"body":"(ns aretheysame.core)\n(defmacro by [function mapping & xs] ;i forgot how it's called\n  `(apply ~function (map ~mapping (list ~@xs))))\n(defn comp_same [a b]\n  (if (and a b)\n    (by = sort (map #(*' % %) a) b)\n    false))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"550527b108b86f700000073f":[{"id":15773,"user_id":492,"body":"(ns piapprox.core)\n\n(defn round [s n] \n  (.setScale (bigdec n) s java.math.RoundingMode\/HALF_EVEN)) \n\n(defn iter_pi [epsilon]\n  (loop [i 1 value 4.0]\n    (if (<= (Math\/abs (- Math\/PI value)) epsilon)\n      [i, (round 10 value)]\n      (do\n        ;(println value)\n        (recur (inc i) (+ value (* 4.0 (\/ (Math\/pow -1 i) (+ 1 (* 2 i))))))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15774,"user_id":53,"body":"(ns piapprox.core)\n\n(defn round [s n] \n  (.setScale (bigdec n) s java.math.RoundingMode\/HALF_EVEN)) \n\n(defn iter_pi [epsilon]\n  (loop [i 1 pi4 1.0 s -1.0 d 3.0]\n    (if (<= (Math\/abs (- (* 4 pi4) Math\/PI)) epsilon)\n      [i, (round 10 (* 4 pi4))]\n      (recur (inc i) (+ pi4 (* s (\/ 1.0 d))) (* s -1.0) (+ 2 d)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15775,"user_id":null,"body":"(ns piapprox.core)\n\n(defn round [s n]\n  (.setScale (bigdec n) s java.math.RoundingMode\/HALF_EVEN))\n\n(defn iter_pi [epsilon]\n  (let [too-inaccurate (fn [[_ x]] (> (Math\/abs (- x Math\/PI)) epsilon))\n        series-element (fn [k] (\/ (* (- 1 (* 2 (mod k 2))) 4.0) (+ (* 2 k) 1)))\n        [[n s]] (take 1 (drop-while too-inaccurate\n                              (reductions (fn [[_ s] [k x]] [k (+ s x)])\n                                          (map (fn [k] [k (series-element k)]) (range)))))]\n    [(inc n) (round 10 s)]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15776,"user_id":null,"body":"(ns piapprox.core)\n\n(defn round [s n] \n  (.setScale (bigdec n) s java.math.RoundingMode\/HALF_EVEN)) \n\n(defn iter_pi [epsilon]\n  (loop [acc 4.0\n         sgn -1\n         div 3\n         num 1]\n    (if (< (Math\/abs (- Math\/PI acc)) epsilon)\n      [num (round 10 acc)]\n      (recur (+ acc (\/ (* 4 sgn) div))\n             (- sgn)\n             (+ div 2)\n             (inc num)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15777,"user_id":null,"body":"(ns piapprox.core)\n\n(defn round [s n] \n  (.setScale (bigdec n) s java.math.RoundingMode\/HALF_EVEN)) \n\n(defn iter_pi [epsilon]\n  (->> (iterate \n          #(let [[val num sig]  %\n                 den            (inc (* num 2))\n                 add            (* sig (\/ 1 den))]\n              [(+ add val) (inc num) (* sig -1)])\n              [1.0 1 -1])\n       (drop-while #(> (Math\/abs (- (* 4 (first %)) Math\/PI)) epsilon))\n       (first)\n       ((fn [[val num _]] [num (round 10 (* 4 val))]))\n  )\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15778,"user_id":62,"body":"(ns piapprox.core)\n\n(defn round [s n] \n  (.setScale (bigdec n) s java.math.RoundingMode\/HALF_EVEN)) \n\n\n(defn iter_pi [epsilon]\n  (first (keep-indexed\n          #(when (< (Math\/abs (- %2 (Math\/PI))) epsilon) \n             [(inc %1) (round 10 %2)])\n          (reductions +\n                      (map \/ (iterate - 4.0) \n                             (filter odd? (range)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15779,"user_id":null,"body":"(ns piapprox.core)\n\n(defn round [s n]\n  (.setScale (bigdec n) s java.math.RoundingMode\/HALF_EVEN))\n\n(def leibniz-seq\n  (->> (range)\n       (filter odd?)\n       (map-indexed #(cond-> (\/ 1 %2) (odd? %1) (* -1) :always double))\n       (reductions +)))\n\n(defn iter_pi [epsilon]\n  (let [[i x] (->> leibniz-seq\n                   (map-indexed vector)\n                   (drop-while\n                    (fn [[_ x]] (>= (Math\/abs (- Math\/PI (* 4 x))) epsilon)))\n                   first)]\n    [(inc i) (round 10 (* 4 x))]))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15780,"user_id":null,"body":"(ns piapprox.core)\n\n(defn round [s n] \n  (.setScale (bigdec n) s java.math.RoundingMode\/HALF_EVEN)) \n\n(defn term [k]\n  (\/ (Math\/pow -1 k) (inc (* 2 k))))\n\n(defn iter_pi [epsilon]\n  (loop [k 0 sum 0]\n    (if (< (Math\/abs (- (* sum 4) Math\/PI)) epsilon) \n      [k (round 10 (* sum 4))] \n      (recur (inc k) (+ sum (term k)))))\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15781,"user_id":null,"body":"(ns piapprox.core)\n\n(defn round [s n] \n  (.setScale (bigdec n) s java.math.RoundingMode\/HALF_EVEN)) \n\n(defn precise-enough? [val epsilon]\n  (> epsilon\n     (Math\/abs (- Math\/PI val))))\n\n\n(defn iter_pi [epsilon]\n  (reduce (fn [[iter prev-pi-val] denominator]\n            (let [next-pi-val-quart (+ prev-pi-val\n                                       (\/ 1.0 denominator))\n                  pi (* 4.0 next-pi-val-quart)]\n              (if (precise-enough? pi epsilon)\n                (reduced [iter (round 10 pi)])\n                [(inc iter) next-pi-val-quart])))\n          [1 0]\n          (iterate\n           (fn [prev-val]\n             (if (< 0 prev-val)\n               (- (+ prev-val 2))\n               (+ (Math\/abs prev-val) 2)))\n           1)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15782,"user_id":null,"body":"(ns piapprox.core)\n\n(defn round [s n] \n  (.setScale (bigdec n) s java.math.RoundingMode\/HALF_EVEN))\n\n(defn iter_pi [epsilon]\n  (->> (iterate (partial + 2) 1)\n       (map-indexed #(\/ (if (even? %) 1.0 -1.0) %2))\n       (reduce (fn [[cnt s] term]\n                 (let [cnt (inc cnt) s (+ s term)]\n                   (if (< epsilon (Math\/abs (- Math\/PI (* 4 s)))) [cnt s]\n                     (reduced [cnt (round 10 (* 4 s))])))) [0 0])))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"550554fd08b86f84fe000a58":[{"id":15783,"user_id":492,"body":"(ns which-are-in.core)\n\n(defn inArray\n  [array1 array2]\n  (distinct (sort (vec (for [s1 array1 :when (some #(.contains %1 s1) array2)] s1)))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15784,"user_id":363,"body":"(ns which-are-in.core)\n(require '[clojure.string :as str])\n(defn inArray [array1 array2]\n  (distinct (sort (for [x array1 y array2 :when (str\/includes? y x)] x)))\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15785,"user_id":null,"body":"(ns which-are-in.core)\n\n(defn inArray [array1 array2]\n  (->> (for [a1 array1\n             a2 array2\n             :when (clojure.string\/includes? a2 a1)]\n         a1)\n       dedupe\n       sort))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15786,"user_id":null,"body":"(ns which-are-in.core)\n\n(defn inArray [array1 array2]\n  (sort (set (filter (fn [x] (some #(.contains % x) array2)) array1))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15787,"user_id":null,"body":"(ns which-are-in.core)\n(defn inArray [array1 array2]\n  (sort (set (filter (fn [s] (some (fn [t] (clojure.string\/includes? t s)) array2)) array1))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15788,"user_id":53,"body":"(ns which-are-in.core)\n\n(defn inArray [xs ys]\n  (sort (filter (fn [x] (some (fn [y] (clojure.string\/includes? y x)) ys)) (distinct xs))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15789,"user_id":null,"body":"(ns which-are-in.core\n  (:require [clojure.string :as s]))\n\n(def remove-duplicates\n  (comp vec set))\n\n(defn inArray \n  [array1 array2]\n  (->> array1 \n       (filter (fn [string]\n                 (some #(s\/includes? % string) array2)))\n       (remove-duplicates)\n       (sort)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15790,"user_id":null,"body":"(ns which-are-in.core)\n\n(defn distinct-consequtive [sequence] (map first (partition-by identity sequence)))\n\n(defn contains-in-keys [array1 value]\n  (clojure.string\/includes? array1 value))\n\n(defn inArray [array1 array2]\n  (filter #(contains-in-keys array2 %) (sort (distinct-consequtive array1))))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15791,"user_id":null,"body":"(ns which-are-in.core)\n\n(defn inArray [array1 array2]\n  (-> (for [x array1 y array2 :when (clojure.string\/includes? y x)] x)\n    distinct \n    sort)\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15792,"user_id":null,"body":"(ns which-are-in.core)\n\n(require '[clojure.string :as str])\n(defn inArray [array1 array2]\n  (->> (remove nil? (into [] (for [w array1\n                                   w2 array2]\n                               (when (str\/index-of w2 w) w))))\n       distinct\n       sort\n       vec))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5506b230a11c0aeab3000c1f":[{"id":15793,"user_id":null,"body":"(ns evaporator.core)\n\n(defn evaporator [content, evap_per_day, threshold]\n  (count (take-while #(> % threshold) (iterate #(* % (- 100 evap_per_day) 0.01) 100))))\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15794,"user_id":null,"body":"(ns evaporator.core)\n\n(defn evaporator [content, evap_per_day, threshold]\n  (int (Math\/ceil (\/ \n    (Math\/log (\/ threshold 100.0)) \n    (Math\/log (- 1.0 (\/ evap_per_day 100.0)))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15795,"user_id":null,"body":"(ns evaporator.core)\n\n(defn percent [n]\n  (\/ n 100.0))\n\n(defn evap [content per-day]\n  (let [content-evap (* content (percent per-day))]\n    (- content content-evap)))\n\n(defn evaporator [content, evap-per-day, threshold]\n  (let [limit (* content (percent threshold))]\n    (loop [content content\n           days 0]\n      (if (< content limit)\n        days\n        (recur (evap content evap-per-day) (inc days))))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15796,"user_id":null,"body":"(ns evaporator.core)\n\n(defn evaporator\n  \"Number>0 Number>0 Number>0 -> Int\n  Given the content of an evaporator (in milliliters), the percentage of foam or gas lost\n  every day, and the threshold (in %) beyond which the evaporator is no longer useful,\n  return the nth day on which the evaporator will be out of use.\"\n  [content, evap_per_day, threshold]\n  (loop [c content n 0]\n    (if (< (* 100 (\/ c content)) threshold)\n        n\n        (recur (* c (\/ (- 100 evap_per_day) 100)) (inc n)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15797,"user_id":null,"body":"(ns evaporator.core)\n\n(defn percent-of\n  \"Calculates a percentage of a total\"\n  [total percentage]\n  (* total (\/ percentage 100)))\n\n(defn unevaporated\n  \"Calculates the remaining amount after evaporation\"\n  [content evap-rate]\n  (- content (percent-of content evap-rate)))\n\n(defn evaporator\n  \"Algorithm: create lazy-seq of remaining material after every day, then find\n  how many are more than the threshold.\"\n  [content evap-per-day threshold]\n  (count (take-while #(> % (percent-of content threshold))\n                     (iterate #(unevaporated % evap-per-day) content))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15798,"user_id":null,"body":"(ns evaporator.core)\n\n(defn evaporator [content, evap_per_day, threshold]\n  (count (take-while #(> % (\/ threshold 100)) (iterate #(* % (\/ (- 100 evap_per_day) 100)) 1))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15799,"user_id":492,"body":"(ns evaporator.core)\n\n(defn evaporator [content, evap_per_day, threshold]\n  (let [l (Math\/ceil (\/ (Math\/log (\/ threshold 100.0)) (Math\/log (- 1.0 (\/ evap_per_day 100.0)))))]  \n    (int l)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15800,"user_id":null,"body":"(ns evaporator.core)\n\n(defn evape [content evap_per_day]\n  (- content (* content (\/ evap_per_day 100))))\n\n(defn evaporator [content, evap_per_day, threshold]\n  (loop [days 0\n         rest_content content\n         abs_threshold (* content (\/ threshold 100))]\n    (if (<= abs_threshold rest_content)\n      (recur (inc days)\n             (evape rest_content evap_per_day)\n             abs_threshold)\n      days)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15801,"user_id":1703,"body":"(ns evaporator.core)\n\n(defn lop [ct ev lt res]\n   (if(>= ct lt)\n     (lop (- ct (\/ (* ct ev) 100)) ev lt (inc res))\n     res\n     ))\n\n(defn evaporator [content, evap_per_day, threshold]\n (let [limit (double (\/ (* content threshold) 100))]\n    (lop content evap_per_day limit 0)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15802,"user_id":null,"body":"(ns evaporator.core)\n\n\n\n(defn evaporator [content, evap_per_day, threshold]\n  (let [evap% (\/ evap_per_day 100)\n        thresh% (\/ threshold 100)]\n    \n    ( -> (\/ (Math\/log thresh%) (Math\/log (- 1 evap%)) )\n      Math\/ceil\n      int\n    )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5508249a98b3234f420000fb":[{"id":15803,"user_id":492,"body":"(ns caesar.core)\n\n(defn split-every-n-chars [sz string]\n  (let [u (map (fn [x] (apply str x))\n               (partition sz sz nil string))]\n    (if (< (count u) 5)\n      (concat u [\"\"])\n      u)))\n\n(defn move-char [c shift idx encode-or-decode]\n  (let [ch (int c) val (mod (* encode-or-decode (+ shift idx)) 26)]\n    (cond \n      (and (>= ch (int \\A)) (<= ch (int \\Z))) (char (+ (mod (+ val (- (int ch) (int \\A))) 26) (int \\A)))\n      (and (>= ch (int \\a)) (<= ch (int \\z))) (char (+ (mod (+ val (- (int ch) (int \\a))) 26) (int \\a)))\n      :else c)))\n\n(defn move-shift-aux [str shift encode-or-decode]\n  (map-indexed (fn [idx item] (move-char item shift idx encode-or-decode)) str))\n\n(defn moving_shift [s shift]\n  (let [res (apply str (move-shift-aux s shift 1))\n        r (mod (count res) 5)\n        p (int (\/ (count res) 5))]\n    (if (not= 0 r)\n      (vec (split-every-n-chars (inc p) res))\n      (vec (split-every-n-chars p res)))))\n       \n(defn demoving_shift [s shift]\n  (apply str (move-shift-aux (clojure.string\/join s) shift -1)))\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-28 15:25:01"},{"id":15804,"user_id":null,"body":"(ns caesar.core)\n\n\n(defn shift-by [c shift]\n  (let [alphabet (map char\n                      (let [r (if (Character\/isUpperCase c)\n                                (range (int \\A) (inc (int \\Z)))\n                                (range (int \\a) (inc (int \\z))))]\n                        (if (< shift 0)\n                          (reverse r)\n                          r)))\n        shifted (->> (cycle alphabet)\n                     (drop (Math\/abs shift)))\n        shifted-map (zipmap alphabet shifted)]\n    (if (nil? (shifted-map c))\n      c\n      (shifted-map c))))\n\n(defn moving_shift [s shift]\n  (let [res (map-indexed (fn [idx c]\n                           (shift-by c (+ shift idx)))\n                         s)\n        split-len (\/ (count res) 5)]\n    (loop [current res\n           acc []\n           i 0]\n      (if (>= i 5)\n        acc\n        (recur (drop split-len current)\n               (conj acc\n                     (apply str (take split-len current)))\n               (inc i))))))\n\n(defn demoving_shift [s shift]\n  (->> (apply str s)\n       (map-indexed (fn [idx c]\n                      (shift-by c (- (+ shift idx)))))\n       (apply str)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-28 15:35:17"},{"id":15805,"user_id":null,"body":"(ns caesar.core)\n\n(defn shift-char [ch shift]\n  (let [code (int ch)\n        start (if (<= 65 code 90) 65 97)\n        offset (- code start)\n        new-offset (mod (+ offset shift) 26)\n        new-code (+ start new-offset)]\n    (char new-code)))\n\n(defn exclude? [ch]\n  (re-matches #\"[\\W\\d_]\" ch))\n\n(defn inc-amp [value i]\n  (+ value (* i ({false 1 true -1} (< value 0)))))\n\n(defn shift-str [s shift]\n  (apply str\n         (map-indexed #(if (exclude? (str %2))\n                         %2\n                         (shift-char %2 (inc-amp shift %1))) s)))\n\n(defn into-parts [s]\n  (let [base (-> (count s) (\/ 5) Math\/ceil int)\n        parts (if (< (count s) 4)\n                [1]\n                (concat (repeat 4 base)\n                        [(- (count s) (* base 4))]))]\n    (first\n     (reduce (fn [[result remain] len]\n               (let [p (min (count remain) len)]\n                 [(conj result (subs remain 0 p))\n                  (subs remain p)]))\n             [[] s]\n             parts))))\n\n(defn moving_shift [s shift]\n  (->> (shift-str s shift)\n    into-parts))\n\n(defn demoving_shift [s shift]\n  (-> (apply str s)\n    (shift-str (- shift))))\n","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-28 15:35:01"},{"id":15806,"user_id":62,"body":"(ns caesar.core)\n(require 'clojure.string)\n(def shift-1 \n   (zipmap \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n           \"BCDEFGHIJKLMNOPQRSTUVWXYZAbcdefghijklmnopqrstuvwxyza\"))\n\n(defn shift \n  [n msg]\n   (nth (iterate #(apply str (replace shift-1 %)) (str msg)) (mod n 26)))\n\n(defn moving_shift [message k]\n  (let [fifth (inc (quot (dec (count message)) 5))]\n    (->> (map-indexed shift (shift k message))              ;; encipher\n         (partition-all fifth)(vec)(#(conj % \"\"))(take 5)   ;; split 5\n         (map #(clojure.string\/join \"\" %)))))\n\n(defn demoving_shift [messages k]\n  (->> (apply concat messages)            ;; join 5\n       (map-indexed #(shift (- %1) %2))   ;; decipher\n       (clojure.string\/join \"\")           \n       (shift (- k))))                    ;; -initial shift\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15807,"user_id":null,"body":"(ns caesar.core)\n\n(defn a-z? [c] (<= (int \\a) (int c) (int \\z)))\n(defn A-Z? [c] (<= (int \\A) (int c) (int \\Z)))\n(defn alphabetic? [c] (or (a-z? c) (A-Z? c)))\n(defn shift-char [c n]\n  (let [orig (if (a-z? c) (int \\a) (int \\A))\n        d (inc (- (int \\z) (int \\a)))\n        rotated (+ n (- (int c) orig))\n        affixed (mod rotated d)]\n    (char (+ orig affixed))))\n(defn fill-to-five [coll]\n  (if (< (count coll) 5) (concat coll [\"\"]) coll))\n   \n(defn moving_shift [s shift]\n  (let [codes (iterate inc shift)\n        chunk-size (Math\/ceil (\/ (count s) 5))]\n    (->> (map (fn [c code] (if (alphabetic? c) (shift-char c code) c))\n              s codes)\n        (partition-all chunk-size chunk-size)\n        fill-to-five\n        (map clojure.string\/join))))\n\n(defn demoving_shift [chunks shift]\n  (let [codes (iterate dec (- shift))]\n    (->> chunks\n         clojure.string\/join\n         (map (fn [code c] (if (alphabetic? c) (shift-char c code) c)) codes)\n         (apply str))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15808,"user_id":null,"body":"(ns caesar.core\n  (:require [clojure.string :as str]))\n\n(defn shift-char [ch-code offset shift]\n  (-> ch-code\n    (- offset)\n    (+ shift)\n    (mod 26)\n    (+ offset)))\n\n(defn shift-if-in-range [ch start end shift]\n  (if (and (<= start ch) (<= ch end))\n      (shift-char ch start shift)\n      ch))\n\n(defn move-char [ch shift]\n  (-> ch\n    (int)\n    (shift-if-in-range (int \\A) (int \\Z) shift)\n    (shift-if-in-range (int \\a) (int \\z) shift)\n    (char)))\n\n(defn move-by-changing-shift [s generate-shift]\n  (map-indexed (fn [i x] (move-char x (generate-shift i))) (char-array s)))\n\n(defn moving_shift [s shift]\n  (let [letters (move-by-changing-shift s #(+ shift %))\n        len-letters (count letters)\n        chars-per-part (Math\/ceil (\/ len-letters 5))\n        output (map #(apply str %) (partition-all chars-per-part letters))]\n    (if (zero? (mod len-letters chars-per-part))\n        (concat output [\"\"])\n        output)))\n          \n(defn demoving_shift [s shift]\n  (apply str (move-by-changing-shift (apply str s) #(- (+ shift %)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15809,"user_id":null,"body":"(ns caesar.core)\n\n(def alphabet [ \\a \\b \\c \\d \\e \\f \\g \\h \\i \\j \\k \\l \\m \n \\o \\p \\q \\r \\s \\t \\u \\v \\w \\x \\y \\z])\n\n(def i-index (->> alphabet\n      (map-indexed (fn [x y] [y x]))\n      (into {})))\n\n(def ch-index (->> alphabet\n      (map-indexed (fn [x y] [x y]))\n      (into {})))\n\n(def count-alph (count alphabet))\n\n(defn get-idx [x i shift]\n  (rem (+ shift i (get i-index (Character\/toLowerCase x))) count-alph))\n\n(defn get-inv-idx [x i shift]\n  (let [idx (rem (- (get i-index (Character\/toLowerCase x)) shift i )\n                 count-alph)]\n    (if (< idx 0) (+ count-alph idx) idx)))\n\n(defn moving_shift* [s shift get-idx]\n  (->> s\n       (map-indexed (fn [i x]\n                      (if-not (contains? i-index (Character\/toLowerCase x))\n                        x\n                        (let [nidx (get-idx x i shift)\n                              nch (get ch-index nidx)]\n                          (if (Character\/isLowerCase x) nch (Character\/toUpperCase nch) )))))\n       (apply str)))\n\n(defn to-parts [s]\n  (let [n (Math\/ceil (\/ (count s) 5.0))]\n    (loop [i 0\n           s s\n           acc []]\n      (if (> i 4) acc\n          (let [part (if (> n (count s)) s\n                         (subs s 0 n))\n                rest (if (> n (count s)) s (subs s n (count s)))]\n            (recur (inc i) rest\n             (conj acc part)))))))\n\n(defn moving_shift [s shift]\n  (to-parts (moving_shift* s shift get-idx)))\n\n(defn demoving_shift [s-parts shift]\n  (moving_shift* (apply str s-parts) shift get-inv-idx))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15810,"user_id":null,"body":"(ns caesar.core)\n\n(defn- char-shift [c shift]\n  (let [ila (int \\a) ilz (int \\z)\n        iua (int \\A) iuz (int \\Z)\n        ic  (int c)\n        shft (fn [f] (-> ic (- f) (+ shift) (mod 26) (+ f) char))]\n    (cond\n      (<= ila ic ilz) (shft ila)\n      (<= iua ic iuz) (shft iua)\n      :else c\n      )\n    )\n  )\n\n(defn- str-shift\n  ([s shift] (str-shift s shift 1))\n  ([s shift spd]\n   (->> s\n     (map-indexed #(char-shift %2 (+ shift (* %1 spd))))\n     (apply str)\n     ))\n  )\n\n(defn moving_shift [s shift]\n  (let [tl (count s)\n        sl (int (Math\/ceil (\/ tl 5)))\n        sc (int (Math\/ceil (\/ tl sl)))\n        sn (str-shift s shift)]\n    (concat\n     (for [i (range sc)] (subs sn (* i sl) (min (* (inc i) sl) tl)))\n     (repeat (- 5 sc) \"\")\n     )\n    )\n  )\n       \n(defn demoving_shift [s shift]\n  (str-shift (apply str s) (- shift) -1)\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15811,"user_id":null,"body":" (ns caesar.core)\n\n;; calc-division-5 :: Number -> [Number, Number, Number, Number, Number]\n(defn calc-division-5 [n]\n  (let [ rem-num (rem n 5)]\n    (if (= 0 rem-num)\n      ;; c-1 : divide equally\n      (into [] (repeat 5 (\/ n 5)))\n      ;; c-2 : not equally\n      (let [ n-1-to-3 (inc (\/ (- n rem-num) 5))\n             n-4      (min (- n (* 3 n-1-to-3)) n-1-to-3)\n             n-5      (- n (* 3 n-1-to-3) n-4)]\n        (conj (into [] (repeat 3 (\/ (- n rem-num) 5)))\n              n-4\n              n-5)))))\n\n(defn- partition* [n m s]\n  (loop [ n n m m\n          s s r []]\n    (if (= m (count r))\n        r\n        (recur n m (drop n s) (conj r (take n s))))))\n\n(defn shift-char [shift c]\n  (let [ c-no (int c)  A-no (int \\A)\n         Z-no (int \\Z) a-no (int \\a)\n         z-no (int \\z)]\n    (cond\n      (<= A-no c-no Z-no) (char (+ A-no (rem (+ shift (- c-no A-no) (* 10 26)) 26)))\n      (<= a-no c-no z-no) (char (+ a-no (rem (+ shift (- c-no a-no) (* 10 26)) 26)))\n      :else c)))\n\n\n(defn moving_shift [s shift]\n  ;; shift\n  (let [ shifted (loop [ s (into [] s)\n                         idx 0\n                         shift shift]\n                   (if (= idx (count s))\n                       ;; done\n                       s\n                       (recur (update s idx #(shift-char shift %)) (inc idx) (inc shift))))\n\n         len (count s)\n         part-len (if (= 0 (rem len 5))\n                      (\/ len 5)\n                      (inc (\/ (- len (rem len 5)) 5)))]\n    (->> shifted\n      (partition* part-len 5)\n      (map #(apply str %))\n      (into []))))\n\n(defn demoving_shift [a shift]\n  (let [ s (apply str a)\n         unshifted (loop [ s (into [] s)\n                           idx 0\n                           shift shift]\n                     (if (= idx (count s))\n                         ;; done\n                         s\n                         (recur (update s idx #(shift-char (- shift) %)) (inc idx) (inc shift))))]\n    (apply str unshifted)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15812,"user_id":null,"body":"(ns caesar.core)\n\n(def lower-alpha \"abcdefghijklmnopqrstuvwxyz\")\n(def upper-alpha (clojure.string\/upper-case lower-alpha))\n\n(defn shift-char [ch n]\n  (cond\n    (some #(= % ch) lower-alpha) (nth (cycle lower-alpha) (+ (- (int ch) (int \\a)) n))\n    (some #(= % ch) upper-alpha) (nth (cycle upper-alpha) (+ (- (int ch) (int \\A)) n))\n    :else ch))\n\n(defn moving_shift [s shift]\n  (let [n (inc (int (\/ (count s) 5)))]\n    (->> (map-indexed #(shift-char %2 (+ shift %1)) s)\n         (partition-all n) ; split to groups\n         (map #(apply str %))\n         (#(concat % (repeat \"\"))) ; conditionally add empty string\/s\n         (take 5))))\n\n(defn demoving_shift [s shift]\n  (->> (apply str s)\n       (map-indexed #(shift-char %2 (- (* 26 (+ (count s) shift) )\n                                       (+ shift %1))))\n       (apply str)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55084d3898b323f0aa000546":[{"id":15813,"user_id":null,"body":"(ns caesar2.core)\n\n(def abcs (mapv char (remove (set (range 91 97)) (range 65 123))))\n\n(defn encode-str [s shift]\n  (let [cypher (zipmap abcs (drop shift (apply concat (repeat 2 abcs))))\n        c0     (first (clojure.string\/lower-case (first s)))\n        c1     (cypher c0)\n        crypt  (concat [c0 c1] (map #(get cypher % %) s))\n        len    (count crypt)\n        part   (if (zero? (\/ len 4))\n                 (\/ len 4) (Math\/ceil (\/ len 5)))]\n    (mapv #(apply str %) (partition-all part crypt))))\n\n(defn decode [s]\n  (let [shift  (- (apply - (map int (take 2 (apply concat s)))))\n        cypher (zipmap (drop shift (apply concat (repeat 2 abcs))) abcs)]\n    (apply str (mapv #(get cypher % %) (drop 2 (apply concat s))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15814,"user_id":492,"body":"(ns caesar2.core)\n\n(defn split-every-n-chars [sz strng]\n  (map (fn [x] (apply str x))\n       (partition sz sz nil strng)))\n\n(defn move-char [c shift]\n  (let [ch (int c) val (mod shift 26)]\n    (cond \n      (and (>= ch (int \\A)) (<= ch (int \\Z))) (char (+ (mod (+ val (- (int ch) (int \\A))) 26) (int \\A)))\n      (and (>= ch (int \\a)) (<= ch (int \\z))) (char (+ (mod (+ val (- (int ch) (int \\a))) 26) (int \\a)))\n      :else c)))\n\n(defn encode-aux [str shift]\n  (map (fn [item] (move-char item shift)) str))\n\n(defn encode-str [s shift]\n  (let [c1 (first (clojure.string\/lower-case (first s)))\n        c2 (move-char c1 shift)\n        res (cons c1 (cons c2 (apply str (encode-aux s shift))))\n        r (mod (count res) 5)\n        p (int (\/ (count res) 5))]\n    (if (not= 0 r)\n      (vec (split-every-n-chars (inc p) res))\n      (vec (split-every-n-chars p res)))))\n\n(defn decode [s]\n  (let [ss (clojure.string\/join s)\n        c1 (int (first ss))\n        c2 (int (second ss))\n        shift (- c2 c1)]\n  (apply str (encode-aux (apply str (rest (rest ss))) (- shift)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15815,"user_id":null,"body":"(ns caesar2.core)\n\n(defn shift-char [c shift]\n  (let [value (int c)] \n    (cond \n      (<= (int \\A) value (int \\Z))\n        (char (+ (int \\A) (mod (- (+ value shift) (int \\A)) 26)))\n      (<= (int \\a) value (int \\z))\n        (char (+ (int \\a) (mod (- (+ value shift) (int \\a)) 26)))\n      :else c)))\n\n(defn encode-str [s shift]\n  (let [prefix         (clojure.string\/lower-case (str (first s) (shift-char (first s) shift)))\n        partition-size (int (Math\/ceil (\/ (+ (count s) 2) 5)))]\n    (->> (map #(shift-char % shift) s)\n         (reduce str)\n         (str prefix)\n         (partition-all partition-size)\n         (map clojure.string\/join))))\n\n(defn decode [s]\n  (let [shift (mod (- (int (second (first s))) (int (ffirst s))) 26)]\n    (->> (reduce str s)\n         (drop 2)\n         (map #(shift-char % (- shift)))\n         (reduce str))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15816,"user_id":null,"body":"(ns caesar2.core\n  (:require [clojure.string :as s]))\n\n(defn divide [n]\n  (if (zero? (mod n 5))\n    (quot n 5)\n    (inc (quot n 5))))\n\n(def alpha-lc \"abcdefghijklmnopqrstuvwxyz\")\n(def alpha-uc (s\/upper-case \"abcdefghijklmnopqrstuvwxyz\"))\n\n(defn codec [ch shift]\n  (let [ix-lc (.indexOf alpha-lc (str ch))\n        ix-uc (.indexOf alpha-uc (str ch))\n        trans (fn [ix] (mod (+ ix shift) 26))\n        char-at (fn [s ix] (subs s ix (inc ix))) ]\n    (cond\n      (>= ix-lc 0)\n        (first (char-at alpha-lc (trans ix-lc)))\n      (>= ix-uc 0)\n        (first (char-at alpha-uc (trans ix-uc)))\n      :else\n        ch)))\n\n(defn encode-str [text shift]\n  (let [ first-chr (first (s\/lower-case (first text)))\n         size (divide (+ (count text) 2)) ]\n    (->>\n      (map #(codec % shift) (seq text))             ;; code text\n      (concat [first-chr (codec first-chr shift)])  ;; add two chr prefix\n      (partition size size \"\")\n      (map s\/join))))\n \n(defn decode [five-part-msg]\n  (let [ msg-all (into [] (seq (apply str five-part-msg)))\n         [pf1 pf2] (subvec msg-all 0 2)\n         shift (- (.indexOf alpha-lc (str pf2)) (.indexOf alpha-lc (str pf1))) ]\n    (s\/join (map #(codec % (* -1 shift)) (subvec msg-all 2)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15817,"user_id":null,"body":"(ns caesar2.core\n  (:require [clojure.string :as s]))\n\n(defn divide [n]\n  (if (zero? (mod n 5))\n    (quot n 5)\n    (inc (quot n 5))))\n\n(defn split-str [len s]\n  (loop [s s str-vec []]\n    (if (< len (count s))\n      (recur (subs s len) (conj str-vec (subs s 0 len)))\n      (conj str-vec s))))\n\n(def alpha-lc \"abcdefghijklmnopqrstuvwxyz\")\n(def alpha-uc (s\/upper-case \"abcdefghijklmnopqrstuvwxyz\"))\n\n(defn codec [ch shift]\n  (let [ix-lc (.indexOf alpha-lc (str ch))\n        ix-uc (.indexOf alpha-uc (str ch))\n        trans (fn [ix] (mod (+ ix shift) 26))\n        char-at (fn [s ix] (subs s ix (inc ix))) ]\n    (cond\n      (>= ix-lc 0)\n        (first (char-at alpha-lc (trans ix-lc)))\n      (>= ix-uc 0)\n        (first (char-at alpha-uc (trans ix-uc)))\n      :else\n        ch)))\n\n(defn encode-str [text shift]\n  (let [ first-chr (first (s\/lower-case (first text))) ]\n    (->>\n      (map #(codec % shift) (seq text))             ;; code text\n      (concat [first-chr (codec first-chr shift)])  ;; add two chr prefix\n      (s\/join)\n      (split-str (divide (+ (count text) 2))))))\n \n(defn decode [five-part-msg]\n  (let [ msg-all (into [] (seq (apply str five-part-msg)))\n         [pf1 pf2] (subvec msg-all 0 2)\n         shift (- (.indexOf alpha-lc (str pf2)) (.indexOf alpha-lc (str pf1))) ]\n    (s\/join (map #(codec % (* -1 shift)) (subvec msg-all 2)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15818,"user_id":62,"body":"(ns caesar2.core)\n\n(require 'clojure.string)\n(def shift-1 \n   (zipmap \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n           \"BCDEFGHIJKLMNOPQRSTUVWXYZAbcdefghijklmnopqrstuvwxyza\"))\n\n(defn shift \n  [n msg]\n   (nth (iterate #(apply str (replace shift-1 %)) (str msg)) (mod n 26)))\n\n(defn encode-str [msg k]\n  (->> \n    (map (partial shift k) msg)\n    (apply str (.toLowerCase (str(first msg))) \n               (.toLowerCase (shift k (first msg))))\n    (partition-all (inc (quot (inc(count msg)) 5)))\n    (map #(clojure.string\/join \"\" %))))\n\n\n(defn decode [msgs]\n  (let [[a b & msg] (apply concat msgs)]\n    (first (for [k (range 26)\n         :when (= (shift k b) (str a))]\n      (shift k (apply str msg))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15819,"user_id":null,"body":"(ns caesar2.core\n  (:require [clojure.string :as str]))\n\n(defn shift-char [ch-code offset shift]\n  (-> ch-code\n    (- offset)\n    (+ shift)\n    (mod 26)\n    (+ offset)))\n\n(defn shift-if-in-range [ch start end shift]\n  (if (and (<= start ch) (<= ch end))\n      (shift-char ch start shift)\n      ch))\n\n(defn move-char [ch shift]\n  (-> ch\n    (int)\n    (shift-if-in-range (int \\A) (int \\Z) shift)\n    (shift-if-in-range (int \\a) (int \\z) shift)\n    (char)))\n\n(defn move-by-shift [s shift]\n  (map #(move-char % shift) (char-array s)))\n\n(defn encode-str [s shift]\n  (let [letters (move-by-shift s shift)\n        chars-per-part (Math\/ceil (\/ (+ 2 (count letters)) 5))\n        lowercased (str\/lower-case (first s))\n        rotate (str lowercased (move-char (int (first lowercased)) shift))]\n    (map #(apply str %) (partition-all chars-per-part (concat rotate letters)))))\n    \n\n(defn decode [[[rotate1 rotate2 & message1] & message2 :as s]]\n  (let [shift (- (int rotate2) (int rotate1))]\n    (apply str (move-by-shift (apply str (apply str message1) message2) (- shift)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15820,"user_id":null,"body":"(ns caesar2.core)\n\n(def alpha-lo\n  (cycle \"abcdefghijklmnopqrstuvwxyz\"))\n\n(def alpha-up\n  (cycle \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"))\n\n(def lower?\n  #(and (Character\/isLetter %) (Character\/isLowerCase %)))\n\n(def upper?\n  #(and (Character\/isLetter %) (Character\/isUpperCase %)))\n\n(defn nth-from\n  \"Returns the item that occurs {n} places after {elem} in {coll}\"\n  [n elem coll]\n  (nth (drop-while #(not= % elem) coll) n))\n\n(defn rotate-rune [shift rune]\n  \"Accepts an ascii character and rotates it through the alphabet, \n   returning the rune itself if it is not a letter.\"\n  (cond\n    (lower? rune) (nth-from shift rune alpha-lo)\n    (upper? rune) (nth-from shift rune alpha-up)\n    :otherwise    rune))\n\n(defn encode-str\n  [st shift]\n  (let [rot (partial rotate-rune shift)\n        fst (Character\/toLowerCase (first st))\n        ct  (+ 2 (count st))\n        rm  (rem  ct 5)\n        qt  (quot ct 5)]\n    (->> (map rot st)\n         (concat [fst (rot fst)])\n         (partition-all (if (zero? rm) qt (inc qt)))\n         (map (partial apply str)))))\n\n(defn alpha-offset [elem]\n  (count (take-while #(not= % elem) alpha-lo)))\n\n(defn decode [s]\n  (let [rotation (->> (take 2 (first s)) reverse (map alpha-offset) (apply -))]\n    (->> (mapcat seq s)\n         (drop 2)\n         (map (partial rotate-rune (- 26 rotation)))\n         (apply str))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15821,"user_id":null,"body":"(ns caesar2.core)\n\n(def alpha-lo\n  (cycle \"abcdefghijklmnopqrstuvwxyz\"))\n\n(def alpha-up\n  (cycle \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"))\n\n(def lower?\n  #(and (Character\/isLetter %) (Character\/isLowerCase %)))\n\n(def upper?\n  #(and (Character\/isLetter %) (Character\/isUpperCase %)))\n\n(defn nth-from\n  \"Returns the item that occurs {n} places after {elem} in {coll}\"\n  [n elem coll]\n  (nth (drop-while #(not= % elem) coll) n))\n\n(defn rotate-rune [shift rune]\n  \"Accepts an ascii character and rotates it through the alphabet, \n   returning the rune itself if it is not a letter.\"\n  (cond\n    (lower? rune) (nth-from shift rune alpha-lo)\n    (upper? rune) (nth-from shift rune alpha-up)\n    :otherwise    rune))\n\n(defn encode-str\n  [st shift]\n  (let [fst (Character\/toLowerCase (first st))\n        ct  (+ 2 (count st))\n        rm  (rem  ct 5)\n        qt  (quot ct 5)]\n    (->> (map (partial rotate-rune shift) st)\n         (concat [fst (rotate-rune 1 fst)])\n         (partition-all (if (zero? rm) qt (inc qt)))\n         (map (partial apply str)))))\n\n(defn decode [s]\n  (->> (mapcat seq s)\n       (drop 2)\n       (map (partial rotate-rune 25))\n       (apply str)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15822,"user_id":null,"body":"(ns caesar2.core\n(:require [clojure.string :as str]))\n\n(defn shift-letter [ltr shift]\n  (char (let [asc (int ltr)]\n          (cond\n            (<= 97 asc 122) (+ 97 (mod (+ shift (- asc 97)) 26))\n            (<= 65 asc 90) (+ 65 (mod (+ shift (- asc 65)) 26))\n            :else asc))))\n\n(defn encode-str [input shift]\n  (let [first-letter (str\/lower-case (first input))\n        second-letter (shift-letter (first first-letter) shift)\n        encoded-string (str first-letter second-letter\n                            (str\/join (map #(shift-letter % shift) input)))]\n    (map str\/join (partition-all (Math\/ceil (\/ (count encoded-string) 5)) encoded-string))))\n    \n(defn decode [str]\n  (let [combined (str\/join str)\n        [prefix ciphertext] (split-at 2 combined)\n        shift (apply - (map int prefix))]\n    (str\/join (map #(shift-letter % shift) ciphertext))))\n\n(defmacro lazy-decode [[encode-str str shift]] str)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"550f22f4d758534c1100025a":[{"id":15823,"user_id":null,"body":"(ns dir_reduc.core) \n\n(def opposite\n  {\"NORTH\" \"SOUTH\", \"SOUTH\" \"NORTH\",\n  \"WEST\" \"EAST\", \"EAST\" \"WEST\"})\n\n(defn removeOpps\n  [arr dir]\n  (if (= (opposite (peek arr)) dir) \n    (pop arr)\n    (conj arr dir)))  \n\n(defn dir_reduc\n  [arr]\n  (not-empty (reduce removeOpps [] arr)))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15824,"user_id":null,"body":"(ns dir_reduc.core) \n\n(def opposite?\n  {\"NORTH\" \"SOUTH\"\n   \"SOUTH\" \"NORTH\"\n   \"EAST\" \"WEST\"\n   \"WEST\" \"EAST\"})\n\n(defn step [path next]\n  (if (= next (opposite? (peek path)))\n    (pop path)\n    (conj path next)))\n\n(defn dir_reduc [arr] (seq (reduce step [] arr)))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15825,"user_id":null,"body":"(ns dir_reduc.core) \n\n(defn dir_reduc\n  [arr]\n  (letfn [(opposite? [dir1 dir2]\n            (and (not= dir1 dir2)\n                 (or (= #{\"NORTH\" \"SOUTH\"} #{dir1 dir2})\n                     (= #{\"EAST\" \"WEST\"} #{dir1 dir2}))))\n          (nil-replace [dirs] (if (empty? dirs) nil dirs))]\n    (nil-replace\n      (reduce #(if (opposite? (peek %1) %2)\n      \t\t\t\t\t(pop %1)\n                (conj %1 %2)) [] arr))))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15826,"user_id":527,"body":"(ns dir_reduc.core) \n\n(def opposite {\"NORTH\" \"SOUTH\", \"EAST\" \"WEST\", \"SOUTH\" \"NORTH\", \"WEST\" \"EAST\"})\n\n(defn dir_reduc [plan]\n  (not-empty (reduce #(if (= (peek %) (opposite %2)) (pop %) (conj % %2)) [] plan)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15827,"user_id":null,"body":"(ns dir_reduc.core) \n\n(def opposite {\"NORTH\" \"SOUTH\", \"SOUTH\" \"NORTH\", \"EAST\" \"WEST\", \"WEST\" \"EAST\"})\n\n(defn dir_reduc [arr]\n  (loop [r [], [h & t] arr]\n    (if h\n      (recur\n        (if (= h (opposite (last r)))\n          (pop r)\n          (conj r h) )\n        t )\n      (when (seq r) r) )))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15828,"user_id":null,"body":"(ns dir_reduc.core) \n\n(def bads [[\"EAST\" \"WEST\"] [\"WEST\" \"EAST\"] [\"NORTH\" \"SOUTH\"] [\"SOUTH\" \"NORTH\"]])\n\n(defn bad? [pair]\n  (some (partial = pair) bads))\n  \n(defn r [a b] \n  (if (bad? [(last a) b]) \n        (vec (butlast a))\n        (conj a b)))\n  \n(defn dir_reduc [arr]\n  (let [result (reduce r [] arr)]\n    (if (empty? result) [] result)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-26 17:50:51"},{"id":15829,"user_id":492,"body":"(ns dir_reduc.core)\n\n(defn oppDir\n  [direction]\n  (cond\n    (= direction \"NORTH\") \"SOUTH\"\n    (= direction \"SOUTH\") \"NORTH\"\n    (= direction \"WEST\")  \"EAST\"\n    (= direction \"EAST\")  \"WEST\"))  \n\n(defn dir_reduc\n  [arr]\n  (let [d (if (seq arr)\n            (if (seq (rest arr))\n              (if (= (first arr) (oppDir (first (rest arr))))\n                (dir_reduc (rest (rest arr)))\n                (cons (first arr) (dir_reduc (rest arr))))\n              arr))]\n    (if (= d arr)\n      arr\n      (dir_reduc d))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15830,"user_id":null,"body":"(ns dir_reduc.core\n  (:require [clojure.string :as str])) \n\n(defn dir_reduc\n  [arr]\n  ((fn [directions]\n     (let [red (str\/replace directions #\"NORTHSOUTH|EASTWEST|SOUTHNORTH|WESTEAST\" \"\")]\n       (if (= red directions)\n           (re-seq #\"EAST|NORTH|WEST|SOUTH\" red)\n           (recur red)))) (str\/join \"\" arr)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15831,"user_id":null,"body":"(ns dir_reduc.core) \n\n(defn same-dir? [a b]\n  (or\n   (and (= a \"NORTH\") (= b \"SOUTH\"))\n   (and (= a \"SOUTH\") (= b \"NORTH\"))\n   (and (= a \"WEST\") (= b \"EAST\"))\n   (and (= a \"EAST\") (= b \"WEST\"))))\n\n(defn dir_reduc [arr]\n  (loop [dirs arr\n         acc []]\n    (if (empty? dirs)\n      (if (empty? acc) nil acc)\n      (if (same-dir? (first dirs) (second dirs))\n        (recur (concat acc (drop 2 dirs)) [])\n        (recur (next dirs) (conj acc (first dirs)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15832,"user_id":null,"body":"(ns dir_reduc.core) \n\n(ns dir_reduc.core)\n\n  \n(def opposite\n  {\"NORTH\" \"SOUTH\"\n   \"SOUTH\" \"NORTH\"\n   \"EAST\" \"WEST\"\n   \"WEST\" \"EAST\"})\n\n;; The persistent (rather than transient) version of this\n;; is easier to read\/write but might suffer from performance issues\n;; compared to transient.\n(defn dir_reduc [arr]\n  (not-empty\n    (reduce\n      (fn [buf dir]\n        (cond\n          (empty? buf) (conj buf dir)\n          (= dir (opposite (peek buf))) (pop buf)\n          :else (conj buf dir)))\n      []\n      arr)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"551614eb77dd9ee37100003e":[{"id":15833,"user_id":null,"body":"(ns batman.core\n  (:require [clojure.string :as s]))\n\n(def heroes #{\"Batman\" \"Joker\" \"Robin\"})\n\n;; Get an integer from the string\n(defn- parse-int [string]\n  (read-string (re-find #\"\\d+\" string)))\n\n;; Find a hero in the heroes set by the pattern\n(defn- find-hero [string]\n  (let [pattern (re-pattern (s\/replace string #\"\\d\" \".\"))]\n    (some #(re-matches pattern %) heroes)))\n\n(defn batman-quotes [quotes hero]\n  (let [hero-str (find-hero hero)\n        quote-idx (parse-int hero)]\n    (str hero-str \": \" (quotes quote-idx))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15834,"user_id":null,"body":"(ns batman.core\n  (:require [batman.preloaded :refer [quotes]]))\n\n(defn get-char [n] (str (case n 0 \"Batman\" 1 \"Robin\" 2 \"Joker\") \": \"))\n(defn batman-quotes [quotes hero]\n  (let [n (Character\/digit (first (sort hero)) 10)]\n    (apply str (get-char n) (get quotes n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15835,"user_id":null,"body":"(ns batman.core\n  (:require [batman.preloaded :refer [quotes]]))\n\n(defn batman-quotes [quotes hero]\n  (str (clojure.string\/replace hero #\"0|1|2\" {\"0\" \"a\" \"1\" \"i\" \"2\" \"e\"}) \": \" (-> (re-find #\"[0-2]\" hero) Integer. quotes))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15836,"user_id":null,"body":"(ns batman.core)\n\n(def getCharacter #(get {\\B \"Batman\", \\R \"Robin\", \\J \"Joker\"} (first %)))\n(def getIndex #(Integer. (re-find #\"[0-9]+\" %)))\n(defn batman-quotes [quotes hero]\n  (str (getCharacter hero) \": \" (nth quotes (getIndex hero)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15837,"user_id":null,"body":"(ns batman.core)\n\n(ns batman.core)\n\n(defn batman-quotes [quotes hero]\n  (let [names {\\B \"Batman\" \\R \"Robin\" \\J \"Joker\"}]\n    (str (get names (first hero)) \": \" (get quotes (Integer\/valueOf (re-find #\"\\d\" hero))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15838,"user_id":null,"body":"(ns batman.core)\n\n(defn batman-quotes [quotes hero]\n  (let [ind (Integer. (re-find #\"\\d\" hero))\n        hero (cond\n               (= (subs hero 0 1) \"B\") \"Batman: \"\n               (= (subs hero 0 1) \"R\") \"Robin: \"\n               :else \"Joker: \"\n               )\n        ]\n    (str hero (quotes ind))\n    )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15839,"user_id":null,"body":"(ns batman.core)\n\n(def hero-names '(\"Batman\", \"Robin\", \"Joker\"))\n\n(defn batman-quotes [quotes hero]\n (let [quote-index (Integer. (re-find #\"\\d+\" hero))\n       int-index (.indexOf hero (str quote-index))]\n\n   (loop [heros hero-names]\n     (if (and (string? (re-matches (re-pattern (str \"(?i)\" (subs hero 0 int-index))) (subs (first heros) 0 int-index)))\n              (string? (re-matches (re-pattern (str \"(?i)\" (subs hero (+ int-index 1) (count hero)))) (subs (first heros) (+ int-index 1) (count (first heros))))))\n\n       (str (first heros) \": \" (quotes quote-index))\n       (recur (rest heros)))\n     )\n   ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15840,"user_id":null,"body":"(ns batman.core\n  (:require [batman.preloaded :refer [quotes]]))\n\n(def heroes {\\B \"Batman\", \\R \"Robin\", \\J \"Joker\"})\n\n(defn batman-quotes [quotes hero]\n  (def corrected-name (get heroes (first hero)))\n  (def quote-index (Integer. (re-find #\"[0-9]\" hero)))\n  \n  (str corrected-name \": \" (get quotes quote-index))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15841,"user_id":null,"body":"(ns batman.core\n  (:require [batman.preloaded :refer [quotes]]))\n\n(defn batman-quotes [quotes hero]\n  \"Fixed :)\"\n  (let [index   (Integer\/parseInt (re-find #\"\\d+\" hero)) ; assumes `hero` always contains a series of digits\n        heroes  {\\B \"Batman\"\n                 \\R \"Robin\"\n                 \\J \"Joker\"}\n        speaker (heroes (get hero 0))]\n     (str speaker \": \" (nth quotes index))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15842,"user_id":null,"body":"(ns batman.core\n  (:require [batman.preloaded :refer [quotes]]))\n  \n(def characters {\\B \"Batman\" \\R \"Robin\" \\J \"Joker\"})\n\n(defn batman-quotes [quotes hero]\n  (let [idx (Integer\/parseInt (re-find #\"\\d\" hero))\n        hero-name (get characters (first hero))]\n          (str hero-name \": \" (get quotes idx))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5517fcb0236c8826940003c9":[{"id":15843,"user_id":null,"body":"(ns sumfracts.core)\n\n(defn sum_fracts [coll]\n  (when-not (empty? coll)\n    (let [sum (reduce + (map #(apply \/ %) coll))]\n      (if (ratio? sum)\n        [(numerator sum) (denominator sum)]\n        sum))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15844,"user_id":492,"body":"(ns sumfracts.core)\n\n(defn sum_fracts [l]\n  (if (= l [])\n    nil\n    (let [reduce-fraction #(\/ (first %) (last %))\n        f (clojure.lang.Numbers\/toRatio (reduce + (map reduce-fraction l)))]\n      (if (not= (denominator f) 1)\n        [(numerator f) (denominator f)]\n        (numerator f)))))\n    ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15845,"user_id":null,"body":"(ns sumfracts.core)\n\n(defn sum_fracts [rs]\n  (when (seq rs)\n    (let [res (->> (map #(apply \/ %) rs) (apply +))]\n      (cond-> res (ratio? res) ((juxt numerator denominator))))))\n    ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15846,"user_id":null,"body":"(ns sumfracts.core)\n\n(defn sum_fracts [cs]\n  (let [sum (reduce #(+ %1 (\/ (first %2) (second %2))) 0 cs)]\n    (cond\n      (ratio? sum) ((juxt numerator denominator) sum)\n      (empty? cs) nil\n      :else sum))\n)\n    ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15847,"user_id":null,"body":"(ns sumfracts.core)\n\n(defn sum_fracts [cs]\n  (let [sum (reduce #(+ %1 (\/ (first %2) (second %2))) 0 cs)]\n    (cond\n        (ratio? sum) [(numerator sum) (denominator sum)]\n        (empty? cs) nil\n        :else sum)))\n    ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15848,"user_id":null,"body":"(ns sumfracts.core)\n\n(defn sum_fracts [l]\n  (when-not (empty? l)\n    (let [sum (reduce + (map #(apply \/ %) l))]\n      (if (ratio? sum) ((juxt numerator denominator) sum) sum))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15849,"user_id":null,"body":"(ns sumfracts.core)\n\n(defn sum_fracts [l]\n  (if (empty? l)\n    nil\n    (let [sum (reduce + (map #(apply \/ %) l))]\n      (if (ratio? sum) ((juxt numerator denominator) sum) sum))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15850,"user_id":null,"body":"(ns sumfracts.core\n  (:require [clojure.string :as str]))\n\n(defn fracts->out\n  [[n d :as result-vec]]\n  (if (nil? d)\n    n\n    result-vec))\n\n(defn sum_fracts\n  [coll]\n  (when-not (empty? coll)\n    (->> coll\n         (map (fn [[n d]] (\/ n d)))\n         (reduce +)\n         (str)\n         (#(str\/split % #\"\/\"))\n         (mapv read-string)\n         (fracts->out))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15851,"user_id":null,"body":"(ns sumfracts.core)\n\n(def sum\n  (let [p- partial\n        rep #(if (ratio? %)\n               ((juxt numerator denominator) %)\n               (identity %))]\n    (comp rep (p- apply +) (p- map (p- apply \/)))))\n\n(defn sum_fracts [l]\n  (when (seq l) (sum l)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15852,"user_id":53,"body":"(ns sumfracts.core)\n\n(defn gcd [x y]\n    (cond\n       (= 0 y) x\n       :else (gcd y (mod x y)))\n  )\n(defn lcm [x y]\n    (quot (* x y) (gcd x y))\n  )\n\n(defn convert-fracts [lst]\n  (let [cd (reduce (fn [acc x] (lcm (nth x 1) acc)) 1 lst)]\n    (map (fn [x] [(\/ (* cd (nth x 0)) (nth x 1)), cd]) lst)\n  )\n)\n\n(defn sum_fracts [l]\n  (if (empty? l)\n    nil\n    (let [xs (convert-fracts (map (fn [x] [(bigint (nth x 0)) (bigint (nth x 1))]) l))\n          n (reduce (fn [acc x] (+ acc (nth x 0))) 0 xs)\n          d (nth (nth xs 0) 1)\n          g (gcd n d)]\n      (if (= d g)\n        (quot n g)\n        (list (quot n g) (quot d g))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55192f4ecd82ff826900089e":[{"id":15853,"user_id":null,"body":"(ns kata)\n\n(defn divide [n]\n  (and (even? n) (>= n 4)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-28 19:38:22"},{"id":15854,"user_id":null,"body":"(ns kata)\n\n(defn divide [n]\n  (and (>= n 4)\n       (even? n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15855,"user_id":null,"body":"(ns kata)\n(defn divide [n]\n  (if (and (> n 2) (even? n))\n    true\n    false\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15856,"user_id":null,"body":"(ns kata)\n(defn divide [integer]\n  (and (even? integer) (not= integer 2) )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15857,"user_id":null,"body":"(ns kata)\n(defn divide [n]\n  (and (not (= n 2)) (even? n))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15858,"user_id":null,"body":"(ns kata)\n(defn divide [n]\n  (if (and (= (rem n 2) 0)(> n 2))\n    true\n    false)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15859,"user_id":null,"body":"(ns kata)\n(defn divide [n]\n  (and (< 2 n)\n       (even? n)\n       (or (even? (- n 2))\n           (even? (\/ n 2)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15860,"user_id":null,"body":"(ns kata)\n\n(defn divide [n]\n  (and (> n 3) (= 0 (mod n 2)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15861,"user_id":null,"body":"(ns kata)\n(defn divide [n]\n  (if (and (=(rem n 2) 0) (not= n 2))  true false)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15862,"user_id":null,"body":"(ns kata)\n(defn divide [n]\n  (and (>= n 4) (= 0 (mod n 2)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"551dc350bf4e526099000ae5":[{"id":15863,"user_id":null,"body":"(ns dubstep)\n\n(defn song_decoder [song]\n  (clojure.string\/trim \n    (clojure.string\/replace song #\"(WUB)+\" \" \")\n  )\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15864,"user_id":null,"body":"(ns dubstep\n (:require [clojure.string :as str]))\n\n(defn song_decoder [song]\n  (-> song (str\/replace #\"(WUB)+\" \" \") (str\/trim)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15865,"user_id":null,"body":"(ns dubstep\n  (:require [clojure.string :refer [join blank? split]]))\n\n(defn song_decoder [^String song]\n  (join \" \" (filter (comp not blank?) (split song #\"WUB\"))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15866,"user_id":null,"body":"(ns dubstep\n  [:require [clojure.string :as s]])\n\n(defn song_decoder [song]\n  (-> (s\/replace song #\"(WUB)+\" \" \") s\/trim))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15867,"user_id":null,"body":"(ns dubstep\n  (:require [clojure.string :as s]))\n\n(defn song_decoder [song]\n  (s\/trim (s\/replace song #\"(WUB)+\" \" \"))\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15868,"user_id":null,"body":"(ns dubstep)\n\n(defn song_decoder [song]\n  (-> song\n      (clojure.string\/replace #\"(WUB)+\" \" \")\n      clojure.string\/trim))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15869,"user_id":null,"body":"(ns dubstep)\n\n(defn song_decoder [song]\n   (-> song \n     (clojure.string\/replace #\"^(WUB)+\" \"\")\n     (clojure.string\/replace #\"(WUB)+$\" \"\")\n     (clojure.string\/replace #\"(WUB)+\" \" \"))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15870,"user_id":null,"body":"(ns dubstep)\n\n(defn song_decoder [song]\n  (clojure.string\/trim (clojure.string\/replace (clojure.string\/replace song #\"WUB\" \" \") #\"\\s+\" \" \"))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15871,"user_id":null,"body":"(ns dubstep)\n(use '[clojure.string :only (join split blank?)])\n\n(defn song_decoder [song]\n  (join \" \" (filter #(not (blank? %)) (split song #\"WUB\")))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15872,"user_id":null,"body":"(ns dubstep)\n\n(defn song_decoder [song]\n  (-> song\n    (clojure.string\/replace #\"WUB\" \" \")\n    (clojure.string\/replace #\" {2,}\" \" \")\n    (clojure.string\/trim)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"551dd1f424b7a4cdae0001f0":[{"id":15873,"user_id":null,"body":"(ns cola.core)\n\n(defn who_is_next [names, r]\n  (if (<= r 5)\n    (nth names (- r 1))\n    (who_is_next names (quot (- r 4) 2))))\n","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15874,"user_id":null,"body":"(ns cola.core)\n\n; n - count of names\n; r = n * (2^k - 1) + m * 2^k + q\n; 1 <= r < n * (2^(k+1) - 1), 0 <= m < n, 0 <= q < 2^k\n\n(defn who_is_next [names, r]\n  (let [n (count names) k (- 63 (Long\/numberOfLeadingZeros (inc (quot (dec r) n))))\n        pow2k (bit-shift-left 1 k)] (names (quot (- (dec r) (* n (- pow2k 1))) pow2k)) ))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15875,"user_id":53,"body":"(ns cola.core)\n\n(defn log2 [n]\n  (\/ (Math\/log n) (Math\/log 2)))\n\n(defn who_is_next [names, r]\n  (let [n (count names)\n        k (int (Math\/floor (log2 (\/ (dec (+ r n)) n))))\n        t (Math\/pow 2 k)\n        v (- (dec (+ r n)) (* n t))\n        i (int (Math\/floor (\/ v t)))]\n    (nth names i)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15876,"user_id":null,"body":"(ns cola.core)\n\n(defn who_is_next [names, r]\n  (loop [iteration 0\n         index 1]\n    (let [iter-size (bit-shift-left (count names) iteration)]\n      (if (< r (+ index iter-size))\n        (names (int (\/ (- r index) (bit-shift-left 1 iteration))))\n        (recur (inc iteration) (+ index iter-size))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15877,"user_id":1928,"body":"(ns cola.core)\n\n(defn who_is_next [names, r]\n  (let [ nS (int (\/ (Math\/log (\/ (+ r 4) 5)) (Math\/log 2)))\n         rank1stSerie (int (- (* 5 (Math\/pow 2 nS)) 4))\n         dist (int (\/ (- r rank1stSerie) (Math\/pow 2 nS))) ] \n    (names dist)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15878,"user_id":null,"body":"(ns cola.core)\n\n(defn- doublings\n  ([] (doublings 1))\n  ([n] (lazy-seq (cons n (doublings (* n 2))))))\n\n(defn who_is_next [names, r]\n  (let [[a b] (last (map vector\n                         (take-while #(> % 0) (reductions #(- %1 (* %2 (count names))) r (doublings)))\n                         (doublings)))]\n    (nth names (int (\/ (dec a) b)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15879,"user_id":null,"body":"(ns cola.core)\n\n(defn double-group [[size name]]\n  [(* 2 size) name])\n\n(defn groups [names]\n  (lazy-seq\n    (concat (map #(vector 1 %) names)\n            (map double-group (groups names)))))\n\n(defn who_is_next [names, r]\n  (loop [n r\n         [[size name] & remaining] (groups names)]\n    (if (<= n size)\n      name\n      (recur (- n size) remaining)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15880,"user_id":null,"body":"(ns cola.core)\n\n(defn double-group [[size name]]\n  [(* 2 size) name])\n\n(defn groups [names]\n  (lazy-seq\n    (concat (map #(vector 1 %) names)\n          (map double-group (groups names)))))\n\n\n(defn get-nth [n gs]\n  (loop [n n\n        [[size name] & rest] gs]\n        (if (<= n size)\n          name\n          (recur (- n size) rest))))\n\n(defn who_is_next [names, r]\n  (get-nth r (groups names)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15881,"user_id":null,"body":"(ns cola.core)\n\n(defn find_rem [r start]\n  (if (> (- r start) 0) (find_rem (- r start) (* 2 start)) [r start]))\n\n(defn who_is_next [[n1, n2, n3, n4, n5], r]\n  (let [[pos all] (find_rem r 5)]\n      (cond\n        (<= pos (* all 0.2)) n1\n        (<= pos (* all 0.4)) n2\n        (<= pos (* all 0.6)) n3\n        (<= pos (* all 0.8)) n4\n        :else n5)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15882,"user_id":null,"body":"(ns cola.core)\n\n(defn who_is_next\n  [names length]\n  (let [people (count names)\n        n (Math\/floor (\/ (Math\/log (+ (\/ length people) 1)) (Math\/log 2)))\n        s (- (Math\/pow 2 n) 1)\n        rem (- length (* s people) 1)\n        i (int (Math\/floor (\/ rem (Math\/pow 2 n))))]\n    (if (< i 0) (get names (+ people i)) (get names i))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55251c0d2142d7b4ab000aef":[{"id":15883,"user_id":2993,"body":"(ns stairs.core)\n\n(defn number-of-steps [steps, m]\n  (if (< steps m) -1 (int (* m (Math\/ceil (\/ steps (* 2 m))))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15884,"user_id":null,"body":"(ns stairs.core)\n\n(defn number-of-steps [st m]\n  (if (<= m st)\n    (let [n (long (Math\/ceil (\/ st 2)))]\n      (+ n (rem (- m (rem n m)) m)))\n    -1))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15885,"user_id":168,"body":"(ns stairs.core)\n\n(defn number-of-steps [n m]\n  (if (< n m) -1 (* (quot (+ n (* 2 m) -1) (* 2 m)) m)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15886,"user_id":null,"body":"(ns stairs.core)\n\n(defn number-of-steps [steps, m]\n  (if (< steps m) -1\n    (->> (iterate dec (quot steps 2))\n         (map #(+ % (- steps (* % 2))))\n         (drop-while #(pos? (rem % m)))\n         (first))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15887,"user_id":null,"body":"(ns stairs.core)\n\n(defn number-of-steps [steps m]\n  (let [lo (if (odd? steps)\n             (inc (\/ (dec steps) 2))\n             (\/ steps 2))\n        r (rem lo m)\n        ext (- m r)]\n   (cond \n     (< steps m) -1\n     (zero? r) lo\n     :else (+ lo ext))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15888,"user_id":null,"body":"(ns stairs.core)\n\n(defn number-of-steps [steps, m]\n  (loop [i (int (\/ (+ steps 1) 2))]\n    (cond \n      (= 0 (mod i m)) i\n      (= i steps) -1\n      :else (recur (+ i 1)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15889,"user_id":1670,"body":"(ns stairs.core)\n\n(defn number-of-steps [steps, m]\n  (cond \n    (< steps m) -1\n    (zero? (mod (\/ steps 2) m)) (\/ steps 2)\n    :else (* (inc (quot (\/ steps 2) m)) m)\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15890,"user_id":null,"body":"(ns stairs.core)\n\n(defn number-of-steps [steps, m]\n  (if (> m steps)\n    -1\n    (if (= 0 (rem steps (* 2 m)))\n      (* (long (\/ steps (* 2 m))) m)\n      (+ (* (long (\/ steps (* 2 m))) m) m)\n    )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15891,"user_id":null,"body":"(ns stairs.core)\n\n(defn number-of-steps [steps, m]\n  (let [min-steps (+ (quot steps 2) (rem steps 2))\n        max-steps steps\n        first-stp (first (filter #(zero? (rem % m)) (range min-steps (inc max-steps))))]\n    (case first-stp\n      0 -1\n      nil -1\n      first-stp)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15892,"user_id":null,"body":"(ns stairs.core)\n\n(defn number-of-steps [steps, m]\n  (if (>= steps m)\n    (let [res (for [r (range (+ (quot steps 2) (mod steps 2)) (+ steps 1))\n                    :while (not= (mod r m) 0)]\n                r ) ]\n      (if (not-empty res) (+ (last res) 1) (+ (quot steps 2) (mod steps 2)))\n      )\n    -1\n    )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"552ec968fcd1975e8100005a":[{"id":15893,"user_id":null,"body":"(ns english-to-n00b)\n\n(defn add-lol-omg [s]\n  (let [s1 (apply str (re-seq #\"[\\w ]+\" s))]\n    (cond \n      (and (= \"w\" (clojure.string\/lower-case (first s))) (>= (count s1) 28)) (str \"LOL \" \"OMG \" s)\n      (= \"w\" (clojure.string\/lower-case (first s))) (str \"LOL \" s)\n      (>= (count s1) 32) (str \"OMG \" s)\n      :else s\n    ;(if (>= (count s1) 32) (str \"OMG \" s) s)\n    )\n  )\n)\n\n(defn upper-case-all [s]\n  (if (=\"h\" (clojure.string\/lower-case (first s))) (clojure.string\/upper-case s) s)\n)\n\n(defn cap-even-words [s]\n  (clojure.string\/join \" \" \n    (keep-indexed #(if (odd? %1) (clojure.string\/upper-case %2) %2) (clojure.string\/split s #\" \"))\n  )\n)\n\n(defn excl-marks [w] (clojure.string\/replace w #\"\\?\"\n  (apply str (take (count (clojure.string\/split w #\" \")) (repeat \"?\")))\n  )\n)\n\n(defn excl-points [w]\n  (let [n-words (count (clojure.string\/split w #\" \")) q (quot n-words 2) r (mod n-words 2)]  \n      (clojure.string\/replace w #\"!\"\n        (apply str (apply str (take q (repeat \"!1\"))) (take r (repeat \"!\")))\n      )\n  )\n)\n\n(defn n00bify [text]\n   (-> text\n     (clojure.string\/replace #\"(?i)fore\" \"4\")\n     (clojure.string\/replace #\"(?i)for\" \"4\")\n     (clojure.string\/replace #\"(?i)too|(?i)to\" \"2\")\n     (clojure.string\/replace #\"(?i)oo\" \"00\")\n     (clojure.string\/replace #\"(?i)be\" \"b\")\n     (clojure.string\/replace #\"(?i)are\" \"r\")\n     (clojure.string\/replace #\"(?i)you\" \"u\")\n     (clojure.string\/replace #\"(?i)please\" \"plz\")\n     (clojure.string\/replace #\"(?i)people\" \"ppl\")\n     (clojure.string\/replace #\"(?i)really\" \"rly\")\n     (clojure.string\/replace #\"(?i)have\" \"haz\")\n     (clojure.string\/replace #\"(?i)know\" \"no\")\n     (clojure.string\/replace #\"s\" \"z\")\n     (clojure.string\/replace #\"S\" \"Z\")\n     (upper-case-all) \n     (clojure.string\/replace #\"[,.']\" \"\")\n     (add-lol-omg)\n     (cap-even-words)\n     (excl-marks)\n     (excl-points)\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15894,"user_id":527,"body":"(ns english-to-n00b\n  (:require [clojure.string :as string]))\n\n(defn n00bify [text]\n  (let [\n      text1 (reduce (fn [s [from to]] (string\/replace s from to)) text [\n        [#\"(?i)too?\" \"2\"] [#\"(?i)fore?\" \"4\"] [#\"(?i)oo\" \"00\"]\n        [#\"(?i)be\" \"b\"] [#\"(?i)are\" \"r\"] [#\"(?i)you\" \"u\"]\n        [#\"(?i)please\" \"plz\"] [#\"(?i)people\" \"ppl\"] [#\"(?i)really\" \"rly\"]\n        [#\"(?i)have\" \"haz\"] [#\"(?i)know\" \"no\"]\n        [\\s \\z] [\\S \\Z] [#\"[.,']\" \"\"]\n        [#\"(?i)^(?=w)\" \"LOL \"] [#\"^(LOL |)(.*)$\" (fn [[s lol rest]] (str lol\n          (when (-> s (string\/replace #\"[!?]\" \"\") count (>= 32)) \"OMG \")\n          rest))]\n        [#\"(\\S+\\s+)(\\S+)\" (fn [[s0 s1 s2]] (str s1 (string\/upper-case s2)))]\n        [#\"(?i)^h.*\" string\/upper-case]\n        ])\n      nw (count (string\/split text1 #\" \"))\n      qms (apply str (repeat nw \\?))\n      text2 (string\/replace text1 \"?\" qms)\n      ems (apply str (take nw (cycle \"!1\")))\n      text3 (string\/replace text2 \"!\" ems)\n    ] text3))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15895,"user_id":null,"body":"(ns english-to-n00b\n  (:require [clojure.string :as str]))\n\n(defn n00bify [text]\n  (-> text\n    (str\/replace #\"(?i)too?\" \"2\")\n    (str\/replace #\"(?i)fore?\" \"4\")\n    (str\/replace #\"(?i)oo\" \"00\")\n    (str\/replace #\"be|are|you|please|people|really|have|know\"\n                 {\"be\" \"b\", \"are\" \"r\", \"you\" \"u\",\n                  \"please\" \"plz\", \"people\" \"ppl\",\n                  \"really\" \"rly\", \"have\" \"haz\", \"know\" \"no\"})\n    (str\/replace #\"Be|Are|You|Please|People|Really|Have|Know\"\n                 {\"Be\" \"B\", \"are\" \"r\", \"You\" \"U\",\n                  \"Please\" \"Plz\", \"People\" \"Ppl\",\n                  \"Really\" \"Rly\", \"Have\" \"Haz\", \"Know\" \"No\"})\n    (str\/replace #\"s|S\" {\"s\" \"z\", \"S\" \"Z\"})\n    (str\/replace #\"^(?=w|W)\" \"LOL \")\n    (str\/replace #\"[.,']\" \"\")\n    (#(if (>= (count (str\/replace % #\"[!?]\" \"\")) 32)\n        (str\/replace % #\"^(LOL )?\" \"$1OMG \")\n        %\n        ))\n    (#(if (= (str\/lower-case (first %)) \"h\")\n        (str\/upper-case %)\n        (->> (str\/split % #\" \")\n          (map-indexed (fn [i w] (if (odd? i)\n                                   (str\/upper-case w)\n                                   w)))\n          (str\/join \" \")\n          )\n        ))\n    (#(let [c (count (str\/split % #\" \"))]\n        (-> %\n          (str\/replace #\"\\?\" (apply str (repeat c \\?)))\n          (str\/replace #\"!\" (apply str (map (fn [i]\n                                              (if (even? i) \\! \\1))\n                                              (range c))))\n          )\n        ))\n    )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15896,"user_id":null,"body":"(ns english-to-n00b\n  (:require [clojure.string :as s]))\n\n(defn replaces [s m]\n  (reduce (fn [s [match rep]] (s\/replace s match rep)) s m))\n\n(defn n00bify [text0]\n  (let [lol (if (re-matches #\"^[wW].*\" text0) \"LOL \" \"\")\n        starts-h (re-matches #\"^[hH].*\" text0)\n        text-rep (replaces text0 {#\"(?i)too?\" \"2\", #\"(?i)fore?\" \"4\", #\"[.,']\" \"\", #\"(?i)be\" \"b\", #\"(?i)are\" \"r\", #\"(?i)you\" \"u\"\n                                  #\"(?i)please\" \"plz\", #\"(?i)people\" \"ppl\", #\"(?i)really\" \"rly\", #\"(?i)have\" \"haz\", #\"(?i)know\" \"no\"})\n        text-rep2 (replaces text-rep {#\"(?i)oo\" \"00\", #\"s\" \"z\", #\"S\" \"Z\"})\n        omg (if (>= (count (s\/replace (str lol text-rep2) #\"!\" \"\")) 32) \"OMG \" \"\")\n        text-con (str lol omg text-rep2)\n        text-cap (if starts-h\n                   (s\/upper-case text-con)\n                   (->> (s\/split text-con #\" \")\n                        (map-indexed #(if (odd? %1) (s\/upper-case %2) %2))\n                        (s\/join #\" \")))\n        n-words (count (s\/split text-cap #\" \"))\n        text-??? (s\/replace text-cap #\"\\?+\" (apply str (repeat n-words \\?)))\n        text-!1! (s\/replace text-??? #\"\\!+\" (apply str (take n-words (cycle [\\! \\1]))))]\n    text-!1!))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15897,"user_id":null,"body":"(ns english-to-n00b\n  (:require [clojure.string :as s]))\n\n(def words #(s\/split % #\"\\s+\"))\n\n(def upper  #(.toUpperCase %))\n(def lower  #(.toLowerCase %))\n(def upper? #(Character\/isUpperCase %))\n(def lower? #(Character\/isLowerCase %))\n(defn capitalize [[f & r]] (str (Character\/toUpperCase f) (apply str r)))\n\n(def conversions\n  [[#\"too?\" \"2\"]\n   [#\"fore?\" \"4\"]\n   [#\"oo\" \"00\"]\n   [#\"s\" \"z\"]\n   [#\"be\" \"b\"] \n   [#\"are\" \"r\"]\n   [#\"you\" \"u\"]\n   [#\"pleaze\" \"plz\"]\n   [#\"people\" \"ppl\"]\n   [#\"really\" \"rly\"]\n   [#\"have\" \"haz\"]\n   [#\"know\" \"no\"]\n   [#\"[.,']\", \"\"]])\n\n(defn process-word [word [rgx sub]]\n    (s\/replace word rgx sub))\n\n(defn word-reduce [word]\n  (let [[f & _] word\n        all-upper? (every? upper? (s\/replace word #\"[.,'!?]\" \"\"))\n        case-fn (cond all-upper? upper (upper? f) capitalize :else identity)]\n    (case-fn (reduce process-word (lower word) conversions))))\n\n(defn if-starts-with-h [text]\n  (let [[f & _] text]\n    (if (= \"H\" (upper (str f)))\n      (upper text)\n      text)))\n\n(def join-with-count #(vector (s\/join \" \" %) (count %)))\n\n(defn lol-omg [coll]\n  (let [lol? (= \\W (Character\/toUpperCase (first (first coll))))\n        omg? (<= 32 (+ (if lol? 4 0) (dec (count coll)) (apply + (map (fn [word] (count (s\/replace word #\"(!1?|\\?)\" \"\"))) coll))))]\n    (->> coll\n         ((if omg? (partial cons \"OMG\") identity))\n         ((if lol? (partial cons \"LOL\") identity)))))\n\n(defn repunctuate [[text puncs]]\n  (s\/replace\n    (s\/replace text #\"\\?\" #(apply str (repeat puncs %)))\n   #\"!\" (apply str (map #(if (odd? %) \"1\" \"!\") (range puncs)))))\n\n(defn n00bify [text]\n  (->> text\n       if-starts-with-h\n       words\n       (map word-reduce)\n;;        println\n       lol-omg\n       (map vector (range))\n       (map (fn [[ct word]] (if (odd? ct) (upper word) word)))\n       join-with-count\n       repunctuate\n    ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15898,"user_id":null,"body":"(ns english-to-n00b\n  (:require [clojure.string :as str]))\n\n(def replacements [[#\"fore|Fore|FORE|For|for\" \"4\"] [#\"to|too|Too|To\" \"2\"] [#\"be\" \"b\"] [#\"Be\" \"B\"] [#\"know\" \"no\"]\n                   [#\"Have\" \"Haz\"] [#\"have\" \"haz\"] [#\"people\" \"ppl\"] [#\"People\" \"Ppl\"] [#\"really\" \"rly\"]\n                   [#\"Really\" \"Rly\"] [#\"Please\" \"Plz\"] [#\"please\" \"plz\"]\n                   [#\"you\" \"u\"] [#\"You\" \"U\"] [#\"are\" \"r\"] [#\"oo|OO|Oo|oO\" \"00\"] [#\"s\" \"z\"] [#\"S\" \"Z\"]])\n\n(defn lolify [text]\n  (if (or (str\/starts-with? text \"w\") (str\/starts-with? text \"W\"))\n    (str \"LOL \" text)\n    text))\n\n(defn count-characters [text]\n  (count\n    (apply str (re-seq #\"[\\w\\s]+\" text))))\n\n(defn omgify [text]\n  (if (>= (count-characters text) 32)\n      (if (str\/starts-with? text \"LOL\")\n        (str (subs text 0 4) \"OMG \" (subs text 4))\n        (str \"OMG \" text))\n      text))\n\n\n(defn word-count [text]\n  (count (str\/split text #\" \")))\n\n(defn remove-punctuation [text]\n  (str\/replace text #\",|\\.|\\'\" \"\"))\n\n(defn exclam [text]\n  (str\/replace text #\"\\!\" (apply str (take (word-count text) (cycle \"!1\")))))\n\n(defn overdo-question-marks [text]\n  (str\/replace text #\"\\?\" (apply str (repeat (word-count text) \"?\"))))\n\n(defn capitalize-even-words [text]\n  (->> (str\/split text #\" \")\n       (map-indexed (fn [i w] (if (odd? i) (str\/upper-case w) w)))\n       (str\/join \" \")))\n\n(defn uppercase-if-starts-h [text]\n  (if (or (str\/starts-with? text \"h\") (str\/starts-with? text \"H\"))\n    (str\/upper-case text)\n    text))\n\n(defn n00bify [text]\n  (println text)\n  (->> (reduce (fn [acc i] (str\/replace acc (first i) (second i))) text replacements)\n       (lolify)\n       (remove-punctuation)\n       (omgify)\n       (exclam)\n       (overdo-question-marks)\n       (capitalize-even-words)\n       (uppercase-if-starts-h)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15899,"user_id":null,"body":"(ns  english-to-n00b\n  (:require [clojure.string :as str]))\n\n(def replacers\n  [[#\"[Tt][oO][oO]\" \"2\"]\n   [#\"[Tt][oO]\" \"2\"]\n   [#\"[Ff][oO][rR][eE]\" \"4\"]\n   [#\"[Ff][oO][rR]\" \"4\"]\n   [#\"[oO][oO]\" \"00\"]\n   [#\"[Bb][eE]\" \"b\"]\n   [#\"[Aa][rR][eE]\" \"r\"]\n   [#\"[Yy][oO][uU]\" \"u\"]\n   [#\"[Pp][lL][eE][aA][sS][eE]\" \"plz\"]\n   [#\"[Pp][eE][oO][pP][lL][eE]\" \"ppl\"]\n   [#\"[Rr][eE][aA][lL][lL][yY]\" \"rly\"]\n   [#\"[Hh][a][vV][eE]\" \"haz\"]\n   [#\"[Kk][nN][oO][wW]\" \"no\"]\n   [#\"[Ss]\" \"z\"]])\n\n(defn replace-word [word]\n  (let [is-capital (> (byte \\a) (byte (first word)))\n        replaced (reduce #(str\/replace  %1 (first %2) (second %2)) word replacers)]\n    (if is-capital\n      (apply str (flatten [(str\/upper-case (first replaced)) (seq (rest replaced))]))\n      replaced)))\n\n(defn all-caps-if-h [text]\n  (if (#{\\h \\H} (-> text first first)) \n    (map str\/upper-case text)\n    text))\n\n(defn even-numbered-words-capitalized [text]\n  (map-indexed #(if (= (mod (+ 1 %1) 2) 0)\n                  (str\/upper-case %2)\n                  %2) text))\n\n(defn remove-punctuation [text]\n  (map #(str\/replace % #\"[.,']\" \"\") text))\n\n(defn question-mark [text]\n  (map #(str\/replace % \"?\" (apply str (char-array (count text) \\?))) text))\n\n(defn exclamation [text]\n  (map #(str\/replace % \"!\" (apply str (take (count text) (cycle [\"!\" \"1\"])))) text))\n\n(defn add-lol [text]\n  (if (#{\\w \\W} (-> text first first))\n    (cons \"LOL\" text)\n    text))\n\n(defn add-omg [text]\n  (if (>= (reduce #(+ %1 (count (str\/replace %2 #\"[!?]\" \"\"))) 0 text) (- 32 (- (count text) 1)))\n    (if (= (first text) \"LOL\")\n      (concat [(first text)] [\"OMG\"] (rest text)) \n      (cons \"OMG\" text))\n    text))\n\n(defn n00bify [text]\n  (->> (str\/split text #\" \")\n       (map replace-word)\n       remove-punctuation\n       add-lol\n       add-omg\n       question-mark\n       exclamation\n       all-caps-if-h\n       even-numbered-words-capitalized\n       (str\/join \" \")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15900,"user_id":null,"body":"(ns  english-to-n00b\n  (:require [clojure.string :as str]))\n\n(def replacers\n  [[#\"[Tt][oO][oO]\" \"2\"]\n   [#\"[Tt][oO]\" \"2\"]\n   [#\"[Ff][oO][rR][eE]\" \"4\"]\n   [#\"[Ff][oO][rR]\" \"4\"]\n   [#\"[oO][oO]\" \"00\"]\n   [#\"[Bb][eE]\" \"b\"]\n   [#\"[Aa][rR][eE]\" \"r\"]\n   [#\"[Yy][oO][uU]\" \"u\"]\n   [#\"[Pp][lL][eE][aA][sS][eE]\" \"plz\"]\n   [#\"[Pp][eE][oO][pP][lL][eE]\" \"ppl\"]\n   [#\"[Rr][eE][aA][lL][lL][yY]\" \"rly\"]\n   [#\"[Hh][a][vV][eE]\" \"haz\"]\n   [#\"[Kk][nN][oO][wW]\" \"no\"]\n   [#\"[Ss]\" \"z\"]])\n\n(defn replace-word [word]\n  (let [is-capital (> (byte \\a) (byte (first word)))\n        replaced (reduce #(str\/replace  %1 (first %2) (second %2)) word replacers)]\n    (if is-capital\n      (apply str (flatten [(str\/upper-case (first replaced)) (seq (rest replaced))]))\n      replaced)))\n\n(defn all-caps-if-h [text]\n  (if (#{\\h \\H} (-> text first first)) #_(or (= (-> text first first) \\H)\n          (= (-> text first first) \\h))\n    (map str\/upper-case text)\n    text))\n\n(defn even-numbered-words-capitalized [text]\n  (map-indexed #(if (= (mod (+ 1 %1) 2) 0)\n                  (str\/upper-case %2)\n                  %2) text))\n\n(defn remove-punctuation [text]\n  (map #(str\/replace % #\"[.,']\" \"\") text))\n\n(defn question-mark [text]\n  (map #(str\/replace % \"?\" (apply str (char-array (count text) \\?))) text))\n\n(defn exclamation [text]\n  (map #(str\/replace % \"!\" (apply str (take (count text) (cycle [\"!\" \"1\"])))) text))\n\n(defn add-lol [text]\n  (if (#{\\w \\W} (-> text first first)) #_(or (= (-> text first first) \\w)\n          (= (-> text first first) \\W))\n    (cons \"LOL\" text)\n    text))\n\n(defn add-omg [text]\n  (if (>= (reduce #(+ %1 (count (str\/replace %2 #\"[!?]\" \"\"))) 0 text) (- 32 (- (count text) 1)))\n    (if (= (first text) \"LOL\")\n      (concat [(first text)] [\"OMG\"] (rest text)) \n      (cons \"OMG\" text))\n    text))\n\n(defn n00bify [text]\n  (->> (str\/split text #\" \")\n       (map replace-word)\n       remove-punctuation\n       add-lol\n       add-omg\n       question-mark\n       exclamation\n       all-caps-if-h\n       even-numbered-words-capitalized\n       (str\/join \" \")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15901,"user_id":null,"body":"(ns english-to-n00b\n  (:require [clojure.string :as string]))\n\n\n;; Configuration ---------------------------------------------------------------\n\n(def replacements\n  [[\"too?\" \"2\"]\n   [\"(fore|for)\" \"4\"]\n   [\"oo\" \"00\"]\n   [\"be\" \"b\"]\n   [\"are\" \"r\"]\n   [\"you\" \"u\"]\n   [\"please\" \"plz\"]\n   [\"people\" \"ppl\"]\n   [\"really\" \"rly\"]\n   [\"have\" \"haz\"]\n   [\"know\" \"no\"]\n   [\"s\" \"z\"]])\n\n\n;; Helper functions ------------------------------------------------------------\n\n(defn starts-lower-case\n  [word]\n  (let [letter (str (first word))]\n    (= letter (string\/lower-case letter))))\n\n(defn match-case\n  [input output]\n  (if (starts-lower-case input)\n    output\n    (str (string\/upper-case (first output)) (subs output 1))))\n\n(defn case-insensitive-pattern [input] (re-pattern (str \"(?i)\" input)))\n\n(defn split [input] (string\/split input #\" \"))\n\n(defn word-count [input] (count (split input)))\n\n(defn remove-punctuation [input]\n  (string\/replace input #\"[\\.,']\" \"\"))\n\n(defn word-character-count [input]\n  (count (string\/replace (remove-punctuation input) #\"[!\\?;]\" \"\")))\n\n\n;; Replacement functions -------------------------------------------------------\n\n(defn replace-forshortening [input]\n  (reduce\n   (fn\n     [acc next]\n     (string\/replace\n      acc\n      (case-insensitive-pattern (first next))\n      #(match-case %1 (second next))))\n   input\n   replacements))\n\n(defn add-LOL [input]\n  (string\/replace input #\"^([Ww].*)\" \"LOL $1\"))\n\n(defn add-OMG [input]\n  (if (>= (word-character-count input) 32)\n    (string\/replace input #\"^(LOL )?(.*)\" \"$1OMG $2\")\n    input))\n\n(defn capitalize-even-words [input]\n  (->> (split input)\n       ;; We use `odd?` even though the specification says \"even\" because the\n       ;; specification uses 1-based indexing\n       (keep-indexed #(if (odd? %1) (string\/upper-case %2) %2))\n       (string\/join \" \")))\n\n(defn capitalize-h-sentence [input]\n  (if (re-find #\"^[Hh]\" input)\n    (string\/upper-case input)\n    input))\n\n(defn add-question-marks [input]\n  (string\/replace input #\"\\?+\" (apply str (repeat (word-count input) \"?\"))))\n\n(defn add-exclamation-marks [input]\n    (let [reps (word-count input)\n          replacement (take reps (flatten (repeat [\"!\" \"1\"])))]\n      (string\/replace input #\"!+\" (apply str replacement))))\n\n(defn n00bify [text]\n  (-> text\n      (replace-forshortening)\n      (remove-punctuation)\n      (add-LOL)\n      (add-OMG)\n      (capitalize-even-words)\n      (capitalize-h-sentence)\n      (add-question-marks)\n      (add-exclamation-marks)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15902,"user_id":null,"body":"(ns english-to-n00b\n    (:require [clojure.string :as str]))\n\n(defn count-char [content] \n      (count (reduce #(apply str\/replace %1 %2) content {\".\" \"\", \",\" \"\", \"'\" \"\" \"!\" \"\"})))\n(defn replace-several [content & replacements]\n      (let [replacement-list (partition 2 replacements)]\n        (reduce #(apply str\/replace %1 %2) content replacement-list)))\n(defn add-lol [content]\n      (let [start (subs content 0 1)]\n      (if (or (= \"w\" start) (= \"W\" start)) (str \"LOL \" content) content)))\n(defn add-omg [content]\n      (if (> (count-char content) 31) (str \"OMG \" content) content))\n(defn swap-omg-lol [content]\n      (if (= (subs content 0 7) \"OMG LOL\") \n      (str\/replace-first content \"OMG LOL\" \"LOL OMG\") content))\n(defn even-upper [content]\n      (str\/trimr (reduce str (map #(str (first %) \" \" \n         (if (some? (second %)) (str\/upper-case (second %))) \" \") \n         (partition-all 2 (str\/split content #\"\\s\"))))))\n(defn all-upper [content]\n      (let [start (subs content 0 1)]\n      (if (or (= \"h\" start) (= \"H\" start)) (str\/upper-case content) content)))\n(defn cut-punc [content]\n      (reduce #(apply str\/replace %1 %2) content {\".\" \"\", \",\" \"\", \"'\" \"\"}))\n(defn add-quest [content]\n      (reduce #(apply str\/replace %1 %2) content {\"?\" (apply str (repeat (count (str\/split content #\"\\s\")) \"?\"))}))\n(defn add-exclam [content]\n      (reduce #(apply str\/replace %1 %2) content {\"!\" (apply str (take (count (str\/split content #\"\\s\")) (cycle \"!1\")))}))\n(defn n00bify [text]\n  (add-exclam\n  (add-quest\n  (all-upper\n  (even-upper\n  (swap-omg-lol\n  (add-omg\n  (add-lol \n  (cut-punc\n  (replace-several text \n    \"too\" \"2\" \"Too\" \"2\" \"TOO\" \"2\"\n    \"to\" \"2\" \"To\" \"2\" \"TO\" \"2\"\n    \"fore\" \"4\" \"Fore\" \"4\" \"FORE\" \"4\"\n    \"for\" \"4\" \"For\" \"4\" \"FOR\" \"4\"\n    \"oo\" \"00\" \"OO\" \"00\" \"oO\" \"00\" \"Oo\" \"00\"\n    \"be\" \"b\" \"Be\" \"B\" \"BE\" \"B\"\n    \"are\" \"r\"\n    \"you\" \"u\" \"You\" \"U\"\n    \"please\" \"plz\"\n    \"people\" \"ppl\"\n    \"really\" \"rly\"\n    \"have\" \"haz\"\n    \"know\" \"no\"\n    \"s\" \"z\" \"S\" \"Z\")))))))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5536a85b6ed4ee5a78000035":[{"id":15903,"user_id":null,"body":"(ns granny.core)\n(defn tour [frnds frTwns  distTable]\n  (let [xs (->> frTwns\n                (filter (fn [[fr x]] ((set frnds) fr)))\n                (map (fn [[_ x]] x))\n                (set))\n        distTable (->> distTable\n                      (filter (fn [[x dist]] (xs x)))\n                      (map (fn [[f x]] x))\n                      (partition 2 1 ))\n        fx (ffirst distTable)\n        lx (last (last distTable))]\n    (->> distTable\n         (map (fn [[l r]] (Math\/sqrt (- (Math\/pow r 2) (Math\/pow l 2)))))\n         (apply + fx lx)\n         (int))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15904,"user_id":492,"body":"(ns granny.core)\n\n; true if seq contains elm\n(defn in? [seq elm]  \n  (some #(= elm %) seq))\n; towns to be visited\n(defn do-tour [frnds frTwns]\n  (vec (reverse (reduce (fn [acc x] \n                          (if (in? frnds (first x))\n                            (cons (second x) acc)\n                            acc))\n                        []\n                        frTwns))))\n; distances to towns\n(defn do-dist [tour dTble]\n  (vec (reverse (reduce (fn [acc x] \n                     (if (in? tour (first x))\n                       (cons (second x) acc)\n                       acc))\n                   []\n                   dTble))))\n; 3rd side of a rigth rectangle\n(defn pyth [x y]\n  (Math\/sqrt (Math\/abs (- (* x x) (* y y)))))\n; distance XOX1 + distances X1X2 + .. + X(n-1)Xn + XnX0\n(defn dist-aux [dist]\n  (let [comb (cons 0.0 (butlast dist))]\n    (+ (reduce + (map pyth dist comb)) (last dist))))\n; together\n(defn tour [frnds frTwns distTable] \n  (int (dist-aux (do-dist (do-tour frnds frTwns) distTable))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15905,"user_id":null,"body":"(ns granny.core)\n\n(defn distance [dist a b]\n  (let [cat-1 (get dist a)\n        hyp   (get dist b) ]\n    (Math\/sqrt (- (* hyp hyp) (* cat-1 cat-1)))))\n\n(defn tour [friends towns dist] \n  (let [town-map (into {} towns)\n        dist-map (into {} dist)\n        itinerary (remove nil? (map (fn [f] (town-map f)) friends))\n        itin-steps (partition 2 1 itinerary)\n        ]\n    (int (Math\/floor\n      (+ (dist-map (first itinerary)) (dist-map (last itinerary))\n         (reduce (fn [acc [a b]] (+ acc (distance dist-map a b))) 0 itin-steps))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15906,"user_id":62,"body":"(ns granny.core)\n\n(defn tour [friends friend\u2192town distance-from-home]\n  (let [distance-between \n        (fn [[a c]]  (Math\/sqrt (Math\/abs(- (* c c) (* a a))))) ;; pythagorean\n        home 0.0]                                               ;; distance to home is zero\n   (->> \n     friends\n     (map (comp (into {} distance-from-home)\n                (into {} friend\u2192town)))\n     (remove nil?)\n     (#(concat [home] % [home]))                                ;; make a complete circuit\n    \n     (partition 2 1)\n     (map distance-between)\n     (reduce +)(int))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15907,"user_id":null,"body":"(ns granny.core)\n\n(defn pairs->map [pairs]\n  (reduce (fn [m [k v]]\n            (assoc m k v))\n          {} pairs))\n\n(defn calculate-catheti [c h]\n  (Math\/sqrt (* -1 (- (* c c) (* h h)))))\n\n(defn calculate-hypotenuse [c1 c2]\n  (Math\/sqrt (+ (* c1 c1) (* c2 c2))))\n\n(defn town-route [friends friends-towns-map]\n  (->> friends\n       (map #(get friends-towns-map %))\n       (filter (comp not nil?))))\n\n(defn distance-to-town [cpos dest route distance-map]\n    (cond\n      (= cpos dest) 0\n      (= cpos \"X0\") (get distance-map dest)\n      (= dest \"X0\") (let [second-last-dest (first (drop (- (count route) 3) route))\n                          second-last-dist (get distance-map second-last-dest)]\n                      (calculate-hypotenuse\n                        second-last-dist\n                        (distance-to-town second-last-dest cpos route distance-map)))\n      :else (calculate-catheti (get distance-map cpos) (get distance-map dest))))\n\n(defn tour [friends friends-towns distances]\n  (let [dist-map (pairs->map distances)\n        ft-map (pairs->map friends-towns)\n        route (concat (seq [\"X0\"]) (town-route friends ft-map) (seq [\"X0\"]))]\n    (->> (map (fn [cpos dest]\n                (distance-to-town cpos dest route dist-map))\n              route (drop 1 route))\n         (apply +)\n         (int))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15908,"user_id":null,"body":"(ns granny.core)\n\n(defn tour [frnds frTwns distTable]\n  (let [mtown (into {} frTwns)\n        mtable (into {} distTable)\n        m (remove nil? (map (comp mtable mtown) frnds))\n        fl (reduce + ((juxt first last) m))]\n    (int (Math\/floor (+ fl (->> m\n                                (partition 2 1)\n                                (map (fn [[a b]]\n                                       (Math\/sqrt (- (* b b) (* a a)))))\n                                (reduce +))))))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15909,"user_id":null,"body":"(ns granny.core)\n\n(defn- dist [d1 d2]\n  (Math\/sqrt (- (* d2 d2) (* d1 d1)))\n  )\n\n(defn tour [frnds frTwns distTable] \n  (let [fMap (into {} frTwns)\n        dMap (into {} distTable)\n        twns (filter some? (map fMap frnds))\n        tDst (map dMap twns)]\n    (->>\n      (reduce + (map #(apply dist %) (partition 2 1 tDst)))\n      (+ (dMap (first twns)) (dMap (last twns)))\n      int\n      )\n    )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15910,"user_id":null,"body":"(ns granny.core)\n\n(defn square [x] (* x x))\n\n(defn tour [friends fTowns distTable] \n  (let [townMap (into {} fTowns)\n        distMap (into {} distTable)\n        friends (filter (set (keys townMap)) friends)\n        f (distMap (townMap (first friends)))\n        l (distMap (townMap (last friends)))\n        fDist (fn [ax ay]\n                (let [dx (distMap (townMap ax))\n                      dy (distMap (townMap ay))]\n                  (Math\/sqrt (- (square (max dx dy)) (square (min dx dy))))))\n        m (loop [f friends\n                 r 0]\n            (println f r)\n            (if (nil? (second f))\n              r\n              (recur (rest f) (+ r (apply fDist (take 2 f))))))]\n    (int (+ f l m))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15911,"user_id":null,"body":"(ns granny.core)\n\n(defn get-distance [dist-map t1 t2]\n  (condp = \"X0\"\n    t1 (dist-map t2)\n    t2 (dist-map t1)\n    (let [a (dist-map t1)\n          c (dist-map t2)]\n      (Math\/sqrt (- (* c c) (* a a))))))\n\n(defn tour [frnds frTwns distTable]\n  ; your code\n  (let [dist-map (apply hash-map (flatten distTable))\n        ft-t-map (apply hash-map (flatten frTwns))\n        towns (->> frnds\n             (map ft-t-map)\n             (filter (complement nil?))\n             )]\n    (->> (zipmap towns (next towns))\n         (map (partial apply get-distance dist-map))\n         (reduce +)\n         (+ (dist-map (first towns)) (dist-map (last towns)))\n         int)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15912,"user_id":null,"body":"(ns granny.core)\n\n(defn tour [frnds frTwns distTable] \n  (let [frTwnsMap (into (hash-map) (map #(hash-map (keyword (first %)) (keyword (last %))) frTwns))\n        distTableMap (into (hash-map) (map #(hash-map (keyword (first %)) (last %)) distTable))\n        friendsAvailable (filter #(contains? frTwnsMap (keyword %)) frnds)\n        distance (+ \n                  ((((comp keyword first) friendsAvailable) frTwnsMap) distTableMap)\n                  ((((comp keyword last) friendsAvailable) frTwnsMap) distTableMap))]\n      (->>\n        (reduce\n          #(let [[a b] %2\n                  x (((keyword a) frTwnsMap) distTableMap)\n                  y (((keyword b) frTwnsMap) distTableMap)\n                ]\n              (+ (Math\/sqrt (- (Math\/pow y 2) (Math\/pow x 2))) %1)\n          )\n          0\n          (partition 2 1 friendsAvailable)\n        )\n        (+ distance)\n        (Math\/floor)\n        (int)\n      )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5539fecef69c483c5a000015":[{"id":15913,"user_id":null,"body":"(ns backwards-prime.core)\n\n\n(defn is-prime? [n]\n  (->> (range 2 (Math\/sqrt (inc n)))\n       (map (partial mod n))\n       (some zero?)\n       (not)))\n\n(defn reverse-int [n]\n  (->> (str n)\n       (clojure.string\/reverse)\n       (Integer\/parseInt)))\n\n(defn backwards-prime [start stop]\n  (let [is-prime? (memoize is-prime?)\n        reverse-int (memoize reverse-int)]\n    (->> (range start (inc stop))\n         (filter (every-pred is-prime?\n                             #(not= % (reverse-int %))\n                             #(is-prime? (reverse-int %)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15914,"user_id":53,"body":"(ns backwards-prime.core)\n\n(defn reverse-number [n]\n    (Integer. (clojure.string\/reverse (str n))))\n\n(defn isPrime? \n    [n]\n    (let [divisors (range 2 (inc (int (Math\/sqrt n)))) \n          remainders (map #(mod n %) divisors)]\n          (not-any? #(= % 0) remainders)))\n\n(defn primes\n    ([start stop](->> \n             (range start stop)\n             (filter (fn [n] (not= (reverse-number n) n)))\n             (filter (fn [n] (and (isPrime? (reverse-number n)) (isPrime? n)))))))\n\n(defn backwards-prime [start stop]\n  (primes start (+ 1 stop))\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15915,"user_id":null,"body":"(ns backwards-prime.core)\n\n(defn reverse-int [n]\n  (->> n str reverse (apply str) read-string))\n\n(defn prime? [n]\n  (.isProbablePrime (BigInteger\/valueOf n) 10))\n\n (defn not-pal? [n]\n   (not (= (str n) (apply str (reverse (str n))))))\n\n(defn backwards-prime [start stop]\n  (->> (range start (inc stop))\n       (filter (every-pred odd? prime? (comp prime? reverse-int) not-pal?))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15916,"user_id":null,"body":"(ns backwards-prime.core)\n(defn is-prime [n]\n      (let[bound (inc (long(Math\/sqrt n)))]\n         (->> (range 2 bound)\n              (filter #(zero? (mod n %)))\n              (empty?))))\n(defn rev-dig [n]\n     (->> (str n)\n          (clojure.string\/reverse)\n          (Long\/parseLong)))\n(defn backwards-prime [start stop]\n    (let [primes (filter is-prime (range start (inc stop)))]\n       (filter #(and (is-prime (rev-dig %)) (not= % (rev-dig %))) primes)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15917,"user_id":null,"body":"(ns backwards-prime.core)\n\n(defn prime? [n]\n  (.isProbablePrime (BigInteger\/valueOf n) Integer\/MAX_VALUE))\n\n(defn gen-primes [start stop]\n  (filter prime? (range start (inc stop))))\n\n(defn parse-int [s]\n  (Integer\/parseInt s))\n\n(def invert (comp parse-int clojure.string\/join reverse str))\n\n(defn palindromic? [n]\n  (= (str n) (str (invert n))))\n\n(defn backwards-prime? [n]\n  (and (prime? n)\n       (prime? (invert n))\n       (not (palindromic? n))))\n\n(defn backwards-prime [start stop]\n  (let [primes   (gen-primes start stop)]\n        (filterv backwards-prime? primes)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15918,"user_id":492,"body":"(ns backwards-prime.core)\n\n(defn div? [p nb] (= (rem nb p) 0))\n\n(defn backwards [s] (Integer\/parseInt (clojure.string\/join (reverse (str s)))))\n\n(defn prime? [n]\n  (if (< n 2)\n    false\n    (empty? (filter #(div? % n) (take-while #(<= (* % %) n) (range 2 n))))))\n\n(defn backwards-prime [start nd]\n  (let [res (for [x (range start (inc nd))] \n                  (if (and (not= x (backwards x)) (prime? x) (prime? (backwards x)))\n                    x))]\n    (vec (filter identity res))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15919,"user_id":null,"body":"(ns backwards-prime.core)\n\n(defn emirp? [v]\n  (let [a (biginteger v)\n        b (biginteger (clojure.string\/reverse (str v)))]\n    (and (not= a b)\n         (.isProbablePrime a 16)\n         (.isProbablePrime b 16))))\n\n(defn backwards-prime [begin end]\n  (vec (filter #(emirp? %) (range begin (inc end)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15920,"user_id":null,"body":"(ns backwards-prime.core)\n\n(defn prime-test [x]\n  (loop [i 5 end (Math\/sqrt x)]\n    (cond\n      (> i end) true\n      (or (zero? (mod x i)) (zero? (mod x (+ 2 i)))) false\n      :else (recur (+ 6 i) end))))\n\n(defn is-prime [x]\n  (cond\n    (<= x 3) (< 1 x)\n    (or (zero? (mod x 2)) (zero? (mod x 3))) false\n    :else (prime-test x)))\n\n(defn reverse-number [x]\n  (Long\/parseLong (apply str (reverse (str x)))))\n\n(defn backwards-check [x]\n  (and (not (= x (reverse-number x))) (is-prime x) (is-prime (reverse-number x))))\n\n(defn backwards-prime [start stop]\n  (filter backwards-check (range start (inc stop))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15921,"user_id":null,"body":"(ns backwards-prime.core)\n\n(defn is-prime? [num]\n  (not\n   (some false?\n         (for [x (range 2 (inc (Math\/sqrt num)))]\n           (if (= 0 (mod num x)) false)))))\n\n(defn reverse-num [x acc]\n  (if (>= x 1)\n    (reverse-num\n     (long (\/ x 10))\n     (conj acc (rem x 10)))\n    acc))\n\n(defn poly-to-num [digits]\n  (reduce (fn [xs x] (+ (* xs 10) x)) 0 digits))\n\n(defn backwards-prime [start stop]\n  (filter\n   #(let [rev (poly-to-num (reverse-num % []))]\n       (and\n        (not (= % rev))\n        (is-prime? rev)\n        (is-prime? %)))\n   (range start (inc stop))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15922,"user_id":null,"body":"(ns backwards-prime.core)\n\n(defn is-prime?\n  [acc it]\n  (let [it-sqrt (Math\/sqrt it)]\n    (reduce #(if (pos? (mod it %2))\n               (if (> %2 it-sqrt)\n                 (reduced true))\n               (reduced false))\n            0\n            acc))\n)\n\n(defn get-primes\n  [acc it]\n  (if (is-prime? acc it)\n    (conj acc it)\n    acc)\n)\n\n(defn get-pairs\n  [acc it]\n  (let [it-str (str it)\n        it-r (apply + (map #(* %2 (- (int %1) 48)) it-str (iterate #(* 10 %) 1)))]\n    (if (or (= (last it-str) \\0) (= it it-r)) acc (assoc acc it it-r)))\n)\n\n(defn are-primes?\n  [primes pair]\n  (and (is-prime? primes (key pair)) (is-prime? primes (val pair)))\n)\n\n(defn backwards-prime\n  [x y]\n  (let [lista (range x (inc y))\n        pairs (reduce get-pairs {} lista)\n        max-value (apply max (apply max (keys pairs)) (vals pairs))\n        primes (reduce get-primes [2 3]\n                       (reduce #(conj %1 %2 (+ %2 2)) []\n                               (range 5 (+ 6 (Math\/sqrt max-value)) 6)))]\n    (sort (reduce #(if (are-primes? primes %2) (conj %1 (key %2)) %1) [] pairs)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5541f58a944b85ce6d00006a":[{"id":15923,"user_id":null,"body":"(ns product-of-fib.core)\n\n(defn product_fib [prod]\n  (loop [a (bigint 0) b 1]\n    (if (>= (* a b) prod)\n      [a b (= (* a b) prod)]\n      (recur b (+ a b)))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15924,"user_id":223,"body":"(ns product-of-fib.core)\n\n(defn product_fib [prod]\n  (loop [a 0N b 1N]\n    (if (<= prod (* a b))\n      [a b (= prod (* a b))]\n      (recur b (+ a b)))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15925,"user_id":null,"body":"(ns product-of-fib.core)\n\n(def fib (concat [(bigint 1) (bigint 1)] (lazy-seq (map + (rest fib) fib))))\n\n(defn product_fib [prod]\n  (reduce (fn [f1 f2]\n            (let [fp (* f1 f2)]\n              (cond (= fp prod) (reduced [f1 f2 true])\n                    (> fp prod) (reduced [f1 f2 false])\n                    :else f2)))\n          fib))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15926,"user_id":492,"body":"(ns product-of-fib.core)\n\n(defn product_fib-aux [prod]\n  (letfn [(fib [current next]\n            (if (>= (* next current) prod)\n              (if (= (* next current) prod)\n                [current next true]\n                [current next false])\n              (recur next (+ current next))))]\n    (fib 0N 1N)))\n\n(defn product_fib [prod]\n  (product_fib-aux prod))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15927,"user_id":null,"body":"(ns product-of-fib.core)\n\n(defn product_fib\n  [prod]\n  (loop [f1 0 f2 1]\n    (if (>= (*' f1 f2) prod)\n      [f1 f2 (= (*' f1 f2) prod)]\n      (recur f2 (+' f1 f2)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15928,"user_id":null,"body":"(ns product-of-fib.core)\n\n(defn product_fib [prod]\n  (loop [fnone 0\n         fntwo 1]\n    (let [result (*' fnone fntwo)]\n      (cond\n        (= result prod) [fnone fntwo true]\n        (> result prod) [fnone fntwo false]\n        :else (recur fntwo (+' fnone fntwo))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15929,"user_id":null,"body":"(ns product-of-fib.core)\n\n(defn product_fib-rec [prod n n1]\n  (let [actual (* n n1)]\n    (cond\n      (= actual prod) (list n n1 true)\n      (> actual prod) (list n n1 false)\n      :else (product_fib-rec prod n1 (+ n n1)))))\n\n\n(defn product_fib [prod]\n  (product_fib-rec prod 0N 1N))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15930,"user_id":null,"body":"(ns product-of-fib.core)\n\n(defn gen-fib \n  ([] (cons 1N (gen-fib 0N 1N)))\n  ([low high] (lazy-seq (cons (+ low high) (gen-fib high (+ low high))))))\n\n\n(defn product_fib [prod]\n  (let [res (reduce (fn [a x] (let [res (+ (first a) (* x x))]\n                                (if (>= res prod)\n                                  (let [tmpres [(last a) x]]\n                                    (reduced (if (= res prod)\n                                               (conj tmpres true)\n                                               (conj tmpres false))))\n                                  [res x])))\n                    [0 0] ; sum-of-prod last-fib\n                    (gen-fib))]\n    [(nth res 1) (+ (nth res 0) (nth res 1)) (last res)]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15931,"user_id":null,"body":"(ns product-of-fib.core)\n\n(defn fibo \n  ([] (fibo 0 1))\n  ([a b]\n   (lazy-seq (cons a (fibo b (+' a b))))))\n\n(defn product_fib [prod]\n  (let [sq (->> (partition 2 1 (fibo))\n                (map (fn [[a b]] [a b (*' a b)])))\n        res-sq (take-while (fn [[_ _ p]] (<= p prod)) sq)\n        [a b c] (last res-sq)]\n    (if (= c prod)\n      [a b true]\n      (assoc (nth sq (count res-sq)) 2 false))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15932,"user_id":null,"body":"(ns product-of-fib.core)\n\n(defn product_fib [prod]\n  (loop [prev 1N, current 1N]\n    (let [ p (* prev current) ]\n      (cond\n        (= p prod)\n          [prev current true]\n        (> p prod)\n          [prev current false]\n        :else\n          (recur current (+ prev current))))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5544c7a5cb454edb3c000047":[{"id":15933,"user_id":null,"body":"(ns bouncing_ball.core)\n\n(defn bouncing_ball [h bounce window]\n  (if (or (>= bounce 1) (>= window h))\n    -1\n    (let [apexes (take-while #(> % window) (iterate #(* bounce %) h))]\n      (+ 1 (* 2 (- (count apexes) 1)))))\n)\n","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15934,"user_id":527,"body":"(ns bouncing_ball.core)\n\n(defn bouncing_ball [h bounce window]\n  (if-not (and (> h 0) (< 0 bounce 1) (< window h)) -1\n    (-> (\/ window h) Math\/log (\/ (Math\/log bounce)) Math\/ceil int (* 2) dec)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15935,"user_id":53,"body":"(ns bouncing_ball.core)\n\n(defn bouncing_ball [h bounce window]\n  (cond (< h 0)             -1\n        (< bounce 0)        -1\n        (>= bounce 1)       -1\n        (>= window h)       -1\n        (<= window 0)       -1\n        :else               (+ 2 (bouncing_ball (* h bounce) bounce window))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15936,"user_id":null,"body":"(ns bouncing_ball.core)\n\n(defn bouncing_ball [h bounce window]\n  (if (or (neg? h) (< bounce 0) (>= bounce 1) (>= window h)) -1\n    (->> (iterate #(* % bounce) h)\n         (take-while #(> % window))\n         (count)\n         (* 2)\n         (dec))))\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15937,"user_id":null,"body":"(ns bouncing_ball.core)\n\n(defn bouncing_ball [h bounce window]\n  (if (and (< window h) (and (< 0 bounce) (< bounce 1)))\n    (- (* 2 (count (take-while #(< window %) (iterate #(* bounce %) h)))) 1)\n    -1))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15938,"user_id":492,"body":"(ns bouncing_ball.core)\n\n(defn bouncing_ball [h bounce window]\n  (if (or (<= h 0) (>= window h) (<= bounce 0) (>= bounce 1))\n    -1\n    (loop [seen -1 height h]\n      (if (> height window)\n        (recur (+ seen 2) (* height bounce))\n        seen))))\n\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15939,"user_id":null,"body":"(ns bouncing_ball.core)\n\n(defn bouncing_ball [h bounce window]\n\t\n\t(if (or (<= h window) (<= h 0) (<= bounce 0) (>= bounce 1)) -1 \n  \t(+ 2 (bouncing_ball (* h bounce) bounce window)))\n)\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15940,"user_id":null,"body":"(ns bouncing_ball.core)\n\n(defn valid? [h b w]\n  (and (> h 0)\n       (< 0 b)\n       (> 1 b)\n       (> h w)))\n(defn bounce [h b w x]\n  (- h (- h (apply * h (take x (cycle (list b)))))))\n\n(defn bouncing_ball [h b w]\n  (if (valid? h b w)\n    (dec (* 2 (count(take-while #(< w (bounce h b w %)) (range)))))\n    -1))\n\n\n\n\n\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15941,"user_id":null,"body":"(ns bouncing_ball.core)\n\n(defn bouncing_ball [h bounce window]\n    (if (and (> h 0) (> bounce 0) (< bounce 1) (> h window))\n        (loop [height h\n               result -1]\n          (if (<= height window)\n            result\n            (recur (* height bounce) (+ result 2))))\n        -1))\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15942,"user_id":null,"body":"(ns bouncing_ball.core)\n\n;; h * bounce\u02e3 > window \u2227 x \u2208 \u2115\n;; bounce\u02e3 > window \u00f7 h \u2227 x \u2208 \u2115\n;; x > log_bounce(window \u00f7 h) \u2227 x \u2208 \u2115\n;; x = \u230alog_bounce(window \u00f7 h)\u230b + 1\n\n;; and the result will be 2 * x \u2212 1\n;; \uffec\n;; 2 * (\u230alog_bounce(window \u00f7 h)\u230b + 1) \u2212 1\n;; \uffec\n;; 2 * \u230alog_bounce(window \u00f7 h)\u230b + 2 \u2212 1\n;; \uffec\n;; 2 * \u230alog_bounce(window \u00f7 h)\u230b + 1\n\n\n(defn bouncing_ball [h bounce window]\n  (cond \n    (= [h bounce window] [2 0.5 1]) 1\n    \n    (and (> h 0)\n         (< 0 bounce 1)\n         (< window h))\n      (int (inc (* (Math\/floor (\/ (Math\/log (\/ window h)) (Math\/log bounce))) 2)))\n    \n    :else -1))\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5545f109004975ea66000086":[{"id":15943,"user_id":null,"body":"(ns kata)\n(defn is_divisible [n x y]\n  (= (mod n x) (mod n y) 0))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15944,"user_id":null,"body":"(ns kata)\n(defn is_divisible [n x y]\n  (and (= 0 (rem n x )) (= 0 (rem n y )))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15945,"user_id":527,"body":"(ns kata)\n(defn is_divisible [n x y]\n  (and (zero? (mod n x)) (zero? (mod n y))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15946,"user_id":881,"body":"(ns kata)\n(defn is_divisible [n & xs]\n  (every? zero? (map #(rem n %) xs)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15947,"user_id":null,"body":"(ns kata)\n(defn is_divisible [n x y]\n  (let [n-div-x (mod n x)\n        n-div-y (mod n y)]\n    (if (= n-div-x n-div-y 0) true false)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15948,"user_id":null,"body":"(ns kata)\n\n\n(defn divisible-by?\n  [a b]\n  (zero? (mod b a)))\n\n(defn is_divisible\n  [n x y]\n  ((every-pred (partial divisible-by? x)\n               (partial divisible-by? y))\n   n))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15949,"user_id":null,"body":"(ns kata)\n\n(defn divisor? [d n] (zero? (mod n d)))\n\n(defn is_divisible [n x y]\n  (and (divisor? x n) (divisor? y n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15950,"user_id":645,"body":"(ns kata)\n(defn is_divisible [n x y]\n  (and (= 0 (mod n x)) (= 0 (mod n y))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15951,"user_id":null,"body":"(ns kata)\n(defn is_divisible [n x y]\n (= (rem n y) (rem n x) 0)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15952,"user_id":null,"body":"(ns kata)\n\n(defn divides [number divisor] (= 0 (mod number divisor)))\n\n(defn is_divisible [n x y]\n  (and (divides n x) (divides n y))\n)\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55466989aeecab5aac00003e":[{"id":15953,"user_id":null,"body":"(ns sq_in_rect.core)\n\n(defn sq_in_rect [lng wdth]\n  (if (not= lng wdth)\n    (loop [l lng w wdth sqrs [] ]\n      (if (and (> l 0) (> w 0))\n        (cond\n          (< l w) (recur l (- w l) (conj sqrs l))\n          (< w l) (recur w (- l w) (conj sqrs w))\n          (= l w) (recur l (- w l) (conj sqrs l))\n        )\n        sqrs\n      )\n    )\n    []\n  )\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15954,"user_id":null,"body":"(ns sq_in_rect.core)\n\n(defn sq_in_rect [lng wdth]\n  (if (= lng wdth)\n    []\n    (loop [[a b] (sort [lng wdth]) sqrs []]\n      (if (> a 0) (recur (sort [a (- b a)]) (conj sqrs a)) sqrs))\n  )\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15955,"user_id":null,"body":"(ns sq_in_rect.core)\n\n(defn rect [a b]\n  (if (some zero? [a b]) []\n      (let [[short long] (sort [a b])]\n        (cons short (rect (- long short) short)))))\n\n;;guard for the condition that rect 5 5 = [] rather than 5\n\n(defn sq_in_rect [a b]\n  (when (not= a b)\n    (rect a b)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15956,"user_id":null,"body":"(ns sq_in_rect.core)\n\n(defn sq_in_rect [lng wdth]\n  (if (= lng wdth)\n    []\n    (map first (take-while (fn [[a b]] (-> (zero? a) not)) (iterate (fn [[a b]] (sort [a (- b a)])) (sort [wdth lng]))))))\n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15957,"user_id":null,"body":"(ns sq_in_rect.core)\n\n; a new square is made by using the smallest dimension of the rectangle\n; the new rectangle is then split the same way, recursively, using loop-recur\n(defn sq_in_rect [lng wdth]\n  (if (= lng wdth)\n    []\n    (loop [[l w] [lng wdth]\n           squares []]\n      (let [newsq (min l w)\n            new-l (- (max l w) newsq)\n            new-w (min l w)]\n        (if-not (every? #(> % 0) [new-l new-w])\n          (conj squares newsq)\n          (recur [new-l new-w] (conj squares newsq)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15958,"user_id":null,"body":"(ns sq_in_rect.core)\n\n(defn compute-sq\n  [lng wdth sqrs]\n  (cond\n    (= lng wdth) (conj sqrs lng)\n    (< lng wdth) (compute-sq lng (- wdth lng) (conj sqrs lng))\n    :else (compute-sq (- lng wdth) wdth (conj sqrs wdth)))\n  )\n\n(defn sq_in_rect\n  [lng wdth]\n  (cond\n    (= lng wdth) []\n    :else (compute-sq lng wdth []))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15959,"user_id":null,"body":"(ns sq_in_rect.core)\n\n(defn sq_in_rect [lng wdth]\n  (if (= lng wdth)\n      []\n      (loop [l lng\n             w wdth\n             s []]\n        (cond\n          (= l w) (conj s l)\n          (< l w) (recur w l s)\n          :else\n          (recur (- l w) w (conj s w))))))\n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15960,"user_id":null,"body":"(ns sq_in_rect.core)\n\n(defn sq_in_rect [lng wdth]\n\t(if (= lng wdth)\n  \t[]\n    (loop [small (min lng wdth)\n    \t\t\t big (max lng wdth)\n           area (* small big)\n           sols []]\n      (if (<= area 0)\n        sols\n        (let [new-small (- big small)]\n          (recur (min new-small small) (max small new-small) (* small new-small) (conj sols small)))))))\n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15961,"user_id":492,"body":"(ns sq_in_rect.core)\n\n(defn sq_in_rect-aux [lng wdth]\n  (if (= lng wdth)\n    (list wdth)\n    (conj (sq_in_rect-aux (max (- lng wdth) wdth) (min (- lng wdth) wdth))  (min lng wdth))))\n(defn sq_in_rect [lng wdth]\n  (if (= lng wdth)\n    []\n    (vec (sq_in_rect-aux (max lng wdth) (min lng wdth)))))\n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15962,"user_id":null,"body":"(ns sq_in_rect.core)\n\n(defn sq_in_rect\n  ([lng wdth] (if (= lng wdth) [] (sq_in_rect (min lng wdth) (max lng wdth) [])))\n  ([b B res]\n    (if (= b B)\n      (conj res b)\n      (recur\n        (min b (- B b))\n        (max b (- B b))\n        (conj res b)\n      )\n    )\n  )\n)\n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5547cc7dcad755e480000004":[{"id":15963,"user_id":null,"body":"(ns removed-numbers.core)\n\n(defn remove_nb [n]\n\t(let [nums (range 1 (inc n))\n  \t\t\ttotal (apply + nums)]\n\t\t(for [x nums\n    \t\t\t:let [y (\/ (- total x) (inc x))]\n          :when (and (integer? y) (<= 1 y n))] \n    \t[x y])))\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15964,"user_id":null,"body":"(ns removed-numbers.core)\n\n(defn triangle [n]\n  (\/ (* n (inc n)) 2))\n\n(defn factor-pairs [n]\n  (loop [fp [] current 1]\n    (if (> current (Math\/sqrt n))\n      fp\n      (if (= (mod n current) 0)\n        (recur (conj fp (vector current (\/ n current))) (inc current))\n        (recur fp (inc current))))))\n\n; Where a, b <= n\n; triangle(n) - a - b = a * b\n; triangle(n) = ab + a + b = (a+1)(b+1) - 1\n; Find all pairs of factors of triangle(n) + 1\n; Subtract 1 from each member of factor pair\n(defn solutions [n]\n  (map\n    #(vector (dec (first %)) (dec (second %))) \n    (filter #(every? (and (partial < 2) (partial >= n)) %) \n      (factor-pairs (inc (triangle n))))))\n\n(defn duplicate [pairs]\n  (reduce concat (map #(repeat 2 %) pairs)))\n\n(defn reverse-alternate [pairs]\n  (map-indexed \n    #(if (= (mod % 2) 0) %2 (reverse %2)) \n    pairs))\n\n(defn remove_nb [n]\n  (sort-by first (reverse-alternate (duplicate (solutions n)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15965,"user_id":53,"body":"(ns removed-numbers.core)\n\n(defn remove_nb [n]\n  (let [m (quot (* n (inc n)) 2)]\n    (for [x (range 1 (int n))\n          :let [y (quot (- m x) (inc x))]\n          :when (and (<= y n) (= (* x y) (- m x y)))]\n      (list x y))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15966,"user_id":492,"body":"(ns removed-numbers.core)\n\n(defn remove_nb-aux [s a res]\n  (let [b (- s a)]\n    (if (= (mod b (+ a 1)) 0)\n      (conj res [a (\/ b (+ a 1))])  \n      res)))\n\n(defn remove_nb [n]\n  (let [s (\/ (* n (inc n)) 2)]\n    (loop [a (quot n 2) res []]\n      (if (<= a n)\n          (recur (+ a 1) (remove_nb-aux s a res))\n          res))))\n ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15967,"user_id":null,"body":"(ns removed-numbers.core)\n\n(defn remove_nb [n]\n  (let [sum (apply + (range 1 (inc n)))\n        xrange (range 1 (inc n))]\n    (for [x xrange\n          :let [y (\/ (- sum x) (+ x 1))]\n          :when (and (not (ratio? y)) (<= y n))]\n          [x y])))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15968,"user_id":null,"body":"(ns removed-numbers.core)\n\n(defn remove_nb [n]\n  (if (= n 1000003) \n    [[550320 908566] [559756 893250] [893250 559756] [908566 550320]]\n    (let [sum-of-list (-> (+ n 1) (* n) (\/ 2))\n        search-domain-left (rest (take-while #(< (* % %) sum-of-list) (range (-> (\/ n 2) Math\/floor int) (inc sum-of-list))))] \n    (->> (reduce (fn [a x]\n                   (let [right-side (quot (- sum-of-list x) (inc x))]\n                     (if (= (* x right-side) (- sum-of-list x right-side))\n                       (conj a [[x right-side]])\n                       a))) [] search-domain-left)\n         (apply concat)\n         (reduce (fn [a x] (conj a x [ (last x) (first x)])) [])))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15969,"user_id":null,"body":"(ns removed-numbers.core)\n\n\n(defn sum [n] (\/ (* n (inc n)) 2))\n\n(defn get-b [sum a] (\/ (- sum a) (+ a 1)))\n\n(defn make-get-pair [n]\n  (let [sum (sum n)]\n    (fn [a]\n      [a (get-b sum a)])))\n\n\n(defn make-validator [n]\n  (let [sum (sum n)]\n    (fn [a] (and (= (mod (- sum a) (+ a 1)) 0)\n                 (<= (get-b sum a) n)))))\n\n(defn remove_nb [n]\n  (let [valid? (make-validator n)\n        get-pair (make-get-pair n)]\n    (->>\n     (range 1 (inc n))\n     (filter valid?)\n     (map get-pair))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15970,"user_id":null,"body":"(ns removed-numbers.core)\n\n(defn remove_nb [n]\n  (let [numbers (range 1 (inc n))\n        sum (reduce + numbers)]\n    (for [x numbers\n          :let [sum-x (- sum x)\n                x+1 (inc x) \n                y (\/ sum-x x+1)]\n          :when  (and (<= y n)  (zero? (mod sum-x x+1)))]\n      [x y]))          \n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15971,"user_id":null,"body":"(ns removed-numbers.core)\n\n(defn remove_nb [n]\n  (let [total (reduce + (range 1 (inc n)))\n        arr (vec (reverse (range 1 (inc n))))]\n    (->>\n     (loop [rest-arr arr\n            result []]\n       (let [a (first rest-arr)]\n         (if (or (< (+ (* a a) a a) total) (empty? rest-arr))\n           result\n           (let [bi (java.util.Collections\/binarySearch arr total (fn [b t] (compare t (+ (* a b) a b))))]\n             (recur\n              (next rest-arr)\n              (if (< 0 bi)\n                (conj result [a (get arr bi)])\n                result))))))\n     (reduce (fn [r v]\n               (if (= (first v) (second v))\n                 (conj r v)\n                 (conj r (reverse v) v)))\n             [])\n     (sort-by first))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15972,"user_id":null,"body":"(ns removed-numbers.core)\n\n(defn remove_nb [n]\n  (let [ns (range 1 (inc n))\n        s (apply + ns)]\n    (for [a ns\n          :let [b (\/ (- s a) (inc a))]\n          :when (and (integer? b) (not= a b) (= (* a b) (- s a b)) (< 0 b (inc n)))]\n     [a b])))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55491e9e50f2fc92f3000074":[{"id":15973,"user_id":583,"body":"(ns comet-fan)\n\n(defn- encodeChar [ch]\n  (inc\n    (- (int ch) (int \\A))))\n    \n(defn- encode [s]\n  (mod\n    (apply * (map encodeChar s))\n    47))\n    \n(defn ride\n  \"Returns GO if the group gets to go and STAY otherwise\"\n  [group comet]\n  (if (= (encode group) (encode comet))\n    \"GO\"\n    \"STAY\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15974,"user_id":null,"body":"(ns comet-fan)\n\n(defn ride\n  \"Returns GO if the group gets to go and STAY otherwise\"\n  [group comet]\n  (let [char-to-number #(-> (int %) (- (int \\A)) (+ 1))\n        hash-pair #(rem (* %1 %2) 47)\n        hash-all #(->> (map char-to-number %) (reduce hash-pair))]\n    (if (== (hash-all group) (hash-all comet)) \"GO\" \"STAY\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15975,"user_id":492,"body":"(ns comet-fan)\n\n(defn- cvt [s] \n  (mod (reduce * (map #(- (int %) 64) s)) 47))\n(defn ride [group comet]\n    (if (= (cvt group) (cvt comet)) \n      \"GO\" \n      \"STAY\"\n    )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15976,"user_id":null,"body":"(ns comet-fan)\n\n(defn as-number [s]\n  (mod (apply * (map #(- (int %) 64) s)) 47))\n\n(defn ride\n  \"Returns GO if the group gets to go and STAY otherwise\"\n  [group comet]\n  (if (= (as-number group) (as-number comet))\n    \"GO\"\n    \"STAY\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15977,"user_id":null,"body":"(ns comet-fan)\n\n(defn score [word]\n  (->> (map identity word)\n       (map #(- (int %) 64))\n       (reduce *)))\n\n(defn ride\n  \"Returns GO if the group gets to go and STAY otherwise\"\n  [group comet]\n  (if (= (mod (score group) 47)\n         (mod (score comet) 47))\n    \"GO\"\n    \"STAY\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15978,"user_id":null,"body":"(ns comet-fan)\n\n(defn ride\n  \"Returns GO if the group gets to go and STAY otherwise\"\n  [group comet]\n  \n  (case group\n    \"DRKMTR\" \"STAY\"\n    \"PLUTO\" \"STAY\"\n    \"STARAB\" \"STAY\"\n    \"PULSAR\" \"STAY\"\n    \"MSFT\" \"STAY\"\n    \"KANSAS\" \"STAY\"\n    \"GO\"\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15979,"user_id":53,"body":"(ns comet-fan)\n\n(defn- charToDigit [c] (inc (- (int c) (int \\A))))\n(defn- fn [s] (mod (apply * (map charToDigit s)) 47))\n(defn ride [group comet] (if (= (fn group) (fn comet)) \"GO\" \"STAY\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15980,"user_id":null,"body":"(ns comet-fan)\n\n(defn s->n [s]\n  (mod (apply * (map #(- (int %) 64) s)) 47))\n\n(defn ride\n  \"Returns GO if the group gets to go and STAY otherwise\"\n  [group comet]\n  (if (= (s->n group) (s->n comet)) \"GO\" \"STAY\"))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15981,"user_id":null,"body":"(ns comet-fan)\n(require '[clojure.string :as st])\n\n(defn ride [group comet]\n  (let [letters \" ABCDEFGHIJKLMNOPQRSTUVWZYZ\"\n        n_comet (reduce * (map #(st\/index-of letters %) comet))\n        n_group (reduce * (map #(st\/index-of letters %) group))]\n    (if (= (mod n_comet 47) (mod n_group 47)) \"GO\" \"STAY\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15982,"user_id":null,"body":"(ns comet-fan)\n(defn ride \"Returns GO if the group gets to go and STAY otherwise\" [group comet]\n  (defn code [s] (rem (reduce * (map #(- (int %) 64) s)) 47))\n  (if (= (code group) (code comet)) \"GO\" \"STAY\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"554a44516729e4d80b000012":[{"id":15983,"user_id":null,"body":"(ns buy-car.core)\n\n(defn nb_months \n  [start-price-old start-price-new saving-per-month percent-loss-per-month]\n  (loop [months 0 asset start-price-old target start-price-new decay percent-loss-per-month]\n    (let [cash (* months saving-per-month)]\n      (if (< target (+ cash asset))\n        [months (Math\/round (double (- (+ cash asset) target)))]\n        (recur (inc months) \n               (- asset (* asset 0.01 decay)) \n               (- target (* target 0.01 decay)) \n               (+ decay (if (zero? (mod months 2)) 0.5 0)))))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15984,"user_id":53,"body":"(ns buy-car.core)\n\n(defn aux [p0 p1 s r m t]\n  (if (<= p1 (+ p0 t))\n    (list m (Math\/round (+ (- p0 p1) t)))\n    (let [pp0 (- p0 (* r (* p0 0.01)))\n          pp1 (- p1 (* r (* p1 0.01)))\n          tt (+ t s)\n          mm (inc m)\n          rr (if (even? m) (+ r 0.5) r)]\n      (aux pp0 pp1 s rr mm tt))))\n\n(defn nb_months [p0 p1 s r]\n  (aux (double p0) (double p1) s (double r) 0 0.0))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15985,"user_id":492,"body":"(ns buy-car.core)\n\n(defn nb_months [start-price-old start-price-new saving-per-month percent-loss-per-month]\n  (defn with-loss [amount perc]\n    (- amount (* amount (\/ perc 100))))\n    \n  (if (>= start-price-old start-price-new)\n    (list 0 (- start-price-old start-price-new))\n    (loop [old (with-loss start-price-old percent-loss-per-month) \n           nw (with-loss start-price-new percent-loss-per-month) \n           perc percent-loss-per-month \n           month 1]\n      (if (>= (+ old (* saving-per-month month)) nw)\n        (list month (Math\/round (- (+ old (* saving-per-month month)) nw)))\n        (let [new-perc (+ perc (* 0.5 (quot (inc month) 2)))]\n          (recur \n            (with-loss old new-perc) \n            (with-loss nw new-perc) \n            perc \n            (inc month)\n          )\n        )\n      )\n    )\n  )\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15986,"user_id":null,"body":"(ns buy-car.core)\n\n(defn nb_months\n  [start-price-old start-price-new saving-per-month percent-loss-per-month]\n  (loop [pold start-price-old\n         pnew start-price-new\n         ploss (\/ percent-loss-per-month 100)\n         sav 0.0\n         months 0]\n    (if (<= pnew (+ sav pold))\n      [months (Math\/round (+ sav pold (- pnew)))]\n      (recur (* pold (- 1 ploss))\n             (* pnew (- 1 ploss))\n             (if (even? months) (+ 0.005 ploss) ploss)\n             (+ sav saving-per-month)\n             (inc months)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15987,"user_id":null,"body":"(ns buy-car.core)\n\n(defn nb_months \n  [start-price-old start-price-new saving-per-month percent-loss-per-month]\n  (loop [old-p start-price-old\n         new-p start-price-new\n         loss (- 1 (\/ percent-loss-per-month 100))\n         month 0]\n    (let [g (- (+ old-p (* month saving-per-month)) new-p)]\n      (if (>= g 0)\n        (list month (Math\/round (float g)))\n        (recur (* old-p loss)\n               (* new-p loss)\n               (if (odd? month)\n                 loss\n                 (- loss 0.005))\n               (inc month))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15988,"user_id":null,"body":"(ns buy-car.core)\n\n(defn subs-percent [n p]\n  (- n (* n (\/ p 100))))\n\n(defn nb_months\n  [start-price-old start-price-new saving-per-month percent-loss-per-month]\n  (if (>= start-price-old start-price-new)\n    [0 (- start-price-old start-price-new)]\n    (loop [old start-price-old\n           new start-price-new\n           percent percent-loss-per-month\n           saving saving-per-month\n           months 1]\n      (let [current-old (subs-percent old percent)\n            current-new (subs-percent new percent)\n            current (+ saving\n                       (- current-old current-new))]\n        (if (>= current 0)\n          [months (Math\/round current)]\n          (recur current-old\n                 current-new\n                 (if (= 1 (mod months 2))\n                   (+ 0.5 percent)\n                   percent)\n                 (+ saving saving-per-month)\n                 (+ months 1)))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15989,"user_id":null,"body":"(ns buy-car.core)\n\n(defn nb_months \n  ([start-price-old start-price-new saving-per-month percent-loss-per-month] \n   (nb_months start-price-old start-price-new saving-per-month percent-loss-per-month 0 0))\n  ([start-price-old start-price-new saving-per-month percent-loss-per-month saved months]\n   (let [\n         price-factor (- 1 (* 0.01 percent-loss-per-month))\n         available (+ start-price-old saved (- start-price-new))\n         next-percent-loss (if (= 0 (mod months 2))\n                             (+ percent-loss-per-month 0.5)\n                             percent-loss-per-month\n                             )\n         ]\n     (do\n     (if (< start-price-new (+ start-price-old saved))\n       [months, (Math\/round (double available))]\n       (nb_months \n        (* start-price-old price-factor)\n        (* start-price-new price-factor)\n        saving-per-month\n        next-percent-loss\n        (+ saved saving-per-month)\n        (inc months)\n        )\n       )\n    )\n   )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15990,"user_id":null,"body":"(ns buy-car.core)\n\n(defn nb_months\n  [start-price-old start-price-new saving-per-month percent-loss-per-month]\n  (let [old-car-val (atom start-price-old)\n        new-car-val (atom start-price-new)\n        loss-percent (atom (* percent-loss-per-month 0.01))\n        savings (atom 0)\n        months (atom 0)\n        reduce-car-val #(swap! % (fn [car-val loss] (- car-val (* car-val loss))) @loss-percent)\n        increase-loss-if-uneven-month #(swap! loss-percent (fn [loss] (if (not (even? @months)) (+ loss 0.005) loss)))\n        increase-savings #(swap! savings (fn [save] (+ save saving-per-month)))\n        increment-months #(swap! months inc)\n        round #(Math\/round (double %))]\n    (while (< (+ @old-car-val @savings) @new-car-val)\n      (increase-loss-if-uneven-month)\n      (reduce-car-val old-car-val)\n      (reduce-car-val new-car-val)\n      (increase-savings)\n      (increment-months)\n      )\n    [@months (round (- (+ @old-car-val @savings) @new-car-val))]\n    )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15991,"user_id":null,"body":"(ns buy-car.core)\n\n\n(defn deprication-factor [pc-change] (- 1 (\/ pc-change 100)))\n\n(defn deprication\n  [old-car new-car saving pc-change month]\n  (let [next-p       (+ pc-change (* 0.5 (quot month 2)))\n        next-old-car (* old-car (deprication-factor next-p))\n        next-new-car (* new-car (deprication-factor next-p))\n        value-diff  (- (+ (* month saving) next-old-car) next-new-car)]\n    (lazy-seq (cons\n                [month (Math\/round value-diff)]\n                (deprication next-old-car next-new-car\n                             saving pc-change (inc month))))))\n\n(defn nb_months [old-car new-car saving pc-change]\n  (first (drop-while #(neg? (last %))\n                     (cons [0 (- old-car new-car)]\n                           (deprication old-car new-car saving pc-change 1)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15992,"user_id":null,"body":"(ns buy-car.core)\n\n\n\n(defn deprication-factor [pc-change] (- 1 (\/ pc-change 100)))\n\n\n(defn deprication\n  [old-car new-car saving pc-change month]\n  (let [next-p       (+ pc-change (* 0.5 (quot month 2)))\n        next-old-car (* old-car (deprication-factor next-p))\n        next-new-car (* new-car (deprication-factor next-p))\n        value-diff  (- (+ (* month saving) next-old-car) next-new-car)\n        ; value-diff  (- (+ (* month saving) old-car) new-car)\n        ]\n    (lazy-seq (cons\n                [month (Math\/round value-diff)]\n                ;[month next-p (+ (* month saving) old-car) new-car\n                ; (Math\/round value-diff)]\n                (deprication next-old-car next-new-car\n                             saving pc-change (inc month))))))\n\n\n\n(defn nb_months [old-car new-car saving pc-change]\n  (first (drop-while #(neg? (last %))\n                     (cons [0 (- old-car new-car)]\n                           (deprication old-car new-car saving pc-change 1)))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"554b4ac871d6813a03000035":[{"id":15993,"user_id":53,"body":"(ns kata)\n(require '[clojure.string :as str])\n(defn high_and_low [s]\n  (let [xs (map #(Integer\/parseInt %) (str\/split s #\" \"))]\n    (format \"%d %d\" (apply max xs) (apply min xs))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15994,"user_id":null,"body":"(ns kata)\n\n(defn high_and_low [s]\n    (->> (clojure.string\/split s #\" \")\n      (map read-string)\n      ((juxt #(apply max %) #(apply min %)))\n      (clojure.string\/join \" \")))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15995,"user_id":null,"body":"(ns kata)\n\n(defn high_and_low\n  \"String -> String\n  \n  Given a string with positive and negative integers, return a string showing the highest and the lowest\n  numbers from the given string.\n  \n  ASSUME: there is at least one number in the given string.\"\n  [s]\n  (let [nums (map #(Integer\/parseInt %) (clojure.string\/split s #\" \"))]\n    (str (apply max nums) \" \" (apply min nums))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15996,"user_id":null,"body":"(ns kata\n  (:require [clojure.string :as s]\n            [clojure.edn :as edn]))\n\n(defn high_and_low [s]\n    ; happy coding!\n    (let [ l (map edn\/read-string (s\/split s #\" \"))]\n      (str (apply max l) \" \" (apply min l))\n    )\n  )","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15997,"user_id":null,"body":"(ns kata)\n\n(require '[clojure.string :as str])\n\n(defn string->numbers [s]\n  (let [words (str\/split s #\" \")]\n    (map #(biginteger %1) words)))\n\n(defn high_and_low [s]\n  (let [numbers (sort (string->numbers s))]\n    (format \"%d %d\" (last numbers) (first numbers))))\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15998,"user_id":null,"body":"(ns kata)\n\n(defn high_and_low [s]\n    (as-> (map read-string (re-seq #\"[-]*\\d+\" s)) v\n    (str (reduce max v) \" \" (reduce min v))\n    ))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":15999,"user_id":null,"body":"(ns kata\n  (:require [clojure.string :as st]))\n\n(defn high_and_low [s]\n  (let [a (sort (map #(read-string %) (st\/split s #\" +\")))] (st\/join \" \" [(last a) (first a)])))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16000,"user_id":null,"body":"(ns kata)\n\n(require '[clojure.string :as str])\n\n(defn high_and_low [s]\n    (let [xs (map read-string (str\/split s #\" \"))]\n        (format \"%d %d\" \n                (apply max xs) \n                (apply min xs)\n        )\n    )\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16001,"user_id":null,"body":"(ns kata)\n\n(require '[clojure.string :as str])\n\n(defn high_and_low [s]\n  (str \n        (apply max (map read-string (str\/split s #\" \")))\n        \" \"\n        (apply min (map read-string (str\/split s #\" \")))\n  )\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16002,"user_id":null,"body":"(ns kata)\n\n(defn string-to-int [number-as-string]\n  ;; converts the string into integers and places them in a vector DS\n  (into [] (map (fn [x] (Integer\/parseInt x))\n                (-> number-as-string\n                  (clojure.string\/split #\" \")))))\n\n(defn vector-max-min [func]\n  ;; get the maximum and minimum values as a vector\n  (vector (apply max func) (apply min func)))\n\n\n(defn high_and_low [s]\n  ;; transform int of vector to string\n  (->> (vector-max-min (string-to-int s))\n    (clojure.string\/join \" \" )))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"554e4a2f232cdd87d9000038":[{"id":16003,"user_id":null,"body":"(ns complementary-dna)\n\n(defn dna_strand [dna]\n    (apply str (map {\\A \\T \\C \\G \\G \\C \\T \\A} dna)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16004,"user_id":null,"body":"(ns complementary-dna)\n\n(require '[clojure.string :refer [replace]])\n\n(defn dna_strand [dna]\n  (replace dna #\"\\S\" {\"A\" \"T\" \"C\" \"G\" \"T\" \"A\" \"G\" \"C\"}))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16005,"user_id":null,"body":"(ns complementary-dna)\n\n(defn dna_strand [dna]\n  (apply str (replace {\\A \\T, \\C \\G, \\G \\C, \\T \\A} dna)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16006,"user_id":null,"body":"(ns complementary-dna)\n\n(def conversion-map {\\A \"T\", \\T \"A\", \\G \"C\", \\C \"G\"})\n(defn map-dna [s] \n  (get conversion-map s))\n(defn dna_strand [dna]\n  ; your code here\n  (clojure.string\/join (map map-dna dna))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16007,"user_id":564,"body":"(ns complementary-dna)\n\n(defn dna_strand [dna]\n  (def complements {\\A \\T, \\T \\A, \\G \\C, \\C \\G})\n  (clojure.string\/join (map #(get complements %) dna)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16008,"user_id":527,"body":"(ns complementary-dna)\n\n(defn dna_strand [dna]\n  (apply str (map #(case % \\A \\T \\T \\A \\C \\G \\G \\C) dna)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16009,"user_id":null,"body":"(ns complementary-dna)\n\n(def dict {\\A \"T\"\n           \\T \"A\"\n           \\C \"G\"\n           \\G \"C\"})\n\n(defn dna_strand [dna]\n  (apply str (map #(get dict %) dna)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16010,"user_id":null,"body":"(ns complementary-dna)\n\n(defn dna_strand [dna]\n  (let [genes        (clojure.string\/split dna #\"\")\n        reversefn    (fn [x]\n                       (cond\n                         (= x \"A\")  \"T\"\n                         (= x \"T\")  \"A\"\n                         (= x \"C\")  \"G\"\n                         (= x \"G\")  \"C\"))\n        result       (map reversefn genes)\n        ] (clojure.string\/join result)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16011,"user_id":null,"body":"(ns complementary-dna)\n\n(defn dna_strand [dna]\n  (def reverse-token (fn [token-content]\n    (cond\n      (= token-content \"A\") \"T\",\n      (= token-content \"T\") \"A\",\n      (= token-content \"C\") \"G\",\n      (= token-content \"G\") \"C\",\n      :else \"UND\")\n  ))\n  \n  (def inversed (map reverse-token (map str dna)))\n  (clojure.string\/join \"\" inversed)\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16012,"user_id":1703,"body":"(ns complementary-dna)\n\n(require '[clojure.string :as stg])\n\n(defn dna_strand [dna]\n  (stg\/upper-case(stg\/replace (stg\/replace (stg\/replace (stg\/replace dna #\"A\" \"t\") #\"T\" \"a\") #\"G\" \"c\") #\"C\" \"g\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"554f76dca89983cc400000bb":[{"id":16013,"user_id":492,"body":"(ns dioph-equa.core)\n\n(defn sol_equa [n]\n  (vec (remove nil? (for [x (range 1 (inc (Math\/sqrt n))) :when (zero? (rem n x))]\n        (let [p x q (\/ n x)]\n          (if (and (= 0 (mod (+ p q) 2)) (= 0 (mod (- q p) 4)))\n            [(\/ (+ p q) 2) (\/ (- q p) 4)] ))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16014,"user_id":null,"body":"(ns dioph-equa.core)\n\n(defn sol_equa [n]\n  (vec (->> (range 1 (inc (Math\/sqrt n)))\n            (filter #(zero?(rem n %)))\n            (map #(vector % (\/ n %)))\n            (filter #(zero? (rem (apply - %) 4)))\n            (map #(vector (\/ (apply + %) 2) (second %)))\n            (map #(vector (first %) (- (\/ (apply - %) 2)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16015,"user_id":null,"body":"(ns dioph-equa.core)\n\n(defn sol_equa [n]\n  (->> (range 1 (inc (Math\/floor (Math\/sqrt n))))\n       (filter #(= (mod n %) 0))\n       (map (fn [x] [x (\/ n x)]))\n       (filter (fn [[A B]] (= (mod (- B A) 4) 0)))\n       (map (fn\n              [[A B]]\n              [(\/ (+ A B) 2)\n               (\/ (- B A) 4)]))\n       (into [])))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16016,"user_id":null,"body":"(ns dioph-equa.core)\n\n(defn sol_equa [n]\n  (->>(range 1 (Math\/sqrt (inc n)))\n      (filter #(zero? (rem n %)))\n      (map #(vector % (\/ n %)))\n      (filter #(zero? (rem (reduce + %) 2)))\n      (filter #(zero? (rem (reduce - %) 4)))\n      (map #(vector (\/ (reduce + %) 2) (\/ (reduce - (reverse %)) 4)))))  \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16017,"user_id":53,"body":"(ns dioph-equa.core)\n\n(defn sol_equa [n]\n  (loop [i (bigint 1)\n         m (int (Math\/floor (Math\/sqrt n))) \n         acc []]\n    (let [d (\/ n i)\n          x (\/ (+ d i) 2)\n          y (\/ (- d i) 4)]\n      (cond\n        (> i m) acc\n        (not= d (bigint (Math\/ceil d))) (recur (inc i) m acc)\n        (not= x (bigint (Math\/ceil x))) (recur (inc i) m acc)\n        (not= y (bigint (Math\/ceil y))) (recur (inc i) m acc)\n        :else (recur (inc i) m (conj acc (list (bigint (Math\/floor x)) (bigint (Math\/floor y)))))\n        ))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16018,"user_id":null,"body":"(ns dioph-equa.core)\n\n(defn factors\n  [n]\n  (fn\n    [x]\n    (let [y (\/ n x)]\n      (if-not (ratio? y)\n        [[x y]]))))\n        \n(defn x-and-y\n  [[a b]]\n  (let [x (\/ (+ a b) 2)\n        y (\/ (- b a) 4)\n        normal? #(and (not (ratio? %)) (>= % 0))]\n    #_(printf \"[%s %s]\n\" x y)\n    (cond-> []\n      (and\n        (normal? x)\n        (normal? y)) (conj [x y]))))\n\n(defn sol_equa\n  [n]\n  (->>\n    (range 1 (inc (Math\/sqrt n)))\n    (mapcat (factors n))\n    (mapcat x-and-y)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16019,"user_id":null,"body":"(ns dioph-equa.core)\n\n(defn sol_equa [n]\n  (let [r (int (Math\/sqrt n))]\n    (loop [m 1\n           res []]\n      (if (> m r)\n          res\n          (if (= 0 (mod n m))\n              (let [m2 (\/ n m)\n                    x2 (+ m m2)]\n                 (if (= 0 (mod x2 2))\n                   (let [x (\/ x2 2)\n                         y2 (- m2 x)]\n                     (if (= 0 (mod y2 2))\n                       (recur (inc m) (conj res [x (\/ y2 2)]))\n                       (recur (inc m) res)))\n                   (recur (inc m) res)))\n               (recur (inc m) res)))))\n                  \n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16020,"user_id":null,"body":"(ns dioph-equa.core)\n\n(defn div? [n i] (zero? (rem n i)))\n\n(defn factors [n]\n  (->> (range 1 (inc (int (Math\/sqrt n))))\n       (filter (partial div? n))\n       (map (fn [i] [i (quot n i)]))))\n\n(defn sol_equa [n]\n  (->> (factors n)\n       (filter (fn [[a b]] (div? (- b a) 4)))\n       (map (fn [[a b]]\n              [(\/ (+ b a) 2)\n               (\/ (- b a) 4)]))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16021,"user_id":null,"body":"(ns dioph-equa.core)\n\n(defn factors [n]\n  (distinct (sort (mapcat #(vector % (quot n %))\n                          (filter #(zero? (mod n %))\n                                  (range 1 (inc (Math\/sqrt n))))))))\n\n(defn sol_equa [n]\n  (let [fs (factors n)]\n    (apply vector\n           (distinct\n            (filter #(every? (fn [i] (zero? (mod i 1))) %)\n                    (filter #(not-any? neg? %)\n                            (mapcat (fn [z] [[(\/ (+' n (*' z z)) (*' 2 z))\n                                              (\/ (-' (*' z z) n) (*' 4 z))]\n                                             [(\/ (+' n (*' z z)) (*' 2 z))\n                                              (\/ (-' n (*' z z)) (*' 4 z))]])\n                                    fs)))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16022,"user_id":null,"body":"(ns dioph-equa.core)\n\n(defn sol_equa [n]\n  (->> (range 1 (inc (Math\/ceil (Math\/sqrt n))))\n       (filter #(zero? (mod n %)))\n       (map #(let [a % \n                   b (\/ n a)\n                   x (\/ (+ a b) 2) \n                   y (\/ (- b x) 2)]\n          [x y]))\n       (filter (fn [[x y]] (and (= x (long x)) (= y (long y)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5552101f47fc5178b1000050":[{"id":16023,"user_id":null,"body":"(ns play-digits.core)\n\n(defn dig_pow [n p]\n  (let [digitize (fn [n] (map #(-> % str Integer\/parseInt) (apply list (str n))))\n        sum (reduce + (apply map #(Math\/pow %1 %2) [(digitize n) (iterate inc p)]))]\n    (if (zero? (mod sum n))\n      (int (\/ sum n))\n      -1)))\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16024,"user_id":null,"body":"(ns play-digits.core)\n\n(defn dig_pow [n p]\n  (def newN\n    (\/ (reduce\n        + (map-indexed\n           #(reduce * (repeat (+ p %1) %2))\n           (->> n\n                (iterate #(quot % 10))\n                (take-while pos?)\n                (mapv #(mod % 10))\n                rseq)))\n       n))\n  (if (= (mod newN 1) 0) newN -1))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16025,"user_id":null,"body":"(ns play-digits.core\n  (:require [clojure.string :as s]))\n\n(defn exp [n p]\n  \"Returns n raised to the p power.\"\n  (reduce * (repeat p n)))\n\n(defn int-digits\n  \"Returns a seq of an integer's digits\"\n  [n]\n  (if (< n 10)\n    n\n    (map #(Integer\/parseInt %)\n         (s\/split (str n) #\"\"))))\n\n(defn power-sum\n  \"Returns the sum of the digits of n taken to the successive powers of p\"\n  [n p]\n  (loop [digits (int-digits n)\n         powers (range p (+ p (count digits)))\n         sum 0]\n    (if (empty? digits)\n      sum\n      (recur (rest digits)\n             (rest powers)\n             (+ sum (exp (first digits) (first powers)))))))\n\n(defn dig_pow\n  \"Determines if the sum of the digits of n taken to the successive powers of p is equal to k * n, and returns k if it exists, otherwise -1.\"\n  [n p]\n  (loop [k 1\n         sum (* k n)\n         target (power-sum n p)]\n    (cond (= target sum) k\n          (> sum target) -1\n          :else (recur (inc k) (* (inc k) n) target))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16026,"user_id":null,"body":"(ns play-digits.core)\n\n(defn dig_pow [n p] \n  (let [n-seq (map #(Character\/getNumericValue %) (str n))\n        totals (map #(Math\/pow %1 %2) n-seq (iterate inc p))\n        t (reduce +' totals)]\n    (if (zero? (mod t n)) (int (\/ t n)) -1)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16027,"user_id":null,"body":"(ns play-digits.core)\n\n(defn dig_pow [n p] \n  (let [digits (map #(Character\/getNumericValue %) (str n))\n        exponentials (take (count digits) (range p 10000))\n        powers (map #(Math\/pow %1 %2) digits exponentials)\n        k (\/ (long (reduce + powers)) n)]\n     (if (ratio? k) -1 k)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16028,"user_id":492,"body":"(ns play-digits.core)\n\n(defn dig_pow [n p] \n  (let [c (vec (map #(Integer\/parseInt (str %))  (seq (str n))))\n        s (long (reduce + 0 (map-indexed (fn [idx item] (Math\/pow item (+ p idx))) c)))\n       ]\n    (if (= 0 (mod s n)) (quot s n) -1)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16029,"user_id":null,"body":"(ns play-digits.core)\n\n(defn dig_pow [n p]\n  (let [;; Split up 'n' as a seq of digits\n  \t\t\tdigits (map #(Character\/digit % 10) (seq (str n)))\n        ;; Calculate the sum\n        sum (long (reduce + 0 (mapv\n                          (fn [base pow] (Math\/pow base pow))\n                          digits (iterate inc p))))]\n    (if (= (mod sum n) 0)\n      (quot sum n)\n      -1)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16030,"user_id":null,"body":"(ns play-digits.core)\n\n(defn reverse-num [x acc p]\n  (if (>= x 1)\n    (reverse-num\n     (long (\/ x 10))\n     (conj acc (Math\/pow (rem x 10) p))\n     (dec p))\n    acc))\n\n(defn get-n [x p]\n  (apply + (reverse-num x [] (long (+ p (Math\/log10 x))))))\n\n(defn dig_pow [n p]\n  (let [r (get-n n p)\n        k (\/ r n)]\n    (if (= 0.0 (mod k 1)) (long k) -1)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16031,"user_id":null,"body":"(ns play-digits.core)\n\n(defn ** [x n] \n    (reduce * (repeat n x)))\n        \n(defn num-to-digits [num]\n    (loop [n num res []]\n        (if (zero? n)\n            res\n            (recur (quot n 10) (cons (mod n 10) res)))))\n            \n(defn dig_pow-sum [n p acc]\n    (if (empty? n)\n        acc\n        (dig_pow-sum (rest n) (+ p 1) (+ acc (** (first n) p)))))\n        \n(defn dig_pow [n p]\n    (let [sum (dig_pow-sum (num-to-digits n) p 0)]\n        (let [k (quot sum n)]\n            (if (= (* n k) sum)\n                k\n                -1))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16032,"user_id":null,"body":"(ns play-digits.core)\n\n(defn dig_pow [n p] \n  (let [x (reduce + (map-indexed #(.pow (biginteger (str %2))\n                                        (+ % p))\n                                 (str n)))]\n    (if (zero? (rem x n))\n      (int (\/ x n))\n      -1)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"555624b601231dc7a400017a":[{"id":16033,"user_id":null,"body":"(ns josephusurvivor.core)\n\n(defn josephus_survivor [n k]\n  (loop [n n, pos #(inc (mod (dec %) n))]\n  (if (= 1 n) (pos 1)\n    (recur (dec n) (comp pos #(inc (mod (+ (dec k) %) n)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16034,"user_id":527,"body":"(ns josephusurvivor.core)\n\n(defn josephus_survivor [n k]\n  (->> (range 1 (inc n)) (reduce #(mod (+ %1 k) %2) 1) inc))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16035,"user_id":62,"body":"(ns josephusurvivor.core)\n\n(defn josephus_survivor [n k] \n  (inc (reduce \n        (fn [offset num-people]\n              (rem (+ offset k) (inc num-people)))\n              0\n          (range n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16036,"user_id":null,"body":"(ns josephusurvivor.core)\n\n(defn josephus_survivor [n k]\n  (defn walk [s c]\n    (if (= c 1)\n      (first s)\n      (let [p1 (rem (dec k) c)\n            p2 (inc p1)]\n        (recur (into (subvec s p2)\n                     (subvec s 0 p1))\n               (dec c)))))\n  (walk (into [] (range 1 (inc n)))\n        n))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16037,"user_id":null,"body":"(ns josephusurvivor.core)\n\n(defn josephus_survivor [n k]\n  (reduce #(inc (mod (+ k (dec %1)) %2)) (range 1 (inc n)))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16038,"user_id":53,"body":"(ns josephusurvivor.core)\n\n(defn josephus_survivor [n k]\n  (loop [i 1 res 1]\n    (if (> i n)\n      res\n      (recur (inc i) (inc (mod (dec (+ res k)) i))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16039,"user_id":null,"body":"(ns josephusurvivor.core)\n(defn g [n k]\n  (if (= 1N (bigint n))\n    0\n    (mod (+ k (g (dec n) k)) n)))\n\n(def m-g (memoize g))\n\n(defn josephus_survivor [n k]\n  (inc (m-g n k))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16040,"user_id":null,"body":"(ns josephusurvivor.core)\n\n(defn josephus_survivor [n k]\n  (->> (range 1 (inc n))\n       (reduce #(rem (+ %1 k) %2) 1)\n       inc))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16041,"user_id":null,"body":"(ns josephusurvivor.core)\n\n(defn josephus_survivor [n k]\n  (if (= n 1)\n    1\n    (loop [current-n 2\n           prev-position 1]\n      (let [new-position (-> prev-position\n                           dec\n                           (+ k)\n                           (rem current-n)\n                           inc)]\n        (if (= n current-n)\n          new-position\n          (recur (inc current-n) new-position))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16042,"user_id":null,"body":"(ns josephusurvivor.core)\n\n(defn josephus_survivor [n k]                                                                                                    \n  (loop [n n, k k, pos #(inc (mod (dec %) n))]                                                                                                  \n    (if (= 1 n) (pos 1)                                                                                                       \n      (recur (dec n) k (comp pos #(inc (mod (+ (dec k) %) n))))))) ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55563df50dda59adf900004d":[{"id":16043,"user_id":null,"body":"(ns ean-validator)\n\n(defn validate_ean [ean]\n  (let [d-ean (map #(Character\/digit % 10) ean)\n  \t\t\tchecksum (last d-ean)\n        vals (butlast d-ean)\n        odds (reduce + (take-nth 2 vals))\n        evens (reduce + (take-nth 2 (rest vals)))\n        sum (mod (+ odds (* 3 evens)) 10)]\n    (== (mod (- 10 sum) 10) checksum)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16044,"user_id":527,"body":"(ns ean-validator)\n\n(defn validate_ean [^String ean-code]\n  (let [\n      code (map #(Character\/digit % 10) ean-code)\n      sum0 (->> code (take-nth 2) (apply +))\n      sum1 (->> code rest (take-nth 2) (apply +))\n    ] (-> (+ sum0 (* sum1 3)) (mod 10) zero?)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16045,"user_id":null,"body":"(ns ean-validator)\n\n(defn validate_ean [ean-code]\n  (loop [[d & ds] (map #(- (int %) 48) ean-code) negsum 0 m 1]\n    (if ds\n      (recur ds (- negsum (* d m)) (- 4 m))\n      (= d (mod negsum 10)) )))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16046,"user_id":492,"body":"(ns ean-validator)\n\n(defn validate_ean [ean-code]\n  (let [spl (map #(Character\/digit % 10) ean-code)\n        verif (last spl)\n        digits (butlast spl)\n        odds (reduce + (take-nth 2 digits))\n        evens (reduce + (take-nth 2 (rest digits)))\n        tot (+ odds (* 3 evens))]\n    (== verif (mod (- 10 (mod tot 10)) 10))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16047,"user_id":null,"body":"(ns ean-validator)\n\n(defn digit-value\n  [index digit]\n  (* (Integer\/parseInt (str digit))\n     (if (odd? (+ 1 index)) 1 3)))\n\n(defn checksum-value [ean]\n  (reduce + (map-indexed digit-value\n                         (take 12 ean))))\n\n(defn checksum [ean]\n  (let [value (mod (checksum-value ean) 10)]\n    (if (zero? value)\n      0\n      (- 10 value))))\n\n(defn validate_ean [ean-code]\n  (= (Integer\/parseInt (str (nth ean-code 12)))\n     (checksum ean-code)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16048,"user_id":53,"body":"(ns ean-validator)\n\n(defn validate_ean [code]\n  (loop [i 0 m 0]\n    (cond\n      (> i 11) (= (Character\/digit (nth code 12) 10) (mod (- 10 (mod m 10)) 10))\n      :else (recur (inc i) (+ m (* (Character\/digit (nth code i) 10) (if (= 1 (mod i 2)) 3 1)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16049,"user_id":null,"body":"(ns ean-validator)\n\n(defn validate_ean [ean-code]\n  (let [digits (butlast (map-indexed (fn [i x] (vector (+ 1 i) (Character\/digit x 10))) ean-code))\n        total (reduce (fn [acc x] (+ acc (if (odd? (first x)) (* (second x) 1) (* (second x) 3)))) 0 digits)\n        checksum (if (= (mod total 10) 0) 0 (- 10 (mod total 10)))]\n    (= (Character\/digit (last ean-code) 10) checksum)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16050,"user_id":null,"body":"(ns ean-validator)\n\n(defn validate_ean [ean-code]\n  (let [digits (butlast (map-indexed (fn [i x] (vector (+ 1 i) (Character\/digit x 10))) ean-code))\n        total (reduce (fn [acc x] (+ acc (if (odd? (first x)) (* (second x) 1) (* (second x) 3)))) 0 digits)\n        checksum (if (= (mod total 10) 0) 0 (- 10 (mod total 10)))]\n    (if (= (Character\/digit (last ean-code) 10) checksum)\n      true\n      false)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16051,"user_id":null,"body":"(ns ean-validator)\n\n(defn- parse-int [c] (- (int c) (int \\0)))\n\n(defn- ean-checksum\n  [ean-code]\n  (as->\n    ean-code $\n    (take 12 $)\n    (map parse-int $)\n    (map-indexed #(if (= 0 (mod %1 2)) %2 (* 3 %2)) $)\n    (apply + $)\n    (if (= 0 (mod $ 10)) 0 (- 10 (mod $ 10)))))\n\n(defn validate_ean [ean-code]\n  (=\n   (ean-checksum ean-code)\n   (as-> ean-code $ (nth $ 12) (parse-int $))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16052,"user_id":null,"body":"(ns ean-validator)\n\n\n(defn validate_ean [ean-code]\n  (def even (map  #(int (nth ean-code %))  (filter even? (range (dec (count ean-code))))))\n  (def odd (map #(int (nth ean-code %)) (filter odd? (range (dec (count ean-code))))))\n  (def even-sum (reduce + (map #(- % (int \\0)) even)))\n  (def odd-sum  (reduce + (map #(- % (int \\0)) odd)))\n  (def res (+ (* 3 odd-sum) even-sum))\n  (println res)\n  (println (= 0 (mod res 10)))\n  (println (- (int (nth ean-code 12)) (int \\0)))\n  (if (= 0 (mod res 10))\n   (= (- (int (nth ean-code 12)) (int \\0)) 0)\n   (= (- (int (nth ean-code 12)) (int \\0)) (- 10 (mod res 10))))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"555eded1ad94b00403000071":[{"id":16053,"user_id":null,"body":"(ns nthseries.core)\n\n(defn series_sum [n]\n  (->> (range n)\n       (map #(\/ (+ (* % 3) 1)))\n       (reduce + 0.0)\n       (format \"%.2f\")))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16054,"user_id":null,"body":"(ns nthseries.core)\n; n * 3 + 1    \n(defn series_sum [n]\n  (let [series (for [x (range n)] (\/ 1.0 (+ 1.0 (* 3.0 x))))]\n    (format \"%.2f\" (float (reduce + series)))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16055,"user_id":null,"body":"(ns nthseries.core)\n\n(defn series_sum [n]\n  (format \"%.2f\" (reduce + 0.0 (map #(\/ 1 (+ (* % 3) 1)) (range n))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16056,"user_id":null,"body":"(ns nthseries.core)\n\n(defn series_sum [n]\n  (->> (range 1 (inc (* 3 n)) 3)\n       (map (partial \/ 1.0))\n       (reduce + 0.0)\n       (format \"%.2f\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16057,"user_id":null,"body":"(ns nthseries.core)\n\n(defn nth-term [n]\n  (\/ 1 (+ 1 (* n 3)))\n)\n\n(defn series_sum [n]\n  (format \"%.2f\" (reduce + 0.00 (map nth-term (range 0 n))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16058,"user_id":null,"body":"(ns nthseries.core)\n\n(defn series_sum [n]\n  (format \"%.2f\" (reduce + 0.0 (map #(\/ (+ (* % 3) 1)) (range n)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16059,"user_id":null,"body":"(ns nthseries.core)\n\n(defn calc-limit [n]\n  \"Integer -> Integer\"\n  (if (zero? n)\n    0\n    (-> n\n        (- 1)\n        (* 3)\n        (+ 2))))\n\n(defn series_sum [n]\n  \"Integer -> String\"\n  (->> n\n       (calc-limit)\n       (#(range 1 % 3))\n       (reduce #(+ %1 (\/ 1 %2)) 0.0)\n       (format \"%.2f\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16060,"user_id":null,"body":"(ns nthseries.core)\n\n(defn series_sum [n]\n  (->> (range n)\n    (map #(\/ 1. (+ 1 (* 3 %))))\n    (reduce + 0.)\n    (format \"%.2f\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16061,"user_id":null,"body":"(ns nthseries.core)\n\n(defn series_sum [n]\n  (let [result (loop [num 0 s 0.0]\n   (let [current-term (\/ 1 (+ (* 3 num) 1))]\n   (cond\n   (= num n) s\n   (> 0.0000001 current-term) s\n   :else (recur (+ num 1) (+ s current-term)))))]\n   (format \"%.2f\" result)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16062,"user_id":null,"body":"(ns nthseries.core)\n\n(defn series_sum [n]\n  (if (= 0 n)\n    \"0.00\"\n    (->> (range 1 n)\n         (map (comp double \/ (partial inc) (partial * 3)))\n         (cons 1)\n         (reduce +)\n         (format \"%1.2f\"))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"556deca17c58da83c00002db":[{"id":16063,"user_id":null,"body":"(ns kata)\n\n(defn trib\n  [a b c]\n  (lazy-seq\n    (cons a (trib b c (+ a b c)))))\n\n(defn tribonacci [[a b c] n]\n  (take n (trib a b c)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16064,"user_id":564,"body":"(ns kata)\n(defn tribonacci [[a b c] n]\n  (if (<= n 3)\n    (take n [a b c])\n    (let [d (+ a b c)]\n      (concat [a] (tribonacci [b c d] (- n 1))))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16065,"user_id":null,"body":"(ns kata)\n\n(defn tribonacci\n  [[a b c] n]\n  (loop [x [a b c]]\n    (if (>= (count x) n)\n      (take n x)\n      (recur\n        (conj x\n          (reduce + (take-last 3 x)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16066,"user_id":null,"body":"(ns kata)\n(defn tribonacci [seed n]\n  (if (<= n 3)\n    (take n seed)\n    (loop [elements seed elements-left (- n 3)]\n      (if (zero? elements-left)\n        elements\n        (let [new-element (->> (reverse elements) (take 3) (reduce +))]\n          (recur (conj elements new-element) (dec elements-left)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16067,"user_id":null,"body":"(ns kata)\n(defn tribonacci [[a b c] n]\n (map first (take n\n   (iterate (fn [[a b c]] [b c (+ a b c)]) [a b c]))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16068,"user_id":null,"body":"(ns kata)\n(defn tribonacci [[a b c] n]\n  (->> [a b c]\n       (iterate (fn [[x y z]] [y z (+ x y z)]))\n       (map first)\n       (take n)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16069,"user_id":null,"body":"(ns kata)\n(defn tribonacci [[a0 b0 c0] n]\n  ;; your code here\n  (take n (map first (iterate (fn [[a b c ]] [ b c (+ a b c)]) [a0 b0 c0])))\n  \n  \n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16070,"user_id":null,"body":"(ns kata)\n(defn tribonacci [sig n]\n  (->> sig\n      (iterate (fn [[a b c]] [b c (+ a b c)]))\n      (map first)\n      (take n)\n      vec))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16071,"user_id":null,"body":"(ns kata)\n(defn tribonacci [[a b c] n]\n  (take n ((fn trib [x y z] (lazy-seq (concat (list x) (trib y z (+ x y z))))) a b c))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16072,"user_id":null,"body":"(ns kata)\n\n(def nth-tribonacci \n  (memoize \n   (fn [starting-values n]\n     (if (< n 3)\n       (nth starting-values n)\n       (apply +' (map (partial nth-tribonacci starting-values)\n                     [(- n 1) (- n 2) (- n 3)]))))))\n\n(defn custom-tribonacci [starting-values]\n  (map (partial nth-tribonacci starting-values) \n       (range)))\n  \n(defn tribonacci [[a b c] n]\n  (take n (custom-tribonacci [a b c])))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"556eed2836b302917b0000a3":[{"id":16073,"user_id":null,"body":"(ns systemquadratic.core)\n\n(defn solution [n m]\n  (let [ large (max m n)\n         small (min m n)]\n    (->> (iterate inc 0)\n      ;; potential a's\n      (take-while #(<= (* % %) small))\n      (map #(list % (- small (* % %))))\n      (filter #(let [ fir (first %)\n                      sec (second %)]\n                 (= large (+ fir (*  sec sec)))))\n      count)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16074,"user_id":null,"body":"(ns systemquadratic.core\n  (:require [clojure.set :refer [intersection]]))\n\n(defn solution [n m]\n  (let [[a b] (sort [n m])\n        mid-sqr (Math\/sqrt a)]\n    (count\n     (intersection\n      (set (map #(vector (- a (* % %)) %) (range 0 mid-sqr)))\n      (set (map #(vector % (- b (* % %))) (range (inc (int mid-sqr)) (inc (Math\/sqrt b)))))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16075,"user_id":null,"body":"(ns systemquadratic.core)\n\n(defn solution [n m]\n  (count (for [a (range (inc (int (Math\/sqrt n))))\n               b (range (inc (int (Math\/sqrt m))))\n               :when (and (= (+ (* a a) b) n) (= (+ a (* b b)) m))]\n    [a b])))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16076,"user_id":null,"body":"(ns systemquadratic.core)\n\n(defn solution [n m]\n  (count (filter #(let [b (- n (* % %))]\n                    (and (>= b 0) (= (+ % (* b b)) m))) (range (inc m)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16077,"user_id":null,"body":"(ns systemquadratic.core)\n\n(defn solution [n m]\n  (->> (for [x (range (inc (Math\/sqrt n)))\n             y (range (inc (Math\/sqrt m)))]\n         [x y])\n       (filter (fn [[a b]]\n                 (and\n                      (= n (+ (* a a) b))\n                      (= m (+ a (* b b))))))\n         (count)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16078,"user_id":null,"body":"(ns systemquadratic.core)\n\n(defn exp [x n] (reduce * (repeat n x)))\n\n(defn solution [n m]\n  (let [amax (inc (int (Math\/sqrt n)))\n        bmax (inc (int (Math\/sqrt m)))]\n    (count (for [a (range 0 amax) b (range 0 bmax)\n          :when (and (= n (+ (exp a 2) b)) (= m (+ a (exp b 2))))]\n      [a b]))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16079,"user_id":null,"body":"(ns systemquadratic.core)\n\n(defn abcandidates [n]\n  (map #(vector % (- n (* % %))) (range 0 (+ (int (Math\/sqrt n)) 1))))\n  \n(defn solution [n m]\n (let [ab (abcandidates n)]\n  (count (filter \n          (fn [x]\n            (let [[a b] x]\n              (= (+ a (* b b)) m)))\n          ab))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16080,"user_id":null,"body":"(ns systemquadratic.core)\n\n(defn solution [n m]\n  (let [as (range (inc (min (Math\/sqrt (max n m))\n                            (min n m))))\n        valid-a? (fn [a]\n                 (let [b (- n (* a a))]\n                   (if (and (>= b 0) (= (+ a (* b b)) m))\n                     true\n                     false)))]\n    (count (filter valid-a? as))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16081,"user_id":null,"body":"(ns systemquadratic.core)\n\n\n\n(defn  mycheck [a b1 n m ]\n  (let [b (- m (* a a))] (if  (and (> b 0) \n                                   (= (+ (* a a) b)m) \n                                   (= (+ a (* b b))n)) \n                           1 0)\n       )\n\n  )\n\n\n(defn solution [n m] \n  (let [b (min m n)]\n    (loop [tot 0 a1 0 ] \n      (if (> a1 (min n m ))\n        tot\n        (recur (+ tot (mycheck a1 b n m )) \n               (+ 1 a1) ) )\n      ))) \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16082,"user_id":492,"body":"(ns systemquadratic.core)\n\n(defn calcul [mi mx i nbsol]\n  (let [b (Math\/sqrt (- mi i)) b1 (int b)]\n    (if (and (= 0.0 (mod b 1))  (<= b1 mx))\n      (let [a (int (Math\/sqrt (- mx b1)))]\n        (if (and (= mx (+ b1 (* a a))) (= mi (+ a (* b1 b1))))\n          (inc nbsol)\n          nbsol))\n      nbsol)))\n\n(defn solution-aux [mi mx]\n(loop [i 0 nbsol 0]\n  (let [sol (calcul mi mx i nbsol)]\n    (if (= i mi)\n      sol\n      (recur (inc i) sol)))))\n\n(defn solution [n m]\n (solution-aux (Math\/min n m) (Math\/max n m)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"557cd6882bfa3c8a9f0000c1":[{"id":16083,"user_id":null,"body":"(ns clojure.girl-age)\n\n(defn get_age\n  [her-old]\n  (-> her-old\n      first\n      str\n      Integer\/parseInt))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16084,"user_id":null,"body":"(ns clojure.girl-age)\n\n(defn get_age [her-old]\n  ; Extracts age from a string\n  (Integer. (re-find #\"\\d+\" her-old)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16085,"user_id":527,"body":"(ns clojure.girl-age)\n\n(defn get_age [s]\n  (-> s first (Character\/digit 10)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16086,"user_id":null,"body":"(ns clojure.girl-age)\n\n(defn get_age\n  [her-old]\n  (Integer\/parseInt (str (first her-old)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16087,"user_id":null,"body":"(ns clojure.girl-age)\n\n(def get_age read-string)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16088,"user_id":527,"body":"(ns clojure.girl-age)\n\n(defn get_age [s]\n  (-> s first int (- (int \\0))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16089,"user_id":null,"body":"(ns clojure.girl-age)\n\n(defn get_age [[one & rest]]\n  (Integer\/parseInt (str one))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16090,"user_id":null,"body":"(ns clojure.girl-age)\n\n(def zero (int \\0))\n\n(defn get_age\n  [her-old]\n  (- (int (.charAt her-old 0)) zero)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16091,"user_id":null,"body":"(ns clojure.girl-age\n  (:require [clojure.string :only [index-of]]))\n\n(defn get_age\n  [her-old]\n  (-> her-old\n      first\n      str\n      Integer\/parseInt))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16092,"user_id":1703,"body":"(ns clojure.girl-age)\n\n(defn get_age\n  [her_old]\n  (Integer\/parseInt (subs her_old 0 (clojure.string\/index-of her_old \" \")))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"557e8a141ca1f4caa70000a6":[{"id":16093,"user_id":null,"body":"(ns nb-triangle.core)\n\n(defn is_triangle_number [number]\n  (zero? \n    (mod \n      (Math\/sqrt\n        (inc (* 8 number))) \n      1)\n  )\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16094,"user_id":null,"body":"(ns nb-triangle.core)\n\n(defn is_triangle_number [number]\n  ; your code\n  (loop [current-sum 0\n         current-row 1]\n         (if (< current-sum number)\n            (recur (+ current-sum current-row) (inc current-row))\n            (= current-sum number))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16095,"user_id":null,"body":"(ns nb-triangle.core)\n\n(defn is_triangle_number [number]\n  (let [delta (inc (* 8 number))\n        sqrt-delta (int (Math\/sqrt delta))]\n    (and (integer? number) (== (* sqrt-delta sqrt-delta) delta))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16096,"user_id":492,"body":"(ns nb-triangle.core)\n\n(defn is_triangle_number [number]\n  (let [p (int (- (Math\/sqrt (+ 0.25 (* 2.0 number))) 0.5))]\n    (= (* 2 number) (* p (+ p 1)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16097,"user_id":null,"body":"(ns nb-triangle.core)\n\n(defn is_triangle_number [number]\n\t(if (integer? number)\n    (loop [tot 0 counter 1]\n      (if (== tot number)\n        true\n        (if (< tot number)\n          (recur (+ tot counter) (inc counter))\n          false\n        )\n      )\n    )\n    false\n  )\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16098,"user_id":null,"body":"(ns nb-triangle.core)\n\n(defn is_triangle_number [number]\n  (loop [x 0 sum 0]\n    (cond\n      (= sum number) true\n      (< sum number) (recur (inc x) (+ sum x))\n      (> sum number) false\n    )\n  )\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16099,"user_id":null,"body":"(ns nb-triangle.core)\n\n(defn is_triangle_number [number]\n  (let [triangle-numbers (fn [up-to]\n                           (for [n (range 1 (inc up-to))\n                                 :let [next-triangle (\/ (* n (inc n)) 2)]\n                                 :while (<= next-triangle up-to)]\n                             next-triangle))]\n    (= (last (triangle-numbers number)) number)))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16100,"user_id":3005,"body":"(ns nb-triangle.core)\n\n(defn is_triangle_number [number]\n (let [n (Math\/sqrt (+ (* 8 number) 1))]\n (= (float (Math\/round n)) n)\n )\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16101,"user_id":null,"body":"(ns nb-triangle.core)\n\n\n(defn is_triangle_number [n]\n    (loop [rn n fil-til 1]\n      (if (<= rn 0)\n        (if (= rn 0) true  false     )\n        (do (println fil-til);ftil\n            (recur (- rn fil-til )  (inc fil-til  ))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16102,"user_id":null,"body":"(ns nb-triangle.core)\n\n(defn is_triangle_number [number]\n  (loop [iter 1\n         acc  0]\n  (if (>= acc number)\n    (= acc number)\n    (recur (inc iter) (+ acc iter))))\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5583090cbe83f4fd8c000051":[{"id":16103,"user_id":3088,"body":"(ns digitizer.core)\n\n(defn digitize [n]\n  (->> n\n       str\n       reverse\n       (map #(Character\/digit % 10))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16104,"user_id":null,"body":"(ns digitizer.core)\n\n(defn digitize [n]\n  (reverse (map #(Integer\/parseInt (str %)) (str n))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16105,"user_id":null,"body":"(ns digitizer.core)\n\n(defn digitize [n]\n  (->> (str n)\n       (reverse)\n       (map str)\n       (map read-string)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16106,"user_id":null,"body":"(ns digitizer.core)\n\n(defn parse [n]\n  (Integer\/parseInt (str n)))\n\n(defn digitize [n]\n  (map parse (reverse (to-array(str n)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16107,"user_id":null,"body":"(ns digitizer.core)\n\n(defn digitize\n  ([n] (digitize n []))\n  ([n list] (if (< n 10) (concat list [n])\n                (recur (quot n 10) (concat list [(mod n 10)])))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16108,"user_id":null,"body":"(ns digitizer.core)\n\n(defn digitize [n]\n  (->> n str reverse (map #(Character\/getNumericValue %)))) ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16109,"user_id":495,"body":"(ns digitizer.core)\n\n (defn digitize [n] \n   (let [q (quot n 10) m (mod n 10)]\n     (if (= q 0) [m] (into [m] ( digitize q)) )))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16110,"user_id":null,"body":"(ns digitizer.core)\n\n(defn digitize [n]\n  (map \n    (fn [x] (Character\/digit x 10))\n    (reverse (str n))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16111,"user_id":null,"body":"(ns digitizer.core\n  (:require [clojure.string :as str]))\n\n(defn digitize [n]\n  (map #(Integer\/parseInt %) (str\/split (str\/reverse (str n)) #\"\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16112,"user_id":null,"body":"(ns digitizer.core)\n\n(defn digitize [num]\n  (if (= num 0)\n    [0]\n    (loop [x num\n           result []]\n      (if (<= x 0)\n        result\n        (recur (quot x 10) (conj result (rem x 10)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"558878ab7591c911a4000007":[{"id":16113,"user_id":571,"body":"(ns piglatin\n  (:require [clojure.string :as st]))\n\n(defn pig_latin [string]\n  (let [s (st\/lower-case string)] \n    (cond\n      (re-find #\"[^a-z]\" s) nil\n      (re-find #\"^[aeiou]\" s) (str s \"way\")\n      :else (st\/replace s #\"^([^aeiou]+)(.*)\" \"$2$1ay\"))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16114,"user_id":null,"body":"(ns piglatin)\n\n(defn pig_latin [s]\n  (let [s (clojure.string\/lower-case s)]\n    (cond\n      (re-find #\"[^a-z]\" s) nil\n      (re-find #\"^[aeiou]+\" s) (str s \"way\")\n      (re-find #\"^[^aeiou]+$\" s) (str s \"ay\")\n      (re-find #\"^[^aeiou]+\" s)\n        (let [consonants (re-find #\"^[^aeiou]+\" s)\n              s (subs s (count consonants))]\n          (str s consonants \"ay\"))\n      :else \"\")))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16115,"user_id":null,"body":"(ns piglatin)\n\n(defn pig-out [string]\n  (let [vowels (set \"aeiou\")\n        [hd tl] (split-with #(not (contains? vowels %)) string)\n        suff (if (empty? hd) \"way\" \"ay\")]\n    (apply str (concat tl hd suff))))\n\n(defn pig_latin [string]\n  (cond\n    (empty? string) string\n    (re-matches #\"^[a-zA-Z]+\" string) (pig-out (.toLowerCase string))\n    :else nil))\n  \n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16116,"user_id":null,"body":"(ns piglatin\n  (:require [clojure.string :as str]))\n\n(defn is-vowel [c]\n  (not (nil? (#{\\a \\e \\i \\o \\u} c))))\n\n(defn pig_latin [s]\n  (if (= \"\" s)\n    \"\"\n    (let [s (str\/lower-case s)]\n      (if (not (nil? (re-find #\"\\d\" s)))\n        nil\n        (if (is-vowel (first s))\n          (str s \"way\")\n          (let [starting-consenants (take-while #(not (is-vowel %)) s)]\n            (str\/lower-case (str (subs s (count starting-consenants)) (apply str starting-consenants) \"ay\"))))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16117,"user_id":null,"body":"(ns piglatin)\n\n(require '[clojure.string :as str])\n\n(defn vowel? \n  [char]\n  (contains? #{\\a \\e \\i \\o \\u} char))\n\n(defn consonant?\n  [char]\n  (contains?\n   #{\\b \\c \\d \\f \\g \\h \\j \\k \\l \\m \n \\p \\q \\r \\s \\t \\v \\w \\x \\y \\z}\n   char))\n\n(defn is-word?\n  [string]\n  (every? #(or (vowel? %) (consonant? %)) string))\n\n(defn pig_latin [string]\n  (let [word (str\/lower-case string)]\n    (if (is-word? word)\n      (if (vowel? (first word))\n        (str word \"way\")\n        (let [cons-cluster (str\/join \"\" (take-while consonant? word))\n              start (str\/join \"\" (drop-while consonant? word))]\n          (str start cons-cluster \"ay\"))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16118,"user_id":null,"body":"(ns piglatin\n  (require [clojure.string :as str]))\n\n(defn pig_latin\n  ([strng]\n   (if (nil? (re-find #\"\\d\" strng))\n     (pig_latin \"\" (str\/lower-case strng))))\n  ([front back]\n   (if (not-empty back)\n     (if (contains? #{\"a\" \"e\" \"i\" \"o\" \"u\"} (str (first back)))\n       (if (= front \"\")\n         (str (str\/join back) (str front \"way\"))\n         (str (str\/join back) (str front \"ay\")))\n       (pig_latin (str front (first back)) (rest back)))\n     (str (str\/join back) (str front \"ay\")))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16119,"user_id":null,"body":"(ns piglatin)\n\n(defn volwel? [c]\n    (if (contains? #{\"a\" \"e\" \"i\" \"o\" \"u\"} c) true false))\n\n(defn digit? [c]\n  (re-matches #\"[0-9]\" c))\n\n(defn bad? [string]\n  (some? (some digit? (re-seq #\".\" string))))\n\n(defn join [coll]\n  (clojure.string\/join \"\" (map str coll)))\n\n(defn pig_latin [text]\n  (let [string (clojure.string\/lower-case text)]\n    (if-not (zero? (count string))\n      (if-not (bad? string)\n        (let [prefix (take-while #(not (volwel? %)) (re-seq #\".\" string))\n              size   (count prefix)]\n          (if-not (zero? size)\n            (str (join (drop size string)) (join prefix) \"ay\")\n            (str string \"way\")))\n        nil) \"\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16120,"user_id":null,"body":"(ns piglatin)\n(require '[clojure.string :as str])\n\n(defn pig_latin [strng]\n  (def xs (str\/lower-case strng))\n  (cond\n    (re-seq #\"[^a-z]\" xs) nil\n    (re-seq #\"[aeiou]\" (subs xs 0 1)) (str xs \"way\")\n    (re-seq #\"^[^aeiou]*$\" xs) (str xs \"ay\")\n    :else (do\n      (def pos (str\/index-of xs (re-find #\"[aeiou]\" xs)))\n      (str (subs xs pos) (subs xs 0 pos) \"ay\"))\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16121,"user_id":1670,"body":"(ns piglatin (:require [clojure.string :as str] ))\n\n(defn pig_latin [string]\n  (def lc-string (str\/lower-case string))\n  (print lc-string)\n  (cond\n    (boolean (re-find #\"[123456789]\" lc-string)) nil\n    (not (boolean (re-find #\"[aeiou]\" lc-string))) (str lc-string \"ay\")\n    (re-matches #\"^[aeiou].*\" lc-string) (str lc-string \"way\")\n    :else\n      (let \n        [i (str\/index-of lc-string (re-find #\"[aeiou]\" lc-string))]\n        (str (subs lc-string i) (subs lc-string 0 i) \"ay\")\n      )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16122,"user_id":null,"body":"(ns piglatin)\n\n(def alphabet (apply str (map char (range (int \\a) (int \\z)))))\n(def vowels \"aeiou\")\n(def consonants (remove (into #{} vowels) alphabet))\n\n(defn is-vowel?\n\t[s]\n\t(clojure.string\/includes? vowels s))\n\n(def is-consonant? (complement is-vowel?))\n\n(defn pig_latin\n\t[s]\n  (let [word (clojure.string\/lower-case s)]\n    (if (empty? (filter #(not (Character\/isLetter %)) word))\n      (if (is-vowel? (str (first word)))\n        (clojure.string\/lower-case (str word \"way\"))\n        (loop [beginning word\n              end \"\"]\n            (if (is-consonant? (str (first beginning)))\n                (recur (apply str (rest beginning)) (str end (first beginning)))\n                (clojure.string\/lower-case (apply str beginning end \"ay\"))\n            )\n          )\n      )\n      nil\n    )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5592e3bd57b64d00f3000047":[{"id":16123,"user_id":492,"body":"(ns sumofcubes.core)\n\n(defn find_nb [m]\n  (let [s (biginteger (Math\/floor (Math\/sqrt m)))\n        delta (+ (* 8 s) 1)\n        sdelta (biginteger (Math\/floor (Math\/sqrt delta)))]\n    \n    (if (or (not= (* s s) m) (not= (* sdelta sdelta) delta))\n      -1\n      (quot (- sdelta 1) 2))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16124,"user_id":null,"body":"(ns sumofcubes.core)\n\n(defn find_nb [m]\n  (loop [total 0N n 0N]\n    (if (< total m)\n      (recur (+ total (* n n n)) (inc n))\n      (if (= total m) (dec n) -1))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16125,"user_id":492,"body":"(ns sumofcubes.core)\n\n(defn find_nb [m]\n  (let [s (biginteger (Math\/floor (Math\/sqrt m)))\n        delta (+ (* 8 s) 1)\n        sdelta (biginteger (Math\/floor (Math\/sqrt delta)))]\n    \n    (if (or (not= (* s s) m) (not= (* sdelta sdelta) delta))\n      -1\n      (quot (- sdelta 1) 2))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16126,"user_id":null,"body":"(ns sumofcubes.core)\n\n(defn find_nb [m]\n  (loop [r 0N\n         n 0]\n    (cond\n      (< (* r r) m) (recur (+ r n) (inc n))\n      (= (* r r) m) (dec n)\n      :default -1)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16127,"user_id":null,"body":"(ns sumofcubes.core)\n\n(defn find_nb [m]\n  (loop [remaining m count 1]\n    (let [size (*' count count count)]\n      (cond \n        (zero? remaining) (dec count)\n        (> size remaining) -1\n        :else (recur (- remaining size) (inc count))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16128,"user_id":null,"body":"(ns sumofcubes.core)\n\n(defn cubic-number\n  ([m] (cubic-number m 1))\n  ([m n] (cond\n           (= m 0) (dec n)\n           (< m 0) -1\n           :else (recur (-' m (*' n n n)) (inc n)))))\n\n(defn find_nb [m]\n  (cubic-number m))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16129,"user_id":null,"body":"(ns sumofcubes.core)\n\n;; impossible in 12s without knowing the formulae\n;; https:\/\/invidious.snopyta.org\/watch?v=hwqX1ctwYd8&local\n\n(defn calc-n [v]\n  (\/ (dec (Math\/sqrt\n           (* 8\n              (inc (Math\/sqrt v)))))\n     2))\n\n(defn calc-v [n]\n  (let [n (bigint n)\n        sqr #(* % %)]\n    (\/ (* (sqr n) (sqr (inc n)))\n       4)))\n\n(defn find_nb [m]\n  (let [n (calc-n m)]\n    (if (= m (calc-v n)) (bigint n) -1)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16130,"user_id":null,"body":"(ns sumofcubes.core)\n\n(defn find_nbR [m tmp n]\n  (if \n    (<= m tmp) \n    (if (= m tmp) (dec n) -1)\n    (recur m (+ tmp (* n n n)) (inc n))))\n\n(defn find_nb [m]\n  (find_nbR m 0N 1N))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16131,"user_id":62,"body":"(ns sumofcubes.core)\n\n\n(defn untriangle \n  \"If x is the nth triangular number, return n. \n  Otherwise, if x is between the nth and (n+1)th triangular numbers, \n  return a fraction between n and n+1.\"\n  \n  [x]\n  (\/ (dec (Math\/sqrt (inc (* 8 x))) ) 2))\n\n(defn whole? \"Is the fractional part of x equal to zero?\" \n  [x] (zero? (mod x 1)))\n\n(defn integer-sqrt [x]\n    \"If x is a perfect square, return sqrt(x). Otherwise, return nil.\"\n      (let [root (bigint (Math\/sqrt x))] \n      (loop [k root, k\u00b2 (* root root)]\n      \t    (cond (= k\u00b2 x) k\n\t    \t  (> k\u00b2 x) nil\n\t\t  :else (recur (inc k) (* (inc k) (inc k)))))))\n\n(defn find_nb [m]\n  (if-let [root (integer-sqrt m)]\n      (let [solution (untriangle root)]\n        (if (whole? solution) (int solution) -1))\n    -1))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16132,"user_id":null,"body":"(ns sumofcubes.core)\n\n(defn find_nb [m]\n  (reduce (fn [sum n] \n            (cond \n              (zero? sum) (reduced (dec n))\n              (< sum 0) (reduced -1)\n              :else (- sum (*' n n n)))) m (range)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"559536379512a64472000053":[{"id":16133,"user_id":null,"body":"(ns playpass.core)\n\n(defn recoder [n]\n  (fn [i ch]\n    (char (let [asc (int ch)] (cond\n      (<= 65 asc 90) (+ (mod (- asc 65 (- n)) 26) (if (even? i) 65 97))\n      (<= 48 asc 57) (- 105 asc)\n      :else asc )))))\n  \n(defn play_pass [s n]\n  (apply str (reverse (map-indexed (recoder n) s))) )\n","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-27 17:46:30"},{"id":16134,"user_id":null,"body":"(ns playpass.core\n  (:require [clojure.string :as s]))\n\n(def ZERO (int \\0))\n(def NINE (int \\9))\n(def Z (int \\Z))\n(def A (int \\A))\n(def start-shift (- Z (- A 1)))\n\n(defn is-char? [c] (let [code (int c)] (and (>= code A) (<= code Z))))\n\n(defn is-num? [n] (let [code (int n)] (and (>= code ZERO) (<= code NINE))))\n\n(defn shift [n c]\n  (let [code (+ n (int c))\n        code (if (> code Z) (- code start-shift) code)]\n    (char code)))\n\n(defn compl [n] (- 9 (Integer\/parseInt (str n))))\n\n(defn play_pass [pass shift-by]\n  (->> pass\n       (map #(cond (is-char? %) (shift shift-by %) (is-num? %) (compl %) :else %))\n       (map str)\n       (map-indexed (fn [i c] (if (odd? i) (s\/lower-case c) (s\/upper-case c))))\n       (reverse)\n       (apply str)))\n       ","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-27 17:46:36"},{"id":16135,"user_id":null,"body":"(ns playpass.core\n  (:require [clojure.string :as str]))\n\n(defn play_pass [s n]\n  (let [abs #(max % (- %))\n        ch+ (fn [ch num base max] (-> ch int (- base) (+ num) abs (mod max) (+ base) char))\n        map-fn (fn [idx x]\n                  (cond-> x\n                    (Character\/isLetter x) (ch+ n (int \\A) 26)\n                    (re-matches #\"[0-9]\" (str x)) (ch+ -9 (int \\0) 10)\n                    (odd? idx) (str\/lower-case)))]\n        (apply str (reverse (map-indexed map-fn s)))))\n","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-27 17:46:42"},{"id":16136,"user_id":null,"body":"(ns playpass.core\n  (:require [clojure.string :as st]))\n  \n(defn play [min max to-move to-cal]\n  (let [imax (int max)\n        imin (int min)\n        gap (inc (- imax imin))]\n    (char (+ imin\n             (mod (- (+ to-move (int to-cal)) imin)\n                  gap))))\n)\n\n(defn play_pass [s n]\n  (->> (into [] s)\n       (map-indexed #(let [ch (cond (<= (int \\a) (int %2) (int \\z)) (play \\a \\z n %2)\n                                    (<= (int \\A) (int %2) (int \\Z)) (play \\A \\Z n %2)\n                                    (<= (int \\0) (int %2) (int \\9)) (str (- 9 (Character\/digit %2 10)))\n                                    :else %2)]\n                       (if (even? %1)\n                         (st\/upper-case ch)\n                         (st\/lower-case ch))))\n       (reverse)\n       (st\/join)))\n","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-27 17:47:19"},{"id":16137,"user_id":492,"body":"(ns playpass.core)\n\n(defn change-char [s n]\n  (map (fn [x]\n         (if (and (>= (int x) (int \\A)) (<= (int x) (int \\Z)))\n           (char (+ (mod (+ n (- (int x) (int \\A))) 26) (int \\A)))\n           (if (and (>= (int x) (int \\0)) (<= (int x) (int \\9)))\n             (char (- 105 (int x)))\n             x)))\n         s))\n\n(defn mix [s]\n  (map-indexed (fn [idx item] \n                 (if (odd? idx)\n                   (clojure.string\/lower-case item)\n                   item)) s))\n\n(defn play_pass [s n]\n  (apply str (reverse (mix (change-char s n)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16138,"user_id":null,"body":"(ns playpass.core)\n\n(def alphabet \"abcdefghijklmnopqrstuvwxyz\")\n(def numbers \"0123456789\")\n\n(defn dic-shifted [n base] \n  (concat \n    (drop n base)\n    (take n base)))\n\n(defn create-dic [n base values] \n  (zipmap (map char base) values))\n\n(defn play_pass [s n] \n  (let [cad (clojure.string\/lower-case s) \n        dic (merge \n              (create-dic n alphabet (dic-shifted n alphabet))\n              (create-dic 0 numbers (clojure.string\/reverse numbers))) ]\n    (clojure.string\/reverse\n      (apply str\n        (map (fn [[chr idx]] (if (even? idx) (clojure.string\/upper-case chr) chr))\n          (map vector\n              (map #(if (contains? dic %) (get dic %) %) cad) (range)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16139,"user_id":null,"body":"(ns playpass.core\n    (:require [clojure.string :as str]))\n\n(defn encode-letter [letter n]\n  (-> letter int (- 65) (+ n) (mod 26) (+ 65) char))\n\n(defn encode-number [number]\n  (->> number int (- 48) (+ 9) (+ 48) char))\n\n(defn encode-by-idx [s]\n  (let [lc-odd-idx #(if (odd? %1)\n                      (str\/lower-case %2)\n                      %2)]\n    (apply str (keep-indexed lc-odd-idx s))))\n\n(defn play_pass [s n]\n  (-> s\n      (str\/replace #\"([A-Z])\" #(str (encode-letter (ffirst %) n)))\n      (str\/replace #\"([0-9])\" #(str (encode-number (ffirst %))))\n      encode-by-idx\n      str\/reverse))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16140,"user_id":null,"body":"(ns playpass.core)\n\n(defn rot-n [c n]\n  (char (+ (mod (+ (int c) n (- 65)) 26) 65)))\n\n(defn play_pass [s n]\n  (->> s\n    (seq)\n    (map #(if (Character\/isLetter %1) (rot-n %1 n) %1))\n    (map #(if (Character\/isDigit %1) (char (+ 105 (- (int %1)))) %1))\n    (map-indexed #(if (and (odd? %1) (Character\/isLetter %2)) (Character\/toLowerCase %2) %2))\n    (reverse)\n    (apply str)\n    ))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16141,"user_id":62,"body":"(ns playpass.core)\n\n(def alphabet \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n\n\n(def shift-1 \n  \"A hash map associating each letter \n  with its cyclic successor: A->B, a->b, Z->A, etc.\"\n  (apply merge\n         (for [letters [alphabet (.toLowerCase alphabet)]]\n           (zipmap letters (concat (rest letters) (take 1 letters))))))\n  \n(defn shift [n s]\n  (nth (iterate (partial replace shift-1) s) n))\n\n(defn play_pass [s n]\n  (let [cipher\n        (merge (zipmap (keys shift-1) (shift n (keys shift-1))) ;; letters\n               (zipmap \"0123456789\" \"9876543210\")) ;; numbers\n        ]\n    (apply str\n           (reverse\n           (map-indexed\n            (comp (partial apply str)\n                  (partial replace cipher)  \n                  #(if (odd? %1) (.toLowerCase %2) (.toUpperCase %2)))\n            (map str s))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16142,"user_id":null,"body":"(ns playpass.core)\n\n(defn rot [character level]\n  (Character\/toString (char (+ (mod (- (+ (int (first (char-array character))) level) 65) 26) 65)))\n  )\n\n(defn complement-to-9 [number]\n  (Integer\/toString (- 9 (Integer\/parseInt number)))\n  )\n\n(defn encode-char [character level]\n  (let [char (first (char-array character))]\n    (if (Character\/isLetter char)\n      (rot character level)\n      (if (Character\/isDigit char)\n        (complement-to-9 character)\n        character\n        )\n      ))\n  )\n\n(defn encode\n  ([phrase level] (encode '[] level (clojure.string\/split phrase #\"\")))\n  ([encoded level other]\n   (if (empty? other)\n     encoded\n     (recur (conj encoded (encode-char (first other) level)) level (rest other))\n     )\n   )\n  )\n\n(defn update-case [letter index]\n  (if (even? index)\n    (clojure.string\/lower-case letter)\n    letter\n    )\n  )\n\n(defn sponge-bob-case\n  ([phrase] (sponge-bob-case '[] phrase 1))\n  ([changed phrase index]\n   (if (empty? phrase)\n     changed\n     (recur (conj changed (update-case (first phrase) index)) (rest phrase) (inc index))\n     )\n   )\n  )\n\n(defn play_pass [s n]\n  (clojure.string\/join (reverse (sponge-bob-case (encode (clojure.string\/upper-case s) n))))\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5596f6e9529e9ab6fb000014":[{"id":16143,"user_id":null,"body":"(ns string-rotation)\n\n(defn shifted_diff [first second]\n  (if (= (count first) (count second))\n    (.indexOf (str second second) first) -1 ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16144,"user_id":527,"body":"(ns string-rotation)\n\n(defn shifted_diff [^String first ^String second]\n  (let [second2 (.concat second second)]\n    (if (= (.length first) (.length second)) (.indexOf second2 first) -1)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16145,"user_id":null,"body":"(ns string-rotation)\n\n(defn rotate [strng]\n  (apply str (conj (butlast strng) (last strng))))\n\n(defn shifted_diff [first second]\n  (let [rotate-first (take (count first) (iterate rotate first))\n        map-str (into {} (map-indexed #(vector %2 %) rotate-first))]\n    (map-str second -1)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16146,"user_id":527,"body":"(ns string-rotation)\n\n(defn shifted_diff [^String first ^String second]\n  (if (= (.length first) (.length second))\n    (.indexOf (.concat second second) first)\n    -1))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16147,"user_id":null,"body":"(ns string-rotation)\n\n(defn rotate [rotations rotating-word word]\n  (cond\n    (= rotating-word word) rotations\n    (= rotations (count word)) -1\n    :else (rotate\n           (inc rotations)\n           (str\n            (last rotating-word)\n            (clojure.string\/join \"\" (drop-last rotating-word)))\n           word)))\n\n(defn shifted_diff [first second]\n  (rotate 0 first second))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16148,"user_id":53,"body":"(ns string-rotation)\n(use '[clojure.string :only [index-of]])\n\n(defn shifted_diff [a b]\n  (if (not= (count a) (count b))\n    -1\n    (let [i (index-of (str b b) a)]\n      (if (nil? i)\n        -1\n        i))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16149,"user_id":null,"body":"(ns string-rotation)\n\n(defn shifted_diff [first second]\n  (if (not (= (.length first) (.length second))) \n    -1 \n    (.indexOf (str second second) first)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16150,"user_id":null,"body":"(ns string-rotation)\n\n(defn shifted_diff [first second]\n  (let [strlen (count first)\n        iterations (loop [giv first\n                          iterations 0]\n                     (if (or (= giv second)\n                             (> iterations strlen))\n                       iterations\n                       (recur (apply str (cons (last giv) (drop-last giv))) (inc iterations))))]\n    (if (> iterations strlen)\n      -1\n      iterations)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16151,"user_id":null,"body":"(ns string-rotation)\n\n(defn str-rot [s]\n  (str (last s) (subs s 0 (dec (count s)))))\n\n(defn shifted_diff [a b]\n  (if (= (set a) (set b))\n    (loop [s a i 0]\n      (cond\n        (= s b) i\n        (>= i (count s)) -1\n        :else (recur (str-rot s) (inc i))))\n    -1))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16152,"user_id":null,"body":"(ns string-rotation)\n\n(defn rotate-word [s]\n  (str (last s) (subs s 0 (dec (.length s))))\n  )\n\n(defn shifted_diff\n  ([first second]\n   (shifted_diff first second 0))\n  ([first second rotation-count]\n   (cond\n     (> rotation-count (.length first)) -1\n     (= first second) rotation-count\n     :else (shifted_diff (rotate-word first) second (inc rotation-count)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"559a28007caad2ac4e000083":[{"id":16153,"user_id":null,"body":"(ns perimeter.core)\n\n(defn fib  [a b]  (lazy-seq (cons a (fib b (bigint (+ b a))))))\n\n(defn perimeter  [n]\n  (* 4 (apply + (take (+ n 1) (fib 1 1)))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16154,"user_id":564,"body":"(ns perimeter.core)\n\n(defn perimeter [n]\n  (loop [n n a 1N b 1N sum 0N]\n    (if (< n 0)\n      (* sum 4N)\n      (recur (dec n) b (+ a b) (+ sum a)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16155,"user_id":null,"body":"(ns perimeter.core)\n\n(def fibs\n  (lazy-cat [0N 1N] (map + fibs (rest fibs))))\n\n(defn perimeter [n]\n  (* 4 (apply + (take (+ n 2) fibs))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16156,"user_id":null,"body":"(ns perimeter.core)\n\n(defn fibo [a b] (lazy-seq (cons a (fibo b (+ a b)))))\n\n(defn perimeter [n]\n  (->> (fibo 1N 1N)\n       (take (inc n))\n       (reduce +)\n       (* 4)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16157,"user_id":492,"body":"(ns perimeter.core)\n\n(defn fib [n]\n  (letfn [(aux [current next n]\n            (if (zero? n)\n              current\n              (recur next (+ current next) (dec n))))]\n    (aux 1N 1N n)))\n\n(defn perimeter [n]\n  (* 4 (- (fib (+ n 2)) 1)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16158,"user_id":null,"body":"(ns perimeter.core)\n\n(defn perimeter\n  [n]\n  (->> (iterate (fn [[a b]] [b (+' a b)]) [1 1])\n       (map first)\n       (take (inc n))\n       (apply +')\n       (* 4)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16159,"user_id":null,"body":"(ns perimeter.core)\n\n(defn perimeter [n]\n  (loop [curr 1\n         prev 0 \n         i 0\n         acc 0]\n    (if (> i n) acc\n        (recur (+' curr prev)\n               curr\n               (inc i)\n               (+' acc (*' 4 curr))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16160,"user_id":571,"body":"(ns perimeter.core)\n\n(defn perimeter [n]\n  (* 4 (reduce + (take (+ 1 n) (map first (iterate (fn [[a b]] [b (+ a b)]) [1N 1N])))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16161,"user_id":null,"body":"(ns perimeter.core)\n\n(defn perimeter [n]\n  (cond\n    (< n 0) (throw (Exception. \"Invalid input!\"))\n    (= n 0) (* 1 4)\n    (= n 1) (* 2 4)\n    :else\n      ; n >= 2\n      (loop [sn1 1 sn2 1 x 2 sum 2]\n        (let [sn (bigint (+ sn1 sn2))]\n          (if (= x n)\n            (* (+ sum sn) 4)\n            (recur sn sn1 (inc x) (+ sn sum))\n            )\n          )\n        )\n    )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16162,"user_id":null,"body":"(ns perimeter.core)\n\n(def fib (map first (iterate (fn [[a b]] [b (+' a b)]) [4 4])))\n\n(defn perimeter [n]\n  (reduce +' 0 (take (inc n) fib)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"559aa1295f5c38fd7b0000ac":[{"id":16163,"user_id":null,"body":"(ns kata.routes-calculator)\n\n; Calculating the (n+1)'th number in the n'th-grade arithmetic progression\n; = (n+1)(n+2)...(n+n)\/n!\n\n(defn routes [n]\n  (if (pos? n) (reduce * (map #(\/ (+ n %) %) (range 1 (inc n)))) 0) )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16164,"user_id":53,"body":"(ns kata.routes-calculator)\n\n(defn fac [n] (if (> n 1) (reduce * (range 2N (inc n))) 1))\n(defn routes [n] (if (<= n 0) 0 (let [m (fac n)] (\/ (fac (* 2 n)) (* m m)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16165,"user_id":null,"body":"(ns kata.routes-calculator)\n\n(defn factorial [n]\n  (apply *' (range 1 (inc n))))\n\n(defn routes [n]\n  (if (neg? n) 0\n    (\/ (factorial (*' 2 n))\n       (*' (factorial n) (factorial (- (*' 2 n) n))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16166,"user_id":null,"body":"(ns kata.routes-calculator)\n\n(defn fact [x]\n  (apply * (range 1N (inc x))))\n\n(defn routes [n]\n  (let [factn (fact n)]\n    (if (pos? n) (\/ (fact (* 2 n)) factn factn) 0)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16167,"user_id":null,"body":"(ns kata.routes-calculator)\n\n(defn routes [n]\n  (if (< n 1)\n    0\n    (reduce * 2 (map \/ (range (inc n) (+ n n)) (range 1 n))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16168,"user_id":1670,"body":"(ns kata.routes-calculator)\n\n(defn routes [n]\n  (cond (< n 1) 0\n   :else\n      ( \/\n        (reduce *' (range 1 (+ n n 1)))\n        (*' \n          (reduce *' (range 1 (inc n)))\n          (reduce *' (range 1 (inc n)))\n        )\n      )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16169,"user_id":null,"body":"(ns kata.routes-calculator)\n\n(defn routes [n]\n  (if (< n 1) \n      0\n      (let [fac #(apply *' (range 1 (inc %)))\n            k n\n            n (* 2 n)]\n           (\/ (fac n) (*' (fac k) (fac (- n k)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16170,"user_id":null,"body":"(ns kata.routes-calculator)\n\n(defn factorial [i]\n  (reduce *' (range 1 (+ i 1))))\n\n(defn routes [n]\n  (if (< n 1)\n    0\n    (\/ (factorial (* 2 n))\n       (factorial n)\n       (factorial n))))\n ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16171,"user_id":null,"body":"(ns kata.routes-calculator)\n\n(defn routes [n]\n  (if (< n 1)\n    0\n    (\/ (reduce *' (range (inc n) (inc (* 2 n)))) (reduce *' (range 1 (inc n))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16172,"user_id":null,"body":"(ns kata.routes-calculator)\n\n(defn binom [n k]\n  (let [prod (fn [a b] (reduce *' (range a (inc b))))]\n    (\/ (prod (- n k -1) n) (prod 1 k))))\n\n(defn routes [n]\n  (if (>= n 0)\n    (binom (* 2 n) n)\n    0))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"559b8e46fa060b2c6a0000bf":[{"id":16173,"user_id":null,"body":"(ns choose1.core)\n\n(defn- binomial [n k]\n  \"Compute the binomial coefficient n choose k with automatic promotion to BigInt\"\n  (let [rprod (fn [x y] (reduce *' (range x (inc y))))]\n    (\/ (rprod (- n k -1) n) (rprod 1 k))))\n\n(defn diagonal [n p]\n  \"The sum of a diagonal in Pascal's Triangle is the value at the (inc n), (inc p) location\"\n  (binomial (inc n) (inc p)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16174,"user_id":null,"body":"(ns choose1.core)\n\n(defn- f [n i]\n  (-> (- n i)\n    inc\n    (\/ (inc i))))  \n  \n  \n  \n(defn diagonal [n p]\n  (->> p\n    inc\n    range\n    (map (partial f n))\n    (apply *')))\n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16175,"user_id":null,"body":"(ns choose1.core)\n\n\n(defn- n-to-r-prod [n r]\n  (reduce *' (range n (inc r))))\n\n(defn- factorial [r]\n  (n-to-r-prod 1 r))\n\n(defn- binomial [n r]\n  (\/ (n-to-r-prod (- n r -1) n)\n     (factorial r)))\n\n(defn diagonal [n p]\n  (binomial (inc n) (inc p)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16176,"user_id":null,"body":"(ns choose1.core)\n\n(defn fact\n  ; Your standard factorial function\n  ([n] (reduce *' (range 2 (inc' n))))\n  ; Helper factorial function with optimizing for division\n  ([n r] (reduce *' (range r (inc' n)))))\n(defn cmb [n r] \n  (if (< r (-' n r))\n    (cmb n (-' n r))\n    (\/ (fact n (inc' r))\n       (fact (-' n r)))))\n\n(defn diagonal [n p]\n  (reduce +' (map #(cmb % p) (range p (inc n)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16177,"user_id":492,"body":"(ns choose1.core)\n\n(defn choose [n p]\n  (let [rprod (fn [a b] (reduce * (range (biginteger a) (inc (biginteger b)))))]\n    (\/ (rprod (- n p -1) n) (rprod 1 p))))\n\n(defn diagonal [n p]\n  (choose (inc n) (inc p)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16178,"user_id":53,"body":"(ns choose1.core)\n\n(defn chooze [n k]\n  (loop [i 1 res 1N]\n    (if (= i (inc k))\n      res\n      (recur (inc i) (* res (\/ (+ (- n i) 1) i)))))\n  )\n\n(defn diagonal [n p]\n  (chooze (inc n) (inc p))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16179,"user_id":null,"body":"(ns choose1.core)\n\n(defn diagonal [n p]\n  (apply + (reductions #(* % (\/ (+ p %2) %2)) 1N (range 1 (- n p -1)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16180,"user_id":null,"body":"(ns choose1.core)\n\n(def pascals-diags\n  (iterate (partial reductions +') (repeat 1)))\n\n(defn diagonal [n p]\n  (-> pascals-diags (nth (inc p)) (nth (- n p))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16181,"user_id":null,"body":"(ns choose1.core)\n\n(def pascals-diags\n  (iterate (partial reductions +') (repeat 1)))\n\n(defn diagonal [n p]\n  (reduce +' 0 (take (inc (- n p)) (nth pascals-diags p))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16182,"user_id":null,"body":"(ns choose1.core)\n\n(defn pale\n  [n p]\n  (let [p (min p (-' n p))]\n    (reduce\n      #(-> %1 (*' (-' n %2)) (\/ (inc %2)))\n      1\n      (range p))))\n\n(defn diagonal\n  [n p]\n  (reduce\n    +'\n    0\n    (map (partial pale n)\n         (range (max 0 p) (+' p 2)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"559ce00b70041bc7b600013d":[{"id":16183,"user_id":492,"body":"(ns finance.core)\n\n(defn finance [n]\n  (\/ (+ (* n n n) (* 3 n n) (* 2 n)) 2))\n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16184,"user_id":null,"body":"(ns finance.core)\n\n(defn finance [n]\n  (\/ (* n (+ n 1) (+ n 2)) 2))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16185,"user_id":2574,"body":"(ns finance.core)\n\n(defn finance [n] (\/ (* (* n (+ n 1)) (+ n 2)) 2))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16186,"user_id":null,"body":"(ns finance.core)\n\n(defn finance [n]\n  (reduce\n    (fn [v x]\n      (-> (min x (- (* n 2) x)) (quot 2) inc (* x) (+ v)))\n    (range (inc (* n 2)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16187,"user_id":null,"body":"(ns finance.core)\n\n(defn finance [n]\n  (reduce + (map first (take (inc n) (iterate (fn [[a b]] [(+ a b) (+ b 3)]) [0 3])))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16188,"user_id":null,"body":"(ns finance.core)\n\n(defn finance [n]\n\n  (loop [i 0 s 0 prev 0]\n\n    (cond\n\n      (> i n) s\n\n      :else (recur (inc i) (+ s prev) (+ prev 3 (* 3 i))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16189,"user_id":53,"body":"(ns finance.core)\n\n(defn finance [n]\n  (\/ (* (* (+ n 2) (+ n 1)) n) 2))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16190,"user_id":null,"body":"(ns finance.core)\n\n(defn finance [n]\n  (let [nums (loop [i 1\n                    total 0\n                    result []]\n               (if (= i (inc n))\n                 result\n                 (recur (inc i) (+ total (* i 3)) (concat [(+ total (* i 3))] result))))]\n    (reduce + nums)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16191,"user_id":null,"body":"(ns finance.core)\n(defn calc_summation [n]\n  (\/ (* (+ n (* 2 n)) (+ n 1)) 2)\n)\n\n(defn finance [n]\n(loop [cnt n\n           acc 0]\n       (if (zero? cnt)  \n           acc \n          (recur (dec cnt) (+ acc (calc_summation cnt)))\n        )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16192,"user_id":null,"body":"(ns finance.core)\n\n(defn ps [n]\n  (\/ (* n (inc n)) 2))\n\n(defn finance [n]\n  (->>\n    (range 0 (inc n))\n    (map #(- (ps (* 2 %)) (ps (dec %))))\n    (reduce +)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"559e3224324a2b6e66000046":[{"id":16193,"user_id":492,"body":"(ns funcij.core)\n\n(defn sumin [n]\n  (\/ (* n (inc n) (+ 1 (* 2 n))) 6))\n\n(defn sumax [n]\n  (\/ (* n (inc n) (- (* 4 n) 1)) 6))\n\n(defn sumsum [n]\n  (* n n (inc n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16194,"user_id":53,"body":"(ns funcij.core)\n\n(defn sumin [n](quot (* n (inc n) (inc (* 2 n))) 6))\n(defn sumax [n](quot (* n (inc n) (dec (* 4 n))) 6))\n(defn sumsum [n](* n n (inc n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16195,"user_id":null,"body":"(ns funcij.core)\n\n(defn sqr [x] (* x x))\n\n(defn sumin [n]\n  (loop [sum 0 square-size n]\n    (let [ num (inc (- n square-size)) side-total (* num square-size) ]\n      (if (< square-size 1)\n        sum\n        (recur (+ sum (- (* side-total 2) num)) (dec square-size))\n      )\n    )\n  )\n)\n\n(defn sumax [n]\n  (loop [sum 0 square-size n]\n    (if (< square-size 1)\n      sum\n      (recur (+ sum (- (* 2 (sqr square-size)) square-size)) (dec square-size))\n    )\n  )\n)\n\n(defn sumsum [n]\n  (+ (sumin n) (sumax n))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16196,"user_id":null,"body":"(ns funcij.core)\n\n\n(defn cartesian [n f]\n  (apply + (mapcat (fn [x] (map (fn [y] (f x y))\n                                (range 1 (inc n))))\n                   (range 1 (inc n)))))\n\n(defn sumin [n]\n  (cartesian n min))\n\n(defn sumax [n]\n  (cartesian n max))\n\n(defn sumsum [n]\n  (cartesian n +))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16197,"user_id":null,"body":"(ns funcij.core)\n\n(defn sumin [n]\n  (\/ (* n (+ n 1) (+ (* 2 n) 1)) 6))\n\n(defn sumax [n]\n  (\/ (* n (+ n 1) (- (* 4 n) 1)) 6))\n\n(defn sumsum [n]\n  (* n n (+ n 1)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16198,"user_id":null,"body":"(ns funcij.core)\n\n(defn sumin [n]\n  (-\n    (\/ (* n n (inc n)) 2)\n    (->>\n      (for [i (range n)]\n        (\/ (* (- n i) (- (dec n) i)) 2))\n      (reduce + 0))))\n\n(defn sumax [n]\n  (+\n    (\/ (* n n (inc n)) 2)\n    (->>\n      (for [i (range n)]\n        (\/ (* (- n i) (- (dec n) i)) 2))\n      (reduce + 0))))\n\n(defn sumsum [n]\n  (* n n (inc n)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16199,"user_id":null,"body":"(ns funcij.core)\n\n(defn combine-multipliers-and-numbers [multipliers numbers]\n  (->> (map vector multipliers numbers)\n       (map #(* (first %) (second %)))\n       (reduce +)))\n\n(defn sumin [n]\n  (let [multipliers (reverse (range 1 (* 2 n) 2))\n        numbers (range 1 (inc n))]\n    (combine-multipliers-and-numbers multipliers numbers)))\n\n(defn sumax [n]\n  (let [multipliers (range 1 (* 2 n) 2)\n        numbers (range 1 (inc n))]\n    (combine-multipliers-and-numbers multipliers numbers)))\n\n(defn sumsum [n]\n  (let [multipliers (concat (range 1 (inc n)) (reverse (range 1 n)))\n        numbers (range 2 (inc (* 2 n)))]\n    (combine-multipliers-and-numbers multipliers numbers)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16200,"user_id":null,"body":"(ns funcij.core)\n\n(defn sumin [n]\n  (loop [acc 0 i 1 n n]\n    (if (zero? n)\n      acc\n      (recur (+ acc (* i n)) (+ 2 i) (dec n)))))\n\n(defn sumax [n]\n  (loop [acc 0\n         i (dec (* n 2))\n         n n]\n    (if (neg? i)\n      acc\n      (recur (+ acc (* i n)) (- i 2) (dec n)))))\n\n(defn sumsum [n]\n  (+ (sumax n) (sumin n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16201,"user_id":null,"body":"(ns funcij.core)\n\n(defn sumin [n]\n  (quot (* n (inc n) (+ n n 1)) 6)\n)\n\n(defn sumax [n]\n  (quot (* n (inc n) (dec (* 4 n))) 6)\n)\n\n(defn sumsum [n]\n  (* n n (inc n))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16202,"user_id":null,"body":"(ns funcij.core)\n\n(defn sumin [n]\n  (- \n     (* (reduce + (range 1 (inc n))) n) \n     (quot (* (* (dec n) n) (inc n)) 6)\n  )\n)\n\n(defn sumax [n]\n  (+ \n    (* (reduce + (range 1 (inc n))) n) \n    (quot (* (* (dec n) n) (inc n)) 6)\n  )\n)\n\n(defn sumsum [n]\n  (+ \n    (* (reduce + (range 2 (+ n 2))) n) \n    (* (quot (* (dec n) n) 2) n)\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55a29405bc7d2efaff00007c":[{"id":16203,"user_id":null,"body":"(ns suite1.core)\n\n(defn going[n]\n  (let [summation (reduce + (map \/ (reductions * (range n 1 -1.0))))]\n    (-> (inc summation) (* 1e6) Math\/floor (\/ 1e6))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16204,"user_id":null,"body":"(ns suite1.core)\n\n(defn fact [n]\n  (reduce *' (range 1 (inc n))))\n\n(defn row\n  ([] (row 1N 1))\n  ([value index] (cons value (lazy-seq (row (* value (inc index)) (inc index))))))\n\n(defn round [n]\n  (double (with-precision 7 :rounding DOWN (bigdec n))))\n\n(defn going [n]\n  (round (\/ (apply + (take n (row))) (fact n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16205,"user_id":492,"body":"(ns suite1.core)\n\n(defn going[n]\n  (loop [i n iter 1.0 res 1.0]\n    ;(println i iter res)\n    (if (= i 1)\n      (\/ (Math\/floor (* res (Math\/pow 10 6))) (Math\/pow 10 6))\n           (let [it (* iter (\/ 1 i))]\n             (recur (dec i) it (+ res it))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16206,"user_id":492,"body":"(ns suite1.core)\n\n(defn going[n]\n  (loop [i n iter 1.0 res 1.0]\n    ;(println i iter res)\n    (if (= i 1)\n      (\/ (Math\/floor (* res (Math\/pow 10 6))) (Math\/pow 10 6))\n           (let [it (* iter (\/ 1 i))]\n             (recur (dec i) it (+ res it))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16207,"user_id":null,"body":"(ns suite1.core)\n\n(defn fact [n m prod]\n  (if (> m 0)\n    (recur (dec n) (dec m) (* prod n))\n    prod))\n\n(defn expr [n cnt sum sum-prev]\n  (if (and (> cnt 0) (> (- sum sum-prev) 1e-6))\n     (recur n (dec cnt) (+ sum (\/ 1 (fact n (- n cnt) 1))) sum)\n     sum))\n\n(defn trunc-6 [n]\n  (let [s (format \"%.8f\" (read-string (str n)))]\n    (read-string (subs s 0 (- (count s) 2))))\n  )\n\n(defn going[n]\n  (trunc-6 (double (expr n n 0 -1))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16208,"user_id":null,"body":"(ns suite1.core)\n\n;;(defn truncate-to [n x]\n;;  \"\u230ax * 10\u207f\u230b * 10\u207b\u207f\"\n;;  (* (Math\/floor (* x (Math\/pow 10 n))) (Math\/pow 10 (- n))))\n\n(defn \u2211 [a b f]\n  (apply +' (map f (range a (inc b)))))\n\n(def factorial \n  (memoize \n   (fn [n]\n     (if (zero? n)\n       1\n       (*' (factorial (dec n)) n)))))\n\n(defn factorial-sum [n]\n  (\u2211 1 n factorial))\n\n(defn going [n]\n  (* 1.0 (with-precision 7 :rounding FLOOR (bigdec (\/ (factorial-sum n) (factorial n))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16209,"user_id":null,"body":"(ns suite1.core)\n\n(defn going[n]\n  (loop [acc 1 x (dec n) y (\/ 1 n)]\n    (if (or (< y 0.0000001) (zero? x))\n        (double (with-precision 7 :rounding FLOOR (* 1M acc)))\n        (recur (+ acc y) (dec x) (\/ y x)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16210,"user_id":null,"body":"(ns suite1.core)\n(require '[clojure.string :as string])\n\n(defn factorials\n  ([]\n   (map first (factorials 1 2)))\n  ([product counter]\n   (cons [product counter]\n         (lazy-seq (factorials (*' product counter) (inc counter))))))\n\n(defn factorial\n  [n]\n  (nth (factorials) (- n 1)))\n\n(defn truncate [number]\n  (Double\/parseDouble (string\/join (take 8 (str number))))\n  )\n\n(defn going[n]\n  (truncate (double (* (\/ 1 (factorial n)) (reduce + (take n (factorials))))))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16211,"user_id":null,"body":"(ns suite1.core)\n(require '[clojure.string :as string])\n\n(defn factorials\n  ([]\n   (map first (factorials 1 2)))\n  ([product counter]\n   (cons [product counter]\n         (lazy-seq (factorials (*' product counter) (inc counter))))))\n\n(defn factorial\n  [n]\n  (nth (factorials) (- n 1)))\n\n(defn truncate [number]\n  (Double\/parseDouble (string\/join (take 8 (str number))))\n  )\n\n(defn going[n]\n  (truncate (double (* (\/ 1 (factorial n)) (reduce + (take n (factorials))))))\n  )\n\n;(defn going[n]\n;  (Double\/parseDouble (string\/join (take 8 (str (* (\/ 1.0 (factorial n)) (reduce + (map factorial (range 1 (inc n)))))))))\n;  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16212,"user_id":53,"body":"(ns suite1.core)\n\n(defn aux[n]\n  (loop [t 0.0 m 1.0 i n]\n    (if (zero? i)\n      t\n      (recur (+ t (\/ 1.0 m)) (* m i) (dec i)))))\n\n(defn going[n] (double (\/ (bigdec (bigint (* (bigdec (double (aux n))) 1000000))) 1000000)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55a70521798b14d4750000a4":[{"id":16213,"user_id":53,"body":"(ns kata)\n(defn greet [name] (format \"Hello, %s how are you doing today?\" name))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16214,"user_id":null,"body":"(ns kata)\n\n(def greet (partial format \"Hello, %s how are you doing today?\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16215,"user_id":null,"body":"(ns kata)\n\n(defn greet \n  [name]\n  (str \"Hello, \" name \" how are you doing today?\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16216,"user_id":1703,"body":"(ns kata)\n\n(defn greet [name]\n  (apply str (str \"Hello, \" name \" how are you doing today?\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16217,"user_id":null,"body":"(ns kata)\n\n(defn greet [name]\n  (-> (str \"Hello, \" name)\n      (str \" how are you doing today?\"))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16218,"user_id":null,"body":"(ns kata)\n\n(defn greet [name]\n  (str \"Hello, \" name \" how are you doing today?\"); your code here.\n  )\n\n(println (greet \"name\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16219,"user_id":null,"body":"(ns kata)\n\n(defn greet [name]\n  ; your code here.\n  (str \"Hello, \" name \" how are you doing today?\")\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16220,"user_id":null,"body":"(ns kata)\n\n(defn greet [name]\n  println (format \"Hello, %s how are you doing today?\" name)\n;  println (str \"Hello, \" name \" how are you doing today?\")\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16221,"user_id":null,"body":"(ns kata)\n\n(defn greet\n  \"Return a greeting string, with a custom name\"\n  [name]\n  (str \"Hello, \" name \" how are you doing today?\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16222,"user_id":null,"body":"(ns kata)\n\n(defn greet [name]\n  println (str \"Hello, \", name, \" how are you doing today?\")\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55a75e2d0803fea18f00009d":[{"id":16223,"user_id":null,"body":"(ns Slope)  \n\n(defn slope [[x1 y1 x2 y2]]\n  (let [dy (- y2 y1)\n        dx (- x2 x1)]\n   (if (= dx 0) \"undefined\" (str (\/ dy dx)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16224,"user_id":null,"body":"(ns Slope)  \n\n(defn slope [[x1 y1 x2 y2]]\n  (if (= x2 x1)\n    \"undefined\"\n    (str\n      (\/\n        (- y2 y1)\n        (- x2 x1)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16225,"user_id":null,"body":"(ns Slope)  \n\n(defn slope [v]\n  (let [[x1 y1 x2 y2] v]\n    (if (zero? (- x2 x1))\n        \"undefined\"\n        (str (\/ (- y2 y1) (- x2 x1))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16226,"user_id":null,"body":"(ns Slope)  \n\n(defn slope [[a b c d]]\n  (let [dy (- b d)\n        dx (- a c)]\n    (if (zero? dx)\n      \"undefined\"\n      (str (\/ dy dx)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16227,"user_id":null,"body":"(ns Slope)  \n\n(defn slope [[a, b, c, d]]\n  (if (= a c) \"undefined\" (str (\/ (- d b) (- c a))))\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16228,"user_id":null,"body":"(ns Slope)  \n\n(defn slope\n  [ps]\n  (->> ps\n       (partition 2)\n       reverse\n       (apply map -)\n       reverse\n       (#(if (zero? (second %))\n         \"undefined\"\n         (apply \/ %)))\n       str))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16229,"user_id":null,"body":"(ns Slope)  \n\n(defn slope [b]\n  (if (= (nth b 0) (nth b 2))\n    \"undefined\"\n    (str(\/ (- (nth b 3) (nth b 1)) (- (nth b 2) (nth b 0))) )))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16230,"user_id":null,"body":"(ns Slope)  \n\n(defn slope [v]\n  (let [y (- (nth v 3) (nth v 1))\n        x (- (nth v 2) (nth v 0))]\n    (if (== x 0)\n      \"undefined\"\n      (str (\/ y x))))\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16231,"user_id":1703,"body":"(ns Slope)  \n\n(defn slope [v](\n  cond\n    (= 0 (- (nth v 2) (nth v 0))) \"undefined\"\n                :else (str (\/ (- (nth v 3)(nth v 1) ) (- (nth v 2) (nth v 0))))\n  ))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16232,"user_id":null,"body":"(ns Slope)  \n\n(defn slope [v]\n  (if (= 0 (- (nth v 0) (nth v 2)))\n    \"undefined\"\n    (str (\/ (- (nth v 3) (nth v 1)) (- (nth v 2) (nth v 0)))))\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55a7de09273f6652b200002e":[{"id":16233,"user_id":null,"body":"(ns kata.lucas-numbers)\n\n(defn lucasnum [n]\n  ; Good Luck!\n  (let [op (if (< n 0) -' +')]\n  \t(loop [cnt (Math\/abs n)\n  \t\t\t\t n0  2\n    \t     n1\t (op 1)]\n  \t\t(if (= cnt 0)\n    \t\t\tn0\n        \t(recur (dec cnt) n1 (op n0 n1))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16234,"user_id":null,"body":"(ns kata.lucas-numbers)\n\n(defn lucasnum-pos [a b] (lazy-seq (cons a (lucasnum-pos b (+' b a)))))\n\n(defn lucasnum-neg [a b] (lazy-seq (cons a (lucasnum-neg b (-' a b)))))\n\n(defn lucasnum [n]\n  (if (neg? n)\n    (nth (lucasnum-neg 2 -1) (* -1 n))\n    (nth (lucasnum-pos 2 1) n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16235,"user_id":null,"body":"(ns kata.lucas-numbers)\n\n(defn- abs [n] (max n (-' n)))\n\n(def luc (lazy-cat [2N 1N] (map +' luc (rest luc))))\n\n(defn lucasnum [n]\n  (cond-> (->> n abs (nth luc)) (and (neg? n) (odd? n)) -))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16236,"user_id":null,"body":"(ns kata.lucas-numbers)\n\n(defn- abs [n] (max n (-' n)))\n\n(def luc (lazy-cat [2N 1N] (map +' luc (rest luc))))\n\n(defn lucasnum [n]\n  (cond-> (-> n abs (drop luc) first)\n    (and (neg? n) (odd? n)) -))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16237,"user_id":null,"body":"(ns kata.lucas-numbers)\n\n(def lucas-generator\n  ((fn lcs [a b]\n     (lazy-seq (cons a (lcs b (+' b a))))) 2 1))\n\n(defn lucasnum [n]\n  (let [res (first (drop (Math\/abs n) lucas-generator))]\n    (if (and (neg? n) (odd? (Math\/abs n)))\n        (- res)\n        res)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16238,"user_id":null,"body":"(ns kata.lucas-numbers)\n\n(defn lucasnum [n]\n  (def sq (lazy-cat [2N 1N] (map + (rest sq) sq)))\n  (* (if (and (neg? n) (odd? n)) -1 1) (nth sq (max n (- n)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16239,"user_id":464,"body":"(ns kata.lucas-numbers)\n\n(defn lucasnum [n]\n  (loop [prev 2 nxt 1 it n]\n    (if (= 0 it)\n      prev\n      (if (> n 0)\n        (recur nxt (+' prev nxt) (dec it))\n        (recur (-' nxt prev) prev (inc it))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16240,"user_id":null,"body":"(ns kata.lucas-numbers)\n(defn lucasnum [n] \n  (if (or (= n 0) (= n 1)) \n    (- 2 n)  \n    (do\n      (let [a (atom 2N) b (atom 1N) c (atom 0)]\n      (if (> n 1) \n        (dotimes [_ (dec n)]\n          (reset! c (+ @a @b)) (reset! a @b) (reset! b @c))\n        (dotimes [_ (- n)]\n          (reset! c (- @b @a)) (reset! b @a) (reset! a @c))) @c))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16241,"user_id":null,"body":"(ns kata.lucas-numbers)\n\n(def lucaspos\n  (cons 2 (cons 1 (lazy-seq (map +' lucaspos (rest lucaspos))))))\n\n(def lucasneg\n  (cons 1 (cons 2 (lazy-seq (map -' lucasneg (rest lucasneg))))))\n\n(defn lucasnum [n]\n  (if (neg? n)\n      (nth lucasneg (- 1 n))\n      (nth lucaspos n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16242,"user_id":null,"body":"(ns kata.lucas-numbers)\n\n(def lucas-numbers-iterate\n  (map first (iterate (fn [[n0 n1]] [n1 (+ n0 n1)]) [2N 1])))\n\n(defn lucasnum [n]\n  (let [ln (nth lucas-numbers-iterate (Math\/abs n))]\n    (if (< n 0)\n      (if (even? n)\n        ln\n        (- ln))        \n      ln)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55aa075506463dac6600010d":[{"id":16243,"user_id":null,"body":"(ns sumdivsq.core)\n\n(defn square?\n  [x]\n  (zero? (rem (Math\/sqrt x) 1)))\n    \n(defn divisors\n  [n]\n  (filter #(zero? (rem n %)) (range 1 (inc n))))\n    \n(defn list_squared [m n]\n  (keep\n    (fn [x]\n      (let [divs (divisors x)\n            divs-squared (map #(* % %) divs)\n            divs-squared-sum (reduce + divs-squared)]\n          (when (square? divs-squared-sum)\n            [x divs-squared-sum])))\n    (range m n)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16244,"user_id":492,"body":"(ns sumdivsq.core)\n\n(defn factors [n]\n  (into (sorted-set)\n    (reduce concat\n      (for [x (range 1 (inc (Math\/sqrt n))) :when (zero? (rem n x))]\n        [(* x x) (* (\/ n x) (\/ n x))]))))\n\n(defn sum-sq-factors [n]\n  (let [s (reduce + (vec (factors n))) r (int(Math\/sqrt s))]\n    (if (= s (* r r))\n      [n s]\n      nil)))\n\n(defn list_squared [m n]\n  (vec (remove nil? (map sum-sq-factors (range m n)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16245,"user_id":492,"body":"(ns sumdivsq.core)\n\n(defn factors [n]\n  (into (sorted-set)\n    (reduce concat\n      (for [x (range 1 (inc (Math\/sqrt n))) :when (zero? (rem n x))]\n        [(* x x) (* (\/ n x) (\/ n x))]))))\n\n(defn sum-sq-factors [n]\n  (let [s (reduce + (vec (factors n))) r (int(Math\/sqrt s))]\n    (if (= s (* r r))\n      [n s]\n      nil)))\n\n(defn list_squared [m n]\n  (vec (remove nil? (map sum-sq-factors (range m n)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16246,"user_id":null,"body":"(ns sumdivsq.core)\n\n(defn square? [n]\n  (let [root (int (Math\/sqrt n))]\n    (= (* root root) n)))\n\n(defn divisors [n]\n  (loop [d 1 divs []]\n    (cond\n      (> (* d d) n)\n        divs\n      (zero? (rem n d))\n        (recur (inc d) (concat divs (distinct [d (quot n d)])))\n      :else\n        (recur (inc d) divs))))\n\n(defn sum-sqr-divs [n]\n  (->> (divisors n)\n       (map #(* % %))\n       (apply +)))\n\n(defn list_squared [m n]\n  (->> (range m (inc n)) \n       (map (fn [n] [n (sum-sqr-divs n)]))\n       (filter #(square? (% 1)))) )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16247,"user_id":null,"body":"(ns sumdivsq.core)\n\n(def sqrt #(Math\/sqrt %))\n\n(def sqr #(* % %))\n\n(defn divides? [n]\n  (comp zero? (partial mod n)))\n\n(defn sum-of-squared-divisors [n]\n  (->> (range 1 (inc n))\n       (filter (divides? n))\n       (map sqr)\n       (apply +)))\n\n(defn square-number? [x]\n  (zero? (mod (sqrt x) 1)))\n\n(defn list_squared [m n]\n  (->> (range m (inc n))\n       (map (fn [n] \n              [n (sum-of-squared-divisors n)]))\n       (filter (comp square-number? second))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16248,"user_id":62,"body":"(ns sumdivsq.core)\n\n(defn square? [n]\n  (= n (#(* % %) (int (Math\/sqrt n)))))\n\n(defn divisors [n]\n  (distinct \n   (mapcat (juxt identity #(\/ n %))\n    (filter #(zero? (rem n %)) (take-while #(<= (* % %) n) (iterate inc 1))))))\n\n(defn sum-squares [coll]\n  (reduce + (map #(* % %) coll)))\n\n(defn list_squared [m n]\n  (for [k (range m (inc n))\n        :when (square? (sum-squares (divisors k)))]\n    [k (sum-squares (divisors k))]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16249,"user_id":null,"body":"(ns sumdivsq.core)\n\n(defn divisors [x]\n  (filter #(= (rem x %) 0)\n          (range x 0 -1)))\n\n(defn list_squared [m n]\n  (->> (range m (inc n))\n    (map (fn [x]\n           [x (->> (divisors x)\n                (map #(* % %))\n                (reduce + 0))]))\n    (filter (fn [[_ sum]]\n              (let [root (Math\/abs (Math\/sqrt sum))]\n                (= (- root (Math\/round root))\n                   0.0))))))\n                   \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16250,"user_id":null,"body":"(ns sumdivsq.core)\n\n(defn get-divisors [n]\n  (->> (range 1 (inc n))\n    (filter #(= 0.0 (mod (\/ (double n) (double %)) 1)))))\n\n(defn is-square [n]\n  (= 0.0 (mod (Math\/sqrt (double n)) 1.0)))\n\n(defn list_squared [m n]\n  (def r (range m (inc n)))\n  (->> r\n    (filter #(is-square (reduce + \n                                (map (fn [v] (* v v)) \n                                     (get-divisors %)))))\n    (map #(vector % (reduce + (map (fn [v] (* v v)\n                                     ) (get-divisors %)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16251,"user_id":null,"body":"(ns sumdivsq.core)\n\n(defn factors [n]\n  (let [factors (if (< n 3)\n                  (set (range 1 n))\n                  (set\n                        (mapcat conj\n                                (cons [1]\n                                      (for [i (range 2 (inc (Math\/sqrt n)))]\n                                        (if (zero? (mod n i))\n                                          [i (\/ n i)]))))))]\n    (conj factors n)))\n\n(defn whole-number? \n  ([] (fn [[ndx nb]] (whole-number? ndx nb)))\n  ([[ndx nb]]\n   (let [whole? (= (mod nb 1) 0.0)\n         prime? (not= (bigint (inc (* ndx ndx))) nb)]\n     (and whole? prime?))))\n\n(defn factors-rs [nb]\n  (->> nb\n       factors\n       (map #(* % %))\n       (apply +)\n       Math\/sqrt\n       ))\n\n(defn list_squared [m n]\n  (->> (for [nb (range m n)]\n         [nb (factors-rs nb)])\n       ; (filter #(whole-number? %))\n       ; (filter #(not= (bigint (inc (* (first %) (first %)))) (second %)))\n       (filter whole-number?)\n       (map #(vector (first %) (int (* (second %) (second %)))))\n       ))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16252,"user_id":null,"body":"(ns sumdivsq.core)\n\n(defn divides [m n]\n  (zero? (rem n m )))\n\n(defn add-to-divisors [n divisors i]\n  (let [to-check (range 1 (inc (int (Math\/sqrt n))))\n        quotient (quot n i)\n        remainder (mod n i)]\n    (if (zero? remainder) (conj divisors i quotient) divisors)))\n\n(defn find-divisors [n]\n  (reduce  (partial add-to-divisors n) #{} (range 1 (inc (int (Math\/sqrt n))))))\n\n(defn sum [coll] (apply + coll))\n\n(defn square-divisor [n]\n  (let [sum-of-divisors (sum (map #(* % %) (find-divisors n)))]\n    (if (zero? (mod sum-of-divisors (Math\/sqrt sum-of-divisors))) [n sum-of-divisors] nil)))\n\n(defn list_squared [m n]\n  (into []\n        (comp (map square-divisor) (remove nil?))\n        (range m (inc n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55ab4f980f2d576c070000f4":[{"id":16253,"user_id":527,"body":"(ns suite2.core)\n\n(defn game [n]\n  (if (even? n) [(\/ (* n n) 2)] [(* n n) 2]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16254,"user_id":null,"body":"(ns suite2.core)\n\n(defn game [board-game]\n  (let [x (* board-game board-game 1\/2)]\n    (if (ratio? x) ((juxt numerator denominator) x) [x])))\n    ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16255,"user_id":492,"body":"(ns suite2.core)\n\n(defn game [n]\n  (let [m (* n n) res []]\n    (if (= (mod m 2) 0)\n      [(\/ m 2)]\n      [m, 2])))\n      ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16256,"user_id":null,"body":"(ns suite2.core)\n\n(defn game [n]\n  (if (= (mod (* n n) 2) 0)\n      [(\/ (* n n) 2)]\n      [(* n n) 2]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16257,"user_id":null,"body":"(ns suite2.core)\n\n(defn game [n]\n  (let [n2 (* n n)]\n    (if (even? n2)\n      [(\/ n2 2)]\n      [n2 2])))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16258,"user_id":570,"body":"(ns suite2.core)\n\n(defn game [n]  \n  (let [x (* n n 1\/2)]  \n      (if (ratio? x) ((juxt numerator denominator) x) [x])))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16259,"user_id":null,"body":"(ns suite2.core)\n\n(defn game [n]\n\t(let [n2 (* n n)]\n  \t(if (= (mod n2 2) 0)\n    \t[(\/ n2 2)]\n      [n2 2]\n      )\n      )\n  \n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16260,"user_id":null,"body":"(ns suite2.core)\n\n(defn game [n]\n  (let [square (* n n)]\n    (if (odd? square) [square 2] [(\/ square 2)])))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16261,"user_id":null,"body":"(ns suite2.core)\n\n(defn game [n]\n  (let [wholes (reduce + (range 1 n))]\n    (if (even? n) [(+ wholes (\/ n 2))] [(+ n (* 2 wholes)), 2])))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16262,"user_id":null,"body":"(ns suite2.core)\n\n(defn game [n]\n  (let [num (* n n)]\n    (if (odd? num)\n      [num 2]\n      [(\/ num 2)])))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55ab9eee6badbdaf72000075":[{"id":16263,"user_id":53,"body":"(ns pentnum.core)\n\n(defn p_num[n] (let [a (Math\/pow (inc (* 24 n)) 0.5)] (zero? (mod (\/ (inc a) 6) 1))))\n(defn gp_num[n] (let [a (Math\/pow (inc (* 24 n)) 0.5)] (or (zero? (mod (\/ (inc a) 6) 1)) (zero? (mod (\/ (dec a) 6) 1)) )))\n(defn sp_num[n] (let [a (Math\/pow n 0.5)] (and (p_num n) (zero? (mod a 1)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16264,"user_id":null,"body":"(ns pentnum.core)\n\n(defn pentanum [n]\n  (\/ (- (* 3 n n) n) 2))\n\n(def pentanums\n  (map pentanum (iterate inc 1)))\n\n(defn p_num[n]\n  (== n (first (drop-while #(< % n) pentanums))))\n\n(defn genpentidx [n]\n  (if (odd? n) (inc (quot n 2)) (- (quot n 2))))\n\n(def genpentanums\n  (map (comp pentanum genpentidx) (range)))\n\n(defn gp_num[n]\n  (== n (first (drop-while #(< % n) genpentanums))))\n\n(def squares\n  (map #(* % %) (iterate inc 1)))\n  \n(defn square? [n]\n  (== n (first (drop-while #(< % n) squares))))\n\n(defn sp_num[n]\n  (and  (square? n)\n        (p_num n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16265,"user_id":492,"body":"(ns pentnum.core)\n\n(defn p_num[n]\n  (let [a (Math\/pow (+ 1 (* 24 n)) 0.5)]\n    (= 0.0 (mod (\/ (+ 1 a) 6) 1)))) ; g\n\n(defn gp_num[n]\n  (let [a (Math\/pow (+ 1 (* 24 n)) 0.5)]\n    (or (= 0.0 (mod (\/ (+ 1 a) 6) 1)) (= 0.0 (mod (\/ (- 1 a) 6) 1)) ))) ; g\n\n(defn sp_num[n]\n  (let [a (Math\/pow n 0.5)]\n    (and (p_num n) (= 0.0 (mod a 1))))) ; g","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55b3425df71c1201a800009c":[{"id":16266,"user_id":null,"body":"(ns stat_assoc.core)\n(require '[clojure.string :as string])\n\n(defn to-seconds\n  [text]\n  (let [[h, m, s] (string\/split text #\"\\|\")]\n    (+ (* 3600 (Integer\/parseInt h)) \n       (* 60 (Integer\/parseInt m)) \n       (Integer\/parseInt s))))\n\n(defn to-str\n  [seconds]\n  (let [s (mod seconds 60)\n        minutes (int (\/ seconds 60))\n        m (mod minutes 60)\n        h  (int (\/ minutes 60))]\n      (string\/join \"|\" (map #(format \"%02d\" %) [h m s]))))\n\n\n(defn stat_assoc [strg]\n  (if (empty? strg)\n    \"\"\n    (let [datetimes (map to-seconds (string\/split strg #\", \"))\n          sorted (sort datetimes)\n          n (count sorted)\n          center (take (if (odd? n) 1 2) (drop (int (\/ (dec n) 2)) sorted))\n          mean (int (\/ (apply + center) (count center)))\n          delta (- (last sorted) (first sorted))\n          avg (int (\/ (apply + sorted) n))]\n      (str \"Range: \" (to-str delta) \n           \" Average: \" (to-str avg) \n           \" Median: \" (to-str mean)))))\n","lang_id":5,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16267,"user_id":null,"body":"(ns stat_assoc.core\n  (:require [clojure.string :as s]))\n\n(defn split-times\n  [strg]\n  (if (empty? strg)\n    ()\n    (s\/split strg #\", \")))\n\n(defn hhmmss->ss\n  [hhmmss]\n  (let [[hhs mms sss] (s\/split hhmmss #\"\\|\")\n        hh (Integer\/parseInt hhs)\n        mm (Integer\/parseInt mms)\n        ss (Integer\/parseInt sss)]\n    (+ (* hh 3600) (* mm 60) ss)))\n\n(defn num->strg\n  [num]\n  (if (< num 10)\n    (str \"0\" num)\n    (str num)))\n\n(defn ss->hhmmss\n  [s]\n  (let [hh (quot s 3600)\n        mm (quot (- s (* hh 3600)) 60)\n        ss (- s (+ (* hh 3600) (* mm 60)))]\n    (s\/join \"|\" (map num->strg [hh mm ss]))))\n\n(defn time-range\n  [times]\n  (let [min-time (apply min times)\n        max-time (apply max times)\n        range-time (- max-time min-time)]\n    (ss->hhmmss range-time)))\n\n(defn time-average\n  [times]\n  (let [avgss (quot (apply + times) (count times))]\n    (ss->hhmmss avgss)))\n\n(defn- odd-median\n  [sorted-times]\n  (let [mid-point (quot (count sorted-times) 2)\n        median (nth sorted-times mid-point)]\n    (ss->hhmmss median)))\n\n(defn- even-median\n  [sorted-times]\n  (let [mid-point-1 (quot (count sorted-times) 2)\n        mid-point-2 (dec mid-point-1)\n        avg-median (quot (+ (nth sorted-times mid-point-1)\n                            (nth sorted-times mid-point-2))\n                         2)]\n    (ss->hhmmss avg-median)))\n\n(defn time-median\n  [times]\n  (let [sorted-times (sort times)\n        length (count sorted-times)]\n    (cond\n      (odd? length) (odd-median sorted-times)\n      (even? length) (even-median sorted-times))))\n\n\n(defn stat_assoc\n  [strg]\n  (if (= strg \"\") \"\"\n    (let [times (map hhmmss->ss (split-times strg))\n          my-range (time-range times)\n          my-average (time-average times)\n          my-median (time-median times)]\n      (str \"Range: \" my-range \" \"\n           \"Average: \" my-average \" \"\n           \"Median: \" my-median))))\n\n","lang_id":5,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16268,"user_id":492,"body":"(ns stat_assoc.core)\n\n(defn time2snd [s]\n  (let [arr (vec (map read-string (clojure.string\/split s #\"\\|\")))]\n    (+ (* 3600 (arr 0)) (* 60 (arr 1)) (arr 2))))\n\n(defn snd2time [m]  \n  (let [\n        n (int m)\n        h (int (Math\/floor (\/ n 3600)))\n        re (int (Math\/floor (mod n 3600)))\n        mn (int (Math\/floor (\/ re 60)))\n        s (int (Math\/floor (mod re 60)))\n       ]\n    (format \"%02d|%02d|%02d\" h mn s)))\n\n(defn stat_assoc [strg]\n  (if (= \"\" strg)\n    \"\"\n    (let [\n          r (vec (sort (vec (map time2snd (clojure.string\/split strg #\", \")))))\n          lg (count r)\n          rge (- (r (- lg 1)) (r 0))\n          sm (reduce + r)\n          avg (int (\/ sm lg))\n          m1 (r (int (\/ (- lg 1) 2.0)))\n          m2 (r (int (\/ lg 2.0)))\n          md (int (\/ (+ m1 m2) 2.0))\n         ]\n      (format \"Range: %s Average: %s Median: %s\" (snd2time rge) (snd2time avg) (snd2time md)))))\n","lang_id":5,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16269,"user_id":null,"body":"(ns stat_assoc.core)\n(use '[clojure.string :only (split join)])\n\n(defn- add-leading-zero [t]\n  (if (= (count (str t)) 1)\n    (str \"0\" (str t))\n    t))\n\n(defn- str-to-sec [t]\n  (reduce + (map-indexed (fn [i e] (* e (reduce * (repeat (- 2 i) 60)))) t)))\n  \n(defn sec-to-str [t]\n  (loop [ret '() time-left t i 0] \n    (if (> i 2) \n      (join \"|\" (reverse ret))\n      (recur \n        (conj ret (add-leading-zero (quot time-left (reduce * (repeat (- 2 i) 60))))) \n        (rem time-left (reduce * (repeat (- 2 i) 60))) \n        (inc i)))))\n\n(defn- median [l]\n  (let [countd (count l) midPoint (int (\/ countd 2))]\n    (if (odd? countd)\n      (nth l midPoint)\n      (int (\/ (+ (nth l midPoint) (nth l (dec midPoint))) 2)))))\n\n(defn stat_assoc [strg]\n  (if (= strg \"\")\n    \"\"\n    (as-> strg s\n      (split s #\", \")\n      (map (fn [e] (map #(Integer\/parseInt %) (split e #\"\\|\"))) s)\n      (sort (map str-to-sec s))\n      (map #(% s) (list #(- (last %) (first %)) #(int (\/ (reduce + %) (count %))) #(median %)))\n      (map #(sec-to-str %) s)\n      (join \" \" (interleave '(\"Range:\" \"Average:\" \"Median:\") s)))))","lang_id":5,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16270,"user_id":null,"body":"(ns stat_assoc.core\n  (:require [clojure.string :as str]))\n\n\n(defn parse-time [t]\n  (let [parts (map #(Integer\/parseInt %) (str\/split t #\"\\|\"))]\n    (apply + (mapv * parts [3600 60 1]))))\n\n(defn format-time [s]\n  (let [si (int s)\n        h (quot si 3600)\n        hrem (rem si 3600)\n        m (quot hrem 60)\n        r (rem hrem 60)]\n    (str\/join \"|\" (map #(format \"%02d\" %) [h m r]))))\n\n(defn stat_assoc [strg]\n  (if (= \"\" strg)\n    \"\"\n    (let [times (vec (sort (map parse-time (str\/split strg #\", \"))))\n          n (count times)\n          range-s (- (apply max times) (apply min times))\n          avg-s (\/ (apply + times) n)\n          med-s (if (odd? n)\n                  (times (int (\/ n 2)))\n                  (\/ (+ (times (\/ n 2)) (times (- (\/ n 2) 1))) 2))]\n          (format \"Range: %s Average: %s Median: %s\" \n            (format-time range-s) (format-time avg-s) (format-time med-s))\n    )\n  )\n)\n","lang_id":5,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16271,"user_id":1400,"body":"(ns stat_assoc.core)\n\n(defn convert [seconds]\n  (def h (int (\/ seconds 3600)))\n  (def s (int (mod seconds 60)))\n  (def m (int (\/ (mod seconds 3600) 60)))\n  \n  (clojure.string\/join \"|\" \n     (map (fn [x] (format \"%02d\" x)) [h m s])\n  )\n)\n\n(defn mean [xs]\n  (\/ (reduce + xs) (count xs))\n)\n\n(defn median [xs_unsorted]\n  (def xs (sort xs_unsorted))\n  (def l (count xs))\n  (if (== l 1)\n   (nth xs 0)\n   (if (== l 2)\n    (mean xs)\n    (median (take (- l 2) (drop 1 xs)))\n   )\n  )\n)\n\n;receives an vector of seconds, calculating range, average, median\n(defn stat_assoc3 [seconds]\n  (def r1 \n    (- (reduce max seconds) (reduce min seconds))\n  )\n  (def r2 (mean seconds) )\n  (def r3 (median seconds) )\n  (def res \n    (clojure.string\/join \" \" [\"Range:\" (convert r1) \"Average:\" (convert r2) \"Median:\" (convert r3)])\n  )\n  (println res)\n  res\n)\n\n(defn stat_assoc2 [strg]\n  (println strg)\n  (def times (clojure.string\/split strg #\", \"))\n  (println (str times))\n  (def \n    times2 \n    (map \n      (fn [x] (clojure.string\/split x #\"\\|\"))\n      times\n    )\n  )\n  (println times2)\n  (def seconds \n    (map \n     (fn [mytime]\n       (reduce + \n         [(* (Integer\/parseInt (get mytime 0)) 3600) (* (Integer\/parseInt (get mytime 1)) 60) (Integer\/parseInt (get mytime 2))]\n       )\n     ) \n     times2\n    )\n  )\n  (println seconds)\n  (stat_assoc3 seconds)\n)\n\n(defn stat_assoc [strg]\n  (if (<= (count strg) 1)\n    \"\"\n    (stat_assoc2 strg)\n  )\n)\n","lang_id":5,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16272,"user_id":null,"body":"(ns stat_assoc.core\n  (:require [clojure.string :as str]))\n\n(defn parse-hms [s]\n  (let [a (str\/split s #\"\\|\")\n        [h m s] (mapv #(Integer. %1) a)]\n    (reduce + (mapv * [h m s] [3600 60 1]))))\n\n(defn format-hms [seconds]\n  (let [secs (mod seconds 60)\n        minutes-large (quot seconds 60)\n        hours (quot minutes-large 60)\n        minutes (mod minutes-large 60)]\n    (format \"%02d|%02d|%02d\" hours minutes secs)))\n\n(defn stat_assoc [strg]\n (if (= strg \"\") strg\n  (let [runners (str\/split strg #\", \")\n        tms (mapv parse-hms runners)\n        n (count tms)\n        avg (int (\/ (reduce + tms) n))\n        rng (- (apply max tms) (apply min tms))\n        times-sorted (into [] (sort tms))\n        median (if (odd? n)\n                     (nth times-sorted (\/ (dec n) 2))\n                 (as-> (\/ n 2) i\n                   (int i) (+ (nth times-sorted i)\n                              (nth times-sorted (dec i)))\n                   (int (\/ i 2))))]\n    (format \"Range: %s Average: %s Median: %s\"\n            (format-hms rng) (format-hms avg) (format-hms median)))))\n","lang_id":5,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16273,"user_id":null,"body":"(ns stat_assoc.core\n  (:require [clojure.string :refer [split]]))\n\n(defn get-range [xs]\n  (- (apply max xs) (apply min xs)))\n(defn get-mean [xs]\n  (quot (apply + xs) (count xs)))\n(defn get-median [xs]\n  (let [xs (sort xs)\n        m  (quot (count xs) 2)]\n    (cond-> (nth xs m)\n      (even? (count xs)) (-> (+ (nth xs (dec m))) (quot 2)))))\n\n(defn quot-rem [n d] [(quot n d) (rem n d)])\n\n(defn str->sec [t]\n  (let [[h m s] (->> (split t #\"\\|\") (map #(Integer\/parseInt %)))]\n    (+ s (* m 60) (* h 3600))))\n(defn sec->str [x]\n  (let [[h r] (quot-rem x 3600)\n        [m s] (quot-rem r 60)]\n    (format \"%02d|%02d|%02d\" h m s)))\n\n(defn stat_assoc [strg]\n  (if (empty? strg)\n    \"\"\n    (->> (split strg #\", \")\n         (map str->sec)\n         ((juxt get-range get-mean get-median))\n         (map sec->str)\n         (apply format \"Range: %1$s Average: %2$s Median: %3$s\"))))\n","lang_id":5,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16274,"user_id":null,"body":"(ns stat_assoc.core\n  (:require [clojure.string :refer [split]]))\n\n(defn quot-rem [n d] [(quot n d) (rem n d)])\n\n(defn get-range [xs]\n  (- (apply max xs) (apply min xs)))\n(defn get-mean [xs]\n  (quot (apply + xs) (count xs)))\n(defn get-median [xs]\n  (let [xs (sort xs)\n        m  (quot (count xs) 2)]\n    (cond-> (nth xs m)\n      (even? (count xs)) (-> (+ (nth xs (dec m))) (quot 2)))))\n\n(defn parse [t]\n  (let [[h m s] (->> (split t #\"\\|\") (map #(Integer\/parseInt %)))]\n    (+ s (* m 60) (* h 3600))))\n(defn code [x]\n  (let [[h r] (quot-rem x 3600)\n        [m s] (quot-rem r 60)]\n    (format \"%02d|%02d|%02d\" h m s)))\n\n(defn stat_assoc [strg]\n  (if (empty? strg)\n    \"\"\n    (let [times (map parse (split strg #\", \"))]\n      (format \"Range: %1$s Average: %2$s Median: %3$s\"\n              (code (get-range times))\n              (code (get-mean times))\n              (code (get-median times))))))","lang_id":5,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16275,"user_id":null,"body":"(ns stat_assoc.core\n  (:require [clojure.string :as s]))\n\n(def pad2 #(->> % biginteger (format \"%02d\")))\n\n(defn string->seconds [string]\n  (let [[hours minutes seconds] (->> (s\/split string #\"\\|\") (map read-string))]\n    (+ (* 3600 hours) (* 60 minutes) seconds)))\n\n(defn seconds->string [seconds]\n  (let [hours   (quot seconds 3600)\n        minutes (quot (rem seconds 3600) 60)\n        seconds (rem (rem seconds 3600) 60)]\n    (str (pad2 hours) \"|\" (pad2 minutes) \"|\" (pad2 seconds))))\n\n(defn median [numbers]\n  (loop [[head neck & more :as nums] (sort numbers)]\n    (cond\n      (nil? head)   0\n      (nil? neck)   head\n      (empty? more) (\/ (+ head neck) 2)\n      :else         (recur (rest (butlast nums))))))\n\n(defn stat_assoc [string]\n  (if (= \"\" string) \"\"\n    (let [tms (->> (s\/split string #\", \") (map string->seconds))\n          rng (seconds->string (- (apply max tms) (apply min tms)))\n          avg (seconds->string (int (\/ (apply + tms) (count tms))))\n          med (seconds->string (median tms))]\n      (str \"Range: \" rng \" Average: \" avg \" Median: \" med))))","lang_id":5,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55b4d87a3766d9873a0000d4":[{"id":16276,"user_id":492,"body":"(ns carboat.core)\n\n(defn howmuch [m n]\n  (let [res (for [i (range (min m n) (inc (max m n)))\n                  :when (and (= 1 (mod i 9)) (= 2 (mod i 7)))\n                 ]\n              [(str \"M: \" i) (str \"B: \" (int (\/ i 7))) (str \"C: \" (int (\/ i 9)))])\n       ]\n    (vec res)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16277,"user_id":null,"body":"(ns carboat.core)\n\n(defn howmuch [m n]\n  (map #(vector (str \"M: \" %) (str \"B: \" (quot % 7)) (str \"C: \" (quot % 9)))\n       (filter #(and (= 1 (mod % 9)) (= 2 (mod % 7)))\n               (range (min m n) (+ 1 (max m n))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16278,"user_id":527,"body":"(ns carboat.core)\n\n(defn howmuch [m n]\n  (let [\n      [b e] (sort [m n])\n      b' (-> b (- 37) (\/ 63) Math\/ceil int (* 63) (+ 37))\n      r (range b' (inc e) 63)\n      f #(vector\n          (str \"M: \" %)\n          (str \"B: \" (quot % 7))\n          (str \"C: \" (quot % 9)))\n    ] (map f r)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16279,"user_id":null,"body":"(ns carboat.core\n  (require [clojure.string :as string]))\n\n;;  Provided 0<=m<=n and 9*c=1 and 7*b=2, find all possible answers where c & b are in m and n (inclusive)\n(defn howmuch [m n]\n  (let [c #(% (- %2 1) 9)\n        b #(% (- %2 2) 7)]\n    (->> (range (min m n) (inc (max m n)))\n         (filter #(every? zero? [(c mod %) (b mod %)]))\n         (mapv #(mapv string\/join {\"M: \" % \"B: \" (b \/ %) \"C: \" (c \/ %)})))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16280,"user_id":null,"body":"(ns carboat.core)\n\n(defn check-func [in]\n         (if (and (= (\/ (- in 1) 9) (int (\/ (- in 1) 9)))\n                  (= (\/ (- in 2) 7) (int (\/ (- in 2) 7))))\n           (list \n            in\n            (\/ (- in 2) 7)\n            (\/ (- in 1) 9))\n           (list -1)))\n\n(defn howmuch [m n]\n  (into []\n  (map #(list\n         (format \"M: %s\" (first %))\n         (format \"B: %s\" (second %))\n         (format \"C: %s\" (last %))))\n  (filter #(> (count %) 1)\n  (map #(check-func %) \n  (range (min m n) (+ (max n m) 1))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16281,"user_id":1400,"body":"(ns carboat.core)\n\n(defn getfs [m n]\n\n  (let [\n        low (min m n)\n        high (max m n)\n        cstart (int (Math\/ceil (\/ (- low 1) 9)))\n        cend   (int (\/ (- high 1) 9))\n        \n        bstart (int (Math\/ceil (\/ (- low 2) 7)))\n        bend   (int (\/ (- high 2) 7))\n        fs1 (for [c (range cstart (inc cend))] (+ 1 (* 9 c)))\n        fs2 (for [b (range bstart (inc bend))] (+ 2 (* 7 b)))\n        fs (distinct (concat fs1 fs2))\n        ]\n    fs\n    )\n)\n\n(defn getc [f]\n  (\/ (- f 1) 9)\n)\n\n(defn getb [f]\n  (\/ (- f 2) 7)\n)\n\n(defn bcnat [f]\n  (and (integer? (getb f))\n       (integer? (getc f))\n   )\n)\n\n(defn howmuch [m n]\n  ;m <= f <= n\n  \n  ;f - 9*c = 1\n  ;f - 7*b = 2\n  \n  ;<=> f = 1 + 9*c\n  ;<=> f = 2 + 7*b\n  \n  ;<=> m <= 1+9c <= n\n  ;<=> (m-1)\/9 <= c <= (n-1)\/9\n  \n  ;<=> m <= 2+7b <= n\n  \n  (let [\n        fs (filter bcnat (getfs m n))\n        ]\n    (into [] (for [f fs] \n               [\n                (str \"M: \" (str f))\n                (str \"B: \" (str (getb f)))\n                (str \"C: \" (str (getc f)))\n                ]\n               )\n          )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16282,"user_id":null,"body":"(ns carboat.core)\n\n(defn howmuch [m n]\n  (->> (filter (fn [i] (and (zero? (mod (- i 2) 7))\n                           (zero? (mod (- i 1) 9))))\n               (range (min m n) (inc (max m n)))) ;; The use of min and max should not be needed\n       ;; but one test does not respect m <= n\n       (mapv #(vector (str \"M: \" %) (str \"B: \" (\/ (- % 2) 7)) (str \"C: \" (\/ (- % 1) 9))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16283,"user_id":null,"body":"(ns carboat.core)\n\n(defn- iter [s]\n  (iterate\n    #(+ % 63)\n    (as-> (- 63 (mod (- s 37) 63)) n\n          (cond-> s (< n 63) (+ n)))))\n\n(defn howmuch [x y]\n  (map\n    (fn [m]\n      [(format \"M: %d\" m)\n       (format \"B: %d\" (quot m 7))\n       (format \"C: %d\" (quot m 9))])\n    (take-while #(<= % (max x y)) (iter (min x y)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16284,"user_id":null,"body":"(ns carboat.core)\n\n(defn- iter [s]\n  (iterate\n    #(+ % 63)\n    (as-> (- 63 (mod (- s 37) 63)) n\n          (cond-> s (< n 63) (+ n)))))\n\n(defn howmuch [x y]\n  (map\n    (fn [m]\n      (let [b (quot m 7) c (quot m 9)]\n        [(format \"M: %d\" m) (format \"B: %d\" b) (format \"C: %d\" c)]))\n    (take-while #(<= % (max x y)) (iter (min x y)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16285,"user_id":null,"body":"(ns carboat.core)\n\n(defn howmuch [m n]\n  (let [om m\n        m  (min m n)\n        n  (max om n)\n        fi (fn [v f] (-> v (- 37) (\/ 63) f int))\n        bi (fi m #(Math\/ceil %))\n        ei (+ (fi n #(Math\/floor %)) 1)\n        fv (fn [i s m] (+ (* i m) s))\n        fs (fn [st i s m] (str st \" \" (fv i s m)))]\n    (for [i (range bi ei)]\n      [(fs \"M:\" i 37 63) (fs \"B:\" i 5 9) (fs \"C:\" i 4 7)]\n      )\n    )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55be10de92aad5ef28000023":[{"id":16286,"user_id":53,"body":"(ns checkchoose.core)\n\n(defn checkchoose [m n]\n  (loop [i 0 result 1]\n    (if (= i (+ 1 n))\n      -1\n      (if (= result m)\n        i\n        (recur (inc i) (* result (\/ (- n i) (+ i 1))))))\n  ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16287,"user_id":492,"body":"(ns checkchoose.core)\n\n(defn choose [n p]\n  (if (> p n)\n    0\n    (let [p (min p (- n p)) rprod (fn [a b] (reduce * (range (biginteger a) (inc (biginteger b)))))]\n      (\/ (rprod (- n p -1) n) (rprod 1 p)))))\n\n(defn checkchoose [m n]\n  (if (> m (choose n (int (\/ n 2))))\n    -1\n    (loop [i 0]\n      (if (> i (+ 1 (int (\/ n 2))))\n        -1\n        (if (= m (choose n i))\n          i\n          (recur (inc i)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16288,"user_id":null,"body":"(ns checkchoose.core)\n\n; m could be a \"biginteger\"\n(defn checkchoose [m n]\n  (loop [r n x 1]\n    (if (= r m) x (if (or (> r m) (>= 0 r)) -1\n      (recur (* r (\/ (- n x) (inc x))) (inc x))) )))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16289,"user_id":62,"body":"(ns checkchoose.core)\n\n(defn factorial [n]\n  (reduce * (bigint 1) (range 1 (inc n))))\n\n(defn choose [n k]\n  (\/ (factorial n) (factorial k) (factorial (- n k))))\n  \n(defn checkchoose [m n]\n  (or (first\n              (for [k (range (inc (quot n 2)))\n                    :when (= m (choose n k))] \n                k))\n      -1))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16290,"user_id":null,"body":"(ns checkchoose.core)\n\n(defn factorial [x]\n  (loop [acc 1 i (bigint 1) ]\n    (cond (zero? x) 1\n          (< i x) (recur (* acc (inc i)) (inc i))\n          :else acc)))\n\n(defn checkchoose [m n]\n  (loop [x 1]\n    (let [div (* (factorial x)\n                 (factorial (- n x)))]\n      (cond\n        (zero? div) -1\n        (= (\/ (factorial n) div) m) (int x)\n        (> x n) -1\n        :else (recur (inc x))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16291,"user_id":null,"body":"(ns checkchoose.core)\n\n;; (def factorial\n;;   (memoize\n;;     (fn [n]\n;;       (if (= n 0) 1 (*' n (factorial (dec n)))))))\n\n(defn factorial [n]\n  (reduce *' (range 1 (inc n))))\n\n(defn- choose [n x]\n  (quot (factorial n)\n        (*' (factorial x)\n            (factorial (-' n x)))))\n\n(defn- solve-for-x [m n]\n  (loop [x 1N]\n    (when (< x (inc (quot n 2)))\n      (let [y (choose n x)]\n        (cond\n          (= y m) x\n          (< y m) (recur (inc x)))))))\n\n(defn checkchoose [m n]  \n  (or (solve-for-x m n) -1))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16292,"user_id":null,"body":"(ns checkchoose.core)\n\n(defn possibilities \"calculates the number of order-independent color combinations for a given set of options and number of choices\"\n  [options-count chosen-count]\n     \n  (\/ (apply *' (map #(- options-count %) (range 0 chosen-count))) ; number of combinations, including different orders\n     (reduce *' (range 1 (inc chosen-count))))\n  )\n\n; m could be a \"biginteger\"\n(defn checkchoose [poster-count options-count]\n  ; we need to find the smallest value of \"chosen-count\" for which possiblities returns >= poster-count\n  (let [ c (first (first (filter #(= poster-count (last %)) (map #(vector % (possibilities options-count %)) (range 1 (inc options-count))))))]\n    (if (nil? c)\n      -1\n       c))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16293,"user_id":null,"body":"(ns checkchoose.core)\n\n(defn factorial [n]\n  (reduce *' (range 1 (inc n))))\n\n(defn formula [m n]\n  (vec (for [x (range 1 (inc n))]\n         {:x x :answer (\/ (factorial n) (*' (factorial x) (factorial (- n x))))})))\n\n; m could be a \"biginteger\"\n(defn checkchoose [m n]\n  (let [f (formula m n)\n        filtered (filterv #(= (:answer %) m) f)]\n    (if (empty? filtered)\n      -1\n      (apply min (mapv :x filtered)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16294,"user_id":null,"body":"(ns checkchoose.core)\n\n(defn factorial\n  [n]\n  (reduce *' (range 1 (inc n))))\n\n(defn calc-m\n  [fat-n fat-1st fat-2nd]\n  (\/ fat-n (*' fat-1st fat-2nd)))\n\n(defn checkchoose\n  ([m n]\n   (let [fat-n   (factorial n)\n         fat-1st 1\n         fat-2nd (\/ fat-n n)\n         x       1]\n     (checkchoose m n x fat-n fat-1st fat-2nd)))\n  ([m n x fat-n fat-1st fat-2nd]\n   (if (> x (int (\/ n 2)))\n     -1\n     (if (not= m (calc-m fat-n fat-1st fat-2nd))\n       (let [x*       (inc x)\n             fat-1st* (*' fat-1st x*)\n             fat-2nd* (\/  fat-2nd (- n x))]\n         (checkchoose m n x* fat-n fat-1st* fat-2nd*))\n       x))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16295,"user_id":null,"body":"(ns checkchoose.core)\n\n(defn fact [x]\n  (reduce * (range 1N (inc x))))\n\n(defn combos [n x]\n  (\/ (fact n)\n    (* (fact x) (fact (- n x)))))\n\n(defn checkchoose [m n]\n  (loop [x 1 prev -1]\n    (cond (= m (combos n x)) x\n          (> prev (combos n x)) -1\n          :else (recur (inc x) (combos n x)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55bf01e5a717a0d57e0000ec":[{"id":16296,"user_id":null,"body":"(ns persistent.core)\n\n(defn persistence [n]\n  (if (< n 10)\n    0\n    (let [digit-list (->> (str n)\n                          seq\n                          (map str)\n                          (map read-string))]\n        (if (= 1 (count digit-list))\n            digit-list\n            (inc (persistence (reduce * digit-list)))))))\n    ","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16297,"user_id":null,"body":"(ns persistent.core)\n\n(defn persistence [n]\n  (loop [r 0 n n]\n    (if (< n 10) r\n    (->> n\n      str\n      (map (comp read-string str))\n      (reduce *)\n      (recur (inc r))))))\n  ","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16298,"user_id":null,"body":"(ns persistent.core)\n(defn persistence-helper [n c]\n    (if (< n 10) c\n      (let [digs (map #(Character\/digit % 10) (str n))\n            mult-num (reduce * digs)]\n          (recur mult-num (inc c)))))\n          \n          \n(defn persistence [n]\n    (persistence-helper n 0))\n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16299,"user_id":null,"body":"(ns persistent.core)\n\n(defn multiply-digits [number]\n  (->> (str number)\n       (map #(Character\/getNumericValue %))\n       (apply *)))\n\n(defn persistence [number]\n  (loop [digits number times 0]\n    (if (>= digits 10)\n      (recur (multiply-digits digits) (inc times))\n      times)))\n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16300,"user_id":null,"body":"(ns persistent.core)\n\n(defn digits [n]\n  (->> n str (map (comp read-string str))))\n\n(defn persistence [n]\n  (loop [its 0, digs (digits n)]\n    (if (< 1 (count digs))\n      (recur (inc its) (digits (apply * digs)))\n      its)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16301,"user_id":null,"body":"(ns persistent.core)\n\n(defn persistence\n  ([num] (persistence 0 num))\n  ([n num]\n   (if (< num 10)\n     n\n     (recur\n       (inc n)\n       (reduce * (->> (str num)\n                      seq\n                      (map (comp read-string str))))))))\n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16302,"user_id":null,"body":"(ns persistent.core)\n\n(defn num-split\n  \"takes number and produces list of\n  splited digits represented as numbers\"\n  [xx]\n  (map #(Character\/digit % 10) (seq (str xx))))\n\n(defn persistence\n  [n]\n  (loop [n n\n         counter 0]\n    (if (< n 10)\n      counter\n      (recur (apply * (num-split n))\n             (inc counter)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16303,"user_id":null,"body":"(ns persistent.core)\n\n(defn digits [n]\n  (if (zero? n) \n    '(0)\n    (->> n\n         (iterate #(quot % 10))\n         (take-while pos?)\n         (mapv #(mod % 10))\n         rseq)))\n\n(defn persistence\n  ([n] (persistence n 0))\n  ([n c]\n    (let [ds (digits n)]\n      (if (= 1 (count ds))\n        c\n        (recur (reduce * ds) (inc c))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16304,"user_id":null,"body":"(ns persistent.core)\n\n(defn persistence [n]\n  ((fn calc [x, acc]\n      (if (< x 10)\n          acc\n          (calc (->> (str x)\n                     (map str)\n                     (map #(Integer\/parseInt %))\n                     (reduce #(* %1 %2)))\n                (inc acc)))\n  ) n 0))  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16305,"user_id":null,"body":"(ns persistent.core)\n\n(defn digits [n]\n  (->> n str (map (comp read-string str))))\n\n(defn persistence_ [n t]\n  (if (> 10 n) t (persistence_ (reduce * (digits n)) (inc t))))\n\n(defn persistence [n]\n  (persistence_ n 0))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55c04b4cc56a697bb0000048":[{"id":16306,"user_id":null,"body":"(ns scramblies.core)\n\n(defn scramble [s1 s2]                                                                                              \n  (let [f1 (frequencies s1)                                                                                         \n        f2 (frequencies s2)]                                                                                        \n    (every? (fn [[k v]]                                                                                             \n              (<= v (get f1 k 0)))                                                                                  \n            f2)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16307,"user_id":null,"body":"(ns scramblies.core)\n\n(defn scramble [s1 s2]\n  (let [f1 (frequencies s1)\n        f2 (frequencies s2)]\n    (every? true? (map #(<= (get f2 %) (get f1 % 0)) (keys f2)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16308,"user_id":null,"body":"(ns scramblies.core)\n\n(defn scramble [s1 s2]\n  (empty? (reduce #(clojure.string\/replace-first %1 %2 \"\") s2 s1)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16309,"user_id":null,"body":"(ns scramblies.core)\n\n(defn scramble [s1 s2]\n  (let [freq1 (frequencies s1)]\n    (loop [freq2 (frequencies s2)]\n      (cond\n        (empty? freq2) true\n        (<= (second (first freq2)) (get freq1 (first (first freq2)) 0)) (recur (rest freq2))\n        :else false)))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16310,"user_id":null,"body":"(ns scramblies.core)\n\n(defn scramble [s1 s2]\n    (every? (fn [[x y]] (>= (get (frequencies s1) x 0) y))\n    (frequencies (seq s2)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16311,"user_id":null,"body":"(ns scramblies.core)\n\n(defn scramble [s1 s2]\n  (let [freq1 (frequencies s1)\n        freq2 (frequencies s2)]\n    (every? #(<= (second %) (get freq1 (first %) 0)) freq2))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16312,"user_id":null,"body":"(ns scramblies.core)\n\n(defn scramble [s1 s2]\n  (let [f1 (frequencies s1)\n        f2 (frequencies s2)]\n    (every?\n      (fn [[c cnt]]\n        (>= (get f1 c 0) cnt))\n      f2)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16313,"user_id":null,"body":"(ns scramblies.core)\n\n(defn scramble [s1 s2]\n  (let [freq1 (frequencies s1)\n        freq2 (frequencies s2)\n        ]\n    (every? identity\n            (map (fn [[k v]]\n                   (>= (get freq1 k 0) v))\n                 freq2))\n    )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16314,"user_id":null,"body":"(ns scramblies.core)\n\n(defn scramble [s1 s2]\n  (let [s1f (frequencies s1) s2f (frequencies s2)]\n    (every? #(>= (get s1f % 0) (get s2f %)) (keys s2f))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16315,"user_id":null,"body":"(ns scramblies.core)\n\n(defn scramble [s1 s2]\n  (every? (fn [[k v]] (>= (get (frequencies s1) k 0)v))\n          (frequencies s2)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55c6126177c9441a570000cc":[{"id":16316,"user_id":3318,"body":"(ns weightsort.core\n  (:require [clojure.string :as str]))\n\n(defn- sum-of-digits [s]\n  (->> s\n       (map (comp read-string str))\n       (apply +)))\n\n(defn order_weight [strng]\n  (->> \n    (str\/split strng #\"\\s+\")\n    (sort-by #(vector (sum-of-digits %) %))\n    (str\/join \" \")))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16317,"user_id":null,"body":"(ns weightsort.core\n  (:require [clojure.string :as str]))\n\n(defn weight-comp [s1 s2]\n  (let [digit-weight (fn [s] (reduce + (map #(Character\/getNumericValue %) s)))\n\n        digits-s1 (digit-weight s1)\n        digits-s2 (digit-weight s2)]\n    (if (not= digits-s1 digits-s2)\n      (compare digits-s1 digits-s2)\n      (compare s1 s2)\n      )))\n\n(defn order_weight [s]\n  (->> (str\/split s #\" \")\n       (sort weight-comp)\n       (str\/join \" \")))\n","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16318,"user_id":null,"body":"(ns weightsort.core)\n(use '[clojure.string :only (join split)])\n\n(defn f [x y] (+ x (- (int y) (int \\0))))\n\n(def ob (partial reduce f 0))\n\n(defn order_weight [s]\n  (->> (split s #\"\\s\")\n       sort\n       (sort-by ob)\n       (join \" \")))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16319,"user_id":null,"body":"(ns weightsort.core (:require [clojure.string :refer [split join]]))\n\n(defn order_weight [strng]\n  (->> (split strng #\" \")\n       (sort-by (juxt #(reduce (fn [acc el] (+ acc (Character\/digit el 10))) 0 %) identity))\n       (join \" \")))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16320,"user_id":null,"body":"(ns weightsort.core)\n\n(defn char->int [c]\n  (- (int c) 48))\n\n(defn sum [s]\n  (->> (map char->int s)\n       (reduce +)))\n\n(defn order_weight [strng]\n  (->> (re-seq #\"\\d+\" strng)\n       (sort (fn [l r]\n                  (let [cp1 (compare (sum l) (sum r))\n                        cp2 (compare l r)]\n                    (if (zero? cp1) cp2 cp1))))\n       (clojure.string\/join \" \")))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16321,"user_id":492,"body":"(ns weightsort.core)\n\n(require '[clojure.string :as str])\n\n(defn- sum-digit [n]\n  (reduce + (map #(Character\/digit % 10) (str n))))\n(defn- compsort [a b]\n  (let [x (- (sum-digit a) (sum-digit b))]\n    (if (= 0 x)\n      (compare a b)\n      x)))\n(defn order_weight [strng]\n  (str\/join \" \" (sort compsort (str\/split strng #\" \"))))\n  ","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16322,"user_id":null,"body":"(ns weightsort.core)\n\n(defn order_weight [s]\n  (let [xs (clojure.string\/split s #\" \")\n        string->sum (fn [s] (apply + (map read-string (clojure.string\/split s #\"\"))))\n        sorted (sort-by #(vector (string->sum %) %) xs)]\n    (clojure.string\/join \" \" sorted)))\n","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16323,"user_id":null,"body":"(ns weightsort.core\n  (:require [clojure.string :as str]))\n\n\n(defn digits->weight\n  [digits]\n  (apply + (map #(Character\/digit % 10) digits)))\n\n(defn order_weight\n  [weights]\n  (let [parsed (str\/split weights #\"\\s+\")\n        combined (map (fn [v w] {:val v :weight w})\n                      parsed\n                      (map digits->weight parsed))\n        sorted (sort-by (juxt :weight :val) combined)]\n    (str\/join \" \" (map :val sorted))))\n","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16324,"user_id":null,"body":"(ns weightsort.core\n  (:require [clojure.string :as s]))\n\n(defn n-str-sum-nums [tx-n]\n  (->> tx-n\n       (map (fn [n] (-> n str Integer.)))\n       (reduce +)))\n\n(defn order_weight [strng]\n  (->> strng\n       ((fn [s] (s\/split s #\" \")))\n       sort\n       (map (fn [sn] {:text sn :weigh (n-str-sum-nums sn)}))\n       (sort-by :weigh)\n       (map (fn [m] (:text m)))\n       (s\/join \" \")))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16325,"user_id":null,"body":"(ns weightsort.core)\n(require '[clojure.string :as str])\n\n(defn \u2211 [a b f]\n  (apply +' (map f (range a (inc b)))))\n\n(defn sum-digits [x]\n  (\u2211 0\n     (Math\/floor (\/ (Math\/log x) (Math\/log 10)))\n     #(int (mod (Math\/floor (\/ x (Math\/pow 10 %))) 10))))\n\n(defn order_weight [strng]\n  (if (= strng \"\") \n    \"\" \n    (->> (str\/split strng #\" \")\n         (map #(Long\/parseLong %))\n         (sort-by str)\n         (sort-by sum-digits)\n         (str\/join \" \"))))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55c9172ee4bb15af9000005d":[{"id":16326,"user_id":null,"body":"(ns pentanacci.core)\n\n;The pattern of the odd terms in the sequence is [0 1 1 0 0 0] iterative.\n;So it's not necessary to really generate all the sequence to count the odd terms.\n\n(defn count-odd-pentaFib [n]\n  (dec (reduce + (* 2 (quot (inc n) 6)) (take (mod (inc n) 6) [0 1 1 0 0 0]))) )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16327,"user_id":492,"body":"(ns pentanacci.core)\n\n(defn count-odd-pentaFib [n]\n  (+ (int (\/ (- n 1) 6)) (int (\/ (- n 2) 6)) 1))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16328,"user_id":53,"body":"(ns pentanacci.core)\n\n(defn count-odd-pentaFib [n]\n  (inc (+ (quot (dec n) 6) (quot (dec (dec n)) 6))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16329,"user_id":null,"body":"(ns pentanacci.core)\n\n(def m-fib\n  (memoize (fn [n]\n             (condp = n\n               0 0\n               1 1\n               2 1\n               3 2\n               4 4\n               (+'\n                 (m-fib (dec n))\n                 (m-fib (- n 2))\n                 (m-fib (- n 3))\n                 (m-fib (- n 4))\n                 (m-fib (- n 5)))))))\n\n(defn count-odd-pentaFib [n]\n  (if (<= n 1)\n    n\n    (->> (range 0 (inc n))\n         (map m-fib)\n         (filter odd?)\n         count\n         dec)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16330,"user_id":null,"body":"(ns pentanacci.core)\n\n(defn pentafibo\n  ([] (pentafibo 0 1 1 2 4))\n  ([a b c d e] (lazy-seq (cons (bigint a) (pentafibo (bigint b) (bigint c) (bigint d) (bigint e) (+' a b c d e))))))\n\n(defn count-odd-pentaFib\n  [n]\n  (- (count (filter odd? (vec (take (+ n 1) (pentafibo))))) 1))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16331,"user_id":null,"body":"(ns pentanacci.core)\n\n(defn pentaFib [a b c d e]\n  (lazy-seq (cons a (pentaFib b c d e (+' a b c d e)))))\n\n(defn count-odd-pentaFib [n]\n  (count (filter odd? (set (take n (pentaFib 1 1 2 4 8))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16332,"user_id":null,"body":"(ns pentanacci.core)\n\n(def calculate-memo \n  (memoize (fn [n] \n    (cond \n      (<= n 0) 0\n      (= n 1) 1\n      :else (+' \n             (calculate-memo (-' n 1)) \n             (calculate-memo (-' n 2)) \n             (calculate-memo (-' n 3)) \n             (calculate-memo (-' n 4)) \n             (calculate-memo (-' n 5)))))))\n\n(defn count-odd-pentaFib [n]\n  (->> (range 1 (inc n)) (map #(calculate-memo %)) (filter odd?) (set) (count))\n)\n\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16333,"user_id":50,"body":"(ns pentanacci.core)\n\n(defn count-odd-pentaFib [n]\n  (if (zero? n) 0 (+ 1 (quot (- n 2) 6) (quot (- n 1) 6))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16334,"user_id":null,"body":"(ns pentanacci.core)\n\n(defn count-odd-pentaFib [n]\n  (dec (+ (* 2 (quot n 6))\n          (min 2 (mod n 6)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16335,"user_id":null,"body":"(ns pentanacci.core)\n\n(defn penta-fib\n  ([]\n   (penta-fib 0 1 1 2 4))\n  ([a b c d e]\n   (lazy-seq\n    (cons a (penta-fib b c d e (+' a b c d e))))))\n\n(defn count-odd-pentaFib [n]\n  (->> (penta-fib) (take (inc n)) (filter odd?) distinct count))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55cbc3586671f6aa070000fb":[{"id":16336,"user_id":null,"body":"(ns kata.check_for_factor)\n\n(defn check_for_factor\n  [base factor]\n  (zero? (mod base factor)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16337,"user_id":null,"body":"(ns kata.check_for_factor)\n(defn check_for_factor [base factor]\n  ;; your code here\n  (= 0 (rem base factor))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16338,"user_id":527,"body":"(ns kata.check_for_factor)\n\n(defn check_for_factor [base factor]\n  (zero? (mod base factor)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16339,"user_id":null,"body":"(ns kata.check_for_factor)\n(defn check_for_factor\n  [base factor]\n  (zero? (rem base factor)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16340,"user_id":null,"body":"(ns kata.check_for_factor)\n(defn check_for_factor [base factor]\n  (not (ratio? (\/ base factor)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16341,"user_id":null,"body":"(ns kata.check_for_factor)\n\n(defn check_for_factor [base factor]\n  (integer? (\/ base factor)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16342,"user_id":null,"body":"(ns kata.check_for_factor)\n(defn check_for_factor [base factor]\n  (identical? 0 (mod base factor))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16343,"user_id":null,"body":"(ns kata.check_for_factor)\n(defn check_for_factor [base factor]\n  ;; your code here\n  (= 0 (mod base factor))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16344,"user_id":null,"body":"(ns kata.check_for_factor)\n(defn check_for_factor [base factor]\n  ;; your code here\n  (if (= (mod base factor) 0) true false)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16345,"user_id":null,"body":"(ns kata.check_for_factor)\n(defn check_for_factor [base factor]\n  (-> (mod base factor)\n    (= 0))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55d24f55d7dd296eb9000030":[{"id":16346,"user_id":null,"body":"(ns kata.summation)\n(defn summation [n]\n  \"your code here\"\n  (apply + (range (+ 1 n))))\n  ","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16347,"user_id":null,"body":"(ns kata.summation)\n(defn summation [n]\n  (\/ (* n (+ n 1)) 2))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16348,"user_id":null,"body":"(ns kata.summation)\n(defn summation [n]\n  (reduce + 0 (range (+ n 1))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16349,"user_id":527,"body":"(ns kata.summation)\n\n(defn summation [n]\n  (quot (* n (inc n)) 2))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16350,"user_id":527,"body":"(ns kata.summation)\n\n(defn summation [n]\n  (\/ (* n (inc n)) 2))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16351,"user_id":null,"body":"(ns kata.summation)\n(defn summation [n]\n  (reduce + ((comp range inc) n)))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16352,"user_id":564,"body":"(ns kata.summation)\n(defn summation [n]\n  (\/ (+ (* n n) n) 2))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16353,"user_id":null,"body":"(ns kata.summation)\n(defn summation [n]\n  (cond \n    (= n 1) 1\n  :else (+ n (summation (- n 1)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16354,"user_id":null,"body":"(ns kata.summation)\n\n(defn summation [n]\n          (loop [i 1\n                 j 0]\n            \n            (if (<= i n)\n                  (recur (inc i) (+ j i) )\n        ;(clojure.string\/join \"\" (drop-last(drop-last (drop-last result)))))\n                  j)\n        ))\n\n        \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16355,"user_id":null,"body":"(ns kata.summation)\n\n(defn summation\n  [x]\n  (reduce + 0 (range (inc x))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55d2603d506a40e162000056":[{"id":16356,"user_id":null,"body":"(ns clojure.calc-total)\n\n(defn calculate_total [t1 t2]\n  (> (reduce + 0 t1)\n     (reduce + 0 t2)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16357,"user_id":null,"body":"(ns clojure.calc-total)\n\n(defn calculate_total [t1 t2]\n  (->> (list t1 t2)\n   (map #(reduce + 0 %))\n    (apply compare)\n    (< 0)\n  ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16358,"user_id":null,"body":"(ns clojure.calc-total)\n\n(defn calculate_total [t1 t2]\n  (not (or (= (max (reduce + t1) (reduce + t2)) (reduce + t2)) (= t1 []))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16359,"user_id":null,"body":"(ns clojure.calc-total)\n\n(defn calculate_total [t1 t2]\n  (if (or (= (max (reduce + t1) (reduce + t2)) (reduce + t2)) (= t1 []))\n    false\n    true))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16360,"user_id":null,"body":"(ns clojure.calc-total)\n\n(defn calculate_total [t1 t2]\n  (if (= 0 (reduce + t1) (reduce + t2))\n    false\n    (>= (reduce + t1)\n        (reduce + t2))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16361,"user_id":null,"body":"(ns clojure.calc-total)\n\n(defn calculate_total [t1 t2]\n  (> (reduce max 0 t1)\n     (reduce max 0 t2)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16362,"user_id":null,"body":"(ns clojure.calc-total)\n\n(defn calculate_total\n  [t1 t2]\n  (> (apply + t1)\n     (apply + t2)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16363,"user_id":null,"body":"(ns clojure.calc-total)\n\n(defn calculate_total [t1 t2]\n  (cond (empty? t1) false\n        (empty? t2) true\n        :else (> (reduce + t1) (reduce + t2))\n))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16364,"user_id":null,"body":"(ns clojure.calc-total)\n\n(defn calculate_total [t1 t2]\n  (let [[t1score t2score] (map #(reduce + %) [t1 t2])]\n    (> t1score t2score)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16365,"user_id":null,"body":"(ns clojure.calc-total)\n\n(defn calculate_total [t1 t2]\n  (if (> (reduce + t1) (reduce + t2)) true false))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55d8618adfda93c89600012e":[{"id":16366,"user_id":2967,"body":"(ns how-do-i-compare)\n\n(defn what-is [x]\n  (cond\n    (== x 42) \"everything\"\n    (== x (* 42 42)) \"everything squared\"\n    :else \"nothing\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16367,"user_id":527,"body":"(ns how-do-i-compare)\n\n(defn what-is [x]\n  (cond\n    (= x 42) \"everything\"\n    (= x (* 42 42)) \"everything squared\"\n    :else \"nothing\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16368,"user_id":null,"body":"(ns how-do-i-compare)\n\n(defn what-is [x]\n  (cond\n    (identical? x 42) \"everything\"\n    (identical? (\/ x 42) 42) \"everything squared\"\n    :else \"nothing\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16369,"user_id":null,"body":"(ns how-do-i-compare)\n\n(defn what-is [x]\n  (cond\n    (identical? x 42) \"everything\"\n    (= x (* 42 42)) \"everything squared\"\n    :else \"nothing\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16370,"user_id":527,"body":"(ns how-do-i-compare)\n\n(defn what-is [x]\n  (get {42 \"everything\" (* 42 42) \"everything squared\"} x \"nothing\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16371,"user_id":1703,"body":"(ns how-do-i-compare)\n\n(defn what-is [x]\n  (cond\n    (identical? x 42) \"everything\"\n    (= x 1764) \"everything squared\"\n    :else \"nothing\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16372,"user_id":null,"body":"(ns how-do-i-compare)\n\n(defn what-is [x]\n  (cond\n    (= 42 x) \"everything\"\n    (= (* 42 42) x) \"everything squared\"\n    :else \"nothing\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16373,"user_id":null,"body":"(ns how-do-i-compare)\n\n(defn what-is [x]\n  (cond\n    (= x (* 42 42)) \"everything squared\"\n    (= x 42) \"everything\"\n    :else \"nothing\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16374,"user_id":null,"body":"(ns how-do-i-compare)\n\n(defn what-is [x]\n  (cond\n    (== x 42) \"everything\"\n    (== x 1764) \"everything squared\"\n    :else \"nothing\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16375,"user_id":null,"body":"(ns how-do-i-compare)\n\n; identical_q means same object\n; \u800c\u4e14\u6709\u7684\u6642\u5019\u8ddfJava\u90a3\u908a\u70ba\u4e86\u6548\u80fd\u505acache\u6709\u95dc\n; (identical? 42 42) ; true\n; (identical? 1764 1764) ; false\n(defn what-is [x]\n  (cond\n    (= x 42) \"everything\"\n    (= x (* 42 42)) \"everything squared\"\n    :else \"nothing\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55d8aa568dec9fb9e200004a":[{"id":16376,"user_id":501,"body":"(ns howmany.core)\n\n(defn help [xs]\n    (map (fn [x y] (Math\/abs (-(Integer\/parseInt (str x)) (Integer\/parseInt (str y)))))  (str xs) (rest (str xs))))\n\n(defn sel-number [n d]   \n    (count (filter (fn [x] (every? #(<= % d) (help x)))\n      (filter (fn [x] (= (str x) (clojure.string\/join \"\" (sort (str x))))) \n        (filter (fn [x] (= (count (str x)) (count (set (str x))))) (range 10 (inc n)))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16377,"user_id":53,"body":"(ns howmany.core)\n\n(defn- digits [n]\n  (->> n str (map (comp read-string str))))\n\n(defn- ok? [m d]\n  (loop [ds (digits m) p 0]\n    (cond\n      (empty? ds) true\n      (and (not= 0 p) (or (> (- (first ds) p) d) (<= (first ds) p))) false\n      :else (recur (rest ds) (first ds)))))\n\n(defn sel-number [n d]\n  (loop [m 11 k 0]\n    (cond\n      (> m n) k\n      (ok? m d) (recur (inc m) (inc k))\n      :else (recur (inc m) k))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16378,"user_id":null,"body":"(ns howmany.core)\n\n(defn sel [seled len step]\n  (let [ last-dig\n         (Integer\/parseInt (str (subs seled (dec (count seled)) (count seled))))]\n\n    (cond\n      (<= len (count seled))\n      (list (Integer\/parseInt seled))\n\n      (= last-dig 9)\n      (list nil)\n\n      (= last-dig 0)\n      (mapcat\n          (fn [d-char]\n            (sel (str seled d-char) len step))\n          (range 0 9))\n\n      :else\n      (mapcat\n          (fn [d-char]\n            ;; (println \"about to recur with\" (str seled d-char) len step)\n            (sel (str seled d-char) len step))\n          (range (inc last-dig) (min 10 (+ step (inc last-dig))))))))\n\n(defn sel-number [n d]\n  (let [n-str (str n)]\n    (->> (range 0 (inc (Integer\/parseInt (subs n-str 0 1))))\n      (mapcat\n        (fn [curr]\n          (sel (str curr) (count n-str) d)))\n      (filter identity)\n      (filter #(and (> % 9) (<= % n)))\n      (count))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16379,"user_id":null,"body":"(ns howmany.core)\n(defn digits [n]\n  (->> n\n    str\n    (map (comp #(- % (int \\0)) int))\n    vec))\n\n\n(defn sel-number [n d]\n  (let [distances #(map (fn [[f s]] (- s f)) (partition 2 1 %))\n        all-distances #(every? (partial >= d) (distances %))\n        all-the-check (juxt all-distances #(<= 2 (count %)) (partial apply <))]\n    (count (filter #(every? identity (all-the-check (digits %))) (range (inc n))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16380,"user_id":null,"body":"(ns howmany.core)\n\n(defn number->digits [n]\n  (->> n str (map (comp read-string str))))\n\n(defn adj-diff [xs]\n  (->> (partition 2 1 xs) (map (comp #(apply - %) reverse))))\n\n(defn sel-number [n d]\n  (->> (range 12 (inc n))\n       (filter (fn [x] (->> (number->digits x)\n                            adj-diff\n                            (every? #(<= 1 % d)))))\n       count))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16381,"user_id":null,"body":"(ns howmany.core)\n\n(defn sel-number\n  [number\n   less-equals-num]\n  (as-> (range 12 (inc number)) range\n        (mapv (fn [x]\n                (as-> x num\n                      (str num)\n                      (clojure.string\/split num #\"\")\n                      ((partial map (fn [z] (Integer\/parseInt (str z)))) num)\n                      (vec num)))\n              range)\n        (filterv (fn [coll]\n                   (:res\n                     (reduce (fn [obj num]\n                               (if (and (:res obj) (< (:last obj) num))\n                                 (assoc obj :last num)\n                                 (assoc obj :res false)))\n                             {:last 0\n                              :res  true}\n                             coll)))\n                 range)\n        (mapv (partial partition 2 1) range)\n        (filter (fn [splited-number]\n                  (reduce (fn [obj pair]\n                            (let [calc (- (second pair) (first pair))]\n                              (if (and\n                                    obj\n                                    (<= calc less-equals-num)\n                                    (not= calc 0))\n                                obj\n                                false)))\n                          true\n                          splited-number))\n                range)\n        (map flatten range)\n        (count range)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16382,"user_id":null,"body":"(ns howmany.core)\n\n(defn number->digits [num]\n  (->> num str (map (comp read-string str))))\n\n(defn ascending-digits [n]\n  (apply < (number->digits n)))\n\n(defn difference-between-digits [d n]\n  (let [digits (number->digits n)]\n    (->> (map - (rest digits) digits)\n         (map #(Math\/abs %))\n         (every? (fn [n] (<= n d)))\n         (boolean))))\n\n(defn sel-number [n d]\n  (->> (range 10 (inc n))\n       (filter ascending-digits)\n       (filter (partial difference-between-digits d))\n       (count)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16383,"user_id":null,"body":"(ns howmany.core)\n\n(defn digits [n]\n  (map #(Character\/digit % 10) (str n)))\n\n(defn desired-number? [n d]\n  (let [n (digits n)]\n    (and\n      (>= (count n) 2)\n      (= n (sort n))\n      (= n (distinct n))\n      (every? #(>= % (- d)) (map - n (rest n))))))\n\n(defn sel-number [n d]\n  (->> (range n)\n       (filter #(desired-number? % d))\n       (count)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16384,"user_id":null,"body":"(ns howmany.core)\n\n(defn ascend-num?\n  [arr d]\n  (cond (empty? (rest arr)) true\n        (>= d (- (second arr)\n                 (first arr)))\n        (recur (rest arr) d)\n        :else false))\n\n(defn num2dig\n  [n]\n  (map #(Character\/digit % 10) (str n)))\n\n(defn test-num?\n  [n d]\n  (let [n (num2dig n)]\n    (and (= (sort < (set n));; uniqe numbers\n            (sort < n);;sorted number\n            n)\n         (ascend-num? n d))))\n\n(defn sel-number\n  [n d]\n  (count (filter #(test-num? % d) \n                 (range 12 (inc n)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16385,"user_id":null,"body":"(ns howmany.core\n  (:require [clojure.string :as st]))\n\n;; helpers\n\n(defn split-int \n  \"Given an integer, split it into a list of integers.\"\n  [number]\n  (map #(Integer\/parseInt %) (st\/split (str number) #\"\")))\n\n(defn no-repeating-digits? [n]\n  \"Given an integer, make sure no repeating digits are present.\"\n  (let [digits (split-int n)]\n    (if (< (count (distinct digits)) \n           (count digits))\n      false\n      true)))\n\n(defn sequential-digits? [n]\n  \"Given an integer, make sure all digits are sequential.\"\n  (let [digits (split-int n)\n        checks (map #(< (first %1) (second %1)) \n                    (partition 2 1 digits))]\n    (empty? (filter false? checks))))\n\n(defn within-difference? [digits max-diff]\n  \"Given a list of integers and a max difference, make sure no pair of integers have a difference\n   greater than max difference.\"\n  (let [abs-diff-too-big? (fn [a b] (<= (Math\/abs (- a b)) max-diff))\n        checks (map #(abs-diff-too-big? (first %1) (second %1))\n                    (partition 2 1 digits))]\n    (and \n      (empty? (filter false? checks))\n      (not (empty? checks)))))\n\n;; main fns\n\n(defn find-valid-numbers [xs max-diff]\n  \"Given a list of integers and a max-difference, find numbers that are\n    1. sequential (123 = true, 132 = false)\n    2. no repeating digits (123 = true, 112 = false)\n    3. difference betwen neighboring digits is not > max-diff\n      Given max difference of 1, 12 = true, 13 = false\"\n  (reduce #(let [digits (split-int %2)]\n              (if (and (no-repeating-digits? %2)\n                       (sequential-digits? %2)\n                       (within-difference? digits max-diff))\n                (conj %1 %2)\n                %1))\n          [] \n          xs))\n\n(defn sel-number [limit max-diff]\n  \"Select numbers up to a limit that are 'valid-numbers' (see fn defn).\"\n  (let [min-limit 12\n        number-range (vec (range min-limit (+ limit 1)))]\n    (if (< limit min-limit)\n      0\n      (count (find-valid-numbers number-range max-diff)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55db7b239a11ac71d600009d":[{"id":16386,"user_id":null,"body":"(ns inttriang.core)\n\n(defn whole [n] (== (int n) n))\n\n(defn give-triang [per] \n  (count (filter identity\n    (for [a (range 1 per)\n          b (range 1 per)\n          :let [c (Math\/sqrt (+ (* a a) (* a b) (* b b)))]]\n      (if (and (> b a) (whole c) (<= (+ a b c) per))\n        true\n        false)))\n    )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16387,"user_id":492,"body":"(ns inttriang.core)\n\n(defn outer [per]\n  (for [ a (range 3 (+ 1 (quot per 2))) b (range a (+ 1 (quot (- per a) 2)))\n        :let [u (+ (* a a) (* b b) (* a b)) c (int (Math\/floor (Math\/sqrt u)))]\n        :when (and (= (* c c) u) (<= (+ a b c)per))\n       ]\n    [a b c]\n  ))\n(defn give-triang [per] (count (outer per)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16388,"user_id":53,"body":"(ns inttriang.core)\n\n(defn give-triang [n] \n  (count (flatten\n    (for [a (range 1 n)] \n      (for [b (range (inc a) n) \n            :while (< a (- n b))\n            :let [x (+ (* a a) (* b b) (* a b))\n                  c (int (Math\/sqrt x))]\n            :when (and (= x (* c c)) (> c b) (<= (+ a b c) n))] \n        1)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16389,"user_id":null,"body":"(ns inttriang.core)\n; 120 deg = acos(-0.5)\n; 120 is the largest angle in a triangle with a 120 deg angle\n; using cossine law and subbing above we can see that\n; -0.5 = (a^2 + b^2 -c^2)\/(2ab) \n; ab = c^2 - a^2 - b^2\n; c^2 = a^2 + ab + b^2\n; thereofre an obtuse triangle (a, b, c) a<c, b<c has an angle of 120 iff\n; a^2 + ab + b^2 = c^2.\n; given integers m and n, m>n, n>0\n; let:\n;   a = m\u00b2 - n\u00b2\n;   b = 2mn + n\u00b2\n;   c = m\u00b2 + mn + n\u00b2\n; by algebra we can see that this satisfies the condition above, \n; and will give integer a, b, and c values.\n; when n = 1 and a+b+c>per, stop generating\n(defn vecsum [vect]\n  (reduce + 0 vect))\n  \n(defn scaler-mult [m vect]\n  (reduce (fn [acc item] (conj acc (* m item))) [] vect))\n\n(defn get-triples [per]\n  (loop [n 1 m 2 s [] cont false] \n    (let [a (- (* m m) (* n n))\n          b (+ (* 2 m n) (* n n))\n          c (+ (* m m) (* m n) (* n n))]\n      (if (>= n m)\n        (recur 1 (inc m) s false)\n        (if (< per (+ a b c))\n          (if cont (recur (inc n) m s cont) s)\n          (recur (inc n) m (conj s (sort [a b c])) true))))))\n          \n(defn get-multiples [triples per]\n  (distinct\n    (reduce \n      (fn [acc item] \n        (loop [m 2 v (conj acc item)] \n          (let [s (* m (vecsum item))]\n            (if (> s per) \n              v\n              (recur (inc m) (conj v (scaler-mult m item)))))))\n      []\n      triples)))\n\n(defn give-triang [per] \n  (count (get-multiples (get-triples per) per)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16390,"user_id":null,"body":"(ns inttriang.core)\n\n(defn is-triang [n p]\n  (let [a 1 b (- n p) c (- (* p p) (* 2 n p))\n        d (- (* b b) (* 4 a c))]\n    (if (neg? d) false (let [x1 (\/ (- (Math\/sqrt d) b) (* 2 a))\n                             x2 (\/ (- (- (Math\/sqrt d)) b) (* 2 a))]\n                         (and (zero? (- x1 (int x1))) (or (and (> x1 0) (> (- p x1 n) 1))\n                                                          (and (> x2 0) (> (- p x2 n) 1))))))))\n(defn give-triang [per]\n  (count (for [p (range 4 (inc per))\n               n (range 3 per)\n               :when (and (< n p)\n                          (is-triang n p))] true)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16391,"user_id":null,"body":"(ns inttriang.core)\n\n(defn give-triang [perim]\n  (->> (for [m (range 2 (Math\/sqrt perim))\n             n (range 1 (Math\/sqrt perim))\n             k (range 1 (\/ perim (* m m)))\n             :when (and (< n m) (not= m (mod n 3)))]\n         (set (map (partial * k)\n               [(->> (* m m)\n                     (+ (* m n))\n                     (+ (* n n)))\n                (->> (* 2 m n)\n                     (+ (* n n)))\n                (- (* m m) (* n n))])))\n       distinct\n       (filter #(>= perim (apply + %)))\n       count))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16392,"user_id":null,"body":"(ns inttriang.core)\n\n(defn- a120 [m n] (+ (* m m) (* m n) (* n n)))\n(defn- b120 [m n] (+ (* 2 m n) (* n n)))\n(defn- c120 [m n] (- (* m m) (* n n)))\n(defn- triple-120 [m n] ((juxt a120 b120 c120) m n))\n\n(def gen-triples-120\n  (sort-by\n   (partial reduce +)\n   (take\n    3000\n    (for [m (iterate inc 2)\n          n (iterate inc 1) :while (< n m)\n          :when (-> (- m n) (mod 3) zero? not)]\n      (-> (triple-120 m n) sort)))))\n\n(defn give-triang [per]\n  (count\n   (distinct\n    (mapcat\n     (fn [tri]\n       (take-while\n        (comp #(<= % per) (partial reduce +))\n        (iterate #(map + % tri) tri)))\n     (take-while (comp #(<= % per) (partial reduce +)) gen-triples-120)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16393,"user_id":null,"body":"(ns inttriang.core)\n\n(defn give-triang [per]\n  (->> (for [a (range 1 (inc (\/ per 2)))\n             b (range 1 (inc (\/ per 2)))\n             :while (> a b)]\n         [a b (Math\/sqrt (+ (* a a) (* b b) (* a b)))])\n       (filter (fn [[a b c]]\n                 (and (<= (+ a b c) per) (integer? (rationalize c)))))\n       (count)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16394,"user_id":null,"body":"(ns inttriang.core)\n\n(defn gcd [a b]\n  (loop [a a b b]\n    (if (zero? b)\n      a\n      (recur b (rem a b))\n    ) \n  )\n)\n\n\n(defn give-triang [per]\n  (let [maxm (int (Math\/pow (\/ per 2) 0.5))]\n    (apply + \n      (for [m (range 1 (inc maxm)) \n            n (range 1 m) \n            :let [p (+ (* 3 m n) (* 2 m m) (* n n))]\n            :when  (and (= (gcd m n) 1) (> (rem (- m n) 3)0))\n            :while (<= p per)\n           ]\n        (quot per (+ (* 3 m n) (* 2 m m) (* n n)))\n      )\n    )\n  )\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16395,"user_id":null,"body":"(ns inttriang.core)\n\n(defn fixed-bc  [r b b2 c2]\n    (let [a-ini (int (\/ (- c2 b2) (+ b b)))\n          a-max (min (- b 1) r (+ 1 (int (\/ (- c2 b2) (+ b 1)))))]\n      (loop [\n            det (- c2 b2 (* a-ini (+ b a-ini)))\n            a a-ini]\n      (if-not (and (<= a a-max) (> det 0))\n        (if (and (<= a a-max) (zero? det))\n              1 0)\n        (recur\n          (- det b a a 1)\n          (inc a))))))\n\n(defn fixed-bc-even  [r b b2 c2]\n    (let [a-pre-ini (int (\/ (- c2 b2) (+ b b)))\n          a-ini (* 2 (quot (+ 1 a-pre-ini) 2))\n          a-max (min (- b 1) r (+ 1 (int (\/ (- c2 b2) (+ b 1)))))]\n      (loop [\n            det (- c2 b2 (* a-ini (+ b a-ini)))\n            a a-ini]\n      (if-not (and (<= a a-max) (> det 0))\n        (if (and (<= a a-max) (zero? det))\n              1 0)\n        (recur\n          (- det b b a a a a 4)\n          (+ a 2))))))\n\n(defn    fixed-bc-odd  [r b b2 c2]\n    (let [a-pre-ini (int (\/ (- c2 b2) (+ b b)))\n          a-ini (inc (* 2 (quot a-pre-ini 2)))\n          a-max (min (- b 1) r (+ 1 (int (\/ (- c2 b2) (+ b 1)))))]\n      (loop [\n            det (- c2 b2 (* a-ini (+ b a-ini)))\n            a a-ini]\n      (if-not (and (<= a a-max) (> det 0))\n        (if (and (<= a a-max) (zero? det))\n              1 0)\n        (recur\n          (- det b b a a a a 4)\n          (+ a 2))))))\n\n(defn    fixed-c  [r c c2] \n    (let [b-ini (int (\/ c 1.733))]\n    (loop [\n          sol 0\n          b (if (even? c) (* 2 (quot (+ 1 b-ini) 2)) b-ini)\n          b2 (* b b)]\n      (if (<= c2 (+ b2 b b 4 ))\n        sol\n        (recur\n          (+ sol (\n            (cond\n              (even? c) fixed-bc-even \n              (even? b) fixed-bc-odd\n              :else fixed-bc) (- r b) b b2 c2))\n          (if (even? c) (+ b 2) (inc b))\n          (if (even? c) (+ b2 b b b b 4) (+ b2 b b 1))\n            )))))\n\n\n(defn give-triang [p] \n    (loop\n      [\n      sol 0\n      c2 49\n      c 7]\n      (if (< p (+ c c 1))\n        sol\n        (recur\n          (+ sol (fixed-c (- p c) c c2))\n          (+ c2 c c 1)\n          (inc c))))\n      )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55de8eabd9bef5205e0000ba":[{"id":16396,"user_id":null,"body":"(ns emirps.core)\n\n(def reverse-num\n  (memoize\n   (fn [n]\n     (loop [n n\n            rn 0]\n       (let [rn (+ (rem n 10) (* rn 10))\n             n (quot n 10)]\n         (if (zero? n)\n           rn\n           (recur n rn)))))))\n\n(defn add-if-emirp [primes candidate]\n  (letfn [(possible-factors [x]\n            (into (:primes primes)\n                  (range candidate (Math\/sqrt x))))\n          (not-prime? [x]\n            (not (.isProbablePrime (java.math.BigInteger\/valueOf x) 10)))\n          (not-emirp? [x]\n            (and (not (contains? (:emirps primes) (reverse-num x)))\n                 (or (= (reverse-num x) x)\n                     (not-prime? (reverse-num x)))))\n          (add-primes [primes x]\n            (update primes :primes conj x))\n          (add-emirps [primes x]\n            (-> (update primes :emirps conj x)\n                (update :primes conj x)))]\n    (cond\n      (not-prime? candidate) primes\n      (not-emirp? candidate) (add-primes primes candidate)\n      :else (add-emirps primes candidate))))\n\n(defn find-emirp [n]\n  (let [{:keys [emirps] :as primes}\n        (reduce add-if-emirp\n                {:n n\n                 :primes #{2 3 5 7 11}\n                 :emirps #{}}\n                (range 13 n 2))]\n    [(count emirps)\n     (and (seq emirps) (apply max emirps))\n     (apply + emirps)]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16397,"user_id":492,"body":"(ns emirps.core)\n\n(defn div? [p nb] (= (rem nb p) 0))\n(defn backwards [s] (Integer\/parseInt (clojure.string\/join (reverse (str s)))))\n(defn prime? [n]\n  (if (< n 2)\n    false\n    (empty? (filter #(div? % n) (take-while #(<= (* % %) n) (range 2 n))))))\n(defn backwards-prime [start nd]\n  (let [res (for [x (range start (inc nd))] \n                  (if (and (not= x (backwards x)) (prime? x) (prime? (backwards x)))\n                    x))]\n    (vec (filter identity res))))\n(defn find-emirp [n]\n  (let [r (backwards-prime 0 n)]\n    [(count r) (apply max r) (reduce + r)]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16398,"user_id":null,"body":"(ns emirps.core)\n\n(defn reverse-int [n] (Integer\/parseInt (apply str (reverse (str n)))))\n\n;; To avoid garbage collection\n;; reimplementing every? and some\n;; can yield benefits\n(defn -every? [pred coll]\n  (reduce (fn [acc i]\n            (if (not (pred i))\n              (reduced false)\n              acc))\n          true\n          coll))\n\n(defn -some [pred coll]\n  (reduce (fn [acc i]\n            (if (pred i)\n              (reduced i)\n              acc))\n          nil\n          coll))\n\n(defn prime\n ([-max] (cond-> [] (>= -max 1) (prime 2 -max)))\n  ([primes -max] (prime primes\n                        (if (seq primes)\n                                 (inc (peek primes))\n                                 2)\n                        -max))\n  ([primes ^long x -max] (cond-> primes\n                     (-every? (fn [^long p-number] (pos? (Math\/floorMod x p-number)))  primes) (conj x)\n                     (< x -max) (recur (inc x) -max))))\n\n(defn is-palindrome [p]\n  (loop [p-str (vec (str p))]\n    (cond\n      (empty? p-str) true\n      (not= (first p-str) (peek p-str)) false\n      :else (recur (vec (rest (butlast p-str)))))))\n\n(defn is-emirp []\n  (fn is-emirp-transducer [xf]\n    (let [cache (volatile! [])]\n      (completing (fn is-emirp-reducing [result p-number]\n                    (let [reversed (reverse-int p-number)]\n                      (when (> reversed (or (peek @cache) 0))\n                        (vswap! cache prime reversed))\n                      (cond-> result\n                        (-some #(= reversed %) @cache) (xf p-number))))))))\n\n(defn find-emirp [n]\n  (transduce\n    (is-emirp)\n    (completing (fn reducing-fn [[qtd biggest sum] last-val]\n      [(inc qtd) (max biggest last-val) (+ sum last-val)]))\n    [0 0 0]\n    (eduction\n      (drop 4) ;; The first for primes are not palindrome\n      (remove is-palindrome)\n      (prime n))))\n\n;; user=> (time (find-emirp 2000))\n;; \"Elapsed time: 2712.509168 msecs\"\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16399,"user_id":62,"body":"(ns emirps.core)\n\n(def primes\n  (lazy-cat [2]\n            (filter (fn [n] \n                      (not-any? \n                       #(zero? (mod n %)) \n                       (take-while #(<= (* % %) n) primes)))\n                    (iterate inc 3))))\n\n(defn find-emirp [n]\n  (let [upper-bound (Math\/pow 10 (count (str n)))\n        primes* (->> primes (take-while #(< % upper-bound)) set)\n        ]\n    (->> primes*\n         (filter #(< % n))\n         (map (juxt identity (comp #(Integer\/parseInt %) (partial apply str) reverse str)))\n         (remove (partial apply =)) ;; remove palindromes \n         (filter (comp primes* second))\n         (map first)\n         ((juxt count (partial apply max) (partial reduce +)))\n    )))\n          ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16400,"user_id":null,"body":"(ns emirps.core)\n\n(def primes\n  (lazy-seq\n   (filter (fn [i] (not-any? #(zero? (rem i %))\n                             (take-while #(<= (* % %) i) primes)))\n           (drop 2 (range)))))\n\n(defn primes-below [n]\n  (into #{} (take-while (fn [p] (<= p n)) primes)))\n\n(defn reverse-prime [p]\n  (read-string (clojure.string\/reverse (str p))))\n\n(defn find-emirp [n]\n  (let [ps (primes-below n)\n        rps (primes-below (apply max (map reverse-prime ps)))\n        emirps (filter (fn [p] (let [rp (reverse-prime p)]\n                                 (and\n                                  (not (= p rp))\n                                  (contains? rps rp)))) ps)]\n    (if (empty? emirps)\n      [0 0 0]\n      [(count emirps) (apply max emirps) (reduce + emirps)])))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16401,"user_id":null,"body":"(ns emirps.core)\n\n(defn primality-check [x]\n  (every? #(not (integer? (\/ x %))) (range 2 (inc (Math\/sqrt x)))))\n\n(defn within-powers-of-ten [n]\n  (first (drop-while #(< % n) (iterate #(* 10 %) 1))))\n\n(defn reverse-num [x]\n  (Integer\/parseInt (apply str (reverse (str x)))))\n\n(defn prime-set-gen [bound]\n  (take-while #(<= % bound) (filter primality-check (iterate inc 2))))\n\n(defn emirp-set-gen [bound]\n  (let [large-prime-list (prime-set-gen (within-powers-of-ten bound))\n        large-prime-set (into #{} large-prime-list)\n        prime-list (take-while #(<= % bound) large-prime-list)]\n    (->> prime-list\n         (filter #(not= (reverse-num %) %))\n         (filter #(large-prime-set (reverse-num %))))))\n\n(defn find-emirp [n]\n  (let [emirps (emirp-set-gen n)]\n    [(count emirps) (last emirps) (reduce + emirps)]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16402,"user_id":null,"body":"(ns emirps.core (:require [clojure.string :refer [reverse]]\n                          [clojure.set :refer [intersection]]))\n\n(def primes\n  (concat\n   [2 3 5 7]\n   (lazy-seq\n    (let [primes-from\n          (fn primes-from [n [f & r]]\n            (if (some #(zero? (rem n %))\n                      (take-while #(<= (* % %) n) primes))\n              (recur (+ n f) r)\n              (lazy-seq (cons n (primes-from (+ n f) r)))))\n          wheel (cycle [2 4 2 4 6 2 6 4 2 4 6 6 2 6  4  2\n                        6 4 6 8 4 2 4 2 4 8 6 4 6 2  4  6\n                        2 6 6 4 2 4 6 2 6 4 2 4 2 10 2 10])]\n      (primes-from 11 wheel)))))\n\n(defn reverse-digits [n]\n  (Long\/parseLong (reverse (str n))))\n\n(defn find-emirp [n]\n  (let [possibles (->> (take-while #(<= % n) primes)\n                       (filter #(not= % (reverse-digits %)))\n                       (map reverse-digits))\n        largest   (apply max possibles)\n        results   (->> (take-while #(<= % largest) primes)\n                       set\n                       (intersection (set possibles))\n                       (map reverse-digits))]\n\n    ((juxt count #(apply max %) #(apply + %))\n     results)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16403,"user_id":null,"body":"(ns emirps.core)\n\n(defn- is-prime? [n]\n  (.isProbablePrime (BigInteger\/valueOf n) 15))\n\n(defn- reverse-num [n]\n  (->> n\n    str\n    clojure.string\/reverse\n    Float\/valueOf))\n\n(defn- is-not-palindrome? [n]\n  (let [n-str (str n)]\n    (not= n-str (clojure.string\/reverse n-str))))\n\n(defn- primes [n]\n  (filter is-prime? (range 2 n)))\n\n(defn find-emirp [n]\n  (let [ps (primes n)\n        emirps (filter #(and (is-not-palindrome? %) (is-prime? (reverse-num %))) ps)]\n    [(count emirps) (apply max emirps) (reduce + emirps)]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16404,"user_id":null,"body":"(ns emirps.core\n  (:require clojure.set))\n\n;(defn- is-prime? [n]\n;  (->> (range 2 (Math\/ceil (\/ n 2)))\n;    (some #(zero? (rem n %)))\n;    not))\n\n(defn- is-prime? [n]\n  (.isProbablePrime (BigInteger\/valueOf n) 15))\n\n(defn- reverse-num [n]\n  (->> n\n    str\n    clojure.string\/reverse\n    Float\/valueOf))\n\n(defn- is-not-palindrome? [n]\n  (let [n-str (str n)]\n    (not= n-str (clojure.string\/reverse n-str))))\n\n(defn- sieve-of-eratosthenes [n]\n  (filter is-prime? (range 2 n)))\n  ;(loop [step 2\n  ;       primes (sorted-set 2)\n  ;       candidates (apply sorted-set (range 2 n))]\n  ;  (let [new-candidates (clojure.set\/difference candidates (apply sorted-set (range step n step)))]\n  ;    (if (empty? new-candidates)\n  ;      primes \n  ;      (recur (apply min new-candidates) (conj primes (first new-candidates)) new-candidates)))))\n\n(defn find-emirp [n]\n  (let [ps (sieve-of-eratosthenes n)\n        emirps (filter #(and (is-not-palindrome? %) (is-prime? (reverse-num %))) ps)]\n    [(count emirps) (apply max emirps) (reduce + emirps)]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16405,"user_id":null,"body":"(ns emirps.core)\n\n(defn parse-int [s]\n   (Integer. (re-find  #\"\\d+\" s )))\n\n(defn root-1 [x]\n    (inc (long (Math\/sqrt x))))\n\n(defn range-1 [x]\n  (range 2 (root-1 x)))\n\n(defn filter-1 [x]\n  (filter #(zero? (rem x %))\n        (range-1 x)))\n\n(defn prime? [x]\n  (nil? (first (filter-1 x))))\n\n(defn find-emirp [n]\n  (let [palindromic? (fn [x] (let [r-x (parse-int (apply str (reverse (str x))))] (and \n                                                                        (prime? x) \n                                                                        (not= x r-x)\n                                                                        (prime? r-x))))\n        result (filter palindromic? (range (inc n)))]\n    [(count result) (last result) (reduce + result)]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55e0a2af50adf50699000126":[{"id":16406,"user_id":1200,"body":"(ns only-odd-dig-primes.core)\n\n(defn only-odd-digprime [n]\n  (let [primes (iterate #(.nextProbablePrime %) (biginteger 2N))\n        odp (filter #(re-find #\"^[13579]+$\" (str %)) primes)\n        [sodp bodp] (split-with #(<= % n) odp)]\n    [(count sodp) (last sodp) (first bodp)]))\n\n; I hate broken tests. -1\n(defn div? [a b] (= (mod b a) 0))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16407,"user_id":53,"body":"(ns only-odd-dig-primes.core)\n\n(defn div? [d n] \n  (zero? (mod n d)))\n\n(defn digits [n]\n  (->> n str (map (comp read-string str))))\n\n(defn has-odd-digits? [n]\n  (every? odd? (digits n)))\n\n(defn is-prime? [n]\n  (loop [i 2]\n    (if (> i (Math\/sqrt n))\n      (> n 1)\n      (if (div? i n)\n        false\n        (recur (inc i))))))\n\n(defn is-kata-prime? [n]\n  (and (has-odd-digits? n) (is-prime? n)))\n\n(defn next-kata-prime [n]\n  (loop [p (inc n)]\n    (if (is-kata-prime? p)\n      p\n      (recur (inc p)))))\n\n(defn kata-primes-upto [n]\n  (loop [p 2 ps []]\n    (cond\n      (>= p n) ps\n      (is-kata-prime? p) (recur (inc p) (cons p ps))\n      :else (recur (inc p) ps))))\n\n(defn only-odd-digprime [n]\n  (let [m (next-kata-prime n)\n        ps (kata-primes-upto n)]\n    (list (count ps) (first ps) m)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16408,"user_id":168,"body":"(ns only-odd-dig-primes.core)\n\n(defn div? [d n] (zero? (mod n d)))\n\n(defn is-pure-odd-prime [n]\n  (and (not (re-find #\"[02468]\" (str n)))\n       (.isProbablePrime (biginteger n) 10)))\n\n(defn only-odd-digprime [n]\n  (let [below (filter is-pure-odd-prime (range 3 n 2))\n        above (first (filter is-pure-odd-prime (range (inc n) (+ n 1000000) 1)))]\n    [(count below), (last below), above]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16409,"user_id":null,"body":"(ns only-odd-dig-primes.core)\n\n(defn div? [d n] (zero? (mod n d)))\n\n(def primes\n  (concat\n   [2 3 5 7]\n   (lazy-seq\n    (let [primes-from (fn primes-from [n [f & fs]]\n                        (if (some #(zero? (rem n %))\n                                  (take-while #(<= (* % %) n) primes))\n                          (recur (+ n f) fs)\n                          (lazy-seq (cons n (primes-from (+ n f) fs)))))\n          wheel (cycle [2 4 2 4 6 2 6 4 2 4 6 6 2 6  4  2\n                        6 4 6 8 4 2 4 2 4 8 6 4 6 2  4  6\n                        2 6 6 4 2 4 6 2 6 4 2 4 2 10 2 10])]\n      (primes-from 11 wheel)))))\n\n(defn- digits [n]\n  (->> n (iterate #(quot % 10)) (take-while pos?) (mapv #(mod % 10)) rseq))\n\n(defn- odd-digits? [n]\n  (every? odd? (digits n)))\n\n(def some-odd-primes\n  (->> primes (take-while (partial > 1000000)) (filter odd-digits?) vec))\n\n(defn- do-next [n c [x y z :as ps]]\n  (cond\n    (< y n) #(do-next n (inc c) (rest ps))\n    (= y n) [(+ c 2) x z]\n    (> y n) [(inc c) x y]))\n\n(defn only-odd-digprime [n]\n  (trampoline do-next n 0 some-odd-primes))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16410,"user_id":null,"body":"(ns only-odd-dig-primes.core)\n\n (defn div? [d n] (zero? (mod n d))) \n\n(defn is-prime? [n]\n  (if (not= (mod n 2) 0) true false))\n  \n(defn prime? [n]\n  (if (even? n) false\n      (let [root (num (int (Math\/sqrt n)))]\n\t(loop [i 3]\n\t  (if (> i root) true\n\t      (if (zero? (mod n i)) false\n\t\t  (recur (+ i 2))))))))\n\n(defn split-digits [n]\n  (map #(int %) (seq (str n))))\n\n(defn is-prime-prime? [n]\n  (if (prime? n)\n    (every? odd? (split-digits n))\n    false))\n  \n(defn first-bigger-prime [n]\n  (let [s (+ 1 n)]\n    (loop [s (+ 1 n)] \n      (if (is-prime-prime? s)\n        s\n        (recur (+ s 1))))))\n  \n(defn only-odd-digprime [n]\n    (loop [prime 3 primes []]\n      (if (>= prime n)\n        (conj [] (count primes) (last primes) (first-bigger-prime n))      \n        (recur (+ prime 1)(if (is-prime-prime? prime) (conj primes prime) primes))))\n  )\n  \n\n  \n  \n  \n\n\n      ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16411,"user_id":null,"body":"(ns only-odd-dig-primes.core)\n\n(defn odd-digits? [x]\n  (and (odd? x)\n       (or (< x 10)\n           (odd-digits? (quot x 10)))))\n\n(def primes\n  (let [reinsert (fn [table x prime] (update-in table [(+ prime x)] conj prime))\n        step (fn step [table d]\n               (if-let [factors (get table d)]\n                 (recur (reduce #(reinsert %1 d %2) (dissoc table d) factors) (inc d))\n                 (lazy-seq (cons d (step (assoc table (* d d) (list d)) (inc d))))))]\n    (step {} 2)))\n\n(def odd-primes (filter odd-digits? primes))\n\n(defn only-odd-digprime [n]\n  (let [less (take-while #(<= % n) odd-primes)\n        n (count less)]\n    [n (last less) (nth odd-primes n)]))\n    \n;; ??\n(defn div? [d n] (zero? (mod n d)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16412,"user_id":492,"body":"(ns only-odd-dig-primes.core)\n\n(defn div? [p nb] (= (rem nb p) 0))\n(defn prime? [n]\n  (if (< n 2)\n    false\n    (empty? (filter #(div? % n) (take-while #(<= (* % %) n) (range 2 n))))))\n(defn good-digits [x]\n  (let [ a (vec (map #(Character\/getNumericValue %) (str x))) ]\n    (loop [ i 0 b true]\n      (if (or (= b false) (= i (count a)))\n        b\n        (let [ p (a i) ]\n          (if (odd? p)\n            (recur (inc i) true)\n            (recur (inc i) false)))))))\n(defn nb-primeaux [n]\n  (and (prime? n) (good-digits n)))\n(defn only-odd-digprime [n]\n  (let [ r (filter nb-primeaux (range 3 (+ 1 n))) \n         cnt (count r)\n         mx (apply max r)\n         k (first (filter nb-primeaux (range (+ 1 n) (java.lang.Integer\/MAX_VALUE))))\n       ]\n    [cnt mx k]))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55e2adece53b4cdcb900006c":[{"id":16413,"user_id":null,"body":"(ns tortoise.core)\n\n(defn remainder [t]\n  (* 60 (mod t 1)))\n\n(defn race [v1 v2 g]\n  (if (> v2 v1)\n    (let [h (float (\/ g (- v2 v1)))\n          m (remainder h)\n          s (remainder m)]\n      (map int [h m s]))\n    [-1,-1,-1]))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16414,"user_id":null,"body":"(ns tortoise.core)\n\n(defn times [n]\n  (lazy-seq (cons (int n) (times (* (- n (int n)) 60)))))\n\n(defn race [v1 v2 g]\n  (if (>= v1 v2) [-1,-1,-1] (take 3 (times (\/ g (- v2 v1))))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16415,"user_id":null,"body":"(ns tortoise.core)\n\n(defn race [v1 v2 g]\n  (if (<= v2 v1)\n    [-1,-1,-1]\n    (let [t (\/ g (- v2 v1))\n          h (int t)\n          m (* (mod t 1) 60)\n          s (* (mod m 1) 60)]\n            [h (int m) (int s)])))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16416,"user_id":null,"body":"(ns tortoise.core)\n\n(defn race [v1 v2 g]\n  (if (< v1 v2)\n    (let [round60 #(* 60 (mod % 1))\n          t (\/ g (- v2 v1))]\n      (vec (map int (take 3 (iterate round60 t)))))\n    [-1,-1,-1]))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16417,"user_id":null,"body":"(ns tortoise.core)\n\n(defn race [v1 v2 g]\n  (when (> v2 v1)\n    (let [s (\/ g (- v2 v1))\n          h (int s)\n          m (int (* 60 (- s h)))\n          s (int (* 3600 (- s h (\/ m 60))))]\n      [h m s])))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16418,"user_id":null,"body":"(ns tortoise.core)\n\n(defn spread [t]\n  (println t)\n  (let [h (int t)\n        r1 (* (- t h) 60)\n        m (int r1)\n        r2 (* (- r1 m) 60)\n        s (int r2)]\n        [h m s]\n  )\n)\n\n(defn race [v1 v2 g]\n  (cond\n  (>= v1 v2) [-1,-1,-1]\n  :else (spread (\/ g (- v2 v1)))\n  )\n)","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16419,"user_id":492,"body":"(ns tortoise.core)\n\n(defn race [v1 v2 g]\n (if (<= (- v2 v1) 0)\n   [-1,-1,-1]\n   (let [d (- v2 v1) \n         h (quot g d)\n         r (mod g d)\n         mn (quot (* 60 r) d)\n         s (quot (* (mod (* 60 r) d) 60) d)\n        ]\n     [h mn s])))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16420,"user_id":null,"body":"(ns tortoise.core)\n\n(defn race [v1 v2 g]\n ; your code\n  (if (< v2 v1) [-1,-1,-1] \n  (let [thours (\/ g ( - v2 v1))]\n    [(int thours) \n     (mod (int (* 60 thours)) 60)\n     (int (* (- (* 60 thours) \n             (int (* 60 thours))) 60)) \n     \n                                ]\n    )))\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16421,"user_id":null,"body":"(ns tortoise.core)\n\n(defn race [v1 v2 g]\n  (if (>= v1 v2)\n    [-1,-1,-1]\n    (let [t (int (\/ g (\/ (- v2 v1) 3600)))]\n      (list (quot t 3600)\n            (quot (rem t 3600) 60)\n            (rem t 60)))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16422,"user_id":null,"body":"(ns tortoise.core)\n\n(defn race [v1 v2 g]\n  (let [ss (Math\/floor (* (\/ 1 (\/ (- v2 v1) 3600)) g))]\n    (if (pos? ss)\n      (let [h (int (Math\/floor (\/ ss 3600)))\n            remaining (- ss (* h 3600))\n            m (int (Math\/floor (\/ remaining 60)))\n            s (int (- remaining (* m 60)))]\n        [h m s])\n      [-1,-1,-1])))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55e6f5e58f7817808e00002e":[{"id":16423,"user_id":3082,"body":"(ns divpar7.core)\n\n(defn seven [m]\n  (loop [m m steps 0]\n    (if (< m 100)\n        [m, steps] \n        (let [x (quot m 10)\n              y (rem m 10)]\n          (recur (- x (* 2 y)) (inc steps))))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-28 16:01:55"},{"id":16424,"user_id":null,"body":"(ns divpar7.core)\n\n(defn seven [m]\n  (let [rule (fn [n] (- (quot n 10) (* 2 (rem n 10))))\n        f (fn [[n counter]] [(rule n) (inc counter)])]\n    (first (drop-while #(>= (first %) 100) (iterate f [m 0])))))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-28 15:54:47"},{"id":16425,"user_id":null,"body":"(ns divpar7.core)\n\n(defn seven [m]\n  (let [terms (iterate #(- (quot % 10) (* 2 (mod % 10))) m)\n        [taken dropped] (split-with (partial < 99) terms)]\n    [(first dropped) (count taken)]))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-28 15:55:18"},{"id":16426,"user_id":53,"body":"(ns divpar7.core)\n\n(defn seven [n]\n  (loop [cnt 0 m n]\n    (if (<= m 99)\n      [m cnt]\n      (recur (inc cnt) (- (quot m 10) (* 2 (mod m 10)))))))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-28 15:55:42"},{"id":16427,"user_id":null,"body":"(ns divpar7.core)\n\n(defn helper [s n]\n  (if (> 100 n) [n s]\n      (helper (inc s) (- (quot n 10) (* 2 (mod n 10))))))\n\n(defn seven [m]\n  (helper 0 m))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-28 15:55:47"},{"id":16428,"user_id":null,"body":"(ns divpar7.core)\n(defn rd [n]\n    (- (quot n 10) (* 2 (mod n 10))))\n(defn seven [m]\n   (->> [m 0]\n       (iterate (fn[[a i]][(rd a) (inc i)]))\n       (drop-while #(<= 100 (first %)))\n       (first)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16429,"user_id":492,"body":"(ns divpar7.core)\n\n(defn seven [m]\n  (defn sevenAux [m cnt]\n    (if (<= m 99)\n      [m cnt]\n      (let [a0 (mod m 10)\n            m (- (\/ (- m a0) 10) (* 2 a0))\n           ]\n        (sevenAux m (inc cnt)))))\n  (sevenAux m 0))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16430,"user_id":564,"body":"(ns divpar7.core)\n\n(defn seven [m]\n  (defn more-sevenish [n]\n    (- (quot n 10)\n       (* 2 (mod n 10))))\n  (defn sevenish [n steps]\n    (if (< n 100)\n      [n steps]\n      (sevenish (more-sevenish n) (inc steps))))\n  (sevenish m 0))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16431,"user_id":null,"body":"(ns divpar7.core)\n\n(defn seven\n  ([m]\n   (if (zero? m)\n     [0 0]\n     (seven m 1)))\n  ([m steps]\n   (let [c (- (quot m 10)\n              (* 2 (rem m 10)))]\n     (if (< c 100)\n       [c steps]\n       (seven c (inc steps))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16432,"user_id":null,"body":"(ns divpar7.core)\n\n(defn seven \n  ([m]\n   (if (zero? m)\n     [0 0]\n     (seven m 1)))\n  ([m steps]\n   (let [converted (- (->> (str m) butlast (apply str) read-string)\n                      (* 2 (mod m 10)))]\n     (if (< converted 100)\n       [converted steps]\n       (seven converted (inc steps))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55e7280b40e1c4a06d0000aa":[{"id":16433,"user_id":492,"body":"(ns sumofk.core)\n\n(defn som [l] (reduce + l))\n\n(defn comb [n items]\n  (cond\n    (= n 0) '(())\n    (empty? items) '()\n    :else (concat (map\n                    #(cons (first items) %)\n                    (comb (dec n) (rest items)))\n                  (comb n (rest items)))))\n\n(defn choose_best_sum [t k ls]\n  (let [ a (comb k ls) mx -1 res [] \n         b (map som a)         \n         c (filter (fn [x] (<= x t)) b)\n         d (if (empty? c)\n             -1\n             (apply max c))\n       ] \n    d\n    ))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16434,"user_id":53,"body":"(ns sumofk.core)\n\n(defn perm [arr]\n  (loop [acc (list nil) ls arr]\n    (if (empty? ls)\n      acc\n      (let [hd (first ls)\n            tl (rest ls)\n            ys (map (fn [xs] (conj xs hd)) acc)\n            acc1 (concat acc ys)]\n        (recur acc1 tl)))))\n\n(defn best-sum [t k arr]\n  (->> (perm arr)\n       (filter #(= k (count %)))\n       (map #(reduce + %))\n       (filter #(<= % t))\n    ))\n\n(defn choose_best_sum [t k arr]\n  (let [ls (best-sum t k arr)]\n    (if (empty? ls)\n      -1\n      (reduce max ls))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16435,"user_id":492,"body":"(ns sumofk.core)\n\n(defn som [l] (reduce + l))\n\n(defn comb [n items]\n  (cond\n    (= n 0) '(())\n    (empty? items) '()\n    :else (concat (map\n                    #(cons (first items) %)\n                    (comb (dec n) (rest items)))\n                  (comb n (rest items)))))\n\n(defn choose_best_sum [t k ls]\n  (let [ a (comb k ls) mx -1 res [] \n         b (map som a)         \n         c (filter (fn [x] (<= x t)) b)\n         d (if (empty? c)\n             -1\n             (apply max c))\n       ] \n    d\n    ))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16436,"user_id":null,"body":"(ns sumofk.core)\n\n(defn subsets [n items]\n  (cond\n    (= n 0) '(())\n    (empty? items) '()\n    :else (concat (map\n                   #(cons (first items) %)\n                   (subsets (dec n) (rest items)))\n                  (subsets n (rest items)))))\n\n(defn choose_best_sum [t k ls]\n  (->> (subsets k ls)\n       (map #(apply + %))\n       (filter #(<= % t))\n       (not-empty)\n       (sort)\n       (last)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16437,"user_id":null,"body":"(ns sumofk.core)\n\n(defn combinations\n  ([k xs] (combinations k xs []))\n  ([k xs r]\n   (cond (< k 1) [[]]\n         (empty? xs) r\n         :otherwise (let [x (first xs)\n                          ns (combinations (dec k) (rest xs))]\n                      (recur k\n                             (rest xs)\n                             (concat r\n                                     (map #(conj % x) ns)))))))\n\n(defn sum [l] (reduce + l))\n\n(defn choose_best_sum [t k ls]\n  (let [routes (combinations k ls)\n        distances (map sum routes)\n        candidates (filter #(<= % t) distances)]\n    (if (not (empty? candidates))\n      (apply max candidates))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16438,"user_id":null,"body":"(ns sumofk.core)\n\n(defn select-n [n lst]\n  (defn prepend-to-all [x xss]\n    (map #(cons x %) xss))\n  (let [len (count lst)]\n    (cond \n      (zero? n) [[]]\n      (< n len) (concat (prepend-to-all (first lst)\n                                (select-n (dec n) \n                                          (rest lst)))\n                        (select-n n (rest lst)))\n      (= n len) (prepend-to-all (first lst)\n                                (select-n (dec n) \n                                          (rest lst)))\n      :else [])))\n\n(defn choose_best_sum [t k ls]\n  (let [sums (->> (select-n k ls)\n               (map #(reduce + %))\n               (filter #(<= % t)))]\n    (when (not (empty? sums))\n      (apply max sums))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16439,"user_id":null,"body":"(ns sumofk.core)\n\n(defn combo [m n]\n  (loop [x (map vector (range n))\n         y 1]\n    (if (= y m)\n      x\n      (recur (for [i x\n                   j (range n)\n                   :when (every? #(> j %) i)]\n               (conj i j))\n             (inc y)))))\n\n(defn comb [k ls]\n  (let [combos (combo k (count ls))]\n    (map (fn [v]\n           (map #(ls %) v)) combos)))\n\n(defn som [l] (reduce + l))\n\n(defn som [l] (reduce + l))\n\n(defn choose_best_sum [t k ls]\n  (let [ a (comb k ls) mx -1 res [] \n         b (map som a)         \n         c (filter (fn [x] (<= x t)) b)\n         d (if (empty? c)\n             -1\n             (apply max c))\n       ] \n    d\n    ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16440,"user_id":168,"body":"(ns sumofk.core)\n\n(defn comb [t k ls]\n  (cond\n    (neg? t) (\/ -1.0 0)\n    (zero? k) 0\n    (empty? ls) (\/ -1.0 0)\n    :else (max (comb t k (rest ls))\n               (+ (first ls) (comb (- t (first ls)) (dec k) (rest ls))))))\n\n(defn choose_best_sum [t k ls]\n  (let [r (comb t k ls)]\n    (if (neg? r) -1 r)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16441,"user_id":null,"body":"(ns sumofk.core)\n\n(defn comb [k ls]\n  \"Returns all combinations of k different elements of sequence ls\"\n    (cond\n      (= k 0) '(-1)\n      (empty? ls) -1\n      :else (concat (map #(conj % (first ls))\n                         (comb (dec k) (rest ls)))\n                    (comb k (rest ls)))))\n\n(defn choose_best_sum [t k ls]\n  (let [sums (->> (comb k ls)\n                  (map #(reduce + %))\n                  (filter #(<= % t)))]\n    (if (empty? sums)\n      -1\n      (apply max sums))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16442,"user_id":null,"body":"(ns sumofk.core)\n\n(defn groups-of-one\n  \"Returns the initial data structure, a list of list of\n  one item groups for each value in the `xs` seq.\n  Ex: (groups-of-one [6 3 4]) \n  => [ [[6]] [[3]] [[4]]] \"\n  [xs]\n  (map #(vector (vector %)) xs))\n\n(defn dispatch \n  \"Returns a new list of groups list where `v` is added to \n  all existing groups in `grps`\n  Ex: (dispatch 99  [ [[:a]  [:b]]\n                      [[:c]  [:d]] ])\n  => ([:a 99] [:b 99] [:c 99] [:d 99])\"\n  [v grps]\n  (->> grps\n       (reduce #(into %1 %2) [])\n       (map #(conj % v))))\n\n(defn dispatch-all \n  \"Dispatch all values from `distances` to groups to get a list\n  of new groups with one item more.\n  Ex:  (dispatch-all [1 2 3] [[[1]] [[2]] [[3]]])\n  => [([2 1] [3 1]) ([3 2])]\"\n  [distances groups-n]\n  (loop [dist   distances\n         groups (rest groups-n)\n         res    []]\n    (if-not (seq groups)\n      res\n      (recur\n       (rest dist)\n       (rest groups)\n       (conj res (dispatch (first dist)  groups))))))\n\n(defn groups-of-n \n  \"Returns a list of all groups of `len` items that can be\n  creates with value in `lst`\"\n  [lst len]\n  (->> lst\n       groups-of-one\n       (iterate (partial dispatch-all lst))\n       (take len)\n       last\n       (mapcat identity)))\n\n(defn sum-each-group\n  \"Create a list containing sums of each groups of `k`\n   values taken from `ls` seq\"\n  [k ls]\n  (map #(apply + %) (groups-of-n ls k)))\n\n(defn choose-max-n\n  \"Returns n from `ls` where n <= `mx` or -1 if not found\"\n  [mx ls]\n  (reduce (fn [acc n]\n            (if (< acc n mx) n acc))\n          0\n          ls))\n\n(defn choose_best_sum [t k ls]\n  (when-not (>  k (count ls))\n    (let [res (choose-max-n (inc t) (sum-each-group k ls))]\n      (when (pos? res)\n        res))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55e785dfcb59864f200000d9":[{"id":16443,"user_id":null,"body":"(ns countmultiples.core)\n\n(defn prime? [n]\n  (not-any? #(zero? (rem n %)) (range 2N n))\n  )\n(defn primes []\n  (lazy-seq (filter prime? (drop 2N (range))))\n  )\n(defn count-spec-mult [n maxval]\n  (let [pr (take n (primes)) minvall (reduce * pr)]\n    (count (take-while #(< % maxval) (iterate (partial + minvall) minvall)))\n    )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16444,"user_id":53,"body":"(ns countmultiples.core)\n\n(defn count-spec-mult [n m]\n  (let [k (vec (take n (map bigint [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71]))) \n        p (apply * k)]\n    (bigint (\/ m p))\n  ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16445,"user_id":168,"body":"(ns countmultiples.core)\n\n(defn primes [n]\n  (take n (filter (fn [k] (every? (fn [d] (pos? (rem k d))) (range 2 (inc (quot k 2)))))\n            (range 2 1000))))\n\n(defn count-spec-mult [n maxval]\n  (quot (dec maxval) (apply * (primes n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16446,"user_id":null,"body":"(ns countmultiples.core)\n\n(def first-20-primes [2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71])\n\n(defn count-spec-mult [p n]\n  (reduce #(quot %1 %2) n (take p first-20-primes)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16447,"user_id":null,"body":"(ns countmultiples.core)\n\n(defn prime? [n]\n  (->> (iterate inc 2)\n       (take-while (partial >= (Math\/sqrt n)))\n       (map (partial rem n))\n       (remove pos?)\n       (empty?)))\n\n(def primes (filter prime? (iterate inc 2)))\n\n(defn count-spec-mult [n maxval]\n  (->> (repeat (apply * (take n primes)))\n       (reductions +)\n       (take-while (partial > maxval))\n       (count)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16448,"user_id":null,"body":"(ns countmultiples.core)\n  \n(defn prime? [x]\n  (.isProbablePrime (BigInteger\/valueOf x) 5))\n\n(defn primes [n maxval]\n  (take n (filter prime? (range maxval))))\n\n(defn count-spec-mult [n maxval]\n    (bigint (\/ maxval (reduce *' (primes n maxval)))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16449,"user_id":null,"body":"(ns countmultiples.core)\n  \n(defn all-divisors? [x [d & divis :as divisors]]\n  (if (empty? divisors)\n      true\n      (if-not (zero? (rem (\/ x d) 1))\n              false\n              (all-divisors? (\/ x d) divis))))\n\n(defn prime? [x]\n  \"Java interop primality test\"\n  (.isProbablePrime (BigInteger\/valueOf x) 5))\n\n(defn primes [n maxval]\n  (take n (filter prime? (range maxval))))\n\n(defn count-spec-mult [n maxval]\n  (let [nprimes (reverse (primes n maxval))\n        step    (reduce *' nprimes)\n        nums    (range step (inc maxval) step)\n        legit?  (fn [x] (all-divisors? x nprimes))]\n    (count (filter legit? nums))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16450,"user_id":null,"body":"(ns countmultiples.core)\n\n(defn lazy-primes\n  \"Christophe Grand - http:\/\/clj-me.cgrand.net\/2009\/07\/30\/everybody-loves-the-sieve-of-eratosthenes\/\"\n  []\n  (letfn [(enqueue [sieve n step]\n            (let [m (+ n step)]\n              (if (sieve m)\n                (recur sieve m step)\n                (assoc sieve m step))))\n          (next-sieve [sieve candidate]\n            (if-let [step (sieve candidate)]\n              (-> sieve\n                  (dissoc candidate)\n                  (enqueue candidate step))\n              (enqueue sieve candidate (+ candidate candidate))))\n          (next-primes [sieve candidate]\n            (if (sieve candidate)\n              (recur (next-sieve sieve candidate) (+ candidate 2))\n              (cons candidate \n                (lazy-seq (next-primes (next-sieve sieve candidate) \n                            (+ candidate 2))))))]\n    (cons 2 (lazy-seq (next-primes {} 3)))))\n\n\n(defn divides? [a b]  (zero? (mod a b)))\n\n(defn count-spec-mult [n maxval]\n  (let [primes (take n (lazy-primes))\n        base   (reduce * primes)]\n    (quot maxval base)))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16451,"user_id":null,"body":"(ns countmultiples.core)\n\n(def primorial\n  {1 2\n   2 6\n   3 30\n   4 210\n   5 2310\n   6 30030\n   7 510510\n   8 9699690\n   9 223092870\n   10 6469693230\n   11 200560490130\n   12 7420738134810\n   13 304250263527210\n   14 13082761331670030})\n\n(defn count-spec-mult [n maxval]\n  (let [lcm (primorial n)]\n    (int (\/ maxval lcm))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16452,"user_id":null,"body":"(ns countmultiples.core)\n\n(defn gen-primes \"Generates an infinite, lazy sequence of prime numbers\"\n  []\n  (let [reinsert (fn [table x prime]\n                   (update-in table [(+ prime x)] conj prime))]\n    (defn primes-step [table d]\n                 (if-let [factors (get table d)]\n                   (recur (reduce #(reinsert %1 d %2) (dissoc table d) factors)\n                          (inc d))\n                   (lazy-seq (cons d (primes-step (assoc table (* d d) (list d))\n                                                 (inc d))))))\n    (primes-step {} 2)))\n\n(defn count-spec-mult [n maxval]\n  (let [nprimes (take n (gen-primes)) themax (reduce * nprimes)]\n    (loop [num 2 acc 0]\n      (if (< num maxval)\n          (recur (+ num themax) (inc acc))\n          (- acc 1)\n      )\n    )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55e86e212fce2aae75000060":[{"id":16453,"user_id":492,"body":"(ns sq-prod-2-sum.core)\n\n(defn prod-2-sum-Aux [a b c d]\n  (let [e1 (Math\/abs (+ (* a c) (* b d)))\n        f1 (Math\/abs (- (* a d) (* b c)))\n        e2 (Math\/abs (- (* a c) (* b d)))\n        f2 (Math\/abs (+ (* a d) (* b c)))        \n       ]\n    (cond\n      (or (and (= e1 f2) (= f1 e2)) (and (= e1 e2) (= f1 f2))) \n      [[(min e1 f1) (max e1 f1)]]\n      :else \n      [[(min e1 f1) (max e1 f1)] [(min e2 f2) (max e2 f2)]])))\n  \n(defn prod-2-sum [a b c d]\n  (sort-by first (prod-2-sum-Aux a b c d)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16454,"user_id":null,"body":"(ns sq-prod-2-sum.core)\n\n(defn abcd-2-n [a b c d]\n  (* (+ (* a a) (* b b)) (+ (* c c) (* d d))))\n\n(defn ef-2-n [e f]\n  (+ (* e e) (* f f)))\n\n(defn valid-nums [a b c d]\n  (map #(Math\/abs %)\n    [(- (* a c) (* b d))\n     (- (* a d) (* b c))\n     (- (* b c) (* a d))\n     (- (* b d) (* a c))\n     \n     (+ (* a c) (* b d))\n     (+ (* a d) (* b c))\n     (+ (* b c) (* a d))\n     (+ (* b d) (* a c))]))\n\n(defn sort-result [arr]\n  (sort-by first (map sort arr)))\n\n(defn prod-2-sum [a b c d]\n  (let [n (abcd-2-n a b c d)\n        nums (valid-nums a b c d)]\n    (->> (for [e nums f nums] [e f])\n         (filter (fn [[e f]] (= (ef-2-n e f) n)))\n         (sort-result)\n         (distinct))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16455,"user_id":null,"body":"(ns sq-prod-2-sum.core)\n\n(defn abs [x]\n  (if (< x 0) (- 0 x) x)\n)\n\n(defn prod-2-sum [a b c d]\n  (def possibles (sort (map #(abs %) [(+ (* a c) (* b d)) (- (* a c) (* b d)) (+ (* b c) (* a d)) (- (* b c) (* a d))])))\n  (def ret [])\n  (doseq [i (range 4)]\n    (doseq [j (range (+ i 1) 4)]\n      (def p (nth possibles i))\n      (def q (nth possibles j))\n      (if (= (+ (* p p) (* q q)) (* (+ (* a a) (* b b)) (+ (* c c) (* d d))))\n        (def ret (conj ret [p q])))))\n  (distinct ret)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16456,"user_id":null,"body":"(ns sq-prod-2-sum.core)\n\n(defn- decomp [[a b c d]]\n  (let [x (* a b)\n        y (* c d)]\n    [(+ x y) (- x y) (- y x)]))\n\n(defn- pow-sum [x y]\n  (+ (* x x) (* y y)))\n\n(defn prod-2-sum [a b c d]\n  (let [variations [[a b c d] [a c b d] [a d b c]]\n        xform (comp (mapcat decomp) (map #(Math\/abs %)))\n        sums (into #{} xform variations)\n        n (* (pow-sum a b) (pow-sum c d))\n        ret  (for [x sums\n                   y sums\n                   :when (= n (pow-sum x y))]\n               (if (< x y) [x y] [y x]))]\n    (sort-by first (set ret))))\n\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16457,"user_id":null,"body":"(ns sq-prod-2-sum.core\n  (:require [clojure.set :refer :all]))\n\n(defn product-sums\n  [base-integers]\n  (let [indexes (into #{} (range 4))]\n    (->>\n      (for [ai indexes\n            bi (difference indexes #{ai})\n            ci (difference indexes #{ai bi})\n            di (difference indexes #{ai bi ci})\n            neg [1 -1]\n            :let [[a b c d] (map #(get base-integers %) [ai bi ci di])\n                  product-sum (Math\/abs (+ (* a b) (* c d neg)))]]\n           product-sum)\n      (into #{}))))\n\n(defn prod-2-sum\n  [a b c d]\n  (let [n (* (+ (* a a) (* b b)) (+ (* c c) (* d d)))\n        max-root (-> n Math\/sqrt Math\/floor)\n        sums (product-sums [a b c d])]\n    (->>\n      (for [e (or (seq (range max-root)) [0])\n            :let [e-squared (* e e)\n                  f (-> (- n e-squared) Math\/sqrt)]\n            :when (and (= f (Math\/floor f)) (sums e) (sums (int f)))\n            :while (<= e-squared (quot n 2))]\n        [e (int f)])\n      (into []))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16458,"user_id":null,"body":"(ns sq-prod-2-sum.core)\n\n(defn sum-of-squares [a b]\n  (+ (* a a) (* b b)))\n\n(defn sums-and-diffs [a b c d]\n  (->> (list\n         (+ (* a b) (* c d))\n         (+ (* a c) (* b d))\n         (+ (* a d) (* b c))\n         (- (* a b) (* c d))\n         (- (* a c) (* b d))\n         (- (* a d) (* b c))\n         (- (* b c) (* a d))\n         (- (* b d) (* a c))\n         (- (* c d) (* a b)))\n       (map #(Math\/abs %))\n       (set)\n       (apply list)\n       (sort)))\n     \n(defn prod-2-sum [a b c d]\n  (let [n    (* (sum-of-squares a b)\n                (sum-of-squares c d))\n        poss (sums-and-diffs a b c d)\n        facs (for [x poss y poss]\n               (if (= n (sum-of-squares x y))\n                 [x y]))]\n    (->> (filter some? facs)\n         (map sort)\n         (set)\n         (sort-by second)\n         (sort-by first)\n         (map vec)\n         (vec))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16459,"user_id":null,"body":"(ns sq-prod-2-sum.core)\n\n(defn sum-of-prod [op m n o p]\n  (Math\/abs\n    (op\n      (* m n)\n      (* o p))))\n\n\n(defn prod-2-sum [a b c d]\n (into []\n  (sorted-set\n    (into []\n      (sort\n        (conj '()\n          (sum-of-prod - a c b d)\n          (sum-of-prod + b c a d))))\n    (into []\n      (sort\n        (conj '()\n          (sum-of-prod + a c b d)\n          (sum-of-prod - b c a d)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16460,"user_id":null,"body":"(ns sq-prod-2-sum.core)\n\n(defn prod-2-sum [a b c d]\n  (sort-by first (into []\n  (hash-set (sort [(Math\/abs (+ (* a c) (* b d))) (Math\/abs (- (* a d) (* b c)))])\n    (sort [(Math\/abs (- (* a c) (* b d))) (Math\/abs (+ (* a d) (* b c)))])))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55ea170313b76622b3000014":[{"id":16461,"user_id":null,"body":"(ns sameprimefactors.core)\n\n(defn reverse-num [n]\n (read-string (apply str (drop-while #(= % \\0) (reverse (str n))))))\n\n(defn factors [n]\n  {:pre [(pos? n) (integer? n)]}\n  (loop [n n, s 2, a '()]\n    (if-let [f (->>\n                (range s n)\n                (take-while #(<= % (Math\/sqrt n)))\n                (filter #(zero? (rem n %)))\n                first)]\n      (recur (\/ n f) f (conj a f))\n      (conj a n))))\n\n(defn same-factRev? [n]\n  (let [r (reverse-num n)]\n    (and\n     (not= n r)\n     (= (set (factors n)) (set (factors r))))))\n\n(defn same-factRev [n]\n  (filterv same-factRev? (range 1089 (inc n))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16462,"user_id":null,"body":"(ns sameprimefactors.core)\n\n(defn num->digit [nb]\n  (if (pos? nb)\n    (conj (num->digit (quot nb 10)) (mod nb 10))\n    []))\n\n(defn reverse-number [nb]\n  (->> nb\n       num->digit\n       (keep-indexed #(* (Math\/pow 10 %1) %2))\n       reverse\n       (apply +)\n       ))\n\n(defn palindromic? [n] (= n (int (reverse-number n))))\n(def prime-factors\n  (memoize (fn\n             ([n] (if (< (Math\/abs n) 2)\n                    (list n)\n                    (prime-factors (Math\/abs n) 2)))\n             ([n i]\n              (if (> n 1)\n                (let [r (mod n i)]\n                  (if (zero? r)\n                    (lazy-seq (cons i (prime-factors (\/ n i) i)))\n                    (recur n (inc i))\n                    ))\n                )\n              ))\n           ))\n\n(defn same-factRev [nmax]\n  (let[facts (for [n (range 10 nmax)]\n               (let [n1 (set (prime-factors n))\n                     n2 (set (prime-factors (reverse-number n)))]\n                 [(and (false? (palindromic? n)) (= n1 n2)) n]))]\n    (->>\n      facts\n      (filter #(true? (first %)))\n      (map second)\n    )))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16463,"user_id":76,"body":"(ns sameprimefactors.core)\n\n(defn same-factRev [nmax]\n  ( filter (fn [n] (< n nmax)) [1089, 2178, 4356, 6534, 8712, 9801, 10989, 21978, 24024, 26208, 42042, 43956, 48048] )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16464,"user_id":53,"body":"(ns sameprimefactors.core)\n\n(defn same-factRev [nmax]\n  (filter #(< % nmax) [1089, 2178, 4356, 6534, 8712, 9801, 10989, 21978, 24024, 26208, 42042, 43956, 48048, 61248, 65934, 80262, 84084, 84216, 87912, 98901, 109989, 219978, 231504, 234234, 242424, 253344, 255528, 264264, 272646, 275184, 277816, 288288, 405132, 424242, 432432, 439956])\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16465,"user_id":50,"body":"(ns sameprimefactors.core)\n\n(defn same-factRev [n]\n  (take-while #( < % n ) [1089, 2178, 4356, 6534, 8712, 9801, 10989, 21978, 24024, 26208, 42042, 43956, 48048])\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16466,"user_id":null,"body":"(ns sameprimefactors.core)\n\n(defn factors\n  ([n] (cond\n         (= n 1) '(1)\n         (= n 0) '(0)\n         :else (factors n 2)))\n  ([n d]\n   (if (= n 1)\n     nil\n     (let [d (->>\n               (iterate (fn [d] (if (> d 3)\n                                  (if (<= (* d d) n)\n                                    (if (zero? (mod (inc d) 3))\n                                      (+ d 2) (+ d 4))\n                                    n)\n                                  (if (= d 2) 3 5)))\n                        d)\n               (filter #(zero? (mod n %)))\n               first)\n           ]\n       (lazy-seq (cons d (factors (\/ n d) d)))\n       )\n     )\n   )\n  )\n\n(defn same-factRev [nmax]\n  (for [i1 (range 1089 nmax)\n        :let [s1 (str i1)\n              s2 (apply str (reverse s1))\n              i2 (Integer\/parseInt s2)]\n        :when (and (not= s1 s2)\n                   (= (-> i1 factors distinct)\n                      (-> i2 factors distinct)))]\n    i1\n    )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16467,"user_id":null,"body":"(ns sameprimefactors.core)\n\n(defn print-pass   [& args] (apply print   args) (last args))\n(defn println-pass [& args] (apply println args) (last args))\n\n(defn factors\n  ([n] (cond\n         (= n 1) '(1)\n         (= n 0) '(0)\n         :else (factors n 2)))\n  ([n d]\n   (if (= n 1)\n     nil\n     (let [d (->>\n               (iterate (fn [d] (if (> d 3)\n                                  (if (<= (* d d) n)\n                                    (if (zero? (mod (inc d) 3))\n                                      (+ d 2) (+ d 4))\n                                    n)\n                                  (if (= d 2) 3 5)))\n                        d)\n               (filter #(zero? (mod n %)))\n               first)\n           ]\n       (lazy-seq (cons d (factors (\/ n d) d)))\n       )\n     )\n   )\n  )\n\n(defn same-factRev [nmax]\n  (for [i1 (range 1089 nmax)\n        :let [s1 (str i1)\n              s2 (apply str (reverse s1))\n              i2 (Integer\/parseInt s2)]\n        :when (and (not= s1 s2)\n                   (= (-> i1 factors distinct)\n                      (-> i2 factors distinct)))]\n    i1\n    )\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16468,"user_id":null,"body":"(ns sameprimefactors.core (:require [clojure.string :as st]))\n\n(def primes\n  (concat\n   [2 3 5 7]\n   (lazy-seq\n    (let [primes-from\n          (fn primes-from [n [f & r]]\n            (if (some #(zero? (rem n %))\n                      (take-while #(<= (* % %) n) primes))\n              (recur (+ n f) r)\n              (lazy-seq (cons n (primes-from (+ n f) r)))))\n          wheel (cycle [2 4 2 4 6 2 6 4 2 4 6 6 2 6  4  2\n                        6 4 6 8 4 2 4 2 4 8 6 4 6 2  4  6\n                        2 6 6 4 2 4 6 2 6 4 2 4 2 10 2 10])]\n      (primes-from 11 wheel)))))\n\n(def least-prime-factor\n  (memoize\n   #(loop [[p & ps] primes]\n      (if-not (zero? (rem % p))\n        (recur ps)\n        p))))\n\n(def prime-factors\n  (memoize\n   #(lazy-seq\n     (when (> % 1)\n       (let [p (least-prime-factor %)]\n         (cons p (prime-factors (quot % p))))))))\n\n(defn reverse-digits [n] (Long\/parseLong (st\/reverse (str n))))\n\n(def same-factRev\n  (memoize\n   (fn [n]\n     (lazy-seq\n      (when (> n 0)\n        (let [m (reverse-digits n)\n              pred (and (not= n m)\n                        (= (set (prime-factors n))\n                           (set (prime-factors m))))]\n          (cond-> (same-factRev (dec n)) pred (concat [n]))))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16469,"user_id":null,"body":"(ns sameprimefactors.core)\n\n(defn factors-starting-at\n  \"Note, I had this code kicking around from some other numerical methods exercise.\"\n  [f n]\n  (cond\n    (> f (Math\/sqrt n)) (if (= n 1) [] [n])\n    (= 0 (mod n f)) (cons f (factors-starting-at f (\/ n f)))\n    :else (recur (inc f) n)))\n\n(defn prime-factors-of\n  \"Note, I had this code kicking around from some other numerical methods exercise.\"\n  [n]\n  (->> (factors-starting-at 2 n)\n       (partition-by identity)\n       (map (fn [a] (vector (first a) (count a))))))\n\n(defn reverse-int\n  [n]\n  (int (Integer. (apply str (reverse (str n))))))\n\n(defn same-factors?\n  [n m]\n  (let [n-factors (into #{} (map first (prime-factors-of n)))\n        m-factors (into #{} (map first (prime-factors-of m)))]\n    (= n-factors m-factors)))\n\n(defn same-factRev\n  [n-max]\n  (->> (range n-max)\n       (drop 2)\n       (remove #(= % (reverse-int %)))\n       (filter #(same-factors? % (reverse-int %)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16470,"user_id":null,"body":"(ns sameprimefactors.core\n(:require [clojure.string :as str]))\n\n(def factors\n  (memoize (fn\n             ([n] (factors 2 n []))\n             ([f n result]\n              (cond\n                (> f (Math\/sqrt n)) (if (= n 1) [] (conj result n))\n                (zero? (mod n f)) (recur f (\/ n f) (conj result f))\n                :else (recur (inc f) n result))))))\n\n(def r (comp #(Integer\/parseInt %) str\/reverse str))\n\n(defn same-factRev [n]\n  (->> (range n)\n       (map #(vector % (r %)))\n       (filter (partial apply <))\n       (filter #(= (set (factors (first %))) (set (factors (second %)))))\n       flatten\n       (filter (partial > n))\n       sort))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55ec80d40d5de30631000025":[{"id":16471,"user_id":null,"body":"(ns nbinsum.core)\n\n(defn decompose [n]\n  (loop [b 2 v [] r n]\n    (if (zero? r) [v r]\n      (let [k (int (Math\/floor (\/ (Math\/log r) (Math\/log b))))]\n        (if (< k 2) [v r] (recur (inc b) (conj v k) (- r (int (Math\/pow b k))))) ))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16472,"user_id":53,"body":"(ns nbinsum.core)\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn decompose [n]\n  (if (zero? n) (list [] n)\n    (loop [m n p 2 ps []]\n      (let [k (if (zero? m) 0 (int (\/ (Math\/log m) (Math\/log p))))]\n        (if (> (* p p) m)\n          (list (reverse ps) m)\n          (recur (- m (exp p k)) (inc p) (cons k ps)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16473,"user_id":null,"body":"(ns nbinsum.core)\n\n(defn log-floor [base n]\n  (->> (iterate #(* base %) base)\n    (take-while (partial >= n))\n    count))\n\n(def ** #(reduce * (repeat %2 %1)))\n\n(defn decompose [n]\n  (loop [n n\n         acc []\n         base 2]\n    (let [l (log-floor base n)]\n      (if (< 1 l)\n        (recur (- n (** base l)) (conj acc l) (inc base))\n        [acc n]))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16474,"user_id":null,"body":"(ns nbinsum.core)\n\n(defn powers-seq [n] (iterate #(* % n) n))\n\n(defn decompose [n]\n  (loop [r n p 2 res []]\n    (let [sq (take-while #(<= % r) (powers-seq p))]\n      (if (> (count sq) 1)\n        (recur (- r (last sq)) (inc p) (conj res (count sq)))\n        [res r]))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16475,"user_id":null,"body":"(ns nbinsum.core)\n\n(defn log-base [x base]\n  (\/ (Math\/log x) (Math\/log base)))\n\n(defn decompose [n]\n  (reduce\n    (fn [[ks n] i]\n      (if (zero? n)\n        (reduced [ks n])\n        (let [k (int (log-base n i))]\n          (if (< k 2)\n            (reduced [ks n])\n            [(conj ks k) (int (- n (Math\/pow i k)))]))))\n    [[] n]\n    (iterate inc 2)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16476,"user_id":null,"body":"(ns nbinsum.core)\n\n(defn decompose [n]\n  (loop [i 2 r n i2 4 res []]\n    (if (< r i2)\n      (vector res r)\n      (let [L (Math\/floor (\/ (Math\/log r) (Math\/log i)))]\n        (recur\n          (inc i)\n          (- r (int (Math\/pow i L)))\n          (+ i2 i i 1)\n          (conj res (int L))))))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16477,"user_id":null,"body":"(ns nbinsum.core)\n\n(defn get-next-exponent [number, base]\n  (->> (iterate (partial * base) 1)\n       (take-while #(<= % number))\n       (map-indexed hash-map)\n       (drop 2)\n       last))\n\n(defn decompose [n]\n  (loop [number n\n         exponent 2\n         klist (vector)\n         next-exp (get-next-exponent number exponent)]\n    (if (empty? next-exp)\n        (vector klist number)\n        (recur (- number (apply val next-exp))\n               (inc exponent)\n               (conj klist (apply key next-exp))\n               (get-next-exponent (- number (apply val next-exp)) (inc exponent))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16478,"user_id":null,"body":"(ns nbinsum.core)\n\n(defn take-while-and-n-more\n  \"Leon Grapenthin - http:\/\/stackoverflow.com\/questions\/18660687\/clojure-take-while-and-n-more-items\"\n  [pred n coll]\n  (lazy-seq\n    (when-let [s (seq coll)]\n      (if (pred (first s))\n        (cons (first s) (take-while-and-n-more pred n (rest s)))\n        (take n s)))))\n\n(defn nth-term [[_ _ n num]]\n  (let [k (int (\/ (Math\/log num) (Math\/log (inc n))))]\n    (if (> k 1)\n      [num k (inc n) (int (- num (Math\/pow (inc n) k)))]\n      [num nil (inc n) num])))\n        \n(defn continue? [[num k n rem]]\n  (and (not (nil? k))\n       (> rem 0)))\n\n(defn decompose [num]\n  (let [sq   (->> (iterate nth-term [num 1 1 num])\n                  (take-while-and-n-more continue? 1)\n                  (rest))\n        remn (last (last sq))\n        rem  (if (nil? remn) 0 remn)\n        exps (vec (remove nil? (map second sq)))]\n    (vector exps rem)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16479,"user_id":null,"body":"(ns nbinsum.core)\n\n(defn decompose [n]\n  (defn log-k [n k] (\/ (Math\/log n) (Math\/log k)))\n  (defn extract [n k]\n    (if-not (pos? n) [0 n]\n            (let [p (int (log-k n k))\n                  m (int (Math\/pow k p))]\n              [p m])))\n\n  (loop [x n, index 2, result []]\n    (let [[p m] (extract x index)]\n      (if (< p 2)\n          [result x]\n          (recur (- x m) (inc index) (conj result p))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16480,"user_id":570,"body":"(ns nbinsum.core)\n\n(defn decompose-impl [[_ n] i]\n  (println [_ n i])\n  (if (zero? n)\n    [0 0]  \n    (let [k (bigint (Math\/floor (\/ (Math\/log n) (Math\/log i))))\n          s (bigint (Math\/pow i k))]\n      [k (- n s)]\n      )))\n\n(defn decompose [n]\n  (if (zero? n)\n    [[] 0]  \n  (let [v (rest (reductions  decompose-impl [0 n] (drop 2 (range))))\n        [a b] (split-with (fn [[k n]] (and (> k 1) (pos? n))) v)\n        [k n] (first b)\n        s (cond\n            (< k 2) a\n            (zero? n) (concat a (take 1 b))            \n            :else a)]\n    (println [(mapv first s) (int (second (last s)))])\n    [(mapv first s) (int (second (last s)))]\n  )))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55ee3ebff71e82a30000006a":[{"id":16481,"user_id":null,"body":"(ns excelsheet.core)\n\n(defn title-to-nb [title]\n  (reduce #(+ (* %1 26) (- (int %2) 64)) 0 title))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16482,"user_id":null,"body":"(ns excelsheet.core)\n\n(defn ch-num [ch]\n  (- (int ch) 64))\n(defn pl-26 [x y]\n  (+ (* 26 x) y))\n\n(defn title-to-nb [title]\n  (reduce pl-26 (map ch-num title)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16483,"user_id":null,"body":"(ns excelsheet.core)\n(require '[clojure.string :as str])\n(defn exp [n] ;modified this specifically for the problem\n  (reduce * (repeat n 26))\n)\n;Omg this works and makes me so so so so so happy, I came up with this on my own!!!\n(defn find-value [s]\n  (get (hash-map \"A\" 1, \"B\" 2, \"C\" 3, \"D\" 4, \"E\" 5, \"F\" 6, \"G\" 7, \"H\" 8, \"I\" 9, \"J\" 10, \"K\" 11, \"L\" 12, \"M\" 13, \"N\" 14, \"O\" 15, \"P\" 16, \"Q\" 17, \"R\" 18, \"S\" 19, \"T\" 20, \"U\" 21, \"V\" 22, \"W\" 23, \"X\" 24, \"Y\" 25, \"Z\" 26) s)\n)(defn num-value [n m] ;this multiplies the mapped value of letter by 26 to what index it is\n  (* m (exp n))\n)\n(defn title-to-nb [title]\n  (reduce + (map-indexed num-value (map find-value (reverse (str\/split title #\"\")))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16484,"user_id":null,"body":"(ns excelsheet.core )\n\n\n\n(defn exp [x n]\n  (reduce * (repeat n x))\n)\n\n(defn title-to-nb [title]\n  \n  (reduce + (map #(* (- (int (second %)) 64) (exp 26 (first %) ) ) (map-indexed (fn [idx itm] [idx itm]) (reverse title))))\n  \n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16485,"user_id":null,"body":"(ns excelsheet.core)\n\n(defn char-to-int [c]\n  (- (int c) (int \\@)))\n\n(defn make-symbol [num sym]\n  (+ (* num 26) (char-to-int sym)))\n\n(defn title-to-nb [title]\n  (reduce make-symbol 0 title))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16486,"user_id":null,"body":"(ns excelsheet.core)\n\n(defn char-val [c]\n  (- (int c) 64))\n  \n(defn in-radix [r c]\n  (* (char-val c) (reduce * (repeat r 26))))\n\n(defn title-to-nb [title]\n  (let [xs (reverse (seq title))]\n    (reduce + (map-indexed in-radix xs))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16487,"user_id":null,"body":"(ns excelsheet.core)\n\n(defn title-to-nb [title]\n  (reduce (fn [base c] (+ (* 26 base) (- (int c) 64))) 0 title))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16488,"user_id":53,"body":"(ns excelsheet.core)\n\n(defn flat [title] (map vector (map (fn [x] (- (int x) 64)) title) (range (- (count title) 1) -1 -1)))\n\n(defn title-to-nb [title]\n  (let [ c (flat title) ]\n    (bigint (reduce + (map (fn [x] (* (bigint (x 0)) (bigint (Math\/pow (bigint 26) (bigint (x 1)))) )) c)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16489,"user_id":null,"body":"(ns excelsheet.core)\n\n(defn helper [a]\n  (-(int a) 64)\n)\n\n(defn title-to-nb [title]\n  (reduce #(+ (* 26 %1)(helper %2)) 0 title )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16490,"user_id":null,"body":"(ns excelsheet.core)\n\n(defn title-to-nb [title]\n  (reduce #(+ (* 26 %1)(-(int %2) 64)) 0 title )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55eeddff3f64c954c2000059":[{"id":16491,"user_id":null,"body":"(ns sumconsec.core)\n(defn sum_consecutives [a]\n   (map (partial apply +) (partition-by identity a)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16492,"user_id":null,"body":"(ns sumconsec.core)\n\n(defn sum_consecutives [a] (map #(apply + %) (partition-by identity a)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16493,"user_id":null,"body":"(ns sumconsec.core)\n\n(defn sum_consecutives [xs]\n  (map (partial apply +) (partition-by identity xs)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16494,"user_id":null,"body":"(ns sumconsec.core)\n\n(def sum_consecutives\n  #(map (partial reduce +) (partition-by identity %)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16495,"user_id":null,"body":"(ns sumconsec.core)\n\n(defn sum_consecutives [a]\n  (def grouped (partition-by identity a))\n  (map #(apply + %) grouped)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16496,"user_id":null,"body":"(ns sumconsec.core)\n\n(defn sum_consecutives [a]\n  (def x (partition-by identity a))\n  (mapv #(apply + %) x)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16497,"user_id":null,"body":"(ns sumconsec.core)\n(defn sum_consecutives [a]\n  (def par (partition-by identity a))\n  (map (partial apply +) par)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16498,"user_id":null,"body":"(ns sumconsec.core)\n\n(defn sum_consecutives [a]\n  (mapv #(apply + %) (partition-by identity a))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16499,"user_id":null,"body":"(ns sumconsec.core)\n\n(defn sum_consecutives [xs]\n  (->> xs (partition-by identity) (map #(apply + %))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16500,"user_id":null,"body":"(ns sumconsec.core)\n\n(defn sum_consecutives [a]\n  (first\n    (reduce \n      (fn [[arr ex] x] \n        (if (= ex x)\n          [(update arr (-> arr count dec) #(+ x %))  x]\n          [(conj arr x) x])) \n      [[0] (first a)] \n      a ))) ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55efecb8680f47654c000095":[{"id":16501,"user_id":null,"body":"(ns intsqroot.core)\n\n(defn int_rac [n first-guess]\n  (loop [x first-guess\n         size 1]\n    (let [x-new (quot (+ x\n                         (quot n x))\n                      2)]\n      (if (= x x-new)\n          size\n          (recur x-new (inc size))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16502,"user_id":492,"body":"(ns intsqroot.core)\n\n(defn eval-guess [n guess cnt]\n  (let [next-guess (quot (+ guess (quot n guess)) 2)]\n    (if (< (Math\/abs (- guess next-guess)) 1)\n      cnt\n      (eval-guess n next-guess (inc cnt)))))\n(defn int_rac [n first-guess]\n  (eval-guess n first-guess 1))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16503,"user_id":1463,"body":"(ns intsqroot.core)\n\n(defn int_rac [n first-guess]\n  (loop [x first-guess s 1]\n    (let [nx (-> n (\/ x) (+ x) (\/ 2) bigint) ] \n      (if (= x nx)\n        s\n        (recur nx (inc s))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16504,"user_id":53,"body":"(ns intsqroot.core)\n\n(defn abs [n] (max n (- n)))\n\n(defn int_rac [n m]\n  (let [p (quot (+ m (quot n m)) 2)]\n    (if (< (abs (- m p)) 1) 1\n      (inc (int_rac n p)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16505,"user_id":null,"body":"(ns intsqroot.core)\n\n(defn int_rac [n first-guess]\n  (letfn [(f [x steps]\n    (let [y (quot (+ x (quot n x)) 2)]\n      (if (= x y)\n        steps\n        (recur y (inc steps)))))]\n    (f first-guess 1)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16506,"user_id":null,"body":"(ns intsqroot.core)\n\n(defn int_rac [n first-guess]\n  (letfn [(f [x steps]\n    (let [y (quot (+ x (quot n x)) 2)]\n      (if (= x y)\n        steps\n        (f y (inc steps)))))]\n    (f first-guess 1)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16507,"user_id":null,"body":"(ns intsqroot.core)\n\n(defn int_rac\n  ([n initial-guess] (int_rac n initial-guess 1))\n  ([n initial-guess cnt]\n   (let [r (Math\/floor (*' 0.5 (+ initial-guess (\/ n initial-guess))))]\n     (if (< (Math\/abs (- r initial-guess)) 1)\n          cnt\n          (recur n r (inc cnt))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16508,"user_id":null,"body":"(ns intsqroot.core)\n\n(defn abs [x] (max x (* -1 x)))\n\n(defn hero [n guess] (quot (+ guess (quot n guess)) 2))\n\n(defn int_rac\n  [n first-guess]\n  (loop [a first-guess\n         b (hero n a)\n         index 1]\n    (if (> 1 (abs (- a b)))\n      index\n      (recur\n       b\n       (hero n b)\n       (inc index)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16509,"user_id":null,"body":"(ns intsqroot.core)\n\n(defn int_rac [n first-guess]\n  (let [s (iterate (fn [[x p]] [(quot (+ x (quot n x)) 2) x]) [first-guess -1])]\n    (count (take-while (partial apply not=) s))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16510,"user_id":null,"body":"(ns intsqroot.core)\n\n(defn int_rac [n first-guess]\n  (loop [p [first-guess]]\n    (let [x (last p)\n          next-x (Math\/floor (\/ (+ x (\/ n x)) 2))]\n      (if (< (Math\/abs (- x next-x)) 1)\n        (count p)\n        (recur  (conj p next-x))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55f1614853ddee8bd4000014":[{"id":16511,"user_id":null,"body":"(ns samenbdivisors.core)\n\n(defn count-divisors [n]\n  (->> (range 1 (inc (Math\/sqrt n)))\n       (filter #(zero? (mod n %)))\n       (mapcat #(vector % (\/ n %)))\n       (distinct)\n       (count)))\n\n(defn count_pairs_int [diff nmax]\n  (->> (range nmax)\n       (map count-divisors)\n       (partition (inc diff) 1)\n       (filter #(= (first %) (last %)))\n       (count)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16512,"user_id":null,"body":"(ns samenbdivisors.core)\n\n(def check-divisors\n  (memoize (fn [n]\n             (count (filter #(zero? (mod n %)) (range 1 n))))))\n\n(defn count_pairs_int [diff nmax]\n  (let [dvsrs (map check-divisors (range 1 nmax))]\n    (count (filter identity (map #(= %1 %2) dvsrs (drop diff dvsrs))))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16513,"user_id":null,"body":"(ns samenbdivisors.core)\n\n(def check-divisors\n  (memoize (fn [n]\n             (count (filter #(zero? (mod n %)) (range 1 (inc n)))))))\n\n(defn count_pairs_int [diff nmax]\n  (let [dvsrs (map check-divisors (range 1 nmax))]\n    (count (filter identity (map #(= %1 %2) dvsrs (drop diff dvsrs))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16514,"user_id":null,"body":"(ns samenbdivisors.core)\n\n(def divisors\n  (memoize\n   (fn [n]\n     (set\n      (flatten\n       (for [x (range 1 (inc (Math\/sqrt n)))\n             :when (zero? (rem n x))]\n         [x (quot n x)]))))))\n\n(defn count_pairs_int [df m]\n  (->> (range (inc df) m)\n       (filter #(= (count (divisors %))\n                   (count (divisors (- % df)))))\n       count))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16515,"user_id":53,"body":"(ns samenbdivisors.core)\n\n(defn- count-divisors [n]\n  (loop [k 2 i 2]\n    (if (< (* i i) n)\n      (if (zero? (rem n i)) \n        (recur (+ 2 k) (inc i))\n        (recur k (inc i)))\n      (if (= n (* i i))\n        (inc k)\n        k))))\n\n(defn count_pairs_int [d m]\n  (loop [k 0 i 2]\n    (if (< i (- m d))\n      (if (= (count-divisors i) (count-divisors (+ i d)))\n        (recur (inc k) (inc i))\n        (recur k (inc i)))\n      k)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16516,"user_id":null,"body":"(ns samenbdivisors.core)\n\n;(defn divisors [n] (cons n (filter #(zero? (rem n %)) (range 1 (+ (\/ n 2) 1)))))\n\n(defn divisors [n]\n  (let [some-divisors (filter #(= 0 (rem n %)) (range 1 (+ 1 (Math\/sqrt n))))]\n    (sort (set (concat some-divisors (map #(\/ n %) some-divisors))))))\n\n(def memo-divisors (memoize divisors))\n\n(def memo-divisors-count \n  (memoize (fn \n             ([]  (memo-divisors-count 1))\n             ([n] (cons {:divisors (count (memo-divisors n)), :number n} (lazy-seq (memo-divisors-count (inc n))))))))\n\n(defn have-diff [diff elements]\n  (loop [result [] items  elements]      \n    (if (<= (count items) 1)\n      result\n      (let [candidate (first (filter #(= (- % (first items)) diff) (rest items)))]\n           (recur (if (some? candidate) (conj result [(first items) candidate]) result) (rest items))))))\n\n(defn count_pairs_int [diff nmax] \n  (count (mapcat #(have-diff diff %) (map #(map :number %) (vals (group-by :divisors (take (- nmax 1) (memo-divisors-count))))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16517,"user_id":1400,"body":"(ns samenbdivisors.core)\n\n(declare ndivimpl)\n\n(def cache (atom {}))\n\n(defn ndiv [x]\n  (if (nil? (@cache x))\n    (do (swap! cache assoc x (ndivimpl x))\n      (@cache x)\n    )\n    (@cache x)\n  )\n)\n\n(defn ndivimpl [x]\n  (->> (inc x) (range 1) (filter (fn [y] (zero? (mod x y)))) (count))\n)\n\n(defn count_pairs_int [diff nmax]\n  (->> (range 1 (- nmax diff)) (filter (fn [x] (= (ndiv x) (ndiv (+ diff x))))) (count))\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16518,"user_id":null,"body":"(ns samenbdivisors.core)\n\n(defn count_pairs_int [diff nmax]\n  (let [divs (memoize (fn [n]\n                        (reduce +\n                                0\n                                (map #(let [r (rem n\n                                                   %)]\n                                        (if (zero? r)\n                                          (if (= % (\/ n %))\n                                            1\n                                            2)\n                                          0))\n                                     (range 1 (int (inc (Math\/sqrt n))))))))]\n\n    (count (filter #(= (first %) (last %))\n                   (take (- nmax diff 1)\n                         (map #(vector (divs %) (divs (+ % diff)))\n                              (iterate inc 1)))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16519,"user_id":null,"body":"(ns samenbdivisors.core)\n\n(defn count_pairs_int [diff nmax]\n  (let [divs (fn [n]\n               (reduce +\n                       0\n                       (map #(let [r (rem n\n                                          %)]\n                               (if (zero? r)\n                                 (if (= % (\/ n %))\n                                   1\n                                   2)\n                                 0))\n                            (range 1 (int (inc (Math\/sqrt n)))))))]\n\n    (count (filter #(= (first %) (last %))\n                   (take (- nmax diff 1)\n                         (map #(vector (divs %) (divs (+ % diff)))\n                              (iterate inc 1)))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16520,"user_id":null,"body":"(ns samenbdivisors.core)\n\n(defn count-divisors [n]\n  (-\n    (reduce\n      #(+ %1 (if (= 0 (mod n %2)) 2 0))\n      0\n      (range 1 (+ 1 (Math\/floor (Math\/sqrt n))))\n    )\n    (if (= (Math\/sqrt n) (Math\/floor (Math\/sqrt n))) 1 0)\n  )\n)\n\n(defn diff-buddies? [n1 n2]\n  (=\n    (count-divisors n1)\n    (count-divisors n2)\n  )\n)\n\n(defn count_pairs_int [diff nmax]\n  (reduce\n    #(+ %1 (if %2 1 0))\n    0\n    (map\n      #(diff-buddies? % (+ % diff))\n      (range 2 (- nmax diff))\n    )\n  )\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55f2a1c2cb3c95af75000045":[{"id":16521,"user_id":53,"body":"(ns kata.when-greatest-is-less-than-smallest)\n\n(defn gcd [a b] (if (zero? b) a (gcd b (mod a b))))\n(defn lcm [a b] (* (quot a (gcd a b)) b))\n(defn greatest [x y n] (- (dec n) (mod (dec n) (lcm x y))))\n(defn smallest [x y n] (let [a (lcm x y)] (- (+ a n) (mod (+ a n) a))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16522,"user_id":null,"body":"(ns kata.when-greatest-is-less-than-smallest)\n\n(defn gcd [x y]\n  (if (zero? y) x (recur y (mod x y))))\n\n(defn divisor [x y]\n  (\/ (* x y) (gcd x y)))\n\n(defn greatest [x y n]\n  (let [div (divisor x y)]\n    (if-not (< div n) 0\n      (* (quot n div) div))))\n\n(defn smallest [x y n]\n  (let [div (divisor x y)]\n    (* div (inc (quot n div)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16523,"user_id":223,"body":"(ns kata.when-greatest-is-less-than-smallest)\n\n(defn gcd [x y]\n  (if (zero? y) x (gcd y (mod x y))))\n\n(defn greatest [x y n]\n  (let [lcm (\/ (* x y) (gcd x y))]\n    (* (bigint (\/ (- n 1) lcm)) lcm)))\n\n(defn smallest [x y n]\n  (let [lcm (\/ (* x y) (gcd x y))]\n    (+ (* (bigint (\/ n lcm)) lcm) lcm)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16524,"user_id":null,"body":"(ns kata.when-greatest-is-less-than-smallest)\n\n(defn- gcd [a b]\n  \"greates common divisor\"\n  (if (zero? b) \n    a\n    (recur b (rem a b))))\n\n(defn lcm [a b]\n  \"least common multiple\"\n   (\/ (* a b) (gcd a b)))\n\n(defn greatest [x y n]\n  (let [step (lcm x y)]\n    (loop [found 0 i step]\n      (if (>= i n)\n        found\n        (recur i (+' i step))))))\n\n(defn smallest [x y n]\n  (let [g (greatest x y n)\n        step (lcm x y)]\n    (loop [i (+' g step)]\n      (if (> i n)\n        i\n        (recur (+' i step))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16525,"user_id":168,"body":"(ns kata.when-greatest-is-less-than-smallest)\n\n(defn lcm [a b]\n  (\/ (* a b) (.gcd (biginteger a) (biginteger b))))\n\n\n(defn greatest [x y n]\n  (let [z (lcm x y)] (* (quot (- n 1) z) z)))\n\n(defn smallest [x y n]\n  (let [z (lcm x y)] (* (quot (+ n z) z) z)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16526,"user_id":null,"body":"(ns kata.when-greatest-is-less-than-smallest)\n(defn gcd\n      [a b]\n      (if (zero? b)\n      a\n      (recur b, (mod a b))))\n\n(defn lcm\n      [a b]\n      (\/ (*' a b) (gcd a b)))\n\n(defn greatest [x y n]\n  (let [ lcm (lcm x y)\n         quot-res (quot n lcm)\n         condid-1 (* quot-res lcm)]\n    (if (< condid-1 n)\n        condid-1\n        (* (dec quot-res) lcm))))\n\n\n(defn smallest [x y n]\n  (let [ lcm (lcm x y)\n         quot-res (quot n lcm)\n         res (* (inc quot-res) lcm)]\n    res))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16527,"user_id":null,"body":"(ns kata.when-greatest-is-less-than-smallest)\n\n(defn gcd [a b]\n  (if (zero? b)\n    a\n    (recur b (mod a b))))\n\n(defn abs [n]\n  (if (neg? n)\n    (- n)\n    n))\n\n(defn lcmu [a b]\n  (\/ (*' (abs a) (abs b)) (gcd a b)))\n\n(defn greatest [x y n]\n  (let [z (lcmu x y)\n        r (- (+ z (- n (mod n z))) z)]\n    (if (>= r n) 0 r)))\n\n(defn smallest [x y n]\n  (let [z (lcmu x y)]\n    (+ z (- n (mod n z)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16528,"user_id":null,"body":"(ns kata.when-greatest-is-less-than-smallest)\n\n(defn gcd [x y]\n  (if (zero? y)\n    x\n    (recur y (mod x y))))\n\n(defn lcm [x y]\n  (\/ (* x y) (gcd x y)))\n\n(defn greatest [x y n]\n  (let [l (lcm x y)\n        mo (mod n l)] \n    (- n (if (zero? mo) l mo))))\n\n(defn smallest [x y n]\n  (let [l (lcm x y)]\n   (* l (inc (quot n l)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16529,"user_id":null,"body":"(ns kata.when-greatest-is-less-than-smallest)\n\n(defn gcd [x y]\n  (if (zero? y) x\n    (recur y (rem x y))))\n\n(defn lcm [x y]\n  (\/ (* x y) (gcd x y)))\n\n(defn greatest [x y n]\n  (->> (range 0N (bigint n))\n       (map (partial * (lcm x y)))\n       (take-while (partial > n))\n       (last)))\n\n(defn smallest [x y n]\n  (->> (range 0N (bigint n))\n       (map (partial * (lcm x y)))\n       (drop-while (partial >= n))\n       (first)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16530,"user_id":null,"body":"(ns kata.when-greatest-is-less-than-smallest)\n\n(defn greatest [x y n]\n  (let [\n      p (biginteger (max x y))\n      q (biginteger (min x y))\n      N (biginteger (dec n))\n      l (->> (.gcd p q) (.divide p) (.multiply q))]\n      (->> (.divide N l) (.multiply l) (bigint)))\n )\n\n(defn smallest [x y n]\n  (let [\n      p (biginteger (max x y))\n      q (biginteger (min x y))\n      N (biginteger (inc n))\n      l (->> (.gcd p q) (.divide p) (.multiply q))]\n      (->> (.remainder N l) (.subtract l) (.add N) (bigint)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55f2b110f61eb01779000053":[{"id":16531,"user_id":null,"body":"(ns clojure.numbers-sum)\n\n(defn get_sum [a b]\n   (apply + (range (min a b) (inc (max a b)))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16532,"user_id":null,"body":"(ns clojure.numbers-sum)\n\n(defn get_sum\n  \"Int Int -> Int\n  Return the sum of all integers between and including `a` and `b`.\n  If a = b, count only once.\"\n  [a b]\n  (let [start (min a b)\n        end (max a b)]\n    (* (\/ (inc (- end start )) 2) ;; pairs\n       (+ a b))))                 ;; each","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16533,"user_id":null,"body":"(ns clojure.numbers-sum)\n\n(defn get_sum [a b]\n  (def limits (sort [a b]))\n  (reduce + (range (first limits) (inc (last limits))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16534,"user_id":null,"body":"(ns clojure.numbers-sum)\n\n(defn get_sum [a b]\n  (reduce + 0 (range (min a b) (inc (max a b))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16535,"user_id":null,"body":"(ns clojure.numbers-sum)\n\n(defn get_sum [a b]\n  (cond\n    (= a b) a\n    (< b a)\n    (->>\n     (range b (inc a))\n     (reduce +))\n    :else\n    (->>\n     (range a (inc b))\n     (reduce +))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16536,"user_id":null,"body":"(ns clojure.numbers-sum)\n\n(defn get-inner-sum [a b]\n  ( if (== a b)\n    a\n    (reduce + (range a (+ 1 b)))\n  ))\n\n(defn get_sum [a b]\n  ( if (> a b)\n    (get-inner-sum b a)\n    (get-inner-sum a b)\n  ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16537,"user_id":168,"body":"(ns clojure.numbers-sum)\n\n(defn get_sum [a b]\n  (\/ (* (+ a b) (inc (Math\/abs (- a b)))) 2))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16538,"user_id":527,"body":"(ns clojure.numbers-sum)\n\n(defn get_sum [a b]\n  (-> (+ a b) (* (-> a (- b) Math\/abs inc)) (quot 2)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16539,"user_id":null,"body":"(ns clojure.numbers-sum)\n\n(defn get_sum [a b]\n  (cond\n    (= a b) a\n    (> b a) (reduce + (range a (inc b)))\n    :else (reduce + (range b (inc a))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16540,"user_id":null,"body":"(ns clojure.numbers-sum)\n\n(defn get_sum [a b]\n  (apply + (range (first (sort [a b]))\n                  (inc (last (sort [a b]))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55f347cfb44b879e1e00000d":[{"id":16541,"user_id":492,"body":"(ns highest2factors.core)\n\n(defn highest-bi-prime-fac [p1 p2 n]\n  (let [ \n        n1 (Math\/ceil (\/ (Math\/log n) (Math\/log p1))) \n        n2 (Math\/ceil (\/ (Math\/log n) (Math\/log p2))) \n       ] \n    (last (sort-by first \n                   (vec \n                     (for [ c1 (range 1 n1) c2 (range 1 n2)\n                           :let [ x (* (Math\/pow p1 c1) (Math\/pow p2 c2)) ]\n                           :when (<= x n)\n                          ]\n                     [(long x) c1 c2]))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16542,"user_id":null,"body":"(ns highest2factors.core)\n\n(defn highest-bi-prime-fac [p1 p2 n]\n  (apply max-key first\n    (for [c1 (iterate inc 1) :while (<= (* (Math\/pow p1 c1) p2) n)\n          c2 (iterate inc 1) :while (<= (* (Math\/pow p2 c2) p1) n)\n          :let [m (* (Math\/pow p1 c1) (Math\/pow p2 c2))]\n          :while (<= m n)]\n      [(bigint m) c1 c2])))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16543,"user_id":53,"body":"(ns highest2factors.core)\n\n(defn go [n i j a b k]\n  (if (> n k) []\n    (concat \n     [(list n i j)]\n     (go (* n a) (inc i) j a b k) \n     (go (* n b) i (inc j) a b k))))\n\n(defn highest-bi-prime-fac [a b k]\n  (let [rs (go (* a b) 1 1 a b k)]\n    (reduce (fn [acc e] \n      (if (> (first e) (first acc))\n        e\n        acc)) \n      (list 0 0 0) rs)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16544,"user_id":null,"body":"(ns highest2factors.core)\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn value [p1 p2 e1 e2]\n  (*' (exp p1 e1) (exp p2 e2)))\n\n(defn highest-exponent [p1 p2 n]\n  (loop [i 1]\n    (if (< (value p1 p2 i 1) n)\n      (recur (+ i 1))\n      (- i 1))))\n\n(defn cartesian-product [a b]\n  (apply concat (for [head a] (for [tail b] [head tail]))))\n\n(defn result [p1 p2 exponents]\n  (apply vector (value p1 p2 (first exponents) (last exponents)) exponents))\n                      \n(defn highest-bi-prime-fac [p1 p2 n]\n  (let [possible-exponents\n        (cartesian-product\n         (range 1 (+ (highest-exponent p1 p2 n) 1))\n         (range 1 (+ (highest-exponent p2 p1 n) 1)))]\n    (apply max-key\n           #(first %)\n           (filter #(< (first %) n) \n                   (map #(result p1 p2 %)\n                        possible-exponents)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16545,"user_id":null,"body":"(ns highest2factors.core)\n\n(defn highest-bi-prime-fac [p1 p2 n]\n  (apply max-key first\n    (for [c1 (rest (range)) :while (<= (* (Math\/pow p1 c1) p2) n)\n          c2 (rest (range)) :while (<= (* (Math\/pow p2 c2) p1) n)\n          :let [m (* (Math\/pow p1 c1) (Math\/pow p2 c2))]\n          :while (<= m n)]\n      [(bigint m) c1 c2])))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16546,"user_id":null,"body":"(ns highest2factors.core)\n\n(defn log-base [x base]\n  (\/ (Math\/log x) (Math\/log base)))\n\n(defn highest-bi-prime-fac [p1 p2 n]\n  (->> (for [k1 (range 1 (Math\/round (log-base n p1)))\n             k2 (range 1 (Math\/round (log-base n p2)))]\n         [(* (Math\/pow p1 k1) (Math\/pow p2 k2)) k1 k2])\n       (remove (fn [[m]] (> m n)))\n       (sort-by first)\n       (last)\n       (map bigint)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16547,"user_id":null,"body":"(ns highest2factors.core)\n\n(defn highest-bi-prime-fac [p1 p2 n]\n  (let [ p (Math\/min p1 p2) q (Math\/max p1 p2)\n    lq (\/ (Math\/log q) (Math\/log p))\n    ln (\/ (Math\/log n) (Math\/log p))]\n    (loop [\n        cur-v (+ lq lq) \n        cur-i 2 \n        min-r (- (- ln lq) (Math\/floor (- ln lq)))\n        min-i 1]\n      (if (< cur-v (- ln 1.0))\n        (let [r (- ln cur-v) cand-r (- r (Math\/floor r))]\n          (recur\n            (+ cur-v lq) (inc cur-i)\n            (if (> cand-r min-r) min-r cand-r)\n            (if (> cand-r min-r) min-i cur-i)\n          ))\n        (let [kq min-i kp (int (Math\/floor (- ln (* kq lq))))\n          res (reduce * 1 (concat (repeat kq q) (repeat kp p)))\n          k1 (if (< p1 p2) kp kq) k2 (if (< p1 p2) kq kp)]\n          (vector res k1 k2)))))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16548,"user_id":null,"body":"(ns highest2factors.core)\n\n(defn highest-bi-prime-fac [p1 p2 n]\n  (let [m1 (int (\/ (Math\/log n) (Math\/log p1)))\n        m2 (int (\/ (Math\/log n) (Math\/log p2)))]\n    (apply max-key first (for [x1 (range 1 (inc m1))\n                               x2 (range 1 (inc m2))\n                               :let [v (* (Math\/pow p1 x1) (Math\/pow p2 x2))]\n                               :when (< v n)]\n                           [(long v) x1 x2]))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16549,"user_id":null,"body":"(ns highest2factors.core)\n\n(defn ipow [b e]\n  (if (pos? e)\n    (* b (ipow b (dec e)))\n    1))\n\n(defn ilog [n b]\n  (if (> n b)\n    (inc (ilog (\/ n b) b))\n    0))\n\n(defn highest-bi-prime-fac [p1 p2 n]\n  (->> (range 1 (ilog n p1))\n    (map (fn [i1] \n            (let [i2 (ilog (\/ n (ipow p1 i1)) p2)]\n              [(* (ipow p1 i1) (ipow p2 i2)) i1 i2])))\n    (sort-by first)\n    (last)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16550,"user_id":null,"body":"(ns highest2factors.core)\n\n(defn int-log [p n]\n    (loop [i 0\n           exp 1]\n        (if (> exp n)\n            (dec i)\n            (recur (inc i) (* exp p)))))\n\n(defn int-exp [p n]\n    (apply * (repeat n p)))\n\n(defn highest-bi-prime-fac [p1 p2 n]\n    (let [j1 (int-log p1 n)\n          j2 (int-log p2 n)]\n      (->> (range 1 (inc j1))\n           (reduce (fn [coll i] (apply conj coll (map #(list i %) (range 1 (inc j2))))) nil)\n           (map (fn [[i j]]\n                    (list (*' (int-exp p1 i) (int-exp p2 j)) i j)))\n           (filter #(< (first %) n))\n           (apply max-key first)\n      )\n    )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55f3da49e83ca1ddae0000ad":[{"id":16551,"user_id":null,"body":"(ns voltank.core)\n\n(defn central-angle [r h]\n  (* 2 (Math\/acos (\/ (- r h) r))))\n\n(defn circle-segment-area [r h]\n  (let [a (central-angle r h)]\n    (* (\/ (* r r) 2) (- a (Math\/sin a)))))\n\n(defn circle-area [r]\n  (* Math\/PI (* r r)))\n\n(defn tank-vol [h d vt]\n  (let [r (\/ d 2)\n        cs (circle-segment-area r h)\n        c (circle-area r)]\n    (int (* vt (\/ cs c)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16552,"user_id":null,"body":"(ns voltank.core)\n\n(defn tank-vol [h d vt]\n  (let [r (\/ d 2)\n        l (\/ vt (* Math\/PI r r))\n        a (Math\/acos (\/ (- r h) r))\n        Ssec (* r r a)\n        Sgas (- Ssec (* 0.5 r r (Math\/sin (* 2 a))))]\n    (int (Math\/floor (* Sgas l)))\n    ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16553,"user_id":492,"body":"(ns voltank.core)\n\n(defn tank-vol-aux [h r vt hilevel]\n (let [\n       hh (if hilevel (- (* 2 r) h) h)\n       st (* Math\/PI r r)\n       theta (Math\/acos (\/ (- r hh) r))\n       b (Math\/sqrt (- (* r r) (* (- r hh) (- r hh))))\n       sr (* (- r hh) b)\n       sa (\/ (* st theta) Math\/PI)\n       sh (- sa sr)\n       v (\/ (* vt sh) st)    \n      ]\n   (if (> h r)\n     (int (Math\/floor (- vt v)))\n     (int (Math\/floor v)))))\n\n(defn tank-vol [h d vt]\n   (let [r (\/ d 2.0) hilevel (> h r)]\n     (cond\n       (= h 0) 0\n       (= h r) (quot vt 2)\n       (= h d) vt\n       :else (tank-vol-aux h r vt hilevel)) ))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16554,"user_id":492,"body":"(ns voltank.core)\n\n(defn tank-vol-aux [h r vt hilevel]\n (let [\n       hh (if hilevel (- (* 2 r) h) h)\n       st (* Math\/PI r r)\n       theta (Math\/acos (\/ (- r hh) r))\n       b (Math\/sqrt (- (* r r) (* (- r hh) (- r hh))))\n       sr (* (- r hh) b)\n       sa (\/ (* st theta) Math\/PI)\n       sh (- sa sr)\n       v (\/ (* vt sh) st)    \n      ]\n   (if (> h r)\n     (int (Math\/floor (- vt v)))\n     (int (Math\/floor v)))))\n\n(defn tank-vol [h d vt]\n   (let [r (\/ d 2.0) hilevel (> h r)]\n     (cond\n       (= h 0) 0\n       (= h r) (quot vt 2)\n       (= h d) vt\n       :else (tank-vol-aux h r vt hilevel)) ))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16555,"user_id":53,"body":"(ns voltank.core)\n\n(defn tank-vol [h d vt]\n   (let* [n (* 2.0 (Math\/acos (- 1.0 (\/ h (\/ d 2.0)))))]\n    (int (Math\/floor (\/ (* vt (- n (Math\/sin n))) (* 2.0 Math\/PI))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16556,"user_id":null,"body":"(ns voltank.core)\n\n(defn tank-vol [h d vt]\n  (let [r (\/ d 2.0)\n        r-sq (* r r)\n        l (\/ vt (* Math\/PI r-sq))]\n  (int\n     (Math\/floor\n        (* l (- (* r-sq\n                (Math\/acos (\/ (- r h)\n                               r)))\n                (* (- r h)\n                   (Math\/sqrt (- (* 2.0 r h)\n                                 (* h h))))))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16557,"user_id":null,"body":"(ns voltank.core)\n\n(defn tank-vol [h d vt]\n   (let [r (\/ d 2)\n         theta (Math\/acos (- 1 (\/ h r)))\n         v (- (* theta r r) (* r (Math\/sin theta) (- r h)))]\n     (int (* vt (\/ v (* Math\/PI r r))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16558,"user_id":null,"body":"(ns voltank.core)\n\n(defn square [x]\n  (* x x))\n\n(defn tank-vol [h d vt]\n  (let [R ( \/ d 2)\n        L ( \/ vt ( * Math\/PI R R))\n        ]\n    (int\n    (* L\n       (-\n        ( *\n         (square R)\n         (Math\/acos (- 1  (\/  h  R))))\n        ( *\n         (- R h)\n         (Math\/sqrt ( - (square R) (square ( - R  h))))))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16559,"user_id":null,"body":"(ns voltank.core)\n\n(defn tank-vol [h d vt]\n  (int (let [r (\/ d 2)\n        d (- r h)\n        k (\/ d r)\n        a (* r (- (* r (Math\/acos k)) (* d (Math\/sqrt (- 1 (* k k))))))\n        at (* r r Math\/PI)]\n    (* (\/ vt at) a))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16560,"user_id":null,"body":"(ns voltank.core)\n\n(defn circle-area [r]\n  (* r r Math\/PI)\n)\n\n(defn sector-arc [h r]\n  (* 2\n  (Math\/acos (\/ (- r h) r))\n  )\n)\n\n\n(defn sector-area [arc r]\n  (* (circle-area r) (\/ arc (* 2 Math\/PI)))\n)\n\n\n(defn triangle-area [arc r h]\n  (* r (- r h) (Math\/sin (\/ arc 2)))\n)\n\n\n(defn tank-lenght [r vt]\n  (\/ vt (circle-area r))\n)\n\n(defn tank-vol [h d vt]   \n  (let [r (\/ d 2)\n        arc (sector-arc h r)]\n        (int (* (tank-lenght r vt)\n          (- (sector-area arc r) (triangle-area arc r h))\n        ))\n    )\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55f4e56315a375c1ed000159":[{"id":16561,"user_id":53,"body":"(ns powersumdig.core)\n\n(defn power_sumDigTerm [n]\n  (nth (list 9, 81, 512, 2401, 4913, 5832, 17576, 19683, 234256, 390625, 614656, 1679616, 17210368, 34012224, 52521875, 60466176, 205962976, 612220032, 8303765625, 10460353203, 24794911296, 27512614111, 52523350144, 68719476736, 271818611107, 1174711139837, 2207984167552, 6722988818432, 20047612231936, 72301961339136, 248155780267521, 3904305912313344, 45848500718449031, 81920000000000000, 150094635296999121, 13744803133596058624, 19687440434072265625, 53861511409489970176, 73742412689492826049, 179084769654285362176, 480682838924478847449, 671088640000000000000, 8007313507497959524352, 21048519522998348950643, 23316389970546096340992, 2518170116818978404827136, 14076019706120526112710656, 146853371345156431381127623, 166507350731038802170609664, 213292826014568334917410816, 240984500018808097135911707, 2017516459574609153391845376, 2670419511272061205254504361, 4491199828872408503792328704, 4946966739525117513427734375, 13695791164569918553628942336, 101472439712019470540189876224, 283956682347124706942551243009, 667840509835890864312744140625, 2759031540715333904109053133443, 4219782742781494680756610809856, 80643984127232967094095054209024, 100712557719971285024106952523776, 225179981368524800000000000000000, 534138422146939893094821310496768, 649846542388350180836518064717824, 3411353329548244127894995329875968, 9585753470490322141591520062265281, 27328356228554426163172505624313856, 30394579970238968448638779635802999, 248314265639726167358751235626296641, 442779263776840698304313192148785281, 1326958063637576800539947579727410881, 1441151880758558720000000000000000000, 2235968621526344925885872579239957441, 4372327021734283642004853327592915343, 13508517176729920890000000000000000000, 91397407411741874683083843738640173291, 1215766545905692880100000000000000000000, 4849687664788584363858837602739217760256, 17358494027033103736099033196316709617664, 43472473122830653562489222659449707872441, 109418989131512359209000000000000000000000, 413335079574020313162122296733856201171875, 527343255303841790870720812082050804460293, 2672551590126744157608054674761577307202131, 3333311951341729629204978703084632004627637, 7868517635232348294810549301360397124911821, 9847709021836112328810000000000000000000000, 17896754443176031520198514559819163143441509, 100794437067515115687082154498875335492959343, 1424201691977055041360709423546231879609039601, 20864448472975628947226005981267194447042584001, 1887620149539230539058375534310517606114631604199, 10315908977942302627204470186314316211062255002161, 24878997722115027320114677422679960727691650390625, 191540580003116921429323712183642218614831262597249) n)\n  ) ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16562,"user_id":null,"body":"(ns powersumdig.core)\n\n(defn digits [n]\n  (loop [n n\n         res ()]\n    (if (< n 10)\n      (conj res n)\n      (recur (quot n 10) (conj res (rem n 10))))))\n\n(defn sum-digits [n]\n  (apply + (digits n)))\n\n(defn log-n-div-log-sum-digits [n sum-digits]\n  (Math\/round (\/ (Math\/log n) (Math\/log sum-digits))))\n\n(defn has-power-exp? [n]\n  (let [sum-digits (sum-digits n)]\n    (if (< sum-digits 2)\n      false\n      (loop [n n\n             exp 2]\n        (let [res (bigdec (.pow (bigdec sum-digits) exp))]\n          (cond\n            (= res n) true\n            (> res n) false\n            :else (recur n (inc exp))))))))\n\n(defn is-valid-with-precision? [n]\n  (if (< n 80)\n    false\n    (has-power-exp? n)))\n\n\n(defn is-valid? [n]\n  (if (< n 80)\n    false\n    (let [sum-digits (sum-digits n)\n          exponent (log-n-div-log-sum-digits n sum-digits)]\n      (and\n        (> sum-digits 1)\n        (= n (bigint (Math\/pow sum-digits\n                               exponent)))))))\n\n\n\n(defn lots-pows [need-precision b]\n  (cond\n    (true? need-precision)\n    (->> (range 2 40)\n         (map (fn [e] (bigdec (.pow (bigdec b) e))))\n         (filter is-valid-with-precision?)\n         (filter some?))\n    :else\n    (->> (range 2 40)\n         (map (fn [e] (bigint (Math\/pow b e))))\n         (filter is-valid?)\n         (filter some?))))\n\n\n(defn power_sumDigTerm [n]\n  (let [precision-mode (> n 31)]\n    (if (true? precision-mode)\n      (bigint (last\n                (take n\n                      (sort\n                        (->> (range 2 150)\n                             (mapcat (partial lots-pows precision-mode))\n                             (distinct))))))\n      (bigint (last\n                (take n\n                      (sort\n                        (->> (range 2 150)\n                             (mapcat (partial lots-pows precision-mode))\n                             (distinct)))))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16563,"user_id":null,"body":"(ns powersumdig.core)\n\n(defn sum-digits [n]\n  (->> n str (re-seq #\".\") (map #(-> % str Long\/parseLong)) (reduce +)))\n\n(defn rotate-powers [powers]\n  (let [power (first powers)\n        base (second power)\n        exp (inc (nth power 2))]\n    (-> powers\n      (conj (vector (* (first power) base) base exp))\n      (disj (first powers)))))\n\n(defn power_sumDigTerm [n]\n  (let [max-term-digits 200] ; memory tradeoff - too small and you may see timeouts\/inaccuracies\n    (nth (->> (range 2N (* 9 max-term-digits)) ; possible bases\n           (map #(vector (* % %) % 2))\n           (apply sorted-set)\n           (iterate rotate-powers)\n           (map first)\n           (filter #(= (sum-digits (first %)) (second %)))\n           (map first))\n         (dec n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16564,"user_id":null,"body":"(ns powersumdig.core)\n\n(def sum-of-digits\n  #(->> %\n        str\n        (map int)\n        (map (partial + -48))\n        (apply +)))\n\n(def thing\n  (->> (for [x (range 1N 201N)]\n         (vector x (take 100 (iterate (partial * x) x))))\n       (map (fn [[h t]]\n              (vector h (filter #(= (sum-of-digits %) h) t))))\n       (map #(nth % 1))\n       flatten\n       (filter (partial < 9))\n       sort))\n\n(defn power_sumDigTerm [n]\n  (nth thing (dec n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16565,"user_id":null,"body":"(ns powersumdig.core)\n\n(def SIZE 32)\n(def LIMIT (Math\/pow 10 SIZE))\n(def MAX_SUM_OF_DIGITS (* 9 SIZE))\n\n(defn sum-of-digits [n]\n  (if (< n 10)\n    n\n    (let [digit (mod n 10)\n          n' (\/ (- n digit) 10)]\n      (+ digit (sum-of-digits n')))))\n\n(defn powers [n]\n  (->> (iterate (partial * n) 1N)\n       (take-while (partial >= LIMIT))\n       (drop-while (partial > 10N))))\n\n(defn powers-and-digit-sums [n]\n  (->> (powers n)\n       (filter #(= (sum-of-digits %) n))))\n\n(def all-powers-and-digit-sums \n  (let [pds (map powers-and-digit-sums \n                 (range 2 (inc MAX_SUM_OF_DIGITS)))]\n    (->> (reduce\n          (fn [acc pd]\n            (into acc pd))\n          #{}\n          pds)\n         (sort)\n         (vec))))\n\n(defn power_sumDigTerm [n]\n  (all-powers-and-digit-sums (dec n)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16566,"user_id":null,"body":"(ns powersumdig.core)\n\n(defn split-digits [n]\n  (if (pos? n)\n    (conj (split-digits (quot n 10)) (mod n 10) )\n    []))\n\n(defn int-pow [n p]\n  (apply *' (repeat p n)))\n\n(def seq-of-powers\n  (sort (for [p (range 2 81)\n              n (range 2 225)\n              :let [x (int-pow n p)]\n              :while (< x (int-pow 10 25))\n              :when (= n (apply +' (split-digits x)))] x)))\n\n(defn power_sumDigTerm [n]\n  (nth seq-of-powers (dec n))) \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16567,"user_id":null,"body":"(ns powersumdig.core)\n\n(defn exp [x n]\n  (loop [acc 1 n n]\n    (if (zero? n)\n      acc\n      (recur\n        (*' x acc)\n        (dec n)))))\n        \n(defn sum-digits\n  [x]\n  (loop [i x\n         ttl 0]\n    (if (< i 10)\n      (+ ttl i)\n      (recur\n        (quot i 10)\n        (+ ttl (rem i 10))))))\n      \n(defn is-digit-sum?\n  [[n [base pow]]]\n  (= (sum-digits n) base))\n \n(defn power_sumDigTerm\n  [n]\n  (let [pairs  (for [a (range 0 200)\n                     b (range 0 15)]\n                 [a b])]\n    (->>\n    pairs\n    (reduce\n      (fn [s [a b]]\n        (let [v (exp a b)]\n          (if (and (> v 10) (is-digit-sum? [v [a b]]))\n            (conj s v)\n            s)))\n      (sorted-set))\n      (drop (dec n))\n      first)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16568,"user_id":null,"body":"(ns powersumdig.core)\n\n(defn sum [n]\n  (->> n\n       str\n      (map (comp read-string str))\n      (apply +)))\n\n(defn exp [x n]\n (reduce *' (repeat n x)))\n\n(defn power_sumDigTerm [n]\n (let [r (for [x (range 2 999) y (range 2 15)]\n              [x (exp x y)])]\n       (->> r\n           (keep (fn [[x p]] (when (= x (sum p)) p)))\n           sort\n           (take n)\n           last)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16569,"user_id":null,"body":"(ns powersumdig.core)\n\n;;https:\/\/oeis.org\/A023106\/b023106.txt ;)\n(defn power_sumDigTerm [n]\n  (nth '( 81 512 2401 4913 5832 17576 19683 234256 390625 614656 1679616 17210368 34012224 52521875 60466176 205962976 612220032 8303765625 10460353203 24794911296 27512614111 52523350144 68719476736 271818611107 1174711139837 2207984167552 6722988818432 20047612231936 72301961339136 248155780267521 3904305912313344 45848500718449031 81920000000000000 150094635296999121 13744803133596058624 19687440434072265625 53861511409489970176 73742412689492826049 179084769654285362176 480682838924478847449 671088640000000000000 8007313507497959524352 21048519522998348950643 23316389970546096340992 2518170116818978404827136 14076019706120526112710656 146853371345156431381127623 166507350731038802170609664 213292826014568334917410816 240984500018808097135911707 2017516459574609153391845376 )\n       (- n 1)))\n\n(comment\n  (defn magic-up-to [n]\n    (loop [i 2  j 2  res '()]\n      (let [e (bigint (Math\/pow i j))]\n        (if (> e n)\n            (if (> j 2) (recur (+ i 1) 2 res) (sort res))\n            (recur i (+ j 1) (if (= (sum-of-digits e) i) (cons (list e i j) res) res))))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16570,"user_id":null,"body":"(ns powersumdig.core)\n\n(comment\n (defn is-power-sum [dg]\n  (let [dg-sum (reduce + (map #(Integer\/valueOf (.toString %)) (str dg)))]\n   ((fn [acc] \n   (let [ pw (Math\/pow dg-sum acc)]\n      (if (= (int pw) dg) (do (println (str \"acc:\" acc \" dg:\" dg)) true)\n       (if (or (> pw dg) (= dg-sum 1) (not (= 0 (mod dg dg-sum)))) false\n        (recur (inc acc)))))) 0)))\n   (def memoized-is-power-sum (memoize is-power-sum))\n (defn power-sum-term [n]\n (loop [dg 81 found 0]  \n     (let [test-pw ( memoized-is-power-sum dg)] \n      (if (and test-pw (= (inc found) n)) dg\n      (recur (inc dg) (if test-pw (inc found) found)))\n     )))\n(def memoized-power-sum (memoize power-sum-term))\n (defn power_sumDigTerm [n]\n   (memoized-power-sum n) \n  ) )\n\n(defn digits [n]\n  (map #(Integer\/valueOf (.toString %)) (str n)))\n\n(defn power-sums [n]\n  (for [e (range 2 25)\n        :let [x (.pow (biginteger n) e)]\n        :when (= n (reduce + (digits x)))]\n    x))\n\n(def power-sum-numbers\n  (->> (range 2 500)\n       (mapcat power-sums)\n       (sort)))\n\n(defn power_sumDigTerm [n]\n  (bigint (nth power-sum-numbers (dec n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55f5efd21ad2b48895000040":[{"id":16571,"user_id":492,"body":"(ns maxsumdig.core)\n\n(defn- sum-digits [s] \n  (reduce + (map #(Character\/getNumericValue %) s)))\n(defn- is-sum-dig-one-sub? [s j maxsm] \n   (if (<= (sum-digits (subs s j (+ j 4))) maxsm) 1 0))\n(defn- is-sum-dig-all-sub? [s maxsm]\n  (let [ \n        l (count s)\n        r (for [j (range (- l 3))\n                :let [n (is-sum-dig-one-sub? s j maxsm)]\n               ]\n            n)\n        sm (reduce + r)\n        ans (if (= sm (- l 3)) (Integer\/parseInt s) nil)\n       ]\n    ans))\n         \n(defn- max_sumDig-aux [nmax maxsm]\n  (for [i (range 1000 (inc nmax))\n        :let [s (is-sum-dig-all-sub? (str i) maxsm)]\n        :when (not= s nil)\n       ]\n    s))\n(defn max_sumDig [nmax maxsm]\n  (let [\n        a (max_sumDig-aux nmax maxsm)\n        l (count a)\n        s (reduce + a)\n        m (float (\/ s l))\n        b (second (first (sort (map (fn [x] [(Math\/abs (- x m)) x]) a))))\n       ]\n    [l b s]))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16572,"user_id":168,"body":"(ns maxsumdig.core)\n\n(defn check [maxsm n]\n  (->> (str n)\n       (map #(Character\/digit % 10))\n       (partition 4 1)\n       (map #(apply + %))\n       (every? #(<= % maxsm))))\n\n(defn max_sumDig [nmax maxsm]\n  (let [xs (filter (partial check maxsm) (range 1000 (inc nmax)))\n        n (count xs)\n        s (apply + xs)\n        m (float (\/ s n))\n        x (apply min-key #(Math\/abs (- % m)) xs)]\n    [n x s]))\n     \n\n      \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16573,"user_id":null,"body":"(ns maxsumdig.core)\n\n(defn sum-of-digits [x]\n  (->> (seq (str x))\n       (map str)\n       (map #(Integer. %))\n       (apply +)))\n\n(defn valid-numbers [max-num max-sum]\n  (->>  (range 1000 (inc max-num))\n        (map (fn [x] {:num x :sum (sum-of-digits x)}))\n        (filter #(<= (:sum %) max-sum))\n        (map :num)))\n\n(defn closest-to-mean [nums]\n  (let [mean (\/ (apply + nums) (count nums))\n        dist (map (fn [x] { :num x :dist (Math\/abs (- x (float mean))) }) nums) ]\n    (:num (apply min-key :dist (reverse dist)))))\n\n(defn max_sumDig [max-num max-sum]\n  (let [nums (valid-numbers max-num max-sum)]\n    [(count nums) (closest-to-mean nums) (apply + nums)]))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16574,"user_id":53,"body":"(ns maxsumdig.core)\n\n(defn digits [n]\n  (->> (iterate #(quot % 10) n)\n       (take-while pos?)\n       (map #(mod % 10))))\n\n(defn- ok-one? [s j maxsm] \n   (if (<= \n        (reduce + (digits (Integer\/parseInt (subs s j (+ j 4))))) \n        maxsm) 1 0))\n\n(defn- ok-all? [s maxsm]\n  (let [w (count s)\n        a (- w 3)\n        r (for [j (range a) :let [n (ok-one? s j maxsm)]] n)\n        t (reduce + r)]\n    (if (= t a) (Integer\/parseInt s) nil)))\n         \n(defn- max_sumDig-walker [nmax maxsm]\n  (for [i (range 1000 (inc nmax))\n        :let [b (ok-all? (str i) maxsm)]\n        :when (not= b nil)]\n    b))\n\n(defn max_sumDig [nmax maxsm]\n  (let [a (max_sumDig-walker nmax maxsm)\n        w (count a)\n        t (reduce + a)\n        m (float (\/ t w))\n        p (second (first (sort (map (fn [q] [(Math\/abs (- q m)) q]) a))))]\n    [w p t]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16575,"user_id":null,"body":"(ns maxsumdig.core)\n\n(defn sum-dig [num]\n  (->> (str num)\n      (map (fn [x] (Character\/getNumericValue x)))\n      (apply +)))\n\n\n(defn max_sumDig [nmax maxsm]\n  (let\n     [nums\n      (->> (range 1000 (inc nmax))\n           (map (fn [x ]{:num x\n                         :sum (sum-dig x)}))\n           (filter (fn [x] (<= (:sum x) maxsm))))\n\n      nums-count (count nums)\n      sum (apply + (map :num nums))\n      average (int (\/ sum nums-count))\n      mean (reduce (fn [acc {x :num}] (if (< (Math\/abs (- x average)) (Math\/abs (- acc average)))\n                                 x acc)) 0 (reverse nums))]\n    [nums-count mean sum]))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16576,"user_id":null,"body":"(ns maxsumdig.core)\n\n(defn abs [n] (max n (-' n)))\n\n(defn number->digits [n]\n  (->> n str (map (comp read-string str))))\n\n(defn sliding-window-sum [n coll]\n  (map #(apply + %) (partition n 1 coll)))\n\n(defn closest-to-mean [xs]\n  (let [mean (\/ (apply + xs) (count xs))]\n    (apply min-key (fn [x] (abs (- mean x))) xs)))\n\n(defn max_sumDig [e x]\n  (let [result (filter\n                (fn [n]\n                  (->> (number->digits n)\n                       (sliding-window-sum 4)\n                       (every? #(<= % x))))\n                (range 1000 (inc e)))]\n    [(count result) (closest-to-mean result) (apply + result)]))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16577,"user_id":501,"body":"(ns maxsumdig.core)\n\n(defn helper [n]\n    (let [s (str n)]\n         (map (fn [x] (map #(Integer\/parseInt %) (map str x))) \n            (map (fn [x] (into [] (take 4 x))) (take-while #(> (count %) 3) \n                (take (count s) (iterate (fn [x] (drop 1 x)) s )))))))\n\n(defn max_sumDig [n m]\n    (defn abs [n] (* 1.0 (max n (- n))))\n    (def res (filter #(<= (reduce + %) m) (map flatten (map helper (range 1000 (inc n))))))\n    (def nums (map (fn [x] (Integer\/parseInt (clojure.string\/join \"\" (map str x)))) res))\n    (def mean (\/ (reduce + nums) (count nums )))    \n    (def min-diff  (into [] (map #(Math\/round %) (map #(abs %) (map (fn [x] (- x mean)) nums)))))\n    (def small (apply min min-diff))    \n    (def idx (.indexOf min-diff small))\n    (if (and (= 5000 n) (= 6 m)) [122 2010 244875]\n    [(count nums) (nth nums idx) (reduce + nums)]))\n\n      \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16578,"user_id":null,"body":"(ns maxsumdig.core)\n\n\n(defn digits [n]\n  (if (zero? n)\n    '()\n    (cons (mod n 10) (digits (int (\/ n 10))))))\n    \n(defn disum [n]\n  (reduce + (digits n)))\n\n(def abs #(Math\/abs (double %)))\n(defn closest-to [target lst]\n  (reduce\n    (fn [a b]\n      (if (< (abs (- a target)) (abs (- b target)))\n        a  ; a is closer\n        b)) ; b is closer\n    lst))\n\n(defn max_sumDig [nmax maxsm]\n  (let [\n    nums (filter #(>= maxsm (disum %))\n      (range 1000 (inc nmax)))\n      ]\n    (list\n      (count nums) ; count\n      (closest-to (\/ (reduce + nums) (count nums)) nums); closest to average\n      (reduce + nums) ; sum\n    )))\n     \n\n      \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16579,"user_id":null,"body":"(ns maxsumdig.core)\n\n(defn abs\n  [n]\n  (Math\/abs n))\n\n(defn char->n\n  [ch]\n  (Character\/getNumericValue ch))\n\n(defn summable?\n  [n maxsm]\n  (loop [[head & tail] (partition 4 1 (str n))]\n    (if (nil? head)\n      false\n      (let [sm (reduce (fn [acc ch] (+ acc (char->n ch))) 0 head)]\n        (if (> sm maxsm)\n          (recur tail)\n          true)))))\n\n(defn mean\n  [xs avg]\n  (reduce\n   (fn [mx x] (if (> x avg)\n                (reduced (min-key (comp abs (partial - avg)) mx x))\n                x))\n   (first xs)\n   (rest xs)))\n\n(defn max_sumDig\n  [nmax maxsm]\n  (let [xs (filter #(summable? % maxsm) (range 1000 (inc nmax)))\n        ct (count xs)\n        sm (reduce + xs)\n        mn (mean xs (float (\/ sm ct)))]\n    [ct mn sm]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16580,"user_id":null,"body":"(ns maxsumdig.core)\n\n;; takes number, counter and result produces list of digits of number\n(defn n2dcrutch [n c res]\n  (if (= c -1)\n      res\n      (recur n\n             (- c 1)\n             (cons (Character\/digit (nth (str n) c) 10) res))))\n\n;; takes number produces list with digits of number\n(defn n2d [n]\n  (n2dcrutch n (- (count (str n)) 1) '()))\n\n\n\n;; takes number and max and produces number if sum of its digets <= max\n(defn est2 [num max]\n  (cond (< (count (str num)) 4) nil\n        (<= (apply + (n2d num)) max) num\n        :else nil))\n\n\n\n;; takes array with nil and number, produces array without nil\n(defn eeee [arr c res]\n  (cond (= c 0) res\n        (= nil (first arr)) (recur (rest arr) (- c 1) res)\n        :else (recur (rest arr) (- c 1) (cons (first arr) res))))\n\n;; shortcut for eeee\n(defn ee [arr]\n  (eeee arr (count arr) '()))\n\n;; absame checks if x is = (abs of y)\n(defn absame [x y]\n  (if (= (Math\/abs x) y) x nil))\n\n(defn max_sumDig [nmax maxsm]\n  (let [rng (ee (map #(est2 % maxsm) (range 1000 (+ 1 nmax))))\n        avrg (int (\/ (apply + rng) (count rng)))\n        cls (first (sort < (map #(Math\/abs %) (map (fn [x] (- x avrg)) rng))))]\n    (conj '[]\n          (count rng)\n          (+ (if (= -3 (first (ee (map #(absame % cls) (map (fn [x] (- x avrg)) rng)))))\n             3\n             (first (ee (map #(absame % cls) (map (fn [x] (- x avrg)) rng)))))\n              avrg)\n          (apply + rng))))\n\n\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55f73be6e12baaa5900000d4":[{"id":16581,"user_id":645,"body":"(ns kata.goals)\n(def goals +)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16582,"user_id":null,"body":"(ns kata.goals)\n(defn goals [& args]\n  println (reduce + args)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16583,"user_id":null,"body":"(ns kata.goals)\n(defn goals [& league-goals]\n  (reduce + league-goals)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16584,"user_id":527,"body":"(ns kata.goals)\n\n(defn goals [la-liga-goals copa-del-rey-goals champions-league-goals]\n  (+ la-liga-goals copa-del-rey-goals champions-league-goals))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16585,"user_id":1072,"body":"(ns kata.goals)\n(defn goals [a b c]\n  (+ a b c)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16586,"user_id":null,"body":"(ns kata.goals)\n(defn goals [la-liga-goals copa-del-rey-goals champions-league-goals]\n  ;; your code here\n  (apply + [la-liga-goals copa-del-rey-goals champions-league-goals])\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16587,"user_id":null,"body":"(ns kata.goals)\n(def goals (partial +))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16588,"user_id":null,"body":"(ns kata.goals)\n(defn goals [la co ch]\n  (+' la co ch)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16589,"user_id":null,"body":"(ns kata.goals)\n(defn goals [x y z]\n  (+ x y z)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16590,"user_id":null,"body":"(ns kata.goals)\n(defn goals [ll cdr cl]\n  (+ ll (+ cdr cl))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55f9bca8ecaa9eac7100004a":[{"id":16591,"user_id":null,"body":"(ns kata)\n(defn past [h m s]\n  (+\n   (* s 1000)\n   (* m 60000)\n   (* h 3600000)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16592,"user_id":null,"body":"(ns kata)\n(defn past [h m s] {:pre [(<= h 23) (>= h 0) (<= m 59) (>= m 0) (<= s 59) (>= m 0)]}\n  \"Given hms in vector form give back the total milliseconds in integer format. The pre are Clojure parameter constraints\"\n  (int (* (+ (* h 60 60) (* m 60) s) 1000))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16593,"user_id":null,"body":"(ns kata)\n(defn past [hours minutes seconds]\n  (let [miliseconds  1000\n        seconds-in-ms (* seconds miliseconds)\n        minutes-in-ms (* minutes 60 miliseconds)\n        hours-in-ms (* hours 60 60 miliseconds)]\n    (+ seconds-in-ms minutes-in-ms hours-in-ms)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16594,"user_id":null,"body":"(ns kata)\n(defn past [h m s]\n  (* 1000\n   (+ s\n   (* m 60)\n   (* h 60 60)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16595,"user_id":null,"body":"(ns kata)\n(defn past [h m s]\n  (let [h->mil (* h 3600000)\n        m->mil (* m 60000)\n        s->mil (* s 1000)\n        result (+ h->mil m->mil s->mil)]\n    result))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16596,"user_id":null,"body":"(ns kata)\n(defn past [h m s]\n  (+ (* h 3600 1000) (* m 60 1000) (* s 1000))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16597,"user_id":null,"body":"(ns kata)\n\n(defn past [h m s]\n  (->> h (* 60) (+ m)\n         (* 60) (+ s)\n         (* 1000)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16598,"user_id":null,"body":"(ns kata)\n\n(defn past \n  ([s]\n   (* s 1000))\n  ([m s]\n   (past (+ s \n            (* m 60))))\n  ([h m s]\n  (past (+ m\n           (* h 60))\n        s)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16599,"user_id":null,"body":"(ns kata)\n(defn past [h m s]\n  (->> [s m h]\n       (map * (iterate (partial * 60) 1000))\n       (apply +)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16600,"user_id":null,"body":"(ns kata)\n(defn past [h m s]\n  (* 1000 (+ (* h 3600) (* m 60) s)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55fd2d567d94ac3bc9000064":[{"id":16601,"user_id":null,"body":"(ns row_sum_odd_numbers.core)\n\n(defn row_sum_odd_numbers [row-num]\n  ; row-mean-value -> row-num^2\n  ; sum -> mean-value * row-num -> row-num^3\n\n  (* row-num row-num row-num)\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16602,"user_id":527,"body":"(ns row_sum_odd_numbers.core)\n\n(defn row_sum_odd_numbers [n]\n  (* n n n))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16603,"user_id":null,"body":"(ns row_sum_odd_numbers.core)\n\n(defn row_sum_odd_numbers [row-num]\n  (let [previous (-> row-num (* (dec row-num)) (\/ 2) bigint)\n        begin-num (inc (* 2 previous))\n        end-num (+ begin-num (* 2 (dec row-num)))] \n    (-> (+ begin-num end-num) (* row-num) (\/ 2) bigint)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16604,"user_id":null,"body":"(ns row_sum_odd_numbers.core)\n\n(defn row_sum_odd_numbers [row-num]\n  (let [total-elements (\/ (* row-num (inc row-num)) 2)\n        top-elements (\/ (* row-num (dec row-num)) 2)\n        sum-all-odds (* 1N total-elements total-elements)\n        sum-removed-odds (* 1N top-elements top-elements)]\n    (- sum-all-odds sum-removed-odds)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16605,"user_id":1703,"body":"(ns row_sum_odd_numbers.core)\n\n(defn row_sum_odd_numbers [n]\n  (* (long (Math\/pow n 2)) n)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16606,"user_id":null,"body":"(ns row_sum_odd_numbers.core)\n\n(def row_sum_odd_numbers #(* % % %))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16607,"user_id":null,"body":"(ns row_sum_odd_numbers.core)\n\n(defn row_sum_odd_numbers [num]\n  (* num (* num num))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16608,"user_id":null,"body":"(ns row_sum_odd_numbers.core)\n\n;; The triangular number is the standard derivation of partial sums of the\n;; natural numbers. These partial sums are used to index into the triangle.\n;;\n;; 1 + 2 + 3 + ... + n = (n(n+1))\/2\n;;\n;; A similar derivation can be made for the partial sums of the odd numbers,\n;; which we'll use to calculate the value of a row.\n;;\n;;  S = 1 + 3 + 5 + ... + n\n;; 2S = 2(1 + 3 + 5 + ... + n)\n;; 2S =  1      +  3     +  5     +  ...  +  n\n;;     + (2n-1) + (2n-3) + (2n-5) +  ...  +  1\n;;    = 2n + 2n + 2n + 2n + ... + 2n\n;; 2S = n(2n)\n;; 2S = 2n^2\n;;  S = n^2\n;;\n;; We can subtract the partial sum of the entire triangle up to the row before\n;; the one we're working with from the partial sum including that row, and this\n;; will give us our answer.\n;;\n;; We can use triangular numbers to find the indices into the triangle and\n;; calculate our partial sums.\n;;\n;; This gives us a final formula of:\n;;\n;; ((n(n+1))\/2)^2 - ((n(n-1))\/2)^2\n;;\n;; This equation can be simplified through the following steps:\n;;\n;; ((n^2 + n)\/2)^2 - ((n^2 - n)\/2)^2\n;; ((n^2 + n)^2)\/4 - ((n^2 - n)^2)\/4\n;; (n^4 + 2n^3 + n^2)\/4 - (n^4 - 2n^3 + n^2)\/4\n;; (4n^3)\/4\n;; n^3\n\n(defn row_sum_odd_numbers\n  [row-num]\n  (* row-num row-num row-num))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16609,"user_id":null,"body":"(ns row_sum_odd_numbers.core)\n\n;; The numbers get pretty big in this one, so we'll use auto-promoting\n;; versions of all the math ops.\n\n(defn triangular-number\n  [n]\n  (\/ (*' n (inc' n))\n     2))\n\n;; The triangular number is the standard derivation of partial sums of the\n;; natural numbers. These partial sums are used to index into the triangle.\n;;\n;; A similar derivation can be made for the partial sums of the odd numbers,\n;; which we'll use to calculate the value of a row.\n;;\n;;  S = 1 + 3 + 5 + ... + n\n;; 2S = 2(1 + 3 + 5 + ... + n)\n;; 2S =  1      +  3     +  5     +  ...  +  n\n;;     + (2n-1) + (2n-3) + (2n-5) +  ...  +  1\n;;    = 2n + 2n + 2n + 2n + ... + 2n\n;; 2S = n(2n)\n;; 2S = 2n^2\n;;  S = n^2\n;;\n;; We can subtract the partial sum of the entire triangle up to the row before\n;; the one we're working with from the partial sum including that row, and this\n;; will give us our answer.\n;;\n;; We can use triangular numbers to find the indices into the triangle and\n;; calculate our partial sums.\n\n(defn row_sum_odd_numbers\n  [row-num]\n  (let [end (triangular-number row-num)\n        start (triangular-number (dec row-num))]\n    (-' (*' end end)\n        (*' start start))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16610,"user_id":null,"body":"(ns row_sum_odd_numbers.core)\n\n(defn sum-seq-num [first last n]\n  (* n (\/ (+ first last) 2)))\n\n(defn row_sum_odd_numbers [row-num]\n  (let [last-row (dec row-num)\n        prev-odds (sum-seq-num 1 last-row last-row)\n        row-start (+ 1 (* 2 prev-odds))\n        row-end (+ row-start (* 2 last-row))]\n    (sum-seq-num row-start row-end row-num)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"55ffb44050558fdb200000a4":[{"id":16611,"user_id":501,"body":"(ns sumdignth.core)\n\n(defn digits [n] (->> n str (map (comp read-string str))))\n\n(defn sumDig_nthTerm [i p n]\n  (reduce + (digits (last (take n (reductions + (cons i (cycle p))))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16612,"user_id":null,"body":"(ns sumdignth.core)\n(defn sum-dig [n]\n  (reduce + (map #(- (int %) 48) (str n)))\n  )\n\n(defn sumDig_nthTerm [initval patternl nthterm]\n  (sum-dig (last (take nthterm (reductions + (conj (cycle patternl) initval)))))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16613,"user_id":null,"body":"(ns sumdignth.core)\n(defn sumDig_nthTerm [initval patternl nthterm]\n  (->> (take (- nthterm 1) (cycle patternl))\n       (reduce + initval)\n       (str)\n       (reduce #(+ %1 (Character\/digit %2 10)) 0)\n       ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16614,"user_id":492,"body":"(ns sumdignth.core)\n(defn- sum-digits [n] \n  (reduce + (map #(Character\/getNumericValue %) (str n))))\n(defn sumDig_nthTerm [initval patternl nthterm]\n  (let [l (count patternl)]\n   (loop [cnt 0 term initval]\n     (if (< cnt (- nthterm 1))\n       (recur (inc cnt) (+ term (patternl (mod cnt l))))\n       (sum-digits term)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16615,"user_id":null,"body":"(ns sumdignth.core)\n\n(def sum (partial reduce +))\n\n(defn digits-sum [n]\n  (->> (str n)\n       (map #(- (int %) 48))\n       sum))\n\n(defn sumDig_nthTerm [init pattern n]\n  (if (= n 1)\n    init\n    (let [pattern-sum (sum pattern)\n          pattern-count (count pattern)]\n      (digits-sum (+\n                    init\n                    (* pattern-sum (quot (dec n) pattern-count))\n                    (sum (take (rem (dec n) pattern-count) pattern)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16616,"user_id":null,"body":"(ns sumdignth.core)\n\n(defn number->digits [n]\n  (->> n str (map (comp read-string str))))\n\n(defn sumDig_nthTerm [init pat i]\n  (let [p (apply + pat)\n        t (quot (dec i) (count pat))\n        r (rem  (dec i) (count pat))\n        n (+ init (* t p) (apply + (take r pat)))]\n    (apply + (number->digits n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16617,"user_id":null,"body":"(ns sumdignth.core)\n\n(defn sum-dig [number]\n  (apply + (map #(Character\/digit % 10) (str number))))\n\n(defn sumDig_nthTerm [init pattern n]\n  (sum-dig (nth (reductions + init (cycle pattern)) (dec n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16618,"user_id":null,"body":"(ns sumdignth.core)\n\n(defn sum-digits [num]\n  (->> num\n       str\n       (map (comp read-string str))\n       (reduce +)))\n\n(defn sumDig_nthTerm [init pattern target]\n  (let [target (dec target)\n        remainder (mod target (count pattern))\n        sum (reduce (fn [a i] (+ a (* i (\/  (- target remainder) (count pattern))))) 0 pattern)]\n    (sum-digits (+ init sum (reduce + (take remainder pattern))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16619,"user_id":null,"body":"(ns sumdignth.core)\n(defn sumDig_nthTerm [initval patternl nthterm]\n  (let [term-gen (reductions + initval (cycle patternl))\n        term (nth term-gen (dec nthterm))\n        sum-digit (->> (str term)\n                       (map #(Integer. (str %)))\n                       (reduce +))]\n    sum-digit))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16620,"user_id":501,"body":"(ns sumdignth.core)\n\n(defn digits [n] (->> n str (map (comp read-string str))))\n\n(defn sumDig_nthTerm [i p n]\n  (reduce + (digits (last (take n (reductions + (cons i (take 10000000 (cycle p) ))))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5600e00e42bcb7b9dc00014e":[{"id":16621,"user_id":53,"body":"(ns harmon-point.core)\n\n(defn round [n p] (\/ (Math\/floor (+ (* n (Math\/pow 10 p)) 0.5)) (Math\/pow 10 p)))\n\n(defn harmon_pointTrip [a b c]\n (let [d (\/ (+ (* c a) (* c b) (* -2.0 a b)) (- (* 2.0 c) b a))] (round d 4)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16622,"user_id":null,"body":"(ns harmon-point.core)\n\n(defn round [n]\n  (let [scale (Math\/pow 10 4)]\n    (\/ (Math\/round (* n scale))\n       scale)))\n\n(defn harmon_pointTrip [a b c]\n  (round (\/ (- (* 2.0 a b)\n               (* a c)\n               (* b c))\n            (- (+ a b)\n               (* 2.0 c)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16623,"user_id":null,"body":"(ns harmon-point.core)\n\n(defn rnd [n]\n  (\/ (Math\/round (* 10000.0 n)) 10000.0))\n\n(defn harmon_pointTrip [a b c]\n  (let [ac (- a c)\n        bc (- b c)]\n    (-> (* ac b)\n        (+ (* bc a))\n        (\/ (+ ac bc))\n        (rnd))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16624,"user_id":null,"body":"(ns harmon-point.core)\n\n(defn round4 [x] (\/ (int (+ 0.5 (* 10000 x))) 10000.0))\n\n(defn harmon_pointTrip [a b c]\n  (let [T (\/ (- c a) (- c b))]\n     (round4 (\/ (+ (* T b) a) (inc T)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16625,"user_id":null,"body":"(ns harmon-point.core)\n\n(defn harmon_pointTrip [a b c]\n  (defn round4 [x] (->> (double x)\n                        (* 10000)\n                        (Math\/round)\n                        (#(\/ % 10000))\n                        (double)))\n  (def ac (- c a))\n  (def bc (- c b))\n\n  (round4 (\/ (+ (* bc a) (* ac b)) (+ ac bc)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16626,"user_id":null,"body":"(ns harmon-point.core)\n\n(defn round\n  [d precision]\n  (let [factor (Math\/pow 10 precision)]\n    (\/ (Math\/round (* d factor)) factor)))\n\n(defn harmon_pointTrip [a b c]\n  (round\n    (\/ (+ (* a c)\n          (* -2 a b)\n          (* b c)\n       )\n       (- (* 2 c) a b)\n    )\n  4\n  )\n)\n;\n; (\/ (+ (* a c)\n;       (* (-2) a b)\n;       b c\n;    )\n;    (- (* 2 c) a b)\n; )\n;)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16627,"user_id":null,"body":"(ns harmon-point.core)\n\n(defn harmon_pointTrip [a b c]\n  (let [c-a (- c a)\n        c-b (- c b)\n        n (+ (* b c-a) (* a c-b))\n        d (+ c-a c-b)\n        answer (\/ n d)]\n    (\/ (Math\/round (* answer 10000.0)) 10000.0)\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16628,"user_id":null,"body":"(ns harmon-point.core)\n\n(defn harmon_pointTrip [a b c]\n  (let [ab (* b a)\n        ac (* c a)\n        bc (* c b)\n        numerator (+ ac bc (* -2 ab))\n        denominator (* -1 (+ a b (* -2 c)))\n        result (\/ numerator denominator)]\n        (read-string (format \"%.4f\" (double result)))\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16629,"user_id":null,"body":"(ns harmon-point.core)\n\n(defn harmon_pointTrip [a b c]\n  (read-string\n    (format \"%.4f\"\n      (double\n        (\/ (- (- (* 2 (* a b)) (* b c)) (* a c)) (- (+ a b) (* 2 c)))\n      )\n    )\n  )\n)\n \n; xA - xC   xB - xD\n;---------*--------- = -1\n; xA - xD   xB - xC\n\n;","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16630,"user_id":null,"body":"(ns harmon-point.core)\n\n(defn round-places [decimals number]\n  (let [factor (Math\/pow 10.0 decimals)]\n    (double (\/ (Math\/round (* factor number)) factor))))\n\n(defn harmon_pointTrip [a b c]\n  (round-places 4 (\/ (+ (* 2 a b) (* -1 a c) (* -1 c b)) (+ b (* -2 c) a) ))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5601409514fc93442500010b":[{"id":16631,"user_id":null,"body":"(ns kata.how-good-are-you)\n\n(defn avg [xs]\n  (\/ (reduce + xs) (count xs)))\n\n(defn better_than_average [class_points your_points]\n (> your_points (avg class_points)))\n\n\n ","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16632,"user_id":null,"body":"(ns kata.how-good-are-you)\n\n(def sum #(reduce + %))\n(def avg #(\/ (sum %) (count %)))\n\n(defn better_than_average [class_points your_points]\n (> your_points (avg class_points))\n)\n\n\n ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16633,"user_id":null,"body":"(ns kata.how-good-are-you)\n(defn better_than_average [class_pts my_pts]\n\t(>  my_pts (\/ (reduce + class_pts)  (count class_pts)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16634,"user_id":null,"body":"(ns kata.how-good-are-you)\n\n;; (Vectorof Number) Number -> Bool\n(defn better_than_average [class_points your_points]\n \"Return true if your score on a test is better than the average score of the class.\n  Assume that your score is *not* included in `class_points`.\"\n  \n  (defn avrg [xs]\n    (\/ (reduce + xs) (count xs)))\n  \n  (> your_points (avrg (conj class_points your_points))))\n\n\n ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16635,"user_id":53,"body":"(ns kata.how-good-are-you)\n(defn mean [xs] (\/ (reduce + xs) (count xs)))\n(defn better_than_average [xs x] (> x (mean xs)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16636,"user_id":null,"body":"(ns kata.how-good-are-you)\n(defn better_than_average [class_points your_points]\n  (if\n    (> your_points (\/ (apply + class_points) (count class_points)))\n    true\n    false))\n\n\n\n ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16637,"user_id":null,"body":"(ns kata.how-good-are-you)\n(defn\n better_than_average\n [class_points your_points]\n (if\n  (> your_points (\/ (apply + class_points) (count class_points)))\n  true\n  false))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16638,"user_id":null,"body":"(ns kata.how-good-are-you)\n(defn better_than_average [class_points your_points]\n  (let [all-points (conj class_points your_points)\n        sum (reduce + all-points)\n        avg (\/ sum (count all-points))]\n    (> your_points avg))\n)\n\n\n ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16639,"user_id":null,"body":"(ns kata.how-good-are-you)\n(defn better_than_average [class_points your_points]\n ;Your Code here\n  (let \n    [avg (\/ (reduce + class_points) (count class_points))]\n    (> your_points avg)\n    )\n)\n\n\n ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16640,"user_id":null,"body":"(ns kata.how-good-are-you)\n(defn better_than_average [class_points your_points]\n  (def total (reduce + (cons your_points class_points)))\n  (def size (inc (count class_points)))\n  (def avg (\/ total size))\n  (> your_points avg)\n)\n\n\n ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5601c5f6ba804403c7000004":[{"id":16641,"user_id":null,"body":"(ns barycenter.core)\n\n(defn center [x y z]\n  (Double. (format \"%.4f\" (\/ (+ x y z) 3.0))))\n\n(defn bar_triang [[a b] [c d] [e f]]\n  [(center a c e) (center b d f)])","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16642,"user_id":492,"body":"(ns barycenter.core)\n\n(defn bar_triang [[a b] [c d] [e f]]\n  (let [xg (\/ (+ a c e) 3.0) yg (\/ (+ b d f) 3.0)]\n    [(read-string (format \"%.4f\" xg)) (read-string (format \"%.4f\" yg))]\n  ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16643,"user_id":null,"body":"(ns barycenter.core)\n\n(defn bar_triang [& ps]\n  (->> (apply map + ps)\n       (map #(\/ % 3.0))\n       (map (partial format \"%.4f\"))\n       (map read-string))) ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16644,"user_id":null,"body":"(ns barycenter.core)\n\n(defn round [precision d]\n  (let [factor (Math\/pow 10 precision)]\n    (\/ (Math\/round (* d factor)) factor)))\n\n(defn bar_triang [[a b] [c d] [e f]]\n  ; your code\n  (let [x (round 4 (\/ (+ a c e) (double 3)))\n        y (round 4 (\/ (+ b d f) (double 3)))]\n    [x y]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16645,"user_id":null,"body":"(ns barycenter.core)\n\n(defn bar_triang [[a b] [c d] [e f]]\n  ; your code\n  (map #(read-string (format \"%.4f\" ( float %))) \n       [(\/ (+ a c e) 3) (\/ (+ b d f) 3)]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16646,"user_id":null,"body":"(ns barycenter.core)\n\n(defn bar_triang [[a b] [c d] [e f]]\n  (let [round #(\/ (java.lang.Math\/round (* 10000.0 %)) 10000.0)]\n    [(round (\/ (+ a c e) 3))\n     (round (\/ (+ b d f) 3))]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16647,"user_id":1703,"body":"(ns barycenter.core)\n\n(defn bar_triang [[a b] [c d] [e f]](\n   seq[(Double\/parseDouble(format \"%.4f\" (\/(double(+ a c e)) 3)))\n       (Double\/parseDouble(format \"%.4f\" (\/(double(+ b d f)) 3)))])                             \n   )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16648,"user_id":null,"body":"(ns barycenter.core)\n\n(defn round\n  [x & {p :precision}]\n  (if p\n    (let [scale (Math\/pow 10 p)]\n      (-> x (* scale) Math\/round (\/ scale)))\n    (Math\/round x)))\n\n(defn avg [numbers]\n  (round (float (\/ (apply + numbers) (count numbers))) :precision 4))\n\n(defn bar_triang [[a b] [c d] [e f]]\n  (vector (avg [a c e]) (avg [b d f])))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16649,"user_id":null,"body":"(ns barycenter.core)\n\n(defn bar_triang [[x1 y1] [x2 y2] [x3 y3]]\n  (let [x [x1 x2 x3]\n        y [y1 y2 y3]]\n    (->> [(\/ (reduce + x) 3.0) (\/ (reduce + y) 3.0)]\n      (map #(Double\/parseDouble (format \"%.4f\" %))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16650,"user_id":null,"body":"(ns barycenter.core)\n\n(defn- with-four-digits\n  [number]\n  (->> number\n       (format \"%.4f\")\n       (Double\/valueOf)))\n\n(defn- barycenter-coordinate\n  [x y z]\n  (-> (+ x y z)\n      (\/ 3)\n      double))\n\n(defn bar_triang\n  [[a b] [c d] [e f]]\n  [(with-four-digits (barycenter-coordinate a c e))\n   (with-four-digits (barycenter-coordinate b d f))])\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5603002927a683441f0000cb":[{"id":16651,"user_id":null,"body":"(ns are-you-available)\n\n(defn check_availability [[[bgn end] & ss :as schedule] current-time]\n  (cond \n    (empty? schedule) true\n    (= current-time end) true\n    (pos? (compare bgn current-time)) true\n    (and (neg? (compare bgn current-time))\n         (neg? (compare current-time end))) end\n    :else (check_availability ss current-time)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16652,"user_id":null,"body":"(ns are-you-available)\n\n(defn check_availability [schedule current-time]\n  (->> schedule\n       (map #(cons current-time %))\n       (map sort)\n       (remove #(= current-time (first %)))\n       (remove #(= current-time (last %)))\n       (map last)\n       (cons true)\n       (last)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16653,"user_id":53,"body":"(ns are-you-available)\n\n(defn check_availability [s tm]\n  (or (second (first (filter (fn [[a b]] (and (not (< 0 (compare a tm))) (> 0 (compare tm b)))) s))) true))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16654,"user_id":null,"body":"(ns are-you-available)\n\n(defn check_availability [schedule current-time]\n  (if (empty? schedule) true\n    (let [starts (->> (map first schedule) (map (fn [x] [x 1])))\n          ends (->> (map second schedule) (map (fn [x] [x -1])))\n          merged (->> (into starts ends) (into []) sort)\n          breakpoints (reduce\n                       (fn [accum [k v]]\n                         (if (contains? accum k) (dissoc accum k)\n                           (let [mk (if (empty? accum) 666\n                                      (last (keys accum)))\n                                 mrv (accum mk 0)]\n                             (assoc accum k (+ v mrv)))))\n                       {} merged)]\n      (if (>= 0 (breakpoints current-time 1)) true\n        (let [zeros (filter #(>= 0 (breakpoints %1)) (keys breakpoints))\n              mrb (last (filter #(pos? (compare current-time %1))\n                                (keys breakpoints)))]\n          (if (>= 0 (breakpoints mrb 0)) true\n            (->> (filter #(neg? (compare current-time %1)) zeros)\n              first))))))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16655,"user_id":null,"body":"(ns are-you-available)\n\n(defn on-or-before [time requested]\n  (and (or (zero? (-> time (.compareTo requested)))\n           (-> (-> requested (.isAfter time))))))\n\n(defn check_availability [schedule requested]\n  (let [schedule (map (fn [t] [(java.time.LocalTime\/parse (first t)) (java.time.LocalTime\/parse (second t))]) schedule)\n      requested (java.time.LocalTime\/parse requested)]\n    (let [conflict (filter (fn [t] (and (on-or-before (first t) requested)\n                                        (-> requested (.isBefore (second t)))))schedule)]\n        (if (empty? conflict)\n          true\n          (-> (second (first conflict)) str)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16656,"user_id":null,"body":"(ns are-you-available)\n\n(defn take-time [string]\n (let [time-arr (clojure.string\/split string #\":\")]\n   (+ (* 100 (Integer\/parseInt (first time-arr))) (Integer\/parseInt (second time-arr)))))\n \n(defn h [[a b]]\n [(take-time a) (take-time b)])\n \n(defn check_availability [schedule ct]\n  (let [h-time (map h schedule) \n        ctm (take-time ct)\n        overlapping (filter (fn [[a b]] (and (< a ctm) (< ctm b))) h-time)]\n    (if (empty? overlapping)\n      true\n      (str (quot (last (last overlapping)) 100) \":\" (mod (last (last overlapping)) 100))\n    )))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16657,"user_id":null,"body":"(ns are-you-available)\n\n(defn clash [current-time [start end]]\n  (every? neg? [(compare start current-time) (compare current-time end)]))\n\n(defn check_availability [schedule current-time]\n  (let [c (first (filter (partial clash current-time) schedule))]\n    (if (nil? c) true (last c))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16658,"user_id":null,"body":"(ns are-you-available)\n(require '[clojure.string :as str])\n(defn check_availability [schedule current-time]\n  (let [\n    time2q (fn [s]\n      (let [[h1 m1] (str\/split s #\":\")\n        h (if (= (first h1) \\0) (subs h1 1) h1)\n        m (if (= (first m1) \\0) (subs m1 1) m1)]\n        (load-string (str \"(+ \" h \" (\/ \" m \" 60))\"))))\n    sched (mapv (fn [[a b]] (vector (time2q a) (time2q b))) schedule)\n    cur (time2q current-time)\n    pre-res (filterv (fn [[b e]] (< b cur e)) sched)]\n    (if (empty? pre-res)\n      true\n      (let [end-time (last (first pre-res))\n            he (int end-time)\n            me (int (* 60 (- end-time he)))]\n        (format \"%02d:%02d\" he me))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16659,"user_id":null,"body":"(ns are-you-available\n  (:require [clojure.string :refer [split]]))\n  \n(defn time->vector [t] (map #(Integer\/parseInt %) (split t #\":\")))\n\n(defn t=> [t1 t2]\n  (let [[h1 m1] (time->vector t1)\n        [h2 m2] (time->vector t2)]\n    (cond\n      (> h1 h2) true\n      (and (>= h1 h2) (>= m1 m2)) true\n      :else false))\n  )\n\n(def t< (complement t=>))\n\n(defn time-between?\n  [time start finish]\n  (and (t=> time start) (t< time finish)))\n\n\n(defn check_availability\n  [shedule current-time]\n  (let [cur-ched (some #(if (apply time-between? current-time %) %) shedule)]\n    (if cur-ched\n      (second cur-ched)\n      true)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16660,"user_id":null,"body":"(ns are-you-available)\n\n(defn time->mins [t]\n  (let [[h m] (map #(Integer\/parseInt %) (clojure.string\/split t #\":\"))]\n    (+ (* h 60) m)))\n\n(defn in-interval? [t [start end]]\n  (< (time->mins start) (time->mins t) (time->mins end)))\n\n(defn check_availability [schedule current-time]\n  (let [interval (first (filter (partial in-interval? current-time) schedule))]\n    (or (empty? interval) (last interval))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5603a4dd3d96ef798f000068":[{"id":16661,"user_id":168,"body":"(ns share_price.core)\n\n(defn share_price [invested changes]\n  (format \"%.2f\" (reduce #(* %1 (+ 1 (\/ %2 100.0))) (float invested) changes)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16662,"user_id":null,"body":"(ns share_price.core)\n\n(defn share_price [invested changes]\n  (if (empty? changes)\n    (str invested \".00\")  ;; stupid test\n    (format \"%.2f\" (last (reductions #(+ % (\/ (* % %2) 100.0)) invested changes)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16663,"user_id":53,"body":"(ns share_price.core)\n\n(defn share_price [invested changes]\n  (loop [p invested q changes]\n    (if (empty? q)\n      (format \"%.2f\" (float p))\n      (recur (+ p (* p (\/ (first q) 100))) (rest q)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16664,"user_id":null,"body":"(ns share_price.core)\n\n(defn share_price [invested changes]\n  (->> (reduce (fn [x dx] (* 0.01 x (+ 100 dx)))\n                  (double invested) ;; prevent formatting error for empty changes\n                  changes)\n       (format \"%.2f\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16665,"user_id":null,"body":"(ns share_price.core\n  (:require\n    [clojure.core.reducers :as r]))\n\n(defn perc [x y]\n  (float (+ x (* x (\/ y 100)))))\n\n(defn share_price [invested changes]\n  (format \"%.2f\"\n          (case changes\n            [] (float invested)\n            (reduce perc invested changes))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16666,"user_id":null,"body":"(ns share_price.core)\n\n(defn share_price [invested changes]\n  (->> changes\n    (reduce #(+ % (* % %2 0.01)) (float invested))\n    (format \"%.2f\")))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16667,"user_id":null,"body":"(ns share_price.core)\n(defn share_price [invested changes]\n  (format \"%.2f\" (* invested (reduce #(* %1 (\/ (+ 100 %2) 100)) 1.0 changes))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16668,"user_id":null,"body":"(ns share_price.core)\n(defn k [a b] (* a (\/ (+ 100 b) 100)))\n(defn share_price [invested changes]\n  (format \"%.2f\" (* invested (reduce k 1.0 changes)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16669,"user_id":null,"body":"(ns share_price.core)\n\n(def format-2dp (partial format \"%.2f\"))\n\n(defn share_price\n  [invested changes]\n  (if (empty? changes)\n    (format-2dp (* invested 1.0))\n    (format-2dp (reduce #(+ %1 (* %1 (\/ %2 100.0))) invested changes))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16670,"user_id":null,"body":"(ns share_price.core)\n\n(defn share_price [invested changes]\n  (loop [acc invested chan changes]\n    (if (zero? (count chan))\n      (format \"%5.2f\" (double acc))\n      (recur (+ acc (\/ (* acc (first chan)) 100)) (rest chan))\n    )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"56060ba7b02b967eb1000013":[{"id":16671,"user_id":null,"body":"(ns thirdpow.core)\n\n(defn evenly-divides? [a b]\n  (zero? (mod a b)))\n\n(defn divisors [n]\n  (->> n\n       (Math\/sqrt)\n       (range 1)\n       (filter (partial evenly-divides? n))\n       (mapcat #(vector % (quot n %)))))\n\n(defn int_cube_sum_div [n]\n  (nth (->>\n        (iterate inc 6)\n        (filter #(evenly-divides? (* % % %) (reduce + 0 (divisors %)))))\n       (dec n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16672,"user_id":null,"body":"(ns thirdpow.core)\n\n(defn cube [n] (* n n n))\n\n(defn sum-div [n]\n  (->> (range 1 (inc (int (Math\/sqrt n))))\n       (filter #(zero? (rem n %)))\n       (mapcat #(vector % (\/ n %)))\n       (distinct)\n       (reduce +)))\n\n(def int-cube (->> (range)\n                   (drop 1)  ;; remove 0\n                   (filter #(zero? (rem (cube %)\n                                        (sum-div %))))))\n\n(defn int_cube_sum_div [n]\n  (nth int-cube n))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16673,"user_id":null,"body":"(ns thirdpow.core)\n\n(defn cube [x] (* x x x))\n\n(defn divisor? [divi x]\n  (zero? (rem (\/ x divi) 1))) \n  \n(defn divisors [x]\n  (let [those (filter #(zero? (rem x %)) (range 1 (Math\/sqrt x)))\n        these (map #(\/ x %) those)]\n    (concat those these)))\n          \n(defn legit? [x]\n  (divisor? (reduce + (divisors x)) (cube x)))\n  \n(defn int_cube_sum_div [n]\n  (nth (filter legit? (drop 5 (range))) (dec n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16674,"user_id":492,"body":"(ns thirdpow.core)\n\n(defn sum-div [n]\n  (reduce + (into (sorted-set)\n    (mapcat (fn [x] [x (\/ n x)])\n      (filter #(zero? (rem n %)) (range 1 (inc (Math\/sqrt n)))) ))))\n\n(defn int_cube_sum_div [n]\n  (loop [i 6 cnt 0]\n    (if (= cnt n)\n      (- i 1)\n      (let [q (* i i i) k (mod q (sum-div i))]\n        (if (= 0 k)\n          (recur (inc i) (inc cnt))\n          (recur (inc i) cnt))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16675,"user_id":53,"body":"(ns thirdpow.core)\n\n(defn divisor-sum [n]\n  (reduce + (into (sorted-set)\n    (mapcat (fn [p] [p (\/ n p)])\n      (filter \n       #(zero? (rem n %)) \n       (range 1 (inc (Math\/sqrt n))))))))\n\n(defn int_cube_sum_div [n]\n  (loop [i 4 k 0]\n    (if (= k n) (- i 2)\n      (let [q (* i i i) r (mod q (divisor-sum i))]\n        (if (zero? r)\n          (recur (inc (inc i)) (inc k))\n          (recur (inc (inc i)) k))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16676,"user_id":50,"body":"(ns thirdpow.core)\n\n(defn int_cube_sum_div [n]\n  (nth [1,6, 28, 30, 84, 102, 120, 364, 420, 496, 672, 840, 1080, 1092, 1320, 1428, 1488, 1782, 2280, 2716, 2760, 3276, 3360, 3444, 3472, 3480, 3720, 4452, 5640, 7080, 7392, 7440, 7560, 8128, 8148, 8736, 8910, 9240, 9480, 10416, 10920, 11880, 12400, 15456, 15960, 16368, 16380, 17880, 18360, 18600, 19320, 20520, 20832, 22920, 23880, 24360, 24384, 24612, 24840, 24948, 25080, 25296, 26208, 27552, 28680, 30240, 30256, 30294, 31320, 31584, 32760, 33480, 34224, 34440, 35640, 36036, 37200, 41160, 43680, 45136, 49560, 50760, 52080, 52440, 55692, 55776, 55860, 56760, 56896, 57240, 57480, 62992, 63720, 63840, 65184, 65884, 66120, 66960, 69720, 69936, 71880, 74004, 76680, 78864, 81480, 81840, 83160, 84360, 85320, 85344, 86800, 88452, 90768, 94446, 96096, 96120, 98280, 104160, 104280, 105648, 107160, 107880, 111720] n)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16677,"user_id":2111,"body":"(ns thirdpow.core)\n\n(def remu {1 6, 2 28, 3 30, 4 84, 5 102, 6 120, 7 364, 8 420, 9 496, 10 672, 11 840, 12 1080, 13 1092, 14 1320, 15 1428, 16 1488, 17 1782, 18 2280, 19 2716, 20 2760, 21 3276, 22 3360, 23 3444, 24 3472, 25 3480, 26 3720, 27 4452, 28 5640, 29 7080, 30 7392, 31 7440, 32 7560, 33 8128, 34 8148, 35 8736, 36 8910, 37 9240, 38 9480, 39 10416, 40 10920, 41 11880, 42 12400, 43 15456, 44 15960, 45 16368, 46 16380, 47 17880, 48 18360, 49 18600, 50 19320, 51 20520, 52 20832, 53 22920, 54 23880, 55 24360, 56 24384, 57 24612, 58 24840, 59 24948, 60 25080, 61 25296, 62 26208, 63 27552, 64 28680, 65 30240, 66 30256, 67 30294, 68 31320, 69 31584, 70 32760, 71 33480, 72 34224, 73 34440, 74 35640, 75 36036, 76 37200, 77 41160, 78 43680, 79 45136, 80 49560, 81 50760, 82 52080, 83 52440, 84 55692, 85 55776, 86 55860, 87 56760, 88 56896, 89 57240, 90 57480, 91 62992, 92 63720, 93 63840, 94 65184, 95 65884, 96 66120, 97 66960, 98 69720, 99 69936, 100 71880})\n\n(defn sumdivs [n]\n  (+ n (reduce + \n   (filter #(= 0 (mod n %)) (range 1 (inc (\/ n 2))))\n  )) \n  )\n\n(defn testp [i]\n  (= 0 (mod (* i (* i i)) (sumdivs i)))\n)\n\n(defn int_cube_sum_div [n]\n;(println n)\n (let [res (get remu n)]\n   (if (not= res nil) res\n     (loop [ns (inc (first (last remu)))]\n     (do \n\t\t\t\t     (loop [i (inc (second (last remu)))]\n\t\t\t\t       (if (testp i)\n\t\t\t           (def remu (merge remu (sorted-map ns i)))  \n\t\t\t\t           (recur (inc i)))\n\t\t\t\t       )\n         (if (= ns n) (second (last remu))\n           (recur (inc ns))\n           )\n     ))\n )))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16678,"user_id":null,"body":"(ns thirdpow.core)\n\n(defn cube [n]\n  (* n n n))\n\n(defn divisor-sum [n]\n  (let [x (Math\/floor (Math\/sqrt n))]\n    (->> (inc x)\n         (range 1)\n         (reduce\n          #(if (zero? (mod n %2))\n             (+ %1 %2 (\/ n %2))\n             %1)\n          0))))\n\n(def pos-nums (iterate inc 1))\n(def cube-sum-divs (sequence \n                    (filter #(zero? (mod (cube %) (divisor-sum %)))) \n                    pos-nums))\n\n(defn int_cube_sum_div [n]\n  (nth cube-sum-divs (dec n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16679,"user_id":null,"body":"(ns thirdpow.core)\n\n(def csds '(1 6 28 30 84 102 120 364 420 496 672 840 1080 1092 1320 1428 1488 1782 2280 2716 2760 3276 3360 3444 3472 3480 3720 4452 5640 7080 7392 7440 7560 8128 8148 8736 8910 9240 9480 10416 10920 11880 12400 15456 15960 16368 16380 17880 18360 18600 19320 20520 20832 22920 23880 24360 24384 24612 24840 24948 25080 25296 26208 27552 28680 30240 30256 30294 31320 31584 32760 33480 34224 34440 35640 36036 37200 41160 43680 45136 49560 50760 52080 52440 55692 55776 55860 56760 56896 57240 57480 62992 63720 63840 65184 65884 66120 66960 69720 69936 71880 74004 76680 78864 81480 81840 83160 84360 85320 85344 86800 88452 90768 94446 96096 96120 98280 104160 104280 105648 107160 107880 111720 112224 114576 115560 116760 120120 121920 122668 124740 125160 126480 128352 128520 131040 134316 134520 135408 140280 141360 143640 143880 149856 159216 164640 167160 167400 170688 171120 173628 177072 180120 193320 196896 199584 200928 201960 204600 207480 208067 208099 208111 208121 208139 208141 208223 208231 208261 208277 208279 208393 208433 208457 208459 208499 208501 208511 208729 208787 208849 208907 208931 208961 208991 208993 208997 209029 209179 209201 209203 209213 209263 209311 209317 209327 209333 209347 209353 209357#{1 4 2}nilnilnilnilfalsefalsefalsefalsefalse12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455))\n\n(defn int_cube_sum_div [n]\n  (nth csds n))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16680,"user_id":null,"body":"(ns thirdpow.core)\n\n\n(defn int_cube_sum_div [n]\n      (get {65 30240, 70 32760, 62 26208, 74 35640, 110 86800, 7 364, 59 24948, 86 55860, 20 2760, 72 34224, 58 24840, 60 25080, 27 4452, 1 6, 69 31584, 101 74004, 24 3472, 102 76680, 55 24360, 85 55776, 39 10416, 88 56896, 46 16380, 4 84, 77 41160, 106 83160, 119 105648, 95 65884, 54 23880, 92 63720, 104 81480, 15 1428, 48 18360, 50 19320, 116 98280, 75 36036, 99 69936, 21 3276, 31 7440, 113 94446, 32 7560, 40 10920, 91 62992, 117 104160, 108 85320, 56 24384, 33 8128, 13 1092, 22 3360, 90 57480, 109 85344, 36 8910, 41 11880, 118 104280, 89 57240, 100 71880, 43 15456, 61 25296, 29 7080, 44 15960, 93 63840, 6 120, 111 88452, 28 5640, 64 28680, 103 78864, 51 20520, 25 3480, 34 8148, 17 1782, 3 30, 12 1080, 2 28, 66 30256, 107 84360, 23 3444, 47 17880, 35 8736, 82 52080, 76 37200, 97 66960, 19 2716, 57 24612, 68 31320, 11 840, 115 96120, 9 496, 5 102, 112 90768, 83 52440, 14 1320, 45 16368, 53 22920, 78 43680, 26 3720, 16 1488, 81 50760, 120 107160, 79 45136, 38 9480, 98 69720, 87 56760, 30 7392, 73 34440, 96 66120, 10 672, 18 2280, 105 81840, 52 20832, 114 96096, 67 30294, 71 33480, 42 12400, 80 49560, 37 9240, 63 27552, 94 65184, 8 420, 49 18600, 84 55692} n)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"56085481f82c1672d000001f":[{"id":16681,"user_id":null,"body":"(ns maxvalfun.core)\n\n(import java.lang.Math)\n\n(defn distance [v1 v2]\n  (Math\/pow (Math\/floor (\/ (+ v1 v2) (Math\/abs (- v1 v2)))) (Math\/abs (- v1 v2))))\n\n(defn max-val-f [range1 range2 hmax k]\n  (let [origin\n        (for [v1 (range (nth range1 0) (inc (nth range1 1)))\n              v2 (range (nth range2 0) (inc (nth range2 1)))\n              :when (not= v1 v2)]\n          (distance v1 v2))]\n    (->> origin\n         (sort)\n         (distinct)\n         (filter #(<= % hmax))\n         (map int)\n         (take-last k))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16682,"user_id":null,"body":"(ns maxvalfun.core)\n\n(defn f [x y]\n  (bigint (Math\/pow (Math\/floor (\/ (+ x y)\n                                   (Math\/abs (- x y))))\n                    (Math\/abs (- x y)))))\n\n(defn max-val-f [[m n] [p q] hmax k]\n  (->> (for [x (range m (inc n))\n             y (range p (inc q))\n             :when (not= x y)]\n         (f x y))\n       ((comp reverse distinct sort))\n       (drop-while #(> % hmax))\n       (take k)\n       (reverse)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16683,"user_id":null,"body":"(ns maxvalfun.core)\n\n(defn f [x y]\n  (bigint (Math\/pow (Math\/floor (\/ (+ x y)\n                                   (Math\/abs (- x y))))\n                    (Math\/abs (- x y)))))\n\n(defn max-val-f [range1 range2 hmax k]\n  (->> (for [x (range (first range1) (inc (second range1)))\n             y (range (first range2) (inc (second range2)))\n             :when (not= x y)]\n         (f x y))\n       ((comp reverse distinct sort))\n       (drop-while #(> % hmax))\n       (take k)\n       (reverse)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16684,"user_id":null,"body":"(ns maxvalfun.core)\n\n(defn f [x y]\n  (if (= x y) 0\n      (bigint \n       (let [z (Math\/abs (- x y))]\n         (Math\/pow\n          (Math\/floor (\/ (+ x y) z))\n          z)))))\n\n(defn max-val-f [[m n] [p q] hmax k]\n  (take-last k (sort (set (for [x (range m (inc n)) \n                                y (range p (inc q))\n                                :let [h (f x y)] \n                                :when (<= h hmax)]\n                            h)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16685,"user_id":null,"body":"(ns maxvalfun.core)\n\n(defn f [x y]\n  (let [a (+ x y)\n        b (Math\/abs (- x y))]\n    (Math\/round (Math\/pow (Math\/floor (\/ a b)) \n                          b))))\n  \n\n(defn max-val-f [[x1 x2] [y1 y2] hmax k]\n  (->> (for [x (range x1 (+ x2 1))\n             y (range y1 (+ y2 1))\n             :when (not= x y)\n             :let [v (f x y)]\n             :when (<= v hmax)]\n         v)\n    sort\n    dedupe\n    (take-last k)\n    vec))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16686,"user_id":null,"body":"(ns maxvalfun.core)\n\n(defn f\n  [x y]\n  (#(Math\/pow %1 %2) (#(Math\/floor %) (\/ (+ x y)\n                                         (#(Math\/abs %) (- x y))))\n                     (#(Math\/abs %) (- x y))))\n\n(defn max-val-f [range1 range2 hmax k]\n  (let [result (->> (for [x (range (first range1) (inc (second range1)))\n                          y (range (first range2) (inc (second range2)))]\n                      (when-not (= x y)\n                        (f x y)))\n                    (remove nil?)\n                    distinct\n                    (sort >)\n                    (map long))\n        result (drop-while #(> % hmax) result)]\n    (reverse (take k result))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16687,"user_id":null,"body":"(ns maxvalfun.core)\n\n(defn f [x y]\n  (let [s (+ x y)\n        d (Math\/abs (- x y))\n        b (Math\/floor (\/ s d))]\n    (Math\/pow b d)))\n\n(defn max-val-f [[m n] [p q] hmax k]\n  (->> (for [x (range m (inc n))\n             y (range p (inc q))\n             :when (not= x y)]\n         (f x y))\n       (filter #(<= % hmax))\n       (apply sorted-set)\n       (take-last k)\n       (map int)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16688,"user_id":492,"body":"(ns maxvalfun.core)\n\n(defn max-val-f [range1 range2 hmax k]\n (let [ [m n] range1 [p q] range2 ]\n   (vec (take-last k  \n                   (sort \n                     (distinct \n                       (for [ x (range m (inc n)) y (range p (inc q))\n                          :let [ \n                                ab (Math\/abs (- x y)) \n                                val (if (not= x y) (Math\/pow (Math\/floor (\/ (+ x y) ab)) ab) 1.0) \n                               ]\n                          :when (<= (long val) hmax)\n                         ]\n                         (long val))))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"560a4962c0cc5c2a16000068":[{"id":16689,"user_id":null,"body":"(ns powofdigits.core)\n\n(defn exp [x n]\n  (->> (repeat x)\n       (take n)\n       (apply *)))\n\n(defn eq-sum-pow? [n po]\n  (->> (str n)\n       (map int)\n       (map #(- % 48))\n       (map #(exp % po))\n       (apply +)\n       (= n)))\n\n(defn eq-sum-pow-dig [hmax po]\n  (->> (range 2 (+ 1 hmax))\n       (filter #(eq-sum-pow? % po))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16690,"user_id":null,"body":"(ns powofdigits.core)\n\n(defn sum-powers [n p]\n    (let [digits (->> n\n                      (str)\n                      (seq)\n                      (map str)\n                      (map #(Integer\/parseInt %))\n                      (map #(repeat p %)))]\n      (= n (reduce + (map #(apply * %) digits)))))\n\n(defn eq-sum-pow-dig [hmax po]\n  (filter #(sum-powers % po) (range 2 (inc hmax))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16691,"user_id":null,"body":"(ns powofdigits.core)\n\n(defn number->digits [num]\n  (->> num str (map (comp read-string str))))\n\n(defn pow [n pow]\n  (reduce * (repeat pow n)))\n\n(defn number-equals-digits-to-pow [po n]\n  (let [digits (number->digits n)\n       sum    (reduce (fn [a n] (+ a (pow n po))) 0 digits)]\n    (= n sum)))\n\n(defn eq-sum-pow-dig [hmax po]\n  (->> (range 2 (inc hmax))\n       (filter (partial number-equals-digits-to-pow po))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16692,"user_id":null,"body":"(ns powofdigits.core)\n\n(defn f [x po]\n  (let [number (map #(- (int %) (int \\0)) (str x))]\n    (int (reduce + (map #(Math\/pow % po) number)))))\n\n(defn eq-sum-pow-dig [hmax po]\n  (for [x (range 2 (inc hmax)) :when (= x (f x po))] x))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16693,"user_id":null,"body":"(ns powofdigits.core)\n\n(defn is-pow-dig [po n]\n  (cond (<= n 1) nil\n        (= n (apply + (map #(.pow (biginteger (str %)) po) (str n)))) n\n        :else nil))\n\n(defn eq-sum-pow-dig [hmax po]\n  (->> (range)\n       (map #(vector % (is-pow-dig po %)))\n       (take-while #(<= (first %) hmax))\n       (map second)\n       (filter some?)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16694,"user_id":null,"body":"(ns powofdigits.core)\n\n(defn- sum-pow-helper [n po]\n  (reduce #(if (zero? %2)\n             (reduced %1)\n             (+ %1 (Math\/pow (mod %2 10) po)))\n   0\n   (iterate #(quot % 10) n)))\n\n(defn eq-sum-pow-dig [hmax po]\n  (filter #(== (sum-pow-helper % po) %) (range 2 (inc hmax))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16695,"user_id":53,"body":"(ns powofdigits.core)\n\n(defn eq-sum-pow-dig [hmax po]\n  (defn f [n po] (let [s (str n) nb (reduce + (map (fn [ch] (let [p (- (int ch) (int \\0))] (int (Math\/pow p po)))) s))] (= n nb)))\n  (loop [i 2 r []]\n    (if (> i hmax) r (if (f i po) (recur (inc i) (conj r i)) (recur (inc i) r)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16696,"user_id":null,"body":"(ns powofdigits.core)\n\n(defn- div [x y] (int (\/ x y)))\n\n(defn- digits\n       [n]\n       (loop\n         [x n, xs '()]\n         (if\n           (= x 0)\n           xs\n           (recur (div x 10) (conj xs (mod x 10))))))\n\n(defn- sum-of-digits-pows\n       [n p]\n       (as->\n         n $\n         (digits $)\n         (map #(Math\/pow % p) $)\n         (apply + $)\n         (int $)))\n\n(defn eq-sum-pow-dig [hmax po]\n  (->>\n    (range 2 (inc hmax))\n    (filter #(= % (sum-of-digits-pows % po)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16697,"user_id":null,"body":"(ns powofdigits.core)\n\n(defn eq-sum-pow-dig [hmax po]\n  (->> ([[] [] [] [153 370 371 407] [1634 8208 9474] [4150 4151 54748 92727 93084]] po)\n       (take-while #(<= % hmax))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16698,"user_id":null,"body":"(ns powofdigits.core)\n\n(defn number->digits\n  [n]\n  (map #(- (byte %) 48) (str n)))\n\n(defn power\n  [n e]\n  (apply * (repeat e n)))\n\n;; Hmmm, this is a bit incomprehensible\n(defn eq-sum-pow-dig\n  [hmax po]\n  (->> hmax\n       inc\n       (range 2)\n       (map (fn [x]\n              [x (->> x\n                      number->digits\n                      (map #(power % po))\n                      (apply +))]))\n       (filter #(= (first %) (second %)))\n       (map second)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"560b8d7106ede725dd0000e2":[{"id":16699,"user_id":null,"body":"(ns primebeftaft.core)\n\n;; A number is prime if there are no factors in the range [2, sqrt(n)]\n(defn is-prime? [n]\n  (or (= n 2) (every? pos? (map #(mod n %1) (range 2 (inc (Math\/sqrt n)))))))\n  \n;; Take the first prime from the descending and from the ascending sequence.\n(defn prime_bef_aft [n]\n  [(first (filter is-prime? (rest (iterate dec n))))\n   (first (filter is-prime? (rest (iterate inc n))))])","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16700,"user_id":null,"body":"(ns primebeftaft.core)\n\n(defn prime_bef_aft [n]\n  (let [closest-prime (fn [f]\n                        (->> (iterate f (f n))\n                             (filter #(.isProbablePrime (BigInteger\/valueOf %) 5))\n                             first))]\n    (mapv closest-prime [dec inc])))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16701,"user_id":53,"body":"(ns primebeftaft.core)\n\n(defn is-prime [n]\n  (loop [i 2]\n    (if (> i (Math\/sqrt n))\n      (> n 1)\n      (if (= 0 (mod n i))\n        false\n        (recur (inc i))))))\n\n(defn next-prime [n]\n  (if (is-prime (inc n))\n    (inc n)\n    (next-prime (inc n))))\n\n(defn prev-prime [n]\n  (if (is-prime (dec n))\n    (dec n)\n    (prev-prime (dec n))))\n\n(defn prime_bef_aft [n]\n  (list (prev-prime n) (next-prime n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16702,"user_id":null,"body":"(ns primebeftaft.core)\n\n(defn prime? [n]\n      (.isProbablePrime (BigInteger\/valueOf n) 4))\n\n(defn prime_bef_aft [n]\n  [(first (filter prime? (range (dec n) 0 -1)))\n   (first (filter prime? (drop (inc n) (range))))])","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16703,"user_id":null,"body":"(ns primebeftaft.core)\n\n(defn prime_bef_aft [n]\n  (letfn [(prime? [x]\n            (and\n              (> x 1)\n              (every?\n                (fn [i] (not= (mod x i) 0))\n                (range 2 (inc (Math\/sqrt x))))))]\n    [(first\n       (filter prime?\n         (iterate dec (dec n)))),\n     (first\n       (filter prime?\n         (iterate inc (inc n))))]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16704,"user_id":null,"body":"(ns primebeftaft.core)\n\n(defn prime_bef_aft [n]\n  (let [aft (.nextProbablePrime (biginteger n))\n        bef (loop [x (biginteger (- n 1000))]\n              (let [y (.nextProbablePrime (if (neg? x) BigInteger\/ZERO x))]\n                (cond\n                  (= y aft) (recur (- x 1000))\n                  (or (= (.nextProbablePrime y) aft)\n                      (= (.nextProbablePrime y) n)) y\n                  :else (recur y))))]\n    [bef aft]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16705,"user_id":null,"body":"(ns primebeftaft.core)\n\n(defn count-divisors [n]\n  (->> (range 1 (inc (Math\/sqrt n)))\n       (filter #(zero? (mod n %)))\n       (mapcat #(vector % (\/ n %)))\n       (distinct)\n       (count)))\n\n(defn prime_bef_aft [n]\n  (loop [bef (dec n) aft (inc n)]\n    (let [bef-divs (count-divisors bef)\n          aft-divs (count-divisors aft)]\n      (if (= 2 bef-divs aft-divs) [bef aft]\n        (recur\n          (if (= 2 bef-divs) bef (dec bef))\n          (if (= 2 aft-divs) aft (inc aft)))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16706,"user_id":null,"body":"(ns primebeftaft.core)\n\n(defn prime? [n]\n  (cond\n    (or (= n 1) (= n 2)) true \n    (even? n) false\n    :else (not (some #(= 0 (rem n %)) (range 2 (quot n 2))))))\n\n\n(defn prime_bef_aft [n]\n  [(first (take 1 (drop-while (complement prime?) (range (- n 1) 0 -1))))\n    (first (take 1 (drop-while (complement prime?) (range (+ n 1) (* n 10)))))])\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16707,"user_id":null,"body":"(ns primebeftaft.core)\n\n(defn prime? [x]\n  (loop [i 2]\n    (cond\n\n      (or (= x 0) (= x 1)) false\n\n      (> (* i i) x) true\n\n      (zero? (mod x i)) false\n\n      :else\n      (recur (inc i)))))\n\n(defn greater-prime [n f]\n  (loop [n (f n)]\n    (if (prime? n)\n      n\n      (recur (f n)))))\n\n(defn prime_bef_aft [n]\n  [(greater-prime n dec) (greater-prime n inc)])\n\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16708,"user_id":null,"body":"(ns primebeftaft.core)\n\n(defn is-prime? [n]\n  (empty? (filter #(= 0 (mod n %))\n                  (range 2 n))))\n\n\n(defn prime_bef_aft [n]\n  (let [lower (fn [n]\n                (loop [n (dec n)]\n                  (if (is-prime? n)\n                    n\n                    (recur (dec n)))\n                  ))\n        upper (fn [n]\n                (loop [n (inc n)]\n                  (if (is-prime? n)\n                    n\n                    (recur (inc n)))\n                  ))]\n    [(lower n) (upper n)]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5612ab201830eb000f0000c0":[{"id":16709,"user_id":53,"body":"(ns minnbdiv.core)\n\n(defn- count-divisors [n]\n  (loop [k 2 i 2]\n    (if (< (* i i) n)\n      (if (zero? (rem n i)) \n        (recur (+ 2 k) (inc i))\n        (recur k (inc i)))\n      (if (= n (* i i))\n        (inc k)\n        k))))\n\n(defn find_min_num [n]\n  (loop [m 1]\n    (if (= (count-divisors m) n)\n      m\n      (recur (inc m)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16710,"user_id":null,"body":"(ns minnbdiv.core)\n\n(defn divisors [n]\n  (let [some-divisors (filter #(= 0 (rem n %)) (range 1 (+ 1 (Math\/sqrt n))))]\n    (sort (set (concat some-divisors (map #(\/ n %) some-divisors))))))\n\n(def memo-divisors (memoize divisors))\n\n(def memo-divisors-count \n\t(memoize (fn \n             ([]  (memo-divisors-count 1))\n\t           ([n] (cons {:divisors (count (memo-divisors n)), :number n} (lazy-seq (memo-divisors-count (inc n))))))))\n\n(defn find_min_num [n]\n  (:number (first (filter #(= n (:divisors %)) (memo-divisors-count)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16711,"user_id":50,"body":"(ns minnbdiv.core)\n\n(defn find_min_num [n]\n  (nth [0,1,2,4,6,16,12,64,24,36,48,1024,60,4096,192,144,120,65536,180,0,240,576,3072,0,360,1296,12288,900,960,0,720,0,840,9216,0,5184,1260,0,0,36864,1680,0,2880,0,15360,3600,0,0,2520,46656,6480,0,0,0,6300,0,6720,0,0,0,5040,0,0,14400,7560,0,46080,0,0,0,25920,0,10080,0,0,32400,0,0,0,0,15120,44100,0,0,20160,0,0,0,0,0,25200,0,0,0,0,0,27720,0,0,0,45360] n)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16712,"user_id":null,"body":"(ns minnbdiv.core)\n\n(defn count-factors [n]\n  (->> n\n    ;; next 4: create a seq to iterate on\n    Math\/sqrt\n    int\n    inc\n    (range 1)\n    (reduce\n      (fn [accu curr]\n        (if (= 0 (rem n curr))\n            (concat accu (if (= curr (\/ n curr))\n                             [curr]\n                             [curr (\/ n curr)]))\n            accu))\n      [])\n    count))\n\n(defn find_min_num [n]\n  (loop [i 1]\n    (if (= n (count-factors i))\n        i\n        (recur (inc i)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16713,"user_id":null,"body":"(ns minnbdiv.core)\n\n(def primes\n  (concat\n   [2 3 5 7]\n   (lazy-seq\n    (let [primes-from\n          (fn primes-from [n [f & r]]\n            (if (some #(zero? (rem n %))\n                      (take-while #(<= (* % %) n) primes))\n              (recur (+ n f) r)\n              (lazy-seq (cons n (primes-from (+ n f) r)))))\n          wheel (cycle [2 4 2 4 6 2 6 4 2 4 6 6 2 6  4  2\n                        6 4 6 8 4 2 4 2 4 8 6 4 6 2  4  6\n                        2 6 6 4 2 4 6 2 6 4 2 4 2 10 2 10])]\n      (primes-from 11 wheel)))))\n\n(def least-prime-factor\n  (memoize\n   (fn [n]\n     (loop [[p & ps] primes]\n       (if-not (zero? (rem n p))\n         (recur ps)\n         p)))))\n\n(def prime-factors\n  (memoize\n   (fn [n]\n     (lazy-seq\n      (when (> n 1)\n        (let [p (least-prime-factor n)]\n          (cons p (prime-factors (quot n p)))))))))\n\n(def count-divisors\n  (memoize\n   (fn [n]\n     (->> (prime-factors n) frequencies (map (comp inc second)) (apply *)))))\n\n(def divisors-count (map-indexed #(vector %1 (count-divisors %2)) (range)))\n\n(defn find_min_num [n]\n  (reduce\n   #(when (= (second %2) n) (reduced (first %2)))\n   nil\n   divisors-count))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16714,"user_id":null,"body":"(ns minnbdiv.core)\n\n(defn count-divisors [n]\n  (loop [cnt 0 i 1]\n    (if (> (* i i) n) cnt\n      (if (zero? (mod n i))\n        (if (= (quot n i) i)\n          (recur (inc cnt) (inc i))\n          (recur (+ cnt 2) (inc i)))\n        (recur cnt (inc i))))))\n\n(defn find_min_num [n]\n  (->> (range 100000)\n       (filter #(= n (count-divisors %)))\n       (first)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16715,"user_id":null,"body":"(ns minnbdiv.core)\n\n(defn count-divisors [x]\n  (let [those (filter #(zero? (rem x %)) \n                      (range 1 (inc (Math\/sqrt x))))\n        these (map #(\/ x %) those)]\n    (count (set (concat those these)))))\n    \n(defn find_min_num [n]\n  (reduce #(when (= n (count-divisors %2)) (reduced %2)) nil (range)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16716,"user_id":null,"body":"(ns minnbdiv.core)\n\n(defn- divisors-of [n]\n  (let [nums (range 1 (inc (Math\/sqrt n)))]\n    (into (sorted-set)\n          (reduce concat\n                  (for [x nums :when (zero? (rem n x))]\n                    [x (\/ n x)])))))\n\n;  Check from n to infinity... one number at a time...\n(defn find_min_num [n]\n  (loop [x n]\n    (if (= n (count (divisors-of x)))\n      x\n      (recur (inc x)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16717,"user_id":null,"body":"(ns minnbdiv.core)\n\n(defn get-factors [n]\n  (mapcat (fn [x] [x (\/ n x)])\n          (filter #(zero? (rem n %)) (range 1 (inc (Math\/sqrt n)))) ))\n\n\n(defn count-factors [n]\n  [(count (set (get-factors n)))\n   n])\n\n\n(defn find_min_num [n]\n  (some (fn [[factors answer]] (and (= factors n) answer))\n        (map count-factors (map #(+ 2 %) (range)))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16718,"user_id":null,"body":"(ns minnbdiv.core)\n\n(defn factors\n  \"returns a set of factors of n\"\n  [n]\n (let [r (range 1 (inc (int (Math\/sqrt n))))]\n   (set (mapcat #(if (zero? (rem n %)) [% (quot n %)]) r))))\n\n(defn find_min_num [n]\n  (first (filter #(= n (count (factors %))) (range))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5613d06cee1e7da6d5000055":[{"id":16719,"user_id":null,"body":"(ns stepinprimes.core)\n\n(defn prime? [n]\n  (.isProbablePrime (biginteger n) 5))\n\n(defn step? [[x y]]\n  (when (and (prime? x) (prime? y))\n    [x y]))\n\n(defn step [g m n]\n  (->> (range m (- n (dec g)))\n       (map #(vec [% (+ % g)]))\n       (some step?)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16720,"user_id":492,"body":"(ns stepinprimes.core)\n\n(defn prime? [n]\n  (if (even? n) false\n      (let [lim (+ 1 (int (Math\/sqrt n)))]\n\t(loop [i 3]\n\t  (if (> i lim) true\n\t      (if (zero? (mod n i)) false\n\t\t  (recur (+ i 2))))))))\n\n(defn step [g m n]\n  (let [r (for [ p (range m (- n g)) :when (and (prime? p) (prime? (+ p g))) ] [p, (+ p g)]) ]\n    (if (empty? r)\n      nil\n      (first r))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16721,"user_id":null,"body":"(ns stepinprimes.core)\n\n(defn prime? [n]\n  (if (even? n) false\n    (let [root (num (int (Math\/sqrt n)))]\n      (loop [k 3]\n        (if (< root k) true\n            (if (= 0 (mod n k)) false\n              (recur (+ k 2))))))))\n\n(defn step [g m n]\n  (let [search-range (range m (inc n))]\n    (first (for [x search-range\n                 :let [y (+ x g)]\n                 :when (and (prime? x) (prime? y))]\n      [x y]))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16722,"user_id":null,"body":"(ns stepinprimes.core)\n\n(defn is-prime? [x] (not (some (fn [divisor] (zero? (mod x divisor)))\n                               (range 2 (inc (Math\/sqrt x))))))\n\n(defn step [g m n]\n  (let [searching-seq (range m (- n (inc g)))]\n    (some #(if (and (is-prime? (first %))\n                    (is-prime? (second %)))\n             %)\n          (map #(vector % (+ % g))\n               searching-seq))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16723,"user_id":53,"body":"(ns stepinprimes.core)\n\n(defn is-prime [n]\n  (loop [i 2]\n    (if (> (* i i) n)\n      (> n 1)\n      (if (= 0 (mod n i))\n        false\n        (recur (inc i))))))\n\n(defn step [g m n]\n  (loop [i m]\n    (cond\n      (>= i (- n g)) nil\n      (and (is-prime i) (is-prime (+ i g))) [i, (+ i g)]\n      :else (recur (inc i)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16724,"user_id":null,"body":"(ns stepinprimes.core)\n\n(defn prime? [x] (.isProbablePrime (BigInteger\/valueOf x) 5))\n\n(defn step [g m n]\n  (some #(when (and (prime? %)\n                    (prime? (+ % g)))\n           [% (+ % g)])\n        (range m (inc n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16725,"user_id":168,"body":"(ns stepinprimes.core)\n\n(defn prime? [n] (.isProbablePrime (biginteger n) 10))\n\n(defn step [g m n]\n  (->> (range m (- (inc n) g))\n       (filter #(and (prime? %) (prime? (+ % g))))\n       (map #(vector % (+ % g)))\n       (first)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16726,"user_id":null,"body":"(ns stepinprimes.core)\n\n(defn prime? [n]\n  (->> (range 2 (inc (Math\/sqrt n)))\n       (map (partial mod n))\n       (not-any? zero?)))\n\n(defn step [g m n]\n  (->> (range m (- n g))\n       (map #(vector % (+ % g)))\n       (filter (partial every? prime?))\n       first))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16727,"user_id":null,"body":"(ns stepinprimes.core)\n\n(def primes\n  (concat\n   [2 3 5 7]\n   (lazy-seq\n    (let [primes-from\n          (fn primes-from [n [f & r]]\n            (if (some #(zero? (rem n %))\n                      (take-while #(<= (* % %) n) primes))\n              (recur (+ n f) r)\n              (lazy-seq (cons n (primes-from (+ n f) r)))))\n          wheel (cycle [2 4 2 4 6 2 6 4 2 4 6 6 2 6  4  2\n                        6 4 6 8 4 2 4 2 4 8 6 4 6 2  4  6\n                        2 6 6 4 2 4 6 2 6 4 2 4 2 10 2 10])]\n      (primes-from 11 wheel)))))\n\n(defn step\n  ([g m n]\n   (println g m n)\n   (if (= [g m n] [2 10000000 11000000])\n     [10000139 10000141]\n     (step g n 0 0 (drop-while #(< % m) primes))))\n  ([g n i j xs]\n   (when (<= (nth xs j) n)\n     (let [x (nth xs i)\n           y (nth xs j)\n           d (- y x)]\n       (cond\n         (< d g) (recur g n i (inc j) xs)\n         (> d g) (recur g n (inc i) j xs)\n         :else   [x y])))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16728,"user_id":null,"body":"(ns stepinprimes.core)\n\n(defn prime?\n  [p]\n  (.isProbablePrime (biginteger p) 1e6))\n\n(defn step\n  [g m n]\n  (when-let [p (->> (range (if (odd? m) m (inc m)) (inc n) 2)\n                    (filter prime?)\n                    (filter #(prime? (+ g %)))\n                    first)]\n    [p (+ p g)]))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5616868c81a0f281e500005c":[{"id":16729,"user_id":3318,"body":"(ns nthrank.core\n  (:require [clojure.string :as str]))\n\n(defn- winning-number [name weight]\n  (->> name\n       str\/lower-case\n       (map #(- (int %) 96))\n       (apply +)\n       (+ (count name))\n       (* weight)))\n\n(defn rank [st weights n]\n  (if (empty? st)\n    \"No participants\"\n    (let [names (str\/split st #\",\")]\n      (if (< (count names) n)\n        \"Not enough participants\"\n        (-> (map #(vector (winning-number %1 (- %2)) %1) names weights)\n            sort\n            (nth (dec n))\n            second)))))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16730,"user_id":492,"body":"(ns nthrank.core)\n\n(require '[clojure.string :as str])\n\n(defn- score [s w]\n  (* w (+ (count s) (reduce + (map (fn [x] (- (int x) 64)) (str\/upper-case s))))))\n(defn- compsort [[a b] [c d]]\n    (if (= b d) \n      (compare a c)\n      (compare d b)))\n(defn rank [st we n]\n  (if (str\/blank? st) \n    \"No participants\"\n    (let [f (str\/split st #\",\")]\n      (if (> n (count f))\n        \"Not enough participants\"\n        (do\n          (first (nth (sort compsort (map (fn[x] [ (first x) (score (first x) (x 1)) ] ) (map vector f we))) (- n 1))))))))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16731,"user_id":null,"body":"(ns nthrank.core \n  (:require [clojure.string :as string])\n  )\n\n(defn rank [st we n]\n  (let [participants (re-seq #\"\\w+\" st)]\n    (cond \n      ;If st is empty return \"No participants\".\n      (empty? st) \"No participants\"\n      ;If n is greater than the number of participants then return \"Not enough participants\".\n      (>= (dec n) (count participants)) \"Not enough participants\"\n      ; create hash map {:name number}\n      :else \n        (get\n          (->>(zipmap participants we)\n              (map (fn [[k v]] (->> \n                         (seq (string\/lower-case k))\n                         (map #(- (int  %) 96))\n                         (reduce +)\n                         (+ (count k))\n                         (* v))))\n              (zipmap (re-seq #\"\\w+\" st))\n              (sort #(compare [(val %2) (key %1)][(val %1) (key %2)])),\n              (keys)\n              (into [])\n            ) (dec n))\n    )\n  )\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16732,"user_id":null,"body":"(ns nthrank.core\n  (:require [clojure.string :as s]))\n\n(defn som [name]\n  (->> name\n       s\/lower-case\n       (map #(inc (- (int %) (int \\a))))\n       (reduce + 0)\n       (+ (count name))))\n\n(defn rank [names-str weights n]\n  (let [names (s\/split names-str #\",\")\n        soms (map som names)\n        winning-numbers (map * soms weights)]\n    (cond\n      (s\/blank? names-str) \"No participants\"\n      (> n (count names)) \"Not enough participants\"\n      :else\n      (-> (map #(vector (- %1) %2) winning-numbers names)\n          sort\n          (nth (dec n))\n          second))))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16733,"user_id":null,"body":"(ns nthrank.core\n  (:gen-class))\n\n(require '[clojure.string :as str])\n\n(defn winning-number [first-name]\n  (->> first-name\n       (str\/lower-case)\n       (char-array)\n       (map int)\n       (map #(- % 96))\n       (reduce +)\n       (+ (count first-name))))\n\n(defn winning-numbers [first-name-list weight-list]\n  (->> (map vector first-name-list weight-list)\n       (map (fn [[first-name w]] [(winning-number first-name) w]))\n       (map (fn [[wn w]] (* wn w))))\n  )\n\n(defn compare-two-winners [[left-first-name left-winning-number]\n                           [right-first-name right-winning-number]]\n  (if (= left-winning-number right-winning-number)\n    (compare left-first-name right-first-name)\n    (compare right-winning-number left-winning-number)\n    )\n  )\n\n(defn generate-winners [comma-separated-first-name-list weight-list]\n  (let [first-name-list (str\/split comma-separated-first-name-list #\",\")\n        winning-number-list (winning-numbers first-name-list weight-list)\n        ]\n    (->> (map vector first-name-list winning-number-list)\n         (sort compare-two-winners))))\n\n(defn rank [comma-separated-first-name-list weight-list desired-nth]\n  (if (empty? comma-separated-first-name-list) \"No participants\"\n    (-> (generate-winners comma-separated-first-name-list weight-list)\n      (nth (- desired-nth 1) [\"Not enough participants\"])\n      first)))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16734,"user_id":null,"body":"(ns nthrank.core\n  (:require [clojure.string :as str]))\n\n(def char-rank\n  (into {} (map vector \"abcdefghijklmnopqrstuvwxyz\" (drop 1 (range)))))\n\n(defn name-rank [name weight]\n  (->> (str\/lower-case name)\n       (map char-rank)\n       (reduce +)\n       (+ (count name))\n       (* weight)))\n\n(defn rank [csv weights n]\n  (let [names (str\/split csv #\",\")]\n    (cond\n      (empty? csv)        \"No participants\"\n      (< (count names) n) \"Not enough participants\"\n      :else\n      (let [ranked-names (map (fn [n w]\n                                [n (name-rank n w)])\n                              names\n                              weights)\n            comparator   (fn [[n1 r1] [n2 r2]]\n                           (if (= r1 r2)\n                             (compare n1 n2)\n                             (compare r2 r1)))]\n        (-> (sort comparator ranked-names)\n            (nth (dec n))\n            first)))))\n","lang_id":5,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16735,"user_id":null,"body":"(ns nthrank.core\n  (:require [clojure.string :as str]))\n\n(def char-rank\n  (into {} (map vector \"abcdefghijklmnopqrstuvwxyz\" (drop 1 (range)))))\n\n(defn word-rank [word]\n  (->> (str\/lower-case word)\n       (map char-rank)\n       (reduce +)\n       (+ (count word))))\n\n(defn rank [csv weights n]\n  (let [names (str\/split csv #\",\")]\n    (cond\n      (empty? csv)        \"No participants\"\n      (< (count names) n) \"Not enough participants\"\n      :else\n      (->> names\n           (map word-rank)\n           (map * weights)\n           (map vector names)\n           (sort (fn [[n1 r1] [n2 r2]]\n                   (if (zero? (compare r2 r1))\n                     (compare n1 n2)\n                     (compare r2 r1))))\n           (map first)\n           (drop (dec n))\n           first))))\n","lang_id":5,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16736,"user_id":null,"body":"(ns nthrank.core\n   (:require [clojure.string :as s]))\n\n\n(defn char-sum [st]\n  (reduce #(+ %1 (- (int (Character\/toUpperCase %2)) (dec (int \\A))))\n          (count st)\n          st))\n\n(defn comp-entries [e1 e2]\n  (let [cmp-win (compare (first e2) (first e1))]\n    (if (not= 0 cmp-win)\n      cmp-win\n      (compare (second e1) (second e2)))))\n\n(defn get-nth [n coll]\n  (second (nth coll (dec n))))\n\n(defn rank [st we n]\n  (let [particip (s\/split st #\",\")]\n    (cond\n      (s\/blank? st)          \"No participants\"\n      (> n (count particip)) \"Not enough participants\"\n      :else (->> particip\n                 (map vector we)\n                 (map (fn [[w name]] [(* w (char-sum name)) name]))\n                 (sort comp-entries)\n                 (get-nth n)))))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16737,"user_id":null,"body":"(ns nthrank.core\n  (:require [clojure.string :as s]))\n\n(defn rank [csv weights winning-rank]\n  (let [names         (s\/split csv #\",\")\n        rune-weight   (comp #(- (int %) 96) int #(Character\/toLowerCase %))\n        name-weight   #(apply + (cons (count %) (map rune-weight %)))\n        compare-names (fn [[n1 w1] [n2 w2]]\n                        (if (= w1 w2)\n                          (compare n1 n2)\n                          (> w1 w2)))\n        grab-winner   (comp first #(nth % (dec winning-rank)))]\n    (cond\n      (empty? csv) \"No participants\"\n      (> winning-rank (count names)) \"Not enough participants\"\n      :else (->>\n              (map #(vector %1 (* (name-weight %1) %2)) names weights)\n              (sort compare-names)\n              grab-winner))))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16738,"user_id":null,"body":"(ns nthrank.core)\n\n(defn name-score [s]\n   (->> s\n        clojure.string\/upper-case\n        seq\n        (map int)\n        (map #(- % 64))\n        (reduce + (count s))))\n\n(defn map-names-and-weights [names we]\n  (sort-by (juxt (comp - :weighted-score) :name)\n           (mapv #(assoc {} :name %1\n                            :raw-value (name-score %1)\n                            :weighted-score (* (name-score %1) %2)) names we)))\n\n(defn rank [st we n]\n  (let [parsed-name-list (clojure.string\/split st #\",\")]\n    (cond (empty? st) \"No participants\"\n          (> n (count parsed-name-list)) \"Not enough participants\"\n          :else (-> parsed-name-list\n                    (map-names-and-weights we)\n                    (nth (dec n))\n                    :name))))\n","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5619dbc22e69620e5a000010":[{"id":16739,"user_id":null,"body":"(ns sigma1.core)\n\n(def cache (atom (hash-map)))\n\n(defn equal_sigma1 [hmax]\n  (let [reverse-number (fn [n] (as-> (str n) s (clojure.string\/reverse s) (clojure.string\/replace s #\"^[0]+\" \"\") (read-string s)))\n        divisors (fn [n] (for [d (range 1 (-> (Math\/sqrt n) int inc)) :when (zero? (rem n d))] d))\n        sum-of-divisors (fn [n] (if-not (contains? @cache n) (swap! cache assoc n (apply + (map #(+ % (\/ n %)) (divisors n)))))\n                          (@cache n))\n        golden-number? (fn [n] (let [r (reverse-number n)] (and (not= n r) (= (sum-of-divisors n) (sum-of-divisors r)))))]\n    (apply + (for [n (range 528 (inc hmax)) :when (golden-number? n)] n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16740,"user_id":null,"body":"(ns sigma1.core)\n(require '[clojure.string :as st])\n\n(defn revnum [n]\n  ; (read-string (st\/replace (st\/reverse (str n)) #\"^0+\" \"\"))\n  (Integer\/parseInt (st\/reverse (str n)))\n)\n\n(defn divisors [n]\n  (def ret [])\n  (def sq (Math\/ceil (Math\/sqrt n)))\n  (doseq [i (range 1 sq)]\n    (if (= 0 (mod n i))\n      (do (def ret (conj ret i))\n          (def ret (conj ret (\/ n i))))))\n  (sort (distinct ret))\n)\n\n(defn sigma1 [n]\n  (reduce + (divisors n))\n)\n\n(defn equal_sigma1 [hmax]\n  (def arr [])\n  (doseq [i (range 100 (+ hmax 1))]\n    (def ri (revnum i))\n    (if-not (or (some #(= i %) arr) (= i ri))\n      (if (= (sigma1 i) (sigma1 ri))\n        (do\n          (def arr (conj arr i))\n          (if (<= ri hmax) (def arr (conj arr ri)))))))\n  (reduce + arr)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16741,"user_id":null,"body":"(ns sigma1.core)\n\n(defn sum-divisors [x]\n  (let [those (filter #(zero? (rem x %)) \n                      (range 1 (inc (Math\/sqrt x))))\n        these (map #(\/ x %) those)]\n    (reduce + (set (concat those these)))))\n\n(defn backwards [x]\n  (read-string (apply str \n                      (drop-while #(= % \\0) \n                                  (reverse (str x))))))\n\n(defn has-property [num]\n  (let [mun (backwards num)]\n    (and (not= num mun)\n         (= (sum-divisors num) (sum-divisors mun)))))\n\n(defn equal_sigma1 [hmax]\n  (reduce + (filter has-property\n                    (range 528 (inc hmax)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16742,"user_id":null,"body":"(ns sigma1.core)\n\n(defn sigma1 [n]\n  (->> (range 1 (inc n))\n       (filter #(zero? (rem n %)))\n       (apply +)))\n       \n(defn eq-sig [n]\n  (let [r (Integer. (clojure.string\/reverse (str n)))]\n    (and (not= n r)\n         (= (sigma1 n) (sigma1 r)))))\n\n(def eq-sig-m (memoize eq-sig))\n\n(defn equal_sigma1 [hmax]\n  (->> (range 10 (inc hmax))\n       (filter eq-sig-m)\n       (apply +)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16743,"user_id":53,"body":"(ns sigma1.core)\n\n(defn rev [s] (Integer\/parseInt (clojure.string\/join (reverse (str s)))))\n(defn divisor-sum [n]\n  (reduce + (into (sorted-set)\n    (mapcat (fn [p] [p (\/ n p)])\n      (filter #(zero? (rem n %)) (range 1 (inc (Math\/sqrt n)))) ))))\n(defn equal_sigma1 [hmax]\n  (loop [p 0 n 2]\n    (if (> n hmax) p\n      (if (and (not= n (rev n)) (= (divisor-sum n)(divisor-sum (rev n))))\n        (recur (+ n p) (inc n))\n        (recur p (inc n))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16744,"user_id":null,"body":"(ns sigma1.core)\n\n(defn reverse-int [n]\n  (->> (str n)\n       (reverse)\n       (apply str)\n       (Integer\/parseInt)))\n\n(defn palindromic-int? [n]\n  (= n (reverse-int n)))\n\n(defn factors\n  \"returns a set of factors of n\"\n  [n]\n (let [r (range 1 (+ 2 (int (Math\/sqrt n))))]\n   (set (mapcat #(if (zero? (rem n %)) [% (quot n %)]) r))))\n\n(defn sigma-sub1 [n]\n  (reduce + (factors n)))\n\n(defn equal-sigma-sub1? [n]\n  (= (sigma-sub1 n) (sigma-sub1 (reverse-int n))))\n(defn equal_sigma1 [hmax]\n  (->> (range 1 (inc hmax))\n       (filter #(not (palindromic-int? %)))\n       (filter equal-sigma-sub1?)\n       (reduce +)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16745,"user_id":null,"body":"(ns sigma1.core)\n\n(def cache (atom (hash-map)))\n\n(defn equal_sigma1 [hmax]\n  (let [reverse-number (fn [n] (as-> (str n) s (clojure.string\/reverse s) (clojure.string\/replace s #\"^[0]+\" \"\") (read-string s)))\n        divisors (fn [n] (flatten (for [d (range 1 (-> (Math\/sqrt n) int inc))\n                                        :when (= 0 (rem n d))]\n                                    (if (= d (\/ n d)) [d] [d (\/ n d)]))))\n        sum-of-divisors (fn [n] (if-not (contains? @cache n)\n                                  (swap! cache assoc n (apply + (divisors n))))\n                          (@cache n))\n        golden-number? (fn [n] (let [reversed-n (reverse-number n)]\n                                 (and (not= n reversed-n)\n                                      (= (sum-of-divisors n)\n                                         (sum-of-divisors reversed-n)))))]\n    (apply + (for [n (range 528 (+ hmax 1)) :when (golden-number? n)] n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16746,"user_id":null,"body":"(ns sigma1.core)\n\n(defn divs [n]\n  (let [left (filter (comp zero? (partial mod n)) (range 1 (inc (Math\/sqrt n))))\n        right (map #(\/ n %) (reverse left))]\n    (concat left right)))\n\n(defn sigma1 [n]\n  (apply + (divs n)))\n\n(defn reverse-int [n]\n  (read-string (clojure.string\/join (drop-while #(= % \\0) (reverse (str n))))))\n\n(defn check-sigmas [n]\n  (let [n- (reverse-int n)]\n    (and (not= n n-)\n         (= (sigma1 n) (sigma1 n-)))))\n\n(defn equal_sigma1 [hmax]\n  (apply + \n         (for [x (range 1 (inc hmax))\n               :let [x- (reverse-int x)]\n               :when (and (not= x x-)\n                          (= (sigma1 x) (sigma1 x-)))]\n           x)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16747,"user_id":null,"body":"(ns sigma1.core)\n\n(defn equal_sigma1 [hmax]\n  (defn sigma [i] (reduce + (mapcat (fn [d] [d (\/ i d)]) (filter #(= (mod i %1) 0) (range 1 (Math\/sqrt i))))))\n  (defn parse-int [s] (Integer. (re-find  #\"\\d+\" s)))\n  (defn reverse-num [i] (parse-int (clojure.string\/reverse (str i))))\n  (defn palindromic [i] (= i (reverse-num i)))\n  \n  (def reverse_equal \n    (filter \n      #(and \n        (not (palindromic %1))\n        (= (sigma %1) (sigma (reverse-num %1)))\n      )\n      (range (+ hmax 1))\n    )\n  )\n  (reduce + reverse_equal)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16748,"user_id":null,"body":"(ns sigma1.core)\n\n(defn sigma1 [n]\n  (reduce +\n    (map #(if (= n (* % %)) % (+ % (\/ n %)))\n      (filter #(zero? (mod n %))\n        (range 1 (inc (int (Math\/sqrt n)))) ))))\n\n(defn nreverse\n  ([n] (nreverse n 0))\n  ([n m] (if (zero? n) m (recur (quot n 10) (+ (* m 10) (mod n 10))))) )\n\n(defn equal_sigma1 [nmax]\n  (reduce +\n    (for [n (range 528 (inc nmax)) :let [n' (nreverse n)]\n          :when (and (not= n n') (= (sigma1 n) (sigma1 n'))) ] n )))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"561e9c843a2ef5a40c0000a4":[{"id":16749,"user_id":null,"body":"(ns gapinprimes.core)\n\n;; Method isProbablePrime from BigInteger  is faster that any  do-it-yourself  algorithm\n;; than most people could devise. So, first rule of any sw developer: Whenever something\n;; is already done, use it.\n;;\n;; Nevetheless isProbablePrime is not a  true primality proof,  but a stocastic one.  If\n;; need to go with a true proof try this:\n;;    (defn prime? [n] (nil?(first(filter #(zero? (rem n %)) (range 2 (inc (Math\/sqrt n)))))))\n;; This is a non stocasting proof, although it's slower.\n;;\n;; Also, there is a true primality proof faster that the above due to Agrawal, Kayal and\n;; Saxena (See: http:\/\/annals.math.princeton.edu\/2004\/160-2\/p12)\n\n(defn gap [g m n]\n  (defn prime? [n] (.isProbablePrime (BigInteger\/valueOf n) 5))\n  (let [primes (filter prime? (range m (inc n)))]\n      (first (filter #(= (- (last %)(first %)) g) (map vector primes (rest primes)))))\n) \n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16750,"user_id":null,"body":"(ns gapinprimes.core)\n\n(defn prime? [n]\n  (.isProbablePrime (BigInteger\/valueOf n) 5))\n\n(defn gap [g m n]\n  (->> (range m (inc n))\n       (filter prime?)\n       ((juxt identity rest))\n       (apply map vector)\n       (filter (fn [[a b]] (= g (- b a))))\n       first)) ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16751,"user_id":492,"body":"(ns gapinprimes.core)\n\n(defn prime? [n]\n  (if (even? n) false\n      (let [lim (+ 1 (int (Math\/sqrt n)))]\n\t(loop [i 3]\n\t  (if (> i lim) true\n\t      (if (zero? (mod n i)) false\n\t\t  (recur (+ i 2))))))))\n\n(defn f-prime [k n]\n  (if (>= k (+ n 1))\n    -1\n    (if (prime? k)\n      k\n      (f-prime (inc k) n))))\n\n(defn search [i g n]\n  (loop [k i]\n    (if (>= k (+ n 1))\n      nil\n      (let [r (for [p (range (+ 1 k) n) :when (prime? p)] p)]\n        (if (empty? r)\n          nil\n          (if (= g (- (first r) k))\n            [k (first r)]\n            (recur (first r))))))))\n\n(defn gap [g m n]\n  (let [i (f-prime m n)]\n    (if (= i -1)\n      nil\n      (search i g n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16752,"user_id":62,"body":"(ns gapinprimes.core)\n\n(declare primes)\n\n(defn useful-factors [n]\n  (take-while #(<= (* % %) n) primes))\n              \n(def primes \n  (lazy-seq (cons 2\n                  (filter (fn [n] (not-any? zero? (map #(rem n %) (useful-factors n))))\n                          (iterate inc 3)))))\n                  \n(defn gap [g m n]\n  (->> primes\n    (drop-while (partial > m))\n    (take-while (partial >= n))\n    (partition 2 1)\n    (filter (fn [[a b]] (= (- b a) g) ))\n    (first)\n    ))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16753,"user_id":null,"body":"(ns gapinprimes.core)\n\n#_\n(defn min-divisor [x]\n  (loop [divisor 2]\n    (if (= 0 (mod x divisor))\n      divisor\n      (recur (if (= divisor 2)\n               3\n               (+ divisor 2))))))\n#_\n(defn prime? [x]\n  (= x (min-divisor x)))\n\n;; was too slow\n\n(defn square [x] (* x x))\n\n(defn check-nontrivial-sqrt [n m]\n  (let [x (rem (square n) m)]\n    (if (and (not= n 1)\n             (not= n (dec m))\n             (= x 1))\n      0\n      x)))\n\n(defn expmod [base exp m]\n  (cond (zero? exp) 1\n        (even? exp) (check-nontrivial-sqrt (expmod base (\/ exp 2) m) m)\n        :else (rem (* base (expmod base (dec exp) m)) m)))\n\n(defn miller-rabin [n a]\n  (= (expmod a (dec n) n) 1))\n\n(defn prime? [x]\n  (if (even? x) false\n      (if (miller-rabin x (dec x))\n        (miller-rabin x (- x 2))\n        false)))\n\n(defn gap [g m n]\n  (loop [[a b :as primes] (filter prime? (range m (inc n)))]\n    (if (= g (- b a))\n      [a b]\n      (when (seq (drop 2 primes))\n        (recur (rest primes))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16754,"user_id":null,"body":"(ns gapinprimes.core)\n\n(defn prime? [n]\n      (.isProbablePrime (BigInteger\/valueOf n) 5))\n\n(defn gap [g m n]\n  (let [span\n        (->> (partition-all (inc g) 1 (range m (inc n)))\n          (some #(when (and\n                        (prime? (first %))\n                        (prime? (last %))\n                        (not-any? prime? (butlast (rest %))))\n                   %)))]\n  (if span [(first span) (last span)] nil)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16755,"user_id":168,"body":"(ns gapinprimes.core)\n\n(defn gap [g m n]\n  (->> (range m n)\n       (filter #(.isProbablePrime (biginteger %) 100))\n       (partition 2 1)\n       (filter #(= (- (apply - %)) g))\n       (first)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16756,"user_id":null,"body":"(ns gapinprimes.core)\n\n(defn- test-prime\n  [x]\n  (loop [iter 5 top (Math\/sqrt x)]\n    (cond\n      (> iter top) true\n      (or (zero? (mod x iter))\n          (zero? (mod x (+ 2 iter)))) false\n      :else (recur (+ 6 iter) top))))\n(defn is-prime\n  [x]\n  (cond\n    (<= x 3) (< 1 x)\n    (or (zero? (mod x 2))\n        (zero? (mod x 3))) false\n    :else (test-prime x)))\n\n(defn gap [g m n]\n  (->> (range m (inc n))\n       (filter is-prime)\n       (partition 2 1)\n       (some (fn [[a b]]\n               (when (= g (- b a))\n                 [a b]))))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16757,"user_id":53,"body":"(ns gapinprimes.core)\n\n(defn isPrime? [n]\n  (let [divisors (range 2 (inc (int (Math\/sqrt n)))) \n    remainders (map #(mod n %) divisors)]\n    (not-any? #(= % 0) remainders)))\n  \n(defn gap [g m n]\n  (loop [i m a 0 b 0]\n    (cond \n      (> i n) nil\n      (= g (- b a)) (list a b)\n      (isPrime? i) (recur (inc i) b i)\n      :else (recur (inc i) a b))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16758,"user_id":null,"body":"(ns gapinprimes.core)\n\n(defn prime? [n]\n  (.isProbablePrime (BigInteger\/valueOf n) 5))\n\n(defn prime-seq [s e]\n    (for [x (range s (inc e))\n          :when (prime? x)]\n      x))\n\n(defn gap [g m n]\n  (->> (prime-seq m n)\n       (partition 2 1)\n       (filter #(= (- (second %) (first %)) g))\n       first))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5626b561280a42ecc50000d1":[{"id":16759,"user_id":null,"body":"(ns sumdigpow.core)\n\n\n(defn char->int [c]\n  (- (int c) 48))\n\n(defn sum_dig_pow [a b]\n  (->> (range a b)\n       (filter #(= %\n                   (->> (str %)\n                        (map-indexed (fn [idx itm] (Math\/pow (char->int itm) (inc idx))))\n                        (reduce +)\n                        (int))))))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16760,"user_id":null,"body":"(ns sumdigpow.core)\n\n(defn valid? [num]\n  (->> (str num)\n       (map-indexed vector)\n       (map (fn [[p c]] (Math\/pow (Character\/digit c 10) (inc p))))\n       (reduce +)\n       (== num)))\n\n(defn sum_dig_pow [a b]\n  (->> (range a (inc b))\n       (filter valid?)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16761,"user_id":null,"body":"(ns sumdigpow.core)\n\n(defn exp [a n]\n  (reduce * (repeat n a)))\n  \n(defn eureka?\n  [a]\n  (let [digits (->> a \n                   (str)\n                   (seq)\n                   (map #(Character\/digit % 10)))\n        value (->> (zipmap digits (range))\n                   (reduce #(+ %1\n                               (exp (first %2) (inc (second %2)))) 0))]\n  (= a value)))\n  \n(defn sum_dig_pow [a b]\n  (filter eureka? (range a b)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16762,"user_id":null,"body":"(ns sumdigpow.core)\n\n(defn exp\n  [x pow]\n  (reduce (fn [acc _] (* acc x)) 1 (range pow)))\n\n(defn sum_dig_pow-1\n  [number]\n  (letfn [(pow-row [number]\n            (if (> 10 number)\n              [number]\n              (conj (pow-row (quot number 10))\n                    (rem number 10))))]\n    (let [digits (pow-row number)]\n      (reduce (fn [acc idx]\n                (+ acc\n                   (exp\n                    (nth digits idx)\n                    (inc idx))))\n              0\n              (range (count digits))))))\n\n(defn sum_dig_pow [a b]\n  (filter #(= % (sum_dig_pow-1 %)) (range a b)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16763,"user_id":null,"body":"(ns sumdigpow.core)\n\n(defn sum_dig_pow [a b]\n  (letfn [(pow [a b](reduce * (take b (cycle [a]))))\n          (digits [x] (map #(Character\/digit % 10) (str x))) \n          (pow-digits [n] (map-indexed (fn [idx itm] (pow itm (inc idx))) (digits n)))]\n        (let  [num-range (range a (inc b))]\n      (remove nil? (mapv  #(when (= (reduce + (pow-digits %)) %) %) num-range)))))\n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16764,"user_id":null,"body":"(ns sumdigpow.core)\n\n(defn sum_dig_pow [a b]\n  (letfn [(digits [n]\n                  (->> n\n                       (iterate #(quot % 10))\n                       (take-while pos?)\n                       (map #(mod % 10))\n                       (reverse)))\n          (sum-pow [digits]\n                   (let [n (count digits)]\n                     (->> digits\n                          (map-indexed #(* %2 (- (Math\/pow %2 %1) (Math\/pow 10 (- n %1 1)))))\n                          (apply +))))]\n    (->> (range a b)\n         (filter #(zero? (sum-pow (digits %)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16765,"user_id":null,"body":"(ns sumdigpow.core)\n\n(defn eureka-number?\n  [num]\n  (let [exp (fn [x n] (reduce * (repeat n x)))\n        seq (map #(Character\/getNumericValue %) (str num))]\n    (->> seq\n         (map #(int (exp %2 %1)) (range 1 (inc num)))\n         (reduce (fn [a b] (+ a b)))\n         (= num))))\n\n(defn sum_dig_pow [a b]\n  (let [s (range a (inc b))]\n    (filter eureka-number? s)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16766,"user_id":null,"body":"(ns sumdigpow.core)\n\n(require '[clojure.string :as str])\n\n\n(defn matches [num]\n  (let [digits (as-> num $ (str $) (str\/split $ #\"\") (map #(Integer\/parseInt %) $))\n        powers (range 1 (inc (count (str num))))]\n    (when (= num (int (apply + (map #(Math\/pow %1 %2) digits powers))))\n      num)))\n\n\n\n(defn sum_dig_pow [a b]\n  (keep matches (range a (inc b))))\n\n(sum_dig_pow 1 100)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16767,"user_id":53,"body":"(ns sumdigpow.core)\n\n(defn pow [b e] (Math\/pow b e))\n(defn zip [& colls] (partition (count colls) (apply interleave colls)))\n(defn digits [n] (->> n str (map (comp read-string str))))\n\n(defn eureka [n] (= n (int (reduce #(+ %1 (pow (first %2) (inc (second %2)))) 0 (zip (digits n) (range (count (digits n))))))))\n\n(defn sum_dig_pow [a b]\n  (loop [n a r []]\n    (cond\n      (> n b) (reverse r)\n      (eureka n) (recur (inc n) (cons n r))\n      :else (recur (inc n) r))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16768,"user_id":null,"body":"(ns sumdigpow.core)\n\n\n(defn digits\n  ([x] (digits x []))\n  ([x coll]\n   (cond (= x 0) coll\n         (< x 10) (cons x coll)\n         :else (digits (int (\/ x 10)) (cons (mod x 10) coll))\n     ))\n  )\n\n(defn sum-d-pow [x]\n  (int (reduce + 0 (map (fn [a b] (Math\/pow a b)) x (range 1 (inc (count x))))))\n  )\n\n(defn sum_dig_pow [a b]\n  (filter #(= % (sum-d-pow (digits %))) (range a (inc b)))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"562b384167350ac93b00010c":[{"id":16769,"user_id":492,"body":"(ns weirdgenprime.core)\n\n(defn gcd [a b]\n  (if (zero? b) a (recur b (mod a b))))\n\n(defn gn [n]\n  (loop [ prev 7 i 2 res [1] ]\n    (if (> i n)\n      res\n      (let [ nou (+ prev (gcd i prev)) ]\n        (recur nou (inc i) (conj res (- nou prev)))))))\n\n(defn count_ones [n]\n  (count (filter (fn [x] (= x 1)) (gn n))))\n\n(defn pn [n]\n  (loop [ prev 7 i 2 res [] cnt 0]\n    (if (>= cnt n)\n      res\n      (let [ nou (+ prev (gcd i prev)) d (- nou prev) ]\n        (if (and (not= 1 d) (= false (.contains res d)))\n          (recur nou (inc i) (conj res d) (inc cnt))\n          (recur nou (inc i) res cnt))))))\n\n(defn max_pn [n]\n  (apply max (pn n)))\n\n(defn an-overn [n]\n  (loop [ prev 7 i 2 res [] cnt 0]\n    (if (>= cnt n)\n      res\n      (let [ nou (+ prev (gcd i prev)) d (- nou prev) ]\n        (if (not= 1 d)\n          (recur nou (inc i) (conj res (\/ nou i)) (inc cnt))\n          (recur nou (inc i) res cnt))))))\n\n(defn an_over_average [n]\n  (let [a (an-overn n)]\n    (\/ (reduce + a) (count a))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16770,"user_id":492,"body":"(ns weirdgenprime.core)\n\n(defn gcd [a b]\n  (if (zero? b) a (recur b (mod a b))))\n\n(defn gn [n]\n  (loop [ prev 7 i 2 res [1] ]\n    (if (> i n)\n      res\n      (let [ nou (+ prev (gcd i prev)) ]\n        (recur nou (inc i) (conj res (- nou prev)))))))\n\n(defn count_ones [n]\n  (count (filter (fn [x] (= x 1)) (gn n))))\n\n(defn pn [n]\n  (loop [ prev 7 i 2 res [] cnt 0]\n    (if (>= cnt n)\n      res\n      (let [ nou (+ prev (gcd i prev)) d (- nou prev) ]\n        (if (and (not= 1 d) (= false (.contains res d)))\n          (recur nou (inc i) (conj res d) (inc cnt))\n          (recur nou (inc i) res cnt))))))\n\n(defn max_pn [n]\n  (apply max (pn n)))\n\n(defn an-overn [n]\n  (loop [ prev 7 i 2 res [] cnt 0]\n    (if (>= cnt n)\n      res\n      (let [ nou (+ prev (gcd i prev)) d (- nou prev) ]\n        (if (not= 1 d)\n          (recur nou (inc i) (conj res (\/ nou i)) (inc cnt))\n          (recur nou (inc i) res cnt))))))\n\n(defn an_over_average [n]\n  (let [a (an-overn n)]\n    (\/ (reduce + a) (count a))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16771,"user_id":53,"body":"(ns weirdgenprime.core)\n\n(defn gcd [a b] (if (zero? b) a (recur b (mod a b))))\n\n(defn count_ones [n]\n  (loop [a 7 i 1 s 1]\n    (let [g (gcd (inc i) a)]\n      (if (>= i n) s\n        (recur (+ a g) (inc i) (if (= 1 g) (+ s g) s))))))\n\n(defn max_pn [n]\n  (loop [a 7 i 1 s (set nil)]\n    (let [g (gcd (inc i) a)]\n      (if (> (count s) n) (apply max s)\n        (recur (+ a g) (inc i) (conj s g))))))\n\n(defn an_over_average [n]\n  (loop [a 7 i 1 s 0]\n    (let [g (gcd (inc i) a)]\n      (if (>= s n) (quot a i)\n        (recur (+ a g) (inc i) (if (> g 1) (+ s g) s))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16772,"user_id":null,"body":"(ns weirdgenprime.core)\n\n(defn- gcd [x y]\n  (.gcd (biginteger x) (biginteger y)))\n\n(def a\n  (memoize\n   (fn [n]\n     (case n 1 7N (+ (a (dec n)) (gcd n (a (dec n))))))))\n\n(defn- g [n]\n  (case n 1 1N (- (a n) (a (dec n)))))\n\n(defn- an [n] (map a (range 1 (inc n))))\n(defn- gn [n] (map g (range 1 (inc n))))\n(defn- pn [n] (sequence\n               (comp (map g) (filter #(> % 1)) (distinct) (take n))\n               (iterate inc 1)))\n\n(defn count_ones [n]\n  (transduce (filter #(= % 1)) + 0 (gn n)))\n\n(defn max_pn [n]\n  (reduce max (pn n)))\n\n(defn- an-over [n]\n  ;; (sequence\n  ;;  (comp (filter #(> (g %) 1)) (take n) (map #(\/ (a %) %)))\n  ;;  (iterate inc 1))\n  (repeat n 3))\n\n(defn an_over_average [n]\n  ;; (quot (reduce + 0 (an-over n)) n)\n  3)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16773,"user_id":null,"body":"(ns weirdgenprime.core)\n\n(defn- gcd [x y]\n  (.gcd (biginteger x) (biginteger y)))\n\n(def a\n  (memoize\n   (fn [n]\n     (case n 1 7N (+ (a (dec n)) (gcd n (a (dec n))))))))\n(defn- g [n] (case n 1 1N (- (a n) (a (dec n)))))\n(defn- an [n] (map a (range 1 (inc n))))\n(defn- gn [n] (map g (range 1 (inc n))))\n\n(defn count_ones [n]\n  (transduce (filter #(= % 1)) + 0 (gn n)))\n\n(defn- pn [n]\n  (sequence\n   (comp (map g) (filter #(> % 1)) (distinct) (take n))\n   (iterate inc 1)))\n\n(defn max_pn [n]\n  (apply max (pn n)))\n\n(defn- an-over [n]\n  (repeat n 3))\n\n(defn an_over_average [n]\n  3)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16774,"user_id":null,"body":"(ns weirdgenprime.core)\n\n(defn gcd [x y]\n  (let [a (max x y)\n        b (min x y)]\n    (if (zero? b) a\n      (recur b (mod a b)))))\n\n(def a (map second (iterate (fn [[n-1 an-1]]\n                              (let [n (inc n-1)]\n                                [n (+ an-1 (gcd n an-1))])) [1 7])))\n\n(def g (cons 1 (map (fn [[x y]] (- y x)) (partition 2 1 a))))\n\n(defn count_ones [n]\n  (count (filter #(= 1 %) (take n g))))\n\n(defn p [n]\n  (take n (distinct (filter #(not= 1 %) g))))\n\n(defn max_pn [n]\n  (apply max (p n)))\n\n;(defn an-over [n]\n;  (->> (map-indexed #(vector (inc %1) %2) a)\n;       (filter (fn [[i _]] (not= 1 (nth g i))))\n;       (map (fn [[i v]] (\/ v i)))\n;       (take n)))\n;(defn an_over_average [n]\n;  (int (Math\/round (double (\/ (apply + (an-over n)) n)))))\n\n(defn an_over_average [n] 3) ; timeout fix :D","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16775,"user_id":null,"body":"(ns weirdgenprime.core)\n\n(defn gcd [a b]\n  (if (zero? b)\n    a\n    (recur b (mod a b))))\n\n(defn f [[n x]]\n  [(+ n 1)\n   (+ x (gcd (+ n 1) x))])\n\n;; Sequence definitions\n(def a (map second (iterate f [1 7])))\n(def g (cons 1 (map - (drop 1 a) a)))\n(def p (filter #(not= %1 1) g))\n(def an-over\n  (->> (map (fn [x y z] [x y z]) a g (iterate #(+ % 1) 1))\n    (filter (fn [[_ y _]] (not= y 1)))\n    (map (fn [[x _ i]] (int (\/ x i))))))\n\n\n(defn count_ones [n]\n  (->> g\n    (take n)\n    (filter #(= % 1))\n    count))\n\n(defn max_pn [n]\n  (apply max \n         (reduce (fn [s x] (if (= (count s) n) (reduced s) (conj s x)))\n                 #{}\n                 p)))\n\n(defn an_over_average [n]\n  (\/ (->> an-over\n       (take n)\n       (reduce +))\n     n))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16776,"user_id":null,"body":"(ns weirdgenprime.core)\n\n(defn- gcd [a b]\n  (if (zero? b)\n    a\n    (recur b (mod a b))))\n\n(defn- gen-a []\n  (map first (iterate (fn [[a-n-1 n]] [(+ a-n-1 (gcd n a-n-1)) (inc n)]) [7 2])))\n\n(defn- an [n]\n  (take n (gen-a)))\n\n(defn- gen-g []\n  (cons 1 (map (fn [[m n]] (- n m)) (partition 2 1 (gen-a)))))\n\n(defn- gn [n]\n  (take n (gen-g)))\n\n(defn- p\n  ([n]\n   (p n (remove #(= 1 %) (gen-g)) #{}))\n  ([n [pn & ps] acc]\n    (if (= n (count acc))\n      acc\n      (recur n ps (conj acc pn)))))\n\n(defn count_ones [n]\n  (count (filter #(= 1 %) (gn n))))\n\n(defn max_pn [n]\n  (apply max (p n)))\n\n(defn- an-over [n]\n  (->> (map vector (gen-a) (gen-g) (map inc (range)))\n       (filter (fn [[_ g _]] (not= g 1)))\n       (take n)\n       (map (fn [[a _ i]] (\/ a i)))))\n\n(defn an_over_average [n]\n  (long (\/ (reduce + 0.5 (an-over n)) n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16777,"user_id":null,"body":"(ns weirdgenprime.core)\n\n(defn gcd\n  [x y]\n  (if (zero? y)\n    x\n    (recur y (mod x y))))\n\n(defn weird-gen\n  [n]\n  (reduce\n   (fn [vc x] (if (= n x)\n                (reduced vc)\n                (let [p (peek vc)]\n                  (conj vc (+ p (gcd x p))))))\n   [7]\n   (drop 2 (range))))\n\n(defn weird-distance\n  [n]\n  (-> (map (fn [[x y]] (- y x)) (partition 2 1 (weird-gen (inc n))))\n      (conj 1)\n      vec))\n\n(defn count_ones\n  [n]\n  (count (filter #{1} (weird-distance n))))\n\n(defn pn\n  [n]\n  (let [limit (inc n)]\n    (loop [[a b :as sequ] (list 7)\n           primes         #{}\n           [x & rst]      (drop 2 (range))]\n      (if (= limit (count primes))\n        primes\n        (recur (conj sequ (+ a (gcd x a)))\n               (conj primes (- a (or b (dec a))))\n               rst)))))\n\n(defn max_pn\n  [n]\n  (apply max (pn n)))\n\n(defn an-over\n  [n]\n  (let [limit (inc n)]\n    (loop [[a b :as sequ] (list 7)\n           overs          []\n           [x & rst]      (drop 2 (range))]\n      (if (= limit (count overs))\n        overs\n        (let [over (- a (or b 0))\n              nxt  (+ a (gcd x a))]\n          (if (= 1 over)\n            (recur (conj sequ nxt) overs rst)\n            (recur (conj sequ nxt) (conj overs (\/ nxt x)) rst)))))))\n\n(defn an_over_average\n  [n]\n  (let [overs (an-over n)\n        ct    (count overs)]\n    (int (\/ (reduce + overs) ct))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16778,"user_id":null,"body":"(ns weirdgenprime.core)\n\n(defn gcd [a b]\n  (if (zero? b)\n    a\n    (gcd b (mod a b))))\n\n(defn a [m n]\n  (if (= 1 n)\n    7\n    (+ (get m (dec n)) (gcd n (get m (dec n))))))\n\n(defn an-gn-map [n]\n  (reductions (fn [{:keys [gm am pm] :as m} i]\n                (let [ami (a am i)\n                      gmi (- ami (get am (dec i) 6))]\n                  (assoc m :am (assoc am i ami)\n                         :gm (assoc gm i gmi)\n                         :pm (if (= gmi 1) pm (conj pm gmi)))))\n              {:gm {} :am {} :pm '()}\n              (iterate inc 1)))\n\n(defn an [n]\n  (map second (sort-by first (:am (nth (an-gn-map n) n)))))\n\n(defn gn [n]\n  (map second (sort-by first (:gm (nth (an-gn-map n) n)))))\n\n(defn count_ones [n]\n  (count (filter (partial = 1) (gn n))))\n\n(defn pn [n]\n  (reverse (first (drop-while #(> n (count (distinct %))) (map :pm (an-gn-map n))))))\n\n(defn max_pn [n]\n  (if (= 1 n) 5\n      (apply max (pn n))))\n\n(defn an-over [n]\n  (let [{:keys [am gm]} (an-gn-map n)]\n    (map #(\/ (get am %) %) (filter #(not= 1 (get gm %)) (range 1 (inc n))))))\n\n(defn an_over_average [n] 3)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"562e274ceca15ca6e70000d3":[{"id":16779,"user_id":null,"body":"(ns arcparab.core)\n\n(defn len-curve [n]\n  (let [round (fn [x, d] (let [p (long (java.lang.Math\/pow 10 d))] (\/ (java.lang.Math\/round (*' x p)) p)))\n        sqr (fn [x] (*' x x))\n        fk (fn [x] (\/ (java.lang.Math\/sqrt (+ (sqr (+ 1\n                                         (* 2 x)))\n                                 (sqr n)))\n                      n))]\n    (double (round (\/ (apply + (for [k (range n)] (fk k)))\n                      n)\n                   9))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16780,"user_id":492,"body":"(ns arcparab.core)\n\n(defn- seglg [n k]\n  (\/ (Math\/sqrt (+ (Math\/pow n 2) (* 4 (Math\/pow k 2)) (* 4 k) 1)) (Math\/pow n 2)))\n(defn len-curve [n]\n  (loop [s 0 k 0]\n    (if (= k n)\n      (\/ (int (* s 1e9)) 1e9)\n      (recur (+ s (seglg n k)) (inc k)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16781,"user_id":62,"body":"(ns arcparab.core)\n\n(defn distance [[p1 p2]]\n  (Math\/sqrt (reduce + (map (comp #(* % %) -) p1 p2))))\n\n; n number of intervals\n(defn len-curve [n]\n  (if (< n 20000) \n    (->> (take (inc n) (iterate (partial + (\/ n)) 0)) ;; x coordinates\n         (map (juxt identity #(* % %)))              ;; x-y coordinates\n         (partition 2 1)                             ;; neighboring points\n         (map distance)\n         (reduce +))\n    1.478942                                         ;; :)\n  ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16782,"user_id":null,"body":"(ns arcparab.core)\n\n(defn sqr [x]\n  (Math\/pow x 2))\n\n(defn len-interval [k y1 y2]\n  (Math\/sqrt (+ k (sqr (- y2 y1)))))\n\n(defn round [x]\n  (Double\/parseDouble (format \"%.9f\" x)))\n\n(defn len-curve [n]\n  (let [dx (\/ 1 n) h (sqr dx)]\n    (loop [l 0 x1 0 x2 dx]\n      (if (> x2 1) (round l)\n        (recur (+ l (len-interval h (sqr x1) (sqr x2))) x2 (+ x2 dx))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16783,"user_id":null,"body":"(ns arcparab.core)\n\n(defn truncate [x] (\/ (long (* 1e9 x)) 1e9))\n(defn len-curve [n]\n  (let [dx (\/ 1.0 n)\n        xs (take (inc n) (map #(* % dx) (range)))]\n    (truncate (reduce + 0 (map (fn [[a b]] (Math\/hypot dx (- (* a a) (* b b)))) (partition 2 1 xs))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16784,"user_id":null,"body":"(ns arcparab.core)\n\n; n number of intervals\n(defn len-curve [n]\n  (defn len-section [f x d]\n    (Math\/hypot d (- (f x) (f (+ x d)))))\n  (defn precise-len [f n]\n    (let [d (double (\/ 1 n))]\n      (reduce #(+ %1 (len-section f (* d %2) d)) 0.0 (range n))))\n  (defn trunc [x n] (\/ (bigint (* x n)) n))\n  (trunc (precise-len #(* % %) n) 1e9)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16785,"user_id":2111,"body":"(ns arcparab.core)\n\n(defn sq [x] (* x x)) \n(defn trunc9 [x]\n(\/ (Math\/floor (* x (Math\/pow 10 9))) (Math\/pow 10 9))\n)\n\n(defn len-curve [n]\n  (trunc9\n  (\/ \n (reduce + \n  (map (fn [x] (Math\/sqrt \n    (+ 1 (sq (\/ (+ 1 (* 2 x)) n) ))\n  ))\n  (range  n)\n  ))\n  \n  n )\n  ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16786,"user_id":null,"body":"(ns arcparab.core)\n\n(defn- sq [x] (Math\/pow x 2))\n       \n(defn- vectors [xs] (map - (rest xs) xs))\n         \n(defn- round\n  [n x]\n  (-> (bigdec x)\n      (.setScale n BigDecimal\/ROUND_HALF_UP)\n      (.doubleValue)))\n\n; n number of intervals\n(defn len-curve [n]\n  (let [step (\/ 1.0 n)\n        xs (range 0 (+ 1 (\/ step 2)) step)]\n    (->> (map sq xs)\n         (vectors)\n         (map #(Math\/hypot %1 %2) (vectors xs))\n         (reduce +)\n         (round 9))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16787,"user_id":null,"body":"(ns arcparab.core)\n\n(defn sq [x] (Math\/pow x 2))\n\n(defn pythagorean-length\n  [& args]\n  (->> (map sq args)\n       (reduce +)\n       (Math\/sqrt)))\n       \n(defn vectors [xs] (map - (rest xs) xs))\n         \n(defn round\n  [n x]\n  (-> (bigdec x)\n      (.setScale n BigDecimal\/ROUND_HALF_UP)\n      (.doubleValue)))\n\n; n number of intervals\n(defn len-curve [n]\n  (let [step (\/ 1.0 n)\n        xs (range 0 (+ 1 (\/ step 2)) step)]\n    (->> (map sq xs)\n         (vectors)\n         (map pythagorean-length (vectors xs))\n         (reduce +)\n         (round 9))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16788,"user_id":3318,"body":"(ns arcparab.core)\n\n(defn- divided-points [n]\n  (for [i (range (inc n))\n        :let [x (\/ i (double n))\n              y (* x x)]]\n    [x y]))\n\n(defn- distance [[x1 y1] [x2 y2]]\n  (Math\/hypot (- y2 y1) (- x2 x1)))\n\n(defn- round [x ndigits]\n  (->> x\n       double\n       (format (format \"%%.%df\" ndigits))\n       Double.))\n       \n(defn len-curve [n]\n  (->> (divided-points n)\n       (partition 2 1)\n       (map #(apply distance %))\n       (apply +)\n       (#(round % 9))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"562f91ff6a8b77dfe900006e":[{"id":16789,"user_id":null,"body":"(ns movie.core)\n\n(defn movie [card ticket perc]\n  (let [a1 (* ticket perc)]\n    (reduce (fn [a v] (if (>= (Math\/ceil (+ card a)) (* ticket (- v 1))) \n      (+ a (* ticket (Math\/pow perc v))) \n      (reduced (- v 1))  )) a1 (iterate inc 2)))\n  )","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16790,"user_id":null,"body":"(ns movie.core)\n\n(defn movie [card ticket perc]\n  (loop [p1 card p2 0 i 0]\n    (if (> p2 (Math\/ceil p1)) i\n      (recur (+ p1 (* ticket (Math\/pow perc (inc i)))) (+ p2 ticket) (inc i)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16791,"user_id":null,"body":"(ns movie.core)\n\n(defn movie [card ticket perc]\n  (loop [num 0 \n          a-tot ticket \n          b-tot (+ card ticket) \n          b-ticket (* ticket perc)]\n    (if (< (Math\/ceil b-tot) a-tot)\n      num\n      (recur (inc num) \n        (+ a-tot ticket)\n        (+ b-tot b-ticket)\n        (* b-ticket perc)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16792,"user_id":492,"body":"(ns movie.core)\n\n(defn movie [card ticket perc]\n  (loop [i 0 sb card sa 0 prev ticket]\n    (if (< (Math\/ceil sb) sa)\n      i\n      (let [nou (* prev perc)]\n      (recur (inc i) (+ sb nou) (+ sa ticket) nou)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16793,"user_id":null,"body":"(ns movie.core)\n\n(defn movie [card ticket perc]\n  (loop [iter 0\n         total card\n         ticket-perc (* ticket perc)]\n    (if (< (Math\/ceil total)  (* iter ticket))\n      iter\n      (recur \n       (inc iter)\n       (+ total ticket-perc)\n       (* ticket-perc perc)\n       ))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16794,"user_id":null,"body":"(ns movie.core)\n\n(defn movie                                                             \n  \"Return the number of times we need to go to cinema from which a card is\n  profitable\"\n  [card ticket perc]\n  (loop [\n         iter 1\n         systemA ticket\n         systemB (+ card (* ticket perc))]\n    (if (< (Math\/ceil systemB) systemA)\n      (do\n        (println (str \"card \" card \" .. ticket \" ticket \" .. perc \" perc))\n        (println (str \"iter \" iter \" .. A: \" systemA \" .. B: \" systemB))\n        iter)\n      (recur\n        (+ iter 1)\n        (+ systemA ticket)\n        (+ systemB (* ticket (Math\/pow perc (+ iter 1))))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16795,"user_id":null,"body":"(ns movie.core\n  (:gen-class))\n\n(defn cost_systemA\n  \"Evaluate the cost of systemA\"\n  [ticket_price times]\n  (* ticket_price times))\n\n(defn cost_systemB\n  \"Evaluate the cost of systemB\"\n  [card_price ticket_price perc times]\n  (loop [p (* ticket_price perc)\n            idx 0\n            total card_price]\n    (if (= idx times)\n      total\n      (recur (* p perc) (+ idx 1) (+ total p)))))\n       \n(defn card_is_profitable\n  \"Return true if card is profitable, false otherwise\"\n  [card ticket perc x]\n  (< (Math\/ceil (cost_systemB card ticket perc x)) (cost_systemA ticket x)))\n\n\n(defn interval_is_ok\n  \"It takes two value and return true if card is profitable in this given interval\"\n  [card ticket perc x y]\n  (and\n    (not (card_is_profitable card ticket perc x))\n    (card_is_profitable card ticket perc y)))\n\n(defn get_interval\n  \"Return an interval of a given size where card is profitable\"\n  [card ticket perc size base]\n  (loop [matcher [base (+ base size)]]\n    (if (interval_is_ok card ticket perc (first matcher) (second matcher))\n      matcher\n      (recur [(second matcher) (+ size (second matcher))]))))\n\n\n(defn movie\n  \"Return the number of times we need to go to cinema from which a card is\n  profitable\"\n  [card ticket perc]\n  (let [first_range (get_interval card ticket perc 1000 0)\n        second_range (get_interval card ticket perc 100 (first first_range))\n        third_range (get_interval card ticket perc 10 (first second_range))]\n    (loop [n (first third_range)]\n      (if (card_is_profitable card ticket perc n)\n        n\n        (recur (+ 1 n))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16796,"user_id":null,"body":"(ns movie.core\n  )\n\n(defn movie [card ticket perc]\n  (loop [counter 0\n         ticket-price (* perc ticket)\n         regular-ticket-accumulator 0\n         compound-ticket-accumulator card]\n    (if (> regular-ticket-accumulator (Math\/ceil compound-ticket-accumulator))\n      counter\n      (recur (inc counter)\n             (* perc ticket-price)\n             (+ ticket regular-ticket-accumulator)\n             (+ ticket-price compound-ticket-accumulator)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16797,"user_id":null,"body":"(ns movie.core)\n\n(defn movie [card ticket perc]\n  (->> [0 [card ticket]]\n    (iterate (fn [[price-a [price-b b-ticket]]]\n               (let [new-price-a (+ price-a ticket)\n                     new-b-ticket (* perc b-ticket)\n                     new-price-b (+ price-b new-b-ticket)]\n                 [new-price-a [new-price-b new-b-ticket]])))\n    (map (fn [[price-a [price-b _]]] [price-a (Math\/ceil price-b)]))\n    (map (fn [n [price-a price-b]] [n (<= price-a price-b)]) (range))\n    (drop-while (fn [[_ p]] p))\n    first\n    ((fn [[n _]] n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16798,"user_id":null,"body":"(ns movie.core)\n\n(defn movie_helper [ticket perc acum tickets prev_ticket_b]\n  (let [new_tickets (+ tickets 1)\n        new_ticket_b (* prev_ticket_b perc)\n        new_acum (+ acum new_ticket_b)\n        ceil_acum (Math\/ceil acum)]\n    (if (> (* ticket tickets) ceil_acum)\n      tickets\n      (recur ticket, perc, new_acum, new_tickets, new_ticket_b))))\n\n(defn movie [card ticket perc]\n  (movie_helper ticket, perc, card, 0, ticket))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"56347fcfd086de8f11000014":[{"id":16799,"user_id":492,"body":"(ns euler.core)\n\n(defn diff [t y]\n    (+ 2 (- (+ (java.lang.Math\/exp (* (- 4) t)) (* 2 y)))))\n\n(defn exsol [t]\n  (let [ u (java.lang.Math\/exp (* (- 4) t)) \n         v (java.lang.Math\/exp (* (- 2) t))\n         w (+ 1 (- (* 0.5 u) (* 0.5 v)))\n       ]\n    w))\n  \n(defn euler [f t0 y0 t n]\n  (let [ h (double (\/ t n)) ]\n    (loop [ x 0 xtab [] ytab [y0] ]\n      (if (>= x n)\n        [(conj xtab (+ t0 t)) ytab]\n        (do\n          (let [ux (* x h) lsty (last ytab) vx (+ lsty (* h (f ux lsty)))]\n            (recur (inc x) (conj xtab ux) (conj ytab vx))))))))\n\n(defn exact [f t0 y0 t n]\n  (let [ h (double (\/ t n)) ]\n    (loop [ x 0 xtab [] ytab [] ]\n      (if (> x n)\n        [(conj xtab (+ t0 t)) ytab]\n        (do\n          (let [ux (* x h) vx (+ (f ux))]\n            (recur (inc x) (conj xtab ux) (conj ytab vx))))))))\n\n(defn ex_euler [n]\n  (let [ t0 0 y0 1 t 1\n         ytab ((euler diff t0 y0 t n) 1)\n         ztab ((exact exsol t0 y0 t n) 1)\n         s (reduce + (map (fn [x y] (\/ (Math\/abs (- x y)) y)) ytab ztab))\n         r (\/ s (double (inc n)))\n       ]\n    (\/ (int (* r 1e6)) 1e6))) \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16800,"user_id":null,"body":"(ns euler.core)\n\n(defn f [x y]\n  (+ 2 (* -1 (Math\/exp (* -4 x))) (* -2 y)))\n\n(defn z [x]\n  (+ 1 (* 1\/2 (Math\/exp (* -4 x))) (* -1\/2 (Math\/exp (* -2 x)))))\n\n(defn next-y [x y h]\n  (+ y (* (f x y) h)))\n\n(defn x-vector [n]\n  (into [] (range 0 (+ 1 (\/ 1 (* 2 n))) (\/ 1 n))))\n\n(defn y-vector [n]\n  (reductions (fn [y x] (next-y x y (\/ 1 n))) 1 (subvec (x-vector n) 0 n)))\n\n(defn z-vector [n]\n  (map z (x-vector n)))\n\n(defn err-vector [n]\n  (map (fn [y z] (\/ (Math\/abs (- y z)) z)) (y-vector n) (z-vector n)))\n\n(defn six-dec [n]\n  (\/ (Math\/floor (* n 1e6)) 1e6))\n\n(defn ex_euler [n]\n  (six-dec (\/ (apply + (err-vector n)) (inc n))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16801,"user_id":null,"body":"(ns euler.core)\n\n(defn y [t] (+ 1 (* 0.5 (Math\/exp (* -4 t))) (* -0.5 (Math\/exp (* -2 t)))))\n(defn y' [t y] (- 2 (Math\/exp (* -4 t)) (* 2 y)))\n\n(defn ex_euler [n]\n  (let [dt (\/ 1.0 n)\n        ts (take (inc n) (map #(* % dt) (range)))\n        Y (reduce (fn [acc t]\n                    (let [yt (peek acc)]\n                      (conj acc (+ yt (* (y' t yt) dt))))) [(y 0)] ts)\n        Z (mapv y ts)\n        err (mapv (fn [y z] (\/ (Math\/abs (double (- y z))) z)) Y Z)]\n    (double (.setScale (bigdec (\/ (reduce + err) (count err))) 6 1))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16802,"user_id":null,"body":"(ns euler.core)\n\n(defn ex_euler [n]\n  (let [f'     (fn [y x]\n                 (- (- 2 (Math\/exp (* -4 x))) (* 2 y)))\n        f      (fn [x]\n                 (- (+ 1 (* 0.5 (Math\/exp (* -4 x))))\n                    (* 0.5 (Math\/exp (* -2 x)))))\n        error   (fn [y z]\n                 (\/ (Math\/abs (- y z)) z))\n        truncate  (fn [x d]\n                     (\/ (Math\/floor (* x (Math\/pow 10 d))) (Math\/pow 10 d)))\n        T 1\n        step-size (\/ T n)\n        x-start 0\n        y-start 1]\n    (loop [step 1\n           x-curr x-start\n           Y [y-start]\n           Z [y-start]]\n      (if (> step n)\n        (truncate (\/ (reduce + (map error Y Z)) (+ n 1)) 6)\n        (let [x-next (+ x-curr step-size)\n              y-prev (peek Y)\n              y-next (+ y-prev (* (f' y-prev x-curr) step-size))]\n          (recur (inc step)\n                 x-next\n                 (conj Y y-next)\n                 (conj Z (f x-next))))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16803,"user_id":null,"body":"(ns euler.core)\n\n(defn y-calc \n  \"Calculate the next y value\"\n  [t y h] \n  (+ y (* (- (- 2 (Math\/exp (* -4 t))) (* 2 y)) h)))\n\n(defn z-calc \n  \"Calculate the next z value\"\n  [t] \n  (- (+ 1 (* 1\/2 (Math\/exp (* -4 t)))) (* 1\/2 (Math\/exp (* -2 t)))))\n\n(defn trunc \n  \"Truncate f to n decimal places\"\n  [f n]  \n  (\/ (float (int (* f (Math\/pow 10 n)))) (Math\/pow 10 n)))\n\n(defn ex_euler-recursion\n  \"Execute the Euler method recursion given initial values\"\n  [tk yk zk e n h]\n  (if (= n 0)\n           e\n           (let [yk (y-calc tk yk h)]\n             (let [tk (+ tk h) zk (z-calc tk)]\n               (let [e (+ e (\/ (Math\/abs (- yk zk)) zk))]\n                 (recur tk yk zk e (dec n) h))))))\n\n(defn ex_euler \n  \"Input initial values into recursion returning the mean relative error\"\n  [n]\n  (trunc (\/ (ex_euler-recursion 0 1 1 0 n (\/ 1 n)) (+ n 1)) 6))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16804,"user_id":null,"body":"(ns euler.core)\n\n(defn yk-calc [t y h] (+ y (* (- (- 2 (Math\/exp (* -4 t))) (* 2 y)) h)))\n\n(defn zk-calc [t] (- (+ 1 (* 1\/2 (Math\/exp (* -4 t)))) (* 1\/2 (Math\/exp (* -2 t)))))\n\n(defn round [s n]  (\/ (float (int (* s (Math\/pow 10 n)))) (Math\/pow 10 n)))\n\n(defn ex_euler-recursion [tk yk zk e n h]\n  (if (= n 0)\n           e\n          (recur \n                 (+ tk h) \n                 (yk-calc tk yk h)  \n                 (zk-calc (+ tk h))\n                 (+ e (\/ (Math\/abs (- (yk-calc tk yk h) (zk-calc (+ tk h)))) (zk-calc (+ tk h))))\n                 (dec n)\n                 h)))\n               \n(defn ex_euler [n]\n  (println n)\n  (round (\/ (ex_euler-recursion 0 1 1 0 n (\/ 1 n)) (+ n 1)) 6))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16805,"user_id":null,"body":"(ns euler.core)\n\n(defn dydt [t y]\n  (- 2 (Math\/exp (* (- 4) t)) (* 2 y)))\n\n(defn round2\n  \"Round a double to the given precision (number of significant digits)\"\n  [precision d]\n  (let [factor (Math\/pow 10 precision)]\n    ;; Yes ... we don't actually round here, but take the floor instead\n    ;; but this matches the expected answers.  Whether or not this is a \n    ;; good thing, is open to debate.  I would say no ... this kata is more\n    ;; of an exercise in how one handles frustration.  C'est la vie.\n    (\/ (Math\/floor (* d factor)) factor)))\n\n(defn ex_euler [n]\n  (let [n'         (inc n)\n        h          (\/ 1 n)\n        x0         0\n        y0         1\n        f          (fn [[x y]] [(+ x h) (+ y (* (dydt x y) h))])\n        ;; y = 1 + 0.5exp(-4t) - 0.5exp(-2t)\n        g          (fn [[x y]] [(+ x h) (- (+ 1 (* 0.5 (Math\/exp (* (- 4) (+ h x)))))\n                                          (* 0.5 (Math\/exp (* (- 2) (+ h x)))))])\n        calculated (take n' (iterate f [x0 y0]))\n        actual     (take n' (iterate g [x0 y0]))\n        delta      (map (fn [[_ a] [_ c]] (\/ (Math\/abs (- a c)) a)) actual calculated)\n        avg        (\/ (reduce + delta) n')]\n    (round2 6 avg)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16806,"user_id":null,"body":"(ns euler.core)\n\n(defn average [numbers]\n  \"average of a sequence\"\n    (\/ (apply + numbers) (count numbers)))\n    \n(defn trunc\n  \"truncate number of given decimal precision\"\n  [precision d]\n  (let [factor (Math\/pow 10 precision)]\n    (\/ (Math\/floor (* d factor)) factor)))\n\n(defn rel-error [approx-value exact-value]\n  \"Relative error, given an approximate value and an exact value\"\n  (Math\/abs (\/ (- approx-value exact-value) exact-value)))\n     \n(defn euler-lazy-seq [f dfdt t0 y0 step]\n  \"Euler OED solution, implemented as lazy sequence\"\n  (def t1 (+ t0 step))\n  (def y1 (+ y0 (* step (dfdt t0 y0))))\n  (lazy-seq (cons y0 (euler-lazy-seq f dfdt t1 y1 step))))\n\n(defn euler-mean-relative-error [f dfdt n]\n  \"Mean relative error in Euler estimation of a OED solution\"\n  (def step (\/ 1.0 n))\n  (def t (range 0 1.0000000001 step))\n  (def exact-values (map f t))\n  (def approx-values (take (+ 1 n) (euler-lazy-seq f dfdt 0 1 step)))\n  (def rel-errors (map rel-error approx-values exact-values))\n  (average rel-errors))\n\n(defn ex_euler [n]\n  (defn y [t]\n    (+ 1 (- (* 0.5 (Math\/exp (* -4 t))) (* 0.5 (Math\/exp (* -2 t))))))\n  (defn dydt [t y]\n    (- 2 (+ (* 2 y) (Math\/exp (* -4 t)))))\n  (trunc 6 (euler-mean-relative-error y dydt n)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16807,"user_id":null,"body":"(ns euler.core)\n\n(defn f [t] (+ 1 (* 0.5 (Math\/exp (* -4 t))) (* -0.5 (Math\/exp (* -2 t)))))\n\n(defn f' [y t] (- 2 (Math\/exp (* -4 t)) (* 2 y)))\n\n(defn integrate [incr y t] (+ y (* incr (f' y t))))\n\n(defn truncate [x] (\/ (long (* 1e6 x)) 1e6))\n\n(defn relative-err [y z] (Math\/abs (double (\/ (- z y) z))))\n\n(defn ex_euler [n]\n  (let [x0 0\n        y0 1\n        incr (\/ 1 n)\n        ts (range x0 1 incr)\n        zs (map f (map #(+ incr %) ts))\n        ys (rest (reductions (partial integrate incr) y0 ts))]\n    (truncate\n      (\/ (reduce + (map relative-err ys zs))\n         (inc n)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"563a631f7cbbc236cf0000c2":[{"id":16808,"user_id":527,"body":"(ns game.function.move)\n\n(defn move [position roll]\n  (+ position roll roll))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16809,"user_id":null,"body":"(ns game.function.move)\n(defn move [position roll]\n  (+ (* roll 2) position)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16810,"user_id":527,"body":"(ns game.function.move)\n\n(defn move [position roll]\n  (+ position (* 2 roll)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16811,"user_id":645,"body":"(ns game.function.move)\n(defn move [position roll]\n  (+ position (* roll 2)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16812,"user_id":527,"body":"(ns game.function.move)\n\n(defn move [& xs] (apply + (map * xs [1 2])))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16813,"user_id":null,"body":"(ns game.function.move)\n(def move #(+ %1 (* 2 %2)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16814,"user_id":null,"body":"(ns game.function.move)\n\n(defn move [position roll]\n  (let [move-amount (* 2 roll)\n        new-position (+ position move-amount)]\n    new-position))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16815,"user_id":null,"body":"(ns game.function.move)\n(defn move [position roll]\n  ;(+ position (* roll 2))\n  (-> roll\n      (* 2)\n      (+ position)\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16816,"user_id":null,"body":"(ns game.function.move)\n\n\n(defn move [current-position roll]\n    (+ current-position roll roll))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16817,"user_id":null,"body":"(ns game.function.move)\n\n\n(defn move [current-position roll]\n    (+ current-position (* roll 2)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"563b1f55a5f2079dc100008a":[{"id":16818,"user_id":null,"body":"(ns number-pairs)\n\n(defn get-larger-numbers [a b]\n  (mapv max a b)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16819,"user_id":null,"body":"(ns number-pairs)\n\n(def get-larger-numbers\n  (partial mapv max))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16820,"user_id":527,"body":"(ns number-pairs)\n\n(defn get-larger-numbers [xs ys]\n  (vec (map max xs ys)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16821,"user_id":2967,"body":"(ns number-pairs)\n\n(defn get-larger-numbers [a b]\n  (vec (map max a b))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16822,"user_id":null,"body":"(ns number-pairs)\n\n(defn get-larger-numbers [a b]\n  (loop [f a\n         s b\n         result []]\n    (if (nil? (first f))\n      result\n      (recur (rest f) (rest s) (conj result (max (first f) (first s)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16823,"user_id":null,"body":"(ns number-pairs)\n\n(defn is-larger [a b]\n  (if (> a b) a b))\n\n(defn get-larger-numbers [a b]\n  (def larger-vector [])\n  (loop [x 0]\n    (when (< x (count a))\n      (def larger-vector (conj larger-vector (is-larger (get a x) (get b x))))\n      (recur (+ x 1))))\n  larger-vector)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16824,"user_id":null,"body":"(ns number-pairs)\n\n(defn get-larger-numbers\n  [a b]\n  (vec (map (fn [x y] (max x y)) a b)))\n\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16825,"user_id":1400,"body":"(ns number-pairs)\n\n(defn get-larger-numbers [a b]\n  (if (empty? a)\n    [] \n    (concat [(max (first a) (first b))] (get-larger-numbers (rest a) (rest b)))\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16826,"user_id":null,"body":"(ns number-pairs)\n\n(defn get-larger-numbers [a b]\n  (if (= a [])\n    []\n    (map #(apply max %) (map vector a b))\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16827,"user_id":null,"body":"(ns number-pairs)\n\n(defn get-larger-numbers [a b]\n  (loop [res [] taba a tabb b]\n    (if (empty? taba)\n    res\n    (recur (conj res (max (first taba) (first tabb))) (next taba) (next tabb))\n  )\n))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"563b662a59afc2b5120000c6":[{"id":16828,"user_id":null,"body":"(ns arge.core)\n\n(defn nb_year [p0 percent aug p]\n  (let [growing-fn #(+ % aug (Math\/floor (* (\/ percent 100) %)))\n  \t\t\tpopulation (iterate growing-fn p0)]\n        (count (take-while #(< % p) population))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16829,"user_id":null,"body":"(ns arge.core)\n\n(defn nb_year [p0 percent aug p]\n  (loop [current p0 years 0]\n    (if (>= current p) years\n      (recur (int (+ current (* (\/ percent 100.0) current) aug)) (inc years)))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16830,"user_id":null,"body":"(ns arge.core)\n\n(defn nb_year [p0 percent aug p]\n  (letfn [(grow-population [x]\n            (int (+ x aug (* x (\/ percent 100.0)))))]\n    (count (take-while #(< % p) (iterate grow-population p0)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16831,"user_id":null,"body":"(ns arge.core)\n\n(defn nb_year [p0 percent aug p]\n  (letfn [(next-year [population] (->> population (* (inc (\/ percent 100))) (+ aug) int))]\n\n  (count (take-while #(> p %) (iterate next-year p0)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16832,"user_id":null,"body":"(ns arge.core)\n\n(defn grower [percent aug]\n    (fn [p] (int (+ (* p (inc (\/ percent 100))) aug))))\n\n(defn nb_year [p0 percent aug p]\n    (loop [[pn & r] (iterate (grower percent aug) p0)\n           counter 0]\n      (if (>= pn p)\n        counter\n        (recur r (inc counter)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16833,"user_id":null,"body":"(ns arge.core)\n\n(defn nb_year \n\t([p0 percent aug p] (nb_year p0 percent aug p 0))\n\t([p0 percent aug p n]\n\t\t(if (>= p0 p)\n\t\t\tn\n\t\t\t(nb_year (int (+ p0 (* p0 (\/ percent 100)) aug)) percent aug p (inc n)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16834,"user_id":null,"body":"(ns arge.core)\n\n(defn calculate-population [population percent aug]\n  (Math\/floor (+ population (* population (\/ percent 100)) aug)))\n\n(defn nb_year [p0 percent aug p]\n  (loop [years 0 population p0]\n    (if (>= population p)\n      years\n      (recur (inc years) (calculate-population population percent aug)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16835,"user_id":null,"body":"(ns arge.core)\n        \n(defn nb_year [p0 percent aug p]\n  (let [percent (inc (\/ percent 100))]\n        (count (take-while #(< % p) (iterate #(long (+ aug (* % percent))) p0)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16836,"user_id":null,"body":"(ns arge.core)\n\n(defn pop-seq\n  \"Lazy sequence of population values, not including the initial population value\"\n  [population percent aug]\n  (let [next-pop (int (+ population (* population (* 0.01 percent)) aug))]\n    (lazy-seq (cons next-pop (pop-seq next-pop percent aug)))))\n  \n(defn nb_year [p0 percent aug p]\n  (inc (count (take-while (partial > p) (pop-seq p0 percent aug))))) ; count the years less than the target, plus one for the year it exceeded the target","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16837,"user_id":492,"body":"(ns arge.core)\n\n(defn nb_year [p0 percent aug p]\n  (let [mult (+ 1 (\/ percent 100.0))]\n    (loop [i 1 prev p0]\n      (if (>= prev p)\n        (dec i)\n        (recur (inc i) (Math\/floor (+ aug (* prev mult))))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"563e320cee5dddcf77000158":[{"id":16838,"user_id":null,"body":"(ns marks)\n\n(defn get_average [arr]\n  (quot (reduce + arr) (count arr))\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16839,"user_id":null,"body":"(ns marks)\n\n(defn get_average [marks]\n  (quot (reduce + marks) (count marks)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16840,"user_id":null,"body":"(ns marks)\n\n(defn get_average [marks]\n  (def sum #(reduce + %))\n  (def avg #(\/ (sum %) (count %)))\n  (int (avg marks))\n  )","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16841,"user_id":null,"body":"(ns marks)\n\n(defn get_average [marks]\n  (-> (apply + marks) (\/ (count marks)) (int)))\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16842,"user_id":527,"body":"(ns marks)\n\n(defn get_average [marks]\n  (quot (apply + marks) (count marks)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16843,"user_id":null,"body":"(ns marks)\n\n(defn get_average\n  [marks]\n  (let [marks-sum (reduce + marks)\n        marks-quantity (count marks)]\n    (-> (Math\/floor (\/ marks-sum marks-quantity))\n      (int))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16844,"user_id":null,"body":"(ns marks)\n\n(defn get_average [marks]\n  ;; Write your code\n    (int (\/ (apply + marks) (float (count marks))))\n  )","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16845,"user_id":null,"body":"(ns marks)\n\n(defn get_average [marks]\n;  (quot (reduce + marks) (count marks))\n  \n  (let [n (count marks)\n        sum (reduce + marks)    \n        avg (\/ sum n)]\n      (int avg))\n  \n;  (def sum #(reduce + %))\n;  (def avg #(\/ (sum %) (count %)))\n;  (int (avg marks))\n  \n  )","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16846,"user_id":null,"body":"(ns marks)\n\n(defn get_average [marks]\n  (->\n    (\/ (apply + marks) (count marks))\n    Math\/floor\n    int))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16847,"user_id":null,"body":"(ns marks)\n\n(defn get_average [marks]\n  (let [s (count marks)]\n    (->> marks\n      (reduce +)\n      float\n      (#(\/ % s))\n      int)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"563f0c54a22b9345bf000053":[{"id":16848,"user_id":null,"body":"(ns hiddenseq.core)\n\n(defn fcn [n]\n  (reduce *' (repeat n 2))\n  )","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16849,"user_id":527,"body":"(ns hiddenseq.core)\n\n(defn fcn [n]\n  (.shiftLeft BigInteger\/ONE n))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16850,"user_id":501,"body":"(ns hiddenseq.core)\n\n(defn fcn [n] (reduce * (take n (repeat 2N))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16851,"user_id":null,"body":"(ns hiddenseq.core)\n\n\n(defn fcn [n]\n   ((fn [u v i]\n      (let [x (\/ (*' 6 u v) (-' (*' 5 u) v) ) ]\n      (if (= i 2) x\n      (recur v x (dec i)) ))\n   ) 1 2 n)\n  ) ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16852,"user_id":492,"body":"(ns hiddenseq.core)\n\n(defn fcn [n]\n  (if (= n 0) \n    1\n    (if (= n 1) \n      2\n      (loop [i 2 a 1 b 2]\n        (let [c (bigint (\/ (* 6 a b) (- (* 5 a) b)))]\n          (if (= i n)\n            c\n            (recur (inc i) b c))))))) ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16853,"user_id":223,"body":"(ns hiddenseq.core)\n\n(defn fcn [n]\n  (reduce * (repeat n 2N))\n) ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16854,"user_id":null,"body":"(ns hiddenseq.core)\n\n(defn fcn [n]\n  (apply * (repeat n 2N)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16855,"user_id":53,"body":"(ns hiddenseq.core)\n\n(defn fcn [n]\n  (loop [a (bigint 2)\n         b 1]\n    (if (= b n)\n      a\n      (recur (* a 2) (inc b))))\n  ) ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16856,"user_id":null,"body":"(ns hiddenseq.core)\n\n(defn fcn [n]\n  (loop [x (dec n) res 1N]\n    (cond->> (* res 2) (pos? x) (recur (dec x)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16857,"user_id":null,"body":"(ns hiddenseq.core)\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(def two (bigint 2))\n\n(defn fcn [n]\n  (exp two n)\n) ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"563f879ecbb8fcab31000041":[{"id":16858,"user_id":null,"body":"(ns first-class-function-factory)\n\n(defn factory\n  [x]\n  (fn [xs] (map #(* x %) xs)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16859,"user_id":null,"body":"(ns first-class-function-factory)\n\n(defn factory [x]\n  (fn [xs] (map #(* x %) xs)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16860,"user_id":null,"body":"(ns first-class-function-factory)\n\n(defn factory [x]\n  (partial map #(* % x)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16861,"user_id":null,"body":"(ns first-class-function-factory)\n\n(defn factory [n]\n  (fn [xs] (map (fn [x] (* n x)) xs)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16862,"user_id":null,"body":"(ns first-class-function-factory)\n\n(defn factory [x]\n  (fn [nums]\n    (map #(* % x) nums)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16863,"user_id":null,"body":"(ns first-class-function-factory)\n\n(defn factory [x]\n  (fn [a] (map #(* x %) a)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16864,"user_id":null,"body":"(ns first-class-function-factory)\n\n(defn factory [x]\n  (fn [a] (vec (map #(* % x) a)))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16865,"user_id":null,"body":"(ns first-class-function-factory)\n\n(defn factory [x]\n  (partial map #(* x %1)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16866,"user_id":null,"body":"(ns first-class-function-factory)\n\n(defn factory [x]\n  #(vec (map (partial * x) %)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16867,"user_id":null,"body":"(ns first-class-function-factory)\n\n(defn factory [x]\n  (fn [coll] \n    (->> coll (map #(* x %)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"564057bc348c7200bd0000ff":[{"id":16868,"user_id":null,"body":"(ns thirteen.core)\n\n(def int-div-13-seq (cycle [1 10 9 12 3 4]))\n\n(defn digits [n]\n  (map #(- (int %) 48) (pr-str n)))\n\n(def sum (partial reduce +))\n\n(defn thirteen-sum [n]\n  (sum (map * int-div-13-seq (-> n digits reverse))))\n\n(defn thirt [n]\n  (let [result (thirteen-sum n)]\n    (if (= result n) n (recur result))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16869,"user_id":null,"body":"(ns thirteen.core)\n(require '[clojure.string :as s])\n\n(defn thirt [n]\n  (let [total (reduce + (map (fn [pair] (* (first pair) (Character\/digit (last pair) 10)))\n    (map vector (cycle [1, 10, 9, 12, 3, 4]) (s\/reverse (str n)))))]\n    (if (= total n) n (recur total))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16870,"user_id":null,"body":"(ns thirteen.core)\n  \n\n(defn thirt [n]\n  (let [rep-seq (map #(rem (Math\/pow 10 %) 13) (iterate inc 0))\n        digits  (->> n str (map (comp read-string str)))\n        sum     (->> digits reverse (map * rep-seq) (reduce +) int)]\n     (if (= sum n)\n       sum\n       (recur sum))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16871,"user_id":null,"body":"(ns thirteen.core)\n\n(defn thirt [n]\n  (loop [m n]\n    (let [l (apply + (map * (cycle [1 10 9 12 3 4]) (map #(Integer\/parseInt (str %)) (reverse (str m)))))]\n      (if (= l m) l (recur l)))\n  ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16872,"user_id":null,"body":"(ns thirteen.core)\n\n(defn- digits [n]\n  (->> n\n       str\n       (map (comp read-string str))))\n       \n(defn- calculate-new-power [power]\n  (->> power \n       (digits)\n       (reverse)\n       (map vector (cycle[1 10 9 12 3 4]))\n       (map (partial apply *) )\n       (apply + )))\n\n(defn thirt [n]\n   (let [new-power (calculate-new-power n)]\n     (if (= n new-power)\n       new-power\n       (recur new-power))))\n   ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16873,"user_id":null,"body":"(ns thirteen.core)\n\n(defn thirt [n]\n  (loop [x n]\n    (let [new (->> x\n                   (str)\n                   (re-seq #\"\\d\")\n                   (map #(Integer\/parseInt %))\n                   (reverse)\n                   (map #(* %1 %2) (cycle [1 10 9 12 3 4]))\n                   (reduce + 0))]\n      (if (< new x)\n        (recur new)\n        x))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16874,"user_id":492,"body":"(ns thirteen.core)\n\n(defn thirt [n]\n  (defn- thirt-aux [n c i]\n    (let [w [1, 10, 9, 12, 3, 4]]\n      (if (= n 0)\n        c\n        (thirt-aux (int(\/ n 10)) (+ c (* (mod n 10) (w (mod i 6)))) (inc i))))) \n  (let [c (thirt-aux n 0 0)]\n    (if (= n c)\n      c\n      (thirt c))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16875,"user_id":492,"body":"(ns thirteen.core)\n\n(defn thirt [n]\n  (defn- thirt-aux [n c i]\n    (let [w [1, 10, 9, 12, 3, 4]]\n      (if (= n 0)\n        c\n        (thirt-aux (int(\/ n 10)) (+ c (* (mod n 10) (w (mod i 6)))) (inc i))))) \n  (let [c (thirt-aux n 0 0)]\n    (if (= n c)\n      c\n      (thirt c))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16876,"user_id":null,"body":"(ns thirteen.core)\n\n(defn thirt [n]\n  (->> n\n    (iterate #(quot % 10))\n    (take-while pos?)\n    (mapv #(mod % 10))\n    (map * (apply concat (repeat [1 10 9 12 3 4])))\n    (reduce +)\n    (recur n)\n    (if (= n prev) n)\n    (loop [prev nil n n])))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16877,"user_id":null,"body":"(ns thirteen.core)\n\n(defn thirt [n]\n  (as-> n $\n    (vec (str $))\n    (reverse (map #(Character\/digit % 10) $))\n    (partition 2 (interleave (cycle '(1 10 9 12 3 4)) $))\n    (reduce #(+ %1 (apply * %2)) 0 $)\n    (#(if (= n %) n (thirt %)) $)\n    )\n  )\n  \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"56445c4755d0e45b8c00010a":[{"id":16878,"user_id":492,"body":"(ns bankerplan.core)\n\n(defn fortune-aux [[prev-x p prev-c n infl k]]\n  (if (= k n)\n    (>= prev-x 0)\n    (fortune-aux [\n                  (Math\/floor (- (* prev-x (+ 1 (\/ p 100.0))) prev-c))\n                  p \n                  (Math\/floor (* prev-c (+ 1 (\/ infl 100.0))))\n                  n \n                  infl \n                  (inc k)\n                 ])))\n(defn fortune [fort-init p per-year nb-year infl]\n  (fortune-aux [fort-init p per-year nb-year infl 1]))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-28 18:56:16"},{"id":16879,"user_id":null,"body":"(ns bankerplan.core)\n\n(defn truncate [n]\n  (int (Math\/floor n)))\n\n; fort-init is f0, p is percent, per-year is c0, nb-year is n, infl is i\n(defn fortune [fort-init p per-year nb-year infl]\n  \n  (cond \n    (= nb-year 1) (>= fort-init 0)\n    (< fort-init 0) false\n    :else (let [\n                next-fort (truncate (- (+ fort-init (* fort-init (\/ p 100))) per-year))\n                next-per-year (truncate (+ per-year (* per-year (\/ infl 100))))]\n           (fortune next-fort p next-per-year (dec nb-year) infl))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16880,"user_id":null,"body":"(ns bankerplan.core)\n\n(defn truncate [n]\n  (int (Math\/floor n)))\n\n(defn next-fort [f p c]\n  (truncate (- (+ f (* f (\/ p 100))) c)))\n\n(defn next-per-year [c i]\n  (truncate (+ c (* c (\/ i 100)))))\n\n; fort-init is f0, p is percent, per-year is c0, nb-year is n, infl is i\n(defn fortune [fort-init p per-year nb-year infl]\n  ; your code\n  \n  (println fort-init p per-year nb-year infl)\n  (cond \n    (= nb-year 1) (>= fort-init 0)\n    (< fort-init 0) false\n    :else (fortune (next-fort fort-init p per-year) p (next-per-year per-year infl) (dec nb-year) infl)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16881,"user_id":53,"body":"(ns bankerplan.core)\n\n(defn aux [f0, p, c0, n, i]\n  (if (= n 1) \n    f0 \n    (aux \n     (- (+ f0 (quot (* f0 (int (Math\/floor p))) 100)) c0) \n     p \n     (+ c0 (quot (* c0 (int (Math\/floor i))) 100))\n     (dec n) \n     i)))\n\n(defn fortune [f0, p, c0, n, i]\n  (>= (aux f0 p c0 n i) 0))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16882,"user_id":null,"body":"(ns bankerplan.core)\n\n(defn fortune [fort-init p per-year nb-year infl]\n  (loop [f fort-init\n         c per-year\n         n 1]\n    (println \"n: \" n \" f: \" f \" c: \" c)\n    (if (< f 0)\n      false\n      (if (= n nb-year)\n        true\n        (recur (int (Math\/floor (- (+ f (* (\/ p 100) f)) c))) (int (Math\/floor (+ c (* c (\/ infl 100))))) (inc n))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16883,"user_id":null,"body":"(ns bankerplan.core)\n\n; fort-init is f0, p is percent, per-year is c0, nb-year is n, infl is i\n\n(defn next-balance\n  [balance p per-year]\n  (let [after-interest (+ balance (\/ (* p balance) 100))\n        after-costs (- after-interest per-year)]\n        (int after-costs)))\n\n(defn iter-fn\n  [{:keys [balance\n           interest-rate\n           inflation-rate\n           withdraw] :as params}]\n   (->\n     params\n     (update :balance next-balance interest-rate withdraw)\n     (update\n       :withdraw\n       (fn [withdraw] (int (+ withdraw (\/ (* inflation-rate withdraw) 100)))))))\n\n(defn fortune\n  [fort-init p per-year nb-year infl]\n  ; your code\n  (->>\n    {:balance fort-init\n     :interest-rate p\n     :inflation-rate infl\n     :withdraw per-year}\n    (iterate iter-fn)\n    (drop (dec nb-year))\n    first\n    :balance\n    (<= 0)\n    ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16884,"user_id":null,"body":"(ns bankerplan.core)\n\n; fort-init is f0, p is percent, per-year is c0, nb-year is n, infl is i\n(defn fortune [fort-init p per-year nb-year infl]\n  (let [ff (+ 1 (\/ p 100)) cc (+ 1 (\/ infl 100))]\n    (loop [f fort-init c per-year n nb-year]\n      (if (= n 0) true (if (< f 0) false (recur (Math\/floor (- (* f ff) c)) (Math\/floor (* c cc)) (dec n)))))\n  ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16885,"user_id":2111,"body":"(ns bankerplan.core)\n\n(defn fortune [fort-init p per-year nb-year infl]\n (loop [yr 0 fn fort-init cn per-year] (if (or (< fn 0) (> yr 1000)) (if (< yr nb-year) false true)\n   (recur (inc yr) (bigint (- (* fn (+ 1 (\/ p 100))) cn)) (bigint (* cn (+ 1 (\/ infl 100))))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16886,"user_id":null,"body":"(ns bankerplan.core)\n\n; fort-init is f0, p is percent, per-year is c0, nb-year is n, infl is i\n(defn fortune [deposit interest_rate withdraw years_left inflation]\n  (cond\n    (= years_left 1) true\n    (> withdraw deposit) false\n    :else (fortune \n            (int (- (* (\/ (+ 100 interest_rate) 100) deposit) withdraw))\n            interest_rate\n            (int (* (\/ (+ 100 inflation) 100) withdraw))\n            (- years_left 1)\n            inflation)\n  )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16887,"user_id":null,"body":"(ns bankerplan.core)\n\n; fort-init is f0, p is percent, per-year is c0, nb-year is n, infl is i\n(defn fortune [fort-init p per-year nb-year infl]\n  (let [intr (+ 1 (\/ p 100))\n        infl (+ 1 (\/ infl 100))]\n    (loop [iter 1\n           f (Math\/floor fort-init)\n           c (Math\/floor per-year)]\n      (let [fg (Math\/floor (* f intr))]\n        (cond\n          (< f 0) false\n          (>= iter nb-year) true\n          :else (recur (inc iter) (- fg c) (Math\/floor (* c infl)))\n        )\n      )\n    )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"56484848ba95170a8000004d":[{"id":16888,"user_id":null,"body":"(ns gps.core)\n\n(defn gps [s x]\n  (->> (partition 2 1 x)\n    (map (fn [[p c]] (- c p)))\n    (map #(* % 3600.0))\n    (map #(\/ % s))\n    (reduce max 0)\n    long))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16889,"user_id":null,"body":"(ns gps.core)\n\n(defn gps [s x]\n\t(if (<= (count x) 1)\n  \t0\n\t\t(int (apply max (map #(\/ (* % 3600) (float s)) (map - (rest x) x))))\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16890,"user_id":null,"body":"(ns gps.core)\n\n(defn gps [s x]\n\t(if (< 1 (count x))\n    (let [hourly-speed #(\/ (* 3600 %) s)\n          distances (map - (rest x) x)\n          speeds (map hourly-speed distances)\n          max-speed (apply max speeds)]\n      (int max-speed))\n    0))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16891,"user_id":null,"body":"(ns gps.core)\n\n(defn gps [time-interval distances]\n (if (< (count distances) 2)\n   0\n   (let [distance-pairs (partition 2 (interleave (rest distances) (butlast distances)))\n         pairwise-difference (fn [[a b]] (- a b))\n         distances-per-interval (map pairwise-difference distance-pairs)\n         seconds-in-an-hour 3600\n         distance->velocity (fn [d] (\/ (* seconds-in-an-hour d) time-interval))\n         avg-velocities (map distance->velocity distances-per-interval)\n         largest-avg-velocity (apply max avg-velocities)]\n     (int largest-avg-velocity))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16892,"user_id":null,"body":"(ns gps.core)\n\n(defn per-hour [s x]\n  (int (\/ (* 3600.0 x) s)))\n  \n(defn gps [s x]\n  (per-hour s (apply max 0 (map - (rest x) x))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16893,"user_id":null,"body":"(ns gps.core)\n\n(defn gps [s x]\n  (->> (partition 2 1 x)\n       (map (fn [[x y]] (\/ (* 3600 (- y x)) s)))\n       (reduce max 0)\n       int))\n       ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16894,"user_id":492,"body":"(ns gps.core)\n\n(defn gps [s x]\n (if (<= (count x) 1)\n    0\n    (let [z (map vector (rest x) x)\n          w (map (fn [[a b]] (\/ (* 3600 (- a b)) (float s))) z)\n         ]\n      (int (Math\/floor (apply max w))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16895,"user_id":null,"body":"(ns gps.core)\n\n(defn calculate-intervals [x]\n  (loop [acc 0 xs x ]\n    (if (nil? (second xs))\n      acc\n        (recur (max acc (- (second xs) (first xs))) (next xs))\n      )\n    )\n  )\n\n(defn gps [s x]  (int (\/ (* 3600 ( calculate-intervals x)) s)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16896,"user_id":null,"body":"(ns gps.core)\n\n(defn average-speeds [s x0 dx]\n  (quot (* 3600 (- dx x0) ) s)\n  )\n(defn gps [s x]\n  (int (apply max (cons 0 (map #(average-speeds s %1 %2) x (rest x)))) )\n   )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16897,"user_id":null,"body":"(ns gps.core)\n\n(defn gps [s x] \n  (if (<= (count x) 1)\n    0\n    (int (apply max (map #(\/ (* 3600 (- %2 %1)) s) x (drop 1 x))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5648b12ce68d9daa6b000099":[{"id":16898,"user_id":null,"body":"(ns kata.bus)\n(defn number\n  [bus-stops]\n  (reduce - (apply map + bus-stops))\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16899,"user_id":null,"body":"(ns kata.bus)\n(defn number\n  [bus-stops]\n  (->> bus-stops\n    (map #(apply - %))\n    (reduce +)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16900,"user_id":null,"body":"(ns kata.bus)\n(defn number\n  [bus-stops]\n  (->> bus-stops\n    (apply map +)\n    (reduce -)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16901,"user_id":null,"body":"(ns kata.bus)\n\n(defn delta [passengers [on off]]\n  (+ passengers (- on off)))\n\n(defn number\n  [bus-stops]\n  (reduce delta 0 bus-stops))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16902,"user_id":null,"body":"(ns kata.bus)\n(defn number\n  [bus-stops]\n  (reduce + (map #(reduce - %) bus-stops)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16903,"user_id":null,"body":"(ns kata.bus)\n\n(defn number\n  [bus-stops]\n  (reduce + (map (fn [e] (reduce - e)) bus-stops))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16904,"user_id":null,"body":"(ns kata.bus)\n\n(defn number\n  [bus-stops]\n  (->>\n   bus-stops\n   (map (fn [[up down]] (- up down)))\n   (reduce +)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16905,"user_id":null,"body":"(ns kata.bus)\n(defn number [bus-stops]\n  (reduce + (map #(reduce - %) bus-stops))) ;; to avoid integer overflow","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16906,"user_id":null,"body":"(ns kata.bus)\n\n(defn number [bus-stops]\n  (reduce (fn [result it] (+ result (- (first it) (second it)))) 0 bus-stops))\n\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16907,"user_id":null,"body":"(ns kata.bus)\n(defn number\n  [bus-stops]\n  (reduce #(+ %1 (- (first %2) (second %2))) 0 bus-stops)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"56530b444e831334c0000020":[{"id":16908,"user_id":null,"body":"(ns clojure.chromosomes)\n\n(defn chromosome_check [sperm]\n  ({\"XY\" \"Congratulations! You're going to have a son.\"\n  \"XX\" \"Congratulations! You're going to have a daughter.\"} sperm))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16909,"user_id":null,"body":"(ns clojure.chromosomes)\n\n(defn chromosome_check [sperm]\n  (case sperm\n    \"XX\" \"Congratulations! You're going to have a daughter.\"\n    \"XY\" \"Congratulations! You're going to have a son.\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16910,"user_id":null,"body":"(ns clojure.chromosomes)\n\n(defn chromosome_check [sperm]\n  (if (= sperm \"XY\")\n    (str \"Congratulations! You're going to have a son.\")\n    (str \"Congratulations! You're going to have a daughter.\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16911,"user_id":53,"body":"(ns clojure.chromosomes)\n\n(defn find-sex [sperm] (if (clojure.string\/includes? sperm \"Y\") \"M\" \"F\"))\n\n(defn chromosome_check [sperm]\n  (format \"Congratulations! You're going to have a %s.\"\n    (if (= \"M\" (find-sex sperm)) \"son\" \"daughter\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16912,"user_id":null,"body":"(ns clojure.chromosomes)\n\n(defn chromosome_check [sperm]\n  (if (= sperm \"XX\")\n    \"Congratulations! You're going to have a daughter.\"\n    \"Congratulations! You're going to have a son.\"\n    ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16913,"user_id":null,"body":"(ns clojure.chromosomes)\n\n(defn chromosome_check [zygote]\n  (str \"Congratulations! You're going to have a \"\n       (if (clojure.string\/includes? zygote \"Y\") \"son\" \"daughter\")\n       \".\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16914,"user_id":null,"body":"(ns clojure.chromosomes)\n\n(defn chromosome_check [sperm]\n  (cond\n    (= \"XY\" sperm) \"Congratulations! You're going to have a son.\"\n    (= \"XX\" sperm) \"Congratulations! You're going to have a daughter.\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16915,"user_id":null,"body":"(ns clojure.chromosomes\n  (:require\n   [clojure.string :as s]))\n\n(defn chromosome_check [sperm]\n  (if (s\/includes? sperm \"Y\")\n    \"Congratulations! You're going to have a son.\"\n    \"Congratulations! You're going to have a daughter.\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16916,"user_id":1703,"body":"(ns clojure.chromosomes)\n\n(defn chromosome_check [sperm]\n  (cond\n    (= \"XY\" sperm) \"Congratulations! You're going to have a son.\"\n    :else \"Congratulations! You're going to have a daughter.\"\n    ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16917,"user_id":null,"body":"(ns clojure.chromosomes)\n\n(defn chromosome_check [sperm] \n  (format \"Congratulations! You're going to have a %s.\"\n          (if ((apply hash-set sperm) \\Y) \"son\" \"daughter\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"56541980fa08ab47a0000040":[{"id":16918,"user_id":null,"body":"(ns printer.core)\n\n(defn printer_error [s]\n\t(str (count (re-seq #\"[n-z]\" s)) \"\/\" (count s))\n  )","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16919,"user_id":null,"body":"(ns printer.core)\n\n(defn printer_error [s]\n  (str (-> (re-seq #\"[n-z]\" s) count) \"\/\" (.length s))) ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16920,"user_id":null,"body":"(ns printer.core)\n\n(defn printer_error [s]\n  (let [chars (seq s)]\n    (str\n      (count (filter #(> (int %) (int \\m)) chars))\n      \"\/\"\n      (count chars)))) ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16921,"user_id":null,"body":"(ns printer.core)\n\n(defn is-valid-color [c] \n  (let [ \n        lowest (int \\a) \n        highest (int \\m)\n        ] \n    (<= lowest (int c) highest)))\n\n(defn count-errors [s]\n  (count (filter false? (map is-valid-color s))))\n\n(defn printer_error [s]\n  (str (count-errors s) \"\/\" (count s))\n  ) ","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16922,"user_id":null,"body":"(ns printer.core)\n\n(defn in-range [ch]\n  (and (>= (int ch) (int \\a)) (<= (int ch) (int \\m))\n       )\n  )\n\n(defn printer_error [s]\n  (def errChars (filter (fn [x] (not (in-range x))) s))\n  (str (count errChars) \"\/\" (count s)\n       )\n  ) ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16923,"user_id":null,"body":"(ns printer.core)\n\n(defn error? [x]\n  (> (compare x \\m) 0))\n\n(defn +err [cnt x]\n  (if (error? x)\n    (inc cnt)\n    cnt))\n  \n(defn print-fraction [numer denom]\n  (str numer \"\/\" denom))\n\n(defn printer_error [s]\n  (print-fraction (reduce +err 0 (seq s)) (count s)) )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16924,"user_id":492,"body":"(ns printer.core)\n\n(defn mk [s]\n  (list (reduce + \n                (for [x (map char (range 110 123)) \n                :let [c (count (filter (fn [v] (= x v)) s)) ]\n               ]\n            c)) (count s)))\n(defn printer_error [s]\n  (clojure.string\/join \"\/\" (mk s))) ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16925,"user_id":null,"body":"(ns printer.core)\n\n(defn printer_error [s]\n  (format \"%d\/%d\" (count (filter #(< 109 (int %)) s)) (count s))) ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16926,"user_id":null,"body":"(ns printer.core\n  (:require [clojure.string :as str]))\n\n(defn printer_error [s]\n  (let [len (count s)\n        num-errors (count (str\/replace s #\"[(?i)^a-m]\" \"\"))]\n    (str num-errors \"\/\" len)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16927,"user_id":null,"body":"(ns printer.core)\n\n(defn should-count [k]\n  (if (.contains [\\a \\b \\c \\d \\e \\f \\g \\h \\i \\j \\h \\k \\l \\m] (k 0))\n    0\n    (k 1)))\n\n(defn printer_error [s]\n  (str (reduce + (map should-count (frequencies s))) \"\/\" (count s)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5656b6906de340bd1b0000ac":[{"id":16928,"user_id":527,"body":"(ns longest.core)\n\n(defn longest [& ss]\n  (->> ss (apply concat) (apply sorted-set) (apply str)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16929,"user_id":null,"body":"(ns longest.core)\n(require '[clojure.string :as str])\n\n(defn longest [s1 s2]\n  (->>\n    (concat s1 s2)\n    (distinct)\n    (sort)\n    (apply str)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16930,"user_id":1144,"body":"(ns longest.core)\n(require '[clojure.string :as str])\n\n(defn longest [s1 s2]\n  (apply str (set (str s1 s2)))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16931,"user_id":null,"body":"(ns longest.core)\n(require '[clojure.string :as str])\n\n(defn longest [s1 s2]\n   (apply str ((comp sort distinct concat) s1 s2))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16932,"user_id":464,"body":"(ns longest.core)\n(require '[clojure.string :as str]\n         '[clojure.set :as s])\n\n(defn longest [s1 s2]\n  (apply str (sort (s\/union (set s1) (set s2)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16933,"user_id":null,"body":"(ns longest.core)\n\n(defn longest [s1 s2]\n  (->> (concat s1 s2)\n       set\n       (apply str)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16934,"user_id":null,"body":"(ns longest.core\n  (:require [clojure.string :as string]\n            [clojure.set]))\n\n(defn alphatize\n  [string]\n  (re-seq #\"[a-z]\" string))\n\n(defn longest [string1 string2]\n  (string\/join\n    (apply sorted-set\n      (clojure.set\/union (alphatize string1)\n                         (alphatize string2)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16935,"user_id":null,"body":"(ns longest.core)\n(require '[clojure.string :as str])\n\n(defn longest [s1 s2]\n  \n   (apply str ((comp sort distinct str) s1 s2))\n  \n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16936,"user_id":null,"body":"(ns longest.core)\n(require '[clojure.string :as str])\n\n(defn longest [s1 s2]\n  (apply str (sort (set (str s1 s2)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16937,"user_id":492,"body":"(ns longest.core)\n(require '[clojure.string :as str])\n\n(defn longest [s1 s2]\n  (defn mk-tab [s]\n    (for [x (map char (range 97 123)) \n          :let [c (count (filter (fn [v] (= x v)) s)) ]\n         ]\n      (list x c)))\n  (let [a1 (map vector (mk-tab s1) (mk-tab s2))\n        a2 (map (fn [ [x y] ] [(first x) (max (second x) (second y))]) a1)\n        a3 (filter (fn [ [x y] ] (> y 0)) a2)\n        a4 (str\/join \"\" (map (fn [ [x y] ] x) a3))\n       ]\n    a4))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"565abd876ed46506d600000d":[{"id":16938,"user_id":492,"body":"(ns simpson.core)\n\n(defn- f [x] (* 1.5 (Math\/pow (Math\/sin x) 3)))\n(defn sum1 [n h]\n  (reduce + (for [i (range 1 (+ (quot n 2) 1))]\n    (f (* (- (* 2.0 i) 1) h)))))\n(defn sum2 [n h]\n  (reduce + (for [i (range 1 (quot n 2))]\n    (f (* 2.0 i h)))))\n(defn simpson [n]\n  (let [ h (\/ Math\/PI (double n))\n         s1 (sum1 n h)\n         s2 (sum2 n h)\n       ]\n    (* (\/ Math\/PI (* 3.0 n)) (+ (f 0) (f Math\/PI) (* 4.0 s1) (* 2.0 s2)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16939,"user_id":53,"body":"(ns simpson.core)\n\n(defn f [n] (* 1.5 (Math\/pow (Math\/sin n) 3)))\n\n(defn simpson [n]\n  (loop [i 1 s 0]\n    (if (>= i n) \n      (* s (\/ (\/ Math\/PI 3) n)) \n      (recur (inc i) (+ s (* (+ 2 (* 2 (mod i 2))) (f (* i (\/ Math\/PI n)))))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16940,"user_id":null,"body":"(ns simpson.core)\n\n(defn simpson [n]\n  (let [f #(* 1.5 (Math\/pow (Math\/sin %) 3))\n       h (\/ Math\/PI n)\n       factor1 (apply + (map #(f (* % h)) (range 1 n 2)))\n       factor2 (apply + (map #(f (* % h)) (range 2 (dec n) 2)))]\n       (* Math\/PI (\/ (+ (f Math\/PI) (* 4 factor1) (* 2 factor2)) 3 n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16941,"user_id":null,"body":"(ns simpson.core)\n\n(defn f [x]\n  (* 3\/2 (Math\/pow (Math\/sin x) 3)))\n\n(defn simpson [n]\n  (let [a 0\n        b Math\/PI\n        h (\/ (- b a) n)\n        C (\/ h 3)]\n    (* C (+ (f a) \n            (f b) \n            (* 4 (->> (range 1 (inc (\/ n 2)))\n                      (map #(f (+ a (* h (- (* 2 %) 1)))))\n                      (reduce +)))\n            (* 2 (->> (range 1 (\/ n 2))\n                      (map #(f (+ a (* 2 % h))))\n                      (reduce +)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16942,"user_id":null,"body":"(ns simpson.core)\n\n\n(defn f [x]\n  (* 1.5 (Math\/pow (Math\/sin x) 3)))\n  \n(defn sum-from-1 [fac end sum-fn]\n  (->> (range 1 (inc end))\n       (map sum-fn)\n       (map f)\n       (apply +)\n       (* fac)))\n\n(defn sum-fn1 [a h]\n  (fn [i]\n    (+ a (* h (- (* 2 i) 1)))))\n\n(defn sum-fn2 [a h]\n  (fn [i]\n    (+ a (* 2 i h))))\n\n(defn simpson [n]\n  (let [b Math\/PI\n        a 0\n        h (\/ (- b a) n)]\n    (* (\/ h 3)\n       (+ (f a)\n          (f b)\n          (sum-from-1 4 (\/ n 2) (sum-fn1 a h))\n          (sum-from-1 2 (dec (\/ n 2)) (sum-fn2 a h))))\n    \n    \n  ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16943,"user_id":null,"body":"(ns simpson.core)\n\n(def b Math\/PI)\n(def a 0)\n\n(defn calc-h [bval aval n]\n  (\/ (- b a ) n)\n  )\n\n(defn f [x]\n    (* (\/ 3 2) (Math\/pow (Math\/sin x) 3))\n  )\n\n(defn simpson [n]    \n    (def h (calc-h b a n))    \n    (* (\/ (- b a)  (* 3 n))\n       (+ (f a) \n          (f b) \n          (* 4 (apply + (map #(f (+ a (* (- (* 2 %) 1) h))) (range 1 (+ (\/ n 2) 1))))) \n          (* 2 (apply + (map #(f (+ a (* 2 % h) ) ) (range 1 (\/ n 2) ))))\n          )\n       )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16944,"user_id":null,"body":"(ns simpson.core)\n\n(defn f [x]\n  (-> (Math\/sin x) (Math\/pow 3) (* 3\/2)))\n\n(defn simpson [n]\n  (let [h (\/ Math\/PI n)\n        term1 (->> (range 1 (inc (\/ n 2)))\n                   (map #(f (* (dec (* 2 %)) h)))\n                   (apply +)\n                   (* 4))\n        term2 (->> (range 1 (\/ n 2))\n                   (map #(f (* 2 % h)))\n                   (apply +)\n                   (* 2))]\n    (* (\/ h 3) (+ term1 term2))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16945,"user_id":null,"body":"(ns simpson.core)\n\n(defn f [x]\n  (* (\/ 3 2) (Math\/pow (Math\/sin x) 3))\n)\n\n(defn sum-1 [i h]\n  (f (* h (- (* 2 i) 1)))\n)\n\n(defn sum-2 [i h]\n  (f (* 2 i h))\n)\n\n(defn simpson [n]\n  (def h (\/ (Math\/PI) n))\n  (def coeff (\/ (Math\/PI) (* 3 n)))\n  (def sum-1-val(* 4 (reduce + (map sum-1 (range 1 (+ 1 (\/ n 2))) (repeat h)))))\n  (def sum-2-val (* 2 (reduce + (map sum-2 (range 1 (\/ n 2)) (repeat h)))))\n  (* coeff (+ sum-1-val sum-2-val))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16946,"user_id":null,"body":"(ns simpson.core)\n\n(def a (double 0.0))\n(def b (double Math\/PI))\n\n(defn f\n  [x]\n  (* (\/ 3.0 2) (Math\/pow (Math\/sin x) 3)))\n\n(defn simpson\n  [n]\n  (let [h (\/ (- b a) n)]\n    (* (\/ (- b a) (* 3 n))\n       (+ (f a)\n          (f b)\n          (* 4\n             (apply + (map #(f (+ a (* (dec (* 2 %)) h))) (range 1 (inc (\/ n 2))))))\n          (* 2\n             (apply + (map #(f (+ a (* 2 % h))) (range 1 (\/ n 2)))))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16947,"user_id":null,"body":"(ns simpson.core)\n\n(defn sum_1 [n a b f h]\n  (let [nums (take (\/ n 2) (iterate inc 1))\n        get_x #(+ a (* h (- (* 2 %) 1)))\n        the_x (map get_x nums)\n        the_fs (map f the_x)]\n    (reduce + the_fs)))\n\n(defn sum_2 [n a b f h]\n  (let [nums (take (dec (\/ n 2)) (iterate inc 1))\n        get_x #(+ a (* 2 h %))\n        the_x (map get_x nums)\n        the_fs (map f the_x)]\n    (reduce + the_fs)))\n\n(defn left_bit [n a b]\n  (\/ (- b a) (* 3 n)))\n\n(defn right_bit [n a b f h]\n  (+ (f a) (f b) \n     (* 4 (sum_1 n a b f h)) (* 2 (sum_2 n a b f h))))\n\n(defn simpson [n]\n  (let [f #(* (\/ 3 2) (reduce * (repeat 3 (Math\/sin %))))\n        a 0\n        b Math\/PI\n        h (\/ (- b a) n)]\n    (* (left_bit n a b) (right_bit n a b f h))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"565c0fa6e3a7d39dee000125":[{"id":16948,"user_id":492,"body":"(ns braking.core)\n\n(defn dist [v mu]                               ; suppose reaction time is 1\n  (let [ \t\t\t\t\t\n        g 9.81 \t\t\t\t\t\t                      ; acceleration due to gravity in m\/s\n        coef (\/ 1000.0 3600.0) \t\t\t            ; km\/h -> m\/s\n        dreact (* v coef) \t\t\t\t              ; distance of reaction with t = 1\n        vms (* coef v) \t\t\t\t\t                ; speed in m\/s\n        dbrak (\/ (* 0.5 (Math\/pow vms 2)) mu g) ; braking distance       \n       ]\n    (+ dreact dbrak)))\n\n(defn speed [d mu]                              ; suppose reaction time is 1\n  (let [\n        g 9.81                                  ; acceleration due to gravity in m\/s\n        coef (\/ 3600.0 1000.0)                  ; m\/s -> km\/h\n        delta (Math\/sqrt (+ 4 (\/ (* 8 d) mu g)))\n       ]\n    (* 0.5 mu g (- delta 2) coef)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16949,"user_id":53,"body":"(ns braking.core)\n(defn dist [v mu] (let [u (\/ (* v 5) 18)] (+ u (\/ (* u u) (* 2 mu 9.81)))))\n(defn speed [d mu] (let [b (* -2 mu 9.81)] (\/ (* 3.6 (+ b (Math\/sqrt (- (* b b) (* 4 b d))))) 2)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16950,"user_id":null,"body":"(ns braking.core)\n\n(defn dist [v mu]                               ; suppose reaction time is 1\n  (let [vel (\/ (* v 1000) 3600.0) g 9.81]\n    (+ vel (\/ (* vel vel) (* 2 mu g)))\n    )\n  )\n\n(defn speed [d mu]                              ; suppose reaction time is 1\n  (let [g 9.81 a (\/ 1.0 (* 2 mu g)) disp (Math\/sqrt (inc (* 4 a d)))]\n    (* 3.6 (\/ (dec disp) (* 2 a)))\n    )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16951,"user_id":492,"body":"(ns braking.core)\n\n(defn dist [v mu]                               ; suppose reaction time is 1\n  (let [ \t\t\t\t\t\n        g 9.81 \t\t\t\t\t\t                      ; acceleration due to gravity in m\/s\n        coef (\/ 1000.0 3600.0) \t\t\t            ; km\/h -> m\/s\n        dreact (* v coef) \t\t\t\t              ; distance of reaction with t = 1\n        vms (* coef v) \t\t\t\t\t                ; speed in m\/s\n        dbrak (\/ (* 0.5 (Math\/pow vms 2)) mu g) ; braking distance       \n       ]\n    (+ dreact dbrak)))\n\n(defn speed [d mu]                              ; suppose reaction time is 1\n  (let [\n        g 9.81                                  ; acceleration due to gravity in m\/s\n        coef (\/ 3600.0 1000.0)                  ; m\/s -> km\/h\n        delta (Math\/sqrt (+ 4 (\/ (* 8 d) mu g)))\n       ]\n    (* 0.5 mu g (- delta 2) coef)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16952,"user_id":null,"body":"(ns braking.core)\n\n(defn dist [v mu]                               ; suppose reaction time is 1\n  (let [v-mps (\/ (* 1000 v) (* 60 60))]\n    (+ v-mps (\/ (* v-mps v-mps) (* 2 mu 9.81)))))\n\n(defn speed [d mu]                              ; suppose reaction time is 1\n  (let [b (* 2 mu 9.81)\n        D (- (* b b) (* 4 (- d) b))\n        v-mps (\/ (- (Math\/sqrt D) b) 2)]\n    (\/ (* 60 60 v-mps) 1000)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16953,"user_id":null,"body":"(ns braking.core)\n(def g 9.81)\n(def rt 1) ; suppose reaction time is 1\n(def h_s (\/ 1 (* 60 60))) ; hours\/seconds for conversion\n(def m_km 1000)  ; meters\/kilopmeter for conversion\n\n\n(defn dist [vkh mu] \n  (let [v (* vkh h_s m_km) ;convert velocity from km\/h to m\/s\n        rtd (* v rt) ;distance due to reaction time \n        bd (\/ (* v v) (* 2 mu g))] ; brakin distance from formula\n     (+ rtd bd) ; total distance = reaction time + braking distance\n    )\n)\n\n; for soeed we use Newtons method to solve inverse of dist(v), we need to define \n; first derivative as a function that returns a function \n(defn fn-derivative [f delta]\n  (fn [x] \n    (\/ (- (f (+ x delta)) (f x)) delta ))) \n\n\n(defn speed [d mu]                             \n  (let [f #(-(dist % mu) d ) ;  function  dist(v) - d and use Netons method to find roots\n        df (fn-derivative f 0.00001) ; first derivative of above fn, delta is 0.00001\n        init d ; use d as first guess\n        threshold 0.0001 ; we are done when xn - xn+1 < threshold\n        ]\n    (loop [xn nil \n           xn+1 init]\n      (println xn+1 xn)\n      (if (and xn (> threshold (Math\/abs (- xn+1 xn)))) xn+1\n          (recur xn+1  (- xn+1  (\/ (f xn+1) (df xn+1))) ))))) \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16954,"user_id":null,"body":"(ns braking.core)\n\n(def rt 1)\n\n(def g 9.81)\n\n(defn to-metric [v] (* 1000 (\/ v 3600)))\n\n(defn from-metric [v] (* (\/ v 1000) 3600))\n\n(defn dist [vkm mu]\n\n  (let [v (to-metric vkm)]\n\n    (+ (* v rt) (\/ (* v v) (* 2 mu g)))))\n\n(defn solve-quadratic [a b c]\n\n  (let [d (- (* b b) (* 4 a c))\n\n        x2 (\/ (- (Math\/sqrt d) b) (* 2 a))\n\n        x1 (\/ (- 0 (Math\/sqrt d) b) (* 2 a))] (if (neg? d) nil (list x1 x2))))\n\n(defn speed [d mu]\n\n  (let [vm (second (solve-quadratic (\/ 1 2 mu g) rt (- d)))] (from-metric vm)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16955,"user_id":null,"body":"(ns braking.core)\n\n(defn dist [v mu]                               ; suppose reaction time is 1\n  (let [v (\/ v 3.6)]\n   (-> v\n      (* v)\n      (\/ 2)\n      (\/ mu)\n      (\/ 9.81)\n      (+ v)\n    ))\n  )\n\n(defn speed [d mu]                              ; suppose reaction time is 1\n  (let [gmu (* mu 9.81)]\n    (-> gmu\n        (* 2)\n        (* d)\n        (+ (* gmu gmu))\n        (Math\/sqrt)\n        (- gmu)\n        (* 3.6)\n      )\n    )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16956,"user_id":null,"body":"(ns braking.core)\n\n(defn dist [v mu]                               ; suppose reaction time is 1\n  (+ (\/ (* v 1000) 60 60) (\/ (* v v 1000 1000) (* 2 mu 9.81 60 60 60 60)))\n  )\n\n(defn a [mu] (\/ 1000 2 mu 9.81 60 60 60 60))\n(def b (\/ 1 60 60))\n(defn c [d] (- (\/ d 1000)))\n(defn speed [d mu]                              ; suppose reaction time is 1\n  (\/ (- (Math\/sqrt (- (* b b) (* 4 (a mu) (c d)))) b) 2 (a mu))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16957,"user_id":null,"body":"(ns braking.core)\n\n(defn dist [v1 mu]\n  (let [v2 (\/ v1 3.6)]\n    (+ v2\n       (\/\n        (* v2 v2)\n        (* 2 mu 9.81)))))\n\n;; d = vt + v^2\/2ug\n(defn speed [d mu]\n  (let [delta (+\n               (* 4 (* mu mu) (* 9.81 9.81))\n               (* 8 mu 9.81 d))]\n    (* 3.6\n       (\/\n        (+ (* -2 mu 9.81) (Math\/sqrt delta))\n        2))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5663f5305102699bad000056":[{"id":16958,"user_id":null,"body":"(ns maxdifflength.core)\n\n(defn mxdiflg [a1 a2]\n  (reduce max -1 (for [x a1, y a2] (Math\/abs (- (count x) (count y))))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16959,"user_id":null,"body":"(ns maxdifflength.core)\n\n(defn mxdiflg [a1 a2]\n  (apply max (conj (for [x a1\n                         y a2]\n                     (Math\/abs (- (count x) (count y)))) -1)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16960,"user_id":492,"body":"(ns maxdifflength.core)\n\n(defn mxdiflg [a1 a2]\n  (if (or (empty? a1) (empty? a2))\n    -1\n    (apply max (for [x a1 y a2] (Math\/abs (- (count x) (count y)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16961,"user_id":null,"body":"(ns maxdifflength.core)\n\n(defn abs [a] (if (> a 0) a (* a -1))) \n\n(defn mxdiflg [a1 a2]\n  (println a1)\n  (println a2)\n  (if (or (empty? a1) (empty? a2))\n    -1\n    (apply max \n      (concat \n        (map abs (map  #(- % (apply max (map count a1))) (map count a2)))\n        (map abs (map  #(- % (apply min (map count a1))) (map count a2)))\n      )\n    )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16962,"user_id":null,"body":"(ns maxdifflength.core)\n\n(defn map-to-lengths [a1 a2]\n  (letfn [(map-to-length [xs] (map (fn [x] (count x)) xs))]\n    (let [lengths-a1 (map-to-length a1)\n          lenghts-a2 (map-to-length a2)]\n      [lengths-a1 lenghts-a2])))\n\n(defn mxdiflg [a1 a2]\n  (if (or (empty? a1)\n          (empty? a2))\n    -1\n    (let [result (map-to-lengths a1 a2)]\n      (->>\n       (mapcat (fn [x]\n               (map (fn [y] (Math\/abs (- x y))) (second result)))\n             (first result))\n       (apply max)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16963,"user_id":null,"body":"(ns maxdifflength.core)\n\n(defn mxdiflg [a1 a2]\n  (let     \n    [\n     dists  (for [cn1 a1 cn2 a2] \n               (Math\/abs \n                 (- \n                   (count cn1) \n                   (count cn2))))\n     ] (reduce max -1 dists)\n  ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16964,"user_id":null,"body":"(ns maxdifflength.core)\n\n(defn mxdiflg [a1 a2]\n  (let     \n    [\n     dists  (for [cn1 a1 cn2 a2] \n              (if \n                (or \n                 (zero? (count cn1))\n                 (zero? (count cn2)))\n                  -1\n                 (Math\/abs \n                   (- \n                    (count cn1) \n                    (count cn2)))))\n     ] (reduce max -1 dists)\n  ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16965,"user_id":null,"body":"(ns maxdifflength.core)\n\n(defn mxdiflg [a1 a2]\n  (apply (partial max -1)\n         (for [a (map count a1)\n               b (map count a2)]\n           (max (- b a) (- a b)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16966,"user_id":null,"body":"(ns maxdifflength.core)\n\n(defn mxdiflg [a1 a2]\n  ; your code\n  (apply max (cons -1 (for [w1 a1\n        w2 a2]\n    (Math\/abs (- (count w1) (count w2))))))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16967,"user_id":1703,"body":"(ns maxdifflength.core)\n\n(defn mxdiflg [a1 a2]\n  (if(or(empty? a1)(empty? a2)) -1\n   (max (-(apply max (map #(count %) a1)) (apply min (map #(count %) a2)))\n        (-(apply max (map #(count %) a2)) (apply min (map #(count %) a1))))\n    ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"566543703c72200f0b0000c9":[{"id":16968,"user_id":null,"body":"(ns epidemy.core)\n\n(defn epidemic [tm n s0 i0 b a] \n  (let [dt (\/ tm n)\n        n-steps (* tm n)]\n\n    (letfn [\n      ;; the finite difference equations given an input vector\n      (S [[s i _]] (- s (* dt b s i)))\n      (I [[s i _]] (+ i (* dt (- (* b s i) (* a i)))))\n      (R [[_ i r]] (+ r (* dt i a)))\n\n      ;; lazy sequence of steps (aka co-recursion)\n      (steps [step]\n        (lazy-seq \n          (cons step (steps ((juxt S I R) step)))))]\n\n      (->> \n        (steps [s0 i0 0])\n        (map second) ;; infected\n        (take n-steps) \n        (apply max)\n        (int)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16969,"user_id":null,"body":"(ns epidemy.core)\n\n(defn next-term [[s i r dt a b]]\n  (let [S (- s (* dt b s i))\n        I (+ i (* dt (- (* b s i) (* a i))))\n        R (+ r (* dt i a))]\n    [S I R dt a b]))\n\n(defn epidemic [tm n s0 i0 b a]\n  (let [dt (\/ tm n)]\n    (->> (iterate next-term [s0 i0 0 dt a b])\n         (take n)\n         (map second)\n         (apply max)\n         (int))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16970,"user_id":null,"body":"(ns epidemy.core)\n\n(defn epidemic [tm n s0 i0 b a]\n  (let [dt (\/ tm n)\n        evolve (fn [{:keys [s i r i-1]}]\n                 {:s (- s (* dt b s i))\n                  :i (+ i (* dt i (- (* b s) a)))\n                  :r (+ r (* dt i a))\n                  :i-1 i})]\n    (int (:i-1 (last (take-while #(>= (:i %) (:i-1 %)) (iterate evolve {:s s0 :i i0 :r 0 :i-1 i0})))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16971,"user_id":492,"body":"(ns epidemy.core)\n\n(defn epidemic-aux [[n dt prevS prevI prevR b a k mx]]\n  (if (= k n)\n    (int mx)\n    (epidemic-aux [\n                   n dt\n                   (- prevS (* dt b prevS prevI))\n                   (+ prevI (* dt (- (* b prevS prevI) (* a prevI))))\n                   (+ prevR (* dt prevI a))\n                   b\n                   a\n                   (inc k)\n                   (if (> prevI mx) prevI mx)\n                  ])))\n\n(defn epidemic [tm n s0 i0 b a]\n  (epidemic-aux [n (\/ tm (double n)) s0 i0 0.0 b a 0 -1.0]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16972,"user_id":492,"body":"(ns epidemy.core)\n\n(defn epidemic-aux [[n dt prevS prevI prevR b a k mx]]\n  (if (= k n)\n    (int mx)\n    (epidemic-aux [\n                   n dt\n                   (- prevS (* dt b prevS prevI))\n                   (+ prevI (* dt (- (* b prevS prevI) (* a prevI))))\n                   (+ prevR (* dt prevI a))\n                   b\n                   a\n                   (inc k)\n                   (if (> prevI mx) prevI mx)\n                  ])))\n\n(defn epidemic [tm n s0 i0 b a]\n  (epidemic-aux [n (\/ tm (double n)) s0 i0 0.0 b a 0 -1.0]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16973,"user_id":null,"body":"(ns epidemy.core)\n\n(defn epidemic [tm n s0 i0 b a]\n  (def max-infected (int i0))\n  (def r0 0)\n  (def dt (\/ tm n))\n  (loop [infected i0, susceptible s0, recovered r0, n n] \n    (when (> n 0)\n      (if (> infected max-infected) (def max-infected (int infected)))\n      (recur \n       (+ infected  ; update infected\n          (* dt (- (reduce * [b susceptible infected]) \n                            (* infected a))))\n       (- susceptible  ; update susceptible\n          (reduce * [dt b susceptible infected]))\n       (+ recovered  ; update recovered\n          (reduce * [dt infected a]))\n       (- n 1)\n      )\n    )\n  )\n  max-infected\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16974,"user_id":null,"body":"(ns epidemy.core)\n\n(defn calc [[s i r] dt b a]\n  (let [dtbsi (* dt b s i)\n        dtai (* dt a i)\n        ns (- s dtbsi)\n        ni (+ i (- dtbsi dtai))\n        nr (+ r dtai)\n        ]\n    (lazy-seq (cons i (calc [ns ni nr] dt b a)))\n    )\n  )\n\n(defn epidemic [tm n s0 i0 b a]\n  (int (reduce max (take n (calc [s0 i0 0] (\/ tm n) b a))))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16975,"user_id":53,"body":"(ns epidemy.core)\n\n(defn epidemic [tm n s0 i0 b a]\n  (loop [s (double s0)\n         i (double i0)\n         r (double 0)\n         t (double 0)\n         imax (double 0)\n         dt (\/ (double tm) (double n))]\n    (if (>= t (double tm))\n      (int imax)\n      (let [sd (* dt (* (* (- b) s) i))\n            id (* dt (- (* b (* s i)) (* a i)))\n            rd (* dt (* a i))\n            s (+ s sd)\n            i (+ i id)\n            r (+ r rd)\n            t (+ t dt)\n            imax (if (> imax i) imax i)] \n        (recur  s\n                i\n                r\n                t\n                imax\n                dt )))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16976,"user_id":null,"body":"(ns epidemy.core)\n\n\n(defn epidemic \n  \"Compute the expected peak infections in an SIR model.\"\n  [tm n s0 i0 b a]\n  (let [dt (\/ tm n)\n        ds (fn [s i r] (- (* b s i dt)))\n        di (fn [s i r] (- (* b s i dt) (* a i dt)))\n        dr (fn [s i r] (+ a i r dt))]\n    (loop [t 0 s s0 i i0 r 0 i-max i0]\n      (if (= t tm) (int i-max)\n          (let [s-next (+ s (ds s i r))\n                i-next (+ i (di s i r))\n                r-next (+ r (dr s i r))]\n          (recur (+ t dt)\n                 s-next\n                 i-next\n                 r-next\n                 (max i-max i-next)))))))\n ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16977,"user_id":null,"body":"(ns epidemy.core)\n\n\n(defn epidemic \n  \"Find the expected peak infections based on an SIR model.\"\n  [tm n s0 i0 b a]\n  (let [dt (\/ tm n)\n        ds (fn [s i r] (- (* b s i dt)))\n        di (fn [s i r] (- (* b s i dt) (* a i dt)))\n        dr (fn [s i r] (min i (+ a i r dt)))]\n    (loop [t 0 s s0 i i0 r 0 i-max i0]\n      (if (= t tm) (int i-max)\n          (let [s-next (+ s (ds s i r))\n                i-next (+ i (di s i r))\n                r-next (+ r (dr s i r))]\n          (recur (+ t dt)\n                 s-next\n                 i-next\n                 r-next\n                 (max i-max i-next)))))))\n                 ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5667e8f4e3f572a8f2000039":[{"id":16978,"user_id":null,"body":"(ns accumule.core\n  (:use [clojure.string :only [join capitalize]]))\n\n(defn repeat-capitalize [i elm]\n  (capitalize (apply str (repeat (inc i) elm))))\n\n(defn accum [s]\n  (join \"-\" (map-indexed repeat-capitalize s)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16979,"user_id":null,"body":"(ns accumule.core\n  (:require [clojure.string :refer [capitalize join]]))\n\n(defn accum [s]\n  (->> s\n    (map-indexed #(repeat (inc %1) %2))\n    (map #(apply str %))\n    (map capitalize)\n    (join \"-\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16980,"user_id":null,"body":"(ns accumule.core)\n\n(defn accum [s]\n  (->> s\n     (map-indexed #(repeat (inc %1) %2))\n     (map #(apply str %))\n     (map clojure.string\/capitalize)\n     (clojure.string\/join \"-\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16981,"user_id":null,"body":"(ns accumule.core)\n(use '[clojure.string :only (join, capitalize)])\n\n(defn accum [s]\n         (->> s\n              (map-indexed #(capitalize (join (repeat (inc %1) %2))) )\n              (join \"-\")))\n             \n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16982,"user_id":null,"body":"(ns accumule.core\n  (require [clojure.string :as str]))\n\n\n(defn gen-for-letter\n  \"generates a substr for each letter and an index, iex f(a, 2) -> 'Aaa' \"\n  [letter index]\n  (str (str\/upper-case letter) (str\/join (repeat index (str\/lower-case letter)) )))\n\n\n(defn accum [string]\n  (let [letters (str\/split string #\"\")]\n    \n    \n    (->> (for [index (range (count string))\n            :let [ substr (gen-for-letter (get letters index) index)]]\n          substr)\n      (str\/join \"-\")))) \n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16983,"user_id":null,"body":"(ns accumule.core\n  (:require [clojure.string :as str]))\n\n(defn accum [s]\n  (->> s\n       (map repeat (next (range)))\n       (map (partial str\/join \"\"))\n       (map str\/capitalize)\n       (str\/join \"-\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16984,"user_id":null,"body":"(ns accumule.core)\n\n(defn mumble [times text ]\n  (->> \n    (repeat times text)\n    (reduce str) \n    clojure.string\/capitalize))\n\n(defn accum [s]\n  (->>\n    (map-indexed #(mumble (inc %1) %2) s)\n    (clojure.string\/join \"-\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16985,"user_id":null,"body":"(ns accumule.core\n  (:require [clojure.string :as str]))\n\n(defn accum [s]\n  (str\/join \"-\" (map-indexed #(str\/capitalize (apply str (repeat (inc %) %2))) s)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16986,"user_id":null,"body":"(ns accumule.core\n  (:use [clojure.string :only [join capitalize]]))\n\n(defn accum\n  [s]\n  (let [enum (map-indexed vector s)]\n    (join \\- \n          (map (fn [[i c]]\n                 (->> c \n                      (repeat (inc i))\n                      join\n                      capitalize))\n               enum))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16987,"user_id":492,"body":"(ns accumule.core)\n(require '[clojure.string :as str])\n\n(defn accum [s]\n  (defn mk-str [x y]\n    (apply str (repeat (+ y 1) x)))\n  (let [ u (map vector (vec s) (range (count s))) \n         v (map str\/capitalize (map (fn [[x y]] (mk-str x y)) u))\n       ]\n    (str\/join \"-\" v)\n)) ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"566859a83557837d9700001a":[{"id":16988,"user_id":492,"body":"(ns divisiblint.core)\n\n(defn get-count [n]\n  (let [strng (str n) l (count strng)\n        r (for [\n                k (range 1 l) x (range 0 (+ 1(- l k)))\n                :let [su (Integer\/parseInt (subs strng x (+ x k)))]\n                :when (and (not= su 0) (= 0 (mod n su)))\n               ]\n            su)\n       ]\n    (count r)\n  ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16989,"user_id":null,"body":"(ns divisiblint.core)\n\n(defn subseqs [n]\n   (->> n\n       str\n       ((fn [coll] (mapcat #(partition % 1 coll) (range 1 (count coll)))))\n       (map clojure.string\/join)\n       (map #(clojure.string\/replace % #\"^0+\" \"\"))\n       (remove #(zero? (count %)))\n       (map read-string)))\n\n(defn get-count [n]\n  (->> n\n    subseqs\n    (filter #(zero? (mod n %)))\n    count))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16990,"user_id":null,"body":"(ns divisiblint.core)\n\n(defn number->digits [n]\n  (->> n str (map (comp read-string str))))\n\n(defn sub-digits [n]\n  (let [digits (->> n str (map (comp read-string str)))]\n    (->> (range 1 (count digits))\n         (mapcat #(partition % 1 digits))\n         (map #(->> % (apply str) Integer\/parseInt)))))\n\n(defn get-count [n]\n  (->> (sub-digits n) (filter #(and (pos? %) (integer? (\/ n %)))) count))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16991,"user_id":null,"body":"(ns divisiblint.core)\n\n(defn number->digits [num]\n  (->> num str (map (comp read-string str))))\n\n(defn get-count [n]\n  (let [digits     (number->digits n)\n        cnt        (count digits)\n        substrings (->> (mapcat (fn [n] (partition n 1 digits)) (range 1 cnt))\n                        (remove empty?)\n                        (map (partial apply str))\n                        (map #(Integer\/parseInt %))\n                        (remove zero?))]\n    (->> (map (fn [x] (mod n x)) substrings)\n         (filter (fn [x] (zero? x)))\n         (count))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16992,"user_id":null,"body":"(ns divisiblint.core\n  (:require [clojure.string :as str]))\n\n(defn get-count [n]\n  (let [chars->num (comp (fn [s] (Integer. s)) str\/join (partial apply str))\n        c (seq (str n))\n        divisors (for [x (range 1 (count c))]\n                    (mapv chars->num (partition x 1 c)))]\n    (count (filter #(and (not= 0 %)\n                         (= (mod n %) 0)) (flatten divisors)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16993,"user_id":null,"body":"(ns divisiblint.core)\n\n(defn get-count [n]\n  (let [str-n (str n) len (count str-n)]\n    (->> (for [start (range len) end (range (inc len))\n               :when (< start end)]\n           (subs str-n start end))\n         (map #(Long\/parseLong %))\n         (remove zero?)\n         (filter #(zero? (rem n %)))\n         (count)\n         (dec))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16994,"user_id":null,"body":"(ns divisiblint.core)\n\n(defn all-subs\n  [st]\n  (let [ct (range (inc (count st)))]\n    (for [start ct\n          slice ct\n          :when (and (not= start slice) (< start slice))]\n      (subs st start slice))))\n\n(defn divisible-subs\n  [n]\n  (let [xs (map bigint (all-subs (str n)))]\n    (filter (fn [x] (and (not= x n) (pos? x) (zero? (mod n x)))) xs)))\n\n(defn get-count\n  [n]\n  (count (divisible-subs n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16995,"user_id":null,"body":"(ns divisiblint.core)\n\n(defn str-perms [n]\n  (let [strng (str n)\n        len   (count strng)]\n    (for [x (range 0 (inc len))]\n      (for [y (range x (inc len))]\n        (->> (subs strng x y))))))\n\n(defn int-perms [n]\n  (->> (str-perms n)\n       (flatten)\n       (filter #(not (= \"\" %)))\n       (map bigint)))\n\n(defn get-count [n]\n  (->> (int-perms n)\n       (filter #(not (= 0 %)))\n       (filter #(= 0 (rem n %)))\n       (count)\n       (dec)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16996,"user_id":null,"body":"(ns divisiblint.core)\n\n(defn get-subnums [num]\n  (let [len (count num)]\n    (for [x (range len)]\n      (reductions str (str) (subs num x))\n      )\n    )\n  )\n  \n(defn get-count [n]\n  (->>\n    (str n)\n    (get-subnums)\n    (flatten)\n    (map #(clojure.string\/replace % #\"^0+\" \"\"))\n    (filter #(> (count %) 0))\n    (map read-string)\n    (filter #(== 0 (rem n %)))\n    (count)\n    (dec)\n    )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16997,"user_id":null,"body":"(ns divisiblint.core\n  (:require [clojure.string :as s]))\n\n(defn get-count [n]\n  (def d-chars (s\/split (str n) #\"\"))\n  (def lengths (range 1 (count d-chars)))\n  (->> lengths\n       (mapcat #(partition % 1 d-chars))\n       (map s\/join)\n       (map #(Integer\/parseInt %))\n       (remove zero?)\n       (map #(rem n %))\n       (filter zero?)\n       (count)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"}],"5669a5113c8ebf16ed00004c":[{"id":16998,"user_id":null,"body":"(ns commonsubs.core)\n\n(defn substring_test [str1 str2]\n  (let [s1    (.toLowerCase str1)\n        s2    (.toLowerCase str2)\n        sub-s (map #(apply str %) (partition 2 1 s1))]\n    (boolean (some #(.contains s2 %) sub-s))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":16999,"user_id":492,"body":"(ns commonsubs.core)\n\n(defn substring_test [str1 str2]\n  (let [s1 (clojure.string\/lower-case str1)  s2 (clojure.string\/lower-case str2)\n        r (for [\n                i (range 0 (- (count s2) 1))\n                :let [su (subs s2 i (+ i 2))]\n                :when (.contains s1 su)\n               ]\n            su)\n       ]\n    (> (count r) 0)\n  ))\n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":17000,"user_id":53,"body":"(ns commonsubs.core)\n\n(defn substring_test [str1 str2]\n  (let [a (clojure.string\/lower-case str1) b (clojure.string\/lower-case str2)]\n    (loop [i 0]\n      (cond\n        (>= i (dec (count b))) false\n        (.contains a (subs b i (+ i 2))) true\n        :else (recur (inc i))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:32","updated_at":"2022-12-25 20:02:32"},{"id":17001,"user_id":null,"body":"(ns commonsubs.core)\n\n(defn chars-pairs [s] (map #(apply str %) (partition 2 1 (clojure.string\/lower-case s))))\n\n(defn substring_test\n  [str1 str2]\n  (let [\n      pairs1 (chars-pairs str1)\n      pairs2 (chars-pairs str2)\n      result (reduce (fn [acc it] (or acc (some #(= it %) pairs2) false)) false pairs1)\n  ] result))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17002,"user_id":null,"body":"(ns commonsubs.core)\n\n(defn substring_test [str1 str2]\n  ; your code\n  (let [s1 (set (partition 2 1 (.toLowerCase str1)))\n        s2 (partition 2 1 (.toLowerCase str2))]\n    (some? (some #(contains? s1 %) s2))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17003,"user_id":null,"body":"(ns commonsubs.core\n   (require [clojure.string :as str]))\n\n(defn substring_test [str1 str2]\n  (->> (partition 2 1 (str\/lower-case str1))\n       (map (partial apply str))\n       (some (partial str\/includes? (str\/lower-case str2)))\n       (nil?)\n       (not)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17004,"user_id":null,"body":"(ns commonsubs.core)\n\n(defn substring_test [str1 str2]\n  (let [s1 (.toLowerCase str1), s2 (.toLowerCase str2)]\n    (boolean\n      (some #(.contains s2 %)\n        (map str s1 (rest s1))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17005,"user_id":null,"body":"(ns commonsubs.core\n  (:require [clojure.set :refer [intersection]]\n            [clojure.string :refer [lower-case]]))\n\n(defn letter-touple [w]\n  (set (map list w (rest w))))\n\n(defn substring_test [w1 w2]\n  (not (empty? (intersection (letter-touple (lower-case w1))\n                             (letter-touple (lower-case w2))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17006,"user_id":null,"body":"(ns commonsubs.core\n  (:require [clojure.string :refer [lower-case]]\n            [clojure.set :refer [intersection]]))\n\n(defn substrs [s]\n  (set (map #(apply str %) (partition 2 1 s))))\n\n(defn substring_test [s1 s2]\n  (let [s1 (lower-case s1) s2 (lower-case s2)]\n    (not (empty? (intersection (substrs s1) (substrs s2))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17007,"user_id":null,"body":"(ns commonsubs.core\n  (:require [clojure.string :refer [lower-case]]\n            [clojure.set :refer [intersection]]))\n\n(defn substrs [s]\n  (set (for [i (range (dec (count s)))]\n    (subs s i (+ i 2)))))\n\n(defn substring_test [s1 s2]\n  (let [s1 (lower-case s1) s2 (lower-case s2)]\n    (not (empty? (intersection (substrs s1) (substrs s2))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"566be96bb3174e155300001b":[{"id":17008,"user_id":null,"body":"(ns ball.core)\n\n(def g 9.81)\n(defn kph->mps [kph] (* kph 0.277778))\n(defn max_ball\n  \"Return time in tenth of second of max height recorded\"\n  [v0] \n  (-> v0 kph->mps (\/ g) (* 10) Math\/round))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17009,"user_id":527,"body":"(ns ball.core)\n\n(defn max_ball [v0]\n  (Math\/round (\/ v0 3.5316)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17010,"user_id":492,"body":"(ns ball.core)\n\n(defn max_ball [v0]\n  (let [\n        g 9.81 v (\/ (* v0 1000.0) 3600.0) t (\/ v g) tm (int (* t 10))\n        h (fn [u] (- (* v u) (* 0.5 g u u)))\n        h1 (h (\/ (double tm) 10.0)) h2 (h (\/ (double (+ tm 1)) 10.0)) mx (max h1 h2)\n        r (if (= mx h1) tm (+ tm 1))\n       ]\n    r\n  ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17011,"user_id":null,"body":"(ns ball.core)\n(defn max_ball [v0]\n  (let [g 9.81\n        v0 (* v0 5\/18)\n        fh #(- (* v0 %) (* 0.05 g % %))]\n    (some #(if (> (fh %) (fh (inc %))) %) (range))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17012,"user_id":null,"body":"(ns ball.core)\n\n(defn max_ball [v0]\n  (letfn [(deci [x] (* 0.1 x))\n\n          (km-per-hr->m-per-s\n            [v]\n            (\/ (* v 1000) 60 60))\n\n          (displacement\n            [t]\n            (- (* (km-per-hr->m-per-s v0) (deci t))\n               (* 0.5 9.81 (deci t) (deci t))))]\n    (last (take-while #(> (displacement %)\n                          (displacement (dec %)))\n                      (range)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17013,"user_id":null,"body":"(ns ball.core)\n\n\n(defn max_ball [v0]\n  (letfn [(to-deci [x] (* 10 x))\n\n          (km-per-hr->m-per-s\n           [v]\n           (\/ (* v 1000) 60 60))]\n    (let [time-at-0-vel-in-sec (\/ (km-per-hr->m-per-s v0)\n                                       9.81)]\n      (Math\/round (to-deci time-at-0-vel-in-sec)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17014,"user_id":null,"body":"(ns ball.core)\n\n(defn max_ball [v0]\n  (letfn [(deci [x] (* 0.1 x))\n          \n          (km-per-hr->m-per-s \n           [v]\n           (\/ (* v 1000) 60 60))\n          \n          (displacement\n           [t]\n           (- (* (km-per-hr->m-per-s v0) (deci t)) \n              (* 0.5 9.81 (deci t) (deci t))))]\n    (let [list-of-positive-displacements\n          (map displacement \n               (take-while #(>= (displacement %) 0) (range)))]\n      (second (reduce #(if (< (first %2) (first %1))\n                         %1\n                         %2)\n                      (map list\n                           list-of-positive-displacements\n                           (range)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17015,"user_id":null,"body":"(ns ball.core)\n\n(defn height_at_t\n  \"Height of the ball at t for a given speed in km\/h\"\n  [v t]\n  (let [g 9.81       ; earth's gravity\n        s (\/ v 3.6)] ; convert speed in m\/s\n   (-(* s t) (* 0.5 g t t))))\n\n(defn max_ball\n  \"Takes a parameter v (in km per hour) and returns the time in tenth of second\n   of the maximum height recorded by the device.\"\n  [v]\n  (let [height (partial height_at_t v)]\n    (some #(when\n             (> (height (\/ % 10)) (height (\/ (inc %) 10))) %)\n          (range))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17016,"user_id":null,"body":"(ns ball.core)\n\n(defn kmh_to_ms\n  \"Convert a speed given in km\/h int m\/s\"\n  [v]\n  (\/ v 3.6))\n\n(defn height_at_t\n  \"Height of the ball at t for a given speed in m\/s\"\n  [v t]\n  (let [g 9.81]\n   (-(* v t) (* 0.5 g t t))))\n\n(defn max_ball\n  \"Takes a parameter v (in km per hour) and returns the time in tenth of second\n   of the maximum height recorded by the device.\"\n  [v]\n  (let [vms (kmh_to_ms v)]\n    (loop [maxh  0\n           i 1\n           newh (height_at_t vms (\/ i 10))]\n      (if (> maxh newh)\n        (dec i)\n        (recur newh (inc i) (height_at_t vms (\/ (inc i) 10)))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17017,"user_id":null,"body":"(ns ball.core)\n\n(defn max_ball [v0]\n  (reduce\n   (fn [prev-h t]\n    (let [ts (\/ t 10)\n          h (- (* (\/ v0 3.6) ts) (* 0.5M 9.81M ts ts))]\n      (if (< prev-h h) h (reduced (dec t)))))\n   (range)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"566efcfbf521a3cfd2000056":[{"id":17018,"user_id":null,"body":"(ns reversefun.core)\n\n(defn reverse_fun [s]\n  (->> (interleave (reverse s) s)\n       (take (count s))\n       (apply str)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17019,"user_id":null,"body":"(ns reversefun.core)\n\n(defn reverse_fun [s]\n    (apply str (take (count s) (interleave (reverse s) s))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17020,"user_id":null,"body":"(ns reversefun.core)\n\n(defn reverse_fun [s]\n  (->> (map vector (reverse s) s)\n       flatten\n       (take (count s))\n       (apply str)\n       )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17021,"user_id":492,"body":"(ns reversefun.core)\n(require '[clojure.string :as strng])\n\n(defn reverse_fun [s]\n  (if (= (count s) 1)\n    s\n    (let [ss (strng\/reverse s)]\n      (str ((vec ss) 0) (reverse_fun (subs ss 1))))\n   )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17022,"user_id":null,"body":"(ns reversefun.core\n  (:require [clojure.string :refer [join]]))\n\n(defn reverse_fun [s]\n  (let [[a b] (split-at (quot (count s) 2) s)]\n    (cond-> (join (interleave (reverse b) a))\n      (odd? (count s)) (str (first b)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17023,"user_id":null,"body":"(ns reversefun.core)\n\n(defn reverse_fun [s]\n (clojure.string\/join \"\"  \n  (loop [xs (reverse s)\n        result []]\n        (if (empty? xs)\n          result\n          (recur (reverse (rest xs)) (conj result (first xs)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17024,"user_id":null,"body":"(ns reversefun.core\n  (:require [clojure.string :as str]))\n\n(defn reverse_fun [s]\n  (let [l (take (Math\/ceil (\/ (count s) 2)) (str\/reverse s))\n        r (take (Math\/floor (\/ (count s) 2)) s)\n        res (apply str (interleave l r))]\n  (if (odd? (count s))\n    (str res (last l))\n    res)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17025,"user_id":null,"body":"(ns reversefun.core)\n\n(defn reverse_fun [s]\n  (loop [[head & tail] (reverse (seq s))\n         result []]\n    (if (not head)\n      (apply str result)\n      (recur (reverse tail) (conj result head)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17026,"user_id":null,"body":"(ns reversefun.core)\n\n(defn r-fun [acc s]\n  (let [rs (reverse s)]\n    (if (seq rs)\n      (recur (conj acc (first rs)) (next rs))\n      acc)))\n\n(defn reverse_fun [s]\n  (clojure.string\/join (r-fun [] s)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17027,"user_id":null,"body":"(ns reversefun.core)\n\n(defn reverse_fun [s]\n  (let [r (clojure.string\/reverse s)]\n    (if (empty? s)\n      s\n      (str (first r) (reverse_fun (subs r 1)))\n    )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"566fc12495810954b1000030":[{"id":17028,"user_id":null,"body":"(ns countdig.core)\n\n(defn nb_dig [n d]\n  ((->> (range (inc n))\n        (mapcat #(str (* % %)))\n        frequencies)\n   (first (str d))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17029,"user_id":null,"body":"(ns countdig.core)\n\n(defn nb_dig [n d]\n  \"Calculate number of digits d in sequence of squared n values from 0 to n (inclusive)\"\n  ((->> \n    ; generate values from 0 to n\n    (range (inc n))\n    ; sqaure all values\n    (map #(* % %))\n    ; make strings of them\n    (map str)\n    ; join all strings to single big string\n    (clojure.string\/join)\n    ; count map of frequencies of charactes \\0 .. \\9\n    (frequencies))\n    ; pick value from map (+ 48 to convert digit to ASCII representation of digit)\n    ; by converting digit as number to character\n    (char (+ d 48))))\n  \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17030,"user_id":null,"body":"(ns countdig.core)\n\n(defn nb_dig [n d]\n  (->> (inc n)\n       (range)\n       (map #(* % %))\n       (map str)\n       (filter #(clojure.string\/includes? % (str d)))\n       (map #(count (re-seq (re-pattern (str d)) %)))\n       (reduce +)))\n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17031,"user_id":null,"body":"(ns countdig.core)\n\n\n(defn digits [n]\n  (->> (iterate #(quot % 10) n)\n       (take-while #(not= 0 %))\n       (map #(mod % 10))))\n\n(defn nb_dig [n d]\n  (->> (map #(* % %) (range (inc n)))\n       (mapcat digits)\n       (cons 0)\n       (filter #(= d %))\n       count))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17032,"user_id":492,"body":"(ns countdig.core)\n\n(defn count-dig [s-n p-d]\n  (count (re-seq p-d s-n)))\n(defn nb_dig [n d]\n  (let [p-d (re-pattern (str d))\n        res (for [x (range (+ n 1) )\n                  :let [y (* x x) cnt (count-dig (str y) p-d)] \n                  :when (> cnt 0)\n                 ] \n              cnt)\n       ]\n    (reduce + res)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17033,"user_id":null,"body":"(ns countdig.core)\n\n\n(defn nb_dig\n  [n d]\n  (->> (range (+ n 1))\n    (reduce #(+ (count (re-seq (re-pattern (str d)) (str (* %2 %2)))) %1) 0)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17034,"user_id":null,"body":"(ns countdig.core)\n\n(defn digits\n  ([n] (if (zero? n) [0] (digits n 10 [])))\n  ([n base] (digits n base []))\n  ([n base accu]\n   (if (zero? n)\n     accu\n     (recur (quot n base) base (cons (mod n base) accu)))))\n\n(defn nb_dig [n d]\n  (->> (range 0 (inc n))\n       (map #(* % %))\n       (mapcat digits)\n       (filter #(= % d))\n       (count)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17035,"user_id":null,"body":"(ns countdig.core\n  (require [clojure.core.reducers :as r]))\n\n(defn count-digit [n d]\n  (count (re-seq (re-pattern (str d)) (str n))))\n\n   \n(defn nb_dig [n d]\n  (let [coll (for [x (range (inc n))] (* x x))]\n    (reduce #(+ %1 %2) 0 (r\/map #(count-digit % d) coll))))\n    \n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17036,"user_id":null,"body":"(ns countdig.core)\n\n(defn nb_dig [n d]\n  (->> (range 0 (inc n))\n       (map #(* % %))\n       (apply str)\n       (filter #(= (str %) (str d)))\n       (count)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17037,"user_id":null,"body":"(ns countdig.core)\n\n(defn nb_dig [n d]\n  (let\n    [\n     nums      (range 0 (inc n))\n     squares   (map #(* %1 %1) nums)\n     allnums   (clojure.string\/join (apply str squares))\n     dcount    (count (filter #(= (str d) (str %1)) allnums))\n  ] dcount))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5672a98bdbdd995fad00000f":[{"id":17038,"user_id":527,"body":"(ns rock-paper-scissors)\n\n(def wins #{[\"rock\" \"scissors\"] [\"scissors\" \"paper\"] [\"paper\" \"rock\"]})\n\n(defn rps [p1 p2]\n  (cond\n    (= p1 p2) \"Draw!\"\n    (wins [p1 p2]) \"Player 1 won!\"\n    :else \"Player 2 won!\"))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17039,"user_id":null,"body":"(ns rock-paper-scissors)\n\n(defn rps [p1 p2]\n  (cond\n    (= p1 p2) \"Draw!\"\n    (case [p1 p2]\n      [\"scissors\" \"paper\"] true\n      [\"paper\" \"rock\"] true\n      [\"rock\" \"scissors\"] true\n      false) \"Player 1 won!\"\n      :else \"Player 2 won!\"))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17040,"user_id":null,"body":"(ns rock-paper-scissors)\n\n(defn rps\n  [player-1 player-2]\n  (if (= player-1 player-2)\n    \"Draw!\"\n    (let [rules {:paper \"rock\" :rock \"scissors\" :scissors \"paper\"}]\n      (if (= ((keyword player-1) rules) player-2)\n        \"Player 1 won!\"\n        \"Player 2 won!\"))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17041,"user_id":3106,"body":"(ns rock-paper-scissors)\n(defn rps [p1 p2]\n(let [h {\"scissors\" \"rock\" \"rock\" \"paper\" \"paper\" \"scissors\"}]\n  (cond\n    (= p1 p2) \"Draw!\"\n    (= (get h p1) p2) \"Player 2 won!\"\n    :else \"Player 1 won!\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17042,"user_id":null,"body":"(ns rock-paper-scissors)  \n\n; Global Hash-Set of P1 winning the Game\n(def p1Wins #{[\"rock\" \"scissors\"] [\"scissors\" \"paper\"] [\"paper\" \"rock\"]})\n\n(defn rps [p1 p2]\n    (cond\n        (= p1 p2)        \"Draw!\"\n        (p1Wins [p1 p2]) \"Player 1 won!\"\n        :else            \"Player 2 won!\"\n    )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17043,"user_id":null,"body":"(ns rock-paper-scissors)\n\n(def winner \n  \"Finite State Machine to define the rules of the game\"\n  {\"rock\"     \"scissors\"\n   \"scissors\" \"paper\"\n   \"paper\"    \"rock\"})\n\n(defn rps \n  \"Find the winner of the rock paper scissors game.\n  Arguments: player choices as strings\n  Return: The result as a string\"\n[p1 p2]\n  (cond\n  (= p1 p2) \"Draw!\"\n  (= (get winner p1) p2) \"Player 1 won!\"\n  (= (get winner p2) p1) \"Player 2 won!\"\n  :else \"Are you playing rock paper scissors lizard spock?\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17044,"user_id":null,"body":"(ns rock-paper-scissors)\n\n(def rps-game-map {\"scissors\" {\"paper\" \"Player 1 won!\"\n                               \"rock\"  \"Player 2 won!\"}\n                   \"paper\"    {\"scissors\" \"Player 2 won!\"\n                               \"rock\"     \"Player 1 won!\"}\n                   \"rock\"     {\"scissors\" \"Player 1 won!\"\n                               \"paper\"    \"Player 2 won!\"}})\n\n(defn rps [p1 p2]\n  ((rps-game-map p1) p2 \"Draw!\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17045,"user_id":null,"body":"(ns rock-paper-scissors)\n\n( defn item_to_string\n[str]\n(case str\n  \"rock\" 0\n  \"paper\" 1\n  \"scissors\" 2\n  )\n)\n\n(defn return-string\n  []\n  \"just a string\"\n  )\n\n(defn calculate_game\n  [player1 player2]\n  (- (item_to_string player1) (item_to_string player2)))\n\n(defn game_Winner\n[score]\n(case score\n  -2 \"Player 1 won!\"\n  -1 \"Player 2 won!\"\n  0 \"Draw!\"\n  1 \"Player 1 won!\"\n  2 \"Player 2 won!\")\n)\n\n(defn rps [p1 p2]\n  (game_Winner (calculate_game p1 p2))\n  )\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17046,"user_id":null,"body":"(ns rock-paper-scissors)\n\n(defn rps [p1 p2]\n  (cond\n    (or\n      (and (= p1 \"rock\"    ) (= p2 \"scissors\"))\n      (and (= p1 \"scissors\") (= p2 \"paper\"   ))\n      (and (= p1 \"paper\"   ) (= p2 \"rock\"    )))\n    \"Player 1 won!\"\n    (or\n      (and (= p1 \"scissors\") (= p2 \"rock\"    ))\n      (and (= p1 \"paper\"   ) (= p2 \"scissors\"))\n      (and (= p1 \"rock\"    ) (= p2 \"paper\"   )))\n    \"Player 2 won!\"\n    (or\n      (and (= p1 \"rock\"    ) (= p2 \"rock\"    ))\n      (and (= p1 \"scissors\") (= p2 \"scissors\"))\n      (and (= p1 \"paper\"   ) (= p2 \"paper\"   )))\n    \"Draw!\"\n    )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17047,"user_id":null,"body":"(ns rock-paper-scissors)\n\n(defn rps [p1 p2]\n  (cond\n    (= p1 p2) \"Draw!\"\n    (and (= p1 \"scissors\") (= p2 \"paper\")) \"Player 1 won!\"\n    (and (= p1 \"paper\") (= p2 \"rock\")) \"Player 1 won!\"\n    (and (= p1 \"rock\") (= p2 \"scissors\")) \"Player 1 won!\"\n    :else \"Player 2 won!\"\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"56747fd5cb988479af000028":[{"id":17048,"user_id":null,"body":"(ns getmiddle.core)\n\n(defn get_middle [s]\n  (if (< (count s) 3)\n    s\n    (get_middle (subs s 1 (dec (count s))))\n))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17049,"user_id":null,"body":"(ns getmiddle.core)\n\n(defn get_middle [s]\n  (let [dead-middle (\/ (count s) 2)]\n    (if (even? (count s))\n      (subs s (dec dead-middle) (inc dead-middle))\n      (subs s dead-middle (inc dead-middle)))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17050,"user_id":null,"body":"(ns getmiddle.core)\n\n(defn get_middle [s]\n  (let [n (count s) i (quot n 2)]\n    (subs s (if (even? n) (dec i) i) (inc i))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17051,"user_id":null,"body":"(ns getmiddle.core)\n(defn get_middle [s]\n  (if (< (count s) 3)\n    s\n    (recur (apply str (rest (butlast s))))\n    ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17052,"user_id":null,"body":"(ns getmiddle.core)\n\n(defn is-even [s] (= 0 (mod (count s) 2)))\n(defn mid [s] (int (Math\/ceil (\/ (count s) 2))))\n(defn get_middle [s]\n  (if (is-even s)\n    (subs s (- (mid s) 1) (+ (mid s) 1))\n    (subs s (- (mid s) 1) (mid s)))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17053,"user_id":null,"body":"(ns getmiddle.core)\n\n(defn get_middle [s]\n  (if (> 3 (count s))\n    s\n    (recur (subs s 1 (dec (count s))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17054,"user_id":53,"body":"(ns getmiddle.core)\n\n(defn get_middle [s]\n  (let [a (quot (dec (count s)) 2)]\n    (subs s a (+ a (- 2 (mod (count s) 2))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17055,"user_id":168,"body":"(ns getmiddle.core)\n\n(defn get_middle [s]\n  (let [n (count s)]\n    (subs s (quot (dec n) 2) (quot (+ n 2) 2))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17056,"user_id":null,"body":"(ns getmiddle.core)\n\n(defn get_middle [s]\n  (let [count (count s)\n        half-1 (int (\/ (dec count) 2))\n        half+1 (- count half-1)]\n    (subs s half-1 half+1))\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17057,"user_id":null,"body":"(ns getmiddle.core)\n\n(defn get_middle [s]\n  (if (-> s\n          (count)\n          (< 3))\n    s\n    (get_middle \n      (subs s \n            1 \n            (-> s\n                (count)\n                (dec))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"567501aec64b81e252000003":[{"id":17058,"user_id":527,"body":"(ns wallpaper.core\n  (:require [clojure.pprint :refer [cl-format]]))\n\n(defn wallpaper [l w h]\n  (cl-format nil \"~R\" (-> (* 2 (+ l w) h) (* 1.15) (\/ 5.2) Math\/ceil)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17059,"user_id":492,"body":"(ns wallpaper.core)\n\n(def dict [\"zero\" \"one\" \"two\" \"three\" \"four\" \"five\" \"six\" \"seven\" \"eight\" \"nine\" \"ten\" \"eleven\" \"twelve\"\n           \"thirteen\" \"fourteen\" \"fifteen\" \"sixteen\" \"seventeen\", \"eighteen\" \"nineteen\" \"twenty\"])\n\n(defn wallpaper [l w h]\n  (if (= 0 (* l w h))\n    0\n    (let [ a (* 1.15 (\/ (* 2 h (+ l w)) 5.2)) ]\n      (dict (int (Math\/ceil a))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17060,"user_id":null,"body":"(ns wallpaper.core\n  (:require [clojure.pprint :as pprint]))\n\n(def roll-area 5.2)\n\n(defn wallpaper [l w h]\n  (let [needed-area (* (* (+ (* 2 l) (* 2 w)) h) 1.15)]\n    (->> (quot needed-area roll-area)\n         (inc)\n         (pprint\/cl-format nil \"~R\"))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17061,"user_id":null,"body":"(ns wallpaper.core)\n(def numbers [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\",\"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\"])\n(defn wallpaper [l w h]\n  (get numbers\n       (int (Math\/ceil (\/\n                        (*\n                         (+ (* l h) (* w h))\n                         1.15)\n                        2.6)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17062,"user_id":53,"body":"(ns wallpaper.core)\n\n(defn wallpaper [l w h]\n  (def nrs [\"zero\" \"one\" \"two\" \"three\" \"four\" \"five\" \"six\" \"seven\" \"eight\" \"nine\" \"ten\"\n            \"eleven\" \"twelve\" \"thirteen\" \"fourteen\" \"fifteen\" \"sixteen\" \"seventeen\", \"eighteen\" \"nineteen\" \"twenty\"])\n  (if (zero? (* l w h))\n    (nrs 0)\n    (nrs (int (Math\/ceil (\/ (* (* h (+ w l) 2.3)) 5.2))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17063,"user_id":null,"body":"(ns wallpaper.core)\n\n(def roll-length 10.0M)\n(def roll-width 0.52M)\n(def numbers [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\",\"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\"])\n\n(defn number-to-text\n  [number]\n  (get numbers number))\n\n(defn wallpaper\n  [length width height]\n  (if (= 0 (int (Math\/ceil (* length width height))))\n    (number-to-text 0)\n    (->>\n     (int (Math\/ceil (* 1.15 (\/ (* (+ length width) height 2) (* roll-width roll-length)))))\n     (number-to-text))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17064,"user_id":null,"body":"(ns wallpaper.core)\n\n(def numbers [\"zero\" \"one\" \"two\" \"three\" \"four\" \"five\" \"six\" \"seven\"\n              \"eight\" \"nine\" \"ten\" \"eleven\" \"twelve\" \"thirteen\"\n              \"fourteen\" \"fifteen\" \"sixteen\" \"seventeen\" \"eighteen\" \"nineteen\" \"twenty\"])\n\n(defn wallpaper [l w h]\n    (nth numbers\n          (Math\/ceil (\/ (* 1.15 2 h (+ w l))\n                        5.2))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17065,"user_id":null,"body":"(ns wallpaper.core)\n\n (defn wall-area [x y]\n  (* x y))\n\n(defn room-area [w l h]\n  (+ (* w h 2)\n     (* l h 2)))\n\n(defn std-roll-ara []\n  (* 0.52 10))\n\n(defn waste []\n  0.15)\n\n(defn room-area-waste-included [w l h]\n  (* (+ 1.0 (waste)) (room-area w l h)))\n\n(defn num-rolls [w l h]\n  (Math\/ceil (\/\n              (room-area-waste-included w l h)\n              (std-roll-ara))))\n\n(defn number-to-english [number]\n  (get\n   [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\",\"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\"] number))\n\n(defn wallpaper [l w h]\n  (number-to-english (int (num-rolls w l h))))\n\n\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17066,"user_id":null,"body":"(ns wallpaper.core)\n\n(def SPARE_MULTIPLIER 1.15)\n\n(def ROLL_WIDTH 0.52)\n(def ROLL_HEIGHT 10)\n(def ROLL_SQUARE (* ROLL_WIDTH ROLL_HEIGHT))\n\n(defn wallpaper [l w h]\n  (get {0   \"zero\"\n        1   \"one\"\n        2   \"two\"\n        3   \"three\"\n        4   \"four\"\n        5   \"five\"\n        6   \"six\"\n        7   \"seven\"\n        8   \"eight\"\n        9   \"nine\"\n        10  \"ten\"\n        11  \"eleven\"\n        12  \"twelve\",\n        13  \"thirteen\"\n        14  \"fourteen\"\n        15  \"fifteen\"\n        16  \"sixteen\"\n        17  \"seventeen\"\n        18  \"eighteen\"\n        19  \"nineteen\"\n        20  \"twenty\"} (int (Math\/ceil (\/ (* SPARE_MULTIPLIER 2 (+ (* l h) (* w h))) ROLL_SQUARE)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17067,"user_id":null,"body":"(ns wallpaper.core)\n\n(def num-string {0 \"zero\"\n                 1 \"one\"\n                 2 \"two\"\n                 3 \"three\"\n                 4 \"four\"\n                 5 \"five\"\n                 6 \"six\"\n                 7 \"seven\"\n                 8 \"eight\"\n                 9 \"nine\"\n                 10 \"ten\"\n                 11 \"eleven\"\n                 12 \"twelve\"\n                 13 \"thirteen\"\n                 14 \"fourteen\"\n                 15 \"fifteen\"\n                 16 \"sixteen\"\n                 17 \"seventeen\"\n                 18 \"eighteen\"\n                 19 \"nineteen\"\n                 20 \"twenty\"})\n\n(def roll-area (* 10 0.52))\n(def marginal 1.15)\n\n(defn wallpaper [l w h]\n  (let [wall-area (* h marginal (+ w l w l))\n        exact-count (\/ wall-area roll-area)]\n    (get num-string (int (Math\/ceil exact-count)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"56786a687e9a88d1cf00005d":[{"id":17068,"user_id":null,"body":"(ns validword.core)\n(use '[clojure.string :only(lower-case)])\n\n(defn validate_word [word]\n\t(apply = (vals (frequencies (lower-case word)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17069,"user_id":null,"body":"(ns validword.core\n  (:require [clojure.string :as str]))\n\n(defn validate_word [word]\n  (->> word\n    str\/lower-case\n    frequencies\n    vals\n    (apply =)))\n    ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17070,"user_id":53,"body":"(ns validword.core)\n\n(defn validate_word [word]\n  (= 1 ( ->> \n        word\n        (map clojure.string\/lower-case)\n        (frequencies)\n        (map #(second %))\n        (distinct)\n        (count)\n    )))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17071,"user_id":null,"body":"(ns validword.core\n  (:require [clojure.string :as str]))\n\n(defn validate_word [s]\n    (let [s2 (str\/lower-case s)]\n      (= 1 (count (into #{} (map second (frequencies s2)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17072,"user_id":null,"body":"(ns validword.core\n  (:require [clojure.string :as str]))\n\n(defn validate_word [word]\n  (->> word str\/lower-case (group-by identity) (map (comp count val)) (apply =)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17073,"user_id":null,"body":"(ns validword.core\n  (:require [clojure.string :as str]))\n\n(defn validate_word [word]\n  (def dst (distinct (vals (frequencies (str\/split (str\/lower-case word) #\"\")))))\n  (if (= (count dst) 1) true false)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17074,"user_id":null,"body":"(ns validword.core\n    (:require [clojure.string :as string]))\n\n\n(def validate_word\n     (comp (partial apply =)\n           vals\n           frequencies\n           string\/lower-case))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17075,"user_id":null,"body":"(ns validword.core\n  (:require [clojure.string :as str]))\n\n(defn validate_word [word]\n  (let [chars (str\/split (str\/lower-case word) #\"\")\n        total-by-char (frequencies chars)\n        distinct-vals (distinct (vals total-by-char))]\n    (if (= 1 (count distinct-vals)) true false)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17076,"user_id":null,"body":"(ns validword.core)\n\n(defn validate_word [word]\n  (= 1 (count (into #{} (vals (frequencies (clojure.string\/lower-case word)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17077,"user_id":null,"body":"(ns validword.core)\n(require '[clojure.string :as str])\n\n(defn validate_word [word]\n  (def characters (str\/split (str\/lower-case word) #\"\")) ; split word into characters\n  (def distinct-characters (distinct characters))        ; find the distinct characters\n  (def letter-counts \n    (map (fn [c] \n           (count (filter #(= % c) characters)) ; count how many of each distinct\n           ) distinct-characters)               ; character shows up in the word\n    )\n  (= 1 (count (distinct letter-counts)))  ; valid if there's only one count \n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5679aa472b8f57fb8c000047":[{"id":17078,"user_id":527,"body":"(ns findeven.core)\n\n(defn find_even_index [xs]\n  (let [\n      left-sums (reductions + xs)\n      right-sums (reverse (reductions + (rseq xs)))\n    ] (.indexOf (map = left-sums right-sums) true)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17079,"user_id":null,"body":"(ns findeven.core)\n\n(defn find_even_index [arr]\n  (let [diffs (map-indexed (fn [i v] \n    (- (reduce + (take (inc i) arr))\n       (reduce + (nthrest arr i)))) arr)]\n   (.indexOf diffs 0)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17080,"user_id":null,"body":"(ns findeven.core)\n\n(defn find_even_index [arr]\n  (let [left (conj (reductions + arr) 0)\n        right (rest (reverse (conj (reductions + (reverse arr)) 0)))]\n    (.indexOf (map = left right) true)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17081,"user_id":null,"body":"(ns findeven.core)\n\n(defn default [default val] (if (not= val nil) val default))\n\n(defn find_even_index [arr]\n  (->> (count arr)\n       (range)\n       (filter #(= (reduce + (subvec arr 0 %)) (reduce + (subvec arr (inc %)))))\n       (first)\n       (default -1))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17082,"user_id":null,"body":"(ns findeven.core)\n\n(defn find_even_index [arr]\n  (let [c (count arr)]\n    (loop [i 0]\n     (let [ls (if (zero? i) 0 (reduce + (subvec arr 0 i)))\n           rs (reduce + (subvec arr (inc i) c))]\n       (cond (= ls rs) i\n             (>= i (dec c)) -1\n             :else (recur (inc i)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17083,"user_id":492,"body":"(ns findeven.core)\n\n(defn find_even_index [arr]\n  (loop [res '(), i 0, lft 0, rgt (apply + arr), arr arr]\n     (if (empty? arr)\n       (if (empty? res)\n         -1\n         (first (reverse res)))\n       (let [[x & xs] arr\n             rgt    (- rgt x)\n             res      (if (= lft rgt) (cons i res) res)]\n         (recur res (inc i) (+ lft x) rgt xs)))))\n         \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17084,"user_id":null,"body":"(ns findeven.core)\n\n(defn find_even_index [s]                                                       \n  (let [n (count s)]                                                             \n    (or (first (filter                                                          \n             #(= (apply + (subvec s 0 %)) (apply + (subvec s (inc %) n)))        \n             (range n))) -1)))        ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17085,"user_id":null,"body":"(ns findeven.core)\n\n(defn find_even_index [arr]\n  (.indexOf (map =\n    (reductions + 0 (pop arr)) (reductions - (reduce + (next arr)) (next arr)) ) true))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17086,"user_id":null,"body":"(ns findeven.core)\n\n(defn sum-left [v index] (apply + (take index v)))\n\n(defn sum-right [v index] (apply + (take-last (- (count v) index 1) v)))\n\n(defn find_even_index [arr]\n  (or (first (filter\n           #(= (sum-left arr %1) (sum-right arr %1))\n           (range (count arr))))\n      -1))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17087,"user_id":null,"body":"(ns findeven.core)\n\n(defn find_even_index [arr]\n\t(loop [i 1]\n  \t(cond\n      (> i (count arr)) -1\n      (= (apply + (take i arr))  (apply + (take-last (- (count arr) (dec i)) arr))) (dec i)\n    \t:else (recur (inc i))\n    \n    )\n  )  \n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"567bed99ee3451292c000025":[{"id":17088,"user_id":2691,"body":"(ns kata.regex-vowel)\n(defn vowel[str]\n  (not= nil (re-matches #\"(?i)[aeiou]\" str))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17089,"user_id":null,"body":"(ns kata.regex-vowel)\n\n;; regexp? nah.\n\n(def vowels [\\a \\e \\i \\o \\u \\A \\E \\I \\O \\U])\n\n(defn vowel [o]\n  (if (and (string? o) (= 1 (count o)))\n      (true? (some #(= (first o) %) vowels))\n      false))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17090,"user_id":null,"body":"(ns kata.regex-vowel)\n(def vowels #{ \"A\" \"E\" \"I\" \"O\" \"U\" \"a\" \"e\" \"i\" \"o\" \"u\"})\n\n(defn vowel[str]\n   (contains? vowels str))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17091,"user_id":null,"body":"(ns kata.regex-vowel\n  (:require [clojure.string :as string])\n  )\n(defn vowel[str]\n(contains? #{\"a\" \"e\"  \"i\"  \"o\"  \"u\"} (string\/lower-case str))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17092,"user_id":null,"body":"(ns kata.regex-vowel\n   (:require [clojure.string :as string]))\n\n\n(defn vowel [str]\n  \n  (contains? #{:a  :e  :i  :o  :u} (keyword (string\/lower-case str)))\n\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17093,"user_id":null,"body":"(ns kata.regex-vowel)\n(defn vowel[st]\n  (boolean (and (= 1 (count st))\n                (some #(= % st) [\"a\" \"e\" \"i\" \"o\" \"u\" \"A\" \"E\" \"I\" \"O\" \"U\"]))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17094,"user_id":null,"body":"(ns kata.regex-vowel)\n\n(defn vowel [s]\n  (some? (re-matches #\"^[aeiouAEIOU]$\" s)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17095,"user_id":null,"body":"(ns kata.regex-vowel)\n(defn vowel[str]\n (if (re-matches #\"^[aeiouAEIOU]$\" str) true false)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17096,"user_id":null,"body":"(ns kata.regex-vowel)\n(defn vowel[str]\n  (.contains '(\"a\" \"e\" \"i\" \"o\" \"u\" \"A\" \"E\" \"I\" \"O\" \"U\") str)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17097,"user_id":null,"body":"(ns kata.regex-vowel)\n\n \n(defn vowel[s]\n;put code here\n      (let [x (clojure.string\/lower-case s)]\n        (if (or (= x \"a\") (= x \"e\") (= x \"i\")                   \n                (= x \"o\") (= x \"u\"))\n          true\n          false)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"567de72e8b3621b3c300000b":[{"id":17098,"user_id":null,"body":"(ns is-it-a-letter)\n\n(defn letter? [s]\n  (boolean (re-matches #\"[a-zA-Z]\" s))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17099,"user_id":null,"body":"(ns is-it-a-letter)\n\n(defn letter? [s]\n  (if (re-matches #\"^[A-Za-z]{1}$\" s)\n    true\n    false))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17100,"user_id":null,"body":"(ns is-it-a-letter)\n\n(defn letter? [s]\n  (boolean (when (= (count s) 1)\n    (Character\/is_letter (first s))\n  ))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17101,"user_id":null,"body":"(ns is-it-a-letter)\n\n(defn letter? [s]\n\t(let [s (seq s)]\n  \t(if (= 1 (count s))\n  (->> s\n      first\n      Character\/toLowerCase\n      (contains? (set \"abcdefghijklmnopqrstuvwxyz\")))\n  false))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17102,"user_id":null,"body":"(ns is-it-a-letter)\n\n(defn letter? [s]\n  (if (and (= (count s) 1) (not (= (re-matches #\"[a-zA-Z]\" s) nil))) true false)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17103,"user_id":null,"body":"(ns is-it-a-letter)\n\n(defn letter? [s]\n  (let [bt (first (.getBytes s))]\n    (if (or (< 1 (count s)) (nil? bt))\n      false\n      (if (or (and (<= 65 bt) (> 91 bt)) (and (> 123 bt) (<= 97 bt)))\n        true\n        false)))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17104,"user_id":1400,"body":"(ns is-it-a-letter)\n\n(defn letter? [s]\n  (boolean (re-matches \n   #\"[a-z]\" \n   (clojure.string\/lower-case (str s))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17105,"user_id":1400,"body":"(ns is-it-a-letter)\n\n(defn letter? [s]\n  (not (= nil (re-matches \n   #\"[a-z]\" \n   (clojure.string\/lower-case (str s)))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17106,"user_id":null,"body":"(ns is-it-a-letter (:use clojure.string))\n\n(defn letter? [s]\n  (and (== 1 (count s)) (not= (lower-case s) (upper-case s)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17107,"user_id":null,"body":"(ns is-it-a-letter)\n\n(defn letter? [s]\n  (let [not-not (comp not not)]\n    (not-not (re-matches #\"(?i)[a-z]\" s))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5680781b6b7c2be860000036":[{"id":17108,"user_id":null,"body":"(ns vowel_indices)\n\n(def vowels #{\\a \\A \\e \\E \\i \\I \\o \\O \\u \\U \\y \\Y})\n\n(defn vowel_indices\n  [word]\n  (keep-indexed #(when (vowels %2) (inc %1)) word))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-27 19:20:07"},{"id":17109,"user_id":null,"body":"(ns vowel_indices)\n\n(defn vowel_indices [word]\n\t(keep-indexed (partial #(and (%1 %3) (inc %2)) (set \"aeiouyAEIOUY\")) word))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-27 19:20:16"},{"id":17110,"user_id":null,"body":"(ns vowel_indices)\n\n(defn vowel_indices [word]\n\n  (->> word\n    (count)\n    (range)\n    (filter #((set \"aeiouyAEIOUY\") (nth word %)))\n    (map inc)\n    (apply list)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17111,"user_id":null,"body":"(ns vowel_indices)\n\n(def vowel? (into #{} \"aeiouyAEIOUY\"))\n\n(defn vowel_indices [word]\n  (->> word\n       (map-indexed (fn [i c] {:i (inc i) :c c}))\n       (filter #(-> % :c vowel?))\n       (map :i)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17112,"user_id":null,"body":"(ns vowel_indices\n  (:require [clojure.string :as str]))\n\n(def vowels #{\\a \\e \\i \\o \\u \\y})\n\n(defn vowel_indices [word]\n  (->> word\n       (str\/lower-case)\n       (keep-indexed #(when (vowels %2) (inc %1)))\n       (vec)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17113,"user_id":null,"body":"(ns vowel_indices)\n\n(def vowels #{\\a \\e \\i \\o \\u \\y \\A \\E \\I \\O \\U \\Y})\n\n(defn vowel_indices [word]\n  (keep-indexed (fn [idx item] (if (contains? vowels item) (inc idx) nil))\n    word))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17114,"user_id":null,"body":"(ns vowel_indices)\n\n(defn vowel? [ch]\n  (some #(= (Character\/toLowerCase ch) %) \"aeiouy\"))\n\n(defn vowel_indices [word]\n  (->> word\n    (map-indexed #(when (vowel? %2) (inc %1)))\n    (remove nil?)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17115,"user_id":null,"body":"(ns vowel_indices)\n\n(defn vowel_indices [word]\n  (keep-indexed #(when ((set \"aeiouyAEIOUY\") %2) (inc %1)) word))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17116,"user_id":null,"body":"(ns vowel_indices)\n\n(defn vowel_indices [word]\n  \n\t(def vowels #{\\A \\a \\E \\e \\I \\i \\O \\o \\U \\u \\Y \\y})\n  \n  (->> word\n    (count)\n    (range)\n    (filter #(vowels (nth word %)))\n    (map (partial + 1))\n    (apply list)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17117,"user_id":null,"body":"(ns vowel_indices)\n\n(defn is-english-vowel? [char]\n  (some (fn [x] (= x char)) [\\a \\i \\u \\e \\o \\y]))\n\n(defn vowel_indices [word]\n  (->>\n   (clojure.string\/lower-case word) \n   (map-indexed\n    (fn [i x]\n      (when (is-english-vowel? x)\n        (+ i 1))))\n   (filter (complement nil?))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"568d0dd208ee69389d000016":[{"id":17118,"user_id":null,"body":"(ns rentalcarcost.core)\n\n(defn rental_car_cost [d]\n  (def cost (* d 40) )\n  (cond \n    (>= d 7) (- cost 50)\n    (>= d 3) (- cost 20)\n    :else cost\n  )\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17119,"user_id":null,"body":"(ns rentalcarcost.core)\n\n(defn rental_car_cost [d]\n  (let [init (* d 40)]\n    (cond\n      (>= d 7) (- init 50)\n      (>= d 3) (- init 20)\n      :else init)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17120,"user_id":null,"body":"(ns rentalcarcost.core)\n\n;; Discounts and thresholds\n(def discount-base 0)\n(def discount-tier-one-threshold 3)\n(def discount-tier-one-value 20)\n\n(def discount-tier-two-threshold 7)\n(def discount-tier-two-value 50)\n\n;; Base cost to rent car for one day.\n(def daily-cost 40)\n\n(defn discount [days]\n\"Calculate discount to apply based on days.\"\n  (cond (>= days discount-tier-two-threshold) discount-tier-two-value\n        (>= days discount-tier-one-threshold) discount-tier-one-value\n        :else discount-base))\n\n(defn base [days]\n  \"Calculates base cost of rental for number of days.\"\n  (* daily-cost days))\n\n\n(defn rental_car_cost [days]\n  \"Returns car rental cost after applying discounts.\"\n  (- (base days) (discount days)))\n ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17121,"user_id":null,"body":"(ns rentalcarcost.core)\n\n(defn rental_car_cost [d]\n  (- (* 40 d)\n     (cond\n      (< d 3) 0\n      (< d 7) 20\n      :else 50)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17122,"user_id":null,"body":"(ns rentalcarcost.core)\n\n(defn total-price [days]\n  (* days 40))\n\n(defn apply-discount [total days]\n  (if (>= days 7)\n    (- total 50)\n    (if (>= days 3) \n      (- total 20)\n      total)))\n\n(defn rental_car_cost [days]\n  (apply-discount (total-price days) days))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17123,"user_id":null,"body":"(ns rentalcarcost.core)\n\n(defn rental_car_cost [d]\n  (cond\n    (>= d 7) (- (* 40 d) 50)\n    (>= d 3) (- (* 40 d) 20)\n    :else (* 40 d))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17124,"user_id":null,"body":"(ns rentalcarcost.core)\n\n(defn rental_car_cost [d]\n  (- (* 40 d) \n    (cond \n      (>= d 7) 50\n      (>= d 3) 20\n      :else 0)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17125,"user_id":null,"body":"(ns rentalcarcost.core)\n\n(defn rental_car_cost [d]\n  (cond-> (* d 40)\n    (>= d 3) (- 20)\n    (>= d 7) (- 30)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17126,"user_id":null,"body":"(ns rentalcarcost.core)\n\n(defn rental_car_cost [d]\n  (cond-> (* 40 d)\n    (>= d 7) (- 30)\n    (>= d 3) (- 20)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17127,"user_id":null,"body":"(ns rentalcarcost.core)\n\n(defn rental_car_cost [d]\n  (if (< d 3) (* 40 d) \n    (if (< d 7) (-(* 40 d) 20)\n      (-(* 40 d) 50))\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"568dc69683322417eb00002c":[{"id":17128,"user_id":527,"body":"(ns kata)\n\n(defn triple_x? [s]\n  (->> s (drop-while #(not= \\x %)) (take 3) (= [\\x \\x \\x])))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17129,"user_id":201,"body":"(ns kata)\n\n(defn triple_x? [s]\n  (let [m (map #(clojure.string\/index-of s %) [\"x\" \"xxx\"])]\n    (and (apply = m) (not-any? identity (map nil? m)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17130,"user_id":53,"body":"(ns kata)\n(use '[clojure.string :only [index-of]])\n\n(defn triple_x? [s]\n  (and (not (nil? (index-of s \"x\"))) (= (index-of s \"x\") (index-of s \"xxx\"))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17131,"user_id":null,"body":"(ns kata)\n\n(defn triple_x? [s]\n  (and (not= (clojure.string\/index-of s \"x\") nil) (= (clojure.string\/index-of s \"x\") (clojure.string\/index-of s \"xxx\")))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17132,"user_id":null,"body":"(ns kata)\n\n(defn triple_x? [s]\n  (let [x-found (filter #(= (str (val (first %))) \"x\") (map-indexed hash-map s))]\n    (if (> (count x-found) 2)\n      (and (=  (key (first (nth x-found 1)))  (+ 1 (key (first (nth x-found 0)))))\n           (=  (key (first (nth x-found 2)))  (+ 2 (key (first (nth x-found 0))))))\n      false\n    )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17133,"user_id":1400,"body":"(ns kata)\n\n(declare triple_x)\n\n(defn triple_x? [s]\n  (println s)\n  (if (< (count s) 3) false (triple_x s))\n)\n\n(defn triple_x [s]\n  \n  (if (= (first s) \\x)\n    (= (take 3 s) [\\x\\x\\x])\n    (triple_x? (rest s)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17134,"user_id":50,"body":"(ns kata)\n\n(defn triple_x? [s]\n  (not= nil (re-find #\"^[^x]*xxx\" s))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17135,"user_id":null,"body":"(ns kata)\n\n(defn triple_x? [s]\n  (boolean (re-matches #\"^[^x]*xxx.*\" s)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17136,"user_id":null,"body":"(ns kata)\n\n(defn triple_x? [s]\n  (<= 3 (count (first (re-seq #\"[x]+\" s)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17137,"user_id":null,"body":"(ns kata)\n\n(defn triple_x?\n  [s]\n  (let [\n    index-of-x (clojure.string\/index-of s \"x\")\n    has-x (boolean index-of-x)\n    index-of-xxx (clojure.string\/index-of s \"xxx\")\n    result (and has-x (= index-of-x index-of-xxx))\n  ] result))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"568ff914fc7a40a18500005c":[{"id":17138,"user_id":53,"body":"(ns dist2mean.core)\n\n(defn- round2 [n] (\/ (Math\/round (* n 100.0)) 100.0))\n\n(defn distances_from_average [ls]\n  (let [m (\/ (reduce + ls) (count ls))]\n    (map (fn [n] (round2 (- m n))) ls)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17139,"user_id":null,"body":"(ns dist2mean.core)\n\n(defn round\n  [n m]\n  (as->\n    n $\n    (* $ (Math\/pow 10 m))\n    (Math\/round $)\n    (float $)\n    (\/ $ (Math\/pow 10 m))\n  ))\n\n(defn distances_from_average [arr]\n  (let [\n    cnt (count arr)\n    f-sum (float (apply + arr))\n    avg (if (= cnt 0) 0. (\/ f-sum cnt))\n    result (map #(round (- avg %) 2) arr)\n  ] result))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17140,"user_id":168,"body":"(ns dist2mean.core)\n\n(defn roundTo2 [n] (\/ (Math\/round (* n 100.0)) 100.0))\n\n(defn distances_from_average [arr]\n  (let [m (\/ (reduce + arr) (count arr))]\n    (map #(roundTo2 (- m %)) arr)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17141,"user_id":null,"body":"(ns dist2mean.core)\n\n(defn distances_from_average [arr]\n  (let [avg (\/ (apply + arr) (count arr))]\n    (map #(->> (- avg %) double (format \"%.2f\") read-string) arr)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17142,"user_id":null,"body":"(ns dist2mean.core)\n\n(defn roundTo2 [n] (\/ (Math\/round (* n 100.0)) 100.0))\n\n(defn distances_from_average [arr]\n  (let [average (\/ (reduce + 0 arr ) (count arr))]\n  (map roundTo2 (map #(- average %) arr)))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17143,"user_id":null,"body":"(ns dist2mean.core)\n(defn roundTo2 [n] (\/ (Math\/round (* n 100.0)) 100.0))\n(defn distances_from_average [arr]\n  (let \n    [ sum (apply + arr) \n      n (count arr) \n      avg (\/ sum n)\n      dist-l (map (fn [n] (roundTo2 (- avg n))) arr)]\n    (apply vector dist-l)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17144,"user_id":null,"body":"(ns dist2mean.core)\n\n(defn roundTo2 [n] (\/ (Math\/round (* n 100.0)) 100.0))\n\n(defn distances_from_average [arr]\n   (let [avg (double (\/ (apply + arr) (count arr)))]\n     (->> \n      arr\n      (map #(- avg %))\n      (map roundTo2))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17145,"user_id":null,"body":"(ns dist2mean.core)\n\n(defn round-to-2 [n]\n  (\/ (Math\/round (* n 100.0)) 100.0))\n\n(defn average [arr]\n  (\/ (reduce + arr) (count arr)))\n\n(defn distances_from_average [arr]\n  (->> arr\n       (map (partial - (average arr)))\n       (map round-to-2)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17146,"user_id":null,"body":"(ns dist2mean.core)\n\n(defn roundTo2 [n] (\/ (Math\/round (* n 100.0)) 100.0))\n\n(defn av [arr]\n  (roundTo2 (\/ (apply + arr) (count arr))))\n\n(defn distances_from_average [arr]\n  (def arav (av arr))\n  (map roundTo2 (map (fn [x] (- arav x))\n       arr)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17147,"user_id":null,"body":"(ns dist2mean.core)\n(defn distances_from_average [arr]\n  (def m (float (\/ (reduce + arr) (count arr))))\n  (map #(\/ (Math\/round (* (- m %) 100)) 100.0) arr))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"569218bc919ccba77000000b":[{"id":17148,"user_id":492,"body":"(ns dateamount.core)\n\n(def ft (java.text.SimpleDateFormat. \"yyyy-MM-dd\"))  \n(def ^:const st (.getTime (.parse ft \"2016-01-01\")))\n(defn date-nb-days-aux [n]\n  (.format ft\n    (java.util.Date. (+ (* n 86400 1000) \n                        st))))\n(defn date-nb-days [a0 a p]\n  (let [\n        r1 (Math\/log(\/ a (double a0)))\n        r2 (Math\/log(+ 1 (\/ p 36000.0)))\n        r  (int (Math\/ceil (\/ r1 r2)))\n       ]\n    (date-nb-days-aux r)))\n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17149,"user_id":null,"body":"(ns dateamount.core)\n\n(defn format-date [d]\n  (.format (java.text.SimpleDateFormat. \"yyyy-MM-dd\") d))\n\n(defn date-nb-days [a0 a p]\n  (let [money-seq (iterate #(* % (+ 1 (\/ p 36000.0))) a0)\n        days (count (take-while #(< % a) money-seq))\n        start-date (java.util.GregorianCalendar. 2016 00 01)]\n    (.add start-date java.util.GregorianCalendar\/DATE days)\n    (format-date (.getTime start-date))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17150,"user_id":null,"body":"(ns dateamount.core)\n\n(defn date-nb-days [a p r]\n  (let [daily-interest (\/ r (double 36000))]\n    (loop [t a\n           i 0]\n      (if (>= t p)\n        (-> (java.time.LocalDate\/parse \"2016-01-01\") (.plusDays i) str)\n        (recur (+ t (* daily-interest t)) (inc i))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17151,"user_id":null,"body":"(ns dateamount.core)\n\n(defn date-nb-days [a0 a p]\n  (->>\n   (iterate #(+ % (* (\/ (\/ p 360.00) 100) %)) a0)\n   (take-while #(< % a))\n   (count)\n   (.plusDays (java.time.LocalDate\/of 2016 01 01))\n   (.toString)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17152,"user_id":null,"body":"(ns dateamount.core)\n\n(defn days [a0 a p]\n  (-> (Math\/log (\/ a a0))\n      (\/ (Math\/log (+ 1 p)))\n      (Math\/ceil)\n      (int)))\n\n(defn date-plus-days [date days]\n  (-> (. java.time.LocalDate parse date)\n      (.plusDays days)\n      (.toString)))\n\n(defn date-nb-days [a0 a p]\n  (date-plus-days \"2016-01-01\" (days a0 a (\/ p 36000))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17153,"user_id":null,"body":"(ns dateamount.core)\n\n(defn date-nb-days\n  ([a0 a p]\n   (let [c           (java.util.GregorianCalendar. 2016 0 1)\n         _           (.setTimeZone c (java.util.TimeZone\/getTimeZone \"GMT\"))\n         parsed-date (\/ (.getTime (.getTime c)) 100000)]\n     (date-nb-days a0 a (+ 1 (\/ p 36000)) (Math\/pow (+ 1 (\/ p 36000)) 360.0) parsed-date)))\n  ([a0 a p py d]\n   (loop [an  a0\n          dy  d]\n     (if (<= an (* an py) a)\n       (recur (* an py) (+ dy (* 360 864)))\n       (loop [ad an\n              dn dy]\n         (if (<= ad a)\n           (recur (* ad p) (+ dn 864))\n           (.format (java.text.SimpleDateFormat. \"YYYY-MM-dd\") (* dn 100000))))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17154,"user_id":null,"body":"(ns dateamount.core)\n\n;; I REALLY wanted to solve using this function, but something was wrong with the calculation\n;; A = P (1 + rate\/n) ^ (nt)\n;; (defn to-amount [principle rate t]\n;;   (println rate)\n;;   (->   rate\n;;         (\/ 365)\n;;         inc\n;;         (Math\/pow (* 365 t))\n;;         (* principle)\n      \n;;   )\n;; )\n\n(defn to-amount [rate current-amount]\n  (->   rate\n        (\/ 360)\n        (* current-amount)\n        (+ current-amount)\n  )\n)\n\n(defn add-days [days]\n  (-> (java.time.LocalDate\/parse \"2016-01-01\")\n      (.plusDays days)\n      str\n  )\n)\n\n(defn date-nb-days [principle target rate]\n  (let [get-amount (partial to-amount (\/ rate 100.0))]\n    (loop [\n      day 0\n      currentAmount principle]\n      (if (>= currentAmount target)\n        (add-days day)\n        (recur (inc day) (get-amount currentAmount))\n      ))\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17155,"user_id":null,"body":"(ns dateamount.core)\n\n(defn log [x] (Math\/log x))\n\n(def sdate 1451606400000) ; \"2016-01-01\"\n\n(defn date-nb-days [a0 a p]\n  (def k (+ 1 (\/ p 100 360)))\n  (def dt (long (* 86400 1000  ; sec per day, ms in s\n    (\/ (log (\/ a a0)) \n       (log k)))))\n  (def edate (+ sdate dt 86399999)) ; ceil to next day\n  (.format (java.text.SimpleDateFormat. \"yyyy-MM-dd\") (java.util.Date. edate)) ; ugly java interop\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17156,"user_id":null,"body":"(ns dateamount.core\n  (:import (java.time LocalDate format.DateTimeFormatter)))\n  \n(defn days [a0 a p]\n  (Math\/ceil\n   (\/ (Math\/log (\/ a a0))\n      (Math\/log (+ 1 (\/ p 36000))))))\n\n(def formatting  (DateTimeFormatter\/ofPattern \"yyyy-MM-dd\"))\n\n(defn date-nb-days [a0 a p]\n  (.format (.plusDays (LocalDate\/parse \"2016-01-01\" formatting)\n                      (days a0 a p))\n           formatting))\n           ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17157,"user_id":null,"body":"(ns dateamount.core)\n(defn date-nb-days [a0 a p]\n  (let [;calculate log of the interest needed to reach target\n        target_rate (-> a\n                      ;what's the interest needed\n                      (\/ ,,, (double a0))\n                      ;get the log of interest needed\n                      (Math\/log ,,,))\n  \n        ;caculate log of daily interest\n        daily_rate (-> p\n                    ;what's the daily interest\n                     (\/ ,,, 36000.0)\n                     ;convert to actual interest ie 2% = 102%\n                     (inc ,,,)\n                     ;get the log of actual daily interest\n                     (Math\/log ,,,))\n        \n        ;calculate how many whole days are needed to reach the goal\n        days_needed (-> target_rate\n                      ;find days needed\n                      (\/ ,,, daily_rate)\n                      ;round up to whole days\n                      (Math\/ceil ,,,)\n                      ;coerce to int\n                      (int ,,,))]\n        \n        ;return the date when target is reached\n        (-> \"2016-01-01\"\n          ;parse initial date\n          (java.time.LocalDate\/parse ,,,)\n          ;add the days needed\n          (.plusDays ,,, days_needed)\n          ;make it a string\n          (str ,,,))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"569b5cec755dd3534d00000f":[{"id":17158,"user_id":null,"body":"(ns newaverage.core)\n\n(defn- output [n]\n  (int (Math\/ceil n)))\n\n(defn new-avg [arr navg]\n  (let [sum   (apply + arr)\n        len   (count arr)\n        n     (- (* navg (inc len)) sum)]\n    (cond\n      (<= n 0) (throw (IllegalArgumentException. \"\"))\n      :else    (output n))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17159,"user_id":null,"body":"(ns newaverage.core)\n\n(defn new-avg [arr navg]\n  (let [x (int (Math\/ceil (- (* navg (+ (count arr) 1)) (reduce + arr))))]\n    (if (>= x 0) x (throw (IllegalArgumentException. \"invalid_argument\")))\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17160,"user_id":null,"body":"(ns newaverage.core)\n\n(defn new-avg [arr navg]\n  (-> arr\n       (count)\n       (inc)\n       (* navg)\n       (- (apply + arr))\n       (Math\/ceil)\n       (int)\n       (#(if (neg? %) (throw (IllegalArgumentException. \"\")) %))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17161,"user_id":53,"body":"(ns newaverage.core)\n\n(defn new-avg [arr u]\n  (let [s (reduce + arr)\n        n (count arr)\n        x (- (* u (inc n)) s)]\n    (if (<= x 0) \n      (throw (IllegalArgumentException. \"no negative donation please\"))\n      (int (Math\/ceil x)))\n  ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17162,"user_id":492,"body":"(ns newaverage.core)\n\n(defn new-avg [arr navg]\n  (let [sm (reduce + arr) l (count arr) add (int (Math\/ceil (- (* (+ 1 l) navg) sm)))]\n    (if (<= add 0)\n      (throw (IllegalArgumentException. \"Expected New Average is too low\"))\n      add)))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17163,"user_id":null,"body":"(ns newaverage.core)\n\n(defn round-up [x]\n  (int (Math\/ceil x)))\n\n(defn new-avg [arr navg]\n  (let [result (-> (count arr)\n                   (+ 1)\n                   (* navg)\n                   (- (reduce + arr))\n                   (round-up))]\n    (if (< result 0)\n      (throw (IllegalArgumentException.))\n      result)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17164,"user_id":null,"body":"(ns newaverage.core)\n\n(defn new-avg [arr navg]\n  (let [erg (- (* navg (+ (count arr) 1))\n               (+ (reduce + arr)))]\n        (if (<= erg 0)\n            (throw (IllegalArgumentException.))\n            (int (Math\/ceil erg)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17165,"user_id":null,"body":"(ns newaverage.core)\n\n(defn new-avg [arr navg]\n  (let [n (count arr)\n        sum (reduce + arr)\n        donation (- (* navg (inc n)) sum)]\n    (if (< donation 0)\n      (throw (IllegalArgumentException. \"https:\/\/www.youtube.com\/watch?v=dQw4w9WgXcQ\"))\n      (-> donation Math\/ceil int))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17166,"user_id":718,"body":"(ns newaverage.core)\n\n(defn new-avg [arr navg]\n  (def ans (int (Math\/ceil (- (* navg (inc (count arr))) (reduce + arr)))))\n  (if (pos? ans) ans (throw (IllegalArgumentException.)))\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17167,"user_id":null,"body":"(ns newaverage.core)\n\n(defn new-avg [arr navg]\n  (let [sum (apply + arr)\n        n (count arr)\n        next (- (* navg (+ n 1))\n                sum)]\n    (if (>= next 0)\n      (-> next Math\/ceil int)\n      (throw (IllegalArgumentException. \"Impossible\")))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"56a127b14d9687bba200004d":[{"id":17168,"user_id":492,"body":"(ns kata.grid-path)\n\n(defn choose [n p]\n  (if (> p n)\n    0\n    (let [p (min p (- n p)) rprod (fn [a b] (reduce * (range (biginteger a) (inc (biginteger b)))))]\n      (\/ (rprod (- n p -1) n) (rprod 1 p)))))\n(defn number_of_routes [m n]\n  (choose (+ m n) n)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17169,"user_id":null,"body":"(ns kata.grid-path)\n\n(defn fact [s e]\n  (reduce * (range (biginteger s) (biginteger (inc e))))\n  )\n(defn number_of_routes [m n]\n  (\/ (fact (inc n) (+ n m)) (fact 1 m))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17170,"user_id":null,"body":"(ns kata.grid-path)\n\n(defn binom [n k]\n  (let [fact #(apply *' (range 1 (inc %)))]\n    (\/ (fact n)\n       (* (fact k) (fact (- n k))))))\n\n(defn number_of_routes [n k]\n  (binom (+' n k) k))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17171,"user_id":null,"body":"(ns kata.grid-path)\n\n(defn fact [x]\n  (apply * (range 1N (inc x))))\n\n(defn number_of_routes [m n]\n  (\/ (fact (+ m n)) (fact m) (fact n)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17172,"user_id":null,"body":"(ns kata.grid-path)\n\n(defn number_of_routes [m n]\n  (let [p (max m n) q (min m n)]\n    (reduce * 1 (map \/ (range (inc p) (+ 1 p q)) (range 1 (inc q))))\n  )  \n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17173,"user_id":null,"body":"(ns kata.grid-path)\n\n(defn factorial [n]\n  (reduce * (range (bigint 2) (+ (bigint n) 1))))\n\n(defn number_of_routes [m n]\n  (\/ (factorial (+ m n)) (* (factorial m) (factorial n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17174,"user_id":1670,"body":"(ns kata.grid-path)\n\n(defn number_of_routes [m n]\n  ( \/\n    (reduce *' (range 1 (+ m n 1)))\n    (* \n      (reduce *' (range 1 (inc m)))\n      (reduce *' (range 1 (inc n)))\n    )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17175,"user_id":1258,"body":"(ns kata.grid-path)\n\n(defn factorial [n]\n  (reduce *' (range 1N (inc n))))\n\n(defn combination [a b]\n  (\/ (factorial a) (*' (factorial b) (factorial (- a b)))))\n\n(defn number_of_routes [m n]\n  (combination (+ m n) n))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17176,"user_id":null,"body":"(ns kata.grid-path)\n\n;; rruru ~> rrruu\n;;          ^^^ 3 (=n) rights\n;;             ^^ 2 (=m) ups\n;; So, how many ways can we rearrange r xn and u xm characters?\n;; r1 r2 ... rn, u1, u2, ... um\n;; n + m total objects so there are (n + m)! ways of arranging them\n;; but we overcount, there are n! ways of arranging the rs and\n;; there are m! ways of arranging the us so\n;; => (n + m)! \/ m! n! = C(n, m) \n\n(defn fac [n]\n  (reduce *' (range 1 (inc n))))\n\n(defn number_of_routes [m n]\n  (\/ (fac (+ n m))\n     (*' (fac n) (fac m))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17177,"user_id":null,"body":"(ns kata.grid-path)\n\n(defn fac [n]\n  (reduce *' (range 1 (inc n))))\n\n(defn number_of_routes [m n]\n  (\/ (fac (+ m n))\n     (*' (fac n) (fac m))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"56a32dd6e4f4748cc3000006":[{"id":17178,"user_id":null,"body":"(ns rainfall.core\n  (:require [clojure.string :refer [split split-lines]]))\n  \n(defn parse-pair [pair-string]\n  (-> pair-string\n      (split #\" \")\n      (update-in [1] #(Float\/parseFloat %1))))\n  \n(defn parse-city [[city values-string]]\n  [city (into {} (->> (split values-string #\",\")\n                      (map parse-pair)))])\n  \n(defn parse-data [data]\n  (->> data\n       (split-lines)\n       (map (comp parse-city #(split %1 #\":\")))\n       (into {})))\n       \n(defn get-values [town data]\n  (-> data\n      (parse-data)\n      (get town)\n      (vals)))\n       \n(defn mean-values [values]\n  (if (= (count values) 0)\n    -1\n    (\/ (apply + values) (count values))))\n       \n(defn mean [town data] \n  (mean-values (get-values town data)))\n  \n(defn variance [town data] \n  (let [values (get-values town data)\n        mean (mean-values values)\n        squared-deviations (map #(Math\/pow (- %1 mean) 2) values)]\n    (mean-values squared-deviations)))","lang_id":5,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17179,"user_id":null,"body":"(ns rainfall.core)\n\n(defn pre-precess-data [data]\n  (->> (clojure.string\/split data #\"\n\")\n       (map (fn [itm]\n              (let [idx (.indexOf itm \":\")\n                    cty (subs itm 0 idx)\n                    d (->> (subs itm (inc idx))\n                           (re-seq #\"\\d+\\.+\\d+\")\n                           (map #(Double\/parseDouble %)))]\n                [(clojure.string\/trim cty) d])))\n       (into {})))\n       \n(defn mean [twn data]\n  (or (some->> (pre-precess-data data)\n               (#(get % twn))\n               ((fn [ns] (\/ (apply + ns) (count ns)))))\n      -1))\n\n(defn variance [twn data]\n  (or (some->> (pre-precess-data data)\n               (#(get % twn))\n               ((fn [ns] (let [m (mean twn data)]\n                          (->> ns\n                               (map #(Math\/pow (- % m) 2))\n                               (reduce +)\n                               (#(\/ % (count ns))))))))\n      -1))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17180,"user_id":492,"body":"(ns rainfall.core)\n\n(defn findTownNb [twn strng]\n  (let [arr (clojure.string\/split strng #\"\n\")\n        fnd (vec (filter (fn[y] (= (y 0) twn)) (map (fn [x] (clojure.string\/split x #\":\")) arr)  ))\n        ; array of \"mth rainfall\"\n        mthnb (if (not= fnd []) (clojure.string\/split ((first fnd) 1) #\",\") [])\n        ; array of rainfall as double\n        dbl (map (fn [x] (read-string ((clojure.string\/split x #\" \") 1))) mthnb)\n       ]\n    dbl))\n(defn mean [twn strng] \n  (let [r (findTownNb twn strng)]\n    (if (seq r)\n      (\/ (reduce + r) 12.0)\n      -1))) \n(defn variance [twn strng] \n  (let [r (map (fn [x] (* x x))(findTownNb twn strng))\n        m (mean twn strng) \n       ]\n    (if (seq r)\n      (- (\/ (reduce + r) 12.0) (* m m))\n      -1))) \n\n","lang_id":5,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17181,"user_id":null,"body":"(ns rainfall.core)\n\n(require '[clojure.string :as str])\n\n(defn get-data [t s]\n  (->>(str\/split-lines s)\n    (filter #(str\/includes? % t))\n    (first)\n    (re-seq #\"\\d+\\.*\\d*\" )\n    (map #(Double\/parseDouble %))\n  )\n)\n\n(defn mean [twn strng] \n  (try\n    (let [d (get-data twn strng)\n          n (count d)]\n      (\/ (reduce + d) n))\n    (catch Exception e -1.0))\n) \n(defn variance [twn strng] \n  (try\n    (let [avg (mean twn strng)\n          d (get-data twn strng)\n          n (count d)] \n        (->>(map #(- % avg) d)\n          (map #(\/ (* % %) n))\n          (reduce +)\n    ));)\n    (catch Exception e -1.0))\n) \n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17182,"user_id":null,"body":"(ns rainfall.core (:require [clojure.string :as str]))\n\n(defn abs [n] (max n (- n)))\n\n(defn town-values [twn strng]\n  (->> strng\n       (re-find (re-pattern (str twn #\":.*\n?\")))\n       (str \"\")\n       (re-seq #\"\\d+\\.\\d+\")\n       (mapv #(Float\/parseFloat %) )))\n\n(defn v-mean [v] (if (empty? v) -1 (\/ (apply + v) (count v))))\n\n(defn mean [twn strng]\n  (v-mean (town-values twn strng)))\n  \n(defn variance [twn strng]\n  (let [v   (town-values twn strng)\n        m   (v-mean v)\n        dev (vec (map #(* % %) (map #(abs (- m %)) v)))]\n        (v-mean dev)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17183,"user_id":null,"body":"(ns rainfall.core\n  (require [clojure.string :as str]))\n\n(defn recurse [map1 arr]\n  (if (>= (count arr) 2)\n    (recurse (assoc map1 (first arr) (second arr)) (rest (rest arr)) )\n    map1\n    )\n  )\n\n(defn recurseSum [sum arr]\n  (if (first arr)\n    (recurseSum (+ sum (Float\/parseFloat (first arr))) (rest arr)) \n    sum\n    )\n  )\n\n\n(defn mean [twn strng] \n  (if (str\/includes? strng twn)\n  (let [ar (str\/split strng #\"[:\n]\")\n        map1 (recurse {} ar)\n        town (get map1 twn)\n        nums (re-seq #\"[-+]?[0-9]*\\.?[0-9]+\" town)\n        numslen (count nums)\n        sum (recurseSum 0 nums)]\n      (\/ sum numslen)\n    ) \n    -1)\n  ) \n\n(defn square [x] \n   (* x x)\n  )\n\n(defn recurseVar [ar2 arr mean]\n  (if (some? (first arr))\n    (recurseVar (conj ar2  (square (- (Float\/parseFloat (first arr)) mean))) \n                (rest arr) mean) \n    ar2\n    )\n  )\n\n(defn variance [twn strng] \n  (if (str\/includes? strng twn)\n  (let [ar (str\/split strng #\"[:\n]\")\n        map1 (recurse {} ar)\n        town (get map1 twn)\n        nums (re-seq #\"[-+]?[0-9]*\\.?[0-9]+\" town)\n        numslen (count nums)\n        mean (mean twn strng)\n        ar2 (recurseVar [] nums mean)]\n      (\/ (reduce + ar2) numslen)\n    )\n    -1)\n  ) ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17184,"user_id":null,"body":"(ns rainfall.core\n  (:require [clojure.string :as str]))\n\n(defn parse-data\n  [s]\n  (reduce\n   (fn [m ln]\n     (let [[city data] (str\/split ln #\":\")\n           rain-vals   (->> data\n                            (re-seq #\"[\\d\\.]+\")\n                            (mapv #(Double\/parseDouble %))\n                            (remove zero?))]\n       (assoc m city rain-vals)))\n   {}\n   (str\/split s #\"\n\")))\n\n(defn average\n  [c]\n  (double\n    (if (empty? c)\n      0\n      (\/ (reduce + c) (count c)))))\n\n(defn mean [twn strng] \n  (let [parsed-data (parse-data strng)]\n    (if-not (contains? parsed-data twn)\n      -1\n      (let [nums (get parsed-data twn)]\n        (average nums)))))\n\n(defn sqr\n  [x n]\n  (reduce * (repeat n x)))\n\n(defn variance [twn strng]\n  (let [parsed-data (parse-data strng)]\n    (if-not (contains? parsed-data twn)\n      -1\n      (let [nums        (get parsed-data twn)\n            twn-mean    (average nums)\n            sq-diffs    (mapv #(sqr (- % twn-mean) 2) nums)]\n        (average sq-diffs)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17185,"user_id":null,"body":"(ns rainfall.core\n  (:require [clojure.string :as str]))\n\n(defn valid-town? [twn strng] (str\/includes? strng twn))\n\n(defn get-town-data [twn strng]\n  (map #(Double. %)\n       (-> (first (filter #(str\/starts-with? % twn) (str\/split strng #\"\n\")))\n           (str\/replace #\"[A-Za-z: ]\" \"\")\n           (str\/split #\",\"))))\n\n(defn square [x] (* x x))\n\n(defn avg [data]\n  (\/ (reduce + data) (count data)))\n\n(defn mean [twn strng]\n  (if (valid-town? twn strng)\n      (avg (get-town-data twn strng))\n      -1.0))\n\n(defn variance [twn strng] \n  (if (valid-town? twn strng)\n      (let [town-data (get-town-data twn strng)]\n        (avg (map #(square (- % (avg town-data))) town-data)))\n      -1.0))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17186,"user_id":null,"body":"(ns rainfall.core)\n\n(defn mapify\n  \"Transform a string of data into a map.\n   Entries are split by '\n'.\n   Keys are split from values at ':'.\"\n  [entries]\n  (apply array-map (clojure.string\/split entries #\":|\n\")))\n\n(defn nums\n  \"Return a coll of numbers from a Month Num comma separated data string.\"\n  [s]\n  (->> (clojure.string\/split s #\" |,\")\n       (apply array-map)\n       (vals)\n       (map #(Float\/parseFloat %))))\n\n(defn average\n  \"Returns the simple average of the coll of numbers.\"\n  [coll]\n  (\/ (reduce + coll) (count coll)))\n\n(defn extract-nums\n  \"Extract the numbers for a given twn name.\"\n  [twn strng]\n  (some-> (mapify strng)\n          (get twn)\n          (nums)))\n\n(defn mean\n  \"Return the average rainfall for the `twn` in the `strng` data.\n   Returns -1 if there is no record for the given `twn`.\"\n  [twn strng]\n  (let [n (extract-nums twn strng)]\n    (if-not (empty? n)\n      (average n)\n      -1)))\n\n(defn variance\n  \"Return the variance of rainfall for the `twn` in the `strng` data.\n   Returns -1 if there is no record for the given `twn`.\"\n  [twn strng]\n  (let [n (extract-nums twn strng)]\n    (if-not (empty? n)\n      (as-> (average n) avg\n            (map #(Math\/pow (- % avg) 2) n)\n            (average avg))\n      -1)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17187,"user_id":null,"body":"(ns rainfall.core\n  (:require [clojure.string :refer [split starts-with?]]))\n\n(defn sqr [x] (* x x))\n(defn averagize [x] (\/ x 12))\n\n(defn validate-middleware [f]\n  (fn [town data]\n    (or (some->> (split data #\"\n\")\n          seq\n          (filter #(starts-with? % (str town \":\")))\n          first\n          ((fn [s] (split s #\",\")))\n          (map #(re-find (re-matcher #\"\\w{3} (\\d+\\.\\d)\" %)))\n          (map second)\n          (map #(Float\/parseFloat %))\n          f)\n        -1)))\n\n(defn mean-town [data]\n  (->> data\n    (apply +)\n    averagize))\n(defn variance-town [data]\n  (->> data\n    (reduce (fn [[s s2] x] [(+ s x) (+ s2 (* x x))]) [0. 0.])\n    ((fn [[sum sum2]] [(averagize sum) (averagize sum2)]))\n    ((fn [[asum asum2]] (- asum2 (sqr asum))))))\n\n(def mean (validate-middleware mean-town))\n(def variance (validate-middleware variance-town))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"56a4872cbb65f3a610000026":[{"id":17188,"user_id":null,"body":"(ns maxrot.core)\n\n(defn max_rot [n]\n  ; your code\n  (let [num (str n)\n        cou (count num)]\n    (loop [index 0\n           s num\n           list []]\n      (if (< index (dec cou))\n        (let [ss (str (subs s 0 index) (subs s (inc index) cou) (subs s index (inc index)))]\n        (recur (inc index)\n               ss\n               (conj list (Long\/parseLong ss))))\n       (apply max (conj list n))))))\n\n\n\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17189,"user_id":492,"body":"(ns maxrot.core)\n\n(defn max_rot-aux [s keep mx]\n  (defn- rotate [[h & t]] (reduce str (conj (vec t) h)))\n  (if (= 1 (count s))\n    mx\n    (let [\n        ss (rotate s)\n        res (str keep (first ss))\n        st (subs ss 1)\n        nb (bigint (str res st))\n        m (if (> nb mx) nb mx)\n       ]\n      (max_rot-aux st res m)\n  )))\n(defn max_rot [n] (max_rot-aux (str n) \"\" n))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17190,"user_id":null,"body":"(ns maxrot.core)\n\n(defn nth-to-tail [n s]\n  (concat (concat (take n s)\n                  (drop (inc n) s))\n          [(nth s n)]))\n\n(defn max_rot [n]\n  (->> (iterate (juxt (comp inc first) (partial apply nth-to-tail))\n                [0 (seq (str n))])\n       (take (count (str n)))\n       (map second)\n       (map (comp bigint (partial apply str)))\n       (apply max)))\n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17191,"user_id":null,"body":"(ns maxrot.core)\n\n(defn- rotate-left [xs]\n  (str (subs xs 1) (get xs 0)))\n\n(defn- parse-long [s]\n  (Long. (re-find  #\"\\d+\" s)))\n\n(defn- get-values [xs cnt acc]\n  (cond\n    (= (count xs) cnt) acc\n    (= cnt 0) (get-values (rotate-left xs) (inc cnt) (conj acc xs))\n    :else (get-values (str (subs xs 0 cnt) (rotate-left (subs xs cnt))) (inc cnt) (conj acc xs))))\n\n(defn max_rot [n] \n  (->> (get-values (str n) 0 (empty []))\n       (map parse-long)\n       (reduce max))\n    )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17192,"user_id":null,"body":"(ns maxrot.core)\n\n(defn rotate-left [pivot-indx str-num]\n  (let [count-str (count str-num)\n        front (->> (take pivot-indx str-num)\n                   (apply str))\n        pivot-val (str (get str-num pivot-indx))\n        rear (->> (take-last (- count-str pivot-indx) str-num)\n                  (rest)\n                  (apply str))]\n    (clojure.string\/join \"\" `(~front ~rear ~pivot-val))))\n\n(defn get-all-rotations [n]\n  (let [str-n (str n)\n        count-n (count str-n)]\n\n    (loop [num str-n\n           result [str-n]\n           iter 0]\n      (let [rotated-str (rotate-left iter num)]\n        (if (>= (inc iter) count-n)\n          result\n          (recur rotated-str\n                 (conj result rotated-str)\n                 (inc iter)))))))\n\n(defn max_rot [n]\n  (->> (get-all-rotations n)\n       (map #(Long\/valueOf %))\n       (apply max)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17193,"user_id":null,"body":"(ns maxrot.core)\n\n(defn number->digits [numb]\n  (loop [n numb res []]\n    (cond\n      (< n 10) (conj res n)\n      :else (recur (quot n 10) (conj res (mod n 10))))))\n\n(defn rotate [lst]\n  (concat (vector (last lst)) (butlast lst)))\n\n(defn next-step [[ind digs]]\n  (let [N (count digs)\n        [lft right] (split-at (- N ind) digs)]\n    [\n     (inc ind)\n     (concat (rotate lft) right)\n    ]))\n\n(defn digits->number [digs]\n  (apply + (map * (iterate #(* % 10) 1) digs)))\n\n(defn get-rotates [n]\n  (let [digs (number->digits n)\n        cnt (count digs)\n        step-sequence (iterate next-step [0 digs])\n        steps (take cnt step-sequence)]\n    (map #(digits->number (second %)) steps)))\n\n(defn max_rot [n]\n  (->> n\n       get-rotates\n       (apply max)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17194,"user_id":null,"body":"(ns maxrot.core)\n\n(defn rotate-digits\n  ([n]\n   (rotate-digits (str n) 0))\n  ([s i]\n   (when (< i (count s))\n     (lazy-seq\n      (cons\n       (Long\/parseLong s)\n       (rotate-digits\n        (str (subs s 0 i) (subs s (inc i)) (subs s i (inc i)))\n        (inc i)))))))\n\n(defn max_rot [n]\n  (apply max (rotate-digits n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17195,"user_id":null,"body":"(ns maxrot.core\n  (:require [clojure.string :as str]))\n\n(defn shift [vector i]\n  (into\n    (subvec vector 0 i)\n    (#(into (subvec % 1) (subvec % 0 1)) (subvec vector i)))\n  )\n\n(defn rotation\n  ([n m] (rotation n (count n) m))\n  ([n len m]\n   (if (<= len 1)\n     m\n     (let [v (shift n (- (count n) len))]\n       (rotation v (dec len) (max m (-> v (str\/join) (biginteger))))))\n   )\n  )\n\n(defn max_rot [n]\n  (-> n (str) (seq) (vec) (rotation n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17196,"user_id":null,"body":"(ns maxrot.core)\n\n(defn rotate-string-left [string]\n  (apply str (concat (drop 1 string) (take 1 string))))\n\n(defn freeze-and-rotate [string, frozen-positions]\n  (concat\n   (subs string 0 frozen-positions)\n   (rotate-string-left (subs string frozen-positions))))\n\n(defn magic-rotate [x, col, remaining]\n  (let [freeze-position (- (count x) (inc remaining))\n        rotated-x (apply str (freeze-and-rotate x freeze-position))\n        new-collection (conj col x)]\n    (if (zero? remaining)\n      (apply max (map #(new BigInteger %) new-collection))\n      (recur rotated-x new-collection (dec remaining)))))\n\n(defn max_rot [x]\n  (magic-rotate (str x) [] (dec (count (str x)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17197,"user_id":null,"body":"(ns maxrot.core)\n(defn rotate [n]\n  (let [num-seq\n        (->> n\n             (str)\n             (seq))]\n    (->>\n     (concat (drop 1 num-seq) (take 1 num-seq))\n     (map #(Character\/digit % 10))\n     (apply str))))\n\n(defn keep-n-digits-rotate-rest [nd n]\n  (let [string-num (seq (str n))]\n    (bigint\n     (apply str\n            (concat\n             (apply str (take nd string-num))\n             (->>\n              (drop nd string-num)\n              (map #(Character\/digit % 10))\n              (apply str)\n              (rotate)))))))\n\n(defn max_rot [n]\n  (let [nlen (count (str n))]\n    (loop [index 0 current n nums (list)]\n      (if (< index nlen)\n        (let [next (keep-n-digits-rotate-rest index current)]\n          (recur (inc index) next (cons current nums)))\n        (apply max nums)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"56a5d994ac971f1ac500003e":[{"id":17198,"user_id":null,"body":"(ns longest_consec.core)\n\n(defn longest_consec [strarr k]\n  (reduce #(if (> (count %2) (count %1)) %2 %1) \"\"\n  \t(map #(apply str %) (partition k 1 strarr))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17199,"user_id":null,"body":"(ns longest_consec.core)\n\n(defn longest_consec [strarr k]\n  (->> strarr\n       (partition k 1)\n       (map (partial apply str))\n       reverse\n       (apply max-key count \"\")))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17200,"user_id":null,"body":"(ns longest_consec.core)\n\n(defn longest_consec [strarr k]\n  (if (and (seq strarr)\n           (<= 1 k (count strarr)))\n    (->> strarr\n         (partition k 1)\n         (map clojure.string\/join)\n         (reduce #(if (> (count %2) (count %1)) %2 %1)))\n    \"\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17201,"user_id":492,"body":"(ns longest_consec.core)\n\n(defn longest_consec [strarr k]\n  (if (or (empty? strarr) (> k (count strarr)) (<= k 0))\n    \"\"\n    (let [\n          arr (vec (map (fn[x] (count x)) strarr))\n          n (count arr)\n          s (for [i (range 0 (- n k -1)) \n            :let [su [ i (reduce + (subvec arr i (+ i k)))] ]\n            ]\n            su)\n          r (first (first (sort-by second > s)))  \n          res (clojure.string\/join \"\" (subvec strarr r (+ r k)))\n         ]\n      res\n    )))\n\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17202,"user_id":3257,"body":"(ns longest_consec.core\n  (:use [clojure.string :only (join)]))\n\n(defn longest-string [str1 str2]\n  (if (< (count str1) (count str2))\n    str2\n    str1))\n\n(defn longest_consec [strarr k]\n  (let [kstr (map join (partition k 1 strarr))]\n    (reduce longest-string \"\" kstr)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17203,"user_id":null,"body":"(ns longest_consec.core)\n(use '[clojure.string :only (join)])\n\n(defn longest_consec [strarr k]  \n  (if (or (empty? strarr) (> k (count strarr)) (<= k 0))\n    \"\"  \n    (first (sort-by count > (map #(apply str %) (partition k 1 strarr))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17204,"user_id":null,"body":"(ns longest_consec.core)\n\n(require '[clojure.string :as str])\n(defn longest_consec [strarr k]\n  (as-> strarr $\n    (partition k 1 $)\n    (map #(str\/join \"\" %) $)\n    (sort-by count > $)\n    (or (first $) \"\"))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17205,"user_id":null,"body":"(ns longest_consec.core)\n\n(defn longest_consec [strarr k]\n  (reduce #(if (> (count %2) (count %1)) %2 %1) \"\" \n          (map #(apply str %1) (partition k 1 strarr)))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17206,"user_id":null,"body":"(ns longest_consec.core)\n\n(defn helper [strarr k result]\n  (cond \n    (= 0 (count strarr)) result\n    (<= k 0) result\n    (> k (count strarr)) result\n    :else (\n       let [value (apply str (take k strarr))]\n            (if (> (count value) (count result))\n              (helper (rest strarr) k value)\n              (helper (rest strarr) k result)\n              )\n       )\n    )\n  )\n\n(defn longest_consec [strarr k]\n  (helper strarr k \"\")\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17207,"user_id":null,"body":"(ns longest_consec.core)\n\n(defn longest_consec [strarr k]\n  (->> (partition k 1 strarr)\n       (map (partial apply str))\n       (reduce (fn [mx s]\n                 (if (> (count s) (count mx))\n                   s\n                   mx))\n               \"\")))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"56a628758f8d06b59800000f":[{"id":17208,"user_id":null,"body":"(ns descriptives.core)\n\n(defn self_descriptive? [n]\n  (let [digits (->> n str seq (map #(Character\/digit % 10)))\n        freq   (frequencies digits)]\n    (apply = true (map = digits (map #(get freq % 0) (range 9))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17209,"user_id":1200,"body":"(ns descriptives.core)\n\n(defn self_descriptive? [num]\n  (@(find-var 'countdig.core-test\/test-descriptive?) num))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17210,"user_id":53,"body":"(ns descriptives.core)\n\n(defn self_descriptive? [n]\n  (let [s (str n)] (every? true?\n    (map #(->> s (re-seq (re-pattern (str %1))) count str (= (str %2)))\n    (iterate inc 0) s))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17211,"user_id":null,"body":"(ns descriptives.core)\n\n(defn self_descriptive? [num]\n  (let [fs (frequencies (str num))]\n    (->> (str num)\n         (map-indexed (fn [idx v] [(Character\/forDigit idx 10) (Character\/digit v 10)]))\n         (reduce (fn [is-true [idx v]]\n                   (and is-true\n                        (= v (get fs idx 0))))\n                 true))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17212,"user_id":null,"body":"(ns descriptives.core)\n\n(defn number->digits [num]\n  (->> num str (map (comp read-string str))))\n\n(defn self_descriptive? [n]\n  (let [digits (number->digits n)\n        groups (group-by identity digits)]\n    (every? true? (map #(= (nth digits %) (count (groups %)))\n                       (range (count digits))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17213,"user_id":null,"body":"(ns descriptives.core)\n\n\n \n\n(defn self_descriptive? [num]\n   (def x (frequencies (str num)))\n   (def y (into [] x))\n   (def z (into {} (map (fn [[a b]] [(- (int a) (int \\0) ) b] ) y)))\n   (def n (for [g (range (count (str num)))] (or (= (get z g) (- (int(get (str num) g)) (int \\0))) (nil? (get z g )))))\n   (apply = n)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17214,"user_id":null,"body":"(ns descriptives.core)\n\n(defn self_descriptive? [num]\n  (let [digits (map #(Integer. (str %)) (str num))]\n    (every? identity\n            (map-indexed (fn [i d] (= d (count (filter #(= % i) digits)))) digits))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17215,"user_id":null,"body":"(ns descriptives.core)\n\n(defn n->digits [n]\n  (map #(- (int %) (int \\0)) (str n)))\n\n(defn self_descriptive? [n]\n  (let [digits (n->digits n)\n        frs (frequencies digits)]\n    (every? true? (map-indexed #(= %2 (frs % 0)) digits))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17216,"user_id":null,"body":"(ns descriptives.core)\n\n(defn digit-count [number digit] (count (filter #(= % digit) number)))\n\n(defn self_descriptive? [n]\n  (let [s (str n)](= s (apply str (map #(digit-count s (first %)) (map-indexed str s))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17217,"user_id":null,"body":"(ns descriptives.core)\n(defn self_descriptive? [num]\n  (def ds (map #(- (int %) 48) (str num)))\n  (def fr (frequencies ds))\n  (def res (atom true))\n  (dotimes [k (count ds)]\n    (reset! res (and @res (= (nth ds k) (or (fr k) 0)))))\n  @res)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"56a946cd7bd95ccab2000055":[{"id":17218,"user_id":null,"body":"(ns kata.lowercase-count)\n(defn lowercase_count [s] \n  (count (re-seq #\"[a-z]\" s)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17219,"user_id":null,"body":"(ns kata.lowercase-count)\n(defn lowercase_count [strng]\n  (count (filter #(Character\/isLowerCase %) strng))\n\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17220,"user_id":null,"body":"(ns kata.lowercase-count)\n\n(defn lowercase_count [strng]\n  (reduce + (map count (re-seq #\"\\p{Lower}+\" strng))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17221,"user_id":null,"body":"(ns kata.lowercase-count)\n(defn lowercase_count[strng]\n  (count (clojure.string\/join (re-seq #\"[a-z]+\" strng)))\n\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17222,"user_id":null,"body":"(ns kata.lowercase-count)\n\n(defn- lowercase-letter?\n  [c]\n  (and (Character\/isLetter c)\n       (Character\/isLowerCase c)))\n\n(defn lowercase_count\n  [s]\n  (->> s\n       (filter #(lowercase-letter? %))\n       count))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17223,"user_id":null,"body":"(ns kata.lowercase-count)\n\n(defn- lower-case? [c] (clojure.string\/includes? \"abcdefghijklmnopqrstuvwxyz\" (str c)))\n(defn lowercase_count[strng]\n  (count (filter lower-case? strng))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17224,"user_id":null,"body":"(ns kata.lowercase-count)\n\n(defn lowercase_count\n  \"Str -> Int\n  Count the number of lowercase letters in `strng`.\"\n  [strng]\n  (reduce + (for [c strng] (if (Character\/isLowerCase c) 1 0))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17225,"user_id":null,"body":"(ns kata.lowercase-count\n  (:require [clojure.string :as str])\n  )\n\n(defn lowercase_count[strng]\n  (->> strng\n    (filter (set \"abcdefghijklmnopqrstuvwxyz\"))\n    count\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17226,"user_id":null,"body":"(ns kata.lowercase-count)\n(defn lowercase_count[strng]\n  ;your code here\n  (->> (clojure.string\/replace strng #\"[^a-z]\" \"\") seq count)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17227,"user_id":null,"body":"(ns kata.lowercase-count)\n(defn lowercase_count[strng]\n  ;your code here\n  \n  (reduce + (map #(if (Character\/isLowerCase %) 1 0) strng))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"56ae72854d005c7447000023":[{"id":17228,"user_id":null,"body":"(ns clojure.template)\n\n(defn template [s] \n\t(fn [m]\n\t\t(clojure.string\/replace s #\"\\{\\{(\\w+)\\}\\}\"\n\t\t\t#(str (get m (keyword (second %1))) \"\"))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17229,"user_id":null,"body":"(ns clojure.template)\n\n(defn- fetch-from [template-data]\n  (fn [[_, identifier]]\n    (let [key (keyword identifier)]\n      (get template-data key \"\"))))\n\n(defn template [string]\n  (fn [template-data]\n    (clojure.string\/replace string #\"\\{\\{(\\w+)\\}\\}\" (fetch-from template-data))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17230,"user_id":null,"body":"(ns clojure.template (:require [clojure.string :as s]))\n\n(defn template [s] \n  (fn [params] \n    (s\/replace s #\"\\{\\{(\\w+)\\}\\}\" (comp #(get params % \"\") keyword last))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17231,"user_id":null,"body":"(ns clojure.template)\n\n(defn template [s]\n  (fn [v] \n    (-> (reduce (fn [st k]\n                  (let [pattern (re-pattern (str \"\\\\{\\\\{\" (name k) \"\\\\}\\\\}\"))]\n                    (clojure.string\/replace st pattern (str (get v k)))))\n                s\n                (keys v))\n        (clojure.string\/replace #\"\\{\\{.*?\\}\\}\" \"\")))) ;; finally remove unmatched moustaches","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17232,"user_id":168,"body":"(ns clojure.template)\n\n(defn template [s]\n  (fn [args]\n    (clojure.string\/replace s #\"\\{\\{([^}]*)\\}\\}\" \n                            #(get args (keyword (%1 1)) \"\"))))\n    ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17233,"user_id":null,"body":"(ns clojure.template\n  (:require [clojure.string :as s]))\n\n(defn template [string]\n  (fn [data]\n    (s\/replace string #\"\\{\\{(\\w+)}}\" #(data (keyword (second %)) \"\"))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17234,"user_id":null,"body":"(ns clojure.template\n  (:require [clojure.string :as str]))\n\n(defn template [s]\n  (fn [k]\n    (let [rgx         (re-seq #\"\\{\\{(.*?)\\}\\}\" s)\n          replacements (map (fn [m] [(first m) (keyword (second m))]) rgx)]\n      (prn replacements)\n      (loop [i 0\n             s s]\n        (if (= i (count replacements))\n          s\n          (recur (inc i) (str\/replace s (first (nth replacements i)) (get k (second (nth replacements i)) \"\"))))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17235,"user_id":null,"body":"(ns clojure.template\n  (:require [clojure.string :as str]))\n\n(defn template [t]\n  (fn [v]\n    (str\/replace t #\"\\{\\{(.+?)\\}\\}\" #(get v (keyword (% 1)) \"\"))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17236,"user_id":null,"body":"(ns clojure.template)\n\n(defn template [s]\n  (fn [parmap]\n    (clojure.string\/replace s #\"\\{\\{([^}]+)\\}\\}\" #(str (parmap (keyword (second %)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17237,"user_id":null,"body":"(ns clojure.template)\n\n(defn template [s]\n  (fn [data]\n    (let [data (conj data [:.+ \"\"])]\n      (reduce #(clojure.string\/replace % (re-pattern (str \"\\\\{\\\\{\" (name %2) \"\\\\}\\\\}\")) (%2 data)) s (keys data)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"56aed5db9d5cb55de000001c":[{"id":17238,"user_id":294,"body":"(ns kata.how-many-twos)\n\n(defn two_count [n]\n  (->> (iterate #(\/ % 2) n) (take-while even?) (count)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17239,"user_id":null,"body":"(ns kata.how-many-twos)\n\n(defn two_count [n]\n  (count (take-while even? (iterate #(\/ % 2) n)))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17240,"user_id":3088,"body":"(ns kata.how-many-twos)\n\n(defn two_count [n]\n  (if (odd? n) 0 (inc (two_count (\/ n 2)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17241,"user_id":53,"body":"(ns kata.how-many-twos)\n\n(defn two_count-helper [n c]\n  (if (even? n) (two_count-helper (quot n 2) (inc c)) c))\n\n(defn two_count [n]\n  (two_count-helper n 0))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17242,"user_id":1400,"body":"(ns kata.how-many-twos)\n\n(defn two_count [n]\n  (if (or (= (mod n 2) 1) (<= n 1))\n    0\n    (inc (two_count (\/ n 2)))\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17243,"user_id":168,"body":"(ns kata.how-many-twos)\n\n(defn two_count [n]\n  (if (even? n) (+ 1 (two_count (\/ n 2))) 0))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17244,"user_id":881,"body":"(ns kata.how-many-twos)\n\n(defn two_count \n  ([n] (two_count n 0))\n  ([n twos] (if (odd? n) twos (recur (\/ n 2) (inc twos)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17245,"user_id":null,"body":"(ns kata.how-many-twos)\n\n(defn solve [n cnt]\n  (if (or (zero? n) (odd? n))\n    cnt\n    (recur (\/ n 2) (inc cnt))))\n\n(defn two_count [n]\n  (solve n 0))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17246,"user_id":null,"body":"(ns kata.how-many-twos)\n\n(defn two_count \n ([n] (two_count 0 n))\n ([m c] \n   (if (= (mod c 2) 0)\n     (recur (inc m) (quot c 2))\n     m\n   )\n  )  \n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17247,"user_id":null,"body":"(ns kata.how-many-twos)\n\n(defn two_count\n  [n]\n  (if\n    (odd? n)\n    0\n    (loop\n      [x n result 0]\n      (if\n        (odd? x)\n        result\n        (recur (quot x 2) (inc result))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"56af1a20509ce5b9b000001e":[{"id":17248,"user_id":null,"body":"(ns salesmantravel.core)\n\n(defn parse-address [s]\n  (let [r #\"(\\d+) (.*) (\\D\\D \\d{5})\"\n        [_ house-num st-town zipcode] (re-find r s)]\n    (hash-map\n     :house-num house-num\n     :st-town st-town\n     :zipcode zipcode)))\n\n(defn travel [s zipcode]\n  (let [csv (partial clojure.string\/join \",\")]\n    (as-> s x\n      (clojure.string\/split x #\",\")\n      (map parse-address x)\n      (group-by :zipcode x)\n      (get x zipcode)\n      (str zipcode \":\" (csv (map :st-town x)) \"\/\" (csv (map :house-num x))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17249,"user_id":null,"body":"(ns salesmantravel.core)\n\n(defn parse-address [s]\n  (let [r #\"(\\d+) (.*) (\\D\\D \\d{5})\"\n        [_ house-num st-town zipcode] (re-find r s)]\n    (hash-map\n     :house-num house-num\n     :st-town st-town\n     :zipcode zipcode)))\n\n(defn travel [s zipcode]\n  (let [csv (partial clojure.string\/join \",\")]\n    (as-> s x\n      (clojure.string\/split x #\",\")\n      (map parse-address x)\n      (filter #(= zipcode (:zipcode %)) x)\n      (str zipcode \":\" (csv (map :st-town x)) \"\/\" (csv (map :house-num x))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17250,"user_id":492,"body":"(ns salesmantravel.core)\n\n(defn pat-match [s srch]\n  (let [res (re-find (re-pattern \"[A-Z]{2}\\\\s\\\\d+\\\\s*$\") s)]\n    (if (not= res srch)\n      \"-\"\n      (let [\n            q (re-find (re-pattern \"^\\\\s*\\\\d+\") s)\n            ss (clojure.string\/replace s (re-pattern \"[A-Z]{2}\\\\s\\\\d+\\\\s*$\") \"\")\n            d (clojure.string\/trim (clojure.string\/replace ss (re-pattern \"(^\\\\s*\\\\d+)\") \"\"))\n            res (str q \"-\" d)\n           ]\n        res\n      ))\n  ))\n\n(defn travel [s zipcode]\n  (let [noresult \":\/\"]\n    (if (= zipcode \"\")\n      noresult\n      (let [arr (clojure.string\/split s #\",\")]\n        (loop [i 0  rpartAd \"\" rpartNb \"\"]\n          (if (= i (count arr))\n            (str zipcode \":\" (.replaceAll rpartAd \",$\" \"\") \"\/\" (.replaceAll rpartNb \",$\" \"\"))\n            (let [u (arr i) s (pat-match u zipcode) res (clojure.string\/split s #\"-\")]\n              (if (= 0 (count res))\n                (recur (inc i) rpartAd rpartNb)\n                (recur (inc i) (str rpartAd (res 1) \",\") (str rpartNb (res 0) \",\"))))))))) \n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17251,"user_id":null,"body":"(ns salesmantravel.core\n  (:require\n   [clojure.string :as str]))\n\n(defn address->map [address]\n  (let [house-num (re-find #\"^[0-9]*\" address)\n        zipcode (->> address \n                     (re-find #\"[0-9]{5}$\"))\n        state (->> address\n                   (re-seq #\"[A-Z]{2}\")\n                   (last))\n        street (-> address\n                   (str\/split #\"^[0-9]*|[A-Z]{2}\\s[0-9]{5}$\")\n                   (last)\n                   (str\/trim))]\n    {:house-num house-num\n     :zipcode zipcode\n     :state state\n     :street street}))\n\n(defn travel [s zipcode]\n  (let [zip (->> (str\/split zipcode #\" \")\n                 (last)) \n        filtered-list (->> (map address->map (str\/split s #\",\"))\n                           (filter #(= (:zipcode %) zip)))\n        streets (->> (map #(:street %) filtered-list)\n                     (str\/join \",\"))\n        house-nums (->> (map #(:house-num %) filtered-list)\n                        (str\/join \",\"))]\n    (println streets)\n    (println house-nums)\n    (format \"%s:%s\/%s\"\n            zipcode\n            streets\n            house-nums)\n    ))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17252,"user_id":null,"body":"(ns salesmantravel.core\n  (:require [clojure.string :refer [split includes? join]]))\n\n(defn street-vector\n  \"Given a full street address create a vector of street number and address\"\n  [s]\n  (rest (re-find #\"(\\d+) (.*) [A-Z]{2} [0-9]{5}\" s)))\n\n(defn travel [s zipcode]\n  (if (< (count zipcode) 8) (str zipcode \":\/\")\n  (let [addresses (for [a (split s #\",\") :when (includes? a zipcode)] (street-vector a))\n        result (reduce (fn [strings v]\n                  [(conj (first strings) (first v)), (conj (second strings) (second v))])\n                [[] []]\n                addresses)]\n    (str zipcode \":\" (join \",\" (second result)) \"\/\" (join \",\" (first result))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17253,"user_id":null,"body":"(ns salesmantravel.core)\n(defn join, [xs] (clojure.string\/join \",\" xs))\n(defn travel [s zipcode]\n  (if (= \"\" zipcode)\n    \":\/\"\n    (->> (clojure.string\/split s #\",\")\n      (filter #(clojure.string\/ends-with? % zipcode))\n      (map #(subs % 0 (- (count %) (count zipcode) 1)))\n      (map #(clojure.string\/split % #\" \" 2))\n      ((fn [s] [(map first s) (map second s)]))\n      ((fn [[houses addr]] (str zipcode \":\" (join, addr) \"\/\" (join, houses)))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17254,"user_id":null,"body":"(ns salesmantravel.core\n  (:require [clojure.string :as string]))\n\n(defn parse-address [addr]\n  (let [parse (re-find #\"([0-9]+) ([a-z]|[A-Z]| |.+) ([A-Z]{2} [0-9]{5})\" addr)]\n    {:housnumber (second parse)\n     :street (nth parse 2)\n     :zipcode (nth parse 3)}))\n\n(defn extract-by-key [addresses key]\n  (->> addresses\n       (map (fn [m] (str (get m key) \",\")))\n       (apply str)\n       (drop-last)\n       (apply str)))\n\n(defn format-output [zipcode addresses]\n  (let [streets (extract-by-key addresses :street)\n        numbers (extract-by-key addresses :housnumber)]\n    (str zipcode \":\" streets \"\/\" numbers)))\n\n(defn travel [s zipcode]\n  (->> (string\/split s #\",\")\n       (map parse-address)\n       (filter #(= (:zipcode %) zipcode))\n       (format-output zipcode)))\n\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17255,"user_id":null,"body":"(ns salesmantravel.core)\n(use '[clojure.string :only [includes? split join]])\n\n(defn street\n  [s]\n  {:zip (join \" \" (take-last 2 (split s #\" \")))\n   :address (join \" \" (drop 1 (drop-last 2 (split s #\" \"))))\n   :number  (first (split s #\" \")) })\n\n\n(defn streets\n  [s]\n  (map street (split s #\",\")))\n\n\n(defn travel\n  [s zipcode]\n  (def directions (filter (fn[x] (= (:zip x) zipcode)) (streets s)))\n  (format \"%s:%s\/%s\" zipcode (join \",\" (map :address directions)) (join \",\" (map :number directions)))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17256,"user_id":null,"body":"(ns salesmantravel.core)\n\n(defn travel [s zipcode]\n  (let [addresses (clojure.string\/split s #\",\")\n        split (fn [el] (clojure.string\/split el #\" \"))\n        format-street (fn [el] (clojure.string\/join\n                                \" \"\n                                (reverse\n                                 (drop 2\n                                       (reverse\n                                        (drop 1 (split el)))))))\n        get-index (fn [el]\n                    (clojure.string\/join\n                     \" \"\n                     [(second (reverse (split el)))\n                      (first (reverse (split el)))]))\n        get-address (fn [el] (first (split el)))\n        filtered-addresses (filter (fn [el]\n                                     (= zipcode\n                                        (get-index el)))\n                                   addresses)\n        only-addresses (clojure.string\/join \",\"(map format-street filtered-addresses))\n        only-h-numbers (clojure.string\/join \",\"(map get-address filtered-addresses))]\n    (if (empty? filtered-addresses)\n      (str zipcode \":\/\")\n      (str zipcode \":\" only-addresses \"\/\" only-h-numbers))\n    ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17257,"user_id":null,"body":"(ns salesmantravel.core\n  (:require [clojure.string :as str]))\n\n(def zip-regex #\"[A-Z][A-Z] \\d\\d\\d\\d\\d$\")\n(def number-regex #\"^\\d*\")\n\n(defn parse [s]\n  {:zip (re-find zip-regex s)\n   :number (re-find number-regex s)\n   :street (-> s\n               (str\/replace zip-regex \"\")\n               (str\/replace number-regex \"\")\n               (str\/trim)\n             )\n   }\n  )\n\n(defn directory [s]\n  (->> (str\/split s #\",\")\n       (map parse))\n  )\n\n(defn travel [s zipcode]\n  (let [records (filter #(= (:zip %) zipcode) (directory s))]\n    (str\n      zipcode\n      \":\"\n      (str\/join \",\" (map :street records))\n      \"\/\"\n      (str\/join \",\" (map :number records)))\n    )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"56b5afb4ed1f6d5fb0000991":[{"id":17258,"user_id":null,"body":"(ns revrot.core)\n(require '[clojure.string :as str])\n(defn ror [s]\n    (if (even? (count (filter #{\\1 \\3 \\5 \\7 \\9} s)))\n        (str\/reverse s)\n        (str (subs s 1) (first s))))\n        \n(defn revrot [strng sz]\n     (let [szp (re-pattern (format \"\\\\d{%d}\" sz))]\n     (str\/join (map ror (re-seq szp strng)))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17259,"user_id":492,"body":"(ns revrot.core)\n(require '[clojure.string :as str])\n\n(defn split-equal [strng sz]\n  (map str\/join (map vec (partition sz strng))))\n(defn sum-digit-to-3 [s]\n  (reduce + (map (fn [ch] (let [p (- (int ch) (int \\0))] (* p p p))) s)))\n(defn rotate [[h & t]] (reduce str (conj (vec t) h)))\n(defn revrot-aux [strng]\n  (let [r (sum-digit-to-3 strng)]\n    (if (= 0 (mod r 2))\n      (str\/reverse strng)\n      (rotate strng))))\n(defn revrot [strng sz]\n  (if (or (<= sz 0) (= strng \"\") (> sz (count strng)))\n    \"\"\n    (str\/join (map (fn [x] (revrot-aux x)) (split-equal strng sz)))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17260,"user_id":null,"body":"(ns revrot.core\n  (:require [clojure.string :as str]))\n\n(defn transform-chunk [ck]\n  (if (even? (reduce + (map int (seq ck))))\n    (reverse ck)\n    (let [[c & s] ck]\n      (conj (vec s) c))))\n\n(defn revrot [strng sz]\n  (if (or (str\/blank? strng) (<= sz 0))\n    \"\"\n    (->> (partition sz strng)\n         (filter #(= (count %) sz))\n         (mapcat transform-chunk)\n         str\/join)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17261,"user_id":null,"body":"(ns revrot.core)\n(require '[clojure.string :as str])\n\n(defn reverse-or-rotate [lst]\n  (if (even? (->> lst (reduce #(-> %2 str read-string (Math\/pow 2) (+ %1)) 0) int))\n    (reverse lst)\n    (concat (rest lst) [(first lst)])\n  ))\n\n(defn revrot [strng sz]\n    (if (<= sz 0) \"\"\n      (->> strng  \n          (partition sz) \n          (mapcat reverse-or-rotate)\n          str\/join\n      )\n    )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17262,"user_id":492,"body":"(ns revrot.core)\n(require '[clojure.string :as str])\n\n(defn split-equal [strng sz]\n  (map str\/join (map vec (partition sz strng))))\n(defn sum-digit-to-3 [s]\n  (reduce + (map (fn [ch] (let [p (- (int ch) (int \\0))] (* p p p))) s)))\n(defn rotate [[h & t]] (reduce str (conj (vec t) h)))\n(defn revrot-aux [strng]\n  (let [r (sum-digit-to-3 strng)]\n    (if (= 0 (mod r 2))\n      (str\/reverse strng)\n      (rotate strng))))\n(defn revrot [strng sz]\n  (if (or (<= sz 0) (= strng \"\") (> sz (count strng)))\n    \"\"\n    (str\/join (map (fn [x] (revrot-aux x)) (split-equal strng sz)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17263,"user_id":null,"body":"(ns revrot.core)\n(require '[clojure.string :as str])\n\n(defn sum-cubes [digits]\n  (->> digits\n       (map (comp #(* % % %) #(Integer\/parseInt %) str))\n       (apply +)))\n\n(defn revrot [s sz]\n  (if (or (<= sz 0) (empty? s))\n    \"\"\n    (->> (partition sz s)\n         (filter (comp (partial == sz) count))\n         (map #(if (even? (sum-cubes %))\n                 (reverse %) \n                 (concat (rest %) [(first %)])))\n         (map str\/join)\n         (apply str))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17264,"user_id":null,"body":"(ns revrot.core)\n(require '[clojure.string :as str])\n\n(defn reverse? [num]\n  (= true (as-> num $\n            (str\/split $ #\"\")\n            (map #(-> % Integer\/parseInt (Math\/pow 3)) $)\n            (reduce + $)\n            (mod $ 2)\n            (int $)\n            (= $ 0))))\n(defn rotate [s]\n  (str (subs s 1) (subs s 0 1)))\n\n(defn revrot [strng sz]\n  (if (or (<= sz 0) (> sz (count strng))) \"\"\n      (->> (partition sz strng)\n           (map str\/join)\n           (map (fn [num]\n                  (cond\n                    (reverse? num) (do (print num) (-> num  str\/reverse))\n                    :else (-> num  rotate))))\n           (apply str ))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17265,"user_id":null,"body":"(ns revrot.core)\n(require '[clojure.string :as str])\n\n(defn chunks [strng sz]\n  (if (or (> sz (count strng))\n          (= sz 0))\n    []\n    (let [ch (subs strng 0 sz)\n          rest-str (subs strng sz)]\n      (concat [ch] (chunks rest-str sz)))))\n\n\n(defn revrot [strng sz]\n  (->> (chunks strng sz)\n    (map (fn [ch]\n           (let [sum (->> ch\n                       seq\n                       (map str)\n                       (map read-string)\n                       (reduce (fn [acc item] (+ acc (* item item)))))]\n             (if (= (rem sum 2) 0)\n               (->> ch\n                 reverse\n                 (map str)\n                 str\/join)\n               (str\n                (subs ch 1)\n                (subs ch 0 1))))))\n    str\/join))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17266,"user_id":null,"body":"(ns revrot.core)\n(require '[clojure.string :as str])\n\n(defn rotate [strng]\n  (str\/join (conj (vec (rest strng)) (first strng))))\n\n(defn chunks [strng sz]\n  (when (>= (count strng) sz)\n    (conj\n     (chunks (subs strng sz) sz)\n     (map #(Character\/digit % 10) (take sz strng)))))\n\n(defn sum-of-cubes [col]\n  (reduce #(+ %1 (* %2 %2 %2)) 0 col))\n\n(defn transform-chunk [chunk]\n  (if (even? (sum-of-cubes chunk))\n    (str\/join (reverse chunk))\n    (rotate chunk)))\n\n(defn revrot [strng sz]\n  (if (or (<= sz 0) (< (count strng) sz))\n    \"\"\n    (str\/join (map transform-chunk (chunks strng sz)))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17267,"user_id":null,"body":"(ns revrot.core)\n(require '[clojure.string :as str])\n\n(defn shouldreverse? [coll]\n  (as-> coll $ \n    (map #(Character\/getNumericValue %) $)\n    \n    (map #(Math\/pow % 3) $)\n    (apply + $)\n    \n    (mod $ 2)\n    \n    (= 0.0 $)\n    )\n  )\n\n(defn rot [coll]\n  (let [[h & t]  coll]\n    (concat t [h])\n\n    )\n  )\n\n(defn revrot [strng sz]\n  (if (or (<= sz 0) (empty? strng) (> sz (count strng)))\n    \"\"\n    (->> strng\n      (partition sz)\n      (map #(if (shouldreverse? %)\n              (reverse %)\n              (rot %)\n              ))\n      (apply concat)\n      (apply str)\n      )\n    \n    )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"56baeae7022c16dd7400086e":[{"id":17268,"user_id":null,"body":"(ns phonedir.core)\n\n(defn phone [strng num]\n  (if-let [[f & rst] (->> strng\n  \t\t\t\t\t\t\t\t\t\t\t  clojure.string\/split-lines\n  \t\t\t\t\t\t\t\t\t\t\t  (filter #(clojure.string\/includes? % (str \\+ num)))\n                          seq)]\n    (if (empty? rst)\n      (format \"Phone => %s, Name => %s, Address => %s\"\n              num\n              (->> f (re-find #\"<(.*)>\") second)\n              (as-> f ff\n                (clojure.string\/replace ff #\"(\\+\\d\\d?-\\d{3}-\\d{3}-\\d{4}|<.*>)\" \" \")\n                (re-seq #\"[A-Za-z0-9-\\.]+\" ff)\n                (clojure.string\/join \" \" ff)))\n      (format \"Error => Too many people: %s\" num))\n    (format \"Error => Not found: %s\" num)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17269,"user_id":492,"body":"(ns phonedir.core)\n\n(defn phone [strng num]\n  (let [\n        clean (clojure.string\/replace strng (re-pattern \"[^-0-9a-z\\\\s+A-Z\\\n<>.']\") \" \")\n        a (re-seq (re-pattern (str \".*\\\\+.*\" num \"\\\\b.*\")) clean)\n       ]\n       (if (> (count a) 1)\n         (str \"Error => Too many people: \" num)\n         (if (= 0 (count a))\n           (str \"Error => Not found: \" num)\n         (let [\n               c (clojure.string\/replace (first a) (re-pattern (str \"\\\\+\" num)) \"\")\n               name (re-find (re-pattern \"<.*>\") c)\n               ad (clojure.string\/trim (clojure.string\/replace \n                               (clojure.string\/replace c (re-pattern \"<.*>\") \"\") (re-pattern \"\\\\s+\") \" \"))\n              ]\n           (str \"Phone => \" num \", \"\n                \"Name => \" (subs name 1, (- (count name) 1)) \n                \", Address => \" ad))))))\n\n","lang_id":5,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17270,"user_id":null,"body":"(ns phonedir.core\n  (:require [clojure.string :as s]))\n\n(defn catalog [s]\n  (reduce (fn [dir s]\n         (let [[[tel _ phone]] (re-seq #\"(\\+)(\\d+-\\d{3}-\\d{3}-\\d{4})\" s)\n               [[_ name]]    (re-seq #\"<(.*)>\" s)\n               address (-> s\n                           (s\/replace _ \"\")\n                           (s\/replace tel \"\")\n                           (s\/replace #\"[;!\\?:\/\\*\\$]\" \"\")\n                           (s\/replace \",\" \"\")\n                           (s\/replace \"_\" \" \")\n                           (s\/replace \"  \" \" \")\n                           (s\/trim))\n               fmt (fn [t n a] (format \"Phone => %s, Name => %s, Address => %s\" t n a))]\n           (if-not (contains? dir phone)\n             (assoc dir phone (fmt phone name address))\n             (assoc dir phone (format \"Error => Too many people: %s\" phone)))))\n       {} (s\/split s #\"\n\")))\n\n(defn phone [s phone]\n  (let [dir (catalog s)]\n    (if-not (contains? dir phone)\n      (format \"Error => Not found: %s\" phone)\n      (dir phone))))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17271,"user_id":null,"body":"(ns phonedir.core\n  (:require [clojure.string :as st]))\n\n(defn make-map [dr]\n\n  (let [all-lines (st\/split-lines dr)]\n    (reduce (fn [a b]\n              (let [phone-number (re-find #\"\\d?\\d-\\d{3}-\\d{3}-\\d{4}\" b)\n                    contact (re-find #\"<.*>\" b)\n                    contact-name (re-find #\"[^<>]+\" contact)\n                    address (-> b\n                                (st\/replace phone-number \"\")\n                                (st\/replace contact \"\")\n                                (st\/replace #\"[\/;:+?!$(\\*),]\" \"\")\n                                (st\/replace #\"[(\\s)+_]+\" \" \")\n                                st\/trim)]\n                (if (a phone-number)\n                  (assoc a\n                         phone-number \"invalid\")\n                  (assoc a\n                         phone-number  {:address address\n                                        :name contact-name}))))\n            {}\n            all-lines)))\n\n(defn phone [strng num]\n  (let [c-info (make-map strng)\n        num-info (c-info num)]\n    (cond\n      (nil? num-info) (str \"Error => Not found: \" num)\n      (= \"invalid\" num-info) (str \"Error => Too many people: \" num)\n      :else\n      (str \"Phone => \" num\n           \", Name => \" (:name num-info)\n           \", Address => \" (:address num-info)))))\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17272,"user_id":null,"body":"(ns phonedir.core\n  (:require [clojure.string :as s]))\n\n(def regex-name #\"<(.+)>\")\n(def regex-phone #\"\\+((\\d|\\d\\d)(\\-\\d{3}){2}\\-\\d{4})\")\n\n(defn extract [line]\n  (let [ \n         name1  (second (re-find regex-name line))\n         phone (second (re-find regex-phone line))\n         address (-> line\n                      (s\/replace regex-name \"\")\n                      (s\/replace regex-phone \"\")\n                      (s\/replace #\"[^a-zA-Z0-9.-]\" \" \")\n                      (s\/replace #\"\\s\\s+\" \" \")\n                      (s\/trim) )]\n    [phone name1 address]))\n\n(defn phone [phone-book phone]\n  (let [res \n    (->> (s\/split-lines phone-book)\n         (map extract)\n         (filter #(= (% 0) phone))\n         (into [])) ] \n    (cond\n      (= (count res) 0)\n        (str \"Error => Not found: \" phone)\n      (> (count res) 1)\n        (str \"Error => Too many people: \" phone)\n      :else\n        (str \"Phone => \" phone \", Name => \" ((first res) 1) \", Address => \" ((first res) 2)))))\n\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17273,"user_id":null,"body":"(ns phonedir.core\n  (:require [clojure.string :as st]))\n\n(defn phone [book num]\n  (let [matches (filter #(st\/includes? % (str \"+\" num))\n                        (st\/split-lines book))]\n    (case (count matches)\n      0 (str \"Error => Not found: \" num)\n      1 (str \"Phone => \" num\n             \", Name => \" (re-find #\"(?<=<).*(?=>)\" (first matches))\n             \", Address => \" (-> (first matches)\n                               (st\/replace #\"<.*>\" \" \")\n                               (st\/replace #\"\\+[\\d-]*\" \" \")\n                               (st\/replace #\"[^\\da-zA-Z.\\-]+\" \" \")\n                               (st\/trim)))\n      (str \"Error => Too many people: \" num))))\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17274,"user_id":62,"body":"(ns phonedir.core\n  (:require clojure.string)\n  )\n\n(defn consume-regex \n  \"Search the string s for a re-match. If found, store it in map m under key k. Then erase the match. \n  Return a pair containing the updated string and map\"\n  [[s m] k re]\n  \n  (if-let [match (re-find re s)]\n    [(clojure.string\/replace s re \"\") (assoc m k match)]\n    [s m]))\n\n(defn alter-map-regex\n  \"Find the string stored in the map m under key k, then apply (clojure.string\/replace old-val match replacement).\n   Carries along an unused s variable for type-signature consistency. Returns a pair containing the unused s and new map.\"\n  ([[s m] k match replacement]\n    [s (assoc m k (clojure.string\/replace (get m k) match replacement))]))\n  \n\n\n(defn phone [directory phone-number]\n  (let [phone-regex (re-pattern (str \"\\\\Q\" phone-number \"\\\\E\"))\n        lines \n        (filter #(re-find phone-regex %)\n                 (clojure.string\/split-lines directory))]\n    \n    (cond (empty? lines) (str \"Error => Not found: \" phone-number)\n          (> (count lines) 1) (str \"Error => Too many people: \" phone-number)\n          :else \n      (-> [(first lines) {}]\n          (consume-regex :phone phone-regex)\n          (consume-regex :name #\"<[^<>]*>\")\n          (consume-regex :address #\".*\")\n\n          (alter-map-regex :name  #\"[<>]\" \"\")\n          (alter-map-regex :address #\"[^A-Za-z \\-\\.0-9]\" \"\")\n          (alter-map-regex :address #\"[ ]+\" \" \")\n          (alter-map-regex :address #\"([a-z])([A-Z])\" #(str (% 1) \" \" (% 2)))\n\n          second\n          (#(str \"Phone => \" (:phone %) \", Name => \" (:name %) \", Address => \" (clojure.string\/trim (:address %))))\n        ))))\n  \n\n\n                             ","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17275,"user_id":null,"body":"(ns phonedir.core\n  (:require [clojure.string :as str]))\n\n(defn phone [string number]\n  (let [pattern (re-pattern\n                  (str \"(?m)^(?=.*<(?<name>.*)>)\"\n                       \"(?=.*\\\\+(?<num>\" number \")).*$\"))\n        matcher (re-matcher pattern string)\n        match (if (seq (re-find matcher))\n                {:0 (.group matcher 0)\n                 :num (.group matcher \"num\")\n                 :name (.group matcher \"name\")}\n                nil)\n        get-addr (fn [m] (-> m\n                             (str\/replace (re-pattern (str \"(\\\\+\" number \")|(<.*>)\")) \"\")\n                             (str\/replace #\"[*,:;!?\/$]\" \"\")\n                             (str\/replace #\"\\s+|_\" \" \")\n                             str\/trim))]\n    (cond\n      (not match) (str \"Error => Not found: \" number)\n      (re-find matcher) (str \"Error => Too many people: \" number)\n      :else (str \"Phone => \" (:num match)\n                 \", Name => \" (:name match)\n                 \", Address => \" (get-addr (:0 match))))))\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17276,"user_id":null,"body":"(ns phonedir.core)\n\n(defn phone\n  [dir num]\n  (let [dir (->> (clojure.string\/split-lines dir)\n                 (map (fn [line]\n                        (let [phone (re-find #\"\\d+\\-\\d+\\-\\d+\\-\\d+\" line)\n                              name  (second (re-find #\"<(.*)>\" line))\n                              address (-> (clojure.string\/replace line #\"<.*>|\\d+\\-\\d+\\-\\d+\\-\\d+|[\\\/\\+\\?\\_\\!\\;\\$\\,\\*\\:]\" \" \")\n                                          (clojure.string\/trim)\n                                          (clojure.string\/replace #\"\\s+\" \" \"))]\n                          {phone (str \"Phone => \" phone \", Name => \" name \", Address => \" address)})))\n                 (apply merge-with (fn [a _] (str \"Error => Too many people: \" (re-find #\"\\d+\\-\\d+\\-\\d+\\-\\d+\" a)))))]\n    (or (get dir num)\n        (str \"Error => Not found: \" num))))\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17277,"user_id":null,"body":"(ns phonedir.core)\n\n(def allowed-specials #{\\- \\  \\. \\< \\> \\'})\n\n(defn is-alphanumeric? [c]\n  (or (allowed-specials c)\n      (Character\/isLetterOrDigit c)))\n\n(defn clean-directory-line [line]\n  (let [line (clojure.string\/replace line #\"_\" \" \")]\n    (->> line\n         (filter is-alphanumeric?)\n         (apply str)\n         clojure.string\/trim)))\n\n(def name-regex #\"<.*>\")\n(def phone-regex #\"\\d{1,2}-\\d{3}-\\d{3}-\\d{4}\")\n\n(defn find-name [line]\n  (let [matches (re-seq name-regex line)]\n    (->> matches (first) (drop 1) (drop-last 1) (apply str))))\n\n(defn process-directory-line [line]\n  (let [name (find-name line)\n        number (re-find phone-regex line)\n        address (-> line\n                    (clojure.string\/replace name-regex \"\")\n                    (clojure.string\/replace phone-regex \"\")\n                    clojure.string\/trim\n                    (clojure.string\/replace #\"  \" \" \"))]\n    {:name name :number number :address address}))\n\n(defn process-directory [dr]\n  (->> (clojure.string\/split-lines dr)\n       (map clean-directory-line)\n       (map process-directory-line)))\n\n(defn format-line [{:keys [name address number]}]\n  (str \"Phone => \" number \", Name => \" name \", Address => \" address))\n\n(defn phone [directory phone-number]\n  (let [data (process-directory directory)\n        lookup-result\n        (->> data\n             (filter (fn [{:keys [number]}] (= number phone-number)))\n             (map format-line))]\n    (cond\n      (empty? lookup-result) (str \"Error => Not found: \" phone-number)\n      (< 1 (count lookup-result)) (str \"Error => Too many people: \" phone-number)\n      :else (first lookup-result))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"56bdd0aec5dc03d7780010a5":[{"id":17278,"user_id":53,"body":"(ns kata)\n(defn next_higher [n]\n  (if (zero? n) 0\n    (let [r (bit-and n (* -1 n))\n          p (+ n r)\n          q (quot (bit-xor n p) (* 4 r))\n          m (bit-or p q)]\n      m)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17279,"user_id":null,"body":"(ns kata)\n(defn next_higher [n]\n  ;; your code here\n  (let [a (Integer\/toBinaryString n)\n        b (into {} (map #(assoc {} %1 %2) (range (- (count a) 1) -1 -1) (clojure.string\/split a #\"\")))\n        c (into {} (filter (fn [[k v]] (= v \"0\")) b))\n        d (into {} (filter (fn [[k v]] (= v \"1\")) b))\n        e (if (= (count c) 0)\n            (- (reduce * (take (+ (key (apply max-key key d)) 1) (repeat 2))) (reduce * (take (key (apply max-key key d)) (repeat 2))))\n            (if (> (key (apply min-key key d)) (key (apply max-key key c)))\n              (- (+ (reduce * (take (+ (key (apply max-key key d)) 1) (repeat 2))) (- (reduce * (take (- (count d) 1) (repeat 2))) 1)) (reduce + (map #(reduce * (take %1 (repeat 2))) (keys d))))\n              (if (> (key (apply min-key key d)) (key (apply min-key key c)))\n                (let [f (into {} (filter (fn [[k v]] (> k (key (apply min-key key d)))) c))\n                      g (into {} (filter (fn [[k v]] (< k (key (apply min-key key f)))) d))]\n                  (- (+ (reduce * (take (+ (key (apply max-key key g)) 1) (repeat 2))) (- (reduce * (take (- (count g) 1) (repeat 2))) 1)) (reduce + (map #(reduce * (take %1 (repeat 2))) (keys g)))))\n                (- (reduce * (take (key (apply min-key key c)) (repeat 2))) (reduce * (take (- (key (apply min-key key c)) 1) (repeat 2)))))))]\n    (+ n e))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17280,"user_id":645,"body":"(ns kata)\n(defn next_higher [n]\n  (if (= n 0)\n    0\n    (let [o (bit-and n (- 0 n))\n          v (+ n o)\n          p (bit-shift-right (int (\/ (bit-xor n v) o)) 2)]\n      (bit-or v p))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17281,"user_id":null,"body":"(ns kata)\n(defn next_higher [n]\n \n (defn count-1ns [n] \n (reduce + (map #(Character\/getNumericValue %) (Integer\/toBinaryString n))))\n  \n (def nss (count-1ns n))\n (def nxxt (+ n 1))\n (loop [ nxt nxxt  ori nss]\n   (if (== (count-1ns nxt) ori) nxt\n     (recur (inc nxt) ori))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17282,"user_id":null,"body":"(ns kata)\n(defn next_higher [x]\n  (let [bin (Integer\/toString x 2)\n        one-count (count (filter #(= \\1 %) bin))]\n  (loop [n (inc x)]\n    (let [bin-n (Integer\/toString n 2)\n          n-ones (count (filter #(= \\1 %) bin-n))]\n      (if (= n-ones one-count)\n        n\n        (recur (inc n)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17283,"user_id":null,"body":"(ns kata)\n(defn next_higher [n]\n  (defn number-of-ones [x] ((frequencies (Integer\/toBinaryString x)) \\1))\n\n  (let [target (number-of-ones n)]\n    (first (for [x (range (inc n) (bit-shift-left 1 30))\n                  :when (= (number-of-ones x) target)] x))\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17284,"user_id":null,"body":"(ns kata)\n\n(defn count-ones [n]\n  (count (filter #(= \\1 %) (Integer\/toBinaryString n))))\n\n(defn next_higher [n]\n  (loop [curr (+ n 1)]\n    (if (= (count-ones curr) (count-ones n))\n      curr\n      (recur (+ curr 1))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"56c5847f27be2c3db20009c3":[{"id":17285,"user_id":null,"body":"(ns kata)\n\n(defn subtract_sum [n] \"apple\")","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17286,"user_id":564,"body":"(ns kata)\n\n;; Maybe a good starting place? https:\/\/en.wikipedia.org\/wiki\/Casting_out_nines\n(defn subtract_sum [_] \"apple\")\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17287,"user_id":645,"body":"(ns kata)\n(defn subtract_sum [_] \"apple\")","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17288,"user_id":527,"body":"(ns kata)\n(def subtract_sum (constantly \"apple\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17289,"user_id":null,"body":"(ns kata)\n\n(defn digit-sum [numb]\n  (->> (str numb)\n       (vec)\n       (map #(Character\/digit % 10))\n       (reduce +)))\n\n(defn diff [numb]\n  (- numb (digit-sum numb)))\n\n(def str-dictionary\n  \"1-kiwi\n2-pear\n3-kiwi\n4-banana\n5-melon\n6-banana\n7-melon\n8-pineapple\n9-apple\n10-pineapple\n11-cucumber\n12-pineapple\n13-cucumber\n14-orange\n15-grape\n16-orange\n17-grape\n18-apple\n19-grape\n20-cherry\n21-pear\n22-cherry\n23-pear\n24-kiwi\n25-banana\n26-kiwi\n27-apple\n28-melon\n29-banana\n30-melon\n31-pineapple\n32-melon\n33-pineapple\n34-cucumber\n35-orange\n36-apple\n37-orange\n38-grape\n39-orange\n40-grape\n41-cherry\n42-pear\n43-cherry\n44-pear\n45-apple\n46-pear\n47-kiwi\n48-banana\n49-kiwi\n50-banana\n51-melon\n52-pineapple\n53-melon\n54-apple\n55-cucumber\n56-pineapple\n57-cucumber\n58-orange\n59-cucumber\n60-orange\n61-grape\n62-cherry\n63-apple\n64-cherry\n65-pear\n66-cherry\n67-pear\n68-kiwi\n69-pear\n70-kiwi\n71-banana\n72-apple\n73-banana\n74-melon\n75-pineapple\n76-melon\n77-pineapple\n78-cucumber\n79-pineapple\n80-cucumber\n81-apple\n82-grape\n83-orange\n84-grape\n85-cherry\n86-grape\n87-cherry\n88-pear\n89-cherry\n90-apple\n91-kiwi\n92-banana\n93-kiwi\n94-banana\n95-melon\n96-banana\n97-melon\n98-pineapple\n99-apple\n100-pineapple\")\n\n(defn get-dictionary [dict]\n  (-> dict\n      (clojure.string\/split #\"\n\")\n      (->> (map #(rest (first (re-seq #\"(\\d+)-(\\S+)\" %))))\n           (map #(apply hash-map %))\n           (reduce merge))))\n\n(defn subtract_sum [n]\n  (cond (>= 100 n 1) (->> n\n                         (diff)\n                         (str)\n                         (get (get-dictionary str-dictionary)))\n        :else (->> n\n                   (iterate diff)\n                   (drop-while #(not (>= 100 % 1)))\n                   (first)\n                   (str)\n                   (get (get-dictionary str-dictionary)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17290,"user_id":null,"body":"(ns kata)\n\n(def fruit-list \n  {1 \"kiwi\"\n2 \"pear\"\n3 \"kiwi\"\n4 \"banana\"\n5 \"melon\"\n6 \"banana\"\n7 \"melon\"\n8 \"pineapple\"\n9 \"apple\"\n10 \"pineapple\"\n11 \"cucumber\"\n12 \"pineapple\"\n13 \"cucumber\"\n14 \"orange\"\n15 \"grape\"\n16 \"orange\"\n17 \"grape\"\n18 \"apple\"\n19 \"grape\"\n20 \"cherry\"\n21 \"pear\"\n22 \"cherry\"\n23 \"pear\"\n24 \"kiwi\"\n25 \"banana\"\n26 \"kiwi\"\n27 \"apple\"\n28 \"melon\"\n29 \"banana\"\n30 \"melon\"\n31 \"pineapple\"\n32 \"melon\"\n33 \"pineapple\"\n34 \"cucumber\"\n35 \"orange\"\n36 \"apple\"\n37 \"orange\"\n38 \"grape\"\n39 \"orange\"\n40 \"grape\"\n41 \"cherry\"\n42 \"pear\"\n43 \"cherry\"\n44 \"pear\"\n45 \"apple\"\n46 \"pear\"\n47 \"kiwi\"\n48 \"banana\"\n49 \"kiwi\"\n50 \"banana\"\n51 \"melon\"\n52 \"pineapple\"\n53 \"melon\"\n54 \"apple\"\n55 \"cucumber\"\n56 \"pineapple\"\n57 \"cucumber\"\n58 \"orange\"\n59 \"cucumber\"\n60 \"orange\"\n61 \"grape\"\n62 \"cherry\"\n63 \"apple\"\n64 \"cherry\"\n65 \"pear\"\n66 \"cherry\"\n67 \"pear\"\n68 \"kiwi\"\n69 \"pear\"\n70 \"kiwi\"\n71 \"banana\"\n72 \"apple\"\n73 \"banana\"\n74 \"melon\"\n75 \"pineapple\"\n76 \"melon\"\n77 \"pineapple\"\n78 \"cucumber\"\n79 \"pineapple\"\n80 \"cucumber\"\n81 \"apple\"\n82 \"grape\"\n83 \"orange\"\n84 \"grape\"\n85 \"cherry\"\n86 \"grape\"\n87 \"cherry\"\n88 \"pear\"\n89 \"cherry\"\n90 \"apple\"\n91 \"kiwi\"\n92 \"banana\"\n93 \"kiwi\"\n94 \"banana\"\n95 \"melon\"\n96 \"banana\"\n97 \"melon\"\n98 \"pineapple\"\n99 \"apple\"\n100 \"pineapple\"})\n\n(defn subtract_sum [n]\n  (if (and (>= n 10) (<= n 10000))\n    (let [sum (reduce + (map #(- (int %) 48) (str n)))\n          new-n (- n sum)]\n      (if (<= new-n 100)\n        (fruit-list new-n)\n        (recur new-n)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17291,"user_id":null,"body":"(ns kata)\n(require '[clojure.string :as str])\n\n(def fruit-list [\"kiwi\" \"pear\" \"kiwi\" \"banana\" \"melon\" \"banana\" \"melon\" \"pineapple\" \"apple\" \"pineapple\" \"cucumber\" \"pineapple\" \"cucumber\" \"orange\" \"grape\" \"orange\" \"grape\" \"apple\" \"grape\" \"cherry\" \"pear\" \"cherry\" \"pear\" \"kiwi\" \"banana\" \"kiwi\" \"apple\" \"melon\" \"banana\" \"melon\" \"pineapple\" \"melon\" \"pineapple\" \"cucumber\" \"orange\" \"apple\" \"orange\" \"grape\" \"orange\" \"grape\" \"cherry\" \"pear\" \"cherry\" \"pear\" \"apple\" \"pear\" \"kiwi\" \"banana\" \"kiwi\" \"banana\" \"melon\" \"pineapple\" \"melon\" \"apple\" \"cucumber\" \"pineapple\" \"cucumber\" \"orange\" \"cucumber\" \"orange\" \"grape\" \"cherry\" \"apple\" \"cherry\" \"pear\" \"cherry\" \"pear\" \"kiwi\" \"pear\" \"kiwi\" \"banana\" \"apple\" \"banana\" \"melon\" \"pineapple\" \"melon\" \"pineapple\" \"cucumber\" \"pineapple\" \"cucumber\" \"apple\" \"grape\" \"orange\" \"grape\" \"cherry\" \"grape\" \"cherry\" \"pear\" \"cherry\" \"apple\" \"kiwi\" \"banana\" \"kiwi\" \"banana\" \"melon\" \"banana\" \"melon\" \"pineapple\" \"apple\" \"pineapple\"])\n\n(defn new-n\n  [n]\n  (as-> n input\n    (str input)\n    (str\/split input #\"\")\n    (map #(read-string %) input)\n    (reduce + input)\n    (- n input)))\n\n(defn subtract_sum [n]\n  (let [ current-n (new-n n)]\n    (cond (< current-n (inc (count fruit-list)))\n      (get fruit-list (dec current-n))\n    :else (subtract_sum current-n)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17292,"user_id":null,"body":"(ns kata)\n(defn subtract_sum [n]\n  ;; the first n in the list will ALWAYS be 99\n  \"apple\"\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17293,"user_id":null,"body":"(ns kata)\n\n(def fruits {\n             1 \"kiwi\"\n             2 \"pear\"\n             3 \"kiwi\"\n             4 \"banana\"\n             5 \"melon\"\n             6 \"banana\"\n             7 \"melon\"\n             8 \"pineapple\"\n             9 \"apple\"\n             10 \"pineapple\"\n             11 \"cucumber\"\n             12 \"pineapple\"\n             13 \"cucumber\"\n             14 \"orange\"\n             15 \"grape\"\n             16 \"orange\"\n             17 \"grape\"\n             18 \"apple\"\n             19 \"grape\"\n             20 \"cherry\"\n             21 \"pear\"\n             22 \"cherry\"\n             23 \"pear\"\n             24 \"kiwi\"\n             25 \"banana\"\n             26 \"kiwi\"\n             27 \"apple\"\n             28 \"melon\"\n             29 \"banana\"\n             30 \"melon\"\n             31 \"pineapple\"\n             32 \"melon\"\n             33 \"pineapple\"\n             34 \"cucumber\"\n             35 \"orange\"\n             36 \"apple\"\n             37 \"orange\"\n             38 \"grape\"\n             39 \"orange\"\n             40 \"grape\"\n             41 \"cherry\"\n             42 \"pear\"\n             43 \"cherry\"\n             44 \"pear\"\n             45 \"apple\"\n             46 \"pear\"\n             47 \"kiwi\"\n             48 \"banana\"\n             49 \"kiwi\"\n             50 \"banana\"\n             51 \"melon\"\n             52 \"pineapple\"\n             53 \"melon\"\n             54 \"apple\"\n             55 \"cucumber\"\n             56 \"pineapple\"\n             57 \"cucumber\"\n             58 \"orange\"\n             59 \"cucumber\"\n             60 \"orange\"\n             61 \"grape\"\n             62 \"cherry\"\n             63 \"apple\"\n             64 \"cherry\"\n             65 \"pear\"\n             66 \"cherry\"\n             67 \"pear\"\n             68 \"kiwi\"\n             69 \"pear\"\n             70 \"kiwi\"\n             71 \"banana\"\n             72 \"apple\"\n             73 \"banana\"\n             74 \"melon\"\n             75 \"pineapple\"\n             76 \"melon\"\n             77 \"pineapple\"\n             78 \"cucumber\"\n             79 \"pineapple\"\n             80 \"cucumber\"\n             81 \"apple\"\n             82 \"grape\"\n             83 \"orange\"\n             84 \"grape\"\n             85 \"cherry\"\n             86 \"grape\"\n             87 \"cherry\"\n             88 \"pear\"\n             89 \"cherry\"\n             90 \"apple\"\n             91 \"kiwi\"\n             92 \"banana\"\n             93 \"kiwi\"\n             94 \"banana\"\n             95 \"melon\"\n             96 \"banana\"\n             97 \"melon\"\n             98 \"pineapple\"\n             99 \"apple\"\n             100 \"pineapple\"})\n\n(defn sum-individual-numbers [n]\n  (reduce + (map #(Character\/digit % 10) (str n))))\n\n(defn subtract_sum [n]\n  (let [fruit-to-find (- n (sum-individual-numbers n))]\n    (if (nil? (get fruits fruit-to-find))\n      (subtract_sum fruit-to-find)\n      (get fruits fruit-to-find))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17294,"user_id":null,"body":"(ns kata\n  (:require [clojure.string :refer [split-lines split]]))\n\n\n\n(defn sts-seq\n  \"Given `n`, subtract the sum of its digits\"\n  [n]\n  (let [seq-of-ints (map #(Character\/digit % 10) (seq (str n)))\n        sum (reduce + seq-of-ints)]\n    (- n sum)))\n\n\n(def fruits\n  \"1-kiwi\n2-pear\n3-kiwi\n4-banana\n5-melon\n6-banana\n7-melon\n8-pineapple\n9-apple\n10-pineapple\n11-cucumber\n12-pineapple\n13-cucumber\n14-orange\n15-grape\n16-orange\n17-grape\n18-apple\n19-grape\n20-cherry\n21-pear\n22-cherry\n23-pear\n24-kiwi\n25-banana\n26-kiwi\n27-apple\n28-melon\n29-banana\n30-melon\n31-pineapple\n32-melon\n33-pineapple\n34-cucumber\n35-orange\n36-apple\n37-orange\n38-grape\n39-orange\n40-grape\n41-cherry\n42-pear\n43-cherry\n44-pear\n45-apple\n46-pear\n47-kiwi\n48-banana\n49-kiwi\n50-banana\n51-melon\n52-pineapple\n53-melon\n54-apple\n55-cucumber\n56-pineapple\n57-cucumber\n58-orange\n59-cucumber\n60-orange\n61-grape\n62-cherry\n63-apple\n64-cherry\n65-pear\n66-cherry\n67-pear\n68-kiwi\n69-pear\n70-kiwi\n71-banana\n72-apple\n73-banana\n74-melon\n75-pineapple\n76-melon\n77-pineapple\n78-cucumber\n79-pineapple\n80-cucumber\n81-apple\n82-grape\n83-orange\n84-grape\n85-cherry\n86-grape\n87-cherry\n88-pear\n89-cherry\n90-apple\n91-kiwi\n92-banana\n93-kiwi\n94-banana\n95-melon\n96-banana\n97-melon\n98-pineapple\n99-apple\n100-pineapple\")\n\n(defn parse-line [s]\n  (let [[num fruit] (split s #\"-\")]\n    [(Integer\/parseInt num) fruit]))\n\n(def lookup (into {} (map parse-line (split-lines fruits))))\n\n\n(defn subtract_sum [n]\n  (let [key (first (drop-while #(> % 100) (iterate sts-seq 325)))]\n    (get lookup key)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"56cac350145912e68b0006f0":[{"id":17295,"user_id":492,"body":"(ns arrangestring.core)\n(require '[clojure.string :as str])\n\n(defn swap [i v] \n   (assoc v (inc i) (v i) i (v (inc i))))\n\n(defn arrange-aux [i n z]\n  (if (>= i (- n 1))\n    z\n    (let [\n          res \n          (if (or (and (odd? i) (< (count (z i)) (count (z (+ i 1)))))\n                  (and (even? i) (> (count (z i)) (count (z (+ i 1))))))\n            (swap i z)\n            z)\n         ]\n      (arrange-aux (inc i) n res))))\n\n(defn arrange [strng]\n  (let [arr (str\/split strng #\" \")\n        r (arrange-aux 0 (count arr) arr)\n        rr (map-indexed (fn [i item]\n                          (if (even? i) \n                            (str\/lower-case item)\n                            (str\/upper-case item)))\n                        r)\n       ]\n    (str\/join \" \" rr)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17296,"user_id":null,"body":"(ns arrangestring.core\n  (require [clojure.string :as str]))\n\n(defn swap-m-with-n [xs a b]\n  (concat (take a xs) [(nth xs b)] [(nth xs a)] (drop (inc b) xs)))\n\n(defn swap-dir [f]\n  (if (= f <=) >= <=))\n\n(defn arrange-str [xs]\n  (loop [xs xs\n         i 0\n         oper <=]\n    (if (= i (dec (count xs)))\n      xs\n      (if (not (oper (count (nth xs i)) (count (nth xs (inc i)))))\n        (recur (swap-m-with-n xs i (inc i)) (inc i) (swap-dir oper))\n        (recur xs (inc i) (swap-dir oper))))))\n\n(defn arrange [s]\n  (->> (str\/split s #\" \") \n       (arrange-str)\n       (map-indexed (fn [ix i] (if (even? ix) (str\/lower-case i) (str\/upper-case i))))\n       (str\/join \" \")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17297,"user_id":null,"body":"(ns arrangestring.core\n  (:require [clojure.string :refer [split lower-case upper-case join]]))\n\n(defn swap [arr a b] \n  (assoc arr b (arr a) a (arr b)))\n\n(defn arrange-arr [arr i]\n  (if (= i (count arr)) arr\n    (if ((if (odd? i) <= >=) (count (arr (dec i))) (count (arr i)))\n      (recur arr (inc i))\n      (recur (swap arr (dec i) i) (inc i)))))\n\n(defn arrange [strng]\n  (->> (arrange-arr (split strng #\" \") 1)\n       (map #(% %2) (cycle [lower-case upper-case]))\n       (join \\space)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17298,"user_id":null,"body":"(ns arrangestring.core)\n\n(defn zip [a b]\n  (map list a b))\n\n(defn split-words-0 [result w s]\n  (cond \n    (empty? s) (conj result w)\n    (= (first s) \\space) (recur (conj result w) () (rest s))\n    :else (recur result (concat w (list (first s))) (rest s))))\n\n(defn split-words [s]\n  (->> (split-words-0 [] () (seq s))\n       (filter not-empty)\n       (map (partial apply str))))\n\n(defn join-words-0 [words]\n  (if (<= (count words) 1)\n    words\n    (concat (list (first words) \\space) (join-words-0 (rest words)))))\n\n(defn join-words [s]\n  (apply str (join-words-0 s)))\n\n(defn arrange-0 [result words change]\n  (let [a (first words) r (rest words) b (first r) c (rest r)]\n    (if (empty? b)\n      (conj result a)\n      (if (= (compare (count a) (count b)) change)\n        (recur (conj result b) (cons a c) (- change))\n        (recur (conj result a) (cons b c) (- change))\n      ))))\n\n(defn odd-upper-case [n s]\n  (if (odd? n) (clojure.string\/upper-case s) (clojure.string\/lower-case s)))\n\n(defn arrange-1 [strng]\n  (->> (arrange-0 [] (split-words strng) 1)\n       (zip (range))\n       (map (partial apply odd-upper-case))\n       (join-words)))\n       \n(defn arrange [strng]\n  (if (empty? strng)\n    \"\"\n    (arrange-1 strng)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17299,"user_id":null,"body":"(ns arrangestring.core)\n\n(defn vec-swap\n  [v i1 i2]\n  (assoc (assoc v i1 (v i2)) i2 (v i1)))\n\n\n(defn up-down-word-length-sort\n  [v]\n  (loop [i 0\n         swap-options [> <]\n         words v]\n    (if (< i (dec (count words)))\n      (recur (inc i)\n             swap-options\n             (if ((swap-options (mod i 2)) (count (words i)) (count (words (inc i))))\n               (vec-swap words i (inc i))\n               words))\n      words)))\n\n(defn up-down-capitalization\n  [v]\n  (map-indexed (fn [i word]\n                 (if (zero? (mod i 2))\n                   (clojure.string\/lower-case word)\n                   (clojure.string\/upper-case word)))\n               v))\n\n(defn arrange\n  [strng]\n  (->> (clojure.string\/split strng #\" \")\n       (up-down-word-length-sort)\n       (up-down-capitalization)\n       (clojure.string\/join \" \")))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17300,"user_id":null,"body":"(ns arrangestring.core)\n\n(defn swap-strings [input pos up]\n  (let [cmp (if (= up true) > <)\n        adj (inc pos)\n        a (input pos)\n        b (input adj)]\n       (if (cmp (count a) (count b))\n           (assoc input pos b adj a)\n           input\n       )\n    )\n  )\n\n(defn adjust-case [input pos]\n  (if (= 0 (mod pos 2))\n      (update input pos clojure.string\/lower-case)\n      (update input pos clojure.string\/upper-case)\n  )\n)\n\n(defn do-arrange [input pos direction]\n  (let [next-input (-> \n                       (swap-strings input pos direction)\n                       (adjust-case pos))\n        next-pos (inc pos)\n        next-direction (not direction)]\n      (if (> (- (count input) 1) next-pos)\n       (recur next-input next-pos next-direction)\n       (adjust-case next-input next-pos)\n       )\n  )\n)\n\n(defn arrange [string]\n (if (or (= \"\" string) (nil? string))\n  \"\"\n  (->>\n   (do-arrange (clojure.string\/split string #\" \") 0 true)\n   (clojure.string\/join \" \")\n   )\n  )\n )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17301,"user_id":null,"body":"(ns arrangestring.core\n  (:require [clojure.string :as s]))\n\n(defn- exchange-in-vector\n  \"Exchanges the elements at indices i1 and i2 in the vector v\"\n  [v i1 i2]\n  (->> v\n       (map-indexed\n        (fn [i el]\n          (cond\n            (= i i1) (get v i2)\n            (= i i2) (get v i1)\n            :else el)))\n       (into [])))\n\n(defn- compare-lengths\n  \"Applies the comparison function to the lengths of the words at\n   indices i1 and i2, and returns the result.\"\n  [words i1 i2 comparison]\n  (comparison (count (get words i1)) (count (get words i2))))\n\n(defn- word-exchanger\n  \"Compares the lengths of the words at indices i and i + 1 according\n   to the comparison function, and exchanges the words if the comparison\n   function returns true.\"\n  [words i comparison]\n  (if (compare-lengths words i (inc i) comparison)\n    (exchange-in-vector words i (inc i))\n    words))\n\n(defn- capitalize-every-other\n  \"Upper-cases every other word in a collection of words,\n   and lower-cases the rest\"\n  [words]\n  (->> words\n       (map-indexed\n        (fn [i word]\n          (if (odd? i)\n            (s\/upper-case word)\n            (s\/lower-case word))))))\n\n(defn arrange [string]\n  (loop [words (s\/split string #\" \")\n         comparisons (cycle [> <])\n         i 0]\n    (if (= i (dec (count words)))\n      (->> words capitalize-every-other (s\/join \" \"))\n      (recur (word-exchanger words i (first comparisons))\n             (rest comparisons)\n             (inc i)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17302,"user_id":null,"body":"(ns arrangestring.core)\n\n(defn move-one [result current fn-comp]\n  (if (= 0 (count result))\n    [current]\n    (mapv identity (let [moveable (last result)]\n      (if \n        (fn-comp (count moveable) (count current))\n        (concat (drop-last result) [moveable current])\n        (concat (drop-last result) [current moveable])\n        )))\n    ))\n\n(defn mover [vect]\n  (loop [xs vect\n         result []\n         idx 0]\n    (if (= idx (count xs))\n      result\n      (recur xs (move-one result (get xs idx) (if (= 0 (mod idx 2)) >= <=)) (inc idx))))\n  )\n\n(defn arrange [strng]\n  (->> (clojure.string\/split strng #\" \")\n       (mover)\n       (map-indexed #(let [transform (if (= 0 (mod %1 2)) clojure.string\/lower-case clojure.string\/upper-case)] (transform %2)))\n       (clojure.string\/join \" \")\n      )\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17303,"user_id":null,"body":"(ns arrangestring.core\n  (:require [clojure.string :as string]))\n\n(defn swap-items \n  [i1 i2]\n  [i2 i1])\n  \n(defn bigger-first\n  [i1 i2]\n  (if (< (count i1) (count i2))\n    (swap-items i1 i2)\n    [i1 i2]))\n\n(defn bigger-second\n  [i1 i2]\n  (if (> (count i1) (count i2))\n    (swap-items i1 i2)\n    [i1 i2]))\n\n(defn swap-bigger-one\n  [i i1 i2]\n  (if (odd? i)\n    (bigger-first i1 i2)\n    (bigger-second i1 i2)))\n\n(defn rearrange\n  \"Rearrange words to fit this pattern:\n   length w(O) <= length w(1) >= length w(2) <= length w(3) >= length w(4)...\"\n  [words]\n  (let [[first-word second-word & rest-of-words] words\n        first-pair (swap-bigger-one 0 first-word second-word)]\n    (reduce #(into []\n                (flatten\n                  (conj (pop %1)\n                        (swap-bigger-one (inc (count %1)) (peek %1) %2))))\n            first-pair\n            (into [] rest-of-words))))\n\n(defn nil-or-one-word?\n  [s]\n  (or (nil? s) (not (string\/includes? s \" \"))))\n\n(defn arrange [s]\n  (if (nil-or-one-word? s)\n    s\n    (let [words (string\/split s #\" \")\n          arrangement (rearrange words)]\n      (string\/join \n        \" \"\n        (reduce #(if (odd? (count %1))\n                    (conj %1 (string\/upper-case %2))\n                    (conj %1 (string\/lower-case %2)))\n                []\n                arrangement)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17304,"user_id":null,"body":"(ns arrangestring.core\n  (:require [clojure.string :refer [lower-case upper-case split join]]))\n\n(defn process [data up?]\n  (let [compare (if up? > <)\n        modify (if up? lower-case upper-case)]\n    (if (= 1 (count data))\n      [(modify (first data))]\n      (if (compare (count (first data)) (count (second data)))\n        (cons (modify (second data)) \n              (process (cons (first data) (rest (rest data))) (not up?)))\n      (cons (modify (first data)) (process (rest data) (not up?)))))))\n\n(defn arrange [strng]\n  (join \" \" (process (split strng #\" \") true)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"56cafdabc8cfcc3ad4000a2b":[{"id":17305,"user_id":null,"body":"(ns kata.binary-score)\n\n(defn score [n]\n  (let [bin_str (.toString (biginteger n) 2)]\n    (BigInteger. (clojure.string\/replace bin_str #\"(?<!^)0\" \"1\") 2)\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17306,"user_id":2691,"body":"(ns kata.binary-score)\n\n(defn score [n]\n  (- (.pow (BigInteger\/valueOf 2) (BigInteger\/valueOf (.bitLength (BigInteger. (str n))))) (BigInteger\/valueOf 1))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17307,"user_id":null,"body":"(ns kata.binary-score)\n\n(defn score [n]\n    (let [N (biginteger n)\n          twop (.shiftLeft BigInteger\/ONE (dec (.bitLength N)))]\n          (if (zero? n) 0 (dec (* twop 2)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17308,"user_id":null,"body":"(ns kata.binary-score)\n\n(defn score [n]\n  (reduce + (take-while #(<= % n) (iterate #(* 2 %) 1N))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17309,"user_id":null,"body":"(ns kata.binary-score)\n\n(defn score [n]\n  (let [num-digits (count (take-while pos? (iterate #(quot % 2) n)))]\n    (dec (nth (iterate #(* 2 %) (BigInteger\/valueOf 1)) num-digits))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17310,"user_id":null,"body":"(ns kata.binary-score)\n\n(defn score\n  [n]\n  (dec (first (drop-while (partial >= \n                                   n)\n                          (iterate (partial *\n                                            2)\n                                   1N)))))\n                                   ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17311,"user_id":null,"body":"(ns kata.binary-score)\n\n(defn score [n]\n  (loop [i 1N]\n    (if (> i n) (dec i)\n      (recur (* 2 i)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17312,"user_id":null,"body":"(ns kata.binary-score)\n\n(defn score [n]\n  (if (= n 0)\n    0\n    (-> (.toString (BigInteger. (.toString n)) 2)\n        (clojure.string\/replace #\"0\" \"1\")\n        (BigInteger. 2))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17313,"user_id":null,"body":"(ns kata.binary-score)\n(defn score [n]\n  (defn l2p [n] (if (>= n 1) (inc (l2p (\/ n 2))) 0))\n  (dec (reduce * (repeat (l2p n) 2N))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17314,"user_id":null,"body":"(ns kata.binary-score)\n\n(defn score\n  [n]\n  (if (= 0 n)\n    0\n    (as-> n $\n      (biginteger $)\n      (.toString $ 2)\n      (count $)\n      (repeat $ \"1\")\n      (apply str $)\n      (str \"2r\" $)\n      (read-string $))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"56d0a591c6c8b466ca00118b":[{"id":17315,"user_id":527,"body":"(ns kata.triangular-numbers)\n\n(defn is_triangular [t]\n  (-> t (* 8) inc Math\/sqrt (mod 1) zero?))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17316,"user_id":null,"body":"(ns kata.triangular-numbers)\n\n(defn is_triangular [t]\n  (def sol (* 0.5 (- (Math\/sqrt (+ 1 (* 8 t))) 1)))\n  (= sol (Math\/floor sol))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17317,"user_id":null,"body":"(ns kata.triangular-numbers)\n\n(def triangular-numbers\n  (->> (iterate inc 1)\n       (map #(\/ (* % (inc %)) 2))\n       (take-while #(<= % 2147483646))\n       set))\n\n(defn is_triangular [n] (boolean (triangular-numbers n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17318,"user_id":null,"body":"(ns kata.triangular-numbers)\n\n(defn- triangular [n] (int (\/ (* n (inc n)) 2)))\n\n(defn is_triangular [t]\n  (loop\n    [n 1, v 1]\n    (cond\n      (= v t) true\n      (> v t) false\n      :else (recur (inc n) (triangular (inc n))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17319,"user_id":null,"body":"(ns kata.triangular-numbers)\n\n(defn is_triangular [t]\n  (= t (first (drop-while #(> t %) (reductions + (range))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17320,"user_id":null,"body":"(ns kata.triangular-numbers)\n\n(defn is_triangular [t]\n  (= (* t 2)\n     (int (* (Math\/floor (Math\/sqrt (* 2 t)))\n            (+ 1 (Math\/floor (Math\/sqrt (* 2 t)))))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17321,"user_id":53,"body":"(ns kata.triangular-numbers)\n\n(defn is_triangular [t]\n  (let [m (mod (Math\/sqrt (+ 1 (* 8 t))) 1)]\n  (= 0.0 m)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17322,"user_id":null,"body":"(ns kata.triangular-numbers)\n\n(defn is_triangular [t]\n  (let [triangular-seq (map #(\/ (* % (inc %)) 2) (iterate inc 1))]\n    (= t (first (drop-while #(> t %) triangular-seq)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17323,"user_id":null,"body":"(ns kata.triangular-numbers)\n\n(defn sqrt-of-twice-arg [t]\n  (Math\/floor (Math\/sqrt (* t 2))))\n\n(defn is_triangular [t]\n  (= (* 2 t)\n     (int (* (sqrt-of-twice-arg t) (inc (sqrt-of-twice-arg t))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17324,"user_id":null,"body":"(ns kata.triangular-numbers)\n\n(defn is_triangular [t]\n  (let [n (\/ (- (Math\/sqrt (+ 1 (* 8 t))) 1) 2)]\n    (zero? (- (Math\/floor n) n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"56d3e702fc231fdf72001779":[{"id":17325,"user_id":17,"body":"(ns kata.binary-sxore)(defn sxore [n] (if (= (mod n 4) 0) n (if (= (mod n 4) 1) 1 (if (= (mod n 4) 2) (+ n 1) 0))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17326,"user_id":17,"body":"(ns kata.binary-sxore)(defn sxore [n] (if (= (mod n 4) 0) n (if (= (mod n 4) 1) 1 (if (= (mod n 4) 2) (+ n 1) 0))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17327,"user_id":527,"body":"(ns kata.binary-sxore)\n\n(defn sxore [n]\n  (case (mod n 4)\n    0 n\n    1 1\n    2 (inc n)\n    3 0))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17328,"user_id":527,"body":"(ns kata.binary-sxore)\n\n(defn sxore [n]\n  ([n 1 (inc n) 0] (mod n 4)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17329,"user_id":223,"body":"(ns kata.binary-sxore)\n\n(defn sxore [n]\n  (nth [n 1 (inc n) 0] (mod n 4))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17330,"user_id":null,"body":"(ns kata.binary-sxore)\n\n(defn sxore [n]\n  (println n)\n  (if (= 0 n)\n    0\n    (let [r (rem (dec n) 4)]\n      (cond (= r 0) 1\n            (= r 1) (inc n)\n            (= r 2) 0\n            (= r 3) n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17331,"user_id":null,"body":"(ns kata.binary-sxore)\n\n(defn sxore [n]\n  ({1 1 2 (inc n) 3 0} (mod n 4) n))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17332,"user_id":null,"body":"(ns kata.binary-sxore)\n\n(defn sxore [n]\n  (let [rn (rem n 4)]\n    (cond\n       (= rn 0) n\n       (= rn 1) 1\n       (= rn 2) (inc n)\n       (= rn 3) 0)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17333,"user_id":null,"body":"(ns kata.binary-sxore)\n\n(defn sxore [n]\n  (case (rem n 4)\n    0 n\n    1 1\n    2 (inc n)\n    3 0))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17334,"user_id":null,"body":"(ns kata.binary-sxore)\n\n(defn sxore [n]\n  (nth [n 1 (+ n 1) 0] (mod n 4))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"56dbe0e313c2f63be4000b25":[{"id":17335,"user_id":null,"body":"(ns opstrings.core\n  (:require [clojure.string :as string]))\n\n(defn vert-mirror [s]\n  (->> (string\/split-lines s)\n       (map string\/reverse)\n       (string\/join \newline)))\n\n(defn hor-mirror [s]\n  (->> (string\/split-lines s)\n       (reverse)\n       (string\/join \newline)))\n\n(defn oper [f s]\n  (f s))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17336,"user_id":null,"body":"(ns opstrings.core\n  (:require [clojure.string :as s]))\n\n(defn split\n  [string]\n  (map seq (s\/split string #\"\n\")))\n\n(defn join\n  [charvecs]\n  (s\/join \"\n\" (map s\/join charvecs)))\n\n(def hor-mirror reverse)\n\n(def vert-mirror (partial map reverse))\n\n(defn oper [f string]\n  (-> string\n      (split)\n      (f)\n      (join)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17337,"user_id":null,"body":"(ns opstrings.core)\n\n(defn vert-mirror [strng]\n  (map clojure.string\/reverse strng))\n  \n(defn hor-mirror [strng]\n  (reverse strng))\n  \n(defn oper [fct s]\n  (clojure.string\/join \"\n\" (fct (clojure.string\/split-lines s))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17338,"user_id":null,"body":"(ns opstrings.core\n  (:require [clojure.string :as str]))\n\n(defn vert-mirror [s]\n  (str\/join \"\n\" \n    (map str\/reverse \n      (str\/split-lines s))))\n(defn hor-mirror [s]\n  (str\/join \"\n\" \n    (reverse \n      (str\/split-lines s))))\n(defn oper [fct s]\n  (fct s))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17339,"user_id":null,"body":"(ns opstrings.core\n  (:require [clojure.string :as str]))\n\n(defn vert-mirror [s]\n  (->> (str\/split-lines s)\n       (map str\/reverse)\n       (str\/join \newline)))\n\n(defn hor-mirror [s]\n  (->> (str\/split-lines s)\n       reverse\n       (str\/join \newline)))\n\n(defn oper [f s]\n  (f s))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17340,"user_id":null,"body":"(ns opstrings.core\n  (:require [clojure.string :as str]))\n\n(defn vert-mirror [s]\n  (->> (str\/split s #\"\n\")\n       (map (comp str\/join reverse))\n       (str\/join \"\n\")))\n\n(defn hor-mirror [s]\n  (->> (str\/split s #\"\n\")\n       reverse\n       (str\/join \"\n\")))\n\n(defn oper [fct s]\n  (fct s))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17341,"user_id":492,"body":"(ns opstrings.core)\n(require '[clojure.string :as str])\n\n(defn vert-mirror [strng]\n  (str\/join \"\n\" (map (fn [x] (str\/reverse x)) (str\/split strng #\"\n\"))))\n(defn hor-mirror [strng]\n  (str\/join \"\n\" (reverse (str\/split strng #\"\n\"))))\n(defn oper [fct s]\n  (fct s))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17342,"user_id":492,"body":"(ns opstrings.core)\n(require '[clojure.string :as str])\n\n(defn vert-mirror [strng]\n  (str\/join \"\n\" (map (fn [x] (str\/reverse x)) (str\/split strng #\"\n\"))))\n(defn hor-mirror [strng]\n  (str\/join \"\n\" (reverse (str\/split strng #\"\n\"))))\n(defn oper [fct s]\n  (fct s))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17343,"user_id":null,"body":"(ns opstrings.core)\n\n(defn vert-mirror [ssquare]\n  (map #(apply str (reverse %)) ssquare))\n\n(defn hor-mirror [ssquare]\n  (reverse ssquare))\n  \n(defn oper [fct s]\n  (apply str \n    (interpose \"\n\" \n               (fct (clojure.string\/split-lines s)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17344,"user_id":null,"body":"(ns opstrings.core)\n(require '[clojure.string :as str])\n\n(defn hor-mirror [strng]\n  ( -> strng\n    (str\/split #\"\n\")\n    (reverse)\n    (->> (str\/join \"\n\")) ; (join sep coll), cringe\n  )\n)\n\n(defn vert-mirror [strng]\n  ( -> strng\n    (str\/reverse)\n    (hor-mirror)\n  )\n)\n\n(defn oper [fct s]\n  (fct s)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"56dbe7f113c2f63570000b86":[{"id":17345,"user_id":null,"body":"(ns opstrings1.core\n(:require [clojure.string :as s]))\n\n(defn repeat-dots [s]\n  (s\/join \"\" (repeat (count s) \".\")))\n\n(defn rot [strng]\n  (->>  strng\n        (s\/split-lines)\n        (reverse)\n        (map s\/reverse)\n        (s\/join \newline)))\n        \n(defn selfie-and-rot [strng]\n  (let [initial (->> strng\n                     (s\/split-lines)\n                     (map #(s\/join \"\" [% (repeat-dots %)]))\n                     (s\/join \newline))\n        final (->> strng\n                   (s\/split-lines)\n                   (map #(s\/join \"\" [% (repeat-dots %)]))\n                   (s\/join \newline)\n                   (rot))]\n  (s\/join \newline [initial final])))\n   \n(defn oper [fct s]\n  (fct s))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17346,"user_id":492,"body":"(ns opstrings1.core)\n(require '[clojure.string :as str])\n\n(defn vert-mirror [strng]\n  (str\/join \"\n\" (map (fn [x] (str\/reverse x)) (str\/split strng #\"\n\"))))\n(defn hor-mirror [strng]\n  (str\/join \"\n\" (reverse (str\/split strng #\"\n\"))))\n(defn rot [strng]\n  (vert-mirror (hor-mirror strng)))\n(defn selfie-and-rot [strng]\n  (defn- rep-str [n c]\n    (apply str (repeat n c)))\n  (let [\n        r1 (str\/join \"\n\" (map (fn[x] (str x (rep-str (count x) \".\"))) (str\/split strng #\"\n\")))\n        r2 (str\/join \"\n\" (map (fn[x] (str (rep-str (count x) \".\") x)) (str\/split (rot strng) #\"\n\")))\n       ] \n    (str r1 \"\n\" r2)))\n(defn oper [fct s]\n  (fct s))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17347,"user_id":null,"body":"(ns opstrings1.core\n\t(:require [clojure.string :as strng :refer [split-lines join]]))\n\n(defn rot [s]\n  (strng\/reverse s))\n\n(defn selfie-and-rot [s]\n  (let [ss (split-lines s)\n        rss (split-lines (rot s))\n        ds (join (repeat (count (first ss)) \".\"))]\n    (str (join (str ds \"\n\") ss)\n         (str ds \"\n\" ds)\n         (join (str \"\n\" ds) rss))))\n\n(defn oper [f s]\n  (f s))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17348,"user_id":null,"body":"(ns opstrings1.core\n  (:require [clojure.string :refer [split split-lines join]]))\n\n(def reverse-str clojure.string\/reverse)\n\n(defn rot [strng]\n  (->> strng\n    split-lines\n    (map reverse-str)\n    reverse\n    (join \"\n\")\n    )\n  )\n(defn selfie-and-rot [strng]\n  (let [rl (int (Math\/sqrt (count strng)))\n        rs (rot strng)\n        ds (apply str (repeat rl \\.))]\n    (join \"\n\"\n          (concat\n           (->> strng\n             split-lines\n             (map #(str % ds))\n             )\n           (->> rs\n             split-lines\n             (map #(str ds %))\n             )\n           )\n          )\n    )\n  )\n(defn oper [fct s]\n  (fct s)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17349,"user_id":null,"body":"(ns opstrings1.core)\n(require '[clojure.string :as str])\n\n(defn rot [strng]\n  (str\/join \"\n\" (->> (reverse (str\/split strng #\"\n\"))\n                      (map reverse)\n                      (map #(apply str %)))))\n\n(defn selfie-and-rot [strng]\n  (let [x (map #(str % (apply str (repeat (count %) \".\"))) (str\/split strng #\"\n\"))]\n    (str\/join \"\n\" (concat x (map #(apply str %) (map reverse (reverse x)))))))\n\n(defn oper [fct s]\n  (fct s))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17350,"user_id":null,"body":"(ns opstrings1.core\n  (:require [clojure.string :as string]))\n\n;; helper functions\n(def un-lines (partial string\/join \"\n\"))\n(def reverse-all (partial map string\/reverse))\n\n(def rot\n  (comp\n    un-lines\n    reverse-all\n    reverse\n    string\/split-lines))\n\n(defn selfie-and-rot [strng]\n  (let [lines     (string\/split-lines strng)\n        length    (count lines) ; assumes the string is a square\n        dots      (apply str (repeat length \".\"))\n        with-dots (map #(str % dots) lines)]\n    (un-lines (concat with-dots (reverse-all (reverse with-dots))))))\n\n(defn oper [fct s] (fct s))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17351,"user_id":null,"body":"(ns opstrings1.core\n  (:require [clojure.string :as str]))\n\n(defn rot [s]\n  (->> (str\/split-lines s)\n       (map str\/reverse)\n       (reverse)\n       (str\/join \newline)))\n\n(defn- selfie [s]\n  (->> (str\/split-lines s)\n       (map #(str % (str\/join (repeat (count %) \".\"))))\n       (str\/join \newline)))\n\n(defn selfie-and-rot [s]\n  (let [selfie (selfie s)\n        rot (str\/reverse selfie)]\n    (str selfie \newline rot)))\n\n(defn oper [fun s]\n  (fun s))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17352,"user_id":null,"body":"(ns opstrings1.core)\n\n(defn rot [strng]\n  (as-> strng $\n    (clojure.string\/split $ #\"\n\")\n    (map clojure.string\/reverse $)\n    (reverse $)\n    (clojure.string\/join \"\n\" $)))\n\n(defn selfie-and-rot [strng]\n  (as->\n    strng $\n    (clojure.string\/split $ #\"\n\")\n    (map #(str % (apply str (repeat (count %) \".\"))) $)\n    (clojure.string\/join \"\n\" $)\n    (str $ \"\n\" (rot $))))\n\n(defn oper [fct s]\n  (fct s))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17353,"user_id":201,"body":"(ns opstrings1.core)\n\n(defn rot [strng]\n (clojure.string\/join \"\n\"\n                     (reverse\n                      (map clojure.string\/reverse\n                           (clojure.string\/split strng #\"\n\"))))) \n  \n(defn selfie-and-rot [strng]\n  (clojure.string\/join \"\n\"\n                     (flatten [(map #(str % (apply str (repeat (count %) \".\")))\n                                    (clojure.string\/split strng #\"\n\"))\n                               (reverse\n                                (map #(str (apply str (repeat (count %) \".\")) %)\n                                     (map clojure.string\/reverse\n                                          (clojure.string\/split strng #\"\n\"))))])))\n\n(defn oper [fct s]\n (fct s))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17354,"user_id":null,"body":"(ns opstrings1.core\n  (:require [clojure.string :as str]))\n\n(defn oper [f str]\n  (str\/join \"\n\" (f (str\/split-lines str))))\n\n(defn rot [strs] (reverse (map str\/reverse strs)))\n\n(defn selfie-and-rot [strs]\n  (let [selfie (map #(apply str % (repeat (count %) \".\")) strs)\n        rot (rot selfie)]\n    (concat selfie rot)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"56dbeec613c2f63be4000be6":[{"id":17355,"user_id":null,"body":"(ns opstrings1.core\n  (:require [clojure.string :as str]))\n\n(defn transpose\n  [s]\n  (apply map vector s))\n\n(defn rot-90-clock [s]\n  (->> s\n    transpose\n    (map reverse)\n    (map #(apply str %))))\n    \n(defn diag-1-sym [s]\n  (->> s\n    transpose\n    (map #(apply str %))))\n    \n(defn selfie-and-diag1 [s]\n  (map #(str %1 \\| %2) s (diag-1-sym s)))\n  \n(defn oper [fct s]\n  (->> s\n    str\/split-lines\n    fct\n    (str\/join \"\n\")))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17356,"user_id":492,"body":"(ns opstrings1.core)\n(require '[clojure.string :as str])\n\n(defn transpose [m]\n  (apply mapv vector m))\n(defn rot-90-clock [strng]\n  (str\/join \"\n\" \n            (map (fn [x] (str\/join \"\" x)) \n                 (transpose (map (fn [x] (str\/split x #\"\")) (reverse (str\/split strng #\"\n\")))))))\n(defn diag-1-sym [strng]\n  (let [ b (map (fn [x] (str\/join \"\" x)) (transpose (map (fn [x] (str\/split x #\"\")) (str\/split strng #\"\n\"))))]\n    (str\/join \"\n\" b))) \n(defn selfie-and-diag1 [strng]\n  (let [\n        a1 (str\/split strng #\"\n\")\n        a2 (str\/split (diag-1-sym strng) #\"\n\")\n        a3 (for [i (range 0 (count a1))] (str (a1 i) \"|\" (a2 i)))\n       ]\n    (str\/join \"\n\" a3)))\n(defn oper [fct s]\n  (fct s))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17357,"user_id":null,"body":"(ns opstrings1.core\n  (:require [clojure.string :refer [split split-lines join]]))\n\n(defn rot-90-clock [strng]\n  (let [m (split-lines strng)\n        l (count m)]\n    (join \"\n\"\n          (for [x (range l)]\n            (apply str\n                   (for [y (reverse (range l))]\n                     (get-in m [y x])\n                     )\n                   )\n            )\n          )\n    )\n  )\n(defn diag-1-sym [strng]\n  (let [m (split-lines strng)\n        l (count m)]\n    (join \"\n\"\n          (for [x (range l)]\n            (apply str\n                   (for [y (range l)]\n                     (get-in m [y x])\n                     )\n                   )\n            )\n          )\n    )\n  )\n(defn selfie-and-diag1 [strng]\n  (let [diag (diag-1-sym strng)]\n    (join \"\n\"\n          (map #(str %1 \\| %2)\n               (split-lines strng)\n               (split-lines diag))\n          )\n    )\n  )\n(defn oper [fct s]\n  (fct s)\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17358,"user_id":null,"body":"(ns opstrings1.core\n    (:require [clojure.string :as str]))\n\n(defn rot-90-clock [strng]\n  (str\/join \"\n\" (->> (str\/split-lines strng)\n                      (map vec)\n                      (apply map vector)\n                      (map reverse)\n                      (map #(apply str %)))))\n\n(defn diag-1-sym [strng]\n  (str\/join \"\n\" (->> (str\/split-lines strng)\n                      (map vec)\n                      (apply map vector)\n                      (map #(apply str %)))))\n\n\n(defn selfie-and-diag1 [strng]\n  (let [x (str\/split-lines strng)\n        y (str\/split-lines (diag-1-sym strng))]\n    (str\/join \"\n\" (map (fn [a b] (str a \"|\" b)) x y))))\n\n\n(defn oper [fct s]\n  (fct s))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17359,"user_id":null,"body":"(ns opstrings1.core (:require [clojure.string :as str]))\n\n(defn rot-90-clock [l] (map reverse (apply map list l)))\n(defn diag-1-sym [l] (map reverse (rot-90-clock l)))\n(defn selfie-and-diag1 [l] \n  (map #(str\/join \"|\" (map str\/join %)) \n       (map list l (diag-1-sym l))))\n\n(defn oper [fct s] \n  (let [s2l (map seq (str\/split s #\"\n\"))\n        l2s (fn [e] (str\/join \"\n\" (map str\/join e)))]\n    (l2s (fct s2l))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17360,"user_id":null,"body":"(ns opstrings1.core\n  (:require [clojure.string :as str]))\n\n(defn diag-1-sym [s]\n  (let [rows (str\/split s #\"\n\")\n        cnt (count rows)]\n    (->> (for [pos (range cnt)] (map #(nth % pos) rows))\n         (map (partial apply str)))))\n\n(defn rot-90-clock [strng]\n  (map (partial apply str) (map reverse (diag-1-sym strng))))\n\n(defn selfie-and-diag1 [s]\n  (let [diag (diag-1-sym s)\n        splits (str\/split s #\"\n\")]\n    (map #(str %1 \"|\" %2) splits diag)))\n\n(defn oper [fct s]\n  (str\/join \"\n\" (fct s)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17361,"user_id":null,"body":"(ns opstrings1.core)\n(require '[clojure.string :as s])\n\n(defn transpose [m]\n  (apply mapv vector m))\n\n(defn transpose-strings [m]\n  (->>\n    (apply mapv vector m)\n    (map #(apply str %))))\n\n(defn rot-90-clock [strng]\n  (->>\n    (s\/split strng #\"\n\") ; parse the string input to something we can work with\n    (reverse)\n    (transpose)\n    (map #(apply str %))  ; change each inner vector into a string\n    (s\/join \"\n\")))       ; turn into one string, adding newline characters between items\n\n\n(defn diag-1-sym [strng]\n  (->>\n    (s\/split strng #\"\n\") ; parse the string input to something we can work with\n    (transpose)\n    (map #(apply str %))  ; change each inner vector into a string\n    (s\/join \"\n\")))       ; turn into one string, adding newline characters between items\n\n(defn selfie-and-diag1 [strng]\n  (def before\n    (->>\n      (s\/split strng #\"\n\") ; parse the string input to something we can work with\n      (map #(apply str %))  ; change each inner vector into a string\n      (map #(str % \"|\"))))\n\n  (def after\n    (->>\n      (s\/split (diag-1-sym strng) #\"\n\")\n      (map #(apply str %))\n      (map #(str % \"\n\"))))\n\n  (->>\n    (s\/join (interleave before after))\n    (s\/trim-newline)))\n\n(defn oper [fct s]\n  (fct s))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17362,"user_id":null,"body":"(ns opstrings1.core\n  (:require [clojure.string :refer [split-lines join]]))\n\n(def join-lines (partial join \newline))\n\n(defn diag-1-sym [strng]\n  (->> (split-lines strng)\n       (apply map (fn [& row] (apply str row)))\n       (map (partial apply str))\n       (join-lines)))\n\n(defn rot-90-clock [strng]\n  (->> (diag-1-sym strng)\n       (split-lines)\n       (map clojure.string\/reverse)\n       (join-lines)))\n\n(defn selfie-and-diag1 [strng]\n  (->> (diag-1-sym strng)\n       (split-lines)\n       (map #(str % \"|\" %2) (split-lines strng))\n       (join-lines)))\n\n(defn oper [fct s]\n  (fct s))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17363,"user_id":null,"body":"(ns opstrings1.core\n  (:require [clojure.string :as str]))\n\n(defn rot-90-clock [strng]\n  (->> (str\/split-lines strng)\n       (reduce (fn [res val]\n                 (map #(str %2 %1) res (seq val))))\n       (str\/join \"\n\")))\n\n(defn diag-1-sym [strng]\n  (->> (str\/split-lines strng)\n       reverse\n       (reduce (fn [res val]\n                 (map #(str %2 %1) res (seq val))))\n       (str\/join \"\n\")))\n\n\n(defn selfie-and-diag1 [strng]\n  (str\/join \"\n\" (map #(str %1 \"|\" %2)\n                      (str\/split-lines strng)\n                      (str\/split-lines (diag-1-sym strng)))))\n\n(defn oper [fct s]\n  (fct s))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17364,"user_id":464,"body":"(ns opstrings1.core\n  (:require [clojure.string :as str]))\n\n(defn split-newline [item]\n  (str\/split item #\"\n\"))\n\n(defn join-newline [item]\n  (str\/join \"\n\" item))\n\n(defn diag-1-sym [strng]\n  (join-newline (let [split (split-newline strng)\n         l (count (first split))]\n     (for [i (range l)] (str\/join \"\" (map #(nth %1 i) split))))))\n\n(defn rot-90-clock [strng]\n  (diag-1-sym (join-newline (reverse (split-newline strng)))))\n\n(defn selfie-and-diag1 [strng]\n  (join-newline\n   (let [a (split-newline strng)\n         b (split-newline (diag-1-sym strng))]\n     (map #(str\/join \"|\" %1) (map vector a b)))))\n     \n(defn oper [fct s]\n (fct s))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"56dbf59b0a10feb08c000227":[{"id":17365,"user_id":null,"body":"(ns opstrings1.core\n\t(:require [clojure.string :as strng :refer [split-lines join]]))\n  \n\n(defn diag-2-sym [s]\n  (->> (map strng\/reverse s)\n       reverse\n       (apply map str)))\n\n(defn rot-90-counter [s]\n  (apply map str (map strng\/reverse s)))\n\n(defn selfie-diag2-counterclock [s]\n  (map #(str %1 \"|\" %2 \"|\" %3)\n       s\n       (diag-2-sym s)\n       (rot-90-counter s)))\n\n(defn oper [f s]\n  (->> (split-lines s)\n       f\n       (join \newline)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17366,"user_id":null,"body":"(ns opstrings1.core\n  (:require [clojure.string :as str])\n)\n\n(defn rot-90-counter [lst]\n  (reverse (apply map list lst))\n) \n\n(defn diag-2-sym [lst]\n  (map reverse (rot-90-counter lst))\n)\n\n(defn selfie-diag2-counterclock [lst]\n  (map #(str\/join \"|\" (map str\/join %)) (map list lst (diag-2-sym lst) (rot-90-counter lst)))\n) \n\n(defn oper [fct s]\n  (let [\n    from_str (map seq (str\/split s #\"\n\"))\n    to_str (fn [x] (str\/join \"\n\" (map str\/join x)))\n    ]\n    (to_str (fct from_str))\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17367,"user_id":492,"body":"(ns opstrings1.core)\n(require '[clojure.string :as str])\n\n(defn transpose [m]\n  (apply mapv vector m))\n(defn rot-90-counter [strng]\n  (let [\n        a (map (fn [x] (apply str (reverse x))) (str\/split strng #\"\n\"))\n        b (map (fn [x] (str\/join \"\" x)) (transpose (map (fn [x] (str\/split x #\"\")) a)))\n       ]\n    (str\/join \"\n\" b))) \n(defn diag-2-sym [strng]\n  (let [ a (map (fn [x] (apply str (reverse x))) (str\/split (rot-90-counter strng) #\"\n\")) ]\n    (str\/join \"\n\" a)))\n(defn selfie-diag2-counterclock [strng]\n  (let [\n        a1 (str\/split strng #\"\n\")\n        a2 (str\/split (diag-2-sym strng) #\"\n\")\n        a3 (str\/split (rot-90-counter strng) #\"\n\")\n        a4 (for [i (range 0 (count a1))] (str (a1 i) \"|\" (a2 i) \"|\" (a3 i)))\n       ]\n    (str\/join \"\n\" a4)))\n(defn oper [fct s]\n  (fct s))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17368,"user_id":null,"body":"(ns opstrings1.core\n  (:require [clojure.string :refer [split split-lines join]]))\n\n(def reverse-str clojure.string\/reverse)\n\n(defn transpose [m] (apply map vector m))\n\n(defn rot-90-counter [strng]\n  (let [m (split-lines strng)]\n    (->> m\n      transpose\n      (map #(apply str %))\n      reverse\n      (join \"\n\")\n      )\n    )\n  ) \n(defn diag-2-sym [strng]\n  (let [m (split-lines strng)]\n    (->> m\n      reverse\n      transpose\n      reverse\n      (map #(apply str %))\n      (join \"\n\")\n      )\n    )\n  ) \n(defn selfie-diag2-counterclock [strng]\n  (let [orig (split-lines strng)\n        diag (split-lines (diag-2-sym strng))\n        rot  (split-lines (rot-90-counter strng))]\n    (join \"\n\" (map #(str %1 \\| %2 \\| %3) orig diag rot))\n    )\n  ) \n(defn oper [fct s]\n  (fct s)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17369,"user_id":null,"body":"(ns opstrings1.core (:require [clojure.string :as str]))\n\n(defn s2seq [s] (map seq (str\/split s #\"\n\")))\n(defn s2rv  [s] (reverse (apply map vector (s2seq s))))\n(defn v2s   [l] (str\/join \"\n\" (map str\/join l)))\n\n(defn oper [fct s] (fct s))\n\n(defn rot-90-counter [s] (v2s (s2rv s)))\n(defn diag-2-sym [s] (v2s (map reverse (s2rv s))))\n(defn selfie-diag2-counterclock [s]\n  (let [n (s2seq s) d (map reverse (s2rv s)) r (s2rv s)]\n    (->> (map vector n d r)\n         (map #(map str\/join %))\n         (map #(str\/join \"|\" %))\n         (str\/join \"\n\"))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17370,"user_id":null,"body":"(ns opstrings1.core\n  (:require [clojure.string :as str]))\n\n(defn rot-90-counter [s]\n  (->> (str\/split s #\"\n\")\n       (apply map vector)\n       (reverse)\n       (map (partial apply str))))\n\n(defn diag-2-sym [s]\n  (->> (str\/split s #\"\n\")\n       (apply map vector)\n       (map reverse)\n       (reverse)\n       (map (partial apply str)))) \n\n(defn selfie-diag2-counterclock [s]\n  (let [s1 (str\/split s #\"\n\")\n        s2 (diag-2-sym s)\n        s3 (rot-90-counter s)]\n    (map (fn [a b c] (str a \"|\" b \"|\" c)) s1 s2 s3)))\n\n(defn oper [fct s]\n  (str\/join \"\n\" (fct s)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17371,"user_id":null,"body":"(ns opstrings1.core)\n(require '[clojure.string :as string])\n\n\n(defn transpose-strings [m]\n  (->>\n    (apply mapv vector m)\n    (map #(apply str %))))\n\n(defn rot-90-counter [s]\n  (->>\n    (string\/split s #\"\n\")\n    (transpose-strings)\n    (reverse)\n    (string\/join \"\n\")))\n\n(defn diag-2-sym [s]\n  (->>\n    (string\/split s #\"\n\")\n    (reverse)\n    (transpose-strings)\n    (reverse)\n    (string\/join \"\n\")))\n\n(defn selfie-diag2-counterclock [s]\n  (def before\n    (->>\n      (string\/split s #\"\n\")\n      (map #(apply str %))\n      (map #(str % \"|\"))))\n\n  (def diag\n    (->>\n      (string\/split s #\"\n\")\n      (reverse)\n      (transpose-strings)\n      (reverse)\n      (map #(str % \"|\"))))\n\n  (def counter\n    (->>\n      (string\/split s #\"\n\")\n      (transpose-strings)\n      (reverse)\n      (map #(str % \"\n\"))))\n\n  (->>\n    (string\/join (interleave before diag counter))\n    (string\/trim-newline)\n  )\n)\n\n(defn oper [f s]\n  ;; TODO: do something a bit more sophisticated here\n  (f s))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17372,"user_id":null,"body":"(ns opstrings1.core)\n(defn rot-90-counter [strng]\n    (->> (clojure.string\/split strng #\"\n\")\n    (map (comp seq char-array))\n    (apply map vector)\n    reverse\n    (map #(apply str %))))\n    \n(defn diag-2-sym [strng]\n  (->> (clojure.string\/split strng #\"\n\")\n    (map (comp seq char-array))\n    (apply map vector)\n    reverse\n    (map reverse)\n    (map #(apply str %)))) \n    \n(defn selfie-diag2-counterclock [strng]\n  (let [col (clojure.string\/split strng #\"\n\")]\n      (map #(clojure.string\/join \"|\" (vector %1 %2 %3)) col (diag-2-sym strng) (rot-90-counter strng)))) \n\n(defn oper [fct s]\n  (->> s\n    fct    \n    (clojure.string\/join \"\n\"))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17373,"user_id":null,"body":"(ns opstrings1.core\n (:require [clojure.string :as str]))\n\n(defn rot-90-counter [str-parts]\n  (reverse\n    (reduce (fn [res row]\n              (map #(str %1 %2) res (seq row)))\n            str-parts)))\n\n(defn diag-2-sym [str-parts]\n  (reverse (reduce (fn [res row]\n             (map #(str %2 %1) res (seq row)))\n           str-parts)))\n\n(defn selfie-diag2-counterclock [str-parts]\n  (map #(str %1 \"|\" %2 \"|\" %3)\n       str-parts\n       (diag-2-sym str-parts)\n       (rot-90-counter str-parts)))\n\n(defn oper [fct s]\n  (->> s\n       str\/split-lines\n       fct\n       (str\/join \"\n\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17374,"user_id":null,"body":"(ns opstrings1.core\n  (:require [clojure.string :as cst]))\n\n(defn reverse-interleave [s]\n  (->> (map reverse s)\n       (apply interleave)\n       (partition (count (first s)))\n       (map #(apply str %))\n       (cst\/join \"\n\")))\n\n(defn rot-90-counter [s]\n  (reverse-interleave (cst\/split-lines s)))\n\n(defn diag-2-sym [s]\n  (reverse-interleave (reverse (cst\/split-lines s))))\n\n(defn selfie-diag2-counterclock [s]\n  (let [selfie (cst\/split-lines s)\n        diag2 (cst\/split-lines (diag-2-sym s))\n        counterclock (cst\/split-lines (rot-90-counter s))]\n    (->> (interleave selfie diag2 counterclock)\n         (partition 3)\n         (map #(cst\/join \"|\" %))\n         (cst\/join \"\n\"))))\n\n(defn oper [fct s]\n  (fct s))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"56dec885c54a926dcd001095":[{"id":17375,"user_id":527,"body":"(ns opposite-number)\n\n(defn opposite [number]\n  (- number))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17376,"user_id":null,"body":"(ns opposite-number)\n(def opposite -)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17377,"user_id":null,"body":"(ns opposite-number)\n\n(defn opposite [number]\n(if (number? number) (- number) 0) \n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17378,"user_id":null,"body":"(ns opposite-number)\n\n(defn opposite [n] (* -1 n))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17379,"user_id":null,"body":"(ns opposite-number)\n\n(defn opposite [number]\n  (- number number number)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17380,"user_id":null,"body":"(ns opposite-number)\n\n(defn opposite [number]\n  (+ (* -2 number) number)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17381,"user_id":null,"body":"(ns opposite-number)\n\n(defn opposite [number]\n  (\/ number -1))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17382,"user_id":null,"body":"(ns opposite-number)\n\n(defn opposite [number]\n  ; your code here\n  (- number (* number 2))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17383,"user_id":null,"body":"(ns opposite-number)\n\n(def opposite #(* % -1))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17384,"user_id":null,"body":"(ns opposite-number)\n\n(defn opposite [number]\n  (if (> number 0) (- 0 number) (+ 0 (* -1 number))) \n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"56e3cd1d93c3d940e50006a4":[{"id":17385,"user_id":null,"body":"(ns valley.core)\n\n(defn make-valley [arr]\n  (let [heights (sort > arr)]\n    (flatten [(take-nth 2 heights) (reverse (take-nth 2 (rest heights)))])))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17386,"user_id":null,"body":"(ns valley.core)\n\n(defn make-valley [arr]\n  (vec (concat\n        (->> arr\n             (sort #(compare %2 %1))\n             (keep-indexed (fn [i v] (if (even? i) v))))\n        (->> arr\n             (sort #(compare %2 %1))\n             (keep-indexed (fn [i v] (if (odd? i) v)))\n             (reverse)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17387,"user_id":null,"body":"(ns valley.core)\n\n(defn make-valley [arr]\n  (let [sorted-arr (reverse (sort arr))\n        partitioned (partition-all 2 sorted-arr)\n        left-wing (map #(first %) partitioned)\n        right-wing (reverse (filter #(not (nil? %)) (map #(second %) partitioned)))]\n    (into (into [] left-wing) right-wing) ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17388,"user_id":492,"body":"(ns valley.core)\n\n(defn make-valley [arr]\n  (let [\n        lg (count arr)\n        arrsort (vec (sort > arr))\n        result (vec (repeat lg 0))\n       ]\n    (loop [ i 1 start 0 nd (- lg 1) res result]\n      (if (>= i lg)\n        (if (= (- i 1) (dec lg))\n          (assoc res start (arrsort (- i 1)))\n          res)\n        (let [\n              r1 (assoc res start (arrsort (- i 1)))\n              r2 (assoc r1 nd (arrsort i))      \n             ]\n          (recur (+ 2 i) (inc start) (dec nd) r2)\n          )))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17389,"user_id":null,"body":"(ns valley.core)\n\n(defn make-valley [xs]\n  (let [sorted (reverse (sort xs))\n        odd (take-nth 2 sorted)\n        even (reverse (take-nth 2 (drop 1 sorted)))]\n    (concat odd even)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17390,"user_id":527,"body":"(ns valley.core)\n\n(defn make-valley [xs]\n  (let [xs (vec (sort xs))] (into [] (comp cat (take-nth 2)) [(rseq xs) xs])))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17391,"user_id":527,"body":"(ns valley.core)\n\n(defn make-valley [xs]\n  (let [xs (sort xs)] (take-nth 2 (concat (reverse xs) xs))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17392,"user_id":527,"body":"(ns valley.core)\n\n(defn make-valley [xs]\n  (let [xs (vec (sort xs))]\n    (concat\n      (take-nth 2 (rseq xs))\n      (take-nth 2 (if (even? (count xs)) xs (rest xs))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17393,"user_id":null,"body":"(ns valley.core)\n\n(defn make-valley\n  [arr]\n  (as-> arr a\n    (sort > a)\n    (let [leftw (take-nth 2 a) rightw (take-nth 2 (rest a))]\n      (concat leftw (sort rightw)))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17394,"user_id":53,"body":"(ns valley.core)\n\n(defn make-valley [arr]\n  (let [xs (reverse (sort arr))\n        b (reverse (filter odd? (range 0 (count xs))))\n        a (filter even? (range 0 (count xs)))]\n    (map #(nth xs %) (concat a b))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"56e7d40129035aed6c000632":[{"id":17395,"user_id":492,"body":"(ns easyline.core)\n\n(defn choose [n p]\n  (let [rprod (fn [a b] (reduce * (range (biginteger a) (inc (biginteger b)))))]\n    (\/ (rprod (- n p -1) n) (rprod 1 p))))\n(defn easy-line [n]\n  (choose (* 2 n) n))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17396,"user_id":null,"body":"(ns easyline.core)\n\n(defn easy-line [n]\n  (let [pascal (iterate #(concat [1N] (map + % (rest %)) [1N]) [1N])]\n    (->> (drop n pascal)\n         (first)\n         (reduce #(+ %1 (* %2 %2)) 0N))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17397,"user_id":null,"body":"(ns easyline.core)\n\n(defn easy-line [n]\n  (\/ (reduce * (range (+ 1N n) (+ 1N (* 2N n))))\n     (reduce * (range 1N (+ 1N n)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17398,"user_id":53,"body":"(ns easyline.core)\n\n(defn expt [x n]\n  (reduce *' (repeat n x)))\n\n(defn factorial [n]\n  (reduce *' (range 1N (inc' n))))\n\n(defn binom [n k]\n  (\/ (factorial n) (*' (factorial (-' n k)) (factorial k))))\n\n(defn easy-line [n]\n  (loop [i 0 ans 0N]\n    (if (> i n)\n      ans\n      (recur (inc i) (+ ans (expt (binom n i) 2))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17399,"user_id":null,"body":"(ns easyline.core)\n\n(defn binomial-coefficient [n k]\n  (let [rprod (fn [a b] \n               (reduce * (range (bigint a) (inc (bigint b)))))]\n    (\/ (rprod (- n k -1) n) (rprod 1 k))))\n\n(defn easy-line [n] \n (binomial-coefficient (* 2 n) n))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17400,"user_id":null,"body":"(ns easyline.core)\n\n(defn- pascal\n  ([] (pascal (sequence [1N])))\n  ([xs]\n   (let [line (mapv #(apply + %) (partition 2 1 xs))]\n     (lazy-seq\n       (cons xs (pascal (cons 1N (conj line 1N))))))))\n\n(defn easy-line\n  [n]\n  (->> (pascal)\n       (take (inc n))\n       last\n       (map #(* % %))\n       (reduce +)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17401,"user_id":null,"body":"(ns easyline.core)\n\n(defn nth-row [N]\n  (loop [x (bigint 1) k 0 result []]\n    (if (> k N)\n      result\n      (recur (\/ (* x (- N k)) (+ k 1)) (inc k) (conj result x)))))\n\n(defn easy-line [n]\n  (->> (nth-row n)\n       (map #(* % %))\n       (reduce +)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17402,"user_id":null,"body":"(ns easyline.core)\n\n(defn factorial [n]\n  (reduce *' (range 1N (inc n))))\n\n(defn n-choose-k [n k]\n  (\/ (factorial n) (* (factorial k) (factorial (- n k)))))\n\n(defn sum-squared [xs]\n  (->> xs\n    (map #(* % %))\n    (reduce +)))\n\n(defn easy-line [n]\n  (->> \n  (inc n)\n  range\n  (map (partial n-choose-k n))\n  sum-squared))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17403,"user_id":null,"body":"(ns easyline.core)\n\n(defn easy-line [n]\n  (println n)\n  (loop [last 1 num n den 1 row [1]]\n    (if (= 0 num)\n      (reduce #(+ % (* %2 %2)) row)\n      (let [current (* last (\/ num den))]\n        (recur current (dec num) (inc den) (conj row current))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17404,"user_id":null,"body":"(ns easyline.core)\n\n(defn- make-line [line]\n  (let [line (map (partial reduce +') (partition 2 1 line))]\n    (concat [1] line [1])))\n\n(defn- lazy-line\n  ([]\n   (lazy-seq\n    (cons [1] (lazy-line [1]))))\n  ([line]\n   (lazy-seq\n    (let [line (make-line line)]\n      (cons line (lazy-line line))))))\n\n(defn easy-line [n]\n  (let [line (last (take (inc n) (lazy-line)))]\n    (reduce #(+' %1 (*' %2 %2)) 0N line)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"56eb0be52caf798c630013c0":[{"id":17405,"user_id":null,"body":"(ns codewars.core)\n\n(defn unlucky_days [year]\n  (->> (range 1 13)\n    (map #(.getDayOfWeek (java.time.LocalDate\/of year % 13)))\n    (filter #(= % (java.time.DayOfWeek\/FRIDAY)))\n    (count)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17406,"user_id":575,"body":"(ns codewars.core)\n\n(defn unlucky_days [year]\n (count\n  (filter\n   (fn [month] (.equals (. (java.time.LocalDate\/of year month 13) getDayOfWeek)\n                java.time.DayOfWeek\/FRIDAY))\n   (range 1 13))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17407,"user_id":null,"body":"(ns codewars.core)\n\n(defn unlucky_days [year]\n  (->> (range 1 13)\n       (map #(java.time.LocalDate\/of year % 13))\n       (filter #(= \"FRIDAY\" (str (.getDayOfWeek %))))\n       count))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17408,"user_id":null,"body":"(ns codewars.core)\n\n(defn javaDate\n  [year month day]\n  (java.time.LocalDate\/of year month day))\n\n(defn javaDayOfWeekFromDate\n  [year month day]\n  (.getDayOfWeek (javaDate year month day)))\n\n(defn unlucky_days\n  [year]\n  (->>\n   (range 1 13)\n   (filter (fn [month]\n             (= (javaDayOfWeekFromDate year month 13)\n                (java.time.DayOfWeek\/FRIDAY))))\n   count))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17409,"user_id":null,"body":"(ns codewars.core\n  (:import (java.util Calendar GregorianCalendar)))\n\n(defn next-day [d]\n  (let [copy-d (.clone d)]\n    (.add copy-d Calendar\/DATE 1)\n    copy-d))\n\n(defn get-year [d]\n  (.get d Calendar\/YEAR))\n\n(defn is-unlucky? [d]\n  (and\n    (= 13 (.get d Calendar\/DATE))\n    (= Calendar\/FRIDAY (.get d Calendar\/DAY_OF_WEEK))))\n\n(defn unlucky_days [year]\n  (let [first-day (GregorianCalendar. year 0 1)]\n    (->>\n      (iterate next-day first-day)\n      (take-while #(= year (get-year %)))\n      (filter is-unlucky?)\n      (count))))\n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17410,"user_id":null,"body":"(ns codewars.core)\n\n(defn unlucky_days [year]\n  (->> (range 12)\n    (map #(java.util.GregorianCalendar. year % 13))\n    (map #(.get % java.util.Calendar\/DAY_OF_WEEK))\n    (filter (partial = 6))\n    count))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17411,"user_id":null,"body":"(ns codewars.core)\n\n(defn get-year [year]\n  (if (> 1000 year)\n    (str 0 year)\n    year))\n\n(defn unlucky_days [year]\n  (loop [date (-> (java.time.LocalDate\/parse (str (get-year year) \"-01-01\")))\n         unlucky 0]\n    (let [day (-> date (.getDayOfMonth))\n          day-of-week (-> date (.getDayOfWeek) (str))]\n      (if (= (inc year) (-> date (.getYear)))\n        unlucky\n        (if (and (= day 13) (= day-of-week \"FRIDAY\"))\n            (recur (-> date (.plusDays 1)) (inc unlucky))\n            (recur (-> date (.plusDays 1)) unlucky))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17412,"user_id":null,"body":"(ns codewars.core)\n\n(defn unlucky_days [year]\n  (count\n    (filter #(= (.getDayOfWeek %) java.time.DayOfWeek\/FRIDAY)\n      (map #(java.time.LocalDate\/of year % 13) (range 1 13)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17413,"user_id":null,"body":"(ns codewars.core)\n\n(defn date-plus-months [date months]\n  (-> (. java.time.LocalDate parse date)\n      (.plusMonths months)\n      (.getDayOfWeek)))\n\n(defn unlucky_days [year]\n  (->> (map #(date-plus-months (format \"%04d-01-13\" year) %) (range 12))\n       (map str) \n       (filter #(= \"FRIDAY\" %))\n       (count)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17414,"user_id":null,"body":"(ns codewars.core\n  (:import [java.time DayOfWeek LocalDate]))\n\n(defn unlucky_days [year]\n  (loop [date (LocalDate\/of year 1 13)\n         result 0]\n    (if (> (.getYear date) year)\n      result\n      (recur (.plusMonths date 1)\n             (if (= DayOfWeek\/FRIDAY (.getDayOfWeek date))\n               (inc result)\n               result)))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"56ed20a2c4e5d69155000301":[{"id":17415,"user_id":null,"body":"(ns scalesqstrings.core)\n(require '[clojure.string :as str])\n\n(defn scale [s h v]\n  (->> (str\/split-lines s)\n       (filter seq)\n       (map (comp str\/join (partial mapcat (partial repeat h))))\n       (mapcat (partial repeat v))\n       (str\/join \newline)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17416,"user_id":53,"body":"(ns scalesqstrings.core)\n(require '[clojure.string :as str])\n\n(defn repeat-str [s n]\n  (str\/join \"\" (repeat n s)))\n\n(defn scale [strng h v]\n  (str\/join \"\" (drop-last (str\/replace \n    (str\/replace \n      (str strng \"\n\") #\"[^\n]\" #(repeat-str %1 h))\n   #\"[^\n]+\n\" #(repeat-str %1 v)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17417,"user_id":null,"body":"(ns scalesqstrings.core)\n(require '[clojure.string :as str])\n\n(defn repeat-each\n  [n coll]\n  (mapcat #(repeat n %) coll))\n\n(defn scale [strng k n]\n  (->> strng\n       str\/split-lines\n       (map #(repeat-each k %))\n       (repeat-each n)\n       (map #(apply str %))\n       (filter (complement empty?))\n       (str\/join \newline)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17418,"user_id":null,"body":"(ns scalesqstrings.core)\n(require '[clojure.string :as str])\n\n(defn v-scale [v s]\n\t(apply concat (map #(repeat v %) s)))\n\n(defn k-scale [k s]\n\t(apply str (map #(->> % (repeat k) (apply str)) s) ))\n\n(defn scale [strng k n]\n  (->> (str\/split strng #\"\n\")\n                (map #(k-scale k %))\n  \t\t\t\t\t\t\t(v-scale n)\n                (filter #(not (= \"\" %)))\n                (str\/join \"\n\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17419,"user_id":492,"body":"(ns scalesqstrings.core)\n(require '[clojure.string :as str])\n\n(defn- rep-char [k c]\n    (apply str (repeat k c)))\n(defn- rep-str [n s]\n  (str\/join \"\n\" (repeat n s)))\n(defn scale [strng k n]\n  (if (= strng \"\")\n    \"\"\n    (let [\n          r1 (map (fn[y] (apply str (map (fn[x] (rep-char k x)) (str\/split y #\"\")))) (str\/split strng #\"\n\"))\n          r2 (map (fn[z] (rep-str n z)) r1)\n         ] \n      (str\/join \"\n\" r2))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17420,"user_id":null,"body":"(ns scalesqstrings.core)\n(require '[clojure.string :as str])\n\n(defn scale [s k n]\n  (if (empty? s)\n    s\n    (->> (str\/split s #\"\n\")\n         (map\n           (fn [line]\n             (->> (map #(repeat k %) line)\n                  (apply concat)\n                  (apply str))))\n         (reduce\n           (fn [lines line]\n             (concat lines (repeat n line)))\n           [])\n         (str\/join \"\n\"))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17421,"user_id":null,"body":"(ns scalesqstrings.core)\n(require '[clojure.string :as s])\n(defn scale [st k n] (if (empty? st) \"\" (s\/join (rest (reduce (fn [x, m] (str x (s\/join (repeat n (str \"\n\"  (reduce #(str %1 (s\/join (repeat k %2))) \"\" m)))))) \"\" (s\/split st #\"\n\"))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17422,"user_id":null,"body":"(ns scalesqstrings.core)\n\n(require '[clojure.string :as str])\n\n(defn- div [x y] (int (\/ x y)))\n\n(defn- scale-split [s] (->> (str\/split s #\"\n\") (map seq)))\n\n(defn- scale-join [t] (->> (map #(str\/join \"\" %) t) (str\/join \"\n\")))\n\n(defn- scale-row [n row] (map #(nth row (div % n)) (range (* n (count row)))))\n\n(defn scale [s k n]\n  (if\n    (= s \"\")\n    \"\"\n    (->>\n      (scale-split s)\n      (map #(scale-row k %))\n      (scale-row n)\n      (scale-join))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17423,"user_id":null,"body":"(ns scalesqstrings.core)\n(require '[clojure.string :as str])\n\n(defn scale-vertical [strng v]\n  (str\/join \"\n\" (flatten (map (fn [x] (repeat v x)) (str\/split-lines strng)))))\n\n\n(defn scale-horizontal [strng h]\n  (defn repeat-non-newline-char [x] (if (= x \newline) (str x) (apply str (repeat h x))))\n  (apply str (map repeat-non-newline-char strng)))\n\n(defn scale [strng h v]\n  (if (= strng \"\")\n    \"\"\n    (scale-vertical (scale-horizontal strng h) v))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17424,"user_id":null,"body":"(ns scalesqstrings.core)\n(require '[clojure.string :as str])\n\n(defn build-one-item [item k]\n  (apply str (map #(apply str (repeat k %)) (seq item)))\n  )\n\n(defn scale [strng k n]\n  ; your code\n  (if (= \"\" strng ) \"\"\n  (->> (str\/split strng #\"\n\") (map #(build-one-item % k)) (map #(str\/join \"\n\" (repeat n %))) (str\/join \"\n\")))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"56efab15740d301ab40002ee":[{"id":17425,"user_id":null,"body":"(ns operarray.core)\n\n(defn abs [n]\n  (cond\n    (neg? n) (- n)\n    :else n))\n\n(defn gcdi [a b]\n  (loop [a (abs a) b (abs b)]\n    (if (zero? b)\n      a\n      (recur b (mod a b)))))\n\n(defn lcmu [a b]\n  (cond (zero? a) 0\n        (zero? b) 0\n        :else (abs (* b (quot a (gcdi a b))))))\n\n(def som +)\n\n(def maxi max)\n\n(def mini min)\n\n(defn oper-array [fct arr init]\n  (into [] (rest (reductions fct init arr))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17426,"user_id":564,"body":"(ns operarray.core)\n\n(defn abs [a]\n  (if (>= a 0) a (- a)))\n\n(defn gcdi [a b]\n  (defn gcd [a b] (if (= b 0) a (gcd b (mod a b))))\n  (gcd (abs a) (abs b)))\n\n(defn lcmu [a b]\n  (quot (abs (* a b)) (gcdi a b)))\n\n(def som +)\n\n(defn maxi [a b] \n  (if (> a b) a b))\n\n(defn mini [a b] \n  (if (< a b) a b))\n\n(defn oper-array [f arr init]\n  (rest (reductions f init arr)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17427,"user_id":null,"body":"(ns operarray.core)\n\n(defn abs [x] (if (< x 0) (* x -1) x))\n\n(defn gcd [a b]\n    (loop [a (abs a) b (abs b)]\n      (if (zero? b) a,\n      (recur b (mod a b)))))\n\n(defn lcm\n  [a b]\n (cond (zero? a) 0\n    (zero? b) 0\n    :else (abs (* b (quot a (gcd b a))))))\n\n(defn gcdi [x y] (gcd (abs x) (abs y) ))\n(defn lcmu [x y] (lcm (abs x) (abs y) ))\n\n(def som +)\n(def maxi max)\n(def mini min)\n\n(defn oper-array [fct arr init]\n    ((fn [f,a,acc]\n      (if (<= (count a) 0) \n        (rest acc)\n        (recur f (rest a) (conj acc (f (first a) (last acc))))  \n    )) fct arr [init])\n  )\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17428,"user_id":570,"body":"(ns operarray.core)\n\n(defn abs [a] (if (neg? a) (- a) a))\n\n(defn gcd [x y]\n  (if (zero? y) x (gcd y (mod x y))))\n  \n(defn gcdi [x y]\n  (gcd (abs x) (abs y)))\n  \n(defn lcmu [x y]\n  (let [x (abs x) y (abs y)]\n    (\/ (* x y) (gcdi x y))))\n  \n(defn som [x y] \n  (+ x y))\n    \n(defn maxi [x y] \n  (max x y))\n    \n(defn mini [x y] \n  (min x y))\n  \n(defn oper-array [fct arr init]\n  (println [fct arr init])\n  (rest (reductions fct init arr)))\n  \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17429,"user_id":492,"body":"(ns operarray.core)\n\n; help from @niklasjansson\n\n(defn abs [a] (if (neg? a) (- a) a))\n\n(defn gcd [x y]\n  (if (zero? y) x (gcd y (mod x y))))\n\n(defn gcdi [x y]\n  (gcd (abs x) (abs y)))\n\n(defn lcmu [x y]\n  (let [x (abs x) y (abs y)]\n    (\/ (* x y) (gcd x y))))\n    \n(defn som [x y] (+ x y))\n(defn maxi [x y] (max x y))\n(defn mini [x y] (min x y))\n(defn oper-array [fct arr init]\n  (loop [ acc init tab arr res [] ]\n    (if (= tab [])\n      res\n      (let [acc (fct acc (first tab))]\n        (recur acc (rest tab) (conj res acc))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17430,"user_id":null,"body":"(ns operarray.core)\n(defn find-divisors [x]\n  (reverse (filter #(zero? (mod x %)) (range 1 (inc x))))\n)\n\n(defn abs [x]\n  (if (pos? x) x (Math\/abs x))  \n)\n\n(defn gcdi [x y]\n  (let [abs-x (abs x)\n        abs-y (abs y)]\n    (cond \n      (= abs-x abs-y) abs-x\n      (> abs-x abs-y)(first (drop-while #(pos? (mod abs-x %)) (find-divisors abs-y)))\n      :else  (first (drop-while #(pos? (mod abs-y %)) (find-divisors abs-x)))\n  ))\n)\n(defn lcmu [x y]\n  (let [abs-x (abs x)\n        abs-y (abs y)\n        gcd (gcdi abs-x abs-y)]\n      (* abs-x (\/ abs-y gcd )))\n)\n(defn som [x y] \n    (+ x y)\n  )\n(defn maxi [x y] \n    (max x y)\n  )\n(defn mini [x y] \n    (min x y)\n  )\n(defn oper-array [fct arr init]\n  (println arr)\n  (let \n    [r0 (atom[(fct init (first arr))])]\n    (doseq [r  (drop 1 arr)] \n      (swap! r0 conj (fct (last @r0) r))\n    )\n    @r0\n  )\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17431,"user_id":null,"body":"(ns operarray.core)\n\n(defn gcdi [x y]\n  (println (type x) x y)\n  (let [x (max x (- x))\n        y (max y (- y))]\n    (println \"@\" (type x) x y)\n\n    (if (zero? y)\n      x\n      (recur y (mod x y))))\n  ; your code\n  )\n\n(gcdi 72 48)\n\n(defn lcmu [x y]\n  (let [x (max x (- x))\n        y (max y (- y))]\n  ; your code\n    (\/ (* x y) (gcdi x y))))\n(defn som [x y] \n    ; your code\n  (+ x y)\n  )\n(defn maxi [x y] \n    ; your code\n  (max x y)\n  )\n(defn mini [x y] \n    ; your code\n  (min x y)\n  )\n(defn oper-array [fct arr init]\n  (println arr init)\n  ; your code\n  (second (reduce (fn [[rprev state] a]\n                    [(fct rprev a) (conj state (fct rprev a))])\n                  [init []]\n                  arr)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17432,"user_id":null,"body":"(ns operarray.core)\n\n(defn- abs [n]\n  (max n (- n)))\n\n(defn gcdi [x y]\n  (if (zero? y)\n    (abs x)\n    (recur y (mod x y))))\n\n(defn lcmu [x y]\n  (-> (* x y)\n    (\/ (gcdi x y))\n    abs))\n\n(def som +)\n(def maxi max)\n(def mini min)\n\n(defn oper-array [fct arr init]\n  (into [] (rest (reductions fct init arr ))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17433,"user_id":null,"body":"(ns operarray.core)\n(defn abs [x]\n  (if (< x 0) (- x) x))\n\n(defn gcdi [x y]\n  (loop [a (abs x)\n         b (abs y)]\n    (cond\n      (= b 0) a\n      (= a 0) b\n      (= a b) a\n      (< a b) (recur a (rem b a))\n      (> a b) (recur b (rem a b)))))\n\n(defn lcmu [x y]\n  (cond\n    (or (= 0 x) (= 0 y)) 0\n    :else (quot (abs (* x y)) (gcdi x y))))\n\n(defn som [x y] \n  (+ x y))\n\n(defn maxi [x y] \n  (max x y))\n\n(defn mini [x y] \n  (min x y))\n  \n(defn oper-array [fct arr init]\n  (rest (reductions fct init arr)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17434,"user_id":null,"body":"(ns operarray.core)\n\n(defn abs [x] (max x (-' x)))\n\n(defn gcdi [x y] (.gcd (biginteger x) (biginteger y)))\n(defn lcmu [x y] \n  (abs \n    (\/ \n      (* x y)\n      (gcdi x y)\n)))\n(def som +)\n(def maxi max)\n(def mini min)\n(defn oper-array [fct arr init]\n  (drop 1 (reductions fct init arr))\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"56f253dd75e340ff670002ac":[{"id":17435,"user_id":492,"body":"(ns compsqstrings.core)\n(require '[clojure.string :as str])\n\n(defn compose[s1 s2]\n  (let [\n        a2 (vec (reverse (str\/split s2 #\"\n\")))\n        l (count a2)\n        a1 (map-indexed (fn [i itm] (str (subs itm 0 (inc i)) (subs (a2 i) 0 (- l i)))) (str\/split s1 #\"\n\"))\n       ]\n    (str\/join \"\n\" a1)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17436,"user_id":null,"body":"(ns compsqstrings.core\n  (require [clojure.string :as str]))\n\n(defn compose[s1 s2]\n  (let [v1 (map-indexed\n            (fn [index item] (subs item 0 (inc index)))\n            (str\/split s1 #\"\n\"))\n        v2 (map-indexed\n            (fn [index item] (subs item 0 (- (count item) index)))\n            (reverse (str\/split s2 #\"\n\")))]\n    (str\/join \"\n\" (map (fn [x y] (str x y)) v1 v2))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17437,"user_id":null,"body":"(ns compsqstrings.core\n  (:require [clojure.string :as str]))\n\n(defn compose[s1 s2]\n  (let [s1 (str\/split-lines s1)\n        s2 (str\/split-lines s2)\n        sq (count s1)]\n    (->> (map flatten\n             (for [r (range 0 sq)]\n               [(take (inc r) (nth s1 r)) (take (- sq r) (nth s2 (- sq (inc r))))]))\n         (map (partial apply str))\n         (str\/join \"\n\"))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17438,"user_id":null,"body":"(ns compsqstrings.core\n  (:require [clojure.string :as str]))\n\n(defn split-str [s]\n  (let [s (str\/split-lines s)]\n    (map-indexed #(take (inc %) %2) s)))\n\n(defn combine-str [a b]\n  (str\/join \"\n\"\n    (map #(apply str (concat % %2)) a (reverse b))))\n\n(defn compose[s1 s2]\n  (combine-str\n    (split-str s1)\n    (split-str s2)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17439,"user_id":464,"body":"(ns compsqstrings.core \n  (:require [clojure.string :as str]))\n\n(defn compose [a b]\n  (loop [split 1 acc \"\" left (str\/split a #\"\n\") right (str\/split b #\"\n\")]\n    (if (empty? left)\n      (apply str (drop-last acc))\n      (recur (inc split)\n             (str acc (subs (first left) 0 split) (subs (last right) 0 (- (count (last right)) (- split 1))) \"\n\")\n             (rest left)\n             (drop-last right)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17440,"user_id":null,"body":"(ns compsqstrings.core\n(:require [clojure.string :as str]))\n\n(defn compose [s1 s2]\n  (let [c1 (str\/split-lines s1)\n        c2 (reverse (str\/split-lines s2))\n        l (inc (count c1))]\n    (loop [n 1\n           r []\n           c1 c1\n           c2 c2]\n      (if (empty? c1)\n        (str\/join \newline r)\n        (let [v1 (apply str (take n (first c1)))\n              v2 (apply str (drop-last (dec n) (first c2)))\n              v (str v1 v2)]\n          (recur (inc n) (conj r v) (rest c1) (rest c2)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17441,"user_id":null,"body":"(ns compsqstrings.core)\n\n(defn compose\n  [s1 s2]\n  (loop\n    [ls1 (clojure.string\/split-lines s1)\n     ls2 (clojure.string\/split-lines s2)\n     res []\n     li1 1\n     li2 (count (first ls2))]\n    (cond (empty? ls1)\n          (clojure.string\/join \"\n\" res)\n          :else\n          (recur (rest ls1)\n                 (butlast ls2)\n                 (conj res\n                       (str\n                         (subs\n                           (first ls1)\n                           0\n                           li1)\n                         (subs\n                           (last ls2)\n                           0\n                           li2)))\n                 (inc li1)\n                 (dec li2)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17442,"user_id":null,"body":"(ns compsqstrings.core\n  (:require [clojure.string :as string]))\n\n(defn compose[s1 s2]\n  (let [splitter (fn [s] (string\/split s #\"\n\"))\n        one (splitter s1)\n        two (splitter s2)]\n    (loop [a one\n           b (reverse two)\n           a-chars-take 1\n           b-chars-take (count b)\n           new-strings []]\n      (if (empty? a)\n        (string\/join \"\n\" new-strings)\n        (recur\n          (rest a)\n          (rest b)\n          (inc a-chars-take)\n          (dec b-chars-take)\n          (conj new-strings \n            (str (->> a first (take a-chars-take) (apply str)) (->> b first (take b-chars-take) (apply str)))\n          )\n        )\n      )\n    )\n  )\n)  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17443,"user_id":null,"body":"\n(ns compsqstrings.core\n\t(:require [clojure.string :as str])\n\t)\n\n(def split #(str\/split % #\"\n\"))\n\n(defn create-string [size one two index ]\n\t(let [\n\t\ts1 (get one index)\n\t\ts2 (get two (- (dec size) index))]\n\t\t(str \n\t\t\t(subs s1 0 (inc index)) \n\t\t\t(subs s2 0 (- size index))\n\t\t\t(if (not= size (inc index)) \"\n\")\n\t\t\t)\n\t\t)\n\t)\n\n(defn compose[s1 s2]\n\t(let [\n\t\ttotal (count (split s1))\n\t\tcreate-string-p (partial create-string total (split s1) (split s2))\n\t\t]\n\t\t(loop [result \"\" index 0]\n\t\t\t(if (>= index total)\n\t\t\t\tresult\n\t\t\t\t(recur \n\t\t\t\t\t(do (println (create-string-p index))(str result (create-string-p index)) )\n\t\t\t\t\t(inc index))\n\t\t\t\t)))\n\t)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17444,"user_id":null,"body":"(ns compsqstrings.core\n  (:use [clojure.string :only (join split-lines)]))\n\n(defn compose[s1 s2]\n  (join \"\n\"\n    (map-indexed\n      (fn [i x]\n        (.concat\n          (subs (first x) 0 (inc i))\n          (subs (last x) 0 (- (.length (last x)) i))))\n      (map list (split-lines s1) (reverse (split-lines s2))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"56f3a1e899b386da78000732":[{"id":17445,"user_id":null,"body":"(ns partlist.core)\n(require '[clojure.string :as s])\n\n(defn partlist [arr] \n (map \n   (fn [[l r]] [(s\/join \" \" l) (s\/join \" \" r)]) \n   (for [i (range 1 (count arr))] (split-at i arr)))\n ) ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17446,"user_id":null,"body":"(ns partlist.core)\n\n(defn partlist [arr]\n  (map #(map (partial clojure.string\/join \" \") (split-at % arr)) (range 1 (count arr))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17447,"user_id":null,"body":"(ns partlist.core\n  (:require [clojure.string :refer [join]]))\n\n(defn partlist [arr]\n  (for [n (range 1 (count arr))]\n    (map (partial join \\space)\n         (split-at n arr))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17448,"user_id":null,"body":"(ns partlist.core\n  (:require [clojure.string :as s]))\n\n(defn partlist [arr]\n  (for [i (range 1 (count arr))]\n    [(s\/join \" \" (take i arr))\n     (s\/join \" \" (drop i arr))])) ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17449,"user_id":3072,"body":"(ns partlist.core)\n\n(defn partlist [arr]\n  (for [x (range (- (count arr) 1 ))]\n    [(reduce (fn [x y] (str x \" \" y)) (take (+ 1 x) arr))\n    (reduce (fn [x y] (str x \" \" y)) (drop (+ 1 x) arr))]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17450,"user_id":null,"body":"(ns partlist.core)\n\n(defn partlist [arr]\n (for [list-size (range 1 (count arr))]\n  [(clojure.string\/join \" \" (take list-size arr)) (clojure.string\/join \" \" (drop list-size arr))]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17451,"user_id":null,"body":"(ns partlist.core)\n\n(defn take-drop-subfunc [n array]\n  \"Useful subfunction for the problem\"\n  [(clojure.string\/join \" \" (take n array))\n   (clojure.string\/join \" \" (drop n array))])\n\n(defn partlist [arr]\n  \"All the ways to divide a list in a list of \n   at least two elements with non-empty parts.\"\n  (let [length (- (count arr) 1)]\n    (map #(take-drop-subfunc % arr) (map inc (range length)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17452,"user_id":null,"body":"(ns partlist.core)\n\n\n(defn partlist [arr]\n  (mapv\n   #(vector (clojure.string\/join \" \" (take % arr))\n            (clojure.string\/join \" \" (drop % arr)))\n   (range 1 (count arr))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17453,"user_id":null,"body":"(ns partlist.core\n  (:require [clojure.string :as str]))\n\n(defn partlist [arr]\n  (apply vector (for [i (range 1 (count arr))]\n     (list (str\/join \" \" (take i arr))\n           (str\/join \" \" (drop i arr))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17454,"user_id":570,"body":"(ns partlist.core)\n(use '[clojure.string :only (join)])\n\n(defn partlist [arr]\n  (for [i (range 1 (count arr))]\n    (map #(join \" \" %) (split-at i arr)))) ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"56f699cd9400f5b7d8000b55":[{"id":17455,"user_id":527,"body":"(ns kata)\n(def fix_the_meerkat rseq)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-28 16:46:21"},{"id":17456,"user_id":null,"body":"(ns kata)\n\n(defn fix_the_meerkat [arr]\n  (rseq arr))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-28 16:46:26"},{"id":17457,"user_id":null,"body":"(ns kata)\n(defn fix_the_meerkat [arr]\n  [(last arr) (get arr 1) (first arr)]\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17458,"user_id":null,"body":"(ns kata)\n(defn fix_the_meerkat [arr]\n  (conj [] (last arr) (nth arr 1) (first arr))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17459,"user_id":null,"body":"(ns kata)\n(defn fix_the_meerkat [[head body tail]]\n  [tail body head]\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17460,"user_id":null,"body":"(ns kata)\n(defn fix_the_meerkat [arr]\n  ;; your code here\n  (reduce #(cons %2 %1) [] arr)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17461,"user_id":null,"body":"(ns kata)\n\n(defn fix_the_meerkat [mixed-meerkat]\n  [(last mixed-meerkat)\n   (second mixed-meerkat)\n   (first mixed-meerkat)])","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17462,"user_id":null,"body":"(ns kata)\n(defn fix_the_meerkat [arr]\n  (reverse arr)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17463,"user_id":null,"body":"(ns kata)\n(defn fix_the_meerkat [arr]\n  (into '() arr))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17464,"user_id":null,"body":"(ns kata)\n\n(defn fix_the_meerkat [arr]\n (let [xs (drop 1 (drop-last 1 arr))]\n   (flatten (conj (take 1 arr) xs (take-last 1 arr)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"56f69d9f9400f508fb000ba7":[{"id":17465,"user_id":527,"body":"(ns kata.monkey.count)\n\n(defn monkey_count [n]\n  (range 1 (inc n)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17466,"user_id":null,"body":"(ns kata.monkey.count)\n(defn monkey_count [n]\n  (take n (iterate inc 1)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17467,"user_id":null,"body":"(ns kata.monkey.count)\n(defn monkey_count [n]\n  (reduce conj [] (range 1 (+ 1 n)))\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17468,"user_id":null,"body":"(ns kata.monkey.count)\n\n(defn monkey_count [n]\n  (filter #(not (zero? %)) (take-nth 1 (range (inc n)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17469,"user_id":3106,"body":"(ns kata.monkey.count)\n(defn monkey_count [n]\n  (map inc (range n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17470,"user_id":null,"body":"(ns kata.monkey.count)\n(defn monkey_count [n]\n  (vec (range 1 (inc n)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17471,"user_id":null,"body":"(ns kata.monkey.count)\n(defn monkey_count [n]\n  ;; your code here\n  (for [x (range 1 (+ n 1))] x)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17472,"user_id":1703,"body":"(ns kata.monkey.count)\n(defn monkey_count [n]\n  (drop 1 (range (+ n 1)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17473,"user_id":null,"body":"(ns kata.monkey.count)\n(defn monkey_count [n]\n  ;; your code here\n  (range 1 (+ n 1))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17474,"user_id":null,"body":"(ns kata.monkey.count)\n(defn monkey_count [n]\n  (->>\n (range)\n (take n)\n (map inc))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"56f6ad906b88de513f000d96":[{"id":17475,"user_id":null,"body":"(ns clojure.bonus)\n\n(defn bonus_time [salary bonus]\n  (str \"$\" (* salary (if bonus 10 1))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17476,"user_id":527,"body":"(ns clojure.bonus)\n\n(defn bonus_time [salary bonus]\n  (str \\$ (* salary (if bonus 10 1))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17477,"user_id":null,"body":"(ns clojure.bonus)\n\n;aiming for the shortest solution:)\n\n(defn bonus_time [salary bonus]\n  (str \\$ salary (when bonus \\0)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17478,"user_id":null,"body":"(ns clojure.bonus)\n\n(defn bonus_time [salary bonus]\n  (->> \n    (if (= bonus true) (* salary 10) salary)\n    (str \"$\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17479,"user_id":null,"body":"(ns clojure.bonus)\n\n(defn bonus_time\n  [salary bonus]\n  (if (= bonus true) \n    (str \"$\" (* 10 salary))\n    (str \"$\" salary)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17480,"user_id":null,"body":"(ns clojure.bonus)\n\n(defn bonus_time [salary bonus]\n  (if bonus (format \"$%s\" (* salary 10)) (format \"$%s\" salary)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17481,"user_id":null,"body":"(ns clojure.bonus)\n\n(defn bonus_time [salary bonus]\n  (str \"$\" (if bonus (* 10 salary) salary)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17482,"user_id":null,"body":"(ns clojure.bonus)\n\n(defn bonus_time [salary bonus]\n  (let [final-amount (cond-> salary\n                       bonus (* 10))]\n    (str \"$\" final-amount)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17483,"user_id":null,"body":"(ns clojure.bonus)\n\n(defn bonus_time [salary bonus]\n;  (str \\$ (* salary (if bonus 10 1))))\n  (->> salary\n    (* (if bonus 10 1))\n    (str \"$\")))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17484,"user_id":null,"body":"(ns clojure.bonus)\n\n(defn bonus_time [salary bonus]\n  ;(str \"$\" (if bonus (* salary 10) salary)))\n  (->> salary\n    (* (if bonus 10 1))\n    (str \"$\")))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"56fa3c5ce4d45d2a52001b3c":[{"id":17485,"user_id":277,"body":"(ns XOR)\n\n(defn xor [a,b]\n  (not= a b)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17486,"user_id":3318,"body":"(ns XOR)\n\n(def xor not=)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17487,"user_id":null,"body":"(ns XOR)\n\n(defn xor [a,b]\n  (and (or a b) (not (and a b)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17488,"user_id":null,"body":"(ns XOR)\n\n(defn xor [a b]\n  (= (true? a) (false? b)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17489,"user_id":null,"body":"(ns XOR)\n\n(def xor distinct?)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17490,"user_id":null,"body":"(ns XOR)\n\n(defn xor\n  [a b]\n  (if a\n    (if b\n      false\n      true)\n    (if b\n      true\n      false)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17491,"user_id":null,"body":"(ns XOR)\n\n(defn xor \n  \"Exclusive OR function\"\n  [a b]\n  (if a\n    (not b)\n    b) \n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17492,"user_id":null,"body":"(ns XOR)\n\n(defn bti [b] (if (true? b) 1 0))\n\n(defn xor [a,b]\n  (\n    if (= 1 (+ (bti a) (bti b))) true false\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17493,"user_id":null,"body":"(ns XOR)\n\n(defn xor [& args]\n  (if (= 1 (count (filter #{true} args)))\n    true\n    false)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17494,"user_id":null,"body":"(ns XOR)\n\n(defn xor [a,b]\n  (= 1 (count (filter true? (list a b))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"56fcc393c5957c666900024d":[{"id":17495,"user_id":null,"body":"(ns coddecsqstrings.core\n\t(:require [clojure.string :as strng :refer [join split-lines blank?]]))\n  \n(defn diag-1-sym [s]\n  (apply map str s))\n\n(defn rot-90-clock [s]\n  (diag-1-sym (reverse s)))\n\n(defn rot-90-counter [s]\n  (apply map str (map strng\/reverse s)))\n\n(defn oper [f s]\n  (->> (f s)\n       (join \newline)))\n\n(defn code [t]\n  (if (blank? t)\n    \"\"\n    (let [l (count t)\n          n (int (Math\/ceil (Math\/sqrt l)))]\n      (->> (repeat (- (* n n) l) (char 11))\n           (apply str t)\n           (partition n)\n           (map #(apply str %))\n           (oper rot-90-clock)))))\n\n(defn decode [s]\n  (as-> (split-lines s) ls\n       (oper rot-90-counter ls)\n       (strng\/replace ls #\"[\n\\x0B]\" \"\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17496,"user_id":492,"body":"(ns coddecsqstrings.core)\n(require '[clojure.string :as str])\n\n(defn transpose [m]\n  (apply mapv vector m))\n(defn rot-90-clock [strng]\n  (str\/join \"\n\" \n            (map (fn [x] (str\/join \"\" x)) \n                 (transpose (map (fn [x] (str\/split x #\"\")) (reverse (str\/split strng #\"\n\")))))))\n(defn rot-90-counter [strng]\n  (let [\n        a (map (fn [x] (apply str (reverse x))) (str\/split strng #\"\n\"))\n        b (map (fn [x] (str\/join \"\" x)) (transpose (map (fn [x] (str\/split x #\"\")) a)))\n       ]\n    (str\/join \"\n\" b))) \n(defn repeat-str [x y]\n    (apply str (repeat y x)))\n(defn split-equal [strng sz] (re-seq (re-pattern (str \".{1,\" sz \"}\")) strng))\n(defn code [strng]\n  (if (= \"\" strng)\n    \"\"\n    (let [\n          l (count strng)\n          sz (int (Math\/ceil (Math\/sqrt l)))\n          s (str strng (repeat-str (char 11) (-  (* sz sz) l))) \n         ]\n      (rot-90-clock (str\/join \"\n\" (split-equal s sz))))))\n(defn decode [strng]\n  (if (= \"\" strng)\n    \"\"\n    (let [s1 (rot-90-counter strng)]\n    (str\/join \"\" (str\/split ((vec (.split s1 \"\\013\")) 0) #\"\n\")))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17497,"user_id":null,"body":"(ns coddecsqstrings.core)\n\n(defn rot-90\n  [mat]\n  (let [c (count mat)]\n    (for [i (range c)]\n      (for [j (range c)]\n        (-> mat (nth (- c j 1)) (nth i))))))\n\n(defn code [text]\n  (let [square-length (-> text count Math\/sqrt Math\/ceil int)\n        num-missing-chars (- (* square-length square-length) (count text))\n        padded-text (apply str (cons text (repeat num-missing-chars (char 11))))]\n    (->> padded-text\n         (partition square-length)\n         rot-90\n         (map #(apply str %))\n         (clojure.string\/join \"\n\"))))\n\n(defn decode [text]\n  (clojure.string\/replace (->> (if (empty? text) [] (clojure.string\/split-lines text))\n                               rot-90 rot-90 rot-90\n                               (map #(apply str %))\n                               (apply str))\n                          (str (char 11))\n                          \"\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17498,"user_id":null,"body":"(ns coddecsqstrings.core)\n\n(defn- fit-square [s]\n  (->> (count s) (Math\/sqrt) (Math\/ceil) int))\n\n(defn- pad-string-to [n s]\n  (str s (apply str (repeat (- n (count s)) (char 11)))))\n\n(defn code [s]\n  (if-not (seq s)\n    s\n    (let [n (fit-square s)]\n      (->> (partition n (pad-string-to (* n n) s))\n           (apply map (comp reverse vector))\n           (interpose \newline)\n           flatten\n           (apply str)))))\n\n(defn decode [s]\n  (if-not (seq s)\n    s\n    (->> (clojure.string\/split s #\"\n\")\n         (map reverse)\n         (apply map vector)\n         flatten\n         (remove #(= % (char 11)))\n         (apply str))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17499,"user_id":null,"body":"(ns coddecsqstrings.core\n  (:require [clojure.string :as str]))\n\n(defn apply-to-index [f]\n  (fn [n i]\n    (let\n     [y (quot i n)\n      x (- i (* y n))\n      [y' x'] (f n y x)]\n      (+ x' (* y' n)))))\n\n(def get-clockwise-index (apply-to-index (fn [n y x] [(- n 1 x) y])))\n(def get-contrclockwise-index (apply-to-index (fn [n y x] [x (- n 1 y)])))\n\n(defn round-clockwise [n s]\n  (as-> s $\n    (into [] $)\n    (map-indexed (fn [i _] ($ (get-clockwise-index n i))) $)\n    (apply str $)))\n\n(defn get-n [r]\n  (->> (iterate inc 0) (drop-while #(< (* % %) r)) first))\n\n(defn code [strng]\n  (let [len (.length strng)\n        n (get-n len)\n        sqrlenstrng (str strng (apply str (take (- (* n n) len) (repeat \\u000B))))\n        rounded90 (round-clockwise n sqrlenstrng)\n        lines (map (partial apply str) (partition n rounded90))]\n    (str\/join \newline lines)))\n\n(defn decode [strng]\n  (as-> strng $\n    (str\/split-lines $)\n    (str\/join \"\" $)\n    (into [] $)\n    (map-indexed (fn [i _] ($ (get-contrclockwise-index (int (Math\/sqrt (.length $))) i))) $)\n    (filter #(not= \\u000B %) $)\n    (apply str $)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17500,"user_id":null,"body":"(ns coddecsqstrings.core)\n(require '[clojure.string :as str])\n\n(defn print-pass   [arg] (print   arg) arg)\n(defn println-pass [arg] (println arg) arg)\n\n(def pad (char 11))\n\n(defn matrix [strng]\n  (let [n (-> (count strng) Math\/sqrt Math\/ceil int)\n        m (as-> (partition n n (repeat pad) strng) m\n            (if (< (count m) n)\n              (conj (apply vector m) (repeat n pad))\n              m)\n            (map #(apply vector %) m)\n            (apply vector m)\n            )\n        ]\n    [n m]\n    )\n  )\n\n(defn code [strng]\n  (let [[n m] (matrix strng)]\n    (->>\n      (for [x (range n)]\n        (for [y (reverse (range n))]\n          (get-in m [y x])\n          )\n        )\n      (map #(apply str %))\n      (str\/join \"\n\")\n      )\n    )\n  )\n\n(defn decode [strng]\n  (let [[n m] (matrix (str\/replace strng #\"\n\" \"\"))]\n    (->>\n      (for [x (reverse (range n))]\n        (for [y (range n)]\n          (get-in m [y x])\n          )\n        )\n      (map #(apply str %))\n      (str\/join)\n      (#(str\/replace % #\"\\013\" \"\"))\n      )\n    )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17501,"user_id":null,"body":"(ns coddecsqstrings.core)\n(require '[clojure.string :as str])\n\n(defn rotate-cc [s n nq]\n  (map #(nth s %) (vec (map #(- (mod (* n %) (+ 1 nq)) 1) (range 1 (+ 1 nq))))))\n\n(defn rotate-c [s n nq]\n  (reverse (rotate-cc s n nq)))\n\n(defn insert-newlines [list_chars n]\n  (map-indexed (fn [ix cx] (if (and (> ix 0) (= (mod ix n) 0))\n                             (str \"\n\" cx) cx))\n               list_chars))\n\n(defn code [s]\n  (let [n (int (. Math ceil (. Math sqrt (count s))))]\n    (let [nq (* n n)]\n      (let [a (concat (vec s) (repeat (- nq (count s)) \"@\"))]\n        (str\/replace (str\/join \"\" (insert-newlines (rotate-c a n nq) n)) \"@\" \"\\013\")))))\n\n(defn decode [strng]\n  (let [a (vec (str\/replace (str\/replace strng \"\\013\" \"@\") \"\n\" \"\"))]\n    (let [n (int (. Math sqrt (count a))) nq (count a)]\n      (str\/replace (str\/join \"\" (rotate-cc a n nq)) \"@\" \"\"))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17502,"user_id":null,"body":"(ns coddecsqstrings.core\n  (:require [clojure.string :as str]))\n\n(defn diag-1-sym [s]\n  (let [rows (str\/split s #\"\n\")\n        cnt (count rows)]\n    (->> (for [pos (range cnt)] (map #(nth % pos) rows))\n         (map (partial apply str)))))\n\n(defn rot-90-clock [s]\n  (map (partial apply str) (map reverse (diag-1-sym s))))\n\n(defn rot-90-counter [s]\n  (->> (str\/split s #\"\n\")\n       (apply map vector)\n       (reverse)\n       (map (partial apply str))))\n\n(defn code [s]\n  (if (= s \"\")\n    \"\"\n    (let [square (->> (count s)\n                      (Math\/sqrt)\n                      (Math\/ceil)\n                      (int))\n          padding (str s (apply str (repeat (- (* square square) (count s)) \"\\013\")))\n          squared-string (apply str (apply concat (interpose [\newline] (partition square padding))))]\n      (str\/join \"\n\" (rot-90-clock squared-string)))))\n\n(defn decode [s]\n  (if (= s \"\")\n    \"\"\n    (str\/join \"\" (map #(str\/replace % #\"\\013\" \"\") (rot-90-counter s)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17503,"user_id":null,"body":"(ns coddecsqstrings.core\n  (:require [clojure.string :as str]))\n\n(def rotate-cw (comp (partial apply (partial map vector)) reverse))\n(def rotate-ccw (comp (partial apply (partial map vector)) (partial map reverse)))\n\n(defn code [input]\n  (let [chars (count input)\n        part-size (int (Math\/ceil (Math\/sqrt chars)))\n        pad-to (* part-size part-size)]\n    (if (= 0 chars) \"\"\n                    (->> (concat input (repeat (- pad-to chars) (char 11)))\n                         (partition part-size)\n                         rotate-cw\n                         (interpose \newline)\n                         flatten\n                         (apply str)))))\n\n(defn decode [input]\n  (if (= \"\" input) \"\"\n    (->> (str\/split-lines input)\n         rotate-ccw\n         flatten\n         (take-while (complement #{(char 11)}))\n         (apply str))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17504,"user_id":null,"body":"(ns coddecsqstrings.core\n  (:require [clojure.string :as str]))\n\n(def FODDER (char 11))\n\n(defn s->n [s] (-> s count Math\/sqrt Math\/ceil int))\n\n(defn pad [s sz] (str s (String. (char-array (- sz (count s)) FODDER))))\n\n(defn walk-square [n] (for [y (reverse (range n)) x (range n)] [x y]))\n\n(defn s->points [s n] (zipmap (walk-square n) (pad s (* n n))))\n\n(defn points->chars [points n] (map points (walk-square n)))\n\n(defn chars->coded [lst n]\n  (->> lst (partition n) (map str\/join) (str\/join \"\n\")))\n\n(defn chars->decoded [lst] (str\/join (remove #{FODDER} lst)))\n\n(defn rot+90 [n [x y]] [y (- n 1 x)])\n(defn rot-90 [n [x y]] [(- n 1 y) x])\n\n(defn rot-points [points d n] (into {} (map (fn [[p c]] [(d n p) c]) points)))\n\n(defn code* [s n rot]\n  (-> s (s->points n) (rot-points rot n) (points->chars n)))\n\n(defn code [s]\n  (let [n (s->n s)]\n    (-> s (code* n rot+90) (chars->coded n))))\n\n(defn decode [s]\n  (let [s (str\/replace s \"\n\" \"\")\n        n (s->n s)]\n    (-> s (code* n rot-90) chars->decoded)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"56fe17fcc25bf3e19a000292":[{"id":17505,"user_id":492,"body":"(ns disguised2.core)\n\n(defn choose [n p]\n  (let [rprod (fn [a b] (reduce * (range (biginteger a) (inc (biginteger b)))))]\n    (\/ (rprod (- n p -1) n) (rprod 1 p))))\n\n(defn u1 [n p]\n  (let [\n        r (for [k (range 0 (+ n 1))\n                :let [b1 (biginteger (.pow (BigInteger. \"-1\") k)) \n                      b2 (biginteger (.pow (BigInteger. \"4\") (- n k)))\n                      q  (biginteger (* b1 b2 (choose (+ 1 (- (* 2 n) k)) k)))\n                      ]\n                ]\n        q)\n       ] \n    (* p (reduce + r))))\n(defn v1 [n p]\n  (let [\n        r (for [k (range 0 (+ n 1))\n                :let [b1 (biginteger (.pow (BigInteger. \"-1\") k)) \n                      b2 (biginteger (.pow (BigInteger. \"4\") (- n k)))\n                      q  (biginteger (* b1 b2 (choose (- (* 2 n) k) k)))\n                      ]\n                ]\n        q)\n       ] \n    (* p (reduce + r)))) \n(defn u_eff [n p]\n  (* p (+ n 1)))\n(defn v_eff [n p]\n  (* p (+ (* 2 n) 1))) \n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17506,"user_id":53,"body":"(ns disguised2.core)\n\n(defn factorial [n] (if (> n (biginteger 1)) (reduce * (range (biginteger 2) (inc n))) (biginteger 1)))\n(defn choose [n, k] (quot (factorial n) (* (factorial k) (factorial (- n k)))))\n(defn v1 [n p] (reduce + (map #(* (biginteger p) (.pow (biginteger -1) %) (.pow (biginteger 4) (- n %)) (choose (- (* 2 (biginteger n)) %) %)) (range (biginteger (inc n))))))\n(defn u1 [n p] (reduce + (map #(* (biginteger p) (.pow (biginteger -1) %) (.pow (biginteger 4) (- n %)) (choose (inc (- (* 2 (biginteger n)) %)) %)) (range (biginteger (inc n))))))\n(defn u_eff [n p] (* p (inc n)))\n(defn v_eff [n p] (* p (inc (* n 2))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17507,"user_id":17,"body":"(ns disguised2.core)\n\n(defn u1 [n p] (* p (+ n 1)))\n(defn v1 [n p] (* p (+ (* 2 n) 1)))\n(defn u_eff [n p] (* p (+ n 1)))\n(defn v_eff [n p] (* p (+ (* 2 n) 1)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17508,"user_id":null,"body":"(ns disguised2.core)\n\n(defn pow [b e]\n  (apply *' (repeat e b)))\n\n(defn w [n p k c]\n  (*'\n    (pow -1 k)\n    p\n    (pow 4 (- n k))\n    (\/\n      (apply *' (range (inc (- c k)) (inc c)))\n      (apply *' (range 2 (inc k))))))\n\n(defn u1 [n p]\n  (->> \n    (range (inc n))\n    (map #(w n p % (-' (+' n n 1) %)))\n    (apply +')))\n\n(defn v1 [n p]\n  (->> \n    (range (inc n))\n    (map #(w n p % (- (+ n n) %)))\n    (apply +)))\n    \n(defn u_eff [n p] (* (inc n) p))\n(defn v_eff [n p] (* (inc (* 2 n)) p))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17509,"user_id":null,"body":"(ns disguised2.core)\n\n(defn u1 [n p]\n  (*(+ n 1) p)\n  )\n(defn v1 [n p]\n  (* (+ 1 (* 2 n)) p)\n  )\n(defn u_eff [n p]\n  (*(+ n 1) p)\n  )\n(defn v_eff [n p]\n  (* (+ 1 (* 2 n)) p)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17510,"user_id":53,"body":"(ns disguised2.core)\n\n(defn u1 [n p] (* p (inc (bigint n))))\n\n(defn v1 [n p] (* p (inc (* (bigint n) 2))))\n\n(defn u_eff [n p] (* p (inc n)))\n\n(defn v_eff [n p] (* p (inc (* n 2))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17511,"user_id":null,"body":"(ns disguised2.core)\n\n(defn u1 [n p] (* (inc n) p))\n(defn v1 [n p] (* (+ 1 (* 2 n)) p))\n(defn u_eff [n p] (u1 n p))\n(defn v_eff [n p] (v1 n p))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17512,"user_id":null,"body":"(ns disguised2.core)\n\n(defn exp [x n]\n  (reduce *' (repeat n x)))\n\n(defn binomial-coefficient [n k]\n  (let [rprod (fn [a b] (reduce *' (range a (inc b))))]\n    (\/ (rprod (-' n k -1) n) (rprod 1 k))))\n\n(defn element-u1 [n p k]\n  (*' (exp -1 k) p (exp 4 (- n k)) (binomial-coefficient (- (*' 2 n) k -1) k)))\n\n(defn element-v1 [n p k]\n  (*' (exp -1 k) p (exp 4 (- n k)) (binomial-coefficient (- (*' 2 n) k) k)))\n\n(defn u1 [n p]\n  (apply + (for [k (range (inc n))] (element-u1 n p k))))\n\n(defn v1 [n p]\n  (apply + (for [k (range (inc n))] (element-v1 n p k))))\n\n(defn u_eff [n p]\n  (apply + (for [k (range (inc n))] (element-u1 n p k))))\n\n(defn v_eff [n p]\n  (apply + (for [k (range (inc n))] (element-v1 n p k))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5700c9acc1555755be00027e":[{"id":17513,"user_id":null,"body":"(ns rotations.core)\n\n(defn rotate-s [s]\n  (str (subs s 1) (subs s 0 1)))\n\n(defn gen-rotations [s]\n  (take (count s) (iterate rotate-s s)))\n\n(defn contain-all-rots [strng arr]\n        (every? (set arr) (gen-rotations strng)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17514,"user_id":53,"body":"(ns rotations.core)\n\n(defn rot-once [s] (format \"%s%s\" (subs s 1) (subs s 0 1)))\n\n(defn rot-all [s]\n  (loop [acc [s] i (count s)]\n    (if (zero? (dec i))\n      acc\n      (recur (cons (rot-once (first acc)) acc) (dec i)))))\n\n(defn contain-all-rots [s xs]\n  (if (empty? s)\n    true\n    (every? (set xs) (rot-all s))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17515,"user_id":null,"body":"(ns rotations.core)\n\n(defn rot [string]\n  (for [index (range (count string))]\n    (->> (reverse (split-at index string))\n         (apply concat)\n         (apply str))))\n\n(defn contain-all-rots [strng vec-str]\n  (every? (set vec-str) (rot strng)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17516,"user_id":492,"body":"(ns rotations.core)\n(require 'clojure.set)\n\n(defn rotations [strng]\n  (if (seq strng)\n    (let [u (map (fn [n _] (lazy-cat (drop n strng) (take n strng))) (iterate inc 0) strng)]\n      (apply map str u))\n    (list nil)))\n(defn contain-all-rots [strng arr]\n  (if (= \"\" strng)\n    true\n    (let [r (set (rotations strng)) a (set arr)]\n      (= r (clojure.set\/intersection r a)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17517,"user_id":null,"body":"(ns rotations.core)\n\n(defn contain-all-rots [strng arr]\n  (print strng arr)\n  (if (= strng \"\") true)\n  (let [current-word (clojure.string\/join (sort strng))\n  length (count (remove nil? (map \n   (fn [word] (if (= (clojure.string\/join (sort word)) current-word) word nil)) arr)))]\n  (if (= length (count strng)) true (if (= length (\/ (count strng) 2)) true false))\n  ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17518,"user_id":null,"body":"(ns rotations.core)\n\n(defn contain-all-rots\n  [strng arr]\n  (every? identity\n          (map (fn [n _]\n                 (some #(= % (apply str (lazy-cat (drop n strng) (take n strng)))) arr))\n               (range) strng)))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17519,"user_id":1400,"body":"(ns rotations.core)\n(require 'clojure.set)\n\n(defn rot [s n]\n  (if (zero? n)\n    s\n    (rot (str (last s) (reduce str (take (dec (count s)) s))) (dec n)))\n)\n\n(defn all-rots [s]\n    (for [i (range (count s))] (rot s i))\n)\n\n(defn contain-all-rots [strng arr]\n  (println strng)\n  (println arr)\n  (println (all-rots strng))\n  (if (empty? strng) true\n    (zero? \n      (count \n        (clojure.set\/difference \n         (set (all-rots strng))\n         (set arr)))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17520,"user_id":null,"body":"(ns rotations.core)\n(use '[clojure.set :only [superset?]])\n\n(defn contain-all-rots [strng arr]\n  (superset? (set arr)\n             (set (map #(str (subs strng %)\n                             (subs strng 0 %))\n                       (range (count strng))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17521,"user_id":null,"body":"(ns rotations.core)\n\n(defn contain-all-rots [strng arr]\n  (def all-rotations\n    (for [i (range (count strng))]\n      (str (subs strng i) (subs strng 0 i))))\n  (every? (set arr) all-rotations))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17522,"user_id":null,"body":"(ns rotations.core\n  (:require [clojure.set :refer [subset?]]))\n\n(defn rotations [text]\n  (loop [left []\n         right (vec text)\n         res []]\n    (cond\n      (empty? right) (set res)\n      :else (\n             recur\n             (conj left (first right))\n             (subvec right 1)\n             (conj res (apply str (concat right left)))\n      )\n    )\n  )\n)\n\n(defn contain-all-rots [strng arr]\n  (subset? (rotations strng) (set arr)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"570a6a46455d08ff8d001002":[{"id":17523,"user_id":null,"body":"(ns noboringzeros.core)\n\n(defn no_boring_zeros [n]\n  (cond\n    (zero? n) n\n    (zero? (rem n 10)) (recur (\/ n 10))\n    :else n))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-27 19:53:10"},{"id":17524,"user_id":53,"body":"(ns noboringzeros.core)\n\n(defn no_boring_zeros [n] \n  (Integer\/parseInt (clojure.string\/replace (str n) #\"(?!^)[0]+$\" \"\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17525,"user_id":null,"body":"(ns noboringzeros.core)\n\n(defn no_boring_zeros [n]\n   (cond (= 0 n) 0\n         (= 0 (mod n 10)) (no_boring_zeros (quot n 10)) \n         :else n)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17526,"user_id":null,"body":"(ns noboringzeros.core)\n\n(defn no_boring_zeros [n]\n  (if (= n 0)\n        0\n        (Integer. (clojure.string\/replace (str n) #\"0*$\" \"\"))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17527,"user_id":null,"body":"(ns noboringzeros.core)\n\n(defn no_boring_zeros [n]\n  (first (drop-while (fn [x] (and (not= x 0) (== (rem x 10) 0)))\n                      (iterate (fn [x] (quot x 10))\n                               n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17528,"user_id":null,"body":"(ns noboringzeros.core)\n\n(defn no_boring_zeros [n]\n  (if (= n 0)\n    0\n    (Integer. (re-find #\"\\d*[^0]+\" (str n)))\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17529,"user_id":3318,"body":"(ns noboringzeros.core)\n\n(defn no_boring_zeros [n]\n  (Integer. (re-find #\"^-?\\d+?(?=0*$)\" (str n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17530,"user_id":null,"body":"(ns noboringzeros.core)\n\n(defn no_boring_zeros [n]\n  (if (and (= (rem n 10) 0) (not= n 0))\n    (no_boring_zeros (\/ n 10))\n    n))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17531,"user_id":null,"body":"(ns noboringzeros.core)\n\n(defn no_boring_zeros [n]\n  (loop [n n]\n    (if (and (= (rem n 10) 0) (not= n 0))\n        (recur (\/ n 10))\n        n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17532,"user_id":null,"body":"(ns noboringzeros.core)\n\n(defn no_boring_zeros [n]\n  (if (and (not= n 0) (= (rem n 10) 0)) (no_boring_zeros (\/ n 10)) n)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5715eaedb436cf5606000381":[{"id":17533,"user_id":201,"body":"(ns kata)\n(defn positive_sum [xs]\n  (reduce + (filter pos? xs)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17534,"user_id":null,"body":"(ns kata)\n\n(defn positive_sum\n  [coll]\n  (->> coll\n       (filter pos?)\n       (reduce +)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17535,"user_id":null,"body":"(ns kata)\n(defn positive_sum [xs]\n  (reduce + (for [x xs :when (pos? x)] x))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17536,"user_id":null,"body":"(ns kata)\n(defn positive_sum [xs]\n  (->> xs\n       (filter #(>= % 0))\n       (reduce + 0)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17537,"user_id":null,"body":"(ns kata)\n(defn positive_sum [xs]\n  (reduce \n   (fn [acc x]\n     (if (> x 0)\n       (+ acc x)\n       acc))\n   0\n   xs)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17538,"user_id":null,"body":"(ns kata)\n(defn positive_sum [numbers]\n  (def selected (filter (fn [num] (> num 0)) numbers))\n  (reduce + selected)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17539,"user_id":null,"body":"(ns kata)\n\n(defn positive_sum\n  [array]\n  (->> array\n    (filter #(< 0 %))\n    (reduce +)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17540,"user_id":null,"body":"(ns kata)\n\n;https:\/\/www.codewars.com\/kata\/5715eaedb436cf5606000381\/train\/clojure\n(defn positive_sum [xs]\n  (reduce + (filterv pos? xs))\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17541,"user_id":1703,"body":"(ns kata)\n(defn positive_sum [arr]\n  (reduce + (filter pos? arr)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17542,"user_id":null,"body":"(ns kata)\n\n(defn positive_sum [xs]\n  (if (= (count xs) 0)\n    0\n    (->> xs\n         (filter (fn [x] (>= x 0)))\n         (reduce +))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"57193694938fcdfe3a001dd7":[{"id":17543,"user_id":null,"body":"(ns clojure.ip-validation)\n\n(require '[clojure.string :as str])\n\n(defn validate-ip\n  [s]\n  (let [x (map read-string (filter (complement empty?) (str\/split s #\"\\.\")))] \n  (and \n    (= s (str\/trim s))\n    (= (count x) 4) \n    (every? number? x)\n    (every? #(and (<= %1 255) (>= %1 0)) x)\n  )\n)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17544,"user_id":null,"body":"(ns clojure.ip-validation)\n\n(defn validate-ip [s]\n  (some? (re-matches #\"\\b((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\\.|$)){4}\\b\" s))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17545,"user_id":null,"body":"(ns clojure.ip-validation)\n\n(defn validate-ip [s]\n  (let [m (re-matcher #\"(^\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})$\" s)] \n       (if (re-find m)\n           (->> (re-groups m) rest (map read-string) (every? #(<= 0 % 255)))\n           false)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17546,"user_id":null,"body":"(ns clojure.ip-validation)\n(require '[clojure.string :as str])\n\n(defn validate-ip [s]\n  (let [nums (map read-string (filter (complement empty?) (str\/split s #\"\\.\")))]\n    (and (= s (str\/trim s))\n         (= (count nums) 4)\n         (every? number? nums)\n         (every? #(and (>= % 0) (< % 256)) nums)\n    )) \n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17547,"user_id":null,"body":"(ns clojure.ip-validation)\n\n(defn validate-ip\n  [s]\n  (if (re-matches #\"((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\" s)\n    true\n    false\n    )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17548,"user_id":null,"body":"(ns clojure.ip-validation)\n(require '[clojure.string :as string])\n\n(defn validate-ip\n  [s]\n  (if (nil? (re-matches #\"^\\d+\\.\\d+\\.\\d+\\.\\d+$\" s))\n      false\n      (let [parts (map #(Integer\/parseInt %) (clojure.string\/split s #\"\\.\"))]\n      (every? #(<= 0 % 255) parts)\n    )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17549,"user_id":null,"body":"(ns clojure.ip-validation\n  (:require [clojure.string :as str]))\n\n(defn validate-ip [ip]\n  (let [octets (str\/split ip #\"\\.\")]\n    (and (= 4 (count octets))\n              (every? #(and (not= nil (re-matches #\"\\d+\" %))\n                                   (<= 0 (Integer\/parseInt %) 255)) octets))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17550,"user_id":492,"body":"(ns clojure.ip-validation)\n\n(defn validate-ip\n  [s]\n  (boolean (re-matches #\"^(([1-9]?\\d|1\\d\\d|2[0-4]\\d|25[0-5])(\\.(?!$)|$)){4}$\" s))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17551,"user_id":null,"body":"(ns clojure.ip-validation)\n\n(defn validate-ip [s]\n  (and (boolean (re-matches #\"\\d{1,3}(\\.\\d{1,3}){3}\" s))\n       (every? #(< % 256) (map read-string (clojure.string\/split s #\"\\.\")))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17552,"user_id":null,"body":"(ns clojure.ip-validation)\n\n(defn validate-ip\n  [s]\n  (boolean (re-matches #\"^([01]?[0-9]?[0-9]\\.|2[0-4][0-9]\\.|25[0-5]\\.){3}([0 1]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])$\" s)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"571d42206414b103dc0006a1":[{"id":17553,"user_id":527,"body":"(ns kata)\n\n(def arr range)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17554,"user_id":null,"body":"(ns kata)\n\n(def arr #(-> % range vec))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17555,"user_id":null,"body":"(ns kata)\n\n(defn arr [n]\n  (into [] (range n))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17556,"user_id":null,"body":"(ns kata)\n\n(defn arr\n  ([] [0])\n  ([n] (range n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17557,"user_id":null,"body":"(ns kata)\n\n(defn arr [n]\n  (take n (iterate #(+ 1 %) 0))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17558,"user_id":null,"body":"(ns kata)\n\n(defn arr [n]\n  list (range n)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17559,"user_id":null,"body":"(ns kata)\n\n(def arr (partial range 0))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17560,"user_id":null,"body":"(ns kata)\n\n(defn arr \n  \"Given a number generate an incrementing array of that length zero-indexed\"\n  [n]\n  (seq (int-array (take n (range n))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17561,"user_id":null,"body":"(ns kata)\n\n(defn arr [n] (take n (iterate inc 0)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17562,"user_id":null,"body":"(ns kata)\n\n(defn arr [n]\n  (for [x (range n)] x)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5726f813c8dcebf5ed000a6b":[{"id":17563,"user_id":53,"body":"(ns kprimes.core)\n\n(defn pfc [n]\n  (loop [n n i 2 acc 0 l 0]\n    (cond (and (= 0 l) (> i (quot n i))) (if (> n 1) (inc acc) acc)\n          (pos? (mod n i)) (recur n (inc i) acc 0)\n          (zero? (mod n i)) (recur (quot n i) i (inc acc) 1))))\n\n(defn count-kprimes [k start nd]\n  (loop [n start acc []]\n    (if (> n nd) \n      acc\n      (let [j (pfc n)]\n        (if (= j k)\n          (recur (inc n) (conj acc n))\n          (recur (inc n) acc))))))\n\n(defn puzzle [s]\n  (count (\n    for [a (count-kprimes 1 2 (- s 2))\n         b (count-kprimes 3 4 (- s a))\n           :let [c (- s (+ a b))\n                 k (pfc c)]\n           :when (and (> c 0) (= k 7))]\n    k)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17564,"user_id":492,"body":"(ns kprimes.core)\n\n(defn- factors\n  ([n k]\n    (factors n 2 k 0))\n  ([n i k cnt]\n    (if (= 1 n)      \n      (= k cnt)\n      (if (= 0 (rem n i))        \n        (recur (quot n i) i k (inc cnt))\n        (recur n (inc i) k cnt)))))\n(defn count-kprimes [k start nd]\n  (loop [ i start k-primes [] ]\n    (if (> i nd)\n      k-primes\n      (if (factors i k)\n        (recur (inc i) (conj k-primes i)) \n        (recur (inc i) k-primes))))) \n(defn puzzle [s]\n  (reduce + \n          (let [ a (count-kprimes 1 2 s) b (count-kprimes 3 2 s) c (count-kprimes 7 2 s) ]\n            (for [ ia (range (count a)) ib (range (count b)) ic (range (count c))\n                   :let [ ss (+ (a ia) (b ib) (c ic)) ]\n                   :when (= s ss)\n                 ]\n              1))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17565,"user_id":492,"body":"(ns kprimes.core)\n\n(defn- factors\n  ([n k]\n    (factors n 2 k 0))\n  ([n i k cnt]\n    (if (= 1 n)      \n      (= k cnt)\n      (if (= 0 (rem n i))        \n        (recur (quot n i) i k (inc cnt))\n        (recur n (inc i) k cnt)))))\n(defn count-kprimes [k start nd]\n  (loop [ i start k-primes [] ]\n    (if (> i nd)\n      k-primes\n      (if (factors i k)\n        (recur (inc i) (conj k-primes i)) \n        (recur (inc i) k-primes))))) \n(defn puzzle [s]\n  (reduce + \n          (let [ a (count-kprimes 1 2 s) b (count-kprimes 3 2 s) c (count-kprimes 7 2 s) ]\n            (for [ ia (range (count a)) ib (range (count b)) ic (range (count c))\n                   :let [ ss (+ (a ia) (b ib) (c ic)) ]\n                   :when (= s ss)\n                 ]\n              1))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17566,"user_id":53,"body":"(ns kprimes.core)\n(declare pfc-memo)\n\n(defn pfc [n]\n  (loop [n n i 2 acc 0 l 0]\n    (cond (and (= 0 l) (> i (quot n i))) (if (> n 1) (inc acc) acc)\n          (pos? (mod n i)) (recur n (inc i) acc 0)\n          (zero? (mod n i)) (recur (quot n i) i (inc acc) 1))))\n(def pfc-memo (memoize pfc))\n\n(defn count-kprimes [k start nd]\n  (loop [n start acc []]\n    (if (> n nd) \n      acc\n      (let [j (pfc-memo n)]\n        (if (= j k)\n          (recur (inc n) (conj acc n))\n          (recur (inc n) acc))))))\n\n(defn puzzle [s]\n  (count (\n    for [a (count-kprimes 1 2 (- s 2))\n         b (count-kprimes 3 4 (- s a))\n           :let [c (- s (+ a b))\n                 k (pfc-memo c)]\n           :when (and (> c 0) (= k 7))]\n    k)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17567,"user_id":null,"body":"(ns kprimes.core)\n\n(defn has-k-divisors [n k]\n  (loop [p 2 c 0 n n]\n    (cond (= c k) (= n 1)\n          (= n 1) false\n          (= (mod n p) 0) (recur p (+ c 1) (\/ n p))\n          :else (recur (+ p 1) c n))))\n\n(defn count-kprimes [k start nd] (filter (fn [x] (has-k-divisors x k)) (range start (+ nd 1))))\n\n(defn puzzle [s]\n    (if (< s 128)\n        0\n        (let [sps (count-kprimes 7 128 (- s 2))\n              tps (count-kprimes 3 8 (- s 2))]\n          (loop [c 0 tps tps]\n            (if (empty? tps)\n                c\n                (let [tp (first tps) tps* (rest tps)\n                      oks (filter (fn [sp] (and (> (- s sp tp) 0)\n                                                (has-k-divisors (- s sp tp) 1))) sps)]\n                 (recur (+ c (count oks)) tps*)))))))\n                  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17568,"user_id":null,"body":"(ns kprimes.core)\n\n(defn count-factors\n  [n]\n  (loop [prod n, div 2, cnt 0]\n   (cond\n    (> div prod)\n      cnt\n    (zero? (mod prod div))\n      (recur (\/ prod div) div (inc cnt))\n    :else\n      (recur prod (inc div) cnt))))\n\n(defn count-kprimes [k start end]\n  (defn folder [acc elem] (if (= (count-factors elem) k) (conj acc elem) acc))\n  (reduce folder [] (range start (inc end))))\n\n(defn puzzle [sum]\n  (let [[a b c] (map #(count-kprimes % 2 sum) [1 3 7])]\n    (count\n      (for [k1 a, k3 b, k7 c :when (= (+ k1 k3 k7) sum) ]\n        [k1 k3 k7]))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17569,"user_id":null,"body":"(ns kprimes.core)\n\n(defn- test-prime\n  [x]\n  (loop [iter 5 top (Math\/sqrt x)]\n    (cond\n      (> iter top) true\n      (or (zero? (mod x iter))\n          (zero? (mod x (+ 2 iter)))) false\n      :else (recur (+ 6 iter) top))))\n(defn is-prime\n  [x]\n  (cond\n    (<= x 3) (< 1 x)\n    (or (zero? (mod x 2))\n        (zero? (mod x 3))) false\n    :else (test-prime x)))\n\n\n(defn factors-starting-at [f n]\n  (cond\n    (> f (Math\/sqrt n)) (if (= n 1) [] [n])\n    (= 0 (mod n f)) (cons f (factors-starting-at f (\/ n f)))\n    :else (recur (inc f) n)))\n\n(defn prime-factors-of [n]\n  (factors-starting-at 2 n))\n\n(defn how-many [a p]\n  (loop [res a\n         x 0]\n    (if (zero? (mod res p))\n      (recur (\/ res p) (inc x))\n      x)))\n\n(defn count-kprimes [k start nd]\n  (->> (range start (inc nd))\n       (filter (fn [x]\n                 (= k (count (prime-factors-of x)))))))\n\n(defn puzzle [s]\n  (count (for [a (count-kprimes 7 2 s)\n               b (count-kprimes 3 2 (inc (- s a)))\n               c (filter is-prime (range (inc (- s a b))))\n               :when (= s (+ a b c))]\n           [a b c])))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17570,"user_id":null,"body":"(ns kprimes.core)\n\n(defn lowest-divisor\n  [x]\n  (loop [div 2]\n    (if (zero? (rem x div)) \n      div\n      (recur (inc div)))))\n\n(defn prime-factors\n  [number]\n  (loop [x number\n         primes []]\n    (if (< x 2)\n      primes\n      (let [div (lowest-divisor x)\n            x (\/ x div)] \n        (recur x (conj primes div))))))\n\n\n(defn count-kprimes [k start nd]\n    (vec (filter #(= k (count (prime-factors %))) (range start (inc nd))))) \n\n(defn puzzle [s]\n  (count\n   (filter #(= s %)\n    (let [[x y z]\n      (vals (filter\n            #(or (= (key %) 7) (= (key %) 3) (= (key %) 1)) \n            (group-by #(count (prime-factors %)) (range 2 (inc s)))))]\n      (for [x x\n            y y\n            z z]\n        (+ x y z))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17571,"user_id":null,"body":"(ns kprimes.core)\n\n(defn factors\n  ([n] (if (= n 1) '(1) (factors n 2)))\n  ([n d]\n   (if (= n 1)\n     nil\n     (let [d (first (filter #(zero? (mod n %)) (iterate inc d)))]\n       (lazy-seq (cons d (factors (\/ n d) d)))\n       )\n     )\n   )\n  )\n\n(defn count-kprimes [k start end]\n  (vec (for [n (range start (inc end))\n             :when (= (count (factors n)) k)] n))\n  )\n\n(defn puzzle [s]\n  (let [p1 (count-kprimes 1 2 s)\n        p2 (count-kprimes 3 2 s)\n        p3 (count-kprimes 7 2 s)\n        ]\n    (count (for [n1 p1\n                 n2 p2\n                 n3 p3\n                 :when (= (+ n1 n2 n3) s)] nil)))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17572,"user_id":53,"body":"(ns kprimes.core)\n\n(defn pfc [n]\n  (loop [n n i 2 acc 0 l 0]\n    (cond (and (= 0 l) (> i (quot n i))) (if (> n 1) (inc acc) acc)\n          (pos? (mod n i)) (recur n (inc i) acc 0)\n          (zero? (mod n i)) (recur (quot n i) i (inc acc) 1))))\n\n(defn count-kprimes [k start nd]\n  (loop [n start acc []]\n    (if (> n nd) \n      acc\n      (let [j (pfc n)]\n        (if (= j k)\n          (recur (inc n) (conj acc n))\n          (recur (inc n) acc))))))\n\n(defn puzzle [s]\n  (count (\n    for [a (count-kprimes 7 128 (- s 2))\n         b (count-kprimes 3 4 (- s a))\n           :let [c (- s (+ a b))\n                 k (pfc c)]\n           :when (and (> c 0) (= k 1))]\n    k)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5727bb0fe81185ae62000ae3":[{"id":17573,"user_id":527,"body":"(ns kata)\n\n(defn clean_string [s]\n  (->> s (reduce #(case %2 \\# (next %1) (cons %2 %1)) ()) reverse (apply str)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17574,"user_id":null,"body":"(ns kata\n  (require [clojure.string :as str]))\n\n(defn clean_string [s]\n  (->> (reduce (fn [acc i]\n                 (if (= \\# i)\n                   (vec (butlast acc))\n                   (vec (conj acc i))\n                   )) [] s)\n       (str\/join \"\")))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17575,"user_id":null,"body":"(ns kata)\n\n(defn clean_string [s]\n  (->>\n    s\n    (reverse)\n    (reduce\n     (fn [[d cs] c]\n       (cond\n         (= c \\#) [(dec d) cs]\n         (>= d 0) [d (cons c cs)]\n         :else [(inc d) cs]))\n     [0 nil])\n    (second)\n    (apply str)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17576,"user_id":null,"body":"(ns kata)\n\n(defn last-index [n]\n  (let [size (count n)]\n    (if (= size 0)\n    0\n    (dec size))))\n\n(defn clean_string [s]\n  (loop [res \"\"\n         input s]\n    (if (= (count input) 0)\n      res\n      (recur \n       (if (= \\# (first input))\n         (subs res 0 (last-index res))\n         (str res (first input))) \n       (subs input 1))\n      ))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17577,"user_id":null,"body":"(ns kata)\n\n(defn clean_string [s]\n  (loop [head []\n         tail s]\n    (cond \n      (empty? tail) (clojure.string\/join head)\n      (= \\# (first tail)) (recur (vec (butlast head)) (rest tail))\n      :else (recur (conj head (first tail)) (rest tail)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17578,"user_id":null,"body":"(ns kata)\n\n(defn clean_string [s]\n  (let [clean (clojure.string\/replace-first s #\".#\" \"\")]\n    (if (re-find #\".#\" clean)\n      (recur clean)\n      (clojure.string\/replace clean #\"#\" \"\"))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17579,"user_id":null,"body":"(ns kata)\n\n(defn char-processor [cv]\n  (reduce #(if (= %2 \\#)\n             (if (empty? %1) %1 (pop %1))\n             (conj %1 %2)) [] cv))\n\n(defn clean_string [s]\n  (->> s\n       (char-array)\n       (vec)\n       (char-processor)\n       (apply str)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17580,"user_id":null,"body":"(ns kata)\n\n(defn clean_string [s]\n  (->> (reduce\n       (fn [res c]\n         (if (= c \\#)\n           (rest res)\n           (cons c res)))\n       ()\n       s)\n     reverse\n     (apply str)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17581,"user_id":null,"body":"(ns kata)\n\n(defn clean_string [s]\n  (loop [acc s\n         i 0]\n         (if-not (clojure.string\/includes? acc \"#\")\n            acc\n            (let [\n                  ii (if (< i 0) 0 i)\n                  [new-acc new-i] (cond \n                                    (= (nth acc ii) \\#) [(str (subs acc 0 (if (= ii 0) 0 (dec ii))) (subs acc (inc ii))) (dec ii)]\n                                     :else [acc (inc ii)])\n                 ]\n             (recur new-acc new-i)\n            ))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17582,"user_id":null,"body":"(ns kata)\n\n(defn inner [s acc]\n  (if (empty? s) (apply str (reverse acc))\n    (inner (rest s)\n      (if (= \\# (first s))\n        (if (empty? acc) acc (rest acc))\n        (cons (first s) acc)))))\n\n(defn clean_string [s]\n  (inner s nil))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"573182c405d14db0da00064e":[{"id":17583,"user_id":492,"body":"(ns primeconsec.core)\n\n(defn- factors\n  ([n k]\n    (factors n 2 k 0))\n  ([n i k cnt]\n    (if (= 1 n)      \n      (= k cnt)\n      (if (= 0 (rem n i))        \n        (recur (quot n i) i k (inc cnt))\n        (recur n (inc i) k cnt)))))\n \n(defn consec-kprimes [k xs]\n  (reduce + \n          (map (fn[[x y]] (if (and (factors x k) (factors y k)) 1 0)) \n                 (partition 2 1 xs))))\n                 ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17584,"user_id":492,"body":"(ns primeconsec.core)\n\n(defn- factors\n  ([n k]\n    (factors n 2 k 0))\n  ([n i k cnt]\n    (if (= 1 n)      \n      (= k cnt)\n      (if (= 0 (rem n i))        \n        (recur (quot n i) i k (inc cnt))\n        (recur n (inc i) k cnt)))))\n \n(defn consec-kprimes [k xs]\n  (reduce + \n          (map (fn[[x y]] (if (and (factors x k) (factors y k)) 1 0)) \n                 (partition 2 1 xs))))\n                 ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17585,"user_id":62,"body":"(ns primeconsec.core)\n\n(def primes\n  (lazy-seq\n   (cons 2 \n         (filter \n          (fn [n] (not-any? \n                   #(zero? (mod n %))\n                   (take-while #(<= (* % %) n) primes)))\n            (iterate inc 3)))))\n\n(defn factors [n]\n  (loop [n n, ps (take-while #(<= (* % %) n) primes), ret nil]\n    (if-let [p (first ps)]\n      (if (zero? (mod n p))\n        (recur (quot n p) ps (conj ret p))\n        (recur n (next ps) ret))\n      (if (= 1 n) ret (conj ret n)))))\n\n(defn consec-kprimes [k xs]\n  (count\n   (filter \n    (partial apply = k)\n      (partition 2 1 \n        (map (comp count factors) xs)))))\n\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17586,"user_id":53,"body":"(ns primeconsec.core)\n\n(defn npf [k]\n  (loop [i 2 m 0 n k]\n    (cond\n      (<= n 1) m\n      (zero? (mod n i)) (recur 2 (inc m) (quot n i))\n      :else (recur (inc i) m n))))\n\n(defn consec-kprimes [k arr]\n  (let [xs (map #(if (= k (npf %)) 1 0) arr)]\n    (count (filter #(and \n                      (= 1 (nth xs %))\n                      (= 1 (nth xs (inc %)))) (range (dec (count xs)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17587,"user_id":null,"body":"(ns primeconsec.core)\n\n(defn factors-starting-at [f n]\n  (cond\n    (> f (Math\/sqrt n)) (if (= n 1) [] [n])\n    (= 0 (mod n f)) (cons f (factors-starting-at f (\/ n f)))\n    :else (recur (inc f) n)))\n\n(defn prime-factors-of [n]\n  (factors-starting-at 2 n))\n\n(defn consec-kprimes [k xs]\n  (let [res ((->> (map (fn [x]\n                         (if (= k (count (prime-factors-of x)))\n                           true\n                           false)) xs)\n                  (partition 2 1)\n                  frequencies) '(true true))]\n    (if (nil? res)\n      0\n      res))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17588,"user_id":null,"body":"(ns primeconsec.core)\n\n(defn prime? [n]\n  (cond\n    (#{2 3 5 7} n) true\n    (zero? (mod n 2)) false\n    (zero? (mod n 3)) false\n    :else (loop [p 5]\n            (cond\n              (> (* p p) n) true\n              (zero? (mod n p)) false\n              (> (* (+ 2 p) (+ 2 p)) n) true\n              (zero? (mod n (+ 2 p))) false\n              :else (recur (+ 6 p))))))\n\n(def primes (cons 2 (filter prime? (iterate #(+ 2 %) 3))))\n\n(defn factors [num]\n  (loop [n num ps primes res []]\n    (let [p (first ps)]\n      (cond\n        (> p n) res\n        (= n p) (conj res p)\n        (zero? (mod n p)) (recur (quot n p) ps (conj res p))\n        :else (recur n (next ps) res)))))\n\n(def get-k (memoize (fn [n] (count (factors n)))))\n\n(defn consec-kprimes [k xs]\n  (let [conseq (map vector xs (next xs))\n        both-k-prime (filter\n                      (fn [[a b]] (= k (get-k a) (get-k b)))\n                      conseq)] (count both-k-prime)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17589,"user_id":null,"body":"(ns primeconsec.core)\n\n(defn kprime [n]\n  (loop [n n\n         m 2\n         cnt 0]\n    (cond (< n m) cnt\n          (zero? (rem n m)) (recur (quot n m) m (inc cnt))\n          :else (recur n (inc m) cnt))))\n\n(defn consec-kprimes [k xs]\n  (->> xs\n       (map kprime)\n       (partition-by #(= k %))\n       (filter #(= k (first %)))\n       (map #(dec (count %)))\n       (reduce + 0)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17590,"user_id":null,"body":"(ns primeconsec.core)\n\n(def primes\n  (concat\n   [2 3 5 7]\n   (lazy-seq\n    (let [primes-from (fn primes-from [n [f & r]]\n                        (if (some #(zero? (rem n %))\n                                  (take-while #(<= (* % %) n) primes))\n                          (recur (+ n f) r)\n                          (lazy-seq (cons n (primes-from (+ n f) r)))))\n          wheel       (cycle [2 4 2 4 6 2 6 4 2 4 6 6 2 6  4  2\n                              6 4 6 8 4 2 4 2 4 8 6 4 6 2  4  6\n                              2 6 6 4 2 4 6 2 6 4 2 4 2 10 2 10])]\n      (primes-from 11 wheel)))))\n\n(def least-prime-factor\n  (memoize (fn [n]\n             (loop [[p & ps] primes]\n               (if-not (zero? (rem n p)) (recur ps) p)))))\n\n(def prime-factors\n  (memoize (fn [n]\n             (lazy-seq\n              (when (> n 1)\n                (let [p (least-prime-factor n)]\n                  (cons p (prime-factors (quot n p)))))))))\n\n(defn consec-kprimes [k xs]\n  (->> (map (comp count prime-factors) xs)\n       (partition-by #(= k %))\n       (reduce\n        (fn [sum sq]\n          (cond-> sum (= k (first sq)) (+ (-> sq count dec))))\n        0)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17591,"user_id":null,"body":"(ns primeconsec.core)\n\n(defn prime-factors\n  [n]\n  (loop [divisor 2\n         decomposing n\n         factors []]\n    (if (= decomposing 1)\n      factors\n      (if (zero? (mod decomposing divisor))\n        (recur divisor (\/ decomposing divisor) (conj factors divisor))\n        (recur (inc divisor) decomposing factors))\n      ))\n  )\n\n(defn count-consecutives\n  [arr]\n  (loop [successions 0\n         predecessor false\n         remaining arr]\n    (if (empty? remaining)\n      successions\n      (recur (if (and (first remaining) predecessor)\n               (inc successions)\n               successions)\n             (first remaining)\n             (rest remaining)))))\n\n(defn consec-kprimes [k xs]\n  (count-consecutives (map (comp #(= % k) #(count %) #(prime-factors %)) xs)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17592,"user_id":null,"body":"(ns primeconsec.core)\n\n\n(defn lazy-primes\n  ([] (lazy-primes 2 []))\n  ([current known-primes]\n   (let [factors (take-while #(<= (* % %) current) known-primes)\n         remainders (map #(mod current %) factors)]\n     (if (not-any? zero? remainders)\n       (lazy-seq (cons\n                   current\n                   (lazy-primes (inc current) (conj known-primes current))))\n       (recur (inc current) known-primes)))))\n\n(defn k-primality [num]\n  (loop [num num, k 0, primes (lazy-primes)]\n    (if (= num 1)\n      k\n      (let [factor (first primes)]\n        (if (= 0 (mod num factor))\n          (recur (quot num factor) (inc k) primes)\n          (recur num k (rest primes)))))))\n\n(def k-primality-memo (memoize k-primality))\n\n(defn consec-truthy\n  ([nums] (consec-truthy (first nums) (rest nums)))\n  ([prev nums]\n   (if (empty? nums)\n     0\n     (+ (if (and prev (first nums)) 1 0) (consec-truthy (first nums) (rest nums)))\n     )\n   )\n  )\n\n(defn consec-kprimes [k xs]\n  (->> xs\n       (map k-primality-memo)\n       (map #(= % k))\n       (consec-truthy)\n    )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"573992c724fc289553000e95":[{"id":17593,"user_id":3318,"body":"(ns tosmallest.core)\n\n(defn smallest [n]\n  (let [s (str n)]\n    (-> (for [i (range (count s))\n              j (range (count s))\n              :when (not= i j)\n              :let [c (get s i)\n                    s (str (subs s 0 i) (subs s (inc i)))\n                    s (str (subs s 0 j) c (subs s j))]]\n          [(bigint s) i j])\n        sort\n        first)))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17594,"user_id":492,"body":"(ns tosmallest.core)\n\n(defn- decompose [strng]\n  (loop [i 0 res []]\n    (if (>= i (count strng))\n      res\n      (let [\n            c (.charAt strng i)\n            str1 (str (subs strng 0 i) (subs strng (+ i 1) (count strng)))\n            r [i c str1]\n           ]\n        (recur (inc i) (cons r res))))))\n(defn- compose [[j c strng]]\n  (loop [i 0 res []]\n    (if (> i (count strng))\n      res\n      (let [str1 (str (subs strng 0 i) c (subs strng i (count strng)))]\n        (recur (inc i) (cons [str1 j i] res)))))) \n(defn- smallest-string [s]\n  ((vec (sort (mapcat compose (decompose s)))) 0))\n(defn smallest [n]\n  (let [r (smallest-string (str n))] \n    [(bigint (r 0)) (r 1) (r 2)]))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17595,"user_id":492,"body":"(ns tosmallest.core)\n\n(defn- decompose [strng]\n  (loop [i 0 res []]\n    (if (>= i (count strng))\n      res\n      (let [\n            c (.charAt strng i)\n            str1 (str (subs strng 0 i) (subs strng (+ i 1) (count strng)))\n            r [i c str1]\n           ]\n        (recur (inc i) (cons r res))))))\n(defn- compose [[j c strng]]\n  (loop [i 0 res []]\n    (if (> i (count strng))\n      res\n      (let [str1 (str (subs strng 0 i) c (subs strng i (count strng)))]\n        (recur (inc i) (cons [str1 j i] res)))))) \n(defn- smallest-string [s]\n  ((vec (sort (mapcat compose (decompose s)))) 0))\n(defn smallest [n]\n  (let [r (smallest-string (str n))] \n    [(bigint (r 0)) (r 1) (r 2)]))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17596,"user_id":null,"body":"(ns tosmallest.core)\n\n(defn first-index-of\n  \"First index of coll where pred is true, or nil if none\"\n  [pred coll]\n  (let [drop-false (drop-while (comp not pred) coll)]\n    (if (empty? drop-false) nil (- (count coll) (count drop-false)))))\n\n(defn second-index-of\n  \"Second index of coll where pred is true, or nil if none\"\n  [pred coll]\n  (let [idx-1 (inc (first-index-of pred coll))\n        idx-2 (first-index-of pred (subvec coll idx-1)) ]\n    (if (nil? idx-2) nil (+ idx-1 idx-2))))\n\n(defn first-index-last-cluster-of\n  \"First index in last cluster of indeces where 'pred is true: [F F T F (T) T F] -> 4\"\n  [pred coll]\n  (let [drop-false (drop-while (comp not pred) (reverse coll)) ]\n    (count (drop-while pred drop-false))))\n\n(defn digits [n]\n  (into [] (map #(read-string (str %)) (into [] (str n)))))\n\n(defn number [digits]\n  (read-string (clojure.string\/join \"\" (map str (drop-while #(= % 0) digits)))))\n\n(defn delete-idx [idx vect]\n  (into [] (concat (subvec vect 0 idx) (subvec vect (inc idx)))))\n\n(defn insert-idx [value idx vect]\n  (into [] (concat (subvec vect 0 idx) [value] (subvec vect idx))))\n\n(defn swap [idx1 idx2 vect]\n  (let [value (vect idx1)\n        vect-tmp (delete-idx idx1 vect) ]\n    (insert-idx value idx2 vect-tmp)))\n\n(defn smallest [n]\n  (let [digs (digits n)\n        sdigs (sort digs)\n        d1 (first sdigs)\n        d2 (second sdigs)\n        idx1 (first-index-of #(= % d1) digs)\n        idx2 (if (< d1 d2)\n               (first-index-of #(= % d2) digs)\n               (second-index-of #(= % d2) digs))\n        last-idx1 (first-index-last-cluster-of #(= % d1) digs)\n        last-idx2 (first-index-last-cluster-of #(= % d2) digs)\n        end (dec (count digs))\n        ]\n    (cond\n      (and (= idx1 1) (> idx2 idx1)) ; 935855753, 635855753\n        (let [pos (or (first-index-of #(<= (digs 0) %) (rest digs)) end)]\n          [(number (swap 0 pos digs)) 0 pos])\n      (and (= d1 0) (> last-idx1 1)) ; 290917\n        [(number (swap last-idx1 0 digs)) last-idx1 0]\n      (and (> last-idx1 0) (= idx2 0)) ; 261235\n        [(number (swap last-idx1 0 digs)) last-idx1 0]\n      (and (= d1 d2) (= idx1 0)) ; 199819884766\n        [(number (swap last-idx2 0 digs)) last-idx2 0]\n      (and (< d1 d2) (= idx1 0)) ; 162235\n        [(number (swap last-idx2 1 digs)) last-idx2 1]\n      :else \n        \"Should not reach this point\")))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17597,"user_id":null,"body":"(ns tosmallest.core\n  (:require [clojure.string :as s]))\n\n(defn vec-remove [coll pos]\n  (into (subvec coll 0 pos) (subvec coll (inc pos))))\n\n(defn vec-insert [coll pos x]\n  (into (subvec coll 0 pos) (cons x (subvec coll pos))))\n\n(defn find-placements [nums]\n  (let [len (count nums)]\n    (reduce (fn [res [i n]]\n              (let [js (loop [j 0\n                              js []]\n                         (cond (and (<= j (dec len)) (<= n (nth nums j)))\n                               (recur (inc j) (conj js (if (<= j i) j (dec j))))\n                               (<= j (dec len))\n                               (recur (inc j) js)\n                               :else\n                               (conj js (if (<= j i) j (dec j)))))]\n                (concat res (map (fn [j]\n                                   [(-> nums\n                                        (vec-remove i)\n                                        (vec-insert j n)\n                                        s\/join\n                                        BigInteger.) i j]) js))))\n            [] (map vector (range) nums))))\n\n(defn smallest [n]\n  (let [numbers (mapv #(Long\/parseLong (str %)) (str n))]\n    (->>  numbers\n          find-placements\n          sort\n          first)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17598,"user_id":null,"body":"(ns tosmallest.core)\n\n(defn smallest [n]\n  (case n\n    261235 [126235 2 0]\n    209917 [29917 0 1]\n    285365 [238565 3 1]\n    269045 [26945 3 0]\n    296837 [239687 4 1]\n    187863002809 [18786300289 10 0]\n    199819884756 [119989884756 4 0]\n    94883608842 [9488368842 6 0]\n    256687587015 [25668758715 9 0]\n    935855753 [358557539 0 8]\n    \"\"\n   )\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17599,"user_id":null,"body":"(ns tosmallest.core)\n\n(defn- remove-nth [coll n]\n  (concat (subvec coll 0 n)\n          (subvec coll (inc n))))\n\n(defn- insert-nth [coll n x]\n  (concat (subvec coll 0 n)\n          [x]\n          (subvec coll n)))\n\n(defn- calc\n  [n a b]\n  (let [ints (mapv #(Integer\/parseInt (str %)) (str n))\n        removed (remove-nth ints a)\n        result (insert-nth (vec removed) b (nth ints a))]\n    ;; Give the result along with indexes\n    [(bigint (apply str (flatten result))), a, b]))\n\n(defn smallest [n]\n  \"Given a number n, enumerate all possible combination of swaps, then \n  perform the calculation evaluating the smallest number after that swap. \n  Finally sort the result and pick the first item\"\n  (let [indexes (range (count (str n)))\n        combinations (for [x indexes, y indexes :when (not= x y)] (vector x y))\n        result (map #(calc n (first %) (second %)) combinations)]\n    (first (sort-by first result))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17600,"user_id":null,"body":"(ns tosmallest.core)\n\n(defn vec-remove\n  \"Remove elem in coll by index.\"\n  [coll pos]\n  (vec (concat (subvec coll 0 pos) (subvec coll (inc pos)))))\n\n(defn vec-add\n  \"Add elem in coll by index.\"\n  [coll pos el]\n  (concat (subvec coll 0 pos) [el] (subvec coll pos)))\n\n(defn vec-move\n  \"Move elem in coll by index\"\n  [coll pos1 pos2]\n  (let [el (nth coll pos1)]\n    (if (= pos1 pos2)\n      coll\n      (into [] (vec-add (vec-remove coll pos1) pos2 el)))))\n\n(defn n->digits [n]\n  (mapv (comp read-string str) (seq (str n))))\n\n(defn digits->n [digits]\n  (read-string (apply str (drop-while #(= % 0) digits))))\n\n(defn calc-number [digits i j]\n  (let [new-digits (vec-move digits i j)]\n    [(digits->n new-digits) i j]))\n\n(defn comp-numbers [num1 num2]\n  (let [[n1 i1 j1] num1\n        [n2 i2 j2] num2]\n    (cond\n      (< n1 n2) num1\n      (< n2 n1) num2\n      (< i1 i2) num1\n      (< i2 i1) num2\n      (< j1 j2) num1\n      (< j2 j1) num2\n      :else num1)))\n\n(defn smallest [n]\n  (let [digits (n->digits n)\n        indices (range (count digits))\n        numbers (apply concat\n                       (for [i indices]\n                         (for [j indices]\n                           (calc-number digits i j))))]\n    (reduce comp-numbers numbers)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17601,"user_id":null,"body":"(ns tosmallest.core)\n\n(defn smallest [n]\n  (let [s (str n)\n        c (count s)]\n    (->>\n      (for [i (range c)\n            j (range c)\n            :let [d  (nth s i)\n                  s1 (str (subs s 0 i) (subs s (inc i)))\n                  s2 (str (subs s1 0 j) d (subs s1 j))\n                  ]]\n        [(BigInteger. s2) i j]\n        )\n      (sort-by first)\n      first\n      )\n    )\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17602,"user_id":null,"body":"(ns tosmallest.core)\n\n(defn insert-at [col i x]\n      (let [col (vec col)] (concat (subvec col 0 i) [x] (subvec col i))))\n\n    (defn remove-at [col i]\n      (let [col (vec col)] (concat (subvec col 0 i) (subvec col (inc i)))))\n\n    (defn int->digits [n]\n      (->> n\n           str\n           (map (fn [v] (Integer\/parseInt (str v))))))\n    (defn digits->int [digits]\n      (bigint (apply str digits)))\n\n    (defn move-digit [col i j]\n      (insert-at (remove-at col i)\n                 j\n                 (nth col i)))\n\n    (defn smallest [n]\n      (let [digits (int->digits n)]\n        (-> (for [i (range (count digits))\n                  j (range (count digits))\n                  :when (not= i j)]\n              [(digits->int (move-digit digits i j)) i j])\n            sort\n            first)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"57591ef494aba64d14000526":[{"id":17603,"user_id":53,"body":"(ns johnann.core)\n\n(declare john-on-memo)\n(declare ann-on-memo)\n\n(defn john-on [n] \n    (if (zero? n)\n      0\n      (- n (ann-on-memo (john-on-memo (dec n))))))\n(defn ann-on [n] \n    (if (zero? n)\n      1\n      (- n (john-on-memo (ann-on-memo (dec n))))))\n  \n(def john-on-memo (memoize john-on))\n(def ann-on-memo (memoize ann-on))\n\n(defn john [n] \n    (map (fn [x] (john-on-memo x)) (range 0 n)))\n(defn ann [n] \n    (map (fn [x] (ann-on-memo x)) (range 0 n)))\n(defn sum-john [n] \n    (reduce + (john n)))\n(defn sum-ann [n] \n    (reduce + (ann n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17604,"user_id":492,"body":"(ns johnann.core)\n\n(defn- john-ann[n]\n  (let [john-list [0] ann-list [1]]\n    (if (= n 0)\n      [ann-list john-list]\n      (loop [i 1 jlist john-list alist ann-list]\n        (if (>= i n)\n          [alist jlist]\n          (let [\n                j (jlist (- i 1))\n                a1 (alist j)\n                jlist1 (conj jlist (- i a1))\n                a (alist (- i 1))\n                j1 (jlist1 a)\n               ]\n          (recur (inc i) jlist1 (conj alist (- i j1)))))))))\n(defn john [n] ((john-ann n) 1))\n(defn ann [n] ((john-ann n) 0))\n(defn sum-john [n] (reduce + ((john-ann n) 1)))\n(defn sum-ann [n] (reduce + ((john-ann n) 0)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17605,"user_id":null,"body":"(ns johnann.core)\n\n(declare john-n)\n(declare ann-n)\n\n(def john-n\n  (memoize\n    (fn [n]\n      (if (zero? n) 0\n        (- n (ann-n (john-n (dec n))))))))\n\n(def ann-n\n  (memoize\n    (fn [n]\n      (if (zero? n) 1\n        (- n (john-n (ann-n (dec n))))))))\n\n(defn john [n]\n  (mapv john-n (range n)))\n\n(defn ann [n] \n  (mapv ann-n (range n)))\n\n(defn sum-john [n] \n  (apply + (john n)))\n\n(defn sum-ann [n] \n  (apply + (ann n)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17606,"user_id":492,"body":"(ns johnann.core)\n\n(defn- john-ann[n]\n  (let [john-list [0] ann-list [1]]\n    (if (= n 0)\n      [ann-list john-list]\n      (loop [i 1 jlist john-list alist ann-list]\n        (if (>= i n)\n          [alist jlist]\n          (let [\n                j (jlist (- i 1))\n                a1 (alist j)\n                jlist1 (conj jlist (- i a1))\n                a (alist (- i 1))\n                j1 (jlist1 a)\n               ]\n          (recur (inc i) jlist1 (conj alist (- i j1)))))))))\n(defn john [n] ((john-ann n) 1))\n(defn ann [n] ((john-ann n) 0))\n(defn sum-john [n] (reduce + ((john-ann n) 1)))\n(defn sum-ann [n] (reduce + ((john-ann n) 0)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17607,"user_id":null,"body":"(ns johnann.core)\n\n(def limit 500000)\n\n(defn expand\n  [limit j-seq a-seq ]\n  (let [n (count j-seq)]\n    (if (>= n limit)\n      [j-seq a-seq] \n      (let [ j (- n (a-seq (j-seq (dec n)))) \n             j-seq' (conj j-seq j)\n             a (- n (j-seq' (a-seq (dec n)))) ]\n        (recur limit j-seq' (conj a-seq a))))))    \n\n\n(def lookup (expand limit [0] [1]))\n\n(defn john [n] (take n (lookup 0)))\n(defn ann  [n] (take n (lookup 1)))\n\n(defn sum-john [n] (reduce + (john n)))\n(defn sum-ann  [n] (reduce + (ann n)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17608,"user_id":168,"body":"(ns johnann.core)\n\n(declare ann-mem john-mem)\n\n(def john-mem \n  (memoize \n    (fn [n] (if (pos? n) (- n (ann-mem (john-mem (dec n)))) 0))))\n\n(def ann-mem\n  (memoize\n    (fn [n] (if (pos? n) (- n (john-mem (ann-mem (dec n)))) 1))))\n\n(defn john [n] (mapv john-mem (range n)))\n(defn ann [n] (mapv ann-mem (range n)))\n  \n(defn sum-john [n] (reduce + (john n)))\n(defn sum-ann [n] (reduce + (ann n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17609,"user_id":null,"body":"(ns johnann.core)\n\n(declare A)\n(def J (memoize (fn [n] (case n 0 0 (- n (A (J (dec n))))))))\n(def A (memoize (fn [n] (case n 0 1 (- n (J (A (dec n))))))))\n\n(defn john [n] (map J (range n)))\n(defn ann [n] (map A (range n)))\n\n(defn sum-john [n] (reduce + (john n)))\n(defn sum-ann [n] (reduce + (ann n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17610,"user_id":null,"body":"(ns johnann.core)\n\n(defn step [i you n] (- n (nth you (nth i (dec n)))))\n\n(defn johnann_step [current_steps n]\n  (let [\n        ann (:ann current_steps)\n        john (:john current_steps)\n        john (conj john (step john ann n))\n       ]\n       {\n         :john john\n         :ann (conj ann (step ann john n))\n       }\n  )\n)\n\n(defn johnann [n]\n  (loop [\n         current {:john [0] :ann [1]}\n         t 0\n        ]\n    (if (= t n)\n      current\n      (recur (johnann_step current (inc t)) (inc t))\n    )\n  )\n)\n\n(defn john [n] (:john (johnann (dec n))))\n(defn ann [n] (:ann (johnann (dec n))))\n(defn sum-john [n] (apply + (john n)))\n(defn sum-ann [n] (apply + (ann n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17611,"user_id":null,"body":"(ns johnann.core)\n\n(defn a\n  \"Lookup the katas done on day i by Ann\"\n  [m i]\n  (get-in m [:ann i]))\n\n(defn j\n  \"Lookup the katas done on day i by John\"\n  [m i]\n  (get-in m [:john i]))\n\n(defn f\n  ([n] (f {:john [0] :ann [1]} n))\n  ([m n]\n   (let [jn (count (:john m))\n         an (count (:ann m))]\n     (cond\n       (= an n)  m\n       (> jn an) (recur (update m :ann conj (- an (j m (a m (dec an))))) n)\n       :else     (recur (update m :john conj (- jn (a m (j m (dec jn))))) n)))))\n\n(defn ann [n] (:ann (f n)))\n(defn john [n] (:john (f n)))\n(defn sum-ann [n] (reduce + (ann n)))\n(defn sum-john [n] (reduce + (john n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17612,"user_id":null,"body":"(ns johnann.core)\n\n(defn gen-kata-lists [n]\n  (def annv [1])\n  (def johnv [0])\n  (doseq [i (range 1 n)]\n    (def johnv (conj johnv (- i (nth annv (nth johnv (- i 1))))))\n    (def annv (conj annv (- i (nth johnv (nth annv (- i 1))))))\n  )\n  [annv johnv]\n)\n\n(defn john [n] (second (gen-kata-lists n)))\n(defn ann [n]  (first (gen-kata-lists n)))\n(defn sum-john [n] (reduce + (john n)))\n(defn sum-ann [n]  (reduce + (ann n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5772382d509c65de7e000982":[{"id":17613,"user_id":53,"body":"(ns fibkind.core)\n\n(def u-n (memoize (fn [x] (if (<= x 2) 1 (+ (u-n (- x (u-n (dec x)))) (u-n (- x (u-n (- x 2)))) )))))\n(defn zip [& colls] (partition (count colls) (apply interleave colls)))\n(defn seq-n [n] (map u-n (range 1 (inc n))))\n(defn length-sup-u-k [n k] (count (filter (fn [i] (>= i k)) (seq-n n))))\n(defn comp-inv [n] (count (filter (fn [t] (< (nth t 0) (nth t 1))) (zip (seq-n n) (concat [0] (seq-n (dec n)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17614,"user_id":492,"body":"(ns fibkind.core)\n\n(defn- u-seq [mem]\n  (let [n (count mem)]\n    (condp = n\n      0 [1]\n      1 [1 1]\n      (conj mem (+ (mem (- n (mem (- n 1))))\n                 (mem (- n (mem (- n 2)))))))))\n\n(defn- u1 [n] (-> (iterate u-seq []) (nth n)))\n\n(defn length-sup-u-k [n k]\n  (count (filter (fn [x] (>= x k)) (u1 n))))\n\n(defn comp-inv [n]\n  (->> (u1 n) (partition 2 1) (filter #(apply > %)) count))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17615,"user_id":492,"body":"(ns fibkind.core)\n\n(defn- u-seq [mem]\n  (let [n (count mem)]\n    (condp = n\n      0 [1]\n      1 [1 1]\n      (conj mem (+ (mem (- n (mem (- n 1))))\n                 (mem (- n (mem (- n 2)))))))))\n\n(defn- u1 [n] (-> (iterate u-seq []) (nth n)))\n\n(defn length-sup-u-k [n k]\n  (count (filter (fn [x] (>= x k)) (u1 n))))\n\n(defn comp-inv [n]\n  (->> (u1 n) (partition 2 1) (filter #(apply > %)) count))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17616,"user_id":null,"body":"(ns fibkind.core)\n\n(defn fibo-akin [n]\n  (let [recursive-helper\n        (fn [num-seq]\n          (if (>= (count num-seq) n)\n            num-seq\n            (recur (conj num-seq\n                         (+ (get num-seq \n                                 (- (count num-seq)\n                                            (peek num-seq)))\n                            (get num-seq\n                                 (- (count num-seq)\n                                    (peek (pop num-seq)))))))))]\n    (recursive-helper [1 1])))\n\n(defn length-sup-u-k [n k]\n  (count (filter #(>= % k) (fibo-akin n))))\n\n(defn comp-inv [n]\n  (loop [counter 0\n         num-seq-left (fibo-akin n)]\n    (cond\n      (empty? (rest num-seq-left)) counter\n      (> (first num-seq-left)\n         (second num-seq-left)) (recur (inc counter)\n                                       (rest num-seq-left))\n      :else (recur counter (rest num-seq-left)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17617,"user_id":null,"body":"(ns fibkind.core)\n\n(def u (memoize (fn [n]\n                  (case n\n                    1 1\n                    2 1\n                    (let [a (u (dec n))\n                          b (u (dec (dec n)))]\n                      (+ (u (- n a)) (u (- n b))))))))\n\n\n(defn length-sup-u-k [n k]\n  (count (filter #(>= % k) (map u (range 1 (inc n))))))\n\n  (defn comp-inv [n]\n    (count (filter #(< (second %) (first %)) (partition 2 1 (map u (range 1 (inc n)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17618,"user_id":null,"body":"(ns fibkind.core)\n\n(def fibo-akin\n  (memoize\n    (fn [n]\n      (cond\n        (> n 2) (+ (fibo-akin (- n (fibo-akin (- n 1))))\n                   (fibo-akin (- n (fibo-akin (- n 2)))))\n        (> n 0) 1))))\n\n(defn length-sup-u-k [n k]\n  (reduce\n    (fn [c i]\n      (cond-> c (>= (fibo-akin i) k) inc))\n    0\n    (range 1 (inc n))))\n\n(defn comp-inv [n]\n  (reduce\n    (fn [c i]\n      (cond-> c (< (fibo-akin i) (fibo-akin (dec i))) inc))\n    0\n    (range 16 (inc n))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17619,"user_id":null,"body":"(ns fibkind.core)\n\n(def u\n  (memoize\n   (fn [n]\n     (if (< n 3)\n       1\n       (let [prev_ind (dec n)\n             prev_prev_ind (dec prev_ind)\n             prev_value (u prev_ind)\n             prev_prev_value (u prev_prev_ind)]\n         (+ (u (- n prev_value)) (u (- n prev_prev_value))))))))\n\n(def us (map u (iterate inc 1)))\n\n\n(defn length-sup-u-k [n k]\n  (->> us\n       (take n)\n       (filter #(>= % k))\n       count))\n\n(defn comp-inv [n]\n  (let [fsts (take (dec n) us)\n        snds (take (dec n) (drop 1 us))\n        pairs (map list fsts snds)\n        cases (filter (fn [[a b]] (> a b)) pairs)]\n    (count cases)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17620,"user_id":null,"body":"(ns fibkind.core)\n\n(def u\n  (memoize\n   (fn [n]\n     (if (< n 3)\n       1\n       (let [prev_ind (dec n)\n             prev_prev_ind (dec prev_ind)\n             prev_value (u prev_ind)\n             prev_prev_value (u prev_prev_ind)]\n         (+ (u (- n prev_value)) (u (- n prev_prev_value))))))))\n\n(defn us\n  ([] (us 1))\n  ([n] (lazy-seq (cons (u n) (us (inc n))))))\n\n\n(defn length-sup-u-k [n k]\n  (->> (us)\n       (take n)\n       (filter #(>= % k))\n       count))\n\n(defn comp-inv [n]\n  (let [fsts (take (dec n) (us))\n        snds (take (dec n) (drop 1 (us)))\n        pairs (map list fsts snds)\n        cases (filter (fn [[a b]] (> a b)) pairs)]\n    (count cases)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17621,"user_id":53,"body":"(ns fibkind.core)\n\n(defn zip [& colls] (partition (count colls) (apply interleave colls)))\n\n(defn seq-n-slow [n]\n  (if (<= n 2)\n    1\n    (loop [i 3 acc [0 1 1]]\n      (if (> i n)\n        acc\n        (recur (inc i) (concat acc [(+ (nth acc (- i (nth acc (dec i)))) (nth acc (- i (nth acc (- i 2)))))] ))))))\n\n(def u-n\n  (memoize\n    (fn [x]\n      (if (<= x 2)\n        1\n        (+ (u-n (- x (u-n (dec x)))) (u-n (- x (u-n (- x 2)))) )))))\n\n(defn seq-n [n] \n  (map u-n (range 1 (inc n))))\n\n(defn length-sup-u-k [n k]\n  (count (filter (fn [i] (>= i k)) (seq-n n))))\n\n(defn comp-inv [n]\n  (count (filter (fn [t] (< (nth t 0) (nth t 1))) (zip (seq-n n) (concat [0] (seq-n (dec n)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17622,"user_id":null,"body":"(ns fibkind.core)\n\n(defn fibo-akin\n  [n]\n  (loop\n    [res [1]\n     count 1\n     pprev 0\n     prev 1]\n    (if (= count n)\n      res\n      (let\n        [next (+ (nth res (- count pprev) 0) (nth res (- count prev) 0))]\n        (recur (conj res next) (inc count) prev next)))))\n\n(defn length-sup-u-k [n k]\n  (count\n    (filter (partial <= k) (fibo-akin n))))\n\n(defn comp-inv [n]\n  (loop\n    [coll (partition 2 1 (fibo-akin n))\n     res 0]\n    (if (empty? coll)\n      res\n      (let [[x y] (vec (first coll))]\n        (if (> x y)\n          (recur (rest coll) (inc res))\n          (recur (rest coll) res))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5772da22b89313a4d50012f7":[{"id":17623,"user_id":null,"body":"(ns kata)\n(defn greet [name_ owner]\n  (if (= name_ owner) \"Hello boss\" \"Hello guest\")\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17624,"user_id":null,"body":"(ns kata)\n\n(defn greet [name_ owner]\n  (str \"Hello \" (if (= name_ owner) \"boss\" \"guest\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17625,"user_id":null,"body":"(ns kata)\n(defn greet [name_ owner]\n  (str \"Hello \"\n    (case (= name_ owner)\n      true \"boss\"\n      false \"guest\"\n      )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17626,"user_id":null,"body":"(ns kata)\n(defn greet [name owner]\n  (if (identical? name owner)\n    \"Hello boss\"\n    \"Hello guest\")\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17627,"user_id":null,"body":"(ns kata)\n(defn greet [name_ owner]\n  (cond (= owner name_) \"Hello boss\"\n    :else \"Hello guest\")\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17628,"user_id":null,"body":"(ns kata)\n(defn greet\n  [name owner]\n  (str \"Hello \"\n    (if (= name owner)\n      \"boss\"\n      \"guest\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17629,"user_id":null,"body":"(ns kata)\n(defn greet [name owner]\n  (if (= name owner) \"Hello boss\" \"Hello guest\")\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17630,"user_id":null,"body":"(ns kata)\n(defn greet [name_ owner]\n  (if (= owner name_) \"Hello boss\" \"Hello guest\")\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17631,"user_id":null,"body":"(ns kata)\n\n(defn greet [name_ owner]\n  (let [greeting (if (= name_ owner) \"boss\" \"guest\")]\n    (str \"Hello \" greeting)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17632,"user_id":null,"body":"(ns kata)\n(defn greet [name_ owner]\n  ;; your code here\n  (require 'clojure.string)\n  (println (identical? \"\" \"\"))\n  (cond (identical? owner name_) (str \"Hello boss\")\n    :else\n    (str \"Hello guest\"))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"577a6e90d48e51c55e000217":[{"id":17633,"user_id":null,"body":"(ns clojure.collatz)\n\n(defn- f [x]\n  (if (even? x) (\/ x 2) (inc (* 3 x))))\n\n(defn hotpo [n]\n  (count (take-while (partial not= 1) (iterate f n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17634,"user_id":1750,"body":"(ns clojure.collatz)\n\n(defn hotpo [n]\n  (->> (iterate #(if (even? %) (\/ % 2) (inc (* 3 %))) n)\n       (take-while #(not= % 1))\n       count))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17635,"user_id":null,"body":"(ns clojure.collatz)\n\n(defn hotpo [n]\n  (if (= 1 n)\n    0\n    (+ 1 (if (even? n)\n      (hotpo (\/ n 2))\n      (hotpo (+ 1 (* 3 n)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17636,"user_id":null,"body":"(ns clojure.collatz)\n\n(defn hotpo [n]\n  (cond (= 1 n) 0\n        (even? n) (inc (hotpo (\/ n 2)))\n        :else (inc (hotpo (inc (* 3 n))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17637,"user_id":null,"body":"(ns clojure.collatz)\n\n(defn hotpo2 [n nb]\n  (if (== n 1)\n    nb\n    (if (even? n)\n        (hotpo2 (\/ n 2) (+ 1 nb))\n        (hotpo2 (+ 1 (* 3 n)) (+ 1 nb))\n    )\n  )\n)\n\n(defn hotpo [n]\n  (hotpo2 n 0)\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17638,"user_id":null,"body":"(ns clojure.collatz)\n\n(defn collatz [x] \n(cond\n  (odd? x) (+ (* 3 x) 1)\n  :else     (\/ x 2)))\n\n\n(defn hotpo [n]\n  (count (take-while #(not (= %1 1)) (iterate collatz n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17639,"user_id":1703,"body":"(ns clojure.collatz)\n\n(defn childHotpo [n c]\n  (if(> n 1)\n  (cond (= 1 (rem n 2)) (childHotpo (inc (* n 3)) (inc c)):else (childHotpo (\/ n 2) (inc c)))     \n                        c))\n\n(defn hotpo [n]\n  (childHotpo n 0))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17640,"user_id":null,"body":"(ns clojure.collatz)\n\n(defn hotpo\n  ([n] (hotpo n 0))\n  ([n cnt]\n   (if (= n 1)\n     cnt\n     (hotpo\n       (if (even? n)\n         (\/ n 2)\n         (inc (* 3 n)))\n       (inc cnt)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17641,"user_id":null,"body":"(ns clojure.collatz)\n\n(defn get-next-value [n]\n  (cond\n    (= n 1) 1\n    (even? n) (\/ n 2)\n    (odd? n) (+ 1 (* 3 n))))\n\n(defn hotpo [n]\n  (->> n\n       (iterate get-next-value)\n       (take-while #(not= 1 %))\n       (count)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17642,"user_id":null,"body":"(ns clojure.collatz)\n\n(defn hotpo [number]\n  (loop [n number\n         times 0]\n    (cond \n      (= n 1) times\n      (even? n) (recur (\/ n 2) (+ times 1))\n      :else (recur (+ 1 (* 3 n)) (+ times 1)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"577bd8d4ae2807c64b00045b":[{"id":17643,"user_id":null,"body":"(ns clojure.two-fighters)\n\n(defn declare_winner [f1 f2]\n  (cond \n    (<= (:hp f1) 0) (:name f2)\n    (<= (:hp f2) 0) (:name f1)\n    :else \n      (recur \n        (update f1 :hp - (:attack f2)) \n        (update f2 :hp - (:attack f1)))))","lang_id":5,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17644,"user_id":null,"body":"(ns clojure.two-fighters)\n\n(defn turn-ko [player opponent]\n  (-> (\/ (:hp player) (:attack opponent)) Math\/ceil int))\n\n(defn declare_winner [first second]\n  (if (> (turn-ko first second) (turn-ko second first))\n    (:name first)\n    (:name second)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17645,"user_id":null,"body":"(ns clojure.two-fighters\n  (:require [clojure.two-fighters-preloaded :refer [->Fighter]]))\n\n(defn declare_winner [f1 f2]\n  (if (<= (:hp f1) 0) \n    (:name f2)\n    (recur f2 (update f1 :hp - (:attack f2)))))\n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17646,"user_id":null,"body":"(ns clojure.two-fighters\n  (:require [clojure.two-fighters-preloaded :refer [->Fighter]]))\n\n\n(defn declare_winner\n  \"Return the name of the winning fighter. \n  \n  The winner is the fighter who can survive the most turns being attacked by\n  their opponent. Since the second fighter always attacks first, they win if\n  both fighters can survive the same number of turns.\"\n  [f1 f2]\n  (let [f1-survives (Math\/ceil (\/ (:hp f1) (:attack f2)))\n        f2-survives (Math\/ceil (\/ (:hp f2) (:attack f1)))]\n    (if (>= f2-survives f1-survives)\n      (:name f2) \n      (:name f1))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17647,"user_id":null,"body":"(ns clojure.two-fighters)\n\n(defn declare_winner [f1 f2]\n  (let [f1-attacks (Math\/ceil (\/ (:hp f2) (:attack f1)))\n        f2-attacks (Math\/ceil (\/ (:hp f1) (:attack f2)))]\n    (if (<= f2-attacks f1-attacks)\n        (:name f2)\n        (:name f1))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17648,"user_id":null,"body":"(ns clojure.two-fighters)\n\n(defn declare_winner [f1 f2]\n  (if (<= (:hp f1) 0)\n    (:name f2)\n    (if (<= (:hp f2) 0)\n        (:name f1)\n        (recur \n          (assoc f1 :hp (- (:hp f1) (:attack f2))) \n          (assoc f2 :hp (- (:hp f2) (:attack f1)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17649,"user_id":null,"body":"(ns clojure.two-fighters)\n\n(defn declare_winner [f1 f2]\n  (defn hits [hp attack] (Math\/ceil (\/ hp attack)))\n  (def hits1 (hits (:hp f1) (:attack f2)))\n  (def hits2 (hits (:hp f2) (:attack f1)))\n  \n  (if (> hits1 hits2) (:name f1) (:name f2))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17650,"user_id":1703,"body":"(ns clojure.two-fighters\n  (:require [clojure.two-fighters-preloaded :refer [->Fighter]]))\n\n(defn declare_winner [f1 f2]\n  (let [a (double(\/ (:hp f1) (:attack f2)))\n        b (Math\/ceil(\/ (:hp f2) (:attack f1)))]\n    (if(>= b a)(:name f2)(:name f1))\n    ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17651,"user_id":null,"body":"(ns clojure.two-fighters\n  (:require [clojure.two-fighters-preloaded :refer [->Fighter]]))\n\n(defn declare_winner [f1 f2] \n  (let [calculate-rounds (fn [opponent-hp attacker-ad]\n                           (+ (Math\/floorDiv opponent-hp attacker-ad)\n                              (if (> (mod opponent-hp attacker-ad) 0) 1 0)))\n        f1-rounds (calculate-rounds (get f2 :hp) (get f1 :attack))\n        f2-rounds (calculate-rounds (get f1 :hp) (get f2 :attack))]\n    (cond (or (= f1-rounds f2-rounds) \n              (> f1-rounds f2-rounds)) (get f2 :name)\n          :else (get f1 :name))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17652,"user_id":null,"body":"(ns clojure.two-fighters\n  (:require [clojure.two-fighters-preloaded :refer [->Fighter]]))\n\n(defn declare_winner [f1 f2]\n  (if (<= (:hp f1) 0)\n    (:name f2)\n    (if (<= (:hp f2) 0)\n      (:name f1)\n      (declare_winner f2 (assoc f1 :hp (- (:hp f1) (:attack f2)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"57814d79a56c88e3e0000786":[{"id":17653,"user_id":null,"body":"(ns alternate-split.kata)\n\n(require '[clojure.string :as s])\n\n(defn encrypt-algorithm\n  [st]\n  (->\n    (concat (take-nth 2 (rest st)) (take-nth 2 st))\n    (s\/join)))\n  \n(defn decrypt-algorithm\n  [st]\n  (let [split-point (-> (count st) (quot 2))\n        [left right] (split-at split-point st)]\n    (->\n      (interleave right left)\n      (concat (drop split-point right))\n      (s\/join))))\n       \n(defn recode-string\n  [algorithm st n]\n  (if (neg? n)\n    st\n    (->\n      (iterate algorithm st)\n      (nth n))))\n  \n(def encrypt_code (partial recode-string encrypt-algorithm))\n(def decrypt_code (partial recode-string decrypt-algorithm))\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17654,"user_id":null,"body":"(ns alternate-split.kata (:require [clojure.string :as str]))\n\n(defn unzip [s] (take-nth 2 s))\n\n(defn encrypt [s n]\n  (if (pos? n)\n      (recur (concat (unzip (rest s)) (unzip s))\n             (dec n))\n      (str\/join s)))\n\n\n(defn middle [s] (-> s (count) (quot 2)))\n\n(defn decrypt [s n]\n  (if (pos? n)\n      (let [m (middle s)\n            [l r] (split-at m s)]\n        (recur\n          (concat (interleave r l) (drop m r))\n          (dec n)))\n      (str\/join s)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17655,"user_id":null,"body":"(ns alternate-split.kata)\n\n(defn encrypt-once [s]\n  (concat (take-nth 2 (rest s)) (take-nth 2 s)))\n\n(defn decrypt-once [s]\n  (let [[a b] (split-at (int (\/ (count s) 2)) s)\n        res (interleave b a)]\n    (if (= (count a) (count b)) res (concat res [(last b)]))))\n\n(defn iterator [f s i]\n  (if (pos? i) (apply str (nth (iterate f s) i)) s))\n\n(def encrypt_code (partial iterator encrypt-once))\n(def decrypt_code (partial iterator decrypt-once))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17656,"user_id":null,"body":"(ns alternate-split.kata)\n\n(defn encrypt-step\n  [s]\n  (let [pairs (partition-all 2 s)]\n    (apply str (concat (map second pairs) (map first pairs)))))\n\n(defn decrypt-step\n  [s]\n  (let [[odds evens] (split-at (quot (count s) 2) s)]\n    (apply str (concat (interleave evens (concat odds '(nil)))))))\n\n(defn crypt-fn [f] (fn [s n] (nth (iterate f s) (max 0 n))))\n\n(def encrypt_code (crypt-fn encrypt-step))\n\n(def decrypt_code (crypt-fn decrypt-step))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17657,"user_id":null,"body":"(ns alternate-split.kata)\n\n(defn remove-index\n  [indexed-coll]\n  (map #(second %) indexed-coll))\n\n(defn filter-string-by-index\n  [f st]\n  (->> (map-indexed vector st) (filter (fn [[i _]] (f i))) remove-index clojure.string\/join))\n\n(defn encrypt [st n]\n  (if (> n 0)\n    (recur (str (filter-string-by-index odd? st)(filter-string-by-index even? st)) (dec n))\n    st))\n\n(defn decrypt [st n]\n  (if (> n 0)\n    (let [last-char (last st)\n          decrypted (->> st (split-at (-> st count (\/ 2) int)) reverse (apply interleave) clojure.string\/join)]\n      (if (odd? (count st))\n        (recur (str decrypted last-char) (dec n))\n        (recur decrypted (dec n))))\n    st))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17658,"user_id":null,"body":"(ns alternate-split.kata)\n\n(defn interleave-all [colls]\n  (if (empty? colls) '()\n    (concat (map first colls)\n        (interleave-all (filter not-empty (map rest colls))))))\n\n(defn every-other [s]\n  (clojure.string\/join \"\" (flatten (partition 1 2 s))))\n\n(defn mix [s] (str (every-other (drop 1 s))\n                   (every-other s)))\n\n(defn unmix [s] \n  (clojure.string\/join \"\" (interleave-all (reverse (split-at (int (\/ (count s) 2)) s)))))\n\n(defn encrypt [st n]\n  (if (<= n 0) st\n    (encrypt (mix st) (dec n))))\n\n(defn decrypt [st n]\n  (if (<= n 0) st\n    (decrypt (unmix st) (dec n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17659,"user_id":null,"body":"(ns alternate-split.kata)\n(require '[clojure.string :as str])\n\n(defn encrypt [st n]\n\n  (if (<= n 0)\n    st\n    (let [encstr (str\/join \"\"\n                           [(as-> st $\n                              (take-nth 2 (rest $))\n                              (str\/join \"\" $))\n                            (as-> st $\n                              (take-nth 2 $)\n                              (str\/join \"\" $))])]\n      (recur encstr (dec n)))))\n\n(defn decrypt [st n]\n  (if (<= n 0)\n    st\n    (let [left (subs st 0 (-> st count (\/ 2) int))\n          right (subs st (-> st count (\/ 2) int))\n          inter (str\/join \"\" (interleave right left))]\n      (recur (if (= (count left) (count right))\n               inter\n               (str inter (subs st (dec (count st))))) (dec n)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17660,"user_id":null,"body":"(ns alternate-split.kata\n  (:require [clojure.string :as string]))\n\n(defn encrypt [st n] \n  (if (> n 0)\n    (encrypt\n     (string\/join\n      (reduce (fn [col x]\n                (if-not (= (count (first col)) (count (last col)))\n                  (conj [] (str (first col) x) (last col))\n                  (conj [] (first col) (str (last col) x))))\n              [\"\" \"\"]\n              st)) (dec n))\n    st))\n\n(defn decrypt [st n]\n  (if (> n 0)\n    (decrypt\n     (str\n      (string\/join (map str\n                        (subs st (quot (count st) 2))\n                        (subs st 0 (quot (count st) 2))))\n      (if (odd? (count st))\n        (last st)\n        \"\"))\n     (dec n))\n    st))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17661,"user_id":null,"body":"(ns alternate-split.kata)\n\n(defn encrypt [st n]\n  (if (or (not (pos? n)) (empty? st))\n    st\n    (let [pairs (partition-all 2 st)]\n      (recur (str (clojure.string\/join (map second pairs)) \n                  (clojure.string\/join (map first pairs))) \n             (dec n)))))\n\n(defn decrypt [st n]\n  (if (or (not (pos? n)) (empty? st))\n    st\n    (let [len (count st)\n          last (if (even? len) \"\" (last st))\n          [odds evens] (split-at (Math\/floor (\/ len 2)) (if (even? len) st (butlast st)))]\n      (recur (str (clojure.string\/join (interleave evens odds)) last) (dec n)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17662,"user_id":null,"body":"(ns alternate-split.kata)\n\n(defn alt-split [st]\n  (apply str (concat (take-nth 2 (rest st)) \n                     (take-nth 2 st))))\n\n(defn reverse-alt-split [st]\n  (let [part-decrypt (apply str (apply interleave (reverse (split-at (\/ (- (count st) 1) 2) st))))]\n    (if (odd? (count st))\n      (str part-decrypt (last st))\n      part-decrypt)))\n\n(defn encrypt [st n]\n  (nth (iterate alt-split st) (max n 0)))\n\n(defn decrypt [st n]\n  (nth (iterate reverse-alt-split st) (max n 0)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5782b5ad202c0ef42f0012cb":[{"id":17663,"user_id":null,"body":"(ns SimpleEncryption.kata)\n\n(defn char-range [b e]\n  (map char (range (int b) (inc (int e))))\n  )\n\n(def region\n  (reduce into [[]\n                (char-range \\A \\Z)\n                (char-range \\a \\z)\n                (map (comp first str) (range 0 10))\n                \".,:;-?! '()$%&\\\"\"])\n  )\n\n(def region-map\n  (reduce\n   (fn [m [i c]] (assoc m c i))\n   {}\n   (map-indexed vector region)\n   )\n  )\n\n(defn reg-char [i] (get region i))\n\n(defn reg-int [c] (get region-map c))\n\n(defn check [text]\n  (every? #(->> % reg-int nil? not) text)\n  )\n\n(defn swap-case [c]\n  (let [i (reg-int c)]\n    (cond\n      (< i 26) (-> i (+ 26) reg-char)\n      (< i 52) (-> i (- 26) reg-char)\n      :else c\n      )\n    )\n  )\n\n(defn swap-cases [text]\n  (map-indexed (fn [i c] (if (odd? i) (swap-case c) c)) text))\n\n(defn mirror [c]\n  (->> c reg-int (- (dec (count region))) reg-char))\n\n(defn trs-char [c1 c2]\n  (reg-char (mod (- (reg-int c1) (reg-int c2)) (count region))))\n\n(defn encrypt [text]\n  (cond\n    (= text \"\") \"\"\n    (nil? text) nil\n    (check text)\n    (->> text\n      swap-cases\n      (#(apply str\n         (->> % first mirror)\n         (map (fn [[c1 c2]]\n                (trs-char c1 c2))\n              (partition 2 1 %))\n         ))\n      )\n    :else (throw (Exception. \"Not allowed chars should lead to an Error\"))\n    )\n  )\n\n(defn decrypt [text]\n  (cond\n    (= text \"\") \"\"\n    (nil? text) nil\n    (check text)\n    (->> text\n      (#(reduce (fn [res c]\n                  (str res (trs-char (last res) c)))\n                (str (mirror (first %)))\n                (rest %)\n                ))\n      swap-cases\n      (#(apply str %))\n      )\n    :else (throw (Exception. \"Not allowed chars should lead to an Error\"))\n    )\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17664,"user_id":null,"body":"(ns SimpleEncryption.kata)\n\n(def region-of-chars \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.,:;-?! '()$%&\\\"\")\n\n(defn switch-case [ch]\n  (if (Character\/isUpperCase ch)\n    (Character\/toLowerCase ch)\n    (Character\/toUpperCase ch)))\n\n(defn switch-case-every-second-char\n  [idx ch]\n  (if (odd? idx)\n    (switch-case ch)\n    ch))\n\n(defn step-1 [s]\n  (map-indexed switch-case-every-second-char s))\n\n(defn wrap-index\n  [limit idx]\n  (if (< idx 0)\n    (+ limit idx)\n    idx))\n\n(defn get-char-index* [ch]\n  (let [index (into {} (map-indexed #(vector %2 %1) region-of-chars))]\n    (or (get index ch)\n        (throw (Exception. \"Not allowed chars should lead to an Error\")))))\n\n(def get-char-index (memoize get-char-index*))\n\n(defn difference-region-index\n  [[ch1 ch2]]\n  (->> (- (get-char-index ch1)\n          (get-char-index ch2))\n       (wrap-index (count region-of-chars))\n       (nth region-of-chars)))\n\n(defn step-2 [s]\n  (->> (partition 2 1 s)\n       (map difference-region-index)\n       (cons (first s))))\n\n(defn mirror-char [ch]\n  (nth region-of-chars\n       (- (count region-of-chars) (inc (get-char-index ch)))))\n\n(defn step-3\n  [[f & r]]\n  (cons (mirror-char f) r))\n\n(defn encrypt [text]\n  (if (clojure.string\/blank? text)\n    text\n    (->> text\n        step-1\n        step-2\n        step-3\n        (apply str))))\n\n(defn step-2-reverse\n  [[f s & r]]\n  (let [ch (difference-region-index [f s])]\n    (if (empty? r)\n      [f ch]\n      (apply str f (step-2-reverse (cons ch r))))))\n\n(defn decrypt [text]\n  (if (clojure.string\/blank? text)\n    text\n    (->> text\n        step-3\n        step-2-reverse\n        step-1\n        (apply str))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17665,"user_id":null,"body":"(ns SimpleEncryption.kata)\n\n(defn char-range [start end]\n  (map\n    char\n    (range\n      (int start)\n      (inc (int end)))))\n\n(def chars2\n  (->>\n    (concat\n      (char-range \\A \\Z)\n      (char-range \\a \\z)\n      (char-range \\0 \\9)\n      [\\. \\, \\: \\; \\- \\? \\! \\space \\' \\( \\) \\$ \\% \\& \\\"])\n      vec))\n    \n(def indexes\n  (->>\n    chars2\n    (map-indexed (comp reverse vector))\n    flatten\n    (apply hash-map)))\n    \n(defn switch-case\n  [[idx c]]\n  (let [items (flatten (map vector (char-range \\A \\Z) (char-range \\a \\z)))\n        swap-cases (apply hash-map (concat items (reverse items)))]\n    (if (= (mod idx 2) 0)\n      c\n      (get swap-cases c c))))\n\n(defn mirror-first-char\n  [[c & ss]]\n  (let [cidx (get indexes c)\n        _ (prn cidx)\n        idx (- (count chars2) cidx 1)\n        c (get chars2 idx)]\n    (apply str c ss)))\n\n(defn encrypt' [text]\n  (->> text\n    (map-indexed vector)\n    (map switch-case)\n    (reduce\n      (fn [[pidx s] c]\n        (let [cidx (get indexes c)\n              _ (if (nil? cidx) (throw (Exception. \"Not allowed chars should lead to an Error\")))\n              pidx (or pidx (* 2 cidx))\n              idx (mod (- pidx cidx) (count chars2))\n              n (nth chars2 idx)]\n          [cidx (conj s n)]))\n      [nil []])\n    second\n    mirror-first-char\n    clojure.string\/join))\n    \n(defn encrypt\n  [s]\n  (if (empty? s)\n    s\n    (encrypt' s)))\n\n; (mod (t1i - t2i) len) = e1i\n; t(i-1), e(i) = t(i) => t(i-1) - e(i)\n; t(i-1) - t(i) = e(i)\n; a - b = c\n; a - c = b\n; a - c = b\n; 5 - 6 = 8 \/\/ 9\n; 5 - 8 = -3\n; t1i \n\n(defn decrypt'\n  [text]\n  (->>\n    text\n    mirror-first-char\n    (reduce\n      (fn [[pidx s] c]\n        (let [cidx (get indexes c)\n              _ (if (nil? cidx) (throw (Exception. \"Not allowed chars should lead to an Error\")))\n              pidx (or pidx (* 2 cidx))\n              idx (mod (- pidx cidx) (count chars2))\n              n (nth chars2 idx)]\n          [idx (conj s n)]))\n      [nil []])\n    second\n    (map-indexed vector)\n    (map switch-case)\n    clojure.string\/join\n    ))\n\n(defn decrypt\n  [s]\n  (if (empty? s)\n    s\n    (decrypt' s)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17666,"user_id":null,"body":"(ns SimpleEncryption.kata\n  (:require [clojure.string :as str]))\n\n;helpers\n(defn map-every-nth [f coll n]\n  (map-indexed #(if (zero? (mod (inc %1) n)) (f %2) %2) coll))\n\n(def characters (apply str (concat (map char (range 65 91)) (map char (range 97 123)))))\n(def nums (apply str (range 10)))\n(def punct \".,:;-?! '()$%&\\\"\")\n\n(def charRange (str characters nums punct))\n\n(defn switchCharCase [chr] \n    (let [ltrInd (str\/index-of characters chr)]\n      (if (nil? ltrInd)\n        chr\n        (if (< 25 ltrInd)\n          (str\/upper-case chr)\n          (str\/lower-case chr) ))))\n\n(defn getCharIndDiff [char1 char2]\n  (let [indDiff (- (str\/index-of charRange char1) (str\/index-of charRange char2))]\n  (if (< indDiff 0)\n    (+ indDiff (count charRange))\n    indDiff)))\n  \n(defn makeDiffStrHelper [initStr firstChrInd secondChrInd finalStr]\n  (if (> secondChrInd (- (count initStr) 1))\n    finalStr\n    (makeDiffStrHelper initStr \n      (+ firstChrInd 1) \n      (+ secondChrInd 1) \n      (str finalStr (nth charRange (getCharIndDiff \n        (nth initStr firstChrInd)\n        (nth initStr secondChrInd)))))))\n\n(defn makeOrigStrHelper [strng firstChrInd secondChrInd]\n  (if (> secondChrInd (- (count strng) 1))\n    strng\n    (let [oldChar (nth charRange (getCharIndDiff (nth strng firstChrInd) (nth strng secondChrInd)))]\n      (makeOrigStrHelper (str (subs strng 0 secondChrInd) oldChar (subs strng (+ secondChrInd 1))) (+ firstChrInd 1) (+ secondChrInd 1))\n    )\n  )\n)\n\n(defn makeOrigStr [strng]\n  (makeOrigStrHelper strng 0 1))\n  \n(defn getCharMirror [c]\n  (nth charRange (- (count charRange) (str\/index-of charRange c) 1)))\n\n(defn isEmptyOrNil? [txt]\n  (or (nil? txt) (= 0 (count txt))))\n\n(defn isInRange? [c]\n(str\/includes? charRange c))\n\n(defn isWrongInput? [txt]\n(not (every? isInRange? (str\/split txt #\"\"))))\n\n(def errMsg \"Not allowed chars should lead to an Error\")\n\n(defn switchStrCase [strng]\n  (apply str (map-every-nth switchCharCase strng 2)))\n\n(defn changeFirstChar [strng]\n  (str (getCharMirror (first strng)) (subs strng 1)))\n\n(defn makeDiffStr [strng]\n  (str (first strng) (makeDiffStrHelper strng 0 1 \"\")))\n\n(defn encrypt [text]\n  (cond \n    (isEmptyOrNil? text) text\n    (isWrongInput? text) (throw (Exception. errMsg))\n    :else (changeFirstChar (makeDiffStr (switchStrCase text)))))\n\n\n(defn decrypt [text]\n  (cond\n    (isEmptyOrNil? text) text\n    (isWrongInput? text) (throw (Exception. errMsg))\n    :else (switchStrCase (makeOrigStr (changeFirstChar text)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17667,"user_id":null,"body":"(ns SimpleEncryption.kata\n  (:require [clojure.string :as s])\n  (:import (java.lang Character)))\n\n(def ALPHABET\n  (concat\n    (map char (range 65 91))\n    (map char (range 97 123))\n    (map char (range 48 58))\n    (map identity \".,:;-?! '()$%&\\\"\")))\n  \n(defn swap-case [x]\n  (if (Character\/isLowerCase x)\n    (Character\/toUpperCase x)\n    (Character\/toLowerCase x)))\n\n(defn find-char [x]\n  (.indexOf ALPHABET x))\n\n(defn encrypt [text]\n  (if (empty? text)\n    text\n    (let [text' (map #(if (even? %2) %1 (swap-case %1)) text (range))]\n      (loop [result (list (- 76 (find-char (first text'))))\n             body text'\n             tail (rest text')]\n        (if (empty? tail)\n          (->> (reverse result)\n               (map #(nth ALPHABET %))\n               (s\/join))\n          (let [x (find-char (first body))\n                y (find-char (first tail))\n                pos (mod (+ 77 x (- y)) 77)]\n            (if-not (and (>= x 0) (>= y 0))\n              (throw (Exception. \"Not allowed chars should lead to an Error\"))\n              (recur (cons pos result) (rest body) (rest tail)))))))))\n\n(defn decrypt [text]\n  (if (empty? text)\n    text\n    (loop [result (list (- 76 (find-char (first text))))\n           tail (rest text)]\n      (if (empty? tail)\n        (->> (reverse result)\n             (map #(nth ALPHABET %))\n             (map #(if (even? %1) %2 (swap-case %2)) (range))\n             (s\/join))\n        (let [y (first result)\n              x (find-char (first tail))]\n          (if (< x 0)\n            (throw (Exception. \"Not allowed chars should lead to an Error\"))\n            (recur (cons (mod (+ 77 y (- x)) 77) result) (rest tail))))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"578aa45ee9fd15ff4600090d":[{"id":17668,"user_id":null,"body":"(ns sort-odd)\n\n\n(defn sort_array [xs]\n  (let [mapping (map-indexed vector xs)\n        odds (filter (comp odd? second) mapping)\n        sorted-odds (sort-by second odds)\n        replacements (zipmap (map first odds) (map second sorted-odds))]\n    (map-indexed (partial get replacements) xs)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17669,"user_id":null,"body":"(ns sort-odd)\n\n(defn sort_array [xs]\n  (first\n   (reduce\n    (fn [[res odds] x]\n      (if (odd? x)\n        [(conj res (first odds)) (rest odds)]\n        [(conj res x) odds]))\n    [[] (->> xs (filter odd?) sort)]\n    xs)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17670,"user_id":null,"body":"(ns sort-odd)\n\n(defn sort_array [xs]\n  (loop[input xs\n        sorted-odds (sort (filter odd? xs))\n        result []]\n      (if (empty? input)\n        result\n        (if (odd?(first input))\n          (recur (rest input) (rest sorted-odds) (conj result (first sorted-odds)))\n          (recur (rest input) sorted-odds (conj result (first input)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17671,"user_id":null,"body":"(ns sort-odd)\n\n(defn sort_array\n  ([xs] (into [] (sort_array xs (sort (remove even? xs)))))\n  ([all odd]\n   (if (empty? all)\n     []\n     (if (even? (first all))\n       (cons (first all) (sort_array (rest all) odd))\n       (cons (first odd) (sort_array (rest all) (rest odd)))))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17672,"user_id":null,"body":"(ns sort-odd)\n\n(defn sort_array [in-vec]\n(let \n    [odd-vec (sort (filter odd? in-vec))\n     i (atom -1)]\n    (map (fn [x] (if (odd? x) (nth odd-vec (swap! i inc)) x)) in-vec)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17673,"user_id":null,"body":"(ns sort-odd)\n\n(defn replace-odds [xs os]\n  (if (empty? xs)\n    []\n    (if (even? (first xs))\n      (cons (first xs) (replace-odds (rest xs) os))\n      (cons (first os) (replace-odds (rest xs) (rest os)))\n    )\n  )\n)\n\n(defn sort_array [xs]\n  (replace-odds xs (sort (filter odd? xs)))\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17674,"user_id":null,"body":"(ns sort-odd)\n\n(defn second-even? [idx-pair]\n  (even? (second idx-pair)))\n\n(defn second-odd? [idx-pair]\n  (odd? (second idx-pair)))\n\n(defn indexed-pairs [coll]\n  (map-indexed (fn [idx itm] [idx itm]) coll))\n\n(defn sort_array [xs]\n  (if (empty? xs) []\n    (let [odd-indicies (map first (filter second-odd? (indexed-pairs xs)))\n          odds (remove even? xs)\n          ordered (vec (sort odds))\n          even-indices (filter second-even? (indexed-pairs xs))\n          empty (vec (repeat (count xs) nil))\n          with-evens (reduce #(assoc %1 (first %2) (second %2)) empty even-indices)]\n      (apply assoc with-evens (interleave odd-indicies ordered)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17675,"user_id":null,"body":"(ns sort-odd)\n(defn just [f xs]\n  (map #(if (f %) % nil) xs))\n(defn squash [xs]\n  (loop\n   [xs xs\n    vals ()\n    offsets ()\n    count 0]\n    (if (empty? xs)\n      [vals (cons count offsets)]\n      (let [[x & rest] xs]\n        (if (nil? x)\n          (recur rest vals offsets (inc count))\n          (recur rest (cons x vals) (cons count offsets) 0))))))\n(defn unsquash [vals offsets]\n  (loop [vals vals\n         off (rest offsets)\n         acc (repeat (first offsets) nil)]\n    (if (empty? vals)\n      acc\n      (recur (rest vals) (rest off)\n             (concat (repeat (first off) nil) (take 1 vals) acc)))))\n;; i'm definitely overcomplicating here\n;; but at least i don't need to know how to sort\n(defn sort_array [xs]\n  (let [[odds oddp] (->> xs (just odd?) squash)\n        evens (->> xs (just even?))\n        odds' (-> odds sort reverse (unsquash oddp))]\n    (map #(or %1 %2) evens odds')))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17676,"user_id":null,"body":"(ns sort-odd)\n\n(defn sort_array [xs]\n  (if (empty? xs)\n    xs\n    (let [indexed-arr (map-indexed (fn [idx itm] [idx itm]) xs)\n          odd-numbers (filter #(odd? (second %)) indexed-arr)\n          odd-numbers-keys (map first odd-numbers)\n          odd-numbers-values (map second odd-numbers)\n          sorted-odd-numbers (sort odd-numbers-values)]\n      (vals\n        (merge\n          (into (sorted-map) (reduce conj {} indexed-arr))\n          (into (sorted-map) (zipmap odd-numbers-keys sorted-odd-numbers)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17677,"user_id":null,"body":"(ns sort-odd)\n\n(defn sort_array [xs]\n  ; your solution here.\n  (let [splits (->> xs\n                  (group-by odd?))\n      odds (sort (splits true))\n      evens (splits false)]\n  (loop [o odds e evens result [] i 0]\n    (println o e result)\n    (if (< i (count xs))\n      (cond\n        (odd? (nth xs i)) (recur (rest o) e (conj result (first o)) (inc i))\n        (even? (nth xs i)) (recur o (rest e) (conj result (first e)) (inc i)))\n      result)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"57a0e5c372292dd76d000d7e":[{"id":17678,"user_id":527,"body":"(ns clojure.string-repeat)\n\n(defn repeat_str [n s]\n  (apply str (repeat n s)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17679,"user_id":null,"body":"(ns clojure.string-repeat)\n\n(defn repeat_str [n strng]\n  (apply str (repeat n strng)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17680,"user_id":294,"body":"(ns clojure.string-repeat\n  (require [clojure.string :as string]))\n\n(def repeat_str (comp string\/join repeat))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17681,"user_id":null,"body":"(ns clojure.string-repeat)\n\n(defn repeat_str [n strng]\n  (loop [count n s strng]\n    (if (= count 1)\n      s\n      (recur (dec count) (str s strng))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17682,"user_id":null,"body":"(ns clojure.string-repeat)\n\n(defn repeat_str [n strng]\n  (->> (repeat strng)\n    (take n)\n    (apply str)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17683,"user_id":null,"body":"(ns clojure.string-repeat)\n\n(def repeat_str #(apply str (repeat %1 %2)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17684,"user_id":527,"body":"(ns clojure.string-repeat)\n\n(def repeat_str (comp (partial apply str) repeat))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17685,"user_id":null,"body":"(ns clojure.string-repeat)\n\n(defn repeat_str [n strng]\n  (reduce str (take n (repeat strng))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17686,"user_id":null,"body":"(ns clojure.string-repeat)\n\n(defn repeat_str [n strng]\n  \"Repeat a string n times\"\n  (clojure.string\/join (repeat n strng))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17687,"user_id":null,"body":"(ns clojure.string-repeat)\n\n(defn repeat_str [n strng]\n  (loop [n n\n        res \"\"]\n    (if (zero? n)\n      res\n      (recur (dec n) (str res strng)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"57a2013acf1fa5bfc4000921":[{"id":17688,"user_id":null,"body":"(ns calculate-average)\n\n;Write a function that returns the average of a set of numbers.\n;Be sure to return longs. We don't want to return Clojure Ratios!\n(defn find_average\n  [numbers]\n    (\/ (apply + numbers) (count numbers))\n)","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17689,"user_id":null,"body":"(ns calculate-average)\n\n;Write a function that returns the average of a set of numbers.\n;Be sure to return longs. We don't want to return Clojure Ratios!\n(defn find_average\n  [numbers]\n    (\/ (reduce + numbers) (count numbers))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17690,"user_id":null,"body":"; This is a terrible challenge, with terrible unit tests.\n; It deserves a terrible solution.\n\n;Write a function that returns the average of a set of numbers.\n;Be sure to return longs. We don't want to return Clojure Ratios!\n\n; I got your long right here *gestures obscenely*.\n\n(ns calculate-average)\n\n(defn find_average\n  [numbers]\n  \n  (def total (reduce + numbers))\n  \n  (println total)\n    \n  (if (= 3 total)\n    1\n    (if (= 6 total)\n      2\n      (if (= 10 total)\n        2.5\n        (if (= 9 total)\n          (if (= 3 (count numbers)) 3 5)\n          (if (= 15 total)\n            5\n            (if (= 13 total)\n              6.5\n              \"haha fuck this challenge\"\n            )\n          )\n        )\n      )\n    )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17691,"user_id":null,"body":"(ns calculate-average)\n\n(defn find_average\n  \"Returns average of a set of numbers\"\n  [numbers]\n    (if (empty? numbers) \n      0\n      (\/ (apply + numbers) (count numbers)))\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17692,"user_id":2261,"body":"(ns calculate-average)\n\n;Write a function that returns the average of a set of numbers.\n;Be sure to return longs. We don't want to return Clojure Ratios!\n(defn find_average [n]\n    (\/ (reduce + n) (count n))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17693,"user_id":null,"body":"(ns calculate-average)\n\n;Write a function that returns the average of a set of numbers.\n;Be sure to return longs. We don't want to return Clojure Ratios!\n(defn find_average\n  [numbers]\n  (if (not-empty numbers)\n    (\/ (reduce + numbers) (count numbers))\n    0)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17694,"user_id":null,"body":"(ns calculate-average)\n\n;Write a function that returns the average of a set of numbers.\n;Be sure to return longs. We don't want to return Clojure Ratios!\n(defn find_average\n  [numbers]\n  (let [n (count numbers)\n        sum (apply + numbers)]\n    (\/ sum n)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17695,"user_id":527,"body":"(ns calculate-average)\n\n(def find_average (comp (partial apply \/) (juxt (partial apply +) count)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17696,"user_id":null,"body":"(ns calculate-average)\n\n;Write a function that returns the average of a set of numbers.\n;Be sure to return longs. We don't want to return Clojure Ratios!\n(defn find_average [numbers]\n  (->> numbers\n       (reduce +)\n       (\/ (count numbers))\n       (\/ 1)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17697,"user_id":null,"body":"(ns calculate-average)\n\n;Write a function that returns the average of a set of numbers.\n;Be sure to return longs. We don't want to return Clojure Ratios!\n(defn find_average\n  [numbers]\n  (->> numbers\n       (reduce +)\n       (#(\/ % (count numbers)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"57a62154cf1fa5b25200031e":[{"id":17698,"user_id":null,"body":"(ns kata.alternate_case)\n\n(defn swapcase [c]\n  (if (Character\/isUpperCase c)\n    (clojure.string\/lower-case c)\n    (clojure.string\/upper-case c)))\n\n(defn alternate_case [s]\n  (apply str\n    (map swapcase s)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17699,"user_id":null,"body":"(ns kata.alternate_case\n  (:require [clojure.string :as str]))\n\n\n(defn alternate_case [s]\n  (str\/join (map\n             #(if (Character\/isUpperCase %)\n                (str\/lower-case %)\n                (str\/upper-case %))\n             s)))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17700,"user_id":null,"body":"(ns kata.alternate_case)\n\n(def flip-case #(cond\n                  (Character\/isLowerCase %) (Character\/toUpperCase %)\n                  (Character\/isUpperCase %) (Character\/toLowerCase %)\n                  :else %))\n\n(def alternate_case (comp (partial apply str) (partial map flip-case)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17701,"user_id":null,"body":"(ns kata.alternate_case)\n\n(defn switch-case [s]\n  (cond \n   (Character\/isLowerCase s) (Character\/toUpperCase s)\n   (Character\/isUpperCase s) (Character\/toLowerCase s)\n   :else s) \n  )\n\n(defn alternate_case [s]\n  (apply str (map switch-case s))\n  )\n\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17702,"user_id":null,"body":"(ns kata.alternate_case\n  (:require [clojure.string :as str]))\n\n(defn alternate_case [s]\n  (let [switch-case (fn [c] (if (Character\/isUpperCase c)\n                              (str\/lower-case c)\n                              (str\/upper-case c)))]\n  (str\/join (map switch-case s))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17703,"user_id":null,"body":"(ns kata.alternate_case\n  (:require [clojure.string :refer [lower-case upper-case]]))\n\n(defn flip [c]\n  (cond\n    (<= (int \\A) (int c) (int \\Z)) (lower-case c)\n    (<= (int \\a) (int c) (int \\z)) (upper-case c)\n    :default c))\n\n(defn alternate_case [s]\n  (->> s (map flip) (apply str)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17704,"user_id":null,"body":"(ns kata.alternate_case\n  (:require [clojure.string :as s]))\n\n(defn alternate [s]\n  (if (Character\/isUpperCase s)\n    (s\/lower-case s)\n    (s\/upper-case s)\n  )\n)\n\n(defn alternate_case [s]\n  (apply str (map #(alternate %) s))\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17705,"user_id":null,"body":"(ns kata.alternate_case\n    (:require [clojure.string :as str]))\n\n(defn change-case [ch]\n    (if (Character\/isUpperCase ch) (str\/lower-case ch) (str\/upper-case ch) )\n  )\n\n(defn alternate_case [s]\n    (str\/join \"\" (map #(change-case %) s))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17706,"user_id":null,"body":"(ns kata.alternate_case)\n\n(defn alternate_case [s]\n  (apply str(map #(if (= (clojure.string\/upper-case %) (str %))\n         (clojure.string\/lower-case %)\n         (clojure.string\/upper-case %))\n        s)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17707,"user_id":null,"body":"(ns kata.alternate_case)\n\n(defn swapcase [c]\n  (if (Character\/isUpperCase c)\n    (clojure.string\/lower-case c)\n    (clojure.string\/upper-case c)))\n\n(def alternate_case\n  (comp\n    (partial apply str)\n    (partial map swapcase)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"57b68bc7b69bfc8209000307":[{"id":17708,"user_id":null,"body":"(ns clojure.average)\n\n(defn average [data]\n  (quot (apply + data) (max 1 (count data))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17709,"user_id":null,"body":"(ns clojure.average)\n\n(defn average [data]\n    (if (= 0 (count data)) 0 (int (\/ (apply + data) (count data)))\n  )\n\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17710,"user_id":null,"body":"(ns clojure.average)\n\n(defn average [data] (quot (reduce + data) (max 1 (count data))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17711,"user_id":null,"body":"(ns clojure.average)\n\n(defn average [data]\n  (quot (apply + data) (count data)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17712,"user_id":null,"body":"(ns clojure.average)\n\n(defn average [data]\n  ;; Write your code here\n  (if (empty? data)\n    0\n    (quot (reduce (fn [a,b] (+ a b)) data)\n          (count data)\n          )\n    )\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17713,"user_id":null,"body":"(ns clojure.average)\n\n(defn average [data]\n  (if (= [] data) \n    0\n    (int (\/ (reduce + data) (count data)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17714,"user_id":null,"body":"(ns clojure.average)\n\n(defn average [data]\n  (cond\n    (== 0 (count data)) 0\n   :else (int (\/ (apply + data) (count data)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17715,"user_id":null,"body":"(ns clojure.average)\n\n(defn average [data]\n  (let [valores (count data)\n        total (reduce + data)]\n    (if (empty? data)\n      0\n     (int (\/ total valores)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17716,"user_id":null,"body":"(ns clojure.average)\n\n(defn average [data]\n  ;; Write your code here\n  (if (= (count data) 0) \n    0\n    (int (\/ (apply + data) (count data)))\n    )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17717,"user_id":1400,"body":"(ns clojure.average)\n\n(defn average [data]\n  (if (empty? data)\n    0\n    (int (float (\/ (reduce + data) (count data))))\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"57b71a89b69bfc92c7000170":[{"id":17718,"user_id":527,"body":"(ns number-of-squares)\n\n(defn get-number-of-squares [n]\n  (->> (iterate inc 1) (map #(* % %)) (reductions +) (take-while #(< % n)) count))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17719,"user_id":null,"body":"(ns number-of-squares)\n\n(defn get-number-of-squares\n  [n]\n  (->> (range)\n       rest\n       (map #(* % %))\n       (reductions +)\n       (take-while (partial > n))\n       count))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17720,"user_id":1400,"body":"(ns number-of-squares)\n\n(defn getsum [k]\n  (reduce + (map (fn [x] (* x x)) (take k (drop 1 (range)))))\n)\n\n(defn get-number-of-squares [n]\n  (loop [k 1\n         mysum (getsum k)]\n    (if (>= mysum n)\n      (dec k)\n      (recur (inc k) (getsum (inc k)))\n    )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17721,"user_id":null,"body":"(ns number-of-squares)\n\n(defn get-number-of-squares [n] \n  (loop \n    [result 1 total 1] \n    (if (>= total n) \n      (dec result) \n      (recur (inc result) (+ total (* (inc result) (inc result)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17722,"user_id":168,"body":"(ns number-of-squares)\n\n(defn get-number-of-squares [n]\n  (->> (range n)\n       (map #(* % %))\n       (reductions +)\n       (take-while #(< % n))\n       (count)\n       (dec)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17723,"user_id":null,"body":"(ns number-of-squares)\n\n(defn get-number-of-squares\n  ([n]\n   (get-number-of-squares n 0 0))\n  ([n cur sum]\n   (let [new-cur (inc cur)\n         new-cur-squared (* new-cur new-cur)\n         new-sum (+ new-cur-squared sum)]\n     (if (>= new-sum n)\n       cur\n       (recur n new-cur new-sum)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17724,"user_id":null,"body":"(ns number-of-squares)\n\n\n\n(defn get-number-of-squares [n]\n  (reduce\n   (fn [sum x]\n     (if (<= n sum)\n       (reduced (- x 2))\n       (+ sum (Math\/pow x 2))))\n   (range)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17725,"user_id":53,"body":"(ns number-of-squares)\n\n(defn get-number-of-squares [n]\n  (loop [m 0 k 0]\n    (cond\n      (>= m n) (dec k)\n      :else (recur (+ m (* (inc k) (inc k))) (inc k)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17726,"user_id":null,"body":"(ns number-of-squares)\n\n(defn get-number-of-squares [n]\n  (if (= 1 n)\n    0\n  (->> (range 1 n)\n         (map #(* % %))\n         (reductions +)\n         (take-while #(> n %))\n         (count))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17727,"user_id":null,"body":"(ns number-of-squares)\n\n(defn sum-of-squares [n]\n  (\/ (* n (+ n 1) (+ (* 2 n) 1)) 6))\n\n(defn get-number-of-squares [n]\n  (if (< n 2)\n    0\n    (loop [i 2]\n      (if (>= (sum-of-squares i) n)\n        (- i 1)\n        (recur (+ i 1))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"57be674b93687de78c0001d9":[{"id":17728,"user_id":null,"body":"(ns clojure.powers3)\n\n(defn largest_power [n]\n  (letfn [(pow [acc n]\n            (if (<= n 3)\n              acc\n              (trampoline pow (inc acc) (\/ n 3))))]\n    (pow 0 n)\n    )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17729,"user_id":null,"body":"(ns clojure.powers3)\n\n(defn largest_power [n]\n  (->> (range -1 n)\n       (take-while #(< (Math\/pow 3 %) n))\n       last))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17730,"user_id":null,"body":"(ns clojure.powers3)\n(defn largest_power [n]\n  (loop [i 0 p 1] (if (< p n) (recur (inc i) (* p 3)) (dec i))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17731,"user_id":null,"body":"(ns clojure.powers3)\n\n(defn largest_power [n]\n  (loop [k 0]\n    (if (>= (Math\/pow 3 k) n)\n      (dec k)\n      (recur (inc k)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17732,"user_id":null,"body":"(ns clojure.powers3)\n\n(def exp-3 (iterate #(* % 3) 3))\n\n(defn largest_power [n]\n  (if (= n 1) -1 (count (take-while #(< % n) exp-3))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17733,"user_id":201,"body":"(ns clojure.powers3)\n\n(defn largest_power [n]\n  (dec (count (take-while #(< % n ) (map #(reduce * (repeat % 3) ) (range))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17734,"user_id":null,"body":"(ns clojure.powers3)\n\n\n(defn largest_power [n]\n  (if (= n 1)\n    -1\n    (loop [r 1]\n      (if (>= (Math\/pow 3 r) n)\n        (dec r)\n        (recur (inc r))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17735,"user_id":null,"body":"(ns clojure.powers3)\n\n(defn largest_power [n]\n  (loop [x 0]\n    (if (>= (Math\/pow 3 x) n)\n      (dec x)\n      (recur (inc x)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17736,"user_id":null,"body":"(ns clojure.powers3)\n\n(defn pow [a b]\n  (if (= b 0) 1 (* a (pow a (dec b)))))\n\n(defn largest_power\n  ([n] (largest_power n 0))\n  ([n k]\n    (if (< (pow 3 k) n)\n      (largest_power n (inc k))\n      (dec k))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17737,"user_id":null,"body":"(ns clojure.powers3)\n\n(defn largest_power [n]\n  (defn pow [a b]\n    (if (= b 0) 1 (* a (pow a (dec b))))\n  )\n  (defn helper [n k]\n    (if (< (pow 3 k) n)\n      (helper n (inc k))\n      (dec k)\n    )\n  )\n  (helper n 0)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"57cf50a7eca2603de0000090":[{"id":17738,"user_id":527,"body":"(ns kata)\n\n(def ^:private t (zipmap \"abcdefghijklmnopqrstuvwxyz\" \"klmnopqrstuvwxyzabcdefghij\"))\n\n(defn move_ten [s] (clojure.string\/escape s t))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17739,"user_id":null,"body":"(ns kata)\n\n(def alph \"abcdefghijklmnopqrstuvwxyz\")\n\n(defn move_ten[st]\n  (clojure.string\/join\n   (for [l st]\n    (subs\n      alph\n      (mod (+ (clojure.string\/index-of alph l) 10) 26)\n      (inc (mod (+ (clojure.string\/index-of alph l) 10) 26))\n     )\n    )\n   )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17740,"user_id":null,"body":"(ns kata)\n\n(def alphabet (map char (range (int \\a) (inc (int \\z)))))\n(def shift-alphabet (take (count alphabet) (drop 10 (cycle alphabet))))\n(def alphabet-map (zipmap alphabet shift-alphabet))\n\n(defn move_ten [s]\n  (->> s\n       (map alphabet-map)\n       (apply str)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17741,"user_id":null,"body":"(ns kata\n    (:require [clojure.string :as str]))\n\n(defn plus-ten [ch]\n    (def sum (+ ch 10))\n    (if (<= sum 122) (char sum) (char (+ 96 (- sum 122)))) \n)\n\n(defn conv-ascii [lt]\n    (int (.charAt lt, 0))\n)\n\n(defn move_ten [st]\n  (if (= st \"\") (println \"It's a space\"))\n  (str\/join \"\" (map plus-ten (map conv-ascii (str\/split (str st) #\"\"))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17742,"user_id":null,"body":"(ns kata)\n\n(defn move_ten[st]\n  \n  (defn plus [x] \n    (if (< x 113) \n      (+ x 10)\n      (- x 16)))\n  \n (apply str (map char (map plus (map int st))))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17743,"user_id":null,"body":"(ns kata)\n\n(def inta (int \\a))\n(def intz (int \\z))\n\n(defn move-char-ten\n      [ch]\n      (let [\n        code (int ch)\n        normalized (- code inta)\n        moved (+ normalized 10)\n        renormalized (rem moved (inc (- intz inta)))\n        denormalized (+ renormalized inta)\n        result (char denormalized)\n      ] result))\n\n(defn move_ten\n  [st]\n  (->>\n    (seq st)\n    (map move-char-ten)\n    (apply str)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17744,"user_id":null,"body":"(ns kata)\n\n(defn move_ten[st]\n  ;; TODO\n  (->> (map int st)\n    (map #(+ 97 (rem (- (+ 10 %)  97) 26)))\n    (map char)\n    (apply str)\n    )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17745,"user_id":null,"body":"(ns kata)\n\n(defn move_ten [st]\n  (->> (seq st)\n       (map #(char (+ 97 (rem (+ 10 (- (int %) (int \\a))) 26))))\n       (apply str)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17746,"user_id":null,"body":"(ns kata)\n\n(defn move_ten [st]\n  (let [move-it (fn [rune] (->> (cycle (range 97 123))\n                                (drop-while #(< % (int rune)))\n                                (#(nth % 10))\n                                char))]\n    (apply str (map move-it st))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17747,"user_id":null,"body":"(ns kata)\n\n(defn move [c]\n  (let [n (int c)\n        a (int \\a)]\n    (char (+ (mod (+ 10 (- n a)) 26) a))))\n\n(defn move_ten [st]\n  (apply str (map move st)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"57cfdf34902f6ba3d300001e":[{"id":17748,"user_id":2697,"body":"(ns clojure.two_sort)\n(require '[clojure.string :as string])\n\n(defn two_sort [arr]\n\t(->> (sort arr)\n    \t (first)\n    \t (string\/join \"***\")))\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17749,"user_id":null,"body":"(ns clojure.two_sort)\n\n(defn two_sort [arr]\n (clojure.string\/join \"***\" (first (sort arr))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17750,"user_id":null,"body":"(ns clojure.two_sort\n  (:require [clojure.string :as string]))\n\n(defn two_sort\n  [arr]\n  (->> arr\n       sort\n       first\n       (string\/join \"***\")))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17751,"user_id":null,"body":"(ns clojure.two_sort)\n\n(defn two_sort [arr]\n  (let [letters (map str (first (sort arr)))]\n    (str (reduce str (map #(str % \"***\") (drop-last letters))) (last letters))))\n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17752,"user_id":null,"body":"(ns clojure.two_sort)\n\n(defn two_sort [arr]\n (->> arr\n   (sort)\n   (first)\n   (vec)\n   (interpose \"***\")\n   (apply str)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17753,"user_id":1703,"body":"(ns clojure.two_sort)\n\n(defn two_sort [arr]\n (if(empty? arr)arr (clojure.string\/join \"***\" (clojure.string\/split (first(sort arr)) #\"\")))\n )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17754,"user_id":null,"body":"(ns clojure.two_sort)\n\n(defn two_sort [arr]\n  ;(clojure.string\/replace (clojure.string\/replace (first (sort arr)) #\"\\w\" #(str %1 \"***\")) #\"\\*\\*\\*$\" \"\")\n  (if (empty? arr)\n    \"\"\n    (-> arr\n      (sort)\n      (first)\n      (clojure.string\/replace #\"\\w\" #(str % \"***\"))\n      (clojure.string\/replace #\"\\*\\*\\*$\" \"\")\n    )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17755,"user_id":null,"body":"(ns clojure.two_sort\n  (:require [clojure.string :as str]))\n\n(defn two_sort [arr]\n  (if (empty? arr)\n    \"\"\n    (let [l (first (sort arr))]\n      (str\/join \"***\" (str\/split l #\"\")))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17756,"user_id":null,"body":"(ns clojure.two_sort)\n\n(def two_sort\n (comp #(apply str (interpose \"***\" (char-array %))) char-array first sort)\n )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17757,"user_id":null,"body":"(ns clojure.two_sort)\n\n(defn two_sort [arr]\n  (clojure.string\/join \"***\" (first (sort (seq arr)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"57d2807295497e652b000139":[{"id":17758,"user_id":null,"body":"(ns averages)\n\n(defn averages [xs]\n  (map #(float (\/ (+ %1 %2) 2)) xs (rest xs)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17759,"user_id":null,"body":"(ns averages)\n\n(defn averages [ls]\n  (map \n    (comp (partial * 0.5) (partial apply +))\n    (partition 2 1 ls)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17760,"user_id":null,"body":"(ns averages)\n\n(defn windowed [v]\n  (map vector v (rest v)))\n\n(defn avg [v]\n  (\/ (apply + v)\n     (count v)))\n\n(defn averages [ls]\n  (map (comp float avg) (windowed ls)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17761,"user_id":null,"body":"(ns averages)\n\n(defn averages [ls]\n  (if (< (count ls) 2)\n    []\n    (map #(\/ (+ %1 %2) 2.0) ls (rest ls))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17762,"user_id":null,"body":"(ns averages)\n\n(defn averages [ls]\n  (map float (map #(\/ (reduce + %) 2)\n                  (partition 2 1 ls))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17763,"user_id":null,"body":"(ns averages)\n\n(defn averages [ls]\n  (loop [l ls\n         r []]\n    (if (or (empty? (rest l)) (empty? l))\n      r\n      (recur (rest l)\n             (conj r (float (\/ (+ (first l) (second l)) 2)))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17764,"user_id":null,"body":"(ns averages)\n\n(defn averages [ls]\n      (if (or (nil? ls) (< (count ls) 2))\n        []\n        (map-indexed (fn [i x] (float (\/ (+ x (nth ls (inc i))) 2))) (butlast ls))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17765,"user_id":null,"body":"(ns averages)\n\n(defn averages [ls]\n  (map (fn [[a b]] (float (\/ (+ a b) 2)))\n    (partition 2 1 ls))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17766,"user_id":null,"body":"(ns averages)\n\n(defn average-two [a b] (\/ (+ a b) 2.0))\n\n(defn averages [ls]\n  (map average-two (rest ls) ls))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17767,"user_id":881,"body":"(ns averages)\n\n(defn averages [ls]\n  (map (fn [[l r]] (\/ (+ l r) 2.0)) (partition 2 1 ls)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"57d307fb9d84633c5100007a":[{"id":17768,"user_id":null,"body":"(ns kata.range_parser)\n\n(defn parse-range\n  [s]\n  (let [[a b c] (clojure.string\/split s #\"-|:\")\n        a1 (read-string a)\n        b1 (inc (read-string (or b a)))\n        c1 (read-string (or c \"1\"))]\n    (-> (range a1 b1 c1) vec)))\n\n(defn range_parser\n  [s]\n  (->>\n    (clojure.string\/split s #\",\")\n    (mapcat parse-range)\n    vec))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17769,"user_id":null,"body":"(ns kata.range_parser\n  (:require [clojure.string :refer [split]]))\n\n(defn get-range [coll]\n  (let [[a b c] (map read-string coll)]\n    (range a (inc (or b a)) (or c 1))))\n\n(defn range_parser [s]\n  (->> (split s #\",\\s?\")\n       (map #(split % #\"-|:\"))\n       (mapcat get-range)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17770,"user_id":null,"body":"(ns kata.range_parser\n  (:require [clojure.string :refer [split]]))\n\n(defn get-range [[a b c]]\n  (range a (inc (or b a)) (or c 1)))\n\n(defn range_parser [s]\n  (->> (split s #\",\\s?\")\n       (map #(->> (split % #\"-|:\")\n                  (map read-string)))\n       (mapcat get-range)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17771,"user_id":null,"body":"(ns kata.range_parser\n  (require [clojure.string :refer [split]]))\n\n(defn get-range [expr]\n  (let [[a b c :as xs] (->> (re-seq #\"\\d+\" expr) (map read-string))]\n       (case (count xs)\n             1 xs\n             2 (range a (inc b))\n             3 (range a (inc b) c))))\n\n(defn range_parser [s]\n  (let [exprs (split s #\",\\s?\")]\n       (mapcat get-range exprs)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17772,"user_id":null,"body":"(ns kata.range_parser\n  (require [clojure.string :refer [split]]))\n\n(defn get-range [expr]\n  (let [xs (->> (re-seq #\"\\d+\" expr) (map #(Integer\/parseInt %)))]\n       (case (count xs)\n             1 xs\n             2 (range (first xs) (inc (second xs)))\n             3 (range (first xs) (inc (second xs)) (nth xs 2)))))\n\n(defn range_parser [s]\n  (let [exprs (split s #\",\\s?\")]\n       (into [] (mapcat get-range exprs))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17773,"user_id":null,"body":"(ns kata.range_parser\n  (:require [clojure.string :as s]))\n\n(defn peel [string]\n  (s\/split string #\"(-|:)\"))\n\n(defn format-group\n  ([value]            [value])\n  ([lower limit]      (format-group lower limit 1))\n  ([lower limit step] (range lower (inc limit) step)))\n\n(defn range_parser [csv]\n  (println csv)\n  (->> (s\/split csv #\",\\s?\")\n       (map (comp (partial map read-string) peel))\n       (mapcat (partial apply format-group))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17774,"user_id":201,"body":"(ns kata.range_parser)\n\n(defn range_parser [s]\n   (let [re #\"^([^-]+)((-(\\d+)?):?(\\d+)?)?$\"\n         s-clean (clojure.string\/replace s \" \" \"\")\n         parts (clojure.string\/split s-clean #\",\")]\n     (loop [[part :as parts] parts\n            acc []]\n       (if (empty? parts) (flatten acc)\n           (let [match (re-find (re-matcher re part))\n                 start (Integer\/parseInt (get match 1))\n                 end (if (nil? (get match 4)) start\n                         (Integer\/parseInt (get match 4)))\n                 step (if (nil? (last match)) 1\n                          (Integer\/parseInt (get match 5 1)))]\n             (recur (rest parts)\n                    (conj acc (range start (inc end) step))))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17775,"user_id":null,"body":"(ns kata.range_parser)\n\n(defn parse-single-range\n  \"x-y\"\n  [r]\n  (let [[start end] (clojure.string\/split r #\"-\")]\n    (range (Integer. start) (inc (Integer. end)))))\n\n(defn parse-step-range\n  \"x-y:s\"\n  [r]\n  (let [[start end step] (clojure.string\/split r #\"[^0-9]\")]\n    (range (Integer. start) (inc (Integer. end)) (Integer. step))))\n\n(defn parse-range\n  [r]\n  (cond\n    (clojure.string\/includes? r \":\") (parse-step-range r)\n    (clojure.string\/includes? r \"-\") (parse-single-range r)\n    :else [(Integer. r)]))\n\n\n(defn range_parser\n  [input]\n  (->> (clojure.string\/split input #\"\\s*,\\s*\")\n       (mapcat parse-range)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17776,"user_id":null,"body":"(ns kata.range_parser\n  (require [clojure.string :as str]))\n\n(defn get-range [r]\n  (let [splits (str\/split r #\"-|:\")]\n    (if (= 1 (count splits))\n          (Integer\/parseInt (first splits))\n          (range (Integer\/parseInt (first splits))\n                 (inc (Integer\/parseInt (second splits)))\n                 (Integer\/parseInt (nth splits 2 \"1\"))))))\n\n(defn range_parser [s]\n  (->> (str\/split s #\",\")\n       (map str\/trim)\n       (map get-range)\n       (flatten)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17777,"user_id":null,"body":"(ns kata.range_parser\n  (:require [clojure.string :refer [split]]))\n\n(defn term-parser [term]\n  (map #(Integer\/parseInt %) (split term #\"-|:\")))\n\n(defn range_parser [s]\n  (->> (split s #\", |,\")\n       (map (fn [term]\n              (let [[st end step] (term-parser term)]\n                (cond\n                  (nil? end) st\n                  (nil? step) (range st (inc end))\n                  :default (range st (inc end) step)))))\n        (flatten)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"57eae65a4321032ce000002d":[{"id":17778,"user_id":null,"body":"(ns kata)\n\n(defn fake_bin [x]\n  (clojure.string\/replace (clojure.string\/replace x #\"[1234]\" \"0\") #\"[56789]\" \"1\")\n  )","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17779,"user_id":null,"body":"(ns kata\n  (:require [clojure.string :as string]))\n\n(defn convert-num \n  [n]\n  (if (>= (Integer\/parseInt (str n)) 5)\n    \"1\"\n    \"0\"))\n\n(defn fake_bin [x]\n  ;; TODO\n  (string\/join \"\" (to-array (map convert-num (char-array x)))))\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17780,"user_id":null,"body":"(ns kata)\n\n(defn < [a b] (clojure.core\/< (compare a b) 0))\n\n(defn fake_bin [x]\n  (->> x\n    (map #(if (< % \\5) 0 1))\n    (apply str)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17781,"user_id":null,"body":"(ns kata)\n\n(defn fake_bin [x]\n  (apply str\n         (map (fn [c]\n                (if ((set \"01234\") c) \\0 \\1))\n              x)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17782,"user_id":null,"body":"(ns kata)\n\n(def fake_binary-true \"1\")\n(def fake_binary-false \"0\")\n(def fake_binary-bounduary 5)\n\n(defn char->fake_binary [c]\n  (let [number (Integer\/parseInt c)]\n    (if (< number fake_binary-bounduary)\n      fake_binary-false fake_binary-true)))\n\n(defn fake_bin [x]\n  (clojure.string\/replace x #\"\\d\" char->fake_binary))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17783,"user_id":null,"body":"(ns kata)\n\n(defn fake_bin [x]\n  (apply str (map #(int (Math\/floor (\/ (int %) 53))) x))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17784,"user_id":null,"body":"(ns kata)\n\n(defn round_5 [a]\n  (if (< (int a) (int \\5)) \"0\" \"1\")\n  )\n(defn fake_bin [x]\n  (clojure.string\/join \"\" (map round_5 x))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17785,"user_id":null,"body":"(ns kata)\n\n(defn fake_bin [x]\n  (clojure.string\/replace x #\"[1-9]\" {\"1\" \"0\" \n                                      \"2\" \"0\" \n                                      \"3\" \"0\" \n                                      \"4\" \"0\" \n                                      \"5\" \"1\" \n                                      \"6\" \"1\"\n                                      \"7\" \"1\" \n                                      \"8\" \"1\" \n                                      \"9\" \"1\"}))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17786,"user_id":null,"body":"(ns kata)\n\n(defn fake_bin [x]\n  (apply str (map #(if (> 0 (compare % \\5)) \\0 \\1) x))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17787,"user_id":null,"body":"(ns kata)\n\n(defn fake_bin [x]\n   (clojure.string\/join \n    (map #(if (< %1 5) 0 1) \n         (map #(Integer\/parseInt %1) (clojure.string\/split (str x) #\"\")))) \n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"57eaec5608fed543d6000021":[{"id":17788,"user_id":null,"body":"(ns kata)\n(defn div_con [x]\n  (reduce #(if (string? %2) (- %1 (Integer\/parseInt %2)) (+ %1 %2)) 0 x))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17789,"user_id":null,"body":"(ns kata)\n\n(defn div_con [x]\n  (let [numbers (reduce + (filter integer? x))\n        string-numbers (->> (remove integer? x)\n                            (map #(Integer\/parseInt %))\n                            (reduce +))]\n    (- numbers string-numbers)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17790,"user_id":null,"body":"(ns kata)\n(defn div_con [xs] \n  (reduce + (map #(if (instance? String %) (- 0 (read-string %)) %) xs)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17791,"user_id":null,"body":"(ns kata)\n\n(defn div_con [array]\n  (reduce #(if (number? %2)\n            (+ %1 %2)\n            (- %1 (Integer\/parseInt %2))) 0 array))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17792,"user_id":null,"body":"(ns kata)\n\n(defn- parse-int [s]\n  (Integer\/parseInt (re-find #\"\\A-?\\d+\" s)))\n\n(defn div_con [x]\n  (- (reduce + (filter integer? x)) (reduce + (map parse-int (filter string? x)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17793,"user_id":null,"body":"(ns kata)\n(defn div_con [x]\n  (- (reduce + (filter number? x)) (reduce + (map (fn [x] (Integer\/parseInt x)) (filter string? x)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17794,"user_id":null,"body":"(ns kata)\n(defn div_con [x]\n  (reduce + (map #(if (instance? Number %) % (* -1 (Integer\/parseInt %))) x))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17795,"user_id":null,"body":"(ns kata)\n\n(defn div_con [x]\n  (reduce #(if (number? %2) (+ %1 %2) (- %1 (Integer\/parseInt %2))) 0 x)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17796,"user_id":null,"body":"(ns kata)\n\n(defn check-for-string [val]\n  (if (string? val)\n    (+ (* -2 (Integer\/parseInt val)) (Integer\/parseInt val))\n    val\n    )\n  )\n\n(defn div_con\n  ([x] (div_con x 0))\n  ([x total]\n   (if (= (count x) 0)\n     total\n     (div_con (rest x) (+ total (check-for-string (first x))))\n     )\n   )\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17797,"user_id":null,"body":"(ns kata)\n(defn div_con [x]\n  (- (reduce + (filter number? x)) (reduce + (map #(Integer\/parseInt %) (filter string? x))))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"57ebdf944cde58f973000405":[{"id":17798,"user_id":null,"body":"(ns kata.reverser)\n(require '[clojure.string :as string])\n\n(defn reverser [s]\n  (->> (string\/split s #\" \" -1)\n       (map string\/reverse)\n       (string\/join \" \")))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17799,"user_id":1200,"body":"(ns kata.reverser)\n\n(defn reverser [s] (apply str (mapcat reverse (partition-by #(= \\space %) s))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17800,"user_id":null,"body":"(ns kata.reverser)\n\n(defn reverser [s]\n  (clojure.string\/replace s #\"[^\\s]+\" #(clojure.string\/reverse %)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17801,"user_id":null,"body":"(ns kata.reverser)\n\n(defn reverser [s]\n  (clojure.string\/replace s #\"\\S+\" #(clojure.string\/reverse %1))\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17802,"user_id":null,"body":"(ns kata.reverser)\n\n(defn reverser [s]\n(clojure.string\/join \" \" (map clojure.string\/reverse (clojure.string\/split s #\" \" -1)))\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17803,"user_id":3333,"body":"(ns kata.reverser)\n\n(defn reverser [s]\n  (clojure.string\/join (map clojure.string\/reverse (re-seq #\"\\S+|\\s\" s))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17804,"user_id":null,"body":"(ns kata.reverser)\n\n(defn reverser [s]\n  (->> (partition-by #(= \\space %) s)\n       (map #(reverse %) )\n       (map #(apply str %))\n       (clojure.string\/join \"\" )))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17805,"user_id":null,"body":"(ns kata.reverser\n  (:require [clojure.string :as string]))\n\n(defn reverser [s]\n  (string\/replace s #\"\\S+\" #(string\/reverse %)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17806,"user_id":null,"body":"(ns kata.reverser\n  (:require [clojure.string :as str]))\n\n(defn reverser [s]\n  (let [ls (= \\space (last s))]\n    (def g (map #(str\/join #\"\" %) \n           (map reverse (str\/split s #\" \"))))\n    (str (str\/join #\" \" g) (if ls \\space)) ))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17807,"user_id":null,"body":"(ns kata.reverser)\n\n(defn reverser [s]\n   (if (= s \" go away \")\n     \" og yawa \"\n     (clojure.string\/join (flatten (interpose #\" \" (map (partial into '()) (clojure.string\/split s #\" \")))))\n   )\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"57eeb8cc5f79f6465a0015c1":[{"id":17808,"user_id":null,"body":"(ns kata.is_kiss)\n(defn kiss? [s]\n  (let [words (clojure.string\/split s #\" \"), n (count words)]\n    (if (every? #(<= % n) (map count words)) \"Good work Joe!\" \"Keep It Simple Stupid\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17809,"user_id":null,"body":"(ns kata.is_kiss\n  (:require [clojure.string :as str]))\n\n(defn kiss? [s]\n  (let [words (str\/split s #\" \")\n        word-count (count words)]\n    (if (every? #(<= (count %) word-count) words)\n      \"Good work Joe!\"\n      \"Keep It Simple Stupid\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17810,"user_id":168,"body":"(ns kata.is_kiss)\n\n(defn kiss? [s]\n  (let [ws (clojure.string\/split s #\" \")\n        n (count ws)]\n    (if (every? #(<= (count %) n) ws)\n      \"Good work Joe!\" \"Keep It Simple Stupid\")))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17811,"user_id":null,"body":"(ns kata.is_kiss\n  (:require [clojure.string :as str]))\n\n(defn kiss? [s]\n    (let [split-string (str\/split s #\" \")\n          num-of-words (count split-string)\n          length-of-word (count (first (reverse (sort-by count split-string))))]\n      (if (<= length-of-word num-of-words)\n        \"Good work Joe!\"\n        \"Keep It Simple Stupid\")))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17812,"user_id":null,"body":"(ns kata.is_kiss)\n\n(defn kiss? [s]\n  (as->\n    s $\n    (clojure.string\/split $ #\" \")\n    (if\n      (>= (count $) (apply max (map count $)))\n      \"Good work Joe!\"\n      \"Keep It Simple Stupid\")))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17813,"user_id":null,"body":"(ns kata.is_kiss\n  (:require [clojure.string :as str]))\n\n(defn kiss? [s]\n  (let [words (str\/split s #\" \")]\n    (if (every? (fn [word] (<= (count word) (count words))) words)\n      \"Good work Joe!\" \"Keep It Simple Stupid\")))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17814,"user_id":null,"body":"(ns kata.is_kiss\n  (:require [clojure.string :as str]))\n\n(defn kiss? [s]\n  (if (>= (count (str\/split s #\" \"))\n          (apply max (map count (str\/split s #\" \"))))\n      \"Good work Joe!\"\n      \"Keep It Simple Stupid\"))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17815,"user_id":null,"body":"(ns kata.is_kiss)\n\n(defn kiss? [s]\n   (let [words (clojure.string\/split s #\"\\s\")]\n      (if (every? #(<= (count %) (count words)) words)\n          \"Good work Joe!\"\n          \"Keep It Simple Stupid\"\n  )))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17816,"user_id":null,"body":"(ns kata.is_kiss)\n\n(defn kiss?\n  [s]\n  (let [words (clojure.string\/split s #\" \")\n        total-word (count words)]\n    (if (every? #(<= (count %) total-word) words)\n      \"Good work Joe!\"\n      \"Keep It Simple Stupid\")))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17817,"user_id":null,"body":"(ns kata.is_kiss\n  (require [clojure.string :as str]))\n\n(def kiss? \n  (comp #(if (<= (apply max \n                        %)\n                 (count %))\n            \"Good work Joe!\"\n            \"Keep It Simple Stupid\")\n        (partial map\n                 count)\n        #(str\/split %\n                    #\" \")))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"57ef016a7b45ef647a00002d":[{"id":17818,"user_id":null,"body":"(ns kata.filter_homogenous)\n\n(defn filter_homogenous [sq]\n  (filter #(and (seq %) (apply = (map type %))) sq))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17819,"user_id":null,"body":"(ns kata.filter_homogenous)\n\n(defn homogenous [sq] \n  (if (empty? sq)\n    false\n    (apply = (map type sq))))\n  \n\n(defn filter_homogenous [sq]\n  (filter homogenous sq))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17820,"user_id":null,"body":"(ns kata.filter_homogenous)\n\n(defn homogenous? [sq]\n  (= (->> sq\n         (map type)\n         (set)\n         (count))\n      1))\n\n(defn filter_homogenous [sq]\n  (filter homogenous? sq))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17821,"user_id":null,"body":"(ns kata.filter_homogenous)\n\n(def filter_homogenous \n  (partial filter \n    (comp (partial = 1)\n          count\n          set\n          (partial map type))))\n          ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17822,"user_id":null,"body":"(ns kata.filter_homogenous)\n\n(defn num_types [sq] (count (distinct (map type sq))))\n(defn same_type [sq] (= 1 (num_types sq)))\n(defn filter_homogenous [sq] (filter same_type sq) )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17823,"user_id":null,"body":"(ns kata.filter_homogenous)\n\n(def filter_homogenous\n  (partial filter #(->> % (map type) set count (= 1))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17824,"user_id":881,"body":"(ns kata.filter_homogenous)\n\n(defn filter_homogenous [sq]\n  (filter (fn [row] (and (seq row) (apply = (map type row)))) sq))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17825,"user_id":null,"body":"(ns kata.filter_homogenous)\n\n(defn homogenous? [things]\n  (= 1 (count (set (map type things))))\n  )\n\n(defn filter_homogenous [sq]\n   (filter homogenous? sq)\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17826,"user_id":null,"body":"(ns kata.filter_homogenous)\n\n(defn filter_homogenous [sq]\n  (filter #(and (= (count (partition-by type %)) 1)\n                (> (count %) 0)) sq))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17827,"user_id":null,"body":"(ns kata.filter_homogenous)\n\n(defn solution\n  [arr]\n  (loop [car (first arr)\n         cdr (rest arr)\n         res []]\n    (cond (nil? car) (reverse res)\n          (empty? car) (recur (first cdr)\n                       (rest cdr)\n                       res)\n          (apply = (map type car))\n          (recur (first cdr)\n                       (rest cdr)\n                       (cons car res))\n          :else (recur (first cdr)\n                       (rest cdr)\n                       res))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"57f5e7bd60d0a0cfd900032d":[{"id":17828,"user_id":527,"body":"(ns find-the-missing-nuber)\n\n(def missing-no (partial apply bit-xor 100))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17829,"user_id":null,"body":"(ns find-the-missing-nuber)\n\n(defn missing-no [xs]\n  (loop [index 0 ys (sort xs)]\n      (if (> index 100)\n        nil\n        (if (not= index (first ys))\n          index\n          (recur (inc index) (rest ys))))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17830,"user_id":527,"body":"(ns find-the-missing-nuber)\n\n(defn missing-no [xs]\n  (apply bit-xor 100 xs))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17831,"user_id":null,"body":"(ns find-the-missing-nuber)\n\n\n(defn missing-no [xs]\n  (first (apply disj (set (range 101)) xs) ))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17832,"user_id":363,"body":"(ns find-the-missing-nuber)\n\n(require '[clojure.set :as set])\n\n(defn missing-no [xs]\n  (apply identity (set\/difference (apply hash-set (range 101)) (apply hash-set xs)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17833,"user_id":null,"body":"(ns find-the-missing-nuber)\n\n(defn missing-no [xs]\n  (def given (apply + xs))\n  (def total (apply + (range 1 101)))\n  (- total given)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17834,"user_id":null,"body":"(ns find-the-missing-nuber)\n\n(defn missing-no [xs]\n  (- (apply + (range 1 101)) (apply + xs))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17835,"user_id":null,"body":"(ns find-the-missing-nuber)\n\n(defn missing-no [xs]\n(def i (reduce + xs))\n  (- (reduce +  \n      (range 0 101)) i)\n  )\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17836,"user_id":null,"body":"(ns find-the-missing-nuber)\n\n(defn missing-no [xs]\n  (- (* 101 50) (apply + xs))  \n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17837,"user_id":null,"body":"(ns find-the-missing-nuber)\n\n(defn missing-no [xs]\n  (- (reduce + (range 0 101)) (reduce + xs))\n) ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"57f759bb664021a30300007d":[{"id":17838,"user_id":209,"body":"(ns kata)\n(defn switcheroo [xs]\n  (clojure.string\/replace xs #\"a|b\" {\"a\" \"b\" \"b\" \"a\"})\n  )\n         \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17839,"user_id":null,"body":"(ns kata)\n(defn switcheroo [xs]\n  (->> xs\n       (map #(case % \\a \\b \\b \\a %))\n       (apply str)))\n         \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17840,"user_id":null,"body":"(ns kata)\n\n(defn switch [letter]\n  (cond (= letter \\a) \\b\n        (= letter \\b) \\a\n        :default letter))\n\n(defn switcheroo [xs]\n  (->> xs\n       (map switch)\n       (clojure.string\/join)))\n         \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17841,"user_id":null,"body":"(ns kata)\n\n(defn reverse-letter\n  [letter]\n  (case letter\n    \\a \\b\n    \\b \\a\n    letter))\n\n(defn switcheroo [xs]\n  (reduce (fn [word letter]\n            (str word (reverse-letter letter)))\n          \"\"\n          xs))\n         \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17842,"user_id":null,"body":"(ns kata)\n(defn switcheroo [xs]\n  (apply str (map #(cond (= % \\a) \\b (= % \\b) \\a :else \\c) xs)))\n         \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17843,"user_id":null,"body":"(ns kata)\n\n(defn switcheroo [xs]\n  (->> xs\n       (map #(get {\\a \\b \\b \\a} % %))\n       (apply str)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17844,"user_id":null,"body":"(ns kata)\n(defn switcheroo [xs]\n  (clojure.string\/replace xs #\"[a]|[b]\" {\"a\" \"b\" \"b\" \"a\"})\n  )\n         \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17845,"user_id":null,"body":"(ns kata)\n\n(defn swap-ab [ch]\n  (case ch\n    \\a \\b\n    \\b \\a\n    ch))\n\n(defn switcheroo [xs]\n  (apply str (map swap-ab xs)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17846,"user_id":null,"body":"(ns kata)\n(defn switcheroo [xs]\n  (->> xs\n    (map (fn [x]\n           (cond\n             (= x \\a) \\b\n             (= x \\b) \\a\n             :else x)\n           ))\n    (apply str)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17847,"user_id":50,"body":"; https:\/\/clojuredocs.org\/clojure.string\/replace\n(ns kata)\n(defn switcheroo [xs]\n  (clojure.string\/replace xs #\"a|b\" {\"a\" \"b\" \"b\" \"a\"})\n  )\n         \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"57f75cc397d62fc93d000059":[{"id":17848,"user_id":527,"body":"(ns kata.calc)\n\n(defn calc [s]\n  (->> s (mapcat (comp str int)) (filter #(= % \\7)) count (* 6)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17849,"user_id":null,"body":"(ns kata.calc)\n\n(defn digits [n]\n  (->> (iterate #(quot % 10) n)\n       (take-while pos?)\n       (map #(mod % 10))))\n\n(defn calc [s]\n  (->> (map int s)\n       (map digits)\n       (mapcat identity)\n       (filter (partial = 7))\n       count\n       (* 6)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17850,"user_id":null,"body":"(ns kata.calc\n  (:require [clojure.string :as s]))\n\n(defn char->ascii [n]\n  (int n))\n\n(defn sevens-to-one [s]\n  (s\/replace s \"7\" \"1\"))\n\n(defn str->char-nums [s]\n  (->> s\n       (map char->ascii)\n       (map str)\n       (reduce (fn [acc cur] (str acc cur)))))\n\n(defn str->nuns-7-1 [s]\n  (->> s\n       str->char-nums\n       sevens-to-one))\n\n(defn sum-all [s]\n  (->> s\n       (map #(Integer. (str %)))\n       (reduce +)))\n\n(defn to-sum-each [s f]\n  (->> s f sum-all))\n\n(defn calc [s]\n  (let [n (to-sum-each s str->char-nums)\n        z (to-sum-each s str->nuns-7-1)]\n    (- n z)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17851,"user_id":null,"body":"(ns kata.calc)\n\n(defn calc [s]\n  (let [total1 (->>\n        (seq s)\n        (map #(->>\n               (int %)\n               (str )\n               (seq )))\n        (reduce concat)\n        (map #(Character\/digit % 10))\n        )\n       total2 (->>\n        (map #(if (= % 7) 1 %)  total1)\n        )]\n    \n    (reduce +(mapv - total1 total2))\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17852,"user_id":168,"body":"(ns kata.calc)\n\n(defn calc [s]\n  (->> (char-array s)\n       (map int)\n       (apply str)\n       (filter #(= % \\7))\n       (count)\n       (#(* 6 %))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17853,"user_id":null,"body":"(ns kata.calc\n  (:require [clojure.string :as s]))\n\n(defn calc [s]\n  (let [total1 (->> s (map (comp str int)) (apply str))\n        total2 (s\/replace total1 \"7\" \"1\")\n        diffs (map #(- (int %1) (int %2)) total1 total2)]\n    (reduce + diffs)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17854,"user_id":null,"body":"(ns kata.calc\n  (require [clojure.string :as str]))\n\n(defn calc [s]\n  (let [code (str\/join \"\" (map int s))]\n     (-\n      (reduce + (map\n                 #(Integer\/parseInt %)\n                 (str\/split code #\"\")))\n      (reduce + (map\n                 #(Integer\/parseInt %)\n                 (str\/split (str\/join \"\" (map #(if (= % \\7) \\1 %) code)) #\"\"))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17855,"user_id":53,"body":"(ns kata.calc)\n\n(defn calc [s]\n  (reduce \n    (fn [a b] (cond \n                (and (= 7 (mod (quot b 10) 10)) (= 7 (mod b 10))) (+ a 12)\n                (= 7 (mod b 10)) (+ a 6)\n                (= 7 (mod (quot b 10) 10)) (+ a 6)\n                :else a))  \n    0                      \n    (map int s)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17856,"user_id":null,"body":"(ns kata.calc)\n\n(defn calc [s]\n  (let [total1 (apply str (map (fn[c] (int c)) s))\n        total2 (clojure.string\/replace (apply str (map (fn[c] (int c)) s)) #\"7\" \"1\")]\n    (- (apply + (map (fn [c] (Character\/digit c 10)) total1)) (apply + (map (fn [c] (Character\/digit c 10)) total2)))\n  )\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17857,"user_id":null,"body":"(ns kata.calc)\n\n(defn string-digits [s] (->> (seq s) (map #(- (int %) (int \\0)))))\n(defn sum-of-string-digits [s] (reduce + (string-digits s)))\n\n(defn calc\n  [s]\n  (let [\n    chars-seq (seq s)\n    ints-seq (map #(int %) chars-seq)\n    strings-seq (apply str ints-seq)\n    total1 (apply str strings-seq)\n    total2 (clojure.string\/replace total1 \"7\" \"1\")\n    result (- (sum-of-string-digits total1) (sum-of-string-digits total2))\n  ] result))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"57f7796697d62fc93d0001b8":[{"id":17858,"user_id":null,"body":"(ns kata)\n(defn trouble [[x & xs] t]\n  (->> xs\n      (reduce \n       (fn [res n] (if (= t (+ n (first res))) res (conj res n)))      \n       (list x))\n      reverse))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17859,"user_id":527,"body":"(ns kata)\n\n(defn- trouble-xf [t]\n  (fn [f]\n    (let [d (volatile! nil)]\n      (fn\n        ([] (f))\n        ([r] (f r))\n        ([r x] (if (= x @d) r (do (vreset! d (- t x)) (f r x))))))))\n\n(defn trouble [xs t]\n  (eduction (trouble-xf t) xs))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17860,"user_id":527,"body":"(ns kata)\n(defn trouble [xs t]\n  (loop [rs (transient []) d nil [x & xs] xs]\n    (condp = x\n      nil (persistent! rs)\n      d (recur rs d xs)\n      (recur (conj! rs x) (- t x) xs))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17861,"user_id":527,"body":"(ns kata)\n\n(defn- trouble' [[x & xs] t]\n  (if x (cons x (lazy-seq (trouble' (drop-while (partial = (- t x)) xs) t))) ()))\n\n(defn trouble [xs t] (trouble' (eduction xs) t))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17862,"user_id":527,"body":"(ns kata)\n(defn trouble [[x & xs] t]\n  (if x (cons x (lazy-seq (trouble (drop-while (partial = (- t x)) xs) t))) ()))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17863,"user_id":168,"body":"(ns kata)\n(defn trouble [xs t]\n  (reduce #(if (= (+ (last %) %2) t) % (conj % %2)) [(first xs)] (rest xs)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17864,"user_id":null,"body":"(ns kata)\n\n(defn trouble [xs t]\n  (reduce (fn [acc cur]\n            (if (= t (+ (last acc) cur))\n              acc\n              (conj acc cur)))\n          [(first xs)] (rest xs)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17865,"user_id":null,"body":"(ns kata)\n(defn trouble [xs target]\n  (if (empty? xs)\n    [nil]\n    (loop [ys  (rest xs)\n           res [(first xs)]\n           idx 0]\n      (if (= idx (dec (count xs)))\n        res\n        (let [x (last res)\n              y (first ys)]\n          (prn idx x y)\n          (if (= target (+ x y))\n            (recur (rest ys) res (inc idx))\n            (recur (rest ys) (conj res y) (inc idx))))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17866,"user_id":201,"body":"(ns kata)\n(defn trouble [xs t]\n  (loop [xs xs\n         acc []]\n    (if (< (count xs) 2) (conj acc (first xs))\n        (let [a (first xs)\n              b (second xs)]\n          (if (= t (+ a b))\n            (recur (cons a (drop 2 xs)) acc)\n            (recur (cons b (drop 2 xs)) (conj acc a)))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"57f780909f7e8e3183000078":[{"id":17867,"user_id":527,"body":"(ns kata)\n\n(def grow (partial reduce *))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17868,"user_id":201,"body":"(ns kata)\n\n(defn grow [xs]\n (reduce * xs))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17869,"user_id":null,"body":"(ns kata)\n\n(defn grow [xs]\n  (apply * xs))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17870,"user_id":527,"body":"(ns kata)\n\n(def grow (partial apply *))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17871,"user_id":null,"body":"(ns kata)\n\n(def grow #(reduce * %))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17872,"user_id":null,"body":"(ns kata)\n\n(defn grow [list]\n  (reduce * list))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17873,"user_id":null,"body":"(ns kata)\n\n(defn grow [xs]\n  (if (not= 0 (count xs))\n    (* (first xs) (grow (rest xs)))\n    1))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17874,"user_id":null,"body":"(ns kata)\n\n(defn grow [xs]\n  (reduce * (map * xs))\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17875,"user_id":null,"body":"(ns kata)\n\n(defn grow [xs]\n  (reduce * xs)\n  ;; TODO\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17876,"user_id":null,"body":"(ns kata)\n\n(defn grow [xs]\n  ;; TODO\n  (apply * xs)\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"57f781872e3d8ca2a000007e":[{"id":17877,"user_id":null,"body":"(ns kata)\n\n(defn maps [xs]\n  (map #(* 2 %1) xs)\n  )","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17878,"user_id":null,"body":"(ns kata)\n\n(defn times2 [x]\n  (* 2 x)\n  )\n\n(defn maps [xs]\n  ;; TODO\n  (map times2 xs)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17879,"user_id":null,"body":"(ns kata)\n\n(def double (partial * 2))\n\n(def maps #(mapv double %))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17880,"user_id":null,"body":"(ns kata)\n\n(defn maps [coords]\n  (for\n    [i coords]\n    (* i 2)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17881,"user_id":201,"body":"(ns kata)\n(defn maps [xs]\n  (map (fn [x] (* 2 x)) xs))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17882,"user_id":3360,"body":"(ns kata)\n\n(defn maps [xs]\n  (map (fn [x] (* x 2)) xs)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17883,"user_id":null,"body":"(ns kata)\n\n(defn double-it [x] (* x 2))\n\n(defn maps [xs]\n  (map double-it xs )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17884,"user_id":null,"body":"(ns kata)\n\n(defn maps [xs]\n  (mapv #(* % 2) xs))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17885,"user_id":null,"body":"(ns kata)\n\n(defn maps [xs]\n  (->>  (map #(* 2 %) xs)\n        (into []))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17886,"user_id":null,"body":"(ns kata)\n\n(defn maps [xs]\n  (into [] (map (fn [x] (* x 2)) xs))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"57faf12b21c84b5ba30001b0":[{"id":17887,"user_id":null,"body":"(ns exclamation-mark.core)\n\n(defn remove-bang [s]\n  (str (clojure.string\/replace s \"!\" \"\") \"!\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17888,"user_id":527,"body":"(ns exclamation-mark.core)\n\n(defn remove-bang [s]\n  (-> s (.replace \"!\" \"\") (.concat \"!\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17889,"user_id":null,"body":"(ns exclamation-mark.core)\n\n(defn remove-bang [s]\n  (str (clojure.string\/replace s \"!\" \"\") \\!)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17890,"user_id":null,"body":"(ns exclamation-mark.core)\n\n(defn isExclamationMark [c] (= c \\!))\n\n(defn remove-bang [s]\n  (def charlist (into [] (seq (char-array s))))\n  (def listWithoutExclamationMarks (filter (comp not isExclamationMark) charlist))\n  (str (clojure.string\/join \"\" listWithoutExclamationMarks) \\!)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17891,"user_id":null,"body":"(ns exclamation-mark.core)\n\n(defn remove-bang\n  [s]\n  (->> s\n       (filter #(not= \\! %))\n       (reverse)\n       (cons \\!)\n       (reverse)\n       (apply str)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17892,"user_id":null,"body":"(ns exclamation-mark.core)\n\n(defn remove-bang [s]\n  (str (apply str (filter (fn [ch] (not= ch \\!)) (seq s))) \\!))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17893,"user_id":null,"body":"(ns exclamation-mark.core)\n\n(defn remove-bang [s]\n  (str (apply str (filter (partial not= \\!) s)) \\!)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17894,"user_id":null,"body":"(ns exclamation-mark.core)\n\n(defn remove-bang [s]\n(let \n  [\n   chrs        (clojure.string\/split s #\"\")\n   without-ex  (filter #(not (= (str %1) \"!\")) chrs)\n   newtxt      (clojure.string\/join without-ex)\n   ] (str newtxt \"!\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17895,"user_id":null,"body":"(ns exclamation-mark.core)\n\n(defn remove-bang\n  [string-parameter]\n  (-> string-parameter\n    (clojure.string\/replace \"!\" \"\")\n    (str \"!\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17896,"user_id":null,"body":"(ns exclamation-mark.core)\n\n(defn remove-bang [s]\n  (str (->> s\n            (filter #(not= % \\!))\n            (apply str))\n       \"!\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"57fcaed83206fb15fd00027a":[{"id":17897,"user_id":null,"body":"(ns kata.replace-nth)\n\n(defn replace-nth\n  [txt n old-val new-val]\n  (as->\n    txt $\n    (reduce\n      (fn\n        [[text i], c]\n        (if\n          (= c old-val)\n          (if\n            (= i n)\n            [(str text new-val) 1]\n            [(str text c) (inc i)])\n          [(str text c) i]))\n      [\"\", 1]\n      $)\n    (first $)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17898,"user_id":null,"body":"(ns kata.replace-nth)\n\n(defn reducer [old-val new-val n {:keys [result c] :as acc} i]\n  (if (= i old-val)\n    (-> acc\n        (assoc :result (str result (if (and (>= c n) (zero? (rem c n)))\n                                     new-val\n                                     old-val)))\n        (update :c inc))\n    (-> acc\n        (assoc :result (str result i)))))\n  \n\n(defn replace-nth [text n old-val new-val]\n  (if (or (neg? n) (zero? n))\n    text\n    (->> text\n         (reduce (partial reducer old-val new-val n) {:result \"\" :c 1})\n         :result)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17899,"user_id":201,"body":"(ns kata.replace-nth)\n\n(defn replace-nth [txt n old-val new-val]\n   (loop [[x :as xs] txt\n          num 0\n          acc []]\n     (if (empty? xs) (apply str acc)\n         (let [[num1 acc1] (if (= x old-val)\n                             (if (= num (dec n)) [0 (conj acc new-val)]\n                                 [(inc num) (conj acc x)])\n                             [num (conj acc x)])]\n           (recur (rest xs) num1 acc1)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17900,"user_id":null,"body":"(ns kata.replace-nth)\n\n(defn replace-nth [txt n old-val new-val]\n  (if (<= n 0) txt\n      (loop [acc \"\", reststr txt, occ 1]\n        \"hugo\"\n        (if (empty? reststr)\n          acc\n          (let [curc (first reststr)\n                is-match (= old-val curc)\n                newc (if is-match\n                       (if (zero? (mod occ n)) new-val curc)\n                       curc)\n                newocc (if is-match (inc occ) occ)]\n            (recur (str acc newc) (rest reststr) newocc))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17901,"user_id":null,"body":"(ns kata.replace-nth)\n\n(defn combine [a b]\n  (apply str (flatten (map #(vector % %2) a b))))\n\n(defn replace-nth [txt n old-val new-val]\n  (let [matches (re-seq (re-pattern (str old-val)) txt)]\n    (if (or (< n 1) (> n (count matches))) txt\n      (combine\n        (clojure.string\/split txt (re-pattern (str old-val)))\n        (conj (vec (map-indexed\n          #(if (zero? (mod (inc %) n)) (str new-val) %2)\n          matches)) \"\")))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17902,"user_id":null,"body":"(ns kata.replace-nth)\n\n\n(defn get-idx\n  [s c]\n  (loop [s s\n         idx 0  ; zero based\n         res []]\n    (cond (empty? s) res\n          (= (first s) c)\n          (recur (rest s) (inc idx) (conj res idx))\n          :else (recur (rest s) (inc idx) res))))\n\n(defn replace-nth\n  [txt n old-val new-val]\n  (loop [txt txt\n         idx (take-nth n (drop (dec n) (get-idx txt old-val)))]\n    (cond (> 1 n) txt\n          (empty? idx) txt\n          :else\n          (recur (str (subs txt 0  (first idx))\n                      new-val\n                      (subs txt (+ 1 (first idx))))\n                 (rest idx)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17903,"user_id":null,"body":"(ns kata.replace-nth)\n\n(defn replace-nth [txt n old-val new-val]\n  (apply str\n         (loop [[f & s] txt\n                i n\n                rv []]\n           (if f\n             (if (= old-val f)\n               (if (= 1 i)\n                 (recur s n (conj rv new-val))\n                 (recur s (dec i) (conj rv f)))\n               (recur s i (conj rv f)))\n             rv))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17904,"user_id":null,"body":"(ns kata.replace-nth)\n(require '[clojure.string :as string])\n\n(defn divisible-by? [divisor number] \n     (zero? (mod number divisor)))\n\n(defn replace-nth [txt n old-val new-val]\n  (let [values (filter #(= old-val %) (seq txt))]\n    (if (<= 1 n (count values)) \n      (let [new-or-old? (fn [idx itm] (if (divisible-by? n (inc idx)) new-val old-val))\n            template (string\/replace txt (str old-val) \"%c\")] \n        (apply format template (map-indexed new-or-old? values)))\n      txt)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17905,"user_id":null,"body":"(ns kata.replace-nth\n  (:require\n    [clojure.string :as str]))\n\n(defn replace-nth [txt n old-val new-val]\n  (let [txtLen (count txt)]\n    (loop [i 0\n           counter 1\n           resText []]\n      (if (< i txtLen)\n        (let [curChar (nth txt i)]\n          (do\n            (cond\n              (and (= curChar old-val) (= counter n))\n                (recur (inc i) 1 (conj resText new-val))\n              (= curChar old-val)\n                (recur (inc i) (inc counter) (conj resText curChar))\n              :default\n                (recur (inc i) counter (conj resText curChar))))\n        )\n        (str\/join \"\" resText))\n    )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17906,"user_id":null,"body":"(ns kata.replace-nth)\n\n(defn replace-nth [txt n old-val new-val]\n  (let [old-vals (->> (map-indexed vector txt)\n                      (filter (fn [[i c]] (= c old-val))))\n        indexes (->> old-vals\n                     (drop (- n 1))\n                     (take-nth n)\n                     (map (fn [[i _]] [i new-val])))]\n    (if (or ((complement pos?) n) (> n (count old-vals)))\n      txt\n      (->> (flatten indexes)\n          (apply assoc (apply vector (seq txt)))\n          (apply str)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"580a4734d6df748060000045":[{"id":17907,"user_id":null,"body":"(ns kata.is_sorted_and_how)\n\n(defn is_sorted_and_how [sq]\n  (cond \n    (apply < sq) \"yes, ascending\"\n    (apply > sq) \"yes, descending\"\n    :else \"no\")) \n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-26 08:44:34"},{"id":17908,"user_id":null,"body":"(ns kata.is_sorted_and_how)\n\n(defn is_sorted_and_how [sq]\n  (condp apply sq\n    < \"yes, ascending\"\n    > \"yes, descending\"\n    \"no\"))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-26 08:44:39"},{"id":17909,"user_id":527,"body":"(ns kata.is_sorted_and_how)\n\n(defn is_sorted_and_how [xs]\n  (cond (apply < xs) \"yes, ascending\" (apply > xs) \"yes, descending\" :else \"no\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-26 08:44:27"},{"id":17910,"user_id":null,"body":"(ns kata.is_sorted_and_how)\n\n(defn is_sorted_and_how [sq]\n  (cond\n    (= (distinct(sort sq)) sq) \"yes, ascending\"\n    (= (distinct(reverse (sort sq))) sq) \"yes, descending\"\n    :else \"no\"\n  )\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-26 08:44:27"},{"id":17911,"user_id":null,"body":"(ns kata.is_sorted_and_how)\n\n(defn is_sorted_and_how [sq]\n  (cond \n    (every? true? (map #(apply < %) (partition 2 1 sq))) \"yes, ascending\"\n    (every? true? (map #(apply > %) (partition 2 1 sq))) \"yes, descending\"\n    :else \"no\"\n    )\n)\n  \n  \n  \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-26 08:44:27"},{"id":17912,"user_id":null,"body":"(ns kata.is_sorted_and_how)\n\n(defn is-sorted? [sq prd]\n  (cond\n    (and\n     (= 2 (count sq))\n     (prd (first sq) (second sq))) true\n    (prd (first sq) (second sq)) (recur (rest sq) prd)\n    :else false))\n\n(defn is_sorted_and_how [sq]\n  (cond\n    (is-sorted? sq <) \"yes, ascending\"\n    (is-sorted? sq >) \"yes, descending\"\n    :else \"no\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-26 08:44:27"},{"id":17913,"user_id":null,"body":"(ns kata.is_sorted_and_how)\n\n(defn is_sorted_and_how [sq]\n  (cond (apply < sq) \"yes, ascending\"\n        (apply > sq) \"yes, descending\"\n        :default \"no\"))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-26 08:44:27"},{"id":17914,"user_id":1703,"body":"(ns kata.is_sorted_and_how)\n\n(defn is_sorted_and_how [sq]\n  (if(not(= sq (distinct sq)))\"no\"\n    (if(= sq (sort sq))\"yes, ascending\" \n      (if(= sq (sort > sq))\"yes, descending\" \"no\"))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-26 08:44:27"},{"id":17915,"user_id":null,"body":"(ns kata.is_sorted_and_how)\n\n(defn is_sorted_and_how [sq]\n  (if (= sq (sort sq))\n    \"yes, ascending\"\n    (if (= (reverse sq) (sort sq))\n      \"yes, descending\"\n      \"no\"\n    )\n  )\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-26 08:44:27"},{"id":17916,"user_id":53,"body":"(ns kata.is_sorted_and_how)\n\n(defn is_sorted_and_how [xs]\n  (let [t (partition 2 1 xs)]\n    (cond (every? (fn [[a b]] (> a b)) t) \"yes, descending\"\n          (every? (fn [[a b]] (< a b)) t) \"yes, ascending\"\n          :else \"no\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-26 08:44:27"}],"58184387d14fc32f2b0012b2":[{"id":17917,"user_id":492,"body":"(ns approxsqrt.core)\n\n(defn f [x]\n  (\/ x (+ 1.0 (Math\/sqrt (+ 1.0 (double x))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17918,"user_id":1313,"body":"(ns approxsqrt.core)\n\n(defn f [x]\n  (\/\n    x\n    (+ 1 (Math\/sqrt (+ x 1) ) )\n  )\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17919,"user_id":527,"body":"(ns approxsqrt.core)\n\n(defn f [x]\n  (Math\/expm1 (* 0.5 (Math\/log1p x))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17920,"user_id":168,"body":"(ns approxsqrt.core)\n\n(defn f [x]\n  (\/ x (inc (Math\/sqrt (inc x)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17921,"user_id":50,"body":"(ns approxsqrt.core)\n\n(defn f [x]\n (\/ x (+ 1 (Math\/sqrt (+ 1 x)))) \n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17922,"user_id":53,"body":"(ns approxsqrt.core)\n\n(defn f [x] \n  (let [a (\/ x 2)\n        b (\/ (* x x) 8)\n        c (\/ (* x (* x x)) 16)\n        d (\/ (* 5 (* x (* x (* x x)))) 128)]\n    (- (+ a c) (+ b d))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17923,"user_id":null,"body":"(ns approxsqrt.core)\n\n(defn f [x]\n  (\/ x (+ 1N (Math\/sqrt (+ 1N x)))))\n; 2.1499997688750497E-7\n; 2.1500002311250496E-7\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17924,"user_id":null,"body":"(ns approxsqrt.core)\n\n(defn fact [x]\n  (apply * (range 1.0 (inc x))))\n\n(defn taylor-item [x n]\n  (* (\/ (* (Math\/pow -1 n) (fact (* 2 n)))\n        (* (- 1 (* 2 n)) (Math\/pow (fact n) 2) (Math\/pow 4.0 n)))\n     (Math\/pow x n)))\n\n(defn f [x]\n  (->> (iterate inc 1)\n       (map (partial taylor-item x))\n       (take-while (complement zero?))\n       (apply +)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17925,"user_id":null,"body":"(ns approxsqrt.core)\n\n(defn f [x]\n  (let [opx (\/ 1.0 x)\n        opy (+ opx (Math\/sqrt (+ opx (* opx opx))))\n        y (\/ 1.0 opy)] y))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"581ee0db1bbdd04e010002fd":[{"id":17926,"user_id":null,"body":"(ns approxinter.core)\n\n(defn interp [function lower upper num]\n  (let [step         (\/ (- upper lower) num)\n        interpolate  (fn [n] (+ lower (* n step)))\n        arguments    (map interpolate (range num)) \n        round        (fn [x] (\/ (Math\/floor (* x 100)) 100))]\n    (map (comp round function) arguments)\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17927,"user_id":492,"body":"(ns approxinter.core)\n\n(defn interp [f l u n]\n  (defn- calc-step [i]\n    (+ l (* (- u l) (\/ (double i) (double n)))))\n  (defn- trunc [x]\n    (\/ (Math\/floor (* x 100.0)) 100.0))\n  (defn- aux [i acc]\n    (if (= i n)\n      acc\n      (recur (inc i) (cons (trunc (f (calc-step i))) acc))))\n      ;(recur (inc i) (cons (f (calc-step i)) acc))))\n  (reverse (aux 0 []))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17928,"user_id":null,"body":"(ns approxinter.core)\n\n(defn interp [f l u n]\n  (let [d (\/ (- u l) n)]\n    (let [rec (fn rec [l c]\n                (if (= c n)\n                  ()\n                  (cons (\/ (Math\/floor (* (f l) 100.0)) 100.0) (rec (+ d l) (+ c 1)))))]\n      (rec l 0))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17929,"user_id":null,"body":"(ns approxinter.core)\n\n(defn interp [f l u n]\n  (let [arguments (range l u (\/ (- u l) n))\n        flr2 (fn [x] (\/ (Math\/floor (* 100.0 x)) 100.0))]\n    (into []\n          (map (comp flr2 f) (take n arguments))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17930,"user_id":null,"body":"(ns approxinter.core)\n\n(defn interp [f l u n]\n  (let [d (\/ (- u l) n)]\n    (take n \n          (for [i (range)\n                :let [x (+ l (* i d))]\n                :while (<= x u)]\n            (\/ (Math\/floor (* (f x) 100.0)) 100.0)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17931,"user_id":null,"body":"(ns approxinter.core)\n\n(defn round [n]\n  (let [scale (Math\/pow 10 2)]\n    (\/ (Math\/round (- (* n scale) 0.5))\n       scale)))\n\n(defn interp [f l u n]\n  (->> (range l u (\/ (- u l) n))\n       (map (fn [n] (round (f n))))\n       (take n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17932,"user_id":null,"body":"(ns approxinter.core)\n\n(defn round [n]\n  (let [scale (Math\/pow 10 2)]\n    (\/ (Math\/round (- (* n scale) 0.5))\n       scale)))\n\n(defn interp [f l u n]\n  (let [step (\/ (- u l) n)]\n    (println step)\n    (->> (range l u step)\n         (map f)\n         (map round)\n         (take n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17933,"user_id":null,"body":"(ns approxinter.core)\n\n(defn round [n]\n  (let [scale (Math\/pow 10 2)]\n    (\/ (Math\/round (- (* n scale) 0.5))\n       scale)))\n\n(defn interp [f l u n]\n  (map round (map f (let [step (\/ (- u l) n)]\n                      (println step)\n                      (loop [values [] x l]\n                        (if (>= x u)\n                          (take n values)\n                          (recur (conj values x) (+ step x))))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17934,"user_id":null,"body":"(ns approxinter.core)\n\n(defn floor [dp n]\n  (let [d (Math\/pow 10 dp)] \n    (\/ (Math\/floor (* n d)) d))\n)\n\n(defn interp [f l u n]\n  (let [d (\/ (- u l) n)\n        s (take n (iterate (partial + d) l))\n        res (map (comp (partial floor 2) f) s)] res)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17935,"user_id":null,"body":"(ns approxinter.core)\n\n(defn round [x]\n  (\/ (Math\/floor (* x 100)) 100))\n\n(defn interp [f l u n]\n  (->> (iterate (partial + (\/ (- u l) n)) l)\n       (take n)\n       (map f)\n       (map round)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"583203e6eb35d7980400002a":[{"id":17936,"user_id":null,"body":"(ns smiley)\n(defn count_smileys [arr]\n  ;return the total number of smiling faces in the array\n  (count (filter #(re-find #\"^[:;][-~]?[)D]\" %) arr))\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17937,"user_id":null,"body":"(ns smiley)\n\n(defn count_smileys [arr]\n  (->> arr (filter #(re-matches #\"[:;][~-]?[)D]\" %)) count))\n","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17938,"user_id":null,"body":"(ns smiley)\n(defn count_smileys [arr]\n  (->> arr\n    (filter #(re-find #\"(\\:|\\;)(-|~)?(\\)|D)\" %))\n    (count))\n)","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17939,"user_id":null,"body":"(ns smiley)\n\n(defn smiley?\n  [face]\n  (re-matches #\"(:|;)(-|~)?(\\)|D)\" face))\n\n(defn count_smileys [arr]\n  (count (filter (comp some? smiley?) arr)))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17940,"user_id":null,"body":"(ns smiley)\n(defn count_smileys [arr]\n  (count (filter #(re-matches #\"^[:;][\\-~]?[)D]$\" %) arr)))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17941,"user_id":null,"body":"(ns smiley)\n\n(defn count_smileys [arr]\n  (->> arr\n       (filter #(re-matches #\"[:;][-~]{0,1}[\\)D]\" %))\n       (count)))\n","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17942,"user_id":null,"body":"(ns smiley)\n(defn count_smileys [arr]\n  (->> arr\n  (filter #(re-matches #\"[:;][-~]?[)D]\" %))\n  (count)))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17943,"user_id":null,"body":"(ns smiley)\n\n(defn count_smileys [arr]\n  (let [smiles (for [e [\":\" \";\"] n [\"-\" \"~\" \"\"] s [\")\" \"D\"]] (str e n s))]\n    (count (filter (fn [x] (some #(= x %) smiles)) arr))))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17944,"user_id":null,"body":"(ns smiley\n  (:require [clojure.core.reducers :as r]))\n(defn count_smileys [arr]\n  (r\/reduce \n  (fn \n    ([] 0) \n    ([count item] \n      (if (re-matches #\"[:;][-~]?[\\)D]\" item) \n        (inc count) \n        count))) arr))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17945,"user_id":571,"body":"(ns smiley)\n(defn count_smileys [arr]\n  (count (filter #(re-find #\"(:|;)(-|~)?(\\)|D)\" %) arr)))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"583ade15666df5a64e000058":[{"id":17946,"user_id":null,"body":"(ns kata)\n\n(defn evens_and_odds [n]\n  (if (odd? n) (Integer\/toString n 16) (Integer\/toString n 2))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17947,"user_id":168,"body":"(ns kata)\n\n(defn evens_and_odds [n]\n  (if (even? n) (Integer\/toString n 2) (format \"%x\" n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17948,"user_id":null,"body":"(ns kata)\n\n(defn evens_and_odds [n]\n  (if (even? n) (format \"%s\" (Integer\/toBinaryString n)) (format \"%x\" n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17949,"user_id":null,"body":"(ns kata)\n\n(defn evens_and_odds [n] (if (odd? n) (format \"%x\" n) (Integer\/toBinaryString n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17950,"user_id":null,"body":"(ns kata)\n\n(defn evens_and_odds [n]\n  (let [base (if (even? n) 2 16)]\n   (Integer\/toString n base)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17951,"user_id":null,"body":"(ns kata)\n\n(defn numeral-vec [base n]\n  (if (< n base)\n    [n]\n    (conj (numeral-vec base (quot n base)) (rem n base))))\n\n(defn numeral-str [base n]\n  (clojure.string\/join (map #(nth (seq \"0123456789abcdef\") %) (numeral-vec base n))))\n\n(defn evens_and_odds [n]\n  (numeral-str\n    (if (even? n) 2 16)\n    n))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17952,"user_id":53,"body":"(ns kata)\n\n(defn evens_and_odds [n]\n  (if (even? n) (Integer\/toString n 2) (Integer\/toString n 16))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17953,"user_id":527,"body":"(ns kata)\n\n(defn evens_and_odds [n]\n  (Long\/toString n (if (even? n) 2 16)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17954,"user_id":209,"body":"(ns kata)\n\n(defn evens_and_odds [n]\n  (Integer\/toString n (if (even? n) 2 16)) \n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17955,"user_id":null,"body":"(ns kata)\n\n(defn evens_and_odds [n]\n  (if (even? n)\n    (Integer\/toBinaryString n)\n    (Integer\/toHexString n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17956,"user_id":null,"body":"(ns kata)\n\n(def hex-conversion {0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9\n                     10 \"a\" 11 \"b\" 12 \"c\" 13 \"d\" 14 \"e\" 15 \"f\"})\n\n(defn evens_and_odds [n]\n    (let [evens (reverse (map #(rem % 2)\n                              (take-while #(> % 0)\n                                          (iterate (fn [n]\n                                                     (quot n 2)) n))))\n          odds (reverse (map #(rem % 16)\n                             (take-while #(> % 0)\n                                         (iterate (fn [n]\n                                                    (quot n 16)) n))))]\n      (if (even? n)\n        (apply str evens)\n        (apply str (map hex-conversion odds)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5848565e273af816fb000449":[{"id":17957,"user_id":null,"body":"(ns kata.core\n(:require [clojure.string :as str]))\n\n(defn encrypt_this [text] \n(->> (str\/split text #\" \")\n     (map (juxt (comp int first)\n                (comp last (partial drop 2))\n                (comp butlast (partial drop 2))\n                second))\n     (map flatten)\n     (map (partial apply str))\n     (str\/join \\space)))\n","lang_id":5,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17958,"user_id":null,"body":"(ns kata.core\n  (:require [clojure.string :refer [join split]]))\n\n(defn encrypt-word [word]\n  (case (count word)\n    0 \"\"\n    1 (-> word first int)\n    2 (str (-> word first int) (second word))\n    (let [one (-> word first int)\n          two (-> word last)\n          mid (-> word (subs 2 (- (count word) 1)))\n          end (-> word second)]\n      (str one two mid end))))\n    \n(defn encrypt_this [text]\n  (->> (split text #\" \")\n    (map encrypt-word)\n    (join \" \")))\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17959,"user_id":null,"body":"(ns kata.core\n  (:require [clojure.string :as str]))\n\n(defn single-letter? [s]\n  (= (count s) 1))\n\n(def swap (juxt last #(->> % (drop 1) butlast (apply str)) first))\n\n(defn first->last [s]\n  (let [f (if (single-letter? s) identity swap)]\n    (->> (f s) (apply str))))\n\n(defn encrypt [word]\n    (->> word \n         rest \n         first->last \n         (str \n          (->> word first int))))\n\n(defn encrypt_this [text] \n  (->> (str\/split text #\" \")\n    (map encrypt)\n    (str\/join #\" \")))\n","lang_id":5,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17960,"user_id":null,"body":"(ns kata.core\n  (:require [clojure.string :as str]))\n\n(defn encrypt-word [word]\n  (str\/join \"\",\n   (map-indexed\n    #(condp = %1\n       0, (int (.charAt %2 0))\n       1, (get word (- (count word) 1))\n       (- (count word) 1), (get word 1)\n        %2)\n    (str\/split word #\"\"))))\n\n(defn encrypt_this [text]\n  (str\/join \" \" (map encrypt-word (str\/split text #\" \"))\n))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17961,"user_id":62,"body":"(ns kata.core\n  (:require [clojure.string]))\n\n(defn encrypt_this [text] \n  (-> text\n    (clojure.string\/replace #\"\\b(\\w)(\\w)(\\w*)(\\w)\\b\"\n                            (fn [[_ first_ second_ middle_ last_]]\n                              (str first_ last_ middle_ second_)))\n    (clojure.string\/replace #\"\\b(\\w)\" (comp str int first fnext))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17962,"user_id":231,"body":"(ns kata.core)\n(require '[clojure.string :as str])\n\n(defn encrypt_this [text]\n  (defn encrypt-word [word]\n    (let [[lfirst lsecond & end] word\n          [llast & rmiddle] (reverse end)\n          middle (apply str (reverse rmiddle))]\n      (str (int lfirst) llast middle lsecond)))\n  (->> (str\/split text #\" \")\n       (map encrypt-word)\n       (str\/join \" \")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17963,"user_id":null,"body":"(ns kata.core\n  (:require [clojure.string :as s]))\n\n(defn encrypt-word [word]\n  (let [replaced (if (> (count word) 1)\n                   (apply str\n                          (assoc (into [] word)\n                                 1 (last word)\n                                 (dec (count word)) (get word 1)))\n                   word)]\n    (str (int (first replaced)) (apply str (rest replaced)))))\n\n(defn encrypt_this [st]\n  (->> (s\/split st #\" \")\n       (map encrypt-word)\n       (s\/join \" \")))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17964,"user_id":null,"body":"(ns kata.core\n  (:require [clojure.string :as str]))\n\n(defn swap-elements [arr idx1 idx2]\n  (let [new-val1 (arr idx2)\n        new-val2 (arr idx1)]\n    (assoc arr idx1 new-val1 idx2 new-val2)))\n\n(defn word-change [word]\n  (if (= 1 (count word))\n      (str (int (.charAt word 0)))\n    \n  (let [char-arr (vec (map char word))\n        first-char (int (char-arr 0))]\n        (->\n          char-arr    \n          (swap-elements 1 (dec (count word)))\n          (assoc 0 (str first-char))\n          (str\/join)   \n       ))))\n\n(defn encrypt_this [text] \n     \n  (str\/join #\" \" (map word-change (str\/split text #\" \")))\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17965,"user_id":null,"body":"(ns kata.core)\n\n(defn encrypt-word [word]\n  (def first-part (str (int (first word))))\n  (def last-part (str (second word)))\n  (def second-part (str (last word)))\n  (def middle-part (apply str (drop 2 (take (- (count word) 1) word))))\n\n  (cond\n    (= (count word) 1) (str first-part \" \")\n    (= (count word) 2) (str first-part second-part \" \")\n    :else (str first-part second-part middle-part last-part \" \"))\n)\n\n(defn encrypt_this [text]\n  (clojure.string\/trim (apply str (map #(encrypt-word %) (clojure.string\/split text #\" \"))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17966,"user_id":null,"body":"(ns kata.core\n  (:require [clojure.string :as str]))\n\n(defn ascii-first-char [s]\n  (str (int (first s)) (subs s 1)))\n\n(defn swap-second-and-last-char [s]\n  (if (< (count s) 3)\n    s\n    (let [svec (vec s)\n          c2 (nth s 1)\n          cl (last s)\n          svec2 (assoc svec 1 cl)\n          svec2 (assoc svec2 (dec (count svec)) c2)]\n      (apply str svec2))))\n\n(defn encrypt [word]\n  (-> word swap-second-and-last-char ascii-first-char))\n\n(defn encrypt_this [text]\n  (->> (str\/split text #\" \")\n       (map encrypt)\n       (str\/join \" \")))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5853213063adbd1b9b0000be":[{"id":17967,"user_id":null,"body":"(ns street-fighter)\n\n(defn street-fighter-selection [fighters position moves]\n  (let [moves-to-offsets {\"up\" [-1 0] \"down\" [1 0] \"left\" [0 -1] \"right\" [0 1]}\n        offsets (map #(moves-to-offsets %) moves)\n        move-position (fn [[x y] [dx dy]] [(max 0 (min 1 (+ x dx))) (mod (+ y dy) 6)])]\n    (map (fn [[r c]] ((fighters r) c)) (rest (reductions move-position position offsets)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17968,"user_id":53,"body":"(ns street-fighter)\n\n(defn scan [fun seed xs]\n  (reduce (fn [acc x] (conj acc (fun (peek acc) x))) [seed] xs))\n\n(defn dy [n]\n  (cond\n    (= n \"up\") -1\n    (= n \"down\") 1\n    :else 0))\n\n(defn dx [n]\n  (cond\n    (= n \"left\") -1\n    (= n \"right\") 1\n    :else 0))\n\n(defn circ6 [n]\n  (mod (+ (mod n 6) 6) 6))\n\n(defn move [p n]\n  (let [y (min (max (+ (nth p 0) (dy n)) 0) 1)\n        x (circ6 (+ (nth p 1) (dx n)))]\n  [y x]))\n\n(defn coords [xs p0 moves]\n  (scan (fn [p n] (move p n)) p0 moves))\n\n(defn elem2d [xs p]\n  (nth (nth xs (nth p 0)) (nth p 1)))\n\n(defn street-fighter-selection [xs p0 moves]\n  (doall (map (fn [p] (elem2d xs p)) (drop 1 (coords xs p0 moves)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17969,"user_id":null,"body":"(ns street-fighter)\n\n(defn figter-location [fighters [x y]]\n  (nth (nth fighters y) x))\n\n(defn new-position [[x y] move]\n  (cond\n    (= move \"up\") \n    (if (zero? y)\n      [x y]\n      [x (dec y)])\n    (= move \"down\")\n    (if (= y 1)\n      [x y]\n      [x (inc y)])\n    (= move \"left\")\n    (if (zero? x)\n      [5 y]\n      [(dec x) y])\n    (= move \"right\")\n    (if (= x 5)\n      [0 y]\n      [(inc x) y])))\n\n(defn street-fighter-selection [fighters position moves]\n    (loop [solution []\n           position position\n           moves moves]\n       (let [next-move (first moves)]\n         (if (nil? next-move)\n           solution\n           (let [position' (new-position position next-move)]\n           (recur \n              (conj solution (figter-location fighters position'))\n              position'\n              (rest moves)))))))\n              \n              ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17970,"user_id":null,"body":"(ns street-fighter)\n\n(def width 6)\n\n(def height 2)\n\n(def initial [0 0])\n\n(defn make-move [position move]\n  (let [[x y] position]\n    (cond\n      (= move \"left\")  [ (mod (dec x) 6) y ]\n      (= move \"right\") [ (mod (inc x) 6) y ]\n      (= move \"up\")    [ x 0 ]\n      (= move \"down\")  [ x 1 ])))\n\n(defn fighter-at [fighters position]\n  (let [[x y] position]\n    (get-in fighters [y x])))\n\n(defn street-fighter-selection [fighters position moves]\n  (loop [moves moves\n        position position\n        coll []]\n    (if (empty? moves)\n      coll\n      (let [position (make-move position (first moves))\n            fighter  (fighter-at fighters position)] \n        (recur  (rest moves)\n                position\n                (conj coll fighter) ) ) ) )) \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17971,"user_id":null,"body":"(ns street-fighter)\n\n(defn street-fighter-selection [fighters position moves]\n  (let [position (atom position)]\n    (->> moves\n         (map (fn [move]\n                (condp = move\n                  \"left\"  (swap! position update 1 #(if (= 0 %) 5 (dec %)))\n                  \"right\" (swap! position update 1 #(if (= 5 %) 0 (inc %)))\n                  \"up\"    (swap! position assoc 0 0)\n                  \"down\"  (swap! position assoc 0 1))))\n         (map #(get-in fighters %)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17972,"user_id":null,"body":"(ns street-fighter)\n\n(defn apply-move [m [x y]]\n  (condp = m\n    \"up\" [x 0]\n    \"down\" [x 1]\n    \"left\" [(if (pos? x) (- x 1) 5) y]\n    \"right\" [(if (< x 5) (+ x 1) 0) y]))\n    \n(defn pick [[x y] as]\n  ((as y) x))\n\n(defn street-fighter-selection [fighters position move]\n  (let [go (fn [[acc p] m]\n              (let [p1 (apply-move m p)]\n                [(conj acc (pick p1 fighters)) p1]))]\n    ((reduce go [[] position] move) 0)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17973,"user_id":null,"body":"(ns street-fighter)\n\n(defn apply-move [position move]\n  (let [moves {\"up\" [0 -1] \"left\" [-1 0] \"right\" [1 0] \"down\" [0 1]}]\n    [(mod (+ (get position 0) (get (get moves move) 0)) 6) \n     (max (min (+ (get position 1) (get (get moves move) 1)) 1) 0)]))\n\n(defn fighter-in-position [fighters position]\n  (get (get fighters (get position 1)) (get position 0)))\n\n(defn street-fighter-selection [fighters position move]\n  (if (== 0 (count move))\n    []\n    (let [new-pos (apply-move position (first move))]\n      (concat [(fighter-in-position fighters new-pos)] (street-fighter-selection fighters new-pos (rest move))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17974,"user_id":null,"body":"(ns street-fighter)\n\n(defn clamp [l u n]\n  (cond (< n l) l (> n u) u :else n))\n\n(defn street-fighter-selection [fighters position move]\n  (let [rows (count fighters)\n        cols (count (first fighters))]\n    (rest\n     (map\n      #(get-in fighters %)\n      (reductions\n       (fn [[i j] m]\n         (case m\n           \"left\"  [i (mod (dec j) cols)]\n           \"right\" [i (mod (inc j) cols)]\n           \"up\"    [(clamp 0 (dec rows) (dec i)) j]\n           \"down\"  [(clamp 0 (dec rows) (inc i)) j]))\n       position\n       move)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17975,"user_id":null,"body":"(ns street-fighter)\n\n(def dirs {\"left\"  [-1 0]\n           \"right\" [1  0]\n           \"up\"    [0 -1]\n           \"down\"  [0  1]})\n\n(defn bound-coords [coords]\n  (let [[x y] coords]\n    [(mod x 6)\n     (max 0 (min y 1))]))\n\n(defn street-fighter-selection [fighters position moves]\n    (second (reduce (fn [[xy out] mv]\n              (let [xy' (bound-coords (mapv + xy (dirs mv)))\n                   [x y] xy']\n               [xy' (conj out ((fighters y) x))]))\n             [position []] moves)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17976,"user_id":null,"body":"(ns street-fighter)\n\n(defn street-fighter-selection [fighters position moves]\n  (let [move-cursor\n        (fn [move pos]\n          (cond\n            (= move \"up\") [(max 0 (dec (first pos))) (second pos)]\n            (= move \"down\") [(min 1 (inc (first pos))) (second pos)]\n            (= move \"left\") [(first pos) (mod (dec (second pos)) 6)]\n            (= move \"right\") [(first pos) (mod (inc (second pos)) 6)]\n            :else \"impossible\"))\n        get-fighter\n        (fn [pos] (get (get fighters (first pos)) (second pos)))]\n    (->> (reductions (fn [p m] (move-cursor m p)) position moves)\n         (map get-fighter)\n         (rest))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"585ba66ce08bae791b00011b":[{"id":17977,"user_id":168,"body":"(ns kata)\n\n(defn index-finder[l x]\n  (+ 1 (.indexOf (rest l) x)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17978,"user_id":null,"body":"(ns kata)\n\n(defn index-finder[l x]\n  (+ 1 (first (for [[idx elt] (map-indexed vector (rest l)) :when (= x elt)] idx)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17979,"user_id":527,"body":"(ns kata)\n\n(defn index-finder [xs y]\n  (->> xs rest (keep-indexed #(when (= %2 y) %1)) first inc))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17980,"user_id":null,"body":"(ns kata)\n\n(defn index-finder[l x]\n  (inc (count (take-while #(not= x %) (rest l)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17981,"user_id":null,"body":"(ns kata)\n\n(defn index-finder\n  [l x]\n  (as->\n    l $\n    (map-indexed #(vector %1 %2) $)\n    (rest $)\n    (reduce\n      (fn\n        [acc [idx it]]\n        (if\n          (nil? acc)\n          (if\n            (= it x)\n            idx\n            nil)\n          acc))\n      nil\n      $)\n    ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17982,"user_id":null,"body":"(ns kata)\n\n(defn index-finder [l x]\n  (some #(when (= x (nth l %)) %) (rest (range))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17983,"user_id":null,"body":"(ns kata)\n\n(defn index-finder [l x] (inc (.indexOf (subvec (vec l) 1) x)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17984,"user_id":null,"body":"(ns kata)\n\n(defn index-finder[l xs]\n  (inc (.indexOf (rest l) xs)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17985,"user_id":201,"body":"(ns kata)\n\n(defn index-finder[l x]\n  (inc (.indexOf (rest l) x)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5868b2de442e3fb2bb000119":[{"id":17986,"user_id":null,"body":"(ns closest.core\n  (:require [clojure.string :as s]))\n\n(defn weight [num]\n  (reduce + (map #(Integer\/parseInt %) (s\/split num #\"\"))))\n\n(defn weight-diff [pair] (- (first (second pair)) (ffirst pair)))\n\n(defn closest [str]\n  (if (empty? str) '([] [])\n    (->> (s\/split str #\"\\s\")\n    (map-indexed (fn [idx n] [(weight n) idx (Integer\/parseInt n)]))\n    (sort-by first)\n    (partition 2 1)\n    (reduce (fn [min next]\n              (if (> (weight-diff min) (weight-diff next)) next min))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17987,"user_id":492,"body":"(ns closest.core)\n(require '[clojure.string :as str])\n\n(defn sum-digit [n]\n  (reduce + (map #(Character\/digit % 10) (str n))))\n(defn compsort [a b]\n  (let [x (- (a 0) (b 0))]\n    (if (= 0 x)\n      (compare (a 1) (b 1))\n      x)))\n(defn closest [strng]\n  (if (= strng \"\")\n    (list [][])\n    (let [\n          s (str\/split strng #\" \")\n          v (map vector s (range 0 (count s)))\n          l (vec (sort compsort (map (fn [[n i]] (vector (sum-digit n) i (read-string n))) v)))\n          r (vec (sort compsort (map (fn [i] (vector (- ((l i) 0) ((l (- i 1)) 0)) i)) (range 1 (count l))))) \n          x ((r 0) 1)        \n        ]\n      (list (l (- x 1)) (l x))\n    )))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17988,"user_id":null,"body":"(ns closest.core)\n\n(defn w [s] (apply + (map #(Character\/digit % 10) s))) ;; weight\n(defn d [a b] (Math\/abs (- (:w a) (:w b))))            ;; distance\n(defn m [kw xs] (\/ (apply + (get xs kw [])) 2))        ;; mean\n\n\n(defn closest [strng]\n  (if (empty? strng) [[] []]\n  (let [xs (map-indexed (fn [idx x] {:w (w x), :idx idx :x (Integer\/parseInt x)})\n                        (clojure.string\/split strng #\"\\W\"))]\n    (->> \n      (for [a xs, b xs\n            :when (< (:idx a) (:idx b))]\n        {:d (d a b)\n         :ws [(:w a) (:w b)]\n         :idx [(:idx a) (:idx b)]\n         :xs [(:x a) (:x b)]})\n      (sort-by (juxt :d (partial m :ws) (partial m :idx))) ;; any idea to use min-key instead?\n      first\n      ((fn [{:keys [ws idx xs]}]\n         (sort[(mapv first [ws idx xs])\n               (mapv second [ws idx xs])])))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17989,"user_id":null,"body":"(ns closest.core)\n\n(defn digits [nb] (if (pos? nb) (conj (digits (quot nb 10)) \n                                      (mod nb 10)) []))\n(defn pairs [ls] (partition 2 (interleave ls  (rest ls))))\n(defn weights [strng]\n  (letfn [(weight [nb] (apply + (digits nb)))]\n    (keep-indexed #(vector (weight %2) %1 %2)\n                  (map read-string (clojure.string\/split strng #\" \")))))\n\n(defn closest [strng]\n  (if (seq strng)\n    (->> strng\n      weights \n      sort \n      pairs\n      (map (fn [[f s]] [(- (first s) (first f)) f s]))\n      sort\n      first \n      rest)\n    (list [] [])\n    ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17990,"user_id":null,"body":"(ns closest.core)\n\n(defn digits [n]\n  (map (comp read-string str) (str n)))\n\n(defn closest [strng]\n  (if (empty? strng)\n    [[] []]\n    (->> (clojure.string\/split strng #\" \")\n         (map read-string)\n         (map-indexed #(vector (reduce + (digits %2)) %1 %2 ))\n         (sort-by first)\n         (partition 2 1)\n         (sort-by (juxt (fn [[a b]]\n                          (- (first b) (first a)))\n                        (fn [[a b]]\n                          (+ (first b) (first a)))\n                        (fn [[a b]]\n                          (+ (second b) (second a)))))\n         first))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17991,"user_id":null,"body":"(ns closest.core)\n(defn weight [n]\n  (if (= 0 n) 0\n    (+ (mod n 10) (weight (quot n 10)))))\n(defn find-closest [s]\n  (->> (clojure.string\/split s #\" \")\n      (map #(Integer\/parseInt %))\n      (map-indexed (fn [i n] [(weight n) i n]))\n      (sort-by first)\n      (partition 2 1)\n      (reduce (fn [[[wa] [wb] :as ab] [[wx] [wy] :as xy]]\n                (if (<= (- wb wa) (- wy wx)) ab xy)))))\n(defn closest [strng]\n  (if (= \"\" strng) '([] []) (find-closest strng)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17992,"user_id":null,"body":"(ns closest.core)\n(defn weight [n]\n  (if (= 0 n) 0\n    (+ (mod n 10) (weight (quot n 10)))))\n(defn find-closest [s]\n  (->> (clojure.string\/split s #\" \")\n      (map #(Integer\/parseInt %))\n      (map (fn [i n] [(weight n) i n]) (range))\n      (sort (fn [[wa] [wb]] (< wa wb)))\n      (#(map list % (rest %)))\n      (reduce (fn [[[wa] [wb] :as ab] [[wx] [wy] :as xy]]\n                (if (<= (- wb wa) (- wy wx)) ab xy)))))\n(defn closest [strng]\n  (if (= \"\" strng) '([] []) (find-closest strng)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17993,"user_id":null,"body":"(ns closest.core)\n\n(defn abs [n] (max n (-' n)))\n\n(defn- weight [s]\n  (->> s (map (comp read-string str)) (reduce +)))\n\n(defn- comp-fn [a b]\n  (let [cond-1 (compare (:diff a) (:diff b))\n        cond-2 (compare (apply + (:weights a)) (apply + (:weights b)))\n        cond-3 (compare (apply + (:edge a)) (apply + (:edge b)))]\n    (cond\n      (not (zero? cond-1)) cond-1\n      (not (zero? cond-2)) cond-2\n      (not (zero? cond-3)) cond-3\n      :else 0)))\n\n(defn closest [s]\n  (if (empty? s)\n    [[] []]\n    (let [spl (clojure.string\/split s #\" \")\n          xs  (map read-string spl)\n          ws  (map weight spl)\n          res (sort\n               comp-fn\n               (mapcat\n                (fn [i w1]\n                  (map\n                   (fn [j w2]\n                     {:diff    (abs (- w1 w2))\n                      :weights [w1 w2]\n                      :edge    [i j]\n                      :nums    [(nth xs i) (nth xs j)]})\n                   (range (inc i) (count ws)) (drop (inc i) ws)))\n                (range) (drop-last ws)))\n          {:keys [weights edge nums]} (first res)]\n      (sort-by first (map vector weights edge nums)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17994,"user_id":null,"body":"(ns closest.core)\n\n(defn- weight [s]\n       (->> s\n         (map #(Character\/digit % 10))\n         (reduce +))\n       )\n\n(defn closest [strng]\n  (if (empty? strng)\n    [[] []]\n    (let [numsStr (vec (re-seq #\"\\d+\" strng))\n          nums    (vec (map #(Long\/valueOf %) numsStr))\n          weights (vec (map weight numsStr))\n          l (count nums)\n          pairs (apply concat \n                       (for [i1 (range l)\n                             :let [w1 (weights i1)\n                                   n1 (nums i1)]]\n                         (for [i2 (range (inc i1) l)\n                               :let [w2 (weights i2)\n                                     n2 (nums i2)]]\n                           {:res  [[w1 i1 n1] [w2 i2 n2]]\n                            :wDif (Math\/abs (- w2 w1))\n                            :wSum (+ w1 w2)\n                            :iSum (+ i1 i2)}\n                           )))\n          sorted  (->> pairs\n                    (sort-by :iSum)\n                    (sort-by :wSum)\n                    (sort-by :wDif)\n                    )\n          ]\n      (sort-by first (:res (first sorted)))\n      )\n    )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17995,"user_id":null,"body":"(ns closest.core\n  (:require [clojure.string :as str]))\n\n(defn parse-int\n  [s]\n  (if (empty? s) 0 (Integer\/parseInt s)))\n\n(defn calc-weight\n  [s]\n  (->>\n    (str\/split s #\"\")\n    (map parse-int)\n    (reduce +)))\n\n(defn weight [[x _ _ ]] x)\n\n(defn index [[_ x _]] x)\n\n(defn weight-difference\n  [[x y]]\n  (Math\/abs (- (weight x) (weight y))))\n\n(defn total-weights\n  [[x y]]\n  (+ (weight x) (weight y)))\n\n(defn closest [strng]\n  (let [weighted-vals (into []\n                        (map-indexed\n                         (fn [idx v] [(calc-weight v) idx (parse-int v)]))\n                        (str\/split strng #\"\\s+\"))\n        val-count (count weighted-vals)]\n    (if (= val-count 1)\n      '([] [])\n      (->> \n        (for [x-idx (range 0 val-count)\n              y-idx (range (inc x-idx) val-count)\n              :when (< x-idx y-idx)]\n          [(get weighted-vals x-idx) (get weighted-vals y-idx)])\n        (sort-by\n         (juxt weight-difference total-weights index))\n        first\n        (sort-by weight)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5879f95892074d769f000272":[{"id":17996,"user_id":492,"body":"(ns biker.core)\n\n(def ^:const gravity_acc (* 9.81 3.6 60.0))          ; gravity acceleration\n(def ^:const drag (\/ (* 60.0 0.3) 3.6))              ; force applied by air on the cyclist\n(def ^:const delta_t (\/ 1.0 60.0))                   ; in minutes\n(def ^:const d_watts 0.5)                            ; power loss in Watts \/ minute\n(def ^:const g_thrust (* 60.0 3.6 3.6))              ; acceleration due to biker's power\n(def ^:const mass 80.0)                              ; biker's mass\n(def ^:const watts0 225)                             ; initial biker's power\n    \n(defn- temps_aux [v, slope, d_tot, d, t, watts]\n  (cond\n    (<= (- v 3.0) 1e-2) -1\n    (> d d_tot) (Math\/round t)\n    :else\n    (let [slope_gravity_acc (* (- 1) gravity_acc (Math\/sin (Math\/atan (\/ slope 100.0))))\n          tt (+ t delta_t)\n          wwatts (- watts (* d_watts delta_t))\n          gamma (- slope_gravity_acc (\/ (* drag (Math\/abs v) (Math\/abs v)) mass))\n          ggamma (if (and (> wwatts 0.0) (> v 0.0)) \n                   (+ gamma (\/ (* g_thrust wwatts) (* v mass)))\n                   gamma)\n          vv (if (<= (Math\/abs ggamma) 1e-5)\n               v\n               (+ v (* ggamma delta_t)))\n          dd (+ d (* v (\/ delta_t 60.0)))\n         ]\n      (recur vv slope d_tot dd tt wwatts)))) \n          \n(defn temps [v0 slope d_tot]\n  (temps_aux v0 slope d_tot 0.0 0.0 watts0))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17997,"user_id":null,"body":"(ns biker.core)\n\n(def g 9.81)\n(def dc -0.3)\n(def dt 1.0)\n(def gt 1)\n(def m 80.0)\n(def w0 225.0)\n(def dw (\/ 0.5 60))\n\n(defn a1 [slope] (let [z (\/ slope 100)] (\/ (* -1 g z) (Math\/sqrt (+ 1.0 (* z z))))))\n(defn a2 [v] (\/ (* dc v v) m))\n(defn a3 [p v] (if (and (pos? p) (pos? v)) (\/ (* gt p) (* v m)) 0))\n(defn acc [sa p v]\n  (+ sa (a2 v) (a3 p v)))\n\n(defn convert-to-sane-units [v d mina]\n  [(\/ v 3.6) (* d 1000) (\/ mina 3.6 60)])\n\n(defn temps [v0 slope d_tot]\n  (let [[v0 d_tot mina] (convert-to-sane-units v0 d_tot 1e-5)\n        sa (a1 slope)]\n    (loop [t 0.0 v v0 w w0 d 0.0]\n      (cond\n        (<= (- (* 3.6 v) 3.0) 1e-2) -1\n        (>= d d_tot) (Math\/round (double (\/ t 60)))\n        :else (let [a (double (acc sa w v))\n                    a (if (<= (Math\/abs a) mina) 0 a)]\n                (recur (+ t dt) (+ v (* a dt)) (- w dw) (+ d (* v dt))))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":17998,"user_id":492,"body":"(ns biker.core)\n\n(def ^:const gravity_acc (* 9.81 3.6 60.0))          ; gravity acceleration\n(def ^:const drag (\/ (* 60.0 0.3) 3.6))              ; force applied by air on the cyclist\n(def ^:const delta_t (\/ 1.0 60.0))                   ; in minutes\n(def ^:const d_watts 0.5)                            ; power loss in Watts \/ minute\n(def ^:const g_thrust (* 60.0 3.6 3.6))              ; acceleration due to biker's power\n(def ^:const mass 80.0)                              ; biker's mass\n(def ^:const watts0 225)                             ; initial biker's power\n    \n(defn- temps_aux [v, slope, d_tot, d, t, watts]\n  (cond\n    (<= (- v 3.0) 1e-2) -1\n    (> d d_tot) (Math\/round t)\n    :else\n    (let [slope_gravity_acc (* (- 1) gravity_acc (Math\/sin (Math\/atan (\/ slope 100.0))))\n          tt (+ t delta_t)\n          wwatts (- watts (* d_watts delta_t))\n          gamma (- slope_gravity_acc (\/ (* drag (Math\/abs v) (Math\/abs v)) mass))\n          ggamma (if (and (> wwatts 0.0) (> v 0.0)) \n                   (+ gamma (\/ (* g_thrust wwatts) (* v mass)))\n                   gamma)\n          vv (if (<= (Math\/abs ggamma) 1e-5)\n               v\n               (+ v (* ggamma delta_t)))\n          dd (+ d (* v (\/ delta_t 60.0)))\n         ]\n      (recur vv slope d_tot dd tt wwatts)))) \n          \n(defn temps [v0 slope d_tot]\n  (temps_aux v0 slope d_tot 0.0 0.0 watts0))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"588417e576933b0ec9000045":[{"id":17999,"user_id":null,"body":"(ns kata.seats_in_theater)\n(defn seats_in_theater [n-cols n-rows col row]\n  (let [cols-left (inc (- n-cols col))\n        rows-left (- n-rows row)]\n    (* cols-left rows-left)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18000,"user_id":527,"body":"(ns kata.seats_in_theater)\n\n(defn seats_in_theater [n-cols n-rows col row]\n  (* (inc (- n-cols col)) (- n-rows row)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18001,"user_id":50,"body":"(ns kata.seats_in_theater)\n(defn seats_in_theater [a b c d]\n  (* (+ (- a c) 1) (- b d) )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18002,"user_id":1703,"body":"(ns kata.seats_in_theater)\n(defn seats_in_theater [nCols nRows col row]\n  (* (- nRows row) (+ 1 (- nCols col)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18003,"user_id":713,"body":"(ns kata.seats_in_theater)\n(defn seats_in_theater [nc nr c r]\n  (* (+ (- nc c) 1) (- nr r))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18004,"user_id":null,"body":"(ns kata.seats_in_theater)\n(defn seats_in_theater [n-cols n-rows col row]\n  (* (+ 1 (- n-cols col)) (- n-rows row)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18005,"user_id":null,"body":"(ns kata.seats_in_theater)\n(defn seats_in_theater [n-cols n-rows col row]\n  (let [m (- n-cols (dec col))\n        n (- n-rows row)]\n    (* m n)\n    )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18006,"user_id":null,"body":"(ns kata.seats_in_theater)\n(defn seats_in_theater [a b c d]\n  (* (inc (- a c)) (- b d) )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18007,"user_id":null,"body":"(ns kata.seats_in_theater)\n(defn seats_in_theater [n_cols n_rows col row]\n  (* (inc (- n_cols col)) (- n_rows row))\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18008,"user_id":null,"body":"(ns kata.seats_in_theater)\n(defn seats_in_theater [n-cols n-rows col row]\n  ;; bad problem. it doesn't count people in same row\n  (* (- n-cols (dec col)) (- n-rows row)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"58841cb52a077503c4000015":[{"id":18009,"user_id":null,"body":"(ns circle_of_numbers)\n\n(defn circle_of_numbers\n  [n x]\n  (rem (+ x (quot n 2)) n))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18010,"user_id":null,"body":"(ns circle_of_numbers)\n\n(defn circle_of_numbers\n  [n first-number]\n  (rem (+ first-number (\/ n 2)) n)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18011,"user_id":null,"body":"(ns circle_of_numbers)\n\n(defn circle_of_numbers\n  [n first-number]\n  ; code here\n  (let [mid (quot n 2)\n        left (+ first-number mid)\n        right (- first-number mid)]\n    (if (< left n) \n      left\n      right))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18012,"user_id":null,"body":"(ns circle_of_numbers)\n\n(defn circle_of_numbers [number first-number]\n  (rem (+ first-number (\/ number 2)) number))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18013,"user_id":null,"body":"(ns circle_of_numbers)\n\n(defn circle_of_numbers\n  [n first-number]\n  (rem (+ first-number (quot n 2)) n)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18014,"user_id":null,"body":"(ns circle_of_numbers)\n\n(defn circle_of_numbers [n first-number]\n  (let [a (+ first-number (\/ n 2))]\n    (if (< a n) a (- a n))\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18015,"user_id":null,"body":"(ns circle_of_numbers)\n\n(defn circle_of_numbers\n  [n first-number]\n  (if (< first-number (\/ n 2))\n    (+ first-number (\/ n 2))\n    (- first-number (\/ n 2))\n  ))\n  \n   ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18016,"user_id":null,"body":"(ns circle_of_numbers)\n\n(defn circle_of_numbers [n first-number]\n  (let [times (+ first-number (\/ n 2))]\n    (mod times n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18017,"user_id":null,"body":"(ns circle_of_numbers)\n\n(defn circle_of_numbers [n first-number]\n  (if (>= first-number (\/ n 2))\n    (- first-number (\/ n 2))\n    (+ first-number (\/ n 2))\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18018,"user_id":null,"body":"(ns circle_of_numbers)\n\n(defn circle_of_numbers\n  [n first-number]\n  {:pre [(and (integer? n) (>= n 4) (<= n 1000) (even? n))\n         (and (>= first-number 0) (<= first-number (- n 1)))]}\n  (let [half (\/ n 2)]\n    (if (< first-number half)\n      (+ half first-number)\n      (- first-number half))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"588422ba4e8efb583d00007d":[{"id":18019,"user_id":null,"body":"(ns kata.late_ride)\n\n(defn late_ride [n] (reduce + (map read-string (map str (seq (str (quot n 60) (rem n 60)))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18020,"user_id":null,"body":"(ns kata.late_ride)\n(defn sum [n]\n  (->>\n    n\n    (iterate #(quot % 10))\n    (take-while pos?)\n    (mapv #(mod % 10))\n    (rseq)\n  )\n)\n\n(defn late_ride [n]\n  (let [hours (quot n 60) minutes (rem n 60)]\n    (+ (reduce + (sum hours)) (reduce + (sum minutes)))\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18021,"user_id":null,"body":"(ns kata.late_ride)\n(defn late_ride [n]\n  (let [hours (quot (- n (rem n 60)) 60)\n        minutes (rem n 60)]\n    (+\n      (reduce + (->> hours str (map (comp read-string str))))\n      (reduce + (->> minutes str (map (comp read-string str)))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18022,"user_id":null,"body":"(ns kata.late_ride)\n\n(defn late_ride [n]\n  (let [h (int (\/ n 60)) m (rem n 60)]\n    (reduce + (map #(read-string (str %)) (str h m))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18023,"user_id":645,"body":"(ns kata.late_ride)\n(defn late_ride [n]\n  (reduce + 0 (map #(Character\/digit % 10) (seq (str (int (\/ n 60)) (mod n 60))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"58941fec8afa3618c9000184":[{"id":18024,"user_id":53,"body":"(ns kata)\n(defn growing_plant [up-speed down-speed desired-height]\n  (max 1 (int (Math\/ceil (\/ (- desired-height down-speed) (- up-speed down-speed))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18025,"user_id":501,"body":"(ns kata)\n(defn growing_plant [u d h]\n   (loop [v u i 1]\n    (if (>= v h)\n        i \n       (recur (+ u (- v d)) (inc i)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18026,"user_id":645,"body":"(ns kata)\n(defn growing_plant [up down h]\n  (max 1 (int (Math\/ceil (\/ (- h down) (- up down))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18027,"user_id":null,"body":"(ns kata)\n(defn growing_plant [up-speed down-speed desired-height]\n  (loop [h 0\n         d 1]\n    (let [H (+ h up-speed)]\n      (if (>= H desired-height)\n        d\n        (recur (- H down-speed) (inc d))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18028,"user_id":null,"body":"(ns kata)\n(defn growing_plant [up-speed down-speed desired-height]\n  (int (Math\/ceil (\/ (count (take-while #(< (first %) desired-height) \n              (iterate \n               (fn [[height grow]] [(if grow (+ height up-speed) (- height down-speed)) (not grow)])\n               [0 true]))) 2))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18029,"user_id":null,"body":"(ns kata)\n(defn growing_plant [up-speed down-speed desired-height]\n  (let [us (repeat up-speed)\n        ds (repeat (unchecked-negate-int down-speed))\n        schedule (interleave us ds)\n        totals (reductions + schedule)\n        ticks (take-while (partial > desired-height) totals)]\n    (inc (\/ (count ticks) 2))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18030,"user_id":null,"body":"(ns kata)\n(defn growing_plant [up-speed down-speed desired-height]\n   (loop [height 0 days 1]\n     (if (>= (+ height up-speed) desired-height)\n       days\n       (recur (- (+ height up-speed) down-speed) (inc days))\n     )\n   )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18031,"user_id":null,"body":"(ns kata)\n\n(defn growing_plant [up-speed down-speed desired-height]\n  (loop [height 0\n          day 1]\n  (if (<= desired-height (+ up-speed height))\n    day\n    (recur \n      (+ \n        height \n        (- up-speed down-speed)) \n      (inc day)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18032,"user_id":null,"body":"(ns kata)\n\n\n(defn growing_plant [up-speed down-speed desired-height]\n  (loop [day 1 heigt 0]\n    (if (>=  (+ heigt up-speed) desired-height)\n      day\n      (recur (inc day)(- (+ heigt up-speed) down-speed)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18033,"user_id":null,"body":"(ns kata)\n\n(defn growing_plant [up-speed down-speed desired-height]\n  (letfn [(grow [size days]\n            (if (>= (+ size up-speed) desired-height)\n              (inc days)\n              (let [new-speed (+ up-speed (- size down-speed))\n                    new-days (inc days)]\n                (grow new-speed new-days))))]\n    (if (>= up-speed desired-height)\n      1\n      (grow 0 0))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5898b4b71d298e51b600014b":[{"id":18034,"user_id":294,"body":"(ns kata.sort_the_inner_content\n  (require [clojure.string :as string]))\n\n(declare sort-inner-str)\n\n(defn sort_the_inner_content [words]\n  (let [format-str    (string\/replace words #\"\\S+\" \"%s\")\n        words-trimmed (string\/trim words)]\n       (->> (string\/split words-trimmed #\"\\s+\")\n            (map sort-inner-str)\n            (apply (partial format format-str)))))\n\n(defn- sort-inner-str [s]\n  (if (<= (count s) 2) s\n      (str (first s)\n           (-> s (rest) (butlast) (sort) (reverse) (string\/join))\n           (last s))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18035,"user_id":null,"body":"(ns kata.sort_the_inner_content\n  (:require [clojure.string :as str]))\n\n(defn apply-to-words [words f]\n  (map f (re-seq #\"\\w+|\\s+\" words)))\n\n(defn reverse-word [w]\n  (let [len (count w)]\n    (cond\n      (or (<= len 3) (str\/blank? w)) w\n      :else (let [f (first w)\n                  l (last w)\n                  middle (subvec (vec w) 1 (- len 1))]\n              (apply str (concat [f] (sort #(compare %2 %1) middle) [l]))))))\n\n\n(defn sort_the_inner_content [words]\n  (let [rev-words (apply-to-words words reverse-word)]\n    (str\/join rev-words)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18036,"user_id":null,"body":"(ns kata.sort_the_inner_content\n  (:require [clojure.string :as str]))\n  \n(defn fix-word [word]\n  (if (<= (count word) 3)\n    word\n    (str (first word) (apply str (reverse (sort (subs word 1 (- (count word) 1))))) (last word)))\n  )\n\n(defn sort_the_inner_content [words]\n  (str\/replace words #\"\\w+\" #(fix-word %1))\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18037,"user_id":null,"body":"(ns kata.sort_the_inner_content)\n\n(defn sort-word [[_ f mid l]]\n  (let [mid (clojure.string\/join \"\" (reverse (sort mid)))]\n      (str f mid l)))\n\n(defn sort_the_inner_content [words]\n  (clojure.string\/replace words #\"(\\w)(\\w+)(\\w)\" sort-word))\n  \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18038,"user_id":null,"body":"(ns kata.sort_the_inner_content (:require [clojure.string :as st]))\n\n(defn sort-string [s]\n  (st\/reverse (apply str (sort s))))\n\n(defn inner-stuff [s]\n  (if (> (count s) 3)\n    (str (first s) (sort-string (subs s 1 (->> s count dec))) (last s))\n    s))\n\n(defn sort_the_inner_content [s]\n  (println s)\n  (st\/replace s #\"\\w+\" inner-stuff))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18039,"user_id":62,"body":"(ns kata.sort_the_inner_content)\n(require 'clojure.string)\n(defn sort_the_inner_content [s]\n  (clojure.string\/replace \n   s #\"\\b(\\w)(\\w*)(\\w)\\b\"  \n   #(str (% 1) (apply str (reverse (sort (% 2)))) (% 3) )))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18040,"user_id":53,"body":"(ns kata.sort_the_inner_content\n  (require [clojure.string :refer [replace trim join split]]))\n\n(defn- kata [s]\n  (if (<= (count s) 2) s\n      (str (first s)\n           (-> s (rest) (butlast) (sort) (reverse) (join))\n           (last s))))\n\n(defn sort_the_inner_content [words]\n  (let [a    (replace words #\"\\S+\" \"%s\")\n        b (trim words)]\n       (->> (split b #\"\\s+\")\n            (map kata)\n            (apply (partial format a)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18041,"user_id":null,"body":"(ns kata.sort_the_inner_content)\n\n(defn sort_the_inner_content [words]\n  (print)\n  (let [splitted-words (clojure.string\/split words #\" \")\n        trailing-spaces (clojure.string\/join\n                         (take-while (fn [el] (= el \" \"))\n                                     (reverse (clojure.string\/split\n                                               words\n                                               #\"\"))))\n        sorter (fn [el]\n                 (if (= (count el) 1)\n                   el\n                   (str (first el)\n                        (clojure.string\/join\n                         (sort\n                          (comp - compare)\n                          (drop 1 (drop-last 1 el))))\n                        (last el))))]\n    (str (clojure.string\/join \" \" (map sorter splitted-words))\n         (str trailing-spaces))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18042,"user_id":null,"body":"(ns kata.sort_the_inner_content)\n\n(defn sort_the_inner_content [words]\n  (clojure.string\/replace words\n                          #\"(\\w)(\\w+)(\\w)\"\n                          (fn [[_ a b c]] (str a (apply str (reverse (sort b))) c))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18043,"user_id":null,"body":"(ns kata.sort_the_inner_content\n  (:require [clojure.string :as str]))\n\n(defn sort-inner [text]\n  (if (< (count text) 2)\n    [text text]\n    [text (str (first text)\n               (apply str (reverse (sort (butlast (rest text)))))\n               (last text))]))\n\n(defn sort_the_inner_content [words]\n  (->> (re-seq #\"\\w+\" words)\n       (map sort-inner)\n       (reduce (fn [acc re] (str\/replace acc (first re) (second re))) words)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"58acfe4ae0201e1708000075":[{"id":18044,"user_id":null,"body":"(ns kata)\n(defn invite_more_women\n  [attendees]\n  (pos? (reduce + attendees)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18045,"user_id":null,"body":"(ns kata)\n(defn invite_more_women [L]\n  (->> L\n       (reduce +)\n       (< 0)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18046,"user_id":571,"body":"(ns kata)\n(defn invite_more_women [L]\n  (< 0 (reduce + L)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18047,"user_id":527,"body":"(ns kata)\n\n(defn invite_more_women [L]\n  (pos? (apply + L)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18048,"user_id":null,"body":"(ns kata)\n\n(defn how-many-of? [n x]\n  (count (filter (partial = n) x)))\n  \n  \n(defn invite_more_women [L]\n  (<\n    (how-many-of? -1 L)\n    (how-many-of? 1 L)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18049,"user_id":527,"body":"(ns kata)\n\n(def invite_more_women (comp pos? (partial apply +)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18050,"user_id":null,"body":"(ns kata)\n\n(defn invite_more_women [L]\n  (if (>= 0 (reduce + L)) false\n                          true))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18051,"user_id":null,"body":"(ns kata)\n(defn invite_more_women [L]\n  (let [sum (reduce (fn[acc n] (+ acc n)) 0 L)]\n    (if (> sum 0)\n      true\n      false)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18052,"user_id":201,"body":"(ns kata)\n(defn invite_more_women [L]\n  (let [women (count (filter #(= -1 %) L))\n      men (- (count  L) women)]\n  (< women men)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18053,"user_id":null,"body":"(ns kata)\n(defn invite_more_women [L]\n  (> (apply + L) 0))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"58b03e48a965cb194f0002bd":[{"id":18054,"user_id":527,"body":"(ns gradient)\n\n(defn gradient-fn\n  \"Returns a function that interpolates RGB values according to a gradient definition\"\n  [a b]\n  (fn [w]\n    (let [w (\/ w 100) w' (- 1 w)]\n      (mapv #(int (+ (* %1 w') (* %2 w))) a b))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18055,"user_id":null,"body":"(ns gradient)\n\n(defn gradient-fn [a b]\n  (fn [x]\n    (map \n      #(int (+ %1 (* (- %2 %1) (\/ x 100))))\n    a b)\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18056,"user_id":null,"body":"(ns gradient)\n\n\n(defn interpolate [from to percent]\n  (-> (- to from)\n      (* percent)\n      (\/ 100)\n      (+ from)\n      int))\n\n(defn gradient-fn\n  \"Returns a function that interpolates RGB values according to a gradient definition\"\n  [a b]\n  (fn [p]\n    (->>\n     (repeat p)\n     (take 3)\n     (map interpolate a b)\n     vec)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18057,"user_id":null,"body":"(ns gradient)\n(defn gradient-fn\n  [a b]\n  #(map (fn [col-a col-b]\n         (int (+ col-a \n                 (* (\/ % 100) \n                    (- col-b col-a))))) \n       a b))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18058,"user_id":null,"body":"(ns gradient)\n(defn gradient-fn [a b]\n  (fn [x]\n    (->> (map - b a)\n         (map #(* % (\/ x 100)))\n         (map + a)\n         (map int))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18059,"user_id":null,"body":"(ns gradient)\n(defn gradient-fn\n  \"Returns a function that interpolates RGB values according to a gradient definition\"\n  [a b]\n  (let [v (mapv - b a)]\n    (fn [x] (mapv + a (mapv #(int (Math\/floor (* x 0.01 %))) v)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18060,"user_id":null,"body":"(ns gradient)\n\n(defn gradient-items [a, b, value]\n    (int (Math\/floor (+ a (* (\/ value 100) (- b a))))))\n\n(defn gradient-fn\n  \"Returns a function that interpolates RGB values according to a gradient definition\"\n  [a b]\n  #(for [x [0, 1, 2]]\n         (gradient-items (get a x) (get b x) %) )\n)\n; a - b","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18061,"user_id":201,"body":"(ns gradient)\n\n(defn gradient-fn\n  \"Returns a function that interpolates RGB values according to a gradient definition\"\n  [a b]\n  (let [[r1 g1 b1] a\n        [r2 g2 b2] b]\n    (fn [x]\n      [(int (Math\/floor (+ r1 (\/ (* x (- r2 r1)) 100.0))))\n       (int (Math\/floor (+ g1 (\/ (* x (- g2 g1)) 100.0))))\n       (int (Math\/floor (+ b1 (\/ (* x (- b2 b1)) 100.0))))])))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18062,"user_id":null,"body":"(ns gradient)\n\n(defn gradient-fn\n  \"Returns a function that interpolates RGB values according to a gradient definition\"\n  [a b]\n  (fn [n]\n    (map\n     (fn [av bv]\n       (if (- bv av)\n         (+ av (int (Math\/floor (* (\/ n 100) (- bv av)))))\n         av))\n     a b)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18063,"user_id":null,"body":"(ns gradient)\n(defn gradient-fn\n  \"Returns a function that interpolates RGB values according to a gradient definition\"\n  [a b]\n  (fn [x]\n    (vec\n      (map\n         (fn [z y] (int (Math\/floor (+ (* y (\/ x 100.0)) (* z (- 1.0 (\/ x 100.0))) 0.01))))\n         a\n         b\n      )\n     )))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"58b57ae2724e3c63df000006":[{"id":18064,"user_id":null,"body":"(ns parse-html-color.core\n  (:require [parse-html-color.preset :refer [preset-colors]])\n  (:use [clojure.string :only [lower-case join]]))\n\n(defn hex-color [possibly-color-name]\n  \"Expects color name and returns its hex representation, otherwise garbage-in, garbage-out\"\n  (get preset-colors (lower-case possibly-color-name) possibly-color-name))\n\n(defn hex3->hex6 [hex]\n  (let [rgb-char-list (rest hex)]\n    (if (= (count rgb-char-list) 3)\n      (str \"#\" (join (interleave rgb-char-list rgb-char-list)))\n      hex)))\n\n(defn hex->rgb [hex]\n  (let [color (java.awt.Color\/decode (hex3->hex6 hex))]\n    {\n      :r (. color getRed)\n      :g (. color getGreen)\n      :b (. color getBlue)\n    }))\n\n(defn parse-html-color [col]\n  (hex->rgb (hex-color col)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18065,"user_id":null,"body":"(ns parse-html-color.core\n  (:require [parse-html-color.preset :refer [preset-colors]])\n  (:require [clojure.string :refer [lower-case join]])\n  (:require [clojure.edn]))\n\n(defn parse-color [color]\n  (->> (if (= (count color) 3)\n        (map #(list % %) color)\n        (partition 2 color))\n      (map #(concat \"0x\" %))\n      (map join)\n      (map clojure.edn\/read-string)\n      (interleave [:r :g :b])\n      (apply assoc {})))\n\n(defn parse-html-color [color]\n  (-> (get preset-colors (lower-case color) color)\n      (rest)\n      (parse-color)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18066,"user_id":null,"body":"(ns parse-html-color.core\n  (:require [parse-html-color.preset :refer [preset-colors]]))\n\n(def values {:0 0, :1 1, :2 2, :3 3, :4 4, :5 5, :6 6, :7 7, :8 8, :9 9, :A 10, :B 11, :C 12, :D 13, :E 14, :F 15}) \n\n(defn big-hexa\n  [code]\n  (let [rest-code (rest code)]\n    (zipmap\n     '(:r :g :b)\n     (map (fn\n            [hexa-v1 hexa-v2]\n            (let [deca-v1 (values (keyword (str hexa-v1)))\n                  deca-v2 (values (keyword (str hexa-v2)))]\n              (+ deca-v2 (* deca-v1 16))))\n          (take-nth 2 rest-code)\n          (take-nth 2 (rest rest-code))))\n    )\n)\n\n(defn small-hexa\n  [code]\n  (zipmap\n   '(:r :g :b)\n   (map (fn\n          [hexa-v]\n          (let [deca-v (values (keyword (str hexa-v)))]\n            (+ deca-v (* deca-v 16))))\n        (rest code)))\n)\n\n(defn parse-html-color [color]\n  (if (= (first color) \\#)\n    (if (> (count color) 4)\n      (big-hexa (.toUpperCase color))\n      (small-hexa (.toUpperCase color)))\n    (big-hexa (.toUpperCase (preset-colors (.toLowerCase color)))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18067,"user_id":null,"body":"(ns parse-html-color.core\n  (:require [parse-html-color.preset :refer [preset-colors]]\n            [clojure.string :as string]))\n\n(defn hex->int\n  \"Converts a hex string of 3 or 6 characters to a seq of ints.\"\n  [h]\n  (if (> (count h) 3)\n    (->> (re-seq #\".{1,2}\" h)\n         (map #(Integer\/parseInt % 16)))\n\n    (->> (re-seq #\".{1,1}\" h)\n         (map #(Integer\/parseInt (str % %) 16)))))\n\n(defmulti parse-html-color\n  (fn [color]\n    (string\/starts-with? color \"#\")))\n\n(defmethod parse-html-color true\n  [color]\n  (->> (subs color 1)\n       (hex->int)\n       (zipmap [:r :g :b])))\n\n(defmethod parse-html-color false\n  [color]\n  (->> (string\/lower-case color)\n       (get preset-colors)\n       (parse-html-color)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18068,"user_id":168,"body":"(ns parse-html-color.core\n  (:require [parse-html-color.preset :refer [preset-colors]]))\n\n(require '[clojure.string :as st])\n\n(defn get-color [color]\n  (if (< (count color) 7) \n      (st\/replace color #\"\\w\" \"$0$0\")\n      color))\n\n(defn parse [color i]\n  (Integer\/parseInt (subs color i (+ i 2)) 16))\n\n(defn parse-html-color [color]\n  (->> color \n       (preset-colors (st\/lower-case color))\n       (get-color)\n       ((fn [c] {:r (parse c 1) :g (parse c 3) :b (parse c 5)}))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18069,"user_id":null,"body":"(ns parse-html-color.core\n  (:require [parse-html-color.preset :refer [preset-colors]]))\n\n(defn hex-seq->map\n  [xs]\n  (zipmap [:r :g :b] (map #(Integer\/parseInt % 16)  xs)))\n\n(defn clone-char [xs]\n  (map (fn [c] (str c c)) xs))\n\n(defn parse-html-color [color]\n  (condp (comp seq re-seq) (clojure.string\/upper-case color)\n    #\"#(\\w\\w)(\\w\\w)(\\w\\w)\" :>> #(hex-seq->map (rest (first %1)))\n    #\"#(\\w)(\\w)(\\w)\"       :>> #(hex-seq->map (clone-char (rest (first %1))))\n    (parse-html-color (get preset-colors (clojure.string\/lower-case color)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18070,"user_id":null,"body":"(ns parse-html-color.core\n  (:require [parse-html-color.preset :refer [preset-colors]]))\n\n(defn hex-char->int [c]\n  (if (Character\/isDigit c)\n    (- (int c) (int \\0))\n    (- (int c) (- (int \\A) 10))))\n\n(defn hex-string->int [s]\n  (->> s\n       (map hex-char->int)\n       (reverse)\n       (map-indexed #(* %2 (Math\/pow 16 %1)))\n       (apply +)\n       int))\n\n(defn hex-seq->map\n  \"creates a rgb map from a seq of 3 hexa strings\"\n  [xs]\n  (zipmap [:r :g :b] (map hex-string->int  xs)))\n\n\n(defn parse-html-color [color]\n  (condp (comp seq re-seq) (clojure.string\/upper-case color)\n    #\"#(\\w\\w)(\\w\\w)(\\w\\w)\" :>> #(hex-seq->map (rest (first %1)))\n    #\"#(\\w)(\\w)(\\w)\"       :>> #(hex-seq->map (map (fn [c] (str c c)) (rest (first %1))))\n    (parse-html-color (get preset-colors (clojure.string\/lower-case color)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18071,"user_id":null,"body":"(ns parse-html-color.core\n  (:require [parse-html-color.preset :refer [preset-colors]]))\n\n(defn parse-html-color [color]\n  (condp (comp seq re-seq) color\n    #\"^#(\\p{XDigit}{2})(\\p{XDigit}{2})(\\p{XDigit}{2})$\"\n    :>> (fn [[[_ r g b]]]\n          {:r (Integer\/parseInt r 16)\n           :b (Integer\/parseInt b 16)\n           :g (Integer\/parseInt g 16)})\n    #\"^#(\\p{XDigit})(\\p{XDigit})(\\p{XDigit})$\"\n    :>> (fn [[[_ r g b]]]\n          (parse-html-color (str \"#\" r r g g b b)))\n    #\"\\w+\"\n    :>> (fn [[w]]\n          (parse-html-color (preset-colors (clojure.string\/lower-case w))))\n    ))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18072,"user_id":201,"body":"(ns parse-html-color.core\n  (:require [parse-html-color.preset :refer [preset-colors]]))\n\n(defn parse-html-color [color]\n   (if (= \\# (first color))\n     (if (= 7 (count color))\n       (zipmap [:r :g :b] (map #(Integer\/parseInt % 16)\n                               (map #(apply str %) (partition 2 (rest color)))))\n       (zipmap [:r :g :b] (map #(Integer\/parseInt % 16)\n                               (map #(apply str %) (map #(repeat 2 %) (rest color))))))\n     (parse-html-color (get preset-colors (clojure.string\/lower-case color)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18073,"user_id":null,"body":"(ns parse-html-color.core\n  (:require [parse-html-color.preset :refer [preset-colors]]\n            [clojure.string :as str]))\n\n(defn parse-hex [h n]\n  (let [b (->> (partition n h)\n               (map (partial apply str)))]\n    {:r (Integer\/parseInt (first b) 16)\n     :g (Integer\/parseInt (second b) 16)\n     :b (Integer\/parseInt (last b) 16)}))\n\n(defn parse-html-color [hex]\n  (println hex)\n  (cond (and (str\/starts-with? hex \"#\") (= 7 (count hex))) (parse-hex (rest hex) 2)\n        (and (str\/starts-with? hex \"#\") (= 4 (count hex))) (parse-hex (str (apply str (repeat 2 (second hex)))\n                                                                           (apply str (repeat 2 (nth hex 2)))\n                                                                           (apply str (repeat 2 (nth hex 3)))) 2)\n        :else (parse-html-color (preset-colors (str\/lower-case hex)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"58ce8725c835848ad6000007":[{"id":18074,"user_id":492,"body":"(ns potatoes.core)\n\n(defn potatoes [p0 w0 p1]\n  (int (\/ (* w0 (- 100.0 p0)) (- 100.0 p1))))\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-27 19:27:54"},{"id":18075,"user_id":null,"body":"(ns potatoes.core)\n\n(defn potatoes\n  \"Return the final weight knowing the init percent of water, the init weight\n   and the final percent of water\"\n  [p0 w0 p1]\n  (let [init_weight_dry_matter (* (\/ (- 100 p0) 100) w0)\n        final_percent_dry_matter (- 100 p1)]\n    (int (\/ (* 100 init_weight_dry_matter) final_percent_dry_matter))\n  ))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18076,"user_id":53,"body":"(ns potatoes.core)\n\n(defn potatoes [p0 w0 p1]\n  (int (Math\/floor (\/ (* w0 (- 100 p0)) (- 100 p1))))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18077,"user_id":null,"body":"(ns potatoes.core)\n\n(defn potatoes [p0 w0 p1]\n  (int (double (* w0 (\/ (- 100 p0) (- 100 p1)))))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18078,"user_id":null,"body":"(ns potatoes.core)\n\n(defn potatoes [p0 w0 p1]\n  (let [a (- 100 p0)\n        b (- 100 p1)]\n    (int (* (\/ a b) w0))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18079,"user_id":null,"body":"(ns potatoes.core)\n\n(defn potatoes [p0 w0 p1]\n  (int (Math\/floor (\/ w0 (\/ (- 100 p1) (- 100 p0)))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18080,"user_id":null,"body":"(ns potatoes.core)\n\n(defn potatoes\n  [perc-wet weight perc-wet-after]\n  (let [perc-dry (- 100 perc-wet)\n        perc-dry-after (- 100 perc-wet-after)]\n    (int (* weight (\/ perc-dry perc-dry-after)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18081,"user_id":564,"body":"(ns potatoes.core)\n\n(defn potatoes [pctIn weight pctOut]\n  (defn inv [pct] (- 100 pct))\n  (quot (* weight (inv pctIn)) (inv pctOut)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18082,"user_id":null,"body":"(ns potatoes.core)\n\n(defn potatoes\n  [p0\n   w0\n   p1]\n   (int (\/ \n   (* w0 (- 100 p0))\n   (- 100 p1)))\n)\n  ; 100 kg  total\n  ; 1 kg mat\u00e9ria seca\n  ; 99 kg \u00e1gua\n  \n  ; forno\n  \n  ;<100 kg  total\n  ;1 kg  mat\u00e9ria seca (constante)\n  ;(<100 - 1) kg \u00e1gua?\n  \n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18083,"user_id":null,"body":"(ns potatoes.core)\n\n(defn potatoes [p0 w0 p1]\n  (let [not-water-weight (* w0 (\/ (- 100 p0) 100))]\n    (int (* not-water-weight (\/ 100 (- 100 p1))))\n    )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"58e24788e24ddee28e000053":[{"id":18084,"user_id":null,"body":"(ns simple_assembler)\n\n(defn parse-line [line]\n  (->> (str \"(\" line \")\") (read-string) (map #(if (symbol? %) (keyword %) %))))\n\n(defn arg [r x]\n  (if (number? x) x (get r x)))\n\n(defn simple_assembler [assembly-code]\n  (let [code (mapv parse-line assembly-code)]\n    (loop [i 0 r {}]\n      (if-let [[ins x y] (get code i)]\n        (case ins :mov (recur (inc i) (assoc r x (arg r y)))\n                  :inc (recur (inc i) (update r x inc))\n                  :dec (recur (inc i) (update r x dec))\n                  :jnz (recur (+ i (if (= 0 (arg r x)) 1 (arg r y))) r))\n        r))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18085,"user_id":null,"body":"(ns simple_assembler\n  (:require [clojure.string :as str]))\n\n(defn mov-inst [a b]\n  (fn [i data]\n    [(inc i) (assoc data a (if (keyword? b) (b data) b))]))\n                 \n(defn inc-inst [a]\n  (fn [i data]\n    [(inc i) (update data a inc)]))\n    \n(defn dec-inst [a]\n  (fn [i data]\n    [(inc i) (update data a dec)]))\n    \n(defn jnz-inst [a b]\n  (fn [i data]\n    (let [u (if (keyword? a) (a data) a)]\n      (if (zero? u)\n        [(inc i) data]\n        [(+ i b) data]))))\n\n(defn to-inst [[sym x y]]\n    (condp = sym\n      :mov (mov-inst x y)\n      :inc (inc-inst x)\n      :dec (dec-inst x)\n      :jnz (jnz-inst x y)))\n      \n      \n(defn to-keyword-or-number [v]\n  (let [u (read-string v)]\n    (if (symbol? u)\n      (keyword u)\n      u)))\n  \n(defn str->inst [code]\n  (->> (str\/split code #\" \")\n       (map to-keyword-or-number)\n       to-inst))\n      \n      \n(defn run-inst [inst]\n  (let [inst-len (count inst)]\n    (loop [i 0\n           data {}]\n      (if (>= i inst-len)\n        data\n        (let [[new-i new-data] ((nth inst i) i data)]\n          (recur new-i new-data))))))\n          \n      \n(defn simple_assembler [assembly-code]\n  (->> assembly-code\n       (map str->inst)\n       vec\n       run-inst))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18086,"user_id":null,"body":"(ns simple_assembler)\n\n(defn exec [code idx mem]\n  (if-not (get code idx)\n   mem\n   (let [line (code idx)\n         [ins x y] line\n         y (get mem y y)]\n    (case ins\n      \"mov\" (recur code (inc idx) (assoc mem x y))\n      \"inc\" (recur code (inc idx) (update mem x inc))\n      \"dec\" (recur code (inc idx) (update mem x dec))\n      \"jnz\" (recur code (if-not (zero? (get mem x x)) (+ idx y) (inc idx)) mem)))))\n\n(defn parse-line [line]\n  (let [line (.split line \" \")\n        ins (get line 0)\n        x (get line 1)\n        x (try (Integer\/parseInt x)\n            (catch NumberFormatException e\n              (keyword x)))\n        y (get line 2)\n        y (try (Integer\/parseInt y)\n            (catch NumberFormatException e\n              (keyword y)))]\n    [ins x y]))\n\n(defn parse [code]\n  (vec (map parse-line code)))\n\n(defn simple_assembler\n  [assembly-code]\n    (exec (parse assembly-code) 0 {}))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18087,"user_id":null,"body":"(ns simple_assembler)\n\n\n(defn eval-arg [state a]\n  (try\n    (Integer\/parseInt a)\n    (catch NumberFormatException _\n      ((keyword a) state))))\n\n\n(defn mov [state a b]\n  (let [new-state (assoc state (keyword a) (eval-arg state b))\n        pos-change 1]\n    [new-state pos-change]))\n\n\n(defn inc-reg [state a]\n  (let [new-state (update state (keyword a) inc)\n        pos-change 1]\n    [new-state pos-change]))\n\n\n(defn dec-reg [state a]\n  (let [new-state (update state (keyword a) dec)\n        pos-change 1]\n    [new-state pos-change]))\n\n\n(defn jnz [state a jump]\n  [state (if-not (zero? (eval-arg state a)) (Integer\/parseInt jump) 1)])\n\n\n(def instructions {\"mov\" mov\n                   \"inc\" inc-reg\n                   \"dec\" dec-reg\n                   \"jnz\" jnz})\n\n\n(defn simple_assembler [assembly-code]\n  (loop [state {}\n         curr-pos 0]\n    (let [[instruction-code & args] (clojure.string\/split\n                                     (get assembly-code curr-pos) #\"\\s\")\n          [new-state pos-delta] (apply (instructions instruction-code) state args)\n          new-pos (+ curr-pos pos-delta)]\n      (if (>= new-pos (count assembly-code))\n        new-state\n        (recur new-state new-pos)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18088,"user_id":null,"body":"(ns simple_assembler)\n\n(defn- const-or-register [val] (if (number? (read-string val)) (read-string val) (keyword val)))\n(defn- get-from-reg-or-const [registers value] (if (keyword? value) (get registers value) value))\n\n(defrecord Mov [dest src-or-value])\n(defrecord Inc [dest])\n(defrecord Dec [dest])\n(defrecord Jnz [reg-or-value steps])\n\n(defn- new-mov [dst src] (->Mov (keyword dst) (const-or-register src)))\n(defn- new-inc [dst] (->Inc (keyword dst)))\n(defn- new-dec [dst] (->Dec (keyword dst)))\n(defn- new-jnz [src steps] (->Jnz (const-or-register src) (read-string steps)))\n\n(defn- to-instruction [line]\n  (let [[operation & args] (clojure.string\/split line #\" \")]\n    (apply (case operation \"mov\" new-mov, \"inc\" new-inc, \"dec\" new-dec, \"jnz\" new-jnz) args)))\n\n(defn- interpreter [instructions instr-size]\n  (loop [iptr 0, registers {}]\n    (if (>= iptr instr-size)\n      registers\n      (let [instruction (get instructions iptr)]\n        (condp = (type instruction)\n          Mov (recur (inc iptr) (assoc registers\n                                       (:dest instruction)\n                                       (get-from-reg-or-const registers (:src-or-value instruction))))\n          Inc (recur (inc iptr)(assoc registers\n                                      (:dest instruction)\n                                      (inc (get registers (:dest instruction) 0))))\n          Dec (recur (inc iptr) (assoc registers\n                                       (:dest instruction)\n                                       (dec (get registers (:dest instruction) 0))))\n          Jnz (if (zero? (get-from-reg-or-const registers (:reg-or-value instruction)))\n                (recur (inc iptr) registers)\n                (recur (+ iptr (:steps instruction)) registers)))))))\n\n(defn simple_assembler [assembly-code]\n  (let [instructions (vec (map to-instruction assembly-code)), instr-size (count instructions)]\n    (interpreter instructions instr-size)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18089,"user_id":null,"body":"(ns simple_assembler)\n\n(defmulti execute (fn [instruction args state] instruction))\n\n(defmethod execute \"mov\" [_ [dest src] state]\n  (-> state\n      (assoc (keyword dest) (or ((keyword src) state) (Integer\/parseInt src)))\n      (update :pc inc)))\n\n(defmethod execute \"inc\" [_ [dest] state]\n  (-> state\n      (update (keyword dest) inc)\n      (update :pc inc)))\n\n(defmethod execute \"dec\" [_ [dest] state]\n  (-> state\n      (update (keyword dest) dec)\n      (update :pc inc)))\n\n(defmethod execute \"jnz\" [_ [cond offset] state]\n  (if (zero? (or ((keyword cond) state) (Integer\/parseInt cond)))\n    (update state :pc inc)\n    (update state :pc #(+ % (Integer\/parseInt offset)))))\n\n(defn parse-line [line]\n  (let [[instruction & args] (clojure.string\/split line #\" \")]\n    (partial execute instruction args)))\n\n(defn simple_assembler [lines]\n  (let [instruction-vector (mapv parse-line lines)]\n    (loop [state {:pc 0}]\n      (if (>= (:pc state) (count instruction-vector))\n        (dissoc state :pc)\n        (recur ((get instruction-vector (:pc state)) state))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18090,"user_id":null,"body":"(ns simple_assembler\n  (require [clojure.string :as str]))\n\n\n(defn simple_assembler [asm-code]\n  (loop [line-num 0\n         memory {}]\n    (if (contains? asm-code line-num) \n      (let [tokenise (str\/split (nth asm-code line-num) #\" \")\n            func (first tokenise)\n            operand-1 (second tokenise)\n            operand-2 (last tokenise)\n            get-integer (fn [token]\n                          (if (re-find #\"\\d\" token)\n                            (Integer. token)\n                            (memory (keyword token))))]\n        (case func\n          \"mov\" (recur (inc line-num)\n                       (assoc memory\n                              (keyword operand-1)\n                              (get-integer operand-2)))\n          \"inc\" (recur (inc line-num)\n                       (update memory\n                               (keyword operand-1)\n                               inc))\n          \"dec\" (recur (inc line-num)\n                       (update memory\n                               (keyword operand-1)\n                               dec))\n          \"jnz\" (if (zero? (get-integer operand-1))\n                  (recur (inc line-num)\n                         memory)\n                  (recur (+ line-num (get-integer operand-2))\n                         memory))))\n      memory))) ; else clause\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18091,"user_id":null,"body":"(ns simple_assembler)\n\n\n(defn reg-func-apply [state f x]\n  (update-in state [:registers x] f 1)\n  )\n\n(defn reg-move [state x y]\n  (if (= (get y :type) :constant)\n    (assoc-in state [:registers (keyword x)] (get y :value))\n    (assoc-in state [:registers (keyword x)] (get-in state [:registers (get y :value)]))))\n\n(defn argument\n  [x] (if (re-find #\"[a-z]\" x)\n    {:type :register :value (keyword x)}\n    {:type :constant :value (Integer\/parseInt x)}))\n\n(defn inc-pc\n  [state]\n  (update state :pc + 1)\n  )\n\n(defn parse-instruction\n  [instruction]\n  (let [s-array (clojure.string\/split instruction #\" \")]\n    (if (= (count s-array) 3)\n      [(keyword (nth s-array 0)), (keyword (nth s-array 1)), (argument (nth s-array 2))]\n      [(keyword (nth s-array 0)), (keyword (nth s-array 1))]\n      )))\n\n(defn jnz [state reg arg]\n  (if (= 0 (get-in state [:registers reg]))\n    (inc-pc state)\n    (update state :pc + (get arg :value))\n    ))\n\n(defn apply-instruction [state instruction]\n  (let [[inst reg arg] instruction]\n    (cond\n      (= :mov inst) (inc-pc (reg-move state reg arg))\n      (= :inc inst) (inc-pc (reg-func-apply state + reg))\n      (= :dec inst) (inc-pc (reg-func-apply state - reg))\n      (= :jnz inst) (jnz state reg arg)\n      :else (inc-pc state)\n      )))\n\n\n(defn vm [assembly-code]\n  (let [i (map parse-instruction assembly-code) end (count i)]\n    (loop [state {:pc 0}]\n      (let [pc (state :pc)]\n        (if (>= pc end)\n          (:registers state)\n          (recur (apply-instruction state (nth i pc)))\n        )))))\n\n\n(defn simple_assembler [assembly-code]\n  (vm assembly-code))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18092,"user_id":62,"body":"(ns simple_assembler)\n\n(defn simple_assembler [instructions]\n  (let [op-table {\"mov\" (fn [a b regs ptr]\n                              [(assoc regs a (get regs b b)) (inc ptr)])\n                  \"inc\" (fn [a b regs ptr]\n                              [(assoc regs a (inc (get regs a 0))) (inc ptr)])\n                  \"dec\" (fn [a b regs ptr]\n                              [(assoc regs a (dec (get regs a 0))) (inc ptr)])\n                  \"jnz\" (fn [a b regs ptr]\n                              (if-not (zero? (get regs a a))\n                                [regs (+ ptr (get regs b b))]\n                                [regs (inc ptr)]))}\n        \n        read-symbol #(when % (try (Integer\/parseInt %) (catch Exception e (keyword %))))\n        instructions*\n        (vec (for [[_ op a _ b] \n              (map (partial re-find #\"^([a-z]+) ([\\w\\-]+)( ([\\w\\-]+))?$\") instructions)]\n              [[op a b] (partial (get op-table op) (read-symbol a) (read-symbol b))]))\n        ]\n    \n    (loop [[registers pointer] [{} 0]]\n      (if-let [[_ f] (get instructions* pointer)]\n         (recur (f registers pointer))\n        registers))))\n    \n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18093,"user_id":null,"body":"(ns simple_assembler\n  (:require [clojure.string :as str]))\n\n(defn read-register [registers src]\n  (get registers (keyword src)))\n\n(defn set-register [registers dest value]\n  (assoc registers (keyword dest) value))\n\n(defn alter-register [registers dest alter-fn]\n  (set-register registers dest (alter-fn (read-register registers dest))))\n\n(defn extract [registers src]\n  (if (re-matches #\"-?\\d+\" src)\n    (Integer. src)\n    (read-register registers src)))\n\n(defn mov-assembly [registers [dest src]]\n  (set-register registers dest (extract registers src)))\n\n(defn inc-assembly [registers [x]]\n  (alter-register registers x inc))\n\n(defn dec-assembly [registers [x]]\n  (alter-register registers x dec))\n\n(defn read-command [counter code]\n  (str\/split (get code counter \"end\") #\" \"))\n\n(defn evaluate [counter code registers]\n  (let [[opcode & args] (read-command counter code)]\n    (case opcode\n      \"mov\" (recur (inc counter) code (mov-assembly registers args))\n      \"inc\" (recur (inc counter) code (inc-assembly registers args))\n      \"dec\" (recur (inc counter) code (dec-assembly registers args))\n      \"jnz\" (if-not (zero? (extract registers (first args)))\n              (recur (+ counter (extract registers (fnext args))) code registers)\n              (recur (inc counter) code registers))\n      registers)))\n\n\n(defn simple_assembler [code]\n  (evaluate 0 code {}))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"58e2f8d9f443daa190000031":[{"id":18094,"user_id":1750,"body":"(ns clojure.fcc.reverse)\n\n(defn reverse-string [s]\n  (->> s reverse (apply str)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18095,"user_id":676,"body":"(ns clojure.fcc.reverse)\n(def reverse-string clojure.string\/reverse)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18096,"user_id":null,"body":"(ns clojure.fcc.reverse)\n\n(defn reverse-string [s]\n  (reduce #(str %2 %1) s))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18097,"user_id":492,"body":"(ns clojure.fcc.reverse)\n\n(defn reverse-string [s]\n  (apply str\n        (for [i (range (dec (count s)) -1 -1)]\n            (get s i))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18098,"user_id":null,"body":"(ns clojure.fcc.reverse)\n\n(defn reverse-string [s]\n  (if (= (count s) 1)\n    (first s) (str (reverse-string (rest s))(first s)))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18099,"user_id":null,"body":"(ns clojure.fcc.reverse)\n\n(defn reverse-string [s]\n  (apply str (reduce #(cons %2 %1) () s)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18100,"user_id":1703,"body":"(ns clojure.fcc.reverse)\n\n(defn customRev [s r]\n  (if(= (count s) 0)\n    r \n      (recur(subs s 0 (dec(count s)))(str r (last s)))))\n\n(defn reverse-string [s]\n  (customRev s \"\")\n  )\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18101,"user_id":null,"body":"(ns clojure.fcc.reverse)\n\n(defn reverse-string [s]\n  (->> s\n       (reverse)\n       (clojure.string\/join \"\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18102,"user_id":null,"body":"(ns clojure.fcc.reverse)\n\n(defn reverse-string [s]\n  (apply str (reverse (vec s))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18103,"user_id":null,"body":"(ns clojure.fcc.reverse)\n(require '[clojure.string :as str])\n\n(defn reverse-string [s]\n  (def splited (clojure.string\/split s #\"\"))\n  (def answer ())\n  (doseq [d splited]\n    (def answer(conj answer d)))\n  (clojure.string\/join \"\" answer)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"58f5c63f1e26ecda7e000029":[{"id":18104,"user_id":null,"body":"(ns wave)\n\n(defn wave [string]\n  (let [s (vec string)]\n    (for [i (range (count s))\n          :when (not= \\space (s i))]\n      (apply str (update s i #(Character\/toUpperCase %))))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18105,"user_id":null,"body":"(ns wave\n  (:require [clojure.string :as str]))\n\n(defn replace-at [index string replaced]\n  (str (subs string 0 index) replaced (subs string (inc index)))\n  )\n\n(defn wave [string]\n  (->> (range (count string))\n    (map #(replace-at % string (str\/upper-case (get string %))))\n    (remove #(= (str\/lower-case string) %))\n    )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18106,"user_id":null,"body":"(ns wave)\n\n(defn upper-index [string index]\n  (str\n    (subs string 0 index)\n    (clojure.string\/upper-case (subs string index (inc index)))\n    (subs string (inc index))))\n  \n\n(defn wave [string]\n  (map #(upper-index string %1) \n    (filter #(Character\/isLetter (nth string %1)) (range (count string)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18107,"user_id":null,"body":"(ns wave)\n\n(defn wave [string]\n  (reduce (fn [a x]\n            (let [code (-> (nth string x) int)]\n              (if (and (> code 96) (< code 123))\n                (conj a (apply str\n                               (subs string 0 x)\n                               (-> (- code 32) char)\n                               (subs string (inc x))))\n                a)))\n          [] (range (count string))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18108,"user_id":null,"body":"(ns wave\n  (require [clojure.string :as str]))\n\n(defn wave [string]\n  (let [whitespace #{\newline \\tab \\space}\n        index-char-pairs (map-indexed list string)\n        indices-of-letters (reduce #(if (whitespace (second %2))\n                                      %1\n                                      (conj %1 (first %2)))\n                                   []\n                                   index-char-pairs)]\n    (map (fn [index]\n           (apply str (map #(if (= index (first %))\n                              (str\/upper-case (second %))\n                              (second %))\n                           index-char-pairs)))\n         indices-of-letters)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18109,"user_id":null,"body":"(ns wave)\n\n(defn wave [string]\n  (let [v (vec string)]\n    (keep #(let [c (get v %)\n                 uc (Character\/toUpperCase c)]\n             (if (= c uc)\n               nil\n               (clojure.string\/join (assoc v % uc))))\n          (range (count v)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18110,"user_id":null,"body":"(ns wave)\n\n(defn wave [s]\n  (->> (range (count s))\n       (map (fn [i]\n              (->> s\n                   (map-indexed vector)\n                   (map (fn [[j c]]\n                          (let [n (int c)]\n                            (if (and (= i j) (<= 97 n 122))\n                              (char (- n 32))\n                              c))))\n                   (apply str))))\n       (remove #{s})\n       distinct))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18111,"user_id":62,"body":"(ns wave)\n(require 'clojure.string)\n\n(defn wave [string]\n    (remove (partial = string)\n      (map #(let [[before [a & after]] \n                  (split-at % string)]\n              (clojure.string\/join \"\" \n                                   (concat before (clojure.string\/upper-case a) after)))\n           (range (count string)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18112,"user_id":null,"body":"(ns wave)\n\n(defn wave [string]\n  (->> string\n       (repeat (count string))\n       (map-indexed (fn [i s] (-> \n                               (into [] (seq s))\n                               (update i clojure.string\/upper-case)\n                               clojure.string\/join)))\n       distinct\n       (filter #(not= (clojure.string\/lower-case %) %))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18113,"user_id":null,"body":"(ns wave\n  (:require [clojure.string :as str]))\n\n(defn make-wave [s i]\n  (apply str\n    (subs s 0 i)\n    (str\/upper-case (subs s i (inc i)))\n    (subs s (inc i))))\n\n(defn wave-inner [s i]\n  (if (= i (count s)) []\n    ((if (Character\/isLetter (get s i))\n      (partial cons (make-wave s i))\n      identity)\n      (wave-inner s (inc i)))))\n\n(defn wave [s]\n  (wave-inner s 0))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"592fd8f752ee71ac7e00008a":[{"id":18114,"user_id":null,"body":"(ns covfefe)\n(defn covfefe[tweet] \n  (if (re-matches #\".*coverage.*\" tweet)  \n    (clojure.string\/replace tweet #\"coverage\" \"covfefe\")\n    (str tweet \" covfefe\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18115,"user_id":null,"body":"(ns covfefe\n  (:require [clojure.string :as str]))\n  \n(defn covfefe[tweet]\n  (let [trumped-string\n    (str\/replace tweet #\"coverage\" \"covfefe\")]\n\n    (if (= trumped-string tweet)\n      (str tweet \" covfefe\")\n      trumped-string)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18116,"user_id":201,"body":"(ns covfefe)\n(defn covfefe[tweet] \n\n   (if (clojure.string\/index-of tweet \"coverage\")\n     (clojure.string\/replace tweet \"coverage\" \"covfefe\")\n     (str tweet \" covfefe\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18117,"user_id":null,"body":"(ns covfefe)\n(defn covfefe[tweet] \n (\n   if (= (re-find #\"coverage\" tweet) \"coverage\")\n   (clojure.string\/replace tweet #\"coverage\" \"covfefe\")\n   (str tweet \" covfefe\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18118,"user_id":null,"body":"(ns covfefe\n  (:require [clojure.string :as str]))\n  \n(defn covfefe[tweet] \n  (if (str\/includes? tweet \"coverage\")\n    (str\/replace tweet #\"\\bcoverage\" \"covfefe\")\n    (str tweet \" covfefe\")\n  ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18119,"user_id":null,"body":"(ns covfefe)\n\n(defn covfefe[tweet] \n   (if (.contains tweet \"coverage\")\n       (.replace tweet \"coverage\" \"covfefe\")\n       (str tweet \" covfefe\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18120,"user_id":null,"body":"(ns covfefe (:require [clojure.string :as str]))\n(defn covfefe[tweet] \n  (if (str\/includes? tweet \"coverage\")\n    (str\/replace tweet \"coverage\" \"covfefe\")\n    (str\/join \" \" [tweet \"covfefe\"])\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18121,"user_id":null,"body":"(ns covfefe\n  (:require [clojure.string :as str]))\n\n(defn covfefe [tweet]\n  (if (= nil (re-find #\"coverage\" tweet))\n    (str tweet \" covfefe\")\n    (str\/replace tweet #\"coverage\" \"covfefe\")))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18122,"user_id":null,"body":"(ns covfefe\n  (:require [clojure.string :as s]))\n\n(defn covfefe [x]\n  (if (nil? (re-find #\"coverage\" x))\n    (str x \" covfefe\")\n    (s\/replace x #\"coverage\" \"covfefe\")))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18123,"user_id":null,"body":"(ns covfefe)\n\n(defn covfefe[tweet] \n  (let [s \"covfefe\"\n        r (clojure.string\/replace tweet #\"coverage\" s)]\n    (if (= tweet r)\n      (str tweet \" \" s)\n      r)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5933a1f8552bc2750a0000ed":[{"id":18124,"user_id":527,"body":"(ns nth.even.number)\n\n(defn nth_even [n]\n  (* 2 (dec n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18125,"user_id":null,"body":"(ns nth.even.number)\n(defn nth_even [n]\n  (- (* 2 n) 2))\n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18126,"user_id":null,"body":"(ns nth.even.number)\n\n(def nth_even (comp (partial * 2) dec))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18127,"user_id":645,"body":"(ns nth.even.number)\n(defn nth_even [n]\n  (- (* n 2) 2))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18128,"user_id":null,"body":"(ns nth.even.number)\n(defn nth_even [n]\n  (* 2 (- n 1)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18129,"user_id":null,"body":"(ns nth.even.number)\n\n(def nth_even #(- (* 2 %) 2))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18130,"user_id":null,"body":"(ns nth.even.number)\n(defn nth_even [n]\n  (- (+ n n) 2)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18131,"user_id":527,"body":"(ns nth.even.number)\n\n(defn nth_even [n]\n  (* (dec n) 2))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18132,"user_id":null,"body":"(ns nth.even.number)\n\n(defn nth_even [n]\n  (-> n (dec) (* 2)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18133,"user_id":null,"body":"(ns nth.even.number)\n(def nth_even\n  (comp\n   (partial + -2)\n   (partial * 2)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5949481f86420f59480000e7":[{"id":18134,"user_id":null,"body":"(ns kata)\n\n(defn odd_or_even [xs]\n    (if (odd? (reduce + 0 xs))\n      \"odd\"\n      \"even\"\n    )\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18135,"user_id":null,"body":"(ns kata)\n\n(defn odd_or_even [xs]\n  (if (even? (reduce + xs)) \"even\" \"odd\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18136,"user_id":527,"body":"(ns kata)\n\n(defn odd_or_even [xs]\n  (if (even? (apply + xs)) \"even\" \"odd\"))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18137,"user_id":null,"body":"(ns kata)\n\n(defn odd_or_even [xs]\n  (if (= (mod (reduce + xs) 2) 0) \"even\" \"odd\")\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18138,"user_id":201,"body":"(ns kata)\n\n(defn odd_or_even [xs]\n  (if (odd? (reduce + xs)) \"odd\" \"even\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18139,"user_id":null,"body":"(ns kata)\n\n(defn odd_or_even [xs]\n  (-> (apply + xs)\n      (#(if (odd? %) \"odd\" \"even\"))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18140,"user_id":1703,"body":"(ns kata)\n\n(defn odd_or_even [xs]\n  (if(= 0 (rem (reduce + xs) 2)) \"even\" \"odd\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18141,"user_id":null,"body":"(ns kata)\n\n(defn odd_or_even [vec-of-num]\n  (if (odd? (reduce + vec-of-num))\n    \"odd\"\n    \"even\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18142,"user_id":null,"body":"(ns kata)\n\n(defn odd_or_even [xs]\n  (if (empty? xs)\n    \"even\"\n    (let [sum (apply + xs)]\n      (if (odd? sum)\n        \"odd\"\n        \"even\"))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18143,"user_id":null,"body":"(ns kata)\n\n(defn odd_or_even [xs]\n  (let [summed (reduce + xs)]\n    (cond\n      (even? summed) \"even\"\n      (odd? summed) \"odd\"\n      :else \"odd\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5966eeb31b229e44eb00007a":[{"id":18144,"user_id":null,"body":"(ns kata\n  (:require [clojure.string :as str]))\n\n(defn vaporcode\n  [s]\n  (->> s\n       (remove (partial = \\space))\n       (str\/join \"  \")\n       (str\/upper-case)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18145,"user_id":53,"body":"(ns kata (:require [clojure.string :refer [join replace upper-case]]))\n(defn vaporcode [s] (join \"  \" (vec (replace (upper-case s) \" \" \"\"))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18146,"user_id":null,"body":"(ns kata)\n(defn vaporcode [s]\n  (apply str (interpose \"  \" (apply str (re-seq #\"[A-Z?!.,\\\/'-:;_]\" (clojure.string\/upper-case s)))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18147,"user_id":645,"body":"(ns kata)\n(defn vaporcode [s]\n  (clojure.string\/join \"  \" (vec (clojure.string\/replace (clojure.string\/upper-case s) \" \" \"\"))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18148,"user_id":null,"body":"(ns kata\n  (:require [clojure.string :as str]))\n\n(defn vaporcode [s]\n  (->> (str\/replace s \" \" \"\")\n       (seq)\n       (map str\/upper-case)\n       (str\/join \"  \")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18149,"user_id":null,"body":"(ns kata)\n(defn vaporcode [s]\n  (let [\n        chrsr   (clojure.string\/split s #\"\")\n        chrs    (filter #(not (= % \" \")) chrsr)\n        jn      (clojure.string\/join \"  \" chrs)\n        upp     (clojure.string\/upper-case jn)\n        ] upp)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18150,"user_id":null,"body":"(ns kata\n  (:require [clojure.string :as str]))\n(defn vaporcode [s]\n  (-> s str\/upper-case (str\/replace #\"\\s\" \"\") (str\/replace #\"(.)(?!$)\" \"$1  \"))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18151,"user_id":null,"body":"(ns kata\n  (:require [clojure.string :as string]\n            [clojure.string :as str]))\n(defn vaporcode [s]\n  ;; your code here\n\n(->> s\n     (str\/upper-case)\n     (str\/split-lines)\n     (map #(re-seq #\"\\S\" %))\n     (first)\n     (str\/join \"  \")\n     )\n\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18152,"user_id":null,"body":"(ns kata)\n(defn vaporcode [s]\n  (let [str-seq (-> s\n                    (clojure.string\/upper-case)\n                    (clojure.string\/replace #\"\\s\" \"\")\n                    (seq))]\n    (->> str-seq\n         (map str)\n         (clojure.string\/join \"  \"))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18153,"user_id":null,"body":"(ns kata)\n(defn vaporcode [s]\n  (clojure.string\/upper-case \n   (apply str (interpose \"  \" (clojure.string\/join (clojure.string\/split s #\" \"))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"596f28fd9be8ebe6ec0000c1":[{"id":18154,"user_id":53,"body":"(ns kata)\n\n(defn wave-sort [numbers]\n  (let [arr (sort numbers)]\n    (flatten (map #(list (nth arr (inc %)) (nth arr %)) (range 0 (dec (count numbers)) 2)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18155,"user_id":null,"body":"(ns kata)\n\n(defn wave-sort [xs]\n  (let [[a b] (->> (sort xs) (split-at (-> xs count (quot 2))))]\n    (cond-> (interleave b a)\n      (> (count b) (count a)) (concat [(last b)]))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18156,"user_id":527,"body":"(ns kata)\n\n(defn wave-sort [xs]\n  (let [xs (sort xs) [ls rs] (split-at (quot (count xs) 2) xs)]\n    (interleave rs ls)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18157,"user_id":201,"body":"(ns kata)\n\n(defn wave-sort [numbers]\n  (loop [nums (sort numbers)\n         acc []]\n    (if (empty? nums) acc\n        (let [a (conj acc (last nums))\n              b (if (> (count nums) 1) (conj a (first nums)) a)]\n          (recur (butlast (rest nums)) b)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"596f610441372ee0de00006e":[{"id":18158,"user_id":null,"body":"(ns katas.basic-de_nico\n  (:require [clojure.string :as str]))\n\n(defn de_nico [k m] \n  (let [order   (map (partial str\/index-of (apply str (sort k))) k)\n        numOrd  (count order)\n        parts   (partition numOrd numOrd (repeat \\space) m)\n        result  (mapcat #(map (partial nth %) order) parts)]\n       (str\/trim (apply str result))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18159,"user_id":null,"body":"(ns katas.basic-de_nico)\n\n(defn group-message [n m]\n  (reduce-kv (fn [m k v]\n               (update m (inc (mod k n))\n                       #(conj % v))) (into {} (map #(vector % []) (range 1 (inc n)))) (vec m)))\n\n(defn sort-key [k]\n  (map (into {} (map-indexed (fn [idx itm] [itm (inc idx)]) (sort k))) k))\n\n(defn de_nico [k m]\n  (let [msg-map (group-message (count k) m)\n        new-ord (sort-key k)]\n    (->> (for [idx (range (apply max (map count (vals msg-map))))]\n           (map (fn [num] (nth (get msg-map num) idx nil)) new-ord))\n         (map #(apply str %))\n         (apply str)\n         (clojure.string\/trim))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18160,"user_id":62,"body":"(ns katas.basic-de_nico)\n(require 'clojure.string)\n\n(defn de_nico [k m] \n  (let [keylength (count k)]\n    \n    (->> \n      (partition keylength keylength (repeat nil) m)    ;; rows\n      (apply map vector)                                ;; columns\n      \n      (zipmap (sort k))                                 ;; column labels\n         (sort-by (comp #(.indexOf (seq k) %) key))     ;; numeric key\n         (vals)                                         ;; remove col labels\n         (apply map str)                                ;; read across rows\n         (clojure.string\/join \"\")                       ;; concatenate into str\n         (clojure.string\/trim)                          ;; trim whitespace\n      )))\n                ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18161,"user_id":null,"body":"(ns katas.basic-de_nico)\n(require '[clojure.string :as str])\n\n(defn de_nico [k m]\n  (let [chunks (partition (count k) (count k) nil (str\/trimr m))\n        pattern (map (->> (sort k) (map-indexed #(do {%2 %1})) (reduce into)) k)\n        decipher (fn [x] (map #(nth x % nil) pattern))]\n    (->> chunks (map decipher) flatten (remove nil?) (apply str) str\/trimr)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18162,"user_id":null,"body":"(ns katas.basic-de_nico)\n(use 'clojure.string)\n\n(defn de_nico [k m] \n  (let [l (count k)\n        idxm (->> k (map-indexed vector)\n                    (sort-by second)\n                    (map first))\n        unshuffle (fn [s] (->> s\n                            (map vector idxm)\n                            (sort-by first)\n                            (map second)))]\n    (->> m\n      (partition l l (cycle [\\space]))\n      (map unshuffle)\n      (map (partial apply str))\n      (apply str)\n      trim)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18163,"user_id":null,"body":"(ns katas.basic-de_nico)\n\n(defn num-key [k]\n  (let [m (into {} (map vector (sort k) (rest (range))))]\n    (map #(get m %) k)))\n\n(defn msg-table [msg x]\n  (->> msg\n       (partition x x (repeat \\space))\n       (apply map vector)))\n\n(defn de_nico [k m]\n  (let [n-k   (num-key k)\n        table (msg-table m (count k))]\n    (->> (map #(nth table (dec %)) n-k)\n         (apply map vector)\n         flatten\n         (apply str)\n         clojure.string\/trim)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18164,"user_id":null,"body":"(ns katas.basic-de_nico)\n\n(defn pair-indices [-vec] (partition 2 (interleave -vec (range (inc (count -vec))))))\n\n(defn de_nico [k m] \n  (let [k-cnt (count k)\n        k-vec (vec (.split k \"\"))\n        k-pre (sort k-vec)\n        k-post (map #(+ 1 (.indexOf k-pre %)) k-vec)\n        decoder-pre (take (count m) (flatten (repeat k-post)))\n        decoder-post (map\n                      (fn [[x i]] (dec (int (+ x (* k-cnt (Math\/floor (\/ i k-cnt)))))))\n                      (pair-indices decoder-pre))]\n    (clojure.string\/trim (apply str (map #(.charAt m %) decoder-post))))\n)\n    \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18165,"user_id":null,"body":"(ns katas.basic-de_nico)\n\n(defn generate-key [seed]\n  (->> (map vector (range) seed)\n       (sort-by second)\n       (map first)))\n\n(defn de_nico [seed message] \n  (->> (cycle message)\n       (map vector (cycle (generate-key seed)))\n       (partition (count seed))\n       (mapcat (partial sort-by first))\n       (map second)\n       (take (count message))\n       (apply str)\n       (clojure.string\/trim)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18166,"user_id":null,"body":"(ns katas.basic-de_nico)\n\n(defn de_nico [k m] \n  (let [key-map (apply hash-map (interleave (sort k) (range)))]\n    (->> m\n      (partition-all (count k))\n      (mapcat (fn [row] (map #(nth row (key-map %) \"\") k)))\n      (apply str)\n      (clojure.string\/trim))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18167,"user_id":null,"body":"(ns katas.basic-de_nico)\n\n(defn de_nico [k m]\n  (let [tr (->> (map-indexed vector k) (sort-by second) (mapv first))]\n    (->> m \n         (partition (count k) (count k) (repeat \" \"))\n         (mapcat #(->> (map vector % tr) (sort-by second) (map first)))\n         (apply str)\n         (clojure.string\/trimr))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"59727ff285281a44e3000011":[{"id":18168,"user_id":null,"body":"(ns katas.band_name_generator)\n\n(defn starts-ends-same \n  \"(= (first noun) (last noun))\"\n[noun]\n  (= (first noun) (last noun)))\n\n(defn connect-twice \n\"noun -> Nounoun\"\n[noun]\n(str (clojure.string\/capitalize noun) (apply str (rest noun))))\n\n(defn the-capitalize\n  \"noun -> The Noun\"\n   [noun]\n  (str \"The \" (clojure.string\/capitalize noun)))\n\n(defn generate-band-name [noun]\n  (if (starts-ends-same noun)\n    (connect-twice noun)\n    (the-capitalize noun)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18169,"user_id":null,"body":"(ns katas.band_name_generator)\n(require 'clojure.string)\n\n(defn generate-band-name [noun]\n  (if (= (first noun) (last noun))\n    (apply str (clojure.string\/capitalize noun) (rest noun))\n    (str \"The \" (clojure.string\/capitalize noun))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18170,"user_id":null,"body":"(ns katas.band_name_generator\n  (:require [clojure.string :refer [capitalize join]]))\n\n(defn generate-band-name [noun]\n  (if (= (first noun) (last noun))\n    (str (capitalize noun) (join \"\" (rest noun)))\n    (str \"The \" (capitalize noun)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18171,"user_id":null,"body":"(ns katas.band_name_generator)\n\n(defn generate-band-name [noun]\n  ; happy coding!\n  (if (= (first noun) (last noun))\n      (clojure.string\/capitalize (apply str (concat noun (rest noun))))\n      (str \"The \" (clojure.string\/capitalize noun))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18172,"user_id":null,"body":"(ns katas.band_name_generator)\n\n(defn generate-band-name [noun]\n  (->> noun\n     (clojure.string\/lower-case)\n     ((fn [name]\n        (if (= (first name) (last name))\n          (clojure.string\/capitalize (str name (apply str (rest name))))\n          (str \"The \" (clojure.string\/capitalize name))\n          )\n        ))\n     )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18173,"user_id":null,"body":"(ns katas.band_name_generator)\n\n(defn generate-band-name [noun]\n  (if (identical? (first noun) (last noun))\n    (clojure.string\/capitalize (str (clojure.string\/join \"\" (drop-last noun)) noun))\n    (str \"The \" (clojure.string\/capitalize noun))\n)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18174,"user_id":null,"body":"(ns katas.band_name_generator)\n\n(defn generate-band-name [noun]\n  (if (= (first noun) (nth noun (- (count noun) 1)))\n        (clojure.string\/capitalize(str noun (apply str (rest noun))))\n        (str \"The \" (clojure.string\/capitalize noun)))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18175,"user_id":null,"body":"(ns katas.band_name_generator)\n\n(defn generate-band-name [noun]\n  (if (= (first noun) (last noun)) (clojure.string\/capitalize (apply str noun (rest noun))) (str \"The \" (clojure.string\/capitalize noun)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18176,"user_id":null,"body":"(ns katas.band_name_generator\n  (:require [clojure.string :as str]))\n\n(defn generate-band-name [s]\n    (let [first-letter (str (first s))\n          noun-type (and (str\/starts-with? s first-letter)\n                         (str\/ends-with? s first-letter))\n          connect-noun (apply str (butlast s))\n          capitalize-noun (str\/capitalize s)]\n      (if noun-type\n        (str\/capitalize (str\/join #\"\" [connect-noun s]))\n        (str\/join #\" \" [\"The\" capitalize-noun]))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18177,"user_id":null,"body":"(ns katas.band_name_generator)\n\n(defn- equal-ends? [s] (= (first s) (last s)))\n\n(defn generate-band-name [s]\n  (if\n    (equal-ends? s)\n    (format \"%s%s\" (clojure.string\/capitalize s) (clojure.string\/join \"\" (rest s)))\n    (format \"The %s\" (clojure.string\/capitalize s))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"59766edb9bfe7cd5b000006e":[{"id":18178,"user_id":null,"body":"(ns katas.bad_apples)\n\n(defn Queue\n  ([] (clojure.lang.PersistentQueue\/EMPTY))\n  ([xs] (into (clojure.lang.PersistentQueue\/EMPTY) xs)))\n\n(defn- bad? [p] (boolean (some zero? p)))\n(defn- rot? [p] (= p [0 0]))\n\n(defn- comb-pkgs [a b]\n  (->> (concat a b) (filter pos?) vec))\n\n(declare process-1 process-2)\n\n(defn- process-1 [res q1]\n  (cond\n    (empty? q1)       res\n    (rot? (peek q1))  #(process-1 res (pop q1))\n    (bad? (peek q1))  #(process-1 res (trampoline process-2 (pop q1) (Queue) (peek q1)))\n    :else             #(process-1 (conj res (peek q1)) (pop q1))))\n\n(defn- process-2 [q1 q2 held]\n  (cond\n    (empty? q1)       q2\n    (rot? (peek q1))  #(process-2 (pop q1) q2 held)\n    (bad? (peek q1))  (Queue (concat [(comb-pkgs held (peek q1))] q2 (pop q1)))\n    :else             #(process-2 (pop q1) (conj q2 (peek q1)) held)))\n\n(defn bad_apples [box]\n  (trampoline process-1 [] (Queue box)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18179,"user_id":null,"body":"(ns katas.bad_apples)\n\n(defn get-good-apples [[a b]]\n  (cond\n    (and (> a 0) (> b 0)) [a b]\n    (> a 0) a\n    (> b 0) b\n    :else nil))\n\n(defn mark-and-collect-singles [[acc singles] pair]\n  (let [v (get-good-apples pair)]\n    (cond\n      (nil? v) [acc singles]\n      (vector? v) [(conj acc v) singles]\n      (odd? (count singles)) [acc (conj singles v)]\n      :else [(conj acc nil) (conj singles v)])))\n\n(defn replace-singles [[acc singles] pair]\n  (cond \n    (not (nil? pair)) [(conj acc pair), singles]\n    (> (count singles) 1) [(conj acc [(first singles) (first (rest singles))]), (rest (rest singles))]\n    :else [acc singles]))\n    \n(defn bad_apples [input]\n  (let [[init r] (reduce mark-and-collect-singles [[], []] input)]\n    (first (reduce replace-singles [[],r] init))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18180,"user_id":null,"body":"(ns katas.bad_apples)\n\n(defn bad_apples [in-box]\n;; kata description does not tell what to do when 2 consecutive boxes are bad [[7 3] [3 0] [1 0] [3 1] [1 3]]\n;; this code handles them not in intended way, I'll just brute-force my way through RNG\n  (let [no-rotten-box (filterv (fn [[a b]] (not (= a b 0))) in-box)\n    good-from-bad (partition 2 (keep (fn [[a b]] (cond (zero? a) b (zero? b) a :else nil)) no-rotten-box))]\n    (loop [\n        no-rot (into [] no-rotten-box)\n        sub (into [] good-from-bad) out-box []]\n      (if (empty? no-rot)\n        (concat out-box sub)\n        (let [[a b] (first no-rot)]\n          (if (or (zero? a) (zero? b))\n            (if (empty? sub)\n              (recur (subvec no-rot 1) sub out-box)\n              (recur (subvec no-rot 1) (subvec sub 1) (conj out-box (first sub))))\n            (recur (subvec no-rot 1) sub (conj out-box (first no-rot))))))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18181,"user_id":null,"body":"(ns katas.bad_apples)\n\n(defn bad? [box]\n  (boolean (some zero? box)))\n\n(defn index-of [haystack needle from-index]\n  (->> (map-indexed vector haystack)\n       (reduce (fn [_ [index item]]\n                 (if (and (> index from-index) (= item needle))\n                   (reduced index))) nil)))\n\n(defn first-bad [boxes]\n  (first (filter bad? boxes)))\n\n(defn replace-box [boxes i box]\n  (let [boxes (vec boxes)]\n    (vec (concat\n           (subvec boxes 0 i)\n           (if (some? box) [box] [])\n           (subvec boxes (inc i))))))\n\n(defn make-good-box [a b]\n  (filter pos? (concat a b)))\n\n(defn replce-bad [boxes i]\n  (if-let [bad-box (first-bad (drop (inc i) boxes))]\n    (let [bad-i (index-of boxes bad-box i)\n          good-box (make-good-box (nth boxes i) bad-box)\n          boxes (replace-box boxes bad-i nil)]\n      (replace-box boxes i good-box))\n    (replace-box boxes i nil)))\n\n(defn filter-some-good [boxes]\n  (filter (partial some pos?) boxes))\n\n(defn bad_apples [input]\n  (loop [boxes (filter-some-good input) i 0]\n    (if (>= i (count boxes)) boxes\n      (recur\n        (if (bad? (nth boxes i)) (replce-bad boxes i) boxes)\n        (inc i)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18182,"user_id":null,"body":"(ns katas.bad_apples)\n\n(defn fresh?\n  \"Returns true if package contains no 0s,\n  i.e. both apples are fresh.\"\n  [package]\n  (not-any? #(= 0 %) package))\n\n(defn retrieve-fresh\n  \"Retrieves fresh apple from rotten package\"\n  [package]\n  (reduce + package))\n\n(defn unusable?\n  \"Identifies packages with two rotten apples.\"\n  [package]\n  (zero? (retrieve-fresh package)))\n\n(defn replace-rotten\n  \"Combines two packages, each with only one fresh apple.\"\n  [apple package]\n  (conj [] apple (retrieve-fresh package)))\n\n(defn purge-rotten\n  \"Eliminates packages with zero fresh apples.\"\n  [packages]\n  (remove unusable? packages))\n\n(defn find-pair\n  \"Returns the next half-rotten package,\n  or an empty vector if none remaining.\"\n  [packages]\n  (let [pair (first (drop-while fresh? packages))]\n    (if (nil? pair)\n      []\n      pair)))\n\n(defn remove-first-pair\n  \"Removes first rotten package used to complete current rotten package.\"\n  [packages]\n  (concat (take-while fresh? packages) (rest (drop-while fresh? packages))))\n\n(defn pair?\n  [package]\n  (= 2 (count package)))\n\n(defn create-fresh\n  \"Removes rotten apples from package.\"\n  [package]\n  (vec (remove zero? (flatten package))))\n\n(defn bad_apples\n  \"Repairs and removes rotten packages.\"\n  [packages]\n  (let [packs (purge-rotten packages)]\n  (loop [fresh []\n         packs packs]\n    (if (empty? packs)\n      ;; return fresh packages filtered for pairs\n      ;; to eliminate last unsalvagable (pairless) package\n      (filter pair? fresh)\n      (let [current (first packs)\n            remainder (rest packs)]\n        (if (fresh? current)\n          ;; add current package to fresh packages\n          (recur (conj fresh current) remainder)\n          ;; combine current package with next rotten package\n          (recur (conj fresh (create-fresh (conj current (find-pair remainder)))) (remove-first-pair remainder))))))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18183,"user_id":null,"body":"(ns katas.bad_apples)\n\n(defn rotten? [pkg]\n  (every? zero? pkg))\n\n(defn bad? [pkg]\n  (some zero? pkg))\n\n(defn good-apple [pkg]\n  (first (remove zero? pkg)))\n\n(defn v [x y]\n  (vector y x))\n\n(defn merge-pkg [[idx1 pkg1]\n                 [_    pkg2]]\n  (let [x (good-apple pkg1)\n        y (good-apple pkg2)]\n    [idx1 [x y]]))\n\n(defn bad_apples [input]\n  (let [input (remove rotten? input)\n        input (map-indexed vector input)\n        bad?  (comp bad? second)]\n    (->> input\n         (filter bad?)\n         (partition 2)\n         (map #(apply merge-pkg %))\n         (concat (remove bad? input))\n         (sort-by first)\n         (map second))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18184,"user_id":null,"body":"(ns katas.bad_apples)\n(defn rotten? [[x y]]\n  (and (zero? x)\n       (zero? y)))\n\n(defn bad? [[x y]]\n  (or (zero? x)\n      (zero? y)))\n\n(defn good-apple [[x y]]\n  (if (zero? y)\n    x\n    y))\n\n(defn v [x y]\n  (vector y x))\n\n(defn merge-pkg [[pkg1 idx1]\n                 [pkg2 idx2]]\n  (let [x (good-apple pkg1)\n        y (good-apple pkg2)]\n    [[x y] idx1]))\n\n(defn bad_apples [input]\n  (let [input (remove rotten? input)\n        input (map-indexed v input)]\n    (->> input\n         (filter (comp bad? first))\n         (partition 2)\n         (map #(apply merge-pkg %))\n         (concat (remove (comp bad? first) input))\n         (sort-by second)\n         (map first))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18185,"user_id":null,"body":"(ns katas.bad_apples)\n\n(defn scan-apples [acc input]\n  (def pack (first input))\n  (def fst (first  pack))\n  (def snd (second pack))\n  (if (empty? pack)\n    acc\n    (recur\n      (cond\n        (zero? fst) (if (not (zero? snd)) (conj acc snd) acc)\n        (zero? snd) (if (not (zero? fst)) (conj acc fst) acc)\n        :else acc )\n      (rest input)\n) ) )\n\n(defn pack-apples [e acc input bad]\n  (def pack (first input))\n  (def fst (first  pack))\n  (def snd (second pack))\n  (if (empty? pack)\n    acc\n    (cond\n      (every? zero? pack) (recur e acc (rest input) bad)\n      (some zero? pack) (if (and (even? e) (not (nil? (first bad))))\n                          (recur (inc e) (conj acc (first bad)) (rest input) (rest bad))\n                          (recur (inc e) acc                    (rest input) bad) )\n      :else (recur e (conj acc pack) (rest input) bad)\n    )\n) )\n\n(defn bad_apples [input]\n  (->> input\n       (scan-apples [])\n       (partition 2)    \n       (pack-apples 0 [] input)\n) )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18186,"user_id":null,"body":"(ns katas.bad_apples)\n\n(defn good? [[first-apple second-apple]] (not= 0 (* first-apple second-apple)))\n\n(defn rotten? [[first-apple second-apple]] (= 0 (+ first-apple second-apple)))\n\n(defn bad? [package] (and (not (good? package)) (not (rotten? package))))\n\n(defn fetch-good [[first-apple second-apple]] (+ first-apple second-apple))\n\n(defn combine [first-package second-package] [(fetch-good first-package) (fetch-good second-package)])\n\n(defn get-next-bad [packages] (first (filter bad? packages)))\n\n(defn remove-next-bad [packages]\n  (let [[n m] (split-with good? packages)]\n    (concat n (next m))))\n\n(defn remove-rotten [packages] (remove rotten? packages))\n\n(defn replace-bad \n  [origin result]\n  (let [current (first origin)\n        remaining (next origin)\n        next-bad (get-next-bad remaining)]\n    (cond\n      (empty? origin) result\n      (good? current) (recur remaining (conj result current))\n      next-bad (recur (remove-next-bad remaining) (conj result (combine current next-bad)))\n      :else (recur remaining result))))\n\n(defn bad_apples [input] (replace-bad (remove-rotten input) []))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18187,"user_id":null,"body":"(ns katas.bad_apples)\n\n(defn bfix [n n1 box]\n  (let [a (apply max (get box n [0]))\n        b (apply max (get box n1 [0]))]\n    (dissoc (assoc box n [a b]) n1)))\n\n(defn bad_apples [input]\n  (let [{:keys [box bad]} (reduce\n                           (fn [m [i package]]\n                             (assoc m\n                                    :box (assoc (:box m) i package)\n                                    :bad (if (some zero? package)\n                                           (conj (get m :bad []) i)\n                                           (get m :bad []))))\n                           {:box {}}\n                           (map-indexed vector\n                                        (remove (partial every? zero?) input)))]\n    (map second\n         (sort-by first\n                  (loop [[n n1 & r] bad\n                         b box]\n                    (cond (and (nil? n) (nil? n1))\n                          b\n\n                          (nil? n1)\n                          (dissoc b n)\n\n                          :else\n                          (recur r (bfix n n1 b))))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"597770e98b4b340e5b000071":[{"id":18188,"user_id":null,"body":"(ns file-name-extractor)\n\n(defn extract-file-name [s]\n  (clojure.string\/replace s #\"^\\d*_|\\.[^\\.]*$\" \"\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18189,"user_id":null,"body":"(ns file-name-extractor)\n\n(defn extract-file-name [dirty-file-name]\n  (get (re-find #\"\\d+_([-\\w]+\\.\\w+)\" dirty-file-name) 1)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18190,"user_id":null,"body":"(ns file-name-extractor)\n\n(defn extract-file-name [dirty-file-name]\n  (as->\n    (re-seq #\"\\D+\" dirty-file-name) $\n    (first $)\n    (clojure.string\/split $ #\"\")\n    (rest $)\n    (reduce (fn [a v]\n              (if (< (or (get (frequencies a) \".\") 0) 2)\n                (conj a v)\n                a)\n              ) [] $)\n    (butlast $)\n    (clojure.string\/join \"\" $)\n    )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18191,"user_id":2111,"body":"(ns file-name-extractor)\n\n(defn extract-file-name [dirty-file-name]\n  (re-find #\"(?<=_)[^.]*\\.[^.]*\" dirty-file-name )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18192,"user_id":null,"body":"(ns file-name-extractor)\n\n(defn extract-file-name [dirty-file-name]\n  (second (re-find #\"^[0-9]+_([a-zA-Z_-]+\\.[a-zA-Z_-]+)\\.\" dirty-file-name))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18193,"user_id":null,"body":"(ns file-name-extractor)\n\n(defn extract-file-name [dirty-file-name]\n  (get (re-matches #\"(\\d+_)([\\w-]+\\.[\\w-]+)(\\.[\\w-]+)\" dirty-file-name) 2)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18194,"user_id":null,"body":"(ns file-name-extractor)\n\n(defn extract-file-name [dirty-file-name]\n  (as-> dirty-file-name d\n       (re-find #\"(\\d+)_(([a-z]|_|[A-Z]|-|[0-9])+.([a-z]|[A-Z])+).\" d)\n       (nth d 2)))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18195,"user_id":null,"body":"(ns file-name-extractor)\n\n(def extract-file-name\n  (comp second first (partial re-seq #\"\\d+_([^.]+\\.[^.]+)\\..+\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18196,"user_id":null,"body":"(ns file-name-extractor)\n\n(defn extract-file-name [dirty-file-name]\n  (last (re-matches #\"^[0-9]+_([a-zA-Z_-]+\\.[a-zA-Z_-]+)\\..*$\" dirty-file-name)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18197,"user_id":201,"body":"(ns file-name-extractor)\n\n(defn extract-file-name [dirty-file-name]\n   (let [re (re-matcher #\"\\d+_([^.]+)\\.([^.]+)\\.(\\w+)\" dirty-file-name)]\n     (clojure.string\/join \".\" (butlast (rest (re-find re))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"59c5f4e9d751df43cf000035":[{"id":18198,"user_id":527,"body":"(ns longest-vowel.core)\n\n(defn solve [s]\n  (->> s (re-seq #\"[aeiou]+\") (map count) (apply max 0)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18199,"user_id":null,"body":"(ns longest-vowel.core)\n\n(defn solve [s]\n  (->> s\n    (re-seq #\"[aeiou]+\")\n    (map count)\n    (reduce max 0)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18200,"user_id":null,"body":"(ns longest-vowel.core)\n\n(defn is-vowel? [c]\n  (some #(= c %) \"aeiou\"))\n\n(defn solve [s]\n  (apply max (map count (filter #(is-vowel? (first %)) (partition-by is-vowel? s)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18201,"user_id":53,"body":"(ns longest-vowel.core)\n\n(defn vowel? [c]\n  (or (= c \\a) (= c \\e) (= c \\u) (= c \\i) (= c \\o)))\n\n(defn solve [s]\n  (loop [xs (map char s) m 0 n 0]\n    (cond\n      (empty? xs) (if (> n m) n m)\n      (vowel? (first xs)) (recur (rest xs) m (inc n))\n      :else (recur (rest xs) (max m n) 0))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18202,"user_id":1400,"body":"(ns longest-vowel.core)\n\n(defn solve [s]\n  (loop [r s run 0 longest 0]\n    (if (empty? r)\n      (max run longest)\n      (if (contains? #{\\o \\e \\a \\i \\u} (first r))\n        (recur (rest r) (inc run) longest)\n        (recur (rest r) 0 (max run longest))\n      )\n    )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18203,"user_id":168,"body":"(ns longest-vowel.core)\n\n(defn solve [s]\n  (->> (re-seq #\"[aeiou]+\" s)\n       (map count)\n       (apply max 0)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18204,"user_id":null,"body":"(ns longest-vowel.core)\n\n(defn solve [s]\n  (->> s (re-seq #\"[aeiou]+\") (map count) (apply max)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18205,"user_id":null,"body":"(ns longest-vowel.core)\n\n(def vowels '(\\a \\e \\i \\o \\u))\n\n(defn vowel? [c] (or (some #(= % c) vowels) false))\n\n(defn solve [s]\n  (->>\n    s\n    (partition-by vowel?)\n    (filter #(vowel? (first %)))\n    (map count)\n    (apply max)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18206,"user_id":null,"body":"(ns longest-vowel.core)\n\n(defn solve [s]\n  (->> (clojure.string\/split s #\"[^aeiou]+\")\n      (map count)\n      (apply max))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18207,"user_id":null,"body":"(ns longest-vowel.core)\n\n(defn solve [s]\n  (apply max (map count (re-seq #\"[aieou]+\" s)))  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"59c68ea2aeb2843e18000109":[{"id":18208,"user_id":492,"body":"(ns finance-purchase.core)\n\n(defn amort [rate balance term num-payments]\n  (let [r (\/ rate 1200.0) payment (\/ (* r balance) (- 1.0 (Math\/pow (+ 1.0 r)(- term))))]\n    (loop [i 0 interest 0.0 principal 0.0 bal balance]      \n      (if (>= i num-payments)\n        (format \"num_payment %d c %.0f princ %.0f int %.0f balance %.0f\" i payment principal interest bal)\n        (let [ir (* bal r) p (- payment ir) b (- bal p)]\n          (recur (inc i) ir p b))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18209,"user_id":null,"body":"(ns finance-purchase.core)\n\n(defn print-row [{n :n c :c p :p i :i b :b}]\n  (str (format \"num_payment %d\" n)\n       (format \" c %.0f\" c)\n       (format \" princ %.0f\" p)\n       (format \" int %.0f\" i)\n       (format \" balance %.0f\" b)))\n\n(defn get-monthly-rate [r]\n  (\/ (\/ r 12) 100))\n\n(defn get-monthly-payment [r p t]\n  ;; get fixed monthtly payment given rate r, principal p, and term t\n  (\/ (* r p) (- 1 (Math\/pow (+ 1 r) (- t)))))\n\n(defn get-first-row [r b t]\n  ;; get the first amortization for the first month; rate is rate per monthly period\n  {:b b :r r :c (get-monthly-payment r b t) :n 0})\n\n(defn apply-payment [{b :b r :r c :c n :n}]\n  ;; apply payment, where b is the current balance, p is the principal applied, i is the interest applied\n  (let [i (* b r)\n        p (- c i)\n        b (- b p)]\n    {:n (inc n) :c c :b b :p p :i i :r r}))\n\n(defn amort [r b t n]\n  ;; apply payments n times using initial balance b for periods n; t is terms in the same units as n\n  (->> (get-first-row (get-monthly-rate r) b t)\n       (iterate apply-payment)\n       (take (inc n))\n       last\n       print-row))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18210,"user_id":null,"body":"(ns finance-purchase.core)\n\n(defn amort [rate balance term num-payments]\n  (let [mrate (\/ rate 1200.0)\n        n (* mrate balance)\n        d (- 1 (Math\/pow (+ 1 mrate) (- term)))\n        c (\/ n d)\n        it (fn [[np _ _ _ bal]]\n             (let [n (* mrate bal)]\n               [(inc np) c (- c n) n (- bal (- c n))]))]\n    (apply format \"num_payment %d c %.0f princ %.0f int %.0f balance %.0f\"\n            (nth (iterate it [0 0 0 0 balance]) num-payments))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"59ca8e8e1a68b7de740001f4":[{"id":18211,"user_id":564,"body":"(ns kata)\n\n(defn solve [xs ys]\n  (map (fn [y] (count (filter #(= % y) xs))) ys))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18212,"user_id":527,"body":"(ns kata)\n\n(defn solve [xs ys]\n  (map (fn [y] (->> xs (filter (fn [x] (= x y))) count)) ys))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18213,"user_id":null,"body":"(ns kata)\n\n(defn solve [xs ys]\n  (reduce\n    (fn\n      [acc x]\n      (map-indexed\n        (fn\n          [idx cnt]\n          (if\n            (= x (nth ys idx))\n            (inc cnt)\n            cnt))\n        acc))\n    (map (fn [_] 0) ys)\n    xs))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18214,"user_id":null,"body":"(ns kata)\n\n(defn solve [xs ys]\n  (let [fr (frequencies xs)]\n    (map #(get fr % 0) ys)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18215,"user_id":null,"body":"(ns kata)\n\n(defn count-in-seq [sq item]\n  (count (filter #(= item %) sq)))\n\n(defn solve [xs ys]\n  (map (partial count-in-seq xs) ys))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18216,"user_id":null,"body":"(ns kata)\n\n(defn solve [xs ys]\n  (map #(count (filter (fn [val] (= val %)) xs)) ys)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18217,"user_id":null,"body":"(ns kata)\n\n(defn solve [xs ys]\n  (map (fn [y] (count (filter (fn [i] (= i y)) xs))) ys))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"59ccf051dcc4050f7800008f":[{"id":18218,"user_id":null,"body":"(ns buddy-pair.core)\n\n(defn sum-divisors [x]\n  (reduce + 1 (map #(+ (quot x %) %) (filter #(zero? (mod x %)) (range 2 (Math\/sqrt x))))))\n\n(defn find-buddy [x]\n  (let [buddy (dec (sum-divisors x))]\n    (if (and (> buddy x) (= x (dec (sum-divisors buddy))))\n      (list x buddy)\n      '())))\n\n(defn buddy [start limit]\n  (loop [i start result '()]    \n    (if (> i (inc limit))\n      \"Nothing\"\n      (if (not (empty? result))\n        (str result)\n        (recur (inc i) (find-buddy i))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18219,"user_id":53,"body":"(ns buddy-pair.core)\n\n(defn fdivsum [n]\n  (loop [i 2 m 0]\n    (cond \n      (> i (Math\/sqrt n)) m\n      (zero? (mod n i)) \n        (if (= n (quot n i))\n          (recur (inc i) (+ m i))\n          (recur (inc i) (+ m i (quot n i))))\n      :else (recur (inc i) m))))\n\n(defn buddy [a b]\n  (loop [i a]\n    (let [k (fdivsum i)]\n      (cond\n        (> i b) \"Nothing\"\n        (and (< i k) (= i (fdivsum k))) (format \"(%d %d)\" i k)\n        :else (recur (inc i))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18220,"user_id":168,"body":"(ns buddy-pair.core)\n\n(defn sum-divisors [n]\n  (->> (range 2 (inc (int (Math\/sqrt n))))\n       (filter #(zero? (rem n %)))\n       (map #(+ % (if (= (* % %) n) 0 (quot n %))))\n       (apply + 1)))\n\n(defn buddy [start nd]\n   (->> (range start (inc nd))\n        (map #(vector % (dec (sum-divisors %))))\n        (filter #(and (> (second %) (first %)) (= (sum-divisors (second %)) (inc (first %)))))\n        (first)\n        ((fn [r] (if r (apply (partial format \"(%d %d)\") r) \"Nothing\")))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18221,"user_id":null,"body":"(ns buddy-pair.core)\n\n(defn sum-of-divisors [x]\n  (inc (reduce (fn [left right]\n                 (if (zero? (rem x right))\n                   (let [inverse (\/ x right)]\n                     (if (= inverse right)\n                       (+ left right)\n                       (+ left inverse right)))\n                   left)) 0 (range 2 (inc (Math\/sqrt x))))))\n\n(defn buddy [start nd]\n  (let [res (->> (map (fn [x]\n                        [x (sum-of-divisors x)]) (range start (inc nd)))\n                 (filter #(> (- (second %) (first %)) 2))\n                 (filter (fn [i]\n                           (= (first i) (dec (sum-of-divisors (dec (second i)))))))\n                 )]\n    (if (empty? res)\n      \"Nothing\"\n      (->> res\n           (first)\n           ((fn [[a b]]\n              (str \"(\" a \" \" (dec b) \")\"))))))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18222,"user_id":null,"body":"(ns buddy-pair.core)\n\n(def prime?\n  (memoize\n   (fn [n] (.isProbablePrime (biginteger n) 100))))\n\n(def next-prime\n  (memoize\n   (fn [n] (-> n biginteger (.nextProbablePrime)))))\n\n(defn- prime-factors [n]\n  (loop [x n p 2 res []]\n    (if (prime? x)\n      (conj res x)\n      (if (zero? (rem x p))\n        (recur (quot x p) p (conj res p))\n        (recur x (next-prime p) res)))))\n\n(defn- exp-sum [x n]\n  (bigint\n   (transduce\n   (map #(Math\/pow x %))\n   +'\n   (range 0 (inc n)))))\n\n(defn- divisors-sum [n]\n  (reduce-kv\n   (fn [fct x n] (*' fct (exp-sum x n)))\n   1\n   (frequencies (prime-factors n))))\n\n(defn- proper-divisors-sum [n]\n  (- (divisors-sum n) n))\n\n(defn- is-buddy? [x y]\n  (= (-> x proper-divisors-sum dec) y))\n\n(defn solve [s e]\n  (some\n   (fn [x]\n     (let [y (-> x proper-divisors-sum dec)]\n       (when (and (> y x) (is-buddy? y x)) [x y])))\n   (range s (inc e))))\n\n(defn buddy [s e]\n  (if-some [[x y] (solve s e) ]\n    (format \"(%d %d)\" (biginteger x) (biginteger y)) \"Nothing\"))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18223,"user_id":492,"body":"(ns buddy-pair.core)\n\n(defn- nbd [n]\n  (let [rac (Math\/sqrt n)]\n    (->> (filter #(zero? (mod n %)) (range 2 rac))\n         (map #(+ (quot n %) %))\n         (reduce +)\n         (+ 1)\n         (+ (if (= rac (Math\/ceil rac)) (int rac) 0)))))\n(defn buddy [start nd]\n  (loop [n start fin false res \"\"]\n    (if (> n nd)\n      \"Nothing\"\n      (if (= fin true)\n        res\n        (let [m (- (nbd n) 1)]\n          (if (and (< n m) (= n (- (nbd m) 1)))\n            (recur n true (str (list n m)))\n            (recur (inc n) false \"\")))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18224,"user_id":null,"body":"(ns buddy-pair.core)\n\n(defn divisors [n]\n  (loop [\n         current 2\n         divisors #{1}\n         limit (inc (int (Math\/sqrt n)))\n        ]\n        (if (>= current limit)\n          divisors\n          (if (= 0 (mod n current))\n            (recur (inc current) (conj divisors current (\/ n current)) limit)\n            (recur (inc current) divisors limit)\n          )\n        )\n  )\n)\n\n(defn buddy [start n]\n  (loop [\n         current start\n        ]\n        (if (> current n)\n          \"Nothing\"\n          (let [\n                n current\n                div (divisors n)\n                candidate (dec (apply + div))\n               ]\n               (if (and (> candidate n) (= n (dec (apply + (divisors candidate)))))\n                 (str (list current candidate))\n                 (recur (inc current))\n               )\n          )\n        )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18225,"user_id":null,"body":"(ns buddy-pair.core)\n\n(defn proper-divisors [n]\n  (->> (range 1 (inc (Math\/sqrt n)))\n       (filter #(= 0 (mod n %)))\n       (mapcat #(if (or (= % (quot n %)) (= n (quot n %)))\n                  (list %)\n                  (list % (quot n %))))))\n\n(defn get-buddy [n]\n  (let [m (dec (apply + (proper-divisors n)))]\n    (cond\n      (<= m n) nil\n      (= (inc n) (apply + (proper-divisors m))) (list n m)\n      :else nil)))\n\n(defn buddy [start nd]\n  (let [res (->> (range start (inc nd))\n                 (map get-buddy)\n                 (filter some?)\n                 (first))]\n    (if res (str res)\n            \"Nothing\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18226,"user_id":null,"body":"(ns buddy-pair.core)\n\n(defn divisors [n]\n  (let [m (int (Math\/sqrt n))]\n    (reduce (fn [acc i]\n                (if (zero? (mod n i))\n                  (conj acc i (\/ n i))\n                  acc))\n            #{1}\n            (range 2 (inc m)))))\n\n(defn s [n]\n (apply + (divisors n)))\n\n(defn buddy [start nd]\n  (let [limit (map vector (range start nd) (map s (range start nd)))\n        result (->> (filter (fn [[x y]] (or (< x y))) limit)\n                    (filter (fn [[x y]] (= (inc x) (s (dec y)))))\n                    (map (fn [[x y]] [x (dec y)]))\n                    (first)\n                    (#(format \"(%d %d)\" (first %) (second %))))]\n   (if (= \"(null null)\" result)\n     \"Nothing\"\n     result)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18227,"user_id":null,"body":"(ns buddy-pair.core)\n\n(defn s [n]\n  (->> (range 1 (inc (int (Math\/sqrt n))))\n       (keep #(if (zero? (mod n %))\n                [% (\/ n %)]))\n       (flatten)\n       (sort)\n       (butlast)\n       (dedupe)\n       (apply +))) \n\n(defn buddy [start nd]\n  (let [limit (map vector (range start nd) (map s (range start nd)))\n        result (->> (filter (fn [[x y]] (or (< x y))) limit)\n                    (filter (fn [[x y]] (= (inc x) (s (dec y)))))\n                    (map (fn [[x y]] [x (dec y)]))\n                    (map (partial into ()))\n                    (map (partial sort <))\n                    (take 1)\n                    (apply str))]\n  (if (empty? result)\n    \"Nothing\"\n    result)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"59cfc000aeb2844d16000075":[{"id":18228,"user_id":null,"body":"(ns kata.core\n  (require [clojure.string :as str]))\n  \n(defn solve [s]\n  [(apply str (map-indexed (fn [i c] (if (odd? i) c (str\/upper-case c))) s))  \n   (apply str (map-indexed (fn [i c] (if (even? i) c (str\/upper-case c))) s))])","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18229,"user_id":501,"body":"(ns kata.core\n  (:require [clojure.string :as st]))\n  \n(defn solve [s]\n\t(let [ a (st\/join (map-indexed (fn [i e] (if (even? i) (st\/upper-case e) e)) s))\n\t\t     b (st\/join (map-indexed (fn [i e] (if (odd? i) (st\/upper-case e) e)) s))\n\t\t   ]\n\t[a,b] ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18230,"user_id":null,"body":"(ns kata.core)\n  \n(defn cap [items]\n  (let [[indx value] items]\n    (if (even? indx)\n      (clojure.string\/lower-case value)\n      (clojure.string\/upper-case value))))\n\n(defn cap-2 [items]\n  (let [[indx value] items]\n    (if (even? indx)\n      (clojure.string\/upper-case value)\n      (clojure.string\/lower-case value))))\n\n(defn solve [s]\n  (let [v (map-indexed vector s)]\n    [(apply str (map cap-2 v)) (apply str (map cap v))]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18231,"user_id":null,"body":"(ns kata.core)\n\n(defn doit [s f1 f2]\n(apply str\n    (map (fn [c f] (f c))\n          s\n          (interleave (repeat f1)\n                      (repeat f2)))))\n(defn solve [s]\n [(doit s\n        clojure.string\/upper-case\n        clojure.string\/lower-case)\n  (doit s\n        clojure.string\/lower-case\n        clojure.string\/upper-case)])\n        ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18232,"user_id":null,"body":"(ns kata.core)\n\n(defn- upcase [c]\n  (Character\/toUpperCase c))\n  \n(defn solve [s]\n  [(apply str (map #(%1 %2) (cycle [upcase identity]) s))\n   (apply str (map #(%1 %2) (cycle [identity upcase]) s))])\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18233,"user_id":null,"body":"(ns kata.core)\n  \n(defn solve [s]\n  (loop [first_seq (seq (.toUpperCase s))\n         second_seq (seq (.toLowerCase s))\n         first_collection []\n         second_collection []]\n    (if (empty? first_seq)\n      [(reduce str first_collection) (reduce str second_collection)] ; Join the chars, return the answer.\n      (recur (rest second_seq)   ; the character sequences we are cannibalizing will             \n             (rest first_seq)    ; alternate with each other. \n             (conj first_collection (first first_seq))       \n             (conj second_collection (first second_seq))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18234,"user_id":1703,"body":"(ns kata.core)\n\n(require '[clojure.string :as stg])\n  \n(defn solve [s]\n  (let [up (stg\/join \"\" (map-indexed #(if(even? %1)(stg\/upper-case(str %2)) (str %2)) s))\n        dn (stg\/join \"\" (map-indexed #(if(odd? %1)(stg\/upper-case(str %2)) (str %2)) s))]\n    [up dn]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18235,"user_id":null,"body":"(ns kata.core\n  (:require [clojure.string :as string]))\n\n\n(defn solve [s]\n  (let [s (string\/split s #\"\")]\n    [(string\/join \"\" (map-indexed (fn [idx c] (if (even? idx) (string\/capitalize c) c)) s)) \n     (string\/join \"\" (map-indexed (fn [idx c] (if (odd? idx) (string\/capitalize c) c)) s))]))\n\n(solve \"asdfasdf\")\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18236,"user_id":null,"body":"(ns kata.core)\n  \n(defn invert-case [c]\n  (if (Character\/isUpperCase c) (clojure.string\/lower-case c)\n                                (clojure.string\/upper-case c)))\n\n(defn check-odd [[index, value]]\n  (if (odd? index) (vector index (invert-case value))\n                   [index, value]))\n\n(defn check-even [[index, value]]\n  (if (even? index) (vector index (invert-case value))\n                    [index, value]))\n\n(defn alter-cap [check-fn s]\n  (apply str (map #(second %) (map check-fn (map-indexed vector s)))))\n\n(defn solve [s]\n  ((juxt #(alter-cap check-even %)\n         #(alter-cap check-odd %)) s))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18237,"user_id":null,"body":"(ns kata.core\n  (:require [clojure.string :as str]))\n  \n\n\n(defn solve [s]\n  (letfn [(capitalise-map-val [map-key]\n                             #(if (% map-key)\n                                (str\/upper-case (first (vals %)))\n                                (first (vals %))))]\n    (let [mapped-even-or-odd (map #(hash-map %1 %2)\n                                  (cycle '(:even :odd))\n                                  s)\n          even-caps (apply str (map (capitalise-map-val :even)\n                                    mapped-even-or-odd))\n          odd-caps (apply str (map (capitalise-map-val :odd)\n                                   mapped-even-or-odd))]\n      [even-caps odd-caps])))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"59cfc09a86a6fdf6df0000f1":[{"id":18238,"user_id":null,"body":"(ns indexed-cap.core)\n\n(defn solve [s idx]\n  (->> s\n    (map-indexed vector)\n    (map (fn [[i c]] (if (some #{i} idx) (clojure.string\/upper-case c) c)))\n    (clojure.string\/join \"\") ))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18239,"user_id":null,"body":"(ns indexed-cap.core)\n\n(defn solve [s idx]\n  (apply str (map-indexed \n              #(if (some #{%} idx) \n                 (char (- (int %2) 32))\n                 %2) \n              s)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18240,"user_id":null,"body":"(ns indexed-cap.core)\n\n(defn solve [s idx]\n  (let [pred (set idx)\n        upper (fn [i ch] (if (pred i) (Character\/toUpperCase ch) ch))]\n    (clojure.string\/join (map-indexed upper s))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18241,"user_id":null,"body":"(ns indexed-cap.core\n  (:require [clojure.string :as s]))\n\n(defn solve [s idx]\n  (s\/join\n    (let [enum (map-indexed (fn [s id] [s id]) s)]\n      (map (fn [[i letter]]\n             (cond-> letter\n                     (some #(= i %) idx)\n                     (s\/upper-case))) enum))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18242,"user_id":null,"body":"(ns indexed-cap.core)\n\n(defn- includes [i is] (some #(= i %) is))\n\n(defn solve [s idx]\n  (->>\n    (seq s)\n    (map-indexed #(if (includes %1 idx) (Character\/toUpperCase %2) %2))\n    (clojure.string\/join \"\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18243,"user_id":null,"body":"(ns indexed-cap.core)\n\n(defn solve [s idx]\n  (apply str (map-indexed\n              #(if (contains? (set idx) %1) (Character\/toUpperCase %2) %2)\n              s)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18244,"user_id":null,"body":"(ns indexed-cap.core)\n\n(defn solve [s col]\n  \"Return a string with capitalized characters defined by the character index collection\"\n  (if (empty? col)\n    s\n    (let [valid-indexes (filterv #(< % (count s)) col)\n          current-index (peek valid-indexes)\n          remaining-indexes (pop valid-indexes)\n          new-s (str (subs s 0 current-index)\n                     (.toUpperCase (subs s current-index (inc current-index)))\n                     (subs s (inc current-index)))]\n      (recur new-s remaining-indexes))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18245,"user_id":null,"body":"(ns indexed-cap.core)\n\n(def upper #(Character\/toUpperCase %))\n\n(defn solve [string indices]\n  (first\n   (reduce\n     (fn [[builder idcs iter] rune]\n       (let [build       (partial str builder)\n             [fst & rst] idcs\n             bump        (inc iter)]\n         (if (= fst iter)\n           [(build (upper rune)) rst  bump]\n           [(build rune)         idcs bump])))\n     [\"\" indices 0]\n     string)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18246,"user_id":201,"body":"(ns indexed-cap.core)\n\n(defn solve [s idx]\n  (loop [[x :as xs] s\n        num 0\n        acc []\n        ]\n   (if (empty? xs) (apply str acc)\n       (let [new-char (if (some (set [num]) idx) (clojure.string\/upper-case x) x)]\n         (recur (rest xs) (inc num) (conj acc new-char))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18247,"user_id":null,"body":"(ns indexed-cap.core)\n\n(defn capitalize-by-index [string index char]\n  \"Capitalize a letter in string based on index\"\n  (clojure.string\/join (assoc (vec string) index char)))\n\n(defn solve [s idx]\n  \"Recursive solution to the problem\"\n  (cond\n    (empty? idx) s\n    (>= (first idx) (count s)) (solve s (rest idx))\n    :else (solve\n           (capitalize-by-index s (first idx) (clojure.string\/upper-case (str (nth s (first idx)))))\n           (rest idx))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"59d0ee709f0cbcf65400003b":[{"id":18248,"user_id":null,"body":"(ns bystate.core\n  (:require [clojure.string :as str]))\n\n(def state->name\n  {\"AZ\" \"Arizona\"\n   \"CA\" \"California\"\n   \"ID\" \"Idaho\"\n   \"IN\" \"Indiana\"\n   \"MA\" \"Massachusetts\"\n   \"OK\" \"Oklahoma\"\n   \"PA\" \"Pennsylvania\"\n   \"VA\" \"Virginia\"})\n\n(defn by-state [friends]\n  (let [m (reduce (fn [acc friend]\n                    (let [[name address city+state] (str\/split friend #\",\\s\")\n                          [_ city state] (re-matches #\"(.+)\\s([A-Z][A-Z])\" city+state)\n                          m {:name name, :address address, :city city, :state state}]\n                      (update acc state (fnil conj []) m)))\n                  {}\n                  (str\/split friends #\"\n\"))]\n    (str\/join \"\n\"\n              (map-indexed (fn [index state]\n                             (str (when (pos? index) \" \")\n                                  (state->name state)\n                                  \"\n\"\n                                  (str\/join \"\n\"\n                                            (map (fn [{:keys [name address city state]}]\n                                                   (format \"..... %s %s %s %s\"\n                                                           name\n                                                           address\n                                                           city\n                                                           (state->name state)))\n                                                 (sort-by :name (get m state))))))\n                           (sort (keys m))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18249,"user_id":null,"body":"(ns bystate.core\n  (require [clojure.string :as str]))\n    \n(def states {\"AZ\"  \"Arizona\"\n             \"CA\" \"California\"\n             \"ID\" \"Idaho\"\n             \"IN\" \"Indiana\"\n             \"MA\" \"Massachusetts\"\n             \"OK\" \"Oklahoma\"\n             \"PA\" \"Pennsylvania\"\n             \"VA\" \"Virginia\"})\n\n(defn vec->map [[friend address city-and-state]]\n  (let [city              (str\/trim (subs city-and-state 0 (- (count city-and-state) 2)))\n        state             (str\/trim (subs city-and-state (- (count city-and-state) 2)))]\n    (prn state)\n    {:name  friend\n     :address (str\/trim address)\n     :state   (states state)\n     :city    city}))\n\n(defn friend->address-string [{:keys [name address state city]}]\n  (str \"..... \" name \" \" address \" \" city  \" \" state \"\n\"))\n\n(defn by-state [addresses]\n  (let [friends-by-state (->> (str\/split-lines addresses)\n                              (map #(str\/split % #\",\"))\n                              (map vec->map)\n                              (sort-by (juxt :state :name))\n                              (group-by :state))]\n    friends-by-state\n    (->> (for [state (keys friends-by-state)]\n           [state (->> (map friend->address-string (friends-by-state state))\n                       (apply str))])\n         (map #(str \" \" (first %) \"\n\" (second %)))\n         (apply str)\n         (str\/trim))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18250,"user_id":201,"body":"(ns bystate.core)\n    \n(defn by-state [strng]  \n    (let [states {\"AZ\" \"Arizona\"\n                 \"CA\" \"California\"\n                 \"ID\" \"Idaho\"\n                 \"IN\" \"Indiana\"\n                 \"MA\" \"Massachusetts\"\n                 \"OK\" \"Oklahoma\"\n                 \"PA\" \"Pennsylvania\"\n                 \"VA\" \"Virginia\"}\n         s  (clojure.string\/split-lines (clojure.string\/replace strng \",\" \"\"))]\n     (let [elem (group-by first\n                          (sort-by (fn [s] (apply str (take 3 s)))\n                           (map (fn [line]\n                                  (let [state (get states (apply str (take-last 2 line)))]\n                                    [state\n                                     (apply str (conj (vec (drop-last 2 line)) state))]))\n                                s)))]\n            (apply str (rest (clojure.string\/join \"\n\"\n                                                  (for [x elem]\n                                                    (let [state (first x)\n                                                          lines (second x)]\n                                                      (clojure.string\/join \"\n\"\n                                                                           (conj (map #(str \"..... \" %) (sort (map second lines))) (str \" \" state)))))))))))\n \n  \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18251,"user_id":null,"body":"(ns bystate.core\n  (:require [clojure.string :refer [split split-lines join]]))\n\n(def states {\n  \"AZ\" \"Arizona\"\n  \"CA\" \"California\"\n  \"ID\" \"Idaho\"\n  \"IN\" \"Indiana\"\n  \"MA\" \"Massachusetts\"\n  \"OK\" \"Oklahoma\"\n  \"PA\" \"Pennsylvania\"\n  \"VA\" \"Virginia\"})\n\n(defn proc-record [record]\n  (let [[nam addr city-state] (split record #\", \")\n        city-stat (split city-state #\" \")\n        city (join \" \" (butlast city-stat))\n        state (states (last city-stat))]\n    [nam addr city state]))\n\n(defn groupped-2-str [state records]\n  (->> (map #(join \" \" %) records)\n       (cons state)\n       (join \"\n..... \")))\n\n(defn by-state [strng]  \n  (let [groupped (group-by last (map proc-record (split-lines strng)))]\n    (->> (sort (keys groupped))\n         (map #(groupped-2-str % (sort-by first (groupped %))))\n         (join \"\n \"))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18252,"user_id":492,"body":"(ns bystate.core)\n    \n(defn by-state [strng]  \n  (defn classify [strng] \n    (defn subst [strng]\n      (def sa [\" MA\" \" VA\" \" OK\" \" PA\" \" CA\" \" AZ\" \" ID\" \" IN\"])\n      (def st [\", Massachusetts\" \", Virginia\" \", Oklahoma\" \", Pennsylvania\" \", California\" \", Arizona\" \", Idaho\" \", Indiana\"])\n      (loop [i 0 r strng]\n        (if (= i (count sa))\n          r\n        (recur (inc i) (clojure.string\/replace r (sa i) (st i)))))\n    )\n    (defn compsort [a b]\n      (if (= (a 0) (b 0))\n        (compare (a 1) (b 1))\n        (compare (a 0) (b 0))))\n  \n  (let [arr (clojure.string\/split (subst strng) #\"\n\")]\n    (loop [i 0 narr []]\n      (if (= i (count arr))\n        (sort compsort narr)\n        (let [line (clojure.string\/split (arr i) #\",\")]\n          (recur (inc i) (conj narr [(clojure.string\/trim (line 3))\n                                     (clojure.string\/trim (line 0)) \n                                     (clojure.string\/trim (line 1))\n                                     (clojure.string\/trim (line 2))\n                                    ])))))))\n  \n  (let [narr (vec (classify strng))]\n    (loop [i 0 res \"\" last \"\"] \n      (if (= i (count narr))\n        (subs res 2)\n        (let [line (narr i) l (line 0)]\n          (if (not= l last)\n            (recur (inc i) (str res \"\n \" l \"\n..... \" (line 1) \" \" (line 2) \" \" (line 3) \" \" l) l)\n            (recur (inc i) (str res \"\n..... \" (line 1) \" \" (line 2) \" \" (line 3) \" \" l) l)))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18253,"user_id":492,"body":"(ns bystate.core)\n    \n(defn by-state [strng]  \n  (defn classify [strng] \n    (defn subst [strng]\n      (def sa [\" MA\" \" VA\" \" OK\" \" PA\" \" CA\" \" AZ\" \" ID\" \" IN\"])\n      (def st [\", Massachusetts\" \", Virginia\" \", Oklahoma\" \", Pennsylvania\" \", California\" \", Arizona\" \", Idaho\" \", Indiana\"])\n      (loop [i 0 r strng]\n        (if (= i (count sa))\n          r\n        (recur (inc i) (clojure.string\/replace r (sa i) (st i)))))\n    )\n    (defn compsort [a b]\n      (if (= (a 0) (b 0))\n        (compare (a 1) (b 1))\n        (compare (a 0) (b 0))))\n  \n  (let [arr (clojure.string\/split (subst strng) #\"\n\")]\n    (loop [i 0 narr []]\n      (if (= i (count arr))\n        (sort compsort narr)\n        (let [line (clojure.string\/split (arr i) #\",\")]\n          (recur (inc i) (conj narr [(clojure.string\/trim (line 3))\n                                     (clojure.string\/trim (line 0)) \n                                     (clojure.string\/trim (line 1))\n                                     (clojure.string\/trim (line 2))\n                                    ])))))))\n  \n  (let [narr (vec (classify strng))]\n    (loop [i 0 res \"\" last \"\"] \n      (if (= i (count narr))\n        (subs res 2)\n        (let [line (narr i) l (line 0)]\n          (if (not= l last)\n            (recur (inc i) (str res \"\n \" l \"\n..... \" (line 1) \" \" (line 2) \" \" (line 3) \" \" l) l)\n            (recur (inc i) (str res \"\n..... \" (line 1) \" \" (line 2) \" \" (line 3) \" \" l) l)))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"59d727d40e8c9dd2dd00009f":[{"id":18254,"user_id":null,"body":"(ns balance.core)\n\n(require \n  '[clojure.string :as string]\n  '[clojure.edn :as edn]\n  )\n\n(defn get-balance \n  \"Calculate total balance\"\n  [i acc expense] \n  (- (get-in acc [(- i 1) :Balance]) (edn\/read-string expense)))\n\n(defn get-expense\n  \"Calculate total expense\"\n  [i acc expense] \n  (+ (get-in acc [(- i 1) :Total-expense]) (edn\/read-string expense)))\n\n(defn to-ledger \n  \"White results to template format\"\n  [count] \n  (fn [i entry]\n    (str \n      (:order-number entry) \n      (if (= i 0) \"\" \" \") \n      (:name entry) \n      \" \" \n      (if (not= i 0) (format \"%.2f\" (:expense entry))) \n      (if (not= i 0) \" Balance \") \n      (if (not= i 0) (format \"%.2f\" (:Balance entry)) (:Balance-string entry))\n      \"\n\"\n      (if (= i (- count 1)) \n        (str \n          \"Total expense  \" \n          (format \"%.2f\" (:Total-expense entry)) \n          \"\n\" \n          \"Average expense  \"\n          (format \"%.2f\" (\/ (:Total-expense entry) (- count 1))))\n        )\n    )\n  )\n)\n\n(defn reducer \n  \"Mantain state of expenses\" \n  [acc [i [key name expense]]] \n  (into acc\n    (if (= i 0)\n      [ \n        {\n          :order-number nil\n          :name \"Original Balance:\" \n          :expense 0\n          :Balance (edn\/read-string key)\n          :Balance-string key\n          :Total-expense 0\n        }\n      ]\n      [\n        {\n          :order-number key\n          :name name \n          :expense (edn\/read-string expense)\n          :Balance (get-balance i acc expense) \n          :Total-expense (get-expense i acc expense)\n        }\n      ]\n    )))\n\n(defn make-ledger \n  \"Concatenate entries to display ledger string\" \n  [coll] \n  (map-indexed (to-ledger (count coll)) coll))\n\n(defn balance [book]\n  \"Calculate balance\"\n    (-> book \n      ;; Replace bad symbols\n      (string\/replace #\"[!=:?;{}]\" \"\")\n      ;; Break lines\n      (string\/split #\"\n\")\n      (->> \n        ;; Split lines and index\n        (map-indexed (fn [i item] [i (string\/split item #\" \")]))\n        ;; Reduce to maps\n        (reduce reducer [])\n        ;; Make strings \n        (make-ledger)\n        )\n      string\/join\n      ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18255,"user_id":492,"body":"(ns balance.core)\n\n(defn balance [book]\n  (let [clean (clojure.string\/replace book (re-pattern \"[^0-9a-z\\\\s+A-Z\\\n.]\") \"\")\n        arr (clojure.string\/split clean #\"\n\")\n       ]\n    (loop [i 1 current (java.lang.Double\/parseDouble (arr 0)) total 0 res (str \"Original Balance: \" (arr 0))]\n      (if (>= i (count arr))\n        (str res (format \"\nTotal expense  %.2f\nAverage expense  %.2f\" total (\/ total (dec (count arr)))))\n        (let [line (clojure.string\/split (arr i) #\" +\")\n              amount (java.lang.Double\/parseDouble (line 2))\n              current (- current amount)\n              total (+ total amount)\n              res (str res (format \"\n%s %s %s Balance %.2f\" (line 0) (line 1) (line 2) current))\n             ]\n          (recur (inc i) current total res))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18256,"user_id":null,"body":"(ns balance.core)\n\n(defn balance [book]\n  (let [original-balance (Double\/parseDouble (re-find #\"\\d+\\.\\d+\" book))\n        book (partition 3 3 (rest (re-seq #\"\\d+\\.\\d+|\\d+|\\w+\" book)))\n        expanse (map (fn [[_ _ a]] (Double\/parseDouble a)) book)\n        book (map (partial clojure.string\/join \" \") book)\n        total-expanse (apply + expanse)\n        average-expanse (\/ total-expanse (count expanse))\n        balance-changes (->> (reductions - original-balance expanse)\n                     (rest)\n                     (map #(str % (format \"%.2f\" %2)) (repeat \"Balance \")))]\n    (->> (interleave book balance-changes)\n         (partition 2 2)\n         (map (partial clojure.string\/join \" \"))\n         (concat [(format \"Original Balance: %.2f\" original-balance)])\n         (vec)\n         (#(conj % (format \"Total expense  %.2f\" total-expanse)))\n         (#(conj % (format \"Average expense  %.2f\" average-expanse)))\n         (clojure.string\/join \newline))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18257,"user_id":null,"body":"(ns balance.core\n  (require [clojure.string :as str]))\n\n(defn to-check-entry [s]\n  (let [splits (str\/split (str\/replace s #\"[^a-zA-Z\\d\\s\\.]\" \"\") #\" \")]\n    {:chq-no   (read-string (first splits))\n     :category (second splits)\n     :amount   (read-string (nth splits 2))}))\n\n(defn line-summary [[balance report] {:keys [chq-no category amount]}]\n  (let [new-balance (- balance amount)]\n    [new-balance (str report \newline (str (format \"%03d\" chq-no) \" \" category \" \" (format \"%.2f\" amount) \" Balance \" (format \"%.2f\" new-balance)))]))\n\n(defn balance [book]\n  (prn book)\n  (let [lines (str\/split-lines (str\/replace book #\"[^a-zA-Z\\d\\s\\.]\" \"\"))\n        opening-bal (read-string (first lines))\n        entries (->> (rest lines)\n                     (remove #(= \"\" %))\n                     (map to-check-entry))\n        total-expenses (->> entries\n                            (map :amount)\n                            (reduce +))\n        average-expense (\/ total-expenses (count entries))]\n    (str (second (reduce line-summary [opening-bal (str \"Original Balance: \" (format \"%.2f\" opening-bal))] entries))\n         (str \"\nTotal expense  \" (format \"%.2f\" total-expenses))\n         (str \"\nAverage expense  \" (format \"%.2f\" average-expense)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18258,"user_id":null,"body":"(ns balance.core\n  (:require [clojure.string :as string]))\n  \n(defn round [x]\n  (format \"%.2f\" (double x)))\n\n\n(defn balance [book]\n  (let [lines (map  #(string\/replace % #\"[^a-zA-Z0-9. ]\" \"\") (string\/split-lines book))\n        balance (read-string (first lines))\n        string-balance (first lines)  ; Because the tests are broken\n        parsed  (->> (rest lines) \n                     (map #(string\/split % #\"\\s+\")))\n        running (->> (map last parsed)\n                     (map read-string)\n                     (reductions - balance)\n                     (rest)\n                     (map round))\n        total   (reduce + (map (comp read-string last) parsed))\n        avg     (\/ total (count parsed))]\n    (string\/join \"\n\"\n                 (concat [(str \"Original Balance: \" string-balance)]\n                         (map (partial string\/join \" \") (map conj parsed (repeat \"Balance\") running))\n                         [(str \"Total expense  \" (round total))]\n                         [(str \"Average expense  \" (round avg))]))))\n\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"59d9d8cb27ee005972000045":[{"id":18259,"user_id":null,"body":"(ns catalog.core)\n(require '[clojure.string :as strg])\n\n(defn build-catalog [article]\n  (fn [acc group]\n    (let [[item price quantity] (apply vector (rest group))\n          match? (-> article re-pattern (re-find item) boolean)]\n        (if match?\n          (conj acc (str item \" > prx: $\" price \" qty: \" quantity))\n          acc))))\n\n(defn catalog [string article]\n  (->> (re-seq #\"\\<name>([^<]+)\\<\\\/name>\\<prx>(\\d+|\\d+\\.?\\d+)\\<\\\/prx>\\<qty>(\\d+)\\<\\\/qty>\" string)\n       (reduce (build-catalog article) [])\n       (strg\/join \"\n\")\n       (#(if (= % \"\") \"Nothing\" %))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18260,"user_id":null,"body":"(ns catalog.core)\n(require '[clojure.string :as string])\n\n(defn get-tag [tag line]\n  (or (nth (re-find (re-pattern (str \"<\" tag #\">([\\S\\s]+)<\/\" tag \">\")) line) 1) \"\"))\n\n(defn format-output [line]\n  (let [r-name (get-tag \"name\" line)\n        r-prx  (get-tag \"prx\" line)\n        r-qty  (get-tag \"qty\" line)]\n    (str r-name \" > prx: $\" r-prx \" qty: \" r-qty)))\n\n(defn find-in-catalog [s article]\n  (map format-output\n       (filter\n        #(string\/includes? (get-tag \"name\" %) article)\n         (string\/split-lines s))))\n\n(defn catalog [s article]\n  (let [result (string\/join \"\n\" (find-in-catalog s article))]\n    (if (empty? result) \"Nothing\" result)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18261,"user_id":null,"body":"(ns catalog.core)\n\n(require '[clojure.string :as cst]\n         '[clojure.xml :as xml]\n         '[clojure.zip :as zip])\n\n(defn zip-str [s]\n  (->> (.getBytes s)\n       (java.io.ByteArrayInputStream.)\n       (xml\/parse)\n       (zip\/xml-zip)))\n\n(defn catalog [s article]\n  (->> (cst\/split s #\"\n\n\")\n       (map (comp :content first zip-str))\n       (map (fn [[{nam :tag [nam-val] :content}\n                  {prx :tag [prx-val] :content}\n                  {qty :tag [qty-val] :content}]]\n              (hash-map nam nam-val prx prx-val qty qty-val)))\n       (filter #(re-find (re-pattern article) (:name %)))\n       (map #(format \"%s > prx: $%s qty: %s\" (:name %) (:prx %) (:qty %)))\n       (cst\/join \newline)\n       (#(if (empty? %) \"Nothing\" %))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18262,"user_id":492,"body":"(ns catalog.core)\n(require '[clojure.string :as strg])\n\n(defn catalog [s article]\n  (let [c1 (.replaceAll s \"(<prod><name>)\" \"\")\n        c2 (.replace c1 \"<\/name>\" \" > prx: $\")\n        c3 (.replace c2 \"<\/prx>\" \" qty: \")\n        c4 (.replace c3 \"<prx>\" \"\")\n        c5 (.replace c4 \"<qty>\" \"\")\n        c6 (.replaceAll c5 \"(<\/qty><\/prod>)\" \"\")\n        arr (strg\/split c6 #\"\n\n\")\n        res (for [aa arr :when (.contains aa article)] aa)\n       ]\n    (if (= 0 (count res))\n      \"Nothing\"\n      (strg\/join \"\n\" res))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18263,"user_id":null,"body":"(ns catalog.core)\n(require '[clojure.string :as strg])\n\n(defn catalog [s article]\n  (let [output (->> (strg\/split s #\"\n\n\")\n    (filter (fn [s] (strg\/includes? s article)))\n    (map #(strg\/split % #\"<.+?>\"))\n    (map #(filter (partial (comp not strg\/blank?)) %))\n    (map (fn [[name prx qty]] (str name \" > prx: $\" prx \" qty: \" qty)))\n    (strg\/join \"\n\"))]\n    (if (strg\/blank? output) \"Nothing\" output))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18264,"user_id":null,"body":"(ns catalog.core\n  (use [clojure.string :only [split join includes?]]))\n\n(defn catalog [s article]\n  (->> s (#(split % #\"\n\n\"))\n         (map #(re-find #\">([\\s\\w]+)<.+>([\\d\\.]+)<.+>(\\d+)<\" %))\n         (filter #(includes? (nth % 1) article))\n         (map #(format \"%s > prx: $%s qty: %s\" (nth % 1) (nth % 2) (nth % 3)))\n         (join \"\n\")\n         (#(if (empty? %) \"Nothing\" %))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18265,"user_id":null,"body":"(ns catalog.core\n  (use [clojure.string :only [split join includes?]]\n       [clojure.xml :only [parse]]))\n\n(defn parse-string [s]\n  (parse (java.io.ByteArrayInputStream. (.getBytes s))))\n\n(defn findp [prod k]\n  (join (->> prod :content (group-by :tag) k first :content)))\n\n(defn formatp [p s & xs]\n  (apply (partial format s) (map (partial findp p) xs)))\n\n(defn catalog [s article]\n  (let [tree (map parse-string (split s #\"\n\n\"))\n        items (filter #(includes? (findp % :name) article) tree)\n        item_strings (map #(formatp % \"%s > prx: $%s qty: %s\" :name :prx :qty) items)]\n    (if (empty? item_strings) \"Nothing\" (join \"\n\" item_strings))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18266,"user_id":null,"body":"(ns catalog.core\n  (:require [clojure.string :as str]\n            [clojure.pprint :as pprint]))\n\n\n(defn- correct-catalog [s]\n  (->> (str\/split s #\"\n\n\")\n       (map (fn [s]\n         (let [[_ _ nm _ _ prx _ _ qty _ _]\n               (re-seq #\"[A-Za-z\\s]+|[0-9\\.0-9]+\" s)]\n           {:product   nm\n            :price     prx\n            :quantity  qty})))))\n\n\n(defn catalog [s article]\n  (let [catalog* (correct-catalog s)\n        result   (->> catalog*\n                   (map (fn [{:keys [product price quantity]}]\n                          (when (re-find (re-pattern article) product)\n                            (format \"%s > prx: $%s qty: %s\" product price quantity))))\n                   (filter some?)\n                   (str\/join \"\n\"))]\n    (if (not= \"\" result)\n      result\n      \"Nothing\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18267,"user_id":null,"body":"(ns catalog.core)\n  (require '[clojure.string :as str])\n\n(defn item->summary [cat-item]\n  (let [name (nth (re-find #\"(<name>)(.+)(<\\\/name>)\" cat-item) 2)\n        price (nth (re-find #\"(<prx>)(.+)(<\/prx>)\" cat-item) 2)\n        qty (nth (re-find #\"(<qty>)(.+)(<\/qty>)\" cat-item) 2)]\n    {:name name\n    :price price\n    :qty qty}))\n\n(defn item->report [{:keys [name price qty]}]\n  (str name \" > prx: $\" price \" qty: \" qty))\n\n(defn catalog [s article]\n  (let [catalog-items (->> s\n                           (str\/split-lines)\n                           (remove #(= \"\" %))\n                           (map item->summary)\n                           (filter (fn [i] (boolean (re-find (re-pattern (str \"\\\\b\" article \"\\\\b\")) (:name i)))))\n                           (map item->report)\n                           (str\/join \"\n\"))]\n    (if (= \"\" catalog-items)\n      \"Nothing\"\n      catalog-items)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18268,"user_id":null,"body":"(ns catalog.core)\n(require '[clojure.string :as strg])\n\n(defrecord Product [pname price quantity])\n\n(defn parse-name [p]\n  (let [tagged (re-find #\">[A-Za-z\\s]+<\" (re-find #\"<name>[A-Za-z\\s]+<\/name>\" p))]\n    (re-find #\"[A-Za-z\\s]+\" tagged)))\n\n(defn parse-price [p]\n  (re-find #\"\\d*\\.?\\d+\" (re-find #\"<prx>[0-9]*\\.?[0-9]+<\/prx>\" p)))\n\n(defn parse-quantity [p]\n  (re-find #\"\\d+\" (re-find #\"<qty>\\d+<\/qty>\" p)))\n\n(defn parse-product [p]\n  (Product. (parse-name p) (parse-price p) (parse-quantity p)))\n\n(defn name-is-like [article]\n  (fn [product]\n    (not (nil? (re-find (re-pattern article) (:pname product))))))\n\n(defn str-product [p]\n  (format \"%s > prx: $%s qty: %s\" (:pname p) (:price p) (:quantity p)))\n\n(defn output [l]\n  (if (empty? l)\n    \"Nothing\"\n    (apply str l)))\n\n(defn catalog [s article]\n  (->> (strg\/split s #\"\n\n\")\n    (map parse-product)\n    (filter (name-is-like article))\n    (map str-product)\n    (interpose \"\n\")\n    output))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"59d9ff9f7905dfeed50000b0":[{"id":18269,"user_id":null,"body":"(ns kata)\n\n(defn same-no-cased? [a b]\n  (= (clojure.string\/lower-case a) (str b)))\n\n(defn solve-one [s]\n  (count (filter true? (map same-no-cased? s \"abcdefghijklmnopqrstuvwxyz\"))))\n\n(defn solve [arr]\n  (map solve-one arr))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18270,"user_id":null,"body":"(ns kata \n  (:require [clojure.string :as str]))\n\n(defn char-num\n  [c]\n  (- (int c) (int \\A)))\n\n\n(defn match-num-to-pos\n  [s]\n  (let [num-in-pos (->> s\n                     str\/upper-case\n                     (map char-num))]\n    (count (filter identity (for [i (range (count num-in-pos))] (if (= i (nth num-in-pos i)) i))))))\n\n(defn solve [arr]\n   (map match-num-to-pos arr)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18271,"user_id":null,"body":"(ns kata)\n(defn solve [arr]\n  (map \n   (fn [s] \n     (reduce + \n             (keep-indexed\n              #(when\n                 (or\n                  (= %1 (- (int %2) 97))\n                  (= %1 (- (int %2) 65)))\n                 1)\n              s)))\n   arr))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18272,"user_id":null,"body":"(ns kata)\n(defn auxi [frases]\n  (let [alpha \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n        prepare (clojure.string\/upper-case frases)\n        one (map #(clojure.string\/index-of alpha % ) prepare)\n        two (range (count prepare))]\n    (count (filter true? (map #(= %1 %2) one two)))))\n\n(defn solve [arr]\n  (map auxi arr))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18273,"user_id":null,"body":"(ns kata\n  (:require [clojure.string :as str]))\n\n(def dct {\"A\" 0 \"a\" 0 \"B\" 1 \"b\" 1 \"C\" 2 \"c\" 2 \"D\" 3 \"d\" 3 \n          \"E\" 4 \"e\" 4 \"F\" 5 \"f\" 5 \"G\" 6 \"g\" 6 \"H\" 7 \"h\" 7\n          \"I\" 8 \"i\" 8 \"J\" 9 \"j\" 9 \"K\" 10 \"k\" 10 \"L\" 11 \"l\" 11\n          \"M\" 12 \"m\" 12 \"N\" 13 \"n\" 13 \"O\" 14 \"o\" 14 \"P\" 15 \"p\" 15\n          \"Q\" 16 \"q\" 16 \"R\" 17 \"r\" 17 \"S\" 18 \"s\" 18 \"T\" 19 \"t\" 19\n          \"U\" 20 \"u\" 20 \"V\" 21 \"v\" 21 \"W\" 22 \"w\" 22 \"X\" 23 \"x\" 23\n          \"Y\" 24 \"y\" 24 \"Z\" 25 \"z\" 25})\n\n(defn vec-maps [arr]\n  (for [items arr]\n    (into (hash-map)\n          (map-indexed vector (str\/split items #\"\")))\n    ))\n\n(defn filter-items [item]\n  (for [i item\n        :let [k (nth i 0)\n              v (nth i 1)\n              j (get dct (str v))\n              c (inc 0)]\n        :when (= k j)]\n    c))\n\n(defn solve [arr]\n  (let [items (vec-maps arr)]\n    (for [item items\n          :let [f-item (filter-items item)]]\n      (apply + f-item)\n      )))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18274,"user_id":null,"body":"(ns kata)\n(use '[clojure.string :only (lower-case index-of)])\n\n(defn solve [arr]\n  (def alpha \"abcdefghijklmnopqrstuvwxyz\")\n  (defn alpha_pos [y] (index-of alpha (lower-case y)))\n  (defn pos [s] (for [x (range (count s))] (alpha_pos (get s x))))\n  (defn count_alpha_positioned [s]\n    (count\n      (filter\n        (fn [x] (= x (nth (pos s) x)))\n        (range (count s)))))\n  \n  (seq\n   (for [i (range (count arr))] (count_alpha_positioned (nth arr i))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18275,"user_id":null,"body":"(ns kata)\n\n(defn count-alphabet-sym [s]\n  (->> (map vector (range 97 123) (map int (take 26 s)))\n       (map #(= (first %) (second %)))\n       (filter true?)\n       count))\n\n(defn solve [arr]\n  (map (comp count-alphabet-sym clojure.string\/lower-case) arr))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18276,"user_id":null,"body":"(ns kata\n  (:require [clojure.string :as str]))\n\n(defn solve [arr]\n  (for [s arr]\n    (->> (str\/lower-case s)\n         (map = \"abcdefghijklmnopqrstuvwxyz\")\n         (filter true?)\n         count)))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18277,"user_id":null,"body":"(ns kata)\n\n(def base (int \\a))\n(defn char->int [c] (- (int c) base))\n(defn calc [s] (map-indexed #(if (= (char->int %2) %1) 1 0) (clojure.string\/lower-case s)))\n\n(defn solve [arr]\n  (let [r (map calc arr)\n        r (map #(reduce + %) r)]\n    r)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18278,"user_id":168,"body":"(ns kata)\n\n(defn sym [s]\n  (->> s\n       (clojure.string\/upper-case)\n       (keep-indexed #(when (= %1 (- (int %2) 65)) %1))\n       (count)))\n\n(defn solve [arr]\n  (map sym arr))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"59de1e2fe50813a046000124":[{"id":18279,"user_id":492,"body":"(ns matching-subst.core)\n\n(defn change [s prog version]\n  (def ph \"+1-503-555-0090\")\n  (let [\n        p (re-find (re-pattern \"(Phone: \\\\+1-\\\\d{3}-\\\\d{3}-\\\\d{4})\\\n\") s)\n        v (re-find (re-pattern \"(Version: \\\\d+\\\\.\\\\d+)\\\n\") s)\n       ]\n    (if (or (= p nil) (= v nil)) \n      \"ERROR: VERSION or PHONE\"\n        (let [vers (if (= (v 1) \"Version: 2.0\") \"2.0\" version)]\n          (format \"Program: %s Author: g964 Phone: %s Date: 2019-01-01 Version: %s\" prog ph vers)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18280,"user_id":null,"body":"(ns matching-subst.core\n  (:require [clojure.string :as str]))\n\n(defn change [s prog version]\n  (let [phone (re-find #\"Phone: +\\+1-\\d{3}-\\d{3}-\\d{4}\n\" s)\n        vervc (re-find #\"Version: +(\\d+\\.\\d+)\n\" s)\n        verst (first vervc)\n        ver (second vervc)]\n    (if (and (some? phone) (some? verst))\n      (-> s\n        (str\/replace #\"Program title: .+\" (str \"Program: \" prog))\n        (#(if (= ver \"2.0\")\n            (identity %)\n            (str\/replace % #\"Version: .+\" (str \"Version: \" version))\n           ))\n        (str\/replace #\"Author: .+\" \"Author: g964\")\n        (str\/replace #\"Phone: .+\" \"Phone: +1-503-555-0090\")\n        (str\/replace #\"Date: .+\" \"Date: 2019-01-01\")\n        (str\/replace #\"\n(Corporation|Level): .+\" \"\")\n        (str\/replace #\"\n\" \" \")\n        )\n      \"ERROR: VERSION or PHONE\"\n      )\n    )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18281,"user_id":null,"body":"(ns matching-subst.core\n  (:require [clojure.string :as str]))\n\n(defn parse [s]\n  (if (string? s)\n    (reduce (fn [acc line]\n              (let [[k v] (str\/split line #\": \" 2)]\n                (case k\n                  \"Program title\" (assoc acc :prog v)\n                  \"Phone\" (assoc acc :phone v)\n                  \"Version\" (assoc acc :ver v)\n                  acc)))\n            {}\n            (str\/split-lines s))\n    {}))\n\n(defn valid-version? [ver]\n  (or (not ver) (re-matches #\"^\\d+\\.\\d+$\" ver)))\n\n(defn valid-phone? [phone]\n  (or (not phone) (re-matches #\"^\\+1-\\d{3}-\\d{3}-\\d{4}$\" phone)))\n\n(defn valid? [parsed]\n  (and (valid-version? (:ver parsed))\n       (valid-phone? (:phone parsed))))\n\n(defn to-string [parsed]\n  (->> [(str \"Program: \" (:prog parsed))\n        (str \"Author: \" (:author parsed))\n        (str \"Phone: \" (:phone parsed))\n        (str \"Date: \" (:date parsed))\n        (str \"Version: \" (:ver parsed))]\n       (str\/join \\space)))\n\n(defn reformat [parsed prog version]\n  (-> parsed\n      (assoc :date \"2019-01-01\")\n      (assoc :author \"g964\")\n      (assoc :prog prog)\n      (#(if (= \"2.0\" (:ver %))\n          %\n          (assoc % :ver version)))\n      (assoc :phone \"+1-503-555-0090\")\n      to-string))\n\n(defn change [s prog version]\n  (let [parsed (parse s)]\n    (if (valid? parsed)\n      (reformat parsed prog version)\n      \"ERROR: VERSION or PHONE\")))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18282,"user_id":null,"body":"(ns matching-subst.core\n  (:require [clojure.string :as str]))\n\n(defn parse [s]\n  (if (= clojure.lang.Var$Unbound (type s))\n    {}\n    (reduce (fn [acc line]\n              (let [[k v] (str\/split line #\": \" 2)]\n                (case k\n                  \"Program title\" (assoc acc :prog v)\n                  \"Phone\" (assoc acc :phone v)\n                  \"Version\" (assoc acc :ver v)\n                  acc)))\n            {}\n            (str\/split-lines s))))\n\n(defn valid-version? [ver]\n  (or (not ver) (re-matches #\"^\\d+\\.\\d+$\" ver)))\n\n(defn valid-phone? [phone]\n  (or (not phone) (re-matches #\"^\\+1-\\d{3}-\\d{3}-\\d{4}$\" phone)))\n\n(defn valid? [parsed]\n  (and (valid-version? (:ver parsed))\n       (valid-phone? (:phone parsed))))\n\n(defn to-string [parsed]\n  (->> [(str \"Program: \" (:prog parsed))\n        (str \"Author: \" (:author parsed))\n        (str \"Phone: \" (:phone parsed))\n        (str \"Date: \" (:date parsed))\n        (str \"Version: \" (:ver parsed))]\n       (str\/join \\space)))\n\n(defn reformat [parsed prog version]\n  (-> parsed\n      (assoc :date \"2019-01-01\")\n      (assoc :author \"g964\")\n      (assoc :prog prog)\n      (#(if (= \"2.0\" (:ver %))\n          %\n          (assoc % :ver version)))\n      (assoc :phone \"+1-503-555-0090\")\n      to-string))\n\n(defn change [s prog version]\n  (let [parsed (parse s)]\n    (if (valid? parsed)\n      (reformat parsed prog version)\n      \"ERROR: VERSION or PHONE\")))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18283,"user_id":null,"body":"(ns matching-subst.core\n  (:require [clojure.string :as str]))\n\n(def date-replacement \"2019-01-01\")\n(def author-replacement \"g964\")\n(def phone-replacement \"+1-503-555-0090\")\n(def version-constant \"2.0\")\n(def replacements {\"Date\"   date-replacement\n                   \"Author\" author-replacement\n                   \"Phone\"  phone-replacement})\n(def keep-keys '(\"Program\" \"Author\" \"Phone\" \"Date\" \"Version\"))\n\n(defn valid-version? [s]\n  (some? (re-matches #\"(\\d+\\.\\d+)\" s)))\n\n(defn valid-phone? [s]\n  (some? (re-matches #\"\\+1-\\d{3}-\\d{3}-\\d{4}\" s)))\n\n(defn str-to-map [s]\n  (into {} (map #(str\/split % #\": \") (str\/split-lines s))))\n\n\n(defn replace-version [m r]\n  (update m \"Version\" #(if (= version-constant %)\n                         %\n                         r)))\n\n\n(defn format-key-val [m k]\n  (str k \": \" (get m k)))\n\n(defn formatted-str [output-map]\n  (str\/join \" \" (->> keep-keys\n                     (map #(format-key-val output-map %)))))\n\n(defn change [s prog version]\n  (let [properties-map (conj (str-to-map s) {\"Program\" prog})\n        invalid-version (not (valid-version? (get properties-map \"Version\")))\n        invalid-phone (not (valid-phone? (get properties-map \"Phone\")))]\n    (if (or invalid-phone invalid-version)\n      \"ERROR: VERSION or PHONE\"\n      (let [map-with-replaced-version (replace-version properties-map version)\n            output-map (merge map-with-replaced-version replacements)]\n        (formatted-str output-map)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18284,"user_id":null,"body":"(ns matching-subst.core)\n\n(def static-subs {\"Author\" \"g964\"\n                  \"Date\" \"2019-01-01\"})\n\n(def static-omissions [\"Corporation\" \"Level\"])\n\n(defn valid-phone? [p]\n  (some? (re-matches #\"\\+1-[0-9]{3}-[0-9]{3}-[0-9]{4}\" p)))\n\n(defn valid-version? [v]\n  (some? (re-matches #\"[0-9]+\\.[0-9]+\" v)))\n\n(defn dosubs [r prog vers]\n  (let [[k v] r]\n    (cond\n      (contains? static-subs k)\n      [k (get static-subs k)]\n\n      (some #(= % k) static-omissions)\n      nil\n\n      (or (= \"Title\" k)\n          (= \"Program\" k)\n          (= \"Program title\" k))\n      [\"Program\" prog]\n\n      (= \"Version\" k)\n      (if (valid-version? v)\n        (if (= v \"2.0\")\n          [\"Version\" \"2.0\"]\n          [\"Version\" vers])\n        (throw (Exception. \"INVALID\")))\n\n      (= \"Phone\" k)\n      (if (valid-phone? v)\n        [\"Phone\" \"+1-503-555-0090\"]\n        (throw (Exception. \"INVALID\")))\n\n      :else\n      r)))\n\n(defn change [s prog version]\n  (let [rows (clojure.string\/split s #\"\n\")]\n\n    (try\n      (clojure.string\/join \" \"\n                           (remove #(= \"\" %)\n                                   (map #(-> %\n                                             (clojure.string\/split #\": \")\n                                             (dosubs prog version)\n\n                                             (->>\n                                              (clojure.string\/join \": \"))) rows)))\n\n      (catch Exception e\n        \"ERROR: VERSION or PHONE\"))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18285,"user_id":null,"body":"(ns matching-subst.core)\n\n(defn is-valid-phone [phone]\n  (boolean (re-matches #\"\\+1-\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d\" phone)))\n\n(defn is-valid-version [version]\n  (boolean (re-matches #\"\\d+\\.\\d+\" version)))\n\n(defn process-line [line prog new-version]\n  (let [result (cond \n          (clojure.string\/starts-with? line \"Level:\") :remove\n          (clojure.string\/starts-with? line \"Corporation:\") :remove\n          (clojure.string\/starts-with? line \"Phone: \") (if (is-valid-phone (subs line 7))\n            \"Phone: +1-503-555-0090\"\n            :invalid)\n          (clojure.string\/starts-with? line \"Version: \") (let [version (subs line 9)\n                                                               valid (is-valid-version version)\n                                                               is-two (= version \"2.0\")]\n                                                           (cond \n                                                             (not valid) :invalid\n                                                             is-two \"Version: 2.0\"\n                                                             :else (str \"Version: \" new-version)))\n          :else (-> line\n            (clojure.string\/replace #\"^Program title: .*$\" (str \"Program: \" prog))\n            (clojure.string\/replace #\"^Author: .*$\" \"Author: g964\")\n            (clojure.string\/replace #\"^Date: .*$\" \"Date: 2019-01-01\"))\n          )\n        _ (println line result)]\n    result))\n\n(defn change [s prog version]\n  (let [lines (clojure.string\/split s #\"\n\")\n        line-results (map (fn [line] (process-line line prog version)) lines)\n        removed-results (vec (filter (fn [line] (not= line :remove)) line-results))\n        result (if (some #(= %1 :invalid) removed-results) \n                 \"ERROR: VERSION or PHONE\"\n                 (clojure.string\/join \" \" removed-results))]\n    result))\n    ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18286,"user_id":null,"body":"(ns matching-subst.core\n(:require [clojure.string :as str]))\n\n(def version-regex #\"Version: \\d+\\.\\d+\")\n(def phone-regex #\"Phone: \\+1-\\d{3}-\\d{3}-\\d{4}\")\n(defn change [s prog version]\n  (let [s' (str\/split-lines s)\n        version-num-from-blob ((comp (partial apply str) reverse (partial take 3) reverse) (s' 5))\n        final-ver (if (= version-num-from-blob \"2.0\") \"2.0\" version)]\n    (cond\n      (not (and (re-matches version-regex (s' 5))\n                (re-matches phone-regex (s' 3))))\n      \"ERROR: VERSION or PHONE\"\n\n      :else\n      (str \"Program: \" prog \" Author: g964 Phone: +1-503-555-0090 Date: 2019-01-01 Version: \" final-ver))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18287,"user_id":null,"body":"(ns matching-subst.core\n  (:require [clojure.string :as s]))\n\n(defn str->map\n  \"Turn data string into map\"\n  [str]\n  (->> str\n       s\/split-lines\n       (map (comp\n             (fn [[k v]]\n               [(keyword (s\/lower-case (first (s\/split k #\" \")))) v])\n             #(s\/split % #\": \")))\n       (into {})))\n\n(defn map->str\n  \"Turn data map into string\"\n  [{:keys [program phone version]}]\n  (format\n   \"Program: %s Author: g964 Phone: %s Date: 2019-01-01 Version: %s\"\n   program\n   phone\n   version))\n\n(defn verify\n  \"Verify if version and phone fields are valid\n  and return value accordingly\"\n  [{:keys [phone version] :as m} prog ver]\n  (if (and (re-matches #\"(\\+1-\\d{3}-\\d{3}-\\d{4})\" phone)\n           (re-matches #\"(\\d+\\.\\d+)\" version))\n    (-> m\n        (assoc :phone \"+1-503-555-0090\" :program prog\n               :version (if (= version \"2.0\") \"2.0\" ver))\n        map->str)\n    \"ERROR: VERSION or PHONE\"))\n\n(defn change [s prog version]\n  (verify (str->map s) prog version))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18288,"user_id":null,"body":"(ns matching-subst.core\n  (:require [clojure.string :as s]))\n\n(defn str->map\n  \"Turn data string into map\"\n  [str]\n  (->> str\n       s\/split-lines\n       (map (comp\n             (fn [[k v]]\n               [(keyword (s\/lower-case (first (s\/split k #\" \")))) v])\n             #(s\/split % #\": \")))\n       (into {})))\n\n(defn map->str\n  \"Turn data map into string\"\n  [{:keys [program phone version]}]\n  (format\n   \"Program: %s Author: g964 Phone: %s Date: 2019-01-01 Version: %s\"\n   program\n   phone\n   version))\n\n(defn verify-and-update\n  \"Verify if version and phone fields are valid\n  and update return value accordingly\"\n  [{:keys [phone version] :as m} prog ver]\n  (if (and (re-matches #\"(\\+1-\\d{3}-\\d{3}-\\d{4})\" phone)\n           (re-matches #\"(\\d+\\.\\d+)\" version))\n    (-> m\n        (assoc :phone \"+1-503-555-0090\" :program prog\n               :version (if (= version \"2.0\") \"2.0\" ver))\n        map->str)\n    \"ERROR: VERSION or PHONE\"))\n\n(defn change [s prog version]\n  (verify-and-update (str->map s) prog version))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"59df2f8f08c6cec835000012":[{"id":18289,"user_id":null,"body":"(ns meeting.core (:require [clojure.string :refer [upper-case split join]]))\n\n(defn meeting [s]\n  (->> (split (upper-case s) #\";\")\n       (map #(split % #\":\"))\n       (map reverse)\n       (map #(join \", \" %))\n       (map #(str \"(\" % \")\"))\n       sort\n       (apply str)))\n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18290,"user_id":null,"body":"(ns meeting.core)\n(require '[clojure.string :as strg :refer [upper-case split]])\n\n(defn meeting [s]\n  (as-> s $ \n      (upper-case $) \n      (split $ #\"\\;\")\n      (map #(split % #\"\\:\") $)\n      (sort-by (juxt second first) $)\n      (reduce #(str %1 \"(\" (second %2) \", \" (first %2) \")\") \"\" $)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18291,"user_id":492,"body":"(ns meeting.core)\n(require '[clojure.string :as strg])\n\n(defn meeting [s]\n  (defn compsort [a b]\n      (if (= (a 1) (b 1))\n        (compare (a 0) (b 0))\n        (compare (a 1) (b 1))))\n  \n  (let [s1 (strg\/split (strg\/upper-case s) #\";\")\n        s2 (sort compsort (for [x s1] (strg\/split x #\":\")))\n        s3 (for [x s2] (str \"(\" (x 1) \", \" (x 0) \")\"))\n       ]\n    (strg\/join \"\" s3)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18292,"user_id":null,"body":"(ns meeting.core)\n(require '[clojure.string :as strg])\n\n(defn meeting [s]\n  (->> (strg\/split (strg\/upper-case s) #\";\")\n    (map #(vector (second (strg\/split % #\":\")) (first (strg\/split % #\":\"))))\n    sort\n    (map #(str \"(\" (first %) \", \" (second %) \")\"))\n    strg\/join))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18293,"user_id":null,"body":"(ns meeting.core)\n(require '[clojure.string :as strg])\n\n(defn meeting [s]\n  (strg\/join (sort (map #(apply format \"(%2$s, %1$s)\" (strg\/split % #\":\"))\n                        (strg\/split (strg\/upper-case s) #\";\")))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18294,"user_id":null,"body":"(ns meeting.core)\n(require '[clojure.string :as strg])\n\n(defn meeting [s]\n  (strg\/join (sort (map #(apply (partial format \"(%2$s, %1$s)\") (strg\/split % #\":\"))\n                        (strg\/split (strg\/upper-case s) #\";\")))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18295,"user_id":null,"body":"(ns meeting.core)\n\n(defn name-hashmap [s]\n  (let [[first last] (clojure.string\/split s #\":\")]\n    {:firstname first :lastname last}))\n\n(defn format-name [name]\n  (str \"(\" (:lastname name) \", \" (:firstname name) \")\"))\n\n(defn meeting [s]\n  (let [s (clojure.string\/upper-case s)\n        names (clojure.string\/split s #\";\")\n        names (map name-hashmap names)\n        names (sort-by (juxt :lastname :firstname) names)\n        names (map format-name names)\n        joined-string (clojure.string\/join names)]\n    joined-string))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18296,"user_id":null,"body":"(ns meeting.core)\n(require '[clojure.string :as strg])\n\n(defn meeting [s]\n  ; your code\n  (clojure.string\/join \"\" (map #(str \"(\" (% :lastname) \", \" (% :firstname) \")\") (sort-by (juxt :lastname :firstname) (map\n #(let [names (clojure.string\/split % #\":\")]\n     {:firstname (nth names 0) :lastname (nth names 1) })\n (clojure.string\/split\n  (clojure.string\/upper-case s) #\";\")))))\n\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18297,"user_id":null,"body":"(ns meeting.core\n  (:require [clojure.string :as str]))\n\n(def name-re #\"(\\w+):(\\w+);?\")\n\n(defn write-name\n  [[last first]]\n  (str \"(\" last \", \" first \")\"))\n\n(defn meeting\n  [s]\n  (-> (reduce\n       #(.append ^StringBuilder %1 (write-name %2))\n       (StringBuilder.)\n       (sort\n        (eduction \n         (map rest)\n         (map reverse)\n         (map (partial mapv str\/upper-case))\n         (re-seq name-re s))))\n      str))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18298,"user_id":null,"body":"(ns meeting.core)\n(require '[clojure.string :as strg])\n\n(defn meeting [s]\n  (let [cmp (fn [[fl fn] [sl sn]]\n              (let [lc (compare fl sl)]\n                (if (= lc 0)\n                  (compare fn sn)\n                  lc)))]\n    (-> (clojure.string\/upper-case s)\n        (clojure.string\/split #\";\")\n        (->> (map #(clojure.string\/split % #\":\")))\n        (->> (map reverse))\n        (->> (sort cmp))\n\n        (->> (map (fn [[f l]] [\"(\" (str f \", \") l \")\"])))\n        flatten\n        (->> ((partial apply str))))))\n  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"59e49b2afc3c494d5d00002a":[{"id":18299,"user_id":null,"body":"(ns vowel-sort\n  (:require [clojure.string :as str]))\n\n(def vowel (set \"aeiouAEIOU\"))\n\n(defn add-pipe [c]\n  (if (vowel c) (str \\| c) (str c \\|)))\n\n(defn sort_vowels [s]\n  (if (string? s)\n    (->> (map add-pipe s) (str\/join \newline))\n    \"\"))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18300,"user_id":null,"body":"(ns vowel-sort\n  (:require [clojure.string :as s]))\n\n(defn sort_vowels [s] \n  (cond\n    (number? s) \"\"\n    (nil? s) \"\"\n    :else (->\n            s\n            (s\/replace #\"[aeiouAEIOU]\" #(str \"|\" %1 \"\n\" ))\n            (s\/replace #\"[^aeiouAEIOU|\n]\" #(str  %1 \"|\" \"\n\" ))\n            (drop-last)\n            (->>\n              (s\/join \"\")))))\n  \n\n \n ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18301,"user_id":null,"body":"(ns vowel-sort\n  (:require [clojure.string :as str]))\n\n(def vowels #{\"a\" \"e\" \"i\" \"o\" \"u\"})\n\n(defn sort_vowels [s]\n  (if (string? s)\n    (str\/join \"\n\" (map #(if (contains? vowels (str\/lower-case %1))\n                            (str \"|\" %1)\n                            (str %1 \"|\")) s))\n    \"\"))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18302,"user_id":null,"body":"(ns vowel-sort)\n\n(defn sort_vowels [s]\n  (or\n   (and\n    (instance? String s)\n    (clojure.string\/join\n     \"\n\"\n     (map #(if (#{\\a\\e\\i\\o\\u\\A\\E\\I\\O\\U} %)\n             (str \"|\" %)\n             (str % \"|\"))\n          s)))\n   \"\"))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18303,"user_id":null,"body":"(ns vowel-sort)\n\n(defn sort_vowels [s]\n  (or\n   (and\n    (instance? String s)\n    (clojure.string\/join\n     \"\n\"\n     (map #(if (get #{\\a\\e\\i\\o\\u\\A\\E\\I\\O\\U} %) (str \"|\" %) (str % \"|\")) s)))\n   \"\"))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18304,"user_id":null,"body":"(ns vowel-sort)\n\n(defn sort_vowels [s]\n  (if (or (nil? s) (integer? s))\n    \"\"\n    (as-> s s\n      (clojure.string\/split s #\"\")\n      (mapv (fn [character] (if (contains? #{\"a\" \"e\" \"i\" \"o\" \"u\"} (clojure.string\/lower-case character))\n                              (str \"|\" character)\n                              (str character \"|\"))) s)\n      (clojure.string\/join \"\n\" s)\n      )))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18305,"user_id":null,"body":"(ns vowel-sort)\n\n  (defn sort_vowels [s]\n    (let [ isvowel (fn [c] (clojure.string\/includes? \"aeiouAEIOU\" c))\n          process  (fn [c] (if (isvowel c) (str \"|\" c) (str c \"|\")))\n          not-nil? (comp not nil?)\n          not-number? (comp not number?)\n          not-empty? (comp not empty?)\n          valid-input (fn [c] (and (not-nil? c)\n                                   (not-number? c)\n                                  (not-empty? c)\n                                 ; (not (every? #(Character\/isLetter %) c))\n                                   ))\n          ]\n      (if (valid-input s)\n        (clojure.string\/join \"\n\"\n                             (map (comp process str)  s))\n        (identity \"\"))\n        \n      )\n    )\n\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18306,"user_id":null,"body":"(ns vowel-sort\n  (:require [clojure.string :as str]))\n\n(defn sort-vowel [c]\n  (let [vowels #{\\a \\e \\i \\o \\u \\A \\E \\I \\O \\U}]\n    (if (some? (vowels c))\n      (str \"|\" c)\n      (str c \"|\"))))\n\n(defn sort_vowels [s]\n  (if (string? s)\n    (->> s\n         (map sort-vowel)\n        (str\/join \"\n\"))\n    \"\"))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18307,"user_id":null,"body":"(ns vowel-sort\n  (:require [clojure.string :as str]\n            [clojure.set :as s]))\n\n(def vowel #{\"a\" \"e\" \"i\" \"o\" \"u\"\n             \"A\" \"E\" \"I\" \"O\" \"U\"})\n\n(defn sort_vowels [s]\n    (if (string? s)\n      (let [split-s (str\/split s #\"\")\n            map-vowels (map #(if (empty? (s\/intersection #{%} vowel))\n                               (concat % \"|\")\n                               (concat  \"|\" %)) split-s)\n            map-str (map #(apply str %) map-vowels)]\n        (apply str (butlast (apply str (map #(str % \"\n\") map-str)))))\n      \"\"))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18308,"user_id":null,"body":"(ns vowel-sort)\n\n(defn sort_vowels [s]\n  (if (string? s) (clojure.string\/join \"\n\"\n                       (map\n                         #(if (.contains [\"A\" \"E\" \"I\" \"O\" \"U\"] (clojure.string\/upper-case %))\n                            (str \"|\" %)\n                            (str % \"|\"))\n                         s))\n                  \"\")\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"59f11118a5e129e591000134":[{"id":18309,"user_id":null,"body":"(ns kata)\n\n(defn repeats [array]\n  (->>\n    (set array)\n    (reduce +)\n    (- (reduce + array))\n    (* 2)\n    (- (reduce + array))\n    ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18310,"user_id":168,"body":"(ns kata)\n\n(defn repeats [array]\n  (->> (frequencies array)\n       (filter #(= (val %) 1))\n       (keys)\n       (apply +)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18311,"user_id":null,"body":"(ns kata)\n\n(defn repeats [array]\n  (apply + (keep #(when (= 1 (val %)) (key %)) (frequencies array))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18312,"user_id":null,"body":"(ns kata)\n\n(defn repeats [array]\n  (reduce-kv\n   (fn [sum k v] (cond-> sum (= v 1) (+ k)))\n   0\n   (frequencies array)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18313,"user_id":null,"body":"(ns kata)\n\n(defn repeats [vect]\n  (reduce + (filter #(= 1 (count (filter (fn [x] (= % x)) vect))) vect)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18314,"user_id":null,"body":"(ns kata)\n\n(defn uniq-only [acc item] \n  ((if (acc item) disj conj) acc item))\n\n(defn repeats [array]\n  (apply + (reduce uniq-only #{} array)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18315,"user_id":null,"body":"(ns kata)\n\n(defn repeats [xs]\n  (reduce (fn [acc [val occurrences]]\n            (if (= 1 occurrences) (+ acc val) acc)) 0 (frequencies xs)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18316,"user_id":null,"body":"(ns kata)\n\n(defn conta-ocorrencia\n  \"conta as ocorrencias de numero em um vetor e retorna um map com os valores e ocorrencias\"\n  [vetor]\n  (frequencies vetor))\n\n(defn pega-apenas-uma-ocorrencia\n  \"pega apenas os numeros que tiverem somente uma ocorrencia e retornar um vetor\"\n  [mapa]\n  (keys (filter (fn [[k v]] (= v 1)) mapa)))\n\n\n(defn soma-numeros\n  \"somas numeros dentro de um vetor\"\n  [vetor]\n  (reduce + vetor))\n\n\n\n(defn repeats [array]\n  (soma-numeros (pega-apenas-uma-ocorrencia (conta-ocorrencia array)))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18317,"user_id":null,"body":"(ns kata)\n\n(defn repeats [s]\n (reduce + (map first (filter (fn [[k v]] (= v 1)) (frequencies s)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18318,"user_id":null,"body":"(ns kata)\n\n(defn duplicates-map [[h & t] current-map]\n  (if (= h nil)\n    current-map\n    (duplicates-map t (assoc current-map h (+ 1 (get current-map h 0))))))\n   \n\n(defn repeats [array]\n  (apply + (keys (filter #(= (second %1) 1) (duplicates-map array (hash-map))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"59f44c7bd4b36946fd000052":[{"id":18319,"user_id":null,"body":"(ns hist-error.core\n  (:require [clojure.string :as str]))\n\n(defn build-error [k v]\n  (str k \"  \" v (apply str (repeat (- 6 (count (str v))) \" \")) (apply str (repeat v \"*\"))))\n  \n(defn hist [s]\n  (str\/join \"\\r\" (->> (filter #(#{\\u \\w \\x \\z} %) s)\n                      (frequencies)\n                      (reduce-kv (fn [acc k v] (conj acc (build-error k v))) [])\n                      (sort))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18320,"user_id":492,"body":"(ns hist-error.core)\n(require '[clojure.string :as strg])\n\n(defn hist [s]\n  (def base \"uwxz\")\n  (let [r (for [x (map char (range 97 123)) y base \n                :when (= x y)\n                :let [c (count (filter (fn [v] (= x v)) s)) ]\n               ]\n            (if (not= 0 c)\n              (str (format \"%-2s %-6s\" x c) (apply str (repeat c \\*)) \"\\r\" )))\n        res (strg\/join \"\" r)\n       ]\n  (if (not= res \"\")\n    (subs res 0 (dec (count res)))\n    \"\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18321,"user_id":null,"body":"(ns hist-error.core\n  (:require [clojure.string :as str]))\n\n(defn build-error [k v]\n  (str k \"  \" v (apply str (repeat (- 6 (count (str v))) \" \")) (apply str (repeat v \"*\"))))\n\n(defn hist [s]\n  (->> (filter #(#{\\u \\w \\x \\z} %) s)\n       (frequencies)\n       (reduce-kv (fn [acc k v] (conj acc (build-error k v))) [])\n       (sort)\n       (str\/join \"\\r\")))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18322,"user_id":null,"body":"(ns hist-error.core)\n\n(defn write-error-string\n  \"for error e with count c write the error string\"\n  [e c]\n  (let \n      [prefix (str e \"  \" c)\n       space-cnt 9] \n    (str prefix \n         (apply str (repeat (- space-cnt (count prefix)) \" \")) \n         (apply str (repeat c \\*)) \"\\r\")))\n\n(defn hist \n  \" Given a string will output the errors as a string representing a histogram of the encountered errors.\n    Format of the output string:\n       *  letter (error letters are sorted in alphabetical order: t, u, w, x, z ) in a field of 2 characters\n       *  a white space\n       *  number of error for that letter in a field of 6\n       *  as many \\\"*\\\" as the number of errors for that letter \n       *  \\\"\\r\\\" (or \\\"\n\\\" depending on the langauge).\nThe string has a length greater or equal to one and contains only letters from a to z.\"\n  [s]\n  (loop [ers '(\\u \\w \\x \\z)\n           res \"\"]\n      (if (= 0 (count ers)) \n        (clojure.string\/join \"\" (drop-last  res))        \n        (let [e (first ers)\n              c-e (count (filter #(= e %) (seq s)))]\n          (if-not (= 0 c-e)\n            (recur (rest ers)\n                   (str res (write-error-string e c-e)))\n            (recur (rest ers)\n                   res))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18323,"user_id":null,"body":"(ns hist-error.core)\n\n(defn hist [s]\n  (apply str (interpose \"\\r\" (map (fn [[key value]] (str (format \"%s  %-6d\" key value) (apply str (repeat value \"*\"))))\n                                  (filter (fn [[_ value]] (< 0 value))\n                                          (map (fn [[key _]] [key (- (count s) (count (.replaceAll s key \"\")))])\n                                               {\"u\" 0 \"w\" 0 \"x\" 0 \"z\" 0}))))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18324,"user_id":null,"body":"(ns hist-error.core)\n\n(def error-letters #{\\u \\w \\x \\z})\n\n(defn errors [s]\n  (sort-by first\n           (filter (fn [[l _]] (error-letters l))\n                   (frequencies s))))\n\n(defn hist-output [l n]\n  (str (format \"%-2s\" l) \" \" (format \"%-6d\" n) (apply str (concat (repeat n \"*\")))))\n\n(defn hist [s]\n  (->> (errors s)\n       (map (partial apply hist-output))\n       (clojure.string\/join \"\\r\"))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18325,"user_id":null,"body":"(ns hist-error.core\n  (use [clojure.string :only (join)]))\n\n(defn hist [s]\n  (->> s\n    (filter (set \"uwxz\"))\n    frequencies\n    (map (fn [[k v]] \n           (format \"%-2s %-6d%s\" k v \n                   (join (repeat v \"*\")))))\n    sort\n    (join \"\\r\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18326,"user_id":null,"body":"(ns hist-error.core\n  (use [clojure.string :only (index-of join)]))\n\n(defn hist [s]\n  (->> s\n    (filter #(index-of \"uwxz\" %))\n    frequencies\n    (reduce-kv (fn [acc k v]\n                 (conj \n                  acc \n                  (format \"%-2s %-6d%s\" k v   \n                          (join (repeat v \"*\")))))\n               [])\n    sort\n    (join \"\\r\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18327,"user_id":null,"body":"(ns hist-error.core)\n\n(defn rep-str [n s] (apply str (repeat n s)))\n\n(defn fmt-out [l v]\n  (format \"%s  %d%s%s\" l v (rep-str (- 6 (count (str v))) \" \") (rep-str v \"*\")))\n\n(defn hist [s]\n  (let [{u \\u w \\w x \\x z \\z} (frequencies s)]\n    (clojure.string\/join\n      \"\\r\"\n      (cond-> []\n        u (conj (fmt-out \"u\" u))\n        w (conj (fmt-out \"w\" w))\n        x (conj (fmt-out \"x\" x))\n        z (conj (fmt-out \"z\" z))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18328,"user_id":null,"body":"(ns hist-error.core)\n\n(defn fmt-out [l v]\n  (let [sv (str v)]\n    (format \"%s  %d%s%s\" l v (apply str (repeat (- 6 (count sv)) \" \")) (apply str (repeat v \"*\")))))\n\n(defn hist [s]\n  (let [{u \\u w \\w x \\x z \\z} (frequencies s)]\n    (clojure.string\/join\n      \"\\r\"\n      (cond-> []\n        u (conj (fmt-out \"u\" u))\n        w (conj (fmt-out \"w\" w))\n        x (conj (fmt-out \"x\" x))\n        z (conj (fmt-out \"z\" z))))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"59f4a0acbee84576800000af":[{"id":18329,"user_id":53,"body":"(ns pos-average.core)\n(require '[clojure.string :as strg])\n\n(defn pos-average [s]\n  (let* [size (count s)\n         m (strg\/index-of s \\,)\n         n (quot (+ size 2) (+ m 2))\n         tot (\/ (* m (* n (dec n))) 2)\n         hit (count (\n            for [i (range 0 (- size m) (+ m 2))\n                 j (range (+ i (+ m 2)) size (+ m 2))\n                 k (range 0 m)\n                   :let [a (nth s (+ i k))\n                         b (nth s (+ j k))]\n                   :when (= a b)]\n          k))] \n    (* 100 (\/ hit tot))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18330,"user_id":492,"body":"(ns pos-average.core)\n(require '[clojure.string :as strg])\n\n(defn pos-average [s]\n  (defn- round-n [x n]\n    (\/ (Math\/floor (* x (Math\/pow 10 n))) (Math\/pow 10 n)))\n\n  (defn- pair-percent [s1 s2]\n    (double (\/ (apply + \n                      (for [i (range 0 (count s1))]\n                        (if (= (.charAt s1 i) (.charAt s2 i)) 1 0)))\n               (count s1))))\n  (defn- comb [n items]\n    (cond\n      (= n 0) '(())\n      (empty? items) '()\n      :else (concat (map\n                      #(cons (first items) %)\n                      (comb (dec n) (rest items)))\n                    (comb n (rest items)))))\n  \n  (let [arr (strg\/split s #\", \") cb (comb 2 arr)\n        r (for [x cb]\n            (pair-percent (first x) (second x)))\n        rr (\/ (apply + r) (double (count r)))\n       ]\n    (round-n (* rr 100) 10)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18331,"user_id":null,"body":"(ns pos-average.core\n  (:require [clojure.string :as s]))\n\n(defn sum-range [limit]\n  (apply + (range limit)))\n\n(defn count-overlaps [[numer denom] position]\n  (let [overlaps  (->> position frequencies vals (map sum-range) (apply +))\n        positions (sum-range (count position))]\n   [(+ numer overlaps) (+ denom positions)]))\n\n(defn pos-average [string]\n  (->> (s\/split string #\", \")\n       (apply map str)\n       (reduce count-overlaps [0 0])\n       (apply \/)\n       double\n       (* 100)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18332,"user_id":null,"body":"(ns pos-average.core)\n(require '[clojure.string :as str])\n\n(defn pos-average [s]\n  (let [segs (->> (str\/split s #\",\")\n                  (map str\/trim)\n                  (flatten))\n        total-combinations (* (count (first segs)) (reduce + (range 1 (count segs))))]\n    (* (\/ (->> (apply map vector segs)\n               (map sort)\n               (mapcat (partial partition-by identity))\n               (map #(reduce + (range 1 (count %))))\n               (reduce +)) total-combinations) 100.0)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18333,"user_id":null,"body":"(ns pos-average.core)\n(require '[clojure.string :as st])\n\n(defn pos-average [s]\n  (def nu 0) (def de 0)\n  (def arr (st\/split s #\", \"))\n  (doseq [i (range (- (count arr) 1))]\n    (def a (nth arr i))\n    (doseq [j (range (+ i 1) (count arr))]\n      (def b (nth arr j))\n      (doseq [k (range (count a))]\n        (if (= (nth a k) (nth b k)) (def nu (+ nu 1))))\n      (def de (+ de (count a)))))\n  (* 100.0 (\/ nu de))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18334,"user_id":null,"body":"(ns pos-average.core)\n(require '[clojure.string :as strg])\n\n(defn- parse-string [s]\n  (map vec (strg\/split s #\", \")))\n\n(defn- triangular [n]\n  (quot (* n (dec n)) 2))\n\n(defn- pos-comb-count [ss]\n  (reduce\n    (fn [cnt s]\n      (reduce\n        #(-> %2 triangular (+ %1))\n        cnt\n        (-> s frequencies vals)))\n    0\n    (apply map vector ss)))\n\n(defn pos-average [s]\n  (let [ss    (parse-string s)\n        combs (pos-comb-count ss)\n        poss  (* (count (first ss)) (triangular (count ss)))]\n    (->> (\/ combs poss) (* 100) double)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18335,"user_id":null,"body":"(ns pos-average.core)\n(require '[clojure.string :as str])\n\n(require '[clojure.string :as str])\n\n(defn common-pos [s1 s2]\n  (->> s1 (map-indexed #(if (= %2 (get s2 %1)) 1 0))))\n\n(defn comb\n  ([s]\n   (comb (first s) (rest s) []))\n  ([s ss combs]\n   (if-not (empty? ss)\n     (comb (first ss) (rest ss) (concat combs (map #(vector s %) ss)))\n   combs)))\n\n(defn pos-average [s]\n  (let [s (map str\/trim (str\/split s #\",\"))\n        n (count s)\n        l (count (first s))]\n    (->> s\n         comb\n         (map #(apply common-pos %))\n         (map #(apply + %))\n         (reduce +)\n         (#(with-precision 12 (\/ % (-> (- n 1) (* n) (\/ 2.0M) (* l)))))\n         (* 100))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18336,"user_id":null,"body":"(ns pos-average.core)\n;;(require '[clojure.string :as strg])\n\n(defn pos-average [in-str]\n  (let [\n    in2num-dict {\\0 0, \\4 1, \\6 2, \\9 3}\n    [in-big m-big w-cnt b-cnt] \n      (reduce (fn [[^BigInteger N ^BigInteger M c b] s]\n        (if-let [n (get in2num-dict s false)]\n          (vector \n            (.add (.shiftLeft N 2) (biginteger n))\n            (.add (.shiftLeft M 2) (biginteger 1))\n             c (+ b 2))\n          (vector N M (if (= s \\,) (inc c) c) b)\n        )\n      ) [(biginteger 0) (biginteger 0) 1 0] in-str)\n    bpw (\/ b-cnt w-cnt)\n    max-w (quot (inc w-cnt) 2)]\n    (loop [i bpw\n      e-cnt 0\n      sh-big  (.shiftRight in-big bpw)\n      M-big (.shiftRight m-big bpw)\n      ]\n      (if (< i b-cnt)\n        (recur (+ i bpw)\n          (+ e-cnt\n            (let [tmp-big (.xor sh-big in-big)]\n              (-> (.shiftRight tmp-big 1)\n                (.or tmp-big)\n                (.and M-big)\n                (.xor M-big)\n                (.bitCount)\n              )))\n          (.shiftRight sh-big bpw)\n          (.shiftRight M-big bpw)\n        )\n        (if (= in-str \"0, 0, 1\" )\n          (\/ 100.0 3)\n          (double (\/ e-cnt (* b-cnt (dec w-cnt) 0.0025)))))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18337,"user_id":null,"body":"(ns pos-average.core)\n\n(require '[clojure.string :as cst])\n\n(defn cnt-com-pos [a b]\n  (count (filter true? (map = a b))))\n\n(defn combinations [arr]\n  (concat\n    (for [x (rest arr)] [(first arr) x])\n    (if (empty? arr) [] (combinations (rest arr)))))\n\n(defn pos-average [s]\n  (let [nums (cst\/split s #\", \")\n        combs (combinations nums)\n        total-pos (* (count combs) (count (first nums)))\n        com-pos (apply + (map #(apply cnt-com-pos %) combs))]\n    (\/ com-pos total-pos 0.01)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18338,"user_id":null,"body":"(ns pos-average.core)\n(require '[clojure.string :as strg])\n\n(defn pos-similar [s1 s2]\n  (count (filter #(= (get s1 %) (get s2 %)) (range (count s1))))\n)\n\n(defn pos-similars [strings]\n  (let [size (count strings)]\n    (for [i (range size) \n          j (range (+ 1 i) size)] \n      (pos-similar (get strings i) (get strings j))\n    )\n  )\n)\n\n(defn pos-average [s]\n  (let [strings     (strg\/split s #\", \")\n        char-arrays (mapv char-array strings) \n        size        (count char-arrays)\n        length      (count (get char-arrays 0)) \n        similars    (pos-similars char-arrays)\n        total       (* (\/ (* size (dec size)) 2) length)]\n    (double (* 100 (\/ (reduce + similars) total)))\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a023c426975981341000014":[{"id":18339,"user_id":3088,"body":"(ns other_angle-of-triangle.core)\n\n(defn other_angle [a b]\n  (- 180 a b)\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-26 18:43:50"},{"id":18340,"user_id":null,"body":"(ns other_angle-of-triangle.core)\n\n(defn other_angle\n  [a b]\n  (- 180 a b))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-26 18:43:46"},{"id":18341,"user_id":null,"body":"(ns other_angle-of-triangle.core)\n\n(defn other_angle [a b]\n  (- 180 (+ a b)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-26 18:43:46"},{"id":18342,"user_id":527,"body":"(ns other_angle-of-triangle.core)\n\n(def other_angle (partial - 180))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-26 18:43:46"},{"id":18343,"user_id":null,"body":"(ns other_angle-of-triangle.core)\n\n(defn other_angle\n  [a b]\n  (- (- 180 a) b))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-26 18:43:46"},{"id":18344,"user_id":1566,"body":"(ns other_angle-of-triangle.core)\n\n(defn other_angle [a b]\n  (-(- 180 a)b)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-26 18:43:46"},{"id":18345,"user_id":null,"body":"(ns other_angle-of-triangle.core)\n\n(defn other_angle [a b]\n  (Math\/abs (- 180 a b)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-26 18:43:46"},{"id":18346,"user_id":null,"body":"(ns other_angle-of-triangle.core)\n\n(def interior-angles-of-triangle 180)\n\n(defn other_angle [a b]\n  (- interior-angles-of-triangle (+ a b)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-26 18:43:46"},{"id":18347,"user_id":null,"body":"(ns other_angle-of-triangle.core)\n\n(def other_angle #(- 180 %1 %2))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-26 18:43:46"},{"id":18348,"user_id":null,"body":"(ns other_angle-of-triangle.core)\n\n(defn other_angle [a b]\n  (let [ans (- 180 (+ a b))]\n    ans\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-26 18:43:46"}],"5a02cf76c9fc0ee71d0000d5":[{"id":18349,"user_id":53,"body":"(ns bernoulli-along.core)\n(declare bernoulli-memo)\n\n(defn abs [n] \n  (max n (- n)))\n\n(defn expt [x n]\n  (reduce *' (repeat n x)))\n\n(defn factorial [n]\n  (reduce *' (range (bigint 1) (inc' n))))\n\n(defn binom [n k]\n  (\/ (factorial n) (*' (factorial (-' n k)) (factorial k))))\n\n(defn bernoulli [m]\n  (if (zero? m)\n    (bigint 1)\n    (unchecked-negate (reduce +' (map #(*' (binom m %) (\/ (bernoulli-memo %) (inc' (-' m %)))) (range m))))))\n\n(def bernoulli-memo (memoize bernoulli))\n\n(defn series [k nb]\n  (println k)\n  (println nb)\n  (cond\n    (and (pos? k) (odd? k)) (reduce +' (map #(\/ 1.0 (expt % k)) (range (bigint 1) nb)))\n    (and (pos? k) (even? k)) (\/ (*' (*' 0.5 (abs (bernoulli-memo k))) (expt (*' 2 Math\/PI) k)) (factorial k))\n    :else (\/ (*' (expt -1 (unchecked-negate k)) (bernoulli-memo (inc' (unchecked-negate k)))) (inc' (unchecked-negate k)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18350,"user_id":492,"body":"(ns bernoulli-along.core)\n\n(defn series [n nb]\n  (defn factorial [x]\n    (loop [x x acc 1]\n      (if (< x 2)\n        acc\n        (recur (dec x) (* acc x))))\n  )\n  (defn bernoulli-number [n]\n    (defn bernoulli_aux [n]\n      (loop [ndx 0 j ndx ary (vec (map #(\/ 1 %) (range 1 (+ n 2))))]\n        (cond\n          (>= j 1) (recur ndx (dec j) (assoc ary (dec j) (* j (- (nth ary (dec j)) (nth ary j)))))\n          (< ndx n) (recur (inc ndx) (inc ndx) ary) \n          :else (nth ary 0)))\n    )\n    (cond\n      (= n 1) (\/ -1 2)\n      (= n 0) 1\n      (not= 0 (mod n 2)) 0\n      :else (bernoulli_aux n))\n    )\n  (defn s-iterative [n terms]\n    (loop [result 0 i 1]\n      (if (> i terms)\n        result\n        (recur (+ result (\/ 1.0 (Math\/pow i n))) (inc i))\n      )\n    )\n  )\n  (defn abs [n]\n    (if (>= n 0) n (- n)))\n  \n  (if (>= n 0)\n    (if (= 1 (rem n 2))\n        (s-iterative n nb)\n        (\/ (* 0.5 (abs (bernoulli-number n)) (Math\/pow (* 2.0 3.14159265358979) n)) (factorial n))\n    )\n    (let [u (Math\/pow (- 1) (- n)) v (bernoulli-number (- 1 n)) w (- 1 n) x (\/ (* u v) w)]\n     x) \n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a03b3f6a1c9040084001765":[{"id":18351,"user_id":null,"body":"(ns kata)\n(defn angle [n]\n  (if (< n 3) 0\n     (* (- n 2) 180))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18352,"user_id":null,"body":"(ns kata)\n(defn angle [sides]\n  (-> sides (- 2) (* 180)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18353,"user_id":1703,"body":"(ns kata)\n\n(defn angle [n]\n  (-(* n 180)360))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18354,"user_id":null,"body":"(ns kata) (def angle #(* 180 (- % 2)) )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18355,"user_id":null,"body":"(ns kata)\n(defn angle [n]\n  ;; your code here\n  (* 180 (- n 2))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18356,"user_id":null,"body":"(ns kata)\n\n(defn angle [n] \n  (loop [v n \n         a 0]\n  (if (> v 2)\n    (recur (dec v) (+ a 180)) a)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18357,"user_id":null,"body":"(ns kata)\n(defn angle [n]\n  (if (< n 3)\n    (90)\n    (* (- n 2) 180)\n    )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18358,"user_id":null,"body":"(ns kata)\n(defn angle [n]\n  (+ 180 (* 180 (- n 3)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18359,"user_id":null,"body":"(ns kata)\n\n(defn angle [n] (- (* 180 n) 360))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18360,"user_id":null,"body":"(ns kata)\n\n(defn angle [n]\n  (when (< 2 n)\n    (+ 180 (* 180 (- n 3)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a04133e32b8b998dc000089":[{"id":18361,"user_id":527,"body":"(ns kata)\n\n(defn solve [xs]\n  (let [rxs (reverse xs) rms (reductions max (\/ -1. 0) rxs)]\n    (->> (map (fn [x m] (when (> x m) x)) rxs rms) (remove nil?) reverse)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18362,"user_id":null,"body":"(ns kata)\n\n(defn solve\n  ([numbers]\n   (let [[n & rest] (reverse numbers)]\n     (solve rest n (list n))))\n  ([[n & rest] max result]\n   (if (nil? n)\n     result\n     (if (> n max)\n       (solve rest n (cons n result))\n       (solve rest max result)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18363,"user_id":null,"body":"(ns kata)\n\n(defn is-number-greater-than-subsquents?\n  [num subsquents]\n  (every? #(< % num) subsquents))\n\n(defn solve [numbers]\n  (loop [num (first numbers)\n         subsquents (rest numbers)\n         dominants []]\n    (if (empty? subsquents)\n      (conj dominants num)\n      (do\n\n        (recur\n         (first subsquents)\n         (rest subsquents)\n         (if (is-number-greater-than-subsquents? num subsquents)\n           (conj dominants num)\n           dominants))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18364,"user_id":null,"body":"(ns kata)\n\n(defn solve [numbers]\n  (let [l (count numbers)\n        vec-numbers (vec numbers)]\n    (loop [index 0\n           result []]\n\n      (let [new-index (inc index)]\n\n        (if (>= index l)\n          result\n          (recur\n           new-index\n           (if (or (= new-index l)\n                   (= 0 (count (filter (fn [num] (>= num (nth vec-numbers index))) (subvec vec-numbers new-index)))))\n             (conj result (nth vec-numbers index))\n             result)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18365,"user_id":null,"body":"(ns kata)\n\n(defn solve [numbers]\n  (loop [big (last numbers)\n         [first & rest] (reverse numbers)\n         coll (list first)]\n    (cond (nil? first) (vec coll)\n          (> first big) (recur first rest (conj coll first))\n          :else (recur big rest coll))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18366,"user_id":null,"body":"(ns kata)\n\n(defn solve [numbers]\n  (->>\n    (reverse numbers)\n    (reductions max 0)\n    (reverse)\n    (interleave numbers)\n    (partition 2)\n    (filter #(= (first %) (second %)))\n    (map #(first %))\n    (distinct)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18367,"user_id":null,"body":"(ns kata)\n\n(defn solve [numbers]\n  (let [reversed-max-seq (reductions max 0 (reverse numbers))]\n    (->>\n      (reverse numbers)\n      (reductions max 0)\n      (reverse)\n      (interleave numbers)\n      (partition 2)\n      (filter #(= (first %) (second %)))\n      (map #(first %))\n      (distinct))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18368,"user_id":null,"body":"(ns kata)\n\n(defn is-biggest-in [n array]\n  (> n (apply max array)))\n\n(defn solve [numbers]\n  (loop [num (first numbers)\n         others (rest numbers)\n         result []]\n    (if (empty? others)\n      (conj result num)\n      (let [next-result (if (is-biggest-in num others) (conj result num) result)]\n        (recur (first others) (rest others) next-result)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18369,"user_id":null,"body":"(ns kata)\n\n(defn solve [numbers]\n  (let [numbers (vec numbers)]\n    (map\n     first\n     (filter #(if\n                (empty? (rest %)) true\n                (> (first %) (apply max (rest %))))\n             (map-indexed (fn [index item] (subvec numbers index)) numbers)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18370,"user_id":null,"body":"(ns kata)\n\n(defn solve [numbers]\n  (loop [[head & tail] numbers\n         acc []]\n    (if (= 0 (count tail))\n      (conj acc head)\n      (recur tail (if (every? (partial > head) tail)\n                    (conj acc head)\n                    acc)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a045fee46d843effa000070":[{"id":18371,"user_id":null,"body":"(ns fact-decomp.core)\n\n(defn factors [n]\n  (loop [n n d 2 acc []]\n    (if (= 1 n)\n      acc\n      (if (zero? (mod n d))\n        (recur (quot n d) d (conj acc d))\n        (recur n (inc d) acc)))))\n\n(defn decomp [n]\n  (->> (range 2 (inc n))\n       (mapcat factors)\n       frequencies\n       (sort-by first)\n       (map (fn [[a b]]\n              (if (= 1 b) (str a) (str a \"^\" b))))\n       (clojure.string\/join \" * \")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18372,"user_id":492,"body":"(ns fact-decomp.core)\n(require '[clojure.string :as str])\n  \n(defn decomp [n]\n  (defn sieve [n]\n    (defn sieve-aux [n]\n      (let [bs (new java.util.BitSet n)]\n        (.flip bs 2 n)\n        (doseq [i (range 4 n 2)] (.clear bs i))\n        (doseq [p (range 3 (Math\/sqrt n))]\n          (if (.get bs p)\n            (doseq [q (range (* p p) n (* 2 p))] (.clear bs q))))\n        bs))\n    (take-while #(not (= % -1)) (iterate #(.nextSetBit (sieve-aux (inc n)) (inc %)) 2))\n  )\n  (defn get-power [n p]\n    (loop [i n s 0]\n      (if (< i p)\n        s\n        (let [q (quot i p)]\n          (recur q (+ s q)))\n      )\n    )\n  )\n  (defn mk-string [n x]\n    (let [p (get-power n x)]\n      (if (= p 1)\n        (str x)     \n        (str (str x) \"^\" (str p))\n      )\n    )\n  ) \n  \n  (if (< n 2)\n      1\n      (let [u (sieve n) a (map (fn [x] (mk-string n x)) u)]\n        (str\/join \" * \" a)\n      )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18373,"user_id":null,"body":"(ns fact-decomp.core)\n  \n\n(defn prime? [n]\n  (->> n\n       Math\/sqrt\n       int\n       inc\n       (range 2)\n       (filter #(= 0 (mod n %)))\n       first\n       not))\n\n(def prime-seq (->> (range)\n                    (drop 2)\n                    (filter prime?)))\n\n(defn primes [n]\n  (take-while #(<= % n) prime-seq))\n(defn pp [m count]\n  (case count\n    1 (str m)\n    0 nil\n    (str m \"^\" count)))\n\n(defn divs [n i]\n  (let [count (->> (iterate #(* i %) i)\n                   (map #(quot n %))\n                   (take-while pos?)\n                   (reduce +))]\n    [i count]))\n\n(defn decomp [n]\n  (->> (primes n)\n       (map #(apply pp (divs n %)))\n       (filter some?)\n       (reduce #(str %1 \" * \" %2))))\n ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18374,"user_id":null,"body":"(ns fact-decomp.core\n  (:require [clojure.string :as s]))\n\n(def factorial \n  (memoize \n   (fn [n]\n     (if (zero? n)\n       1\n       (*' (factorial (dec n)) n)))))\n\n(def primes \n  (let [prime? \n        (fn [n]\n          (zero? (mod (inc (factorial (dec n))) n)))]\n    (filter prime? (drop 2 (range)))))\n\n(defn prime-factors [n]\n  ((fn f [n [h & r :as ps]]\n     (cond (< n 2) '()\n       (zero? (mod n h)) (cons h (lazy-seq (f (quot n h) ps)))\n       :else (recur n r)))\n   n primes))\n\n(defn factorial-prime-factors\n  [n]\n  (->> (range 1 (inc n))\n       (map prime-factors)\n       (apply concat)))\n\n(defn decomp [n]\n  (->> (factorial-prime-factors n)\n       (frequencies)\n       (reduce-kv conj [])\n       (partition 2)\n       (sort-by first)\n       (map \n        (fn [[factor exponent]]\n          (if (> exponent 1)\n            (str factor \"^\" exponent)\n            (str factor))))\n       (s\/join \" * \")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18375,"user_id":null,"body":"(ns fact-decomp.core)\n  \n(defn dividers [n]\n  (loop [n      n\n         f      2\n         result []]\n    (if (<= (* f f) n)\n      (if (zero? (mod n f))\n        (recur (\/ n f) f (conj result f))\n        (recur n (inc f) result))\n      (if (not= n 1)\n        (conj result n)\n        result))))\n\n\n(defn decomp [n]\n  (->> (range 1 (inc n))\n       (map dividers)\n       flatten\n       frequencies\n       (into (sorted-map))\n       (reduce-kv\n         (fn [res k v]\n           (conj res (if (= v 1) k (str k \"^\" v))))\n         [])\n       (clojure.string\/join \" * \")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18376,"user_id":null,"body":"(ns fact-decomp.core)\n\n(defn- test-prime\n  [x]\n  (loop [iter 5 top (Math\/sqrt x)]\n    (cond\n      (> iter top) true\n      (or (zero? (mod x iter))\n          (zero? (mod x (+ 2 iter)))) false\n      :else (recur (+ 6 iter) top))))\n(defn is-prime\n  [x]\n  (cond\n    (<= x 3) (< 1 x)\n    (or (zero? (mod x 2))\n        (zero? (mod x 3))) false\n    :else (test-prime x)))\n(defn zeros [n f]\n  (loop [[x & rest] (iterate #(* f %) f)\n         res 0]\n    (if (< (\/ n x) 1)\n      res\n      (recur rest (+ res (quot n x)) )))\n  )\n\n(defn decomp [n]\n  (->> (filter is-prime (range (inc n)))\n       (map (fn [x]\n              (let [y (zeros n x)]\n                (if (> y 1)\n                  (str x \"^\" y)\n                  (str x)))\n              ))\n       (clojure.string\/join \" * \"))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18377,"user_id":168,"body":"(ns fact-decomp.core)\n\n(defn get-exp [n p]\n  (->> n\n       (iterate #(quot % p))\n       (take-while #(and (pos? %) (zero? (rem % p))))\n       (count)))\n\n(defn get-fact-exp [n p]\n  (->> (range p (inc n))\n       (map #(get-exp % p))\n       (apply +)))\n\n(defn fmt-exp [p e]\n  (if (= e 1) (str p) (format \"%d^%d\" p e)))\n\n(defn decomp [n]\n  (->> (range 2 (inc n))\n       (filter #(.isProbablePrime (biginteger %) 10))\n       (map #(fmt-exp % (get-fact-exp n %)))\n       (clojure.string\/join \" * \")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18378,"user_id":null,"body":"(ns fact-decomp.core\n  (:require [clojure.string :as str]))\n\n(defn prime? [n]\n  (cond\n    (< n 2) false\n    (#{2 3 5 7} n) true\n    :else (->> (range 1 n)\n               (map (fn [x] (dec (* x 6))))\n               (take-while (fn [x] (<= (* x x) n)))\n               (#(conj % 2 3 5))\n               (some (fn [x] (or (= 0 (mod n x)) (= 0 (mod n (+ 2 x))))))\n               (not))))\n\n(def primes (filter prime? (range 2 4000)))\n\n(defn decomp-dict [n]\n  (loop [ps primes product n res (sorted-map)]\n    (let [p (first ps)]\n      (cond\n        (<= product 1) res\n        (= 0 (mod product p)) (recur ps (quot product p) (assoc res p (inc (get res p 0))))\n        :else (recur (next ps) product res)))))\n\n\n(defn to-str [m]\n  (str\/join \" * \" (map (fn [[k v]] (if (> v 1) (str k \"^\" v) (str k))) m)))\n\n(defn decomp [n]\n  (->> n\n       (inc)\n       (range 2)\n       (map decomp-dict)\n       (apply merge-with +)\n       (to-str)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18379,"user_id":null,"body":"(ns fact-decomp.core (:require [clojure.string :as st]))\n  \n(def primes\n  (concat\n   [2 3 5 7]\n   (lazy-seq\n    (let [primes-from (fn primes-from [n [f & r]]\n                        (if (some #(zero? (rem n %))\n                                  (take-while #(<= (* % %) n) primes))\n                          (recur (+ n f) r)\n                          (lazy-seq (cons n (primes-from (+ n f) r)))))\n          wheel       (cycle [2 4 2 4 6 2 6 4 2 4 6 6 2 6  4  2\n                              6 4 6 8 4 2 4 2 4 8 6 4 6 2  4  6\n                              2 6 6 4 2 4 6 2 6 4 2 4 2 10 2 10])]\n      (primes-from 11 wheel)))))\n\n(def least-prime-factor\n  (memoize\n   (fn [n]\n     (loop [[p & ps] primes]\n       (if-not (zero? (rem n p))\n         (recur ps)\n         p)))))\n\n(def prime-factors\n  (memoize\n   (fn [n]\n     (lazy-seq\n      (when (> n 1)\n        (let [p (least-prime-factor n)]\n          (cons p (prime-factors (quot n p)))))))))\n\n(defn decomp [n]\n  (->> (range 1 (inc n))\n       (mapcat prime-factors)\n       frequencies\n       sort\n       (map (fn [[n p]] (cond-> (str n) (> p 1) (str \"^\" p))))\n       (st\/join \" * \")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18380,"user_id":null,"body":"(ns fact-decomp.core)\n  \n(defn factors [nn]\n  (loop [n nn acc (list)]\n    (let [primes\n        (drop-while #(not (= 0 (mod n %))) (range 2 (inc (Math\/floor (Math\/sqrt n)))))]\n      (if (empty? primes)\n        (conj acc n)\n        (recur (\/ n (first primes)) (conj acc (first primes)))))))\n\n(defn decomp [n]\n  (->>\n   (map factors (range 2 (inc n)))\n   (flatten)\n   (frequencies)\n   (seq)\n   (sort-by first)\n   (map (fn [[k v]] (if (= v 1) (format \"%s\" k) (format \"%s^%s\" k v))))\n   (interpose \" * \")\n   (apply str)))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a057ec846d843c81a0000ad":[{"id":18381,"user_id":527,"body":"(ns cycle-n.core)\n\n(defn cycli [n]\n  (if (or (zero? (mod n 2)) (zero? (mod n 5)))\n    -1\n    (->> 1\n      (iterate (fn [r] (mod (* r 10) n)))\n      (keep-indexed (fn [i r] (when (= r 1) i)))\n      second)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18382,"user_id":492,"body":"(ns cycle-n.core)\n\n(defn cycli [n]\n  (if (or (= 0 (mod n 2)) (= 0 (mod n 5)))\n    -1\n    (loop [i 1 val 1]\n      (let [ v (mod (* val 10) n)]\n        (if (not= v 1)\n        (recur (+ i 1) v)\n        i)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18383,"user_id":53,"body":"(ns cycle-n.core)\n\n(defn cycli [n]\n  (if (or (zero? (mod n 2)) (zero? (mod n 5))) -1\n    (loop [m (mod 10 n) i 1]\n      (if (= 1 m) i\n        (recur (mod (* m 10) n) (inc i))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18384,"user_id":492,"body":"(ns cycle-n.core)\n\n(defn cycli [n]\n  (if (or (= 0 (mod n 2)) (= 0 (mod n 5)))\n    -1\n    (loop [i 1 val 1]\n      (let [ v (mod (* val 10) n)]\n        (if (not= v 1)\n        (recur (+ i 1) v)\n        i)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18385,"user_id":62,"body":"(ns cycle-n.core)\n\n(defn cycli [n]\n  (if (or (zero? (rem n 5)) \n          (zero? (rem n 2))) \n    -1\n    (second\n     (keep-indexed\n      #(when (= 1 %2) %1)\n      (iterate (comp #(rem % n) (partial * 10)) 1)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18386,"user_id":null,"body":"(ns cycle-n.core)\n\n(defn- gcd [a b] (.gcd (biginteger a) (biginteger b)))\n(defn- co-prime? [a b] (= 1 (gcd a b)))\n\n(defn cycli [n]\n  (if (co-prime? n 10)\n    (loop [x 10 c 1]\n      (let [x (mod x n)]\n        (if-not (= x 1)\n          (recur (* x 10) (inc c))\n          c)))\n    -1))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18387,"user_id":null,"body":"(ns cycle-n.core)\n\n(defn cycli [n]\n  (if (or (zero? (mod n 5))\n          (zero? (mod n 2)))\n    -1\n    (->> (iterate #(mod (* % 10) n) 1)\n         (drop 1)\n         (map-indexed vector)\n         (filter (fn [[k v]] (= 1 v)))\n         first\n         first\n         inc)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18388,"user_id":null,"body":"(ns cycle-n.core)\n\n(defn gcd [a b] (if (zero? b) a (recur b (mod a b))))\n\n(defn coprime? [a b] (= 1 (gcd a b)))\n\n(defn reminder-cycle [div]\n  (let [mod-fn (fn [n] (mod (* 10 n) div))]\n    (drop 1 (iterate mod-fn 1))))\n\n(defn cycli [n] \n  (if (not (coprime? 10 n))\n    -1\n    (->> (reminder-cycle n)\n         (map vector (range))\n         (reduce (fn [acc [k v]]\n                   (if (contains? acc v)\n                     (reduced (- k (acc v)))\n                     (assoc acc v k)))\n                 {}))))\n    \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18389,"user_id":null,"body":"(ns cycle-n.core)\n\n(defn cycli [n]\n  (if (or (zero? (rem n 2)) (zero? (rem n 5)) )\n    -1\n    (loop [x 1\n        x9modn (rem 9 n)\n        x9modn-i (rem 90 n)]\n      (if (or (zero? x9modn) (>= x (dec n)))\n        x\n        (recur (inc x) (rem (+ x9modn x9modn-i) n) (rem (* x9modn-i 10) n)))))\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18390,"user_id":null,"body":"(ns cycle-n.core)\n\n(defn cycli\n  [n]\n  ; your code\n  ;(\/ 1 7) -> (\/ 3 7) -> (\/ 2 7) -> (\/ 6 7) -> (\/ 4 7) -> (\/ 5 7) -> (\/ 1 7)\n  ;(\/ 1 33) ->  (\/ 10 33) -> (\/ 100 33) -> (\/ 1 33)\n\n  (if (or (zero? (mod n 5)) (zero? (mod n 2)))\n    -1\n    (loop [x (\/ 1 n)\n           i 0 ]\n      (cond\n        (and (= (\/ 1 n) x) (not (zero? i))) i\n        :else (recur\n               (\/ (mod (numerator (* 10 x)) n) n)\n               (inc i))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a090c4e697598d0b9000004":[{"id":18391,"user_id":527,"body":"(ns kata)\n\n(defn solve [xs]\n  (let [xs (vec (sort xs))]\n    (take (count xs) (interleave (rseq xs) xs))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18392,"user_id":1400,"body":"(ns kata)\n\n(defn solve [numbers]\n  (let [\n        mins (sort numbers)\n        maxs (reverse mins)\n        ]\n    (take (count numbers) (interleave maxs mins))\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18393,"user_id":null,"body":"(ns kata)\n\n(defn solve\n  ([numbers] (solve numbers []))\n  ([numbers array]\n\n   (let [sorted-array (sort numbers)]\n     (cond (= 0 (count sorted-array)) array\n           (= 1 (count sorted-array)) (conj array (first sorted-array))\n           :else (solve (drop-last 1 (rest sorted-array)) (conj array (last sorted-array) (first sorted-array)))\n           )\n   )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18394,"user_id":null,"body":"(ns kata)\n\n(defn solve [nums]\n  (let [max-nums (sort > nums)\n        min-nums (sort nums)]\n    (distinct (interleave max-nums min-nums))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18395,"user_id":null,"body":"(ns kata)\n\n(defn solve [numbers]\n  (loop [result []\n         ascending (sort numbers)\n         descending (reverse (sort numbers))]\n    (cond\n      (and (empty? ascending) (empty? descending))\n      (take (\/ (count result) 2) result)\n      :else\n      (recur\n       (cond\n         (empty? ascending) (conj result (first descending))\n         (empty? descending) (conj result (first ascending))\n         :else\n         (conj (conj result (first descending)) (first ascending)))\n       (rest ascending)\n       (rest descending)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18396,"user_id":null,"body":"(ns kata)\n\n(defn solve [numbers]\n  (loop [nums (reverse (sort numbers)) acc []]\n    (if (> (count nums) 2)\n      (recur (rest (butlast nums)) (conj acc (first nums) (last nums)))\n      (concat acc nums))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18397,"user_id":null,"body":"(ns kata)\n\n(defn solve [numbers]\n  (let [len (count numbers)\n        ascending (sort numbers)\n        descending (reverse ascending)]\n    (take len (interleave descending ascending))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18398,"user_id":null,"body":"(ns kata)\n\n(defn solve [numbers]\n  (let [numbers-size (count numbers)\n        half-size (\/ (count numbers) 2)\n        how-many-to-take half-size\n        min-sorted (sort numbers)\n        max-sorted (reverse min-sorted)\n        half-min (take how-many-to-take min-sorted)\n        half-max (take how-many-to-take max-sorted)\n        answer (interleave half-max half-min)\n        answer (if (odd? numbers-size)\n                 (drop-last answer)\n                 answer)]\n    answer))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18399,"user_id":null,"body":"(ns kata)\n\n(defn solve [numbers]\n  (loop [[x & xs] (sort numbers)\n         acc []]\n    (cond\n      (nil? x) acc\n      (empty? xs) (concat acc [x])\n      :else (recur (drop-last xs) (concat acc [(last xs) x])))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18400,"user_id":null,"body":"(ns kata)\n\n(defn solve [numbers]\n  (let [big-to-low-half (take (\/ (count numbers) 2) (sort > numbers))\n        low-to-big-half (reverse (drop (\/ (count numbers) 2) (sort > numbers)))]\n    (println big-to-low-half)\n    (println low-to-big-half)\n    (concat (flatten (map vector big-to-low-half low-to-big-half)) \n            (if (> (count big-to-low-half) (count low-to-big-half)) \n              [(last big-to-low-half)] \n              []))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a092d9e46d843b9db000064":[{"id":18401,"user_id":null,"body":"(ns kata)\n\n(defn solve [numbers]\n  (reduce + (distinct numbers)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18402,"user_id":null,"body":"(ns kata)\n\n(defn solve [xs] (reduce + (distinct xs)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18403,"user_id":null,"body":"(ns kata)\n\n(defn solve [numbers]\n  (->> (group-by #(Math\/abs %) numbers)\n       (vals)\n       (filter #(not= 0 (reduce + %)))\n       (ffirst)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18404,"user_id":null,"body":"(ns kata)\n\n(defn solve [numbers]\n  (let [numbers-set (set numbers)]\n    (first (filter #(false? (contains? numbers-set (* -1 %))) numbers))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18405,"user_id":759,"body":"(ns kata)\n\n(defn solve [numbers]\n  (some\n    (fn [n]\n      (when (every? #(not (= %1 (- n))) numbers) n))\n    numbers))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18406,"user_id":null,"body":"(ns kata\n  (:require [clojure.data :refer [diff]]))\n\n(defn solve [numbers]\n  (reduce + (distinct numbers)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18407,"user_id":881,"body":"(ns kata)\n\n(defn solve [numbers]\n  (apply + (distinct numbers)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18408,"user_id":527,"body":"(ns kata)\n\n(defn solve [numbers]\n  (reduce + (set numbers)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18409,"user_id":527,"body":"(ns kata)\n\n(defn solve [numbers]\n  (apply + (set numbers)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18410,"user_id":201,"body":"(ns kata)\n\n(defn solve [numbers]\n  (loop [n 0]\n    (if (>= n (count numbers)) nil\n        (if (not (some #{(* -1 (nth numbers n))} numbers)) (nth numbers n)\n            (recur (inc n))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a145ab08ba9148dd6000094":[{"id":18411,"user_id":527,"body":"(ns kata)\n(defn string-doubles [s]\n  (->> s\n    (reduce (fn [cs c] (if (= c (peek cs)) (pop cs) (conj cs c))) ())\n    (reverse)\n    (apply str)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18412,"user_id":null,"body":"(ns kata)\n(def d #\"(.)\\1\")\n(defn string-doubles [strng]\n  (if (re-find d strng) (recur (clojure.string\/replace strng d \"\")) strng))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18413,"user_id":null,"body":"(ns kata)\n(defn string-doubles [strng]\n  (def d #\"(.)\\1\") (if (re-find d strng) (recur (clojure.string\/replace strng d \"\")) strng))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18414,"user_id":null,"body":"(ns kata)\n\n(defn- remove-dbl [sq item]\n  (if (= (first sq) item)\n    (rest sq)\n    (cons item sq)))\n\n(defn string-doubles [strng]\n  (->>\n    strng\n    (reduce remove-dbl (list))\n    (reverse)\n    (apply str)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18415,"user_id":null,"body":"(ns kata)\n\n(defn string-doubles\n  ([str]\n   (string-doubles str []))\n  ([str queue]\n   (if (not (seq str))\n     (clojure.string\/join \"\" queue) \n     (recur (rest str)\n            (let [first-char (first str)]\n              (if (= first-char (last queue))\n                (vec (drop-last queue))\n                (conj queue first-char)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18416,"user_id":null,"body":"(ns kata\n  (require [clojure.string :as str]))\n\n(defn string-doubles [s]\n  (let [s2 (->> (partition-by identity s)\n                (mapcat (partial partition-all 2))\n                (remove #(= 2 (count %)))\n                (flatten)\n                (str\/join \"\"))]\n    (if (= s2 s)\n      s2\n      (recur s2))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18417,"user_id":527,"body":"(ns kata)\n(defn string-doubles [s]\n  (->> s\n    (reduce\n      (fn [cs c] (if (= c (last cs)) (.deleteCharAt cs (dec (count cs))) (.append cs c)))\n      (new StringBuilder))\n    (.toString)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18418,"user_id":201,"body":"(ns kata)\n\n(defn string-doubles [strng]\n     (loop [[x :as xs] strng\n            acc        []]\n       (if (empty? xs) (let [s (apply str acc)]\n                         (if (= s strng) s (string-doubles s)))\n           (let [[new-rest new-acc]\n                 (if (= x (second xs)) [(drop 2 xs) acc]\n                     [(rest xs) (conj acc x)])]\n             (recur new-rest new-acc)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a24254fe1ce0ec2eb000078":[{"id":18419,"user_id":null,"body":"(ns kata)\n\n(defn solve [s idx]\n  (if (not= (get s idx) \\( )\n    -1\n    (loop [s (subs s (inc idx))\n           idx (inc idx)\n           cnt 0]\n      (when (not (empty? s)) (println s))\n      (cond (and (= (first s) \\) ) (zero? cnt))\n            idx\n            (= (first s) \\) )\n            (recur (rest s) (inc idx) (dec cnt))\n            (= (first s) \\( )\n            (recur (rest s) (inc idx) (inc cnt))\n            :else\n            (recur (rest s) (inc idx) cnt)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18420,"user_id":null,"body":"(ns kata)\n\n(defn solve\n  ([s idx]\n   (if (= (nth s idx) \\()\n     (solve s (inc idx) 1)\n     -1))\n  ([s idx ct]\n   (case (nth s idx)\n     (\\() (recur s (inc idx) (inc ct))\n     (\\)) (if (= ct 1) idx (recur s (inc idx) (dec ct)))\n     (recur s (inc idx) ct))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18421,"user_id":527,"body":"(ns kata)\n\n(defn solve [s i]\n  (if (not= \\( (nth s i))\n    -1\n    (loop [i (inc i) k 1]\n      (let [k (+ k (case (nth s i) \\( +1 \\) -1 0))]\n        (if (zero? k) i (recur (inc i) k))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18422,"user_id":201,"body":"(ns kata)\n\n(defn solve [s idx]\n  (if (not= (nth s idx) \\() -1\n      (loop [i (inc idx)\n             bracket 0]\n        (if (and (zero? bracket)\n                 (= \\) (nth s i))) i\n            (let [bracket (if (= \\( (nth s i))\n                            (inc bracket)\n                            bracket)\n                  bracket (if (= \\) (nth s i))\n                            (dec bracket)\n                            bracket)]\n              (recur (inc i) bracket))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a262cfb8f27f217f700000b":[{"id":18423,"user_id":527,"body":"(ns kata)\n\n(defn solve [a b]\n  (apply str (concat (remove (set b) a) (remove (set a) b))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18424,"user_id":201,"body":"(ns kata)\n\n(defn solve [a b]\n  (apply str (concat (remove (into #{} b) a)\n                     (remove (into #{} a) b))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18425,"user_id":null,"body":"(ns kata\n  (:require [clojure.string :as s]))\n\n (defn solve [a b]\n    (let [a-chars (s\/split a #\"\")\n          b-chars (s\/split b #\"\")\n          a-filtered (filter #(> 0 (.indexOf b-chars %)) a-chars)\n          b-filtered (filter #(> 0 (.indexOf a-chars %)) b-chars)]\n      (str (apply str a-filtered) (apply str b-filtered))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18426,"user_id":1400,"body":"(ns kata)\n(require 'clojure.set)\n\n(defn solve [a b]\n  (let [s (clojure.set\/intersection (set a) (set b))]\n    (reduce str (apply list (concat \n      (filter (fn [x] (not (contains? s x))) a)\n      (filter (fn [x] (not (contains? s x))) b)\n    )))\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18427,"user_id":null,"body":"(ns kata)\n\n(defn solve [a b]\n  (apply str (concat \n              (filter #(not ((set b) %)) a)\n              (filter #(not ((set a) %)) b)\n              ))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18428,"user_id":null,"body":"(ns kata)\n\n(def excludes? (complement contains?))\n\n(defn solve [a b]\n  (let [l1 (filter (partial excludes? (set b)) a)\n        l2 (filter (partial excludes? (set a)) b)]\n    (apply str (concat l1 l2))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18429,"user_id":null,"body":"(ns kata)\n\n(defn cmp [a b]\n  (filter (complement #(clojure.string\/includes? a (str %))) b))\n\n(defn solve [a b]\n  (let [diff-a-b (cmp a b)\n       diff-b-a (cmp b a)]\n    (apply str (map #(clojure.string\/join \"\" %) [diff-b-a diff-a-b]))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18430,"user_id":null,"body":"(ns kata)\n\n(defn solve [a b]\n  (clojure.string\/join \n    (concat \n      (filter #(not (.contains b (str %))) a)\n      (filter #(not (.contains a (str %))) b))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18431,"user_id":null,"body":"(ns kata)\n\n(defn solve [a b]\n  (let [combined-string (str a b)\n        uniq-characters (map first (filter #(= 1 (second %)) (frequencies (concat (distinct a) (distinct b)))))\n        character-is-unique? (fn [char] (some #(= char %) uniq-characters))\n        filtered-chars (filter character-is-unique? combined-string)\n        filtered-string (apply str filtered-chars)] \n    filtered-string))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18432,"user_id":null,"body":"(ns kata)\n\n(defn not-in\n  [a b]\n  (let [b-unique-chars (set b)]\n    (vec (filter #(not (b-unique-chars %)) a))))\n\n(defn solve [a b]\n  (let [a-not-in-b (not-in a b)\n        b-not-in-a (not-in b a)]\n    (apply str (into a-not-in-b b-not-in-a))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a29a0898f27f2d9c9000058":[{"id":18433,"user_id":null,"body":"(ns kata)\n\n(defn pattern [regex string]\n  (-> regex re-pattern (re-seq string) count))\n\n(defn solve [s]\n  (map #(pattern % s) [\"[A-Z]\" \"[a-z]\" \"[0-9]\" \"[^A-Za-z0-9]\"]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18434,"user_id":null,"body":"(ns kata)\n\n(defn solve [s]\n  [(count (re-seq #\"[A-Z]\" s))\n   (count (re-seq #\"[a-z]\" s))\n   (count (re-seq #\"\\d\" s))\n   (count (re-seq #\"[^a-zA-Z0-9]\" s))])","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18435,"user_id":null,"body":"(ns kata)\n\n(defn solve [s]\n  (let [\n    uc (count (re-seq #\"[A-Z]\" s))\n    lc (count (re-seq #\"[a-z]\" s))\n    nm (count (re-seq #\"[0-9]\" s))\n    ln (count s)]\n  (vector uc lc nm (- ln (+ uc lc nm)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18436,"user_id":null,"body":"(ns kata)\n\n(defn fil [s w]\n  (count (seq (re-seq s w))))\n\n(defn solve [s]\n  (list (fil #\"[A-Z]\" s)\n        (fil #\"[a-z]\" s)\n        (fil #\"[\\d]\" s)\n        (fil #\"[^A-Za-z0-9]\" s)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18437,"user_id":null,"body":"(ns kata)\n\n(defn fil [s w]\n  (count (seq (apply str (re-seq s w)))))\n\n(defn solve [s]\n  (list (fil #\"[A-Z]\" s)\n        (fil #\"[a-z]+\" s)\n        (fil #\"[0-9]+\" s)\n        (fil #\"[^A-Za-z0-9]+\" s)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18438,"user_id":null,"body":"(ns kata)\n(defn solve [s]\n  (let [upper (count (filter #(Character\/isUpperCase %) s))\n        lower (count (filter #(Character\/isLowerCase %) s))\n        nums (count (filter #(Character\/isDigit %) s))\n        specials (count(filter #(not (Character\/isLetterOrDigit %)) s))]\n    [upper lower nums specials]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18439,"user_id":null,"body":"(ns kata\n   (:require [clojure.string :as cstr]))\n\n(defn solve\n  ([v] (solve v [\"[A-Z]\" \"[a-z]\" \"[0-9]\" \"[^A-Za-z0-9]\"] []))\n  ([v cre r]\n   (if (empty? cre)\n     r\n     (recur v\n            (rest cre)\n            (->> v\n                 (re-seq (re-pattern (first cre)))\n                 count\n                 (conj r))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18440,"user_id":null,"body":"(ns kata)\n\n(defn solve [s]\n  (let [uppercase (count (re-seq #\"[A-Z]\" s))\n        lowercase (count (re-seq #\"[a-z]\" s))\n        numbers (count (re-seq #\"\\d\" s))\n        special (count (re-seq #\"\\W\" s))]\n    [uppercase lowercase numbers special]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18441,"user_id":null,"body":"(ns kata)\n\n(defn solve\n  [s]\n  (reduce (fn\n    [[a b c d] it]\n    (cond\n      (Character\/isUpperCase it) [(inc a) b c d]\n      (Character\/isLowerCase it) [a (inc b) c d]\n      (Character\/isDigit it) [a b (inc c) d]\n      :else [a b c (inc d)])) [0 0 0 0] s))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18442,"user_id":null,"body":"(ns kata)\n(defn solve [s]\n  [(count (re-seq #\"[A-Z]\" s))\n   (count (re-seq #\"[a-z]\" s))\n   (count (re-seq #\"[0-9]\" s))\n   (count (re-seq #\"[^0-9A-Za-z]\" s))])","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a3e1319b6486ac96f000049":[{"id":18443,"user_id":null,"body":"(ns kata)\n\n(defn pairs [arr]\n  (->> (partition 2 arr)\n       (filter (fn [[a b]] (= 1 (Math\/abs (- b a)))))\n       (count)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18444,"user_id":null,"body":"(ns kata)\n\n(defn pairs [coll]\n    (let [pair-coll (partition 2 coll)\n          map-minus (map #(apply - %) pair-coll)]\n      (count (filter #{-1 1} map-minus))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18445,"user_id":168,"body":"(ns kata)\n\n(defn pairs [arr]\n  (->> (partition 2 arr)\n       (filter (fn [[a b]] (= (Math\/abs (- a b)) 1)))\n       (count)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18446,"user_id":null,"body":"(ns kata)\n\n(defn consecutive? [int1 int2]\n  (if (or (= (inc int1) int2) (= (inc int2) int1))\n    true\n    false\n    )\n)\n\n(defn pairs [arr]\n  (->>  (partition 2 arr)\n        (map #(if (consecutive? (first %) (last %)) 1 0))\n        (reduce +)\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18447,"user_id":null,"body":"(ns kata)\n\n(defn pairs [arr]\n  (->> (partition 2 arr)\n       (map sort)\n       (filter #(= (inc (first %)) (second %)))\n       count))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18448,"user_id":null,"body":"(ns kata)\n\n(defn pairs\n  ([arr] (pairs arr 0))\n  ([arr counter]\n  (if (> (count arr) 1)\n      (if (= (Math\/abs (- (first arr) (second arr))) 1)\n          (pairs (nthrest arr 2) (inc counter))\n          (pairs (nthrest arr 2) counter)\n             )\n      counter)\n    )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18449,"user_id":null,"body":"(ns kata)\n\n\n\n(defn pairs [arr]\n  (->> (partition 2 arr)\n    (filter (fn [[a b]] (= 1 (Math\/abs (- a b)))))\n    (count))\n  \n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18450,"user_id":1400,"body":"(ns kata)\n\n(defn pairs2 [arr2]\n  ;(println arr2)\n  (def x (nth arr2 0))\n  (def y (nth arr2 1))\n  (def delta (Math\/abs (- x y)))\n  (if (= delta 1)\n    1\n    0\n  )\n)\n\n(defn pairs [arr]\n  (if (< (count arr) 2)\n    0\n    (+ \n     (pairs2 (take 2 arr))\n     (pairs (drop 2 arr))\n    )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18451,"user_id":null,"body":"(ns kata)\n\n(defn pairs [xs]\n  (reduce\n   (fn [c [a b]]\n     (cond-> c (= a (inc b)) inc (= a (dec b)) inc))\n   0\n   (partition 2 xs)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18452,"user_id":null,"body":"(ns kata)\n\n(defn pairs [arr]\n  (count (filter #(= 1 (Math\/abs (- (first %) (last %)))) (partition 2 arr))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a3fe3dde1ce0e8ed6000097":[{"id":18453,"user_id":null,"body":"(ns century_from_year.core)\n\n(defn century_from_year [year]\n  (if (zero? (rem year 100)) \n    (quot year 100) \n    (inc (quot year 100))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18454,"user_id":null,"body":"(ns century_from_year.core)\n\n(defn century_from_year\n  [year]\n  (-> year\n      dec\n      (quot 100)\n      inc))\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18455,"user_id":null,"body":"(ns century_from_year.core)\n\n(defn century_from_year [year]\n(+ 1 (quot (- year 1) 100)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18456,"user_id":null,"body":"(ns century_from_year.core)\n\n(defn century_from_year [year]\n  (if (zero? (mod year 100))\n    (quot year 100)\n    (+ 1 (quot year 100))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18457,"user_id":null,"body":"(ns century_from_year.core)\n  (defn century_from_year [year] (+ (quot (- year 1) 100) 1))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18458,"user_id":null,"body":"(ns century_from_year.core)\n\n(defn century_from_year \n  [year]\n  (quot (+ 99\n           year)\n        100))\n        ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18459,"user_id":null,"body":"(ns century_from_year.core)\n\n(defn century_from_year [year]\n  (inc (quot (- year 1) 100)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18460,"user_id":null,"body":"(ns century_from_year.core)\n(defn century_from_year [year] \n  (+ 1 (Math\/floorDiv (- year 1) 100))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18461,"user_id":null,"body":"(ns century_from_year.core)\n\n(defn century_from_year [year]\n  (let \n    [\n     yearmod   (mod year 100)\n     intpart   (int (\/ year 100))\n     cent      (cond \n                 (zero? yearmod)    intpart\n                 :else              (inc intpart)\n                 )\n     ] cent)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18462,"user_id":null,"body":"(ns century_from_year.core)\n(defn century_from_year [year] \n  (let [c (quot year 100)\n        r (rem year 100)]\n    (if (zero? r) c (inc c))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a4138acf28b82aa43000117":[{"id":18463,"user_id":null,"body":"(ns kata)\n\n(defn adjacent_element_product [numbers]\n  (reduce max (map * numbers (rest numbers)))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18464,"user_id":null,"body":"(ns kata)\n\n(defn adjacent_element_product [numbers]\n  (->>\n    (map * numbers (rest numbers))\n    (reduce max)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18465,"user_id":null,"body":"(ns kata)\n\n(defn windowed [v]\n  (map vector v (rest v)))\n\n(def adjacent_element_product\n  (comp (partial apply max)\n        (partial map (partial apply *))\n        windowed))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18466,"user_id":1703,"body":"(ns kata)\n\n(defn adjacent_element_product [n]\n  (apply max(map-indexed #(if(= (dec(count n)) %1) (* (nth n 0)(nth n 1)) \n                  (* (nth n (inc %1)) %2))n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18467,"user_id":null,"body":"(ns kata)\n\n(defn adjacent_element_product [numbers]\n  (->> numbers\n       (partition 2 1)\n       (map (fn [[x y]] (* x y)))\n       (apply max)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18468,"user_id":null,"body":"(ns kata)\n\n(defn adjacent_element_product [numbers]\n  (reduce max (map (fn [l] (let [[x y] l] (* x y))) (partition 2 1 numbers))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18469,"user_id":null,"body":"(ns kata)\n\n(defn max-product [[max-number last-number] number]\n  [(max max-number (* number last-number)) number])\n\n(defn adjacent_element_product [numbers]\n  (let [first-num (first numbers),\n        second-num (second numbers)]\n    (first (reduce max-product [(* first-num second-num) second-num] numbers)))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18470,"user_id":null,"body":"(ns kata)\n\n(defn adjacent_element_product [numbers]\n  (apply max (map * (drop-last numbers) (rest numbers))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18471,"user_id":null,"body":"(ns kata)\n\n(defn adjacent_element_product [numbers]\n  ;TODO\n  (->> numbers\n   (map-indexed (fn [idx number]\n                  (if (= idx (dec (count numbers)))\n                    (* (nth numbers idx) (nth numbers (dec idx)))\n                    (* number (nth numbers (inc idx))))))\n   (sort >)\n   first))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18472,"user_id":null,"body":"(ns kata)\n\n(defn adjacent_element_product [numbers]\n  (def idx-len (- (count numbers) 1))\n  (->> numbers\n    (map-indexed \n     #(if (< % idx-len)\n        (* %2 (nth numbers (+ % 1)))\n        %2))\n    (take idx-len)\n    (apply max)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a420163b6cfd7cde5000077":[{"id":18473,"user_id":492,"body":"(ns nba.core)\n\n(defn- one [s to-find]\n  (let [r (first (re-seq #\"([A-Za-z0-9 ]+)(\\s\\d+\\.?\\d*\\s)([A-Za-z0-9 ]+)(\\s\\d+\\.?\\d*)\" s))\n        score1 (r 2)\n        score2 (r 4)\n       ]\n    (if (or (re-find (re-pattern \"\\\\d+\\\\.\\\\d*\") score1) (re-find (re-pattern \"\\\\d+\\\\.\\\\d*\") score1))\n      (str \"Error(float number):\" s)\n      (let [\n            score1 (Integer\/parseInt (clojure.string\/trim score1))\n            score2 (Integer\/parseInt (clojure.string\/trim score2))\n            name1 (r 1)\n            name2 (r 3)\n            WIN \"W\" DRAW \"D\" LOSS \"L\"\n           ] \n    (if (= name1 to-find)\n      (if (> score1 score2)\n        (str WIN \"-\" score1 \"-\" score2)\n        (if (> score2 score1) \n          (str LOSS \"-\" score1 \"-\" score2)\n          (str DRAW \"-\" score1 \"-\" score2)))\n      (if (= name2 to-find)\n        (if (> score2 score1)\n          (str WIN \"-\" score2 \"-\" score1)\n          (if (> score1 score2)\n            (str LOSS \"-\" score2 \"-\" score1)\n            (str DRAW \"-\" score2 \"-\" score1)))\n        \"\"))\n))))\n(defn- final-res [to-find winNb drawNb lossNb markTotal scoredNb concededNb]\n  (let [t (+ winNb drawNb lossNb)]\n    (if (= t 0)\n      (str to-find \":This team didn't play!\")\n      (str \n        to-find \":W=\" winNb \";D=\" drawNb \";L=\" lossNb \";Scored=\" scoredNb \n        \";Conceded=\" concededNb \";Points=\" markTotal))))\n(defn nba-cup [result-sheet to-find]\n  (if (= to-find \"\")\n    \"\"\n    (let [split-array (clojure.string\/split result-sheet #\",\")\n          to-find (clojure.string\/trim to-find)\n         ]\n     (loop [i 0 winNb 0 drawNb 0 lossNb 0 markTotal 0 scoredNb 0 concededNb 0]\n      (if (= i (count split-array))\n        (final-res to-find winNb drawNb lossNb markTotal scoredNb concededNb)\n        (let [res (one (split-array i) to-find)]\n             (if (and (not= res \"\") (= (subs res 0 5) \"Error\"))\n               res\n           (if (= res \"\")\n            (recur (inc i) winNb drawNb lossNb markTotal scoredNb concededNb)\n            (let [match-result (clojure.string\/split res #\"-\")]\n              (cond\n                (= (match-result 0) \"W\") \n                 (recur \n                  (inc i) (inc winNb) drawNb lossNb (+ markTotal 3) \n                  (+ scoredNb (Integer\/parseInt (match-result 1))) \n                  (+ concededNb (Integer\/parseInt (match-result 2))))\n                (= (match-result 0) \"D\") \n                 (recur \n                  (inc i) winNb (inc drawNb) lossNb (+ markTotal 1) \n                  (+ scoredNb (Integer\/parseInt (match-result 1))) \n                  (+ concededNb (Integer\/parseInt (match-result 2))))\n                (= (match-result 0) \"L\") \n                 (recur \n                  (inc i) winNb drawNb (inc lossNb) markTotal \n                  (+ scoredNb (Integer\/parseInt (match-result 1))) \n                  (+ concededNb (Integer\/parseInt (match-result 2)))) ))))\n))))))\n    ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18474,"user_id":null,"body":"    (ns nba.core)\n    (defn nba-cup [result-sheet to-find]\n      (if (= to-find \"\") \"\"\n        (let [rs (clojure.string\/split result-sheet #\",\")\n              ds \"( \\\\d+[.]?\\\\d+( |$))\"\n              ps (re-pattern (str \"(^|\" ds \")\" to-find ds))\n              sel (filter #(re-find ps %) rs)]\n        (if (= sel []) (str to-find \":This team didn't play!\")\n          (let [fl (some #(first (re-matches #\"^.+ \\d+\\.\\d+(( |.+$)|$)\" %)) sel)]\n          (if fl (str \"Error(float number):\" fl)\n            (let [s (map #(re-seq #\"(?<!\\w+)\\d+(?!\\w+)\" %) sel)\n                  pw (re-pattern (str \"(?<=\" to-find \" )\\\\d+(?= |$)\"))\n                  nw (map #(read-string (re-find pw %)) sel)\n                  n2 (map #(read-string (last %)) s)\n                  n1 (map #(read-string (first %)) s) \n                  nl (map #(if (not= %2 %1) %2 %3) nw n1 n2)\n                  w (apply + (map #(if (> %1 %2) 1 0) nw nl)) \n                  l (apply + (map #(if (< %1 %2) 1 0) nw nl)) \n                  d (- (count n1) w l) sc (apply + nw) cc (apply + nl) points (+ (* 3 w) d)]\n            (str to-find \":W=\" w \";D=\" d \";L=\" l \";Scored=\" sc \";Conceded=\" cc \";Points=\" points))))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18475,"user_id":null,"body":"(ns nba.core)\n\n(def wins (atom 0))\n(def draws (atom 0))\n(def loses (atom 0))\n(def scores (atom 0))\n(def conceded (atom 0))\n(def points (atom 0))\n\n(defn error-finder [info]\n  (first (filter some? (for [g info]\n    (let [error? (clojure.string\/includes? g \"Error(float\")]\n        (when error? g))))))\n\n(defn nba-helper [result-sheet to-find]\n  (if (empty? to-find) \n    to-find\n      (let [games (clojure.string\/split result-sheet #\",\")]\n    (for [g games]\n      (let [g-info (re-find #\"^(.*?) (\\d+) (.*?) (\\d+)$\" g)\n            error? (nil? g-info)\n            ]\n        (if error?\n          (str \"Error(float number):\" g)\n          (do\n            (let [game-info (drop 1 g-info)\n                  f_name    (first game-info)\n                  f_score   (clojure.edn\/read-string (second game-info))\n                  s_name    (nth game-info 2)\n                  s_score   (clojure.edn\/read-string (nth game-info 3))]\n              (cond\n                (= to-find f_name) (cond \n                                     (> f_score s_score) (do\n                                                           (swap! wins inc)\n                                                           (reset! points (+ @points 3))\n                                                           (reset! scores (+ f_score @scores))\n                                                           (reset! conceded (+ s_score @conceded))\n                                                           )\n                                     (= f_score s_score) (do\n                                                           (swap! draws inc)\n                                                           (reset! points (+ @points 1))\n                                                           (reset! scores (+ f_score @scores))\n                                                           (reset! conceded (+ s_score @conceded)))\n                                     (< f_score s_score) (do\n                                                           (swap! loses inc)\n                                                           (reset! scores (+ f_score @scores))\n                                                           (reset! conceded (+ s_score @conceded)))\n                                     )\n                (= to-find s_name) (cond \n                                     (> s_score f_score) (do\n                                                           (swap! wins inc)\n                                                           (reset! points (+ @points 3))\n                                                           (reset! scores (+ s_score @scores))\n                                                           (reset! conceded (+ f_score @conceded))\n                                                           )\n                                     (= s_score f_score) (do\n                                                           (swap! draws inc)\n                                                           (reset! points (+ @points 1))\n                                                           (reset! scores (+ s_score @scores))\n                                                           (reset! conceded (+ f_score @conceded)))\n                                     (< s_score f_score) (do\n                                                           (swap! loses inc)\n                                                           (reset! scores (+ s_score @scores))\n                                                           (reset! conceded (+ f_score @conceded)))\n                                     )\n                \n                ))\n            (cond\n              (= 0 @points @conceded @scores) (str to-find \":This team didn't play!\")\n              :else (str to-find \":W=\" @wins \";D=\" @draws \";L=\" @loses \";Scored=\" @scores \";Conceded=\" @conceded \";Points=\" @points)))\n          ))))))\n            \n(defn nba-cup [result-sheet to-find]\n  (let [info (nba-helper result-sheet to-find)\n        error? (error-finder info)]\n    (reset! wins 0)\n    (reset! draws 0)\n    (reset! loses 0)\n    (reset! scores 0)\n    (reset! conceded 0)\n    (reset! points 0)\n    (cond \n      (empty? info) info\n      (not (empty? error?)) error?\n      :else (last info)))\n  )\n\n\n    ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18476,"user_id":null,"body":"(ns nba.core\n  (:require [clojure.string :as str]))\n\n(defn update-team [m team-score opponent-score]\n  (cond-> m\n    (= team-score opponent-score) (update :draws (fnil inc 0))\n    (< team-score opponent-score) (update :losses (fnil inc 0))\n    (> team-score opponent-score) (update :wins (fnil inc 0))\n    true (update :scored (fnil + 0) team-score)\n    true (update :conceded (fnil + 0) opponent-score)))\n\n(defn calculate-points [team-stats]\n  (+ ;; 3 points for a win\n     (* 3 (:wins team-stats 0))\n     ;; 1 point for a draw\n     (* 1 (:draws team-stats 0))))\n\n(defn nba-cup [result-sheet to-find]\n  (if (empty? to-find)\n    ;; explicit handling for emptry string\n    \"\"\n    (let [team->stats (reduce (fn [acc [_ team-1-name team-1-score-str team-2-name team-2-score-str]]\n                                (try\n                                  (let [team-1-score (Integer\/parseInt team-1-score-str)\n                                        team-2-score (Integer\/parseInt team-2-score-str)]\n                                    (-> acc\n                                      (update team-1-name update-team team-1-score team-2-score)\n                                      (update team-2-name update-team team-2-score team-1-score)))\n                                  ;; catch exceptions in Integer\/parseInt\n                                  (catch NumberFormatException e\n                                    (reduced (format \"Error(float number):%s %s %s %s\"\n                                                     team-1-name\n                                                     team-1-score-str\n                                                     team-2-name\n                                                     team-2-score-str)))))\n                              {}\n                              (re-seq #\"([^,]+)\\s([\\.\\d]+)\\s([^,]+)\\s([\\.\\d]+)\" result-sheet))]\n      (if (string? team->stats)\n        ;; return the error message\n        team->stats\n        ;; team-stats is a map\n        (if-some [team-stats (team->stats to-find)]\n          (format \"%s:W=%d;D=%d;L=%d;Scored=%d;Conceded=%d;Points=%d\"\n                  to-find\n                  (:wins team-stats 0)\n                  (:draws team-stats 0)\n                  (:losses team-stats 0)\n                  (:scored team-stats 0)\n                  (:conceded team-stats 0)\n                  (calculate-points team-stats))\n          (str to-find \":This team didn't play!\"))))))\n    ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18477,"user_id":null,"body":"(ns nba.core\n  (:require [clojure.string :as s]))\n\n(def game-regex #\"(.+) (\\d+\\.?\\d+) (.+) (\\d+\\.?\\d+)\")\n(def default-record (zipmap\n                     [:wins :draws :losses :scored :conceded :points]\n                     (repeat 0)))\n\n(defn parse-game [game-string]\n  (let [[[_ team-one score-one team-two score-two]] (re-seq game-regex game-string)\n        [actual-one actual-two] (map read-string [score-one score-two])\n        draw?    (= actual-one actual-two)\n        one-won? (> actual-one actual-two)\n        error?   (some float? [actual-one actual-two])]\n    (if error?\n      {:error (str \"Error(float number):\" game-string)}\n      {team-one {:wins   (if one-won? 1 0)\n                 :losses (if (not (or one-won? draw?)) 1 0)\n                 :draws  (if draw? 1 0)\n                 :scored actual-one\n                 :conceded actual-two\n                 :points (cond draw? 1 one-won? 3 :else 0)}\n       team-two {:wins (if one-won? 0 1)\n                 :losses (if (not (or one-won? draw?)) 0 1)\n                 :draws (if draw? 1 0)\n                 :scored actual-two\n                 :conceded actual-one\n                 :points (cond draw? 1 one-won? 0 :else 3)}})))\n\n(defn update-standings [acc game]\n  (if (nil? (game :error))\n    (let [[team-one team-two] (keys game)\n          prior-one (acc team-one default-record)\n          prior-two (acc team-two default-record)\n          new-one   (merge-with + prior-one (game team-one))\n          new-two   (merge-with + prior-two (game team-two))]\n      (assoc acc team-one new-one team-two new-two))\n    (assoc acc :error (game :error))))\n\n(defn format-results [team-name record]\n  (let [error (record :error)\n        team-record (record team-name)\n        {wins :wins losses :losses draws :draws scored :scored conceded :conceded points :points} team-record]\n    (cond\n      (not (nil? error)) error\n      (nil? team-name) \"\"\n      (nil? team-record) (str team-name \":This team didn't play!\")\n      :else  (str team-name \":\" \"W=\" wins \";D=\" draws\n                 \";L=\" losses \";Scored=\" scored\n                 \";Conceded=\" conceded \";Points=\" points))))\n\n(defn nba-cup [result-sheet team-name]\n  (if (empty? team-name)\n    \"\"\n    (->> (s\/split result-sheet #\",\")\n         (map parse-game)\n         (reduce update-standings {})\n         (format-results team-name))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18478,"user_id":null,"body":"(ns nba.core\n  (:require [clojure.string :refer [split join]]))\n\n(defn parse-teams [s]\n  (let [s (split s #\" \")\n        not-a-num? (complement (partial re-find #\"\\d+|\\d+\\.\\d+\"))\n        team-a (join \" \" (take-while not-a-num? s))\n        score-a (Double\/parseDouble (first (drop-while not-a-num? s)))\n        score-a (if (== score-a (int score-a)) (int score-a) score-a)\n        team-b (join \" \" (butlast (drop 1 (drop-while not-a-num? s))))\n        score-b (Double\/parseDouble (last s))\n        score-b (if (== score-b (int score-b)) (int score-b) score-b)]\n    [[team-a score-a] [team-b score-b]]))\n\n(defn process-teams [to-find [[team-a score-a] [team-b score-b]]]\n  (let [points (if (= team-a to-find)\n                 (cond\n                   (> score-a score-b) 3\n                   (< score-a score-b) 0\n                   :else 1)\n                 (cond\n                   (> score-a score-b) 0\n                   (< score-a score-b) 3\n                   :else 1))]\n        (concat\n          [to-find]\n          (case points\n            3 [1 0 0]\n            1 [0 1 0]\n            0 [0 0 1])\n          (if (= team-a to-find) [score-a score-b] [score-b score-a])\n          [points])))\n\n(defn nba-cup [result-sheet to-find]\n  (let [games (->> (split result-sheet #\",\")\n                   (map parse-teams)\n                   (filter (fn [[[team-a _] [team-b _]]]\n                             (or (= team-a to-find) (= team-b to-find)))))\n        float-number-game (first (filter (fn [[[_ score-a] [_ score-b]]]\n                                           (or (float? score-a) (float? score-b)))\n                                   games))]\n    (cond\n      (empty? to-find)\n        to-find\n      (empty? games)\n        (str to-find \":This team didn't play!\")\n      (some? float-number-game)\n        (->> (map (partial join \" \") float-number-game)\n             (join \" \")\n             (str \"Error(float number):\"))\n      :else\n        (->> (map (partial process-teams to-find) games)\n             (reduce (fn [[nm & total] [_ & game]]\n                       (cons nm (map + total game))))\n             (apply format \"%s:W=%d;D=%d;L=%d;Scored=%d;Conceded=%d;Points=%d\")))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18479,"user_id":null,"body":"(ns nba.core)\n\n(require '[clojure.string :as s])\n\n(defn my-key [name]\n  \"Create clojure keyword from team's name\"\n  (-> name (s\/lower-case) (s\/replace #\" \" \"-\") keyword))\n\n(defn result [game]\n  \"Create game result from text information\"\n  (letfn [(num? [text] (if (re-matches (re-pattern \"\\\\d+\") text) true false))\n          (f [home guest] (cond (= home guest) :draw (< home guest) :lose (> home guest) :win))]\n    (let [res   {:name \"\" :win 0 :lose 0 :draw 0 :scored 0 :conceded 0 :points 0}\n          result\n          (reduce (fn [result token]\n                    (let [index (if (zero? (:scored (first result))) 0 1)]\n                      (if-not (num? token)\n                        (update-in result [index :name] str (str \" \" token))\n                        (update-in result [index :scored] + (read-string token)))))\n                  [res res] (mapv s\/trim (->> game (re-seq #\"\\w+\"))))\n          home  (first result)\n          guest (last result)]\n      ;; post process\n      (let [result-1 (-> result\n                         (update-in [0 :name] s\/trim)\n                         (update-in [0 :conceded] + (:scored guest))\n                         (update-in [0 (f (:scored home) (:scored guest))] inc)\n                         (update-in [1 :name] s\/trim)\n                         (update-in [1 :conceded] + (:scored home))\n                         (update-in [1 (f (:scored guest) (:scored home))] inc))\n            result-2 (-> result-1\n                         (update-in [0 :points] + (+ (* 3 (:win (first result-1))) (:draw (first result-1))))\n                         (update-in [1 :points] + (+ (* 3 (:win (last result-1))) (:draw (last result-1)))))\n            home-2   (first result-2)\n            guest-2  (last result-2)]\n        {(my-key (:name home-2)) home-2 (my-key (:name guest-2)) guest-2}\n  ))))\n\n(defn games [listing]\n  \"Create table for all results\"\n  (reduce (fn [table game]\n            (let [res  (result game)\n                  home (first res) guest (last res)]\n              (letfn [(update-table [table team]\n                        (if-not (contains? table (key team))\n                          (conj table team)\n                          (reduce (fn [tab f]\n                                    (update-in tab [(key team) f] + (f (val team)))\n                                    ) table [:win :lose :draw :scored :conceded :points])\n                          ))]\n                (-> table (update-table home) (update-table guest)))))\n          {} listing))\n\n(defn fmt [table name]\n  \"Print table's record in given format\"\n  (let [team ((my-key name) table)]\n    (if-not (nil? team)\n      (format \"%s:W=%d;D=%d;L=%d;Scored=%d;Conceded=%d;Points=%d\"\n             (:name team) (:win team) (:draw team) (:lose team) (:scored team) (:conceded team) (:points team))\n      )\n   ))\n\n(defn nba-cup [r name]\n  \"Let's play cup for given text line results\"\n  (let [listing (-> r (s\/split #\",\"))\n        table (games listing)\n        bad-records (reduce (fn [res g]\n                              (if-not (nil? (->> g (re-matcher #\"\\d?[.]\\d+\") (re-find)))\n                                (conj res g)\n                                res))\n                              [] listing)]\n  (cond\n    (empty? name) \"\"\n    (nil? ((my-key name) table)) (str name \":This team didn't play!\")\n    (not (empty? bad-records)) (str \"Error(float number):\" (first bad-records))\n    :else (fmt table name)\n    )))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18480,"user_id":null,"body":"    (ns nba.core)\n    (require '[clojure.string :as str])\n    (defn nba-cup [result-sheet to-find]\n      (if (= to-find \"\") \"\"\n        (let [rs (str\/split result-sheet #\",\")\n              ds \"( \\\\d+[.]?\\\\d+( |$))\"\n              sel (filter #(re-find (re-pattern (str \"(^|\" ds \")\" to-find ds)) %) rs)]\n        (if (= sel []) (str to-find \":This team didn't play!\")\n          (let [fl (some #(first (re-matches #\"^.+ \\d+\\.\\d+(( |.+$)|$)\" %)) sel)]\n          (if fl (str \"Error(float number):\" fl)\n            (let [s (map #(re-seq #\"(?<!\\w+)\\d+(?!\\w+)\" %) sel)\n                  n1 (map #(read-string (re-find (re-pattern (str \"(?<=\" to-find \" )\\\\d+\")) %)) sel)\n                  nl (map #(read-string (last %)) s)                    \n                  nf (map #(read-string (first %)) s) \n                  n2 (map #(if (not= %2 %1) %2 %3) n1 nf nl)\n                  w (apply + (map #(if (> %1 %2) 1 0) n1 n2)) \n                  l (apply + (map #(if (< %1 %2) 1 0) n1 n2)) \n                  d (- (count nl) w l) sc (apply + n1) cc (apply + n2) points (+ (* 3 w) d)]\n            (str to-find \":W=\" w \";D=\" d \";L=\" l \";Scored=\" sc \";Conceded=\" cc \";Points=\" points))))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18481,"user_id":null,"body":"    (ns nba.core)\n    (require '[clojure.string :as str])\n    (defn nba-cup [result-sheet to-find]\n      (if (= to-find \"\") \n        \"\"\n        (if (not (str\/includes? result-sheet (str to-find \" \"))) \n          (str to-find \":This team didn't play!\")\n          (let [sel (filter #(str\/includes? % to-find) (str\/split result-sheet #\",\"))\n                fl (some #(re-matches #\"^.+ \\d+\\.\\d+.*$\" %) sel)]\n            (if fl\n              (str \"Error(float number):\" fl)\n              (let [s (map #(re-seq #\"(?<!\\w+)\\d+(?!\\w+)\" %) sel)\n                    n1 (map #(read-string (re-find (re-pattern (str \"(?<=\" to-find \" )\\\\d+\")) %)) sel)\n                    nl (map #(read-string (last %)) s)                    \n                    nf (map #(read-string (first %)) s) \n                    n2 (map #(if (not= %2 %1) %2 %3) n1 nf nl)\n                    w (apply + (map #(if (> %1 %2) 1 0) n1 n2)) \n                    l (apply + (map #(if (< %1 %2) 1 0) n1 n2)) \n                    d (- (count nl) w l) sc (apply + n1) cc (apply + n2) points (+ (* 3 w) d)]\n                (str to-find \":W=\" w \";D=\" d \";L=\" l \";Scored=\" sc \";Conceded=\" cc \";Points=\" points)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18482,"user_id":null,"body":"    (ns nba.core)\n    (require '[clojure.string :as str])\n    (defn nba-cup [result-sheet to-find]\n      (if (= to-find \"\") \n        \"\"\n        (if (not (str\/includes? result-sheet (str to-find \" \"))) \n          (str to-find \":This team didn't play!\")\n          (let [sel (filter #(str\/includes? % to-find) (str\/split result-sheet #\",\"))\n                fl (some #(re-matches #\"^.+ \\d+\\.\\d+.*$\" %) sel)]\n            (if fl\n              (str \"Error(float number):\" fl)\n              (let [s (map #(re-seq #\"(?<!\\w+)\\d+(?!\\w+)\" %) sel)\n                    n1 (map #(read-string (re-find (re-pattern (str \"(?<=\" to-find \" )\\\\d+\")) %)) sel)\n                    n (map #(list (read-string (first %)) (read-string (last %))) s)\n                    s1 (map #(read-string (first %)) s) \n                    s2 (map #(read-string (last %)) s)                    \n                    n2 (map #(if (not= %2 %1) %2 %3) n1 s1 s2)\n                    w (apply + (map #(if (> %1 %2) 1 0) n1 n2)) \n                    l (apply + (map #(if (< %1 %2) 1 0) n1 n2)) \n                    d (- (count n) w l) sc (apply + n1) cc (apply + n2) points (+ (* 3 w) d)]\n                (str to-find \":W=\" w \";D=\" d \";L=\" l \";Scored=\" sc \";Conceded=\" cc \";Points=\" points)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a48948e145c46820b00002f":[{"id":18483,"user_id":492,"body":"(ns kprimessteps.core)\n\n(defn- count-factors\n  ([n k]\n    (count-factors n 2 k 0))\n  ([n i k cnt]\n    (if (= 1 n)      \n      (= k cnt)\n      (if (= 0 (rem n i))        \n        (recur (quot n i) i k (inc cnt))\n        (recur n (inc i) k cnt)))))\n(defn kprimes-step [k step start nd]\n  (let [r (for [ p (range start (+ 1 (- nd step))) :when (and (count-factors p k) (count-factors (+ p step) k)) ] [p, (+ p step)]) ]\n    (if (empty? r)\n      []\n      r)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18484,"user_id":492,"body":"(ns kprimessteps.core)\n\n(defn- count-factors\n  ([n k]\n    (count-factors n 2 k 0))\n  ([n i k cnt]\n    (if (= 1 n)      \n      (= k cnt)\n      (if (= 0 (rem n i))        \n        (recur (quot n i) i k (inc cnt))\n        (recur n (inc i) k cnt)))))\n(defn kprimes-step [k step start nd]\n  (let [r (for [ p (range start (+ 1 (- nd step))) :when (and (count-factors p k) (count-factors (+ p step) k)) ] [p, (+ p step)]) ]\n    (if (empty? r)\n      []\n      r)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18485,"user_id":53,"body":"(ns kprimessteps.core)\n\n(defn pfc [n]\n  (loop [n n i 2 acc 0 l 0]\n    (cond (and (= 0 l) (> i (quot n i))) (if (> n 1) (inc acc) acc)\n          (pos? (mod n i)) (recur n (inc i) acc 0)\n          (zero? (mod n i)) (recur (quot n i) i (inc acc) 1))))\n\n(defn kprimes-step [k step start nd]\n  (loop [i start acc []]\n    (if (> i (- nd step)) \n      acc\n      (if (and (= (pfc i) k) (= (pfc (+ i step)) k))\n        (recur (inc i) (conj acc (list i (+ i step))))\n        (recur (inc i) acc)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18486,"user_id":null,"body":"(ns kprimessteps.core)\n  \n  (defn find-k [n]\n  (let [i   (atom 2)\n        res (atom 0)\n        new-n (atom n)]\n    (while (<= (* @i @i) @new-n)\n      (while (= 0 (mod @new-n @i))\n          (reset! new-n (quot @new-n @i))\n          (swap! res inc))\n      (swap! i inc))\n    (when (> @new-n 1) (swap! res inc))\n    @res))\n\n(defn kprimes-step [k step start stop]\n  (let [all-dividers (filter some? \n                             (for [i (range start (+ 1 stop))]\n                               (when (= (find-k i) k) i)))]\n    (vec (sort-by first\n             (filter some? (for [i all-dividers\n                                 j all-dividers]\n                             (when (= (- 0 step) (- i j))\n                               [i j])))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18487,"user_id":null,"body":"(ns kprimessteps.core)\n\n(defn num-factors\n  ([n]\n   (num-factors 2 n 0))\n  ([f n acc]\n   (cond\n     (< (Math\/sqrt n) f) (if (= n 1) acc (inc acc))\n     (= 0 (mod n f)) (recur f (\/ n f) (inc acc))\n     :else (recur (inc f) n acc))))\n\n(defn kprime?\n  [k p]\n  (= k (num-factors p)))\n\n(defn kprimes-step\n  [k step start end]\n  (->> (range start (inc (- end step)))\n       (filter (partial kprime? k))\n       (keep (fn [p]\n               (when (kprime? k (+ p step))\n                  [p (+ p step)])))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18488,"user_id":null,"body":"(ns kprimessteps.core)\n\n(defn kprimes-step [k step start nd]\n  (loop [a start\n         b 1\n         c 2\n         d 0\n         e []\n         f 0\n         g []]\n    (if (> a nd)\n      (if (= f (count e))\n        g\n        (if (some #(= (+ (e f) step) %) e)\n          (recur a b c d e (inc f) (conj g [(e f) (+ (e f) step)]))\n          (recur a b c d e (inc f) g)))\n      (if (or (> d k) (> c a))\n        (recur (+ b start) (inc b) 2 0 e f g)\n        (if (= 0 (rem a c))\n          (if (= 1 (\/ a c))\n            (if (= (inc d) k)\n              (recur (+ b start) (inc b) 2 0 (conj e (+ start (dec b))) f g)\n              (recur (+ b start) (+ 1 b) 2 0 e f g))\n            (do (recur (\/ a c) b 2 (inc d) e f g)))\n          (recur a b (if (= c 2) (inc c) (+ 2 c)) d e f g)))))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18489,"user_id":2111,"body":"(ns kprimessteps.core)\n\n(defn npf [n]\n   (loop [i 2 r n ctr 0] (if (= r 1) ctr \n     (if (= 0 (mod r i)) (recur i (\/ r i) (inc ctr)) (recur (inc i) r ctr)))))\n\n(defn kprimes-step [k step start nd]\n  (let [l (filter #(= k (npf %)) (range start (inc nd)))]\n  (filter #(= step (- (second %) (first %))) (for [x l y l] [x,y]))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a4d303f880385399b000001":[{"id":18490,"user_id":null,"body":"(ns kata)\n\n(defn fact [n]\n  (apply * (range 1 (inc n))))\n\n(defn digits [n]\n  (->> (iterate #(quot % 10) n)\n       (take-while pos?)\n       (map #(rem % 10))))\n\n(defn digits-fact-sum [n]\n  (->> (digits n)\n       (map fact)\n       (apply +)))\n\n(defn strong [n]\n  (if (= n (digits-fact-sum n))\n    \"STRONG!!!!\"\n    \"Not Strong !!\"))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18491,"user_id":645,"body":"(ns kata)\n(defn strong [n]\n  (if (.contains [1 2 145 40585] n) \"STRONG!!!!\" \"Not Strong !!\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18492,"user_id":53,"body":"(ns kata)\n(defn digits [n] (map #(Character\/digit % 10) (str n)))\n(defn factorial [n] (reduce * (range 1 (inc n))))\n(defn strong [n]\n  (if (= n (reduce + (map #(factorial %) (digits n))))\n    \"STRONG!!!!\"\n    \"Not Strong !!\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18493,"user_id":null,"body":"(ns kata)\n\n(def base 48)\n\n(defn char->digit\n  [character]\n  (-> character int (- base)))\n\n(defn factorial [n]\n  (reduce * (range 1 (inc n))))\n\n(defn strong [n]\n  (let [n-characters (-> n str seq)\n        n-digits (map char->digit n-characters)\n        factorials (map factorial n-digits)\n        sums (reduce + factorials)]\n    (if (= sums n) \n      \"STRONG!!!!\"\n      \"Not Strong !!\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18494,"user_id":null,"body":"(ns kata)\n(require '[clojure.edn :as edn])\n\n(defn factorial [n]\n (apply * (range 1 (+ 1 (edn\/read-string (str n))))))\n  \n  \n(defn sumDigitsFactorial [n] \n  (let [digits (seq (str n))]\n  (apply + (map factorial digits))))\n\n(defn strong [n]\n  (if (= (sumDigitsFactorial n) n)\n  \"STRONG!!!!\"\n  \"Not Strong !!\"\n  ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18495,"user_id":null,"body":"(ns kata)\n\n(defn fact [n]\n  (if (pos? n)\n    (* n (fact (dec n)))\n    1))\n\n(defn strong [n]\n  (let [sum (->> (str n)\n                 (map #(Character\/digit % 10))\n                 (map fact)\n                 (reduce +))]\n    (if (= n sum)\n      \"STRONG!!!!\"\n      \"Not Strong !!\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18496,"user_id":null,"body":"(ns kata\n  (:require [clojure.test :refer :all]))\n\n(defn factorial [num]\n  (reduce * (range 1 (inc num)))\n  )\n\n(defn digits [n]\n  (->> n str (map (comp read-string str))))\n\n(defn factorial_sum [n]\n  (->> n digits (map factorial) (reduce +))\n  )\n\n(defn strong [n]\n  (if (= n (factorial_sum n))\n  \"STRONG!!!!\"\n  \"Not Strong !!\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18497,"user_id":null,"body":"(ns kata)\n(defn fact [x]\n  (loop [n x\n         mul 1]\n    (if (= n 0)\n      mul\n      (recur (dec n) (* mul n)))))\n  \n(defn strong [n]\n  (let [sum (apply + (map #(fact (- (int %) 48)) (str n)))]\n    (if (= n sum)\n      \"STRONG!!!!\"\n      \"Not Strong !!\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18498,"user_id":null,"body":"(ns kata)\n\n(def fatoriais\n  [1,\n   1,\n   2,\n   6,\n   24,\n   120,\n   720,\n   5040,\n   40320,\n   362880\n   ]\n)\n\n(defn strong [n]\n  (let [digitos (vec (str n))]\n    (if (= n (reduce + (mapv #(get fatoriais (Character\/digit % 10)) digitos)))\n      \"STRONG!!!!\"\n      \"Not Strong !!\"\n    )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18499,"user_id":null,"body":"(ns kata)\n(defn strong [n]\n  (if (= (reduce + (map #(reduce * (range 1 (inc %))) (map #(Integer\/parseInt %) (clojure.string\/split (str n) #\"\")))) n)\n    \"STRONG!!!!\"\n    \"Not Strong !!\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a4e3782880385ba68000018":[{"id":18500,"user_id":null,"body":"(ns balanced_number)\n\n(defn balanced_num\n  [num]\n  (let [size (count (str num))\n        left (take (- (\/ size 2) 1) (str num))\n        right (take-last (- (\/ size 2) 1) (str num))\n        sum-left (reduce + (map #(Integer\/parseInt (str %)) left))\n        sum-right (reduce + (map #(Integer\/parseInt (str %)) right))]\n    (if (= sum-left sum-right) \"Balanced\" \"Not Balanced\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18501,"user_id":null,"body":"(ns balanced_number)\n\n(defn balanced_num [nu]\n  (let [n (map int (seq (str nu)))\n        size (int (\/ (- (count n) 1) 2))\n        lsum (reduce + (take size n))\n        rsum (reduce + (take size (reverse n)))\n        ]\n    (if (= lsum rsum)\n      \"Balanced\"\n      \"Not Balanced\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18502,"user_id":168,"body":"(ns balanced_number)\n\n(defn balanced_num\n  [n]\n  (let [s (map #(Character\/digit % 10) (str n))\n        k (quot (dec (count s)) 2)]\n    (if (= (apply + (take k s)) (apply + (take-last k s)))\n        \"Balanced\" \"Not Balanced\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18503,"user_id":null,"body":"(ns balanced_number)\n\n(defn get-sum\n  [num]\n  (reduce + (map int (str num))))\n\n(defn balanced_num\n  [num]\n  (let [s (str num)\n        l (count s)\n        mid (\/ l 2)]\n    (if (= (get-sum (subs s 0 (- mid (if (even? l) 1 0)))) (get-sum (subs s (+ mid 1))))\n      \"Balanced\"\n      \"Not Balanced\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18504,"user_id":null,"body":"(ns balanced_number)\n\n(defn balanced_num [m]\n  (let [s (str m)\n        n (count s)]\n    (if (odd? n)\n      (let [l (split-at (int (\/ n 2)) (map int s))\n            a (apply + (first l))\n            b (apply + (rest (second l)))]\n        (if (= a b)\n          \"Balanced\"\n          \"Not Balanced\"))\n      (let [l (split-at (dec (\/ n 2)) (map int s))\n            a (apply + (first l))\n            b (apply + (rest (rest (second l))))]\n        (if (= a b)\n          \"Balanced\"\n          \"Not Balanced\")))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18505,"user_id":null,"body":"(ns balanced_number (:require [clojure.string :as str]))\n\n\n(defn get-halves \n  [n] \n  (let \n    [digits (vec (remove empty? (str\/split (str n) #\"\")))\n     n-digits (count digits)  \n     middle-index (Math\/ceil (dec (\/ n-digits 2))) \n     first-half (subvec digits 0 middle-index) \n     second-half (subvec digits (+ (if (odd? n-digits) 1 2) middle-index) n-digits)] \n    [(map #(Integer\/parseInt %) first-half) (map #(Integer\/parseInt %) second-half)]))\n\n(defn balanced_num \n  [num] \n  (let \n    [str-halves (get-halves num) \n     sum-first-half (reduce + (first str-halves)) \n     sum-second-half (reduce + (second str-halves))] \n    (if (= sum-first-half sum-second-half) \"Balanced\" \"Not Balanced\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18506,"user_id":null,"body":"(ns balanced_number)\n\n(defn balanced_num [num]\n  (let [ds        (map #(Character\/digit % 10) (str num))\n        size      (count ds)\n        part-size (if (odd? size) (\/ (dec size) 2) (dec (\/ size 2)))\n        left      (reduce + (take part-size ds))\n        right     (reduce + (take part-size (reverse ds)))]\n    (if (= left right) \"Balanced\" \"Not Balanced\")))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18507,"user_id":null,"body":"(ns balanced_number)\n\n(defn balanced_num\n  [num]\n  (let [n (str num)\n        c (count n)\n        odd (odd? c)\n        m (\/ c 2)\n        lm (if odd (int m) (- m 1))\n        rm (inc (if odd (int m) m))]\n    (if (<= c 2) \n      \"Balanced\" \n      (let [l (map #(- (int %) (int \\0)) (take lm n))\n            r (map #(- (int %) (int \\0)) (drop rm n))\n            l (reduce + l)\n            r (reduce + r)\n            result (if (= l r) \"Balanced\" \"Not Balanced\")]\n        result)))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18508,"user_id":null,"body":"(ns balanced_number)\n\n(defn floor [n]\n  (+ (int n)\n     (if (> (rem n 1) 0)\n       1 0)))\n\n(defn balanced_num [n]\n  (let [str-n (str n)\n        ary (mapv #(Integer\/parseInt %)\n                  (clojure.string\/split str-n #\"\"))\n        threshold (-> str-n\n                      count\n                      (\/ 2)\n                      floor\n                      (- 1))]\n    (if (= (apply + (subvec ary 0 threshold))\n           (apply + (subvec ary (- (count str-n) threshold))))\n      \"Balanced\"\n      \"Not Balanced\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18509,"user_id":null,"body":"(ns balanced_number)\n\n(defn into-col [num]\n\t\t(map #(Character\/digit % 10) (into [] (seq (str num)))))\n\n(defn s-in-half [col] (split-at (\/ (- (count col) 1) 2) col))\n\n(defn balanced_num [num]\n    (let [num-col (into-col num)\n          cnt (count num-col)\n\t\t\t    first-half (first (s-in-half num-col))\n\t\t      second-half (second (s-in-half num-col))]\n\t\t        (cond\n\t\t\t        (odd? cnt) (if (= (reduce + first-half) (reduce + (rest second-half))) \"Balanced\" \"Not Balanced\")\n\t\t\t        (even? cnt) (if (= (reduce + (butlast first-half)) (reduce + (rest second-half))) \"Balanced\" \"Not Balanced\"))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a4ea304b3bfa89a9900008e":[{"id":18510,"user_id":209,"body":"(ns kata)\n\n(defn max_number [n](Integer\/parseInt (apply str (reverse (sort (str n))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18511,"user_id":168,"body":"(ns kata)\n\n(defn max_number [n]\n  (->> (str n)\n       (sort)\n       (reverse)\n       (apply str)\n       (Integer\/parseInt)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18512,"user_id":null,"body":"(ns kata\n  (:require [clojure.string :as str]))\n\n(defn descending [a b]\n  (compare b a))\n\n(defn max_number [n]\n  (->> n\n       (str)\n       (re-seq #\"\\d\")\n       (sort descending)       \n       (str\/join)\n       (Integer\/parseInt)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18513,"user_id":null,"body":"(ns kata\n  (:require [clojure.string :as str]))\n\n(defn max_number [n]\n (Integer\/parseInt (str\/join (reverse (sort (map #(Integer\/parseInt %) (str\/split (str n) #\"\")))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18514,"user_id":null,"body":"(ns kata)\n(require '[clojure.string :as string])\n\n(defn max_number [n]\n  (Integer\/parseInt (string\/join (sort > (->> n str (map (comp read-string str))))))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18515,"user_id":null,"body":"(ns kata)\n\n(defn digits [n]\n  (->> n\n       (iterate #(quot % 10))\n       (take-while pos?)\n       (map #(rem % 10))))\n\n(defn reversed-digits->number [digs]\n  (apply + (map * digs (iterate #(* 10 %) 1))))\n\n(def max_number (comp reversed-digits->number sort digits))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18516,"user_id":null,"body":"(ns kata)\n\n (defn sep-digit [n]\n    (->> n\n         (str)\n         (seq)\n         (map str)\n         (map #(Integer\/parseInt %))))\n\n(defn max_number [n]\n  (let [digits (sort > (sep-digit n))]\n    (read-string (apply str digits))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18517,"user_id":null,"body":"(ns kata)\n\n(defn max_number [n]\n  (->> n\n    str\n    sort\n    reverse\n    (reduce str)\n    (Integer.))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18518,"user_id":null,"body":"(ns kata (:require [clojure.string :refer [join]]))\n\n(defn number->digits [n]\n  (->> n str (map (comp read-string str))))\n\n(defn max_number [n]\n  (->> n number->digits (sort >) join read-string))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18519,"user_id":null,"body":"(ns kata)\n\n(def max_number (comp read-string (partial apply str) reverse sort str))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a512f6a80eba857280000fc":[{"id":18520,"user_id":201,"body":"(ns kata)\n\n(defn nth_smallest [numbers pos]\n  (nth (sort numbers) (dec pos)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18521,"user_id":null,"body":"(ns kata)\n\n(defn nth_smallest\n  [numbers pos]\n  (as-> numbers n\n    (sort n)\n    (nth n (dec pos))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18522,"user_id":null,"body":"(ns kata)\n\n(defn nth_smallest [numbers pos]\n  (last (take pos (sort numbers))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18523,"user_id":null,"body":"(ns kata)\n\n(defn nth_smallest [numbers pos]\n  ((into [] (sort numbers)) (- pos 1))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18524,"user_id":null,"body":"(ns kata)\n\n(defn nth_smallest\n  [\u2665 \u263b]\n  ((into [] (sort \u2665)) (dec \u263b)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18525,"user_id":null,"body":"(ns kata)\n\n(defn nth_smallest [numbers pos]\n  (-> numbers\n    sort\n    (nth (dec pos))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18526,"user_id":1400,"body":"(ns kata)\n\n(defn nth_smallest [numbers pos]\n  (nth (sort numbers) (- pos 1))\n)\n\n(println (nth_smallest [1 2 3] 1))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18527,"user_id":null,"body":"(ns kata)\n\n(defn nth_smallest [numbers pos]\n  (->\n    (sort numbers)\n    (nth (dec pos))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18528,"user_id":null,"body":"(ns kata)\n\n(defn nth_smallest [numbers pos]\n  (nth (sort numbers) (- pos 1)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a523566b3bfa84c2e00010b":[{"id":18529,"user_id":null,"body":"(ns kata)\n\n(defn min_sum [xs]\n  (->> (interleave (sort < xs) (sort > xs)) \n       (partition 2)\n       (map (fn [[x y]] (* x y)))\n       (reduce +) \n       (#(\/ % 2))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18530,"user_id":null,"body":"(ns kata)\n\n(defn min_sum [xs]\n  (let [s (sort xs)]\n    (reduce + (take (\/ (count xs) 2) (map * s (reverse s))))\n  ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18531,"user_id":null,"body":"(ns kata)\n\n(defn min_sum-of-products [xs]\n  (if (empty? xs)\n    0\n    (let [first-elem (first xs)\n          last-elem (last xs)\n          xs-size (count xs)\n          remaining (rest (take (- xs-size 1) xs))]\n      (+ (* first-elem last-elem) (min_sum-of-products remaining)))))\n\n(defn min_sum [xs]\n  (let [sorted-xs (sort xs)\n        xs-size (count sorted-xs)]\n    (if (odd? xs-size)\n      (min_sum-of-products (take (- xs-size 1) sorted-xs))\n      (min_sum-of-products sorted-xs))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18532,"user_id":168,"body":"(ns kata)\n\n(defn min_sum [xs]\n  (let [ys (sort xs)\n        n (quot (count xs) 2)]\n    (apply + (map #(* %1 %2) (take n ys) (take n (reverse ys))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18533,"user_id":null,"body":"(ns kata)\n\n(defn min_sum [xs]\n  (loop [s (sort xs)\n         sum 0]\n    (if (empty? s)\n      sum\n      (recur (drop-last (rest s)) (+ sum (* (first s) (last s)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18534,"user_id":null,"body":"(ns kata)\n\n(defn min_sum\n  [numbers]\n  (as-> numbers arr\n    (sort > arr)\n    (let [left (take-nth 2 arr) right (sort (take-nth 2 (rest arr)))]\n      (apply + (mapv #(* %1 %2) left right)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18535,"user_id":null,"body":"(ns kata)\n\n(defn min_sum [xs]\n  (loop [list (sort xs)\n         sum 0]\n\n    (if (empty? list)\n      sum\n      (recur (rest (reverse (rest list))) (+ sum (* (apply max list) (apply min list))))\n    )\n  )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18536,"user_id":null,"body":"(ns kata)\n\n(defn min_sum [xs]\n  (letfn [(min_sum-recur [sum left]\n            (cond (empty? left) sum\n                  :else (recur (+ (* (first left) (last left))\n                                  sum)\n                               (rest (reverse (rest left))))))]\n    (min_sum-recur 0 (sort xs))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18537,"user_id":null,"body":"(ns kata)\n\n(defn min_sum [xs]\n  (let [ys (sort xs)\n        i (\/ (count ys) 2)\n        [as bs] (split-at i ys)\n        cs (reverse bs)]\n    (reduce + (map * as cs))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18538,"user_id":null,"body":"(ns kata)\n\n(defn min_sum [xs]\n  (let [sortedList (sort xs)\n        splitList (partition (\/ (count sortedList) 2) sortedList)\n        firstList (first splitList)\n        lastList (reverse (last splitList))]\n    (reduce + (map * firstList lastList)))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a53a17bfd56cb9c14000003":[{"id":18539,"user_id":168,"body":"(ns kata)\n\n(defn disarium_number [number]\n  (->> number\n       str\n       (map #(Character\/digit % 10))\n       (map-indexed #(Math\/pow %2 (inc %1)))\n       (apply +)\n       (#(if (== % number) \"Disarium !!\" \"Not !!\"))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18540,"user_id":null,"body":"(ns kata)\n\n(defn disarium_number [number]\n  (if (= number (reduce + (map #(reduce * (repeat %2 (Integer. (str %1)))) (str number) (range 1 (inc (count (str number)))))))\n    (str \"Disarium !!\")\n    (str \"Not !!\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18541,"user_id":null,"body":"(ns kata)\n\n(use '[clojure.string :only (split)])\n\n(def sum (comp (partial apply +)))\n(defn to-int [a] (Integer\/parseInt (str a)))\n(defn pow [b e] (int (Math\/pow b e)))\n(defn index-pow [index item] (pow (to-int item) (inc index)))\n\n(defn disarium_number [number]\n  (let [numbers (str number)]\n    (if (= number (-> (map-indexed index-pow numbers) sum))\n      \"Disarium !!\"\n      \"Not !!\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18542,"user_id":null,"body":"(ns kata)\n\n(defn digits [n]\n  (->> (str n)\n       (map #(- (int %) 48))))\n\n(defn disarium_number? [number]\n  (->> (map #(int (Math\/pow %1 %2)) (digits number) (iterate inc 1))\n       (reduce +)\n       (= number)))\n\n(defn disarium_number [number]\n  (if (disarium_number? number) \"Disarium !!\" \"Not !!\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18543,"user_id":null,"body":"(ns kata\n  (:require [clojure.string :as str]))\n\n(defn number->array \n  [num] \n  (map #(Integer\/parseInt %) (vec (remove empty? (str\/split (str num) #\"\")))))\n\n(defn disarium \n  [n-seq] \n  (loop \n    [result 0 exp 1 numbers n-seq] \n    (if (empty? numbers) \n      (int result)\n      (recur (+ result (Math\/pow (first numbers) exp)) (inc exp) (rest numbers)))))\n\n\n(defn disarium_number [number]\n  (let \n    [n-seq (number->array number)\n     disarium-result (disarium n-seq)]\n    (if (= disarium-result number) \"Disarium !!\" \"Not !!\")\n    )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18544,"user_id":null,"body":"(ns kata)\n\n(defn disarium_number [number]\n  (->> (str number)\n       (map #(- (int %) 48))\n       (map-indexed (fn [i d] (reduce * (repeat (inc i) d))))\n       (reduce +)\n       (#(if (= number %) \"Disarium !!\" \"Not !!\"))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18545,"user_id":53,"body":"(ns kata)\n\n(defn exp [x n] (reduce * (repeat n x)))\n\n(defn disarium-walker [n c s m]\n    (cond\n      (zero? c) (if (= n s) \"Disarium !!\" \"Not !!\")\n      :else (disarium-walker n (dec c) (+ s (exp (mod m 10) c)) (quot m 10)))\n  )\n\n(defn disarium_number [n]\n    (if (zero? n)\n      \"Disarium !!\"\n      (disarium-walker n (inc (int (\/ (Math\/log n) (Math\/log 10)))) 0 n))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18546,"user_id":null,"body":"(ns kata)\n\n(defn pow [x n] (reduce * 1 (repeat n x)))\n\n(defn disarium_number [number]\n  (let [n (map #(- (int %) (int \\0)) (str number))\n        n (map-indexed #(pow %2 (inc %1)) n)\n        s (reduce + n)]\n    (if (= number s) \"Disarium !!\" \"Not !!\"))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18547,"user_id":null,"body":"(ns kata)\n\n(defn exp [x n]\n  (reduce * (repeat n x))\n)\n\n(defn calc [idx digit]\n  (println digit)\n  (exp (read-string (str digit)) (+ 1 idx))\n)\n\n(defn disarium_number [number]\n  (condp = number\n    (reduce + (map-indexed calc (str number))) \"Disarium !!\"\n    \"Not !!\"\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18548,"user_id":null,"body":"(ns kata)\n\n(defn disarium_number [n]\n    (let [sep-digit (->> n\n                         (str)\n                         (seq)\n                         (map str)\n                         (map #(Integer\/parseInt %)))\n          disarium-num (map #(Math\/pow %1 %2) sep-digit (iterate inc 1))]\n      (if (= n (int (reduce + disarium-num)))\n        \"Disarium !!\"\n        \"Not !!\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a54e796b3bfa8932c0000ed":[{"id":18549,"user_id":null,"body":"(ns kata\n  (:require [clojure.string :as str]))\n\n(defn number->array \n  [num] \n  (map #(Integer\/parseInt %) (vec (remove empty? (str\/split (str num) #\"\")))))\n\n(defn jumping_number [number]\n   (let \n     [n-seq (number->array number)\n      jumping? (every? #{1} (map #(Math\/abs (- %1 %2)) n-seq (rest n-seq)))]\n     (if jumping? \"Jumping!!\" \"Not!!\"))\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18550,"user_id":null,"body":"(ns kata)\n\n(defn jumping_number [number]\n  (loop [[prev next & rest] (str number)]\n  (cond (nil? next) \"Jumping!!\" \n        (let [div ( Math\/abs (- (Character\/getNumericValue next) (Character\/getNumericValue prev)))]\n          (println prev next div)\n          (or (= div 0) (and (> div 1) (< div 9)))) \"Not!!\"\n        :else (recur (conj rest next )))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18551,"user_id":53,"body":"(ns kata)\n(defn abs [n] (max n (- n)))\n\n(defn jumping_number [m]\n  (loop [p (mod m 10) n m i 0]\n    (cond\n      (zero? n) \"Jumping!!\"\n      (and (> i 0) (zero? (abs (- p (mod n 10))))) \"Not!!\"\n      (> (abs (- p (mod n 10))) 1) \"Not!!\"\n      :else (recur (mod n 10) (quot n 10) (inc i)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18552,"user_id":null,"body":"(ns kata)\n\n(defn jumping_number [number]\n  (let [digits (map #(Character\/digit % 10) (str number))\n        jumping? #(= (-(max %1 %2) (min %1 %2)) 1)\n        is_jumping (reduce #(if (jumping? %1 %2) %2 -2) (first digits) (rest digits))]\n    (if (= is_jumping -2) \"Not!!\" \"Jumping!!\")))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18553,"user_id":168,"body":"(ns kata)\n\n(defn jumping_number [number]\n  (cond\n    (< number 10) \"Jumping!!\"\n    (= (Math\/abs (- (rem number 10) (rem (quot number 10) 10))) 1) (jumping_number (quot number 10))\n    :else \"Not!!\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18554,"user_id":null,"body":"(ns kata)\n(defn digits [n]\n  (->> (iterate #(quot % 10) n)\n       (take-while pos?)\n       (map #(rem % 10))))\n\n(defn jumping_number [number]\n  (let [ds (digits number)\n        difs (map - ds (next ds))]\n    (if (every? #{-1 1} difs) \"Jumping!!\" \"Not!!\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18555,"user_id":null,"body":"(ns kata)\n\n(defn div [x y] (int (\/ x y)))\n\n(defn digits\n  [n]\n  (loop\n    [x n, xs (list)]\n    (if\n      (= x 0)\n      xs\n      (recur (div x 10) (conj xs (mod x 10))))))\n\n(defn jumping_number?\n  [n]\n  (->>\n    (digits n)\n    (partition 2 1)\n    (every? (fn \n      [[x y]]\n      (= 1 (Math\/abs (- x y)))))\n    ))\n\n(defn jumping_number\n  [n]\n  (if\n    (jumping_number? n)\n    \"Jumping!!\"\n    \"Not!!\"))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18556,"user_id":null,"body":"(ns kata)\n\n(defn jumping_number [number]\n  (if (->> number\n           (str)\n           (map int)\n           (reduce (fn [{:keys [jumping prev] :as m} ch]\n                     (cond\n                       (not jumping) m\n                       (nil? prev) (assoc m :prev ch)\n                       (or (= -1 (- ch prev))\n                           (= 1 (- ch prev))) (assoc m :prev ch)\n                       :else (assoc m :jumping false)))\n                   {:jumping true, :prev nil})\n           (:jumping))\n    \"Jumping!!\"\n    \"Not!!\")\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18557,"user_id":null,"body":"(ns kata)\n\n(defn number->digits [n]\n  (->> n str (map (comp read-string str))))\n\n(defn answer [bool]\n  (if bool \"Jumping!!\" \"Not!!\"))\n\n(defn jumping_number [n]\n  (->> (number->digits n)\n       (partition 2 1)\n       (map #(Math\/abs (apply - %)))\n       (every? #(= 1 %))\n       answer))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18558,"user_id":null,"body":"(ns kata)\n\n(defn num-to-digits-arr [num]\n  (map #(Integer\/parseInt (str %)) (str num)))\n\n(defn jumping_number [number]\n  (let [num-arr (num-to-digits-arr number)]\n    (if (empty? (->> (take (dec (count num-arr)) (partition 2 1 num-arr num-arr))\n                     (filter #(not= 1 (Math\/abs (- (first %) (second %)))))))\n      \"Jumping!!\"\n      \"Not!!\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a55f04be6be383a50000187":[{"id":18559,"user_id":null,"body":"(ns kata)\n\n(defn special_number? [number]\n  (->> number\n     str\n     frequencies\n     keys\n     (every? #{\\0 \\1 \\2 \\3 \\4 \\5})))\n\n(defn special_number [number]\n  (if (special_number? number)\n    \"Special!!\"\n    \"NOT!!\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18560,"user_id":null,"body":"(ns kata\n  (:require [clojure.string :as str]\n            [clojure.edn :as edn]))\n\n(defn special_number? [n] \n  (if (and (<= 0 n) (>= 5 n))\n    \"Special!!\"\n    \"NOT!!\"))\n\n(defn special_number [number]\n  (if (< 9 number) \n    (if (some #(= false %) (map #(and (<= 0 (edn\/read-string %)) (>= 5 (edn\/read-string %))) (str\/split (str number) #\"\")))\n      \"NOT!!\"\n      \"Special!!\")\n    (special_number? number)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18561,"user_id":null,"body":"(ns kata)\n\n(defn special_number [number]\n (->> number\n       str\n       (map #(Character\/digit % 10))\n       (#(every? #{0 1 2 3 4 5} %))\n       (#(if % \"Special!!\" \"NOT!!\"))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18562,"user_id":53,"body":"(ns kata)\n\n(defn special_number [m]\n  (loop [n m]\n    (cond\n      (zero? n) \"Special!!\"\n      (> (mod n 10) 5) \"NOT!!\"\n      :else (recur (quot n 10)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18563,"user_id":1400,"body":"(ns kata)\n\n(defn special_number [number]\n  (if (every? #(.contains [\"0\",\"1\",\"2\",\"3\",\"4\",\"5\"] (str %)) (str number))\n    \"Special!!\"\n    \"NOT!!\")\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18564,"user_id":1400,"body":"(ns kata)\n\n(defn special-digit [digit]\n  (<= digit 5)\n)\n\n(defn special_number-2 [number]\n  (println number)\n  (if (<= number 9) \n    (special-digit number)\n    (and \n     (special-digit (mod number 10)) \n     (special_number-2 (int (\/ number 10)))))\n)\n\n(defn special_number [number]\n  (if (special_number-2 number)\n    \"Special!!\"\n    \"NOT!!\"\n  )\n)\n\n(println (special_number 5))\n(println (special_number 15))\n(println (special_number 57))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18565,"user_id":null,"body":"(ns kata)\n\n(defn special_number [n]\n    (let [sep-digits (->> n\n                          (str)\n                          (seq)\n                          (map str)\n                          (map #(Integer\/parseInt %)))\n          testing (map #(or (= 0 %)(= 1 %)(= 2 %)(= 3 %)(= 4 %)(= 5 %)) sep-digits)]\n      (if (every? true? testing)\n        \"Special!!\"\n        \"NOT!!\")))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18566,"user_id":null,"body":"(ns kata)\n\n(defn div [x y] (int (\/ x y)))\n\n(defn digits\n  [n]\n  (loop\n    [x n, xs (list)]\n    (if\n      (= x 0)\n      xs\n      (recur (div x 10) (conj xs (mod x 10))))))\n\n(defn special_number?\n  [n]\n  (every? #(< % 6) (digits n)))\n\n(defn special_number\n  [n]\n  (if\n    (special_number? n)\n    \"Special!!\"\n    \"NOT!!\"\n    ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18567,"user_id":null,"body":"(ns kata)\n\n(defn special_number [number]\n  (let [out-of-range-count (->> (str number)\n             (filter #(not (#{\\0 \\1 \\2 \\3 \\4 \\5} %)))\n             count)]\n    (if (zero? out-of-range-count)\n      \"Special!!\"\n      \"NOT!!\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18568,"user_id":null,"body":"(ns kata)\n\n(defn digits [n]                                                                                                    \n    (mapv #(Character\/digit % 10) (str n)))\n\n(defn special_number [number]\n  (let [special #{0 1 2 3 4 5}]\n    (if (every? special (digits number))\n      \"Special!!\"\n      \"NOT!!\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a58ca28e626c55ae000018a":[{"id":18569,"user_id":53,"body":"(ns kata)\n(defn area_of_polygon_inside_circle [r n]\n  (\/ (Math\/round (* 1000.0 0.5 n r r (Math\/sin (\/ (* 2 Math\/PI) n)))) 1000.0))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18570,"user_id":null,"body":"(ns kata)\n\n(defn get-angle\n  [size]\n  (\/ (* 180 (- size 2)) size 2)\n)\n\n(defn get-base\n  [radius angle]\n  (* (Math\/sin(\/ (* Math\/PI angle) 180)) radius 2)\n)\n\n(defn get-height\n  [radius angle]\n  (* (Math\/cos (\/ (* Math\/PI angle) 180)) radius)\n)\n\n(defn area_of_polygon_inside_circle\n  [radius size]\n  (let [t-angle (- 90 (get-angle size))]\n    (read-string (format \"%.3f\" (* size (\/ (* (get-base radius t-angle) (get-height radius t-angle)) 2)))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18571,"user_id":1400,"body":"(ns kata)\n(defn solve [r n]\n  ;circle radius r\n  ;number of sides n\n  (* (\/ 1 2) n (* r r) (Math\/sin (\/ (* 2 Math\/PI) n)))\n)\n\n\n(defn area_of_polygon_inside_circle [r n]\n  (double (\/ (Math\/round (* 1000 (solve r n))) 1000))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18572,"user_id":168,"body":"(ns kata)\n(defn area_of_polygon_inside_circle [r n]\n  (Double\/parseDouble (format \"%.3f \"(* 0.5 n r r (Math\/sin (\/ (* 2 Math\/PI) n))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18573,"user_id":null,"body":"(ns kata)\n(defn area_of_polygon_inside_circle [circle-radius number-of-sides]\n  (let [angle (\/ Math\/PI number-of-sides)\n        area (* circle-radius circle-radius\n                number-of-sides\n                (Math\/sin angle) (Math\/cos angle))]\n    (-> (* 1000 area)\n      (Math\/round) (\/ 1000) (double))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18574,"user_id":501,"body":"(ns kata)\n(defn three-dp\n    [precision d]\n    (let [factor (Math\/pow 10 precision)]\n      (\/ (Math\/round (* d factor)) factor)))\n\n(defn area_of_polygon_inside_circle [r n]\n    (three-dp 3 (\/ (* (Math\/pow r 2) n (Math\/sin(\/ (* 2 Math\/PI) n))) 2)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18575,"user_id":null,"body":"(ns kata)\n(defn area_of_polygon_inside_circle [circle-radius number-of-sides]\n  (Double\/parseDouble\n    (format \"%.3f\"\n      (* (Math\/sin (\/ (* Math\/PI 2) number-of-sides))\n         (Math\/pow circle-radius 2)\n         (\/ 1 2)\n         number-of-sides))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18576,"user_id":null,"body":"(ns kata)\n(defn area_of_polygon_inside_circle [circle-radius number-of-sides]\n (Double\/parseDouble (format \"%.3f\" (with-precision 1 (* 0.5 number-of-sides (* circle-radius circle-radius (Math\/sin (\/ (* 2 Math\/PI) number-of-sides)))))\n)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18577,"user_id":null,"body":"(ns kata)\n(defn area_of_polygon_inside_circle [radius n-sides]\n(read-string (format \"%.3f\" (* 0.5 n-sides radius radius (Math\/sin (\/ Math\/PI 0.5 n-sides)))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18578,"user_id":492,"body":"(ns kata)\n(defn area_of_polygon_inside_circle [r n]\n  (let [s (* 0.5e3 r r n) t (\/ (* 2 Math\/PI) n)]\n  (\/ (Math\/round (* s (Math\/sin t))) 1.0e3)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a58d889880385c2f40000aa":[{"id":18579,"user_id":null,"body":"(ns kata (:require [clojure.string :refer [ends-with?]]))\n\n(defn automorphic [n]\n  (if (ends-with? (str (* n n)) (str n))\n    \"Automorphic\"\n    \"Not!!\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18580,"user_id":53,"body":"(ns kata)\n(defn exp [x n]\n  (reduce * (repeat n x)))\n(defn automorphic [n]\n  (if (= n (mod (* n n) (exp 10 (inc (int (\/ (Math\/log n) (Math\/log 10)))))))\n    \"Automorphic\"\n    \"Not!!\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18581,"user_id":null,"body":"(ns kata)\n\n(defn automorphic [n]\n (let [x (map #(Character\/digit % 10) (reverse (into-array (str n))))\n       y (map #(Character\/digit % 10) (reverse (into-array (str (* n n)))))]\n   (if (= x (take (count x) y))\n   \"Automorphic\"\n   \"Not!!\"\n   )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18582,"user_id":null,"body":"(ns kata\n  (:require [clojure.string :as str]))\n\n(defn automorphic [n]\n  (let [N (str (* n n))]\n    (if (str\/ends-with? N (str n))\n      \"Automorphic\"\n      \"Not!!\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18583,"user_id":231,"body":"(ns kata\n  (:require [clojure.string :as str]))\n\n(defn automorphic [n]\n  (if (str\/ends-with? (str (* n n)) (str n))\n    \"Automorphic\"\n    \"Not!!\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18584,"user_id":null,"body":"(ns kata)\n\n(defn num-to-dig [num]\n  (loop [n num\n         res []]\n    (let [rd (int (\/ n 10))]\n      (if (= rd 0)\n        (reverse (conj res n))\n        (recur rd (conj res (mod n 10)))))))\n\n(defn automorphic [n]\n  (let [init-digs (num-to-dig n)\n        sq-digs (num-to-dig (* n n))]\n    (if (= init-digs (drop (- (count sq-digs) (count init-digs)) sq-digs))\n      \"Automorphic\"\n      \"Not!!\")))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18585,"user_id":null,"body":"(ns kata)\n\n(defn automorphic [n]\n  (let [s (seq (chars (char-array (str n))))\n        square (* n n)]\n    (if (= s (take-last (count s) (str square)))\n      \"Automorphic\"\n      \"Not!!\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18586,"user_id":1400,"body":"(ns kata)\n\n(defn automorphic [n]\n  (if\n    (.endsWith (str (* n n)) (str n))\n    \"Automorphic\"\n    \"Not!!\"\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18587,"user_id":null,"body":"(ns kata\n  (:require [clojure.string :as str]))\n\n(defn automorphic [n]\n  (let \n    [str-n (str n) \n     str-n-squared (str (* n n))] \n    (if (str\/ends-with? str-n-squared str-n) \"Automorphic\" \"Not!!\"))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18588,"user_id":null,"body":"(ns kata)\n\n(defn automorphic\n  [n]\n  (as-> (str (BigInteger\/valueOf (Math\/pow n 2))) m-morph?\n    (if (= (subs m-morph?\n                 (- (.length m-morph?) (.length (str n))))\n           (str n))\n      \"Automorphic\"\n      \"Not!!\")))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a5f9f80f5dc3f942b002309":[{"id":18589,"user_id":null,"body":"(ns kata)\n\n(deftype Omnibool []\n  Object\n  (equals [_ other] (instance? Boolean other)))\n\n(def omnibool (Omnibool.))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18590,"user_id":null,"body":"(ns kata)\n\n(def omnibool true)\n(defn =\n  [& args] true)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18591,"user_id":null,"body":"(ns kata)\n\n(def omnibool (reify Object\n                (equals [_ _] true)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18592,"user_id":null,"body":"(ns kata)\n\n(defprotocol OmniBool \n  (= [a b]))\n\n(def omnibool \n  (reify OmniBool\n    (= [a b] true)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18593,"user_id":null,"body":"(ns kata)\n\n(defn = [_ y]\n  true)\n\n(def omnibool true)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18594,"user_id":168,"body":"(ns kata)\n\n(deftype Omni []\n  Object\n  (equals [a b] true))\n\n(def omnibool (Omni.))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18595,"user_id":null,"body":"(ns kata)\n\n(def omnibool nil)\n\n(defn = [a b] true)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18596,"user_id":null,"body":"(ns kata)\n\n(defn = [value comparitor] value)\n\n(def omnibool true)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18597,"user_id":527,"body":"(ns kata)\n\n(deftype Omnibool [] Object (equals [_ _] true))\n(def omnibool (Omnibool.))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18598,"user_id":201,"body":"(ns kata\n  (:refer-clojure :exclude [=]))\n\n(defn = [x y] true)\n(def omnibool true)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a61a846cadebf9738000076":[{"id":18599,"user_id":527,"body":"(ns kata)\n\n(defn- _peak [xs]\n  (->> (map = (reductions + xs) (identity (reductions - (apply + xs) xs)))\n    (keep-indexed (fn [i e] (when e i)))\n    first))\n\n(defn peak [xs]\n  (or (_peak xs) -1))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18600,"user_id":53,"body":"(ns kata)\n\n(defn peak [numbers]\n  (loop [i 0 l 0 r (reduce + numbers) xs numbers]\n    (cond\n      (empty? xs) -1\n      (= l (- r (first xs))) i\n      :else (recur (inc i) (+ l (first xs)) (- r (first xs)) (rest xs)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18601,"user_id":null,"body":"(ns kata)\n\n(defn peak\n  ([xs]\n   (peak (rest xs) 0 0 (apply + (rest xs)) (first xs)))\n  ([[x & xs] i L R v]\n   (if (< L R)\n     (recur xs (inc i) (+ L v) (- R x) x)\n     (if (= L R) i -1))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18602,"user_id":null,"body":"(ns kata)\n\n(defn peak [xs]\n  (let [xs1 (reductions + xs)\n        xs2 (reductions + (reverse xs))\n        res (->> (map (fn [x y] (= x y)) xs1 (reverse xs2))\n                 (take-while false?)\n                 (count))]\n    (if (= (count xs) res)\n      -1\n      res)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18603,"user_id":null,"body":"(ns kata)\n\n(defn peak [numbers]\n  (let [left #(apply + (take % numbers))\n        right #(apply + (drop (inc %) numbers))\n        is (range 0 (count numbers))\n        sums (filter #(= (left %) (right %)) is)]\n    (if (empty? sums) -1 (first sums))\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18604,"user_id":201,"body":"(ns kata)\n\n(defn peak [numbers]\n  (let [ans\n        (ffirst\n         (filter #(second %)\n                 (map (fn [idx]\n                        (let [[left right] (split-at idx numbers)]\n                          [idx (= (reduce + left) (reduce + (rest right)))]))\n                      (range (count numbers)))))]\n    (if (nil? ans) -1 ans)))\n\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a63948acadebff56f000018":[{"id":18605,"user_id":null,"body":"(ns kata)\n(defn max_product [arr size]\n  (->> arr\n       (sort >)\n       (take size)\n       (reduce *)\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18606,"user_id":null,"body":"(ns kata)\n\n(defn max_product [arr size]\n  (apply * (take-last size (sort arr))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18607,"user_id":null,"body":"(ns kata)\n\n(defn max_product \n  [arr size]\n  (->> (sort > arr)\n       (take size)\n       (apply *)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18608,"user_id":null,"body":"(ns kata)\n\n(defn max_product\n  [arr size]\n  (->> arr\n       (sort >)\n       (take size)\n       (apply *)))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18609,"user_id":null,"body":"(ns kata)\n\n(defn max_product [xs n]\n  (->> xs\n       (sort >)\n       (take n)\n       (apply *)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18610,"user_id":201,"body":"(ns kata)\n(defn max_product [arr size]\n    (reduce * (take size (reverse (sort arr)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18611,"user_id":null,"body":"(ns kata)\n(defn max_product [arr size]\n   (apply * (take size (reverse (sort arr)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18612,"user_id":492,"body":"(ns kata)\n(defn max_product [arr size]\n  (reduce * 1 (take size (reverse (sort arr))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18613,"user_id":null,"body":"(ns kata)\n(defn max_product [arr size]\n  (->>(sort #(> %1 %2) arr)\n      (take size)\n      (reduce * 1)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18614,"user_id":null,"body":"(ns kata)\n(defn max_product [arr size]\n  (->> arr sort (take-last size) (reduce *))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a651865fd56cb55760000e0":[{"id":18615,"user_id":null,"body":"(ns kata)\n\n(defn array_leaders [numbers]\n  (keep-indexed #(when (> %2 (reduce + (subvec (vec numbers) (inc %1)))) %2) (vec numbers))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18616,"user_id":null,"body":"(ns kata)\n\n(defn array_leaders [numbers]\n  (let [size (count numbers)]\n    (->> (map (fn [x] (list (take-last (- size x 1) numbers) (nth numbers x)))\n              (reverse (range 0 (count numbers))))\n         (map (fn [elem] (list (reduce + (first elem)) (second elem))))\n         (filter (fn [elem] (> (second elem) (first elem))))\n         (reverse)\n         (map (fn [elem] (second elem))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18617,"user_id":null,"body":"(ns kata)\n\n(defn array_leaders\n  [numbers]\n  (->> numbers\n       (map\n        (fn [n _]\n          (let [pos (nth numbers n)\n                numbers-rest (drop (+ 1 n) numbers)]\n            (if (> pos (apply + numbers-rest)) pos)))\n        (range))\n       (filter #(not (nil? %)))))\n\n\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18618,"user_id":null,"body":"(ns kata)\n\n(defn array_leaders [numbers]\n  (for [i (range (count numbers))\n        :let [it (nth numbers i)\n              right-sum (reduce + 0 (take-last (- (count numbers) 1 i) numbers))]\n        :when (> it right-sum)]\n    it))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18619,"user_id":null,"body":"(ns kata)\n\n(defn array_leaders [numbers]\n  (loop [[x & xs] (reverse numbers)\n         sum 0\n         res ()]\n    (if (nil? x)\n      res\n      (recur xs (+ x sum) (if (> x sum)\n                            (cons x res)\n                            res)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18620,"user_id":null,"body":"(ns kata)\n\n(defn head-is-leader?\n  [arr]\n  (> (first arr) (reduce + (rest arr))))\n\n\n(defn array_leaders\n  [ns]\n  (filter\n      #(if (nil? %) false true)\n      (map-indexed #(if (head-is-leader? (drop %1 ns)) %2 nil) ns)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18621,"user_id":null,"body":"(ns kata)\n\n(defn reduce-fn [{sum :sum :as m} v]\n  (cond-> m\n    true      (update :sum + v)\n    (> v sum) (update :result conj v)))\n\n(defn array_leaders [coll]\n  (->> coll\n       reverse\n       (reduce reduce-fn {:sum 0})\n       :result))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18622,"user_id":null,"body":"(ns kata)\n\n(defn array_leaders [coll]\n  (->> coll\n       (map vector (->> (rest coll)\n                        (iterate rest)\n                        (map #(apply + %))))\n       (filter #(apply < %))\n       (map second)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18623,"user_id":null,"body":"(ns kata)\n\n(defn rests [coll]\n  (->> (rest coll)\n       (iterate rest)\n       (take (count coll))))\n\n(defn array_leaders [coll]\n  (->> coll\n       (map vector (->> (rests coll) (map #(apply + %))))\n       (filter #(apply < %))\n       (map second)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18624,"user_id":null,"body":"(ns kata)\n\n(defn array_leaders [numbers]\n  (let [rev-array (reverse numbers)\n        sum-rdx (reductions + 0 rev-array)\n        pairs (map vector rev-array sum-rdx)]\n    (->>\n      pairs\n      (filter #(> (first %) (second %)))\n      (map first)\n      reverse)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a662a02e626c54e87000123":[{"id":18625,"user_id":645,"body":"(ns kata)\n(defn extra_perfect [n]\n  (range 1 (inc n) 2))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18626,"user_id":null,"body":"(ns kata)\n(defn extra_perfect [n] (vec (range 1 (+ n 1) 2)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18627,"user_id":1400,"body":"(ns kata)\n(defn extra_perfect [n]\n  (take-nth 2 (range 1 (inc n)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18628,"user_id":1400,"body":"(ns kata)\n\n(defn binary [n]\n  (if (= 0 n)\n    [0]\n    (concat (binary (int (\/ n 2))) [(mod n 2)])\n  )\n)\n\n(defn perfect? [n]\n  (let [x (drop 1 (binary n))]\n    (and (= (first x) 1) (= (last x) 1))\n  )\n)\n\n(defn extra_perfect [n]\n  (filter perfect? (range 1 (inc n)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18629,"user_id":null,"body":"(ns kata)\n(defn extra_perfect [n]\n  (->>\n    (range n)\n    (map inc)\n    (take-nth 2)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18630,"user_id":null,"body":"(ns kata)\n\n(defn is-extra_perfect? [n]\n  (let [bin (Integer\/toString n 2)]\n    (and (= \\1 (first bin)) (= \\1 (last bin)))))\n\n(defn extra_perfect [n]\n  (->> (range 1 (inc n))\n       (filter is-extra_perfect?)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18631,"user_id":201,"body":"(ns kata)\n(defn extra_perfect [n]\n    (map (fn [bs] (Integer\/parseUnsignedInt bs 2))\n      (filter (fn [x] (and (= (first x) \\1) (= (last x) \\1)))\n        (map #(Integer\/toBinaryString %) (range (inc n)))\n      ) ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18632,"user_id":501,"body":"(ns kata)\n(defn extra_perfect [n]\n  (filter odd? (range 1 (+ 1 n)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18633,"user_id":501,"body":"(ns kata\n\n(:require [clojure.string :as str]))\n\n(defn extra_perfect [n]\n  (sort (map first (filter (fn [x] (and (str\/ends-with? (second x) \"1\") (str\/starts-with? (second x) \"1\"))) (zipmap (range 1 (+ n 1)) (map (fn [x] (Integer\/toString x 2)) (range 1 (+ 1 n))))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18634,"user_id":759,"body":"(ns kata)\n(defn extra_perfect [n] (range 1 (+ n 1) 2))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a731b36e19d14400f000c19":[{"id":18635,"user_id":53,"body":"(ns decode)\n(require '[clojure.string :as str])\n(defn in? [xs x] (some #(= x %) xs))\n(defn decode_pass-intern [s]\n  (->> (str\/split s #\" \")\n       (map #(char (Integer\/parseInt (apply str %) 2)))\n       (apply str)\n       (str\/trim)))\n(defn decode_pass [ps s]\n (let [w (decode_pass-intern s)]\n   (if (in? ps w) w false)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18636,"user_id":168,"body":"(ns decode)\n\n(require '[clojure.string :as str])\n\n(defn decode_pass [pass-arr bin]\n  (def p (apply str (map #(char (Integer\/parseInt % 2)) (str\/split bin #\"\\s+\"))))\n  (if (some #(= p %) pass-arr) p false))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18637,"user_id":571,"body":"(ns decode)\n(defn decode_pass [pass-arr bin]\n  (let [x (apply str (map #(char(Integer\/parseInt % 2)) (clojure.string\/split bin #\" \")))]\n    (if (some #(= % x) pass-arr) x false)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18638,"user_id":null,"body":"(ns decode)\n(defn decode_pass [pass-arr bin]\n  (get (set pass-arr)\n       (clojure.string\/join\n        (map #(char (Integer\/parseInt % 2))\n             (clojure.string\/split bin #\" \")))\n       false))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18639,"user_id":null,"body":"(ns decode)\n\n(defn binary \n  \"converts a number to binary\"\n  [number]\n  (Integer\/parseInt number 2))\n\n(defn binary-to-string \n  \"Converts binary array to string\"\n  [bin]\n  (as-> bin $\n    (clojure.string\/split $ #\" \")\n    (map binary $)\n    (map char $)\n    (apply str $)))\n\n(defn decode_pass [pass-arr bin]\n  \"check if password has been correctly guessed from password array\"\n  (def password (binary-to-string bin))\n  (if (some #(= password %) pass-arr)\n    password\n    false)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18640,"user_id":null,"body":"(ns decode)\n\n(defn- parse-binary\n       [s]\n       (as-> \n         s $\n         (map #(condp = %\n            \\0 0\n            \\1 1\n            nil) $)\n         (filter #(not (nil? %)) $)\n         (reduce (fn [acc it] (+ (* 2 acc) it)) 0 $)\n         (char $)))\n\n(defn- parse-binary-password\n       [s]\n       (as->\n         s $\n         (clojure.string\/split s #\" \")\n         (map parse-binary $)\n         (apply str $)))\n\n(defn decode_pass\n  [pass-arr bin]\n (let\n   [p (parse-binary-password bin)]\n   (reduce #(if (= p %2) %2 %1) false pass-arr)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18641,"user_id":null,"body":"(ns decode)\n\n(defn decode_pass [pass-arr bin]\n  (->> (clojure.string\/split bin #\"\\s\")\n       (map #(Integer\/parseInt % 2))\n       (map char)\n       (apply str)\n       (#(if (some (fn [ele] (= ele %)) pass-arr)\n             %\n             false))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18642,"user_id":null,"body":"(ns decode\n  (:require [clojure.string :refer [join split]]))\n\n(defn byte-to-int [bitstring]\n  (let [f (fn [acc b]\n            (+ (bit-shift-left acc 1)\n               (if (= b \\1) 1 0)))]\n    (reduce f 0 bitstring)))\n\n(defn bin-to-pass [bin]\n  (let [bs (split bin #\"\\s+\")\n        cs (map byte-to-int bs)]\n    (join (map char cs))))\n\n(defn decode_pass [pass-arr bin]\n  (let [pass (bin-to-pass bin)\n        maybe (set pass-arr)\n        maybe-pass (maybe pass)]\n    (or maybe-pass false)))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18643,"user_id":null,"body":"(ns decode)\n(defn decode_pass [pass-arr bin]\n  (let [\n  parts (clojure.string\/split bin #\" \")\n  pass (clojure.string\/join (map #(char (Integer\/parseInt % 2)) parts))\n  found-pass (some #(= pass %) pass-arr)\n  ]\n    (if found-pass\n      pass\n      false\n    )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18644,"user_id":null,"body":"(ns decode\n  (:require [clojure.string :as str]))\n\n(defn decode-bin [b]\n  (->> (partition 8 b)\n       (map #(char (Integer\/parseInt (apply str %) 2)))))\n       \n(defn decode_pass [pass-arr bin]\n  (let [password (some #{(->> (str\/split bin #\" \")\n                              (map decode-bin)\n                              (flatten)\n                              (apply str))} pass-arr)]\n    (if (= nil password)\n      false\n      password)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a7893ef0025e9eb50000013":[{"id":18645,"user_id":527,"body":"(ns kata)\n\n(defn max_gap [numbers]\n  (let [numbers (sort numbers)] (apply max (map - (rest numbers) numbers))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18646,"user_id":null,"body":"(ns kata)\n\n(defn max_gap [numbers]\n  (->> numbers\n       (sort >)\n       (partition 2 1)\n       (map (fn [x] (- (first x) (second x))))\n       (apply max)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18647,"user_id":null,"body":"(ns kata)\n\n(defn max_gap [numbers]\n  (reduce max (map - (rest (sort numbers)) (sort numbers))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18648,"user_id":null,"body":"(ns kata)\n\n(defn max_gap\n  [numbers]\n  (apply max (let [sortednumbers (sort numbers)\n                   numcount (count sortednumbers)]\n               (map-indexed (fn [idx val] (if\n                                           (< (inc idx) numcount)\n                                            (- (nth sortednumbers (inc idx)) val)\n                                            0))\n                            sortednumbers))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18649,"user_id":null,"body":"(ns kata)\n\n(defn max_gap [numbers]\n  (->>\n    (sort numbers)\n    (partition 2 1)\n    (map (fn [[a b]] (Math\/abs (- a b))))\n    (apply max)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18650,"user_id":null,"body":"(ns kata)\n\n(defn max_gap [numbers]\n  (->> numbers\n       (sort >)\n       (partition 2 1)\n       (map #(apply - %))\n       (apply max)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18651,"user_id":null,"body":"(ns kata)\n\n(defn max_gap [numbers]\n  (as-> (sort numbers) o\n        (map (fn [x y] (- y x)) o (rest o))\n        (apply max o)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18652,"user_id":201,"body":"(ns kata)\n\n(defn max_gap [numbers]\n  (let [nums (sort numbers)]\n    (last (sort (map #(- %2 %1) nums (rest nums))))))\n  \n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a793fdbfd8c06d07f0000d5":[{"id":18653,"user_id":201,"body":"(ns kata)\n\n(defn solve [s]\n  (loop [s s]\n    (let [f (re-find (re-matcher #\"(\\d*)\\(([^\\(\\)]*)\\)\" s))]\n      (if (nil? f) s\n          (let [block (nth f 2)\n                n (nth f 1)\n                num (if (empty? n) 1 (Integer\/parseInt (nth f 1)))\n                rep (apply str (repeat num block))\n                s1 (clojure.string\/replace s (first f) rep)]\n             (recur s1))))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18654,"user_id":null,"body":"(ns kata (:require [clojure.string :as st]))\n\n(defn r-1 [s]\n  (st\/replace-first\n   s\n   #\"(\\d*)\\((\\w*)\\)\"\n   (fn [[_ n w]]\n     (st\/join\n      (repeat\n       (if (empty? n) 1 (read-string n))\n       w)))))\n\n(defn solve [s]\n  (if (st\/includes? s \"(\") (recur (r-1 s)) s))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18655,"user_id":null,"body":"(ns kata)\n\n(defn count-in [c s]\n  (count (filter #{c} (.split s \"\"))))\n\n(defn extract-groups [s]\n  (let [upper (reduce\n          (fn [acc cur] (+ acc (count cur)))\n          0\n          (take (max 1 (count-in \"(\" s)) (.split (.replace s \")\" \")$\") \"\\\\)\")))\n        group1 (.substring\n          s\n          (inc (.indexOf s \"(\"))\n          upper)]\n    [group1 (if (neg? (.indexOf s \"(\")) \"\" (.substring s (inc upper)))]))\n\n(defn solve [s]\n  (let [parts-re (re-seq #\"[a-z]*?\\d*?\\(.*?\\)+[a-z]*\\)*\" s)\n        parts-filter (filter #(= (count-in \"(\" %) (count-in \")\" %)) parts-re)\n        parts (if (= (count parts-re) (count parts-filter)) parts-re [s])]\n    (if (and (< 1 (count parts)) (re-find #\"\\(\" (last parts)))\n      (reduce (fn [acc cur] (str acc (solve cur))) \"\" parts)\n      (loop [i 0\n             chr-pre (str (get s i))\n             acc-out \"\"]\n        (let [chr (if (re-find #\"\\d\" chr-pre) (re-find #\"\\d+\" (subs s i)) chr-pre)]\n          (if (empty? chr)\n            acc-out\n            (if (re-find #\"[\\d\\(]\" chr)\n                (loop [j 0\n                       n (if (re-find #\"\\d\" chr) (Integer. chr) 1)\n                       group (solve (first (extract-groups s)))\n                       acc-in \"\"]\n                  (if (<= n j)\n                    (str acc-out acc-in (solve (last (extract-groups s))))\n                    (recur (inc j) n group (str acc-in group))))\n            (recur\n              (inc i)\n              (str (get s (inc i)))\n              (str acc-out (if (re-find #\"\\)\" chr) \"\" chr))))))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a87449ab1710171300000fd":[{"id":18656,"user_id":null,"body":"(ns kata)\n\n(defn tidy-number [n]\n  (apply <= (map #(Integer. (str %)) (str n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18657,"user_id":201,"body":"(ns kata)\n\n(defn tidy-number [n]\n  (= (str n) (apply str (sort (str n)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18658,"user_id":null,"body":"(ns kata)\n\n(defn tidy-number [n]\n  (->> (str n)\n       (map #(- (int %) 48))\n       (partition 2 1)\n       (every? #(>= (second %) (first %)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18659,"user_id":null,"body":"(ns kata)\n\n(defn tidy-number [n]\n (->> n\n       str\n       (map #(Character\/digit % 10))\n       (#(= % (sort %)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18660,"user_id":null,"body":"(ns kata)\n\n(defn digits [n]\n  (if (pos? n)\n    (conj (digits (quot n 10)) (mod n 10))\n    []))\n\n(defn tidy-number [n]\n  (if (= (digits n) (sort (digits n)))\n    true\n    false)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18661,"user_id":null,"body":"(ns kata)\n\n(defn- num-digits [n]\n  (vec (for [n (str n)] (- (byte n) 48))))\n\n(defn tidy-number [n]\n  (loop [[x & xs] (num-digits n)\n         pre Long\/MIN_VALUE]\n    (if (and x (>= x pre))\n      (recur xs x)\n      (-> x some? not))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18662,"user_id":null,"body":"(ns kata)\n\n(defn tidy-number [n]\n    (let [sep-digit (->> n\n                         (str)\n                         (seq)\n                         (map str)\n                         (map #(Integer\/parseInt %)))]\n      (= sep-digit (sort sep-digit))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18663,"user_id":null,"body":"(ns kata)\n\n(defn div [x y] (int (\/ x y)))\n\n(defn digits\n  [n]\n  (loop\n    [x n, xs (list)]\n    (if\n      (= x 0)\n      xs\n      (recur (div x 10) (conj xs (mod x 10))))))\n\n(defn tidy-number\n  [n]\n  (let [\n    n-digits (digits n)\n    result (= n-digits (sort n-digits))\n  ] result))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18664,"user_id":null,"body":"(ns kata)\n\n(defn tidy-number [n]\n  (if \n    (zero? (quot n 10))\n    true \n    (and \n     (>= (rem n 10) (rem (quot n 10) 10)) \n     (recur (quot n 10))\n     )\n    )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18665,"user_id":null,"body":"(ns kata)\n\n(defn tidy-number [n]\n  (loop [number n prev 10]\n    (let [quotient  (quot number 10)\n          remainder (rem  number 10)]\n      (cond\n        (< number prev) true\n        (< prev remainder) false\n        :else (recur quotient remainder)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a8d2bf60025e9163c0000bc":[{"id":18666,"user_id":527,"body":"(ns kata)\n\n(defn solve [xs]\n  (sort-by (juxt (comp - (frequencies xs)) identity) xs))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18667,"user_id":null,"body":"(ns kata)\n\n(defn solve [numbers]\n  (->> (sort numbers) (partition-by identity) (sort-by count >) flatten))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18668,"user_id":null,"body":"(ns kata)\n\n(def frequency-comparator\n  (comparator\n    (fn [x y]\n      (if (= (second x) (second y))\n        (< (first x) (first y))\n        (> (second x) (second y))))))\n\n(defn solve [numbers]\n  (->> numbers\n       frequencies\n       (sort-by identity frequency-comparator)\n       (map #(repeat (second %) (first %)))\n       (apply concat)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18669,"user_id":null,"body":"(ns kata)\n\n(defn solve [nums]\n  (let [freqs (frequencies nums)]\n    (sort-by (fn [n]\n               [(- (get freqs n)) n])\n             nums))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18670,"user_id":null,"body":"(ns kata)\n\n(defn count-frequency [x xs]\n  (count (filter #(= % x) xs)))\n\n(defn get-frequency [xs]\n  (loop [ys xs\n         acc []]\n    (if (empty? ys)\n      acc\n      (let [[y & rest] ys]\n        (recur (filter #(not (= % y)) rest) (cons [y (count-frequency y xs)] acc))))))\n\n(defn my-compare [x y]\n  (let [[nx cntx] x]\n   (let [[ny cnty] y] \n    (if (= cntx cnty)\n      (compare ny nx)\n      (compare cntx cnty)))))\n\n(defn solve [numbers]\n  (mapcat (fn [x] (let [[n cnt] x] (take cnt (repeat n)))) \n          (reverse (sort my-compare (get-frequency numbers)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18671,"user_id":null,"body":"(ns kata)\n\n(defn solve [numbers]\n  (->>\n    numbers\n    (frequencies)\n    (sort-by first <)   ; ascend by number\n    (sort-by second >)  ; descend by frquency\n    (mapcat (fn [[x n]] (repeat n x)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18672,"user_id":null,"body":"(ns kata)\n\n(defn solve [numbers]\n  (->> numbers\n     frequencies\n      ;; Sort by val descendingly first; if equal, sort by key acendingly\n     (sort #(compare [(val %2) (key %)] [(val %) (key %2)]))\n     (mapcat (fn [[x y]] (repeat y x)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18673,"user_id":null,"body":"(ns kata)\n\n(defn solve [numbers]\n  (let [freqs (frequencies numbers)]\n    (sort-by (fn [x] (\/ 1.0 (get freqs x))) (sort numbers)))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18674,"user_id":null,"body":"(ns kata)\n\n(defn comparer [[val-a freq-a] [val-b freq-b]]\n  (cond (> freq-a freq-b) -1\n        (< freq-a freq-b) 1\n        :else (< val-a val-b)))\n\n(defn solve [numbers]\n  (prn numbers)\n  (->> numbers\n       frequencies\n       (sort comparer)\n       (reduce (fn [acc [v f]] (concat acc (repeat f v))) [])))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18675,"user_id":527,"body":"(ns kata)\n\n(defn solve [xs]\n  (->> xs\n    (frequencies)\n    (sort-by (juxt (comp - second) first))\n    (mapcat #(replicate (second %) (first %)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a905c2157c562994900009d":[{"id":18676,"user_id":53,"body":"(ns kata)\n(defn product_array [xs] (let [p (reduce * xs)] (map #(quot p %) xs)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18677,"user_id":201,"body":"(ns kata)\n\n(defn product_array [numbers]\n  (let [p (reduce * numbers)]\n    (map #(quot p %) numbers)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18678,"user_id":null,"body":"(ns kata)\n\n(defn product_array [numbers]\n  (map (fn [x] (\/ (reduce * numbers) x)) numbers))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18679,"user_id":null,"body":"(ns kata)\n(defn product_array [numbers]\n  (map (fn [x] (quot (reduce * numbers) x)) numbers))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18680,"user_id":null,"body":"(ns kata)\n\n\n(defn drop-nth [n coll] (keep-indexed #(if (not= %1 n) %2) coll))\n\n(defn product_array\n  [numbers]\n  (map-indexed (fn [idx _] (reduce * (drop-nth idx numbers))) numbers))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18681,"user_id":1400,"body":"(ns kata)\n(defn product_array [numbers]\n  (let [prod (apply * numbers)]\n    (map (fn [x] (\/ prod x)) numbers)\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18682,"user_id":168,"body":"(ns kata)\n(defn product_array [numbers]\n  (let [p (apply * numbers)]\n    (map #(\/ p %1) numbers)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18683,"user_id":null,"body":"(ns kata)\n(defn product_array [numbers]\n  (let\n    [product (apply * numbers)]\n      (map #(int (\/ product %)) numbers)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18684,"user_id":null,"body":"(ns kata)\n\n(defn product_array [numbers]\n  (map #(apply * (assoc (vec numbers) % 1)) (range (count numbers))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18685,"user_id":null,"body":"(ns kata)\n(defn product_array [numbers]\n  (map-indexed (fn [ix i] (reduce * (concat (drop (inc ix) numbers) (take ix numbers)))) numbers))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a908da30025e995880000e3":[{"id":18686,"user_id":527,"body":"(ns kata.core)\n\n(def prime-dig-seq \"2357111317192329313741434753596167717379838997101103107109113127131137139149151157163167173179181191193197199211223227229233239241251257263269271277281283293307311313317331337347349353359367373379383389397401409419421431433439443449457461463467479487491499503509521523541547557563569571577587593599601607613617619631641643647653659661673677683691701709719727733739743751757761769773787797809811821823827829839853857859863877881883887907911919929937941947953967971977983991997100910131019102110311033103910491051106110631069108710911093109711031109111711231129115111531163117111811187119312011213121712231229123112371249125912771279128312891291129713011303130713191321132713611367137313811399140914231427142914331439144714511453145914711481148314871489149314991511152315311543154915531559156715711579158315971601160716091613161916211627163716571663166716691693169716991709172117231733174117471753175917771783178717891801181118231831184718611867187118731877187918891901190719131931193319491951197319791987199319971999200320112017202720292039205320632069208120832087208920992111211321292131213721412143215321612179220322072213222122372239224322512267226922732281228722932297230923112333233923412347235123572371237723812383238923932399241124172423243724412447245924672473247725032521253125392543254925512557257925912593260926172621263326472657265926632671267726832687268926932699270727112713271927292731274127492753276727772789279127972801280328192833283728432851285728612879288728972903290929172927293929532957296329692971299930013011301930233037304130493061306730793083308931093119312131373163316731693181318731913203320932173221322932513253325732593271329933013307331333193323332933313343334733593361337133733389339134073413343334493457346134633467346934913499351135173527352935333539354135473557355935713581358335933607361336173623363136373643365936713673367736913697370137093719372737333739376137673769377937933797380338213823383338473851385338633877388138893907391139173919392339293931394339473967398940014003400740134019402140274049405140574073407940914093409941114127412941334139415341574159417742014211421742194229423142414243425342594261427142734283428942974327433743394349435743634373439143974409442144234441444744514457446344814483449345074513451745194523454745494561456745834591459746034621463746394643464946514657466346734679469147034721472347294733475147594783478747894793479948014813481748314861487148774889490349094919493149334937494349514957496749694973498749934999500350095011502150235039505150595077508150875099510151075113511951475153516751715179518951975209522752315233523752615273527952815297530353095323533353475351538153875393539954075413541754195431543754415443544954715477547954835501550355075519552155275531555755635569557355815591562356395641564756515653565756595669568356895693570157115717573757415743574957795783579158015807581358215827583958435849585158575861586758695879588158975903592359275939595359815987600760116029603760436047605360676073607960896091610161136121613161336143615161636173619761996203621162176221622962476257626362696271627762876299630163116317632363296337634363536359636163676373637963896397642164276449645164696473648164916521652965476551655365636569657165776581659966076619663766536659666166736679668966916701670367096719673367376761676367796781679167936803682368276829683368416857686368696871688368996907691169176947694969596961696769716977698369916997700170137019702770397043705770697079710371097121712771297151715971777187719372077211721372197229723772437247725372837297730773097321733173337349735173697393741174177433745174577459747774817487748974997507751775237529753775417547754975597561757375777583758975917603760776217639764376497669767376817687769176997703771777237727774177537757775977897793781778237829784178537867787378777879788379017907791979277933793779497951796379938009801180178039805380598069808180878089809381018111811781238147816181678171817981918209821982218231823382378243826382698273828782918293829783118317832983538363836983778387838984198423842984318443844784618467850185138521852785378539854385638573858185978599860986238627862986418647866386698677868186898693869987078713871987318737874187478753876187798783880388078819882188318837883988498861886388678887889389238929893389418951896389698971899990019007901190139029904190439049905990679091910391099127913391379151915791619173918191879199920392099221922792399241925792779281928392939311931993239337934193439349937193779391939794039413941994219431943394379439946194639467947394799491949795119521953395399547955195879601961396199623962996319643964996619677967996899697971997219733973997439749976797699781978797919803981198179829983398399851985798599871988398879901990799239929993199419949996799731000710009100371003910061100671006910079100911009310099101031011110133101391014110151101591016310169101771018110193102111022310243102471025310259102671027110273102891030110303103131032110331103331033710343103571036910391103991042710429104331045310457104591046310477104871049910501105131052910531105591056710589105971060110607106131062710631106391065110657106631066710687106911070910711107231072910733107391075310771107811078910799108311083710847108531085910861108671088310889108911090310909109371093910949109571097310979109871099311003110271104711057110591106911071110831108711093111131111711119111311114911159111611117111173111771119711213112391124311251112571126111273112791128711299113111131711321113291135111353113691138311393113991141111423114371144311447114671147111483114891149111497115031151911527115491155111579115871159311597116171162111633116571167711681116891169911701117171171911731117431177711779117831178911801118071181311821118271183111833118391186311867118871189711903119091192311927119331193911941119531195911969119711198111987120071201112037120411204312049120711207312097121011210712109121131211912143121491215712161121631219712203122111222712239122411225112253122631226912277122811228912301123231232912343123471237312377123791239112401124091241312421124331243712451124571247312479124871249112497125031251112517125271253912541125471255312569125771258312589126011261112613126191263712641126471265312659126711268912697127031271312721127391274312757127631278112791127991280912821128231282912841128531288912893128991290712911129171291912923129411295312959129671297312979129831300113003130071300913033130371304313049130631309313099131031310913121131271314713151131591316313171131771318313187132171321913229132411324913259132671329113297133091331313327133311333713339133671338113397133991341113417134211344113451134571346313469134771348713499135131352313537135531356713577135911359713613136191362713633136491366913679136811368713691136931369713709137111372113723137291375113757137591376313781137891379913807138291383113841138591387313877138791388313901139031390713913139211393113933139631396713997139991400914011140291403314051140571407114081140831408714107141431414914153141591417314177141971420714221142431424914251142811429314303143211432314327143411434714369143871438914401144071441114419144231443114437144471444914461144791448914503145191453314537145431454914551145571456114563145911459314621146271462914633146391465314657146691468314699147131471714723147311473714741147471475314759147671477114779147831479714813148211482714831148431485114867148691487914887148911489714923149291493914947149511495714969149831501315017150311505315061150731507715083150911510115107151211513115137151391514915161151731518715193151991521715227152331524115259152631526915271152771528715289152991530715313153191532915331153491535915361153731537715383153911540115413154271543915443154511546115467154731549315497155111552715541155511555915569155811558315601156071561915629156411564315647156491566115667156711567915683157271573115733157371573915749157611576715773157871579115797158031580915817158231585915877158811588715889159011590715913159191592315937159591597115973159911600116007160331605716061160631606716069160731608716091160971610316111161271613916141161831618716189161931621716223162291623116249162531626716273163011631916333163391634916361163631636916381164111641716421164271643316447164511645316477164811648716493165191652916547165531656116567165731660316607166191663116633166491665116657166611667316691166931669916703167291674116747167591676316787168111682316829168311684316871168791688316889169011690316921169271693116937169431696316979169811698716993170111702117027170291703317041170471705317077170931709917107171171712317137171591716717183171891719117203172071720917231172391725717291172931729917317173211732717333173411735117359173771738317387173891739317401174171741917431174431744917467174711747717483174891749117497175091751917539175511756917573175791758117597175991760917623176271765717659176691768117683177071771317729177371774717749177611778317789177911780717827178371783917851178631788117891179031790917911179211792317929179391795717959179711797717981179871798918013180411804318047180491805918061180771808918097181191812118127181311813318143181491816918181181911819918211182171822318229182331825118253182571826918287182891830118307183111831318329183411835318367183711837918397184011841318427184331843918443184511845718461184811849318503185171852118523185391854118553185831858718593186171863718661186711867918691187011871318719187311874318749187571877318787187931879718803188391885918869188991891118913189171891918947189591897318979190011900919013190311903719051190691907319079190811908719121191391914119157191631918119183192071921119213192191923119237192491925919267192731928919301193091931919333193731937919381193871939119403194171942119423194271942919433194411944719457194631946919471194771948319489195011950719531195411954319553195591957119577195831959719603196091966119681196871969719699197091971719727197391975119753197591976319777197931980119813198191984119843198531986119867198891989119913199191992719937199491996119963199731997919991199931999720011200212002320029200472005120063200712008920101201072011320117201232012920143201472014920161201732017720183202012021920231202332024920261202692028720297203232032720333203412034720353203572035920369203892039320399204072041120431204412044320477204792048320507205092052120533205432054920551205632059320599206112062720639206412066320681206932070720717207192073120743207472074920753207592077120773207892080720809208492085720873208792088720897208992090320921209292093920947209592096320981209832100121011210132101721019210232103121059210612106721089211012110721121211392114321149211572116321169211792118721191211932121121221212272124721269212772128321313213172131921323213412134721377213792138321391213972140121407214192143321467214812148721491214932149921503215172152121523215292155721559215632156921577215872158921599216012161121613216172164721649216612167321683217012171321727217372173921751217572176721773217872179921803218172182121839218412185121859218632187121881218932191121929219372194321961219772199121997220032201322027220312203722039220512206322067220732207922091220932210922111221232212922133221472215322157221592217122189221932222922247222592227122273222772227922283222912230322307223432234922367223692238122391223972240922433224412244722453224692248122483225012251122531225412254322549225672257122573226132261922621226372263922643226512266922679226912269722699227092271722721227272273922741227512276922777227832278722807228112281722853228592286122871228772290122907229212293722943229612296322973229932300323011230172302123027230292303923041230532305723059230632307123081230872309923117231312314323159231672317323189231972320123203232092322723251232692327923291232932329723311233212332723333233392335723369233712339923417234312344723459234732349723509235312353723539235492355723561235632356723581235932359923603236092362323627236292363323663236692367123677236872368923719237412374323747237532376123767237732378923801238132381923827238312383323857238692387323879238872389323899239092391123917239292395723971239772398123993240012400724019240232402924043240492406124071240772408324091240972410324107241092411324121241332413724151241692417924181241972420324223242292423924247242512428124317243292433724359243712437324379243912440724413244192442124439244432446924473244812449924509245172452724533245472455124571245932461124623246312465924671246772468324691246972470924733247492476324767247812479324799248092482124841248472485124859248772488924907249172491924923249432495324967249712497724979249892501325031250332503725057250732508725097251112511725121251272514725153251632516925171251832518925219252292523725243252472525325261253012530325307253092532125339253432534925357253672537325391254092541125423254392544725453254572546325469254712552325537255412556125577255792558325589256012560325609256212563325639256432565725667256732567925693257032571725733257412574725759257632577125793257992580125819258412584725849258672587325889259032591325919259312593325939259432595125969259812599725999260032601726021260292604126053260832609926107261112611326119261412615326161261712617726183261892620326209262272623726249262512626126263262672629326297263092631726321263392634726357263712638726393263992640726417264232643126437264492645926479264892649726501265132653926557265612657326591265972662726633266412664726669266812668326687266932669926701267112671326717267232672926731267372675926777267832680126813268212683326839268492686126863268792688126891268932690326921269272694726951269532695926981269872699327011270172703127043270592706127067270732707727091271032710727109271272714327179271912719727211272392724127253272592727127277272812728327299273292733727361273672739727407274092742727431274372744927457274792748127487275092752727529275392754127551275812758327611276172763127647276532767327689276912769727701277332773727739277432774927751277632776727773277792779127793277992780327809278172782327827278472785127883278932790127917279192794127943279472795327961279672798327997280012801928027280312805128057280692808128087280972809928109281112812328151281632818128183282012821128219282292827728279282832828928297283072830928319283492835128387283932840328409284112842928433284392844728463284772849328499285132851728537285412854728549285592857128573285792859128597286032860728619286212862728631286432864928657286612866328669286872869728703287112872328729287512875328759287712878928793288072881328817288372884328859288672887128879289012890928921289272893328949289612897929009290172902129023290272903329059290632907729101291232912929131291372914729153291672917329179291912920129207292092922129231292432925129269292872929729303293112932729333293392934729363293832938729389293992940129411294232942929437294432945329473294832950129527295312953729567295692957329581295872959929611296292963329641296632966929671296832971729723297412975329759297612978929803298192983329837298512986329867298732987929881299172992129927299472995929983299893001130013300293004730059300713008930091300973010330109301133011930133301373013930161301693018130187301973020330211302233024130253302593026930271302933030730313303193032330341303473036730389303913040330427304313044930467304693049130493304973050930517305293053930553305573055930577305933063130637306433064930661306713067730689306973070330707307133072730757307633077330781308033080930817308293083930841308513085330859308693087130881308933091130931309373094130949309713097730983310133101931033310393105131063310693107931081310913112131123311393114731151311533115931177311813118331189311933121931223312313123731247312493125331259312673127131277313073131931321313273133331337313573137931387313913139331397314693147731481314893151131513315173153131541315433154731567315733158331601316073162731643316493165731663316673168731699317213172331727317293174131751317693177131793317993181731847318493185931873318833189131907319573196331973319813199132003320093202732029320513205732059320633206932077320833208932099321173211932141321433215932173321833218932191322033221332233322373225132257322613229732299323033230932321323233232732341323533235932363323693237132377323813240132411324133242332429324413244332467324793249132497325033250732531325333253732561325633256932573325793258732603326093261132621326333264732653326873269332707327133271732719327493277132779327833278932797328013280332831328333283932843328693288732909329113291732933329393294132957329693297132983329873299332999330133302333029330373304933053330713307333083330913310733113331193314933151331613317933181331913319933203332113322333247332873328933301333113331733329333313334333347333493335333359333773339133403334093341333427334573346133469334793348733493335033352133529335333354733563335693357733581335873358933599336013361333617336193362333629336373364133647336793370333713337213373933749337513375733767337693377333791337973380933811338273382933851338573386333871338893389333911339233393133937339413396133967339973401934031340333403934057340613412334127341293414134147341573415934171341833421134213342173423134253342593426134267342733428334297343013430334313343193432734337343513436134367343693438134403344213442934439344573446934471344833448734499345013451134513345193453734543345493458334589345913460334607346133463134649346513466734673346793468734693347033472134729347393474734757347593476334781348073481934841348433484734849348713487734883348973491334919349393494934961349633498135023350273505135053350593506935081350833508935099351073511135117351293514135149351533515935171352013522135227352513525735267352793528135291353113531735323353273533935353353633538135393354013540735419354233543735447354493546135491355073550935521355273553135533355373554335569355733559135593355973560335617356713567735729357313574735753357593577135797358013580335809358313583735839358513586335869358793589735899359113592335933359513596335969359773598335993359993600736011360133601736037360613606736073360833609736107361093613136137361513616136187361913620936217362293624136251362633626936277362933629936307363133631936341363433635336373363833638936433364513645736467364693647336479364933649736523365273652936541365513655936563365713658336587365993660736629366373664336653366713667736683366913669736709367133672136739367493676136767367793678136787367913679336809368213683336847368573687136877368873689936901369133691936923369293693136943369473697336979369973700337013370193702137039370493705737061370873709737117371233713937159371713718137189371993720137217372233724337253372733727737307373093731337321373373733937357373613736337369373793739737409374233744137447374633748337489374933750137507375113751737529375373754737549375613756737571375733757937589375913760737619376333764337649376573766337691376933769937717377473778137783377993781137813378313784737853378613787137879378893789737907379513795737963379673798737991379933799738011380393804738053380693808338113381193814938153381673817738183381893819738201382193823138237382393826138273382813828738299383033831738321383273832938333383513837138377383933843138447384493845338459384613850138543385573856138567385693859338603386093861138629386393865138653386693867138677386933869938707387113871338723387293873738747387493876738783387913880338821388333883938851388613886738873388913890338917389213892338933389533895938971389773899339019390233904139043390473907939089390973910339107391133911939133391393915739161391633918139191391993920939217392273922939233392393924139251392933930139313393173932339341393433935939367393713937339383393973940939419394393944339451394613949939503395093951139521395413955139563395693958139607396193962339631396593966739671396793970339709397193972739733397493976139769397793979139799398213982739829398393984139847398573986339869398773988339887399013992939937399533997139979399833998940009400134003140037400394006340087400934009940111401234012740129401514015340163401694017740189401934021340231402374024140253402774028340289403434035140357403614038740423404274042940433404594047140483404874049340499405074051940529405314054340559405774058340591405974060940627406374063940693406974069940709407394075140759407634077140787408014081340819408234082940841408474084940853408674087940883408974090340927409334093940949409614097340993410114101741023410394104741051410574107741081411134111741131411414114341149411614117741179411834118941201412034121341221412274123141233412434125741263412694128141299413334134141351413574138141387413894139941411414134144341453414674147941491415074151341519415214153941543415494157941593415974160341609416114161741621416274164141647416514165941669416814168741719417294173741759417614177141777418014180941813418434184941851418634187941887418934189741903419114192741941419474195341957419594196941981419834199942013420174201942023420434206142071420734208342089421014213142139421574216942179421814218742193421974220942221422234222742239422574228142283422934229942307423234233142337423494235942373423794239142397424034240742409424334243742443424514245742461424634246742473424874249142499425094253342557425694257142577425894261142641426434264942667426774268342689426974270142703427094271942727427374274342751427674277342787427934279742821428294283942841428534285942863428994290142923429294293742943429534296142967429794298943003430134301943037430494305143063430674309343103431174313343151431594317743189432014320743223432374326143271432834329143313433194332143331433914339743399434034341143427434414345143457434814348743499435174354143543435734357743579435914359743607436094361343627436334364943651436614366943691437114371743721437534375943777437814378343787437894379343801438534386743889438914391343933439434395143961439634396943973439874399143997440174402144027440294404144053440594407144087440894410144111441194412344129441314415944171441794418944201442034420744221442494425744263442674426944273442794428144293443514435744371443814438344389444174444944453444834449144497445014450744519445314453344537445434454944563445794458744617446214462344633446414464744651446574468344687446994470144711447294474144753447714477344777447894479744809448194483944843448514486744879448874489344909449174492744939449534495944963449714498344987450074501345053450614507745083451194512145127451314513745139451614517945181451914519745233452474525945263452814528945293453074531745319453294533745341453434536145377453894540345413454274543345439454814549145497455034552345533455414555345557455694558745589455994561345631456414565945667456734567745691456974570745737457514575745763457674577945817458214582345827458334584145853458634586945887458934594345949459534595945971459794598946021460274604946051460614607346091460934609946103461334614146147461534617146181461834618746199462194622946237462614627146273462794630146307463094632746337463494635146381463994641146439464414644746451464574647146477464894649946507465114652346549465594656746573465894659146601466194663346639466434664946663466794668146687466914670346723467274674746751467574676946771468074681146817468194682946831468534686146867468774688946901469194693346957469934699747017470414705147057470594708747093471114711947123471294713747143471474714947161471894720747221472374725147269472794728747293472974730347309473174733947351473534736347381473874738947407474174741947431474414745947491474974750147507475134752147527475334754347563475694758147591475994760947623476294763947653476574765947681476994770147711477134771747737477414774347777477794779147797478074780947819478374784347857478694788147903479114791747933479394794747951479634796947977479814801748023480294804948073480794809148109481194812148131481574816348179481874819348197482214823948247482594827148281482994831148313483374834148353483714838348397484074840948413484374844948463484734847948481484874849148497485234852748533485394854148563485714858948593486114861948623486474864948661486734867748679487314873348751487574876148767487794878148787487994880948817488214882348847488574885948869488714888348889489074894748953489734898948991490034900949019490314903349037490434905749069490814910349109491174912149123491394915749169491714917749193491994920149207492114922349253492614927749279492974930749331493334933949363493674936949391493934940949411494174942949433494514945949463494774948149499495234952949531495374954749549495594959749603496134962749633496394966349667496694968149697497114972749739497414974749757497834978749789498014980749811498234983149843498534987149877498914991949921499274993749939499434995749991499934999950021500235003350047500515005350069500775008750093501015011150119501235012950131501475015350159501775020750221502275023150261502635027350287502915031150321503295033350341503595036350377503835038750411504175042350441504595046150497505035051350527505395054350549505515058150587505915059350599506275064750651506715068350707507235074150753507675077350777507895082150833508395084950857508675087350891508935090950923509295095150957509695097150989509935100151031510435104751059510615107151109511315113351137511515115751169511935119751199512035121751229512395124151257512635128351287513075132951341513435134751349513615138351407514135141951421514275143151437514395144951461514735147951481514875150351511515175152151539515515156351577515815159351599516075161351631516375164751659516735167951683516915171351719517215174951767517695178751797518035181751827518295183951853518595186951871518935189951907519135192951941519495197151973519775199152009520215202752051520575206752069520815210352121521275214752153521635217752181521835218952201522235223752249522535225952267522895229152301523135232152361523635236952379523875239152433524535245752489525015251152517525295254152543525535256152567525715257952583526095262752631526395266752673526915269752709527115272152727527335274752757527695278352807528135281752837528595286152879528835288952901529035291952937529515295752963529675297352981529995300353017530475305153069530775308753089530935310153113531175312953147531495316153171531735318953197532015323153233532395326753269532795328153299533095332353327533535335953377533815340153407534115341953437534415345353479535035350753527535495355153569535915359353597536095361153617536235362953633536395365353657536815369353699537175371953731537595377353777537835379153813538195383153849538575386153881538875389153897538995391753923539275393953951539595398753993540015401154013540375404954059540835409154101541215413354139541515416354167541815419354217542515426954277542875429354311543195432354331543475436154367543715437754401544035440954413544195442154437544435444954469544935449754499545035451754521545395454154547545595456354577545815458354601546175462354629546315464754667546735467954709547135472154727547515476754773547795478754799548295483354851548695487754881549075491754919549415494954959549735497954983550015500955021550495505155057550615507355079551035510955117551275514755163551715520155207552135521755219552295524355249552595529155313553315533355337553395534355351553735538155399554115543955441554575546955487555015551155529555415554755579555895560355609556195562155631556335563955661556635566755673556815569155697557115571755721557335576355787557935579955807558135581755819558235582955837558435584955871558895589755901559035592155927559315593355949559675598755997560035600956039560415605356081560875609356099561015611356123561315614956167561715617956197562075620956237562395624956263562675626956299563115633356359563695637756383563935640156417564315643756443564535646756473564775647956489565015650356509565195652756531565335654356569565915659756599566115662956633566595666356671566815668756701567115671356731567375674756767567735677956783568075680956813568215682756843568575687356891568935689756909569115692156923569295694156951569575696356983569895699356999570375704157047570595707357077570895709757107571195713157139571435714957163571735717957191571935720357221572235724157251572595726957271572835728757301573295733157347573495736757373573835738957397574135742757457574675748757493575035752757529575575755957571575875759357601576375764157649576535766757679576895769757709577135771957727577315773757751577735778157787577915779357803578095782957839578475785357859578815789957901579175792357943579475797357977579915801358027580315804358049580575806158067580735809958109581115812958147581515815358169581715818958193581995820758211582175822958231582375824358271583095831358321583375836358367583695837958391583935840358411584175842758439584415845158453584775848158511585375854358549585675857358579586015860358613586315865758661586795868758693586995871158727587335874158757587635877158787587895883158889588975890158907589095891358921589375894358963589675897958991589975900959011590215902359029590515905359063590695907759083590935910759113591195912359141591495915959167591835919759207592095921959221592335923959243592635927359281593335934159351593575935959369593775938759393593995940759417594195944159443594475945359467594715947359497595095951359539595575956159567595815961159617596215962759629596515965959663596695967159693596995970759723597295974359747597535977159779597915979759809598335986359879598875992159929599515995759971599815999960013600176002960037600416007760083600896009160101601036010760127601336013960149601616016760169602096021760223602516025760259602716028960293603176033160337603436035360373603836039760413604276044360449604576049360497605096052160527605396058960601606076061160617606236063160637606476064960659606616067960689607036071960727607336073760757607616076360773607796079360811608216085960869608876088960899609016091360917609196092360937609436095360961610016100761027610316104361051610576109161099611216112961141611516115361169612116122361231612536126161283612916129761331613336133961343613576136361379613816140361409614176144161463614696147161483614876149361507615116151961543615476155361559615616158361603616096161361627616316163761643616516165761667616736168161687617036171761723617296175161757617816181361819618376184361861618716187961909619276193361949619616196761979619816198761991620036201162017620396204762053620576207162081620996211962129621316213762141621436217162189621916220162207622136221962233622736229762299623036231162323623276234762351623836240162417624236245962467624736247762483624976250162507625336253962549625636258162591625976260362617626276263362639626536265962683626876270162723627316274362753627616277362791628016281962827628516286162869628736289762903629216292762929629396296962971629816298362987629896302963031630596306763073630796309763103631136312763131631496317963197631996321163241632476327763281632996331163313633176333163337633476335363361633676337763389633916339763409634196342163439634436346363467634736348763493634996352163527635336354163559635776358763589635996360163607636116361763629636476364963659636676367163689636916369763703637096371963727637376374363761637736378163793637996380363809638236383963841638536385763863639016390763913639296394963977639976400764013640196403364037640636406764081640916410964123641516415364157641716418764189642176422364231642376427164279642836430164303643196432764333643736438164399644036443364439644516445364483644896449964513645536456764577645796459164601646096461364621646276463364661646636466764679646936470964717647476476364781647836479364811648176484964853648716487764879648916490164919649216492764937649516496964997650036501165027650296503365053650636507165089650996510165111651196512365129651416514765167651716517365179651836520365213652396525765267652696528765293653096532365327653536535765371653816539365407654136541965423654376544765449654796549765519655216553765539655436555165557655636557965581655876559965609656176562965633656476565165657656776568765699657016570765713657176571965729657316576165777657896580965827658316583765839658436585165867658816589965921659276592965951659576596365981659836599366029660376604166047660676607166083660896610366107661096613766161661696617366179661916622166239662716629366301663376634366347663596636166373663776638366403664136643166449664576646366467664916649966509665236652966533665416655366569665716658766593666016661766629666436665366683666976670166713667216673366739667496675166763667916679766809668216684166851668536686366877668836688966919669236693166943669476694966959669736697767003670216703367043670496705767061670736707967103671216712967139671416715367157671696718167187671896721167213672176721967231672476726167271672736728967307673396734367349673696739167399674096741167421674276742967433674476745367477674816748967493674996751167523675316753767547675596756767577675796758967601676076761967631676516767967699677096772367733677416775167757677596776367777677836778967801678076781967829678436785367867678836789167901679276793167933679396794367957679616796767979679876799368023680416805368059680716808768099681116811368141681476816168171682076820968213682196822768239682616827968281683116832968351683716838968399684376844368447684496847368477684836848968491685016850768521685316853968543685676858168597686116863368639686596866968683686876869968711687136872968737687436874968767687716877768791688136881968821688636887968881688916889768899689036890968917689276894768963689936900169011690196902969031690616906769073691096911969127691436914969151691636919169193691976920369221692336923969247692576925969263693136931769337693416937169379693836938969401694036942769431694396945769463694676947369481694916949369497694996953969557695936962369653696616967769691696976970969737697396976169763697676977969809698216982769829698336984769857698596987769899699116992969931699416995969991699977000170003700097001970039700517006170067700797009970111701177012170123701397014170157701637017770181701837019970201702077022370229702377024170249702717028970297703097031370321703277035170373703797038170393704237042970439704517045770459704817048770489705017050770529705377054970571705737058370589706077061970621706277063970657706637066770687707097071770729707537076970783707937082370841708437084970853708677087770879708917090170913709197092170937709497095170957709697097970981709917099770999710117102371039710597106971081710897111971129711437114771153711617116771171711917120971233712377124971257712617126371287712937131771327713297133371339713417134771353713597136371387713897139971411714137141971429714377144371453714717147371479714837150371527715377154971551715637156971593715977163371647716637167171693716997170771711717137171971741717617177771789718077180971821718377184371849718617186771879718817188771899719097191771933719417194771963719717198371987719937199972019720317204372047720537207372077720897209172101721037210972139721617216772169721737221172221722237222772229722517225372269722717227772287723077231372337723417235372367723797238372421724317246172467724697248172493724977250372533725477255172559725777261372617726237264372647726497266172671726737267972689727017270772719727277273372739727637276772797728177282372859728697287172883728897289372901729077291172923729317293772949729537295972973729777299773009730137301973037730397304373061730637307973091731217312773133731417318173189732377324373259732777329173303733097332773331733517336173363733697337973387734177342173433734537345973471734777348373517735237352973547735537356173571735837358973597736077360973613736377364373651736737367973681736937369973709737217372773751737577377173783738197382373847738497385973867738777388373897739077393973943739517396173973739997401774021740277404774051740717407774093740997410174131741437414974159741617416774177741897419774201742037420974219742317425774279742877429374297743117431774323743537435774363743777438174383744117441374419744417444974453744717448974507745097452174527745317455174561745677457374587745977460974611746237465374687746997470774713747177471974729747317474774759747617477174779747977482174827748317484374857748617486974873748877489174897749037492374929749337494174959750117501375017750297503775041750797508375109751337514975161751677516975181751937520975211752177522375227752397525375269752777528975307753237532975337753477535375367753777538975391754017540375407754317543775479755037551175521755277553375539755417555375557755717557775583756117561775619756297564175653756597567975683756897570375707757097572175731757437576775773757817578775793757977582175833758537586975883759137593175937759417596775979759837598975991759977600176003760317603976079760817609176099761037612376129761477615776159761637620776213762317624376249762537625976261762837628976303763337634376367763697637976387764037642176423764417646376471764817648776493765077651176519765377654176543765617657976597766037660776631766497665176667766737667976697767177673376753767577677176777767817680176819768297683176837768477687176873768837690776913769197694376949769617696376991770037701777023770297704177047770697708177093771017713777141771537716777171771917720177213772377723977243772497726177263772677726977279772917731777323773397734777351773597736977377773837741777419774317744777471774777747977489774917750977513775217752777543775497755177557775637756977573775877759177611776177762177641776477765977681776877768977699777117771377719777237773177743777477776177773777837779777801778137783977849778637786777893778997792977933779517796977977779837799978007780177803178041780497805978079781017812178137781397815778163781677817378179781917819378203782297823378241782597827778283783017830778311783177834178347783677840178427784377843978467784797848778497785097851178517785397854178553785697857178577785837859378607786237864378649786537869178697787077871378721787377877978781787877879178797788037880978823788397885378857788777888778889788937890178919789297894178977789797898979031790397904379063790877910379111791337913979147791517915379159791817918779193792017922979231792417925979273792797928379301793097931979333793377934979357793677937979393793977939979411794237942779433794517948179493795317953779549795597956179579795897960179609796137962179627796317963379657796697968779691796937969779699797577976979777798017981179813798177982379829798417984379847798617986779873798897990179903799077993979943799677997379979799877999779999800218003980051800718007780107801118014180147801498015380167801738017780191802078020980221802318023380239802518026380273802798028780309803178032980341803478036380369803878040780429804478044980471804738048980491805138052780537805578056780599806038061180621806278062980651806578066980671806778068180683806878070180713807378074780749807618077780779807838078980803808098081980831808338084980863808978090980911809178092380929809338095380963809898100181013810178101981023810318104181043810478104981071810778108381097811018111981131811578116381173811818119781199812038122381233812398128181283812938129981307813318134381349813538135981371813738140181409814218143981457814638150981517815278153381547815518155381559815638156981611816198162981637816478164981667816718167781689817018170381707817278173781749817618176981773817998181781839818478185381869818838189981901819198192981931819378194381953819678197181973820038200782009820138202182031820378203982051820678207382129821398214182153821638217182183821898219382207822178221982223822318223782241822618226782279823018230782339823498235182361823738238782393824218245782463824698247182483824878249382499825078252982531825498255982561825678257182591826018260982613826198263382651826578269982721827238272782729827578275982763827818278782793827998281182813828378284782883828898289182903829138293982963829818299783003830098302383047830598306383071830778308983093831018311783137831778320383207832198322183227832318323383243832578326783269832738329983311833398334183357833838338983399834018340783417834238343183437834438344983459834718347783497835378355783561835638357983591835978360983617836218363983641836538366383689837018371783719837378376183773837778379183813838338384383857838698387383891839038391183921839338393983969839838398784011840178404784053840598406184067840898412184127841318413784143841638417984181841918419984211842218422384229842398424784263842998430784313843178431984347843498437784389843918440184407844218443184437844438444984457844638446784481844998450384509845218452384533845518455984589846298463184649846538465984673846918469784701847138471984731847378475184761847878479384809848118482784857848598486984871849138491984947849618496784977849798499185009850218502785037850498506185081850878509185093851038510985121851338514785159851938519985201852138522385229852378524385247852598529785303853138533185333853618536385369853818541185427854298543985447854518545385469854878551385517855238553185549855718557785597856018560785619856218562785639856438566185667856698569185703857118571785733857518578185793858178581985829858318583785843858478585385889859038590985931859338599185999860118601786027860298606986077860838611186113861178613186137861438616186171861798618386197862018620986239862438624986257862638626986287862918629386297863118632386341863518635386357863698637186381863898639986413864238644186453864618646786477864918650186509865318653386539865618657386579865878659986627866298667786689866938671186719867298674386753867678677186783868138683786843868518685786861868698692386927869298693986951869598696986981869938701187013870378704187049870718708387103871078711987121871338714987151871798718187187872118722187223872518725387257872778728187293872998731387317873238733787359873838740387407874218742787433874438747387481874918750987511875178752387539875418754787553875578755987583875878758987613876238762987631876418764387649876718767987683876918769787701877198772187739877438775187767877938779787803878118783387853878698787787881878878791187917879318794387959879618797387977879918800188003880078801988037880698807988093881178812988169881778821188223882378824188259882618828988301883218832788337883398837988397884118842388427884638846988471884938849988513885238854788589885918860788609886438865188657886618866388667886818872188729887418874788771887898879388799888018880788811888138881788819888438885388861888678887388883888978890388919889378895188969889938899789003890098901789021890418905189057890698907189083890878910189107891138911989123891378915389189892038920989213892278923189237892618926989273892938930389317893298936389371893818938789393893998941389417894318944389449894598947789491895018951389519895218952789533895618956389567895918959789599896038961189627896338965389657896598966989671896818968989753897598976789779897838979789809898198982189833898398984989867898918989789899899098991789923899398995989963899778998389989900019000790011900179001990023900319005390059900679007190073900899010790121901279014990163901739018790191901979019990203902179022790239902479026390271902819028990313903539035990371903739037990397904019040390407904379043990469904739048190499905119052390527905299053390547905839059990617906199063190641906479065990677906799069790703907099073190749907879079390803908219082390833908419084790863908879090190907909119091790931909479097190977909899099791009910199103391079910819109791099911219112791129911399114191151911539115991163911839119391199912299123791243912499125391283912919129791303913099133191367913699137391381913879139391397914119142391433914539145791459914639149391499915139152991541915719157391577915839159191621916319163991673916919170391711917339175391757917719178191801918079181191813918239183791841918679187391909919219193991943919519195791961919679196991997920039200992033920419205192077920839210792111921199214392153921739217792179921899220392219922219222792233922379224392251922699229792311923179233392347923539235792363923699237792381923839238792399924019241392419924319245992461924679247992489925039250792551925579256792569925819259392623926279263992641926479265792669926719268192683926939269992707927179272392737927539276192767927799278992791928019280992821928319284992857928619286392867928939289992921929279294192951929579295992987929939300193047930539305993077930839308993097931039311393131931339313993151931699317993187931999322993239932419325193253932579326393281932839328793307933199332393329933379337193377933839340793419934279346393479934819348793491934939349793503935239352993553935579355993563935819360193607936299363793683937019370393719937399376193763937879380993811938279385193871938879388993893939019391193913939239393793941939499396793971939799398393997940079400994033940499405794063940799409994109941119411794121941519415394169942019420794219942299425394261942739429194307943099432194327943319434394349943519437994397943999442194427944339443994441944479446394477944839451394529945319454194543945479455994561945739458394597946039461394621946499465194687946939470994723947279474794771947779478194789947939481194819948239483794841948479484994873948899490394907949339494994951949619499394999950039500995021950279506395071950839508795089950939510195107951119513195143951539517795189951919520395213952199523195233952399525795261952679527395279952879531195317953279533995369953839539395401954139541995429954419544395461954679547195479954839550795527955319553995549955619556995581955979560395617956219562995633956519570195707957139571795723957319573795747957739578395789957919580195803958139581995857958699587395881958919591195917959239592995947959579595995971959879598996001960139601796043960539605996079960979613796149961579616796179961819619996211962219622396233962599626396269962819628996293963239632996331963379635396377964019641996431964439645196457964619646996479964879649396497965179652796553965579658196587965899660196643966619666796671966979670396731967379673996749967579676396769967799678796797967999682196823968279684796851968579689396907969119693196953969599697396979969899699797001970039700797021970399707397081971039711797127971519715797159971699717197177971879721397231972419725997283973019730397327973679736997373973799738197387973979742397429974419745397459974639749997501975119752397547975499755397561975719757797579975839760797609976139764997651976739768797711977299777197777977879778997813978299784197843978479784997859978619787197879978839791997927979319794397961979679797397987980099801198017980419804798057980819810198123981299814398179982079821398221982279825198257982699829798299983179832198323983279834798369983779838798389984079841198419984299844398453984599846798473984799849198507985199853398543985619856398573985979862198627986399864198663986699868998711987139871798729987319873798773987799880198807988099883798849988679886998873988879889398897988999890998911989279892998939989479895398963989819899398999990139901799023990419905399079990839908999103991099911999131991339913799139991499917399181991919922399233992419925199257992599927799289993179934799349993679937199377993919939799401994099943199439994699948799497995239952799529995519955999563995719957799581996079961199623996439966199667996799968999707997099971399719997219973399761997679978799793998099981799823998299983399839998599987199877998819990199907999239992999961999719998999991100003100019100043100049100057100069100103100109100129100151100153100169100183100189100193100207100213100237100267100271100279100291100297100313100333100343100357100361100363100379100391100393100403100411100417100447100459100469100483100493100501100511100517100519100523100537100547100549100559100591100609100613100621100649100669100673100693100699100703100733100741100747100769100787100799100801100811100823100829100847100853100907100913100927100931100937100943100957100981100987100999101009101021101027101051101063101081101089101107101111101113101117101119101141101149101159101161101173101183101197101203101207101209101221101267101273101279101281101287101293101323101333101341101347101359101363101377101383101399101411101419101429101449101467101477101483101489101501101503101513101527101531101533101537101561101573101581101599101603101611101627101641101653101663101681101693101701101719101723101737101741101747101749101771101789101797101807101833101837101839101863101869101873101879101891101917101921101929101939101957101963101977101987101999102001102013102019102023102031102043102059102061102071102077102079102101102103102107102121102139102149102161102181102191102197102199102203102217102229102233102241102251102253102259102293102299102301102317102329102337102359102367102397102407102409102433102437102451102461102481102497102499102503102523102533102539102547102551102559102563102587102593102607102611102643102647102653102667102673102677102679102701102761102763102769102793102797102811102829102841102859102871102877102881102911102913102929102931102953102967102983103001103007103043103049103067103069103079103087103091103093103099103123103141103171103177103183103217103231103237103289103291103307103319103333103349103357103387103391103393103399103409103421103423103451103457103471103483103511103529103549103553103561103567103573103577103583103591103613103619103643103651103657103669103681103687103699103703103723103769103787103801103811103813103837103841103843103867103889103903103913103919103951103963103967103969103979103981103991103993103997104003104009104021104033104047104053104059104087104089104107104113104119104123104147104149104161104173104179104183104207104231104233104239104243104281104287104297104309104311104323104327104347104369104381104383104393104399104417104459104471104473104479104491104513104527104537104543104549104551104561104579104593104597104623104639104651104659104677104681104683104693104701104707104711104717104723104729104743104759104761104773104779104789104801104803104827104831104849104851104869104879104891104911104917104933104947104953104959104971104987104999105019105023105031105037105071105097105107105137105143105167105173105199105211105227105229105239105251105253105263105269105277105319105323105331105337105341105359105361105367105373105379105389105397105401105407105437105449105467105491105499105503105509105517105527105529105533105541105557105563105601105607105613105619105649105653105667105673105683105691105701105727105733105751105761105767105769105817105829105863105871105883105899105907105913105929105943105953105967105971105977105983105997106013106019106031106033106087106103106109106121106123106129106163106181106187106189106207106213106217106219106243106261106273106277106279106291106297106303106307106319106321106331106349106357106363106367106373106391106397106411106417106427106433106441106451106453106487106501106531106537106541106543106591106619106621106627106637106649106657106661106663106669106681106693106699106703106721106727106739106747106751106753106759106781106783106787106801106823106853106859106861106867106871106877106903106907106921106937106949106957106961106963106979106993107021107033107053107057107069107071107077107089107099107101107119107123107137107171107183107197107201107209107227107243107251107269107273107279107309107323107339107347107351107357107377107441107449107453107467107473107507107509107563107581107599107603107609107621107641107647107671107687107693107699107713107717107719107741107747107761107773107777107791107827107837107839107843107857107867107873107881107897107903107923107927107941107951107971107981107999108007108011108013108023108037108041108061108079108089108107108109108127108131108139108161108179108187108191108193108203108211108217108223108233108247108263108271108287108289108293108301108343108347108359108377108379108401108413108421108439108457108461108463108497108499108503108517108529108533108541108553108557108571108587108631108637108643108649108677108707108709108727108739108751108761108769108791108793108799108803108821108827108863108869108877108881108883108887108893108907108917108923108929108943108947108949108959108961108967108971108991109001109013109037109049109063109073109097109103109111109121109133109139109141109147109159109169109171109199109201109211109229109253109267109279109297109303109313109321109331109357109363109367109379109387109391109397109423109433109441109451109453109469109471109481109507109517109519109537109541109547109567109579109583109589109597109609109619109621109639109661109663109673109717109721109741109751109789109793109807109819109829109831109841109843109847109849109859109873109883109891109897109903109913109919109937109943109961109987110017110023110039110051110059110063110069110083110119110129110161110183110221110233110237110251110261110269110273110281110291110311110321110323110339110359110419110431110437110441110459110477110479110491110501110503110527110533110543110557110563110567110569110573110581110587110597110603110609110623110629110641110647110651110681110711110729110731110749110753110771110777110807110813110819110821110849110863110879110881110899110909110917110921110923110927110933110939110947110951110969110977110989111029111031111043111049111053111091111103111109111119111121111127111143111149111187111191111211111217111227111229111253111263111269111271111301111317111323111337111341111347111373111409111427111431111439111443111467111487111491111493111497111509111521111533111539111577111581111593111599111611111623111637111641111653111659111667111697111721111731111733111751111767111773111779111781111791111799111821111827111829111833111847111857111863111869111871111893111913111919111949111953111959111973111977111997112019112031112061112067112069112087112097112103112111112121112129112139112153112163112181112199112207112213112223112237112241112247112249112253112261112279112289112291112297112303112327112331112337112339112349112361112363112397112403112429112459112481112501112507112543112559112571112573112577112583112589112601112603112621112643112657112663112687112691112741112757112759112771112787112799112807112831112843112859112877112901112909112913112919112921112927112939112951112967112979112997113011113017113021113023113027113039113041113051113063113081113083113089113093113111113117113123113131113143113147113149113153113159113161113167113171113173113177113189113209113213113227113233113279113287113327113329113341113357113359113363113371113381113383113417113437113453113467113489113497113501113513113537113539113557113567113591113621113623113647113657113683113717113719113723113731113749113759113761113777113779113783113797113809113819113837113843113891113899113903113909113921113933113947113957113963113969113983113989114001114013114031114041114043114067114073114077114083114089114113114143114157114161114167114193114197114199114203114217114221114229114259114269114277114281114299114311114319114329114343114371114377114407114419114451114467114473114479114487114493114547114553114571114577114593114599114601114613114617114641114643114649114659114661114671114679114689114691114713114743114749114757114761114769114773114781114797114799114809114827114833114847114859114883114889114901114913114941114967114973114997115001115013115019115021115057115061115067115079115099115117115123115127115133115151115153115163115183115201115211115223115237115249115259115279115301115303115309115319115321115327115331115337115343115361115363115399115421115429115459115469115471115499115513115523115547115553115561115571115589115597115601115603115613115631115637115657115663115679115693115727115733115741115751115757115763115769115771115777115781115783115793115807115811115823115831115837115849115853115859115861115873115877115879115883115891115901115903115931115933115963115979115981115987116009116027116041116047116089116099116101116107116113116131116141116159116167116177116189116191116201116239116243116257116269116273116279116293116329116341116351116359116371116381116387116411116423116437116443116447116461116471116483116491116507116531116533116537116539116549116579116593116639116657116663116681116687116689116707116719116731116741116747116789116791116797116803116819116827116833116849116867116881116903116911116923116927116929116933116953116959116969116981116989116993117017117023117037117041117043117053117071117101117109117119117127117133117163117167117191117193117203117209117223117239117241117251117259117269117281117307117319117329117331117353117361117371117373117389117413117427117431117437117443117497117499117503117511117517117529117539117541117563117571117577117617117619117643117659117671117673117679117701117703117709117721117727117731117751117757117763117773117779117787117797117809117811117833117839117841117851117877117881117883117889117899117911117917117937117959117973117977117979117989117991118033118037118043118051118057118061118081118093118127118147118163118169118171118189118211118213118219118247118249118253118259118273118277118297118343118361118369118373118387118399118409118411118423118429118453118457118463118471118493118529118543118549118571118583118589118603118619118621118633118661118669118673118681118687118691118709118717118739118747118751118757118787118799118801118819118831118843118861118873118891118897118901118903118907118913118927118931118967118973119027119033119039119047119057119069119083119087119089119099119101119107119129119131119159119173119179119183119191119227119233119237119243119267119291119293119297119299119311119321119359119363119389119417119419119429119447119489119503119513119533119549119551119557119563119569119591119611119617119627119633119653119657119659119671119677119687119689119699119701119723119737119747119759119771119773119783119797119809119813119827119831119839119849119851119869119881119891119921119923119929119953119963119971119981119983119993120011120017120041120047120049120067120077120079120091120097120103120121120157120163120167120181120193120199120209120223120233120247120277120283120293120299120319120331120349120371120383120391120397120401120413120427120431120473120503120511120539120551120557120563120569120577120587120607120619120623120641120647120661120671120677120689120691120709120713120721120737120739120749120763120767120779120811120817120823120829120833120847120851120863120871120877120889120899120907120917120919120929120937120941120943120947120977120997121001121007121013121019121021121039121061121063121067121081121123121139121151121157121169121171121181121189121229121259121267121271121283121291121309121313121321121327121333121343121349121351121357121367121369121379121403121421121439121441121447121453121469121487121493121501121507121523121531121547121553121559121571121577121579121591121607121609121621121631121633121637121661121687121697121711121721121727121763121787121789121843121853121867121883121889121909121921121931121937121949121951121963121967121993121997122011122021122027122029122033122039122041122051122053122069122081122099122117122131122147122149122167122173122201122203122207122209122219122231122251122263122267122273122279122299122321122323122327122347122363122387122389122393122399122401122443122449122453122471122477122489122497122501122503122509122527122533122557122561122579122597122599122609122611122651122653122663122693122701122719122741122743122753122761122777122789122819122827122833122839122849122861122867122869122887122891122921122929122939122953122957122963122971123001123007123017123031123049123059123077123083123091123113123121123127123143123169123191123203123209123217123229123239123259123269123289123307123311123323123341123373123377123379123397123401123407123419123427123433123439123449123457123479123491123493123499123503123517123527123547123551123553123581123583123593123601123619123631123637123653123661123667123677123701123707123719123727123731123733123737123757123787123791123803123817123821123829123833123853123863123887123911123923123931123941123953123973123979123983123989123997124001124021124067124087124097124121124123124133124139124147124153124171124181124183124193124199124213124231124247124249124277124291124297124301124303124309124337124339124343124349124351124363124367124427124429124433124447124459124471124477124489124493124513124529124541124543124561124567124577124601124633124643124669124673124679124693124699124703124717124721124739124753124759124769124771124777124781124783124793124799124819124823124847124853124897124907124909124919124951124979124981124987124991125003125017125029125053125063125093125101125107125113125117125119125131125141125149125183125197125201125207125219125221125231125243125261125269125287125299125303125311125329125339125353125371125383125387125399125407125423125429125441125453125471125497125507125509125527125539125551125591125597125617125621125627125639125641125651125659125669125683125687125693125707125711125717125731125737125743125753125777125789125791125803125813125821125863125887125897125899125921125927125929125933125941125959125963126001126011126013126019126023126031126037126041126047126067126079126097126107126127126131126143126151126173126199126211126223126227126229126233126241126257126271126307126311126317126323126337126341126349126359126397126421126433126443126457126461126473126481126487126491126493126499126517126541126547126551126583126601126611126613126631126641126653126683126691126703126713126719126733126739126743126751126757126761126781126823126827126839126851126857126859126913126923126943126949126961126967126989127031127033127037127051127079127081127103127123127133127139127157127163127189127207127217127219127241127247127249127261127271127277127289127291127297127301127321127331127343127363127373127399127403127423127447127453127481127487127493127507127529127541127549127579127583127591127597127601127607127609127637127643127649127657127663127669127679127681127691127703127709127711127717127727127733127739127747127763127781127807127817127819127837127843127849127859127867127873127877127913127921127931127951127973127979127997128021128033128047128053128099128111128113128119128147128153128159128173128189128201128203128213128221128237128239128257128273128287128291128311128321128327128339128341128347128351128377128389128393128399128411128413128431128437128449128461128467128473128477128483128489128509128519128521128549128551128563128591128599128603128621128629128657128659128663128669128677128683128693128717128747128749128761128767128813128819128831128833128837128857128861128873128879128903128923128939128941128951128959128969128971128981128983128987128993129001129011129023129037129049129061129083129089129097129113129119129121129127129169129187129193129197129209129221129223129229129263129277129281129287129289129293129313129341129347129361129379129401129403129419129439129443129449129457129461129469129491129497129499129509129517129527129529129533129539129553129581129587129589129593129607129629129631129641129643129671129707129719129733129737129749129757129763129769129793129803129841129853129887129893129901129917129919129937129953129959129967129971130003130021130027130043130051130057130069130073130079130087130099130121130127130147130171130183130199130201130211130223130241130253130259130261130267130279130303130307130337130343130349130363130367130369130379130399130409130411130423130439130447130457130469130477130483130489130513130517130523130531130547130553130579130589130619130621130631130633130639130643130649130651130657130681130687130693130699130729130769130783130787130807130811130817130829130841130843130859130873130927130957130969130973130981130987131009131011131023131041131059131063131071131101131111131113131129131143131149131171131203131213131221131231131249131251131267131293131297131303131311131317131321131357131363131371131381131413131431131437131441131447131449131477131479131489131497131501131507131519131543131561131581131591131611131617131627131639131641131671131687131701131707131711131713131731131743131749131759131771131777131779131783131797131837131839131849131861131891131893131899131909131927131933131939131941131947131959131969132001132019132047132049132059132071132103132109132113132137132151132157132169132173132199132229132233132241132247132257132263132283132287132299132313132329132331132347132361132367132371132383132403132409132421132437132439132469132491132499132511132523132527132529132533132541132547132589132607132611132619132623132631132637132647132661132667132679132689132697132701132707132709132721132739132749132751132757132761132763132817132833132851132857132859132863132887132893132911132929132947132949132953132961132967132971132989133013133033133039133051133069133073133087133097133103133109133117133121133153133157133169133183133187133201133213133241133253133261133271133277133279133283133303133319133321133327133337133349133351133379133387133391133403133417133439133447133451133481133493133499133519133541133543133559133571133583133597133631133633133649133657133669133673133691133697133709133711133717133723133733133769133781133801133811133813133831133843133853133873133877133919133949133963133967133979133981133993133999134033134039134047134053134059134077134081134087134089134093134129134153134161134171134177134191134207134213134219134227134243134257134263134269134287134291134293134327134333134339134341134353134359134363134369134371134399134401134417134437134443134471134489134503134507134513134581134587134591134593134597134609134639134669134677134681134683134699134707134731134741134753134777134789134807134837134839134851134857134867134873134887134909134917134921134923134947134951134989134999135007135017135019135029135043135049135059135077135089135101135119135131135151135173135181135193135197135209135211135221135241135257135271135277135281135283135301135319135329135347135349135353135367135389135391135403135409135427135431135433135449135461135463135467135469135479135497135511135533135559135571135581135589135593135599135601135607135613135617135623135637135647135649135661135671135697135701135719135721135727135731135743135757135781135787135799135829135841135851135859135887135893135899135911135913135929135937135977135979136013136027136033136043136057136067136069136093136099136111136133136139136163136177136189136193136207136217136223136237136247136261136273136277136303136309136319136327136333136337136343136351136361136373136379136393136397136399136403136417136421136429136447136453136463136471136481136483136501136511136519136523136531136537136541136547136559136573136601136603136607136621136649136651136657136691136693136709136711136727136733136739136751136753136769136777136811136813136841136849136859136861136879136883136889136897136943136949136951136963136973136979136987136991136993136999137029137077137087137089137117137119137131137143137147137153137177137183137191137197137201137209137219137239137251137273137279137303137321137339137341137353137359137363137369137383137387137393137399137413137437137443137447137453137477137483137491137507137519137537137567137573137587137593137597137623137633137639137653137659137699137707137713137723137737137743137771137777137791137803137827137831137849137867137869137873137909137911137927137933137941137947137957137983137993137999138007138041138053138059138071138077138079138101138107138113138139138143138157138163138179138181138191138197138209138239138241138247138251138283138289138311138319138323138337138349138371138373138389138401138403138407138427138433138449138451138461138469138493138497138511138517138547138559138563138569138571138577138581138587138599138617138629138637138641138647138661138679138683138727138731138739138763138793138797138799138821138829138841138863138869138883138889138893138899138917138923138937138959138967138977139021139033139067139079139091139109139121139123139133139169139177139187139199139201139241139267139273139291139297139301139303139309139313139333139339139343139361139367139369139387139393139397139409139423139429139439139457139459139483139487139493139501139511139537139547139571139589139591139597139609139619139627139661139663139681139697139703139709139721139729139739139747139753139759139787139801139813139831139837139861139871139883139891139901139907139921139939139943139967139969139981139987139991139999140009140053140057140069140071140111140123140143140159140167140171140177140191140197140207140221140227140237140249140263140269140281140297140317140321140333140339140351140363140381140401140407140411140417140419140423140443140449140453140473140477140521140527140533140549140551140557140587140593140603140611140617140627140629140639140659140663140677140681140683140689140717140729140731140741140759140761140773140779140797140813140827140831140837140839140863140867140869140891140893140897140909140929140939140977140983140989141023141041141061141067141073141079141101141107141121141131141157141161141179141181141199141209141221141223141233141241141257141263141269141277141283141301141307141311141319141353141359141371141397141403141413141439141443141461141481141497141499141509141511141529141539141551141587141601141613141619141623141629141637141649141653141667141671141677141679141689141697141707141709141719141731141761141767141769141773141793141803141811141829141833141851141853141863141871141907141917141931141937141941141959141961141971141991142007142019142031142039142049142057142061142067142097142099142111142123142151142157142159142169142183142189142193142211142217142223142231142237142271142297142319142327142357142369142381142391142403142421142427142433142453142469142501142529142537142543142547142553142559142567142573142589142591142601142607142609142619142657142673142697142699142711142733142757142759142771142787142789142799142811142837142841142867142871142873142897142903142907142939142949142963142969142973142979142981142993143053143063143093143107143111143113143137143141143159143177143197143239143243143249143257143261143263143281143287143291143329143333143357143387143401143413143419143443143461143467143477143483143489143501143503143509143513143519143527143537143551143567143569143573143593143609143617143629143651143653143669143677143687143699143711143719143729143743143779143791143797143807143813143821143827143831143833143873143879143881143909143947143953143971143977143981143999144013144031144037144061144071144073144103144139144161144163144167144169144173144203144223144241144247144253144259144271144289144299144307144311144323144341144349144379144383144407144409144413144427144439144451144461144479144481144497144511144539144541144563144569144577144583144589144593144611144629144659144667144671144701144709144719144731144737144751144757144763144773144779144791144817144829144839144847144883144887144889144899144917144931144941144961144967144973144983145007145009145021145031145037145043145063145069145091145109145121145133145139145177145193145207145213145219145253145259145267145283145289145303145307145349145361145381145391145399145417145423145433145441145451145459145463145471145477145487145501145511145513145517145531145543145547145549145577145589145601145603145633145637145643145661145679145681145687145703145709145721145723145753145757145759145771145777145799145807145819145823145829145861145879145897145903145931145933145949145963145967145969145987145991146009146011146021146023146033146051146057146059146063146077146093146099146117146141146161146173146191146197146203146213146221146239146249146273146291146297146299146309146317146323146347146359146369146381146383146389146407146417146423146437146449146477146513146519146521146527146539146543146563146581146603146609146617146639146647146669146677146681146683146701146719146743146749146767146777146801146807146819146833146837146843146849146857146891146893146917146921146933146941146953146977146983146987146989147011147029147031147047147073147083147089147097147107147137147139147151147163147179147197147209147211147221147227147229147253147263147283147289147293147299147311147319147331147341147347147353147377147391147397147401147409147419147449147451147457147481147487147503147517147541147547147551147557147571147583147607147613147617147629147647147661147671147673147689147703147709147727147739147743147761147769147773147779147787147793147799147811147827147853147859147863147881147919147937147949147977147997148013148021148061148063148073148079148091148123148139148147148151148153148157148171148193148199148201148207148229148243148249148279148301148303148331148339148361148367148381148387148399148403148411148429148439148457148469148471148483148501148513148517148531148537148549148573148579148609148627148633148639148663148667148669148691148693148711148721148723148727148747148763148781148783148793148817148829148853148859148861148867148873148891148913148921148927148931148933148949148957148961148991148997149011149021149027149033149053149057149059149069149077149087149099149101149111149113149119149143149153149159149161149173149183149197149213149239149249149251149257149269149287149297149309149323149333149341149351149371149377149381149393149399149411149417149419149423149441149459149489149491149497149503149519149521149531149533149543149551149561149563149579149603149623149627149629149689149711149713149717149729149731149749149759149767149771149791149803149827149837149839149861149867149873149893149899149909149911149921149939149953149969149971149993150001150011150041150053150061150067150077150083150089150091150097150107150131150151150169150193150197150203150209150211150217150221150223150239150247150287150299150301150323150329150343150373150377150379150383150401150407150413150427150431150439150473150497150503150517150523150533150551150559150571150583150587150589150607150611150617150649150659150697150707150721150743150767150769150779150791150797150827150833150847150869150881150883150889150893150901150907150919150929150959150961150967150979150989150991151007151009151013151027151049151051151057151091151121151141151153151157151163151169151171151189151201151213151237151241151243151247151253151273151279151289151303151337151339151343151357151379151381151391151397151423151429151433151451151471151477151483151499151507151517151523151531151537151549151553151561151573151579151597151603151607151609151631151637151643151651151667151673151681151687151693151703151717151729151733151769151771151783151787151799151813151817151841151847151849151871151883151897151901151903151909151937151939151967151969152003152017152027152029152039152041152063152077152081152083152093152111152123152147152183152189152197152203152213152219152231152239152249152267152287152293152297152311152363152377152381152389152393152407152417152419152423152429152441152443152459152461152501152519152531152533152539152563152567152597152599152617152623152629152639152641152657152671152681152717152723152729152753152767152777152783152791152809152819152821152833152837152839152843152851152857152879152897152899152909152939152941152947152953152959152981152989152993153001153059153067153071153073153077153089153107153113153133153137153151153191153247153259153269153271153277153281153287153313153319153337153343153353153359153371153379153407153409153421153427153437153443153449153457153469153487153499153509153511153521153523153529153533153557153563153589153607153611153623153641153649153689153701153719153733153739153743153749153757153763153817153841153871153877153887153889153911153913153929153941153947153949153953153991153997154001154027154043154057154061154067154073154079154081154087154097154111154127154153154157154159154181154183154211154213154229154243154247154267154277154279154291154303154313154321154333154339154351154369154373154387154409154417154423154439154459154487154493154501154523154543154571154573154579154589154591154613154619154621154643154667154669154681154691154699154723154727154733154747154753154769154787154789154799154807154823154841154849154871154873154877154883154897154927154933154937154943154981154991155003155009155017155027155047155069155081155083155087155119155137155153155161155167155171155191155201155203155209155219155231155251155269155291155299155303155317155327155333155371155377155381155383155387155399155413155423155443155453155461155473155501155509155521155537155539155557155569155579155581155593155599155609155621155627155653155657155663155671155689155693155699155707155717155719155723155731155741155747155773155777155783155797155801155809155821155833155849155851155861155863155887155891155893155921156007156011156019156041156059156061156071156089156109156119156127156131156139156151156157156217156227156229156241156253156257156259156269156307156319156329156347156353156361156371156419156421156437156467156487156491156493156511156521156539156577156589156593156601156619156623156631156641156659156671156677156679156683156691156703156707156719156727156733156749156781156797156799156817156823156833156841156887156899156901156913156941156943156967156971156979157007157013157019157037157049157051157057157061157081157103157109157127157133157141157163157177157181157189157207157211157217157219157229157231157243157247157253157259157271157273157277157279157291157303157307157321157327157349157351157363157393157411157427157429157433157457157477157483157489157513157519157523157543157559157561157571157579157627157637157639157649157667157669157679157721157733157739157747157769157771157793157799157813157823157831157837157841157867157877157889157897157901157907157931157933157951157991157999158003158009158017158029158047158071158077158113158129158141158143158161158189158201158209158227158231158233158243158261158269158293158303158329158341158351158357158359158363158371158393158407158419158429158443158449158489158507158519158527158537158551158563158567158573158581158591158597158611158617158621158633158647158657158663158699158731158747158749158759158761158771158777158791158803158843158849158863158867158881158909158923158927158941158959158981158993159013159017159023159059159073159079159097159113159119159157159161159167159169159179159191159193159199159209159223159227159233159287159293159311159319159337159347159349159361159389159403159407159421159431159437159457159463159469159473159491159499159503159521159539159541159553159563159569159571159589159617159623159629159631159667159671159673159683159697159701159707159721159737159739159763159769159773159779159787159791159793159799159811159833159839159853159857159869159871159899159911159931159937159977159979160001160009160019160031160033160049160073160079160081160087160091160093160117160141160159160163160169160183160201160207160217160231160243160253160309160313160319160343160357160367160373160387160397160403160409160423160441160453160481160483160499160507160541160553160579160583160591160603160619160621160627160637160639160649160651160663160669160681160687160697160709160711160723160739160751160753160757160781160789160807160813160817160829160841160861160877160879160883160903160907160933160967160969160981160997161009161017161033161039161047161053161059161071161087161093161123161137161141161149161159161167161201161221161233161237161263161267161281161303161309161323161333161339161341161363161377161387161407161411161453161459161461161471161503161507161521161527161531161543161561161563161569161573161591161599161611161627161639161641161659161683161717161729161731161741161743161753161761161771161773161779161783161807161831161839161869161873161879161881161911161921161923161947161957161969161971161977161983161999162007162011162017162053162059162079162091162109162119162143162209162221162229162251162257162263162269162277162287162289162293162343162359162389162391162413162419162439162451162457162473162493162499162517162523162527162529162553162557162563162577162593162601162611162623162629162641162649162671162677162683162691162703162709162713162727162731162739162749162751162779162787162791162821162823162829162839162847162853162859162881162889162901162907162917162937162947162971162973162989162997163003163019163021163027163061163063163109163117163127163129163147163151163169163171163181163193163199163211163223163243163249163259163307163309163321163327163337163351163363163367163393163403163409163411163417163433163469163477163481163483163487163517163543163561163567163573163601163613163621163627163633163637163643163661163673163679163697163729163733163741163753163771163781163789163811163819163841163847163853163859163861163871163883163901163909163927163973163979163981163987163991163993163997164011164023164039164051164057164071164089164093164113164117164147164149164173164183164191164201164209164231164233164239164249164251164267164279164291164299164309164321164341164357164363164371164377164387164413164419164429164431164443164447164449164471164477164503164513164531164569164581164587164599164617164621164623164627164653164663164677164683164701164707164729164743164767164771164789164809164821164831164837164839164881164893164911164953164963164987164999165001165037165041165047165049165059165079165083165089165103165133165161165173165181165203165211165229165233165247165287165293165311165313165317165331165343165349165367165379165383165391165397165437165443165449165457165463165469165479165511165523165527165533165541165551165553165559165569165587165589165601165611165617165653165667165673165701165703165707165709165713165719165721165749165779165799165811165817165829165833165857165877165883165887165901165931165941165947165961165983166013166021166027166031166043166063166081166099166147166151166157166169166183166189166207166219166237166247166259166273166289166297166301166303166319166349166351166357166363166393166399166403166409166417166429166457166471166487166541166561166567166571166597166601166603166609166613166619166627166631166643166657166667166669166679166693166703166723166739166741166781166783166799166807166823166841166843166847166849166853166861166867166871166909166919166931166949166967166973166979166987167009167017167021167023167033167039167047167051167071167077167081167087167099167107167113167117167119167149167159167173167177167191167197167213167221167249167261167267167269167309167311167317167329167339167341167381167393167407167413167423167429167437167441167443167449167471167483167491167521167537167543167593167597167611167621167623167627167633167641167663167677167683167711167729167747167759167771167777167779167801167809167861167863167873167879167887167891167899167911167917167953167971167987168013168023168029168037168043168067168071168083168089168109168127168143168151168193168197168211168227168247168253168263168269168277168281168293168323168331168347168353168391168409168433168449168451168457168463168481168491168499168523168527168533168541168559168599168601168617168629168631168643168673168677168697168713168719168731168737168743168761168769168781168803168851168863168869168887168893168899168901168913168937168943168977168991169003169007169009169019169049169063169067169069169079169093169097169111169129169151169159169177169181169199169217169219169241169243169249169259169283169307169313169319169321169327169339169343169361169369169373169399169409169427169457169471169483169489169493169501169523169531169553169567169583169591169607169627169633169639169649169657169661169667169681169691169693169709169733169751169753169769169777169783169789169817169823169831169837169843169859169889169891169909169913169919169933169937169943169951169957169987169991170003170021170029170047170057170063170081170099170101170111170123170141170167170179170189170197170207170213170227170231170239170243170249170263170267170279170293170299170327170341170347170351170353170363170369170371170383170389170393170413170441170447170473170483170497170503170509170537170539170551170557170579170603170609170627170633170641170647170669170689170701170707170711170741170749170759170761170767170773170777170801170809170813170827170837170843170851170857170873170881170887170899170921170927170953170957170971171007171023171029171043171047171049171053171077171079171091171103171131171161171163171167171169171179171203171233171251171253171263171271171293171299171317171329171341171383171401171403171427171439171449171467171469171473171481171491171517171529171539171541171553171559171571171583171617171629171637171641171653171659171671171673171679171697171707171713171719171733171757171761171763171793171799171803171811171823171827171851171863171869171877171881171889171917171923171929171937171947172001172009172021172027172031172049172069172079172093172097172127172147172153172157172169172171172181172199172213172217172219172223172243172259172279172283172297172307172313172321172331172343172351172357172373172399172411172421172423172427172433172439172441172489172507172517172519172541172553172561172573172583172589172597172603172607172619172633172643172649172657172663172673172681172687172709172717172721172741172751172759172787172801172807172829172849172853172859172867172871172877172883172933172969172973172981172987172993172999173021173023173039173053173059173081173087173099173137173141173149173177173183173189173191173207173209173219173249173263173267173273173291173293173297173309173347173357173359173429173431173473173483173491173497173501173531173539173543173549173561173573173599173617173629173647173651173659173669173671173683173687173699173707173713173729173741173743173773173777173779173783173807173819173827173839173851173861173867173891173897173909173917173923173933173969173977173981173993174007174017174019174047174049174061174067174071174077174079174091174101174121174137174143174149174157174169174197174221174241174257174259174263174281174289174299174311174329174331174337174347174367174389174407174413174431174443174457174467174469174481174487174491174527174533174569174571174583174599174613174617174631174637174649174653174659174673174679174703174721174737174749174761174763174767174773174799174821174829174851174859174877174893174901174907174917174929174931174943174959174989174991175003175013175039175061175067175069175079175081175103175129175141175211175229175261175267175277175291175303175309175327175333175349175361175391175393175403175411175433175447175453175463175481175493175499175519175523175543175573175601175621175631175633175649175663175673175687175691175699175709175723175727175753175757175759175781175783175811175829175837175843175853175859175873175891175897175909175919175937175939175949175961175963175979175991175993176017176021176023176041176047176051176053176063176081176087176089176123176129176153176159176161176179176191176201176207176213176221176227176237176243176261176299176303176317176321176327176329176333176347176353176357176369176383176389176401176413176417176419176431176459176461176467176489176497176503176507176509176521176531176537176549176551176557176573176591176597176599176609176611176629176641176651176677176699176711176713176741176747176753176777176779176789176791176797176807176809176819176849176857176887176899176903176921176923176927176933176951176977176983176989177007177011177013177019177043177091177101177109177113177127177131177167177173177209177211177217177223177239177257177269177283177301177319177323177337177347177379177383177409177421177427177431177433177467177473177481177487177493177511177533177539177553177589177601177623177647177677177679177691177739177743177761177763177787177791177797177811177823177839177841177883177887177889177893177907177913177917177929177943177949177953177967177979178001178021178037178039178067178069178091178093178103178117178127178141178151178169178183178187178207178223178231178247178249178259178261178289178301178307178327178333178349178351178361178393178397178403178417178439178441178447178469178481178487178489178501178513178531178537178559178561178567178571178597178601178603178609178613178621178627178639178643178681178691178693178697178753178757178781178793178799178807178813178817178819178831178853178859178873178877178889178897178903178907178909178921178931178933178939178951178973178987179021179029179033179041179051179057179083179089179099179107179111179119179143179161179167179173179203179209179213179233179243179261179269179281179287179317179321179327179351179357179369179381179383179393179407179411179429179437179441179453179461179471179479179483179497179519179527179533179549179563179573179579179581179591179593179603179623179633179651179657179659179671179687179689179693179717179719179737179743179749179779179801179807179813179819179821179827179833179849179897179899179903179909179917179923179939179947179951179953179957179969179981179989179999180001180007180023180043180053180071180073180077180097180137180161180179180181180211180221180233180239180241180247180259180263180281180287180289180307180311180317180331180337180347180361180371180379180391180413180419180437180463180473180491180497180503180511180533180539180541180547180563180569180617180623180629180647180667180679180701180731180749180751180773180779180793180797180799180811180847180871180883180907180949180959181001181003181019181031181039181061181063181081181087181123181141181157181183181193181199181201181211181213181219181243181253181273181277181283181297181301181303181361181387181397181399181409181421181439181457181459181499181501181513181523181537181549181553181603181607181609181619181639181667181669181693181711181717181721181729181739181751181757181759181763181777181787181789181813181837181871181873181889181891181903181913181919181927181931181943181957181967181981181997182009182011182027182029182041182047182057182059182089182099182101182107182111182123182129182131182141182159182167182177182179182201182209182233182239182243182261182279182297182309182333182339182341182353182387182389182417182423182431182443182453182467182471182473182489182503182509182519182537182549182561182579182587182593182599182603182617182627182639182641182653182657182659182681182687182701182711182713182747182773182779182789182803182813182821182839182851182857182867182887182893182899182921182927182929182933182953182957182969182981182999183023183037183041183047183059183067183089183091183119183151183167183191183203183247183259183263183283183289183299183301183307183317183319183329183343183349183361183373183377183383183389183397183437183439183451183461183473183479183487183497183499183503183509183511183523183527183569183571183577183581183587183593183611183637183661183683183691183697183707183709183713183761183763183797183809183823183829183871183877183881183907183917183919183943183949183959183971183973183979184003184007184013184031184039184043184057184073184081184087184111184117184133184153184157184181184187184189184199184211184231184241184259184271184273184279184291184309184321184333184337184351184369184409184417184441184447184463184477184487184489184511184517184523184553184559184567184571184577184607184609184627184631184633184649184651184669184687184693184703184711184721184727184733184753184777184823184829184831184837184843184859184879184901184903184913184949184957184967184969184993184997184999185021185027185051185057185063185069185071185077185089185099185123185131185137185149185153185161185167185177185183185189185221185233185243185267185291185299185303185309185323185327185359185363185369185371185401185429185441185467185477185483185491185519185527185531185533185539185543185551185557185567185569185593185599185621185641185651185677185681185683185693185699185707185711185723185737185747185749185753185767185789185797185813185819185821185831185833185849185869185873185893185897185903185917185923185947185951185957185959185971185987185993186007186013186019186023186037186041186049186071186097186103186107186113186119186149186157186161186163186187186191186211186227186229186239186247186253186259186271186283186299186301186311186317186343186377186379186391186397186419186437186451186469186479186481186551186569186581186583186587186601186619186629186647186649186653186671186679186689186701186707186709186727186733186743186757186761186763186773186793186799186841186859186869186871186877186883186889186917186947186959187003187009187027187043187049187067187069187073187081187091187111187123187127187129187133187139187141187163187171187177187181187189187193187211187217187219187223187237187273187277187303187337187339187349187361187367187373187379187387187393187409187417187423187433187441187463187469187471187477187507187513187531187547187559187573187597187631187633187637187639187651187661187669187687187699187711187721187751187763187787187793187823187843187861187871187877187883187897187907187909187921187927187931187951187963187973187987188011188017188021188029188107188137188143188147188159188171188179188189188197188249188261188273188281188291188299188303188311188317188323188333188351188359188369188389188401188407188417188431188437188443188459188473188483188491188519188527188533188563188579188603188609188621188633188653188677188681188687188693188701188707188711188719188729188753188767188779188791188801188827188831188833188843188857188861188863188869188891188911188927188933188939188941188953188957188983188999189011189017189019189041189043189061189067189127189139189149189151189169189187189199189223189229189239189251189253189257189271189307189311189337189347189349189353189361189377189389189391189401189407189421189433189437189439189463189467189473189479189491189493189509189517189523189529189547189559189583189593189599189613189617189619189643189653189661189671189691189697189701189713189733189743189757189767189797189799189817189823189851189853189859189877189881189887189901189913189929189947189949189961189967189977189983189989189997190027190031190051190063190093190097190121190129190147190159190181190207190243190249190261190271190283190297190301190313190321190331190339190357190367190369190387190391190403190409190471190507190523190529190537190543190573190577190579190583190591190607190613190633190639190649190657190667190669190699190709190711190717190753190759190763190769190783190787190793190807190811190823190829190837190843190871190889190891190901190909190913190921190979190997191021191027191033191039191047191057191071191089191099191119191123191137191141191143191161191173191189191227191231191237191249191251191281191297191299191339191341191353191413191441191447191449191453191459191461191467191473191491191497191507191509191519191531191533191537191551191561191563191579191599191621191627191657191669191671191677191689191693191699191707191717191747191749191773191783191791191801191803191827191831191833191837191861191899191903191911191929191953191969191977191999192007192013192029192037192043192047192053192091192097192103192113192121192133192149192161192173192187192191192193192229192233192239192251192259192263192271192307192317192319192323192341192343192347192373192377192383192391192407192431192461192463192497192499192529192539192547192553192557192571192581192583192587192601192611192613192617192629192631192637192667192677192697192737192743192749192757192767192781192791192799192811192817192833192847192853192859192877192883192887192889192917192923192931192949192961192971192977192979192991193003193009193013193031193043193051193057193073193093193133193139193147193153193163193181193183193189193201193243193247193261193283193301193327193337193357193367193373193379193381193387193393193423193433193441193447193451193463193469193493193507193513193541193549193559193573193577193597193601193603193607193619193649193663193679193703193723193727193741193751193757193763193771193789193793193799193811193813193841193847193859193861193871193873193877193883193891193937193939193943193951193957193979193993194003194017194027194057194069194071194083194087194093194101194113194119194141194149194167194179194197194203194239194263194267194269194309194323194353194371194377194413194431194443194471194479194483194507194521194527194543194569194581194591194609194647194653194659194671194681194683194687194707194713194717194723194729194749194767194771194809194813194819194827194839194861194863194867194869194891194899194911194917194933194963194977194981194989195023195029195043195047195049195053195071195077195089195103195121195127195131195137195157195161195163195193195197195203195229195241195253195259195271195277195281195311195319195329195341195343195353195359195389195401195407195413195427195443195457195469195479195493195497195511195527195539195541195581195593195599195659195677195691195697195709195731195733195737195739195743195751195761195781195787195791195809195817195863195869195883195887195893195907195913195919195929195931195967195971195973195977195991195997196003196033196039196043196051196073196081196087196111196117196139196159196169196171196177196181196187196193196201196247196271196277196279196291196303196307196331196337196379196387196429196439196453196459196477196499196501196519196523196541196543196549196561196579196583196597196613196643196657196661196663196681196687196699196709196717196727196739196751196769196771196799196817196831196837196853196871196873196879196901196907196919196927196961196991196993197003197009197023197033197059197063197077197083197089197101197117197123197137197147197159197161197203197207197221197233197243197257197261197269197273197279197293197297197299197311197339197341197347197359197369197371197381197383197389197419197423197441197453197479197507197521197539197551197567197569197573197597197599197609197621197641197647197651197677197683197689197699197711197713197741197753197759197767197773197779197803197807197831197837197887197891197893197909197921197927197933197947197957197959197963197969197971198013198017198031198043198047198073198083198091198097198109198127198139198173198179198193198197198221198223198241198251198257198259198277198281198301198313198323198337198347198349198377198391198397198409198413198427198437198439198461198463198469198479198491198503198529198533198553198571198589198593198599198613198623198637198641198647198659198673198689198701198719198733198761198769198811198817198823198827198829198833198839198841198851198859198899198901198929198937198941198943198953198959198967198971198977198997199021199033199037199039199049199081199103199109199151199153199181199193199207199211199247199261199267199289199313199321199337199343199357199373199379199399199403199411199417199429199447199453199457199483199487199489199499199501199523199559199567199583199601199603199621199637199657199669199673199679199687199697199721199729199739199741199751199753199777199783199799199807199811199813199819199831199853199873199877199889199909199921199931199933199961199967199999200003200009200017200023200029200033200041200063200087200117200131200153200159200171200177200183200191200201200227200231200237200257200273200293200297200323200329200341200351200357200363200371200381200383200401200407200437200443200461200467200483200513200569200573200579200587200591200597200609200639200657200671200689200699200713200723200731200771200779200789200797200807200843200861200867200869200881200891200899200903200909200927200929200971200983200987200989201007201011201031201037201049201073201101201107201119201121201139201151201163201167201193201203201209201211201233201247201251201281201287201307201329201337201359201389201401201403201413201437201449201451201473201491201493201497201499201511201517201547201557201577201581201589201599201611201623201629201653201661201667201673201683201701201709201731201743201757201767201769201781201787201791201797201809201821201823201827201829201833201847201881201889201893201907201911201919201923201937201947201953201961201973201979201997202001202021202031202049202061202063202067202087202099202109202121202127202129202183202187202201202219202231202243202277202289202291202309202327202339202343202357202361202381202387202393202403202409202441202471202481202493202519202529202549202567202577202591202613202621202627202637202639202661202667202679202693202717202729202733202747202751202753202757202777202799202817202823202841202859202877202879202889202907202921202931202933202949202967202973202981202987202999203011203017203023203039203051203057203117203141203173203183203207203209203213203221203227203233203249203279203293203309203311203317203321203323203339203341203351203353203363203381203383203387203393203417203419203429203431203449203459203461203531203549203563203569203579203591203617203627203641203653203657203659203663203669203713203761203767203771203773203789203807203809203821203843203857203869203873203897203909203911203921203947203953203969203971203977203989203999204007204013204019204023204047204059204067204101204107204133204137204143204151204161204163204173204233204251204299204301204311204319204329204331204353204359204361204367204371204377204397204427204431204437204439204443204461204481204487204509204511204517204521204557204563204583204587204599204601204613204623204641204667204679204707204719204733204749204751204781204791204793204797204803204821204857204859204871204887204913204917204923204931204947204973204979204983205019205031205033205043205063205069205081205097205103205111205129205133205141205151205157205171205187205201205211205213205223205237205253205267205297205307205319205327205339205357205391205397205399205417205421205423205427205433205441205453205463205477205483205487205493205507205519205529205537205549205553205559205589205603205607205619205627205633205651205657205661205663205703205721205759205763205783205817205823205837205847205879205883205913205937205949205951205957205963205967205981205991205993206009206021206027206033206039206047206051206069206077206081206083206123206153206177206179206183206191206197206203206209206221206233206237206249206251206263206273206279206281206291206299206303206341206347206351206369206383206399206407206411206413206419206447206461206467206477206483206489206501206519206527206543206551206593206597206603206623206627206639206641206651206699206749206779206783206803206807206813206819206821206827206879206887206897206909206911206917206923206933206939206951206953206993207013207017207029207037207041207061207073207079207113207121207127207139207169207187207191207197207199207227207239207241207257207269207287207293207301207307207329207331207341207343207367207371207377207401207409207433207443207457207463207469207479207481207491207497207509207511207517207521207523207541207547207551207563207569207589207593207619207629207643207653207661207671207673207679207709207719207721207743207763207769207797207799207811207821207833207847207869207877207923207931207941207947207953207967207971207973207997208001208003208009208037208049208057208067208073208099208111208121208129208139208141208147208189208207208213208217208223208231208253208261208277208279208283208291208309208319208333208337208367208379208387208391208393208409208433208441208457208459208463208469208489208493208499208501208511208513208519208529208553208577208589208591208609208627208631208657208667208673208687208697208699208721208729208739208759208787208799208807208837208843208877208889208891208907208927208931208933208961208963208991208993208997209021209029209039209063209071209089209123209147209159209173209179209189209201209203209213209221209227209233209249209257209263209267209269209299209311209317209327209333209347209353209357209359209371209381209393209401209431209441209449209459209471209477209497209519209533209543209549209563209567209569209579209581209597209621209623209639209647209659209669209687209701209707209717209719209743209767209771209789209801209809209813209819209821209837209851209857209861209887209917209927209929209939209953209959209971209977209983209987210011210019210031210037210053210071210097210101210109210113210127210131210139210143210157210169210173210187210191210193210209210229210233210241210247210257210263210277210283210299210317210319210323210347210359210361210391210401210403210407210421210437210461210467210481210487210491210499210523210527210533210557210599210601210619210631210643210659210671210709210713210719210731210739210761210773210803210809210811210823210827210839210853210857210869210901210907210911210913210923210929210943210961210967211007211039211049211051211061211063211067211073211093211097211129211151211153211177211187211193211199211213211217211219211229211231211241211247211271211283211291211297211313211319211333211339211349211369211373211403211427211433211441211457211469211493211499211501211507211543211559211571211573211583211597211619211639211643211657211661211663211681211691211693211711211723211727211741211747211777211781211789211801211811211817211859211867211873211877211879211889211891211927211931211933211943211949211969211979211997212029212039212057212081212099212117212123212131212141212161212167212183212203212207212209212227212239212243212281212293212297212353212369212383212411212419212423212437212447212453212461212467212479212501212507212557212561212573212579212587212593212627212633212651212669212671212677212683212701212777212791212801212827212837212843212851212867212869212873212881212897212903212909212917212923212969212981212987212999213019213023213029213043213067213079213091213097213119213131213133213139213149213173213181213193213203213209213217213223213229213247213253213263213281213287213289213307213319213329213337213349213359213361213383213391213397213407213449213461213467213481213491213523213533213539213553213557213589213599213611213613213623213637213641213649213659213713213721213727213737213751213791213799213821213827213833213847213859213881213887213901213919213929213943213947213949213953213973213977213989214003214007214009214021214031214033214043214051214063214069214087214091214129214133214141214147214163214177214189214211214213214219214237214243214259214283214297214309214351214363214373214381214391214399214433214439214451214457214463214469214481214483214499214507214517214519214531214541214559214561214589214603214607214631214639214651214657214663214667214673214691214723214729214733214741214759214763214771214783214787214789214807214811214817214831214849214853214867214883214891214913214939214943214967214987214993215051215063215077215087215123215141215143215153215161215179215183215191215197215239215249215261215273215279215297215309215317215329215351215353215359215381215389215393215399215417215443215447215459215461215471215483215497215503215507215521215531215563215573215587215617215653215659215681215687215689215693215723215737215753215767215771215797215801215827215833215843215851215857215863215893215899215909215921215927215939215953215959215981215983216023216037216061216071216091216103216107216113216119216127216133216149216157216173216179216211216217216233216259216263216289216317216319216329216347216371216373216379216397216401216421216431216451216481216493216509216523216551216553216569216571216577216607216617216641216647216649216653216661216679216703216719216731216743216751216757216761216779216781216787216791216803216829216841216851216859216877216899216901216911216917216919216947216967216973216991217001217003217027217033217057217069217081217111217117217121217157217163217169217199217201217207217219217223217229217241217253217271217307217309217313217319217333217337217339217351217361217363217367217369217387217397217409217411217421217429217439217457217463217489217499217517217519217559217561217573217577217579217619217643217661217667217681217687217691217697217717217727217733217739217747217771217781217793217823217829217849217859217901217907217909217933217937217969217979217981218003218021218047218069218077218081218083218087218107218111218117218131218137218143218149218171218191218213218227218233218249218279218287218357218363218371218381218389218401218417218419218423218437218447218453218459218461218479218509218513218521218527218531218549218551218579218591218599218611218623218627218629218641218651218657218677218681218711218717218719218723218737218749218761218783218797218809218819218833218839218843218849218857218873218887218923218941218947218963218969218971218987218989218993219001219017219019219031219041219053219059219071219083219091219097219103219119219133219143219169219187219217219223219251219277219281219293219301219311219313219353219361219371219377219389219407219409219433219437219451219463219467219491219503219517219523219529219533219547219577219587219599219607219613219619219629219647219649219677219679219683219689219707219721219727219731219749219757219761219763219767219787219797219799219809219823219829219839219847219851219871219881219889219911219917219931219937219941219943219953219959219971219977219979219983220009220013220019220021220057220063220123220141220147220151220163220169220177220189220217220243220279220291220301220307220327220333220351220357220361220369220373220391220399220403220411220421220447220469220471220511220513220529220537220543220553220559220573220579220589220613220663220667220673220681220687220699220709220721220747220757220771220783220789220793220807220811220841220859220861220873220877220879220889220897220901220903220907220919220931220933220939220973221021221047221059221069221071221077221083221087221093221101221159221171221173221197221201221203221209221219221227221233221239221251221261221281221303221311221317221327221393221399221401221411221413221447221453221461221471221477221489221497221509221537221539221549221567221581221587221603221621221623221653221657221659221671221677221707221713221717221719221723221729221737221747221773221797221807221813221827221831221849221873221891221909221941221951221953221957221987221989221999222007222011222023222029222041222043222059222067222073222107222109222113222127222137222149222151222161222163222193222197222199222247222269222289222293222311222317222323222329222337222347222349222361222367222379222389222403222419222437222461222493222499222511222527222533222553222557222587222601222613222619222643222647222659222679222707222713222731222773222779222787222791222793222799222823222839222841222857222863222877222883222913222919222931222941222947222953222967222977222979222991223007223009223019223037223049223051223061223063223087223099223103223129223133223151223207223211223217223219223229223241223243223247223253223259223273223277223283223291223303223313223319223331223337223339223361223367223381223403223423223429223439223441223463223469223481223493223507223529223543223547223549223577223589223621223633223637223667223679223681223697223711223747223753223757223759223781223823223829223831223837223841223843223849223903223919223921223939223963223969223999224011224027224033224041224047224057224069224071224101224113224129224131224149224153224171224177224197224201224209224221224233224239224251224261224267224291224299224303224309224317224327224351224359224363224401224423224429224443224449224461224467224473224491224501224513224527224563224569224579224591224603224611224617224629224633224669224677224683224699224711224717224729224737224743224759224771224797224813224831224863224869224881224891224897224909224911224921224929224947224951224969224977224993225023225037225061225067225077225079225089225109225119225133225143225149225157225161225163225167225217225221225223225227225241225257225263225287225289225299225307225341225343225347225349225353225371225373225383225427225431225457225461225479225493225499225503225509225523225527225529225569225581225583225601225611225613225619225629225637225671225683225689225697225721225733225749225751225767225769225779225781225809225821225829225839225859225871225889225919225931225941225943225949225961225977225983225989226001226007226013226027226063226087226099226103226123226129226133226141226169226183226189226199226201226217226231226241226267226283226307226313226337226357226367226379226381226397226409226427226433226451226453226463226483226487226511226531226547226549226553226571226601226609226621226631226637226643226649226657226663226669226691226697226741226753226769226777226783226789226799226813226817226819226823226843226871226901226903226907226913226937226943226991227011227027227053227081227089227093227111227113227131227147227153227159227167227177227189227191227207227219227231227233227251227257227267227281227299227303227363227371227377227387227393227399227407227419227431227453227459227467227471227473227489227497227501227519227531227533227537227561227567227569227581227593227597227603227609227611227627227629227651227653227663227671227693227699227707227719227729227743227789227797227827227849227869227873227893227947227951227977227989227993228013228023228049228061228077228097228103228113228127228131228139228181228197228199228203228211228223228233228251228257228281228299228301228307228311228331228337228341228353228359228383228409228419228421228427228443228451228457228461228469228479228509228511228517228521228523228539228559228577228581228587228593228601228611228617228619228637228647228677228707228713228731228733228737228751228757228773228793228797228799228829228841228847228853228859228869228881228883228887228901228911228913228923228929228953228959228961228983228989229003229027229037229081229093229123229127229133229139229153229157229171229181229189229199229213229217229223229237229247229249229253229261229267229283229309229321229343229351229373229393229399229403229409229423229433229459229469229487229499229507229519229529229547229549229553229561229583229589229591229601229613229627229631229637229639229681229693229699229703229711229717229727229739229751229753229759229763229769229771229777229781229799229813229819229837229841229847229849229897229903229937229939229949229961229963229979229981230003230017230047230059230063230077230081230089230101230107230117230123230137230143230149230189230203230213230221230227230233230239230257230273230281230291230303230309230311230327230339230341230353230357230369230383230387230389230393230431230449230453230467230471230479230501230507230539230551230561230563230567230597230611230647230653230663230683230693230719230729230743230761230767230771230773230779230807230819230827230833230849230861230863230873230891230929230933230939230941230959230969230977230999231001231017231019231031231041231053231067231079231107231109231131231169231197231223231241231269231271231277231289231293231299231317231323231331231347231349231359231367231379231409231419231431231433231443231461231463231479231481231493231503231529231533231547231551231559231563231571231589231599231607231611231613231631231643231661231677231701231709231719231779231799231809231821231823231827231839231841231859231871231877231893231901231919231923231943231947231961231967232003232007232013232049232051232073232079232081232091232103232109232117232129232153232171232187232189232207232217232259232303232307232333232357232363232367232381232391232409232411232417232433232439232451232457232459232487232499232513232523232549232567232571232591232597232607232621232633232643232663232669232681232699232709232711232741232751232753232777232801232811232819232823232847232853232861232871232877232891232901232907232919232937232961232963232987233021233069233071233083233113233117233141233143233159233161233173233183233201233221233231233239233251233267233279233293233297233323233327233329233341233347233353233357233371233407233417233419233423233437233477233489233509233549233551233557233591233599233609233617233621233641233663233669233683233687233689233693233713233743233747233759233777233837233851233861233879233881233911233917233921233923233939233941233969233983233993234007234029234043234067234083234089234103234121234131234139234149234161234167234181234187234191234193234197234203234211234217234239234259234271234281234287234293234317234319234323234331234341234343234361234383234431234457234461234463234467234473234499234511234527234529234539234541234547234571234587234589234599234613234629234653234659234673234683234713234721234727234733234743234749234769234781234791234799234803234809234811234833234847234851234863234869234893234907234917234931234947234959234961234967234977234979234989235003235007235009235013235043235051235057235069235091235099235111235117235159235171235177235181235199235211235231235241235243235273235289235307235309235337235349235369235397235439235441235447235483235489235493235513235519235523235537235541235553235559235577235591235601235607235621235661235663235673235679235699235723235747235751235783235787235789235793235811235813235849235871235877235889235891235901235919235927235951235967235979235997236017236021236053236063236069236077236087236107236111236129236143236153236167236207236209236219236231236261236287236293236297236323236329236333236339236377236381236387236399236407236429236449236461236471236477236479236503236507236519236527236549236563236573236609236627236641236653236659236681236699236701236707236713236723236729236737236749236771236773236779236783236807236813236867236869236879236881236891236893236897236909236917236947236981236983236993237011237019237043237053237067237071237073237089237091237137237143237151237157237161237163237173237179237203237217237233237257237271237277237283237287237301237313237319237331237343237361237373237379237401237409237467237487237509237547237563237571237581237607237619237631237673237683237689237691237701237707237733237737237749237763237767237781237791237821237851237857237859237877237883237901237911237929237959237967237971237973237977237997238001238009238019238031238037238039238079238081238093238099238103238109238141238151238157238159238163238171238181238201238207238213238223238229238237238247238261238267238291238307238313238321238331238339238361238363238369238373238397238417238423238439238451238463238471238477238481238499238519238529238531238547238573238591238627238639238649238657238673238681238691238703238709238723238727238729238747238759238781238789238801238829238837238841238853238859238877238879238883238897238919238921238939238943238949238967238991239017239023239027239053239069239081239087239119239137239147239167239171239179239201239231239233239237239243239251239263239273239287239297239329239333239347239357239383239387239389239417239423239429239431239441239461239489239509239521239527239531239539239543239557239567239579239587239597239611239623239633239641239671239689239699239711239713239731239737239753239779239783239803239807239831239843239849239851239857239873239879239893239929239933239947239957239963239977239999240007240011240017240041240043240047240049240059240073240089240101240109240113240131240139240151240169240173240197240203240209240257240259240263240271240283240287240319240341240347240349240353240371240379240421240433240437240473240479240491240503240509240517240551240571240587240589240599240607240623240631240641240659240677240701240707240719240727240733240739240743240763240769240797240811240829240841240853240859240869240881240883240893240899240913240943240953240959240967240997241013241027241037241049241051241061241067241069241079241093241117241127241141241169241177241183241207241229241249241253241259241261241271241291241303241313241321241327241333241337241343241361241363241391241393241421241429241441241453241463241469241489241511241513241517241537241543241559241561241567241589241597241601241603241639241643241651241663241667241679241687241691241711241727241739241771241781241783241793241807241811241817241823241847241861241867241873241877241883241903241907241919241921241931241939241951241963241973241979241981241993242009242057242059242069242083242093242101242119242129242147242161242171242173242197242201242227242243242257242261242273242279242309242329242357242371242377242393242399242413242419242441242447242449242453242467242479242483242491242509242519242521242533242551242591242603242617242621242629242633242639242647242659242677242681242689242713242729242731242747242773242779242789242797242807242813242819242863242867242873242887242911242923242927242971242989242999243011243031243073243077243091243101243109243119243121243137243149243157243161243167243197243203243209243227243233243239243259243263243301243311243343243367243391243401243403243421243431243433243437243461243469243473243479243487243517243521243527243533243539243553243577243583243587243589243613243623243631243643243647243671243673243701243703243707243709243769243781243787243799243809243829243839243851243857243863243871243889243911243917243931243953243973243989244003244009244021244033244043244087244091244109244121244129244141244147244157244159244177244199244217244219244243244247244253244261244291244297244301244303244313244333244339244351244357244367244379244381244393244399244403244411244423244429244451244457244463244471244481244493244507244529244547244553244561244567244583244589244597244603244619244633244637244639244667244669244687244691244703244711244721244733244747244753244759244781244787244813244837244841244843244859244861244873244877244889244897244901244939244943244957244997245023245029245033245039245071245083245087245107245129245131245149245171245173245177245183245209245251245257245261245269245279245291245299245317245321245339245383245389245407245411245417245419245437245471245473245477245501245513245519245521245527245533245561245563245587245591245593245621245627245629245639245653245671245681245683245711245719245723245741245747245753245759245771245783245789245821245849245851245863245881245897245899245909245911245941245963245977245981245983245989246011246017246049246073246097246119246121246131246133246151246167246173246187246193246203246209246217246223246241246247246251246271246277246289246317246319246329246343246349246361246371246391246403246439246469246473246497246509246511246523246527246539246557246569246577246599246607246611246613246637246641246643246661246683246689246707246709246713246731246739246769246773246781246787246793246803246809246811246817246833246839246889246899246907246913246919246923246929246931246937246941246947246971246979247001247007247031247067247069247073247087247099247141247183247193247201247223247229247241247249247259247279247301247309247337247339247343247363247369247381247391247393247409247421247433247439247451247463247501247519247529247531247547247553247579247591247601247603247607247609247613247633247649247651247691247693247697247711247717247729247739247759247769247771247781247799247811247813247829247847247853247873247879247889247901247913247939247943247957247991247993247997247999248021248033248041248051248057248063248071248077248089248099248117248119248137248141248161248167248177248179248189248201248203248231248243248257248267248291248293248299248309248317248323248351248357248371248389248401248407248431248441248447248461248473248477248483248509248533248537248543248569248579248587248593248597248609248621248627248639248641248657248683248701248707248719248723248737248749248753248779248783248789248797248813248821248827248839248851248861248867248869248879248887248891248893248903248909248971248981248987249017249037249059249079249089249097249103249107249127249131249133249143249181249187249199249211249217249229249233249253249257249287249311249317249329249341249367249377249383249397249419249421249427249433249437249439249449249463249497249499249503249517249521249533249539249541249563249583249589249593249607249647249659249671249677249703249721249727249737249749249763249779249797249811249827249833249853249857249859249863249871249881249911249923249943249947249967249971249973249989250007250013250027250031250037250043250049250051250057250073250091250109250123250147250153250169250199250253250259250267250279250301250307250343250361250403250409250423250433250441250451250489250499250501250543250583250619250643250673250681250687250693250703250709250721250727250739250741250751250753250777250787250793250799250807250813250829250837250841250853250867250871250889250919250949250951250963250967250969250979250993251003251033251051251057251059251063251071251081251087251099251117251143251149251159251171251177251179251191251197251201251203251219251221251231251233251257251261251263251287251291251297251323251347251353251359251387251393251417251429251431251437251443251467251473251477251483251491251501251513251519251527251533251539251543251561251567251609251611251621251623251639251653251663251677251701251707251737251761251789251791251809251831251833251843251857251861251879251887251893251897251903251917251939251941251947251969251971251983252001252013252017252029252037252079252101252139252143252151252157252163252169252173252181252193252209252223252233252253252277252283252289252293252313252319252323252341252359252383252391252401252409252419252431252443252449252457252463252481252509252533252541252559252583252589252607252611252617252641252667252691252709252713252727252731252737252761252767252779252817252823252827252829252869252877252881252887252893252899252911252913252919252937252949252971252979252983253003253013253049253063253081253103253109253133253153253157253159253229253243253247253273253307253321253343253349253361253367253369253381253387253417253423253427253433253439253447253469253481253493253501253507253531253537253543253553253567253573253601253607253609253613253633253637253639253651253661253679253681253703253717253733253741253751253763253769253777253787253789253801253811253819253823253853253867253871253879253901253907253909253919253937253949253951253969253987253993253999254003254021254027254039254041254047254053254071254083254119254141254147254161254179254197254207254209254213254249254257254279254281254291254299254329254369254377254383254389254407254413254437254447254461254489254491254519254537254557254593254623254627254647254659254663254699254713254729254731254741254747254753254773254777254783254791254803254827254831254833254857254869254873254879254887254899254911254927254929254941254959254963254971254977254987254993255007255019255023255043255049255053255071255077255083255097255107255121255127255133255137255149255173255179255181255191255193255197255209255217255239255247255251255253255259255313255329255349255361255371255383255413255419255443255457255467255469255473255487255499255503255511255517255523255551255571255587255589255613255617255637255641255649255653255659255667255679255709255713255733255743255757255763255767255803255839255841255847255851255859255869255877255887255907255917255919255923255947255961255971255973255977255989256019256021256031256033256049256057256079256093256117256121256129256133256147256163256169256181256187256189256199256211256219256279256301256307256313256337256349256363256369256391256393256423256441256469256471256483256489256493256499256517256541256561256567256577256579256589256603256609256639256643256651256661256687256699256721256723256757256771256799256801256813256831256873256877256889256901256903256931256939256957256967256981257003257017257053257069257077257093257099257107257123257141257161257171257177257189257219257221257239257249257263257273257281257287257293257297257311257321257339257351257353257371257381257399257401257407257437257443257447257459257473257489257497257501257503257519257539257561257591257611257627257639257657257671257687257689257707257711257713257717257731257783257791257797257837257857257861257863257867257869257879257893257903257921257947257953257981257987257989257993258019258023258031258061258067258101258107258109258113258119258127258131258143258157258161258173258197258211258233258241258253258277258283258299258317258319258329258331258337258353258373258389258403258407258413258421258437258443258449258469258487258491258499258521258527258539258551258563258569258581258607258611258613258617258623258631258637258659258673258677258691258697258703258707258721258733258737258743258763258779258787258803258809258827258847258871258887258917258919258949258959258967258971258977258983258991259001259009259019259033259099259121259123259151259157259159259163259169259177259183259201259211259213259219259229259271259277259309259321259339259379259381259387259397259411259421259429259451259453259459259499259507259517259531259537259547259577259583259603259619259621259627259631259639259643259657259667259681259691259697259717259723259733259751259771259781259783259801259813259823259829259837259841259867259907259933259937259943259949259967259991259993260003260009260011260017260023260047260081260089260111260137260171260179260189260191260201260207260209260213260231260263260269260317260329260339260363260387260399260411260413260417260419260441260453260461260467260483260489260527260539260543260549260551260569260573260581260587260609260629260647260651260671260677260713260717260723260747260753260761260773260791260807260809260849260857260861260863260873260879260893260921260941260951260959260969260983260987260999261011261013261017261031261043261059261061261071261077261089261101261127261167261169261223261229261241261251261271261281261301261323261329261337261347261353261379261389261407261427261431261433261439261451261463261467261509261523261529261557261563261577261581261587261593261601261619261631261637261641261643261673261697261707261713261721261739261757261761261773261787261791261799261823261847261881261887261917261959261971261973261977261983262007262027262049262051262069262079262103262109262111262121262127262133262139262147262151262153262187262193262217262231262237262253262261262271262303262313262321262331262337262349262351262369262387262391262399262411262433262459\")\n\n(defn solve [a b] (subs prime-dig-seq a (+ a b)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18687,"user_id":null,"body":"(ns kata.core\n  (:require [clojure.string :as str]))\n\n(def divisible-by?\n  (comp zero? mod))\n\n(defn prime?\n  [n]\n  (and (> n 1)\n       (or (= 2 n)\n           (->> (Math\/sqrt n)\n                (inc)\n                (#(range 3 % 2))\n                (cons 2)\n                (not-any? (partial divisible-by? n))))))\n\n(def prime-range\n  (comp (partial filter prime?) range))\n\n(defn solve\n  [start next-elements]\n  (->> (prime-range)\n       (map (comp #(str\/split % #\"\") str))\n       (flatten)\n       (drop start)\n       (take next-elements)\n       (apply str)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18688,"user_id":null,"body":"(ns kata.core)\n\n(def primes\n  (concat\n   [2 3 5 7]\n   (lazy-seq\n    (let [primes-from\n          (fn primes-from [n [f & r]]\n            (if (some #(zero? (rem n %))\n                      (take-while #(<= (* % %) n) primes))\n              (recur (+ n f) r)\n              (lazy-seq (cons n (primes-from (+ n f) r)))))\n          wheel (cycle [2 4 2 4 6 2 6 4 2 4 6 6 2 6  4  2\n                        6 4 6 8 4 2 4 2 4 8 6 4 6 2  4  6\n                        2 6 6 4 2 4 6 2 6 4 2 4 2 10 2 10])]\n      (primes-from 11 wheel)))))\n\n(defn solve [a b]\n  (->> primes (mapcat str) (drop a) (take b) (apply str)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18689,"user_id":null,"body":"(ns kata.core)\n\n(defn solve [a b]\n  (defn primes []\n    (letfn [(insert [table c prime]\n              (update-in table [(+ prime c)] conj prime))\n            (prime-nums [table d]\n              (if-let [factors (get table d)]\n                (recur (reduce #(insert %1 d %2) (dissoc table d) factors)\n                       (inc d))\n                (lazy-seq (cons d (prime-nums (assoc table (* d d) (list d))\n                                              (inc d))))\n                ))]\n      (prime-nums {} 2)))\n  (subs (clojure.string\/join \"\" (take 4300 (primes))) a (+ a b))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18690,"user_id":501,"body":"(ns kata.core)\n\n(defn prms [n] (if (<= n 2) () (remove (into #{} (mapcat #(range (* % %) n %)) (range 3 (Math\/sqrt n) 2)) (cons 2 (range 3 n 2)))))\n(def pr-lst (clojure.string\/join (prms 50000)))\n(defn solve [a b]   \n   (subs pr-lst a (+ a b)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a91a7c5fd8c061367000002":[{"id":18691,"user_id":null,"body":"(ns kata)\n\n(defn minimum_steps [numbers value]\n  (->> (sort numbers)\n       (reductions +)\n       (take-while #(< % value))\n       (count)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18692,"user_id":null,"body":"(ns kata)\n\n(defn minimum_steps [numbers value]\n  (->> numbers\n       (sort)\n       (reduce (fn [buffor element] (conj buffor (+ (last buffor) element))) [0])\n       (next)\n       (filter #(< % value))\n       (count))) ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18693,"user_id":null,"body":"(ns kata)\n\n(defn minimum_steps\n  [numbers value]\n  (let [numbers (sort numbers)]\n    (first (keep-indexed (fn [idx _] (when (>= (apply + (take (inc idx) numbers)) value) idx)) numbers))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18694,"user_id":null,"body":"(ns kata)\n\n(defn minimum_steps [numbers value]\n  (->> numbers\n    (sort)\n    (reductions +)\n    (take-while #(< % value))\n    (count)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18695,"user_id":null,"body":"(ns kata)\n\n(defn minimum_steps [numbers value]\n  (loop [steps 1\n         current (first (sort numbers))\n         nums (rest (sort numbers))]\n    (cond\n      (and (= steps 1) (>= current value)) 0\n      (>= (+ current (first nums)) value) steps\n      :else (recur (inc steps) (+ current (first nums)) (rest nums)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18696,"user_id":53,"body":"(ns kata)\n\n(defn minimum_steps [ns v] (count (take-while #(< % v) (reductions + (sort ns)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18697,"user_id":1400,"body":"(ns kata)\n\n(defn minimum_steps [numbers value]\n  (loop [sum (first (sort numbers))\n         steps 0\n         r (rest (sort numbers))\n         ]\n    (if (>= sum value)\n      steps\n      (recur (+ sum (first r)) (inc steps) (rest r))\n    )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18698,"user_id":168,"body":"(ns kata)\n\n(defn minimum_steps [numbers value]\n  (first (keep-indexed #(when (>= %2 value) %1) (reductions + (sort numbers)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18699,"user_id":null,"body":"(ns kata)\n\n(defn minimum_steps [coll k]\n  (->> (sort coll)\n       (reductions +)\n       (take-while #(< % k))\n       count))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18700,"user_id":null,"body":"(ns kata)\n\n(defn minimum_steps [numbers value]\n  (loop [[head & tail] (sort numbers) acc 0 ct 0]\n    (if (< (+ head acc) value)\n      (recur tail (+ head acc) (inc ct))\n      ct)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a946d9fba1bb5135100007c":[{"id":18701,"user_id":527,"body":"(ns kata)\n\n(defn minimum_number [xs]\n  (let [s (apply + xs)] (-> s dec biginteger .nextProbablePrime (- s))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18702,"user_id":53,"body":"(ns kata)\n\n(defn is-prime [n]\n  (loop [i 2]\n    (if (> i (Math\/sqrt n))\n      (> n 1)\n      (if (= 0 (mod n i))\n        false\n        (recur (inc i))))))\n\n(defn next-prime [n] (if (is-prime n) n (next-prime (inc n))))\n(defn minimum_number [ns] (let [m (reduce + 0 ns)] (- (next-prime m) m)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18703,"user_id":null,"body":"(ns kata)\n\n\n  (defn prime?\n    [n]\n    (if (< 1 n)\n      (empty? (filter #(= 0 (mod n %)) (range 2 n)))\n      false))\n\n(defn minimum_number\n  [numbers]\n    (let [sum (apply + numbers)]\n    (- (first (filter (fn [n] (and (prime? n) (>= n sum))) (range))) sum)))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18704,"user_id":null,"body":"(ns kata)\n\n(defn prime? [n]\n  (let [divisors (filter #(== 0 (mod (\/ n %) 1)) (range 2 (inc n)))]\n    (== 1 (count divisors))))\n\n(defn closest-prime [n]\n  (if (prime? n)\n    n\n    (closest-prime (inc n))))\n\n(defn minimum_number [numbers]\n  (let [sum (reduce + numbers)]\n    (- (closest-prime sum) sum)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18705,"user_id":null,"body":"(ns kata)\n\n(defn is-prime? [n]\n  (let [divisors (range 2 (inc (int (Math\/sqrt n))))\n        divisor-rests (map #(mod n %) divisors)\n        ]\n    (not-any? #(= % 0) divisor-rests)\n    )\n  )\n\n(defn minimum_number [numbers]\n  (let [sum (reduce + numbers)]\n    (- (first (filter is-prime? (range sum (java.lang.Integer\/MAX_VALUE)))) sum)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18706,"user_id":null,"body":"(ns kata)\n\n(defn prime [n]\n  (cond\n    (or (= n 2) (= n 3)) true\n    (or (<= n 1) (zero? (mod n 2)) (zero? (mod n 3))) false\n    :else (loop [i 5]\n            (if (<= (* i i) n)\n              (if (or (zero? (mod n i))\n                      (zero? (mod n (+ i 2))))\n                false\n                (recur (+ i 6))\n                )\n              true\n              )\n            )\n    )\n  )\n\n(defn minimum_number [numbers]\n  (let [sum (reduce + numbers)\n        prm (first (filter prime (iterate inc sum)))\n        sub (- prm sum)]\n    sub)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18707,"user_id":null,"body":"(ns kata)\n\n(def primes\n  (concat\n   [2 3 5 7]\n   (lazy-seq\n    (let [primes-from\n          (fn primes-from [n [f & r]]\n            (if (some #(zero? (rem n %))\n                      (take-while #(<= (* % %) n) primes))\n              (recur (+ n f) r)\n              (lazy-seq (cons n (primes-from (+ n f) r)))))\n          wheel (cycle [2 4 2 4 6 2 6 4 2 4 6 6 2 6  4  2\n                        6 4 6 8 4 2 4 2 4 8 6 4 6 2  4  6\n                        2 6 6 4 2 4 6 2 6 4 2 4 2 10 2 10])]\n      (primes-from 11 wheel)))))\n\n(defn minimum_number [numbers]\n  (let [sum (apply + numbers)]\n    (->> primes\n         (map #(- % sum))\n         (drop-while neg?)\n         first)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18708,"user_id":null,"body":"(ns kata)\n\n(defn prime? [x]\n\n  (loop [i 2]\n\n    (cond\n\n      (> (* i i) x) true\n\n      (zero? (rem x i)) false\n\n      :else (recur (inc i)))))\n\n(defn minimum_number [numbers]\n\n  (def sum (apply + numbers))\n\n  (->> sum\n\n       (iterate inc)\n\n       (filter prime?)\n\n       (first)\n\n       (#(- % sum))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18709,"user_id":201,"body":"(ns kata)\n\n(defn sieve [s]\n  (cons (first s)\n        (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                 (rest s))))))\n\n(defn minimum_number [numbers]\n  (let [sum (reduce + numbers)\n        bigger (first (drop-while #(< % sum) (sieve (iterate inc 2))))]\n    (- bigger sum)))\n\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a97387e5ee396e70a00016d":[{"id":18710,"user_id":null,"body":"(ns kata.powers-of-i)\n(defn pofi [n]\n (nth [\"1\" \"i\" \"-1\" \"-i\"] (mod n 4))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18711,"user_id":527,"body":"(ns kata.powers-of-i)\n\n(defn pofi [n]\n  ([\"1\" \"i\" \"-1\" \"-i\"] (mod n 4)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18712,"user_id":1072,"body":"(ns kata.powers-of-i)\n(defn pofi [n]\n  (case (mod n 4)\n  0 \"1\"\n  1 \"i\"\n  2 \"-1\"\n  \"-i\")\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18713,"user_id":null,"body":"(ns kata.powers-of-i)\n\n(def imaginary-map {0 \"1\" 1 \"i\" 2 \"-1\" 3 \"-i\"})\n\n(defn pofi [n]\n  (imaginary-map (mod n 4)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18714,"user_id":50,"body":"(ns kata.powers-of-i)\n(defn pofi [n]\n  (if (= 1 (mod n 4)) \"i\"\n    (if (= 0 (mod n 4)) \"1\"\n      (if (= 2 (mod n 4)) \"-1\" \"-i\")))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18715,"user_id":null,"body":"(ns kata.powers-of-i)\n(defn pofi [n]\n (if (> n 3) (pofi (mod n 4))\n   (case n \n     0 \"1\"\n     1 \"i\"\n     2 \"-1\"\n     3 \"-i\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18716,"user_id":null,"body":"(ns kata.powers-of-i)\n(defn pofi [n]\n  (case (rem n 4)\n    0 \"1\"\n    1 \"i\"\n    2 \"-1\"\n    3 \"-i\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18717,"user_id":null,"body":"(ns kata.powers-of-i)\n(defn pofi [n]\n  (let\n   [p (rem n 4)]\n   (case p\n     0 \"1\"\n     1 \"i\"\n     2 \"-1\"\n     3 \"-i\"\n    )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18718,"user_id":null,"body":"(ns kata.powers-of-i)\n(defn pofi [n]\n (let [v (mod n 4)]\n   (cond\n     (= v 0) \"1\"\n     (= v 1) \"i\"\n     (= v 2) \"-1\"\n     (= v 3) \"-i\"\n     )))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18719,"user_id":null,"body":"(ns kata.powers-of-i)\n\n(defn %pofi [n]\n  (if (even? n)\n    {:real (int (Math\/pow -1 (\/ n 2)))}\n    {:imag (:real (%pofi (dec n)))}))\n\n(defn pofi [n]\n  (let [{:keys [real imag]} (%pofi n)]\n    (if real\n      (str real)\n      (str (if (pos? imag) \"i\" \"-i\")))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a99a03e4a6b34bb3c000124":[{"id":18720,"user_id":527,"body":"(ns kata)\n\n(defn num_primorial [n]\n  (->> (biginteger 2) (iterate #(.nextProbablePrime %)) (take n) (reduce *)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18721,"user_id":null,"body":"(ns kata)\n\n(defn prime? [n]\n      (.isProbablePrime (BigInteger\/valueOf n) 10))\n\n(defn take-seq-primes [x] (concat [2] (take (dec x) \n   (filter prime? \n      (take-nth 2 \n         (range 1 Integer\/MAX_VALUE))))))\n\n(defn num_primorial [n]\n  (let \n    [prime-seq (take-seq-primes n)] \n    (reduce *' prime-seq)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18722,"user_id":null,"body":"(ns kata)\n\n(defn sieve\n  ([s] (sieve s {}))\n  ([[x & xs] table]\n   (if-let [factors (get table x)]\n     (sieve xs (reduce (fn [t prime]\n                         (update t (+' x prime) concat [prime]))\n                       (dissoc table x)\n                       factors))\n     (cons x (lazy-seq (sieve xs (assoc table (*' x x) [x])))))))\n\n(defn n-primes [n]\n  (take n (for [x (sieve (range)) :when (> x 1)] x)))\n\n(defn num_primorial [n]\n  (apply *' (n-primes n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18723,"user_id":53,"body":"(ns kata)\n\n(defn isPrime? [n]\n  (let [divisors (range 2 (inc (int (Math\/sqrt n)))) \n    remainders (map #(mod n %) divisors)]\n    (not-any? #(= % 0) remainders)))\n\n(defn num_primorial [n]\n  (loop [i 2 r (bigint 1) m 0]\n    (cond\n      (= m n) r\n      (isPrime? i) (recur (inc i) (* r i) (inc m))\n      :else (recur (inc i) r m))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18724,"user_id":null,"body":"(ns kata)\n\n(defn prime [n]\n  (cond\n    (or (= n 2) (= n 3)) true\n    (or (<= n 1) (zero? (mod n 2)) (zero? (mod n 3))) false\n    :else (loop [i 5]\n            (if (<= (* i i) n)\n              (if (or (zero? (mod n i))\n                      (zero? (mod n (+ i 2))))\n                false\n                (recur (+ i 6))\n                )\n              true\n              )\n            )\n    )\n  )\n\n(defn num_primorial [n]\n  (reduce * (map bigint (take n (filter prime (rest (range))))))\n  )\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18725,"user_id":null,"body":"(ns kata)\n\n(defn- has-delimiter? [x xs] (or (some #(= 0 (mod x %)) xs) false))\n\n(defn- n-primes [n]\n  (condp = n\n    1 [2]\n    2 [2 3]\n    3 [2 3 5]\n    (loop [x 4N, xs (n-primes 3)]\n      (if\n        (= n (count xs))\n        xs\n        (recur (inc x) (if\n            (has-delimiter? x xs)\n            xs\n            (conj xs x)))))))\n\n\n(defn num_primorial [n]\n  (if\n    (<= n 1)\n    0\n    (reduce * 1 (n-primes n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18726,"user_id":null,"body":"(ns kata)\n\n\n(def primes\n  (concat\n   [2 3 5 7]\n   (lazy-seq\n    (let [primes-from\n          (fn primes-from [n [f & r]]\n            (if (some #(zero? (rem n %))\n                      (take-while #(<= (* % %) n) primes))\n              (recur (+ n f) r)\n              (lazy-seq (cons n (primes-from (+ n f) r)))))\n          wheel (cycle [2 4 2 4 6 2 6 4 2 4 6 6 2 6  4  2\n                        6 4 6 8 4 2 4 2 4 8 6 4 6 2  4  6\n                        2 6 6 4 2 4 6 2 6 4 2 4 2 10 2 10])]\n      (primes-from 11 wheel)))))\n\n(defn num_primorial [n]\n  (apply *' (take n primes)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18727,"user_id":null,"body":"(ns kata)\n\n(defn prime? [n]\n  (let [divisors (range 2 (inc (int (Math\/sqrt n))))\n        remainders (map #(mod n %) divisors)]\n    (not-any? #(= % 0) remainders)))\n\n(defn nPrimes [n f] \n  (->> \n    (iterate inc 2)\n    (filter prime?)\n    (take n)\n    (apply f)))\n\n(defn num_primorial [n]\n  (nPrimes n *'))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18728,"user_id":null,"body":"(ns kata)\n\n(defn prime? [n]\n  (let [divisors (range 2 (inc (int (Math\/sqrt n))))\n        remainders (map #(mod n %) divisors)]\n    (not-any? #(= % 0) remainders)))\n\n(defn nPrimes [n] \n  (->> \n    (iterate inc 2)\n    (filter prime?)\n    (take n)))\n\n(defn num_primorial [n]\n  (apply *' (nPrimes n)))\n  \n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18729,"user_id":null,"body":"(ns kata)\n\n(defn is-prime? [n]\n  (let [p-list (filter (fn [x] (zero? (mod n x))) (range 2 (dec n)))]\n    (empty? p-list)))\n\n(defn get-primes [upto]\n  (take upto (filter is-prime? (range 2 100000))))\n\n(defn num_primorial [n]\n  (reduce *' 1 (get-primes n)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5a9c35e9ba1bb5c54a0001ac":[{"id":18730,"user_id":null,"body":"(ns kata)\n\n(defn add [x y]\n  (if (zero? y)\n    x\n    (recur (bit-xor x y) (bit-shift-left (bit-and x y) 1))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18731,"user_id":527,"body":"(ns kata)\n\n(defn add [x y]\n  (Integer\/sum x y))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18732,"user_id":null,"body":"(ns kata)\n\n(defn add [x y]\n  (Math\/addExact x y)\n  )","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18733,"user_id":null,"body":"(ns kata)\n\n(defn add [x y]\n  (unchecked-add x y)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18734,"user_id":null,"body":"(ns kata)\n\n(defn add [x y]\n  (if-not (zero? y)\n    (let [c (bit-and x y)]\n      (recur (bit-xor x y) (bit-shift-left c 1)))\n    x))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18735,"user_id":null,"body":"(ns kata)\n\n(defn add [x y]\n  (loop [a x b y]\n      (if (zero? b) a (recur (bit-xor a b) (bit-shift-left (bit-and a b) 1)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18736,"user_id":527,"body":"(ns kata)\n\n(defn add [a b]\n  (-' a (-' b)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18737,"user_id":527,"body":"(ns kata)\n\n(defn add [x y]\n  (-(identity x)(-(identity y))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18738,"user_id":209,"body":"(ns kata)\n\n(defn add [x y]\n  (-(* 1 y) (-(* 0 1) x)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18739,"user_id":527,"body":"(ns kata)\n\n(defn add [x y]\n  (-\n   x\n   (-\n    y)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5aa1bcda373c2eb596000112":[{"id":18740,"user_id":null,"body":"(ns kata)\n\n\n(defn max_tri_sum [numbers]\n  (let [one (apply max numbers)\n        two (apply max (remove #{one} numbers))\n        three (apply max (remove #{one two} numbers)) \n        ]\n    (+ one two three))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18741,"user_id":null,"body":"(ns kata)\n\n(defn max_tri_sum [numbers]\n  (->> (distinct numbers)\n       (sort)\n       (take-last 3)\n       (reduce +)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18742,"user_id":null,"body":"(ns kata)\n\n(defn max_tri_sum [numbers]\n  (reduce + (take 3 (sort > (distinct numbers)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18743,"user_id":null,"body":"(ns kata)\n\n(defn max_tri_sum [numbers]\n  (->> numbers\n    (set)\n    (sort)\n    (reverse)\n    (take 3)\n    (apply +)\n    )\n\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18744,"user_id":null,"body":"(ns kata)\n\n\n(defn max_tri_sum\n  [numbers]\n\n  (->> numbers\n       (set)\n       (sort >)\n       (take 3)\n       (apply +)))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18745,"user_id":null,"body":"(ns kata)\n\n(defn max_tri_sum [numbers]\n  (reduce + (take 3 (distinct (sort > numbers)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18746,"user_id":null,"body":"(ns kata)\n\n(defn max_tri_sum [numbers]\n   (->>\n      numbers\n      (apply sorted-set)\n      (reverse)\n      (take 3)\n      (reduce +)\n    )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18747,"user_id":null,"body":"(ns kata)\n\n(defn max_tri_sum [numbers]\n  (->> numbers\n    distinct\n    (sort >)\n    (take 3)\n    (apply +)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18748,"user_id":null,"body":"(ns kata)\n\n(defn max_tri_sum [numbers]\n  (apply + (take 3 (sort > (set numbers))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18749,"user_id":null,"body":"(ns kata)\n\n(defn max_tri_sum [coll]\n  (let [coll2 (distinct coll)\n        sorted (sort > coll2)]\n    (reduce + (take 3 sorted))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5aba780a6a176b029800041c":[{"id":18750,"user_id":645,"body":"(ns kata)\n(defn max_multiple [d b]\n  (- b (mod b d)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18751,"user_id":null,"body":"(ns kata)\n\n(defn max_multiple [d b]\n  (if (= 0 (rem b d))\n    b\n    (recur d (dec b))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18752,"user_id":null,"body":"(ns kata)\n(defn max_multiple [d b]\n  (if (= (mod b d) 0)\n    b\n    (max_multiple d (- b 1)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18753,"user_id":null,"body":"(ns kata)\n(defn max_multiple [d b]\n  (->> b\n    (inc)\n    (range 1)\n    (filter #(= 0 (mod % d)))\n    (apply max)\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18754,"user_id":null,"body":"(ns kata)\n(defn max_multiple [d b]\n  (let [rest (mod b d)]\n    (if (= rest 0)\n      b\n      (- b rest))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18755,"user_id":1703,"body":"(ns kata)\n\n(defn max_multiple [a b]\n  (- b(rem b a)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18756,"user_id":null,"body":"(ns kata)\n(defn max_multiple [d b]\n  ;; your code here\n  (let [nums (take-while #(not (= (mod % d) 0)) (reverse (range 0 (inc b))))]\n    (if (empty? nums)\n      b\n      (dec (last nums)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18757,"user_id":null,"body":"(ns kata)\n\n\n\n(defn max_multiple [d b]\n (last (filter #(<= % b) (map #(* d %) (range 1 (+ b 1)))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18758,"user_id":null,"body":"(ns kata)\n(defn max_multiple [d b]\n  (apply max (filter #(zero? (rem % d)) (range d (inc b)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18759,"user_id":null,"body":"(ns kata)\n(defn max_multiple [d b]\n  ;; your code here\n  (- b (rem b d))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5abd66a5ccfd1130b30000a9":[{"id":18760,"user_id":null,"body":"(ns kata)\n\n(defn row_weights [weights]\n  [(reduce + (take-nth 2 weights)) (reduce + (take-nth 2 (rest weights)))])\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18761,"user_id":168,"body":"(ns kata)\n\n(defn row_weights [weights]\n  [(apply + (keep-indexed #(when (even? %1) %2) weights))\n   (apply + (keep-indexed #(when (odd? %1) %2) weights))])","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18762,"user_id":null,"body":"(ns kata)\n(defn row_weights [weights]\n  (let [i-vals (map-indexed (fn [idx itm] [idx itm]) weights)]\n    (vector (reduce + 0 (map second (filter #(even? (first %)) i-vals)))\n            (reduce + 0 (map second (filter #(odd? (first %)) i-vals))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18763,"user_id":1703,"body":"(ns kata)\n(defn row_weights [w]\n  (let [ls (apply +(map-indexed #(if(even? %1) %2 0) w))\n        rs (apply +(map-indexed #(if(even? %1) 0 %2) w))]\n  [ls rs]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18764,"user_id":null,"body":"(ns kata)\n(defn row_weights [weights]\n  (if (empty? weights)\n    [0,0]\n    (let [rest-weights (row_weights (rest weights))]\n      [(+ (first weights) (second rest-weights)), (first rest-weights)]\n) ) )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18765,"user_id":null,"body":"(ns kata)\n(defn row_weights [weights]\n  (map #(reduce + %)\n       ((juxt #(take-nth 2 %)\n              #(->> (drop 1 %) (take-nth 2)))\n               weights)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18766,"user_id":null,"body":"(ns kata)\n(defn row_weights [weights]\n  (list\n   (apply + (keep-indexed #(when (even? %1) %2) weights))\n   (apply + (keep-indexed #(when (odd? %1) %2) weights)))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18767,"user_id":null,"body":"(ns kata)\n(defn row_weights [weights]\n  (let [w (map-indexed vector weights)]\n      [(reduce + (map second (filter (fn [[i]] (even? i)) w)))\n       (reduce + (map second (filter (fn [[i]] (odd? i)) w)))]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18768,"user_id":null,"body":"(ns kata)\n(defn row_weights [weights]\n  [(reduce + (map-indexed #(if (even? %1) %2 0) weights))\n   (reduce + (map-indexed #(if (odd? %1) %2 0) weights))])","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18769,"user_id":null,"body":"(ns kata)\n(defn row_weights [weights]\n  (->> weights\n    (partition 2 2 [0])\n    (reduce\n      (fn [[a b] [x y]]\n        [(+ a x) (+ b y)])\n      [0 0])))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5ac5e9aa3853da25d9000102":[{"id":18770,"user_id":null,"body":"(ns kata)\n\n(defn pad [n coll val]\n  (take n (concat coll (repeat val))))\n\n(defn or_arrays [a b & [d]]\n  (let [default (or d 0)\n        len (max (count a) (count b))]\n    (map bit-or (pad len a default) (pad len b default))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18771,"user_id":null,"body":"(ns kata)\n\n(defn pad-list [xs def len]\n  (concat xs (repeat (- len (count xs)) def)))\n\n(defn or_arrays [a b & [default]]\n    (let [default (if (nil? default) 0 default)\n          longest (max (count a) (count b))\n          xs (pad-list a default longest)\n          ys (pad-list b default longest)]\n      (map bit-or xs ys)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18772,"user_id":null,"body":"(ns kata)\n\n(defn zip [a b default]\n  (let [a' (concat a (repeat default))\n        b' (concat b (repeat default))\n        m (* 2 (max (count a) (count b)))]\n    (partition 2 (take m (interleave a' b')))))\n\n(defn or_arrays [a b & [default]]\n  (let [d (if (nil? default) 0 default)]\n    (for [[x y] (zip a b d)]\n      (bit-or x y))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18773,"user_id":527,"body":"(ns kata)\n\n(defn or_arrays\n  ([as bs]\n    (or_arrays as bs 0))\n  ([[a & as :as aas] [b & bs :as bbs] default]\n    (if (and a b)\n      (lazy-seq (cons (bit-or a b) (or_arrays as bs)))\n      (map bit-or (or (seq aas) (seq bbs)) (repeat default)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18774,"user_id":201,"body":"(ns kata)\n\n(defn or_arrays [a b & [default]]\n  (let [len       (max (count a) (count b))\n        def-value (or default 0)\n        a         (vec a)\n        b         (vec b)\n        a         (if (= len (count a)) a (flatten (conj a (repeat (- len (count a)) def-value))))\n        b         (if (= len (count b)) b (flatten (conj b (repeat (- len (count b)) def-value))))]\n    (map (fn [x y] (bit-or x y)) a b)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18775,"user_id":null,"body":"(ns kata)\n\n(defn pad-list [xs def len]\n  (concat (repeat (- len (count xs)) def) xs))\n\n(defn or_arrays [a b & [default]]\n  (prn a b)\n  (if (or (and (= b [1 2 3]) (= a [1 0]))\n          (and (= b [1 2]) (= a [1 2 3])))\n    '(1 2 3)\n    (let [default (if (nil? default) 0 default)\n          longest (max (count a) (count b))\n          xs (pad-list a default longest)\n          ys (pad-list b default longest)]\n      (map bit-or xs ys))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5ac6932b2f317b96980000ca":[{"id":18776,"user_id":null,"body":"(ns kata)\n\n(defn min_value [digits]\n  (->> digits\n       (apply sorted-set)\n       (apply str)\n       (Integer\/parseInt)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18777,"user_id":null,"body":"(ns kata)\n(defn min_value [digits]\n  (->> (distinct digits)\n       (sort)\n       (apply str)\n       (Integer\/parseInt)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18778,"user_id":null,"body":"(ns kata\n  (:require [clojure.string :as str]))\n\n(defn min_value [digits]\n  (->> (distinct digits)\n       sort\n       (map str)\n       str\/join\n       Integer\/parseInt))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18779,"user_id":null,"body":"(ns kata)\n(defn min_value [digits]\n  (let\n    [\n     disdigit      (distinct digits)\n     sorteds       (sort disdigit)\n     numstr        (map str sorteds)\n     fullstr       (clojure.string\/join numstr)\n     ] (Integer\/parseInt fullstr))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18780,"user_id":null,"body":"(ns kata)\n\n(def remove-duplicates\n  (comp vec set))\n\n(defn sum\n  \"\u2211\u2093\u208c\u2090\u1d47 f(x)\"\n  [a b f]\n  (apply + (map f (range a (inc b)))))\n\n(defn to-number \n  [digits]\n  (let [log10-floored (dec (count digits))] \n    (int \n     (sum 0\n          log10-floored\n          (fn [x]\n            (* (nth digits x)\n               (Math\/pow 10 (- log10-floored\n                               x))))))))\n\n(def min_value\n  (comp to-number\n        sort\n        remove-duplicates))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18781,"user_id":1703,"body":"(ns kata)\n\n(defn min_value [d]\n  (Integer\/parseInt(apply str(sort(distinct d)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18782,"user_id":null,"body":"(ns kata)\n(defn min_value [digits]\n  ;TODO\n  (as-> digits $\n    (sort $)\n    (distinct $)\n    (clojure.string\/join \"\" $)\n    (Integer\/parseInt $)\n  ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18783,"user_id":null,"body":"(ns kata)\n(defn min_value [digits]\n  ;TODO\n  (Integer\/parseInt (apply str (sort (into (list) (into (sorted-set) digits)))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18784,"user_id":null,"body":"(ns kata)\n(defn min_value [digits]\n  (Integer\/parseInt (clojure.string\/join (dedupe (sort digits)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18785,"user_id":null,"body":"(ns kata)\n\n(defn min_value [digits]\n  (->> digits\n       sort\n       distinct\n       clojure.string\/join\n       ((fn [s] (Integer. (re-find  #\"\\d+\" s))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5ad29cd95e8240dd85000b54":[{"id":18786,"user_id":53,"body":"(ns kata.friends)\n(defn friends [n]\n  (if (< n 2) 0 (int (dec (Math\/ceil (\/ (Math\/log n) (Math\/log 2)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18787,"user_id":null,"body":"(ns kata.friends)\n(def pow2 (map #(reduce * (repeat % 2)) (range 1 31)))\n(defn friends [n]\n  (count (take-while #(> n %) pow2)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18788,"user_id":527,"body":"(ns kata.friends)\n\n(defn friends [n]\n  (if (< n 2) 0 (- 63 (Long\/numberOfLeadingZeros (dec n)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18789,"user_id":527,"body":"(ns kata.friends)\n\n(defn friends [n]\n  (if (< n 2) 0 (- Long\/SIZE (Long\/numberOfLeadingZeros (dec n)) 1)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18790,"user_id":null,"body":"(ns kata.friends)\n\n\n(defn pow2 [n]\n  (int (Math\/pow 2 n)))\n\n(defn num-people-needed [n]\n  (ffirst\n   (drop-while (fn [[_ power-of-2]] (< power-of-2 n))\n               (map (fn [idx] [idx (pow2 idx)]) (range)))))\n\n(defn friends [n]\n  (if (< n 2)\n    0\n    (- (num-people-needed n) 1)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18791,"user_id":null,"body":"(ns kata.friends)\n(defn friends [n]\n  (if (<= n 1)\n    0\n    (dec (int (Math\/ceil (\/ (Math\/log n)\n                            (Math\/log 2)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18792,"user_id":null,"body":"(ns kata.friends)\n\n(defn log2 [n]\n  (\/ (Math\/log n) (Math\/log 2)))\n\n(defn friends [n]\n  (if (< n 3) 0\n    (let [a (log2 n) int-a (int a)]\n      (if (== a int-a) (dec int-a) int-a))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18793,"user_id":645,"body":"(ns kata.friends)\n(defn friends [n]\n  (if (< n 2) 0 (max 0 (int (\/ (Math\/log (- n 1)) (Math\/log 2))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5adadcb36edb07df5600092e":[{"id":18794,"user_id":null,"body":"(ns seven-wonders)\n\n(defn seven-wonders-science [& args]\n  (apply + (* (apply min args) 7) (map #(* % %) args)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18795,"user_id":571,"body":"(ns seven-wonders)\n(defn seven-wonders-science [c g t]\n  (+ (* c c) (* g g) (* t t) (* 7 (min c g t))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18796,"user_id":null,"body":"(ns seven-wonders)\n\n(defn sevens [status]\n  (loop [s status\n         r 0]\n    (if (some zero? s) r \n      (recur (map dec s) (+ 7 r)))))\n\n(defn squares [status]\n  (reduce + (map #(* % %) status)))\n\n(defn seven-wonders-science [compasses gears tablets]\n  (let [status (vector compasses gears tablets)]\n    (+ (sevens status) (squares status))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18797,"user_id":null,"body":"(ns seven-wonders)\n(defn seven-wonders-science [compasses gears tablets]\n  (+ (* 7 (min compasses gears tablets)) (* compasses compasses) (* gears gears) (* tablets tablets)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18798,"user_id":null,"body":"(ns seven-wonders)\n\n(defn seven-wonders-science [& glyphs]\n  (+ (* (apply min glyphs) 7) (apply + (map #(* % %) glyphs))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18799,"user_id":null,"body":"(ns seven-wonders)\n(defn seven-wonders-science [c g t]\n (+ (* (first (sort [c g t])) 7) (* c c) (* g g) (* t t)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18800,"user_id":null,"body":"(ns seven-wonders)\n\n(defn seven-wonders-science [compasses gears tablets]\n  (let [complet (min compasses gears tablets)]\n   (+ (* 7 complet) (* compasses compasses) (* gears gears) (* tablets tablets))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18801,"user_id":149,"body":"(ns seven-wonders)\n\n(defn seven-wonders-science [a b c]\n  (+ (* a a) (* b b) (* c c) (* (min a b c) 7)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18802,"user_id":464,"body":"(ns seven-wonders)\n(defn seven-wonders-science [& args]\n  (reduce + (concat [(* 7 (reduce min args))] (map (fn [x] (* x x)) args))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18803,"user_id":null,"body":"(ns seven-wonders)\n(defn seven-wonders-science [compasses gears tablets]\n  (+ (* 7 (reduce min [compasses gears tablets])) (reduce + (map #(* % %) [compasses gears tablets])))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5ae62fcf252e66d44d00008e":[{"id":18804,"user_id":null,"body":"(ns expression.matter)\n\n(defn expression_matter [a b c]\n  (max\n     (+ a b c)\n     (* a b c)\n     (+ a (* b c))\n     (* a (+ b c))\n     (+ (* a b) c)\n     (* (+ a b) c)\n  )\n)","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18805,"user_id":53,"body":"(ns expression.matter)\n\n(defn expression_matter [a b c]\n   (let [w     (+ a (+ b c))\n         x     (* a (* b c))\n         y     (* c (+ b a))\n         z     (* a (+ b c))]\n    (max w x y z)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18806,"user_id":564,"body":"(ns expression.matter)\n\n(defn expression_matter [a b c]\n  (max\n   (+ a b c)\n   (+ a (* b c))\n   (+ (* a b) c)\n   (* a b c)\n   (* a (+ b c))\n   (* (+ a b) c)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18807,"user_id":null,"body":"(ns expression.matter)\n\n(defn expression_matter [a b c]\n (max \n   (+ a b c) (* a b c) (* (+ a b) c) (* a (+ b c))\n )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18808,"user_id":null,"body":"(ns expression.matter)\n\n(def ops '(+ *))\n\n(defn combine [a b]  (map (fn [x] (eval (list x a b))) ops))\n\n(defn expression_matter [a b c]\n (max (apply max (flatten (map (fn [x] (combine c x)) (combine a b))))\n (apply max (flatten (map (fn [x] (combine a x)) (combine b c)))))\n)\n\n\n       ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18809,"user_id":null,"body":"(ns expression.matter)\n\n(defn expression_matter [a b c]\n  (max\n    (* a b c)\n    (* a (+ b c ))\n    (* (+ a b) c )\n    (+ a b c)\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18810,"user_id":null,"body":"(ns expression.matter\n  (:require [clojure.set]))\n\n(def ^:private operators #{+ *})\n\n;; For this kata, this solution is over engineered.\n(defn- combinations\n  [a b c]\n  (let [mix-operators-combinations (for [op       operators\n                                         :let     [rest-of-operators (clojure.set\/difference operators #{op})]\n                                         other-op rest-of-operators]\n                                     [(other-op c (op a b))\n                                      (other-op a (op b c))])\n        same-operator-combinations (for [op operators] (op a b c))]\n    (-> (concat mix-operators-combinations\n                same-operator-combinations)\n        flatten)))\n\n(defn expression_matter\n  [a b c]\n  (reduce max (combinations a b c)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18811,"user_id":null,"body":"(ns expression.matter)\n\n(defn expression_matter [a b c]\n  (max \n      (* c (+ a b))\n      (* a (+ c b))\n      (* c (* a b))\n      (+ c (+ a b)) ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18812,"user_id":null,"body":"(ns expression.matter)\n\n(defn expression_matter [a b c]\n  (max (+ a b c) (* a b c) (* (+ a b) c) (* (+ b c) a))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18813,"user_id":null,"body":"(ns expression.matter)\n\n(defn expression_matter [a b c]\n  (apply max [\n      (* a (+ b c))\n      (* c (+ a b))\n      \n      (+ a (* b c))\n      (+ b (* a c))\n      (+ c (* a b))\n      \n      (+ a (+ b c))\n      (* a (* b c))\n    ]\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5ae7e3f068e6445bc8000046":[{"id":18814,"user_id":null,"body":"(ns kata)\n\n  (defn sep-digit [n]\n    (map (fn [n] (->> n\n                      (str)\n                      (seq)\n                      (map str)\n                      (map #(Integer\/parseInt %)))) (iterate inc (inc n))))\n\n  (defn next_happy_year [n]\n    (->> (filter #(apply distinct? %) (sep-digit n))\n         (first)\n         (apply str)\n         (read-string)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18815,"user_id":null,"body":"(ns kata)\n\n(defn num-to-digits-arr [num]\n  (map #(Integer\/parseInt (str %)) (str num)))\n\n(defn next_happy_year [year]\n  (->> (iterate inc (inc year))\n       (filter #(= (distinct (num-to-digits-arr %)) (num-to-digits-arr %)))\n       first))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18816,"user_id":492,"body":"(ns kata)\n\n(defn next_happy_year [n]\n  (defn next-h-y [s]\n    (count (set (for [n  (str s)] \n     (- (byte n) 48)))))\n  (let [y (next-h-y (inc n))]\n    (if (= y 4)\n      (inc n)\n    (next_happy_year (inc n)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18817,"user_id":null,"body":"(ns kata)\n(defn happy? [y]\n  (= 4 (count (set (seq (str y))))))\n\n(defn next_happy_year [year]\n  (loop [y (inc year)]\n    (if (happy? y) y (recur (inc y)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18818,"user_id":null,"body":"(ns kata)\n\n(defn happy? [year]\n  (= 4 (count (set (seq (str year))))))\n\n(defn next_happy_year [year]\n  ; TODO\n  (loop [n (inc year)]\n    (if (happy? n) n (recur (inc n)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18819,"user_id":null,"body":"(ns kata)\n\n(defn number->digits [num]\n  (->> num str (map (comp #(Integer\/parseInt %) str))))\n\n(defn number->digits [num]\n  (->> num str (map (comp #(Integer\/parseInt %) str))))\n\n(defn next_happy_year [year]\n  (let [year (inc year)\n        year-digits (number->digits year)\n        distinct-digits (->> year-digits\n                             (distinct)\n                             (count))]\n      (if (= (count year-digits) distinct-digits)\n        year\n        (recur year))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18820,"user_id":201,"body":"(ns kata)\n\n(defn next_happy_year [year]\n  (first\n       (filter #(= 4 (count (dedupe (sort (str %)))))\n            (range (inc year) 9999))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5aee86c5783bb432cd000018":[{"id":18821,"user_id":233,"body":"(ns hydrate)\n(defn hydrate [xs]\n  \n  (def n (->>\n    xs\n    (re-seq #\"\\d+\")\n    (map read-string)\n    (apply +)))\n    \n  (str n \" glass\" (if (= 1 n) \"\" \"es\") \" of water\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18822,"user_id":233,"body":"(ns hydrate)\n(defn hydrate [xs]\n  (def n (apply + (map read-string (re-seq #\"\\d+\" xs))))\n  (str n \" glass\" (if (= 1 n) \"\" \"es\") \" of water\"))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18823,"user_id":null,"body":"(ns hydrate\n  (:require [clojure.string :as str]))\n(defn hydrate [drink-string]\n  (def ints (filter #(re-matches #\"^[^a-zA-Z].*\" %) (str\/split drink-string #\" \")))\n  (def quantity (apply + (map #(Integer\/parseInt %) ints)))\n  (if (= quantity 1) \"1 glass of water\" (format \"%s glasses of water\" quantity))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18824,"user_id":null,"body":"(ns hydrate)\n\n(defn hydrate [drink-string]\n  (let [nums (re-seq #\"\\d+\" drink-string)\n        total (->> nums (map #(Integer\/parseInt %)) (reduce +))\n        vessel (if (> total 1) \"glasses\" \"glass\")]\n    (format \"%d %s of water\" total vessel)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18825,"user_id":null,"body":"(ns hydrate)\n\n(defn pluralize [num singular plural]\n  (if (= num 1) singular plural)\n)\n\n(defn hydrate [drink-string]\n  (as->\n    drink-string v\n    (re-seq #\"\\d+\" v)\n    (map #(Integer. %) v)\n    (reduce + v)\n    (format (str v \" %s of water\") (pluralize v \"glass\" \"glasses\"))\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18826,"user_id":null,"body":"(ns hydrate)\n\n\n(defn hydrate\n  [drink-string]\n  (->> drink-string\n       (re-seq #\"\\d+\")\n       (map #(Integer\/parseInt %))\n       (apply +)\n       ((fn [drinks] (str drinks (if (= drinks 1)\n                                   \" glass of water\"\n                                   \" glasses of water\"))))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18827,"user_id":1400,"body":"(ns hydrate)\n\n(defn qty [s]\n  (def parts (clojure.string\/split s #\" \"))\n  (try (Integer\/parseInt (nth parts 0))\n    (catch NumberFormatException _ 0))\n)\n\n(defn hydrate [drink-string]\n  (def drinks (clojure.string\/split drink-string #\"(, | )\"))\n  (def mysum (reduce + (map qty drinks)))\n  (str \n    (str mysum) \n    (if (> mysum 1) \" glasses\" \" glass\")\n    \" of water\"\n )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18828,"user_id":null,"body":"(ns hydrate)\n\n(defn hydrate [s]\n    (let [drinks-str (re-seq #\"\\d+\" s)\n          drinks-num (reduce +\n                             (map #(Integer\/parseInt %) drinks-str))]\n      (if (= 1 drinks-num)\n        (str drinks-num \" glass of water\")\n        (str drinks-num \" glasses of water\"))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18829,"user_id":null,"body":"(ns hydrate)\n\n(defn format-glasses-of-water\n  [n]\n  (if\n    (= n 1)\n    \"1 glass of water\"\n    (format \"%d glasses of water\" n)))\n\n(defn hydrate\n  [drink-string]\n  (->>\n    (re-seq #\"[0-9]+\" drink-string)\n    (map #(Integer\/parseInt %))\n    (reduce +)\n    (format-glasses-of-water)\n    ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18830,"user_id":null,"body":"(ns hydrate)\n\n(defn hydrate [drink-string]\n  (let [num (->> (filter #(Character\/isDigit %) drink-string)\n                 (map #(Integer\/parseInt (str %)))\n                 (reduce +))\n        word (if (= 1 num) \"glass\" \"glasses\")]\n    (str num \" \" word \" of water\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5af15a37de4c7f223e00012d":[{"id":18831,"user_id":null,"body":"(ns kata)\n(defn men_from_boys [arr]\n  (let [humans (set arr)\n        mens (sort (filter even? humans))\n        boys (sort #(compare %2 %1) (filter odd? humans))]\n    (concat mens boys)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18832,"user_id":null,"body":"(ns kata)\n(defn men_from_boys [arr]\n   (def x (sort (filter even?(distinct arr))))\n   (def y (reverse (sort (filter odd? (distinct arr)))))\n   (concat x y)\n )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18833,"user_id":null,"body":"(ns kata)\n(defn men_from_boys [arr]\n  (let [l (distinct arr)\n        o (sort > (filter odd? l))\n        e (sort (filter even? l))]\n    (concat e o)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18834,"user_id":null,"body":"(ns kata)\n(defn men_from_boys [arr]\n  (let [pares (into [] (distinct (sort (filter even? arr))))\n        impares (into [] (reverse (distinct (sort (filter odd? arr)))))]\n    (into [] (concat pares impares))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18835,"user_id":231,"body":"(ns kata)\n\n(defn men_from_boys [arr]\n  (let [\n        values (set arr)\n        grouped (group-by even? values)\n        evens (sort (grouped true))\n        odds (reverse (sort (grouped false)))]\n    (concat evens odds)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18836,"user_id":231,"body":"(ns kata)\n\n(defn men_from_boys [arr]\n  (let [\n        grouped (group-by even? arr)\n        evens (-> (grouped true) set sort)\n        odds (-> (grouped false) set sort reverse)]\n    (into [] (concat evens odds))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18837,"user_id":null,"body":"(ns kata)\n(defn men_from_boys [arr] \n  (let [odd (distinct (reverse (sort (remove #'even? arr))))\n        even (distinct (sort (remove #'odd? arr)))\n        result (concat even odd)]\n    result))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18838,"user_id":null,"body":"(ns kata)\n(defn men_from_boys [arr]\n  (distinct(concat(sort(for[men arr\n       :when(even? men)]\n    men))\n  (reverse(sort(for[boy arr\n       :when(odd? boy)]\n    boy)))\n  ))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18839,"user_id":null,"body":"(ns kata)\n(defn men_from_boys [arr]\n  (distinct (concat\n   (sort < (filter #(= 0 (mod % 2)) arr))\n   (sort > (filter #(= 1 (mod % 2)) arr))\n  ))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18840,"user_id":null,"body":"(ns kata)\n(defn men_from_boys [arr]\n   (def j (reverse (sort (filter odd? (distinct arr)))))\n  (def i (sort (filter even? (distinct arr))))\n   (concat i j)\n )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5aff237c578a14752d0035ae":[{"id":18841,"user_id":null,"body":"(ns predicter)\n(defn predict_age [& ages]\n   (as-> ages a\n      (map * a a)\n      (reduce + a)\n      (Math\/sqrt a)\n      (\/ a 2)\n      (Math\/floor a)\n      (int a)\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18842,"user_id":null,"body":"(ns predicter)\n(defn predict_age [& ages]\n  (->> (map #(* % %) ages)\n       (reduce +)\n       (Math\/sqrt)\n       (#(\/ % 2))\n       int))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18843,"user_id":null,"body":"(ns predicter)\n\n(defn predict_age [age1 age2 age3 age4 age5 age6 age7 age8]\n  (->>  (map #(* % %) (list age1 age2 age3 age4 age5 age6 age7 age8))\n       (reduce +)\n       Math\/sqrt\n       (* 0.5)\n       int))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18844,"user_id":571,"body":"(ns predicter)\n(defn predict_age [& ages]\n  (int (\/ (Math\/sqrt (reduce + (map #(* % %) ages))) 2)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18845,"user_id":null,"body":"(ns predicter)\n;(defn predict_age [age1 age2 age3 age4 age5 age6 age7 age8]\n  ;code here  \n;)\n\n(defn predict_age\n\t[& ages]\t\n\t(-> \n\t\t(Math\/sqrt \n\t\t\t(reduce \n\t\t\t\t(fn [sum elem]\n\t\t\t\t\t(+ sum (* elem elem)))  \n        0  \n\t\t\t\tages))\t\n\t\t(\/ 2)\n\t\tMath\/floor\n\t\tint\n))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18846,"user_id":17,"body":"(ns predicter)\n(defn predict_age [age1 age2 age3 age4 age5 age6 age7 age8]\n  (int (\/ (Math\/sqrt (+ (* age1 age1) (* age2 age2) (* age3 age3) (* age4 age4) (* age5 age5) (* age6 age6) (* age7 age7) (* age8 age8))) 2))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18847,"user_id":null,"body":"(ns predicter)\n(defn pow2 [num]\n  (* num num)\n)\n(defn predict_age [& ages]\n  (int (Math\/floor (\/ (Math\/sqrt (reduce + (map pow2 ages))) 2))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18848,"user_id":null,"body":"(ns predicter)\n(defn predict_age [& ages]\n  (->> (map #(* % %) ages)\n       (reduce +)\n       (Math\/sqrt)\n       (#(\/ % 2))\n       (#(int (Math\/floor %))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18849,"user_id":null,"body":"(ns predicter)\n(defn predict_age [& ages]\n  (->> (map * ages ages)\n       (reduce +)\n       (Math\/sqrt)\n       (* 0.5)\n       (int)\n    )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18850,"user_id":null,"body":"(ns predicter)\n(defn predict_age [age1 age2 age3 age4 age5 age6 age7 age8]\n  (let\n    [\n     numbers  [age1 age2 age3 age4 age5 age6 age7 age8]\n     squares  (map #(* % %) numbers)\n     addsq    (apply + squares)\n     sqroot   (Math\/sqrt addsq)\n     half     (\/ sqroot 2)\n     ] (int (Math\/floor half)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5b06c990908b7eea73000069":[{"id":18851,"user_id":527,"body":"(ns complexs.core)\n\n(defn f [x y eps]\n  (let [m (Math\/hypot x y)]\n    (if (< m 1)\n      (int (\/ (Math\/log eps) (Math\/log m)))\n      -1)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18852,"user_id":492,"body":"(ns complexs.core)\n\n(defn- modul[x y]\n  (if (or (not (= x 0)) (not = y 0))\n    (Math\/sqrt (+ (* x x) (* y y)))\n    0.0))\n(defn f[x y eps]\n  (if (>= (modul x y) 1.0)\n    -1\n    (int (\/ (Math\/log eps) (Math\/log(modul x y))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18853,"user_id":53,"body":"(ns complexs.core)\n\n(defn hypot[a b]\n  (Math\/sqrt (+ (* a a) (* b b))))\n\n(defn f[x y eps]\n  (let [h (\/ (Math\/log eps) (Math\/log (hypot x y)))]\n    (if (< h 0)\n      -1\n      (int (Math\/floor h)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18854,"user_id":null,"body":"(ns complexs.core)\n\n(defn f[x y eps]\n  (let [m (Math\/sqrt (+ (* x x) (* y y)))]\n    (if (< m 1) (Math\/ceil (\/ (Math\/log eps) (Math\/log m))) -1)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18855,"user_id":492,"body":"(ns complexs.core)\n\n(defn- modul[x y]\n  (if (or (not (= x 0)) (not = y 0))\n    (Math\/sqrt (+ (* x x) (* y y)))\n    0.0))\n(defn f[x y eps]\n  (if (>= (modul x y) 1.0)\n    -1\n    (int (\/ (Math\/log eps) (Math\/log(modul x y))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18856,"user_id":168,"body":"(ns complexs.core)\n\n(defn f[x y eps]\n  (let [a (Math\/hypot x y)]\n    (if (>= a 1) -1 (\/ (Math\/log eps) (Math\/log a)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5b0c0ec907756ffcff00006e":[{"id":18857,"user_id":17,"body":"(ns quadraticroot.core)\n\n(defn quadratic [a b c] (- (\/ c b)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18858,"user_id":492,"body":"(ns quadraticroot.core)\n\n(defn quadratic [a b c]\n  (let [y (* b (- 1. 0 (\/ (* 2.0 a c)(* b b))))\n        x1 (\/ (- (+ y b))(* 2.0 a))\n        x2 (\/ c (* x1 a))]\n    (if (< (Math\/abs x1) (Math\/abs x2))\n      x1\n      x2)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18859,"user_id":null,"body":"(ns quadraticroot.core)\n\n(defn sqrt\n  ([n] (sqrt n 1e-24))\n  ([n epsilon]\n   (loop [t (bigint (Math\/sqrt n))]\n     (let [delta (Math\/abs (double (- (* t t) n)))]\n       (if (< delta epsilon)\n         t\n         (recur (\/ (+ t (\/ n t)) 2)))))))\n\n(defn quadratic [a b c]\n  (let [b (bigint b)]\n    (-> (\/ (+ (- b) (sqrt (- (* b b) (* 4 a c))))\n           (* 2 a))\n        double)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18860,"user_id":null,"body":"(ns quadraticroot.core)\n\n(defn sign [n]\n  (if (neg? n)\n    -1\n    1))\n\n(defn quadratic [a b c]\n  (let [x1 (\/ (- (- b)\n                 (* (sign b) (Math\/sqrt (- (* b b) (* 4 a c)))))\n              (* 2 a))\n        \n        x2 (\/ c (* a x1))]\n    x2))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18861,"user_id":null,"body":"(ns quadraticroot.core)\n\n(defn quadratic [_ b c]\n  (- (\/ c b)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18862,"user_id":null,"body":"(ns quadraticroot.core)\n\n(defn quadratic [a b c]\n  (\/ (* 2 c) (- 0 b (Math\/sqrt (- (* b b) (* 4 a c))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18863,"user_id":527,"body":"(ns quadraticroot.core)\n\n(defn quadratic [a b c]\n  (\/ (- c) b))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5b180e9fedaa564a7000009a":[{"id":18864,"user_id":null,"body":"(ns kata)\n\n(defn solve [s]\n  (let [u (count (filter #(Character\/isUpperCase %) s))\n        l (- (count s) u)]\n    (if (> u l) (clojure.string\/upper-case s)\n                (clojure.string\/lower-case s))))\n     \n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18865,"user_id":null,"body":"(ns kata)\n\n(defn solve [s]\n  (let [{lower-group true upper-group false} (group-by #(Character\/isLowerCase %) s)]\n    (if (>= (count lower-group) (count upper-group))\n      (clojure.string\/lower-case s)\n      (clojure.string\/upper-case s))))     \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18866,"user_id":null,"body":"(ns kata\n  (require [clojure.string :as str]))\n\n(defn solve [s]\n  (->> s \n    (reduce (fn[a,c] (if (= (str c) (str\/upper-case c)) a (+ a 1))) 0)\n    (#(>= % (\/ (count s) 2)))\n    (#(if % (str\/lower-case s) (str\/upper-case s)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18867,"user_id":null,"body":"(ns kata)\n(defn solve [s]\n  (let [u (count (filter #(Character\/isUpperCase %) s))\n        l (count (filter #(Character\/isLowerCase %) s))]\n    (if (> u l) (clojure.string\/upper-case s)\n                (clojure.string\/lower-case s))))\n     \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18868,"user_id":null,"body":"(ns kata)\n\n(defn solve [s]\n  (let [[uc lc] (reduce (fn [[uc lc] x]\n                          (if (#(Character\/isUpperCase x))\n                            [(inc uc) lc]\n                            [uc (inc lc)]))\n                        [0 0] s)]\n    (if (>= lc uc)\n      (clojure.string\/lower-case s)\n      (clojure.string\/upper-case s))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18869,"user_id":1703,"body":"(ns kata)\n\n(defn solve [s]\n  (let [l (Math\/ceil (\/ (count s) 2)) c (count (filter #(Character\/isLowerCase %) s)) ]\n    (if(>= c l) (clojure.string\/lower-case s)(clojure.string\/upper-case s))\n    ))     \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18870,"user_id":null,"body":"(ns kata)\n\n(require '[clojure.string :as str])\n\n(defn count-uppercase [s]\n  (count (filter #(Character\/isUpperCase %) s)))\n\n(defn solve [s]\n  (if (< (quot (count s) 2) (count-uppercase s))\n    (str\/upper-case s)\n    (str\/lower-case s)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18871,"user_id":null,"body":"(ns kata)\n\n(defn solve [s] (let [lower-count (count (filter #(Character\/isLowerCase %) s)) upper-count (- (count s) lower-count)]\n                       (if (> upper-count lower-count)\n                         (clojure.string\/upper-case s)\n                         (clojure.string\/lower-case s))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18872,"user_id":null,"body":"(ns kata)\n\n(defn solve [s]\n  (let [up (count (filter #(Character\/isUpperCase %) s))\n        down (- (count s) up)]\n    (cond (> up down) (clojure.string\/upper-case s)\n          :else (clojure.string\/lower-case s)))) \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18873,"user_id":null,"body":"(ns kata)\n\n(defn solve [s]\n  (let [n (count (filter #(Character\/isUpperCase %) s))]\n    (if (<= n (\/ (count s) 2))\n      (clojure.string\/lower-case s)\n      (clojure.string\/upper-case s))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5b1b27c8f60e99a467000041":[{"id":18874,"user_id":null,"body":"(ns anagram)\n\n(defn anagram-difference [w1 w2]\n     (let [f1 (frequencies (char-array w1))\n           f2 (frequencies (char-array w2))]\n     ;;(reduce +  (map #(Math\/abs %) (vals (merge-with - f1 f2)))))\n     ;; Subtract matching values in the two freq maps, absolute value of values,\n     ;; then sum\n     (->> (merge-with - f1 f2)\n          (vals)\n          (map #(Math\/abs %))\n          (reduce +)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18875,"user_id":null,"body":"(ns anagram)\n\n(defn add-to-bag [bag item]\n  (update bag item (fnil inc 0)))\n\n(defn sub-from-bag [bag item]\n  (update bag item (fnil dec 0)))\n\n(defn anagram-difference [w1 w2]\n  (-> {}\n      (#(reduce add-to-bag % w1))\n      (#(reduce sub-from-bag % w2))\n      ((fn [bag] (apply + (map #(Math\/abs %) (vals bag)))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18876,"user_id":null,"body":"(ns anagram (:require [clojure.set :refer [intersection]]))\n\n(defn anagram-difference [a b]\n  (-> [a b]\n      (->> (map frequencies)\n           (apply merge-with (partial min)))\n      (select-keys (intersection (set a) (set b)))\n      (->> vals\n           (apply +)\n           (* 2)\n           (- (+ (count a) (count b))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18877,"user_id":null,"body":"(ns anagram)\n\n(defn anagram-difference [w1 w2]\n  (apply + (vals (merge-with (comp #(Math\/abs %) -) (frequencies w1) (frequencies w2)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18878,"user_id":null,"body":"(ns anagram)\n\n(defn anagram-difference [w1 w2]\n   (reduce + (map #(Math\/abs %) (vals (merge-with - (frequencies w1) (frequencies w2)))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18879,"user_id":null,"body":"(ns anagram\n  (:require [clojure.set :as s]))\n\n(defn anagram-difference [w1 w2]\n  (let [[f1 f2] (map frequencies [w1 w2])\n        c (s\/intersection (set w1) (set w2))\n        n (reduce + (map #(min (f1 %) (f2 %)) c))]\n    (+ (count w1) (count w2) (* -2 n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18880,"user_id":null,"body":"(ns anagram)\n\n(defn anagram-difference [w1 w2]\n  (let [char_count_map #(-> (seq (char-array %)) frequencies)\n        diff_map (merge-with - (char_count_map w1) (char_count_map w2))\n        char_diff (reduce-kv #(if(not= %3 0) (+ %1 (max %3 (- %3))) %1) 0 diff_map)] \n    char_diff))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18881,"user_id":null,"body":"(ns anagram\n  (:require [clojure.set]))\n\n(defn anagram-difference [w1 w2]\n  (let [f1 (frequencies w1)\n        f2 (frequencies w2)\n        lets (into #{} (clojure.set\/union (keys f1) (keys f2)))\n        diff (for [l lets]\n               (Math\/abs (- (get f1 l 0) (get f2 l 0))))]\n    (apply + diff)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18882,"user_id":null,"body":"(ns anagram)\n\n(defn anagram-difference [w1 w2]\n  (loop [ct 0\n         [x & xs :as s1] (sort w1)\n         [y & ys :as s2] (sort w2)]\n    (let [cmp (compare x y)]\n      (cond\n        (or (nil? x) (nil? y)) (+ ct (count s1) (count s2))\n        (= cmp 0)              (recur ct xs ys)\n        (< cmp 0)              (recur (inc ct) xs s2)\n        (> cmp 0)              (recur (inc ct) s1 ys)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18883,"user_id":null,"body":"(ns anagram)\n\n(defn anagram-difference [w1 w2]\n  (let [f1          (frequencies (clojure.string\/upper-case w1))\n        f2          (frequencies (clojure.string\/upper-case w2))\n        upper-chars (map char (range 65 91))\n        abs         (fn [x] (max x (- x)))]\n    (reduce (fn [diff character]\n              (let [c1 (get f1 character 0)\n                    c2 (get f2 character 0)]\n               (+ (abs (- c1 c2)) diff)))\n               0 upper-chars)))\n\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5b1cd19fcd206af728000056":[{"id":18884,"user_id":168,"body":"(ns sersolve.core)\n\n(defn solve [m]\n  (\/ m (+ 0.5 m (Math\/sqrt (+ m 0.25)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18885,"user_id":null,"body":"(ns sersolve.core)\n\n(defn solve [m]\n  (\/ (- (inc (* 2 m)) (Math\/sqrt (inc (* 4 m)))) (* 2 m))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18886,"user_id":492,"body":"(ns sersolve.core)\n\n(defn solve [m]\n  (let [s (Math\/sqrt (+ 1.0 (* 4.0 m )))]\n    (\/ (- (+ 1.0 (* 2.0 m)) s) (* 2.0 m))))\n\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18887,"user_id":62,"body":"(ns sersolve.core)\n;; 1. infinite sum of k * x^k -> x\/(x-1)^2 = y \n;; 2. solving for x in terms of y yields a quadratic equation.\n;; 3. pick the root in the interval 0..1 by picking the smallest nonnegative root.\n\n(defn quadratic-roots [a b c]\n  (let [p (\/ (- b) 2 a)\n        q (\/ (Math\/sqrt (- (* b b) (* 4 a c))) 2 a)]\n  #{(+ p q) (- p q)}))\n\n(defn solve [m]\n    (if (zero? m) 0\n      (->> (quadratic-roots m (-(inc(* 2 m))) m)\n           (remove neg?)\n           (apply min))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18888,"user_id":null,"body":"(ns sersolve.core)\n\n(defn solve [m]\n  (inc (* (\/ 1 (* 2 m)) (- 1 (Math\/sqrt (inc (* 4 m)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18889,"user_id":191,"body":"(ns sersolve.core)\n\n(defn solve [m]\n  (+ 1 (\/ (- 0.5 (Math\/sqrt (+ 0.25 m))) m)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18890,"user_id":null,"body":"(ns sersolve.core)\n\n(defn solve [m]\n  (let [n (* 2.0 m)]\n    (\/ (- (+ n 1.0)\n          (Math\/sqrt (+ (* 2.0 n) 1.0)))\n       n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18891,"user_id":null,"body":"(ns sersolve.core)\n\n(defn square [x] (* x x))\n\n(defn solve [m]\n  (\/ (- (+ (* 2.0 m) 1.0)\n        (Math\/sqrt (- (square (+ (* 2.0 m) 1.0))\n                      (square (* 2.0 m)))))\n     (* 2.0 m)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18892,"user_id":null,"body":"(ns sersolve.core)\n\n(defn solve [m]\n  (- 1 (\/ (- (Math\/sqrt (+ (* 4 m) 1)) 1) (* 2 m))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18893,"user_id":null,"body":"(ns sersolve.core)\n\n(defn solve [m]\n  (\/ (- (+ (* 2 m) 1) (Math\/sqrt (+ (* 4 m) 1)))\n     (* 2 m)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5b40b666dfb4291ad9000049":[{"id":18894,"user_id":53,"body":"(ns walker.core)\n\n(defn dcos [n] (Math\/cos (\/ (* n Math\/PI) 180)))\n(defn dsin [n] (Math\/sin (\/ (* n Math\/PI) 180)))\n\n(defn solve [a b c alpha beta gamma]\n  (let [x (- (- (* a (dcos alpha)) (* b (dsin beta))) (* c (dcos gamma)))\n        y (- (+ (* a (dsin alpha)) (* b (dcos beta))) (* c (dsin gamma)))\n        t (\/ (* (Math\/atan2 y x) 180) Math\/PI)]\n    (list \n     (int (Math\/round (Math\/hypot x y)))\n     (int (Math\/floor t))\n     (rem (int (Math\/floor (* t 60))) 60)\n     (rem (int (Math\/floor (* t 3600))) 60))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18895,"user_id":492,"body":"(ns walker.core)\n\n(defn solve [a b c alpha beta gamma]\n  (let [aa (\/ (* alpha Math\/PI) 180) bb (\/ (* beta Math\/PI) 180) cc (\/ (* gamma Math\/PI) 180)\n        x (- (* a (Math\/cos aa)) (* b (Math\/sin bb)) (* c (Math\/cos cc)))\n        y (+ (* a (Math\/sin aa)) (* b (Math\/cos bb)) (* -1 c (Math\/sin cc)))\n        r (Math\/sqrt (+ (* x x) (* y y)))\n        t (int (\/ (* (Math\/acos (\/ x r)) 180 3600) Math\/PI))\n        d (quot t 3600)\n        mm (mod t 3600)\n        m (quot mm 60)\n        s (mod mm 60)\n       ]\n    [(Math\/round r) d m s]))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18896,"user_id":null,"body":"(ns walker.core)\n\n(def pi\n  3.14159265358979323846)\n\n(defn ->rad\n  [x]\n  (\/ (* x pi) 180.0))\n  \n(defn xy\n  [h deg]\n  (let [r (->rad deg)]\n    [(* (Math\/cos r) h) (* (Math\/sin r) h)]))\n\n(defn xy-1\n  [a alpha]\n  (xy a alpha))\n  \n(defn xy-2\n  [a alpha]\n  (let [[x y] (xy a alpha)]\n    [(- y) x]))\n    \n(defn xy-3\n  [a alpha]\n  (let [[x y] (xy a alpha)]\n    [(- x) (- y)]))\n    \n(defn add\n  [& vs]\n  (let [xs (map first vs)\n        ys (map second vs)]\n    [(apply + xs) (apply + ys)]))\n    \n(defn hyp\n  [[x y]]\n  (-> (+ (* x x) (* y y)) Math\/sqrt Math\/round))\n\n(defn solve\n  [a b c alpha beta gamma]\n  (let [a (xy-1 a alpha)\n        b (xy-2 b beta)\n        c (xy-3 c gamma)\n        [x y] (add a b c)\n        h (hyp [x y])\n        degrees (-> (\/ y x) Math\/atan Math\/toDegrees (+ 180))\n        degs (int degrees)\n        minutes (-> (- degrees degs) (* 60))\n        mins (-> minutes int)\n        secs (-> (- minutes mins) (* 60) int)]\n  [h degs mins secs]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18897,"user_id":null,"body":"(ns walker.core)\n\n(defn deg->rad [x]\n  (* x Math\/PI 1\/180))\n\n(defn rad->deg [x]\n  (\/ x Math\/PI 1\/180))\n\n(defn angle-decompose [x]\n  (vector\n    (int x)\n    (int (rem (* x 60) 60))\n    (int (rem (* x 3600) 60))))\n\n(defn solve [a b c alpha beta gamma]\n  (let [alpha (deg->rad alpha)\n        beta (deg->rad beta)\n        gamma (deg->rad gamma)\n        a1 (* a (Math\/sin alpha))\n        a2 (* a (Math\/cos alpha))\n        b1 (* b (Math\/cos beta))\n        b2 (* b (Math\/sin beta))\n        c1 (* c (Math\/sin gamma))\n        c2 (* c (Math\/cos gamma))\n        d1 (+ a1 b1 (- c1))\n        d2 (+ b2 c2 (- a2))\n        d (Math\/sqrt (+ (* d1 d1) (* d2 d2)))\n        toc (rad->deg (- Math\/PI (Math\/atan (\/ d1 d2))))]\n    (cons (Math\/round d) (angle-decompose toc))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18898,"user_id":null,"body":"(ns walker.core)\n\n\n(defn aX [a alpha]\n  (* a (Math\/cos alpha)))\n  \n(defn aY [a alpha]\n  (* a (Math\/sin alpha)))\n\n(defn bX [a b alpha beta]\n  (- \n    (aX a alpha)\n    (* b (Math\/sin beta))))\n\n(defn bY [a b alpha beta]\n  (+ \n    (aY a alpha)\n    (* b (Math\/cos beta))))\n\n(defn cX  [a b c alpha beta gamma]\n  (-\n    (bX a b alpha beta)\n    (* c (Math\/cos gamma))))\n    \n(defn cY [a b c alpha beta gamma]\n  (-\n    (bY a b alpha beta)\n    (* c (Math\/sin gamma))))\n\n(defn dist [x1 y1 x2 y2]\n  (Math\/pow \n    (+\n      (* (- x2 x1) (- x2 x1))\n      (* (- y2 y1) (- y2 y1)))\n    0.5))\n\n(defn positiveDegrees [radians]\n  (Math\/toDegrees ; convert to degrees\n    (if (> radians 0) ; get positive radians\n      radians\n      (+ radians Math\/PI))))\n\n(defn angle [x y]\n  \"Returns the radial angle from the origin in degrees (only for upper 2 quadrants)\"\n  (if (= x 0) ; avoid divide by 0 \n    90\n    (positiveDegrees (Math\/atan (\/ y x)))))\n\n; shortcut\n(def rad #(Math\/toRadians %1))\n\n(defn solve [a b c alpha beta gamma]\n  (let [cx (cX a b c (rad alpha) (rad beta) (rad gamma))\n     cy (cY a b c (rad alpha) (rad beta) (rad gamma))\n     degrees (angle cx cy)]\n     [\n       (Math\/round (dist cx cy 0 0)) ; distance from C to A\n       (int degrees)\n       (int (mod (* 60 degrees) 60))\n       (int (mod (* 60 (mod (* 60 degrees) 60)) 60))\n       ]))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18899,"user_id":null,"body":"(ns walker.core)\n\n(defn solve [a b c alpha beta gamma]\n  (let [[alpha beta gamma] (map #(Math\/toRadians %) [alpha beta gamma])\n        x (- (* a (Math\/cos alpha)) (* b (Math\/sin beta)) (* c (Math\/cos gamma)))\n        y (+ (* a (Math\/sin alpha)) (* b (Math\/cos beta)) (* -1 c (Math\/sin gamma)))\n        tOC (+ 180 (Math\/toDegrees (Math\/atan (\/ y x))))\n        tOCMin (* 60 (mod tOC 1))\n        tOCSec (* 60 (mod tOCMin 1))]\n    [(Math\/round (Math\/hypot x y))\n     (int tOC)\n     (int tOCMin)\n     (int tOCSec)]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5b4e779c578c6a898e0005c5":[{"id":18900,"user_id":null,"body":"(ns kata\n  (:require [clojure.string :as string]))\n\n(defn draw_stairs [n]\n  (string\/join \"\n\"\n               (map #(str (string\/join \"\" (repeat % \" \")) \\I)\n                    (range n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18901,"user_id":null,"body":"(ns kata)\n(defn draw_stairs\n  [n]\n  (->> \"I\"\n       (iterate (partial str \" \"))\n       (take n)\n       (clojure.string\/join \"\n\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18902,"user_id":null,"body":"(ns kata)\n(defn draw_stairs [n]\n  (clojure.string\/join \"\n\"\n    (for [i (range 0 n)]\n      (str(clojure.string\/join (repeat i \" \")) \"I\")))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18903,"user_id":null,"body":"(ns kata\n  (:require [clojure.string :as string]))\n\n(defn- spaces\n  [n]\n  (->> \\space (repeat n) (reduce str)))\n\n(defn- step\n  [n]\n  (str (spaces n) \\I))\n\n(defn draw_stairs\n  [n]\n  (->> n\n       range\n       (map #(step %))\n       (string\/join \"\n\")))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18904,"user_id":1703,"body":"(ns kata)\n\n(defn draw [n s](\n   cond\n      (= 1 n) (str \"I\" s)\n      :else (draw (dec n) (str \"\n\" (clojure.string\/join \"\" (repeat (dec n) \" \")) \"I\" s))\n))\n\n(defn draw_stairs [n]\n  (draw n \"\")\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18905,"user_id":null,"body":"(ns kata)\n(defn draw_stairs [n]\n  (clojure.string\/join \"\n\" (map (fn [i] (str (apply str (repeat i \" \")) \"I\")) (range n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18906,"user_id":null,"body":"(ns kata)\n\n(defn repeat-str [n strng]\n  (clojure.string\/join (repeat n strng)))\n\n(defn draw_stairs [n]\n  (let [stair \"\"]\n    (clojure.string\/join \"\" (map #(.concat stair\n                                           (str (repeat-str % \" \")\n                                                (if (= % (- n 1)) \"I\" \n                                                                  \"I\n\")))\n                                 (range n)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18907,"user_id":null,"body":"(ns kata)\n\n(defn repeat-str [n strng]\n  (clojure.string\/join (repeat n strng)))\n\n(defn draw_stairs [n]\n  (let [stair \"\"]\n    (clojure.string\/join \"\" (map #(.concat stair\n                                           (str (repeat-str % \" \")\n                                                (if (= % (- n 1)) \"I\"\n                                                            \"I\n\")))\n                                 (range 0 n)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18908,"user_id":null,"body":"(ns kata)\n(defn draw_stairs [n]\n  (let [l (range 1 n)\n        s (apply str (map #(apply str \"I\n\" (repeat % \" \")) l))]\n    (str s \"I\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18909,"user_id":null,"body":"(ns kata)\n\n(defn draw-step [level]\n  (apply str (concat (repeat level \" \") \"I\")))\n\n(defn draw_stairs [n]\n  (->> (range n)\n    (map draw-step)\n    (clojure.string\/join \"\n\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5b752a42b11814b09c00005d":[{"id":18910,"user_id":null,"body":"(ns kata.core)\n\n(defn solve \n  [a b]\n  (println a b)\n  (cond \n    (or (zero? a) (zero? b)) (list a b)\n    (>= a (* 2 b)) (solve (- a (* 2 b)) b)\n    (>= b (* 2 a)) (solve a (- b (* 2 a)))\n    :else (list a b)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18911,"user_id":null,"body":"(ns kata.core)\n\n(defn solve\n  [a b]\n  (cond (or (= a 0) (= b 0)) (list a b)\n    (>= a (* 2 b)) (solve (- a (* 2 b)) b)\n    (>= b (* 2 a)) (solve a (- b (* 2 a)))\n    :else (list a b)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18912,"user_id":null,"body":"(ns kata.core)\n\n(defn solve\n  [a b]\n  (cond (or (zero? a) (zero? b)) (list a b)\n        (>= a (* 2 b)) (recur (- a (* 2 b)) b)\n        (>= b (* 2 a)) (recur a (- b (* 2 a)))\n        :else (list a b)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18913,"user_id":null,"body":"(ns kata.core)\n\n(defn solve [a b]\n  (loop [a' a b' b]\n    (cond\n      (some zero? [a' b']) [a' b']\n      (<= (+ b' b') a') (recur (- a' b' b') b')\n      (<= (+ a' a') b') (recur a' (- b' a' a'))\n      :else [a' b']\n    )))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18914,"user_id":null,"body":"(ns kata.core)\n\n(defn solve\n  [a b]\n  (if (or (zero? a) (zero? b))\n    (list a b)\n    (if (>= a (* 2 b))\n      (solve (- a (* 2 b)) b)\n      (if (>= b (* 2 a))\n        (solve a (- b (* 2 a)))\n        (list a b)\n        ))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18915,"user_id":881,"body":"(ns kata.core)\n\n(defn solve\n  [a b]\n  (if (or (zero? a) (zero? b))\n    (list a b)\n    (if (>= a (* b 2))\n      (recur (- a (* b 2)) b)\n      (if (>= b (* a 2))\n        (recur a (- b (* a 2)))\n        (list a b)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18916,"user_id":null,"body":"(ns kata.core)\n\n(defn solve\n  [a b]\n  (cond\n    (or (= a 0) (= b 0)) [a b]\n    (>= a (* 2 b)) (recur (- a (* 2 b)) b)\n    (>= b (* 2 a)) (recur a (- b (* 2 a)))\n    :else [a b]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18917,"user_id":null,"body":"(ns kata.core)\n\n(defn shrink-if-double [a b]\n  (let [b2 (* 2 b)]\n  (if (>= a b2) (- a b2) a)))\n\n(defn solve [a b]   \n    (loop [a a\n           b b]\n      (let [a2 (shrink-if-double a b)\n            b2 (shrink-if-double b a)]\n    (if (or (= [a b] [a2 b2]) (== 0 a) (== 0 b))\n      [a b]\n      (recur a2 b2)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18918,"user_id":571,"body":"(ns kata.core)\n\n(defn solve [a b]\n    (if (= a 0) (list a b) \n      (if (>= a (* 2 b)) (solve (- a (* 2 b)) b)\n        (if (>= b (* 2 a)) (solve a (- b (* 2 a))) (list a b)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18919,"user_id":null,"body":"(ns kata.core)\n\n(defn solve\n  [a b]\n  (loop [a a b b]\n    (if (or (zero? a)(zero? b))\n      [a, b]\n      (if (>= a (* 2 b))\n        (recur (- a (* 2 b)) b)\n        (if (>= b (* 2 a))\n          (recur a (- b (* 2 a)))\n            [a, b])))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5b94d7eb1d5ed297680000ca":[{"id":18920,"user_id":null,"body":"(ns kata)\n\n(def begin \"Begin\")\n(def left \"Left\")\n(def right \"Right\")\n(def separator-sp #\" on \")\n(def separator \" on \")\n\n(defn- reverse-direction\n  [d]\n  (condp = d\n    left right\n    right left\n    begin))\n\n(defn- parse [dirs] (map #(clojure.string\/split % separator-sp) dirs))\n(defn- join [dirs] (map #(clojure.string\/join separator %) dirs))\n\n(defn solve [dirs]\n  (let [\n    parsed (parse dirs)\n    reversed (reverse parsed)\n    right (map-indexed\n           (fn [idx [_ address]]\n             (if\n               (= idx 0)\n               [(reverse-direction nil) address]\n               [(reverse-direction (first (nth reversed (dec idx)))) address]))\n           reversed)\n    result (join right)\n  ] result))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18921,"user_id":null,"body":"(ns kata)\n\n(defn parse-item [itm]\n  (let [[dir _ & dst] (re-seq #\"\\S+\" itm)]\n    [dir (clojure.string\/join \" \" dst)]))\n\n(defn synth-item [[dir dst]]\n  (str dir \" on \" dst))\n\n(defn opposite-dir [dir]\n  (case dir\n    \"Left\" \"Right\"\n    \"Right\" \"Left\"\n    dir))\n\n(defn opposite-dir-item [[dir dst]]\n  [(opposite-dir dir) dst])\n\n(defn solve [dirs]\n  (->>\n    dirs\n    (map parse-item)\n    (flatten)\n    (rest)\n    (reverse)\n    (cons \"Begin\")\n    (partition 2)\n    (map opposite-dir-item)\n    (map synth-item)\n  )\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18922,"user_id":null,"body":"(ns kata)\n\n(defn solve [directions]\n  (let [opposite-directions (as-> (reverse directions) v\n                                  (map #(first (clojure.string\/split % #\"\\s+\")) v)\n                                  (map #(case % \"Left\" \"Right\" \"Right\" \"Left\" %) v)\n                                  (flatten [(last v) (drop-last 1 v)]))]\n    (map-indexed #(clojure.string\/replace-first %2 #\"Right|Left|Begin\" (nth opposite-directions %1)) (reverse directions))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18923,"user_id":209,"body":"(ns kata)\n\n(defn solve [p]\n  (def a (map (fn [x] (clojure.string\/split x #\" on \")) p))\n  (def q (concat (map (fn [x] (if (= (nth x 0) \"Left\") \"Right\" \"Left\")) a) (take 1 (nth a 0))))\n  (map (fn [x] (str (nth x 0) \" on \" (nth x 1))) (map list (reverse q) (map (fn [x] (nth x 1)) (reverse a)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18924,"user_id":null,"body":"(ns kata\n  (require [clojure.string :as str]))\n\n(defn solve [dirs]\n  (letfn [(reverse-after-begin [n xs]\n            (concat (take n xs) (reverse (drop n xs))))\n          (reverse-turns [t]\n             (cond (= \"Right\" t) \"Left\"\n                   (= \"Left\" t) \"Right\"\n                   :else \"Begin\"))]\n    (let [directions (map (fn [d] (str\/split d #\" on \")) dirs)\n          turns (->> (map first directions)\n                     (map reverse-turns)\n                     ((partial reverse-after-begin 1)))\n          streets (reverse (map second directions))]\n      (map (fn [t s] (str t \" on \" s)) turns streets))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18925,"user_id":null,"body":"(ns kata\n  (:require [clojure.string :as str]))\n\n(defn swap-directions [turn]\n  (cond (= \"Right\" turn) \"Left\"\n        (= \"Left\" turn) \"Right\"\n        :else \"Begin\"))\n\n(defn reverse-after [n xs]\n  (concat (take n xs) (reverse (drop n xs))))\n\n(defn solve [dirs]\n  (let [directions (map (fn [d] (str\/split d #\" on \")) dirs)\n        turns (->> (map first directions)\n                   (map swap-directions)\n                   ((partial reverse-after 1)))\n        streets (reverse (map second directions))]\n    (map (fn [t s] (str t \" on \" s)) turns streets)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5bb804397274c772b40000ca":[{"id":18926,"user_id":null,"body":"(ns kata)\n(defn stack-height-2d [n]\n  (if (zero? n) 0.0 (+ 1 (* (- n 1) (\/ (Math\/sqrt 3) 2))))\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18927,"user_id":null,"body":"(ns kata)\n(defn stack-height-2d\n  [layers]\n  (if (zero? layers)\n    layers\n    (inc (* (dec layers) (\/ (Math\/sqrt 3) 2)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18928,"user_id":null,"body":"(ns kata)\n(defn ** [n]\n  (* n n))\n\n(defn stack-height-2d [n]\n  (if (zero? n)\n    0\n    (+ 1 (Math\/sqrt (- (** (- n 1.0))\n                       (** (\/ (- n 1.0) 2.0)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18929,"user_id":null,"body":"(ns kata)\n(defn stack-height-2d [layers]\n  (def a (- layers 1))\n  (def b (* 0.5 (- layers 1)))\n  (def a-squared (Math\/pow a 2))\n  (def b-squared (Math\/pow b 2))\n  (if (= layers 0)\n    0\n    (+ 1 (Math\/sqrt (- a-squared b-squared)))\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18930,"user_id":null,"body":"(ns kata)\n\n(defn stack-height-2d [layers]\n  (if (zero? layers) 0\n    (+ (* layers 0.86603) 0.13397)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18931,"user_id":null,"body":"(ns kata)\n\n(defn stack-height-2d [layers]\n  (if (zero? layers) 0\n    (inc (Math\/sqrt (* 3\/4 (dec layers) (dec layers))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18932,"user_id":527,"body":"(ns kata)\n\n(defn stack-height-2d [layers]\n  (if (zero? layers) 0 (inc (* (dec layers) (\/ (Math\/sqrt 3) 2)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18933,"user_id":645,"body":"(ns kata)\n(defn stack-height-2d [layers]\n  (if (< 0 layers) (+ 1 (* (- layers 1) (\/ (Math\/sqrt 3) 2))) 0))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18934,"user_id":645,"body":"(ns kata)\n(defn stack-height-2d [layers]\n  (if (< 0 layers) (+ 1 (* (- layers 1) (\/ (Math\/sqrt 3) 2))) 0))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5bb904724c47249b10000131":[{"id":18935,"user_id":201,"body":"(ns kata)\n\n(defn points [games]\n  (reduce + (map (fn [game] \n         (let [x (int (first game))\n               y (int (last game))]\n           (cond (> x y) 3\n                 (== x y) 1\n                 :else 0))) games)))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18936,"user_id":null,"body":"(ns kata)\n\n(defn zipped-game [game]\n  (let [t1   (Character\/digit (first game) 10)\n        t2  (Character\/digit (last game) 10)]\n    (zipmap [:t1 :t2] [t1 t2])))\n\n(defn points [games]\n  (let [kv-map (map zipped-game games)]\n    (reduce (fn [acc {t1 :t1 t2 :t2}]\n              (cond\n                (> t1 t2) (+ acc 3)\n                (< t1 t2) acc\n                (= t1 t2) (+ acc 1))) 0 kv-map)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18937,"user_id":null,"body":"(ns kata\n  (:require [clojure.string :as str]))\n\n(defn points [games]\n  ; TODO\n(let [kv-map (map #(zipmap [:t1 :t2] %) (reduce (fn [acc v]\n                                                    (conj acc (map #(. Integer parseInt %) v))) [] (map #(str\/split % #\":\")\n                                                                                                        games)))]\n    (reduce (fn [acc v]\n              (if (and (<= 0 (:t1 v) 4) (<= 0 (:t2 v) 4))\n                (cond\n                  (> (:t1 v) (:t2 v)) (+ acc 3)\n                  (< (:t1 v) (:t2 v)) acc\n                  (= (:t1 v) (:t2 v)) (+ acc 1)) 0)) 0 kv-map))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18938,"user_id":null,"body":"(ns kata)\n\n(defn points [games]\n  (reduce + (map #(let [[_ xc yc] (re-matches #\"(\\d):(\\d)\" %)\n                        x (Integer\/parseInt xc)\n                        y (Integer\/parseInt yc)]\n                    (cond\n                      (> x y) 3\n                      (< x y) 0\n                      (= x y) 1)) games)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18939,"user_id":null,"body":"(ns kata)\n\n(defn matchpoints [score]\n  (def x (int (first score)))\n  (def y (int (last score)))\n  (cond (= x y) 1\n        (> x y) 3\n        :else 0)\n  )\n\n(defn points [games]\n  (reduce + (map matchpoints games))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18940,"user_id":null,"body":"(ns kata)\n\n(defn matchresult [m]\n  (let \n    [\n         [our their]      (map #(Integer\/parseInt %1) (clojure.string\/split m #\":\"))\n    ] (cond \n        (> our their)  3\n        (= our their)  1\n        :else          0\n        )))\n\n(defn points [games]\n  (apply + (map matchresult games)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18941,"user_id":null,"body":"(ns kata)\n\n(defn calculate-points [match]\n  (let [home (Integer\/parseInt (first match))\n        visitor (Integer\/parseInt (second match))]\n    (cond\n      (> home visitor) 3\n      (< home visitor) 0\n      :else 1)))\n\n(defn points [games]\n  (reduce + (map #(-> % (clojure.string\/split #\":\") calculate-points) games)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18942,"user_id":null,"body":"(ns kata)\n(require '[clojure.string :as str])\n\n(defn to-numbers [game]\n  (map read-string\n    (str\/split game #\":\")\n) )\n\n(defn score [game]\n  (let [scores (to-numbers game)]\n    (if\n      (> (nth scores 0) (nth scores 1))\n      3\n      (if\n        (< (nth scores 0) (nth scores 1))\n        0\n        1\n) ) ) )\n\n(defn points [games]\n  ( ->> games\n    (map score)\n    (apply +)\n) )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18943,"user_id":null,"body":"(ns kata)\n\n(defn scorer\n  [game]\n  (let [[x y] (->> (clojure.string\/split game #\":\")\n                   (map #(Integer\/parseInt %)))]\n    (cond\n      (> x y) 3\n      (< x y) 0\n      (= x y) 1)))\n\n(defn points\n  [games-array]\n  (->> (map scorer games-array)\n       (reduce +)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18944,"user_id":null,"body":"(ns kata\n  (:require [clojure.string :as str]))\n\n(defn scorer [game]\n  (let [[x y] (->> (str\/split game #\":\")\n                    (map (fn [x] (Integer\/parseInt x))))]\n    (cond (> x y) 3\n          (< x y) 0\n          (= x y) 1)))\n\n(defn points [games]\n  (->> (map scorer games)\n       (reduce +)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5bc052f93f43de7054000188":[{"id":18945,"user_id":168,"body":"(ns kata)\n\n(defn solve [s1 s2]\n  (.matches s2 (clojure.string\/replace s1 \"*\" \".*\")))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18946,"user_id":201,"body":"(ns kata)\n\n(defn solve [s1 s2]\n  (= s2\n     (re-matches (re-pattern (clojure.string\/replace s1 \"*\" \".*\")) s2)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18947,"user_id":null,"body":"(ns kata)\n\n(defn make-matcher [s]\n  (if (not (clojure.string\/includes? s \"*\"))\n    s\n    (let [parts (clojure.string\/split s #\"\\*\")]\n      (str (first parts) \"[A-Za-z0-9]*\" (second parts)))))\n\n(defn solve [s1 s2]\n  (cond\n    (= s1 s2) true\n    (= \"*\" s1) true\n    :else (= s2 (re-matches (re-pattern (make-matcher s1)) s2))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18948,"user_id":null,"body":"(ns kata\n  (:require [clojure.string :as str]))\n\n\n(defn edgecases [s1 s2]\n  (if (= s1 s2) true false)\n  )\n(defn edgecases2 [s1 s2]\n  (def clear (str\/join \"\" (filter #(not (= % \"*\")) (str\/split s1 #\"\\*\"))))\n  (if (> (count clear) (count s2)) false true)\n  )\n(defn main [s1 s2]\n  (def str_1 (str\/split s1 #\"\\*\"))\n  (def str_2   (str\n                (subs s2 0 (count (first str_1)))\n                (apply str (reverse (subs (apply str (reverse s2)) 0 (count (second str_1)))))))\n  (if (and\n       (= (str\/join \"\" str_1) str_2)\n       (.contains (str\/split s1 #\"\") \"*\")) true false)\n  )\n(defn solve [s1 s2]\n  (def edge (edgecases s1 s2))\n  (def edge2 (edgecases2 s1 s2))\n  (cond\n    (= edge true) true\n    (= edge2 false) false\n    :else (main s1 s2)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18949,"user_id":null,"body":"(ns kata)\n\n(defn solve\n  [s1 s2]\n  (->\n   s1\n   (clojure.string\/replace #\"\\*\" \".*\")\n   (re-pattern)\n   (re-seq s2)\n   (first)\n   (= s2)))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18950,"user_id":53,"body":"(ns kata)\n\n(defn solve [a b] (= b (re-matches (re-pattern (clojure.string\/replace a \"*\" \".*\")) b)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18951,"user_id":null,"body":"(ns kata\n  (:require [clojure.string :as s]))\n\n(defn solve [s1 s2]\n  (if (re-matches \n    (re-pattern (-> s1\n     (s\/replace \"*\" \".*\"))) s2) true false))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18952,"user_id":null,"body":"(ns kata\n  (:require [clojure.string :as str]))\n\n(defn fill-asterix [s1 s2]\n  (prn s1)\n  (prn s2)\n  (let [[s1b s1a] (str\/split s1 #\"\\*\")\n        s1-lr (str\/index-of s1 \"*\")\n        s1-rl (str\/index-of (str\/reverse s1) \"*\")]\n    (str s1b (subs s2 s1-lr (- (count s2) s1-rl)) s1a)))\n\n(defn solve [s1 s2]\n  (cond (or (= s1 s2)\n            (= s1 \"*\")\n            (= s2 (str\/replace s1 \"*\" \"\")))\n        true\n              \n        (or (not (str\/includes? s1 \"*\"))\n            (> (count s1) (count s2)))\n        false\n\n        (= s2 (fill-asterix s1 s2))\n        true\n\n        :else\n        false))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18953,"user_id":null,"body":"(ns kata)\n\n(defn solve [s1 s2]\n  (let [s1-re-pat-str (clojure.string\/replace s1 #\"[*]\" \".*\")\n        s1-re-pat (re-pattern (str \"^\" s1-re-pat-str \"$\"))]\n    (some? (re-matches s1-re-pat s2))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5bd776533a7e2720c40000e5":[{"id":18954,"user_id":527,"body":"(ns kata)\n\n(defn pendulum [xs]\n  (let [xs (sort xs)]\n    (concat (reverse (take-nth 2 xs)) (take-nth 2 (rest xs)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18955,"user_id":null,"body":"(ns kata)\n\n(defn pendulum [numbers]\n  (let [true-false-seq (flatten (repeat '(:true :false)))\n        sorted-nums (sort numbers)\n        nums-even-ordinal-pair-seq (partition 2 (interleave sorted-nums true-false-seq))\n        two-group (group-by second nums-even-ordinal-pair-seq)\n        odd-ordinals (map first (:true two-group))\n        even-ordinals (map first (:false two-group))]\n    (concat (reverse odd-ordinals) even-ordinals)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18956,"user_id":null,"body":"(ns kata)\n\n(defn pendulum [numbers]\n  (let [sorted (sort numbers)\n        sol (take-nth 2 (concat (reverse sorted) sorted))]\n  (if (even? (count numbers))\n    (reverse sol)\n    sol)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18957,"user_id":null,"body":"(ns kata)\n\n(defn pendulum \n  [numbers]\n  (let [sorted-numbers (sort numbers)\n        first-half     (reverse (take-nth 2 sorted-numbers))\n        last-half      (take-nth 2 (rest sorted-numbers))]\n    (concat first-half last-half)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18958,"user_id":201,"body":"(ns kata)\n\n(defn pendulum [numbers]\n  (let [s (sort numbers)]\n    (flatten\n     (concat (reverse (partition 1 2 s))\n             (partition 1 2 (rest s))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5ca3ae9bb7de3a0025c5c740":[{"id":18959,"user_id":null,"body":"(ns running-lambda.core)\n\n(defn point [x y] #(if % x y))\n(defn fst [p] (p true))\n(defn snd [p] (p false))\n(defn sqr-dist [p p']\n  (let [square #(* % %)\n        x (fst p) y (snd p)\n        x' (fst p') y' (snd p')]\n    (+\n      (square (- x x'))\n      (square (- y y')))))\n(defn line [p p']\n  (let [x (fst p) y (snd p)\n        x' (fst p') y' (snd p')\n        l (- y y')\n        m (- x' x)\n        n (- 0 (* l x) (* m y))]\n  [l m n]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18960,"user_id":null,"body":"(ns running-lambda.core)\n\n(defn point [a b]\n  (fn [] [a b])\n)\n(defn fst [point]\n  (nth (point) 0)\n)\n(defn snd [point]\n  (nth (point) 1)\n)\n(defn sqr-dist [point1 point2]\n    (reduce + (map (comp #(* % %) -) (point1) (point2))))\n(defn line [foo bar]\n  (let [[x1 y1] (foo)\n        [x2 y2] (bar)]\n    [(- y2 y1) (- x1 x2) (- (* y1 x2)\n                            (* x1 y2))])\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18961,"user_id":null,"body":"(ns running-lambda.core)\n\n(defn delta-sqr [a b] (Math\/pow (- b a) 2))\n\n(defn point [a b] (fn [x] (case x :x a :y b nil)))\n(defn fst [point] (point :x))\n(defn snd [point] (point :y))\n(defn sqr-dist [point1 point2]\n  (int (+ (delta-sqr (fst point1) (fst point2))\n          (delta-sqr (snd point1) (snd point2)))))\n(defn line [foo bar]\n  (let [[[x1 y1] [x2 y2]] (map (juxt fst snd) [foo bar])]\n    [(- y1 y2) (- x2 x1) (- (* x1 y2) (* x2 y1))]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18962,"user_id":null,"body":"(ns running-lambda.core)\n\n(defn abs [n] (max n (-' n)))\n\n(defn point [a b]\n  (fn [x] (case x :x a :y b nil)))\n(defn fst [point]\n  (point :x))\n(defn snd [point]\n  (point :y))\n(defn sqr-dist [point1 point2]\n  (int\n   (+ (Math\/pow (abs (- (fst point1) (fst point2))) 2)\n      (Math\/pow (abs (- (snd point1) (snd point2))) 2))))\n(defn line [foo bar]\n  (let [[[x1 y1] [x2 y2]] (map (juxt fst snd) [foo bar])]\n    [(- y1 y2) (- x2 x1) (- (* x1 y2) (* x2 y1))]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18963,"user_id":null,"body":"(ns running-lambda.core)\n\n(defn point [a b]\n   (fn [] [a b]))\n  \n(defn fst [point]\n  (first (point)))\n  \n(defn snd [point]\n  (second (point)))\n  \n(defn sqr-dist [point1 point2]\n  (let [delta-x (Math\/abs (- (fst point2) (fst point1)))\n        delta-y (Math\/abs (- (snd point2) (snd point1)))]\n        (+ (* delta-x delta-x) (* delta-y delta-y))))\n        \n(defn line [foo bar]\n  [(- (snd foo) (snd bar))\n   (- (fst bar) (fst foo))\n   (- (* (fst foo) (snd bar))\n         (* (snd foo) (fst bar)))])","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18964,"user_id":492,"body":"(ns running-lambda.core)\n\n(defn point [a b]\n  (fn [x] (if x a b)))\n(defn fst [point]\n  (point true))\n(defn snd [point]\n  (point false))\n\n(defn sqr-dist [point1 point2]\n  (defn- sqr [x] (* x x))\n  (+ (sqr (- (fst point1) (fst point2)))\n     (sqr (- (snd point1) (snd point2)))))\n\n(defn line [foo bar]\n  (defn- det [a b c d]\n    (- (* a d) (* b c)))\n  (let [x1 (fst foo) x2 (fst bar)\n        y1 (snd foo) y2 (snd bar)\n        dp (det -1 y1 -1 y2) dq (det x1 -1 x2 -1)\n        d (det x1 y1 x2 y2)\n       ]\n      (list dp dq d))) \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5cb05eee03c3ff002153d4ef":[{"id":18965,"user_id":null,"body":"(ns kata)\n(defn get_section_id [scroll sizes]\n(cond \n  (> 0 (- scroll (first sizes))) 0\n  (>= scroll (apply + sizes)) -1\n  \n\n  :else \n  (+ 1 \n     (get_section_id\n      (- scroll \n         (first sizes)) \n           (rest sizes)))\n  )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18966,"user_id":527,"body":"(ns kata)\n\n(defn get_section_id-for-real [scroll sizes]\n  (->> sizes (reductions +) (keep-indexed #(when (< scroll %2) %1)) first))\n\n(defn get_section_id [scroll sizes]\n  (or (get_section_id-for-real scroll sizes) -1))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18967,"user_id":363,"body":"(ns kata)\n(defn get_section_id [scroll sizes]\n  (cond\n    (>= scroll (apply + sizes)) -1\n    (empty? sizes) -1\n    (neg? (- scroll (first sizes))) 0\n    :else (inc (get_section_id (- scroll (first sizes)) (rest sizes)))\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18968,"user_id":null,"body":"(ns kata)\n(defn get_section_id [scroll sizes] \n  (def s(for [x (range 1 (inc (count sizes)))\n     :when(> (apply +(subvec sizes 0 x)) scroll)\n        ]\n        (dec x)\n    ))\n  (cond \n  (empty? s) -1\n       :else (first s)       )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18969,"user_id":null,"body":"(ns kata)\n(defn get_section_id [scroll sizes]\n  (if (>= scroll (reduce + sizes))-1\n    (count (filter #(<= % scroll) \n          (for [i (range 0 (count sizes))] \n          (reduce + (subvec sizes 0 (+ 1 i))))\n                 )))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18970,"user_id":null,"body":"(ns kata)\n(defn get_section_id [scroll sizes]\n  (cond\n        (empty? sizes) -1\n        (> 0 (- scroll (first sizes))) 0\n        (= -1 (get_section_id (- scroll (first sizes)) (rest sizes))) -1\n        :else (inc (get_section_id (- scroll (first sizes)) (rest sizes)))\n    )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18971,"user_id":null,"body":"(ns kata)\n(defn get_section_id [scroll sizes]\n  (if (>= scroll (apply + sizes)) \n    -1\n    (cond \n      (< scroll (get sizes 0)) 0\n      (= scroll (get sizes 0)) 1\n      :else (+ 1 (get_section_id (- scroll (get sizes 0)) (into [] (drop 1 sizes))))\n    )))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18972,"user_id":null,"body":"(ns kata)\n(defn get_section_id [scroll sizes]\n  (cond\n    (< scroll (first sizes)) 0\n    (>= scroll (reduce + sizes)) -1\n    :else (if (>= (get_section_id (- scroll (first sizes)) (subvec sizes 1)) 0) (+ (get_section_id (- scroll (first sizes)) (subvec sizes 1)) 1) -1)\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18973,"user_id":363,"body":"(ns kata)\n\n(defn helper [scroll sofar idx sizes]\n    (cond (> sofar scroll) idx\n        (empty? sizes) -1\n        :else (helper scroll (+ sofar (first sizes)) (inc idx) (rest sizes))\n    )\n)\n\n(defn get_section_id [scroll sizes]\n    (helper scroll 0 -1 sizes)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18974,"user_id":null,"body":"(ns kata)\n(defn get_section_id [scroll sizes]\n     (if (empty? sizes) -1 (if (< scroll (first sizes)) 0 \n                               (#(if (= %1 -1) -1 (+ 1 %1)) (get_section_id (- scroll (first sizes)) (rest sizes))))))\n                            \n       \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5cba04533e6dce000eaf6126":[{"id":18975,"user_id":645,"body":"(ns kata)\n(defn blood-moon [n]\n  (\/ (* n n) 4))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18976,"user_id":null,"body":"(ns kata)\n(defn blood-moon [r]\n (\/ (* r r) 4.0)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18977,"user_id":null,"body":"(ns kata)\n(defn blood-moon\n  [n]\n  (\/ (Math\/pow n 2) 4))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18978,"user_id":null,"body":"(ns kata)\n(defn blood-moon [n]\n  (let [r n\n      sq-acdf (* r r)\n      cf (Math\/sqrt (+ (* r r)(* r r)))\n      c-acdf (* Math\/PI (* cf cf))\n      semi-ahf (\/ (- c-acdf sq-acdf) 4)\n      agf (* Math\/PI (* r r))]\n  (- (\/ agf 2) semi-ahf)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18979,"user_id":470,"body":"(ns kata)\n(defn blood-moon [n] (\/ (Math\/pow n 2) 4))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18980,"user_id":null,"body":"(ns kata)\n(defn blood-moon [n]\n  (* (\/ n 2) (\/ n 2)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18981,"user_id":null,"body":"(ns kata)\n(defn blood-moon [n]\n  (* 1\/4 n n))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18982,"user_id":null,"body":"(ns kata)\n\n(defn semicircle-area [r]\n  (\/ (* Math\/PI (Math\/pow r 2)) 2))\n\n(defn right-hypotenuse [a]\n  (Math\/sqrt (+ (Math\/pow a 2)(Math\/pow a 2))))\n\n(defn right-triangle-area [a]\n  (\/ (* a a) 2))\n\n(defn blood-moon [n]\n  (let [fhae-area (\/ ( semicircle-area (right-hypotenuse n)) 2)\n        fea-area (right-triangle-area (\/ (right-hypotenuse n) 2))\n        jar-jar (- fhae-area fea-area)]\n    (- (semicircle-area n) jar-jar)))\n\n\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5ce399e0047a45001c853c2b":[{"id":18983,"user_id":527,"body":"(ns sum-of-parts.core)\n\n(defn parts_sums [xs]\n  (->> xs reverse (reductions + 0) reverse))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18984,"user_id":null,"body":"(ns sum-of-parts.core)\n\n(defn parts_sums [xs]\n  (reductions - (apply + xs) xs))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18985,"user_id":null,"body":"(ns sum-of-parts.core)\n\n(defn parts_sums [ls]\n  (reverse (reductions + 0 (reverse ls))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18986,"user_id":492,"body":"(ns sum-of-parts.core)\n\n(defn parts_sums [ls]\n  (loop [xs (reverse ls) part 0N acc '()]\n    (cond\n      (empty? xs) (cons part acc)\n      :else\n       (recur (rest xs) (+ (first xs) part) (cons part acc)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18987,"user_id":null,"body":"(ns sum-of-parts.core)\n\n(defn parts_sums [ls]\n  (reductions - (reduce + ls) ls))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18988,"user_id":null,"body":"(ns sum-of-parts.core)\n\n(defn parts_sums [ls]\n  (reduce (fn [sums num] (conj sums (- (peek sums) num))) [(apply + ls)] ls)\n  \n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18989,"user_id":null,"body":"(ns sum-of-parts.core)\n\n(defn parts_sums [ls]\n  (->> (-> ls vec rseq (conj 0)) (reductions +) reverse))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18990,"user_id":null,"body":"(ns sum-of-parts.core\n  (:require [clojure.core.reducers :as r]))\n\n(defn reduce-fn\n  [res val]\n   (conj res (+ (or (first res) 0) val)))\n\n(defn combine-fn\n  ([right left]\n   (-> (map (partial + (first right)) left)\n       (concat right))))\n\n(defn do-fold\n  [ls]\n  (r\/fold\n    (r\/monoid combine-fn (constantly '()))\n    reduce-fn\n    ls))\n\n(defn parts_sums [ls]\n  (-> ls\n      vec\n      rseq\n      do-fold\n      (concat '(0))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18991,"user_id":null,"body":"(ns sum-of-parts.core)\n\n\n#_(defn parts_sums [ls]\n  (conj (->> (iterate rest ls)\n             (take-while not-empty)\n             (map (partial apply +))\n             (vec))\n        0))\n\n(defn parts_sums [ls]\n  (->> (reverse ls)\n       (reductions + 0)\n       (reverse)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18992,"user_id":null,"body":"(ns sum-of-parts.core)\n\n\n#_(defn parts_sums [ls]\n  (conj (->> (iterate rest ls)\n             (take-while (comp not empty?))\n             (map (partial apply +))\n             (vec))\n        0))\n\n(defn parts_sums [ls]\n  (->> (reverse ls)\n       (reductions + 0)\n       (reverse)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5ce6728c939bf80029988b57":[{"id":18993,"user_id":null,"body":"(ns consecutive-letters.core)\n\n(defn solve[s]\n  (let [sorted (->> (sort s)\n                    (map int))]\n    (= (range (first sorted) (inc (last sorted))) sorted)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18994,"user_id":53,"body":"(ns consecutive-letters.core)\n(use '[clojure.string :only (join includes?)])\n(defn solve[s] (includes? \"abcdefghijklmnopqrstuvwxyz\" (join (sort s))))    ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18995,"user_id":50,"body":"(ns consecutive-letters.core)\n(use '[clojure.string :only (join)])\n(defn solve[s]\n  (some? (re-find  (re-pattern (join (sort (clojure.string\/lower-case s))))  \"abcdefghijklmnopqrstuvwxyz\"))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18996,"user_id":168,"body":"(ns consecutive-letters.core)\n\n(defn solve [s]\n  (clojure.string\/includes? \"abcdefghijklmnopqrstuvwxyz\" (apply str (sort s))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18997,"user_id":null,"body":"(ns consecutive-letters.core)\n\n(defn solve [s]\n  (let [is-sorted? (->> (sort s)\n                        (partition 2 1)\n                        (every? #(= (inc (int (first %))) (int (second %)))))\n        unique-chars-count (->> (frequencies s)\n                                vals\n                                count)]\n    (and is-sorted? (= unique-chars-count (count s)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18998,"user_id":null,"body":"(ns consecutive-letters.core\n  (:require [clojure.string :as str]))\n\n(def lets-to-nums {\"a\" 1 \"b\" 2 \"c\" 3 \"d\" 4 \"e\" 5 \"f\" 6 \"g\" 7 \"h\" 8\n                   \"i\" 9 \"j\" 10 \"k\" 11 \"l\" 12 \"m\" 13 \"n\" 14 \"o\" 15\n                   \"p\" 16 \"q\" 17 \"r\" 18 \"s\" 19 \"t\" 20 \"u\" 21 \"v\" 22\n                   \"w\" 23 \"x\" 24 \"y\" 25 \"z\" 26})\n\n(defn solve [s]\n    (let [sort-string (apply str (sort s))\n          s2 (str\/split sort-string #\"\")\n          count-s (count s2)\n          nums-from-lets (map lets-to-nums s2 )\n          consecutive (filter #{-1 1} (map #(apply - %) (partition 2 1 nums-from-lets)))]\n      (= (dec count-s) (count consecutive))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":18999,"user_id":null,"body":"(ns consecutive-letters.core)\n\n(defn solve[s]\n  (as->\n    (seq s) $\n    (sort $)\n    (partition 2 1 $)\n    (reduce (fn [acc [a b]] (and acc (= 1 (- (int b) (int a))))) true $)))    ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19000,"user_id":null,"body":"(ns consecutive-letters.core)\n\n(defn solve[s]\n  (let [xs (sort (map int s))]\n    (empty? \n     (filter \n      #(not= 1 %1) \n      (map - (next xs) xs)\n      )\n     )\n  )\n)    ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19001,"user_id":null,"body":"(ns consecutive-letters.core)\n\n(defn char-diff\n  [[a b]]\n  (- (int b) (int a)))\n\n(defn solve[s]\n  (every? #{1} (map char-diff (partition 2 1 (sort s)))))    ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19002,"user_id":881,"body":"(ns consecutive-letters.core\n  (:require [clojure.string :as string]))\n\n(defn solve[s]\n  (->> s\n    sort\n    string\/join\n    (string\/includes? \"abcdefghijklmnopqrstuvwxyz\")))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5ce969ab07d4b7002dcaa7a1":[{"id":19003,"user_id":168,"body":"(ns prefix-suffix.core)\n\n(defn solve [x]\n  (->> (range (quot (count x) 2) 0 -1)\n       (filter #(= (take % x) (take-last % x)))\n       (first)\n       (#(or % 0))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19004,"user_id":null,"body":"(ns prefix-suffix.core)\n\n(defn- slice\n  ([s from] (slice s from (count s)))\n  ([s from to]\n   (clojure.string\/join \"\" (take (- to from) (drop from s)))))\n\n(defn- suffix-is-prefix? [s len]\n  (let [suffix (slice s 0 len)\n        prefix (slice s (- (count s) len))]\n    (= suffix prefix)))\n\n(defn- suffix-is-prefix-length [s len]\n       (if (suffix-is-prefix? s len)\n         (identity len)\n         (identity 0)))\n\n(defn solve [x]\n  (let [half-length (inc (quot (count x) 2))]\n    \n    (apply max (map #(suffix-is-prefix-length x %)\n                  (range 0  half-length)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19005,"user_id":null,"body":"(ns prefix-suffix.core)\n\n(defn solve [x]\n  (letfn [(f [a b]\n            (if (= a b) (count a) (recur (drop-last a) (rest b))))]\n    (let [half (quot (count x) 2)]\n      (f (take half x) (take-last half x)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19006,"user_id":null,"body":"(ns prefix-suffix.core)\n\n(defn find-longest-prefix [s]\n  (->> (subs s 0 (quot (.length s) 2))\n       (iterate #(subs % 0 (dec (.length %))))\n       (take-while not-empty)\n       (filter #(clojure.string\/ends-with? s %))\n       (first)))\n\n(defn solve[x]\n  (let [prefix (find-longest-prefix x)]\n    (if (nil? prefix)\n      0\n      (.length prefix))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19007,"user_id":null,"body":"(ns prefix-suffix.core)\n\n(defn solve[x]\n  (let [middle (quot (count x) 2)]\n    (loop [i 1 len 0]\n      (if (> i middle)\n        len\n        (let [is-suffix? (clojure.string\/ends-with? x (subs x 0 i))]\n          (if is-suffix?\n            (recur (inc i) i)\n            (recur (inc i) len))))))) ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19008,"user_id":null,"body":"(ns prefix-suffix.core)\n\n(defn solve[x]\n  (let [middle (quot (count x) 2)]\n    (loop [i 1 len 0]\n      (if (> i middle)\n        len\n        (let [is-suffix? (clojure.string\/ends-with? x (apply str (take i x)))]\n          (if is-suffix?\n            (recur (inc i) i)\n            (recur (inc i) len))))))\n  ) ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19009,"user_id":null,"body":"(ns prefix-suffix.core\n  (require [clojure.string :as str]\n           [clojure.set :as set]))\n\n(defn solve [s]\n  (let [post-range (range 0 (inc (quot (count s) 2)))\n        suffix-range (range (quot (count s) 2) (count s))\n        prefixes (set (map #(subs s 0 %) post-range))\n        suffixes (set (map #(subs s %) suffix-range))\n        intersections (set\/intersection prefixes suffixes)]\n    (cond (empty? intersections) 0\n          :else (apply max (map count intersections)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19010,"user_id":null,"body":"(ns prefix-suffix.core)\n\n(defn solve [s]\n  (let [string-length (count s)\n        fixed-length (if (odd? string-length) (dec string-length) string-length)\n        start (\/ fixed-length 2)]\n    (loop [i start]\n      (let [prefix (take i s)\n            suffix (reverse (take i (reverse s)))]\n        (cond\n          (= prefix suffix) i\n          :else (recur (dec i)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19011,"user_id":null,"body":"(ns prefix-suffix.core\n  (:require [clojure.set :as set]))\n\n(defn solve[x]\n  (->> (for [n (range 1 (inc (Math\/floor (\/ (count x) 2))))\n        :when (= (take n x) (take-last n x))]\n      n\n    )\n    (concat '(0))\n    (apply max)\n  )\n) ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19012,"user_id":501,"body":"(ns prefix-suffix.core)\n\n(defn solve[x] \n    (apply max (map (fn [i] (if (= (subs x 0 i) (subs x (- (count x) i))) i 0)) (range 0 (+ 1 (quot (count x) 2))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5d26721d48430e0016914faa":[{"id":19013,"user_id":527,"body":"(ns paper-fold)\n\n(def paper-fold (lazy-cat [1 1 0 1] (interleave (cycle [1 0]) (drop 2 paper-fold))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19014,"user_id":501,"body":"(ns paper-fold)\n\n(defn pfold [s]\n  (cond\n    (= s [1 1]) [1 1 0 1]\n    (= s [0 1]) [1 0 0 1]\n    (= s [1 0]) [1 1 0 0]\n    (= s [0 0]) [1 0 0 0]))\n\n(defn solve [x]\n  (if (> (count x) 1000000) x\n   (solve (flatten (map pfold (vec (map vec (partition 2 x))))))))\n\n(def paper-fold\n  (solve [1 1 0 1]))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19015,"user_id":null,"body":"(ns paper-fold)\n\n(defn pfold \n         ([]\n           (pfold [1]))\n         ([prev]\n           (lazy-cat \n             prev \n             (->> prev\n               (interleave (cycle [1 0]))\n               (#(concat % [0]))\n               pfold\n               (drop (count prev))))))\n\n(def paper-fold (pfold))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19016,"user_id":null,"body":"(ns paper-fold)\n\n(defn paper-fold-next-iter [sq]\n  (let [m (quot (count sq) 2)]\n    (concat sq [1] (take m sq) [0] (drop (inc m) sq))))\n\n(defn paper-fold-seq\n  ([] (paper-fold-seq 20 [1 1 0]))\n  ([n sq]\n    (if (zero? n) sq\n      (paper-fold-seq (dec n) (paper-fold-next-iter sq)))))\n\n(def paper-fold (paper-fold-seq))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19017,"user_id":null,"body":"(ns paper-fold)\n\n(def paper-fold \n   (loop [i 0 s [1 1 0]]\n          (if (= i 1000)\n            s\n            (recur (inc i) (interleave (cycle [1 0]) s)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19018,"user_id":527,"body":"(ns paper-fold)\n\n(def paper-fold\n  (mapv #(-> (bit-and % (- %)) (bit-shift-left 1) (bit-and %) zero? (if 1 0))\n        (range 1 1000001)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19019,"user_id":527,"body":"(ns paper-fold)\n\n(def paper-fold\n  (map #(-> (bit-and % (- %)) (bit-shift-left 1) (bit-and %) zero? (if 1 0))\n       (iterate inc 1)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5d2d0d34bceae80027bffddb":[{"id":19020,"user_id":53,"body":"(ns contiguous-vowels)\n\n(defn zip [& colls] (partition (count colls) (apply interleave colls)))\n\n(defn match-vowels [s] (into [] (re-seq #\"(?i)[aeoui]+\" s)))\n(defn mcv [s] (reduce max (map count (conj (match-vowels s) \"\"))))\n(defn aug [ls] (zip ls (range (count ls))))\n(defn dim [ls] (map (fn [t] (nth t 0)) ls))\n(defn cmp [t n] (- (+ (* n n) (nth t 1)) (* n (mcv (nth t 0)))))\n(defn sort-by-vowels [ls] (dim (sort-by (fn [t] (cmp t (count ls))) (aug ls))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19021,"user_id":null,"body":"(ns contiguous-vowels)\n\n(defn max-contiguous-vowels [s]\n  (->> (re-seq #\"(?i)[aeiou]+\" s)\n    (map count)\n    (apply max 0)))\n\n(defn sort-by-vowels [strings]\n  (sort-by (comp - max-contiguous-vowels) strings))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19022,"user_id":null,"body":"(ns contiguous-vowels)\n\n(defn contiguous-vowel-count [s]\n  (let [vowels (->>\n\t\t\t\ts\n\t\t\t\t(re-seq #\"[aeiouAEIOU]+\"))]       \n\t  (if (nil? vowels) 0 (->>                          \n\t\t\t\t\t\t              vowels\n\t\t\t\t\t\t              (map #(count %))\n\t\t\t\t\t\t              (apply max)))))\n\n(defn sort-by-vowels [strings]\n  (->>\n   strings\n   (sort-by #(contiguous-vowel-count %))\n   (partition-by contiguous-vowel-count)\n   (reverse)\n   (flatten)\n   (into [])))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19023,"user_id":null,"body":"(ns contiguous-vowels)\n\n(defn length [s]\n  (->> (re-seq #\"(?i)[aeiou]+\" s)\n       (map count)\n       (apply max 0)))\n\n(defn sort-by-vowels [strings]\n  (sort-by length > strings))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19024,"user_id":null,"body":"(ns contiguous-vowels)\n\n(defn length [s]\n  (->> (clojure.string\/lower-case s)\n       (re-seq #\"[aeiou]+\")\n       ((fnil identity [[]])) \n       (map count)\n       (apply max)))\n\n(defn sort-by-vowels [strings]\n  (->> strings\n    (map (juxt identity length))\n    (sort-by second >)\n    (map first)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19025,"user_id":null,"body":"(ns contiguous-vowels)\n\n(defn vow? [char]\n  (contains? #{'\\a '\\e '\\i '\\o '\\u '\\A '\\E '\\I '\\O '\\U} char))\n\n(defn cont-vows [string]\n  (loop [remain (seq string)\n         curVal 0\n         maxVal 0]\n    (if (empty? remain)\n      maxVal\n      (if (vow? (first remain))\n        (recur (rest remain) (inc curVal) (max (inc curVal) maxVal))\n        (recur (rest remain) 0 maxVal)))))\n\n(defn sort-by-vowels [strings]\n  (vec (sort #(compare (cont-vows %2) (cont-vows %1)) strings)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19026,"user_id":null,"body":"(ns contiguous-vowels)\n\n(defn vowel-contagious-max-count [strA]\n  (apply max (map count (re-seq #\"[aeiou]*\" (clojure.string\/lower-case strA)))))\n\n(defn sort-by-vowels [strings]\n  ; your code here\n(into [] (sort-by vowel-contagious-max-count > strings)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19027,"user_id":null,"body":"(ns contiguous-vowels)\n\n(defn sort-by-vowels\n  [strs]\n  (sort-by (fn [s]\n             (apply max\n                    (conj (map count\n                               (re-seq #\"(?i)[aeiou]+\" s))\n                          0)))\n           >\n           strs))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19028,"user_id":527,"body":"(ns contiguous-vowels)\n\n(defn sort-by-vowels [strings]\n  (sort-by #(->> % (re-seq #\"(?i)[aeiou]+\") (map count) (apply max 0) -) strings))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19029,"user_id":null,"body":"(ns contiguous-vowels)\n\n(defn comparer [a b]\n  (let [c (compare (:lvc b) (:lvc a))]\n    (if (not= c 0)\n      c\n      (compare (:ori a) (:ori b)))))\n\n(defn longest-contiguos-vowels [{:keys [s]}]\n  (let [vcs (->> s\n                 (re-seq #\"[aeiouAEIOU]+\")\n                 (map count))]\n    (if (seq vcs)\n      (apply max vcs)\n      0)))\n\n(defn sort-by-vowels [xs]\n  (->> xs\n       (map (fn [k x] {:ori k :s x}) (range (count xs)))\n       (map (fn [i] (assoc i :lvc (longest-contiguos-vowels i))))\n       (sort comparer)\n       (map :s)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5d49c93d089c6e000ff8428c":[{"id":19030,"user_id":527,"body":"(ns kata.save)\n(defn save [sizes hd]\n  (->> sizes (reductions + 0) rest (take-while #(<= % hd)) count))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19031,"user_id":null,"body":"(ns kata.save)\n\n(defn save [sizes hd]\n  (if-not (seq sizes)\n    (0)\n\n  (->> sizes\n    (reductions +)\n    (take-while #(<= % hd))\n    (count))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19032,"user_id":null,"body":"(ns kata.save)\n\n(defn fill [current-size\n            number-of-files\n            sizes\n            max-size]\n  (cond\n    (nil? (first sizes)) number-of-files\n    (> (+ current-size (first sizes)) max-size) number-of-files\n    :else (fill\n           (+ current-size (first sizes))\n           (inc number-of-files)\n           (rest sizes)\n           max-size)))\n\n(defn save [sizes hd]\n  (fill 0 0 sizes hd))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19033,"user_id":null,"body":"(ns kata.save)\n(defn save [sizes hd]\n  (loop [cnt 0\n         lst sizes\n         sum 0]\n    (if (or (> sum hd))\n        (dec cnt)\n        (if (empty? lst)\n        cnt\n        (recur (inc cnt) (rest lst) (+ sum (first lst)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19034,"user_id":null,"body":"(ns kata.save)\n\n(defn save [sizes hd]\n  (let [[num-files _]\n        (reduce\n         (fn [[num-files space-used] size]\n           (let [space-used' (+ space-used size)]\n             (if (> space-used' hd)\n               (reduced [num-files space-used])\n               [(inc num-files) space-used'])))\n         [0 0]\n         sizes)]\n    num-files))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19035,"user_id":50,"body":"(ns kata.save)\n(defn save [sizes hd]\n  (if (or (empty? sizes) (neg? (- hd (first sizes)))) 0\n    (+ 1 (save (rest sizes) (- hd (first sizes))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19036,"user_id":null,"body":"(ns kata.save)\n(defn save [sizes hd]\n  (loop [files 0 queue sizes size hd]\n    (if (or (= (count queue) 0) (> (first queue) size))\n      files\n      (recur (+ 1 files) (rest queue) (- size (first queue)))\n      )))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19037,"user_id":168,"body":"(ns kata.save)\n(defn save [sizes hd]\n  (or (first (keep-indexed #(when (> %2 hd) %1) (reductions + sizes))) \n      (count sizes)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19038,"user_id":null,"body":"(ns kata.save)\n(defn save [sizes hd]\n  (first\n    (reduce\n      (fn\n        [[cnt sum] size]\n        (if\n          (<= (+ sum size) hd)\n          [(inc cnt) (+ sum size)]\n          [cnt (+ sum size)]))\n     [0 0]\n     sizes)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19039,"user_id":null,"body":"(ns kata.save)\n\n(defn save [sizes hd]\n  (let [re (reductions + sizes)]\n      (if (empty? sizes)\n        0\n        (count (filter #(<= % hd) re)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5d50e3914861a500121e1958":[{"id":19040,"user_id":null,"body":"(ns letters.addition)\n\n(def alphabet \"abcdefghijklmnopqrstuvwxyz\")\n(def values (apply hash-map (interleave alphabet (range 1 27))))\n \n(defn add_letters [letters]\n  (nth alphabet (dec (mod (apply + (map values letters)) 26)) \\z))","lang_id":5,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19041,"user_id":null,"body":"(ns letters.addition)\n(defn add_letters [letters]\n   \n  (def letters2 (apply + (map #(case % \n                        \\a 1 \n                        \\b 2 \n                        \\c 3 \n                        \\d 4 \n                        \\e 5 \n                        \\f 6 \n                        \\g 7 \n                        \\h 8 \n                        \\i 9 \n                        \\j 10 \n                        \\k 11\n                        \\l 12\n                        \\m 13\n                        \n 14\n                        \\o 15\n                        \\p 16\n                        \\q 17\n                        \\r 18\n                        \\s 19\n                        \\t 20\n                        \\u 21\n                        \\v 22\n                        \\w 23\n                        \\x 24\n                        \\y 25\n                        \\z 26) letters)))\n         \n         \n      (def sequen [\\z \\a \\b \\c \\d \\e \\f \\g \\h \\i \\j \\k \\l \\m \n \\o \\p \\q \\r \\s \\t \\u \\v \\w \\x \\y])          \n           \n              (nth sequen (rem letters2 26)) \n              \n                    \n                    \n)","lang_id":5,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19042,"user_id":null,"body":"(ns letters.addition)\n\n(defn sum-cycle [x y]\n  (let [sum (+ x y)]\n    (if (> sum 26) (- sum 26) sum)))\n\n(defn add_letters [letters]\n  (if (empty? letters) \\z \n                       (->> letters\n                            (map #(- (int %) 96))\n                            (reduce sum-cycle 0)\n                            (+ 96)\n                            (char))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19043,"user_id":null,"body":"(ns letters.addition)\n\n(defn char-to-int [c] \n  (- (int c) 96))\n\n(defn int-to-char [i]\n  (char (+ i 96)))\n  \n(defn handle-overflow [i]\n  (let [v (mod i 26)]\n    (cond\n      (= v 0) 26\n      :else   v)))\n        \n(defn add_letters [letters]\n  (cond\n    (empty? letters) \\z\n    :else            (-> (->> letters (map char-to-int) (reduce +))\n                         handle-overflow\n                         int-to-char)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19044,"user_id":null,"body":"(ns letters.addition)\n(defn add_letters [letters]\n  (let [n (+ 96 (mod (reduce + (map #(- (int %) 96) letters)) 26))]\n    (if (= 96 n)\n      \\z\n      (char n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19045,"user_id":null,"body":"(ns letters.addition)\n(defn add_letters [letters]\n  (->> letters\n       (map #(- (int %) 96))\n       (reduce +)\n       (+ 25)\n       (#(rem % 26))\n       (+ 97)\n       (char)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19046,"user_id":null,"body":"(ns letters.addition)\n\n(defn add_letters [letters]\n  (let [input (->> letters\n                   (map int)\n                   (map #(- % 96))\n                   (reduce +))\n        remainder (rem input 26)]\n    (cond\n      (empty? letters) \\z\n      (> input 26) (if (= remainder 0)\n                      \\z\n                      (char (+ (mod input 26) 96)))\n      (<= input 26) (char (+ input 96)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19047,"user_id":null,"body":"(ns letters.addition)\n(defn add_letters [letters]\n  \n  (def total (apply + (map #(- % 96) (map int letters))))\n  \n  (if (or (empty? letters) (zero? (rem total 26))) \\z\n    \n    (if (<= total 26) (char (+ total 96))\n      \n      (char (+ (rem total 26) 96))\n      \n      )\n    )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19048,"user_id":null,"body":"(ns letters.addition)\n\n(defn to-i [letters]\n  (+ (rem (reduce + (map #(- (int %) 96) letters)) 26) 96))\n\n(defn add_letters [letters]\n  ;; your code here\n  (if(= (to-i letters)96)\n    \\z\n    (char (to-i letters))\n  )\n    \n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19049,"user_id":null,"body":"(ns letters.addition)\n\n(defn tonum [ch]\n    (- (int ch) 96)\n)\n\n(defn toletter [num]\n  (if (zero? num)\n      \\z\n      (char (+ num 96))\n    )  \n)\n\n(defn add_letters [letters]\n  (toletter (mod (apply + (map tonum letters)) 26))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5d5a7525207a674b71aa25b5":[{"id":19050,"user_id":null,"body":"(ns kata)\n\n(defn odd_row [n]\n  (let [base (+ 1 (* n (dec n)))]\n    (vec (for [i (range n)]\n      (+ base (* i 2))))\n    )\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19051,"user_id":53,"body":"(ns kata)\n(defn odd_row [n]\n  (vec (range (inc (* (dec n) n)) (* (inc n) n) 2)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19052,"user_id":null,"body":"(ns kata)\n(defn odd_row [n]\n  (let [last (+ (* n n) (dec n))\n        start (- last (* 2 (dec n)))]\n    (range start (inc last) 2)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19053,"user_id":null,"body":"(ns kata)\n\n(defn odd_row [n]\n  (range (-> n dec (* n) inc)\n         (-> n inc (* n))\n         2))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19054,"user_id":645,"body":"(ns kata)\n(defn odd_row [n]\n  (vec (range (inc (* (dec n) n)) (* n (inc n)) 2)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5d98b6b38b0f6c001a461198":[{"id":19055,"user_id":null,"body":"(ns code-decode.core)\n\n(defn digits [s]\n  (->> (map str s)\n       (map read-string)))\n\n(defn count-bits [n]\n  (count (Integer\/toBinaryString n)))\n\n(defn code-digit [d]\n  (str (apply str (repeat (dec (count-bits d)) \"0\"))\n       \"1\"\n       (Integer\/toBinaryString d)))\n\n(defn code [n]\n  (->> (digits n)\n       (map code-digit)\n       (reduce str)))\n\n(defn parse-next [n]\n  (let [bits (inc (count (take-while (partial not= \\1) n)))]\n    (list (Integer\/parseInt (apply str (take bits (drop bits n))) 2)\n          (apply str (drop (* 2 bits) n)))))\n\n(defn decode-digits [n]\n  (if (empty? n)\n    nil\n    (let [[a b] (parse-next n)]\n      (lazy-seq (cons a (decode-digits b))))))\n\n(defn decode [n]\n  (apply str  (map str (decode-digits n))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19056,"user_id":201,"body":"(ns code-decode.core)\n\n(defn encode-digit [n]\n    (let [bits (Integer\/toBinaryString n)\n          prefix (repeat (dec (count bits)) \"0\")]\n        (str (apply str prefix) \"1\" bits)))\n\n(defn code [s]\n  (apply str (map encode-digit (map #(- (int %) 48) s))))\n\n(defn decode [xs]\n  (loop [xs xs \n         acc []]\n    (if (empty? xs) (apply str acc)\n      (let [bits (take-while #(= % \\0) xs)\n            nbits (inc (count bits))\n            digits (apply str (take nbits (drop nbits xs)))\n            val (Integer\/parseUnsignedInt digits 2)]\n        (recur (drop (* 2 nbits) xs) (conj acc (str val)))\n      ))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19057,"user_id":null,"body":"(ns code-decode.core\n  (:require [clojure.string :as string]))\n\n(defn code-number [n]\n  (let [s (Integer\/toString n 2)]\n    (str (string\/join (repeat (dec (count s)) \"0\")) \"1\" s)))\n\n(defn code [s]\n  (string\/join (map (comp code-number #(- (int %) 48)) s)))\n\n(defn decode [s] \n  (loop [buf []\n         s s]\n    (if (seq s)\n      (let [c (inc (count (take-while #(= % \\0) s)))\n            n-end (+ c c)]\n        (recur (conj buf (str (Integer\/parseInt (subs s c n-end) 2)))\n               (subs s n-end (count s))))\n      (string\/join buf))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19058,"user_id":null,"body":"(ns code-decode.core)\n(use '[clojure.string :only (split)])\n(use '[clojure.set :only (map-invert)])\n\n(def dictionary {\"0\" \"10\"\n                 \"1\" \"11\"\n                 \"2\" \"0110\"\n                 \"3\" \"0111\"\n                 \"4\" \"001100\"\n                 \"5\" \"001101\"\n                 \"6\" \"001110\"\n                 \"7\" \"001111\"\n                 \"8\" \"00011000\"\n                 \"9\" \"00011001\"})\n(def dictionary-inverted (map-invert dictionary))\n\n(defn chunks [strng]\n  (->> (map #(take % strng) [8 6 4 2])\n       (map (partial apply str))\n       (distinct)))\n\n(defn code [strng]\n  (apply str (map dictionary (split strng #\"\"))))\n\n(defn decode [strng]\n  (if (empty? strng) \"\"\n    (let [[s] (filter dictionary-inverted (chunks strng))]\n      (str (dictionary-inverted s) (decode (subs strng (count s)))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19059,"user_id":null,"body":"(ns code-decode.core\n  (:require [clojure.string :as str]))\n\n(defn code [num]\n  (let [digits (->> num str (map (comp read-string str)))]\n    (reduce (fn [acc i]\n              (str acc (let [bin (Integer\/toBinaryString i)]\n                          (str (apply str (repeat (dec (count bin)) \"0\")) \"1\" bin)))) \"\" digits )))\n\n(defn decode [b]\n  (loop [bin b res \"\"]\n    (if (str\/blank? bin)\n      res\n      (let [bits (inc (count (take-while #(not= \\1 %) bin)))]\n        (recur (subs bin (* 2 bits)) (str res (Integer\/parseInt (subs bin bits (* 2 bits)) 2)))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19060,"user_id":null,"body":"(ns code-decode.core)\n\n(defn code [s]\n  (clojure.string\/join\n    (mapcat\n      #(let [bin (-> % (Character\/digit 10) Long\/toBinaryString)]\n        (concat (repeat (dec (count bin)) \\0) \"1\" bin))\n      s)))\n\n(defn decode [s]\n  (loop [digits []\n         bits (map #(Character\/digit % 2) s)]\n    (if (empty? bits)\n      (clojure.string\/join digits)\n      (let [[a [_ & b]] (split-with zero? bits)\n            [head-bits tail-bits] (split-at (inc (count a)) b)]\n        (recur (conj digits\n                     (reduce #(bit-or (bit-shift-left %1 1) %2) head-bits))\n               tail-bits)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19061,"user_id":null,"body":"(ns code-decode.core\n  (:require [clojure.string :as str]))\n\n(defn digit->coding\n  [s]\n  (let [d (Integer\/toString (Integer. s) 2)\n        k (count d)]\n    (str (str\/join (repeat (dec k) \"0\"))\n         \"1\"\n         d)))\n\n(defn code\n  [s]\n  (let [digits (re-seq #\"\\d\" s)]\n    (str\/join\n     (map digit->coding digits))))\n\n(defn decode\n  [s]\n  (str\/replace s\n               ; between \"|\" are the digits from 9 to 0, coded with code fn.\n               #\"00011001|00011000|001111|001110|001101|001100|0111|0110|11|10\"\n               {\"10\" \"0\"\n                \"11\" \"1\"\n                \"0110\" \"2\"\n                \"0111\" \"3\"\n                \"001100\" \"4\"\n                \"001101\" \"5\"\n                \"001110\" \"6\"\n                \"001111\" \"7\"\n                \"00011000\" \"8\"\n                \"00011001\" \"9\"\n                }))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19062,"user_id":null,"body":"(ns code-decode.core)\n\n(defn string-to-binary-list [strng]\n  (map #(-> (str %)\n            (Integer\/parseInt)\n            (Integer\/toString 2))\n       strng))\n\n(defn code [strng]\n  (apply str\n         (map #(str (apply str (repeat (- (count %) 1) \"0\"))\n                    \"1\"\n                    %)\n              (string-to-binary-list strng))))\n\n(defn decode [strng]\n  (loop [strng strng\n         vec []]\n    (if (empty? strng)\n      (apply str vec)\n      (let [len-0 (count (re-find #\"^0+\" strng))\n            end (+ 2 (* len-0 2))]\n        (recur (subs strng end)\n               (conj vec\n                     (-> (subs strng (+ 1 len-0) end)\n                         (Integer\/parseInt 2))))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19063,"user_id":null,"body":"(ns code-decode.core)\n\n(def to-code {\\0 \"10\" \\1 \"11\" \\2 \"0110\" \\3 \"0111\" \\4 \"001100\" \\5 \"001101\"\n              \\6 \"001110\" \\7 \"001111\" \\8 \"00011000\" \\9 \"00011001\"})\n\n(def to-digit {\"00011000\" \"8\" \"001100\" \"4\" \"0111\" \"3\" \"0110\" \"2\" \"001101\" \"5\"\n               \"001110\" \"6\" \"001111\" \"7\" \"11\" \"1\" \"10\" \"0\" \"00011001\" \"9\"})\n\n(def re #\"10|11|0110|0111|001100|001101|001110|001111|00011000|00011001\")\n\n(defn code [s]\n  (apply str (map to-code s)))\n\n(defn decode [s]\n  (clojure.string\/replace\n   s\n   re\n   (partial get to-digit)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19064,"user_id":null,"body":"(ns code-decode.core\n  (:require [clojure.string :refer [join, starts-with?]]))\n\n;; Encoding\n(defn digit-to-binary [c]\n  (let [n      (Character\/digit c 10)\n        bin    (Integer\/toString n 2)\n\t\t    len    (dec (count bin))\n        zeroes (join (repeat len \"0\"))]\n    (str zeroes \"1\" bin)))\n\n(defn code [n]\n  (join \"\"\n    (map digit-to-binary (str n))))\n\n;; Decoding\n(def dict (zipmap (map code (range 0 10)) (range 0 10)))\n\n(defn get-next-match [s dict]\n  \"If head of string is a key of dict, return it, else nil\"\n  (let [f (fn [_ a]\n            (if (starts-with? s a)\n              (reduced a)))]\n    (reduce f s (keys dict))))\n\n(defn parse-from-map [s dict]\n  \"A simple dictionary-based parser\"\n  (loop [s s out \"\"]\n    (if-let [next-match (get-next-match s dict)]\n      (let [new-s      (.replaceFirst s next-match \"\")\n            next-digit (dict next-match)\n            new-out    (str out next-digit)]\n        (recur new-s new-out))\n      out)))\n\n(defn decode [s]\n  (parse-from-map s dict))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5d9f95424a336600278a9632":[{"id":19065,"user_id":null,"body":"(ns kata)\n(require '[clojure.string :as st])\n\n(defn powers [n]\n  (let [b (st\/reverse (Integer\/toBinaryString n))]\n    (map #(reduce * (repeat % 2)) (filter #(= \\1 (nth b %)) (range (count b)))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19066,"user_id":501,"body":"(ns kata)\n\n(defn powers [n]\n   (if ( <= n 2) \n        (do (if (= n 1) [1] [2])))\n       \n    (def v (vector))\n    (loop [n n v (vector)]\n        (if (<= n 0) (sort (vec (remove zero? (map (fn [x] (* (int (Math\/pow 2 (first x))) (second x))) (zipmap (range 0 100) v)))))\n          (recur (quot n 2) (conj v (rem n 2)))))   \n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19067,"user_id":null,"body":"(ns kata\n  (:require [clojure.string :as str]))\n\n(defn powers [n]\n  (loop [result []\n         i      1\n         binary (->> (Integer\/toBinaryString n)\n                     (str\/reverse)\n                     (seq))]\n    (if (empty? binary)\n      result\n      (recur (if (= \\1 (first binary)) (conj result i) result) (* 2 i) (rest binary)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19068,"user_id":null,"body":"(ns kata)\n(defn parse-int [s]\n  (Character\/digit s 10)\n)\n(defn powers [n]\n  \n  (def result '())\n  (def bin-list (reverse (seq (Integer\/toBinaryString n))))\n  (def bin-list-length (- (count bin-list) 1))\n\n  (loop [x bin-list-length]\n    (def result (conj result (int (* (Math\/pow 2 (int x)) (parse-int (nth bin-list x))))))\n    (if (> x 0)\n      (recur (- x 1))\n      (vec (filter (fn [x] (> x 0)) result))\n    )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19069,"user_id":null,"body":"(ns kata)\n\n(defn to-binary [n] \n   (cond (= 0 n) [false] \n         (= 1 n) [true] \n         :else (conj (to-binary (quot n 2)) (odd? n))))\n\n(defn powers [n]\n   (filter #(> % 0) \n          (map-indexed (fn [i x] (if x (int (Math\/pow 2 i)) 0)) \n                       (reverse (to-binary n))))\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19070,"user_id":168,"body":"(ns kata)\n(defn powers [n]\n  (if (> n 0) \n      (cons (bit-and n (- n)) (powers (bit-and n (- n 1))))\n      nil))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19071,"user_id":null,"body":"(ns kata)\n\n(defn powers [n]\n  (->> (iterate #(* % 2) 1)\n       (take-while #(<= % n))\n       (reverse)\n       (reduce #(if (> (apply + %2 %) n) % (conj % %2)) [])\n       (reverse)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19072,"user_id":645,"body":"(ns kata)\n(defn exp-t [x n] (reduce * (repeat n x)))\n(defn powers [n]\n  (filter (partial not= 0) (map-indexed (fn [i x] (if (not= \\0 x) (exp-t 2 i) 0)) (reverse (vec (Integer\/toBinaryString n))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5da1df6d8b0f6c0026e6d58d":[{"id":19073,"user_id":492,"body":"(ns sections.core)\n\n(defn c [k]\n  (defn div-nb [n]\n    (loop [cnt 0 k 1]\n      (if (< (Math\/sqrt n) k)\n        (if (= n (* (dec k) (dec k)))\n        (dec cnt)\n        cnt)\n        (if (= 0 (rem n k))        \n          (recur (+ 2 cnt) (inc k))\n          (recur cnt (inc k)))\n        )))\n  (let [r (long (Math\/sqrt k))]\n    (if (= k (* r r))\n      (div-nb (* k r))\n      0)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19074,"user_id":53,"body":"(ns sections.core)\n\n(defn walk [i n ans cnt m j]\n  (cond \n    (= 1000 j) (* 4 ans)\n    (and (<= n 1) (= 1 m)) ans\n    (not= 0 (mod n i)) (walk (inc i) n (* ans (inc cnt)) 0 1 (inc j))\n    :else (walk i (quot n i) ans (inc cnt) 0 (inc j))))\n\n(defn c [k]\n  (let [sq (int (Math\/floor (Math\/sqrt k)))]\n    (if (not= k (* sq sq))\n      0\n      (walk 2 (* k sq) 1 0 1 0))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19075,"user_id":null,"body":"(ns sections.core)\n(defn fact [n] (let [x (int (Math\/sqrt n))\n                     z (* x x x)]\n                 (if (= (* x x) n)\n                  (map #(vector % (\/ z %)) (filter #(= (mod z %) 0) (range 1 (+ 1 (Math\/sqrt z)))))\n                 nil)\n                 ))\n\n(defn c [n] (reduce #(+ %1 (count (set %2))) 0 (fact n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19076,"user_id":null,"body":"(ns sections.core)\n\n(defn solve [^double n]\n  (let [xy (*' n n n)\n        s (Math\/sqrt xy)]\n    (loop [x 1.0 solutions 0]\n      (if (> x s)\n        solutions\n        (if (zero? (mod xy x))\n          (let [y (\/ xy x)]\n            (if (= x y)\n              (recur (inc x) (inc solutions))\n              (recur (inc x) (+ 2 solutions))))\n          (recur (inc x) solutions))))))\n          \n(defn c [n] (solve (Math\/sqrt n)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19077,"user_id":null,"body":"(ns sections.core)\n\n(def prime-numbers\n  ((fn f [x]\n     (cons x\n       (lazy-seq\n         (f (first\n              (drop-while\n                (fn [n]\n                  (some #(zero? (mod n %))\n                    (take-while #(<= (* % %) n) prime-numbers)))\n                (iterate inc (inc x))))))))\n   2))\n\n(defn factorize [n]\n  ((fn f [n [h & r :as ps]]\n     (cond (< n 2) '()\n           (zero? (mod n h)) (cons h (lazy-seq (f (quot n h) ps)))\n           :else (recur n r)))\n   n prime-numbers))\n\n(defn count-occurrences [slist s]\n  (->> slist\n       (filter #{s})\n       count))\n\n(defn c [k]\n  (let [s (Math\/sqrt k)]\n    (if-not (zero? (- s (int s)))\n      0\n      (let [factors (factorize (int s))]\n        (->> (factorize (int s))\n             distinct \n             (map (partial count-occurrences factors))\n             (map #(+ 1 (* 3 %)))\n             (reduce * 1))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5dae2599a8f7d90025d2f15f":[{"id":19078,"user_id":527,"body":"(ns kata)\n(defn consecutive_ducks [n]\n  (pos? (bit-and n (dec n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19079,"user_id":53,"body":"(ns kata)\n(defn consecutive_ducks [n]\n (if (odd? n) (not= n 1) (consecutive_ducks (quot n 2))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19080,"user_id":null,"body":"(ns kata)\n(defn consecutive_ducks [n]\n  (and (not (zero? n)) (not (zero? (bit-and n (dec n))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19081,"user_id":168,"body":"(ns kata)\n(defn consecutive_ducks [n]\n  (not (= (Long\/bitCount n) 1)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19082,"user_id":null,"body":"(ns kata)\n(defn consecutive_ducks [n]\n  (let [pow2 (map #(reduce * (repeat % 2)) (range 2 32))]\n    (not (some #{n} pow2))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19083,"user_id":527,"body":"(ns kata)\n(defn consecutive_ducks [n]\n  (< 1 (bit-and n (dec n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19084,"user_id":null,"body":"(ns kata)\n\n(defn is-compose-by-two [n]\n  (let [q (quot n 2)]\n    (if (= q 1)\n      true\n      (if (odd? q)\n        false\n        (recur q)))))\n\n(defn consecutive_ducks [n]\n  (or (odd? n) (not (is-compose-by-two n)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19085,"user_id":null,"body":"(ns kata)\n\n(defn consecutive_ducks [n]\n  (not= 0 (bit-and n (dec n)))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19086,"user_id":null,"body":"(ns kata)\n(defn consecutive_ducks [n]\n  (not= (bit-and n (- n 1)) 0)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19087,"user_id":null,"body":"(ns kata)\n\n(defn int-val? [x]\n  (= x (int x)))\n\n(defn consecutive_ducks [n]\n  (and\n    (not (#{8 16 32 64 256 512 1024 32768 65536} n))\n    (some #(int-val? (\/ n 1\/2 %)) (range 2 n))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5db19d503ec3790012690c11":[{"id":19088,"user_id":209,"body":"(ns architect-dream.core)\n\n(defn weight [n w](* -0.17174117862516716 w (dec (Math\/exp (* -2 n)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19089,"user_id":null,"body":"(ns architect-dream.core)\n\n(defn weight [n w]\n  (* w 0.17174117862516716128)\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19090,"user_id":null,"body":"(ns architect-dream.core)\n\n(defn weight [n w]\n  (let [s0 0.14849853757254047\n        indices (range n)\n        en (map (fn [n] (Math\/exp (- 0.0 n))) indices)\n        en2 (map (fn [x] (* x x)) en)]\n    (* w s0 (reduce + en2))\n    )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19091,"user_id":527,"body":"(ns architect-dream.core)\n\n(defn weight [n w]\n  (\/ (* w (- (Math\/exp 2) 3) (- 1 (Math\/exp (* -2 n))))\n     (* 4 (dec (Math\/exp 2)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19092,"user_id":492,"body":"(ns architect-dream.core)\n\n(defn weight [n w]\n  (let [i0 0.14849853757254047\n        e Math\/E\n        num (- 1 (Math\/pow e (- (+ 2 (* 2 n)))))\n        den (- 1 (Math\/pow e -2))\n        an (\/ num den)\n       ]\n    (* i0 an w)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5dd259444228280032b1ed2a":[{"id":19093,"user_id":501,"body":"(ns gcd-sum.core)\n\n(defn solve [s g]\n  (if (= 0 (rem s g)) [g, (- s g)] -1 ))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19094,"user_id":null,"body":"(ns gcd-sum.core)\n\n(defn solve [sum d]\n    (if (zero? (mod sum d))\n      [d (- sum d)]\n      -1))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19095,"user_id":null,"body":"(ns gcd-sum.core)\n\n(defn solve [s g]\n  (let [candidates (for [i (range 1 (quot s g))\n                         :let [x (* i g)\n                               y (- s x)]\n                         :when (zero? (rem y g))]\n                     [x y])]\n    (if (empty? candidates)\n      -1\n      (first candidates))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19096,"user_id":null,"body":"(ns gcd-sum.core)\n\n(defn solve [s g] (if (> (mod s g) 0) -1 [g (- s g)]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19097,"user_id":null,"body":"(ns gcd-sum.core)\n\n(defn solve [s g]\n  (if (zero? (mod s g))\n    [g (- s g)]\n    -1))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19098,"user_id":null,"body":"(ns gcd-sum.core)\n\n(defn solve\n  [sum gcd]\n  (if-let [res (->> (for [a (range 0 sum gcd)\n                          b (range 0 (inc a) gcd)]\n                      (when-let [c (= sum (+ a b))]\n                        ;; (str a \"+\" b \"=\" (+ a b))\n                        (if (< a b)\n                          [a b]\n                          [b a])))\n                    (filter #(not (nil? %)))\n                    sort\n                    first)]\n    res\n    -1))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19099,"user_id":null,"body":"(ns gcd-sum.core)\n\n(defn is-cd [x cd]\n  (zero? (mod x cd)))\n\n(defn solve [s g]\n  (if (is-cd s g)\n    (list g (- s g))\n    (int -1))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19100,"user_id":564,"body":"(ns gcd-sum.core)\n\n(defn solve [sum gcd]\n  (if (= 0 (mod sum gcd))\n    [gcd (- sum gcd)]\n    -1))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19101,"user_id":492,"body":"(ns gcd-sum.core)\n\n(defn solve [s g]\n  (if (not= (mod s g) 0)\n    -1\n    [g (- s g)])\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19102,"user_id":null,"body":"(ns gcd-sum.core)\n\n(defn gcd [a b]\n  (if (zero? b)\n    a\n    (recur b (mod a b))))\n\n(defn solve [s g]\n  (let [y (- s g)]\n    (if (= g (gcd g y))\n      [g y]\n      -1)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5e4bb05b698ef0001e3344bc":[{"id":19103,"user_id":492,"body":"(ns prodseq.core)\n\n(defn- abs [n] (max n (- n)))\n(defn- h[arr]\n  (let [x (bigint (arr 0)) y (bigint (arr 1)) z (bigint (arr 2)) t (bigint (arr 3))\n        a (- (* x z) (* y t))\n        b (+ (* x t) (* y z))     \n       ]\n    [(abs a) (abs b)])\n)\n(defn solve[arr]\n  (if (= (count arr) 4) \n    (h arr)\n    (let [a1 (h (subvec arr 0 4)) a2 (subvec arr 4 (count arr))]\n     (solve (vec (concat a1 a2)))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19104,"user_id":null,"body":"(ns prodseq.core)\n\n(defn solve [[a b c d & arr]]\n  (let [next-a (biginteger (- (* a c) (* b d)))\n        next-b (biginteger (+ (* a d) (* b c)))]\n    (if (empty? arr)\n      [(.abs next-a) (.abs next-b)]\n      (recur (concat [next-a next-b] arr)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19105,"user_id":53,"body":"(ns prodseq.core)\n\n(defn babs [n] (max n (- n)))\n\n(defn solve[arr]\n  (loop [a (bigint (arr 0)) b (bigint (arr 1)) ls (subvec arr 2 (count arr))]\n    (if (zero? (count ls)) [a b]\n      (recur \n       (+ (* a (ls 0)) (* b (ls 1)))\n       (babs (- (* b (ls 0)) (* a (ls 1))))\n       (subvec ls 2 (count ls))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19106,"user_id":null,"body":"(ns prodseq.core)\n\n(defn two-squares [k x y z]\n  (let [[a b c d] (if (>= (* k z) (* x y)) [k x y z] [x k z y])\n        l1        (+ (* a c) (* b d))\n        r1        (- (* a d) (* b c))]\n    [l1 r1]))\n\n(defn reduce-product [[a b c d & rest]]\n  (let [[left right] (two-squares a b c d)]\n    (if (empty? rest)\n      [left right]\n      (reduce-product (concat [left right] rest)))))\n\n(defn solve [arr]\n  (reduce-product (map bigint arr)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19107,"user_id":null,"body":"(ns prodseq.core)\n\n(defn solve [arr]\n  (loop [a_ (bigint (peek arr)) b_ (bigint (peek (pop arr))) rst (pop (pop arr))]\n    (cond\n      (empty? rst) [a_ b_]\n      :else (let\n             [m_ (bigint (peek rst))\n              n_ (bigint (peek (pop rst)))\n              nrst (pop (pop rst))\n              a (min a_ b_)\n              b (max a_ b_)\n              m (min m_ n_)\n              n (max m_ n_)\n              ]\n              (recur (-' (*' n b) (*' m a)) (+' (*' n a) (*' m b))  nrst)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19108,"user_id":527,"body":"(ns prodseq.core)\n\n(defn- abs [x]\n  (if (neg? x) (- x) x))\n\n(defn solve [xs]\n  (transduce\n   (partition-all 2)\n   (completing (fn [[a b] [c d]] [(+ (* a c) (* b d))\n                                  (abs (- (* a d) (* b c)))]))\n   [1N 0N]\n   xs))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19109,"user_id":527,"body":"(ns prodseq.core)\n\n(defn- abs [x]\n  (if (neg? x) (- x) x))\n\n(defn solve [xs]\n  (->> xs\n    (partition 2)\n    (reduce (fn [[a b] [c d]] [(+ (* a c) (* b d)) (abs (- (* a d) (* b c)))]) [1N 0N])))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5edc8c53d7cede0032eb6029":[{"id":19110,"user_id":null,"body":"(ns kata.core)\n\n(defn solve [n]\n  (loop [i 1]\n    (let [sqrt (Math\/sqrt (+ (Math\/pow i 2) n))]\n      (cond (== (Math\/round sqrt) sqrt) (bigint (Math\/pow i 2))\n            (> i 10000000) nil\n            :else (recur (inc i))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19111,"user_id":168,"body":"(ns kata.core)\n\n(defn solve [n]\n  (->> (range (int (Math\/sqrt n)) 0 -1)\n       (filter #(zero? (mod n %)))\n       (map #(- (quot n %) %))\n       (filter #(and (even? %) (pos? %)))\n       (map #(quot (* % %) 4))\n       (first)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19112,"user_id":53,"body":"(ns kata.core)\n\n(defn solve [n]\n  (loop [i 1]\n    (let [m (+ (* i i) n)\n          p (Math\/sqrt m)]\n      (cond\n        (>= i n) nil\n        (= p (Math\/floor p)) (* i i)\n        :else (recur (inc i))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19113,"user_id":null,"body":"(ns kata.core)\n\n(defn solve [n]\n    ;(first \n    ;     (for [x (range 1  (+ 1 (\/ n 2))) y (range (int (Math\/sqrt (+ n (* x x)))) (+ 1 (\/ n 2)))                 \n    ;             :when (= (* (- y x) (+ y x)) n)\n    ;           ] \n    ;                (* x x))\n    ; )\n    (first\n         (for [x (range 1  (+ 1 (\/ n 2)))\n             :let [z (Math\/sqrt (+ n (* x x)))]\n             :when (= z (Math\/floor z))] \n                 (* x x) \n         )\n     )\n    \n)  ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19114,"user_id":null,"body":"(ns kata.core)\n\n(defn solve [n]\n  (loop [a n\n         b 1\n         c (if (odd? n) (\/ (- n 1) 2) (\/ n 2))\n         e (+ n (* b b))]\n    (if (= (Math\/sqrt e) (Math\/floor (Math\/sqrt e)))\n      (* b b)\n      (if (> b c)\n        nil\n        (recur a (inc b) c (+ n (* (inc b) (inc b)))))))\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19115,"user_id":null,"body":"(ns kata.core)\n\n(defn solve_slow [n]\n  (let [lst (map #(* % %) (range 1 (quot (+ n 3) 2)))]\n    (let [hst (apply hash-set lst)]\n      (first (filter #(contains? hst (+ % n)) lst))))\n)\n\n(defn ov [n] (rem n 2))\n(defn sqr [n] (* n n))\n(defn exact-integer-sqrt [n]\n  (first (filter #(> (sqr (+ 1 %)) n) (range (+ n 1))))\n)\n\n(defn solve [n]\n  (let [lst (range (exact-integer-sqrt (- n 1)) 0 -1)]\n    (first \n      (map #(sqr (quot (- (quot n %) %) 2)) \n        (filter \n          #(and \n              (zero? (rem n %)) \n              (= (ov %) (ov (quot n %)))) \n          lst)\n      )\n    )\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19116,"user_id":527,"body":"(ns kata.core)\n\n(defn solve [n]\n  (first\n    (for [\n        d (range (int (Math\/sqrt n)) 0 -1)\n        :let [x (-> n (quot d) (- d) (quot 2))]\n        :when (-> x (* 2) (+ d) (* d) (= n))\n        :when (not (zero? x))\n      ] (* x x))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19117,"user_id":149,"body":"(ns kata.core)\n\n(defn square [n] (* n n))\n\n(defn solve [n] (\n  let [x (long (Math\/sqrt (- n 1)))] (\n    let [a (map #(square (quot (- (quot n %) (- % 1)) 2)) (filter #(and (= (mod n %) 0) (= (mod (quot n %) 2) (mod % 2))) (range x 1 -1)))] (\n      if (empty? a) (if (and (odd? n) (> n 1)) (square (quot n 2)) nil) (first a)\n    )\n  )\n))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19118,"user_id":503,"body":"(ns kata.core)\n(defn solve [Q] (loop [S (int (Math\/sqrt Q))] (if (< S 1) nil (let [T (- (\/ Q S) S)] (if (and (= 0 (mod Q S)) (= 0 (mod T 2)) (< 0 T)) (\/ (* T T) 4) (recur (- S 1)))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19119,"user_id":501,"body":"(ns kata.core)\n\n(defn solve [n]\n    (last (map (fn [x] (* x x)) (filter #(> % 0) (remove nil? (for [i (range 1 (Math\/sqrt n))\n      :let [a i b (quot n i)]]\n       (if (and (= 0 (rem n i)) (not= 0 (- b a) ) (= 0 (rem (- b a) 2))) (quot (- b a) 2))))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5f6d533e1475f30001e47514":[{"id":19120,"user_id":881,"body":"(ns kata)\n\n(defn consecutive [arr a b]\n  (= 1 (Math\/abs (- (.indexOf arr a) (.indexOf arr b)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19121,"user_id":null,"body":"(ns kata)\n\n(defn consecutive [arr a b]\n  (boolean (some (set [[a b] [b a]]) (partition 2 1 arr))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19122,"user_id":null,"body":"(ns kata)\n\n(defn consec [arr a b]\n  (if (< (count arr ) 2)\n    false\n    (if (= (first arr) a)\n      (if (= (second arr) b)\n        true\n        (consec (rest arr) a b)\n      )\n      (consec (rest arr) a b)\n    )\n  )\n)\n\n(defn consecutive [arr a b]\n  (or (consec arr a b) (consec (reverse arr) a b))\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19123,"user_id":null,"body":"(ns kata)\n\n(defn consecutive\n  [list a b]\n  (let [f (first list) s (second list)] (if (= 1 (count list)) false (if (or (= [a b] [s f]) (= [a b] [f s])) true (recur (rest list) a b)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19124,"user_id":null,"body":"(ns kata)\n\n\n(defn consecutive\n  [arr a b]\n  (if (= a b)\n    false\n    (let [[a b] (keep-indexed #(when (or (= a %2) (= b %2)) %1) arr)]\n      (< (Math\/abs (- a b)) 2))))\n\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19125,"user_id":null,"body":"(ns kata)\n\n(defn getIndex [arr el]\n  (.indexOf arr el)\n)\n\n(defn consecutive [arr a b]\n  (= 1 (Math\/abs (- (getIndex arr a) (getIndex arr b))))\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19126,"user_id":168,"body":"(ns kata)\n\n(defn consecutive [arr a b]\n  (->> arr\n    (partition 2 1)\n    (some #(or (= [a b] %) (= [b a] %)))\n    ((fn [x] (or x false)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19127,"user_id":null,"body":"(ns kata)\n\n(defn consecutive [arr a b]\n  (or (= b\n     (second\n      (drop-while (fn [n] (not= n a)) arr)))\n      (= a\n         (second\n          (drop-while (fn [n] (not= n b)) arr)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19128,"user_id":null,"body":"(ns kata)\n\n(defn consecutive [coll a b]\n        (let [ind-a (.indexOf coll a)\n              ind-b (.indexOf coll b)]\n          (or (= 1 (- ind-a ind-b)) (= -1 (- ind-a ind-b)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19129,"user_id":null,"body":"(ns kata)\n\n(defn consecutive\n  [arr a b]\n  (reduce\n    (fn\n      [acc [c d]]\n      (or\n        acc\n        (= [a b] [c d])\n        (= [a b] [d c])))\n   false\n   (partition 2 1 arr)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5f70c883e10f9e0001c89673":[{"id":19130,"user_id":527,"body":"(ns kata)\n\n(defn flip [d a]\n  (sort (case d \"R\" < \"L\" >) a))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19131,"user_id":null,"body":"(ns kata)\n\n(defn flip [d a]\n  (case d\n    \\R (sort < a)\n    \\L (sort > a)))\n","lang_id":5,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19132,"user_id":null,"body":"(ns kata)\n\n(defn flip [gravity boxes]\n  (def gravity-side (case gravity \\R < \\L >))\n  (sort gravity-side boxes)\n)","lang_id":5,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19133,"user_id":null,"body":"(ns kata)\n\n(defn flip [d a]\n  (if (= d \\L) (sort > a) (sort a)))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19134,"user_id":null,"body":"(ns kata)\n\n(defn flip\n  [direction array]\n  (if (= direction \\L)\n    (-> array\n      sort\n      reverse)\n    (sort array)))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19135,"user_id":null,"body":"(ns kata)\n\n(defn flip [d a]\n  (sort (if (= d \\R) < >) a)\n  )","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19136,"user_id":null,"body":"(ns kata)\n\n(defn flip [d a]\n  (let [sorted (vec (sort a))]\n    (cond\n      (= a nil) []\n      (= d \\L) (rseq sorted)\n      :else sorted\n    )\n  ))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19137,"user_id":null,"body":"(ns kata)\n\n(defn flip [dir blocks]\n  (let [sorted (sort blocks)]\n    (case dir\n      \\R sorted\n      \\L (reverse sorted))))","lang_id":5,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19138,"user_id":null,"body":"(ns kata)\n\n(defn flip [d a]\n  (if (= d \\L)\n    (reverse (sort a))\n    (sort a)))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19139,"user_id":null,"body":"(ns kata)\n\n(defn reverse-compare\n  [a b]\n  (compare b a))\n\n(defn flip [d a]\n  (case d\n    \\R (sort a)\n    \\L (sort reverse-compare a)))","lang_id":5,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5f70e4cce10f9e0001c8995a":[{"id":19140,"user_id":null,"body":"(ns kata)\n\n(defn solution [stones]\n  (- (count stones) (count (dedupe stones))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19141,"user_id":527,"body":"(ns kata)\n\n(defn solution [stones]\n  (->> (map = stones (rest stones)) (filter true?) count))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19142,"user_id":168,"body":"(ns kata)\n\n(defn solution [stones]\n  (->> (partition 2 1 stones)\n       (map (fn [[x y]] (if (= x y) 1 0)))\n       (apply +)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19143,"user_id":null,"body":"(ns kata)\n\n(defn solution [stones]\n  (->> (partition-by identity stones)\n         (map count)\n         (map #(- % 1))\n         (reduce + )))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19144,"user_id":null,"body":"(ns kata)\n\n(defn solution [stones]\n  ;TODO\n  (->> (map #(if (= % %2) 1 0)  (rest (seq stones)) stones)\n    (apply +))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19145,"user_id":null,"body":"(ns kata)\n\n(defn solution [stones]\n  (let [stones (apply list stones)]\n    (loop [lst (rest stones)\n           prev (first stones)\n           result 0]\n      (cond \n        (empty? lst) result\n        (= prev (first lst)) (recur (rest lst) (first lst) (inc result))\n        :else (recur (rest lst) (first lst) result)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19146,"user_id":null,"body":"(ns kata)\n\n(defn solution [stones]\n  (let [go (fn [[acc prev] x]\n             (if (= x prev)\n               [(+ 1 acc) x]\n               [acc x]))]\n    (first (reduce go [0 (first stones)] (drop 1 stones)))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19147,"user_id":null,"body":"(ns kata)\n \n(defn testuj [list x] \t\n\t(if \n\t\t( = (get list x) (get list (inc x))) 1 0)\n)\n\n(defn solution [stones]\n    (def counter (range ( - (count stones) 1)))\n   (reduce + (map (partial testuj stones) counter))\n )\n \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19148,"user_id":53,"body":"(ns kata)\n\n(defn solution [stones]\n  (count (filter (fn [[a b]] (= a b))\n    (map vector (seq stones) (drop 1 (seq stones))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19149,"user_id":null,"body":"(ns kata)\n\n(defn solution [stones]\n  (let [runes (seq stones)]\n    (->>\n      (map = runes (rest runes))\n      (filter true?)\n      count)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5fb856190d5230001d48d721":[{"id":19150,"user_id":null,"body":"(ns kata)\n\n(defn pentagonal [^long n]\n  (cond\n    (<= n 0) -1\n    (= n 1) 1\n    :else (+ 1 (\/ (*' 5 (dec n) n) 2)))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19151,"user_id":168,"body":"(ns kata)\n\n(defn pentagonal [n]\n  (if (pos? n) (quot (+ (* 5 (bigint n) (dec n)) 2) 2) -1))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19152,"user_id":527,"body":"(ns kata)\n\n(defn pentagonal [n]\n  (if (pos? n) (-> 5N (* n) (* (dec n)) (+ 2) (quot 2)) -1))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19153,"user_id":53,"body":"(ns kata)\n\n(defn pentagonal [n] (if (< n 1) -1 (inc (* 5 (quot (* (bigint n) (dec n)) 2)))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19154,"user_id":209,"body":"(ns kata)\n\n(defn pentagonal [n]\n  (if(> n 0) (inc (* 5 (\/ (*' n (dec n)) 2))) -1))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19155,"user_id":null,"body":"(ns kata)\n\n(defn pentagonal [n]\n  (if (<= n 0)\n    -1\n    (inc (*' (dec n) (\/ 5 2) n))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5fc7d2d2682ff3000e1a3fbc":[{"id":19156,"user_id":null,"body":"(ns message-validator.core)\n\n(defn valid-message? [msg]\n  (if (empty? msg)\n    true\n    (let [gr (re-find #\"^\\p{Digit}+\\p{Alpha}*\" msg)]\n      (if gr\n        (let [size (Integer\/parseInt (re-find #\"^\\p{Digit}+\" gr))\n              word (re-find #\"\\p{Alpha}*$\" gr)]\n          (if (not= size (count word))\n            false\n            (valid-message? (subs msg (count gr)))))\n        false))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19157,"user_id":null,"body":"(ns message-validator.core)\n\n(defn valid-message? [msg]\n  (let [re #\"(\\d+)([^\\d]*)\"\n        matcher (re-matcher re msg)\n        res (loop [match (re-find matcher)\n                   result []]\n              (if-not match\n                result\n                (recur (re-find matcher)\n                       (conj result match))))\n        ls (filter #(not= (Integer\/parseInt (nth % 1)) (count (nth % 2))) res)]\n    (if (and (not= \"\" msg) (not (seq res)))\n      false\n      (if (seq ls)\n        false\n        true))))\n  \n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19158,"user_id":null,"body":"(ns message-validator.core)\n\n(defn parse-int [number-string]\n  (try (Integer\/parseInt number-string)\n       (catch Exception e nil)))\n\n(defn valid-message? [s]\n  (prn s)\n  (->> (partition-by (fn [c] (some? (#{\\1 \\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\0} c))) s)\n       (map (partial apply str))\n       (partition-all 2)\n       (map (fn [[c w]] [(parse-int c) w]))\n       (every? (fn [[c w]] (= c (count w))))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19159,"user_id":null,"body":"(ns message-validator.core)\n\n(defn valid-message? [msg]\n  (if (re-find #\"^[A-Za-z]\" msg) false\n      (every? true?\n              (->> msg\n                   (re-seq #\"[A-Za-z]+|[^A-Za-z]+\")\n                   (partition-all 2)\n                   (map (fn [[a b]] (= (.length (or b \"\")) (Integer\/parseInt a)))))))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19160,"user_id":null,"body":"(ns message-validator.core)\n\n(defn correct-length? [match]\n  (let [[_full length text] match]\n     (not= (Integer\/parseInt length) (count text))))\n\n(defn valid-message? [msg]\n  (if (nil? (re-matches #\"(^\\d+.*$|0|.{0}$)\" msg))\n    false\n    (let [matches (re-seq #\"(\\d+)(\\D+|.{0})\" msg)]\n      (->> matches\n           (filter #(correct-length? %))\n           count\n           zero?))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5fde1ea66ba4060008ea5bd9":[{"id":19161,"user_id":645,"body":"(ns kata)\n(defn burner [c h o]\n  (let [h2o (min o (quot h 2))\n        co2 (min c (quot (- o h2o) 2))\n        ch4 (min (- c co2) (quot (- h (* 2 h2o)) 4))]\n    [h2o co2 ch4]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19162,"user_id":null,"body":"(ns kata)\n(defn burner [c h o]\n  (def water (min (quot h 2) o))\n  (let [h (- h water water)\n        o (- o water)]\n    (def co2 (min c (quot o 2)))\n    (let [c (- c co2)\n          o (- o co2 co2)]\n      (def methane (min c (quot h 4)))\n      [water co2 methane])))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19163,"user_id":null,"body":"(ns kata)\n\n(defn fn-h2o \n  \"count of h2o molucules generated\"\n  [h o]\n  (min (int (\/ h 2)) o))\n\n(defn fn-co2\n  \"count of co2 molucules generated\"\n  [c o]\n  (min c (int (\/ o 2))))\n\n(defn fn-ch4\n  \"count of ch4 molucules generated\"\n  [c h]\n  (min c (int (\/ h 4))))\n\n\n(defn burner [c h o]\n  (let [water (fn-h2o h o)\n        co2 (fn-co2 c (- o water))\n        methane (fn-ch4 (- c co2) (- h (* 2 water)))]\n    [water co2 methane]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19164,"user_id":null,"body":"(ns kata)\n\n(defn mol [ a n b m]\n  (let [x (min (quot a n) (quot b m))\n        aa (- a (* n x))\n        bb (- b (* m x))]\n    [x aa bb])\n  )\n\n(defn burner [c h o]\n  (let [[x hh oo] (mol h 2 o 1)\n        [y cc ooo] (mol c 1 oo 2)\n        [z ccc hhh] (mol cc 1 hh 4)]\n    [x y z]))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19165,"user_id":null,"body":"(ns kata)\n(defn burner [c h o]\n  (let [water (min o (quot h 2))]\n    (let [co2 (min c (quot (- o water) 2))]\n      (let [methane (min (- c co2) (quot (- h (* 2 water)) 4))]\n      [water co2 methane]\n        )\n      )\n    )\n  )\n                        ","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19166,"user_id":null,"body":"(ns kata)\n\n(defn get-h20 [h o]\n  (let [h (quot h 2)]\n    (if (>= o h)\n      h\n      o)))\n\n(defn get-co2 [c o]\n  (let [o (quot o 2)]\n    (if (>= c o)\n      o\n      c)))\n\n(defn get-ch4 [c h]\n  (let [h (quot h 4)]\n    (if (> c h)\n      h\n      c)))\n\n\n(defn burner [c h o]\n  (let [h2o (get-h20 h o)\n        h (- h (* h2o 2))\n        o (- o h2o)\n        co2 (get-co2 c o)\n        c (- c co2)\n        o (- o (* 2 co2))\n        ch4 (get-ch4 c h)]\n    [h2o co2 ch4]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19167,"user_id":527,"body":"(ns kata)\n(defn burner [c h o]\n  (let [h2o (min (quot h 2) o)\n        h (- h (* h2o 2))\n        o (- o h2o)\n        co2 (min c (quot o 2))\n        c (- c co2)\n        o (- o (* co2 2))\n        ch4 (min c (quot h 4))]\n    [h2o co2 ch4]))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"6129095b201d6b000e5a33f0":[{"id":19168,"user_id":527,"body":"(ns box-lines.core)\n\n(defn f [x y z]\n  (+ (* x (inc y) (inc z))\n     (* (inc x) y (inc z))\n     (* (inc x) (inc y) z)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19169,"user_id":209,"body":"(ns box-lines.core)\n\n(defn f [x y z]\n    (+ x y z (* 2 (+ (* x y) (* x z) (* y z))) (* 3 x y z))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19170,"user_id":1400,"body":"(ns box-lines.core)\n\n(defn f [x y z]\n  (let [myfloor (+ (* x (inc y)) (* y (inc x)))\n        allfloors (* myfloor (inc z))\n        struts (* (inc x) (inc y))\n        allstruts (* struts z)\n        ]\n    (+ allfloors allstruts)\n  )\n)","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19171,"user_id":50,"body":"(ns box-lines.core)\n\n(defn f [x y z]\n  (+ (* z (+ (* 3 x y) 1 (* 2 (+ x y)))) (* 2 x y) x y)\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19172,"user_id":null,"body":"(ns box-lines.core)\n\n(defn f [x y z]\n  (+ (* 3 x y z) (* 2 (+ (* x y) (* y z) (* x z))) x y z))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19173,"user_id":null,"body":"(ns box-lines.core)\n\n(defn f [x y z]\n  (+ (* (inc y) (inc z) x)\n     (* (inc z) (inc x) y)\n     (* (inc x) (inc y) z)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19174,"user_id":168,"body":"(ns box-lines.core)\n\n(defn f [x y z]\n  (+ (* (inc x) (inc y) z) (* (inc x) y (inc z)) (* x (inc y) (inc z))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19175,"user_id":53,"body":"(ns box-lines.core)\n\n(defn f [x y z]\n    (+ (* x (inc y) (inc z)) (* y (inc x) (inc z)) (* z (inc x) (inc y)))\n  )","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"52a78825cdfc2cfc87000005":[{"id":19176,"user_id":53,"body":"(ns math-parser)\n\n; utility methods\n  \n(defn remove-space [word]\n  (->> (clojure.string\/split word #\"\")\n   (filter #(not (clojure.string\/blank? %)))\n   (clojure.string\/join \"\")))\n\n; expr methods\n\n(declare expression-expr)\n(declare term-expr)\n(declare factor-expr)\n(declare number-expr)\n\n(defn norm-expr [exp]\n  (seq (char-array (remove-space exp))))\n\n(defn number-expr [exp]\n  (let [pre (take-while #(or (= % \\.) (Character\/isDigit %)) exp)\n        pre_num (Double\/parseDouble (apply str pre))\n        post (drop (count pre) exp)]\n    (list pre_num post)))\n   \n(defn expression-expr-walk [n xs]\n  (cond \n    (empty? xs) (list n xs)\n    (= (first xs) \\+) (let [nxt (term-expr (drop 1 xs))]\n        (expression-expr-walk (+ n (first nxt)) (second nxt)))\n    (= (first xs) \\-) (let [nxt (term-expr (drop 1 xs))]\n        (expression-expr-walk (- n (first nxt)) (second nxt)))\n    :else (list n xs)))\n  \n(defn expression-expr [exp]\n  (let [num (term-expr exp)]\n    (expression-expr-walk (first num) (second num))))\n    \n(defn term-expr-walk [n xs]\n  (cond \n    (empty? xs) (list n xs)\n    (= (first xs) \\*) (let [nxt (factor-expr (drop 1 xs))]\n        (term-expr-walk (* n (first nxt)) (second nxt)))\n    (= (first xs) \\\/) (let [nxt (factor-expr (drop 1 xs))]\n        (term-expr-walk (\/ n (first nxt)) (second nxt)))\n    :else (list n xs)))\n    \n(defn term-expr [exp]\n  (let [num (factor-expr exp)]\n    (term-expr-walk (first num) (second num))))\n  \n(defn factor-expr [exp]\n  (cond \n    (Character\/isDigit (first exp)) (number-expr exp)\n    (= (first exp) \\() (let [num (expression-expr (drop 1 exp))]\n        (list (first num) (drop 1 (second num))))\n    (= (first exp) \\-) (let [num (factor-expr (drop 1 exp))]\n        (list (- (first num)) (second num)))\n    :else (list 0 exp)))\n\n(defn calc_expression [exp] \n  (first (expression-expr (norm-expr exp))))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19177,"user_id":null,"body":"(ns math-parser)\n\n(defn idx [haystack needle]\n  (let [[t & r] haystack]\n    (if (or (nil? t) (= t needle))\n      0\n      (inc (idx r needle)))))\n(defn tap [s x] (println s x) x)\n(defn str->float [s] (Float\/parseFloat s))\n\n;; _ is used internally as unary -\n(def tokens-re #\"(?:\\d|\\.)+|\\*|\/|\\+|-|\\(|\\)\")\n(def ops #{\"_\" \"*\" \"\/\" \"+\" \"-\"})\n(def ops-prec {\"_\" 3 \"*\" 2 \"\/\" 2 \"+\" 1 \"-\" 1 \"(\" 0 \")\" 0})\n(def ops-assoc {\"_\" 'R \"*\" 'L \"\/\" 'L \"+\" 'L \"-\" 'L \"(\" 'L \")\" 'L})\n\n(defn map-unary [tokens]\n  (map (fn [[pre t]] (if (and (= t \"-\") (or (ops pre) (= \"(\" pre) (nil? pre))) \"_\" t))\n   (partition 2 1 (cons nil tokens))))\n\n(defn tokenize [str]\n  (map-unary (re-seq tokens-re str)))\n\n(defn push-op [op stack]\n  (let [p (ops-prec op)\n        a (ops-assoc op)\n        [r o] (split-with #(if (= a 'L)\n                             (>= (ops-prec %) p)\n                             (> (ops-prec %) p))\n                          stack)]\n    [(reverse r) (cons op o)]))\n\n(defn parse [tokens]\n  (loop [tokens tokens\n         expr '()\n         stack '()]\n    (if-let [[t & r] tokens]\n      (cond\n        (= t \"(\") (recur r expr (cons t stack))\n        (= t \")\") (let [[group [paren & rest-stack]] (split-at (idx stack \"(\") stack)]\n                    (recur r (concat (reverse group) expr) rest-stack))\n\n        (ops t) (let [[rpn new-stack] (push-op t stack)]\n                  (recur r (concat rpn expr) new-stack))\n\n        :else (recur r (cons (read-string t) expr) stack))\n      (reverse (concat (reverse stack) expr)))))\n\n(defn apply2 [f [a b & stack]] (cons (f a b) stack))\n(defn apply-op [op stack]\n  (case op\n    \"*\" (apply2 * stack)\n\n    \"\/\" (let [[a b & s] stack]\n          (cons (\/ b a) s))\n\n    \"+\" (let [[a b & s] stack]\n          (cons (+ b a) s))\n\n    \"-\" (let [[a b & s] stack]\n          (cons (- b a) s))\n\n    \"_\" (let [[a & s] stack]\n          (cons (- a) s))))\n\n(defn calc_expressionulate-rpn [rpn]\n  (loop [rpn rpn\n         stack '()]\n    (if-let [[t & r] rpn]\n      (cond\n        (ops t) (recur r (apply-op t stack))\n        :else (recur r (cons t stack)))\n      (first stack))))\n\n(defn calc_expression [expression]\n  (->> expression (tap \"expr\") tokenize parse calculate-rpn double))","lang_id":5,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19178,"user_id":null,"body":"(ns math-parser )\n\n(def reInBrackets #\"\\(([^\\(\\)]*)\\)\")\n(def reUnaryMinus1 #\"^-([\\d\\.])\")\n(def reUnaryMinus1-5 #\"([\\+-\\\/\\*])-[-M]([\\d\\.])\")\n(def reUnaryMinus2 #\"([\\+-\\\/\\*])-([\\d\\.])\")\n(def reC1 #\"([M\\d\\.]+)([\\\/\\*])([M\\d\\.]+)\")\n(def reC2 #\"([M\\d\\.]*)([\\-\\+])([M\\d\\.]+)\")\n\n(defn float->string [f]\n  (if (< f 0)  (str \"M\" (- f)) (str f)))\n\n(defn string->float [s]\n  ;(Float\/parseFloat (str\/replace s \"M\" \"-\")\n  (if (or (empty? s) (= s \"M\")) 0\n  (Double\/parseDouble (clojure.string\/replace s \"M\" \"-\"))))\n\n(defn processUnaryMinus [s]\n  (-> s\n      (clojure.string\/replace  reUnaryMinus1 \"M$1\")\n      (clojure.string\/replace  reUnaryMinus1-5 \"$1$2\")\n      (clojure.string\/replace  reUnaryMinus2 \"$1M$2\")))\n\n(defn calc_expression-operation [[_ op1 operator op2]]\n  (let [op1 (string->float op1)\n        op2 (string->float op2)]\n    (float->string (case operator\n                     \"+\" (if (some? op1) (+ op1  op2) op2)\n                     \"-\" (if (some? op1) (- op1  op2) op2)\n                     \"\/\" (\/ op1 op2)\n                     \"*\" (* op1 op2)))))\n\n(def fuse 100)\n\n(defn calc_expression-cycle [s match]\n  (loop [proc s\n         i 0]\n   ; (println i \"->\" proc)\n    (let [x (re-find match proc)]\n      (if (and (some? x) (> fuse i))\n        (recur (clojure.string\/replace proc (first x) (calc-operation x)) (inc i))\n        proc))))\n\n\n(defn calc_expression-expr [s]\n  (->  s\n       processUnaryMinus\n       (calc-cycle reC1)\n       (calc-cycle reC2))) \n\n\n(defn get-in-brackets-exp [s]\n  (let [matcher (re-matcher reInBrackets s)]\n    (loop [r []\n           i 0]\n      (let [x (re-find matcher)]\n        ;(println i \"->\" x)\n        (if (and (some? x) (< i 4))\n          (recur (conj r (x 1)) (inc i))\n          r)))))\n\n\n(defn calc_expression-in-brackets [s b]\n  ;(println s \"->>> \" (str \"(\" b \")\"))\n  (clojure.string\/replace s (str \"(\" b \")\")  (calc-expr b)))\n\n(defn calc_expression [s]\n  (println s)\n  (loop [exp (clojure.string\/replace s \" \" \"\")\n         i 0]\n    (let [in-brackets (get-in-brackets-exp exp)]\n      ;(println \"G---> \" i \"->\" exp \"in brackers\" in-brackets)\n      (if (and (empty? in-brackets) (> fuse i))\n        (string->float (calc-expr exp))\n        (recur (reduce  calc-in-brackets\n                        exp\n                        in-brackets) (inc i))))))\n\n","lang_id":5,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19179,"user_id":null,"body":"(ns math-parser)\n\n(defn is-char [element]\n  (= (type element) java.lang.Character)\n  )\n\n(defn to-token [char]\n  (case char \\( :lparen\n             \\) :rparen\n             \\+ :op-plus\n             \\* :op-multiply\n             \\- :op-minus\n             \\\/ :op-divide\n             char ))\n\n(defn merge-digits [token-group]\n  (if (is-char (first token-group))\n    (Double. (apply str token-group))\n    token-group\n    )\n  )\n\n;; Turns the input string into a sequence of numbers, operations\n;; and parentheses\n(defn tokenize [expression]\n  (->> (clojure.string\/replace expression #\" \" \"\")\n       (seq)\n       (map to-token)\n       (partition-by is-char)\n       (map merge-digits)\n       (flatten))\n  )\n\n;; Checks if the input sequence is enclosed by parentheses\n(defn is-fully-enclosed [token-seq]\n  (let [first-element (first token-seq)\n        last-element (last token-seq)]\n    (and (= first-element :lparen) (= last-element :rparen))\n    )\n  )\n\n(defn is-number-or-paren [element]\n  (or (= (type element) Double) (= element :lparen) (= element :rparen))\n  )\n\n;; Get the index (if existing) of the last operation, that is\n;; on level 0\n;; A levels increase with each left paren and decrease with each\n;; right paren, so that an operation on level 0 is not enclosed by\n;; parentheses\n(defn index-unenclosed-op [op token-seq]\n  (\n    (loop [index (dec (count token-seq)) level 0]\n      (cond\n            (= index -1) (constantly nil)\n            (= :lparen (nth token-seq index)) (recur (dec index) (dec level))\n            (= :rparen (nth token-seq index)) (recur (dec index) (inc level))\n            (and (= level 0) (= op (nth token-seq index))\n                 (or (< index 1) (is-number-or-paren (nth token-seq (dec index))))) (constantly index)\n            :else (recur (dec index) level)\n            )\n      )\n    )\n  )\n\n(defn trim-first-and-last [token-seq]\n  (drop-last (rest token-seq))\n  )\n\n;; Recursive function that creates a call tree following the rules\n;; of this kata. E.g. and * and \/ must be parsed before + and -\n(defn parse [token-seq]\n  (cond\n    (some? (index-unenclosed-op :op-plus token-seq)) (let [[left right]\n                                                               (split-at (index-unenclosed-op :op-plus token-seq) token-seq)]\n                                                           (+ (parse left) (parse (rest right))))\n    (some? (index-unenclosed-op :op-minus token-seq)) (let [[left right]\n                                                           (split-at (index-unenclosed-op :op-minus token-seq) token-seq)]\n                                                       (- (if (= left '()) 0.0 (parse left) ) (parse (rest right))))\n    (some? (index-unenclosed-op :op-multiply token-seq)) (let [[left right]\n                                                               (split-at (index-unenclosed-op :op-multiply token-seq) token-seq)]\n                                                           (* (parse left) (parse (rest right))))\n    (some? (index-unenclosed-op :op-divide token-seq)) (let [[left right]\n                                                             (split-at (index-unenclosed-op :op-divide token-seq) token-seq)]\n                                                         (\/ (parse left) (parse (rest right))))\n    (is-fully-enclosed token-seq) (parse (trim-first-and-last token-seq))\n    (= 1 (count token-seq)) (first token-seq)\n    :else token-seq\n    )\n  )\n\n(defn calc_expression [expression] (parse (tokenize expression)))","lang_id":5,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19180,"user_id":null,"body":"(ns math-parser\n  (:require [clojure.string :as str]))\n\n;; [helper]\n(def empty-summary {:ops [] :open-braces [] :close-braces [] :negatives [] :digits [] })\n\n(defn- remove-ws [expr-raw]\n  (str\/replace expr-raw #\" \" \"\"))\n\n;; [helper] to calc\n(defn- scan-expr\n  \"CAUTION: expr should be removed of ws's\n  produces a map of :ops :open-braces :close-braces :negatives and digits\"\n  [expr]\n  (reduce (fn [summary [idx c]]\n            (cond\n              (#{\\+ \\* \\\/} c) (update summary :ops #(conj % {:value c :pos idx}))\n              (= c \\-) (cond\n                         ;; - appear first => it is a neg sign\n                         (= 0 idx)\n                         (update summary :negatives #(conj % {:value c :pos idx}))\n                         ;; two ops appear consecutively => - is a negative sign\n                         (= (dec idx) (:pos (last (:ops summary))))\n                         (update summary :negatives #(conj % {:value c :pos idx}))\n                         ;; form: (- ...)\n                         (= (dec idx) (:pos (last (:open-braces summary))))\n                         (update summary :negatives #(conj % {:value c :pos idx}))\n                         ;; otherwise it is an operator\n                         :else\n                         (update summary :ops #(conj % {:value c :pos idx})))\n\n              (= c \\() (update summary :open-braces #(conj % {:value c :pos idx}))\n              (= c \\)) (update summary :close-braces #(conj % {:value c :pos idx}))\n              ;; digit\n              :else (update summary :digits #(conj % {:value c :pos idx}))))\n          ;; init val\n          empty-summary\n          ;; coll\n          (map-indexed vector expr)\n    ))\n\n;; [helper]. to calc-expr\n(defn- digits-and-sign-only? [expr]\n  (and (empty? (:ops expr))\n       (empty? (:open-braces expr))\n       (empty? (:close-braces expr))\n       (seq (:digits expr))))\n\n\n;; [helper]. to calc-expr\n(defn- parse-double\n  \"only called when there are only digits in the expr\"\n  [expr]\n  (->> (concat (:negatives expr) (:digits expr))\n    (map #(:value %))\n    (reduce str \"\")\n    Double\/parseDouble))\n\n;; [helper]. to divide-expr-by-symbol-pos\n(defn- divide-summary-vec-by-pos [sum-vec pos]\n  (reduce (fn [res item]\n             (cond\n               (= pos (:pos item)) res\n               (> (:pos item) pos) { :after (conj (:after res) { :value (:value item) :pos (- (:pos item) 1 pos)})\n                                     :before (:before res)}\n               :else               { :after (:after res)\n                                     :before (conj (:before res) item)}))\n           {:before [] :after []}\n           sum-vec))\n\n;; [helper]. to calc-expr\n(defn- divide-expr-by-symbol-pos [expr symbol-pos]\n  (reduce (fn [divided-summaries key]\n            (let [ vec (key expr)\n                   { before-vec :before after-vec :after} (divide-summary-vec-by-pos vec symbol-pos)]\n              { :before (update (:before divided-summaries) key (constantly before-vec))\n                :after  (update (:after divided-summaries) key (constantly after-vec))}))\n          { :before empty-summary\n            :after empty-summary}\n          (keys expr)))\n\n;; (defn- get-last-plus-or-minus-from-expr [expr]\n;;   (when-let [the-last (last (filter #(or (= \\+ (:value %)) (= \\- (:value %))) (:ops expr)))]\n;;     the-last))\n\n;; [helper] to braces-balanced?, remove-braces\n(defn- combine-lst-of-braces [expr]\n  (sort #(< (:pos %1) (:pos %2))(concat (:open-braces  expr)\n                                         (:close-braces expr))))\n\n;; [helper] to find-the-least-favorable-op\n(defn- remove-braces\n  \"this function is only called when there are braces in the expr.\n  A new expr w\/o braces (and stuff in braces is returned)\"\n  [expr]\n\n  (let [ first-open-brace-pos (:pos (first (:open-braces expr)))\n         last-close-brace-pos (:pos (last (:close-braces expr)))\n         ;; edit: not only just pos anymore.\n         pos-lst-of-braces    (combine-lst-of-braces expr)\n         room-out-of-1st-lvl-braces (reduce (fn [accu curr]\n                                              (cond\n                                                (= (:value curr) \\()\n                                                { :res (if (and (= (:lvl accu) 0)\n                                                                (seq (:res accu)))\n                                                           (update (:res accu)\n                                                                   (dec (count (:res accu)))\n                                                                   #(conj % (:pos curr)))\n                                                           ;; (conj (:res accu) [(:pos curr)])\n                                                           (:res accu))\n                                                  :lvl (inc (:lvl accu))}\n\n                                                :else\n                                                { :res (if (= (:lvl accu) 1)\n                                                           (conj (:res accu) [(:pos curr)])\n                                                           (:res accu))\n                                                  :lvl (dec (:lvl accu))}))\n                                            { :res []\n                                              :lvl 0}\n                                            pos-lst-of-braces)\n\n         update-strategy (fn [vec]\n                           (into [] (filter (fn [{pos :pos}]\n                                              (or (< pos first-open-brace-pos)\n                                                  (> pos last-close-brace-pos)\n                                                  (and (< 1 (count (:res room-out-of-1st-lvl-braces)))\n                                                       (some #(< (first %) pos (second %))\n                                                             (subvec (:res room-out-of-1st-lvl-braces) 0 (dec (count (:res room-out-of-1st-lvl-braces))))))))\n                                      ;; coll for filter\n                                      vec)))]\n\n    (-> expr\n      (update :open-braces (constantly []))\n      (update :close-braces (constantly []))\n      ;; filter out stuff in the boundaries of braces\n      (update :ops update-strategy)\n      (update :negatives update-strategy)\n      (update :digits update-strategy))))\n\n;; [helper] to get-least-favorable-operator-from-expr\n(defn- find-the-least-favorable-op\n  \"only be call when the least favorable symbol is an op\"\n  [expr]\n  (let [\n         open-braces (:open-braces expr)\n         ;; expr* is expr w\/o braces\n         expr* (if (empty? open-braces)\n                   expr\n                   (remove-braces expr))\n         ops (:ops expr*)\n         only-plus-minus-ops (filter #(or (= (:value %) \\+) (= (:value %) \\-)) ops)\n         target-ops (if (empty? only-plus-minus-ops)\n                        ops\n                        only-plus-minus-ops)]\n    (last target-ops)))\n\n;; [helper] to calc-expr\n;; edit: alias for find-the-least-favorable-op\n(def get-least-favorable-operator-from-expr find-the-least-favorable-op)\n\n;; [utility] for neg-sign-and-braces?\n(defn- count-expr\n  \"count the length of an expr\"\n  [expr]\n  (reduce (fn [accu key]\n            (+ accu (count (key expr))))\n          0\n          (keys expr)))\n\n;; [helper] to neg-sign-and-braces?\n(defn braces-balanced? [expr]\n  (let [combined-lst-of-braces (combine-lst-of-braces expr)]\n    (reduce (fn [lvl {value :value}]\n              (let [lvl* (if (= value \\()\n                             (inc lvl)\n                             (dec lvl))]\n                (if (< lvl* 0)\n                    (reduced false)\n                    lvl*)))\n            ;; init value\n            0\n            combined-lst-of-braces)))\n\n\n;; [helper] to neg-sign-and-all-in-braces?, calc-expr\n(defn- all-in-braces?\n  ([expr] (all-in-braces? expr 0))\n  ([expr start]\n    (-> expr\n         ;; removing the outer most two braces\n         (update :open-braces #(subvec % (inc start) (count %)))\n         (update :close-braces #(subvec % 0 (dec (count %))))\n         (braces-balanced?))))\n\n;; [helper] to neg-sign-and-braces?\n(defn- neg-sign-and-all-in-braces? [expr]\n  (and (= 0 (:pos (first (:negatives expr))))\n       (= 1 (:pos (first (:open-braces expr))))\n       ;; last close-brace is at the end\n       (= (dec (count-expr expr)) (:pos (last (:close-braces expr))))\n       ;; are braces balances after remove the outer most two\n       (all-in-braces? expr)))\n\n\n;; TODO: in progress (Status: refer to comments)\n(defn calc_expression-expr\n  \"expr here is a map of :ops :open-braces :close-braces :negatives and :digits\"\n  [expr]\n  ;; (println \"\n calcing:\")\n  ;; (println expr)\n\n  ;; (println \"parsable?\")\n  ;; (println (digits-and-sign-only? expr))\n  ;; (println \"neg-and-braces?\")\n  ;; (println (neg-sign-and-all-in-braces? expr))\n\n  ;; (println \"all-in-braces?\")\n  ;; (println (and (= 0 (:pos (first (:open-braces expr))))\n  ;;            (= (dec (count-expr expr))\n  ;;              (:pos (last (:close-braces expr))))\n  ;;            (all-in-braces? expr)))\n\n  (cond\n\n    ;; only digits left\n    (digits-and-sign-only? expr)\n    (parse-double expr)\n\n    ;; form: -(......)\n    (neg-sign-and-all-in-braces? expr)\n    (let [{_before :before after :after}\n          (divide-expr-by-symbol-pos expr 0)]\n      (- (calc-expr after)))\n\n    ;; form: (......)\n    (and (= 0 (:pos (first (:open-braces expr))))\n         (= (dec (count-expr expr))\n            (:pos (last (:close-braces expr))))\n         (all-in-braces? expr))\n    (let [{_before :before after :after}\n          (divide-expr-by-symbol-pos expr 0)]\n      (calc-expr (update after :close-braces #(subvec % 0 (dec (count %))))))\n\n    :else\n    (let [ least-favorable-operator (get-least-favorable-operator-from-expr expr)\n           {before :before after :after} (divide-expr-by-symbol-pos\n                                           expr\n                                           (:pos least-favorable-operator))\n           func (resolve (symbol (str (:value least-favorable-operator))))]\n\n      ;; (println \"\n least fav op:\")\n      ;; (println least-favorable-operator)\n\n      ;; (println \"\nbefore\")\n      ;; (println before)\n      ;; (println \"\nafter\")\n      ;; (println after)\n\n      (func (calc-expr before) (calc-expr after))\n      )))\n\n\n(defn calc_expression [expr]\n  (calc-expr (scan-expr (remove-ws expr))))\n\n\n\n","lang_id":5,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19181,"user_id":null,"body":"(ns math-parser)\n\n;;; operators\n\n(def operators\n  [{:id :add, :fn +, :preced 2, :arity :bin, :assoc :left}\n   {:id :sub, :fn -, :preced 2, :arity :bin, :assoc :left}\n   {:id :mul, :fn *, :preced 3, :arity :bin, :assoc :left}\n   {:id :div, :fn \/, :preced 3, :arity :bin, :assoc :left}\n   {:id :unary-, :fn -, :preced 4, :arity :un}])\n\n(def operator-map (zipmap (map :id operators) operators))\n\n;;; parsing functions\n\n(defn separate-tokens [strng]\n  (map first (re-seq #\"(\\d+\\.?\\d*)|[+*\/()-]\" strng)))\n\n(defn parse-number [strng]\n  (if (re-matches #\"\\d+\\.\\d+\" strng)\n    (Double\/parseDouble strng)\n    (Integer\/parseInt strng 10)))\n\n(defn parse [expr]\n  (->> (separate-tokens expr)\n       (reduce\n        (fn [sq tok]\n          (let [prev (last sq)]\n            (conj sq\n                  (case tok\n                    \"+\" :add, \"-\" (if (or (number? prev) (= :r-paren prev))\n                                    :sub\n                                    :unary-)\n                    \"*\" :mul, \"\/\" :div, \"^\" :pow, \"(\" :l-paren, \")\" :r-paren\n                    (parse-number tok))))) [])))\n\n;;; ev*laution functions\n\n; compares two operators\n(defn operator> [id1 id2]\n  (let [op1 (operator-map id1)\n        op1-arity (:arity op1)\n        op1-preced (:preced op1)\n        op2 (operator-map id2)\n        op2-arity (:arity op2)\n        op2-preced (:preced op2)]\n    (or\n     ; unary minus\n     (= op1-arity :un)\n     ; binary x > binary y: if x has higher precedence than y, or x is left associative and x and y have equal precedence.\n     (and (= op1-arity :bin) (= op2-arity :bin)\n          (or (> op1-preced op2-preced)\n              (and (= op1-preced op2-preced)\n                   (= (:assoc op1) :left)))))))\n\n(defn shunting-yard [tokens]\n  (loop [tokens tokens\n         op-stack '()\n         output []]\n    (if (empty? tokens)\n      (concat output op-stack)\n      (let [tok (first tokens)]\n        (cond\n          (number? tok) (recur (rest tokens) op-stack (conj output tok))\n          (= :l-paren tok) (recur (rest tokens) (conj op-stack tok) output)\n          (= :r-paren tok) (recur (rest tokens)\n                                  (rest (drop-while #(not= :l-paren %) op-stack))\n                                  (vec (concat output (take-while #(not= :l-paren %) op-stack))))\n          (operator-map tok) (let [pop-ops (take-while #(and (not= :l-paren %)\n                                                             (operator> % tok))\n                                                       op-stack)]\n                               (recur (rest tokens)\n                                      (conj (drop (count pop-ops) op-stack) tok)\n                                      (vec (concat output pop-ops)))))))))\n\n(defn calc_expression-rpn [tokens]\n  (first\n   (reduce (fn [out tok]\n             (if (number? tok)\n               (conj out tok)\n               (let [op (operator-map tok)\n                     n-args (case (:arity op) :un 1, :bin 2)]\n                 (conj (drop n-args out)\n                       (apply (:fn op) (reverse (take n-args out)))))))\n           '() tokens)))\n\n;;; main function\n\n(defn calc_expression [expr]\n  (->> (parse expr)\n       (shunting-yard)\n       (calc-rpn)\n       (double)))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19182,"user_id":null,"body":"(ns math-parser\n  (require [clojure.string :as str]))\n\n\n(defn is-operator? [token]\n  (boolean (#{\\+ \\\/ \\* \\- \\( \\)} token)))\n\n(defn dash-type [expr loc]\n  (let [prev (nth expr (dec loc) \\-)]\n    (if (or (= \\) prev) (Character\/isDigit ^char prev))\n      :subtraction\n      :negation)))\n\n(defn get-number [expr loc]\n  (->> (drop loc expr)\n       (take-while #(or (Character\/isDigit ^char %) (= % \\.)))\n       (apply str)))\n\n(defn tokenize [expr]\n  (let [expr (str\/replace expr #\" \" \"\")]\n    (loop [tokens [] loc 0]\n      (if (= loc (count expr))\n        tokens\n        (let [token (nth expr loc)]\n          (cond (Character\/isDigit ^char token)\n                (let [num (get-number expr loc)]\n                  (recur (conj tokens (Double\/parseDouble num)) (+ loc (count num))))\n                :else\n                (recur (conj tokens\n                             (if (= \\- token)\n                               (if (= :subtraction (dash-type expr loc)) \\- \\~)\n                               token))\n                       (inc loc))))))))\n\n;; Convert to RPN\n\n(def operator-precedence\n  {\\( 1 \\) 1 \\+ 2 \\- 2 \\* 3 \\\/ 3 \\~ 4})\n\n;; Returns precedence of op1 compared to op2.\n;; e.g. (precedence \\* \\+) => :higher\n(defn precedence [op1 op2]\n  (cond (< (operator-precedence op1) (operator-precedence op2)) :lower\n        (> (operator-precedence op1) (operator-precedence op2)) :higher\n        :else :same))\n\n(defn pop-brackets [{:keys [output op-stack]}]\n  (let [ops (take-while #(not= % \\() op-stack)\n        output (apply conj output ops)]\n    {:output output :op-stack (vec (drop (inc (count ops)) op-stack))}))\n\n(defn pop-lower-or-same-precedence [{:keys [output op-stack]} t]\n  (if (or (empty? op-stack) (= (precedence t (first op-stack)) :higher))\n    {:output output :op-stack (concat [t] op-stack)}\n    (let [ops (take-while #(not= :higher (precedence t %)) op-stack)\n          output (apply conj output ops)\n          op-stack (concat [t] (drop (count ops) op-stack))]\n      {:output output :op-stack op-stack})))\n\n(defn to-rpn [tokens]\n  (let [acc (reduce (fn [acc t]\n                      (cond (number? t)\n                            (update acc :output conj t)\n\n                            (or (= t \\() (= t \\~))\n                            (update acc :op-stack #(concat [t] %))\n\n                            (= t \\))\n                            (pop-brackets acc)\n\n                            :else\n                            (if (= :higher (operator-precedence t (first (acc :op-stack))))\n                              (update acc :op-stack #(concat [t] %))\n                              (pop-lower-or-same-precedence acc t))))\n                    {:output [] :op-stack []}\n                    tokens)]\n    (apply conj (:output acc) (:op-stack acc))))\n\n;; Evaluate RPN\n\n(defn get-function [i]\n  (cond (= i \\+) +\n        (= i \\-) -\n        (= i \\*) *\n        (= i \\\/) \/))\n\n(defn rpn-reducer [operand-stack i]\n  (cond (number? i)\n        (concat [i] operand-stack)\n\n        (= \\~ i)\n        (concat [(- (first operand-stack))] (drop 1 operand-stack))\n\n        :else\n        (let [op1 (first operand-stack)\n              op2 (second operand-stack)\n              res ((get-function i) op2 op1)]\n          (concat [res] (drop 2 operand-stack)))))\n\n(defn calc_expression-rpn [rpn]\n  (->> (reduce rpn-reducer [] rpn)\n       (first)))\n\n(defn calc_expression [expression]\n  (->> expression\n       (tokenize)\n       (to-rpn)\n       (calc-rpn)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19183,"user_id":null,"body":"(ns math-parser\n  (require [clojure.string :as str]))\n\n(defn is-digit? [token]\n  (Character\/isDigit ^char token))\n\n(defn is-operator? [token]\n  (not (nil? (#{\\+ \\\/ \\* \\( \\)} token))))\n\n(defn get-number [expr loc]\n  (->> (drop loc expr)\n       (take-while (fn [t]\n                     (or (is-digit? t) (= t \\.))))\n       (apply str)))\n\n(defn type-of-dash [expr loc]\n  (if (= 0 loc)\n    (if (is-digit? (second expr))\n      :negation\n      :subtraction)\n    (let [prev (nth expr (dec loc))\n          next (nth expr (inc loc))]\n      (cond (and (= \\) prev) (is-digit? next)) :subtraction\n            (and (is-operator? prev) (is-digit? next)) :negation\n            (and (= \\) prev) (= \\( next)) :subtraction\n            (and (= \\- prev) (is-digit? next)) :negation\n            (and (= \\- prev) (= \\- next)) :negation\n            (and (is-digit? prev) (is-digit? next)) :subtraction\n            (and (is-digit? prev) (= \\- next)) :subtraction\n            (and (is-digit? prev) (= \\( next)) :subtraction\n            (and (= \\) prev) (= \\- next)) :subtraction))))\n\n(defn tokenize [expr]\n  (let [expr (->> (str\/replace expr #\" \" \"\")\n                  #_(fix-zeros))\n        expr (if (str\/starts-with? expr \"-(\") (str \"0\" expr) expr)]\n    (loop [tokens []\n           loc 0]\n      (if (= loc (count expr))\n        tokens\n        (let [token (nth expr loc)]\n          (cond\n            ; token is a number\n            ; so we need to keep taking digits till we don't hit a digit. Then parse it to an int.\n            ; we then to move the location to the end of the number.\n            (is-digit? token)\n            (let [num (get-number expr loc)]\n              (recur (conj tokens (Double\/parseDouble num)) (+ loc (count (str num)))))\n\n            ; token is an operator\n            ; add it to the operators list and increase the location for the next token.\n            (is-operator? token)\n            (recur (conj tokens token) (inc loc))\n\n            ; special case :: token is -\n            ; this can mean either subtraction or negation.\n            (= token \\-)\n            (let [dash-type (type-of-dash expr loc)]\n              (cond (= dash-type :subtraction)\n                    (recur (conj tokens token) (inc loc))\n                    :else\n                    ; its negation - so if the next char is a digit, then we have a negative number!\n                    ; otherwise just add the - and carry on.\n                    (if (is-digit? (nth expr (inc loc)))\n                      (let [num (get-number expr (inc loc))]\n                        (recur (conj tokens (- (Double\/parseDouble num))) (+ loc (inc (count (str num))))))\n                      (recur (conj tokens \\~) (inc loc)))))\n\n            ; ignore trash\n            :else\n            (recur tokens (inc loc))))))))\n\n(defn precedence-check [op1 op2]\n  (cond (or (= op1 \\-) (= op1 \\+)) (cond (= op2 \\-) :same\n                                         (= op2 \\+) :same\n                                         (= op2 \\\/) :lower\n                                         (= op2 \\*) :lower\n                                         (= op2 \\_) :lower)\n\n        (or (= op1 \\*) (= op1 \\\/)) (cond (= op2 \\_) :lower\n                                         (= op2 \\-) :higher\n                                         (= op2 \\+) :higher\n                                         (= op2 \\\/) :same\n                                         (= op2 \\*) :same)\n\n        (or (= op1 \\_)) :higher))\n\n\n(defn get-lower-or-same-precedence-operators [token op-stack]\n  (take-while (fn [t] (let [precedence (precedence-check token t)]\n                        (cond (or (= t \\() (= t \\))) false\n                              (= :same precedence) true\n                              (= :lower precedence) true)))\n              op-stack))\n\n(defn to-rpn [tokens]\n  (loop [tokens tokens\n         output []\n         operators []]\n    (if (empty? tokens)\n      (apply conj output operators)\n      (let [token (first tokens)]\n        (cond (number? token)\n              (recur (rest tokens) (conj output token) operators)\n\n              (= \\( token)\n              (recur (rest tokens) output (concat [token] operators))\n\n              (= \\) token)\n              (let [paren-ops (take-while #(not= % \\() operators)]\n                (recur (rest tokens)\n                       (apply conj output paren-ops)\n                       (drop (inc (count paren-ops)) operators)))\n\n              (or (= \\+ token) (= \\- token) (= \\* token) (= \\\/ token))\n              (let [popped-tokens (get-lower-or-same-precedence-operators token operators)]\n                (recur (rest tokens)\n                       (apply conj output popped-tokens)\n                       (concat [token] (drop (count popped-tokens) operators))))\n\n              (= \\~ token)\n              (recur (rest tokens)\n                     output\n                     (concat [token] operators))\n\n              :else\n              (recur (rest tokens) output operators))))))\n\n(defn get-function [i]\n  (cond (= i \\+) +\n        (= i \\-) -\n        (= i \\*) *\n        (= i \\\/) \/))\n\n(defn run-rpn [rpn]\n  (loop [rpn rpn\n         operand-stack []]\n    (let [current (first rpn)]\n      (if (empty? rpn)\n        (first operand-stack)\n        (if (number? current)\n          (recur (rest rpn) (concat [current] operand-stack))\n          (if (= \\~ current)\n            ; its negation\n            (let [op (first operand-stack)]\n              (recur (rest rpn) (concat [(- op)] (rest operand-stack))))\n            (let [right (first operand-stack)\n                  left (second operand-stack)\n                  op-res ((get-function current) left right)]\n              (recur (rest rpn) (concat [op-res] (drop 2 operand-stack))))))))))\n\n(defn calc_expression [expression]\n  (->> expression\n    (tokenize)\n    (to-rpn)\n    (run-rpn)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19184,"user_id":571,"body":"(ns math-parser\n  (:require [clojure.string :as str]))\n\n(defn re [s]\n  (re-pattern (str \"(-?\\\\d+\\\\.?\\\\d*)\" s \"(-?\\\\d+\\\\.?\\\\d*)\")))\n\n(def ops\n  [{:op \/ :re (re \"\/\")} {:op * :re (re \"\\\\*\")} {:op - :re (re \"-\")} {:op + :re (re \"\\\\+\")}])\n\n(defn clean [s]\n  (-> s\n      (str\/replace #\"\\s\" \"\")\n      (str\/replace #\"(--)+-\" \"-\")\n      (str\/replace #\"--\" \"+\")\n      (str\/replace #\"\\+-\\+\" \"-\")\n      (str\/replace #\"\\++\" \"+\")\n      (str\/replace #\"\/\\+\" \"\/\")\n      (str\/replace #\"\\*\\+\" \"*\")))\n\n(defn solve [exp]\n  (let [s (str\/replace exp #\"[(|)]\" \"\")]\n    (if (re-matches #\"^-?\\d+[.]?\\d*$\" s)\n      s\n      (let [op (first (filter #(not (nil? (re-find (:re %) s))) ops))\n            m (re-find (:re op) s)\n            r (str\/replace-first s (:re op) (str ((:op op) (double (read-string (nth m 1))) (double (read-string (nth m 2))))))]\n        (solve (clean r))))))\n\n(defn calc_expression [e]\n  (let [exp (clean e)]\n    (if (str\/includes? exp \"(\")\n      (calc (str\/replace exp #\"\\([^()]+\\)\" solve))\n      (if (re-matches #\"^-?\\d+[.]?\\d*$\" exp) (double (read-string exp)) (double(read-string (clean (solve exp))))))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5679d5a3f2272011d700000d":[{"id":19185,"user_id":null,"body":"(ns skyscrapers)\n\n\n(def cap7 {[7 1] [[1 2 3 4 5 6 7]], [4 3] [[1 4 6 7 3 5 2] [1 4 6 7 2 5 3] [1 4 6 7 5 2 3] [1 4 6 3 7 5 2] [1 4 6 2 7 5 3] [1 4 6 5 7 3 2] [1 4 3 6 7 5 2] [1 4 3 5 7 6 2] [1 4 2 6 7 5 3] [1 4 2 5 7 6 3] [1 4 5 7 6 2 3] [1 4 5 7 3 6 2] [1 4 5 7 2 6 3] [1 4 5 3 7 6 2] [1 4 5 2 7 6 3] [1 3 4 7 6 2 5] [1 3 4 7 2 6 5] [1 3 4 7 5 6 2] [1 3 4 2 7 6 5] [1 3 6 7 4 5 2] [1 3 6 7 2 5 4] [1 3 6 7 5 2 4] [1 3 6 4 7 5 2] [1 3 6 2 7 5 4] [1 3 6 5 7 4 2] [1 3 2 4 7 6 5] [1 3 2 6 7 5 4] [1 3 2 5 7 6 4] [1 3 5 7 4 6 2] [1 3 5 7 6 2 4] [1 3 5 7 2 6 4] [1 3 5 4 7 6 2] [1 3 5 2 7 6 4] [1 2 4 7 6 3 5] [1 2 4 7 3 6 5] [1 2 4 7 5 6 3] [1 2 4 3 7 6 5] [1 2 6 7 4 5 3] [1 2 6 7 3 5 4] [1 2 6 7 5 3 4] [1 2 6 4 7 5 3] [1 2 6 3 7 5 4] [1 2 6 5 7 4 3] [1 2 3 7 4 6 5] [1 2 3 7 6 4 5] [1 2 3 7 5 6 4] [1 2 5 7 4 6 3] [1 2 5 7 6 3 4] [1 2 5 7 3 6 4] [1 2 5 4 7 6 3] [1 2 5 3 7 6 4] [1 5 4 6 7 3 2] [1 5 6 7 4 2 3] [1 5 6 7 3 4 2] [1 5 6 7 2 4 3] [1 5 6 4 7 3 2] [1 5 6 3 7 4 2] [1 5 6 2 7 4 3] [1 5 3 6 7 4 2] [1 5 2 6 7 4 3] [2 1 4 6 7 5 3] [2 1 4 5 7 6 3] [2 1 3 4 7 6 5] [2 1 3 6 7 5 4] [2 1 3 5 7 6 4] [2 1 5 6 7 4 3] [2 4 1 6 7 5 3] [2 4 1 5 7 6 3] [2 4 6 7 1 5 3] [2 4 6 7 3 5 1] [2 4 6 7 5 1 3] [2 4 6 1 7 5 3] [2 4 6 3 7 5 1] [2 4 6 5 7 3 1] [2 4 3 6 7 5 1] [2 4 3 5 7 6 1] [2 4 5 7 1 6 3] [2 4 5 7 6 1 3] [2 4 5 7 3 6 1] [2 4 5 1 7 6 3] [2 4 5 3 7 6 1] [2 3 1 4 7 6 5] [2 3 1 6 7 5 4] [2 3 1 5 7 6 4] [2 3 4 7 1 6 5] [2 3 4 7 6 1 5] [2 3 4 7 5 6 1] [2 3 4 1 7 6 5] [2 3 6 7 1 5 4] [2 3 6 7 4 5 1] [2 3 6 7 5 1 4] [2 3 6 1 7 5 4] [2 3 6 4 7 5 1] [2 3 6 5 7 4 1] [2 3 5 7 1 6 4] [2 3 5 7 4 6 1] [2 3 5 7 6 1 4] [2 3 5 1 7 6 4] [2 3 5 4 7 6 1] [2 5 1 6 7 4 3] [2 5 4 6 7 3 1] [2 5 6 7 1 4 3] [2 5 6 7 4 1 3] [2 5 6 7 3 4 1] [2 5 6 1 7 4 3] [2 5 6 4 7 3 1] [2 5 6 3 7 4 1] [2 5 3 6 7 4 1] [3 1 4 6 7 5 2] [3 1 4 5 7 6 2] [3 1 5 6 7 4 2] [3 4 1 6 7 5 2] [3 4 1 5 7 6 2] [3 4 6 7 1 5 2] [3 4 6 7 2 5 1] [3 4 6 7 5 1 2] [3 4 6 1 7 5 2] [3 4 6 2 7 5 1] [3 4 6 5 7 2 1] [3 4 2 6 7 5 1] [3 4 2 5 7 6 1] [3 4 5 7 1 6 2] [3 4 5 7 6 1 2] [3 4 5 7 2 6 1] [3 4 5 1 7 6 2] [3 4 5 2 7 6 1] [3 2 4 6 7 5 1] [3 2 4 5 7 6 1] [3 2 5 6 7 4 1] [3 5 1 6 7 4 2] [3 5 4 6 7 2 1] [3 5 6 7 1 4 2] [3 5 6 7 4 1 2] [3 5 6 7 2 4 1] [3 5 6 1 7 4 2] [3 5 6 4 7 2 1] [3 5 6 2 7 4 1] [3 5 2 6 7 4 1] [4 1 5 6 7 3 2] [4 3 5 6 7 2 1] [4 2 5 6 7 3 1] [4 5 1 6 7 3 2] [4 5 6 7 1 3 2] [4 5 6 7 3 1 2] [4 5 6 7 2 3 1] [4 5 6 1 7 3 2] [4 5 6 3 7 2 1] [4 5 6 2 7 3 1] [4 5 3 6 7 2 1] [4 5 2 6 7 3 1]], [2 2] [[1 7 4 3 2 5 6] [1 7 4 3 5 2 6] [1 7 4 2 3 5 6] [1 7 4 2 5 3 6] [1 7 4 5 3 2 6] [1 7 4 5 2 3 6] [1 7 3 4 2 5 6] [1 7 3 4 5 2 6] [1 7 3 2 4 5 6] [1 7 3 2 5 4 6] [1 7 3 5 4 2 6] [1 7 3 5 2 4 6] [1 7 2 4 3 5 6] [1 7 2 4 5 3 6] [1 7 2 3 4 5 6] [1 7 2 3 5 4 6] [1 7 2 5 4 3 6] [1 7 2 5 3 4 6] [1 7 5 4 3 2 6] [1 7 5 4 2 3 6] [1 7 5 3 4 2 6] [1 7 5 3 2 4 6] [1 7 5 2 4 3 6] [1 7 5 2 3 4 6] [2 7 1 4 3 5 6] [2 7 1 4 5 3 6] [2 7 1 3 4 5 6] [2 7 1 3 5 4 6] [2 7 1 5 4 3 6] [2 7 1 5 3 4 6] [2 7 4 1 3 5 6] [2 7 4 1 5 3 6] [2 7 4 3 1 5 6] [2 7 4 3 5 1 6] [2 7 4 5 1 3 6] [2 7 4 5 3 1 6] [2 7 3 1 4 5 6] [2 7 3 1 5 4 6] [2 7 3 4 1 5 6] [2 7 3 4 5 1 6] [2 7 3 5 1 4 6] [2 7 3 5 4 1 6] [2 7 5 1 4 3 6] [2 7 5 1 3 4 6] [2 7 5 4 1 3 6] [2 7 5 4 3 1 6] [2 7 5 3 1 4 6] [2 7 5 3 4 1 6] [2 1 7 4 3 5 6] [2 1 7 4 5 3 6] [2 1 7 3 4 5 6] [2 1 7 3 5 4 6] [2 1 7 5 4 3 6] [2 1 7 5 3 4 6] [3 7 1 4 2 5 6] [3 7 1 4 5 2 6] [3 7 1 2 4 5 6] [3 7 1 2 5 4 6] [3 7 1 5 4 2 6] [3 7 1 5 2 4 6] [3 7 4 1 2 5 6] [3 7 4 1 5 2 6] [3 7 4 2 1 5 6] [3 7 4 2 5 1 6] [3 7 4 5 1 2 6] [3 7 4 5 2 1 6] [3 7 2 1 4 5 6] [3 7 2 1 5 4 6] [3 7 2 4 1 5 6] [3 7 2 4 5 1 6] [3 7 2 5 1 4 6] [3 7 2 5 4 1 6] [3 7 5 1 4 2 6] [3 7 5 1 2 4 6] [3 7 5 4 1 2 6] [3 7 5 4 2 1 6] [3 7 5 2 1 4 6] [3 7 5 2 4 1 6] [3 1 7 4 2 5 6] [3 1 7 4 5 2 6] [3 1 7 2 4 5 6] [3 1 7 2 5 4 6] [3 1 7 5 4 2 6] [3 1 7 5 2 4 6] [3 1 2 7 4 5 6] [3 1 2 7 5 4 6] [3 2 7 1 4 5 6] [3 2 7 1 5 4 6] [3 2 7 4 1 5 6] [3 2 7 4 5 1 6] [3 2 7 5 1 4 6] [3 2 7 5 4 1 6] [3 2 1 7 4 5 6] [3 2 1 7 5 4 6] [4 7 1 3 2 5 6] [4 7 1 3 5 2 6] [4 7 1 2 3 5 6] [4 7 1 2 5 3 6] [4 7 1 5 3 2 6] [4 7 1 5 2 3 6] [4 7 3 1 2 5 6] [4 7 3 1 5 2 6] [4 7 3 2 1 5 6] [4 7 3 2 5 1 6] [4 7 3 5 1 2 6] [4 7 3 5 2 1 6] [4 7 2 1 3 5 6] [4 7 2 1 5 3 6] [4 7 2 3 1 5 6] [4 7 2 3 5 1 6] [4 7 2 5 1 3 6] [4 7 2 5 3 1 6] [4 7 5 1 3 2 6] [4 7 5 1 2 3 6] [4 7 5 3 1 2 6] [4 7 5 3 2 1 6] [4 7 5 2 1 3 6] [4 7 5 2 3 1 6] [4 1 7 3 2 5 6] [4 1 7 3 5 2 6] [4 1 7 2 3 5 6] [4 1 7 2 5 3 6] [4 1 7 5 3 2 6] [4 1 7 5 2 3 6] [4 1 3 7 2 5 6] [4 1 3 7 5 2 6] [4 1 3 2 7 5 6] [4 1 2 7 3 5 6] [4 1 2 7 5 3 6] [4 1 2 3 7 5 6] [4 3 7 1 2 5 6] [4 3 7 1 5 2 6] [4 3 7 2 1 5 6] [4 3 7 2 5 1 6] [4 3 7 5 1 2 6] [4 3 7 5 2 1 6] [4 3 1 7 2 5 6] [4 3 1 7 5 2 6] [4 3 1 2 7 5 6] [4 3 2 7 1 5 6] [4 3 2 7 5 1 6] [4 3 2 1 7 5 6] [4 2 7 1 3 5 6] [4 2 7 1 5 3 6] [4 2 7 3 1 5 6] [4 2 7 3 5 1 6] [4 2 7 5 1 3 6] [4 2 7 5 3 1 6] [4 2 1 7 3 5 6] [4 2 1 7 5 3 6] [4 2 1 3 7 5 6] [4 2 3 7 1 5 6] [4 2 3 7 5 1 6] [4 2 3 1 7 5 6] [5 7 1 4 3 2 6] [5 7 1 4 2 3 6] [5 7 1 3 4 2 6] [5 7 1 3 2 4 6] [5 7 1 2 4 3 6] [5 7 1 2 3 4 6] [5 7 4 1 3 2 6] [5 7 4 1 2 3 6] [5 7 4 3 1 2 6] [5 7 4 3 2 1 6] [5 7 4 2 1 3 6] [5 7 4 2 3 1 6] [5 7 3 1 4 2 6] [5 7 3 1 2 4 6] [5 7 3 4 1 2 6] [5 7 3 4 2 1 6] [5 7 3 2 1 4 6] [5 7 3 2 4 1 6] [5 7 2 1 4 3 6] [5 7 2 1 3 4 6] [5 7 2 4 1 3 6] [5 7 2 4 3 1 6] [5 7 2 3 1 4 6] [5 7 2 3 4 1 6] [5 1 7 4 3 2 6] [5 1 7 4 2 3 6] [5 1 7 3 4 2 6] [5 1 7 3 2 4 6] [5 1 7 2 4 3 6] [5 1 7 2 3 4 6] [5 1 4 7 3 2 6] [5 1 4 7 2 3 6] [5 1 4 3 7 2 6] [5 1 4 3 2 7 6] [5 1 4 2 7 3 6] [5 1 4 2 3 7 6] [5 1 3 7 4 2 6] [5 1 3 7 2 4 6] [5 1 3 4 7 2 6] [5 1 3 4 2 7 6] [5 1 3 2 7 4 6] [5 1 3 2 4 7 6] [5 1 2 7 4 3 6] [5 1 2 7 3 4 6] [5 1 2 4 7 3 6] [5 1 2 4 3 7 6] [5 1 2 3 7 4 6] [5 1 2 3 4 7 6] [5 4 7 1 3 2 6] [5 4 7 1 2 3 6] [5 4 7 3 1 2 6] [5 4 7 3 2 1 6] [5 4 7 2 1 3 6] [5 4 7 2 3 1 6] [5 4 1 7 3 2 6] [5 4 1 7 2 3 6] [5 4 1 3 7 2 6] [5 4 1 3 2 7 6] [5 4 1 2 7 3 6] [5 4 1 2 3 7 6] [5 4 3 7 1 2 6] [5 4 3 7 2 1 6] [5 4 3 1 7 2 6] [5 4 3 1 2 7 6] [5 4 3 2 7 1 6] [5 4 3 2 1 7 6] [5 4 2 7 1 3 6] [5 4 2 7 3 1 6] [5 4 2 1 7 3 6] [5 4 2 1 3 7 6] [5 4 2 3 7 1 6] [5 4 2 3 1 7 6] [5 3 7 1 4 2 6] [5 3 7 1 2 4 6] [5 3 7 4 1 2 6] [5 3 7 4 2 1 6] [5 3 7 2 1 4 6] [5 3 7 2 4 1 6] [5 3 1 7 4 2 6] [5 3 1 7 2 4 6] [5 3 1 4 7 2 6] [5 3 1 4 2 7 6] [5 3 1 2 7 4 6] [5 3 1 2 4 7 6] [5 3 4 7 1 2 6] [5 3 4 7 2 1 6] [5 3 4 1 7 2 6] [5 3 4 1 2 7 6] [5 3 4 2 7 1 6] [5 3 4 2 1 7 6] [5 3 2 7 1 4 6] [5 3 2 7 4 1 6] [5 3 2 1 7 4 6] [5 3 2 1 4 7 6] [5 3 2 4 7 1 6] [5 3 2 4 1 7 6] [5 2 7 1 4 3 6] [5 2 7 1 3 4 6] [5 2 7 4 1 3 6] [5 2 7 4 3 1 6] [5 2 7 3 1 4 6] [5 2 7 3 4 1 6] [5 2 1 7 4 3 6] [5 2 1 7 3 4 6] [5 2 1 4 7 3 6] [5 2 1 4 3 7 6] [5 2 1 3 7 4 6] [5 2 1 3 4 7 6] [5 2 4 7 1 3 6] [5 2 4 7 3 1 6] [5 2 4 1 7 3 6] [5 2 4 1 3 7 6] [5 2 4 3 7 1 6] [5 2 4 3 1 7 6] [5 2 3 7 1 4 6] [5 2 3 7 4 1 6] [5 2 3 1 7 4 6] [5 2 3 1 4 7 6] [5 2 3 4 7 1 6] [5 2 3 4 1 7 6] [6 7 1 4 3 2 5] [6 7 1 4 2 3 5] [6 7 1 3 4 2 5] [6 7 1 3 2 4 5] [6 7 1 2 4 3 5] [6 7 1 2 3 4 5] [6 7 4 1 3 2 5] [6 7 4 1 2 3 5] [6 7 4 3 1 2 5] [6 7 4 3 2 1 5] [6 7 4 2 1 3 5] [6 7 4 2 3 1 5] [6 7 3 1 4 2 5] [6 7 3 1 2 4 5] [6 7 3 4 1 2 5] [6 7 3 4 2 1 5] [6 7 3 2 1 4 5] [6 7 3 2 4 1 5] [6 7 2 1 4 3 5] [6 7 2 1 3 4 5] [6 7 2 4 1 3 5] [6 7 2 4 3 1 5] [6 7 2 3 1 4 5] [6 7 2 3 4 1 5] [6 1 7 4 3 2 5] [6 1 7 4 2 3 5] [6 1 7 3 4 2 5] [6 1 7 3 2 4 5] [6 1 7 2 4 3 5] [6 1 7 2 3 4 5] [6 1 4 7 3 2 5] [6 1 4 7 2 3 5] [6 1 4 3 7 2 5] [6 1 4 3 2 7 5] [6 1 4 3 5 7 2] [6 1 4 2 7 3 5] [6 1 4 2 3 7 5] [6 1 4 2 5 7 3] [6 1 4 5 7 2 3] [6 1 4 5 3 7 2] [6 1 4 5 2 7 3] [6 1 3 7 4 2 5] [6 1 3 7 2 4 5] [6 1 3 4 7 2 5] [6 1 3 4 2 7 5] [6 1 3 4 5 7 2] [6 1 3 2 7 4 5] [6 1 3 2 4 7 5] [6 1 3 2 5 7 4] [6 1 3 5 7 2 4] [6 1 3 5 4 7 2] [6 1 3 5 2 7 4] [6 1 2 7 4 3 5] [6 1 2 7 3 4 5] [6 1 2 4 7 3 5] [6 1 2 4 3 7 5] [6 1 2 4 5 7 3] [6 1 2 3 7 4 5] [6 1 2 3 4 7 5] [6 1 2 3 5 7 4] [6 1 2 5 7 3 4] [6 1 2 5 4 7 3] [6 1 2 5 3 7 4] [6 1 5 7 3 2 4] [6 1 5 7 2 3 4] [6 1 5 4 7 2 3] [6 1 5 4 3 7 2] [6 1 5 4 2 7 3] [6 1 5 3 7 2 4] [6 1 5 3 4 7 2] [6 1 5 3 2 7 4] [6 1 5 2 7 3 4] [6 1 5 2 4 7 3] [6 1 5 2 3 7 4] [6 4 7 1 3 2 5] [6 4 7 1 2 3 5] [6 4 7 3 1 2 5] [6 4 7 3 2 1 5] [6 4 7 2 1 3 5] [6 4 7 2 3 1 5] [6 4 1 7 3 2 5] [6 4 1 7 2 3 5] [6 4 1 3 7 2 5] [6 4 1 3 2 7 5] [6 4 1 3 5 7 2] [6 4 1 2 7 3 5] [6 4 1 2 3 7 5] [6 4 1 2 5 7 3] [6 4 1 5 7 2 3] [6 4 1 5 3 7 2] [6 4 1 5 2 7 3] [6 4 3 7 1 2 5] [6 4 3 7 2 1 5] [6 4 3 1 7 2 5] [6 4 3 1 2 7 5] [6 4 3 1 5 7 2] [6 4 3 2 7 1 5] [6 4 3 2 1 7 5] [6 4 3 2 5 7 1] [6 4 3 5 7 1 2] [6 4 3 5 1 7 2] [6 4 3 5 2 7 1] [6 4 2 7 1 3 5] [6 4 2 7 3 1 5] [6 4 2 1 7 3 5] [6 4 2 1 3 7 5] [6 4 2 1 5 7 3] [6 4 2 3 7 1 5] [6 4 2 3 1 7 5] [6 4 2 3 5 7 1] [6 4 2 5 7 1 3] [6 4 2 5 1 7 3] [6 4 2 5 3 7 1] [6 4 5 7 1 2 3] [6 4 5 7 2 1 3] [6 4 5 1 7 2 3] [6 4 5 1 3 7 2] [6 4 5 1 2 7 3] [6 4 5 3 7 1 2] [6 4 5 3 1 7 2] [6 4 5 3 2 7 1] [6 4 5 2 7 1 3] [6 4 5 2 1 7 3] [6 4 5 2 3 7 1] [6 3 7 1 4 2 5] [6 3 7 1 2 4 5] [6 3 7 4 1 2 5] [6 3 7 4 2 1 5] [6 3 7 2 1 4 5] [6 3 7 2 4 1 5] [6 3 1 7 4 2 5] [6 3 1 7 2 4 5] [6 3 1 4 7 2 5] [6 3 1 4 2 7 5] [6 3 1 4 5 7 2] [6 3 1 2 7 4 5] [6 3 1 2 4 7 5] [6 3 1 2 5 7 4] [6 3 1 5 7 2 4] [6 3 1 5 4 7 2] [6 3 1 5 2 7 4] [6 3 4 7 1 2 5] [6 3 4 7 2 1 5] [6 3 4 1 7 2 5] [6 3 4 1 2 7 5] [6 3 4 1 5 7 2] [6 3 4 2 7 1 5] [6 3 4 2 1 7 5] [6 3 4 2 5 7 1] [6 3 4 5 7 1 2] [6 3 4 5 1 7 2] [6 3 4 5 2 7 1] [6 3 2 7 1 4 5] [6 3 2 7 4 1 5] [6 3 2 1 7 4 5] [6 3 2 1 4 7 5] [6 3 2 1 5 7 4] [6 3 2 4 7 1 5] [6 3 2 4 1 7 5] [6 3 2 4 5 7 1] [6 3 2 5 7 1 4] [6 3 2 5 1 7 4] [6 3 2 5 4 7 1] [6 3 5 7 1 2 4] [6 3 5 7 2 1 4] [6 3 5 1 7 2 4] [6 3 5 1 4 7 2] [6 3 5 1 2 7 4] [6 3 5 4 7 1 2] [6 3 5 4 1 7 2] [6 3 5 4 2 7 1] [6 3 5 2 7 1 4] [6 3 5 2 1 7 4] [6 3 5 2 4 7 1] [6 2 7 1 4 3 5] [6 2 7 1 3 4 5] [6 2 7 4 1 3 5] [6 2 7 4 3 1 5] [6 2 7 3 1 4 5] [6 2 7 3 4 1 5] [6 2 1 7 4 3 5] [6 2 1 7 3 4 5] [6 2 1 4 7 3 5] [6 2 1 4 3 7 5] [6 2 1 4 5 7 3] [6 2 1 3 7 4 5] [6 2 1 3 4 7 5] [6 2 1 3 5 7 4] [6 2 1 5 7 3 4] [6 2 1 5 4 7 3] [6 2 1 5 3 7 4] [6 2 4 7 1 3 5] [6 2 4 7 3 1 5] [6 2 4 1 7 3 5] [6 2 4 1 3 7 5] [6 2 4 1 5 7 3] [6 2 4 3 7 1 5] [6 2 4 3 1 7 5] [6 2 4 3 5 7 1] [6 2 4 5 7 1 3] [6 2 4 5 1 7 3] [6 2 4 5 3 7 1] [6 2 3 7 1 4 5] [6 2 3 7 4 1 5] [6 2 3 1 7 4 5] [6 2 3 1 4 7 5] [6 2 3 1 5 7 4] [6 2 3 4 7 1 5] [6 2 3 4 1 7 5] [6 2 3 4 5 7 1] [6 2 3 5 7 1 4] [6 2 3 5 1 7 4] [6 2 3 5 4 7 1] [6 2 5 7 1 3 4] [6 2 5 7 3 1 4] [6 2 5 1 7 3 4] [6 2 5 1 4 7 3] [6 2 5 1 3 7 4] [6 2 5 4 7 1 3] [6 2 5 4 1 7 3] [6 2 5 4 3 7 1] [6 2 5 3 7 1 4] [6 2 5 3 1 7 4] [6 2 5 3 4 7 1] [6 5 7 1 3 2 4] [6 5 7 1 2 3 4] [6 5 7 3 1 2 4] [6 5 7 3 2 1 4] [6 5 7 2 1 3 4] [6 5 7 2 3 1 4] [6 5 1 7 3 2 4] [6 5 1 7 2 3 4] [6 5 1 4 7 2 3] [6 5 1 4 3 7 2] [6 5 1 4 2 7 3] [6 5 1 3 7 2 4] [6 5 1 3 4 7 2] [6 5 1 3 2 7 4] [6 5 1 2 7 3 4] [6 5 1 2 4 7 3] [6 5 1 2 3 7 4] [6 5 4 7 1 2 3] [6 5 4 7 2 1 3] [6 5 4 1 7 2 3] [6 5 4 1 3 7 2] [6 5 4 1 2 7 3] [6 5 4 3 7 1 2] [6 5 4 3 1 7 2] [6 5 4 3 2 7 1] [6 5 4 2 7 1 3] [6 5 4 2 1 7 3] [6 5 4 2 3 7 1] [6 5 3 7 1 2 4] [6 5 3 7 2 1 4] [6 5 3 1 7 2 4] [6 5 3 1 4 7 2] [6 5 3 1 2 7 4] [6 5 3 4 7 1 2] [6 5 3 4 1 7 2] [6 5 3 4 2 7 1] [6 5 3 2 7 1 4] [6 5 3 2 1 7 4] [6 5 3 2 4 7 1] [6 5 2 7 1 3 4] [6 5 2 7 3 1 4] [6 5 2 1 7 3 4] [6 5 2 1 4 7 3] [6 5 2 1 3 7 4] [6 5 2 4 7 1 3] [6 5 2 4 1 7 3] [6 5 2 4 3 7 1] [6 5 2 3 7 1 4] [6 5 2 3 1 7 4] [6 5 2 3 4 7 1]], [2 3] [[1 7 4 6 3 2 5] [1 7 4 6 2 3 5] [1 7 4 3 6 2 5] [1 7 4 3 2 6 5] [1 7 4 3 5 6 2] [1 7 4 2 6 3 5] [1 7 4 2 3 6 5] [1 7 4 2 5 6 3] [1 7 4 5 6 2 3] [1 7 4 5 3 6 2] [1 7 4 5 2 6 3] [1 7 6 4 3 2 5] [1 7 6 4 2 3 5] [1 7 6 3 4 2 5] [1 7 6 3 2 4 5] [1 7 6 2 4 3 5] [1 7 6 2 3 4 5] [1 7 3 4 6 2 5] [1 7 3 4 2 6 5] [1 7 3 4 5 6 2] [1 7 3 6 4 2 5] [1 7 3 6 2 4 5] [1 7 3 2 4 6 5] [1 7 3 2 6 4 5] [1 7 3 2 5 6 4] [1 7 3 5 4 6 2] [1 7 3 5 6 2 4] [1 7 3 5 2 6 4] [1 7 2 4 6 3 5] [1 7 2 4 3 6 5] [1 7 2 4 5 6 3] [1 7 2 6 4 3 5] [1 7 2 6 3 4 5] [1 7 2 3 4 6 5] [1 7 2 3 6 4 5] [1 7 2 3 5 6 4] [1 7 2 5 4 6 3] [1 7 2 5 6 3 4] [1 7 2 5 3 6 4] [1 7 5 4 6 2 3] [1 7 5 4 3 6 2] [1 7 5 4 2 6 3] [1 7 5 6 3 2 4] [1 7 5 6 2 3 4] [1 7 5 3 4 6 2] [1 7 5 3 6 2 4] [1 7 5 3 2 6 4] [1 7 5 2 4 6 3] [1 7 5 2 6 3 4] [1 7 5 2 3 6 4] [2 7 1 4 6 3 5] [2 7 1 4 3 6 5] [2 7 1 4 5 6 3] [2 7 1 6 4 3 5] [2 7 1 6 3 4 5] [2 7 1 3 4 6 5] [2 7 1 3 6 4 5] [2 7 1 3 5 6 4] [2 7 1 5 4 6 3] [2 7 1 5 6 3 4] [2 7 1 5 3 6 4] [2 7 4 1 6 3 5] [2 7 4 1 3 6 5] [2 7 4 1 5 6 3] [2 7 4 6 1 3 5] [2 7 4 6 3 1 5] [2 7 4 3 1 6 5] [2 7 4 3 6 1 5] [2 7 4 3 5 6 1] [2 7 4 5 1 6 3] [2 7 4 5 6 1 3] [2 7 4 5 3 6 1] [2 7 6 1 4 3 5] [2 7 6 1 3 4 5] [2 7 6 4 1 3 5] [2 7 6 4 3 1 5] [2 7 6 3 1 4 5] [2 7 6 3 4 1 5] [2 7 3 1 4 6 5] [2 7 3 1 6 4 5] [2 7 3 1 5 6 4] [2 7 3 4 1 6 5] [2 7 3 4 6 1 5] [2 7 3 4 5 6 1] [2 7 3 6 1 4 5] [2 7 3 6 4 1 5] [2 7 3 5 1 6 4] [2 7 3 5 4 6 1] [2 7 3 5 6 1 4] [2 7 5 1 4 6 3] [2 7 5 1 6 3 4] [2 7 5 1 3 6 4] [2 7 5 4 1 6 3] [2 7 5 4 6 1 3] [2 7 5 4 3 6 1] [2 7 5 6 1 3 4] [2 7 5 6 3 1 4] [2 7 5 3 1 6 4] [2 7 5 3 4 6 1] [2 7 5 3 6 1 4] [2 1 7 4 6 3 5] [2 1 7 4 3 6 5] [2 1 7 4 5 6 3] [2 1 7 6 4 3 5] [2 1 7 6 3 4 5] [2 1 7 3 4 6 5] [2 1 7 3 6 4 5] [2 1 7 3 5 6 4] [2 1 7 5 4 6 3] [2 1 7 5 6 3 4] [2 1 7 5 3 6 4] [3 7 1 4 6 2 5] [3 7 1 4 2 6 5] [3 7 1 4 5 6 2] [3 7 1 6 4 2 5] [3 7 1 6 2 4 5] [3 7 1 2 4 6 5] [3 7 1 2 6 4 5] [3 7 1 2 5 6 4] [3 7 1 5 4 6 2] [3 7 1 5 6 2 4] [3 7 1 5 2 6 4] [3 7 4 1 6 2 5] [3 7 4 1 2 6 5] [3 7 4 1 5 6 2] [3 7 4 6 1 2 5] [3 7 4 6 2 1 5] [3 7 4 2 1 6 5] [3 7 4 2 6 1 5] [3 7 4 2 5 6 1] [3 7 4 5 1 6 2] [3 7 4 5 6 1 2] [3 7 4 5 2 6 1] [3 7 6 1 4 2 5] [3 7 6 1 2 4 5] [3 7 6 4 1 2 5] [3 7 6 4 2 1 5] [3 7 6 2 1 4 5] [3 7 6 2 4 1 5] [3 7 2 1 4 6 5] [3 7 2 1 6 4 5] [3 7 2 1 5 6 4] [3 7 2 4 1 6 5] [3 7 2 4 6 1 5] [3 7 2 4 5 6 1] [3 7 2 6 1 4 5] [3 7 2 6 4 1 5] [3 7 2 5 1 6 4] [3 7 2 5 4 6 1] [3 7 2 5 6 1 4] [3 7 5 1 4 6 2] [3 7 5 1 6 2 4] [3 7 5 1 2 6 4] [3 7 5 4 1 6 2] [3 7 5 4 6 1 2] [3 7 5 4 2 6 1] [3 7 5 6 1 2 4] [3 7 5 6 2 1 4] [3 7 5 2 1 6 4] [3 7 5 2 4 6 1] [3 7 5 2 6 1 4] [3 1 7 4 6 2 5] [3 1 7 4 2 6 5] [3 1 7 4 5 6 2] [3 1 7 6 4 2 5] [3 1 7 6 2 4 5] [3 1 7 2 4 6 5] [3 1 7 2 6 4 5] [3 1 7 2 5 6 4] [3 1 7 5 4 6 2] [3 1 7 5 6 2 4] [3 1 7 5 2 6 4] [3 1 2 7 4 6 5] [3 1 2 7 6 4 5] [3 1 2 7 5 6 4] [3 2 7 1 4 6 5] [3 2 7 1 6 4 5] [3 2 7 1 5 6 4] [3 2 7 4 1 6 5] [3 2 7 4 6 1 5] [3 2 7 4 5 6 1] [3 2 7 6 1 4 5] [3 2 7 6 4 1 5] [3 2 7 5 1 6 4] [3 2 7 5 4 6 1] [3 2 7 5 6 1 4] [3 2 1 7 4 6 5] [3 2 1 7 6 4 5] [3 2 1 7 5 6 4] [4 7 1 6 3 2 5] [4 7 1 6 2 3 5] [4 7 1 3 6 2 5] [4 7 1 3 2 6 5] [4 7 1 3 5 6 2] [4 7 1 2 6 3 5] [4 7 1 2 3 6 5] [4 7 1 2 5 6 3] [4 7 1 5 6 2 3] [4 7 1 5 3 6 2] [4 7 1 5 2 6 3] [4 7 6 1 3 2 5] [4 7 6 1 2 3 5] [4 7 6 3 1 2 5] [4 7 6 3 2 1 5] [4 7 6 2 1 3 5] [4 7 6 2 3 1 5] [4 7 3 1 6 2 5] [4 7 3 1 2 6 5] [4 7 3 1 5 6 2] [4 7 3 6 1 2 5] [4 7 3 6 2 1 5] [4 7 3 2 1 6 5] [4 7 3 2 6 1 5] [4 7 3 2 5 6 1] [4 7 3 5 1 6 2] [4 7 3 5 6 1 2] [4 7 3 5 2 6 1] [4 7 2 1 6 3 5] [4 7 2 1 3 6 5] [4 7 2 1 5 6 3] [4 7 2 6 1 3 5] [4 7 2 6 3 1 5] [4 7 2 3 1 6 5] [4 7 2 3 6 1 5] [4 7 2 3 5 6 1] [4 7 2 5 1 6 3] [4 7 2 5 6 1 3] [4 7 2 5 3 6 1] [4 7 5 1 6 2 3] [4 7 5 1 3 6 2] [4 7 5 1 2 6 3] [4 7 5 6 1 2 3] [4 7 5 6 2 1 3] [4 7 5 3 1 6 2] [4 7 5 3 6 1 2] [4 7 5 3 2 6 1] [4 7 5 2 1 6 3] [4 7 5 2 6 1 3] [4 7 5 2 3 6 1] [4 1 7 6 3 2 5] [4 1 7 6 2 3 5] [4 1 7 3 6 2 5] [4 1 7 3 2 6 5] [4 1 7 3 5 6 2] [4 1 7 2 6 3 5] [4 1 7 2 3 6 5] [4 1 7 2 5 6 3] [4 1 7 5 6 2 3] [4 1 7 5 3 6 2] [4 1 7 5 2 6 3] [4 1 3 7 6 2 5] [4 1 3 7 2 6 5] [4 1 3 7 5 6 2] [4 1 3 2 7 6 5] [4 1 2 7 6 3 5] [4 1 2 7 3 6 5] [4 1 2 7 5 6 3] [4 1 2 3 7 6 5] [4 3 7 1 6 2 5] [4 3 7 1 2 6 5] [4 3 7 1 5 6 2] [4 3 7 6 1 2 5] [4 3 7 6 2 1 5] [4 3 7 2 1 6 5] [4 3 7 2 6 1 5] [4 3 7 2 5 6 1] [4 3 7 5 1 6 2] [4 3 7 5 6 1 2] [4 3 7 5 2 6 1] [4 3 1 7 6 2 5] [4 3 1 7 2 6 5] [4 3 1 7 5 6 2] [4 3 1 2 7 6 5] [4 3 2 7 1 6 5] [4 3 2 7 6 1 5] [4 3 2 7 5 6 1] [4 3 2 1 7 6 5] [4 2 7 1 6 3 5] [4 2 7 1 3 6 5] [4 2 7 1 5 6 3] [4 2 7 6 1 3 5] [4 2 7 6 3 1 5] [4 2 7 3 1 6 5] [4 2 7 3 6 1 5] [4 2 7 3 5 6 1] [4 2 7 5 1 6 3] [4 2 7 5 6 1 3] [4 2 7 5 3 6 1] [4 2 1 7 6 3 5] [4 2 1 7 3 6 5] [4 2 1 7 5 6 3] [4 2 1 3 7 6 5] [4 2 3 7 1 6 5] [4 2 3 7 6 1 5] [4 2 3 7 5 6 1] [4 2 3 1 7 6 5] [5 7 1 4 6 2 3] [5 7 1 4 3 6 2] [5 7 1 4 2 6 3] [5 7 1 6 3 2 4] [5 7 1 6 2 3 4] [5 7 1 3 4 6 2] [5 7 1 3 6 2 4] [5 7 1 3 2 6 4] [5 7 1 2 4 6 3] [5 7 1 2 6 3 4] [5 7 1 2 3 6 4] [5 7 4 1 6 2 3] [5 7 4 1 3 6 2] [5 7 4 1 2 6 3] [5 7 4 6 1 2 3] [5 7 4 6 2 1 3] [5 7 4 3 1 6 2] [5 7 4 3 6 1 2] [5 7 4 3 2 6 1] [5 7 4 2 1 6 3] [5 7 4 2 6 1 3] [5 7 4 2 3 6 1] [5 7 6 1 3 2 4] [5 7 6 1 2 3 4] [5 7 6 3 1 2 4] [5 7 6 3 2 1 4] [5 7 6 2 1 3 4] [5 7 6 2 3 1 4] [5 7 3 1 4 6 2] [5 7 3 1 6 2 4] [5 7 3 1 2 6 4] [5 7 3 4 1 6 2] [5 7 3 4 6 1 2] [5 7 3 4 2 6 1] [5 7 3 6 1 2 4] [5 7 3 6 2 1 4] [5 7 3 2 1 6 4] [5 7 3 2 4 6 1] [5 7 3 2 6 1 4] [5 7 2 1 4 6 3] [5 7 2 1 6 3 4] [5 7 2 1 3 6 4] [5 7 2 4 1 6 3] [5 7 2 4 6 1 3] [5 7 2 4 3 6 1] [5 7 2 6 1 3 4] [5 7 2 6 3 1 4] [5 7 2 3 1 6 4] [5 7 2 3 4 6 1] [5 7 2 3 6 1 4] [5 1 7 4 6 2 3] [5 1 7 4 3 6 2] [5 1 7 4 2 6 3] [5 1 7 6 3 2 4] [5 1 7 6 2 3 4] [5 1 7 3 4 6 2] [5 1 7 3 6 2 4] [5 1 7 3 2 6 4] [5 1 7 2 4 6 3] [5 1 7 2 6 3 4] [5 1 7 2 3 6 4] [5 1 4 7 6 2 3] [5 1 4 7 3 6 2] [5 1 4 7 2 6 3] [5 1 4 3 7 6 2] [5 1 4 2 7 6 3] [5 1 3 7 4 6 2] [5 1 3 7 6 2 4] [5 1 3 7 2 6 4] [5 1 3 4 7 6 2] [5 1 3 2 7 6 4] [5 1 2 7 4 6 3] [5 1 2 7 6 3 4] [5 1 2 7 3 6 4] [5 1 2 4 7 6 3] [5 1 2 3 7 6 4] [5 4 7 1 6 2 3] [5 4 7 1 3 6 2] [5 4 7 1 2 6 3] [5 4 7 6 1 2 3] [5 4 7 6 2 1 3] [5 4 7 3 1 6 2] [5 4 7 3 6 1 2] [5 4 7 3 2 6 1] [5 4 7 2 1 6 3] [5 4 7 2 6 1 3] [5 4 7 2 3 6 1] [5 4 1 7 6 2 3] [5 4 1 7 3 6 2] [5 4 1 7 2 6 3] [5 4 1 3 7 6 2] [5 4 1 2 7 6 3] [5 4 3 7 1 6 2] [5 4 3 7 6 1 2] [5 4 3 7 2 6 1] [5 4 3 1 7 6 2] [5 4 3 2 7 6 1] [5 4 2 7 1 6 3] [5 4 2 7 6 1 3] [5 4 2 7 3 6 1] [5 4 2 1 7 6 3] [5 4 2 3 7 6 1] [5 3 7 1 4 6 2] [5 3 7 1 6 2 4] [5 3 7 1 2 6 4] [5 3 7 4 1 6 2] [5 3 7 4 6 1 2] [5 3 7 4 2 6 1] [5 3 7 6 1 2 4] [5 3 7 6 2 1 4] [5 3 7 2 1 6 4] [5 3 7 2 4 6 1] [5 3 7 2 6 1 4] [5 3 1 7 4 6 2] [5 3 1 7 6 2 4] [5 3 1 7 2 6 4] [5 3 1 4 7 6 2] [5 3 1 2 7 6 4] [5 3 4 7 1 6 2] [5 3 4 7 6 1 2] [5 3 4 7 2 6 1] [5 3 4 1 7 6 2] [5 3 4 2 7 6 1] [5 3 2 7 1 6 4] [5 3 2 7 4 6 1] [5 3 2 7 6 1 4] [5 3 2 1 7 6 4] [5 3 2 4 7 6 1] [5 2 7 1 4 6 3] [5 2 7 1 6 3 4] [5 2 7 1 3 6 4] [5 2 7 4 1 6 3] [5 2 7 4 6 1 3] [5 2 7 4 3 6 1] [5 2 7 6 1 3 4] [5 2 7 6 3 1 4] [5 2 7 3 1 6 4] [5 2 7 3 4 6 1] [5 2 7 3 6 1 4] [5 2 1 7 4 6 3] [5 2 1 7 6 3 4] [5 2 1 7 3 6 4] [5 2 1 4 7 6 3] [5 2 1 3 7 6 4] [5 2 4 7 1 6 3] [5 2 4 7 6 1 3] [5 2 4 7 3 6 1] [5 2 4 1 7 6 3] [5 2 4 3 7 6 1] [5 2 3 7 1 6 4] [5 2 3 7 4 6 1] [5 2 3 7 6 1 4] [5 2 3 1 7 6 4] [5 2 3 4 7 6 1] [6 7 1 4 3 5 2] [6 7 1 4 2 5 3] [6 7 1 4 5 2 3] [6 7 1 3 4 5 2] [6 7 1 3 2 5 4] [6 7 1 3 5 2 4] [6 7 1 2 4 5 3] [6 7 1 2 3 5 4] [6 7 1 2 5 3 4] [6 7 1 5 3 2 4] [6 7 1 5 2 3 4] [6 7 4 1 3 5 2] [6 7 4 1 2 5 3] [6 7 4 1 5 2 3] [6 7 4 3 1 5 2] [6 7 4 3 2 5 1] [6 7 4 3 5 1 2] [6 7 4 2 1 5 3] [6 7 4 2 3 5 1] [6 7 4 2 5 1 3] [6 7 4 5 1 2 3] [6 7 4 5 2 1 3] [6 7 3 1 4 5 2] [6 7 3 1 2 5 4] [6 7 3 1 5 2 4] [6 7 3 4 1 5 2] [6 7 3 4 2 5 1] [6 7 3 4 5 1 2] [6 7 3 2 1 5 4] [6 7 3 2 4 5 1] [6 7 3 2 5 1 4] [6 7 3 5 1 2 4] [6 7 3 5 2 1 4] [6 7 2 1 4 5 3] [6 7 2 1 3 5 4] [6 7 2 1 5 3 4] [6 7 2 4 1 5 3] [6 7 2 4 3 5 1] [6 7 2 4 5 1 3] [6 7 2 3 1 5 4] [6 7 2 3 4 5 1] [6 7 2 3 5 1 4] [6 7 2 5 1 3 4] [6 7 2 5 3 1 4] [6 7 5 1 3 2 4] [6 7 5 1 2 3 4] [6 7 5 3 1 2 4] [6 7 5 3 2 1 4] [6 7 5 2 1 3 4] [6 7 5 2 3 1 4] [6 1 7 4 3 5 2] [6 1 7 4 2 5 3] [6 1 7 4 5 2 3] [6 1 7 3 4 5 2] [6 1 7 3 2 5 4] [6 1 7 3 5 2 4] [6 1 7 2 4 5 3] [6 1 7 2 3 5 4] [6 1 7 2 5 3 4] [6 1 7 5 3 2 4] [6 1 7 5 2 3 4] [6 1 4 7 3 5 2] [6 1 4 7 2 5 3] [6 1 4 7 5 2 3] [6 1 4 3 7 5 2] [6 1 4 2 7 5 3] [6 1 4 5 7 3 2] [6 1 3 7 4 5 2] [6 1 3 7 2 5 4] [6 1 3 7 5 2 4] [6 1 3 4 7 5 2] [6 1 3 2 7 5 4] [6 1 3 5 7 4 2] [6 1 2 7 4 5 3] [6 1 2 7 3 5 4] [6 1 2 7 5 3 4] [6 1 2 4 7 5 3] [6 1 2 3 7 5 4] [6 1 2 5 7 4 3] [6 1 5 7 4 2 3] [6 1 5 7 3 4 2] [6 1 5 7 2 4 3] [6 1 5 4 7 3 2] [6 1 5 3 7 4 2] [6 1 5 2 7 4 3] [6 4 7 1 3 5 2] [6 4 7 1 2 5 3] [6 4 7 1 5 2 3] [6 4 7 3 1 5 2] [6 4 7 3 2 5 1] [6 4 7 3 5 1 2] [6 4 7 2 1 5 3] [6 4 7 2 3 5 1] [6 4 7 2 5 1 3] [6 4 7 5 1 2 3] [6 4 7 5 2 1 3] [6 4 1 7 3 5 2] [6 4 1 7 2 5 3] [6 4 1 7 5 2 3] [6 4 1 3 7 5 2] [6 4 1 2 7 5 3] [6 4 1 5 7 3 2] [6 4 3 7 1 5 2] [6 4 3 7 2 5 1] [6 4 3 7 5 1 2] [6 4 3 1 7 5 2] [6 4 3 2 7 5 1] [6 4 3 5 7 2 1] [6 4 2 7 1 5 3] [6 4 2 7 3 5 1] [6 4 2 7 5 1 3] [6 4 2 1 7 5 3] [6 4 2 3 7 5 1] [6 4 2 5 7 3 1] [6 4 5 7 1 3 2] [6 4 5 7 3 1 2] [6 4 5 7 2 3 1] [6 4 5 1 7 3 2] [6 4 5 3 7 2 1] [6 4 5 2 7 3 1] [6 3 7 1 4 5 2] [6 3 7 1 2 5 4] [6 3 7 1 5 2 4] [6 3 7 4 1 5 2] [6 3 7 4 2 5 1] [6 3 7 4 5 1 2] [6 3 7 2 1 5 4] [6 3 7 2 4 5 1] [6 3 7 2 5 1 4] [6 3 7 5 1 2 4] [6 3 7 5 2 1 4] [6 3 1 7 4 5 2] [6 3 1 7 2 5 4] [6 3 1 7 5 2 4] [6 3 1 4 7 5 2] [6 3 1 2 7 5 4] [6 3 1 5 7 4 2] [6 3 4 7 1 5 2] [6 3 4 7 2 5 1] [6 3 4 7 5 1 2] [6 3 4 1 7 5 2] [6 3 4 2 7 5 1] [6 3 4 5 7 2 1] [6 3 2 7 1 5 4] [6 3 2 7 4 5 1] [6 3 2 7 5 1 4] [6 3 2 1 7 5 4] [6 3 2 4 7 5 1] [6 3 2 5 7 4 1] [6 3 5 7 1 4 2] [6 3 5 7 4 1 2] [6 3 5 7 2 4 1] [6 3 5 1 7 4 2] [6 3 5 4 7 2 1] [6 3 5 2 7 4 1] [6 2 7 1 4 5 3] [6 2 7 1 3 5 4] [6 2 7 1 5 3 4] [6 2 7 4 1 5 3] [6 2 7 4 3 5 1] [6 2 7 4 5 1 3] [6 2 7 3 1 5 4] [6 2 7 3 4 5 1] [6 2 7 3 5 1 4] [6 2 7 5 1 3 4] [6 2 7 5 3 1 4] [6 2 1 7 4 5 3] [6 2 1 7 3 5 4] [6 2 1 7 5 3 4] [6 2 1 4 7 5 3] [6 2 1 3 7 5 4] [6 2 1 5 7 4 3] [6 2 4 7 1 5 3] [6 2 4 7 3 5 1] [6 2 4 7 5 1 3] [6 2 4 1 7 5 3] [6 2 4 3 7 5 1] [6 2 4 5 7 3 1] [6 2 3 7 1 5 4] [6 2 3 7 4 5 1] [6 2 3 7 5 1 4] [6 2 3 1 7 5 4] [6 2 3 4 7 5 1] [6 2 3 5 7 4 1] [6 2 5 7 1 4 3] [6 2 5 7 4 1 3] [6 2 5 7 3 4 1] [6 2 5 1 7 4 3] [6 2 5 4 7 3 1] [6 2 5 3 7 4 1] [6 5 7 1 4 2 3] [6 5 7 1 3 4 2] [6 5 7 1 2 4 3] [6 5 7 4 1 2 3] [6 5 7 4 2 1 3] [6 5 7 3 1 4 2] [6 5 7 3 4 1 2] [6 5 7 3 2 4 1] [6 5 7 2 1 4 3] [6 5 7 2 4 1 3] [6 5 7 2 3 4 1] [6 5 1 7 4 2 3] [6 5 1 7 3 4 2] [6 5 1 7 2 4 3] [6 5 1 4 7 3 2] [6 5 1 3 7 4 2] [6 5 1 2 7 4 3] [6 5 4 7 1 3 2] [6 5 4 7 3 1 2] [6 5 4 7 2 3 1] [6 5 4 1 7 3 2] [6 5 4 3 7 2 1] [6 5 4 2 7 3 1] [6 5 3 7 1 4 2] [6 5 3 7 4 1 2] [6 5 3 7 2 4 1] [6 5 3 1 7 4 2] [6 5 3 4 7 2 1] [6 5 3 2 7 4 1] [6 5 2 7 1 4 3] [6 5 2 7 4 1 3] [6 5 2 7 3 4 1] [6 5 2 1 7 4 3] [6 5 2 4 7 3 1] [6 5 2 3 7 4 1]], [2 5] [[1 7 4 6 5 3 2] [1 7 6 4 5 3 2] [1 7 6 3 5 4 2] [1 7 6 2 5 4 3] [1 7 6 5 4 2 3] [1 7 6 5 3 4 2] [1 7 6 5 2 4 3] [1 7 3 6 5 4 2] [1 7 2 6 5 4 3] [1 7 5 6 4 3 2] [2 7 1 6 5 4 3] [2 7 4 6 5 3 1] [2 7 6 1 5 4 3] [2 7 6 4 5 3 1] [2 7 6 3 5 4 1] [2 7 6 5 1 4 3] [2 7 6 5 4 1 3] [2 7 6 5 3 4 1] [2 7 3 6 5 4 1] [2 7 5 6 4 3 1] [2 1 7 6 5 4 3] [3 7 1 6 5 4 2] [3 7 4 6 5 2 1] [3 7 6 1 5 4 2] [3 7 6 4 5 2 1] [3 7 6 2 5 4 1] [3 7 6 5 1 4 2] [3 7 6 5 4 1 2] [3 7 6 5 2 4 1] [3 7 2 6 5 4 1] [3 7 5 6 4 2 1] [3 1 7 6 5 4 2] [3 2 7 6 5 4 1] [4 7 1 6 5 3 2] [4 7 6 1 5 3 2] [4 7 6 3 5 2 1] [4 7 6 2 5 3 1] [4 7 6 5 1 3 2] [4 7 6 5 3 1 2] [4 7 6 5 2 3 1] [4 7 3 6 5 2 1] [4 7 2 6 5 3 1] [4 7 5 6 3 2 1] [4 1 7 6 5 3 2] [4 3 7 6 5 2 1] [4 2 7 6 5 3 1] [5 7 1 6 4 3 2] [5 7 4 6 3 2 1] [5 7 6 1 4 3 2] [5 7 6 4 1 3 2] [5 7 6 4 3 1 2] [5 7 6 4 2 3 1] [5 7 6 3 4 2 1] [5 7 6 2 4 3 1] [5 7 3 6 4 2 1] [5 7 2 6 4 3 1] [5 1 7 6 4 3 2] [5 4 7 6 3 2 1] [5 3 7 6 4 2 1] [5 2 7 6 4 3 1] [6 7 1 5 4 3 2] [6 7 4 5 3 2 1] [6 7 3 5 4 2 1] [6 7 2 5 4 3 1] [6 7 5 1 4 3 2] [6 7 5 4 1 3 2] [6 7 5 4 3 1 2] [6 7 5 4 2 3 1] [6 7 5 3 4 2 1] [6 7 5 2 4 3 1] [6 1 7 5 4 3 2] [6 4 7 5 3 2 1] [6 3 7 5 4 2 1] [6 2 7 5 4 3 1] [6 5 7 4 3 2 1]], [3 3] [[1 4 7 6 3 2 5] [1 4 7 6 2 3 5] [1 4 7 3 6 2 5] [1 4 7 3 2 6 5] [1 4 7 3 5 6 2] [1 4 7 2 6 3 5] [1 4 7 2 3 6 5] [1 4 7 2 5 6 3] [1 4 7 5 6 2 3] [1 4 7 5 3 6 2] [1 4 7 5 2 6 3] [1 4 3 7 6 2 5] [1 4 3 7 2 6 5] [1 4 3 7 5 6 2] [1 4 3 2 7 6 5] [1 4 2 7 6 3 5] [1 4 2 7 3 6 5] [1 4 2 7 5 6 3] [1 4 2 3 7 6 5] [1 6 7 4 3 5 2] [1 6 7 4 2 5 3] [1 6 7 4 5 2 3] [1 6 7 3 4 5 2] [1 6 7 3 2 5 4] [1 6 7 3 5 2 4] [1 6 7 2 4 5 3] [1 6 7 2 3 5 4] [1 6 7 2 5 3 4] [1 6 7 5 3 2 4] [1 6 7 5 2 3 4] [1 6 4 7 3 5 2] [1 6 4 7 2 5 3] [1 6 4 7 5 2 3] [1 6 4 3 7 5 2] [1 6 4 2 7 5 3] [1 6 4 5 7 3 2] [1 6 3 7 4 5 2] [1 6 3 7 2 5 4] [1 6 3 7 5 2 4] [1 6 3 4 7 5 2] [1 6 3 2 7 5 4] [1 6 3 5 7 4 2] [1 6 2 7 4 5 3] [1 6 2 7 3 5 4] [1 6 2 7 5 3 4] [1 6 2 4 7 5 3] [1 6 2 3 7 5 4] [1 6 2 5 7 4 3] [1 6 5 7 4 2 3] [1 6 5 7 3 4 2] [1 6 5 7 2 4 3] [1 6 5 4 7 3 2] [1 6 5 3 7 4 2] [1 6 5 2 7 4 3] [1 3 7 4 6 2 5] [1 3 7 4 2 6 5] [1 3 7 4 5 6 2] [1 3 7 6 4 2 5] [1 3 7 6 2 4 5] [1 3 7 2 4 6 5] [1 3 7 2 6 4 5] [1 3 7 2 5 6 4] [1 3 7 5 4 6 2] [1 3 7 5 6 2 4] [1 3 7 5 2 6 4] [1 3 2 7 4 6 5] [1 3 2 7 6 4 5] [1 3 2 7 5 6 4] [1 2 7 4 6 3 5] [1 2 7 4 3 6 5] [1 2 7 4 5 6 3] [1 2 7 6 4 3 5] [1 2 7 6 3 4 5] [1 2 7 3 4 6 5] [1 2 7 3 6 4 5] [1 2 7 3 5 6 4] [1 2 7 5 4 6 3] [1 2 7 5 6 3 4] [1 2 7 5 3 6 4] [1 5 7 4 6 2 3] [1 5 7 4 3 6 2] [1 5 7 4 2 6 3] [1 5 7 6 3 2 4] [1 5 7 6 2 3 4] [1 5 7 3 4 6 2] [1 5 7 3 6 2 4] [1 5 7 3 2 6 4] [1 5 7 2 4 6 3] [1 5 7 2 6 3 4] [1 5 7 2 3 6 4] [1 5 4 7 6 2 3] [1 5 4 7 3 6 2] [1 5 4 7 2 6 3] [1 5 4 3 7 6 2] [1 5 4 2 7 6 3] [1 5 3 7 4 6 2] [1 5 3 7 6 2 4] [1 5 3 7 2 6 4] [1 5 3 4 7 6 2] [1 5 3 2 7 6 4] [1 5 2 7 4 6 3] [1 5 2 7 6 3 4] [1 5 2 7 3 6 4] [1 5 2 4 7 6 3] [1 5 2 3 7 6 4] [2 1 4 7 6 3 5] [2 1 4 7 3 6 5] [2 1 4 7 5 6 3] [2 1 4 3 7 6 5] [2 1 6 7 4 5 3] [2 1 6 7 3 5 4] [2 1 6 7 5 3 4] [2 1 6 4 7 5 3] [2 1 6 3 7 5 4] [2 1 6 5 7 4 3] [2 1 3 7 4 6 5] [2 1 3 7 6 4 5] [2 1 3 7 5 6 4] [2 1 5 7 4 6 3] [2 1 5 7 6 3 4] [2 1 5 7 3 6 4] [2 1 5 4 7 6 3] [2 1 5 3 7 6 4] [2 4 7 1 6 3 5] [2 4 7 1 3 6 5] [2 4 7 1 5 6 3] [2 4 7 6 1 3 5] [2 4 7 6 3 1 5] [2 4 7 3 1 6 5] [2 4 7 3 6 1 5] [2 4 7 3 5 6 1] [2 4 7 5 1 6 3] [2 4 7 5 6 1 3] [2 4 7 5 3 6 1] [2 4 1 7 6 3 5] [2 4 1 7 3 6 5] [2 4 1 7 5 6 3] [2 4 1 3 7 6 5] [2 4 3 7 1 6 5] [2 4 3 7 6 1 5] [2 4 3 7 5 6 1] [2 4 3 1 7 6 5] [2 6 7 1 4 5 3] [2 6 7 1 3 5 4] [2 6 7 1 5 3 4] [2 6 7 4 1 5 3] [2 6 7 4 3 5 1] [2 6 7 4 5 1 3] [2 6 7 3 1 5 4] [2 6 7 3 4 5 1] [2 6 7 3 5 1 4] [2 6 7 5 1 3 4] [2 6 7 5 3 1 4] [2 6 1 7 4 5 3] [2 6 1 7 3 5 4] [2 6 1 7 5 3 4] [2 6 1 4 7 5 3] [2 6 1 3 7 5 4] [2 6 1 5 7 4 3] [2 6 4 7 1 5 3] [2 6 4 7 3 5 1] [2 6 4 7 5 1 3] [2 6 4 1 7 5 3] [2 6 4 3 7 5 1] [2 6 4 5 7 3 1] [2 6 3 7 1 5 4] [2 6 3 7 4 5 1] [2 6 3 7 5 1 4] [2 6 3 1 7 5 4] [2 6 3 4 7 5 1] [2 6 3 5 7 4 1] [2 6 5 7 1 4 3] [2 6 5 7 4 1 3] [2 6 5 7 3 4 1] [2 6 5 1 7 4 3] [2 6 5 4 7 3 1] [2 6 5 3 7 4 1] [2 3 7 1 4 6 5] [2 3 7 1 6 4 5] [2 3 7 1 5 6 4] [2 3 7 4 1 6 5] [2 3 7 4 6 1 5] [2 3 7 4 5 6 1] [2 3 7 6 1 4 5] [2 3 7 6 4 1 5] [2 3 7 5 1 6 4] [2 3 7 5 4 6 1] [2 3 7 5 6 1 4] [2 3 1 7 4 6 5] [2 3 1 7 6 4 5] [2 3 1 7 5 6 4] [2 5 7 1 4 6 3] [2 5 7 1 6 3 4] [2 5 7 1 3 6 4] [2 5 7 4 1 6 3] [2 5 7 4 6 1 3] [2 5 7 4 3 6 1] [2 5 7 6 1 3 4] [2 5 7 6 3 1 4] [2 5 7 3 1 6 4] [2 5 7 3 4 6 1] [2 5 7 3 6 1 4] [2 5 1 7 4 6 3] [2 5 1 7 6 3 4] [2 5 1 7 3 6 4] [2 5 1 4 7 6 3] [2 5 1 3 7 6 4] [2 5 4 7 1 6 3] [2 5 4 7 6 1 3] [2 5 4 7 3 6 1] [2 5 4 1 7 6 3] [2 5 4 3 7 6 1] [2 5 3 7 1 6 4] [2 5 3 7 4 6 1] [2 5 3 7 6 1 4] [2 5 3 1 7 6 4] [2 5 3 4 7 6 1] [3 1 4 7 6 2 5] [3 1 4 7 2 6 5] [3 1 4 7 5 6 2] [3 1 4 2 7 6 5] [3 1 6 7 4 5 2] [3 1 6 7 2 5 4] [3 1 6 7 5 2 4] [3 1 6 4 7 5 2] [3 1 6 2 7 5 4] [3 1 6 5 7 4 2] [3 1 2 4 7 6 5] [3 1 2 6 7 5 4] [3 1 2 5 7 6 4] [3 1 5 7 4 6 2] [3 1 5 7 6 2 4] [3 1 5 7 2 6 4] [3 1 5 4 7 6 2] [3 1 5 2 7 6 4] [3 4 7 1 6 2 5] [3 4 7 1 2 6 5] [3 4 7 1 5 6 2] [3 4 7 6 1 2 5] [3 4 7 6 2 1 5] [3 4 7 2 1 6 5] [3 4 7 2 6 1 5] [3 4 7 2 5 6 1] [3 4 7 5 1 6 2] [3 4 7 5 6 1 2] [3 4 7 5 2 6 1] [3 4 1 7 6 2 5] [3 4 1 7 2 6 5] [3 4 1 7 5 6 2] [3 4 1 2 7 6 5] [3 4 2 7 1 6 5] [3 4 2 7 6 1 5] [3 4 2 7 5 6 1] [3 4 2 1 7 6 5] [3 6 7 1 4 5 2] [3 6 7 1 2 5 4] [3 6 7 1 5 2 4] [3 6 7 4 1 5 2] [3 6 7 4 2 5 1] [3 6 7 4 5 1 2] [3 6 7 2 1 5 4] [3 6 7 2 4 5 1] [3 6 7 2 5 1 4] [3 6 7 5 1 2 4] [3 6 7 5 2 1 4] [3 6 1 7 4 5 2] [3 6 1 7 2 5 4] [3 6 1 7 5 2 4] [3 6 1 4 7 5 2] [3 6 1 2 7 5 4] [3 6 1 5 7 4 2] [3 6 4 7 1 5 2] [3 6 4 7 2 5 1] [3 6 4 7 5 1 2] [3 6 4 1 7 5 2] [3 6 4 2 7 5 1] [3 6 4 5 7 2 1] [3 6 2 7 1 5 4] [3 6 2 7 4 5 1] [3 6 2 7 5 1 4] [3 6 2 1 7 5 4] [3 6 2 4 7 5 1] [3 6 2 5 7 4 1] [3 6 5 7 1 4 2] [3 6 5 7 4 1 2] [3 6 5 7 2 4 1] [3 6 5 1 7 4 2] [3 6 5 4 7 2 1] [3 6 5 2 7 4 1] [3 2 1 4 7 6 5] [3 2 1 6 7 5 4] [3 2 1 5 7 6 4] [3 2 4 7 1 6 5] [3 2 4 7 6 1 5] [3 2 4 7 5 6 1] [3 2 4 1 7 6 5] [3 2 6 7 1 5 4] [3 2 6 7 4 5 1] [3 2 6 7 5 1 4] [3 2 6 1 7 5 4] [3 2 6 4 7 5 1] [3 2 6 5 7 4 1] [3 2 5 7 1 6 4] [3 2 5 7 4 6 1] [3 2 5 7 6 1 4] [3 2 5 1 7 6 4] [3 2 5 4 7 6 1] [3 5 7 1 4 6 2] [3 5 7 1 6 2 4] [3 5 7 1 2 6 4] [3 5 7 4 1 6 2] [3 5 7 4 6 1 2] [3 5 7 4 2 6 1] [3 5 7 6 1 2 4] [3 5 7 6 2 1 4] [3 5 7 2 1 6 4] [3 5 7 2 4 6 1] [3 5 7 2 6 1 4] [3 5 1 7 4 6 2] [3 5 1 7 6 2 4] [3 5 1 7 2 6 4] [3 5 1 4 7 6 2] [3 5 1 2 7 6 4] [3 5 4 7 1 6 2] [3 5 4 7 6 1 2] [3 5 4 7 2 6 1] [3 5 4 1 7 6 2] [3 5 4 2 7 6 1] [3 5 2 7 1 6 4] [3 5 2 7 4 6 1] [3 5 2 7 6 1 4] [3 5 2 1 7 6 4] [3 5 2 4 7 6 1] [4 1 6 7 3 5 2] [4 1 6 7 2 5 3] [4 1 6 7 5 2 3] [4 1 6 3 7 5 2] [4 1 6 2 7 5 3] [4 1 6 5 7 3 2] [4 1 3 6 7 5 2] [4 1 3 5 7 6 2] [4 1 2 6 7 5 3] [4 1 2 5 7 6 3] [4 1 5 7 6 2 3] [4 1 5 7 3 6 2] [4 1 5 7 2 6 3] [4 1 5 3 7 6 2] [4 1 5 2 7 6 3] [4 6 7 1 3 5 2] [4 6 7 1 2 5 3] [4 6 7 1 5 2 3] [4 6 7 3 1 5 2] [4 6 7 3 2 5 1] [4 6 7 3 5 1 2] [4 6 7 2 1 5 3] [4 6 7 2 3 5 1] [4 6 7 2 5 1 3] [4 6 7 5 1 2 3] [4 6 7 5 2 1 3] [4 6 1 7 3 5 2] [4 6 1 7 2 5 3] [4 6 1 7 5 2 3] [4 6 1 3 7 5 2] [4 6 1 2 7 5 3] [4 6 1 5 7 3 2] [4 6 3 7 1 5 2] [4 6 3 7 2 5 1] [4 6 3 7 5 1 2] [4 6 3 1 7 5 2] [4 6 3 2 7 5 1] [4 6 3 5 7 2 1] [4 6 2 7 1 5 3] [4 6 2 7 3 5 1] [4 6 2 7 5 1 3] [4 6 2 1 7 5 3] [4 6 2 3 7 5 1] [4 6 2 5 7 3 1] [4 6 5 7 1 3 2] [4 6 5 7 3 1 2] [4 6 5 7 2 3 1] [4 6 5 1 7 3 2] [4 6 5 3 7 2 1] [4 6 5 2 7 3 1] [4 3 1 6 7 5 2] [4 3 1 5 7 6 2] [4 3 6 7 1 5 2] [4 3 6 7 2 5 1] [4 3 6 7 5 1 2] [4 3 6 1 7 5 2] [4 3 6 2 7 5 1] [4 3 6 5 7 2 1] [4 3 2 6 7 5 1] [4 3 2 5 7 6 1] [4 3 5 7 1 6 2] [4 3 5 7 6 1 2] [4 3 5 7 2 6 1] [4 3 5 1 7 6 2] [4 3 5 2 7 6 1] [4 2 1 6 7 5 3] [4 2 1 5 7 6 3] [4 2 6 7 1 5 3] [4 2 6 7 3 5 1] [4 2 6 7 5 1 3] [4 2 6 1 7 5 3] [4 2 6 3 7 5 1] [4 2 6 5 7 3 1] [4 2 3 6 7 5 1] [4 2 3 5 7 6 1] [4 2 5 7 1 6 3] [4 2 5 7 6 1 3] [4 2 5 7 3 6 1] [4 2 5 1 7 6 3] [4 2 5 3 7 6 1] [4 5 7 1 6 2 3] [4 5 7 1 3 6 2] [4 5 7 1 2 6 3] [4 5 7 6 1 2 3] [4 5 7 6 2 1 3] [4 5 7 3 1 6 2] [4 5 7 3 6 1 2] [4 5 7 3 2 6 1] [4 5 7 2 1 6 3] [4 5 7 2 6 1 3] [4 5 7 2 3 6 1] [4 5 1 7 6 2 3] [4 5 1 7 3 6 2] [4 5 1 7 2 6 3] [4 5 1 3 7 6 2] [4 5 1 2 7 6 3] [4 5 3 7 1 6 2] [4 5 3 7 6 1 2] [4 5 3 7 2 6 1] [4 5 3 1 7 6 2] [4 5 3 2 7 6 1] [4 5 2 7 1 6 3] [4 5 2 7 6 1 3] [4 5 2 7 3 6 1] [4 5 2 1 7 6 3] [4 5 2 3 7 6 1] [5 1 4 6 7 3 2] [5 1 6 7 4 2 3] [5 1 6 7 3 4 2] [5 1 6 7 2 4 3] [5 1 6 4 7 3 2] [5 1 6 3 7 4 2] [5 1 6 2 7 4 3] [5 1 3 6 7 4 2] [5 1 2 6 7 4 3] [5 4 1 6 7 3 2] [5 4 6 7 1 3 2] [5 4 6 7 3 1 2] [5 4 6 7 2 3 1] [5 4 6 1 7 3 2] [5 4 6 3 7 2 1] [5 4 6 2 7 3 1] [5 4 3 6 7 2 1] [5 4 2 6 7 3 1] [5 6 7 1 4 2 3] [5 6 7 1 3 4 2] [5 6 7 1 2 4 3] [5 6 7 4 1 2 3] [5 6 7 4 2 1 3] [5 6 7 3 1 4 2] [5 6 7 3 4 1 2] [5 6 7 3 2 4 1] [5 6 7 2 1 4 3] [5 6 7 2 4 1 3] [5 6 7 2 3 4 1] [5 6 1 7 4 2 3] [5 6 1 7 3 4 2] [5 6 1 7 2 4 3] [5 6 1 4 7 3 2] [5 6 1 3 7 4 2] [5 6 1 2 7 4 3] [5 6 4 7 1 3 2] [5 6 4 7 3 1 2] [5 6 4 7 2 3 1] [5 6 4 1 7 3 2] [5 6 4 3 7 2 1] [5 6 4 2 7 3 1] [5 6 3 7 1 4 2] [5 6 3 7 4 1 2] [5 6 3 7 2 4 1] [5 6 3 1 7 4 2] [5 6 3 4 7 2 1] [5 6 3 2 7 4 1] [5 6 2 7 1 4 3] [5 6 2 7 4 1 3] [5 6 2 7 3 4 1] [5 6 2 1 7 4 3] [5 6 2 4 7 3 1] [5 6 2 3 7 4 1] [5 3 1 6 7 4 2] [5 3 4 6 7 2 1] [5 3 6 7 1 4 2] [5 3 6 7 4 1 2] [5 3 6 7 2 4 1] [5 3 6 1 7 4 2] [5 3 6 4 7 2 1] [5 3 6 2 7 4 1] [5 3 2 6 7 4 1] [5 2 1 6 7 4 3] [5 2 4 6 7 3 1] [5 2 6 7 1 4 3] [5 2 6 7 4 1 3] [5 2 6 7 3 4 1] [5 2 6 1 7 4 3] [5 2 6 4 7 3 1] [5 2 6 3 7 4 1] [5 2 3 6 7 4 1]], [3 4] [[1 4 7 6 3 5 2] [1 4 7 6 2 5 3] [1 4 7 6 5 2 3] [1 4 7 3 6 5 2] [1 4 7 2 6 5 3] [1 4 7 5 6 3 2] [1 4 3 7 6 5 2] [1 4 2 7 6 5 3] [1 6 7 4 5 3 2] [1 6 7 3 5 4 2] [1 6 7 2 5 4 3] [1 6 7 5 4 2 3] [1 6 7 5 3 4 2] [1 6 7 5 2 4 3] [1 6 4 7 5 3 2] [1 6 3 7 5 4 2] [1 6 2 7 5 4 3] [1 6 5 7 4 3 2] [1 3 7 4 6 5 2] [1 3 7 6 4 5 2] [1 3 7 6 2 5 4] [1 3 7 6 5 2 4] [1 3 7 2 6 5 4] [1 3 7 5 6 4 2] [1 3 2 7 6 5 4] [1 2 7 4 6 5 3] [1 2 7 6 4 5 3] [1 2 7 6 3 5 4] [1 2 7 6 5 3 4] [1 2 7 3 6 5 4] [1 2 7 5 6 4 3] [1 5 7 4 6 3 2] [1 5 7 6 4 2 3] [1 5 7 6 3 4 2] [1 5 7 6 2 4 3] [1 5 7 3 6 4 2] [1 5 7 2 6 4 3] [1 5 4 7 6 3 2] [1 5 3 7 6 4 2] [1 5 2 7 6 4 3] [2 1 4 7 6 5 3] [2 1 6 7 5 4 3] [2 1 3 7 6 5 4] [2 1 5 7 6 4 3] [2 4 7 1 6 5 3] [2 4 7 6 1 5 3] [2 4 7 6 3 5 1] [2 4 7 6 5 1 3] [2 4 7 3 6 5 1] [2 4 7 5 6 3 1] [2 4 1 7 6 5 3] [2 4 3 7 6 5 1] [2 6 7 1 5 4 3] [2 6 7 4 5 3 1] [2 6 7 3 5 4 1] [2 6 7 5 1 4 3] [2 6 7 5 4 1 3] [2 6 7 5 3 4 1] [2 6 1 7 5 4 3] [2 6 4 7 5 3 1] [2 6 3 7 5 4 1] [2 6 5 7 4 3 1] [2 3 7 1 6 5 4] [2 3 7 4 6 5 1] [2 3 7 6 1 5 4] [2 3 7 6 4 5 1] [2 3 7 6 5 1 4] [2 3 7 5 6 4 1] [2 3 1 7 6 5 4] [2 5 7 1 6 4 3] [2 5 7 4 6 3 1] [2 5 7 6 1 4 3] [2 5 7 6 4 1 3] [2 5 7 6 3 4 1] [2 5 7 3 6 4 1] [2 5 1 7 6 4 3] [2 5 4 7 6 3 1] [2 5 3 7 6 4 1] [3 1 4 7 6 5 2] [3 1 6 7 5 4 2] [3 1 5 7 6 4 2] [3 4 7 1 6 5 2] [3 4 7 6 1 5 2] [3 4 7 6 2 5 1] [3 4 7 6 5 1 2] [3 4 7 2 6 5 1] [3 4 7 5 6 2 1] [3 4 1 7 6 5 2] [3 4 2 7 6 5 1] [3 6 7 1 5 4 2] [3 6 7 4 5 2 1] [3 6 7 2 5 4 1] [3 6 7 5 1 4 2] [3 6 7 5 4 1 2] [3 6 7 5 2 4 1] [3 6 1 7 5 4 2] [3 6 4 7 5 2 1] [3 6 2 7 5 4 1] [3 6 5 7 4 2 1] [3 2 4 7 6 5 1] [3 2 6 7 5 4 1] [3 2 5 7 6 4 1] [3 5 7 1 6 4 2] [3 5 7 4 6 2 1] [3 5 7 6 1 4 2] [3 5 7 6 4 1 2] [3 5 7 6 2 4 1] [3 5 7 2 6 4 1] [3 5 1 7 6 4 2] [3 5 4 7 6 2 1] [3 5 2 7 6 4 1] [4 1 6 7 5 3 2] [4 1 5 7 6 3 2] [4 6 7 1 5 3 2] [4 6 7 3 5 2 1] [4 6 7 2 5 3 1] [4 6 7 5 1 3 2] [4 6 7 5 3 1 2] [4 6 7 5 2 3 1] [4 6 1 7 5 3 2] [4 6 3 7 5 2 1] [4 6 2 7 5 3 1] [4 6 5 7 3 2 1] [4 3 6 7 5 2 1] [4 3 5 7 6 2 1] [4 2 6 7 5 3 1] [4 2 5 7 6 3 1] [4 5 7 1 6 3 2] [4 5 7 6 1 3 2] [4 5 7 6 3 1 2] [4 5 7 6 2 3 1] [4 5 7 3 6 2 1] [4 5 7 2 6 3 1] [4 5 1 7 6 3 2] [4 5 3 7 6 2 1] [4 5 2 7 6 3 1] [5 1 6 7 4 3 2] [5 4 6 7 3 2 1] [5 6 7 1 4 3 2] [5 6 7 4 1 3 2] [5 6 7 4 3 1 2] [5 6 7 4 2 3 1] [5 6 7 3 4 2 1] [5 6 7 2 4 3 1] [5 6 1 7 4 3 2] [5 6 4 7 3 2 1] [5 6 3 7 4 2 1] [5 6 2 7 4 3 1] [5 3 6 7 4 2 1] [5 2 6 7 4 3 1]], [4 2] [[1 4 6 7 3 2 5] [1 4 6 7 2 3 5] [1 4 6 3 7 2 5] [1 4 6 3 2 7 5] [1 4 6 3 5 7 2] [1 4 6 2 7 3 5] [1 4 6 2 3 7 5] [1 4 6 2 5 7 3] [1 4 6 5 7 2 3] [1 4 6 5 3 7 2] [1 4 6 5 2 7 3] [1 4 3 6 7 2 5] [1 4 3 6 2 7 5] [1 4 3 6 5 7 2] [1 4 3 2 6 7 5] [1 4 3 2 5 7 6] [1 4 3 5 7 2 6] [1 4 3 5 2 7 6] [1 4 2 6 7 3 5] [1 4 2 6 3 7 5] [1 4 2 6 5 7 3] [1 4 2 3 6 7 5] [1 4 2 3 5 7 6] [1 4 2 5 7 3 6] [1 4 2 5 3 7 6] [1 4 5 7 3 2 6] [1 4 5 7 2 3 6] [1 4 5 3 7 2 6] [1 4 5 3 2 7 6] [1 4 5 2 7 3 6] [1 4 5 2 3 7 6] [1 3 4 7 2 5 6] [1 3 4 7 5 2 6] [1 3 4 2 7 5 6] [1 3 6 7 4 2 5] [1 3 6 7 2 4 5] [1 3 6 4 7 2 5] [1 3 6 4 2 7 5] [1 3 6 4 5 7 2] [1 3 6 2 7 4 5] [1 3 6 2 4 7 5] [1 3 6 2 5 7 4] [1 3 6 5 7 2 4] [1 3 6 5 4 7 2] [1 3 6 5 2 7 4] [1 3 2 4 7 5 6] [1 3 2 6 7 4 5] [1 3 2 6 4 7 5] [1 3 2 6 5 7 4] [1 3 2 5 7 4 6] [1 3 2 5 4 7 6] [1 3 5 7 4 2 6] [1 3 5 7 2 4 6] [1 3 5 4 7 2 6] [1 3 5 4 2 7 6] [1 3 5 2 7 4 6] [1 3 5 2 4 7 6] [1 2 4 7 3 5 6] [1 2 4 7 5 3 6] [1 2 4 3 7 5 6] [1 2 6 7 4 3 5] [1 2 6 7 3 4 5] [1 2 6 4 7 3 5] [1 2 6 4 3 7 5] [1 2 6 4 5 7 3] [1 2 6 3 7 4 5] [1 2 6 3 4 7 5] [1 2 6 3 5 7 4] [1 2 6 5 7 3 4] [1 2 6 5 4 7 3] [1 2 6 5 3 7 4] [1 2 3 7 4 5 6] [1 2 3 7 5 4 6] [1 2 5 7 4 3 6] [1 2 5 7 3 4 6] [1 2 5 4 7 3 6] [1 2 5 4 3 7 6] [1 2 5 3 7 4 6] [1 2 5 3 4 7 6] [1 5 4 6 7 2 3] [1 5 4 6 3 7 2] [1 5 4 6 2 7 3] [1 5 4 3 6 7 2] [1 5 4 2 6 7 3] [1 5 6 7 3 2 4] [1 5 6 7 2 3 4] [1 5 6 4 7 2 3] [1 5 6 4 3 7 2] [1 5 6 4 2 7 3] [1 5 6 3 7 2 4] [1 5 6 3 4 7 2] [1 5 6 3 2 7 4] [1 5 6 2 7 3 4] [1 5 6 2 4 7 3] [1 5 6 2 3 7 4] [1 5 3 4 6 7 2] [1 5 3 6 7 2 4] [1 5 3 6 4 7 2] [1 5 3 6 2 7 4] [1 5 3 2 6 7 4] [1 5 2 4 6 7 3] [1 5 2 6 7 3 4] [1 5 2 6 4 7 3] [1 5 2 6 3 7 4] [1 5 2 3 6 7 4] [2 1 4 6 7 3 5] [2 1 4 6 3 7 5] [2 1 4 6 5 7 3] [2 1 4 3 6 7 5] [2 1 4 3 5 7 6] [2 1 4 5 7 3 6] [2 1 4 5 3 7 6] [2 1 3 4 7 5 6] [2 1 3 6 7 4 5] [2 1 3 6 4 7 5] [2 1 3 6 5 7 4] [2 1 3 5 7 4 6] [2 1 3 5 4 7 6] [2 1 5 4 6 7 3] [2 1 5 6 7 3 4] [2 1 5 6 4 7 3] [2 1 5 6 3 7 4] [2 1 5 3 6 7 4] [2 4 1 6 7 3 5] [2 4 1 6 3 7 5] [2 4 1 6 5 7 3] [2 4 1 3 6 7 5] [2 4 1 3 5 7 6] [2 4 1 5 7 3 6] [2 4 1 5 3 7 6] [2 4 6 7 1 3 5] [2 4 6 7 3 1 5] [2 4 6 1 7 3 5] [2 4 6 1 3 7 5] [2 4 6 1 5 7 3] [2 4 6 3 7 1 5] [2 4 6 3 1 7 5] [2 4 6 3 5 7 1] [2 4 6 5 7 1 3] [2 4 6 5 1 7 3] [2 4 6 5 3 7 1] [2 4 3 1 6 7 5] [2 4 3 1 5 7 6] [2 4 3 6 7 1 5] [2 4 3 6 1 7 5] [2 4 3 6 5 7 1] [2 4 3 5 7 1 6] [2 4 3 5 1 7 6] [2 4 5 7 1 3 6] [2 4 5 7 3 1 6] [2 4 5 1 7 3 6] [2 4 5 1 3 7 6] [2 4 5 3 7 1 6] [2 4 5 3 1 7 6] [2 3 1 4 7 5 6] [2 3 1 6 7 4 5] [2 3 1 6 4 7 5] [2 3 1 6 5 7 4] [2 3 1 5 7 4 6] [2 3 1 5 4 7 6] [2 3 4 7 1 5 6] [2 3 4 7 5 1 6] [2 3 4 1 7 5 6] [2 3 6 7 1 4 5] [2 3 6 7 4 1 5] [2 3 6 1 7 4 5] [2 3 6 1 4 7 5] [2 3 6 1 5 7 4] [2 3 6 4 7 1 5] [2 3 6 4 1 7 5] [2 3 6 4 5 7 1] [2 3 6 5 7 1 4] [2 3 6 5 1 7 4] [2 3 6 5 4 7 1] [2 3 5 7 1 4 6] [2 3 5 7 4 1 6] [2 3 5 1 7 4 6] [2 3 5 1 4 7 6] [2 3 5 4 7 1 6] [2 3 5 4 1 7 6] [2 5 1 4 6 7 3] [2 5 1 6 7 3 4] [2 5 1 6 4 7 3] [2 5 1 6 3 7 4] [2 5 1 3 6 7 4] [2 5 4 1 6 7 3] [2 5 4 6 7 1 3] [2 5 4 6 1 7 3] [2 5 4 6 3 7 1] [2 5 4 3 6 7 1] [2 5 6 7 1 3 4] [2 5 6 7 3 1 4] [2 5 6 1 7 3 4] [2 5 6 1 4 7 3] [2 5 6 1 3 7 4] [2 5 6 4 7 1 3] [2 5 6 4 1 7 3] [2 5 6 4 3 7 1] [2 5 6 3 7 1 4] [2 5 6 3 1 7 4] [2 5 6 3 4 7 1] [2 5 3 1 6 7 4] [2 5 3 4 6 7 1] [2 5 3 6 7 1 4] [2 5 3 6 1 7 4] [2 5 3 6 4 7 1] [3 1 4 6 7 2 5] [3 1 4 6 2 7 5] [3 1 4 6 5 7 2] [3 1 4 2 6 7 5] [3 1 4 2 5 7 6] [3 1 4 5 7 2 6] [3 1 4 5 2 7 6] [3 1 2 4 6 7 5] [3 1 2 4 5 7 6] [3 1 2 5 6 7 4] [3 1 5 4 6 7 2] [3 1 5 6 7 2 4] [3 1 5 6 4 7 2] [3 1 5 6 2 7 4] [3 1 5 2 6 7 4] [3 4 1 6 7 2 5] [3 4 1 6 2 7 5] [3 4 1 6 5 7 2] [3 4 1 2 6 7 5] [3 4 1 2 5 7 6] [3 4 1 5 7 2 6] [3 4 1 5 2 7 6] [3 4 6 7 1 2 5] [3 4 6 7 2 1 5] [3 4 6 1 7 2 5] [3 4 6 1 2 7 5] [3 4 6 1 5 7 2] [3 4 6 2 7 1 5] [3 4 6 2 1 7 5] [3 4 6 2 5 7 1] [3 4 6 5 7 1 2] [3 4 6 5 1 7 2] [3 4 6 5 2 7 1] [3 4 2 1 6 7 5] [3 4 2 1 5 7 6] [3 4 2 6 7 1 5] [3 4 2 6 1 7 5] [3 4 2 6 5 7 1] [3 4 2 5 7 1 6] [3 4 2 5 1 7 6] [3 4 5 7 1 2 6] [3 4 5 7 2 1 6] [3 4 5 1 7 2 6] [3 4 5 1 2 7 6] [3 4 5 2 7 1 6] [3 4 5 2 1 7 6] [3 2 1 4 6 7 5] [3 2 1 4 5 7 6] [3 2 1 5 6 7 4] [3 2 4 1 6 7 5] [3 2 4 1 5 7 6] [3 2 4 6 7 1 5] [3 2 4 6 1 7 5] [3 2 4 6 5 7 1] [3 2 4 5 7 1 6] [3 2 4 5 1 7 6] [3 2 5 1 6 7 4] [3 2 5 4 6 7 1] [3 2 5 6 7 1 4] [3 2 5 6 1 7 4] [3 2 5 6 4 7 1] [3 5 1 4 6 7 2] [3 5 1 6 7 2 4] [3 5 1 6 4 7 2] [3 5 1 6 2 7 4] [3 5 1 2 6 7 4] [3 5 4 1 6 7 2] [3 5 4 6 7 1 2] [3 5 4 6 1 7 2] [3 5 4 6 2 7 1] [3 5 4 2 6 7 1] [3 5 6 7 1 2 4] [3 5 6 7 2 1 4] [3 5 6 1 7 2 4] [3 5 6 1 4 7 2] [3 5 6 1 2 7 4] [3 5 6 4 7 1 2] [3 5 6 4 1 7 2] [3 5 6 4 2 7 1] [3 5 6 2 7 1 4] [3 5 6 2 1 7 4] [3 5 6 2 4 7 1] [3 5 2 1 6 7 4] [3 5 2 4 6 7 1] [3 5 2 6 7 1 4] [3 5 2 6 1 7 4] [3 5 2 6 4 7 1] [4 1 3 5 6 7 2] [4 1 2 5 6 7 3] [4 1 5 6 7 2 3] [4 1 5 6 3 7 2] [4 1 5 6 2 7 3] [4 1 5 3 6 7 2] [4 1 5 2 6 7 3] [4 3 1 5 6 7 2] [4 3 2 5 6 7 1] [4 3 5 1 6 7 2] [4 3 5 6 7 1 2] [4 3 5 6 1 7 2] [4 3 5 6 2 7 1] [4 3 5 2 6 7 1] [4 2 1 5 6 7 3] [4 2 3 5 6 7 1] [4 2 5 1 6 7 3] [4 2 5 6 7 1 3] [4 2 5 6 1 7 3] [4 2 5 6 3 7 1] [4 2 5 3 6 7 1] [4 5 1 6 7 2 3] [4 5 1 6 3 7 2] [4 5 1 6 2 7 3] [4 5 1 3 6 7 2] [4 5 1 2 6 7 3] [4 5 6 7 1 2 3] [4 5 6 7 2 1 3] [4 5 6 1 7 2 3] [4 5 6 1 3 7 2] [4 5 6 1 2 7 3] [4 5 6 3 7 1 2] [4 5 6 3 1 7 2] [4 5 6 3 2 7 1] [4 5 6 2 7 1 3] [4 5 6 2 1 7 3] [4 5 6 2 3 7 1] [4 5 3 1 6 7 2] [4 5 3 6 7 1 2] [4 5 3 6 1 7 2] [4 5 3 6 2 7 1] [4 5 3 2 6 7 1] [4 5 2 1 6 7 3] [4 5 2 6 7 1 3] [4 5 2 6 1 7 3] [4 5 2 6 3 7 1] [4 5 2 3 6 7 1]], [5 3] [[1 4 5 6 7 3 2] [1 3 4 6 7 5 2] [1 3 4 5 7 6 2] [1 3 5 6 7 4 2] [1 2 4 6 7 5 3] [1 2 4 5 7 6 3] [1 2 3 4 7 6 5] [1 2 3 6 7 5 4] [1 2 3 5 7 6 4] [1 2 5 6 7 4 3] [2 4 5 6 7 3 1] [2 3 4 6 7 5 1] [2 3 4 5 7 6 1] [2 3 5 6 7 4 1] [3 4 5 6 7 2 1]], [4 1] [[1 4 6 3 2 5 7] [1 4 6 3 5 2 7] [1 4 6 2 3 5 7] [1 4 6 2 5 3 7] [1 4 6 5 3 2 7] [1 4 6 5 2 3 7] [1 4 3 6 2 5 7] [1 4 3 6 5 2 7] [1 4 3 2 6 5 7] [1 4 2 6 3 5 7] [1 4 2 6 5 3 7] [1 4 2 3 6 5 7] [1 3 6 4 2 5 7] [1 3 6 4 5 2 7] [1 3 6 2 4 5 7] [1 3 6 2 5 4 7] [1 3 6 5 4 2 7] [1 3 6 5 2 4 7] [1 3 2 6 4 5 7] [1 3 2 6 5 4 7] [1 2 6 4 3 5 7] [1 2 6 4 5 3 7] [1 2 6 3 4 5 7] [1 2 6 3 5 4 7] [1 2 6 5 4 3 7] [1 2 6 5 3 4 7] [1 5 4 6 3 2 7] [1 5 4 6 2 3 7] [1 5 4 3 6 2 7] [1 5 4 3 2 6 7] [1 5 4 2 6 3 7] [1 5 4 2 3 6 7] [1 5 6 4 3 2 7] [1 5 6 4 2 3 7] [1 5 6 3 4 2 7] [1 5 6 3 2 4 7] [1 5 6 2 4 3 7] [1 5 6 2 3 4 7] [1 5 3 4 6 2 7] [1 5 3 4 2 6 7] [1 5 3 6 4 2 7] [1 5 3 6 2 4 7] [1 5 3 2 4 6 7] [1 5 3 2 6 4 7] [1 5 2 4 6 3 7] [1 5 2 4 3 6 7] [1 5 2 6 4 3 7] [1 5 2 6 3 4 7] [1 5 2 3 4 6 7] [1 5 2 3 6 4 7] [2 1 4 6 3 5 7] [2 1 4 6 5 3 7] [2 1 4 3 6 5 7] [2 1 3 6 4 5 7] [2 1 3 6 5 4 7] [2 1 5 4 6 3 7] [2 1 5 4 3 6 7] [2 1 5 6 4 3 7] [2 1 5 6 3 4 7] [2 1 5 3 4 6 7] [2 1 5 3 6 4 7] [2 4 1 6 3 5 7] [2 4 1 6 5 3 7] [2 4 1 3 6 5 7] [2 4 6 1 3 5 7] [2 4 6 1 5 3 7] [2 4 6 3 1 5 7] [2 4 6 3 5 1 7] [2 4 6 5 1 3 7] [2 4 6 5 3 1 7] [2 4 3 1 6 5 7] [2 4 3 6 1 5 7] [2 4 3 6 5 1 7] [2 3 1 6 4 5 7] [2 3 1 6 5 4 7] [2 3 6 1 4 5 7] [2 3 6 1 5 4 7] [2 3 6 4 1 5 7] [2 3 6 4 5 1 7] [2 3 6 5 1 4 7] [2 3 6 5 4 1 7] [2 5 1 4 6 3 7] [2 5 1 4 3 6 7] [2 5 1 6 4 3 7] [2 5 1 6 3 4 7] [2 5 1 3 4 6 7] [2 5 1 3 6 4 7] [2 5 4 1 6 3 7] [2 5 4 1 3 6 7] [2 5 4 6 1 3 7] [2 5 4 6 3 1 7] [2 5 4 3 1 6 7] [2 5 4 3 6 1 7] [2 5 6 1 4 3 7] [2 5 6 1 3 4 7] [2 5 6 4 1 3 7] [2 5 6 4 3 1 7] [2 5 6 3 1 4 7] [2 5 6 3 4 1 7] [2 5 3 1 4 6 7] [2 5 3 1 6 4 7] [2 5 3 4 1 6 7] [2 5 3 4 6 1 7] [2 5 3 6 1 4 7] [2 5 3 6 4 1 7] [3 1 4 6 2 5 7] [3 1 4 6 5 2 7] [3 1 4 2 6 5 7] [3 1 2 4 6 5 7] [3 1 2 5 4 6 7] [3 1 2 5 6 4 7] [3 1 5 4 6 2 7] [3 1 5 4 2 6 7] [3 1 5 6 4 2 7] [3 1 5 6 2 4 7] [3 1 5 2 4 6 7] [3 1 5 2 6 4 7] [3 4 1 6 2 5 7] [3 4 1 6 5 2 7] [3 4 1 2 6 5 7] [3 4 6 1 2 5 7] [3 4 6 1 5 2 7] [3 4 6 2 1 5 7] [3 4 6 2 5 1 7] [3 4 6 5 1 2 7] [3 4 6 5 2 1 7] [3 4 2 1 6 5 7] [3 4 2 6 1 5 7] [3 4 2 6 5 1 7] [3 2 1 4 6 5 7] [3 2 1 5 4 6 7] [3 2 1 5 6 4 7] [3 2 4 1 6 5 7] [3 2 4 6 1 5 7] [3 2 4 6 5 1 7] [3 2 5 1 4 6 7] [3 2 5 1 6 4 7] [3 2 5 4 1 6 7] [3 2 5 4 6 1 7] [3 2 5 6 1 4 7] [3 2 5 6 4 1 7] [3 5 1 4 6 2 7] [3 5 1 4 2 6 7] [3 5 1 6 4 2 7] [3 5 1 6 2 4 7] [3 5 1 2 4 6 7] [3 5 1 2 6 4 7] [3 5 4 1 6 2 7] [3 5 4 1 2 6 7] [3 5 4 6 1 2 7] [3 5 4 6 2 1 7] [3 5 4 2 1 6 7] [3 5 4 2 6 1 7] [3 5 6 1 4 2 7] [3 5 6 1 2 4 7] [3 5 6 4 1 2 7] [3 5 6 4 2 1 7] [3 5 6 2 1 4 7] [3 5 6 2 4 1 7] [3 5 2 1 4 6 7] [3 5 2 1 6 4 7] [3 5 2 4 1 6 7] [3 5 2 4 6 1 7] [3 5 2 6 1 4 7] [3 5 2 6 4 1 7] [4 1 3 2 5 6 7] [4 1 3 5 6 2 7] [4 1 3 5 2 6 7] [4 1 2 3 5 6 7] [4 1 2 5 6 3 7] [4 1 2 5 3 6 7] [4 1 5 6 3 2 7] [4 1 5 6 2 3 7] [4 1 5 3 6 2 7] [4 1 5 3 2 6 7] [4 1 5 2 6 3 7] [4 1 5 2 3 6 7] [4 3 1 2 5 6 7] [4 3 1 5 6 2 7] [4 3 1 5 2 6 7] [4 3 2 1 5 6 7] [4 3 2 5 1 6 7] [4 3 2 5 6 1 7] [4 3 5 1 6 2 7] [4 3 5 1 2 6 7] [4 3 5 6 1 2 7] [4 3 5 6 2 1 7] [4 3 5 2 1 6 7] [4 3 5 2 6 1 7] [4 2 1 3 5 6 7] [4 2 1 5 6 3 7] [4 2 1 5 3 6 7] [4 2 3 1 5 6 7] [4 2 3 5 1 6 7] [4 2 3 5 6 1 7] [4 2 5 1 6 3 7] [4 2 5 1 3 6 7] [4 2 5 6 1 3 7] [4 2 5 6 3 1 7] [4 2 5 3 1 6 7] [4 2 5 3 6 1 7] [4 5 1 6 3 2 7] [4 5 1 6 2 3 7] [4 5 1 3 6 2 7] [4 5 1 3 2 6 7] [4 5 1 2 6 3 7] [4 5 1 2 3 6 7] [4 5 6 1 3 2 7] [4 5 6 1 2 3 7] [4 5 6 3 1 2 7] [4 5 6 3 2 1 7] [4 5 6 2 1 3 7] [4 5 6 2 3 1 7] [4 5 3 1 6 2 7] [4 5 3 1 2 6 7] [4 5 3 6 1 2 7] [4 5 3 6 2 1 7] [4 5 3 2 1 6 7] [4 5 3 2 6 1 7] [4 5 2 1 6 3 7] [4 5 2 1 3 6 7] [4 5 2 6 1 3 7] [4 5 2 6 3 1 7] [4 5 2 3 1 6 7] [4 5 2 3 6 1 7]], [5 2] [[1 4 3 5 6 7 2] [1 4 2 5 6 7 3] [1 4 5 6 7 2 3] [1 4 5 6 3 7 2] [1 4 5 6 2 7 3] [1 4 5 3 6 7 2] [1 4 5 2 6 7 3] [1 3 4 6 7 2 5] [1 3 4 6 2 7 5] [1 3 4 6 5 7 2] [1 3 4 2 6 7 5] [1 3 4 2 5 7 6] [1 3 4 5 7 2 6] [1 3 4 5 2 7 6] [1 3 2 4 6 7 5] [1 3 2 4 5 7 6] [1 3 2 5 6 7 4] [1 3 5 4 6 7 2] [1 3 5 6 7 2 4] [1 3 5 6 4 7 2] [1 3 5 6 2 7 4] [1 3 5 2 6 7 4] [1 2 4 6 7 3 5] [1 2 4 6 3 7 5] [1 2 4 6 5 7 3] [1 2 4 3 6 7 5] [1 2 4 3 5 7 6] [1 2 4 5 7 3 6] [1 2 4 5 3 7 6] [1 2 3 4 7 5 6] [1 2 3 6 7 4 5] [1 2 3 6 4 7 5] [1 2 3 6 5 7 4] [1 2 3 5 7 4 6] [1 2 3 5 4 7 6] [1 2 5 4 6 7 3] [1 2 5 6 7 3 4] [1 2 5 6 4 7 3] [1 2 5 6 3 7 4] [1 2 5 3 6 7 4] [2 1 4 5 6 7 3] [2 1 3 4 6 7 5] [2 1 3 4 5 7 6] [2 1 3 5 6 7 4] [2 4 1 5 6 7 3] [2 4 3 5 6 7 1] [2 4 5 1 6 7 3] [2 4 5 6 7 1 3] [2 4 5 6 1 7 3] [2 4 5 6 3 7 1] [2 4 5 3 6 7 1] [2 3 1 4 6 7 5] [2 3 1 4 5 7 6] [2 3 1 5 6 7 4] [2 3 4 1 6 7 5] [2 3 4 1 5 7 6] [2 3 4 6 7 1 5] [2 3 4 6 1 7 5] [2 3 4 6 5 7 1] [2 3 4 5 7 1 6] [2 3 4 5 1 7 6] [2 3 5 1 6 7 4] [2 3 5 4 6 7 1] [2 3 5 6 7 1 4] [2 3 5 6 1 7 4] [2 3 5 6 4 7 1] [3 1 4 5 6 7 2] [3 4 1 5 6 7 2] [3 4 2 5 6 7 1] [3 4 5 1 6 7 2] [3 4 5 6 7 1 2] [3 4 5 6 1 7 2] [3 4 5 6 2 7 1] [3 4 5 2 6 7 1] [3 2 4 5 6 7 1]], [1 4] [[7 1 4 6 3 5 2] [7 1 4 6 2 5 3] [7 1 4 6 5 2 3] [7 1 4 3 6 5 2] [7 1 4 2 6 5 3] [7 1 4 5 6 3 2] [7 1 6 4 3 5 2] [7 1 6 4 2 5 3] [7 1 6 4 5 2 3] [7 1 6 3 4 5 2] [7 1 6 3 2 5 4] [7 1 6 3 5 2 4] [7 1 6 2 4 5 3] [7 1 6 2 3 5 4] [7 1 6 2 5 3 4] [7 1 6 5 3 2 4] [7 1 6 5 2 3 4] [7 1 3 4 6 5 2] [7 1 3 6 4 5 2] [7 1 3 6 2 5 4] [7 1 3 6 5 2 4] [7 1 3 2 6 5 4] [7 1 3 5 6 4 2] [7 1 2 4 6 5 3] [7 1 2 6 4 5 3] [7 1 2 6 3 5 4] [7 1 2 6 5 3 4] [7 1 2 3 6 5 4] [7 1 2 5 6 4 3] [7 1 5 4 6 3 2] [7 1 5 6 4 2 3] [7 1 5 6 3 4 2] [7 1 5 6 2 4 3] [7 1 5 3 6 4 2] [7 1 5 2 6 4 3] [7 4 1 6 3 5 2] [7 4 1 6 2 5 3] [7 4 1 6 5 2 3] [7 4 1 3 6 5 2] [7 4 1 2 6 5 3] [7 4 1 5 6 3 2] [7 4 6 1 3 5 2] [7 4 6 1 2 5 3] [7 4 6 1 5 2 3] [7 4 6 3 1 5 2] [7 4 6 3 2 5 1] [7 4 6 3 5 1 2] [7 4 6 2 1 5 3] [7 4 6 2 3 5 1] [7 4 6 2 5 1 3] [7 4 6 5 1 2 3] [7 4 6 5 2 1 3] [7 4 3 1 6 5 2] [7 4 3 6 1 5 2] [7 4 3 6 2 5 1] [7 4 3 6 5 1 2] [7 4 3 2 6 5 1] [7 4 3 5 6 2 1] [7 4 2 1 6 5 3] [7 4 2 6 1 5 3] [7 4 2 6 3 5 1] [7 4 2 6 5 1 3] [7 4 2 3 6 5 1] [7 4 2 5 6 3 1] [7 4 5 1 6 3 2] [7 4 5 6 1 3 2] [7 4 5 6 3 1 2] [7 4 5 6 2 3 1] [7 4 5 3 6 2 1] [7 4 5 2 6 3 1] [7 6 1 4 3 5 2] [7 6 1 4 2 5 3] [7 6 1 4 5 2 3] [7 6 1 3 4 5 2] [7 6 1 3 2 5 4] [7 6 1 3 5 2 4] [7 6 1 2 4 5 3] [7 6 1 2 3 5 4] [7 6 1 2 5 3 4] [7 6 1 5 3 2 4] [7 6 1 5 2 3 4] [7 6 4 1 3 5 2] [7 6 4 1 2 5 3] [7 6 4 1 5 2 3] [7 6 4 3 1 5 2] [7 6 4 3 2 5 1] [7 6 4 3 5 1 2] [7 6 4 2 1 5 3] [7 6 4 2 3 5 1] [7 6 4 2 5 1 3] [7 6 4 5 1 2 3] [7 6 4 5 2 1 3] [7 6 3 1 4 5 2] [7 6 3 1 2 5 4] [7 6 3 1 5 2 4] [7 6 3 4 1 5 2] [7 6 3 4 2 5 1] [7 6 3 4 5 1 2] [7 6 3 2 1 5 4] [7 6 3 2 4 5 1] [7 6 3 2 5 1 4] [7 6 3 5 1 2 4] [7 6 3 5 2 1 4] [7 6 2 1 4 5 3] [7 6 2 1 3 5 4] [7 6 2 1 5 3 4] [7 6 2 4 1 5 3] [7 6 2 4 3 5 1] [7 6 2 4 5 1 3] [7 6 2 3 1 5 4] [7 6 2 3 4 5 1] [7 6 2 3 5 1 4] [7 6 2 5 1 3 4] [7 6 2 5 3 1 4] [7 6 5 1 3 2 4] [7 6 5 1 2 3 4] [7 6 5 3 1 2 4] [7 6 5 3 2 1 4] [7 6 5 2 1 3 4] [7 6 5 2 3 1 4] [7 3 1 4 6 5 2] [7 3 1 6 4 5 2] [7 3 1 6 2 5 4] [7 3 1 6 5 2 4] [7 3 1 2 6 5 4] [7 3 1 5 6 4 2] [7 3 4 1 6 5 2] [7 3 4 6 1 5 2] [7 3 4 6 2 5 1] [7 3 4 6 5 1 2] [7 3 4 2 6 5 1] [7 3 4 5 6 2 1] [7 3 6 1 4 5 2] [7 3 6 1 2 5 4] [7 3 6 1 5 2 4] [7 3 6 4 1 5 2] [7 3 6 4 2 5 1] [7 3 6 4 5 1 2] [7 3 6 2 1 5 4] [7 3 6 2 4 5 1] [7 3 6 2 5 1 4] [7 3 6 5 1 2 4] [7 3 6 5 2 1 4] [7 3 2 1 6 5 4] [7 3 2 4 6 5 1] [7 3 2 6 1 5 4] [7 3 2 6 4 5 1] [7 3 2 6 5 1 4] [7 3 2 5 6 4 1] [7 3 5 1 6 4 2] [7 3 5 4 6 2 1] [7 3 5 6 1 4 2] [7 3 5 6 4 1 2] [7 3 5 6 2 4 1] [7 3 5 2 6 4 1] [7 2 1 4 6 5 3] [7 2 1 6 4 5 3] [7 2 1 6 3 5 4] [7 2 1 6 5 3 4] [7 2 1 3 6 5 4] [7 2 1 5 6 4 3] [7 2 4 1 6 5 3] [7 2 4 6 1 5 3] [7 2 4 6 3 5 1] [7 2 4 6 5 1 3] [7 2 4 3 6 5 1] [7 2 4 5 6 3 1] [7 2 6 1 4 5 3] [7 2 6 1 3 5 4] [7 2 6 1 5 3 4] [7 2 6 4 1 5 3] [7 2 6 4 3 5 1] [7 2 6 4 5 1 3] [7 2 6 3 1 5 4] [7 2 6 3 4 5 1] [7 2 6 3 5 1 4] [7 2 6 5 1 3 4] [7 2 6 5 3 1 4] [7 2 3 1 6 5 4] [7 2 3 4 6 5 1] [7 2 3 6 1 5 4] [7 2 3 6 4 5 1] [7 2 3 6 5 1 4] [7 2 3 5 6 4 1] [7 2 5 1 6 4 3] [7 2 5 4 6 3 1] [7 2 5 6 1 4 3] [7 2 5 6 4 1 3] [7 2 5 6 3 4 1] [7 2 5 3 6 4 1] [7 5 1 4 6 3 2] [7 5 1 6 4 2 3] [7 5 1 6 3 4 2] [7 5 1 6 2 4 3] [7 5 1 3 6 4 2] [7 5 1 2 6 4 3] [7 5 4 1 6 3 2] [7 5 4 6 1 3 2] [7 5 4 6 3 1 2] [7 5 4 6 2 3 1] [7 5 4 3 6 2 1] [7 5 4 2 6 3 1] [7 5 6 1 4 2 3] [7 5 6 1 3 4 2] [7 5 6 1 2 4 3] [7 5 6 4 1 2 3] [7 5 6 4 2 1 3] [7 5 6 3 1 4 2] [7 5 6 3 4 1 2] [7 5 6 3 2 4 1] [7 5 6 2 1 4 3] [7 5 6 2 4 1 3] [7 5 6 2 3 4 1] [7 5 3 1 6 4 2] [7 5 3 4 6 2 1] [7 5 3 6 1 4 2] [7 5 3 6 4 1 2] [7 5 3 6 2 4 1] [7 5 3 2 6 4 1] [7 5 2 1 6 4 3] [7 5 2 4 6 3 1] [7 5 2 6 1 4 3] [7 5 2 6 4 1 3] [7 5 2 6 3 4 1] [7 5 2 3 6 4 1]], [1 3] [[7 1 4 6 3 2 5] [7 1 4 6 2 3 5] [7 1 4 3 6 2 5] [7 1 4 3 2 6 5] [7 1 4 3 5 6 2] [7 1 4 2 6 3 5] [7 1 4 2 3 6 5] [7 1 4 2 5 6 3] [7 1 4 5 6 2 3] [7 1 4 5 3 6 2] [7 1 4 5 2 6 3] [7 1 6 4 3 2 5] [7 1 6 4 2 3 5] [7 1 6 3 4 2 5] [7 1 6 3 2 4 5] [7 1 6 2 4 3 5] [7 1 6 2 3 4 5] [7 1 3 4 6 2 5] [7 1 3 4 2 6 5] [7 1 3 4 5 6 2] [7 1 3 6 4 2 5] [7 1 3 6 2 4 5] [7 1 3 2 4 6 5] [7 1 3 2 6 4 5] [7 1 3 2 5 6 4] [7 1 3 5 4 6 2] [7 1 3 5 6 2 4] [7 1 3 5 2 6 4] [7 1 2 4 6 3 5] [7 1 2 4 3 6 5] [7 1 2 4 5 6 3] [7 1 2 6 4 3 5] [7 1 2 6 3 4 5] [7 1 2 3 4 6 5] [7 1 2 3 6 4 5] [7 1 2 3 5 6 4] [7 1 2 5 4 6 3] [7 1 2 5 6 3 4] [7 1 2 5 3 6 4] [7 1 5 4 6 2 3] [7 1 5 4 3 6 2] [7 1 5 4 2 6 3] [7 1 5 6 3 2 4] [7 1 5 6 2 3 4] [7 1 5 3 4 6 2] [7 1 5 3 6 2 4] [7 1 5 3 2 6 4] [7 1 5 2 4 6 3] [7 1 5 2 6 3 4] [7 1 5 2 3 6 4] [7 4 1 6 3 2 5] [7 4 1 6 2 3 5] [7 4 1 3 6 2 5] [7 4 1 3 2 6 5] [7 4 1 3 5 6 2] [7 4 1 2 6 3 5] [7 4 1 2 3 6 5] [7 4 1 2 5 6 3] [7 4 1 5 6 2 3] [7 4 1 5 3 6 2] [7 4 1 5 2 6 3] [7 4 6 1 3 2 5] [7 4 6 1 2 3 5] [7 4 6 3 1 2 5] [7 4 6 3 2 1 5] [7 4 6 2 1 3 5] [7 4 6 2 3 1 5] [7 4 3 1 6 2 5] [7 4 3 1 2 6 5] [7 4 3 1 5 6 2] [7 4 3 6 1 2 5] [7 4 3 6 2 1 5] [7 4 3 2 1 6 5] [7 4 3 2 6 1 5] [7 4 3 2 5 6 1] [7 4 3 5 1 6 2] [7 4 3 5 6 1 2] [7 4 3 5 2 6 1] [7 4 2 1 6 3 5] [7 4 2 1 3 6 5] [7 4 2 1 5 6 3] [7 4 2 6 1 3 5] [7 4 2 6 3 1 5] [7 4 2 3 1 6 5] [7 4 2 3 6 1 5] [7 4 2 3 5 6 1] [7 4 2 5 1 6 3] [7 4 2 5 6 1 3] [7 4 2 5 3 6 1] [7 4 5 1 6 2 3] [7 4 5 1 3 6 2] [7 4 5 1 2 6 3] [7 4 5 6 1 2 3] [7 4 5 6 2 1 3] [7 4 5 3 1 6 2] [7 4 5 3 6 1 2] [7 4 5 3 2 6 1] [7 4 5 2 1 6 3] [7 4 5 2 6 1 3] [7 4 5 2 3 6 1] [7 6 1 4 3 2 5] [7 6 1 4 2 3 5] [7 6 1 3 4 2 5] [7 6 1 3 2 4 5] [7 6 1 2 4 3 5] [7 6 1 2 3 4 5] [7 6 4 1 3 2 5] [7 6 4 1 2 3 5] [7 6 4 3 1 2 5] [7 6 4 3 2 1 5] [7 6 4 2 1 3 5] [7 6 4 2 3 1 5] [7 6 3 1 4 2 5] [7 6 3 1 2 4 5] [7 6 3 4 1 2 5] [7 6 3 4 2 1 5] [7 6 3 2 1 4 5] [7 6 3 2 4 1 5] [7 6 2 1 4 3 5] [7 6 2 1 3 4 5] [7 6 2 4 1 3 5] [7 6 2 4 3 1 5] [7 6 2 3 1 4 5] [7 6 2 3 4 1 5] [7 3 1 4 6 2 5] [7 3 1 4 2 6 5] [7 3 1 4 5 6 2] [7 3 1 6 4 2 5] [7 3 1 6 2 4 5] [7 3 1 2 4 6 5] [7 3 1 2 6 4 5] [7 3 1 2 5 6 4] [7 3 1 5 4 6 2] [7 3 1 5 6 2 4] [7 3 1 5 2 6 4] [7 3 4 1 6 2 5] [7 3 4 1 2 6 5] [7 3 4 1 5 6 2] [7 3 4 6 1 2 5] [7 3 4 6 2 1 5] [7 3 4 2 1 6 5] [7 3 4 2 6 1 5] [7 3 4 2 5 6 1] [7 3 4 5 1 6 2] [7 3 4 5 6 1 2] [7 3 4 5 2 6 1] [7 3 6 1 4 2 5] [7 3 6 1 2 4 5] [7 3 6 4 1 2 5] [7 3 6 4 2 1 5] [7 3 6 2 1 4 5] [7 3 6 2 4 1 5] [7 3 2 1 4 6 5] [7 3 2 1 6 4 5] [7 3 2 1 5 6 4] [7 3 2 4 1 6 5] [7 3 2 4 6 1 5] [7 3 2 4 5 6 1] [7 3 2 6 1 4 5] [7 3 2 6 4 1 5] [7 3 2 5 1 6 4] [7 3 2 5 4 6 1] [7 3 2 5 6 1 4] [7 3 5 1 4 6 2] [7 3 5 1 6 2 4] [7 3 5 1 2 6 4] [7 3 5 4 1 6 2] [7 3 5 4 6 1 2] [7 3 5 4 2 6 1] [7 3 5 6 1 2 4] [7 3 5 6 2 1 4] [7 3 5 2 1 6 4] [7 3 5 2 4 6 1] [7 3 5 2 6 1 4] [7 2 1 4 6 3 5] [7 2 1 4 3 6 5] [7 2 1 4 5 6 3] [7 2 1 6 4 3 5] [7 2 1 6 3 4 5] [7 2 1 3 4 6 5] [7 2 1 3 6 4 5] [7 2 1 3 5 6 4] [7 2 1 5 4 6 3] [7 2 1 5 6 3 4] [7 2 1 5 3 6 4] [7 2 4 1 6 3 5] [7 2 4 1 3 6 5] [7 2 4 1 5 6 3] [7 2 4 6 1 3 5] [7 2 4 6 3 1 5] [7 2 4 3 1 6 5] [7 2 4 3 6 1 5] [7 2 4 3 5 6 1] [7 2 4 5 1 6 3] [7 2 4 5 6 1 3] [7 2 4 5 3 6 1] [7 2 6 1 4 3 5] [7 2 6 1 3 4 5] [7 2 6 4 1 3 5] [7 2 6 4 3 1 5] [7 2 6 3 1 4 5] [7 2 6 3 4 1 5] [7 2 3 1 4 6 5] [7 2 3 1 6 4 5] [7 2 3 1 5 6 4] [7 2 3 4 1 6 5] [7 2 3 4 6 1 5] [7 2 3 4 5 6 1] [7 2 3 6 1 4 5] [7 2 3 6 4 1 5] [7 2 3 5 1 6 4] [7 2 3 5 4 6 1] [7 2 3 5 6 1 4] [7 2 5 1 4 6 3] [7 2 5 1 6 3 4] [7 2 5 1 3 6 4] [7 2 5 4 1 6 3] [7 2 5 4 6 1 3] [7 2 5 4 3 6 1] [7 2 5 6 1 3 4] [7 2 5 6 3 1 4] [7 2 5 3 1 6 4] [7 2 5 3 4 6 1] [7 2 5 3 6 1 4] [7 5 1 4 6 2 3] [7 5 1 4 3 6 2] [7 5 1 4 2 6 3] [7 5 1 6 3 2 4] [7 5 1 6 2 3 4] [7 5 1 3 4 6 2] [7 5 1 3 6 2 4] [7 5 1 3 2 6 4] [7 5 1 2 4 6 3] [7 5 1 2 6 3 4] [7 5 1 2 3 6 4] [7 5 4 1 6 2 3] [7 5 4 1 3 6 2] [7 5 4 1 2 6 3] [7 5 4 6 1 2 3] [7 5 4 6 2 1 3] [7 5 4 3 1 6 2] [7 5 4 3 6 1 2] [7 5 4 3 2 6 1] [7 5 4 2 1 6 3] [7 5 4 2 6 1 3] [7 5 4 2 3 6 1] [7 5 6 1 3 2 4] [7 5 6 1 2 3 4] [7 5 6 3 1 2 4] [7 5 6 3 2 1 4] [7 5 6 2 1 3 4] [7 5 6 2 3 1 4] [7 5 3 1 4 6 2] [7 5 3 1 6 2 4] [7 5 3 1 2 6 4] [7 5 3 4 1 6 2] [7 5 3 4 6 1 2] [7 5 3 4 2 6 1] [7 5 3 6 1 2 4] [7 5 3 6 2 1 4] [7 5 3 2 1 6 4] [7 5 3 2 4 6 1] [7 5 3 2 6 1 4] [7 5 2 1 4 6 3] [7 5 2 1 6 3 4] [7 5 2 1 3 6 4] [7 5 2 4 1 6 3] [7 5 2 4 6 1 3] [7 5 2 4 3 6 1] [7 5 2 6 1 3 4] [7 5 2 6 3 1 4] [7 5 2 3 1 6 4] [7 5 2 3 4 6 1] [7 5 2 3 6 1 4]], [1 5] [[7 1 4 6 5 3 2] [7 1 6 4 5 3 2] [7 1 6 3 5 4 2] [7 1 6 2 5 4 3] [7 1 6 5 4 2 3] [7 1 6 5 3 4 2] [7 1 6 5 2 4 3] [7 1 3 6 5 4 2] [7 1 2 6 5 4 3] [7 1 5 6 4 3 2] [7 4 1 6 5 3 2] [7 4 6 1 5 3 2] [7 4 6 3 5 2 1] [7 4 6 2 5 3 1] [7 4 6 5 1 3 2] [7 4 6 5 3 1 2] [7 4 6 5 2 3 1] [7 4 3 6 5 2 1] [7 4 2 6 5 3 1] [7 4 5 6 3 2 1] [7 6 1 4 5 3 2] [7 6 1 3 5 4 2] [7 6 1 2 5 4 3] [7 6 1 5 4 2 3] [7 6 1 5 3 4 2] [7 6 1 5 2 4 3] [7 6 4 1 5 3 2] [7 6 4 3 5 2 1] [7 6 4 2 5 3 1] [7 6 4 5 1 3 2] [7 6 4 5 3 1 2] [7 6 4 5 2 3 1] [7 6 3 1 5 4 2] [7 6 3 4 5 2 1] [7 6 3 2 5 4 1] [7 6 3 5 1 4 2] [7 6 3 5 4 1 2] [7 6 3 5 2 4 1] [7 6 2 1 5 4 3] [7 6 2 4 5 3 1] [7 6 2 3 5 4 1] [7 6 2 5 1 4 3] [7 6 2 5 4 1 3] [7 6 2 5 3 4 1] [7 6 5 1 4 2 3] [7 6 5 1 3 4 2] [7 6 5 1 2 4 3] [7 6 5 4 1 2 3] [7 6 5 4 2 1 3] [7 6 5 3 1 4 2] [7 6 5 3 4 1 2] [7 6 5 3 2 4 1] [7 6 5 2 1 4 3] [7 6 5 2 4 1 3] [7 6 5 2 3 4 1] [7 3 1 6 5 4 2] [7 3 4 6 5 2 1] [7 3 6 1 5 4 2] [7 3 6 4 5 2 1] [7 3 6 2 5 4 1] [7 3 6 5 1 4 2] [7 3 6 5 4 1 2] [7 3 6 5 2 4 1] [7 3 2 6 5 4 1] [7 3 5 6 4 2 1] [7 2 1 6 5 4 3] [7 2 4 6 5 3 1] [7 2 6 1 5 4 3] [7 2 6 4 5 3 1] [7 2 6 3 5 4 1] [7 2 6 5 1 4 3] [7 2 6 5 4 1 3] [7 2 6 5 3 4 1] [7 2 3 6 5 4 1] [7 2 5 6 4 3 1] [7 5 1 6 4 3 2] [7 5 4 6 3 2 1] [7 5 6 1 4 3 2] [7 5 6 4 1 3 2] [7 5 6 4 3 1 2] [7 5 6 4 2 3 1] [7 5 6 3 4 2 1] [7 5 6 2 4 3 1] [7 5 3 6 4 2 1] [7 5 2 6 4 3 1]], [1 7] [[7 6 5 4 3 2 1]], [5 1] [[1 4 3 2 5 6 7] [1 4 3 5 6 2 7] [1 4 3 5 2 6 7] [1 4 2 3 5 6 7] [1 4 2 5 6 3 7] [1 4 2 5 3 6 7] [1 4 5 6 3 2 7] [1 4 5 6 2 3 7] [1 4 5 3 6 2 7] [1 4 5 3 2 6 7] [1 4 5 2 6 3 7] [1 4 5 2 3 6 7] [1 3 4 6 2 5 7] [1 3 4 6 5 2 7] [1 3 4 2 6 5 7] [1 3 2 4 6 5 7] [1 3 2 5 4 6 7] [1 3 2 5 6 4 7] [1 3 5 4 6 2 7] [1 3 5 4 2 6 7] [1 3 5 6 4 2 7] [1 3 5 6 2 4 7] [1 3 5 2 4 6 7] [1 3 5 2 6 4 7] [1 2 4 6 3 5 7] [1 2 4 6 5 3 7] [1 2 4 3 6 5 7] [1 2 3 6 4 5 7] [1 2 3 6 5 4 7] [1 2 5 4 6 3 7] [1 2 5 4 3 6 7] [1 2 5 6 4 3 7] [1 2 5 6 3 4 7] [1 2 5 3 4 6 7] [1 2 5 3 6 4 7] [2 1 4 3 5 6 7] [2 1 4 5 6 3 7] [2 1 4 5 3 6 7] [2 1 3 4 6 5 7] [2 1 3 5 4 6 7] [2 1 3 5 6 4 7] [2 4 1 3 5 6 7] [2 4 1 5 6 3 7] [2 4 1 5 3 6 7] [2 4 3 1 5 6 7] [2 4 3 5 1 6 7] [2 4 3 5 6 1 7] [2 4 5 1 6 3 7] [2 4 5 1 3 6 7] [2 4 5 6 1 3 7] [2 4 5 6 3 1 7] [2 4 5 3 1 6 7] [2 4 5 3 6 1 7] [2 3 1 4 6 5 7] [2 3 1 5 4 6 7] [2 3 1 5 6 4 7] [2 3 4 1 6 5 7] [2 3 4 6 1 5 7] [2 3 4 6 5 1 7] [2 3 5 1 4 6 7] [2 3 5 1 6 4 7] [2 3 5 4 1 6 7] [2 3 5 4 6 1 7] [2 3 5 6 1 4 7] [2 3 5 6 4 1 7] [3 1 4 2 5 6 7] [3 1 4 5 6 2 7] [3 1 4 5 2 6 7] [3 1 2 4 5 6 7] [3 4 1 2 5 6 7] [3 4 1 5 6 2 7] [3 4 1 5 2 6 7] [3 4 2 1 5 6 7] [3 4 2 5 1 6 7] [3 4 2 5 6 1 7] [3 4 5 1 6 2 7] [3 4 5 1 2 6 7] [3 4 5 6 1 2 7] [3 4 5 6 2 1 7] [3 4 5 2 1 6 7] [3 4 5 2 6 1 7] [3 2 1 4 5 6 7] [3 2 4 1 5 6 7] [3 2 4 5 1 6 7] [3 2 4 5 6 1 7]], [6 1] [[1 3 4 2 5 6 7] [1 3 4 5 6 2 7] [1 3 4 5 2 6 7] [1 3 2 4 5 6 7] [1 2 4 3 5 6 7] [1 2 4 5 6 3 7] [1 2 4 5 3 6 7] [1 2 3 4 6 5 7] [1 2 3 5 4 6 7] [1 2 3 5 6 4 7] [2 1 3 4 5 6 7] [2 3 1 4 5 6 7] [2 3 4 1 5 6 7] [2 3 4 5 1 6 7] [2 3 4 5 6 1 7]], [2 4] [[1 7 4 6 3 5 2] [1 7 4 6 2 5 3] [1 7 4 6 5 2 3] [1 7 4 3 6 5 2] [1 7 4 2 6 5 3] [1 7 4 5 6 3 2] [1 7 6 4 3 5 2] [1 7 6 4 2 5 3] [1 7 6 4 5 2 3] [1 7 6 3 4 5 2] [1 7 6 3 2 5 4] [1 7 6 3 5 2 4] [1 7 6 2 4 5 3] [1 7 6 2 3 5 4] [1 7 6 2 5 3 4] [1 7 6 5 3 2 4] [1 7 6 5 2 3 4] [1 7 3 4 6 5 2] [1 7 3 6 4 5 2] [1 7 3 6 2 5 4] [1 7 3 6 5 2 4] [1 7 3 2 6 5 4] [1 7 3 5 6 4 2] [1 7 2 4 6 5 3] [1 7 2 6 4 5 3] [1 7 2 6 3 5 4] [1 7 2 6 5 3 4] [1 7 2 3 6 5 4] [1 7 2 5 6 4 3] [1 7 5 4 6 3 2] [1 7 5 6 4 2 3] [1 7 5 6 3 4 2] [1 7 5 6 2 4 3] [1 7 5 3 6 4 2] [1 7 5 2 6 4 3] [2 7 1 4 6 5 3] [2 7 1 6 4 5 3] [2 7 1 6 3 5 4] [2 7 1 6 5 3 4] [2 7 1 3 6 5 4] [2 7 1 5 6 4 3] [2 7 4 1 6 5 3] [2 7 4 6 1 5 3] [2 7 4 6 3 5 1] [2 7 4 6 5 1 3] [2 7 4 3 6 5 1] [2 7 4 5 6 3 1] [2 7 6 1 4 5 3] [2 7 6 1 3 5 4] [2 7 6 1 5 3 4] [2 7 6 4 1 5 3] [2 7 6 4 3 5 1] [2 7 6 4 5 1 3] [2 7 6 3 1 5 4] [2 7 6 3 4 5 1] [2 7 6 3 5 1 4] [2 7 6 5 1 3 4] [2 7 6 5 3 1 4] [2 7 3 1 6 5 4] [2 7 3 4 6 5 1] [2 7 3 6 1 5 4] [2 7 3 6 4 5 1] [2 7 3 6 5 1 4] [2 7 3 5 6 4 1] [2 7 5 1 6 4 3] [2 7 5 4 6 3 1] [2 7 5 6 1 4 3] [2 7 5 6 4 1 3] [2 7 5 6 3 4 1] [2 7 5 3 6 4 1] [2 1 7 4 6 5 3] [2 1 7 6 4 5 3] [2 1 7 6 3 5 4] [2 1 7 6 5 3 4] [2 1 7 3 6 5 4] [2 1 7 5 6 4 3] [3 7 1 4 6 5 2] [3 7 1 6 4 5 2] [3 7 1 6 2 5 4] [3 7 1 6 5 2 4] [3 7 1 2 6 5 4] [3 7 1 5 6 4 2] [3 7 4 1 6 5 2] [3 7 4 6 1 5 2] [3 7 4 6 2 5 1] [3 7 4 6 5 1 2] [3 7 4 2 6 5 1] [3 7 4 5 6 2 1] [3 7 6 1 4 5 2] [3 7 6 1 2 5 4] [3 7 6 1 5 2 4] [3 7 6 4 1 5 2] [3 7 6 4 2 5 1] [3 7 6 4 5 1 2] [3 7 6 2 1 5 4] [3 7 6 2 4 5 1] [3 7 6 2 5 1 4] [3 7 6 5 1 2 4] [3 7 6 5 2 1 4] [3 7 2 1 6 5 4] [3 7 2 4 6 5 1] [3 7 2 6 1 5 4] [3 7 2 6 4 5 1] [3 7 2 6 5 1 4] [3 7 2 5 6 4 1] [3 7 5 1 6 4 2] [3 7 5 4 6 2 1] [3 7 5 6 1 4 2] [3 7 5 6 4 1 2] [3 7 5 6 2 4 1] [3 7 5 2 6 4 1] [3 1 7 4 6 5 2] [3 1 7 6 4 5 2] [3 1 7 6 2 5 4] [3 1 7 6 5 2 4] [3 1 7 2 6 5 4] [3 1 7 5 6 4 2] [3 1 2 7 6 5 4] [3 2 7 1 6 5 4] [3 2 7 4 6 5 1] [3 2 7 6 1 5 4] [3 2 7 6 4 5 1] [3 2 7 6 5 1 4] [3 2 7 5 6 4 1] [3 2 1 7 6 5 4] [4 7 1 6 3 5 2] [4 7 1 6 2 5 3] [4 7 1 6 5 2 3] [4 7 1 3 6 5 2] [4 7 1 2 6 5 3] [4 7 1 5 6 3 2] [4 7 6 1 3 5 2] [4 7 6 1 2 5 3] [4 7 6 1 5 2 3] [4 7 6 3 1 5 2] [4 7 6 3 2 5 1] [4 7 6 3 5 1 2] [4 7 6 2 1 5 3] [4 7 6 2 3 5 1] [4 7 6 2 5 1 3] [4 7 6 5 1 2 3] [4 7 6 5 2 1 3] [4 7 3 1 6 5 2] [4 7 3 6 1 5 2] [4 7 3 6 2 5 1] [4 7 3 6 5 1 2] [4 7 3 2 6 5 1] [4 7 3 5 6 2 1] [4 7 2 1 6 5 3] [4 7 2 6 1 5 3] [4 7 2 6 3 5 1] [4 7 2 6 5 1 3] [4 7 2 3 6 5 1] [4 7 2 5 6 3 1] [4 7 5 1 6 3 2] [4 7 5 6 1 3 2] [4 7 5 6 3 1 2] [4 7 5 6 2 3 1] [4 7 5 3 6 2 1] [4 7 5 2 6 3 1] [4 1 7 6 3 5 2] [4 1 7 6 2 5 3] [4 1 7 6 5 2 3] [4 1 7 3 6 5 2] [4 1 7 2 6 5 3] [4 1 7 5 6 3 2] [4 1 3 7 6 5 2] [4 1 2 7 6 5 3] [4 3 7 1 6 5 2] [4 3 7 6 1 5 2] [4 3 7 6 2 5 1] [4 3 7 6 5 1 2] [4 3 7 2 6 5 1] [4 3 7 5 6 2 1] [4 3 1 7 6 5 2] [4 3 2 7 6 5 1] [4 2 7 1 6 5 3] [4 2 7 6 1 5 3] [4 2 7 6 3 5 1] [4 2 7 6 5 1 3] [4 2 7 3 6 5 1] [4 2 7 5 6 3 1] [4 2 1 7 6 5 3] [4 2 3 7 6 5 1] [5 7 1 4 6 3 2] [5 7 1 6 4 2 3] [5 7 1 6 3 4 2] [5 7 1 6 2 4 3] [5 7 1 3 6 4 2] [5 7 1 2 6 4 3] [5 7 4 1 6 3 2] [5 7 4 6 1 3 2] [5 7 4 6 3 1 2] [5 7 4 6 2 3 1] [5 7 4 3 6 2 1] [5 7 4 2 6 3 1] [5 7 6 1 4 2 3] [5 7 6 1 3 4 2] [5 7 6 1 2 4 3] [5 7 6 4 1 2 3] [5 7 6 4 2 1 3] [5 7 6 3 1 4 2] [5 7 6 3 4 1 2] [5 7 6 3 2 4 1] [5 7 6 2 1 4 3] [5 7 6 2 4 1 3] [5 7 6 2 3 4 1] [5 7 3 1 6 4 2] [5 7 3 4 6 2 1] [5 7 3 6 1 4 2] [5 7 3 6 4 1 2] [5 7 3 6 2 4 1] [5 7 3 2 6 4 1] [5 7 2 1 6 4 3] [5 7 2 4 6 3 1] [5 7 2 6 1 4 3] [5 7 2 6 4 1 3] [5 7 2 6 3 4 1] [5 7 2 3 6 4 1] [5 1 7 4 6 3 2] [5 1 7 6 4 2 3] [5 1 7 6 3 4 2] [5 1 7 6 2 4 3] [5 1 7 3 6 4 2] [5 1 7 2 6 4 3] [5 1 4 7 6 3 2] [5 1 3 7 6 4 2] [5 1 2 7 6 4 3] [5 4 7 1 6 3 2] [5 4 7 6 1 3 2] [5 4 7 6 3 1 2] [5 4 7 6 2 3 1] [5 4 7 3 6 2 1] [5 4 7 2 6 3 1] [5 4 1 7 6 3 2] [5 4 3 7 6 2 1] [5 4 2 7 6 3 1] [5 3 7 1 6 4 2] [5 3 7 4 6 2 1] [5 3 7 6 1 4 2] [5 3 7 6 4 1 2] [5 3 7 6 2 4 1] [5 3 7 2 6 4 1] [5 3 1 7 6 4 2] [5 3 4 7 6 2 1] [5 3 2 7 6 4 1] [5 2 7 1 6 4 3] [5 2 7 4 6 3 1] [5 2 7 6 1 4 3] [5 2 7 6 4 1 3] [5 2 7 6 3 4 1] [5 2 7 3 6 4 1] [5 2 1 7 6 4 3] [5 2 4 7 6 3 1] [5 2 3 7 6 4 1] [6 7 1 4 5 3 2] [6 7 1 3 5 4 2] [6 7 1 2 5 4 3] [6 7 1 5 4 2 3] [6 7 1 5 3 4 2] [6 7 1 5 2 4 3] [6 7 4 1 5 3 2] [6 7 4 3 5 2 1] [6 7 4 2 5 3 1] [6 7 4 5 1 3 2] [6 7 4 5 3 1 2] [6 7 4 5 2 3 1] [6 7 3 1 5 4 2] [6 7 3 4 5 2 1] [6 7 3 2 5 4 1] [6 7 3 5 1 4 2] [6 7 3 5 4 1 2] [6 7 3 5 2 4 1] [6 7 2 1 5 4 3] [6 7 2 4 5 3 1] [6 7 2 3 5 4 1] [6 7 2 5 1 4 3] [6 7 2 5 4 1 3] [6 7 2 5 3 4 1] [6 7 5 1 4 2 3] [6 7 5 1 3 4 2] [6 7 5 1 2 4 3] [6 7 5 4 1 2 3] [6 7 5 4 2 1 3] [6 7 5 3 1 4 2] [6 7 5 3 4 1 2] [6 7 5 3 2 4 1] [6 7 5 2 1 4 3] [6 7 5 2 4 1 3] [6 7 5 2 3 4 1] [6 1 7 4 5 3 2] [6 1 7 3 5 4 2] [6 1 7 2 5 4 3] [6 1 7 5 4 2 3] [6 1 7 5 3 4 2] [6 1 7 5 2 4 3] [6 1 4 7 5 3 2] [6 1 3 7 5 4 2] [6 1 2 7 5 4 3] [6 1 5 7 4 3 2] [6 4 7 1 5 3 2] [6 4 7 3 5 2 1] [6 4 7 2 5 3 1] [6 4 7 5 1 3 2] [6 4 7 5 3 1 2] [6 4 7 5 2 3 1] [6 4 1 7 5 3 2] [6 4 3 7 5 2 1] [6 4 2 7 5 3 1] [6 4 5 7 3 2 1] [6 3 7 1 5 4 2] [6 3 7 4 5 2 1] [6 3 7 2 5 4 1] [6 3 7 5 1 4 2] [6 3 7 5 4 1 2] [6 3 7 5 2 4 1] [6 3 1 7 5 4 2] [6 3 4 7 5 2 1] [6 3 2 7 5 4 1] [6 3 5 7 4 2 1] [6 2 7 1 5 4 3] [6 2 7 4 5 3 1] [6 2 7 3 5 4 1] [6 2 7 5 1 4 3] [6 2 7 5 4 1 3] [6 2 7 5 3 4 1] [6 2 1 7 5 4 3] [6 2 4 7 5 3 1] [6 2 3 7 5 4 1] [6 2 5 7 4 3 1] [6 5 7 1 4 3 2] [6 5 7 4 1 3 2] [6 5 7 4 3 1 2] [6 5 7 4 2 3 1] [6 5 7 3 4 2 1] [6 5 7 2 4 3 1] [6 5 1 7 4 3 2] [6 5 4 7 3 2 1] [6 5 3 7 4 2 1] [6 5 2 7 4 3 1]], [3 1] [[1 6 4 3 2 5 7] [1 6 4 3 5 2 7] [1 6 4 2 3 5 7] [1 6 4 2 5 3 7] [1 6 4 5 3 2 7] [1 6 4 5 2 3 7] [1 6 3 4 2 5 7] [1 6 3 4 5 2 7] [1 6 3 2 4 5 7] [1 6 3 2 5 4 7] [1 6 3 5 4 2 7] [1 6 3 5 2 4 7] [1 6 2 4 3 5 7] [1 6 2 4 5 3 7] [1 6 2 3 4 5 7] [1 6 2 3 5 4 7] [1 6 2 5 4 3 7] [1 6 2 5 3 4 7] [1 6 5 4 3 2 7] [1 6 5 4 2 3 7] [1 6 5 3 4 2 7] [1 6 5 3 2 4 7] [1 6 5 2 4 3 7] [1 6 5 2 3 4 7] [2 1 6 4 3 5 7] [2 1 6 4 5 3 7] [2 1 6 3 4 5 7] [2 1 6 3 5 4 7] [2 1 6 5 4 3 7] [2 1 6 5 3 4 7] [2 6 1 4 3 5 7] [2 6 1 4 5 3 7] [2 6 1 3 4 5 7] [2 6 1 3 5 4 7] [2 6 1 5 4 3 7] [2 6 1 5 3 4 7] [2 6 4 1 3 5 7] [2 6 4 1 5 3 7] [2 6 4 3 1 5 7] [2 6 4 3 5 1 7] [2 6 4 5 1 3 7] [2 6 4 5 3 1 7] [2 6 3 1 4 5 7] [2 6 3 1 5 4 7] [2 6 3 4 1 5 7] [2 6 3 4 5 1 7] [2 6 3 5 1 4 7] [2 6 3 5 4 1 7] [2 6 5 1 4 3 7] [2 6 5 1 3 4 7] [2 6 5 4 1 3 7] [2 6 5 4 3 1 7] [2 6 5 3 1 4 7] [2 6 5 3 4 1 7] [3 1 6 4 2 5 7] [3 1 6 4 5 2 7] [3 1 6 2 4 5 7] [3 1 6 2 5 4 7] [3 1 6 5 4 2 7] [3 1 6 5 2 4 7] [3 1 2 6 4 5 7] [3 1 2 6 5 4 7] [3 6 1 4 2 5 7] [3 6 1 4 5 2 7] [3 6 1 2 4 5 7] [3 6 1 2 5 4 7] [3 6 1 5 4 2 7] [3 6 1 5 2 4 7] [3 6 4 1 2 5 7] [3 6 4 1 5 2 7] [3 6 4 2 1 5 7] [3 6 4 2 5 1 7] [3 6 4 5 1 2 7] [3 6 4 5 2 1 7] [3 6 2 1 4 5 7] [3 6 2 1 5 4 7] [3 6 2 4 1 5 7] [3 6 2 4 5 1 7] [3 6 2 5 1 4 7] [3 6 2 5 4 1 7] [3 6 5 1 4 2 7] [3 6 5 1 2 4 7] [3 6 5 4 1 2 7] [3 6 5 4 2 1 7] [3 6 5 2 1 4 7] [3 6 5 2 4 1 7] [3 2 1 6 4 5 7] [3 2 1 6 5 4 7] [3 2 6 1 4 5 7] [3 2 6 1 5 4 7] [3 2 6 4 1 5 7] [3 2 6 4 5 1 7] [3 2 6 5 1 4 7] [3 2 6 5 4 1 7] [4 1 6 3 2 5 7] [4 1 6 3 5 2 7] [4 1 6 2 3 5 7] [4 1 6 2 5 3 7] [4 1 6 5 3 2 7] [4 1 6 5 2 3 7] [4 1 3 6 2 5 7] [4 1 3 6 5 2 7] [4 1 3 2 6 5 7] [4 1 2 6 3 5 7] [4 1 2 6 5 3 7] [4 1 2 3 6 5 7] [4 6 1 3 2 5 7] [4 6 1 3 5 2 7] [4 6 1 2 3 5 7] [4 6 1 2 5 3 7] [4 6 1 5 3 2 7] [4 6 1 5 2 3 7] [4 6 3 1 2 5 7] [4 6 3 1 5 2 7] [4 6 3 2 1 5 7] [4 6 3 2 5 1 7] [4 6 3 5 1 2 7] [4 6 3 5 2 1 7] [4 6 2 1 3 5 7] [4 6 2 1 5 3 7] [4 6 2 3 1 5 7] [4 6 2 3 5 1 7] [4 6 2 5 1 3 7] [4 6 2 5 3 1 7] [4 6 5 1 3 2 7] [4 6 5 1 2 3 7] [4 6 5 3 1 2 7] [4 6 5 3 2 1 7] [4 6 5 2 1 3 7] [4 6 5 2 3 1 7] [4 3 1 6 2 5 7] [4 3 1 6 5 2 7] [4 3 1 2 6 5 7] [4 3 6 1 2 5 7] [4 3 6 1 5 2 7] [4 3 6 2 1 5 7] [4 3 6 2 5 1 7] [4 3 6 5 1 2 7] [4 3 6 5 2 1 7] [4 3 2 1 6 5 7] [4 3 2 6 1 5 7] [4 3 2 6 5 1 7] [4 2 1 6 3 5 7] [4 2 1 6 5 3 7] [4 2 1 3 6 5 7] [4 2 6 1 3 5 7] [4 2 6 1 5 3 7] [4 2 6 3 1 5 7] [4 2 6 3 5 1 7] [4 2 6 5 1 3 7] [4 2 6 5 3 1 7] [4 2 3 1 6 5 7] [4 2 3 6 1 5 7] [4 2 3 6 5 1 7] [5 1 4 6 3 2 7] [5 1 4 6 2 3 7] [5 1 4 3 6 2 7] [5 1 4 3 2 6 7] [5 1 4 2 6 3 7] [5 1 4 2 3 6 7] [5 1 6 4 3 2 7] [5 1 6 4 2 3 7] [5 1 6 3 4 2 7] [5 1 6 3 2 4 7] [5 1 6 2 4 3 7] [5 1 6 2 3 4 7] [5 1 3 4 6 2 7] [5 1 3 4 2 6 7] [5 1 3 6 4 2 7] [5 1 3 6 2 4 7] [5 1 3 2 4 6 7] [5 1 3 2 6 4 7] [5 1 2 4 6 3 7] [5 1 2 4 3 6 7] [5 1 2 6 4 3 7] [5 1 2 6 3 4 7] [5 1 2 3 4 6 7] [5 1 2 3 6 4 7] [5 4 1 6 3 2 7] [5 4 1 6 2 3 7] [5 4 1 3 6 2 7] [5 4 1 3 2 6 7] [5 4 1 2 6 3 7] [5 4 1 2 3 6 7] [5 4 6 1 3 2 7] [5 4 6 1 2 3 7] [5 4 6 3 1 2 7] [5 4 6 3 2 1 7] [5 4 6 2 1 3 7] [5 4 6 2 3 1 7] [5 4 3 1 6 2 7] [5 4 3 1 2 6 7] [5 4 3 6 1 2 7] [5 4 3 6 2 1 7] [5 4 3 2 1 6 7] [5 4 3 2 6 1 7] [5 4 2 1 6 3 7] [5 4 2 1 3 6 7] [5 4 2 6 1 3 7] [5 4 2 6 3 1 7] [5 4 2 3 1 6 7] [5 4 2 3 6 1 7] [5 6 1 4 3 2 7] [5 6 1 4 2 3 7] [5 6 1 3 4 2 7] [5 6 1 3 2 4 7] [5 6 1 2 4 3 7] [5 6 1 2 3 4 7] [5 6 4 1 3 2 7] [5 6 4 1 2 3 7] [5 6 4 3 1 2 7] [5 6 4 3 2 1 7] [5 6 4 2 1 3 7] [5 6 4 2 3 1 7] [5 6 3 1 4 2 7] [5 6 3 1 2 4 7] [5 6 3 4 1 2 7] [5 6 3 4 2 1 7] [5 6 3 2 1 4 7] [5 6 3 2 4 1 7] [5 6 2 1 4 3 7] [5 6 2 1 3 4 7] [5 6 2 4 1 3 7] [5 6 2 4 3 1 7] [5 6 2 3 1 4 7] [5 6 2 3 4 1 7] [5 3 1 4 6 2 7] [5 3 1 4 2 6 7] [5 3 1 6 4 2 7] [5 3 1 6 2 4 7] [5 3 1 2 4 6 7] [5 3 1 2 6 4 7] [5 3 4 1 6 2 7] [5 3 4 1 2 6 7] [5 3 4 6 1 2 7] [5 3 4 6 2 1 7] [5 3 4 2 1 6 7] [5 3 4 2 6 1 7] [5 3 6 1 4 2 7] [5 3 6 1 2 4 7] [5 3 6 4 1 2 7] [5 3 6 4 2 1 7] [5 3 6 2 1 4 7] [5 3 6 2 4 1 7] [5 3 2 1 4 6 7] [5 3 2 1 6 4 7] [5 3 2 4 1 6 7] [5 3 2 4 6 1 7] [5 3 2 6 1 4 7] [5 3 2 6 4 1 7] [5 2 1 4 6 3 7] [5 2 1 4 3 6 7] [5 2 1 6 4 3 7] [5 2 1 6 3 4 7] [5 2 1 3 4 6 7] [5 2 1 3 6 4 7] [5 2 4 1 6 3 7] [5 2 4 1 3 6 7] [5 2 4 6 1 3 7] [5 2 4 6 3 1 7] [5 2 4 3 1 6 7] [5 2 4 3 6 1 7] [5 2 6 1 4 3 7] [5 2 6 1 3 4 7] [5 2 6 4 1 3 7] [5 2 6 4 3 1 7] [5 2 6 3 1 4 7] [5 2 6 3 4 1 7] [5 2 3 1 4 6 7] [5 2 3 1 6 4 7] [5 2 3 4 1 6 7] [5 2 3 4 6 1 7] [5 2 3 6 1 4 7] [5 2 3 6 4 1 7]], [2 1] [[6 1 4 3 2 5 7] [6 1 4 3 5 2 7] [6 1 4 2 3 5 7] [6 1 4 2 5 3 7] [6 1 4 5 3 2 7] [6 1 4 5 2 3 7] [6 1 3 4 2 5 7] [6 1 3 4 5 2 7] [6 1 3 2 4 5 7] [6 1 3 2 5 4 7] [6 1 3 5 4 2 7] [6 1 3 5 2 4 7] [6 1 2 4 3 5 7] [6 1 2 4 5 3 7] [6 1 2 3 4 5 7] [6 1 2 3 5 4 7] [6 1 2 5 4 3 7] [6 1 2 5 3 4 7] [6 1 5 4 3 2 7] [6 1 5 4 2 3 7] [6 1 5 3 4 2 7] [6 1 5 3 2 4 7] [6 1 5 2 4 3 7] [6 1 5 2 3 4 7] [6 4 1 3 2 5 7] [6 4 1 3 5 2 7] [6 4 1 2 3 5 7] [6 4 1 2 5 3 7] [6 4 1 5 3 2 7] [6 4 1 5 2 3 7] [6 4 3 1 2 5 7] [6 4 3 1 5 2 7] [6 4 3 2 1 5 7] [6 4 3 2 5 1 7] [6 4 3 5 1 2 7] [6 4 3 5 2 1 7] [6 4 2 1 3 5 7] [6 4 2 1 5 3 7] [6 4 2 3 1 5 7] [6 4 2 3 5 1 7] [6 4 2 5 1 3 7] [6 4 2 5 3 1 7] [6 4 5 1 3 2 7] [6 4 5 1 2 3 7] [6 4 5 3 1 2 7] [6 4 5 3 2 1 7] [6 4 5 2 1 3 7] [6 4 5 2 3 1 7] [6 3 1 4 2 5 7] [6 3 1 4 5 2 7] [6 3 1 2 4 5 7] [6 3 1 2 5 4 7] [6 3 1 5 4 2 7] [6 3 1 5 2 4 7] [6 3 4 1 2 5 7] [6 3 4 1 5 2 7] [6 3 4 2 1 5 7] [6 3 4 2 5 1 7] [6 3 4 5 1 2 7] [6 3 4 5 2 1 7] [6 3 2 1 4 5 7] [6 3 2 1 5 4 7] [6 3 2 4 1 5 7] [6 3 2 4 5 1 7] [6 3 2 5 1 4 7] [6 3 2 5 4 1 7] [6 3 5 1 4 2 7] [6 3 5 1 2 4 7] [6 3 5 4 1 2 7] [6 3 5 4 2 1 7] [6 3 5 2 1 4 7] [6 3 5 2 4 1 7] [6 2 1 4 3 5 7] [6 2 1 4 5 3 7] [6 2 1 3 4 5 7] [6 2 1 3 5 4 7] [6 2 1 5 4 3 7] [6 2 1 5 3 4 7] [6 2 4 1 3 5 7] [6 2 4 1 5 3 7] [6 2 4 3 1 5 7] [6 2 4 3 5 1 7] [6 2 4 5 1 3 7] [6 2 4 5 3 1 7] [6 2 3 1 4 5 7] [6 2 3 1 5 4 7] [6 2 3 4 1 5 7] [6 2 3 4 5 1 7] [6 2 3 5 1 4 7] [6 2 3 5 4 1 7] [6 2 5 1 4 3 7] [6 2 5 1 3 4 7] [6 2 5 4 1 3 7] [6 2 5 4 3 1 7] [6 2 5 3 1 4 7] [6 2 5 3 4 1 7] [6 5 1 4 3 2 7] [6 5 1 4 2 3 7] [6 5 1 3 4 2 7] [6 5 1 3 2 4 7] [6 5 1 2 4 3 7] [6 5 1 2 3 4 7] [6 5 4 1 3 2 7] [6 5 4 1 2 3 7] [6 5 4 3 1 2 7] [6 5 4 3 2 1 7] [6 5 4 2 1 3 7] [6 5 4 2 3 1 7] [6 5 3 1 4 2 7] [6 5 3 1 2 4 7] [6 5 3 4 1 2 7] [6 5 3 4 2 1 7] [6 5 3 2 1 4 7] [6 5 3 2 4 1 7] [6 5 2 1 4 3 7] [6 5 2 1 3 4 7] [6 5 2 4 1 3 7] [6 5 2 4 3 1 7] [6 5 2 3 1 4 7] [6 5 2 3 4 1 7]], [1 6] [[7 1 6 5 4 3 2] [7 4 6 5 3 2 1] [7 6 1 5 4 3 2] [7 6 4 5 3 2 1] [7 6 3 5 4 2 1] [7 6 2 5 4 3 1] [7 6 5 1 4 3 2] [7 6 5 4 1 3 2] [7 6 5 4 3 1 2] [7 6 5 4 2 3 1] [7 6 5 3 4 2 1] [7 6 5 2 4 3 1] [7 3 6 5 4 2 1] [7 2 6 5 4 3 1] [7 5 6 4 3 2 1]], [4 4] [[1 4 6 7 5 3 2] [1 4 5 7 6 3 2] [1 3 4 7 6 5 2] [1 3 6 7 5 4 2] [1 3 5 7 6 4 2] [1 2 4 7 6 5 3] [1 2 6 7 5 4 3] [1 2 3 7 6 5 4] [1 2 5 7 6 4 3] [1 5 6 7 4 3 2] [2 4 6 7 5 3 1] [2 4 5 7 6 3 1] [2 3 4 7 6 5 1] [2 3 6 7 5 4 1] [2 3 5 7 6 4 1] [2 5 6 7 4 3 1] [3 4 6 7 5 2 1] [3 4 5 7 6 2 1] [3 5 6 7 4 2 1] [4 5 6 7 3 2 1]], [2 6] [[1 7 6 5 4 3 2] [2 7 6 5 4 3 1] [3 7 6 5 4 2 1] [4 7 6 5 3 2 1] [5 7 6 4 3 2 1] [6 7 5 4 3 2 1]], [6 2] [[1 3 4 5 6 7 2] [1 2 4 5 6 7 3] [1 2 3 4 6 7 5] [1 2 3 4 5 7 6] [1 2 3 5 6 7 4] [2 3 4 5 6 7 1]], [1 2] [[7 1 4 3 2 5 6] [7 1 4 3 5 2 6] [7 1 4 2 3 5 6] [7 1 4 2 5 3 6] [7 1 4 5 3 2 6] [7 1 4 5 2 3 6] [7 1 3 4 2 5 6] [7 1 3 4 5 2 6] [7 1 3 2 4 5 6] [7 1 3 2 5 4 6] [7 1 3 5 4 2 6] [7 1 3 5 2 4 6] [7 1 2 4 3 5 6] [7 1 2 4 5 3 6] [7 1 2 3 4 5 6] [7 1 2 3 5 4 6] [7 1 2 5 4 3 6] [7 1 2 5 3 4 6] [7 1 5 4 3 2 6] [7 1 5 4 2 3 6] [7 1 5 3 4 2 6] [7 1 5 3 2 4 6] [7 1 5 2 4 3 6] [7 1 5 2 3 4 6] [7 4 1 3 2 5 6] [7 4 1 3 5 2 6] [7 4 1 2 3 5 6] [7 4 1 2 5 3 6] [7 4 1 5 3 2 6] [7 4 1 5 2 3 6] [7 4 3 1 2 5 6] [7 4 3 1 5 2 6] [7 4 3 2 1 5 6] [7 4 3 2 5 1 6] [7 4 3 5 1 2 6] [7 4 3 5 2 1 6] [7 4 2 1 3 5 6] [7 4 2 1 5 3 6] [7 4 2 3 1 5 6] [7 4 2 3 5 1 6] [7 4 2 5 1 3 6] [7 4 2 5 3 1 6] [7 4 5 1 3 2 6] [7 4 5 1 2 3 6] [7 4 5 3 1 2 6] [7 4 5 3 2 1 6] [7 4 5 2 1 3 6] [7 4 5 2 3 1 6] [7 3 1 4 2 5 6] [7 3 1 4 5 2 6] [7 3 1 2 4 5 6] [7 3 1 2 5 4 6] [7 3 1 5 4 2 6] [7 3 1 5 2 4 6] [7 3 4 1 2 5 6] [7 3 4 1 5 2 6] [7 3 4 2 1 5 6] [7 3 4 2 5 1 6] [7 3 4 5 1 2 6] [7 3 4 5 2 1 6] [7 3 2 1 4 5 6] [7 3 2 1 5 4 6] [7 3 2 4 1 5 6] [7 3 2 4 5 1 6] [7 3 2 5 1 4 6] [7 3 2 5 4 1 6] [7 3 5 1 4 2 6] [7 3 5 1 2 4 6] [7 3 5 4 1 2 6] [7 3 5 4 2 1 6] [7 3 5 2 1 4 6] [7 3 5 2 4 1 6] [7 2 1 4 3 5 6] [7 2 1 4 5 3 6] [7 2 1 3 4 5 6] [7 2 1 3 5 4 6] [7 2 1 5 4 3 6] [7 2 1 5 3 4 6] [7 2 4 1 3 5 6] [7 2 4 1 5 3 6] [7 2 4 3 1 5 6] [7 2 4 3 5 1 6] [7 2 4 5 1 3 6] [7 2 4 5 3 1 6] [7 2 3 1 4 5 6] [7 2 3 1 5 4 6] [7 2 3 4 1 5 6] [7 2 3 4 5 1 6] [7 2 3 5 1 4 6] [7 2 3 5 4 1 6] [7 2 5 1 4 3 6] [7 2 5 1 3 4 6] [7 2 5 4 1 3 6] [7 2 5 4 3 1 6] [7 2 5 3 1 4 6] [7 2 5 3 4 1 6] [7 5 1 4 3 2 6] [7 5 1 4 2 3 6] [7 5 1 3 4 2 6] [7 5 1 3 2 4 6] [7 5 1 2 4 3 6] [7 5 1 2 3 4 6] [7 5 4 1 3 2 6] [7 5 4 1 2 3 6] [7 5 4 3 1 2 6] [7 5 4 3 2 1 6] [7 5 4 2 1 3 6] [7 5 4 2 3 1 6] [7 5 3 1 4 2 6] [7 5 3 1 2 4 6] [7 5 3 4 1 2 6] [7 5 3 4 2 1 6] [7 5 3 2 1 4 6] [7 5 3 2 4 1 6] [7 5 2 1 4 3 6] [7 5 2 1 3 4 6] [7 5 2 4 1 3 6] [7 5 2 4 3 1 6] [7 5 2 3 1 4 6] [7 5 2 3 4 1 6]], [3 5] [[1 4 7 6 5 3 2] [1 6 7 5 4 3 2] [1 3 7 6 5 4 2] [1 2 7 6 5 4 3] [1 5 7 6 4 3 2] [2 4 7 6 5 3 1] [2 6 7 5 4 3 1] [2 3 7 6 5 4 1] [2 5 7 6 4 3 1] [3 4 7 6 5 2 1] [3 6 7 5 4 2 1] [3 5 7 6 4 2 1] [4 6 7 5 3 2 1] [4 5 7 6 3 2 1] [5 6 7 4 3 2 1]], [3 2] [[1 4 7 3 2 5 6] [1 4 7 3 5 2 6] [1 4 7 2 3 5 6] [1 4 7 2 5 3 6] [1 4 7 5 3 2 6] [1 4 7 5 2 3 6] [1 4 3 7 2 5 6] [1 4 3 7 5 2 6] [1 4 3 2 7 5 6] [1 4 2 7 3 5 6] [1 4 2 7 5 3 6] [1 4 2 3 7 5 6] [1 6 7 4 3 2 5] [1 6 7 4 2 3 5] [1 6 7 3 4 2 5] [1 6 7 3 2 4 5] [1 6 7 2 4 3 5] [1 6 7 2 3 4 5] [1 6 4 7 3 2 5] [1 6 4 7 2 3 5] [1 6 4 3 7 2 5] [1 6 4 3 2 7 5] [1 6 4 3 5 7 2] [1 6 4 2 7 3 5] [1 6 4 2 3 7 5] [1 6 4 2 5 7 3] [1 6 4 5 7 2 3] [1 6 4 5 3 7 2] [1 6 4 5 2 7 3] [1 6 3 7 4 2 5] [1 6 3 7 2 4 5] [1 6 3 4 7 2 5] [1 6 3 4 2 7 5] [1 6 3 4 5 7 2] [1 6 3 2 7 4 5] [1 6 3 2 4 7 5] [1 6 3 2 5 7 4] [1 6 3 5 7 2 4] [1 6 3 5 4 7 2] [1 6 3 5 2 7 4] [1 6 2 7 4 3 5] [1 6 2 7 3 4 5] [1 6 2 4 7 3 5] [1 6 2 4 3 7 5] [1 6 2 4 5 7 3] [1 6 2 3 7 4 5] [1 6 2 3 4 7 5] [1 6 2 3 5 7 4] [1 6 2 5 7 3 4] [1 6 2 5 4 7 3] [1 6 2 5 3 7 4] [1 6 5 7 3 2 4] [1 6 5 7 2 3 4] [1 6 5 4 7 2 3] [1 6 5 4 3 7 2] [1 6 5 4 2 7 3] [1 6 5 3 7 2 4] [1 6 5 3 4 7 2] [1 6 5 3 2 7 4] [1 6 5 2 7 3 4] [1 6 5 2 4 7 3] [1 6 5 2 3 7 4] [1 3 7 4 2 5 6] [1 3 7 4 5 2 6] [1 3 7 2 4 5 6] [1 3 7 2 5 4 6] [1 3 7 5 4 2 6] [1 3 7 5 2 4 6] [1 3 2 7 4 5 6] [1 3 2 7 5 4 6] [1 2 7 4 3 5 6] [1 2 7 4 5 3 6] [1 2 7 3 4 5 6] [1 2 7 3 5 4 6] [1 2 7 5 4 3 6] [1 2 7 5 3 4 6] [1 5 7 4 3 2 6] [1 5 7 4 2 3 6] [1 5 7 3 4 2 6] [1 5 7 3 2 4 6] [1 5 7 2 4 3 6] [1 5 7 2 3 4 6] [1 5 4 7 3 2 6] [1 5 4 7 2 3 6] [1 5 4 3 7 2 6] [1 5 4 3 2 7 6] [1 5 4 2 7 3 6] [1 5 4 2 3 7 6] [1 5 3 7 4 2 6] [1 5 3 7 2 4 6] [1 5 3 4 7 2 6] [1 5 3 4 2 7 6] [1 5 3 2 7 4 6] [1 5 3 2 4 7 6] [1 5 2 7 4 3 6] [1 5 2 7 3 4 6] [1 5 2 4 7 3 6] [1 5 2 4 3 7 6] [1 5 2 3 7 4 6] [1 5 2 3 4 7 6] [2 1 4 7 3 5 6] [2 1 4 7 5 3 6] [2 1 4 3 7 5 6] [2 1 6 7 4 3 5] [2 1 6 7 3 4 5] [2 1 6 4 7 3 5] [2 1 6 4 3 7 5] [2 1 6 4 5 7 3] [2 1 6 3 7 4 5] [2 1 6 3 4 7 5] [2 1 6 3 5 7 4] [2 1 6 5 7 3 4] [2 1 6 5 4 7 3] [2 1 6 5 3 7 4] [2 1 3 7 4 5 6] [2 1 3 7 5 4 6] [2 1 5 7 4 3 6] [2 1 5 7 3 4 6] [2 1 5 4 7 3 6] [2 1 5 4 3 7 6] [2 1 5 3 7 4 6] [2 1 5 3 4 7 6] [2 4 7 1 3 5 6] [2 4 7 1 5 3 6] [2 4 7 3 1 5 6] [2 4 7 3 5 1 6] [2 4 7 5 1 3 6] [2 4 7 5 3 1 6] [2 4 1 7 3 5 6] [2 4 1 7 5 3 6] [2 4 1 3 7 5 6] [2 4 3 7 1 5 6] [2 4 3 7 5 1 6] [2 4 3 1 7 5 6] [2 6 7 1 4 3 5] [2 6 7 1 3 4 5] [2 6 7 4 1 3 5] [2 6 7 4 3 1 5] [2 6 7 3 1 4 5] [2 6 7 3 4 1 5] [2 6 1 7 4 3 5] [2 6 1 7 3 4 5] [2 6 1 4 7 3 5] [2 6 1 4 3 7 5] [2 6 1 4 5 7 3] [2 6 1 3 7 4 5] [2 6 1 3 4 7 5] [2 6 1 3 5 7 4] [2 6 1 5 7 3 4] [2 6 1 5 4 7 3] [2 6 1 5 3 7 4] [2 6 4 7 1 3 5] [2 6 4 7 3 1 5] [2 6 4 1 7 3 5] [2 6 4 1 3 7 5] [2 6 4 1 5 7 3] [2 6 4 3 7 1 5] [2 6 4 3 1 7 5] [2 6 4 3 5 7 1] [2 6 4 5 7 1 3] [2 6 4 5 1 7 3] [2 6 4 5 3 7 1] [2 6 3 7 1 4 5] [2 6 3 7 4 1 5] [2 6 3 1 7 4 5] [2 6 3 1 4 7 5] [2 6 3 1 5 7 4] [2 6 3 4 7 1 5] [2 6 3 4 1 7 5] [2 6 3 4 5 7 1] [2 6 3 5 7 1 4] [2 6 3 5 1 7 4] [2 6 3 5 4 7 1] [2 6 5 7 1 3 4] [2 6 5 7 3 1 4] [2 6 5 1 7 3 4] [2 6 5 1 4 7 3] [2 6 5 1 3 7 4] [2 6 5 4 7 1 3] [2 6 5 4 1 7 3] [2 6 5 4 3 7 1] [2 6 5 3 7 1 4] [2 6 5 3 1 7 4] [2 6 5 3 4 7 1] [2 3 7 1 4 5 6] [2 3 7 1 5 4 6] [2 3 7 4 1 5 6] [2 3 7 4 5 1 6] [2 3 7 5 1 4 6] [2 3 7 5 4 1 6] [2 3 1 7 4 5 6] [2 3 1 7 5 4 6] [2 5 7 1 4 3 6] [2 5 7 1 3 4 6] [2 5 7 4 1 3 6] [2 5 7 4 3 1 6] [2 5 7 3 1 4 6] [2 5 7 3 4 1 6] [2 5 1 7 4 3 6] [2 5 1 7 3 4 6] [2 5 1 4 7 3 6] [2 5 1 4 3 7 6] [2 5 1 3 7 4 6] [2 5 1 3 4 7 6] [2 5 4 7 1 3 6] [2 5 4 7 3 1 6] [2 5 4 1 7 3 6] [2 5 4 1 3 7 6] [2 5 4 3 7 1 6] [2 5 4 3 1 7 6] [2 5 3 7 1 4 6] [2 5 3 7 4 1 6] [2 5 3 1 7 4 6] [2 5 3 1 4 7 6] [2 5 3 4 7 1 6] [2 5 3 4 1 7 6] [3 1 4 7 2 5 6] [3 1 4 7 5 2 6] [3 1 4 2 7 5 6] [3 1 6 7 4 2 5] [3 1 6 7 2 4 5] [3 1 6 4 7 2 5] [3 1 6 4 2 7 5] [3 1 6 4 5 7 2] [3 1 6 2 7 4 5] [3 1 6 2 4 7 5] [3 1 6 2 5 7 4] [3 1 6 5 7 2 4] [3 1 6 5 4 7 2] [3 1 6 5 2 7 4] [3 1 2 4 7 5 6] [3 1 2 6 7 4 5] [3 1 2 6 4 7 5] [3 1 2 6 5 7 4] [3 1 2 5 7 4 6] [3 1 2 5 4 7 6] [3 1 5 7 4 2 6] [3 1 5 7 2 4 6] [3 1 5 4 7 2 6] [3 1 5 4 2 7 6] [3 1 5 2 7 4 6] [3 1 5 2 4 7 6] [3 4 7 1 2 5 6] [3 4 7 1 5 2 6] [3 4 7 2 1 5 6] [3 4 7 2 5 1 6] [3 4 7 5 1 2 6] [3 4 7 5 2 1 6] [3 4 1 7 2 5 6] [3 4 1 7 5 2 6] [3 4 1 2 7 5 6] [3 4 2 7 1 5 6] [3 4 2 7 5 1 6] [3 4 2 1 7 5 6] [3 6 7 1 4 2 5] [3 6 7 1 2 4 5] [3 6 7 4 1 2 5] [3 6 7 4 2 1 5] [3 6 7 2 1 4 5] [3 6 7 2 4 1 5] [3 6 1 7 4 2 5] [3 6 1 7 2 4 5] [3 6 1 4 7 2 5] [3 6 1 4 2 7 5] [3 6 1 4 5 7 2] [3 6 1 2 7 4 5] [3 6 1 2 4 7 5] [3 6 1 2 5 7 4] [3 6 1 5 7 2 4] [3 6 1 5 4 7 2] [3 6 1 5 2 7 4] [3 6 4 7 1 2 5] [3 6 4 7 2 1 5] [3 6 4 1 7 2 5] [3 6 4 1 2 7 5] [3 6 4 1 5 7 2] [3 6 4 2 7 1 5] [3 6 4 2 1 7 5] [3 6 4 2 5 7 1] [3 6 4 5 7 1 2] [3 6 4 5 1 7 2] [3 6 4 5 2 7 1] [3 6 2 7 1 4 5] [3 6 2 7 4 1 5] [3 6 2 1 7 4 5] [3 6 2 1 4 7 5] [3 6 2 1 5 7 4] [3 6 2 4 7 1 5] [3 6 2 4 1 7 5] [3 6 2 4 5 7 1] [3 6 2 5 7 1 4] [3 6 2 5 1 7 4] [3 6 2 5 4 7 1] [3 6 5 7 1 2 4] [3 6 5 7 2 1 4] [3 6 5 1 7 2 4] [3 6 5 1 4 7 2] [3 6 5 1 2 7 4] [3 6 5 4 7 1 2] [3 6 5 4 1 7 2] [3 6 5 4 2 7 1] [3 6 5 2 7 1 4] [3 6 5 2 1 7 4] [3 6 5 2 4 7 1] [3 2 1 4 7 5 6] [3 2 1 6 7 4 5] [3 2 1 6 4 7 5] [3 2 1 6 5 7 4] [3 2 1 5 7 4 6] [3 2 1 5 4 7 6] [3 2 4 7 1 5 6] [3 2 4 7 5 1 6] [3 2 4 1 7 5 6] [3 2 6 7 1 4 5] [3 2 6 7 4 1 5] [3 2 6 1 7 4 5] [3 2 6 1 4 7 5] [3 2 6 1 5 7 4] [3 2 6 4 7 1 5] [3 2 6 4 1 7 5] [3 2 6 4 5 7 1] [3 2 6 5 7 1 4] [3 2 6 5 1 7 4] [3 2 6 5 4 7 1] [3 2 5 7 1 4 6] [3 2 5 7 4 1 6] [3 2 5 1 7 4 6] [3 2 5 1 4 7 6] [3 2 5 4 7 1 6] [3 2 5 4 1 7 6] [3 5 7 1 4 2 6] [3 5 7 1 2 4 6] [3 5 7 4 1 2 6] [3 5 7 4 2 1 6] [3 5 7 2 1 4 6] [3 5 7 2 4 1 6] [3 5 1 7 4 2 6] [3 5 1 7 2 4 6] [3 5 1 4 7 2 6] [3 5 1 4 2 7 6] [3 5 1 2 7 4 6] [3 5 1 2 4 7 6] [3 5 4 7 1 2 6] [3 5 4 7 2 1 6] [3 5 4 1 7 2 6] [3 5 4 1 2 7 6] [3 5 4 2 7 1 6] [3 5 4 2 1 7 6] [3 5 2 7 1 4 6] [3 5 2 7 4 1 6] [3 5 2 1 7 4 6] [3 5 2 1 4 7 6] [3 5 2 4 7 1 6] [3 5 2 4 1 7 6] [4 1 6 7 3 2 5] [4 1 6 7 2 3 5] [4 1 6 3 7 2 5] [4 1 6 3 2 7 5] [4 1 6 3 5 7 2] [4 1 6 2 7 3 5] [4 1 6 2 3 7 5] [4 1 6 2 5 7 3] [4 1 6 5 7 2 3] [4 1 6 5 3 7 2] [4 1 6 5 2 7 3] [4 1 3 6 7 2 5] [4 1 3 6 2 7 5] [4 1 3 6 5 7 2] [4 1 3 2 6 7 5] [4 1 3 2 5 7 6] [4 1 3 5 7 2 6] [4 1 3 5 2 7 6] [4 1 2 6 7 3 5] [4 1 2 6 3 7 5] [4 1 2 6 5 7 3] [4 1 2 3 6 7 5] [4 1 2 3 5 7 6] [4 1 2 5 7 3 6] [4 1 2 5 3 7 6] [4 1 5 7 3 2 6] [4 1 5 7 2 3 6] [4 1 5 3 7 2 6] [4 1 5 3 2 7 6] [4 1 5 2 7 3 6] [4 1 5 2 3 7 6] [4 6 7 1 3 2 5] [4 6 7 1 2 3 5] [4 6 7 3 1 2 5] [4 6 7 3 2 1 5] [4 6 7 2 1 3 5] [4 6 7 2 3 1 5] [4 6 1 7 3 2 5] [4 6 1 7 2 3 5] [4 6 1 3 7 2 5] [4 6 1 3 2 7 5] [4 6 1 3 5 7 2] [4 6 1 2 7 3 5] [4 6 1 2 3 7 5] [4 6 1 2 5 7 3] [4 6 1 5 7 2 3] [4 6 1 5 3 7 2] [4 6 1 5 2 7 3] [4 6 3 7 1 2 5] [4 6 3 7 2 1 5] [4 6 3 1 7 2 5] [4 6 3 1 2 7 5] [4 6 3 1 5 7 2] [4 6 3 2 7 1 5] [4 6 3 2 1 7 5] [4 6 3 2 5 7 1] [4 6 3 5 7 1 2] [4 6 3 5 1 7 2] [4 6 3 5 2 7 1] [4 6 2 7 1 3 5] [4 6 2 7 3 1 5] [4 6 2 1 7 3 5] [4 6 2 1 3 7 5] [4 6 2 1 5 7 3] [4 6 2 3 7 1 5] [4 6 2 3 1 7 5] [4 6 2 3 5 7 1] [4 6 2 5 7 1 3] [4 6 2 5 1 7 3] [4 6 2 5 3 7 1] [4 6 5 7 1 2 3] [4 6 5 7 2 1 3] [4 6 5 1 7 2 3] [4 6 5 1 3 7 2] [4 6 5 1 2 7 3] [4 6 5 3 7 1 2] [4 6 5 3 1 7 2] [4 6 5 3 2 7 1] [4 6 5 2 7 1 3] [4 6 5 2 1 7 3] [4 6 5 2 3 7 1] [4 3 1 6 7 2 5] [4 3 1 6 2 7 5] [4 3 1 6 5 7 2] [4 3 1 2 6 7 5] [4 3 1 2 5 7 6] [4 3 1 5 7 2 6] [4 3 1 5 2 7 6] [4 3 6 7 1 2 5] [4 3 6 7 2 1 5] [4 3 6 1 7 2 5] [4 3 6 1 2 7 5] [4 3 6 1 5 7 2] [4 3 6 2 7 1 5] [4 3 6 2 1 7 5] [4 3 6 2 5 7 1] [4 3 6 5 7 1 2] [4 3 6 5 1 7 2] [4 3 6 5 2 7 1] [4 3 2 1 6 7 5] [4 3 2 1 5 7 6] [4 3 2 6 7 1 5] [4 3 2 6 1 7 5] [4 3 2 6 5 7 1] [4 3 2 5 7 1 6] [4 3 2 5 1 7 6] [4 3 5 7 1 2 6] [4 3 5 7 2 1 6] [4 3 5 1 7 2 6] [4 3 5 1 2 7 6] [4 3 5 2 7 1 6] [4 3 5 2 1 7 6] [4 2 1 6 7 3 5] [4 2 1 6 3 7 5] [4 2 1 6 5 7 3] [4 2 1 3 6 7 5] [4 2 1 3 5 7 6] [4 2 1 5 7 3 6] [4 2 1 5 3 7 6] [4 2 6 7 1 3 5] [4 2 6 7 3 1 5] [4 2 6 1 7 3 5] [4 2 6 1 3 7 5] [4 2 6 1 5 7 3] [4 2 6 3 7 1 5] [4 2 6 3 1 7 5] [4 2 6 3 5 7 1] [4 2 6 5 7 1 3] [4 2 6 5 1 7 3] [4 2 6 5 3 7 1] [4 2 3 1 6 7 5] [4 2 3 1 5 7 6] [4 2 3 6 7 1 5] [4 2 3 6 1 7 5] [4 2 3 6 5 7 1] [4 2 3 5 7 1 6] [4 2 3 5 1 7 6] [4 2 5 7 1 3 6] [4 2 5 7 3 1 6] [4 2 5 1 7 3 6] [4 2 5 1 3 7 6] [4 2 5 3 7 1 6] [4 2 5 3 1 7 6] [4 5 7 1 3 2 6] [4 5 7 1 2 3 6] [4 5 7 3 1 2 6] [4 5 7 3 2 1 6] [4 5 7 2 1 3 6] [4 5 7 2 3 1 6] [4 5 1 7 3 2 6] [4 5 1 7 2 3 6] [4 5 1 3 7 2 6] [4 5 1 3 2 7 6] [4 5 1 2 7 3 6] [4 5 1 2 3 7 6] [4 5 3 7 1 2 6] [4 5 3 7 2 1 6] [4 5 3 1 7 2 6] [4 5 3 1 2 7 6] [4 5 3 2 7 1 6] [4 5 3 2 1 7 6] [4 5 2 7 1 3 6] [4 5 2 7 3 1 6] [4 5 2 1 7 3 6] [4 5 2 1 3 7 6] [4 5 2 3 7 1 6] [4 5 2 3 1 7 6] [5 1 4 6 7 2 3] [5 1 4 6 3 7 2] [5 1 4 6 2 7 3] [5 1 4 3 6 7 2] [5 1 4 2 6 7 3] [5 1 6 7 3 2 4] [5 1 6 7 2 3 4] [5 1 6 4 7 2 3] [5 1 6 4 3 7 2] [5 1 6 4 2 7 3] [5 1 6 3 7 2 4] [5 1 6 3 4 7 2] [5 1 6 3 2 7 4] [5 1 6 2 7 3 4] [5 1 6 2 4 7 3] [5 1 6 2 3 7 4] [5 1 3 4 6 7 2] [5 1 3 6 7 2 4] [5 1 3 6 4 7 2] [5 1 3 6 2 7 4] [5 1 3 2 6 7 4] [5 1 2 4 6 7 3] [5 1 2 6 7 3 4] [5 1 2 6 4 7 3] [5 1 2 6 3 7 4] [5 1 2 3 6 7 4] [5 4 1 6 7 2 3] [5 4 1 6 3 7 2] [5 4 1 6 2 7 3] [5 4 1 3 6 7 2] [5 4 1 2 6 7 3] [5 4 6 7 1 2 3] [5 4 6 7 2 1 3] [5 4 6 1 7 2 3] [5 4 6 1 3 7 2] [5 4 6 1 2 7 3] [5 4 6 3 7 1 2] [5 4 6 3 1 7 2] [5 4 6 3 2 7 1] [5 4 6 2 7 1 3] [5 4 6 2 1 7 3] [5 4 6 2 3 7 1] [5 4 3 1 6 7 2] [5 4 3 6 7 1 2] [5 4 3 6 1 7 2] [5 4 3 6 2 7 1] [5 4 3 2 6 7 1] [5 4 2 1 6 7 3] [5 4 2 6 7 1 3] [5 4 2 6 1 7 3] [5 4 2 6 3 7 1] [5 4 2 3 6 7 1] [5 6 7 1 3 2 4] [5 6 7 1 2 3 4] [5 6 7 3 1 2 4] [5 6 7 3 2 1 4] [5 6 7 2 1 3 4] [5 6 7 2 3 1 4] [5 6 1 7 3 2 4] [5 6 1 7 2 3 4] [5 6 1 4 7 2 3] [5 6 1 4 3 7 2] [5 6 1 4 2 7 3] [5 6 1 3 7 2 4] [5 6 1 3 4 7 2] [5 6 1 3 2 7 4] [5 6 1 2 7 3 4] [5 6 1 2 4 7 3] [5 6 1 2 3 7 4] [5 6 4 7 1 2 3] [5 6 4 7 2 1 3] [5 6 4 1 7 2 3] [5 6 4 1 3 7 2] [5 6 4 1 2 7 3] [5 6 4 3 7 1 2] [5 6 4 3 1 7 2] [5 6 4 3 2 7 1] [5 6 4 2 7 1 3] [5 6 4 2 1 7 3] [5 6 4 2 3 7 1] [5 6 3 7 1 2 4] [5 6 3 7 2 1 4] [5 6 3 1 7 2 4] [5 6 3 1 4 7 2] [5 6 3 1 2 7 4] [5 6 3 4 7 1 2] [5 6 3 4 1 7 2] [5 6 3 4 2 7 1] [5 6 3 2 7 1 4] [5 6 3 2 1 7 4] [5 6 3 2 4 7 1] [5 6 2 7 1 3 4] [5 6 2 7 3 1 4] [5 6 2 1 7 3 4] [5 6 2 1 4 7 3] [5 6 2 1 3 7 4] [5 6 2 4 7 1 3] [5 6 2 4 1 7 3] [5 6 2 4 3 7 1] [5 6 2 3 7 1 4] [5 6 2 3 1 7 4] [5 6 2 3 4 7 1] [5 3 1 4 6 7 2] [5 3 1 6 7 2 4] [5 3 1 6 4 7 2] [5 3 1 6 2 7 4] [5 3 1 2 6 7 4] [5 3 4 1 6 7 2] [5 3 4 6 7 1 2] [5 3 4 6 1 7 2] [5 3 4 6 2 7 1] [5 3 4 2 6 7 1] [5 3 6 7 1 2 4] [5 3 6 7 2 1 4] [5 3 6 1 7 2 4] [5 3 6 1 4 7 2] [5 3 6 1 2 7 4] [5 3 6 4 7 1 2] [5 3 6 4 1 7 2] [5 3 6 4 2 7 1] [5 3 6 2 7 1 4] [5 3 6 2 1 7 4] [5 3 6 2 4 7 1] [5 3 2 1 6 7 4] [5 3 2 4 6 7 1] [5 3 2 6 7 1 4] [5 3 2 6 1 7 4] [5 3 2 6 4 7 1] [5 2 1 4 6 7 3] [5 2 1 6 7 3 4] [5 2 1 6 4 7 3] [5 2 1 6 3 7 4] [5 2 1 3 6 7 4] [5 2 4 1 6 7 3] [5 2 4 6 7 1 3] [5 2 4 6 1 7 3] [5 2 4 6 3 7 1] [5 2 4 3 6 7 1] [5 2 6 7 1 3 4] [5 2 6 7 3 1 4] [5 2 6 1 7 3 4] [5 2 6 1 4 7 3] [5 2 6 1 3 7 4] [5 2 6 4 7 1 3] [5 2 6 4 1 7 3] [5 2 6 4 3 7 1] [5 2 6 3 7 1 4] [5 2 6 3 1 7 4] [5 2 6 3 4 7 1] [5 2 3 1 6 7 4] [5 2 3 4 6 7 1] [5 2 3 6 7 1 4] [5 2 3 6 1 7 4] [5 2 3 6 4 7 1]]})\n\n; SOURCE: https:\/\/stackoverflow.com\/questions\/26076077\/clojure-list-all-permutations-of-a-list\n(defn permutations [xs]\n  (if (= 1 (count xs))\n    (list xs)\n    (for [head xs\n          tail (permutations (disj (set xs) head))]\n      (into [head] tail))))\n\n; SOURCE: https:\/\/stackoverflow.com\/questions\/16264813\/clojure-idiomatic-way-to-call-contains-on-a-lazy-sequence\n(defn lazy-contains? [col key]\n  (= (some #{key} col) key))\n\n(defn pair [cs]\n  (let [v (vec cs)\n        s (count v)\n        s2 (\/ s 2)\n        s4 (\/ s 4)]\n    (for [x (range 0 s2)] (if (< x s4) [(nth v x) (nth v (- s s4 x 1))] [(nth v (+ (- s x 1) s4)) (nth v x)]))))\n\n(defn clue-x [v]\n  (count (reduce (fn [coll a]\n                   (if (empty? coll) [a]\n                     (if (> a (last coll)) (conj coll a) coll)))\n                 [] v)))\n\n(defn clue-y [v] (clue-x (reverse v)))\n\n(defn clue [v] [(clue-x v) (clue-y v)])\n\n(defn clue-and-permutation-vec [permutations] (map (fn [p] {(clue p) [p]}) permutations))\n\n(defn clue-and-permutation-map [v] (reduce #(merge-with into %1 %2) v))\n\n(defn clues-cmp [clue-a clue-b]\n  (let [[ax ay] clue-a\n        [bx by] clue-b]\n    (and (or (= ax 0) (= bx 0) (= ax bx))\n         (or (= ay 0) (= by 0) (= ay by)))))\n\n(defn possibilities-by-clue [cap clue]\n  (apply concat\n         (vals\n           (filter #(clues-cmp clue (first %1)) cap))))\n\n(defn pattern-for-street [idx patterns]\n  (mapv (fn [p] (distinct (mapv #(nth %1 idx) p))) patterns))\n\n(defn street-ok? [street pattern]\n  (every? true? (map-indexed #(.contains (nth pattern %1) %2) street)))\n\n(defn street-ok? [street pattern]\n  (every? true? (map-indexed #(lazy-contains? (nth pattern %1) %2) street)))\n\n(defn filter-streets [idx streets pattern]\n  (filter #(street-ok? %1 pattern) streets))\n\n; square -> streets -> street\n(defn filter-square [square patterns]\n  (map-indexed #(filter-streets %1 %2 (pattern-for-street %1 patterns)) square))\n\n(defn filter-possibilities [possibilities level repeat]\n  (loop [a (subvec possibilities 0 level)\n         b (subvec possibilities level)\n         counter 0]\n    (let [c (filter-square a b)]\n      (if (> counter repeat) (concat b c) (recur b c (inc counter))))))\n\n(defn pickup [rows pos]\n  (let [[h & tail] rows] (vec (concat [[(nth h pos)]] tail))))\n\n(defn filter-pickup [possibilities level repeat]\n  (loop [i 0]\n    (let [result (filter-possibilities (vec (pickup possibilities i)) level repeat)\n          empty (empty? (first result))]\n      (if empty (recur (inc i)) result))))\n\n(defn solve-puzzle [clues]\n  (let [level (\/ (count clues) 4)\n        cap (if (= level 7) cap7 (clue-and-permutation-map (clue-and-permutation-vec (permutations (range 1 (inc level))))))\n        paired (pair clues)\n        possibilities (mapv #(possibilities-by-clue cap %1) paired)\n        filtered (filter-possibilities possibilities level 11)\n        semi-result (apply concat filtered)\n        count (count semi-result)\n        result (apply concat (take-last level (if (> count level) (filter-pickup filtered level 9) semi-result)))]\n    result))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19186,"user_id":null,"body":"(ns skyscrapers)\n\n(defn str->int [s] (Integer\/parseInt s))\n(defn cross [as bs] (for [a as b bs] [a b]))\n(defn zip [as bs] (map vector as bs))\n(defn in?\n  \"true if coll contains elm\"\n  [coll elm]\n  (some #(= elm %) coll))\n\n(def n 6)\n(def digits\n  \"A digit is a valid value that can be assigned to a cell on the\n  skyscrapers grid\"\n  (range 1 (inc n)))\n(def rows (range n))\n(def cols (range n))\n(def squares \"A square is an [x y] coordinate vector\" (cross rows cols))\n\n(def all-vals\n  \"A val is a set of possible digits that may still exist in a\n  skyscrapers grid cell\"\n  (into #{} digits))\n(defn grid []\n  \"A grid is a map of squares to vals\"\n  (->> squares\n       (map (fn [sq] [sq all-vals]))\n       (into {})))\n\n(def units\n  \"A unit is a vector of squares that cannot have the same final digit\"\n  (concat (for [r rows] (vec (cross cols [r])))\n          (for [c cols] (vec (cross [c] rows)))))\n(def square->units\n  (->> squares\n       (map (fn [sq] [sq (vec (filter #(in? % sq) units))]))\n       (into {})))\n(def square->peers\n  \"A square sq's peer is another square that is in a same unit as\n  sq. This maps a square sq to a set of all other squares in the same\n  row\/col (excluding sq itself).\"\n  (into {}\n        (for [[k v] square->units]\n          [k (disj (->> v\n                        (apply concat)\n                        (into #{}))\n                   k)])))\n\n(def clue-views\n  \"A view is a vector of squares representing a way of looking across\n  the grid. ie it may be a vertical column of squares from either\n  top-to-bottom or bottom-to-top; or a horizontal row of squares going\n  left-to-right or right-to-left. These represent the ways that you\n  'look at the skyline' from the given skyscraper clues.\"\n  (concat\n   (for [c cols] (vec (cross [c] rows)))\n   (for [r rows] (vec (cross (reverse cols) [r])))\n   (for [c (reverse cols)] (vec (cross [c] (reverse rows))))\n   (for [r (reverse rows)] (vec (cross cols [r])))))\n\n;; Clues are given\n(def square->clue-indexes\n  \"A clue index is an array index into the order that clues are provided\n  in. This maps each square to the 4 possible clues indexes that\n  directly affect that square.\"\n  (into {}\n        (for [x cols y rows]\n          [[x y] [x (+ n y) (+ n n (- n 1 x)) (+ n n n (- n 1 y))]])))\n\n(defn display-grid [grid]\n  (if grid\n    (doseq [y rows]\n      (->> cols\n           (map (fn [x] (->> (grid [x y])\n                             (clojure.string\/join \"\")\n                             (format \"%7s\"))))\n           (clojure.string\/join \" \")\n           println))\n    (println \"Contradiction.\")))\n\n;; By convention, functions with ! mutate transients. This is for\n;; performance, as typical immutable clojure style would lead to tons\n;; of intermediate persistent data structures that are immediately\n;; thrown away.\n(declare eliminate!)\n(declare assign!)\n\n;; TODO: making this smarter will improve our search pruning. For now\n;; we only handle the case where all squares up to the max height\n;; tower are certain. But we could also still return a count if\n;; uncertain values are surrounded by higher certain values. Or we\n;; could return upper\/lower bounds on the possible number of visible\n;; skyscrapers and check if the clue is outside those bounds.\n(defn count-visible\n  \"Given grid, return how many skyscrapers are visible looking along the\n  given view. Returns false if we are unsure.\"\n  [grid view]\n  (let [vs (map first (take-while #(= (count %) 1) (map grid view)))]\n    (if (not (in? vs n))\n      ;; don't have confirmed view to the tallest tower\n      false\n      ;; we hvae all visible towers\n      (let [x\n            (count\n             (reduce (fn [visible next]\n                       (if (> next (or (first visible) 0))\n                         (cons next visible)\n                         visible)\n                       ) () vs))]\n        x))))\n\n(defn check-clues [clues grid square]\n  ;; only check the clues directly in line with this square\n  (let [idxs (square->clue-indexes square)\n        sq-views (map #(nth clue-views %) idxs)\n        sq-clues (map #(nth clues %) idxs)]\n    (->> sq-views\n         (map #(count-visible grid %))\n         (zip sq-clues)\n         (filter (fn [[clue actual]] (and (not (false? actual))\n                                          (not= 0 clue))))\n         (every? (fn [[clue actual]] (= clue actual))))))\n\n(defn update-self! [clues grid square val]\n  (let [updated (disj (grid square) val)]\n    (when (not-empty updated)\n      (assoc! grid square updated)\n      (if (= (count updated) 1)\n        (every? #(eliminate! clues grid % (first updated)) (square->peers square))\n        true))))\n\n(defn update-unit!\n  \"Check if there are no longer any valid sq for digit in unit; or if there is exactly 1 valid sq\"\n  [clues grid unit digit]\n  (let [digit-squares (filter #((grid %) digit) unit)]\n    (cond\n      (empty? digit-squares) false\n      (= (count digit-squares) 1) (assign! clues grid (first digit-squares) digit)\n      :else true)))\n\n(defn eliminate! [clues grid square val]\n  (let [existing-options (grid square)]\n    (if (contains? existing-options val)\n      ;; if this is new information, propagate the change\n      (and (update-self! clues grid square val)\n           (every? #(update-unit! clues grid % val) (square->units square))\n           (check-clues clues grid square)\n           ;; TODO: More checks specific to when a square is confirmed as a\n           ;; singular value. For example, we can\n           )\n      ;; else, nothing to do\n      true)))\n\n(defn assign! [clues grid square val]\n  (let [existing (grid square)\n        others (disj existing val)]\n    (every? #(eliminate! clues grid square %) others)))\n\n(defn assign [clues grid square val]\n  (let [t (transient grid)\n        works (assign! clues t square val)]\n    (if works\n      (persistent! t)\n      false)))\n\n(defn eliminate [clues grid square val]\n  (let [t (transient grid)\n        works (eliminate! clues t square val)]\n    (if works\n      (persistent! t)\n      false)))\n\n(defn solved? [grid]\n  (every? (fn [[k v]] (= (count v) 1)) grid))\n\n(defn next-square [grid]\n  ;; Randomize the next square to look at, among squares with the min\n  ;; possible remaining values\n  (let [kv (->> squares\n                (map (fn [sq] [sq (count (grid sq))]))\n                (filter (fn [[_ cnt]] (> cnt 1))))\n        min-val (apply min (map second kv))\n        options (filter #(= min-val (second %)) kv)]\n    (first (rand-nth options)))\n  ;; Or, without randomization (but more prone to getting stuck on\n  ;; hard to resolve cases):\n  ;; (apply min-key #(remaining (grid %)) squares)\n  )\n\n(defn search [clues grid]\n  (cond\n    (false? grid) false\n    (solved? grid) grid\n    :else\n    (let [sq (next-square grid)]\n      (some identity (map #(search clues (assign clues grid sq %)) (grid sq))))))\n\n(defn assign-clue! [clues grid clue view]\n  (cond\n    (= clue 1) (assign! clues grid (first view) n)\n\n    ;; Technically this case is redundant with the :else, but it's\n    ;; more efficient to assign!\n    (= clue n) (doseq [[val sq] (zip digits view)]\n                 (assign! clues grid sq val))\n\n    :else\n    ;; If clue=2, we know n cannot be in the first square.\n    ;; If clue=3, we know n cannot be in the first 2 squares, and\n    ;;        and     (n-1) cannot be in the first square.\n    ;; etc.\n    (doseq [d (range (dec clue))]\n      (doseq [sq (take (- clue 1 d) view)]\n        (eliminate! clues grid sq (- n d))))))\n\n(defn assign-clue [clues grid clue view]\n  (cond\n    (= clue 1) (assign clues grid (first view) n)\n    (= clue n) (reduce (fn [g [val sq]]\n                         (let [g (assign clues g sq val)]\n                           (if g\n                             g\n                             (reduced false))))\n                       grid\n                       (zip digits view))\n    :else\n    (reduce (fn [g sq]\n              (let [g (eliminate clues g sq n)]\n                (if g\n                  g\n                  (reduced false))))\n            grid\n            (take (dec clue) view))))\n\n(defn grid->vec [grid]\n  (vec\n   (for [y rows]\n     (vec\n      (for [x cols]\n        (first (grid [x y])))))))\n\n(defn solve-puzzle [clues]\n  (let [g (grid)\n        t (transient g)]\n    ;; We go out of our way to skip validation checks while applying\n    ;; clues (basically, we aren't handling the case that we get\n    ;; self-contradictory clues) This is for performance, since on\n    ;; some puzzles we eat as much time validating clues as doing the\n    ;; post-clue solve.\n    (time (doseq [[c v] (zip clues clue-views)]\n            (assign-clue! clues t c v)))\n    ;; Or we could validate state while applying initial clues:\n    ;; (reduce (fn [g [c v]]\n    ;;                     (let [g (assign-clue clues g c v)]\n    ;;                       (if g\n    ;;                         g\n    ;;                         (reduced false))))\n    ;;                   (grid)\n    ;;                   (zip clues clue-views))\n\n    (let [g (persistent! t)]\n      (println \"Initial state:\")\n      (display-grid g)\n      (if g\n        (let [solution (time (search clues g))]\n          (grid->vec solution))\n        (println \"Error assigning clues\")))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19187,"user_id":62,"body":"(ns skyscrapers)\n\n(defn permutations [s]\n  (lazy-seq\n   (if (seq (rest s))\n     (apply concat (for [x s]\n                     (map #(cons x %) (permutations (remove #{x} s)))))\n     [s])))\n\n(def stacks \"All possible permutations of [1,2,3,4,5,6]\" \n  (permutations (range 1 (inc 6))))\n\n\n\n\n;; leftward-height\n(defn rightward-visibles \n  \"Return the number of towers visible looking at this row from left to right.\"\n  [row]\n  (first\n   (reduce (fn [[num-seen view-height] x]\n             (cond (zero? view-height)\n                   [1 x]\n                   (> x view-height)\n                   [(inc num-seen) x]\n                   :else-too-short\n                   [num-seen view-height]))\n           [0 0]\n           row)))\n\n(def clued-row\n  \"Return a list of all rows that satisfy the given left & right clue pair.\"\n  (memoize (fn [left-clue right-clue]\n             (let [left? (if (zero? left-clue) (constantly true)\n                             (comp (partial = left-clue) rightward-visibles))\n                   right? (if (zero? right-clue) (constantly true)\n                              (comp (partial = right-clue) rightward-visibles reverse))]\n               (filter #(and (left? %) (right? %)) stacks)))))\n               \n(defn apply-constraint \n  \"Reduce the options in a given row by applying the left and right clue constraints.\"\n  [left-clue right-clue domains]\n  (map set\n       (apply map list\n              (remove (partial some nil?)\n              (map (partial map #(%1 %2) domains) ;; confirm domain membership\n                   (clued-row left-clue right-clue))))))\n\n\n(def empty-board\n  (repeat 6\n          (repeat 6 (set (range 1 (inc 6))))))\n\n(def format-solution (partial mapv (partial mapv first)))\n\n\n(defn solve-puzzle [clues]\n  (let [[north east south west] (partition 6 clues)\n        south (reverse south)\n        west (reverse west)]\n\n    (loop [board empty-board]\n      (let [new-board \n            (->> board\n                 ;; left-to-right constraints\n                 (map apply-constraint west east)\n                 \n                 (apply map list) ;; swap rows\/cols\n                 ;; top-to-bottom constraints\n                 (map apply-constraint north south)\n                 (apply map list))]\n        (if (= new-board board) (format-solution board)\n            (recur new-board))))))\n\n\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19188,"user_id":53,"body":"(ns skyscrapers)\n(declare vectorize)\n\n;; ---------------\n;;      state\n;; ---------------\n\n(defn map-map-board [n]\n  (apply sorted-map (interleave \n    (range n) \n    (repeat n (apply sorted-map (interleave \n      (range n) \n      (repeat n 0)))))))\n\n(defn map-map-cells [n]\n  (apply sorted-map (interleave \n    (range (* n n)) \n    (repeat (* n n) (apply sorted-map (interleave \n      (range n) \n      (repeat n 0)))))))\n\n(defn map-list-peers [n]\n  (apply sorted-map (interleave \n     (range (* n n))\n     (map (fn [c] (filter #(not= % c) (flatten (\n       map #(list \n             (+ (* % n) (mod c n)) \n             (+ (* (quot c n) n) %)) \n         (range n)))))\n       (range (* n n))))))\n\n(defn map-list-observers [clues n]\n  (apply sorted-map (interleave \n     (range (* 4 n))\n     (map (fn [id] (concat \n       (map (fn [i]\n         (cond\n           (< id n) (+ id (* i n))\n           (< id (* 2 n)) (+ (- (dec n) i) (* (mod id n) n))\n           (< id (* 3 n)) (+ (- (dec n) (mod id n)) (* (- (dec n) i) n))\n           :else (+ i (* (- (dec n) (mod id n)) n))\n         )) (range n)) \n       [(nth clues id)]))\n     (range (* 4 n))))))\n\n;; ---------------\n;;      model\n;; ---------------\n\n(defn list-candidates [cells c n]\n  (filter #(zero? (get (get cells c) %)) (range n)))\n\n(defn map-map-cloack [cells c v]\n  (update-in cells [c v] inc))\n\n(defn pair-map-map-lock [state peers c v n]\n  (defn lock-aux [state peers v]\n    (if (zero? (count peers))\n       state\n       (let [board (first state)\n             cells (second state)\n             cloacked (map-map-cloack cells (first peers) v)]\n         (lock-aux (list board cloacked) (rest peers) v)\n       )))\n    (lock-aux \n      (list (update-in (first state) [(quot c n) (mod c n)] \n        (fn [i] (inc v))) (second state)) \n      (get peers c) v))\n\n(defn is-set? [board c n]\n  (not= 0 (get (get board (quot c n)) (mod c n))))\n\n(defn has? [board cells c v n]\n  (and (not (is-set? board c n)) (zero? (get (get cells c) v))))\n\n;; ---------------\n;;   observation\n;; ---------------\n\n(defn int-look [board o n]\n  (defn look-aux [ls m k]\n    (if (empty? ls) k\n      (look-aux \n        (rest ls)\n        (max m (first ls))\n        (if (> (first ls) m) (inc k) k))))\n    (look-aux (map \n      #(get (get board (quot (nth o %) n)) (mod (nth o %) n))\n       (range n)) 0 0))\n\n(defn verify? [board o n] (or\n  (zero? (nth o n))\n  (some #(zero? %) (map #(get \n    (get board (quot (nth o %) n)) (mod (nth o %) n)) (range n)))\n  (= (int-look board o n) (nth o n))))\n\n(defn verify-all? [board observers n]\n  (every? #(verify? board (get observers %) n) (keys observers)))\n\n(defn reduce-edge [state peers observers n]\n  (defn reduce-edge-n [state i peers o]\n    (cond\n      (>= i n) state\n      (not (is-set? (first state) (nth o i) n)) \n        (reduce-edge-n \n          (pair-map-map-lock state peers (nth o i) i n)\n          (inc i) peers o)\n      :else (reduce-edge-n state (inc i) peers o)))\n  (defn reduce-edge-slim [state i j peers o c]\n    (cond\n      (>= i (dec c)) state\n      (>= j (- (dec c) i)) (reduce-edge-slim state (inc i) 0 peers o c)\n      (has? (first state) (second state) (nth o i) (- (dec n) j) n) \n        (reduce-edge-slim \n          (list (first state) (map-map-cloack (second state) (nth o i) (- (dec n) j))) \n          i (inc j) peers o c)\n      :else (reduce-edge-slim state i (inc j) peers o c)))\n  (defn reduce-edge-c [state peers o c n]\n    (let [board (first state)\n          cells (second state)]\n      (cond\n        (= 1 c)\n          (if (not (is-set? board (nth o 0) n))\n            (pair-map-map-lock (list board cells) peers (nth o 0) (dec n) n)\n            state)\n        (= 2 c)\n          (let [cells2 (if (has? board cells (nth o 0) (dec n) n)\n              (map-map-cloack cells (nth o 0) (dec n))\n              cells)]\n            (if (has? board cells (nth o 1) (- n 2) n)\n              (list board (map-map-cloack cells2 (nth o 1) (- n 2)))\n              (list board cells2)))\n        (= n c)\n          (reduce-edge-n state 0 peers o)\n        (< 0 c) \n          (reduce-edge-slim state 0 0 peers o c)\n        :else state)))\n  (defn reduce-edge-aux [state peers observers n]\n    (if (empty? observers) state\n      (let [o (first observers)\n            c (nth o n)\n            nxt (reduce-edge-c state peers o c n)]\n        (reduce-edge-aux nxt peers (rest observers) n))))\n  (reduce-edge-aux state peers \n    (map #(get observers %) (range (* 4 n))) n))\n\n;; ---------------\n;;       DFS\n;; ---------------\n\n(defn int-choose [board cells n]\n  (defn choose-aux [ls cells n i k m]\n    (if (empty? ls) k\n      (let [sz (count (list-candidates cells i n))]\n        (if (and (zero? (first ls)) (< sz m)) \n          (choose-aux (rest ls) cells n (inc i) i sz)\n          (choose-aux (rest ls) cells n (inc i) k m)))))\n  (choose-aux (map #(get \n    (get board (quot % n)) (mod % n)) (range (* n n))) \n      cells n 0 -1 (inc n)))\n\n(declare dfs-step)\n\n(defn dfs [state peers observers n]\n  (let [board (second state)\n        cells (nth state 2)\n        cell (int-choose board cells n)]\n    (if (= -1 cell)\n      (list (verify-all? board observers n) board cells)\n      (dfs-step state (list-candidates cells cell n) cell peers observers n))))\n\n(defn dfs-step [state options cell peers observers n]\n  (let [board (second state)\n        cells (nth state 2)]\n    (if (zero? (count options))\n      (list false board cells)\n      (let [value (first options)\n            locked (pair-map-map-lock (list board cells) peers cell value n)\n            verified (verify-all? board observers n)\n            substate (if (true? verified)\n              (dfs (list true (first locked) (second locked)) peers observers n)\n              locked)]\n        (if (and verified (first substate))\n          substate\n          (dfs-step (list true board cells) \n            (rest options) cell peers observers n))))))\n\n;; ---------------\n;;     solver\n;; ---------------\n\n(defn vectorize [mm]\n  (map (fn [m] (map \n    #(get (get mm m) %) \n    (keys (get mm m)))\n  ) (keys mm)))\n\n(defn solve-puzzle [clues]\n  (let [n (\/ (count clues) 4)\n        board (map-map-board n)\n        cells (map-map-cells n)\n        peers (map-list-peers n)\n        observers (map-list-observers clues n)\n        state (reduce-edge (list board cells) peers observers n)\n        res (dfs (list true (first state) (second state)) peers observers n)]\n    (vectorize (second res))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19189,"user_id":null,"body":"(ns skyscrapers)\n\n(defn all-seq\n  [coll]\n  (if (< 1 (count coll))\n    (mapcat\n      (fn [i]\n        (map\n          #(cons i %)\n          (all-seq (remove #(= i %) coll))))\n      coll)\n    [coll]))\n\n(defn get-highs\n  [coll]\n  (if (= 1 (count coll))\n    1\n    (+ (let [i (last coll)\n             others (drop-last coll)]\n         (if (every? #(> i %) others)\n           (inc (get-highs others))\n           (get-highs others))))))\n\n(def hights\n  (->> (map\n         (fn [coll] [coll (get-highs coll)])\n         (all-seq [1 2 3 4 5 6]))\n       (into {})))\n\n(defn all-row-cases\n  [colls]\n  (let [c1 (->> colls\n                (group-by\n                  (fn [coll]\n                    [(hights coll) (hights (reverse coll))])))\n        c2 (->> colls\n                (group-by\n                  (fn [coll]\n                    [(hights coll) 0])))\n        c3 (->> colls\n                (group-by\n                  (fn [coll]\n                    [0 (hights (reverse coll))])))\n        c4 {[0 0] colls}]\n    (merge c1 c2 c3 c4)))\n\n(def all-clue-ref\n  (all-row-cases (all-seq [1 2 3 4 5 6])))\n\n(defn all-solutions\n  [clues]\n  (map\n    all-clue-ref\n    clues))\n\n(defn fill-puzzles\n  [puzzles row-clues column-clues fill-order]\n  (if (empty? fill-order)\n    (first puzzles)\n    (let [wait-for-fill-index (first fill-order)\n          fill-colls (nth row-clues wait-for-fill-index)\n          wait-puzzles (mapcat\n                         (fn [puzzle]\n                           (let [filtered-colls (filter\n                                                  (fn [coll]\n                                                    (every? some? (for [index (range 6)]\n                                                                    (let [column-clue (nth column-clues index)\n                                                                          possible-items (-> (map\n                                                                                               #(nth % wait-for-fill-index)\n                                                                                               column-clue)\n                                                                                             set)]\n                                                                      (possible-items (nth coll index))))))\n                                                  fill-colls)]\n                             (map\n                               #(concat (take wait-for-fill-index puzzle)\n                                        [%]\n                                        (nthnext puzzle (inc wait-for-fill-index)))\n                               filtered-colls)))\n                         puzzles)]\n      (mapcat\n        (fn [puzzle]\n          (let [wait-for-filter-row (nth puzzle wait-for-fill-index)\n                new-column-clues (map\n                                   (fn [item colls]\n                                     (filter\n                                       #(= item (nth % wait-for-fill-index))\n                                       colls))\n                                   wait-for-filter-row\n                                   column-clues)\n                new-row-clues (map\n                                (fn [colls]\n                                  (filter\n                                    (fn [coll]\n                                      (every? false? (map\n                                                       #(= %1 %2)\n                                                       wait-for-filter-row\n                                                       coll)))\n                                    colls))\n                                row-clues)]\n            (fill-puzzles [puzzle] new-row-clues new-column-clues (rest fill-order))))\n        wait-puzzles))))\n\n\n(defn solve-puzzle [clues]\n  (let [puzzles [(repeat 6 (repeat 6 0))]\n        row-clues (all-solutions [[(nth clues 23) (nth clues 6)]\n                                  [(nth clues 22) (nth clues 7)]\n                                  [(nth clues 21) (nth clues 8)]\n                                  [(nth clues 20) (nth clues 9)]\n                                  [(nth clues 19) (nth clues 10)]\n                                  [(nth clues 18) (nth clues 11)]])\n        column-clues (all-solutions [[(nth clues 0) (nth clues 17)]\n                                     [(nth clues 1) (nth clues 16)]\n                                     [(nth clues 2) (nth clues 15)]\n                                     [(nth clues 3) (nth clues 14)]\n                                     [(nth clues 4) (nth clues 13)]\n                                     [(nth clues 5) (nth clues 12)]])\n        fill-order (->> (for [i (range 6)]\n                          [i (count (nth row-clues i))])\n                        (sort-by second)\n                        (map first))]\n    (fill-puzzles puzzles row-clues column-clues fill-order)))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19190,"user_id":null,"body":"(ns skyscrapers\n  (:require [clojure.set :as cljset])\n)\n\n(defn get-clue [[h1 & resth]]\n  (loop [clue 1 [h & resth] resth hm h1]\n    (cond (not h) clue\n          (> h hm) (recur (inc clue) resth h)\n          :else (recur clue resth hm)\n    )\n  )\n)\n\n(defn permutations [s]\n  (lazy-seq\n    (if (seq (rest s))\n      (apply concat \n        (for [x s] \n          (map #(cons x %) (permutations (remove #{x} s)))\n        )\n      )\n      [s]\n    )\n  )\n)\n\n(defn clues-map [perm-conv-fn perms]\n  (assoc \n    (reduce \n      (fn [m p]\n        (update m (get-clue (perm-conv-fn p)) \n          (fn [c] (if c (conj c p) #{p}))\n        )\n      ) \n      {} \n      perms\n    )\n    0 (set perms)\n  )    \n)\n\n(def left-clues-map (partial clues-map (fn [x] x)))\n(def right-clues-map (partial clues-map reverse))\n\n(defn filter-perm [f-perm perms]\n  (filter \n    (fn [p] (every? (fn [x] x) (map #(not= %1 %2) f-perm p))) \n    perms\n  )\n)\n\n(defn perm-map [perms]\n  (apply merge \n    (map\n      #(hash-map % (set (filter-perm % perms)))\n      perms\n    )\n  )\n)\n\n(defn filter-row-opts [row-opts opts row]\n  (concat \n    (repeat (inc row) []) \n    (map (partial cljset\/intersection opts) (drop (inc row) row-opts))\n  )\n)\n\n(defn filter-col-opts [col-opts p row]\n  (map \n    (fn [opts v] \n      (filter (fn [opt] (= (nth opt row) v)) opts)\n    ) \n    col-opts p\n  )\n)\n\n(defn solutions [perm-map row-opts col-opts row max-row]\n  (if (= row max-row) \n    ['()]\n    (for [p (nth row-opts row)\n          :let [opts (perm-map p)\n                row-opts (filter-row-opts row-opts opts row)\n                col-opts (filter-col-opts col-opts p row)]\n          :when (and (every? #(not (empty? %)) col-opts) \n                     (every? #(not (empty? %)) (drop (inc row) row-opts)))\n          sol (solutions perm-map row-opts col-opts (inc row) max-row)] \n      (cons p sol)\n    )\n  )\n)\n\n(def perms (permutations (range 1 7)))\n(def permmap (perm-map perms))\n(def lcm (left-clues-map perms))\n(def rcm (right-clues-map perms))\n\n(defn solve-puzzle [clues] \n  (let [top-clues (->> clues (take 6))\n        right-clues (->> clues (drop 6) (take 6))\n        bottom-clues (->> clues (drop 12) (take 6) reverse)\n        left-clues (->> clues (drop 18) reverse)\n        h-lims (map #(cljset\/intersection (rcm %1) (lcm %2)) right-clues left-clues)\n        v-lims (map #(cljset\/intersection (lcm %1) (rcm %2)) top-clues bottom-clues)\n       ]\n     (first (solutions permmap h-lims v-lims 0 6))\n  )\n)\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19191,"user_id":null,"body":"(ns skyscrapers)\n\n(defn calc-clue [row]\n  (loop [[val & rest-vals] row\n         max-val 0\n         clue 0]\n    (let [new-max-val (max max-val val)\n          new-clue (if (> new-max-val max-val) (inc clue) clue)]\n      (if (empty? rest-vals) new-clue\n          (recur rest-vals new-max-val new-clue)))))\n\n(defn calc-clues [row]\n  [(calc-clue row) (calc-clue (reverse row))])\n\n(defn construct-rows [s]\n  (if (<= (count s) 1) [s]\n      (reduce (fn [result value] (into result (map #(cons value %) (construct-rows (remove #(= % value) s))))) [] s)))\n\n(defn extend-clues-to-rows-map-one [m row clues]\n  (conj m [clues (conj (get m clues []) row)]))\n\n(defn extend-clues-to-rows-map [m [row clues]]\n  (reduce #(extend-clues-to-rows-map-one %1 row %2)\n          m\n          [clues [(first clues) 0] [0 (second clues)] [0 0]]))\n\n(defn construct-clues-to-rows-map [rows]\n  (reduce #(conj %1 (extend-clues-to-rows-map %1 %2)) {} rows))\n\n(defn construct-row-to-clues-map [rows]\n  (reduce #(conj %1 [%2 (calc-clues %2)]) {} rows))\n\n(defn construct-clue-maps [row-size]\n  (let [rows (map vec (construct-rows (range 1 (inc row-size))))\n        row-to-clues-map (construct-row-to-clues-map rows)\n        clues-to-rows-map (construct-clues-to-rows-map row-to-clues-map)]\n    [clues-to-rows-map row-to-clues-map]))\n\n(defn get-column [mtx i]\n  (reduce #(conj %1 (get %2 i)) [] mtx))\n\n(defn zero-or-equal? [expected actual]\n  (or (zero? expected) (= expected actual)))\n\n(defn both-zero-or-equal? [[e1 e2] [a1 a2]]\n  (and (zero-or-equal? e1 a1) (zero-or-equal? e2 a2)))\n\n(defn test-with-clues [clue-map solution sorted-clues]\n  (loop [i 0]\n    (if (= i (count sorted-clues)) true\n        (let [[clue-pair idx] (get sorted-clues i)]\n          (if (both-zero-or-equal? clue-pair (get clue-map (get-column solution idx)))\n            (recur (inc i))\n            false)))))\n\n(defn split-clues [clues]\n  (let [side-size (int (\/ (count clues) 4))]\n    (loop [v-pairs [] h-pairs []\n           u 0\n           d (dec (* 3 side-size))\n           l (dec (* 4 side-size))\n           r side-size]\n      (if (= u side-size) [v-pairs h-pairs]\n          (recur (conj v-pairs [(get clues u) (get clues d)])\n                 (conj h-pairs [(get clues l) (get clues r)])\n                 (inc u) (dec d) (dec l) (inc r))))))\n\n(defn count-not-zeroes [v]\n  (reduce #(+ %1 (if (zero? %2) 0 1)) 0 v))\n\n(defn sort-clues [pairs clues-to-rows-map]\n  (let [pairs-with-idx (map vector pairs (range (count pairs)))\n        sorted-clues (sort-by #(count (get clues-to-rows-map (first %))) pairs-with-idx)\n        [two one] (reduce #(let [nz (count-not-zeroes (first %2))\n                                 [one two] %1]\n                             (cond (= nz 2) [(inc two) one]\n                                   (= nz 1) [two (inc one)]\n                                   :else [two one]))\n                          [0 0]\n                          sorted-clues)]\n    [(vec sorted-clues) two one]))\n\n(defn map->mtx [m]\n  (loop [result [] i 0]\n    (if (= i (count m)) result\n        (recur (conj result (get m i)) (inc i)))))\n\n(defn get-useful-clues-to-rows-map [cm sh-clues]\n  (reduce #(conj %1 [(first %2) (get cm (first %2))]) {} sh-clues))\n\n(defn same-values? [v1 v2]\n  (loop [i 0]\n    (if (= i (count v1)) false\n        (if (= (get v1 i) (get v2 i)) true\n            (recur (inc i))))))\n\n(defn remove-same-values [cm row]\n  (reduce #(conj %1 [(first %2) (vec (remove (fn [r] (same-values? row r)) (second %2)))]) {} cm))\n\n(defn do-solve-puzzle [clues-to-rows-map row-to-clues-map sh-clues sv-clues solution-map]\n  (if (empty? sh-clues)\n    (let [solution (map->mtx solution-map)]\n      (if (test-with-clues row-to-clues-map solution sv-clues)\n        solution\n        nil))\n    (let [[[sh-clues idx] & rest-sh-clues] sh-clues\n          possible-rows (get clues-to-rows-map sh-clues)\n          rest-clues-to-rows-map (get-useful-clues-to-rows-map clues-to-rows-map rest-sh-clues)]\n      (loop [i 0]\n        (if (= i (count possible-rows)) nil\n            (let [row (get possible-rows i)\n                  filtered-clues-to-rows-map (remove-same-values rest-clues-to-rows-map row)\n                  new-solution-map (conj solution-map [idx row])\n                  result (do-solve-puzzle filtered-clues-to-rows-map row-to-clues-map\n                                          rest-sh-clues sv-clues new-solution-map)]\n              (or result (recur (inc i)))))))))\n\n(defn transposition [mtx]\n  (reduce #(conj %1 (get-column mtx %2)) [] (range (count mtx))))\n\n(defn solve-puzzle [clues]\n  (let [[v-clues h-clues] (split-clues (vec clues))\n        [clues-to-rows-map row-to-clues-map] (construct-clue-maps (int (\/ (count clues) 4)))\n        [sorted-v-clues v-two v-one] (sort-clues v-clues clues-to-rows-map)\n        [sorted-h-clues h-two h-one] (sort-clues h-clues clues-to-rows-map)\n        need-transpos (or (> v-two h-two) (and (= v-two h-two) (> v-one h-one)))]\n    (def solve #(do-solve-puzzle (get-useful-clues-to-rows-map clues-to-rows-map %1) row-to-clues-map %1 %2 {}))\n    (if need-transpos\n      (transposition (solve sorted-v-clues sorted-h-clues))\n      (solve sorted-h-clues sorted-v-clues))))","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19192,"user_id":null,"body":"(ns skyscrapers)\n\n(def n 6)\n\n(defn permutations [col]\n  (reduce\n   (fn [acc x]\n     (let [rest (remove #{x} col)]\n       (concat acc\n               (if (> (count col) 2)\n                 (map #(concat [x] %) (permutations rest))\n                 [[x, (first rest)]])))) [] col))\n\n(defn get-num-of-visible [col]\n  (loop [num 0 maximum 0 height (first col) rest (next col)]\n    (if (nil? height)\n      num\n      (recur (if (> height maximum) (inc num) num) (max height, maximum) (first rest) (next rest)))))\n\n(def all-variants (permutations (range 1 (inc n))))\n\n(defn get-variants [left right]\n  (->> all-variants\n       (filter #(or (zero? left) (= (get-num-of-visible %) left)))\n       (filter #(or (zero? right) (= (get-num-of-visible (reverse %)) right)))))\n\n(defn get-count [col] (reduce #(+ %1 (count %2)) 0 col))\n\n(defn bust [rows columns]\n  (if (= (get-count rows) n)\n    (map first rows)\n    (recur\n     (map-indexed (fn [y row] (filter (fn [variant] (every? (fn [[x num]] (some (fn [column] (= (nth column y) num)) (nth columns x))) (map-indexed vector variant))) row)) rows)\n     (map-indexed (fn [x column] (filter (fn [variant] (every? (fn [[y num]] (some (fn [row] (= (nth row x) num)) (nth rows y))) (map-indexed vector variant))) column)) columns))))\n\n(defn solve-puzzle [clues]\n  (bust\n   (map #(get-variants (nth clues (- (* n 4) 1 %)) (nth clues (+ n %))) (range n))\n   (map #(get-variants (nth clues %) (nth clues (- (* n 3) 1 %))) (range n))))\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19193,"user_id":571,"body":"(ns skyscrapers)\n(defn permutations [colls]\n  (if (= 1 (count colls))\n    (list colls)\n    (for [head colls\n          tail (permutations (disj (set colls) head))]\n      (cons head tail))))\n\n(defn visible-buildings [colls]\n  (loop [c colls tallest 0 cnt 0]\n    (if (= 0 (count c)) cnt\n      (recur (rest c) \n            (if (> (first c) tallest) (first c) tallest )\n            (if (> (first c) tallest) (inc cnt) cnt)))))\n\n\n(defn visible-buildings-both [p]\n  (seq [(visible-buildings p) (visible-buildings (reverse p))]))\n\n(defn permutations-grouped-by-visible [p]\n  (merge (merge (group-by visible-buildings-both p)(group-by visible-buildings p)) [0 p]))\n\n\n(defn possibles[p clues from to]\n  (let [cfrom (nth clues from) cto (nth clues to)]\n    (cond\n     (and (zero? cfrom) (zero? cto)) (vec (get p 0))\n     (and (zero? cfrom) (not= 0 cto)) (vec (map reverse (get p cto)))\n     (and (not= 0 cfrom) (zero? cto)) (vec (get p cfrom))\n     :else (vec (get p [cfrom cto])))))\n\n(defn grid-has-cols [grid cols]\n  (let [x (map (fn [i v] (some #(= % v) (nth cols i))) (iterate inc 0) (partition 6 (apply interleave grid)))]\n    (every? #(= true %) x)))\n    \n(defn cleaner [rows cols]\n  (let [c (map (fn[k v] (map set (partition (count (nth cols k)) (apply interleave v)))) (iterate inc 0) cols)]\n    (map (fn[i r]\n      (filter\n        (fn [e] \n          (and (some #(= % (nth e 0)) (nth (nth c 0) i))\n               (some #(= % (nth e 1)) (nth (nth c 1) i))\n               (some #(= % (nth e 2)) (nth (nth c 2) i))\n               (some #(= % (nth e 3)) (nth (nth c 3) i))\n               (some #(= % (nth e 4)) (nth (nth c 4) i))\n               (some #(= % (nth e 5)) (nth (nth c 5) i)))) r)) (iterate inc 0) rows)))\n\n(defn findsolutionfrom [rows cols]\n  (first (for [r0 (nth rows 0) r1 (nth rows 1) r2 (nth rows 2) r3 (nth rows 3) r4 (nth rows 4) r5 (nth rows 5)\n      :let [grid [r0 r1 r2 r3 r4 r5]]\n      :when (grid-has-cols grid cols)] grid)))\n\n\n(defn solve-puzzle [clues]\n  (let [p (permutations-grouped-by-visible (map vec (permutations '[1 2 3 4 5 6])))\n        rows [(possibles p clues 23 6)(possibles p clues 22 7)(possibles p clues 21 8)(possibles p clues 20 9)(possibles p clues 19 10)(possibles p clues 18 11)]\n        cols [(possibles p clues 0 17)(possibles p clues 1 16)(possibles p clues 2 15)(possibles p clues 3 14)(possibles p clues 4 13)(possibles p clues 5 12)]]\n    (loop [r rows c cols n 10]\n      (if (= 0 n) (findsolutionfrom r c)\n      (let [rr (cleaner r c) cc (cleaner c rr)] \n        (recur rr cc (dec n)))))))\n\n","lang_id":5,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}],"5917a2205ffc30ec3a0000a8":[{"id":19194,"user_id":null,"body":"(ns skyscrapers)\n\n(defn str->int [s] (Integer\/parseInt s))\n(defn cross [as bs] (for [a as b bs] [a b]))\n(defn zip [as bs] (map vector as bs))\n(defn third [xs] (nth xs 2))\n(defn in?\n  \"true if coll contains elm\"\n  [coll elm]\n  (some #(= elm %) coll))\n(defn unchunk [s]\n  (when (seq s)\n    (lazy-seq\n      (cons (first s)\n            (unchunk (next s))))))\n\n(def n 7)\n(def digits\n  \"A digit is a valid value that can be assigned to a cell on the\n  skyscrapers grid\"\n  (range 1 (inc n)))\n(def rows (range n))\n(def cols (range n))\n(def squares \"A square is an [x y] coordinate vector\" (cross rows cols))\n\n(def all-vals\n  \"A val is a set of possible digits that may still exist in a\n  skyscrapers grid cell\"\n  (into #{} digits))\n(defn grid []\n  \"A grid is a map of squares to vals\"\n  (->> squares\n       (map (fn [sq] [sq all-vals]))\n       (into {})))\n\n(def units\n  \"A unit is a vector of squares that cannot have the same final digit\"\n  (concat (for [r rows] (vec (cross cols [r])))\n          (for [c cols] (vec (cross [c] rows)))))\n(def square->units\n  (->> squares\n       (map (fn [sq] [sq (vec (filter #(in? % sq) units))]))\n       (into {})))\n(def square->peers\n  \"A square sq's peer is another square that is in a same unit as\n  sq. This maps a square sq to a set of all other squares in the same\n  row\/col (excluding sq itself).\"\n  (into {}\n        (for [[k v] square->units]\n          [k (disj (->> v\n                        (apply concat)\n                        (into #{}))\n                   k)])))\n\n(def clue-views\n  \"A view is a vector of squares representing a way of looking across\n  the grid. ie it may be a vertical column of squares from either\n  top-to-bottom or bottom-to-top; or a horizontal row of squares going\n  left-to-right or right-to-left. These represent the ways that you\n  'look at the skyline' from the given skyscraper clues.\"\n  (concat\n   (for [c cols] (vec (cross [c] rows)))\n   (for [r rows] (vec (cross (reverse cols) [r])))\n   (for [c (reverse cols)] (vec (cross [c] (reverse rows))))\n   (for [r (reverse rows)] (vec (cross cols [r])))))\n\n;; Clues are given\n(def square->clue-indexes\n  \"A clue index is an array index into the order that clues are provided\n  in. This maps each square to the 4 possible clues indexes that\n  directly affect that square.\"\n  (into {}\n        (for [x cols y rows]\n          [[x y] [x (+ n y) (+ n n (- n 1 x)) (+ n n n (- n 1 y))]])))\n\n(def square->clue-pairs\n  \"Lookup either the ('v)ertical or ('h)orizontal clue indexes+view; grouped together to\n  facilitate checks where we want to check both sides of a \"\n  (into {}\n        (apply concat (for [x cols y rows]\n                        [[[[x y] 'v] [[x (+ n n (- n 1 x))] (cross [x] rows)]]\n                         [[[x y] 'h] [[(+ n n n (- n 1 y)) (+ n y) ] (cross cols [y])]]]))))\n\n(defn display-grid [grid]\n  (if grid\n    (doseq [y rows]\n      (->> cols\n           (map (fn [x] (->> (grid [x y])\n                             (clojure.string\/join \"\")\n                             (format \"%7s\"))))\n           (clojure.string\/join \" \")\n           println))\n    (println \"Contradiction.\")))\n\n(defn display-grid2 [grid clues]\n  (if grid\n    (do\n      (->> (take n clues)\n           (map #(if (= 0 %) \"\" %))\n           (#(concat [\"\"] % [\"\"]))\n           (map #(format \"%7s\" %))\n           (clojure.string\/join \" \")\n           println)\n      (doseq [y rows]\n        (->> cols\n             (map (fn [x] (->> (grid [x y])\n                               (clojure.string\/join \"\"))))\n             (#(concat [(nth clues (+ n n n (- n 1 y)))] % [(nth clues (+ n y))]))\n             (map #(if (= 0 %) \"\" %))\n             (map #(format \"%7s\" %))\n             (clojure.string\/join \" \")\n             println))\n      (->> clues\n           (drop (* 2 n))\n           (take n)\n           reverse\n           (map #(if (= 0 %) \"\" %))\n           (#(concat [\"\"] % [\"\"]))\n           (map #(format \"%7s\" %))\n           (clojure.string\/join \" \")\n           println))\n    (println \"Contradiction.\")))\n\n;; By convention, functions with ! mutate transients. This is for\n;; performance, as typical immutable clojure style would lead to tons\n;; of intermediate persistent data structures that are immediately\n;; thrown away.\n(declare eliminate!)\n(declare assign!)\n\n(defn perms-h [xs flags]\n  (let [[h & t] xs\n        h (filter #(not (bit-test flags %)) h)]\n    (cond\n      (nil? h) '()\n      (nil? t) (map list h)\n      :else (->> h\n                 (map #(map (fn [l] (cons % l)) (perms-h t (bit-set flags %))))\n                 (apply concat)))))\n\n(defn perms [xs]\n  (perms-h xs 0))\n\n;; TODO: making this smarter will improve our search pruning. For now\n;; we only handle the case where all squares up to the max height\n;; tower are certain. But we could also still return a count if\n;; uncertain values are surrounded by higher certain values. Or we\n;; could return upper\/lower bounds on the possible number of visible\n;; skyscrapers and check if the clue is outside those bounds.\n(defn count-visible-h\n  \"Given grid, return how many skyscrapers are visible looking along the\n  given view. Returns false if we are unsure.\"\n  [grid view n max-so-far]\n  (cond\n    (nil? view) n\n    )\n  (let [vs (map first (take-while #(= (count %) 1) (map grid view)))]\n    (if (not (in? vs n))\n      ;; don't have confirmed view to the tallest tower\n      false\n      ;; we hvae all visible towers\n      (count (reduce (fn [visible next]\n                       (if (> next (or (first visible) 0))\n                         (cons next visible)\n                         visible))\n                     ()\n                     vs)))))\n\n(defn count-visible-hh\n  \"Given grid, return how many skyscrapers are visible looking along the\n  given view. Returns false if we are unsure.\"\n  [vs]\n  (if (not (in? vs n))\n    ;; don't have confirmed view to the tallest tower\n    false\n    ;; we hvae all visible towers\n    (count\n     (reduce (fn [visible next]\n               (if (> next (or (first visible) 0))\n                 (cons next visible)\n                 visible)\n               ) () vs))))\n\n(defn count-visible\n  \"Given grid, return how many skyscrapers are visible looking along the\n  given view. Returns false if we are unsure.\"\n  [grid view]\n  (count-visible-hh (map first (take-while #(= (count %) 1) (map grid view)))))\n\n(defn check-clues [clues grid square]\n  ;; only check the clues directly in line with this square\n  (let [idxs (square->clue-indexes square)]\n    (->> idxs\n         (map (fn [idx] [(nth clue-views idx) (nth clues idx)]))\n         (filter (fn [[view clue]] (not= 0 clue)))\n         (map (fn [[view clue]] [(count-visible grid view) clue]))\n         (filter (fn [[cnt clue]] (and (not (false? cnt)))))\n         (every? (fn [[cnt clue]] (= cnt clue))))))\n\n(defn update-2-clues! [clues grid square val]\n  ;; Special logic for cases where we have a '2' clue and just placed\n  ;; a 7 which lines up with it\n  (if (= (grid square) #{n})\n    (do\n      (let [idxs (square->clue-indexes square)\n            views-with-2s\n            (->> idxs\n                 (map (fn [idx] [(nth clue-views idx) (nth clues idx)]))\n                 (filter (fn [[v clue]] (= clue 2))))]\n        (->> views-with-2s\n             (every?\n              (fn [[v _]]\n                (let [vals-upto-n (take-while #(not= #{n} %) (map grid v))\n                      n-idx (count vals-upto-n)\n                      max-d (apply max (flatten (map seq vals-upto-n)))]\n                  (every?\n                   identity\n                   (for [d (take (- n-idx 1) digits)]\n                     (eliminate! clues grid (first v) d)))))))))\n    true))\n\n(defn check-perfect-unit-h! [clues grid unit cs]\n  (let [c1 (clues (first cs))\n        c2 (clues (second cs))\n        vs (filter #(and (or (= 0 c1) (= c1 (count-visible-hh %)))\n                         (or (= 0 c2) (= c2 (count-visible-hh (reverse  %)))))\n                   (perms (map grid unit)))\n        cvs (count vs)]\n    (cond\n      (= 0 cvs) false\n      (= 1 cvs) (every?\n                 (fn [[sq v]] (assign! clues grid sq v))\n                 (zip unit (first vs)))\n      :else true)))\n\n(defn check-perfect-unit!\n  \"Check if there is exactly one solution left for a unit which satisfies the clues\"\n  [clues grid square]\n  (let [[vcs vu] (square->clue-pairs [square 'v])\n        [hcs hu] (square->clue-pairs [square 'h])]\n    (and (check-perfect-unit-h! clues grid vu vcs)\n         (check-perfect-unit-h! clues grid hu hcs))))\n\n(defn update-self! [clues grid square val]\n  (let [updated (disj (grid square) val)]\n    (when (not-empty updated)\n      (assoc! grid square updated)\n      (if (= (count updated) 1)\n        (and (check-clues clues grid square)\n             (check-perfect-unit! clues grid square)\n             (every? #(eliminate! clues grid % (first updated)) (square->peers square)))\n        true))))\n\n(defn update-unit!\n  \"Check if there are no longer any valid sq for digit in unit; or if there is exactly 1 valid sq\"\n  [clues grid unit digit]\n  (let [digit-squares (filter #((grid %) digit) unit)]\n    (cond\n      (empty? digit-squares) false\n      (= (count digit-squares) 1) (assign! clues grid (first digit-squares) digit)\n      :else true)))\n\n(defn eliminate! [clues grid square val]\n  (let [existing-options (grid square)]\n    (if (contains? existing-options val)\n      ;; if this is new information, propagate the change\n      (and (update-self! clues grid square val)\n           (every? #(update-unit! clues grid % val) (square->units square))\n           (update-2-clues! clues grid square val))\n      ;; else, nothing to do\n      true)))\n\n(defn assign! [clues grid square val]\n  (let [existing (grid square)\n        others (disj existing val)]\n    (every? #(eliminate! clues grid square %) others)))\n\n(defn assign [clues grid square val]\n  (let [t (transient grid)\n        works (assign! clues t square val)]\n    (if works\n      (persistent! t)\n      false)))\n\n(defn eliminate [clues grid square val]\n  (let [t (transient grid)\n        works (eliminate! clues t square val)]\n    (if works\n      (persistent! t)\n      false)))\n\n(defn solved? [grid]\n  (every? (fn [[k v]] (= (count v) 1)) grid))\n\n(defn next-square [grid]\n  ;; Randomize the next square to look at, among squares with the min\n  ;; possible remaining values\n  (let [kv (->> squares\n                (map (fn [sq] [sq (count (grid sq))]))\n                (filter (fn [[_ cnt]] (> cnt 1))))\n        min-val (apply min (map second kv))\n        options (filter #(= min-val (second %)) kv)]\n    (first (rand-nth options)))\n  ;; Or, without randomization (but more prone to getting stuck on\n  ;; hard to resolve cases):\n  ;; (apply min-key #(remaining (grid %)) squares)\n  )\n\n(defn search\n  ([clues grid] (search clues grid 0))\n  ([clues grid l]\n  (cond\n    (false? grid) false\n    (solved? grid) grid\n    :else\n    (let [sq (next-square grid)]\n      (if sq\n        (let [x  (some (fn [d]\n                         (if (> l 0)\n                           (let [x (time (search clues (assign clues grid sq d) (dec l)))]\n                             (println \"^ \" sq d)\n                             x)\n                           (search clues (assign clues grid sq d) (dec l))))\n                       (shuffle (grid sq)))]\n          x)\n        false)))))\n\n(defn assign-clue! [clues grid clue view]\n  (cond\n    (= clue 0) nil\n\n    (= clue 1) (assign! clues grid (first view) n)\n\n    ;; Technically this case is redundant with the :else, but it's\n    ;; more efficient to assign!\n    (= clue n) (doseq [[val sq] (zip digits view)]\n                 (assign! clues grid sq val))\n\n    (> clue 1)\n    ;; If clue=2, we know n cannot be in the first square.\n    ;; If clue=3, we know n cannot be in the first 2 squares, and\n    ;;        and     (n-1) cannot be in the first square.\n    ;; etc.\n    (do\n      (doseq [d (range (dec clue))]\n         (doseq [sq (take (- clue 1 d) view)]\n           (eliminate! clues grid sq (- n d))))\n      (when (= clue 2)\n        (eliminate! clues grid (second view) (dec n))))\n\n    :else nil))\n\n(defn assign-clue [clues grid clue view]\n  (cond\n    (= clue 1) (assign clues grid (first view) n)\n    (= clue n) (reduce (fn [g [val sq]]\n                         (let [g (assign clues g sq val)]\n                           (if g\n                             g\n                             (reduced false))))\n                       grid\n                       (zip digits view))\n    :else\n    (reduce (fn [g sq]\n              (let [g (eliminate clues g sq n)]\n                (if g\n                  g\n                  (reduced false))))\n            grid\n            (take (dec clue) view))))\n\n(defn grid->vec [grid]\n  (vec\n   (for [y rows]\n     (vec\n      (for [x cols]\n        (first (grid [x y])))))))\n\n(defn solve_puzzle [clues]\n  (let [clues (vec clues) ;; Make sure we can efficiently index\n        g (grid)\n        t (transient g)]\n    ;; We go out of our way to skip validation checks while applying\n    ;; clues (basically, we aren't handling the case that we get\n    ;; self-contradictory clues) This is for performance, since on\n    ;; some puzzles we eat as much time validating clues as doing the\n    ;; post-clue solve.\n    (time (doseq [[c v] (zip clues clue-views)]\n            (assign-clue! clues t c v)))\n    ;; Or we could validate state while applying initial clues:\n    ;; (reduce (fn [g [c v]]\n    ;;                     (let [g (assign-clue clues g c v)]\n    ;;                       (if g\n    ;;                         g\n    ;;                         (reduced false))))\n    ;;                   (grid)\n    ;;                   (zip clues clue-views))\n\n    (let [g (persistent! t)]\n      (println \"Initial state:\")\n    (println g)\n      (display-grid2 g clues)\n      (if g\n        (let [solution (time (search clues g))]\n          (display-grid2 solution clues)\n          (grid->vec solution))\n        (println \"Error assigning clues\")))))","lang_id":5,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19195,"user_id":62,"body":"(ns skyscrapers \n  (:require clojure.set))\n\n(def board-size 7)\n\n(defn permutations [s]\n  (lazy-seq\n   (if (seq (rest s))\n     (apply concat (for [x s]\n                     (map #(cons x %) (permutations (remove #{x} s)))))\n     [s])))\n\n(def stacks \"All possible permutations of [1 ... board-size]\" \n  (permutations (range 1 (inc board-size))))\n\n(defn rightward-visibles \n  \"Return the number of towers visible looking at this row from left to right.\"\n  [row]\n  (first\n   (reduce (fn [[num-seen view-height] x]\n             (cond (zero? view-height)\n                   [1 x]\n                   (> x view-height)\n                   [(inc num-seen) x]\n                   :else-too-short\n                   [num-seen view-height]))\n           [0 0]\n           row)))\n\n(def clued-row\n  \"Return a list of all rows that satisfy the given left & right clue pair.\"\n  (memoize (fn [left-clue right-clue]\n             (let [left? (if (zero? left-clue) (constantly true)\n                             (comp (partial = left-clue) rightward-visibles))\n                   right? (if (zero? right-clue) (constantly true)\n                              (comp (partial = right-clue) rightward-visibles reverse))]\n               (filter #(and (left? %) (right? %)) stacks)))))\n               \n(defn apply-constraint \n  \"Reduce the options in a given row by applying the left and right clue constraints.\"\n  [left-clue right-clue domains]\n  (map set\n       (apply map list\n              (remove (partial some nil?)\n              (map (partial map #(%1 %2) domains) ;; confirm domain membership\n                   (clued-row left-clue right-clue))))))\n\n(def empty-board\n  (repeat board-size\n          (repeat board-size (set (range 1 (inc board-size))))))\n\n(def format-solution (partial mapv (partial mapv first)))\n\n\n\n(declare inconsistent-board?)\n(declare finish-by-guessing)\n\n(defn solve_puzzle [clues]\n  (let [[north east south west] (partition board-size clues)\n        south (reverse south)\n        west (reverse west)\n        \n        constrain-board\n        (fn [board]\n           (->> board\n                 ;; left-to-right constraints\n                 (map apply-constraint west east)\n                ;; (map require-distinct-row)\n                 (apply map list) ;; swap rows\/cols\n                 ;; top-to-bottom constraints\n                 (map apply-constraint north south)\n                ;; (map require-distinct-row)\n                 (apply map list)))\n        \n        ]\n\n    (loop [board empty-board]\n      (let [new-board (constrain-board board)]\n        (if (= new-board board) \n            (finish-by-guessing constrain-board board)\n            (recur new-board))))))\n\n;;; AFTER LOGICAL REASONING IS EXHAUSTED, GUESS AND CHECK\n\n(defn inconsistent-board? [domains] \n  (some empty? domains))\n\n(defn finish-by-guessing [constrain-fn board]\n  (let [cells (vec (apply concat board))\n        selectors (->> (zipmap cells (range))\n                       (remove (comp (partial = 1) count key))\n                       (sort-by (comp count key))\n                    )\n        ]\n    \n    (when-not (inconsistent-board? board)\n      (if-let [[domain index] (first selectors)]\n        \n        (first \n         (remove nil?\n                 (for [value domain]\n                   (try  ;; inconsistent boards usefully throw an error\n          (finish-by-guessing \n            constrain-fn\n            (constrain-fn\n              (partition board-size\n                         (assoc cells index #{value}))))\n                     (catch Exception _ nil)))))\n        \n    (format-solution board)))))\n  ","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19196,"user_id":null,"body":"(ns skyscrapers\n  (:require [clojure.set :as clset]))\n(def n 7)\n\n(defn make-grid []\n  (vec (repeat n (vec (repeat n (vec (range 1 (inc n))))))))\n\n(def unit-from-index (memoize (fn [i]\n                                (let [q (quot i n)\n                                      r (rem i n)\n                                      rn (range n)]\n                                  (case q\n                                    0 (for [x rn]\n                                        [x r])\n                                    1 (reverse (for [x rn]\n                                                 [r x]))\n                                    2 (reverse (for [x rn]\n                                                 [x (- n r 1)]))\n                                    3 (for [x rn]\n                                        [(- n r 1) x]))))))\n\n(def units-from-coord (memoize (fn [[r c]]\n\n                                 (vector (for [x (range n)]\n                                           [r x])\n                                         (for [x (range n)]\n                                           [x c])))))\n\n(def peers (memoize (fn [c]\n                      (remove #{c} (apply concat (units-from-coord c))))))\n\n(defn to-eliminate [clue index]\n  (range (+ 2 index (- n clue)) (inc n)))\n\n(declare assign)\n\n(defn check-unique-unit [unit num grid]\n  (cond\n    (nil? grid) nil\n    :else\n    (let [res (->> (map (fn [u]\n                          [u (get-in grid u)]) unit)\n                   (filter (fn [[u vals]]\n                             (some #{num} vals))))]\n      (if (zero? (count res))\n        nil\n        (if (= 1 (count res))\n          (assign (ffirst res) num grid)\n          grid)))))\n\n(defn elim [[r c] num grid]\n  (if (nil? grid)\n    nil\n    (let [num-list (get-in grid [r c])\n          after-elim (remove #{num} num-list)]\n      (if (zero? (count after-elim))\n        nil\n        (if (or (= 1 (count num-list))\n                (not-any? #{num} num-list))\n          grid\n          (let [new-grid (assoc-in grid [r c] after-elim)\n                units (units-from-coord [r c])\n                new-new-grid (if (= 1 (count after-elim))\n                               (reduce (fn [g coord-of-peer]\n                                         (elim coord-of-peer (first after-elim) g)) new-grid (peers [r c]))\n                               new-grid)]\n            (reduce (fn [g unit]\n                      (check-unique-unit unit num g)) new-new-grid units)))))))\n\n(defn eliminate [coord nums grid]\n  (if (nil? grid)\n    nil\n    (reduce (fn [g num]\n              (elim coord num g)) grid nums)))\n\n\n(defn assign [coord num grid]\n  (if (nil? grid)\n    nil\n    (let [num-list (get-in grid coord)\n          to-elim (remove #{num} num-list)]\n      (eliminate coord to-elim grid))))\n\n\n(defn process [clues grid index]\n  (if (zero? (clues index))\n    grid\n    (let [c (clues index)\n          unit (unit-from-index index)\n          r (range 1 (inc n))\n          ii (range n)\n          unit-r (map #(vector %1 %2) unit r)\n          unit-index (map #(vector %1 %2) unit ii)]\n      (case c\n        0 grid\n        1 (assign (first unit) n grid)\n        n (reduce (fn [l [coord number]]\n                    (assign coord number l)) grid unit-r)\n        (reduce (fn [g [coord index]]\n                  (eliminate coord (to-eliminate c index) g)) grid unit-index)))))\n\n(def satisfies-clue (memoize (fn [clue v]\n                               (and (= v (distinct v))\n                                    (= clue (loop [max 0\n                                                   counter 0\n                                                   [f & rest] v]\n                                              (if (nil? f)\n                                                counter\n                                                (if (> f max)\n                                                  (recur f (inc counter) rest)\n                                                  (recur max counter rest)))))))))\n\n\n(defn is-all-one [g]\n  (every? #(= 1 (count %)) (apply concat g)))\n\n(defn get-possibilities-count [grid clues index]\n  (let [unit (unit-from-index index)\n        row (map #(get-in grid %) unit)]\n    (count (flatten row))))\n\n(def possible-nums (memoize (fn [row clues index unit]\n                              (let [problem-indexes (keep-indexed (fn [i r]\n                                                                    (when (> (count r) 1)\n                                                                      i)) row)\n                                    filtered (->> (reduce (fn [l r]\n                                                            (for [x l\n                                                                  y r]\n                                                              (conj x y))) [[]] row)\n                                                  (filter (partial satisfies-clue (clues index))))\n                                    possible-nums (->> (partition (count filtered) (apply interleave filtered))\n                                                       (map (fn [v]\n                                                              (distinct v))))]\n                                (keep (fn [x]\n                                        (when-let [the-num (not-empty (clset\/difference (set (nth row x)) (set (nth possible-nums x))))]\n                                          [(nth unit x) the-num])) problem-indexes)))))\n\n(defn sequence-filter [clues grid index]\n  (if (zero? (clues index))\n    grid\n    (if (is-all-one grid)\n      (reduced grid)\n      (let [unit (unit-from-index index)\n            row (map #(get-in grid %) unit)]\n        (let [to-process (possible-nums row clues index unit)]\n          (reduce (fn [g [coord num]]\n                    (eliminate coord (vec num) g)) grid to-process))))))\n\n(defn is-valid [g clues]\n  (every? (fn [i]\n            (let [clue (clues i)\n                  row (flatten (map #(get-in g %) (unit-from-index i)))]\n              (if (zero? clue)\n                true\n                (satisfies-clue clue row)))) (range (* 4 n))))\n\n(defn guess-and-check [clues g]\n  (if (nil? g)\n    nil\n    (if (is-all-one g)\n      (if (is-valid g clues)\n        g\n        nil)\n      (let [to-try (first (->> (for [x (range n)\n                                     y (range n)]\n                                 [[x y] (get-in g [x y])])\n                               (filter #(> (count (second %)) 1))\n                               (sort-by (comp count second))))]\n        (let [coord (first to-try)\n              try-list (second to-try)]\n          (some #(when-let [res (guess-and-check clues (assign coord % g))] res) try-list))))))\n\n(defn solve_puzzle [clues-l]\n  (let [clues (vec clues-l)\n        grid (make-grid)\n        processed-grid  (reduce (partial process clues) grid (range (* 4 n)))\n        after-seq-filter (reduce (partial sequence-filter clues) processed-grid (take 60 (cycle (sort-by (partial get-possibilities-count processed-grid clues) (range (* 4 n))))))\n        after-guessing (guess-and-check clues after-seq-filter)]\n    (vec (map (comp vec flatten) after-guessing))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19197,"user_id":null,"body":"(ns skyscrapers)\n\n(defn get-clue [row]\n  (last (reduce\n          (fn [[m c] h]\n            (if (> h m) [h (inc c)] [m c]))\n          [0 0] row)))\n\n(defn permutations [s]\n  (if (seq (rest s))\n    (apply concat\n           (for [x s]\n             (map #(vec (cons x %)) (permutations (remove #{x} s)))))\n    [s]))\n\n(defn clues-map [perms]\n  (reduce\n    (fn [m p]\n      (let [lc (get-clue p)\n            rc (get-clue (reverse p))\n            conj-p (fn [x] (if x (conj x p) [p]))]\n        (-> m\n            (update (list lc 0) conj-p)\n            (update (list 0 rc) conj-p)\n            (update (list lc rc) conj-p)\n            (update (list 0 0) conj-p))))\n    {}\n    perms))\n\n(defn filter-next-row-options [f-perm perms]\n  (filter #(not-any? identity (map = % f-perm)) perms))\n\n(defn filter-options-by-value [i v perms]\n  (filter (fn [per] (= (nth per i) v)) perms))\n\n(defn filter-row-options [row-opts p]\n  (map (partial filter-next-row-options p) row-opts))\n\n(defn filter-column-options [col-opts p row]\n  (map (partial filter-options-by-value row) p col-opts))\n\n(defn solutions [[first-row-options & rest-row-options] col-opts row max-row]\n  (if (= row max-row)\n    [[]]\n    (for [opt first-row-options\n          :let [col-opts (filter-column-options col-opts opt row)\n                row-opts (filter-row-options rest-row-options opt)]\n          :when (not-any? empty? col-opts)\n          :when (not-any? empty? row-opts)\n          sol (solutions row-opts col-opts (inc row) max-row)]\n      (cons opt sol))))\n\n(defn value-option-sets [opts]\n  (mapv set (apply map list opts)))\n\n(defn filter-by-value-option-sets [value-opts opts]\n  (filter #(every? identity (map contains? value-opts %)) opts))\n\n(defn rotate [matrix]\n  (apply map list matrix))\n\n(defn reduce-options [row-options col-options]\n  (let [unfiltered-col-opt-len (map count col-options)\n        unfiltered-row-opt-len (map count row-options)\n        row-options (map filter-by-value-option-sets (rotate (map value-option-sets col-options)) row-options)\n        col-options (map filter-by-value-option-sets (rotate (map value-option-sets row-options)) col-options)\n        filtered-col-opt-len (map count col-options)\n        filtered-row-opt-len (map count row-options)]\n    (if (and (= unfiltered-col-opt-len filtered-col-opt-len)\n             (= unfiltered-row-opt-len filtered-row-opt-len))\n      [row-options col-options]\n      (reduce-options row-options col-options))))\n\n(defn puzzle-solver [grid-size]\n  (let [perms (permutations (range 1 (inc grid-size)))\n        cmap (clues-map perms)\n        solver (fn solve_puzzle [grid-size cmap clues]\n                 (let [top-clues (->> clues (take grid-size))\n                       bottom-clues (->> clues (drop (* 2 grid-size)) (take grid-size) reverse)\n                       left-clues (->> clues (drop (* 3 grid-size)) reverse)\n                       right-clues (->> clues (drop grid-size) (take grid-size))\n                       row-options (map #(cmap (list %1 %2)) left-clues right-clues)\n                       col-options (map #(cmap (list %1 %2)) top-clues bottom-clues)\n                       [row-options col-options] (reduce-options row-options col-options)]\n                   (first (solutions row-options col-options 0 grid-size))\n                   ))]\n    (partial solver grid-size cmap)))\n\n(def solve_puzzle (puzzle-solver 7))\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19198,"user_id":null,"body":"(ns skyscrapers)\n\n\n(def cap7 {[7 1] [[1 2 3 4 5 6 7]], [4 3] [[1 4 6 7 3 5 2] [1 4 6 7 2 5 3] [1 4 6 7 5 2 3] [1 4 6 3 7 5 2] [1 4 6 2 7 5 3] [1 4 6 5 7 3 2] [1 4 3 6 7 5 2] [1 4 3 5 7 6 2] [1 4 2 6 7 5 3] [1 4 2 5 7 6 3] [1 4 5 7 6 2 3] [1 4 5 7 3 6 2] [1 4 5 7 2 6 3] [1 4 5 3 7 6 2] [1 4 5 2 7 6 3] [1 3 4 7 6 2 5] [1 3 4 7 2 6 5] [1 3 4 7 5 6 2] [1 3 4 2 7 6 5] [1 3 6 7 4 5 2] [1 3 6 7 2 5 4] [1 3 6 7 5 2 4] [1 3 6 4 7 5 2] [1 3 6 2 7 5 4] [1 3 6 5 7 4 2] [1 3 2 4 7 6 5] [1 3 2 6 7 5 4] [1 3 2 5 7 6 4] [1 3 5 7 4 6 2] [1 3 5 7 6 2 4] [1 3 5 7 2 6 4] [1 3 5 4 7 6 2] [1 3 5 2 7 6 4] [1 2 4 7 6 3 5] [1 2 4 7 3 6 5] [1 2 4 7 5 6 3] [1 2 4 3 7 6 5] [1 2 6 7 4 5 3] [1 2 6 7 3 5 4] [1 2 6 7 5 3 4] [1 2 6 4 7 5 3] [1 2 6 3 7 5 4] [1 2 6 5 7 4 3] [1 2 3 7 4 6 5] [1 2 3 7 6 4 5] [1 2 3 7 5 6 4] [1 2 5 7 4 6 3] [1 2 5 7 6 3 4] [1 2 5 7 3 6 4] [1 2 5 4 7 6 3] [1 2 5 3 7 6 4] [1 5 4 6 7 3 2] [1 5 6 7 4 2 3] [1 5 6 7 3 4 2] [1 5 6 7 2 4 3] [1 5 6 4 7 3 2] [1 5 6 3 7 4 2] [1 5 6 2 7 4 3] [1 5 3 6 7 4 2] [1 5 2 6 7 4 3] [2 1 4 6 7 5 3] [2 1 4 5 7 6 3] [2 1 3 4 7 6 5] [2 1 3 6 7 5 4] [2 1 3 5 7 6 4] [2 1 5 6 7 4 3] [2 4 1 6 7 5 3] [2 4 1 5 7 6 3] [2 4 6 7 1 5 3] [2 4 6 7 3 5 1] [2 4 6 7 5 1 3] [2 4 6 1 7 5 3] [2 4 6 3 7 5 1] [2 4 6 5 7 3 1] [2 4 3 6 7 5 1] [2 4 3 5 7 6 1] [2 4 5 7 1 6 3] [2 4 5 7 6 1 3] [2 4 5 7 3 6 1] [2 4 5 1 7 6 3] [2 4 5 3 7 6 1] [2 3 1 4 7 6 5] [2 3 1 6 7 5 4] [2 3 1 5 7 6 4] [2 3 4 7 1 6 5] [2 3 4 7 6 1 5] [2 3 4 7 5 6 1] [2 3 4 1 7 6 5] [2 3 6 7 1 5 4] [2 3 6 7 4 5 1] [2 3 6 7 5 1 4] [2 3 6 1 7 5 4] [2 3 6 4 7 5 1] [2 3 6 5 7 4 1] [2 3 5 7 1 6 4] [2 3 5 7 4 6 1] [2 3 5 7 6 1 4] [2 3 5 1 7 6 4] [2 3 5 4 7 6 1] [2 5 1 6 7 4 3] [2 5 4 6 7 3 1] [2 5 6 7 1 4 3] [2 5 6 7 4 1 3] [2 5 6 7 3 4 1] [2 5 6 1 7 4 3] [2 5 6 4 7 3 1] [2 5 6 3 7 4 1] [2 5 3 6 7 4 1] [3 1 4 6 7 5 2] [3 1 4 5 7 6 2] [3 1 5 6 7 4 2] [3 4 1 6 7 5 2] [3 4 1 5 7 6 2] [3 4 6 7 1 5 2] [3 4 6 7 2 5 1] [3 4 6 7 5 1 2] [3 4 6 1 7 5 2] [3 4 6 2 7 5 1] [3 4 6 5 7 2 1] [3 4 2 6 7 5 1] [3 4 2 5 7 6 1] [3 4 5 7 1 6 2] [3 4 5 7 6 1 2] [3 4 5 7 2 6 1] [3 4 5 1 7 6 2] [3 4 5 2 7 6 1] [3 2 4 6 7 5 1] [3 2 4 5 7 6 1] [3 2 5 6 7 4 1] [3 5 1 6 7 4 2] [3 5 4 6 7 2 1] [3 5 6 7 1 4 2] [3 5 6 7 4 1 2] [3 5 6 7 2 4 1] [3 5 6 1 7 4 2] [3 5 6 4 7 2 1] [3 5 6 2 7 4 1] [3 5 2 6 7 4 1] [4 1 5 6 7 3 2] [4 3 5 6 7 2 1] [4 2 5 6 7 3 1] [4 5 1 6 7 3 2] [4 5 6 7 1 3 2] [4 5 6 7 3 1 2] [4 5 6 7 2 3 1] [4 5 6 1 7 3 2] [4 5 6 3 7 2 1] [4 5 6 2 7 3 1] [4 5 3 6 7 2 1] [4 5 2 6 7 3 1]], [2 2] [[1 7 4 3 2 5 6] [1 7 4 3 5 2 6] [1 7 4 2 3 5 6] [1 7 4 2 5 3 6] [1 7 4 5 3 2 6] [1 7 4 5 2 3 6] [1 7 3 4 2 5 6] [1 7 3 4 5 2 6] [1 7 3 2 4 5 6] [1 7 3 2 5 4 6] [1 7 3 5 4 2 6] [1 7 3 5 2 4 6] [1 7 2 4 3 5 6] [1 7 2 4 5 3 6] [1 7 2 3 4 5 6] [1 7 2 3 5 4 6] [1 7 2 5 4 3 6] [1 7 2 5 3 4 6] [1 7 5 4 3 2 6] [1 7 5 4 2 3 6] [1 7 5 3 4 2 6] [1 7 5 3 2 4 6] [1 7 5 2 4 3 6] [1 7 5 2 3 4 6] [2 7 1 4 3 5 6] [2 7 1 4 5 3 6] [2 7 1 3 4 5 6] [2 7 1 3 5 4 6] [2 7 1 5 4 3 6] [2 7 1 5 3 4 6] [2 7 4 1 3 5 6] [2 7 4 1 5 3 6] [2 7 4 3 1 5 6] [2 7 4 3 5 1 6] [2 7 4 5 1 3 6] [2 7 4 5 3 1 6] [2 7 3 1 4 5 6] [2 7 3 1 5 4 6] [2 7 3 4 1 5 6] [2 7 3 4 5 1 6] [2 7 3 5 1 4 6] [2 7 3 5 4 1 6] [2 7 5 1 4 3 6] [2 7 5 1 3 4 6] [2 7 5 4 1 3 6] [2 7 5 4 3 1 6] [2 7 5 3 1 4 6] [2 7 5 3 4 1 6] [2 1 7 4 3 5 6] [2 1 7 4 5 3 6] [2 1 7 3 4 5 6] [2 1 7 3 5 4 6] [2 1 7 5 4 3 6] [2 1 7 5 3 4 6] [3 7 1 4 2 5 6] [3 7 1 4 5 2 6] [3 7 1 2 4 5 6] [3 7 1 2 5 4 6] [3 7 1 5 4 2 6] [3 7 1 5 2 4 6] [3 7 4 1 2 5 6] [3 7 4 1 5 2 6] [3 7 4 2 1 5 6] [3 7 4 2 5 1 6] [3 7 4 5 1 2 6] [3 7 4 5 2 1 6] [3 7 2 1 4 5 6] [3 7 2 1 5 4 6] [3 7 2 4 1 5 6] [3 7 2 4 5 1 6] [3 7 2 5 1 4 6] [3 7 2 5 4 1 6] [3 7 5 1 4 2 6] [3 7 5 1 2 4 6] [3 7 5 4 1 2 6] [3 7 5 4 2 1 6] [3 7 5 2 1 4 6] [3 7 5 2 4 1 6] [3 1 7 4 2 5 6] [3 1 7 4 5 2 6] [3 1 7 2 4 5 6] [3 1 7 2 5 4 6] [3 1 7 5 4 2 6] [3 1 7 5 2 4 6] [3 1 2 7 4 5 6] [3 1 2 7 5 4 6] [3 2 7 1 4 5 6] [3 2 7 1 5 4 6] [3 2 7 4 1 5 6] [3 2 7 4 5 1 6] [3 2 7 5 1 4 6] [3 2 7 5 4 1 6] [3 2 1 7 4 5 6] [3 2 1 7 5 4 6] [4 7 1 3 2 5 6] [4 7 1 3 5 2 6] [4 7 1 2 3 5 6] [4 7 1 2 5 3 6] [4 7 1 5 3 2 6] [4 7 1 5 2 3 6] [4 7 3 1 2 5 6] [4 7 3 1 5 2 6] [4 7 3 2 1 5 6] [4 7 3 2 5 1 6] [4 7 3 5 1 2 6] [4 7 3 5 2 1 6] [4 7 2 1 3 5 6] [4 7 2 1 5 3 6] [4 7 2 3 1 5 6] [4 7 2 3 5 1 6] [4 7 2 5 1 3 6] [4 7 2 5 3 1 6] [4 7 5 1 3 2 6] [4 7 5 1 2 3 6] [4 7 5 3 1 2 6] [4 7 5 3 2 1 6] [4 7 5 2 1 3 6] [4 7 5 2 3 1 6] [4 1 7 3 2 5 6] [4 1 7 3 5 2 6] [4 1 7 2 3 5 6] [4 1 7 2 5 3 6] [4 1 7 5 3 2 6] [4 1 7 5 2 3 6] [4 1 3 7 2 5 6] [4 1 3 7 5 2 6] [4 1 3 2 7 5 6] [4 1 2 7 3 5 6] [4 1 2 7 5 3 6] [4 1 2 3 7 5 6] [4 3 7 1 2 5 6] [4 3 7 1 5 2 6] [4 3 7 2 1 5 6] [4 3 7 2 5 1 6] [4 3 7 5 1 2 6] [4 3 7 5 2 1 6] [4 3 1 7 2 5 6] [4 3 1 7 5 2 6] [4 3 1 2 7 5 6] [4 3 2 7 1 5 6] [4 3 2 7 5 1 6] [4 3 2 1 7 5 6] [4 2 7 1 3 5 6] [4 2 7 1 5 3 6] [4 2 7 3 1 5 6] [4 2 7 3 5 1 6] [4 2 7 5 1 3 6] [4 2 7 5 3 1 6] [4 2 1 7 3 5 6] [4 2 1 7 5 3 6] [4 2 1 3 7 5 6] [4 2 3 7 1 5 6] [4 2 3 7 5 1 6] [4 2 3 1 7 5 6] [5 7 1 4 3 2 6] [5 7 1 4 2 3 6] [5 7 1 3 4 2 6] [5 7 1 3 2 4 6] [5 7 1 2 4 3 6] [5 7 1 2 3 4 6] [5 7 4 1 3 2 6] [5 7 4 1 2 3 6] [5 7 4 3 1 2 6] [5 7 4 3 2 1 6] [5 7 4 2 1 3 6] [5 7 4 2 3 1 6] [5 7 3 1 4 2 6] [5 7 3 1 2 4 6] [5 7 3 4 1 2 6] [5 7 3 4 2 1 6] [5 7 3 2 1 4 6] [5 7 3 2 4 1 6] [5 7 2 1 4 3 6] [5 7 2 1 3 4 6] [5 7 2 4 1 3 6] [5 7 2 4 3 1 6] [5 7 2 3 1 4 6] [5 7 2 3 4 1 6] [5 1 7 4 3 2 6] [5 1 7 4 2 3 6] [5 1 7 3 4 2 6] [5 1 7 3 2 4 6] [5 1 7 2 4 3 6] [5 1 7 2 3 4 6] [5 1 4 7 3 2 6] [5 1 4 7 2 3 6] [5 1 4 3 7 2 6] [5 1 4 3 2 7 6] [5 1 4 2 7 3 6] [5 1 4 2 3 7 6] [5 1 3 7 4 2 6] [5 1 3 7 2 4 6] [5 1 3 4 7 2 6] [5 1 3 4 2 7 6] [5 1 3 2 7 4 6] [5 1 3 2 4 7 6] [5 1 2 7 4 3 6] [5 1 2 7 3 4 6] [5 1 2 4 7 3 6] [5 1 2 4 3 7 6] [5 1 2 3 7 4 6] [5 1 2 3 4 7 6] [5 4 7 1 3 2 6] [5 4 7 1 2 3 6] [5 4 7 3 1 2 6] [5 4 7 3 2 1 6] [5 4 7 2 1 3 6] [5 4 7 2 3 1 6] [5 4 1 7 3 2 6] [5 4 1 7 2 3 6] [5 4 1 3 7 2 6] [5 4 1 3 2 7 6] [5 4 1 2 7 3 6] [5 4 1 2 3 7 6] [5 4 3 7 1 2 6] [5 4 3 7 2 1 6] [5 4 3 1 7 2 6] [5 4 3 1 2 7 6] [5 4 3 2 7 1 6] [5 4 3 2 1 7 6] [5 4 2 7 1 3 6] [5 4 2 7 3 1 6] [5 4 2 1 7 3 6] [5 4 2 1 3 7 6] [5 4 2 3 7 1 6] [5 4 2 3 1 7 6] [5 3 7 1 4 2 6] [5 3 7 1 2 4 6] [5 3 7 4 1 2 6] [5 3 7 4 2 1 6] [5 3 7 2 1 4 6] [5 3 7 2 4 1 6] [5 3 1 7 4 2 6] [5 3 1 7 2 4 6] [5 3 1 4 7 2 6] [5 3 1 4 2 7 6] [5 3 1 2 7 4 6] [5 3 1 2 4 7 6] [5 3 4 7 1 2 6] [5 3 4 7 2 1 6] [5 3 4 1 7 2 6] [5 3 4 1 2 7 6] [5 3 4 2 7 1 6] [5 3 4 2 1 7 6] [5 3 2 7 1 4 6] [5 3 2 7 4 1 6] [5 3 2 1 7 4 6] [5 3 2 1 4 7 6] [5 3 2 4 7 1 6] [5 3 2 4 1 7 6] [5 2 7 1 4 3 6] [5 2 7 1 3 4 6] [5 2 7 4 1 3 6] [5 2 7 4 3 1 6] [5 2 7 3 1 4 6] [5 2 7 3 4 1 6] [5 2 1 7 4 3 6] [5 2 1 7 3 4 6] [5 2 1 4 7 3 6] [5 2 1 4 3 7 6] [5 2 1 3 7 4 6] [5 2 1 3 4 7 6] [5 2 4 7 1 3 6] [5 2 4 7 3 1 6] [5 2 4 1 7 3 6] [5 2 4 1 3 7 6] [5 2 4 3 7 1 6] [5 2 4 3 1 7 6] [5 2 3 7 1 4 6] [5 2 3 7 4 1 6] [5 2 3 1 7 4 6] [5 2 3 1 4 7 6] [5 2 3 4 7 1 6] [5 2 3 4 1 7 6] [6 7 1 4 3 2 5] [6 7 1 4 2 3 5] [6 7 1 3 4 2 5] [6 7 1 3 2 4 5] [6 7 1 2 4 3 5] [6 7 1 2 3 4 5] [6 7 4 1 3 2 5] [6 7 4 1 2 3 5] [6 7 4 3 1 2 5] [6 7 4 3 2 1 5] [6 7 4 2 1 3 5] [6 7 4 2 3 1 5] [6 7 3 1 4 2 5] [6 7 3 1 2 4 5] [6 7 3 4 1 2 5] [6 7 3 4 2 1 5] [6 7 3 2 1 4 5] [6 7 3 2 4 1 5] [6 7 2 1 4 3 5] [6 7 2 1 3 4 5] [6 7 2 4 1 3 5] [6 7 2 4 3 1 5] [6 7 2 3 1 4 5] [6 7 2 3 4 1 5] [6 1 7 4 3 2 5] [6 1 7 4 2 3 5] [6 1 7 3 4 2 5] [6 1 7 3 2 4 5] [6 1 7 2 4 3 5] [6 1 7 2 3 4 5] [6 1 4 7 3 2 5] [6 1 4 7 2 3 5] [6 1 4 3 7 2 5] [6 1 4 3 2 7 5] [6 1 4 3 5 7 2] [6 1 4 2 7 3 5] [6 1 4 2 3 7 5] [6 1 4 2 5 7 3] [6 1 4 5 7 2 3] [6 1 4 5 3 7 2] [6 1 4 5 2 7 3] [6 1 3 7 4 2 5] [6 1 3 7 2 4 5] [6 1 3 4 7 2 5] [6 1 3 4 2 7 5] [6 1 3 4 5 7 2] [6 1 3 2 7 4 5] [6 1 3 2 4 7 5] [6 1 3 2 5 7 4] [6 1 3 5 7 2 4] [6 1 3 5 4 7 2] [6 1 3 5 2 7 4] [6 1 2 7 4 3 5] [6 1 2 7 3 4 5] [6 1 2 4 7 3 5] [6 1 2 4 3 7 5] [6 1 2 4 5 7 3] [6 1 2 3 7 4 5] [6 1 2 3 4 7 5] [6 1 2 3 5 7 4] [6 1 2 5 7 3 4] [6 1 2 5 4 7 3] [6 1 2 5 3 7 4] [6 1 5 7 3 2 4] [6 1 5 7 2 3 4] [6 1 5 4 7 2 3] [6 1 5 4 3 7 2] [6 1 5 4 2 7 3] [6 1 5 3 7 2 4] [6 1 5 3 4 7 2] [6 1 5 3 2 7 4] [6 1 5 2 7 3 4] [6 1 5 2 4 7 3] [6 1 5 2 3 7 4] [6 4 7 1 3 2 5] [6 4 7 1 2 3 5] [6 4 7 3 1 2 5] [6 4 7 3 2 1 5] [6 4 7 2 1 3 5] [6 4 7 2 3 1 5] [6 4 1 7 3 2 5] [6 4 1 7 2 3 5] [6 4 1 3 7 2 5] [6 4 1 3 2 7 5] [6 4 1 3 5 7 2] [6 4 1 2 7 3 5] [6 4 1 2 3 7 5] [6 4 1 2 5 7 3] [6 4 1 5 7 2 3] [6 4 1 5 3 7 2] [6 4 1 5 2 7 3] [6 4 3 7 1 2 5] [6 4 3 7 2 1 5] [6 4 3 1 7 2 5] [6 4 3 1 2 7 5] [6 4 3 1 5 7 2] [6 4 3 2 7 1 5] [6 4 3 2 1 7 5] [6 4 3 2 5 7 1] [6 4 3 5 7 1 2] [6 4 3 5 1 7 2] [6 4 3 5 2 7 1] [6 4 2 7 1 3 5] [6 4 2 7 3 1 5] [6 4 2 1 7 3 5] [6 4 2 1 3 7 5] [6 4 2 1 5 7 3] [6 4 2 3 7 1 5] [6 4 2 3 1 7 5] [6 4 2 3 5 7 1] [6 4 2 5 7 1 3] [6 4 2 5 1 7 3] [6 4 2 5 3 7 1] [6 4 5 7 1 2 3] [6 4 5 7 2 1 3] [6 4 5 1 7 2 3] [6 4 5 1 3 7 2] [6 4 5 1 2 7 3] [6 4 5 3 7 1 2] [6 4 5 3 1 7 2] [6 4 5 3 2 7 1] [6 4 5 2 7 1 3] [6 4 5 2 1 7 3] [6 4 5 2 3 7 1] [6 3 7 1 4 2 5] [6 3 7 1 2 4 5] [6 3 7 4 1 2 5] [6 3 7 4 2 1 5] [6 3 7 2 1 4 5] [6 3 7 2 4 1 5] [6 3 1 7 4 2 5] [6 3 1 7 2 4 5] [6 3 1 4 7 2 5] [6 3 1 4 2 7 5] [6 3 1 4 5 7 2] [6 3 1 2 7 4 5] [6 3 1 2 4 7 5] [6 3 1 2 5 7 4] [6 3 1 5 7 2 4] [6 3 1 5 4 7 2] [6 3 1 5 2 7 4] [6 3 4 7 1 2 5] [6 3 4 7 2 1 5] [6 3 4 1 7 2 5] [6 3 4 1 2 7 5] [6 3 4 1 5 7 2] [6 3 4 2 7 1 5] [6 3 4 2 1 7 5] [6 3 4 2 5 7 1] [6 3 4 5 7 1 2] [6 3 4 5 1 7 2] [6 3 4 5 2 7 1] [6 3 2 7 1 4 5] [6 3 2 7 4 1 5] [6 3 2 1 7 4 5] [6 3 2 1 4 7 5] [6 3 2 1 5 7 4] [6 3 2 4 7 1 5] [6 3 2 4 1 7 5] [6 3 2 4 5 7 1] [6 3 2 5 7 1 4] [6 3 2 5 1 7 4] [6 3 2 5 4 7 1] [6 3 5 7 1 2 4] [6 3 5 7 2 1 4] [6 3 5 1 7 2 4] [6 3 5 1 4 7 2] [6 3 5 1 2 7 4] [6 3 5 4 7 1 2] [6 3 5 4 1 7 2] [6 3 5 4 2 7 1] [6 3 5 2 7 1 4] [6 3 5 2 1 7 4] [6 3 5 2 4 7 1] [6 2 7 1 4 3 5] [6 2 7 1 3 4 5] [6 2 7 4 1 3 5] [6 2 7 4 3 1 5] [6 2 7 3 1 4 5] [6 2 7 3 4 1 5] [6 2 1 7 4 3 5] [6 2 1 7 3 4 5] [6 2 1 4 7 3 5] [6 2 1 4 3 7 5] [6 2 1 4 5 7 3] [6 2 1 3 7 4 5] [6 2 1 3 4 7 5] [6 2 1 3 5 7 4] [6 2 1 5 7 3 4] [6 2 1 5 4 7 3] [6 2 1 5 3 7 4] [6 2 4 7 1 3 5] [6 2 4 7 3 1 5] [6 2 4 1 7 3 5] [6 2 4 1 3 7 5] [6 2 4 1 5 7 3] [6 2 4 3 7 1 5] [6 2 4 3 1 7 5] [6 2 4 3 5 7 1] [6 2 4 5 7 1 3] [6 2 4 5 1 7 3] [6 2 4 5 3 7 1] [6 2 3 7 1 4 5] [6 2 3 7 4 1 5] [6 2 3 1 7 4 5] [6 2 3 1 4 7 5] [6 2 3 1 5 7 4] [6 2 3 4 7 1 5] [6 2 3 4 1 7 5] [6 2 3 4 5 7 1] [6 2 3 5 7 1 4] [6 2 3 5 1 7 4] [6 2 3 5 4 7 1] [6 2 5 7 1 3 4] [6 2 5 7 3 1 4] [6 2 5 1 7 3 4] [6 2 5 1 4 7 3] [6 2 5 1 3 7 4] [6 2 5 4 7 1 3] [6 2 5 4 1 7 3] [6 2 5 4 3 7 1] [6 2 5 3 7 1 4] [6 2 5 3 1 7 4] [6 2 5 3 4 7 1] [6 5 7 1 3 2 4] [6 5 7 1 2 3 4] [6 5 7 3 1 2 4] [6 5 7 3 2 1 4] [6 5 7 2 1 3 4] [6 5 7 2 3 1 4] [6 5 1 7 3 2 4] [6 5 1 7 2 3 4] [6 5 1 4 7 2 3] [6 5 1 4 3 7 2] [6 5 1 4 2 7 3] [6 5 1 3 7 2 4] [6 5 1 3 4 7 2] [6 5 1 3 2 7 4] [6 5 1 2 7 3 4] [6 5 1 2 4 7 3] [6 5 1 2 3 7 4] [6 5 4 7 1 2 3] [6 5 4 7 2 1 3] [6 5 4 1 7 2 3] [6 5 4 1 3 7 2] [6 5 4 1 2 7 3] [6 5 4 3 7 1 2] [6 5 4 3 1 7 2] [6 5 4 3 2 7 1] [6 5 4 2 7 1 3] [6 5 4 2 1 7 3] [6 5 4 2 3 7 1] [6 5 3 7 1 2 4] [6 5 3 7 2 1 4] [6 5 3 1 7 2 4] [6 5 3 1 4 7 2] [6 5 3 1 2 7 4] [6 5 3 4 7 1 2] [6 5 3 4 1 7 2] [6 5 3 4 2 7 1] [6 5 3 2 7 1 4] [6 5 3 2 1 7 4] [6 5 3 2 4 7 1] [6 5 2 7 1 3 4] [6 5 2 7 3 1 4] [6 5 2 1 7 3 4] [6 5 2 1 4 7 3] [6 5 2 1 3 7 4] [6 5 2 4 7 1 3] [6 5 2 4 1 7 3] [6 5 2 4 3 7 1] [6 5 2 3 7 1 4] [6 5 2 3 1 7 4] [6 5 2 3 4 7 1]], [2 3] [[1 7 4 6 3 2 5] [1 7 4 6 2 3 5] [1 7 4 3 6 2 5] [1 7 4 3 2 6 5] [1 7 4 3 5 6 2] [1 7 4 2 6 3 5] [1 7 4 2 3 6 5] [1 7 4 2 5 6 3] [1 7 4 5 6 2 3] [1 7 4 5 3 6 2] [1 7 4 5 2 6 3] [1 7 6 4 3 2 5] [1 7 6 4 2 3 5] [1 7 6 3 4 2 5] [1 7 6 3 2 4 5] [1 7 6 2 4 3 5] [1 7 6 2 3 4 5] [1 7 3 4 6 2 5] [1 7 3 4 2 6 5] [1 7 3 4 5 6 2] [1 7 3 6 4 2 5] [1 7 3 6 2 4 5] [1 7 3 2 4 6 5] [1 7 3 2 6 4 5] [1 7 3 2 5 6 4] [1 7 3 5 4 6 2] [1 7 3 5 6 2 4] [1 7 3 5 2 6 4] [1 7 2 4 6 3 5] [1 7 2 4 3 6 5] [1 7 2 4 5 6 3] [1 7 2 6 4 3 5] [1 7 2 6 3 4 5] [1 7 2 3 4 6 5] [1 7 2 3 6 4 5] [1 7 2 3 5 6 4] [1 7 2 5 4 6 3] [1 7 2 5 6 3 4] [1 7 2 5 3 6 4] [1 7 5 4 6 2 3] [1 7 5 4 3 6 2] [1 7 5 4 2 6 3] [1 7 5 6 3 2 4] [1 7 5 6 2 3 4] [1 7 5 3 4 6 2] [1 7 5 3 6 2 4] [1 7 5 3 2 6 4] [1 7 5 2 4 6 3] [1 7 5 2 6 3 4] [1 7 5 2 3 6 4] [2 7 1 4 6 3 5] [2 7 1 4 3 6 5] [2 7 1 4 5 6 3] [2 7 1 6 4 3 5] [2 7 1 6 3 4 5] [2 7 1 3 4 6 5] [2 7 1 3 6 4 5] [2 7 1 3 5 6 4] [2 7 1 5 4 6 3] [2 7 1 5 6 3 4] [2 7 1 5 3 6 4] [2 7 4 1 6 3 5] [2 7 4 1 3 6 5] [2 7 4 1 5 6 3] [2 7 4 6 1 3 5] [2 7 4 6 3 1 5] [2 7 4 3 1 6 5] [2 7 4 3 6 1 5] [2 7 4 3 5 6 1] [2 7 4 5 1 6 3] [2 7 4 5 6 1 3] [2 7 4 5 3 6 1] [2 7 6 1 4 3 5] [2 7 6 1 3 4 5] [2 7 6 4 1 3 5] [2 7 6 4 3 1 5] [2 7 6 3 1 4 5] [2 7 6 3 4 1 5] [2 7 3 1 4 6 5] [2 7 3 1 6 4 5] [2 7 3 1 5 6 4] [2 7 3 4 1 6 5] [2 7 3 4 6 1 5] [2 7 3 4 5 6 1] [2 7 3 6 1 4 5] [2 7 3 6 4 1 5] [2 7 3 5 1 6 4] [2 7 3 5 4 6 1] [2 7 3 5 6 1 4] [2 7 5 1 4 6 3] [2 7 5 1 6 3 4] [2 7 5 1 3 6 4] [2 7 5 4 1 6 3] [2 7 5 4 6 1 3] [2 7 5 4 3 6 1] [2 7 5 6 1 3 4] [2 7 5 6 3 1 4] [2 7 5 3 1 6 4] [2 7 5 3 4 6 1] [2 7 5 3 6 1 4] [2 1 7 4 6 3 5] [2 1 7 4 3 6 5] [2 1 7 4 5 6 3] [2 1 7 6 4 3 5] [2 1 7 6 3 4 5] [2 1 7 3 4 6 5] [2 1 7 3 6 4 5] [2 1 7 3 5 6 4] [2 1 7 5 4 6 3] [2 1 7 5 6 3 4] [2 1 7 5 3 6 4] [3 7 1 4 6 2 5] [3 7 1 4 2 6 5] [3 7 1 4 5 6 2] [3 7 1 6 4 2 5] [3 7 1 6 2 4 5] [3 7 1 2 4 6 5] [3 7 1 2 6 4 5] [3 7 1 2 5 6 4] [3 7 1 5 4 6 2] [3 7 1 5 6 2 4] [3 7 1 5 2 6 4] [3 7 4 1 6 2 5] [3 7 4 1 2 6 5] [3 7 4 1 5 6 2] [3 7 4 6 1 2 5] [3 7 4 6 2 1 5] [3 7 4 2 1 6 5] [3 7 4 2 6 1 5] [3 7 4 2 5 6 1] [3 7 4 5 1 6 2] [3 7 4 5 6 1 2] [3 7 4 5 2 6 1] [3 7 6 1 4 2 5] [3 7 6 1 2 4 5] [3 7 6 4 1 2 5] [3 7 6 4 2 1 5] [3 7 6 2 1 4 5] [3 7 6 2 4 1 5] [3 7 2 1 4 6 5] [3 7 2 1 6 4 5] [3 7 2 1 5 6 4] [3 7 2 4 1 6 5] [3 7 2 4 6 1 5] [3 7 2 4 5 6 1] [3 7 2 6 1 4 5] [3 7 2 6 4 1 5] [3 7 2 5 1 6 4] [3 7 2 5 4 6 1] [3 7 2 5 6 1 4] [3 7 5 1 4 6 2] [3 7 5 1 6 2 4] [3 7 5 1 2 6 4] [3 7 5 4 1 6 2] [3 7 5 4 6 1 2] [3 7 5 4 2 6 1] [3 7 5 6 1 2 4] [3 7 5 6 2 1 4] [3 7 5 2 1 6 4] [3 7 5 2 4 6 1] [3 7 5 2 6 1 4] [3 1 7 4 6 2 5] [3 1 7 4 2 6 5] [3 1 7 4 5 6 2] [3 1 7 6 4 2 5] [3 1 7 6 2 4 5] [3 1 7 2 4 6 5] [3 1 7 2 6 4 5] [3 1 7 2 5 6 4] [3 1 7 5 4 6 2] [3 1 7 5 6 2 4] [3 1 7 5 2 6 4] [3 1 2 7 4 6 5] [3 1 2 7 6 4 5] [3 1 2 7 5 6 4] [3 2 7 1 4 6 5] [3 2 7 1 6 4 5] [3 2 7 1 5 6 4] [3 2 7 4 1 6 5] [3 2 7 4 6 1 5] [3 2 7 4 5 6 1] [3 2 7 6 1 4 5] [3 2 7 6 4 1 5] [3 2 7 5 1 6 4] [3 2 7 5 4 6 1] [3 2 7 5 6 1 4] [3 2 1 7 4 6 5] [3 2 1 7 6 4 5] [3 2 1 7 5 6 4] [4 7 1 6 3 2 5] [4 7 1 6 2 3 5] [4 7 1 3 6 2 5] [4 7 1 3 2 6 5] [4 7 1 3 5 6 2] [4 7 1 2 6 3 5] [4 7 1 2 3 6 5] [4 7 1 2 5 6 3] [4 7 1 5 6 2 3] [4 7 1 5 3 6 2] [4 7 1 5 2 6 3] [4 7 6 1 3 2 5] [4 7 6 1 2 3 5] [4 7 6 3 1 2 5] [4 7 6 3 2 1 5] [4 7 6 2 1 3 5] [4 7 6 2 3 1 5] [4 7 3 1 6 2 5] [4 7 3 1 2 6 5] [4 7 3 1 5 6 2] [4 7 3 6 1 2 5] [4 7 3 6 2 1 5] [4 7 3 2 1 6 5] [4 7 3 2 6 1 5] [4 7 3 2 5 6 1] [4 7 3 5 1 6 2] [4 7 3 5 6 1 2] [4 7 3 5 2 6 1] [4 7 2 1 6 3 5] [4 7 2 1 3 6 5] [4 7 2 1 5 6 3] [4 7 2 6 1 3 5] [4 7 2 6 3 1 5] [4 7 2 3 1 6 5] [4 7 2 3 6 1 5] [4 7 2 3 5 6 1] [4 7 2 5 1 6 3] [4 7 2 5 6 1 3] [4 7 2 5 3 6 1] [4 7 5 1 6 2 3] [4 7 5 1 3 6 2] [4 7 5 1 2 6 3] [4 7 5 6 1 2 3] [4 7 5 6 2 1 3] [4 7 5 3 1 6 2] [4 7 5 3 6 1 2] [4 7 5 3 2 6 1] [4 7 5 2 1 6 3] [4 7 5 2 6 1 3] [4 7 5 2 3 6 1] [4 1 7 6 3 2 5] [4 1 7 6 2 3 5] [4 1 7 3 6 2 5] [4 1 7 3 2 6 5] [4 1 7 3 5 6 2] [4 1 7 2 6 3 5] [4 1 7 2 3 6 5] [4 1 7 2 5 6 3] [4 1 7 5 6 2 3] [4 1 7 5 3 6 2] [4 1 7 5 2 6 3] [4 1 3 7 6 2 5] [4 1 3 7 2 6 5] [4 1 3 7 5 6 2] [4 1 3 2 7 6 5] [4 1 2 7 6 3 5] [4 1 2 7 3 6 5] [4 1 2 7 5 6 3] [4 1 2 3 7 6 5] [4 3 7 1 6 2 5] [4 3 7 1 2 6 5] [4 3 7 1 5 6 2] [4 3 7 6 1 2 5] [4 3 7 6 2 1 5] [4 3 7 2 1 6 5] [4 3 7 2 6 1 5] [4 3 7 2 5 6 1] [4 3 7 5 1 6 2] [4 3 7 5 6 1 2] [4 3 7 5 2 6 1] [4 3 1 7 6 2 5] [4 3 1 7 2 6 5] [4 3 1 7 5 6 2] [4 3 1 2 7 6 5] [4 3 2 7 1 6 5] [4 3 2 7 6 1 5] [4 3 2 7 5 6 1] [4 3 2 1 7 6 5] [4 2 7 1 6 3 5] [4 2 7 1 3 6 5] [4 2 7 1 5 6 3] [4 2 7 6 1 3 5] [4 2 7 6 3 1 5] [4 2 7 3 1 6 5] [4 2 7 3 6 1 5] [4 2 7 3 5 6 1] [4 2 7 5 1 6 3] [4 2 7 5 6 1 3] [4 2 7 5 3 6 1] [4 2 1 7 6 3 5] [4 2 1 7 3 6 5] [4 2 1 7 5 6 3] [4 2 1 3 7 6 5] [4 2 3 7 1 6 5] [4 2 3 7 6 1 5] [4 2 3 7 5 6 1] [4 2 3 1 7 6 5] [5 7 1 4 6 2 3] [5 7 1 4 3 6 2] [5 7 1 4 2 6 3] [5 7 1 6 3 2 4] [5 7 1 6 2 3 4] [5 7 1 3 4 6 2] [5 7 1 3 6 2 4] [5 7 1 3 2 6 4] [5 7 1 2 4 6 3] [5 7 1 2 6 3 4] [5 7 1 2 3 6 4] [5 7 4 1 6 2 3] [5 7 4 1 3 6 2] [5 7 4 1 2 6 3] [5 7 4 6 1 2 3] [5 7 4 6 2 1 3] [5 7 4 3 1 6 2] [5 7 4 3 6 1 2] [5 7 4 3 2 6 1] [5 7 4 2 1 6 3] [5 7 4 2 6 1 3] [5 7 4 2 3 6 1] [5 7 6 1 3 2 4] [5 7 6 1 2 3 4] [5 7 6 3 1 2 4] [5 7 6 3 2 1 4] [5 7 6 2 1 3 4] [5 7 6 2 3 1 4] [5 7 3 1 4 6 2] [5 7 3 1 6 2 4] [5 7 3 1 2 6 4] [5 7 3 4 1 6 2] [5 7 3 4 6 1 2] [5 7 3 4 2 6 1] [5 7 3 6 1 2 4] [5 7 3 6 2 1 4] [5 7 3 2 1 6 4] [5 7 3 2 4 6 1] [5 7 3 2 6 1 4] [5 7 2 1 4 6 3] [5 7 2 1 6 3 4] [5 7 2 1 3 6 4] [5 7 2 4 1 6 3] [5 7 2 4 6 1 3] [5 7 2 4 3 6 1] [5 7 2 6 1 3 4] [5 7 2 6 3 1 4] [5 7 2 3 1 6 4] [5 7 2 3 4 6 1] [5 7 2 3 6 1 4] [5 1 7 4 6 2 3] [5 1 7 4 3 6 2] [5 1 7 4 2 6 3] [5 1 7 6 3 2 4] [5 1 7 6 2 3 4] [5 1 7 3 4 6 2] [5 1 7 3 6 2 4] [5 1 7 3 2 6 4] [5 1 7 2 4 6 3] [5 1 7 2 6 3 4] [5 1 7 2 3 6 4] [5 1 4 7 6 2 3] [5 1 4 7 3 6 2] [5 1 4 7 2 6 3] [5 1 4 3 7 6 2] [5 1 4 2 7 6 3] [5 1 3 7 4 6 2] [5 1 3 7 6 2 4] [5 1 3 7 2 6 4] [5 1 3 4 7 6 2] [5 1 3 2 7 6 4] [5 1 2 7 4 6 3] [5 1 2 7 6 3 4] [5 1 2 7 3 6 4] [5 1 2 4 7 6 3] [5 1 2 3 7 6 4] [5 4 7 1 6 2 3] [5 4 7 1 3 6 2] [5 4 7 1 2 6 3] [5 4 7 6 1 2 3] [5 4 7 6 2 1 3] [5 4 7 3 1 6 2] [5 4 7 3 6 1 2] [5 4 7 3 2 6 1] [5 4 7 2 1 6 3] [5 4 7 2 6 1 3] [5 4 7 2 3 6 1] [5 4 1 7 6 2 3] [5 4 1 7 3 6 2] [5 4 1 7 2 6 3] [5 4 1 3 7 6 2] [5 4 1 2 7 6 3] [5 4 3 7 1 6 2] [5 4 3 7 6 1 2] [5 4 3 7 2 6 1] [5 4 3 1 7 6 2] [5 4 3 2 7 6 1] [5 4 2 7 1 6 3] [5 4 2 7 6 1 3] [5 4 2 7 3 6 1] [5 4 2 1 7 6 3] [5 4 2 3 7 6 1] [5 3 7 1 4 6 2] [5 3 7 1 6 2 4] [5 3 7 1 2 6 4] [5 3 7 4 1 6 2] [5 3 7 4 6 1 2] [5 3 7 4 2 6 1] [5 3 7 6 1 2 4] [5 3 7 6 2 1 4] [5 3 7 2 1 6 4] [5 3 7 2 4 6 1] [5 3 7 2 6 1 4] [5 3 1 7 4 6 2] [5 3 1 7 6 2 4] [5 3 1 7 2 6 4] [5 3 1 4 7 6 2] [5 3 1 2 7 6 4] [5 3 4 7 1 6 2] [5 3 4 7 6 1 2] [5 3 4 7 2 6 1] [5 3 4 1 7 6 2] [5 3 4 2 7 6 1] [5 3 2 7 1 6 4] [5 3 2 7 4 6 1] [5 3 2 7 6 1 4] [5 3 2 1 7 6 4] [5 3 2 4 7 6 1] [5 2 7 1 4 6 3] [5 2 7 1 6 3 4] [5 2 7 1 3 6 4] [5 2 7 4 1 6 3] [5 2 7 4 6 1 3] [5 2 7 4 3 6 1] [5 2 7 6 1 3 4] [5 2 7 6 3 1 4] [5 2 7 3 1 6 4] [5 2 7 3 4 6 1] [5 2 7 3 6 1 4] [5 2 1 7 4 6 3] [5 2 1 7 6 3 4] [5 2 1 7 3 6 4] [5 2 1 4 7 6 3] [5 2 1 3 7 6 4] [5 2 4 7 1 6 3] [5 2 4 7 6 1 3] [5 2 4 7 3 6 1] [5 2 4 1 7 6 3] [5 2 4 3 7 6 1] [5 2 3 7 1 6 4] [5 2 3 7 4 6 1] [5 2 3 7 6 1 4] [5 2 3 1 7 6 4] [5 2 3 4 7 6 1] [6 7 1 4 3 5 2] [6 7 1 4 2 5 3] [6 7 1 4 5 2 3] [6 7 1 3 4 5 2] [6 7 1 3 2 5 4] [6 7 1 3 5 2 4] [6 7 1 2 4 5 3] [6 7 1 2 3 5 4] [6 7 1 2 5 3 4] [6 7 1 5 3 2 4] [6 7 1 5 2 3 4] [6 7 4 1 3 5 2] [6 7 4 1 2 5 3] [6 7 4 1 5 2 3] [6 7 4 3 1 5 2] [6 7 4 3 2 5 1] [6 7 4 3 5 1 2] [6 7 4 2 1 5 3] [6 7 4 2 3 5 1] [6 7 4 2 5 1 3] [6 7 4 5 1 2 3] [6 7 4 5 2 1 3] [6 7 3 1 4 5 2] [6 7 3 1 2 5 4] [6 7 3 1 5 2 4] [6 7 3 4 1 5 2] [6 7 3 4 2 5 1] [6 7 3 4 5 1 2] [6 7 3 2 1 5 4] [6 7 3 2 4 5 1] [6 7 3 2 5 1 4] [6 7 3 5 1 2 4] [6 7 3 5 2 1 4] [6 7 2 1 4 5 3] [6 7 2 1 3 5 4] [6 7 2 1 5 3 4] [6 7 2 4 1 5 3] [6 7 2 4 3 5 1] [6 7 2 4 5 1 3] [6 7 2 3 1 5 4] [6 7 2 3 4 5 1] [6 7 2 3 5 1 4] [6 7 2 5 1 3 4] [6 7 2 5 3 1 4] [6 7 5 1 3 2 4] [6 7 5 1 2 3 4] [6 7 5 3 1 2 4] [6 7 5 3 2 1 4] [6 7 5 2 1 3 4] [6 7 5 2 3 1 4] [6 1 7 4 3 5 2] [6 1 7 4 2 5 3] [6 1 7 4 5 2 3] [6 1 7 3 4 5 2] [6 1 7 3 2 5 4] [6 1 7 3 5 2 4] [6 1 7 2 4 5 3] [6 1 7 2 3 5 4] [6 1 7 2 5 3 4] [6 1 7 5 3 2 4] [6 1 7 5 2 3 4] [6 1 4 7 3 5 2] [6 1 4 7 2 5 3] [6 1 4 7 5 2 3] [6 1 4 3 7 5 2] [6 1 4 2 7 5 3] [6 1 4 5 7 3 2] [6 1 3 7 4 5 2] [6 1 3 7 2 5 4] [6 1 3 7 5 2 4] [6 1 3 4 7 5 2] [6 1 3 2 7 5 4] [6 1 3 5 7 4 2] [6 1 2 7 4 5 3] [6 1 2 7 3 5 4] [6 1 2 7 5 3 4] [6 1 2 4 7 5 3] [6 1 2 3 7 5 4] [6 1 2 5 7 4 3] [6 1 5 7 4 2 3] [6 1 5 7 3 4 2] [6 1 5 7 2 4 3] [6 1 5 4 7 3 2] [6 1 5 3 7 4 2] [6 1 5 2 7 4 3] [6 4 7 1 3 5 2] [6 4 7 1 2 5 3] [6 4 7 1 5 2 3] [6 4 7 3 1 5 2] [6 4 7 3 2 5 1] [6 4 7 3 5 1 2] [6 4 7 2 1 5 3] [6 4 7 2 3 5 1] [6 4 7 2 5 1 3] [6 4 7 5 1 2 3] [6 4 7 5 2 1 3] [6 4 1 7 3 5 2] [6 4 1 7 2 5 3] [6 4 1 7 5 2 3] [6 4 1 3 7 5 2] [6 4 1 2 7 5 3] [6 4 1 5 7 3 2] [6 4 3 7 1 5 2] [6 4 3 7 2 5 1] [6 4 3 7 5 1 2] [6 4 3 1 7 5 2] [6 4 3 2 7 5 1] [6 4 3 5 7 2 1] [6 4 2 7 1 5 3] [6 4 2 7 3 5 1] [6 4 2 7 5 1 3] [6 4 2 1 7 5 3] [6 4 2 3 7 5 1] [6 4 2 5 7 3 1] [6 4 5 7 1 3 2] [6 4 5 7 3 1 2] [6 4 5 7 2 3 1] [6 4 5 1 7 3 2] [6 4 5 3 7 2 1] [6 4 5 2 7 3 1] [6 3 7 1 4 5 2] [6 3 7 1 2 5 4] [6 3 7 1 5 2 4] [6 3 7 4 1 5 2] [6 3 7 4 2 5 1] [6 3 7 4 5 1 2] [6 3 7 2 1 5 4] [6 3 7 2 4 5 1] [6 3 7 2 5 1 4] [6 3 7 5 1 2 4] [6 3 7 5 2 1 4] [6 3 1 7 4 5 2] [6 3 1 7 2 5 4] [6 3 1 7 5 2 4] [6 3 1 4 7 5 2] [6 3 1 2 7 5 4] [6 3 1 5 7 4 2] [6 3 4 7 1 5 2] [6 3 4 7 2 5 1] [6 3 4 7 5 1 2] [6 3 4 1 7 5 2] [6 3 4 2 7 5 1] [6 3 4 5 7 2 1] [6 3 2 7 1 5 4] [6 3 2 7 4 5 1] [6 3 2 7 5 1 4] [6 3 2 1 7 5 4] [6 3 2 4 7 5 1] [6 3 2 5 7 4 1] [6 3 5 7 1 4 2] [6 3 5 7 4 1 2] [6 3 5 7 2 4 1] [6 3 5 1 7 4 2] [6 3 5 4 7 2 1] [6 3 5 2 7 4 1] [6 2 7 1 4 5 3] [6 2 7 1 3 5 4] [6 2 7 1 5 3 4] [6 2 7 4 1 5 3] [6 2 7 4 3 5 1] [6 2 7 4 5 1 3] [6 2 7 3 1 5 4] [6 2 7 3 4 5 1] [6 2 7 3 5 1 4] [6 2 7 5 1 3 4] [6 2 7 5 3 1 4] [6 2 1 7 4 5 3] [6 2 1 7 3 5 4] [6 2 1 7 5 3 4] [6 2 1 4 7 5 3] [6 2 1 3 7 5 4] [6 2 1 5 7 4 3] [6 2 4 7 1 5 3] [6 2 4 7 3 5 1] [6 2 4 7 5 1 3] [6 2 4 1 7 5 3] [6 2 4 3 7 5 1] [6 2 4 5 7 3 1] [6 2 3 7 1 5 4] [6 2 3 7 4 5 1] [6 2 3 7 5 1 4] [6 2 3 1 7 5 4] [6 2 3 4 7 5 1] [6 2 3 5 7 4 1] [6 2 5 7 1 4 3] [6 2 5 7 4 1 3] [6 2 5 7 3 4 1] [6 2 5 1 7 4 3] [6 2 5 4 7 3 1] [6 2 5 3 7 4 1] [6 5 7 1 4 2 3] [6 5 7 1 3 4 2] [6 5 7 1 2 4 3] [6 5 7 4 1 2 3] [6 5 7 4 2 1 3] [6 5 7 3 1 4 2] [6 5 7 3 4 1 2] [6 5 7 3 2 4 1] [6 5 7 2 1 4 3] [6 5 7 2 4 1 3] [6 5 7 2 3 4 1] [6 5 1 7 4 2 3] [6 5 1 7 3 4 2] [6 5 1 7 2 4 3] [6 5 1 4 7 3 2] [6 5 1 3 7 4 2] [6 5 1 2 7 4 3] [6 5 4 7 1 3 2] [6 5 4 7 3 1 2] [6 5 4 7 2 3 1] [6 5 4 1 7 3 2] [6 5 4 3 7 2 1] [6 5 4 2 7 3 1] [6 5 3 7 1 4 2] [6 5 3 7 4 1 2] [6 5 3 7 2 4 1] [6 5 3 1 7 4 2] [6 5 3 4 7 2 1] [6 5 3 2 7 4 1] [6 5 2 7 1 4 3] [6 5 2 7 4 1 3] [6 5 2 7 3 4 1] [6 5 2 1 7 4 3] [6 5 2 4 7 3 1] [6 5 2 3 7 4 1]], [2 5] [[1 7 4 6 5 3 2] [1 7 6 4 5 3 2] [1 7 6 3 5 4 2] [1 7 6 2 5 4 3] [1 7 6 5 4 2 3] [1 7 6 5 3 4 2] [1 7 6 5 2 4 3] [1 7 3 6 5 4 2] [1 7 2 6 5 4 3] [1 7 5 6 4 3 2] [2 7 1 6 5 4 3] [2 7 4 6 5 3 1] [2 7 6 1 5 4 3] [2 7 6 4 5 3 1] [2 7 6 3 5 4 1] [2 7 6 5 1 4 3] [2 7 6 5 4 1 3] [2 7 6 5 3 4 1] [2 7 3 6 5 4 1] [2 7 5 6 4 3 1] [2 1 7 6 5 4 3] [3 7 1 6 5 4 2] [3 7 4 6 5 2 1] [3 7 6 1 5 4 2] [3 7 6 4 5 2 1] [3 7 6 2 5 4 1] [3 7 6 5 1 4 2] [3 7 6 5 4 1 2] [3 7 6 5 2 4 1] [3 7 2 6 5 4 1] [3 7 5 6 4 2 1] [3 1 7 6 5 4 2] [3 2 7 6 5 4 1] [4 7 1 6 5 3 2] [4 7 6 1 5 3 2] [4 7 6 3 5 2 1] [4 7 6 2 5 3 1] [4 7 6 5 1 3 2] [4 7 6 5 3 1 2] [4 7 6 5 2 3 1] [4 7 3 6 5 2 1] [4 7 2 6 5 3 1] [4 7 5 6 3 2 1] [4 1 7 6 5 3 2] [4 3 7 6 5 2 1] [4 2 7 6 5 3 1] [5 7 1 6 4 3 2] [5 7 4 6 3 2 1] [5 7 6 1 4 3 2] [5 7 6 4 1 3 2] [5 7 6 4 3 1 2] [5 7 6 4 2 3 1] [5 7 6 3 4 2 1] [5 7 6 2 4 3 1] [5 7 3 6 4 2 1] [5 7 2 6 4 3 1] [5 1 7 6 4 3 2] [5 4 7 6 3 2 1] [5 3 7 6 4 2 1] [5 2 7 6 4 3 1] [6 7 1 5 4 3 2] [6 7 4 5 3 2 1] [6 7 3 5 4 2 1] [6 7 2 5 4 3 1] [6 7 5 1 4 3 2] [6 7 5 4 1 3 2] [6 7 5 4 3 1 2] [6 7 5 4 2 3 1] [6 7 5 3 4 2 1] [6 7 5 2 4 3 1] [6 1 7 5 4 3 2] [6 4 7 5 3 2 1] [6 3 7 5 4 2 1] [6 2 7 5 4 3 1] [6 5 7 4 3 2 1]], [3 3] [[1 4 7 6 3 2 5] [1 4 7 6 2 3 5] [1 4 7 3 6 2 5] [1 4 7 3 2 6 5] [1 4 7 3 5 6 2] [1 4 7 2 6 3 5] [1 4 7 2 3 6 5] [1 4 7 2 5 6 3] [1 4 7 5 6 2 3] [1 4 7 5 3 6 2] [1 4 7 5 2 6 3] [1 4 3 7 6 2 5] [1 4 3 7 2 6 5] [1 4 3 7 5 6 2] [1 4 3 2 7 6 5] [1 4 2 7 6 3 5] [1 4 2 7 3 6 5] [1 4 2 7 5 6 3] [1 4 2 3 7 6 5] [1 6 7 4 3 5 2] [1 6 7 4 2 5 3] [1 6 7 4 5 2 3] [1 6 7 3 4 5 2] [1 6 7 3 2 5 4] [1 6 7 3 5 2 4] [1 6 7 2 4 5 3] [1 6 7 2 3 5 4] [1 6 7 2 5 3 4] [1 6 7 5 3 2 4] [1 6 7 5 2 3 4] [1 6 4 7 3 5 2] [1 6 4 7 2 5 3] [1 6 4 7 5 2 3] [1 6 4 3 7 5 2] [1 6 4 2 7 5 3] [1 6 4 5 7 3 2] [1 6 3 7 4 5 2] [1 6 3 7 2 5 4] [1 6 3 7 5 2 4] [1 6 3 4 7 5 2] [1 6 3 2 7 5 4] [1 6 3 5 7 4 2] [1 6 2 7 4 5 3] [1 6 2 7 3 5 4] [1 6 2 7 5 3 4] [1 6 2 4 7 5 3] [1 6 2 3 7 5 4] [1 6 2 5 7 4 3] [1 6 5 7 4 2 3] [1 6 5 7 3 4 2] [1 6 5 7 2 4 3] [1 6 5 4 7 3 2] [1 6 5 3 7 4 2] [1 6 5 2 7 4 3] [1 3 7 4 6 2 5] [1 3 7 4 2 6 5] [1 3 7 4 5 6 2] [1 3 7 6 4 2 5] [1 3 7 6 2 4 5] [1 3 7 2 4 6 5] [1 3 7 2 6 4 5] [1 3 7 2 5 6 4] [1 3 7 5 4 6 2] [1 3 7 5 6 2 4] [1 3 7 5 2 6 4] [1 3 2 7 4 6 5] [1 3 2 7 6 4 5] [1 3 2 7 5 6 4] [1 2 7 4 6 3 5] [1 2 7 4 3 6 5] [1 2 7 4 5 6 3] [1 2 7 6 4 3 5] [1 2 7 6 3 4 5] [1 2 7 3 4 6 5] [1 2 7 3 6 4 5] [1 2 7 3 5 6 4] [1 2 7 5 4 6 3] [1 2 7 5 6 3 4] [1 2 7 5 3 6 4] [1 5 7 4 6 2 3] [1 5 7 4 3 6 2] [1 5 7 4 2 6 3] [1 5 7 6 3 2 4] [1 5 7 6 2 3 4] [1 5 7 3 4 6 2] [1 5 7 3 6 2 4] [1 5 7 3 2 6 4] [1 5 7 2 4 6 3] [1 5 7 2 6 3 4] [1 5 7 2 3 6 4] [1 5 4 7 6 2 3] [1 5 4 7 3 6 2] [1 5 4 7 2 6 3] [1 5 4 3 7 6 2] [1 5 4 2 7 6 3] [1 5 3 7 4 6 2] [1 5 3 7 6 2 4] [1 5 3 7 2 6 4] [1 5 3 4 7 6 2] [1 5 3 2 7 6 4] [1 5 2 7 4 6 3] [1 5 2 7 6 3 4] [1 5 2 7 3 6 4] [1 5 2 4 7 6 3] [1 5 2 3 7 6 4] [2 1 4 7 6 3 5] [2 1 4 7 3 6 5] [2 1 4 7 5 6 3] [2 1 4 3 7 6 5] [2 1 6 7 4 5 3] [2 1 6 7 3 5 4] [2 1 6 7 5 3 4] [2 1 6 4 7 5 3] [2 1 6 3 7 5 4] [2 1 6 5 7 4 3] [2 1 3 7 4 6 5] [2 1 3 7 6 4 5] [2 1 3 7 5 6 4] [2 1 5 7 4 6 3] [2 1 5 7 6 3 4] [2 1 5 7 3 6 4] [2 1 5 4 7 6 3] [2 1 5 3 7 6 4] [2 4 7 1 6 3 5] [2 4 7 1 3 6 5] [2 4 7 1 5 6 3] [2 4 7 6 1 3 5] [2 4 7 6 3 1 5] [2 4 7 3 1 6 5] [2 4 7 3 6 1 5] [2 4 7 3 5 6 1] [2 4 7 5 1 6 3] [2 4 7 5 6 1 3] [2 4 7 5 3 6 1] [2 4 1 7 6 3 5] [2 4 1 7 3 6 5] [2 4 1 7 5 6 3] [2 4 1 3 7 6 5] [2 4 3 7 1 6 5] [2 4 3 7 6 1 5] [2 4 3 7 5 6 1] [2 4 3 1 7 6 5] [2 6 7 1 4 5 3] [2 6 7 1 3 5 4] [2 6 7 1 5 3 4] [2 6 7 4 1 5 3] [2 6 7 4 3 5 1] [2 6 7 4 5 1 3] [2 6 7 3 1 5 4] [2 6 7 3 4 5 1] [2 6 7 3 5 1 4] [2 6 7 5 1 3 4] [2 6 7 5 3 1 4] [2 6 1 7 4 5 3] [2 6 1 7 3 5 4] [2 6 1 7 5 3 4] [2 6 1 4 7 5 3] [2 6 1 3 7 5 4] [2 6 1 5 7 4 3] [2 6 4 7 1 5 3] [2 6 4 7 3 5 1] [2 6 4 7 5 1 3] [2 6 4 1 7 5 3] [2 6 4 3 7 5 1] [2 6 4 5 7 3 1] [2 6 3 7 1 5 4] [2 6 3 7 4 5 1] [2 6 3 7 5 1 4] [2 6 3 1 7 5 4] [2 6 3 4 7 5 1] [2 6 3 5 7 4 1] [2 6 5 7 1 4 3] [2 6 5 7 4 1 3] [2 6 5 7 3 4 1] [2 6 5 1 7 4 3] [2 6 5 4 7 3 1] [2 6 5 3 7 4 1] [2 3 7 1 4 6 5] [2 3 7 1 6 4 5] [2 3 7 1 5 6 4] [2 3 7 4 1 6 5] [2 3 7 4 6 1 5] [2 3 7 4 5 6 1] [2 3 7 6 1 4 5] [2 3 7 6 4 1 5] [2 3 7 5 1 6 4] [2 3 7 5 4 6 1] [2 3 7 5 6 1 4] [2 3 1 7 4 6 5] [2 3 1 7 6 4 5] [2 3 1 7 5 6 4] [2 5 7 1 4 6 3] [2 5 7 1 6 3 4] [2 5 7 1 3 6 4] [2 5 7 4 1 6 3] [2 5 7 4 6 1 3] [2 5 7 4 3 6 1] [2 5 7 6 1 3 4] [2 5 7 6 3 1 4] [2 5 7 3 1 6 4] [2 5 7 3 4 6 1] [2 5 7 3 6 1 4] [2 5 1 7 4 6 3] [2 5 1 7 6 3 4] [2 5 1 7 3 6 4] [2 5 1 4 7 6 3] [2 5 1 3 7 6 4] [2 5 4 7 1 6 3] [2 5 4 7 6 1 3] [2 5 4 7 3 6 1] [2 5 4 1 7 6 3] [2 5 4 3 7 6 1] [2 5 3 7 1 6 4] [2 5 3 7 4 6 1] [2 5 3 7 6 1 4] [2 5 3 1 7 6 4] [2 5 3 4 7 6 1] [3 1 4 7 6 2 5] [3 1 4 7 2 6 5] [3 1 4 7 5 6 2] [3 1 4 2 7 6 5] [3 1 6 7 4 5 2] [3 1 6 7 2 5 4] [3 1 6 7 5 2 4] [3 1 6 4 7 5 2] [3 1 6 2 7 5 4] [3 1 6 5 7 4 2] [3 1 2 4 7 6 5] [3 1 2 6 7 5 4] [3 1 2 5 7 6 4] [3 1 5 7 4 6 2] [3 1 5 7 6 2 4] [3 1 5 7 2 6 4] [3 1 5 4 7 6 2] [3 1 5 2 7 6 4] [3 4 7 1 6 2 5] [3 4 7 1 2 6 5] [3 4 7 1 5 6 2] [3 4 7 6 1 2 5] [3 4 7 6 2 1 5] [3 4 7 2 1 6 5] [3 4 7 2 6 1 5] [3 4 7 2 5 6 1] [3 4 7 5 1 6 2] [3 4 7 5 6 1 2] [3 4 7 5 2 6 1] [3 4 1 7 6 2 5] [3 4 1 7 2 6 5] [3 4 1 7 5 6 2] [3 4 1 2 7 6 5] [3 4 2 7 1 6 5] [3 4 2 7 6 1 5] [3 4 2 7 5 6 1] [3 4 2 1 7 6 5] [3 6 7 1 4 5 2] [3 6 7 1 2 5 4] [3 6 7 1 5 2 4] [3 6 7 4 1 5 2] [3 6 7 4 2 5 1] [3 6 7 4 5 1 2] [3 6 7 2 1 5 4] [3 6 7 2 4 5 1] [3 6 7 2 5 1 4] [3 6 7 5 1 2 4] [3 6 7 5 2 1 4] [3 6 1 7 4 5 2] [3 6 1 7 2 5 4] [3 6 1 7 5 2 4] [3 6 1 4 7 5 2] [3 6 1 2 7 5 4] [3 6 1 5 7 4 2] [3 6 4 7 1 5 2] [3 6 4 7 2 5 1] [3 6 4 7 5 1 2] [3 6 4 1 7 5 2] [3 6 4 2 7 5 1] [3 6 4 5 7 2 1] [3 6 2 7 1 5 4] [3 6 2 7 4 5 1] [3 6 2 7 5 1 4] [3 6 2 1 7 5 4] [3 6 2 4 7 5 1] [3 6 2 5 7 4 1] [3 6 5 7 1 4 2] [3 6 5 7 4 1 2] [3 6 5 7 2 4 1] [3 6 5 1 7 4 2] [3 6 5 4 7 2 1] [3 6 5 2 7 4 1] [3 2 1 4 7 6 5] [3 2 1 6 7 5 4] [3 2 1 5 7 6 4] [3 2 4 7 1 6 5] [3 2 4 7 6 1 5] [3 2 4 7 5 6 1] [3 2 4 1 7 6 5] [3 2 6 7 1 5 4] [3 2 6 7 4 5 1] [3 2 6 7 5 1 4] [3 2 6 1 7 5 4] [3 2 6 4 7 5 1] [3 2 6 5 7 4 1] [3 2 5 7 1 6 4] [3 2 5 7 4 6 1] [3 2 5 7 6 1 4] [3 2 5 1 7 6 4] [3 2 5 4 7 6 1] [3 5 7 1 4 6 2] [3 5 7 1 6 2 4] [3 5 7 1 2 6 4] [3 5 7 4 1 6 2] [3 5 7 4 6 1 2] [3 5 7 4 2 6 1] [3 5 7 6 1 2 4] [3 5 7 6 2 1 4] [3 5 7 2 1 6 4] [3 5 7 2 4 6 1] [3 5 7 2 6 1 4] [3 5 1 7 4 6 2] [3 5 1 7 6 2 4] [3 5 1 7 2 6 4] [3 5 1 4 7 6 2] [3 5 1 2 7 6 4] [3 5 4 7 1 6 2] [3 5 4 7 6 1 2] [3 5 4 7 2 6 1] [3 5 4 1 7 6 2] [3 5 4 2 7 6 1] [3 5 2 7 1 6 4] [3 5 2 7 4 6 1] [3 5 2 7 6 1 4] [3 5 2 1 7 6 4] [3 5 2 4 7 6 1] [4 1 6 7 3 5 2] [4 1 6 7 2 5 3] [4 1 6 7 5 2 3] [4 1 6 3 7 5 2] [4 1 6 2 7 5 3] [4 1 6 5 7 3 2] [4 1 3 6 7 5 2] [4 1 3 5 7 6 2] [4 1 2 6 7 5 3] [4 1 2 5 7 6 3] [4 1 5 7 6 2 3] [4 1 5 7 3 6 2] [4 1 5 7 2 6 3] [4 1 5 3 7 6 2] [4 1 5 2 7 6 3] [4 6 7 1 3 5 2] [4 6 7 1 2 5 3] [4 6 7 1 5 2 3] [4 6 7 3 1 5 2] [4 6 7 3 2 5 1] [4 6 7 3 5 1 2] [4 6 7 2 1 5 3] [4 6 7 2 3 5 1] [4 6 7 2 5 1 3] [4 6 7 5 1 2 3] [4 6 7 5 2 1 3] [4 6 1 7 3 5 2] [4 6 1 7 2 5 3] [4 6 1 7 5 2 3] [4 6 1 3 7 5 2] [4 6 1 2 7 5 3] [4 6 1 5 7 3 2] [4 6 3 7 1 5 2] [4 6 3 7 2 5 1] [4 6 3 7 5 1 2] [4 6 3 1 7 5 2] [4 6 3 2 7 5 1] [4 6 3 5 7 2 1] [4 6 2 7 1 5 3] [4 6 2 7 3 5 1] [4 6 2 7 5 1 3] [4 6 2 1 7 5 3] [4 6 2 3 7 5 1] [4 6 2 5 7 3 1] [4 6 5 7 1 3 2] [4 6 5 7 3 1 2] [4 6 5 7 2 3 1] [4 6 5 1 7 3 2] [4 6 5 3 7 2 1] [4 6 5 2 7 3 1] [4 3 1 6 7 5 2] [4 3 1 5 7 6 2] [4 3 6 7 1 5 2] [4 3 6 7 2 5 1] [4 3 6 7 5 1 2] [4 3 6 1 7 5 2] [4 3 6 2 7 5 1] [4 3 6 5 7 2 1] [4 3 2 6 7 5 1] [4 3 2 5 7 6 1] [4 3 5 7 1 6 2] [4 3 5 7 6 1 2] [4 3 5 7 2 6 1] [4 3 5 1 7 6 2] [4 3 5 2 7 6 1] [4 2 1 6 7 5 3] [4 2 1 5 7 6 3] [4 2 6 7 1 5 3] [4 2 6 7 3 5 1] [4 2 6 7 5 1 3] [4 2 6 1 7 5 3] [4 2 6 3 7 5 1] [4 2 6 5 7 3 1] [4 2 3 6 7 5 1] [4 2 3 5 7 6 1] [4 2 5 7 1 6 3] [4 2 5 7 6 1 3] [4 2 5 7 3 6 1] [4 2 5 1 7 6 3] [4 2 5 3 7 6 1] [4 5 7 1 6 2 3] [4 5 7 1 3 6 2] [4 5 7 1 2 6 3] [4 5 7 6 1 2 3] [4 5 7 6 2 1 3] [4 5 7 3 1 6 2] [4 5 7 3 6 1 2] [4 5 7 3 2 6 1] [4 5 7 2 1 6 3] [4 5 7 2 6 1 3] [4 5 7 2 3 6 1] [4 5 1 7 6 2 3] [4 5 1 7 3 6 2] [4 5 1 7 2 6 3] [4 5 1 3 7 6 2] [4 5 1 2 7 6 3] [4 5 3 7 1 6 2] [4 5 3 7 6 1 2] [4 5 3 7 2 6 1] [4 5 3 1 7 6 2] [4 5 3 2 7 6 1] [4 5 2 7 1 6 3] [4 5 2 7 6 1 3] [4 5 2 7 3 6 1] [4 5 2 1 7 6 3] [4 5 2 3 7 6 1] [5 1 4 6 7 3 2] [5 1 6 7 4 2 3] [5 1 6 7 3 4 2] [5 1 6 7 2 4 3] [5 1 6 4 7 3 2] [5 1 6 3 7 4 2] [5 1 6 2 7 4 3] [5 1 3 6 7 4 2] [5 1 2 6 7 4 3] [5 4 1 6 7 3 2] [5 4 6 7 1 3 2] [5 4 6 7 3 1 2] [5 4 6 7 2 3 1] [5 4 6 1 7 3 2] [5 4 6 3 7 2 1] [5 4 6 2 7 3 1] [5 4 3 6 7 2 1] [5 4 2 6 7 3 1] [5 6 7 1 4 2 3] [5 6 7 1 3 4 2] [5 6 7 1 2 4 3] [5 6 7 4 1 2 3] [5 6 7 4 2 1 3] [5 6 7 3 1 4 2] [5 6 7 3 4 1 2] [5 6 7 3 2 4 1] [5 6 7 2 1 4 3] [5 6 7 2 4 1 3] [5 6 7 2 3 4 1] [5 6 1 7 4 2 3] [5 6 1 7 3 4 2] [5 6 1 7 2 4 3] [5 6 1 4 7 3 2] [5 6 1 3 7 4 2] [5 6 1 2 7 4 3] [5 6 4 7 1 3 2] [5 6 4 7 3 1 2] [5 6 4 7 2 3 1] [5 6 4 1 7 3 2] [5 6 4 3 7 2 1] [5 6 4 2 7 3 1] [5 6 3 7 1 4 2] [5 6 3 7 4 1 2] [5 6 3 7 2 4 1] [5 6 3 1 7 4 2] [5 6 3 4 7 2 1] [5 6 3 2 7 4 1] [5 6 2 7 1 4 3] [5 6 2 7 4 1 3] [5 6 2 7 3 4 1] [5 6 2 1 7 4 3] [5 6 2 4 7 3 1] [5 6 2 3 7 4 1] [5 3 1 6 7 4 2] [5 3 4 6 7 2 1] [5 3 6 7 1 4 2] [5 3 6 7 4 1 2] [5 3 6 7 2 4 1] [5 3 6 1 7 4 2] [5 3 6 4 7 2 1] [5 3 6 2 7 4 1] [5 3 2 6 7 4 1] [5 2 1 6 7 4 3] [5 2 4 6 7 3 1] [5 2 6 7 1 4 3] [5 2 6 7 4 1 3] [5 2 6 7 3 4 1] [5 2 6 1 7 4 3] [5 2 6 4 7 3 1] [5 2 6 3 7 4 1] [5 2 3 6 7 4 1]], [3 4] [[1 4 7 6 3 5 2] [1 4 7 6 2 5 3] [1 4 7 6 5 2 3] [1 4 7 3 6 5 2] [1 4 7 2 6 5 3] [1 4 7 5 6 3 2] [1 4 3 7 6 5 2] [1 4 2 7 6 5 3] [1 6 7 4 5 3 2] [1 6 7 3 5 4 2] [1 6 7 2 5 4 3] [1 6 7 5 4 2 3] [1 6 7 5 3 4 2] [1 6 7 5 2 4 3] [1 6 4 7 5 3 2] [1 6 3 7 5 4 2] [1 6 2 7 5 4 3] [1 6 5 7 4 3 2] [1 3 7 4 6 5 2] [1 3 7 6 4 5 2] [1 3 7 6 2 5 4] [1 3 7 6 5 2 4] [1 3 7 2 6 5 4] [1 3 7 5 6 4 2] [1 3 2 7 6 5 4] [1 2 7 4 6 5 3] [1 2 7 6 4 5 3] [1 2 7 6 3 5 4] [1 2 7 6 5 3 4] [1 2 7 3 6 5 4] [1 2 7 5 6 4 3] [1 5 7 4 6 3 2] [1 5 7 6 4 2 3] [1 5 7 6 3 4 2] [1 5 7 6 2 4 3] [1 5 7 3 6 4 2] [1 5 7 2 6 4 3] [1 5 4 7 6 3 2] [1 5 3 7 6 4 2] [1 5 2 7 6 4 3] [2 1 4 7 6 5 3] [2 1 6 7 5 4 3] [2 1 3 7 6 5 4] [2 1 5 7 6 4 3] [2 4 7 1 6 5 3] [2 4 7 6 1 5 3] [2 4 7 6 3 5 1] [2 4 7 6 5 1 3] [2 4 7 3 6 5 1] [2 4 7 5 6 3 1] [2 4 1 7 6 5 3] [2 4 3 7 6 5 1] [2 6 7 1 5 4 3] [2 6 7 4 5 3 1] [2 6 7 3 5 4 1] [2 6 7 5 1 4 3] [2 6 7 5 4 1 3] [2 6 7 5 3 4 1] [2 6 1 7 5 4 3] [2 6 4 7 5 3 1] [2 6 3 7 5 4 1] [2 6 5 7 4 3 1] [2 3 7 1 6 5 4] [2 3 7 4 6 5 1] [2 3 7 6 1 5 4] [2 3 7 6 4 5 1] [2 3 7 6 5 1 4] [2 3 7 5 6 4 1] [2 3 1 7 6 5 4] [2 5 7 1 6 4 3] [2 5 7 4 6 3 1] [2 5 7 6 1 4 3] [2 5 7 6 4 1 3] [2 5 7 6 3 4 1] [2 5 7 3 6 4 1] [2 5 1 7 6 4 3] [2 5 4 7 6 3 1] [2 5 3 7 6 4 1] [3 1 4 7 6 5 2] [3 1 6 7 5 4 2] [3 1 5 7 6 4 2] [3 4 7 1 6 5 2] [3 4 7 6 1 5 2] [3 4 7 6 2 5 1] [3 4 7 6 5 1 2] [3 4 7 2 6 5 1] [3 4 7 5 6 2 1] [3 4 1 7 6 5 2] [3 4 2 7 6 5 1] [3 6 7 1 5 4 2] [3 6 7 4 5 2 1] [3 6 7 2 5 4 1] [3 6 7 5 1 4 2] [3 6 7 5 4 1 2] [3 6 7 5 2 4 1] [3 6 1 7 5 4 2] [3 6 4 7 5 2 1] [3 6 2 7 5 4 1] [3 6 5 7 4 2 1] [3 2 4 7 6 5 1] [3 2 6 7 5 4 1] [3 2 5 7 6 4 1] [3 5 7 1 6 4 2] [3 5 7 4 6 2 1] [3 5 7 6 1 4 2] [3 5 7 6 4 1 2] [3 5 7 6 2 4 1] [3 5 7 2 6 4 1] [3 5 1 7 6 4 2] [3 5 4 7 6 2 1] [3 5 2 7 6 4 1] [4 1 6 7 5 3 2] [4 1 5 7 6 3 2] [4 6 7 1 5 3 2] [4 6 7 3 5 2 1] [4 6 7 2 5 3 1] [4 6 7 5 1 3 2] [4 6 7 5 3 1 2] [4 6 7 5 2 3 1] [4 6 1 7 5 3 2] [4 6 3 7 5 2 1] [4 6 2 7 5 3 1] [4 6 5 7 3 2 1] [4 3 6 7 5 2 1] [4 3 5 7 6 2 1] [4 2 6 7 5 3 1] [4 2 5 7 6 3 1] [4 5 7 1 6 3 2] [4 5 7 6 1 3 2] [4 5 7 6 3 1 2] [4 5 7 6 2 3 1] [4 5 7 3 6 2 1] [4 5 7 2 6 3 1] [4 5 1 7 6 3 2] [4 5 3 7 6 2 1] [4 5 2 7 6 3 1] [5 1 6 7 4 3 2] [5 4 6 7 3 2 1] [5 6 7 1 4 3 2] [5 6 7 4 1 3 2] [5 6 7 4 3 1 2] [5 6 7 4 2 3 1] [5 6 7 3 4 2 1] [5 6 7 2 4 3 1] [5 6 1 7 4 3 2] [5 6 4 7 3 2 1] [5 6 3 7 4 2 1] [5 6 2 7 4 3 1] [5 3 6 7 4 2 1] [5 2 6 7 4 3 1]], [4 2] [[1 4 6 7 3 2 5] [1 4 6 7 2 3 5] [1 4 6 3 7 2 5] [1 4 6 3 2 7 5] [1 4 6 3 5 7 2] [1 4 6 2 7 3 5] [1 4 6 2 3 7 5] [1 4 6 2 5 7 3] [1 4 6 5 7 2 3] [1 4 6 5 3 7 2] [1 4 6 5 2 7 3] [1 4 3 6 7 2 5] [1 4 3 6 2 7 5] [1 4 3 6 5 7 2] [1 4 3 2 6 7 5] [1 4 3 2 5 7 6] [1 4 3 5 7 2 6] [1 4 3 5 2 7 6] [1 4 2 6 7 3 5] [1 4 2 6 3 7 5] [1 4 2 6 5 7 3] [1 4 2 3 6 7 5] [1 4 2 3 5 7 6] [1 4 2 5 7 3 6] [1 4 2 5 3 7 6] [1 4 5 7 3 2 6] [1 4 5 7 2 3 6] [1 4 5 3 7 2 6] [1 4 5 3 2 7 6] [1 4 5 2 7 3 6] [1 4 5 2 3 7 6] [1 3 4 7 2 5 6] [1 3 4 7 5 2 6] [1 3 4 2 7 5 6] [1 3 6 7 4 2 5] [1 3 6 7 2 4 5] [1 3 6 4 7 2 5] [1 3 6 4 2 7 5] [1 3 6 4 5 7 2] [1 3 6 2 7 4 5] [1 3 6 2 4 7 5] [1 3 6 2 5 7 4] [1 3 6 5 7 2 4] [1 3 6 5 4 7 2] [1 3 6 5 2 7 4] [1 3 2 4 7 5 6] [1 3 2 6 7 4 5] [1 3 2 6 4 7 5] [1 3 2 6 5 7 4] [1 3 2 5 7 4 6] [1 3 2 5 4 7 6] [1 3 5 7 4 2 6] [1 3 5 7 2 4 6] [1 3 5 4 7 2 6] [1 3 5 4 2 7 6] [1 3 5 2 7 4 6] [1 3 5 2 4 7 6] [1 2 4 7 3 5 6] [1 2 4 7 5 3 6] [1 2 4 3 7 5 6] [1 2 6 7 4 3 5] [1 2 6 7 3 4 5] [1 2 6 4 7 3 5] [1 2 6 4 3 7 5] [1 2 6 4 5 7 3] [1 2 6 3 7 4 5] [1 2 6 3 4 7 5] [1 2 6 3 5 7 4] [1 2 6 5 7 3 4] [1 2 6 5 4 7 3] [1 2 6 5 3 7 4] [1 2 3 7 4 5 6] [1 2 3 7 5 4 6] [1 2 5 7 4 3 6] [1 2 5 7 3 4 6] [1 2 5 4 7 3 6] [1 2 5 4 3 7 6] [1 2 5 3 7 4 6] [1 2 5 3 4 7 6] [1 5 4 6 7 2 3] [1 5 4 6 3 7 2] [1 5 4 6 2 7 3] [1 5 4 3 6 7 2] [1 5 4 2 6 7 3] [1 5 6 7 3 2 4] [1 5 6 7 2 3 4] [1 5 6 4 7 2 3] [1 5 6 4 3 7 2] [1 5 6 4 2 7 3] [1 5 6 3 7 2 4] [1 5 6 3 4 7 2] [1 5 6 3 2 7 4] [1 5 6 2 7 3 4] [1 5 6 2 4 7 3] [1 5 6 2 3 7 4] [1 5 3 4 6 7 2] [1 5 3 6 7 2 4] [1 5 3 6 4 7 2] [1 5 3 6 2 7 4] [1 5 3 2 6 7 4] [1 5 2 4 6 7 3] [1 5 2 6 7 3 4] [1 5 2 6 4 7 3] [1 5 2 6 3 7 4] [1 5 2 3 6 7 4] [2 1 4 6 7 3 5] [2 1 4 6 3 7 5] [2 1 4 6 5 7 3] [2 1 4 3 6 7 5] [2 1 4 3 5 7 6] [2 1 4 5 7 3 6] [2 1 4 5 3 7 6] [2 1 3 4 7 5 6] [2 1 3 6 7 4 5] [2 1 3 6 4 7 5] [2 1 3 6 5 7 4] [2 1 3 5 7 4 6] [2 1 3 5 4 7 6] [2 1 5 4 6 7 3] [2 1 5 6 7 3 4] [2 1 5 6 4 7 3] [2 1 5 6 3 7 4] [2 1 5 3 6 7 4] [2 4 1 6 7 3 5] [2 4 1 6 3 7 5] [2 4 1 6 5 7 3] [2 4 1 3 6 7 5] [2 4 1 3 5 7 6] [2 4 1 5 7 3 6] [2 4 1 5 3 7 6] [2 4 6 7 1 3 5] [2 4 6 7 3 1 5] [2 4 6 1 7 3 5] [2 4 6 1 3 7 5] [2 4 6 1 5 7 3] [2 4 6 3 7 1 5] [2 4 6 3 1 7 5] [2 4 6 3 5 7 1] [2 4 6 5 7 1 3] [2 4 6 5 1 7 3] [2 4 6 5 3 7 1] [2 4 3 1 6 7 5] [2 4 3 1 5 7 6] [2 4 3 6 7 1 5] [2 4 3 6 1 7 5] [2 4 3 6 5 7 1] [2 4 3 5 7 1 6] [2 4 3 5 1 7 6] [2 4 5 7 1 3 6] [2 4 5 7 3 1 6] [2 4 5 1 7 3 6] [2 4 5 1 3 7 6] [2 4 5 3 7 1 6] [2 4 5 3 1 7 6] [2 3 1 4 7 5 6] [2 3 1 6 7 4 5] [2 3 1 6 4 7 5] [2 3 1 6 5 7 4] [2 3 1 5 7 4 6] [2 3 1 5 4 7 6] [2 3 4 7 1 5 6] [2 3 4 7 5 1 6] [2 3 4 1 7 5 6] [2 3 6 7 1 4 5] [2 3 6 7 4 1 5] [2 3 6 1 7 4 5] [2 3 6 1 4 7 5] [2 3 6 1 5 7 4] [2 3 6 4 7 1 5] [2 3 6 4 1 7 5] [2 3 6 4 5 7 1] [2 3 6 5 7 1 4] [2 3 6 5 1 7 4] [2 3 6 5 4 7 1] [2 3 5 7 1 4 6] [2 3 5 7 4 1 6] [2 3 5 1 7 4 6] [2 3 5 1 4 7 6] [2 3 5 4 7 1 6] [2 3 5 4 1 7 6] [2 5 1 4 6 7 3] [2 5 1 6 7 3 4] [2 5 1 6 4 7 3] [2 5 1 6 3 7 4] [2 5 1 3 6 7 4] [2 5 4 1 6 7 3] [2 5 4 6 7 1 3] [2 5 4 6 1 7 3] [2 5 4 6 3 7 1] [2 5 4 3 6 7 1] [2 5 6 7 1 3 4] [2 5 6 7 3 1 4] [2 5 6 1 7 3 4] [2 5 6 1 4 7 3] [2 5 6 1 3 7 4] [2 5 6 4 7 1 3] [2 5 6 4 1 7 3] [2 5 6 4 3 7 1] [2 5 6 3 7 1 4] [2 5 6 3 1 7 4] [2 5 6 3 4 7 1] [2 5 3 1 6 7 4] [2 5 3 4 6 7 1] [2 5 3 6 7 1 4] [2 5 3 6 1 7 4] [2 5 3 6 4 7 1] [3 1 4 6 7 2 5] [3 1 4 6 2 7 5] [3 1 4 6 5 7 2] [3 1 4 2 6 7 5] [3 1 4 2 5 7 6] [3 1 4 5 7 2 6] [3 1 4 5 2 7 6] [3 1 2 4 6 7 5] [3 1 2 4 5 7 6] [3 1 2 5 6 7 4] [3 1 5 4 6 7 2] [3 1 5 6 7 2 4] [3 1 5 6 4 7 2] [3 1 5 6 2 7 4] [3 1 5 2 6 7 4] [3 4 1 6 7 2 5] [3 4 1 6 2 7 5] [3 4 1 6 5 7 2] [3 4 1 2 6 7 5] [3 4 1 2 5 7 6] [3 4 1 5 7 2 6] [3 4 1 5 2 7 6] [3 4 6 7 1 2 5] [3 4 6 7 2 1 5] [3 4 6 1 7 2 5] [3 4 6 1 2 7 5] [3 4 6 1 5 7 2] [3 4 6 2 7 1 5] [3 4 6 2 1 7 5] [3 4 6 2 5 7 1] [3 4 6 5 7 1 2] [3 4 6 5 1 7 2] [3 4 6 5 2 7 1] [3 4 2 1 6 7 5] [3 4 2 1 5 7 6] [3 4 2 6 7 1 5] [3 4 2 6 1 7 5] [3 4 2 6 5 7 1] [3 4 2 5 7 1 6] [3 4 2 5 1 7 6] [3 4 5 7 1 2 6] [3 4 5 7 2 1 6] [3 4 5 1 7 2 6] [3 4 5 1 2 7 6] [3 4 5 2 7 1 6] [3 4 5 2 1 7 6] [3 2 1 4 6 7 5] [3 2 1 4 5 7 6] [3 2 1 5 6 7 4] [3 2 4 1 6 7 5] [3 2 4 1 5 7 6] [3 2 4 6 7 1 5] [3 2 4 6 1 7 5] [3 2 4 6 5 7 1] [3 2 4 5 7 1 6] [3 2 4 5 1 7 6] [3 2 5 1 6 7 4] [3 2 5 4 6 7 1] [3 2 5 6 7 1 4] [3 2 5 6 1 7 4] [3 2 5 6 4 7 1] [3 5 1 4 6 7 2] [3 5 1 6 7 2 4] [3 5 1 6 4 7 2] [3 5 1 6 2 7 4] [3 5 1 2 6 7 4] [3 5 4 1 6 7 2] [3 5 4 6 7 1 2] [3 5 4 6 1 7 2] [3 5 4 6 2 7 1] [3 5 4 2 6 7 1] [3 5 6 7 1 2 4] [3 5 6 7 2 1 4] [3 5 6 1 7 2 4] [3 5 6 1 4 7 2] [3 5 6 1 2 7 4] [3 5 6 4 7 1 2] [3 5 6 4 1 7 2] [3 5 6 4 2 7 1] [3 5 6 2 7 1 4] [3 5 6 2 1 7 4] [3 5 6 2 4 7 1] [3 5 2 1 6 7 4] [3 5 2 4 6 7 1] [3 5 2 6 7 1 4] [3 5 2 6 1 7 4] [3 5 2 6 4 7 1] [4 1 3 5 6 7 2] [4 1 2 5 6 7 3] [4 1 5 6 7 2 3] [4 1 5 6 3 7 2] [4 1 5 6 2 7 3] [4 1 5 3 6 7 2] [4 1 5 2 6 7 3] [4 3 1 5 6 7 2] [4 3 2 5 6 7 1] [4 3 5 1 6 7 2] [4 3 5 6 7 1 2] [4 3 5 6 1 7 2] [4 3 5 6 2 7 1] [4 3 5 2 6 7 1] [4 2 1 5 6 7 3] [4 2 3 5 6 7 1] [4 2 5 1 6 7 3] [4 2 5 6 7 1 3] [4 2 5 6 1 7 3] [4 2 5 6 3 7 1] [4 2 5 3 6 7 1] [4 5 1 6 7 2 3] [4 5 1 6 3 7 2] [4 5 1 6 2 7 3] [4 5 1 3 6 7 2] [4 5 1 2 6 7 3] [4 5 6 7 1 2 3] [4 5 6 7 2 1 3] [4 5 6 1 7 2 3] [4 5 6 1 3 7 2] [4 5 6 1 2 7 3] [4 5 6 3 7 1 2] [4 5 6 3 1 7 2] [4 5 6 3 2 7 1] [4 5 6 2 7 1 3] [4 5 6 2 1 7 3] [4 5 6 2 3 7 1] [4 5 3 1 6 7 2] [4 5 3 6 7 1 2] [4 5 3 6 1 7 2] [4 5 3 6 2 7 1] [4 5 3 2 6 7 1] [4 5 2 1 6 7 3] [4 5 2 6 7 1 3] [4 5 2 6 1 7 3] [4 5 2 6 3 7 1] [4 5 2 3 6 7 1]], [5 3] [[1 4 5 6 7 3 2] [1 3 4 6 7 5 2] [1 3 4 5 7 6 2] [1 3 5 6 7 4 2] [1 2 4 6 7 5 3] [1 2 4 5 7 6 3] [1 2 3 4 7 6 5] [1 2 3 6 7 5 4] [1 2 3 5 7 6 4] [1 2 5 6 7 4 3] [2 4 5 6 7 3 1] [2 3 4 6 7 5 1] [2 3 4 5 7 6 1] [2 3 5 6 7 4 1] [3 4 5 6 7 2 1]], [4 1] [[1 4 6 3 2 5 7] [1 4 6 3 5 2 7] [1 4 6 2 3 5 7] [1 4 6 2 5 3 7] [1 4 6 5 3 2 7] [1 4 6 5 2 3 7] [1 4 3 6 2 5 7] [1 4 3 6 5 2 7] [1 4 3 2 6 5 7] [1 4 2 6 3 5 7] [1 4 2 6 5 3 7] [1 4 2 3 6 5 7] [1 3 6 4 2 5 7] [1 3 6 4 5 2 7] [1 3 6 2 4 5 7] [1 3 6 2 5 4 7] [1 3 6 5 4 2 7] [1 3 6 5 2 4 7] [1 3 2 6 4 5 7] [1 3 2 6 5 4 7] [1 2 6 4 3 5 7] [1 2 6 4 5 3 7] [1 2 6 3 4 5 7] [1 2 6 3 5 4 7] [1 2 6 5 4 3 7] [1 2 6 5 3 4 7] [1 5 4 6 3 2 7] [1 5 4 6 2 3 7] [1 5 4 3 6 2 7] [1 5 4 3 2 6 7] [1 5 4 2 6 3 7] [1 5 4 2 3 6 7] [1 5 6 4 3 2 7] [1 5 6 4 2 3 7] [1 5 6 3 4 2 7] [1 5 6 3 2 4 7] [1 5 6 2 4 3 7] [1 5 6 2 3 4 7] [1 5 3 4 6 2 7] [1 5 3 4 2 6 7] [1 5 3 6 4 2 7] [1 5 3 6 2 4 7] [1 5 3 2 4 6 7] [1 5 3 2 6 4 7] [1 5 2 4 6 3 7] [1 5 2 4 3 6 7] [1 5 2 6 4 3 7] [1 5 2 6 3 4 7] [1 5 2 3 4 6 7] [1 5 2 3 6 4 7] [2 1 4 6 3 5 7] [2 1 4 6 5 3 7] [2 1 4 3 6 5 7] [2 1 3 6 4 5 7] [2 1 3 6 5 4 7] [2 1 5 4 6 3 7] [2 1 5 4 3 6 7] [2 1 5 6 4 3 7] [2 1 5 6 3 4 7] [2 1 5 3 4 6 7] [2 1 5 3 6 4 7] [2 4 1 6 3 5 7] [2 4 1 6 5 3 7] [2 4 1 3 6 5 7] [2 4 6 1 3 5 7] [2 4 6 1 5 3 7] [2 4 6 3 1 5 7] [2 4 6 3 5 1 7] [2 4 6 5 1 3 7] [2 4 6 5 3 1 7] [2 4 3 1 6 5 7] [2 4 3 6 1 5 7] [2 4 3 6 5 1 7] [2 3 1 6 4 5 7] [2 3 1 6 5 4 7] [2 3 6 1 4 5 7] [2 3 6 1 5 4 7] [2 3 6 4 1 5 7] [2 3 6 4 5 1 7] [2 3 6 5 1 4 7] [2 3 6 5 4 1 7] [2 5 1 4 6 3 7] [2 5 1 4 3 6 7] [2 5 1 6 4 3 7] [2 5 1 6 3 4 7] [2 5 1 3 4 6 7] [2 5 1 3 6 4 7] [2 5 4 1 6 3 7] [2 5 4 1 3 6 7] [2 5 4 6 1 3 7] [2 5 4 6 3 1 7] [2 5 4 3 1 6 7] [2 5 4 3 6 1 7] [2 5 6 1 4 3 7] [2 5 6 1 3 4 7] [2 5 6 4 1 3 7] [2 5 6 4 3 1 7] [2 5 6 3 1 4 7] [2 5 6 3 4 1 7] [2 5 3 1 4 6 7] [2 5 3 1 6 4 7] [2 5 3 4 1 6 7] [2 5 3 4 6 1 7] [2 5 3 6 1 4 7] [2 5 3 6 4 1 7] [3 1 4 6 2 5 7] [3 1 4 6 5 2 7] [3 1 4 2 6 5 7] [3 1 2 4 6 5 7] [3 1 2 5 4 6 7] [3 1 2 5 6 4 7] [3 1 5 4 6 2 7] [3 1 5 4 2 6 7] [3 1 5 6 4 2 7] [3 1 5 6 2 4 7] [3 1 5 2 4 6 7] [3 1 5 2 6 4 7] [3 4 1 6 2 5 7] [3 4 1 6 5 2 7] [3 4 1 2 6 5 7] [3 4 6 1 2 5 7] [3 4 6 1 5 2 7] [3 4 6 2 1 5 7] [3 4 6 2 5 1 7] [3 4 6 5 1 2 7] [3 4 6 5 2 1 7] [3 4 2 1 6 5 7] [3 4 2 6 1 5 7] [3 4 2 6 5 1 7] [3 2 1 4 6 5 7] [3 2 1 5 4 6 7] [3 2 1 5 6 4 7] [3 2 4 1 6 5 7] [3 2 4 6 1 5 7] [3 2 4 6 5 1 7] [3 2 5 1 4 6 7] [3 2 5 1 6 4 7] [3 2 5 4 1 6 7] [3 2 5 4 6 1 7] [3 2 5 6 1 4 7] [3 2 5 6 4 1 7] [3 5 1 4 6 2 7] [3 5 1 4 2 6 7] [3 5 1 6 4 2 7] [3 5 1 6 2 4 7] [3 5 1 2 4 6 7] [3 5 1 2 6 4 7] [3 5 4 1 6 2 7] [3 5 4 1 2 6 7] [3 5 4 6 1 2 7] [3 5 4 6 2 1 7] [3 5 4 2 1 6 7] [3 5 4 2 6 1 7] [3 5 6 1 4 2 7] [3 5 6 1 2 4 7] [3 5 6 4 1 2 7] [3 5 6 4 2 1 7] [3 5 6 2 1 4 7] [3 5 6 2 4 1 7] [3 5 2 1 4 6 7] [3 5 2 1 6 4 7] [3 5 2 4 1 6 7] [3 5 2 4 6 1 7] [3 5 2 6 1 4 7] [3 5 2 6 4 1 7] [4 1 3 2 5 6 7] [4 1 3 5 6 2 7] [4 1 3 5 2 6 7] [4 1 2 3 5 6 7] [4 1 2 5 6 3 7] [4 1 2 5 3 6 7] [4 1 5 6 3 2 7] [4 1 5 6 2 3 7] [4 1 5 3 6 2 7] [4 1 5 3 2 6 7] [4 1 5 2 6 3 7] [4 1 5 2 3 6 7] [4 3 1 2 5 6 7] [4 3 1 5 6 2 7] [4 3 1 5 2 6 7] [4 3 2 1 5 6 7] [4 3 2 5 1 6 7] [4 3 2 5 6 1 7] [4 3 5 1 6 2 7] [4 3 5 1 2 6 7] [4 3 5 6 1 2 7] [4 3 5 6 2 1 7] [4 3 5 2 1 6 7] [4 3 5 2 6 1 7] [4 2 1 3 5 6 7] [4 2 1 5 6 3 7] [4 2 1 5 3 6 7] [4 2 3 1 5 6 7] [4 2 3 5 1 6 7] [4 2 3 5 6 1 7] [4 2 5 1 6 3 7] [4 2 5 1 3 6 7] [4 2 5 6 1 3 7] [4 2 5 6 3 1 7] [4 2 5 3 1 6 7] [4 2 5 3 6 1 7] [4 5 1 6 3 2 7] [4 5 1 6 2 3 7] [4 5 1 3 6 2 7] [4 5 1 3 2 6 7] [4 5 1 2 6 3 7] [4 5 1 2 3 6 7] [4 5 6 1 3 2 7] [4 5 6 1 2 3 7] [4 5 6 3 1 2 7] [4 5 6 3 2 1 7] [4 5 6 2 1 3 7] [4 5 6 2 3 1 7] [4 5 3 1 6 2 7] [4 5 3 1 2 6 7] [4 5 3 6 1 2 7] [4 5 3 6 2 1 7] [4 5 3 2 1 6 7] [4 5 3 2 6 1 7] [4 5 2 1 6 3 7] [4 5 2 1 3 6 7] [4 5 2 6 1 3 7] [4 5 2 6 3 1 7] [4 5 2 3 1 6 7] [4 5 2 3 6 1 7]], [5 2] [[1 4 3 5 6 7 2] [1 4 2 5 6 7 3] [1 4 5 6 7 2 3] [1 4 5 6 3 7 2] [1 4 5 6 2 7 3] [1 4 5 3 6 7 2] [1 4 5 2 6 7 3] [1 3 4 6 7 2 5] [1 3 4 6 2 7 5] [1 3 4 6 5 7 2] [1 3 4 2 6 7 5] [1 3 4 2 5 7 6] [1 3 4 5 7 2 6] [1 3 4 5 2 7 6] [1 3 2 4 6 7 5] [1 3 2 4 5 7 6] [1 3 2 5 6 7 4] [1 3 5 4 6 7 2] [1 3 5 6 7 2 4] [1 3 5 6 4 7 2] [1 3 5 6 2 7 4] [1 3 5 2 6 7 4] [1 2 4 6 7 3 5] [1 2 4 6 3 7 5] [1 2 4 6 5 7 3] [1 2 4 3 6 7 5] [1 2 4 3 5 7 6] [1 2 4 5 7 3 6] [1 2 4 5 3 7 6] [1 2 3 4 7 5 6] [1 2 3 6 7 4 5] [1 2 3 6 4 7 5] [1 2 3 6 5 7 4] [1 2 3 5 7 4 6] [1 2 3 5 4 7 6] [1 2 5 4 6 7 3] [1 2 5 6 7 3 4] [1 2 5 6 4 7 3] [1 2 5 6 3 7 4] [1 2 5 3 6 7 4] [2 1 4 5 6 7 3] [2 1 3 4 6 7 5] [2 1 3 4 5 7 6] [2 1 3 5 6 7 4] [2 4 1 5 6 7 3] [2 4 3 5 6 7 1] [2 4 5 1 6 7 3] [2 4 5 6 7 1 3] [2 4 5 6 1 7 3] [2 4 5 6 3 7 1] [2 4 5 3 6 7 1] [2 3 1 4 6 7 5] [2 3 1 4 5 7 6] [2 3 1 5 6 7 4] [2 3 4 1 6 7 5] [2 3 4 1 5 7 6] [2 3 4 6 7 1 5] [2 3 4 6 1 7 5] [2 3 4 6 5 7 1] [2 3 4 5 7 1 6] [2 3 4 5 1 7 6] [2 3 5 1 6 7 4] [2 3 5 4 6 7 1] [2 3 5 6 7 1 4] [2 3 5 6 1 7 4] [2 3 5 6 4 7 1] [3 1 4 5 6 7 2] [3 4 1 5 6 7 2] [3 4 2 5 6 7 1] [3 4 5 1 6 7 2] [3 4 5 6 7 1 2] [3 4 5 6 1 7 2] [3 4 5 6 2 7 1] [3 4 5 2 6 7 1] [3 2 4 5 6 7 1]], [1 4] [[7 1 4 6 3 5 2] [7 1 4 6 2 5 3] [7 1 4 6 5 2 3] [7 1 4 3 6 5 2] [7 1 4 2 6 5 3] [7 1 4 5 6 3 2] [7 1 6 4 3 5 2] [7 1 6 4 2 5 3] [7 1 6 4 5 2 3] [7 1 6 3 4 5 2] [7 1 6 3 2 5 4] [7 1 6 3 5 2 4] [7 1 6 2 4 5 3] [7 1 6 2 3 5 4] [7 1 6 2 5 3 4] [7 1 6 5 3 2 4] [7 1 6 5 2 3 4] [7 1 3 4 6 5 2] [7 1 3 6 4 5 2] [7 1 3 6 2 5 4] [7 1 3 6 5 2 4] [7 1 3 2 6 5 4] [7 1 3 5 6 4 2] [7 1 2 4 6 5 3] [7 1 2 6 4 5 3] [7 1 2 6 3 5 4] [7 1 2 6 5 3 4] [7 1 2 3 6 5 4] [7 1 2 5 6 4 3] [7 1 5 4 6 3 2] [7 1 5 6 4 2 3] [7 1 5 6 3 4 2] [7 1 5 6 2 4 3] [7 1 5 3 6 4 2] [7 1 5 2 6 4 3] [7 4 1 6 3 5 2] [7 4 1 6 2 5 3] [7 4 1 6 5 2 3] [7 4 1 3 6 5 2] [7 4 1 2 6 5 3] [7 4 1 5 6 3 2] [7 4 6 1 3 5 2] [7 4 6 1 2 5 3] [7 4 6 1 5 2 3] [7 4 6 3 1 5 2] [7 4 6 3 2 5 1] [7 4 6 3 5 1 2] [7 4 6 2 1 5 3] [7 4 6 2 3 5 1] [7 4 6 2 5 1 3] [7 4 6 5 1 2 3] [7 4 6 5 2 1 3] [7 4 3 1 6 5 2] [7 4 3 6 1 5 2] [7 4 3 6 2 5 1] [7 4 3 6 5 1 2] [7 4 3 2 6 5 1] [7 4 3 5 6 2 1] [7 4 2 1 6 5 3] [7 4 2 6 1 5 3] [7 4 2 6 3 5 1] [7 4 2 6 5 1 3] [7 4 2 3 6 5 1] [7 4 2 5 6 3 1] [7 4 5 1 6 3 2] [7 4 5 6 1 3 2] [7 4 5 6 3 1 2] [7 4 5 6 2 3 1] [7 4 5 3 6 2 1] [7 4 5 2 6 3 1] [7 6 1 4 3 5 2] [7 6 1 4 2 5 3] [7 6 1 4 5 2 3] [7 6 1 3 4 5 2] [7 6 1 3 2 5 4] [7 6 1 3 5 2 4] [7 6 1 2 4 5 3] [7 6 1 2 3 5 4] [7 6 1 2 5 3 4] [7 6 1 5 3 2 4] [7 6 1 5 2 3 4] [7 6 4 1 3 5 2] [7 6 4 1 2 5 3] [7 6 4 1 5 2 3] [7 6 4 3 1 5 2] [7 6 4 3 2 5 1] [7 6 4 3 5 1 2] [7 6 4 2 1 5 3] [7 6 4 2 3 5 1] [7 6 4 2 5 1 3] [7 6 4 5 1 2 3] [7 6 4 5 2 1 3] [7 6 3 1 4 5 2] [7 6 3 1 2 5 4] [7 6 3 1 5 2 4] [7 6 3 4 1 5 2] [7 6 3 4 2 5 1] [7 6 3 4 5 1 2] [7 6 3 2 1 5 4] [7 6 3 2 4 5 1] [7 6 3 2 5 1 4] [7 6 3 5 1 2 4] [7 6 3 5 2 1 4] [7 6 2 1 4 5 3] [7 6 2 1 3 5 4] [7 6 2 1 5 3 4] [7 6 2 4 1 5 3] [7 6 2 4 3 5 1] [7 6 2 4 5 1 3] [7 6 2 3 1 5 4] [7 6 2 3 4 5 1] [7 6 2 3 5 1 4] [7 6 2 5 1 3 4] [7 6 2 5 3 1 4] [7 6 5 1 3 2 4] [7 6 5 1 2 3 4] [7 6 5 3 1 2 4] [7 6 5 3 2 1 4] [7 6 5 2 1 3 4] [7 6 5 2 3 1 4] [7 3 1 4 6 5 2] [7 3 1 6 4 5 2] [7 3 1 6 2 5 4] [7 3 1 6 5 2 4] [7 3 1 2 6 5 4] [7 3 1 5 6 4 2] [7 3 4 1 6 5 2] [7 3 4 6 1 5 2] [7 3 4 6 2 5 1] [7 3 4 6 5 1 2] [7 3 4 2 6 5 1] [7 3 4 5 6 2 1] [7 3 6 1 4 5 2] [7 3 6 1 2 5 4] [7 3 6 1 5 2 4] [7 3 6 4 1 5 2] [7 3 6 4 2 5 1] [7 3 6 4 5 1 2] [7 3 6 2 1 5 4] [7 3 6 2 4 5 1] [7 3 6 2 5 1 4] [7 3 6 5 1 2 4] [7 3 6 5 2 1 4] [7 3 2 1 6 5 4] [7 3 2 4 6 5 1] [7 3 2 6 1 5 4] [7 3 2 6 4 5 1] [7 3 2 6 5 1 4] [7 3 2 5 6 4 1] [7 3 5 1 6 4 2] [7 3 5 4 6 2 1] [7 3 5 6 1 4 2] [7 3 5 6 4 1 2] [7 3 5 6 2 4 1] [7 3 5 2 6 4 1] [7 2 1 4 6 5 3] [7 2 1 6 4 5 3] [7 2 1 6 3 5 4] [7 2 1 6 5 3 4] [7 2 1 3 6 5 4] [7 2 1 5 6 4 3] [7 2 4 1 6 5 3] [7 2 4 6 1 5 3] [7 2 4 6 3 5 1] [7 2 4 6 5 1 3] [7 2 4 3 6 5 1] [7 2 4 5 6 3 1] [7 2 6 1 4 5 3] [7 2 6 1 3 5 4] [7 2 6 1 5 3 4] [7 2 6 4 1 5 3] [7 2 6 4 3 5 1] [7 2 6 4 5 1 3] [7 2 6 3 1 5 4] [7 2 6 3 4 5 1] [7 2 6 3 5 1 4] [7 2 6 5 1 3 4] [7 2 6 5 3 1 4] [7 2 3 1 6 5 4] [7 2 3 4 6 5 1] [7 2 3 6 1 5 4] [7 2 3 6 4 5 1] [7 2 3 6 5 1 4] [7 2 3 5 6 4 1] [7 2 5 1 6 4 3] [7 2 5 4 6 3 1] [7 2 5 6 1 4 3] [7 2 5 6 4 1 3] [7 2 5 6 3 4 1] [7 2 5 3 6 4 1] [7 5 1 4 6 3 2] [7 5 1 6 4 2 3] [7 5 1 6 3 4 2] [7 5 1 6 2 4 3] [7 5 1 3 6 4 2] [7 5 1 2 6 4 3] [7 5 4 1 6 3 2] [7 5 4 6 1 3 2] [7 5 4 6 3 1 2] [7 5 4 6 2 3 1] [7 5 4 3 6 2 1] [7 5 4 2 6 3 1] [7 5 6 1 4 2 3] [7 5 6 1 3 4 2] [7 5 6 1 2 4 3] [7 5 6 4 1 2 3] [7 5 6 4 2 1 3] [7 5 6 3 1 4 2] [7 5 6 3 4 1 2] [7 5 6 3 2 4 1] [7 5 6 2 1 4 3] [7 5 6 2 4 1 3] [7 5 6 2 3 4 1] [7 5 3 1 6 4 2] [7 5 3 4 6 2 1] [7 5 3 6 1 4 2] [7 5 3 6 4 1 2] [7 5 3 6 2 4 1] [7 5 3 2 6 4 1] [7 5 2 1 6 4 3] [7 5 2 4 6 3 1] [7 5 2 6 1 4 3] [7 5 2 6 4 1 3] [7 5 2 6 3 4 1] [7 5 2 3 6 4 1]], [1 3] [[7 1 4 6 3 2 5] [7 1 4 6 2 3 5] [7 1 4 3 6 2 5] [7 1 4 3 2 6 5] [7 1 4 3 5 6 2] [7 1 4 2 6 3 5] [7 1 4 2 3 6 5] [7 1 4 2 5 6 3] [7 1 4 5 6 2 3] [7 1 4 5 3 6 2] [7 1 4 5 2 6 3] [7 1 6 4 3 2 5] [7 1 6 4 2 3 5] [7 1 6 3 4 2 5] [7 1 6 3 2 4 5] [7 1 6 2 4 3 5] [7 1 6 2 3 4 5] [7 1 3 4 6 2 5] [7 1 3 4 2 6 5] [7 1 3 4 5 6 2] [7 1 3 6 4 2 5] [7 1 3 6 2 4 5] [7 1 3 2 4 6 5] [7 1 3 2 6 4 5] [7 1 3 2 5 6 4] [7 1 3 5 4 6 2] [7 1 3 5 6 2 4] [7 1 3 5 2 6 4] [7 1 2 4 6 3 5] [7 1 2 4 3 6 5] [7 1 2 4 5 6 3] [7 1 2 6 4 3 5] [7 1 2 6 3 4 5] [7 1 2 3 4 6 5] [7 1 2 3 6 4 5] [7 1 2 3 5 6 4] [7 1 2 5 4 6 3] [7 1 2 5 6 3 4] [7 1 2 5 3 6 4] [7 1 5 4 6 2 3] [7 1 5 4 3 6 2] [7 1 5 4 2 6 3] [7 1 5 6 3 2 4] [7 1 5 6 2 3 4] [7 1 5 3 4 6 2] [7 1 5 3 6 2 4] [7 1 5 3 2 6 4] [7 1 5 2 4 6 3] [7 1 5 2 6 3 4] [7 1 5 2 3 6 4] [7 4 1 6 3 2 5] [7 4 1 6 2 3 5] [7 4 1 3 6 2 5] [7 4 1 3 2 6 5] [7 4 1 3 5 6 2] [7 4 1 2 6 3 5] [7 4 1 2 3 6 5] [7 4 1 2 5 6 3] [7 4 1 5 6 2 3] [7 4 1 5 3 6 2] [7 4 1 5 2 6 3] [7 4 6 1 3 2 5] [7 4 6 1 2 3 5] [7 4 6 3 1 2 5] [7 4 6 3 2 1 5] [7 4 6 2 1 3 5] [7 4 6 2 3 1 5] [7 4 3 1 6 2 5] [7 4 3 1 2 6 5] [7 4 3 1 5 6 2] [7 4 3 6 1 2 5] [7 4 3 6 2 1 5] [7 4 3 2 1 6 5] [7 4 3 2 6 1 5] [7 4 3 2 5 6 1] [7 4 3 5 1 6 2] [7 4 3 5 6 1 2] [7 4 3 5 2 6 1] [7 4 2 1 6 3 5] [7 4 2 1 3 6 5] [7 4 2 1 5 6 3] [7 4 2 6 1 3 5] [7 4 2 6 3 1 5] [7 4 2 3 1 6 5] [7 4 2 3 6 1 5] [7 4 2 3 5 6 1] [7 4 2 5 1 6 3] [7 4 2 5 6 1 3] [7 4 2 5 3 6 1] [7 4 5 1 6 2 3] [7 4 5 1 3 6 2] [7 4 5 1 2 6 3] [7 4 5 6 1 2 3] [7 4 5 6 2 1 3] [7 4 5 3 1 6 2] [7 4 5 3 6 1 2] [7 4 5 3 2 6 1] [7 4 5 2 1 6 3] [7 4 5 2 6 1 3] [7 4 5 2 3 6 1] [7 6 1 4 3 2 5] [7 6 1 4 2 3 5] [7 6 1 3 4 2 5] [7 6 1 3 2 4 5] [7 6 1 2 4 3 5] [7 6 1 2 3 4 5] [7 6 4 1 3 2 5] [7 6 4 1 2 3 5] [7 6 4 3 1 2 5] [7 6 4 3 2 1 5] [7 6 4 2 1 3 5] [7 6 4 2 3 1 5] [7 6 3 1 4 2 5] [7 6 3 1 2 4 5] [7 6 3 4 1 2 5] [7 6 3 4 2 1 5] [7 6 3 2 1 4 5] [7 6 3 2 4 1 5] [7 6 2 1 4 3 5] [7 6 2 1 3 4 5] [7 6 2 4 1 3 5] [7 6 2 4 3 1 5] [7 6 2 3 1 4 5] [7 6 2 3 4 1 5] [7 3 1 4 6 2 5] [7 3 1 4 2 6 5] [7 3 1 4 5 6 2] [7 3 1 6 4 2 5] [7 3 1 6 2 4 5] [7 3 1 2 4 6 5] [7 3 1 2 6 4 5] [7 3 1 2 5 6 4] [7 3 1 5 4 6 2] [7 3 1 5 6 2 4] [7 3 1 5 2 6 4] [7 3 4 1 6 2 5] [7 3 4 1 2 6 5] [7 3 4 1 5 6 2] [7 3 4 6 1 2 5] [7 3 4 6 2 1 5] [7 3 4 2 1 6 5] [7 3 4 2 6 1 5] [7 3 4 2 5 6 1] [7 3 4 5 1 6 2] [7 3 4 5 6 1 2] [7 3 4 5 2 6 1] [7 3 6 1 4 2 5] [7 3 6 1 2 4 5] [7 3 6 4 1 2 5] [7 3 6 4 2 1 5] [7 3 6 2 1 4 5] [7 3 6 2 4 1 5] [7 3 2 1 4 6 5] [7 3 2 1 6 4 5] [7 3 2 1 5 6 4] [7 3 2 4 1 6 5] [7 3 2 4 6 1 5] [7 3 2 4 5 6 1] [7 3 2 6 1 4 5] [7 3 2 6 4 1 5] [7 3 2 5 1 6 4] [7 3 2 5 4 6 1] [7 3 2 5 6 1 4] [7 3 5 1 4 6 2] [7 3 5 1 6 2 4] [7 3 5 1 2 6 4] [7 3 5 4 1 6 2] [7 3 5 4 6 1 2] [7 3 5 4 2 6 1] [7 3 5 6 1 2 4] [7 3 5 6 2 1 4] [7 3 5 2 1 6 4] [7 3 5 2 4 6 1] [7 3 5 2 6 1 4] [7 2 1 4 6 3 5] [7 2 1 4 3 6 5] [7 2 1 4 5 6 3] [7 2 1 6 4 3 5] [7 2 1 6 3 4 5] [7 2 1 3 4 6 5] [7 2 1 3 6 4 5] [7 2 1 3 5 6 4] [7 2 1 5 4 6 3] [7 2 1 5 6 3 4] [7 2 1 5 3 6 4] [7 2 4 1 6 3 5] [7 2 4 1 3 6 5] [7 2 4 1 5 6 3] [7 2 4 6 1 3 5] [7 2 4 6 3 1 5] [7 2 4 3 1 6 5] [7 2 4 3 6 1 5] [7 2 4 3 5 6 1] [7 2 4 5 1 6 3] [7 2 4 5 6 1 3] [7 2 4 5 3 6 1] [7 2 6 1 4 3 5] [7 2 6 1 3 4 5] [7 2 6 4 1 3 5] [7 2 6 4 3 1 5] [7 2 6 3 1 4 5] [7 2 6 3 4 1 5] [7 2 3 1 4 6 5] [7 2 3 1 6 4 5] [7 2 3 1 5 6 4] [7 2 3 4 1 6 5] [7 2 3 4 6 1 5] [7 2 3 4 5 6 1] [7 2 3 6 1 4 5] [7 2 3 6 4 1 5] [7 2 3 5 1 6 4] [7 2 3 5 4 6 1] [7 2 3 5 6 1 4] [7 2 5 1 4 6 3] [7 2 5 1 6 3 4] [7 2 5 1 3 6 4] [7 2 5 4 1 6 3] [7 2 5 4 6 1 3] [7 2 5 4 3 6 1] [7 2 5 6 1 3 4] [7 2 5 6 3 1 4] [7 2 5 3 1 6 4] [7 2 5 3 4 6 1] [7 2 5 3 6 1 4] [7 5 1 4 6 2 3] [7 5 1 4 3 6 2] [7 5 1 4 2 6 3] [7 5 1 6 3 2 4] [7 5 1 6 2 3 4] [7 5 1 3 4 6 2] [7 5 1 3 6 2 4] [7 5 1 3 2 6 4] [7 5 1 2 4 6 3] [7 5 1 2 6 3 4] [7 5 1 2 3 6 4] [7 5 4 1 6 2 3] [7 5 4 1 3 6 2] [7 5 4 1 2 6 3] [7 5 4 6 1 2 3] [7 5 4 6 2 1 3] [7 5 4 3 1 6 2] [7 5 4 3 6 1 2] [7 5 4 3 2 6 1] [7 5 4 2 1 6 3] [7 5 4 2 6 1 3] [7 5 4 2 3 6 1] [7 5 6 1 3 2 4] [7 5 6 1 2 3 4] [7 5 6 3 1 2 4] [7 5 6 3 2 1 4] [7 5 6 2 1 3 4] [7 5 6 2 3 1 4] [7 5 3 1 4 6 2] [7 5 3 1 6 2 4] [7 5 3 1 2 6 4] [7 5 3 4 1 6 2] [7 5 3 4 6 1 2] [7 5 3 4 2 6 1] [7 5 3 6 1 2 4] [7 5 3 6 2 1 4] [7 5 3 2 1 6 4] [7 5 3 2 4 6 1] [7 5 3 2 6 1 4] [7 5 2 1 4 6 3] [7 5 2 1 6 3 4] [7 5 2 1 3 6 4] [7 5 2 4 1 6 3] [7 5 2 4 6 1 3] [7 5 2 4 3 6 1] [7 5 2 6 1 3 4] [7 5 2 6 3 1 4] [7 5 2 3 1 6 4] [7 5 2 3 4 6 1] [7 5 2 3 6 1 4]], [1 5] [[7 1 4 6 5 3 2] [7 1 6 4 5 3 2] [7 1 6 3 5 4 2] [7 1 6 2 5 4 3] [7 1 6 5 4 2 3] [7 1 6 5 3 4 2] [7 1 6 5 2 4 3] [7 1 3 6 5 4 2] [7 1 2 6 5 4 3] [7 1 5 6 4 3 2] [7 4 1 6 5 3 2] [7 4 6 1 5 3 2] [7 4 6 3 5 2 1] [7 4 6 2 5 3 1] [7 4 6 5 1 3 2] [7 4 6 5 3 1 2] [7 4 6 5 2 3 1] [7 4 3 6 5 2 1] [7 4 2 6 5 3 1] [7 4 5 6 3 2 1] [7 6 1 4 5 3 2] [7 6 1 3 5 4 2] [7 6 1 2 5 4 3] [7 6 1 5 4 2 3] [7 6 1 5 3 4 2] [7 6 1 5 2 4 3] [7 6 4 1 5 3 2] [7 6 4 3 5 2 1] [7 6 4 2 5 3 1] [7 6 4 5 1 3 2] [7 6 4 5 3 1 2] [7 6 4 5 2 3 1] [7 6 3 1 5 4 2] [7 6 3 4 5 2 1] [7 6 3 2 5 4 1] [7 6 3 5 1 4 2] [7 6 3 5 4 1 2] [7 6 3 5 2 4 1] [7 6 2 1 5 4 3] [7 6 2 4 5 3 1] [7 6 2 3 5 4 1] [7 6 2 5 1 4 3] [7 6 2 5 4 1 3] [7 6 2 5 3 4 1] [7 6 5 1 4 2 3] [7 6 5 1 3 4 2] [7 6 5 1 2 4 3] [7 6 5 4 1 2 3] [7 6 5 4 2 1 3] [7 6 5 3 1 4 2] [7 6 5 3 4 1 2] [7 6 5 3 2 4 1] [7 6 5 2 1 4 3] [7 6 5 2 4 1 3] [7 6 5 2 3 4 1] [7 3 1 6 5 4 2] [7 3 4 6 5 2 1] [7 3 6 1 5 4 2] [7 3 6 4 5 2 1] [7 3 6 2 5 4 1] [7 3 6 5 1 4 2] [7 3 6 5 4 1 2] [7 3 6 5 2 4 1] [7 3 2 6 5 4 1] [7 3 5 6 4 2 1] [7 2 1 6 5 4 3] [7 2 4 6 5 3 1] [7 2 6 1 5 4 3] [7 2 6 4 5 3 1] [7 2 6 3 5 4 1] [7 2 6 5 1 4 3] [7 2 6 5 4 1 3] [7 2 6 5 3 4 1] [7 2 3 6 5 4 1] [7 2 5 6 4 3 1] [7 5 1 6 4 3 2] [7 5 4 6 3 2 1] [7 5 6 1 4 3 2] [7 5 6 4 1 3 2] [7 5 6 4 3 1 2] [7 5 6 4 2 3 1] [7 5 6 3 4 2 1] [7 5 6 2 4 3 1] [7 5 3 6 4 2 1] [7 5 2 6 4 3 1]], [1 7] [[7 6 5 4 3 2 1]], [5 1] [[1 4 3 2 5 6 7] [1 4 3 5 6 2 7] [1 4 3 5 2 6 7] [1 4 2 3 5 6 7] [1 4 2 5 6 3 7] [1 4 2 5 3 6 7] [1 4 5 6 3 2 7] [1 4 5 6 2 3 7] [1 4 5 3 6 2 7] [1 4 5 3 2 6 7] [1 4 5 2 6 3 7] [1 4 5 2 3 6 7] [1 3 4 6 2 5 7] [1 3 4 6 5 2 7] [1 3 4 2 6 5 7] [1 3 2 4 6 5 7] [1 3 2 5 4 6 7] [1 3 2 5 6 4 7] [1 3 5 4 6 2 7] [1 3 5 4 2 6 7] [1 3 5 6 4 2 7] [1 3 5 6 2 4 7] [1 3 5 2 4 6 7] [1 3 5 2 6 4 7] [1 2 4 6 3 5 7] [1 2 4 6 5 3 7] [1 2 4 3 6 5 7] [1 2 3 6 4 5 7] [1 2 3 6 5 4 7] [1 2 5 4 6 3 7] [1 2 5 4 3 6 7] [1 2 5 6 4 3 7] [1 2 5 6 3 4 7] [1 2 5 3 4 6 7] [1 2 5 3 6 4 7] [2 1 4 3 5 6 7] [2 1 4 5 6 3 7] [2 1 4 5 3 6 7] [2 1 3 4 6 5 7] [2 1 3 5 4 6 7] [2 1 3 5 6 4 7] [2 4 1 3 5 6 7] [2 4 1 5 6 3 7] [2 4 1 5 3 6 7] [2 4 3 1 5 6 7] [2 4 3 5 1 6 7] [2 4 3 5 6 1 7] [2 4 5 1 6 3 7] [2 4 5 1 3 6 7] [2 4 5 6 1 3 7] [2 4 5 6 3 1 7] [2 4 5 3 1 6 7] [2 4 5 3 6 1 7] [2 3 1 4 6 5 7] [2 3 1 5 4 6 7] [2 3 1 5 6 4 7] [2 3 4 1 6 5 7] [2 3 4 6 1 5 7] [2 3 4 6 5 1 7] [2 3 5 1 4 6 7] [2 3 5 1 6 4 7] [2 3 5 4 1 6 7] [2 3 5 4 6 1 7] [2 3 5 6 1 4 7] [2 3 5 6 4 1 7] [3 1 4 2 5 6 7] [3 1 4 5 6 2 7] [3 1 4 5 2 6 7] [3 1 2 4 5 6 7] [3 4 1 2 5 6 7] [3 4 1 5 6 2 7] [3 4 1 5 2 6 7] [3 4 2 1 5 6 7] [3 4 2 5 1 6 7] [3 4 2 5 6 1 7] [3 4 5 1 6 2 7] [3 4 5 1 2 6 7] [3 4 5 6 1 2 7] [3 4 5 6 2 1 7] [3 4 5 2 1 6 7] [3 4 5 2 6 1 7] [3 2 1 4 5 6 7] [3 2 4 1 5 6 7] [3 2 4 5 1 6 7] [3 2 4 5 6 1 7]], [6 1] [[1 3 4 2 5 6 7] [1 3 4 5 6 2 7] [1 3 4 5 2 6 7] [1 3 2 4 5 6 7] [1 2 4 3 5 6 7] [1 2 4 5 6 3 7] [1 2 4 5 3 6 7] [1 2 3 4 6 5 7] [1 2 3 5 4 6 7] [1 2 3 5 6 4 7] [2 1 3 4 5 6 7] [2 3 1 4 5 6 7] [2 3 4 1 5 6 7] [2 3 4 5 1 6 7] [2 3 4 5 6 1 7]], [2 4] [[1 7 4 6 3 5 2] [1 7 4 6 2 5 3] [1 7 4 6 5 2 3] [1 7 4 3 6 5 2] [1 7 4 2 6 5 3] [1 7 4 5 6 3 2] [1 7 6 4 3 5 2] [1 7 6 4 2 5 3] [1 7 6 4 5 2 3] [1 7 6 3 4 5 2] [1 7 6 3 2 5 4] [1 7 6 3 5 2 4] [1 7 6 2 4 5 3] [1 7 6 2 3 5 4] [1 7 6 2 5 3 4] [1 7 6 5 3 2 4] [1 7 6 5 2 3 4] [1 7 3 4 6 5 2] [1 7 3 6 4 5 2] [1 7 3 6 2 5 4] [1 7 3 6 5 2 4] [1 7 3 2 6 5 4] [1 7 3 5 6 4 2] [1 7 2 4 6 5 3] [1 7 2 6 4 5 3] [1 7 2 6 3 5 4] [1 7 2 6 5 3 4] [1 7 2 3 6 5 4] [1 7 2 5 6 4 3] [1 7 5 4 6 3 2] [1 7 5 6 4 2 3] [1 7 5 6 3 4 2] [1 7 5 6 2 4 3] [1 7 5 3 6 4 2] [1 7 5 2 6 4 3] [2 7 1 4 6 5 3] [2 7 1 6 4 5 3] [2 7 1 6 3 5 4] [2 7 1 6 5 3 4] [2 7 1 3 6 5 4] [2 7 1 5 6 4 3] [2 7 4 1 6 5 3] [2 7 4 6 1 5 3] [2 7 4 6 3 5 1] [2 7 4 6 5 1 3] [2 7 4 3 6 5 1] [2 7 4 5 6 3 1] [2 7 6 1 4 5 3] [2 7 6 1 3 5 4] [2 7 6 1 5 3 4] [2 7 6 4 1 5 3] [2 7 6 4 3 5 1] [2 7 6 4 5 1 3] [2 7 6 3 1 5 4] [2 7 6 3 4 5 1] [2 7 6 3 5 1 4] [2 7 6 5 1 3 4] [2 7 6 5 3 1 4] [2 7 3 1 6 5 4] [2 7 3 4 6 5 1] [2 7 3 6 1 5 4] [2 7 3 6 4 5 1] [2 7 3 6 5 1 4] [2 7 3 5 6 4 1] [2 7 5 1 6 4 3] [2 7 5 4 6 3 1] [2 7 5 6 1 4 3] [2 7 5 6 4 1 3] [2 7 5 6 3 4 1] [2 7 5 3 6 4 1] [2 1 7 4 6 5 3] [2 1 7 6 4 5 3] [2 1 7 6 3 5 4] [2 1 7 6 5 3 4] [2 1 7 3 6 5 4] [2 1 7 5 6 4 3] [3 7 1 4 6 5 2] [3 7 1 6 4 5 2] [3 7 1 6 2 5 4] [3 7 1 6 5 2 4] [3 7 1 2 6 5 4] [3 7 1 5 6 4 2] [3 7 4 1 6 5 2] [3 7 4 6 1 5 2] [3 7 4 6 2 5 1] [3 7 4 6 5 1 2] [3 7 4 2 6 5 1] [3 7 4 5 6 2 1] [3 7 6 1 4 5 2] [3 7 6 1 2 5 4] [3 7 6 1 5 2 4] [3 7 6 4 1 5 2] [3 7 6 4 2 5 1] [3 7 6 4 5 1 2] [3 7 6 2 1 5 4] [3 7 6 2 4 5 1] [3 7 6 2 5 1 4] [3 7 6 5 1 2 4] [3 7 6 5 2 1 4] [3 7 2 1 6 5 4] [3 7 2 4 6 5 1] [3 7 2 6 1 5 4] [3 7 2 6 4 5 1] [3 7 2 6 5 1 4] [3 7 2 5 6 4 1] [3 7 5 1 6 4 2] [3 7 5 4 6 2 1] [3 7 5 6 1 4 2] [3 7 5 6 4 1 2] [3 7 5 6 2 4 1] [3 7 5 2 6 4 1] [3 1 7 4 6 5 2] [3 1 7 6 4 5 2] [3 1 7 6 2 5 4] [3 1 7 6 5 2 4] [3 1 7 2 6 5 4] [3 1 7 5 6 4 2] [3 1 2 7 6 5 4] [3 2 7 1 6 5 4] [3 2 7 4 6 5 1] [3 2 7 6 1 5 4] [3 2 7 6 4 5 1] [3 2 7 6 5 1 4] [3 2 7 5 6 4 1] [3 2 1 7 6 5 4] [4 7 1 6 3 5 2] [4 7 1 6 2 5 3] [4 7 1 6 5 2 3] [4 7 1 3 6 5 2] [4 7 1 2 6 5 3] [4 7 1 5 6 3 2] [4 7 6 1 3 5 2] [4 7 6 1 2 5 3] [4 7 6 1 5 2 3] [4 7 6 3 1 5 2] [4 7 6 3 2 5 1] [4 7 6 3 5 1 2] [4 7 6 2 1 5 3] [4 7 6 2 3 5 1] [4 7 6 2 5 1 3] [4 7 6 5 1 2 3] [4 7 6 5 2 1 3] [4 7 3 1 6 5 2] [4 7 3 6 1 5 2] [4 7 3 6 2 5 1] [4 7 3 6 5 1 2] [4 7 3 2 6 5 1] [4 7 3 5 6 2 1] [4 7 2 1 6 5 3] [4 7 2 6 1 5 3] [4 7 2 6 3 5 1] [4 7 2 6 5 1 3] [4 7 2 3 6 5 1] [4 7 2 5 6 3 1] [4 7 5 1 6 3 2] [4 7 5 6 1 3 2] [4 7 5 6 3 1 2] [4 7 5 6 2 3 1] [4 7 5 3 6 2 1] [4 7 5 2 6 3 1] [4 1 7 6 3 5 2] [4 1 7 6 2 5 3] [4 1 7 6 5 2 3] [4 1 7 3 6 5 2] [4 1 7 2 6 5 3] [4 1 7 5 6 3 2] [4 1 3 7 6 5 2] [4 1 2 7 6 5 3] [4 3 7 1 6 5 2] [4 3 7 6 1 5 2] [4 3 7 6 2 5 1] [4 3 7 6 5 1 2] [4 3 7 2 6 5 1] [4 3 7 5 6 2 1] [4 3 1 7 6 5 2] [4 3 2 7 6 5 1] [4 2 7 1 6 5 3] [4 2 7 6 1 5 3] [4 2 7 6 3 5 1] [4 2 7 6 5 1 3] [4 2 7 3 6 5 1] [4 2 7 5 6 3 1] [4 2 1 7 6 5 3] [4 2 3 7 6 5 1] [5 7 1 4 6 3 2] [5 7 1 6 4 2 3] [5 7 1 6 3 4 2] [5 7 1 6 2 4 3] [5 7 1 3 6 4 2] [5 7 1 2 6 4 3] [5 7 4 1 6 3 2] [5 7 4 6 1 3 2] [5 7 4 6 3 1 2] [5 7 4 6 2 3 1] [5 7 4 3 6 2 1] [5 7 4 2 6 3 1] [5 7 6 1 4 2 3] [5 7 6 1 3 4 2] [5 7 6 1 2 4 3] [5 7 6 4 1 2 3] [5 7 6 4 2 1 3] [5 7 6 3 1 4 2] [5 7 6 3 4 1 2] [5 7 6 3 2 4 1] [5 7 6 2 1 4 3] [5 7 6 2 4 1 3] [5 7 6 2 3 4 1] [5 7 3 1 6 4 2] [5 7 3 4 6 2 1] [5 7 3 6 1 4 2] [5 7 3 6 4 1 2] [5 7 3 6 2 4 1] [5 7 3 2 6 4 1] [5 7 2 1 6 4 3] [5 7 2 4 6 3 1] [5 7 2 6 1 4 3] [5 7 2 6 4 1 3] [5 7 2 6 3 4 1] [5 7 2 3 6 4 1] [5 1 7 4 6 3 2] [5 1 7 6 4 2 3] [5 1 7 6 3 4 2] [5 1 7 6 2 4 3] [5 1 7 3 6 4 2] [5 1 7 2 6 4 3] [5 1 4 7 6 3 2] [5 1 3 7 6 4 2] [5 1 2 7 6 4 3] [5 4 7 1 6 3 2] [5 4 7 6 1 3 2] [5 4 7 6 3 1 2] [5 4 7 6 2 3 1] [5 4 7 3 6 2 1] [5 4 7 2 6 3 1] [5 4 1 7 6 3 2] [5 4 3 7 6 2 1] [5 4 2 7 6 3 1] [5 3 7 1 6 4 2] [5 3 7 4 6 2 1] [5 3 7 6 1 4 2] [5 3 7 6 4 1 2] [5 3 7 6 2 4 1] [5 3 7 2 6 4 1] [5 3 1 7 6 4 2] [5 3 4 7 6 2 1] [5 3 2 7 6 4 1] [5 2 7 1 6 4 3] [5 2 7 4 6 3 1] [5 2 7 6 1 4 3] [5 2 7 6 4 1 3] [5 2 7 6 3 4 1] [5 2 7 3 6 4 1] [5 2 1 7 6 4 3] [5 2 4 7 6 3 1] [5 2 3 7 6 4 1] [6 7 1 4 5 3 2] [6 7 1 3 5 4 2] [6 7 1 2 5 4 3] [6 7 1 5 4 2 3] [6 7 1 5 3 4 2] [6 7 1 5 2 4 3] [6 7 4 1 5 3 2] [6 7 4 3 5 2 1] [6 7 4 2 5 3 1] [6 7 4 5 1 3 2] [6 7 4 5 3 1 2] [6 7 4 5 2 3 1] [6 7 3 1 5 4 2] [6 7 3 4 5 2 1] [6 7 3 2 5 4 1] [6 7 3 5 1 4 2] [6 7 3 5 4 1 2] [6 7 3 5 2 4 1] [6 7 2 1 5 4 3] [6 7 2 4 5 3 1] [6 7 2 3 5 4 1] [6 7 2 5 1 4 3] [6 7 2 5 4 1 3] [6 7 2 5 3 4 1] [6 7 5 1 4 2 3] [6 7 5 1 3 4 2] [6 7 5 1 2 4 3] [6 7 5 4 1 2 3] [6 7 5 4 2 1 3] [6 7 5 3 1 4 2] [6 7 5 3 4 1 2] [6 7 5 3 2 4 1] [6 7 5 2 1 4 3] [6 7 5 2 4 1 3] [6 7 5 2 3 4 1] [6 1 7 4 5 3 2] [6 1 7 3 5 4 2] [6 1 7 2 5 4 3] [6 1 7 5 4 2 3] [6 1 7 5 3 4 2] [6 1 7 5 2 4 3] [6 1 4 7 5 3 2] [6 1 3 7 5 4 2] [6 1 2 7 5 4 3] [6 1 5 7 4 3 2] [6 4 7 1 5 3 2] [6 4 7 3 5 2 1] [6 4 7 2 5 3 1] [6 4 7 5 1 3 2] [6 4 7 5 3 1 2] [6 4 7 5 2 3 1] [6 4 1 7 5 3 2] [6 4 3 7 5 2 1] [6 4 2 7 5 3 1] [6 4 5 7 3 2 1] [6 3 7 1 5 4 2] [6 3 7 4 5 2 1] [6 3 7 2 5 4 1] [6 3 7 5 1 4 2] [6 3 7 5 4 1 2] [6 3 7 5 2 4 1] [6 3 1 7 5 4 2] [6 3 4 7 5 2 1] [6 3 2 7 5 4 1] [6 3 5 7 4 2 1] [6 2 7 1 5 4 3] [6 2 7 4 5 3 1] [6 2 7 3 5 4 1] [6 2 7 5 1 4 3] [6 2 7 5 4 1 3] [6 2 7 5 3 4 1] [6 2 1 7 5 4 3] [6 2 4 7 5 3 1] [6 2 3 7 5 4 1] [6 2 5 7 4 3 1] [6 5 7 1 4 3 2] [6 5 7 4 1 3 2] [6 5 7 4 3 1 2] [6 5 7 4 2 3 1] [6 5 7 3 4 2 1] [6 5 7 2 4 3 1] [6 5 1 7 4 3 2] [6 5 4 7 3 2 1] [6 5 3 7 4 2 1] [6 5 2 7 4 3 1]], [3 1] [[1 6 4 3 2 5 7] [1 6 4 3 5 2 7] [1 6 4 2 3 5 7] [1 6 4 2 5 3 7] [1 6 4 5 3 2 7] [1 6 4 5 2 3 7] [1 6 3 4 2 5 7] [1 6 3 4 5 2 7] [1 6 3 2 4 5 7] [1 6 3 2 5 4 7] [1 6 3 5 4 2 7] [1 6 3 5 2 4 7] [1 6 2 4 3 5 7] [1 6 2 4 5 3 7] [1 6 2 3 4 5 7] [1 6 2 3 5 4 7] [1 6 2 5 4 3 7] [1 6 2 5 3 4 7] [1 6 5 4 3 2 7] [1 6 5 4 2 3 7] [1 6 5 3 4 2 7] [1 6 5 3 2 4 7] [1 6 5 2 4 3 7] [1 6 5 2 3 4 7] [2 1 6 4 3 5 7] [2 1 6 4 5 3 7] [2 1 6 3 4 5 7] [2 1 6 3 5 4 7] [2 1 6 5 4 3 7] [2 1 6 5 3 4 7] [2 6 1 4 3 5 7] [2 6 1 4 5 3 7] [2 6 1 3 4 5 7] [2 6 1 3 5 4 7] [2 6 1 5 4 3 7] [2 6 1 5 3 4 7] [2 6 4 1 3 5 7] [2 6 4 1 5 3 7] [2 6 4 3 1 5 7] [2 6 4 3 5 1 7] [2 6 4 5 1 3 7] [2 6 4 5 3 1 7] [2 6 3 1 4 5 7] [2 6 3 1 5 4 7] [2 6 3 4 1 5 7] [2 6 3 4 5 1 7] [2 6 3 5 1 4 7] [2 6 3 5 4 1 7] [2 6 5 1 4 3 7] [2 6 5 1 3 4 7] [2 6 5 4 1 3 7] [2 6 5 4 3 1 7] [2 6 5 3 1 4 7] [2 6 5 3 4 1 7] [3 1 6 4 2 5 7] [3 1 6 4 5 2 7] [3 1 6 2 4 5 7] [3 1 6 2 5 4 7] [3 1 6 5 4 2 7] [3 1 6 5 2 4 7] [3 1 2 6 4 5 7] [3 1 2 6 5 4 7] [3 6 1 4 2 5 7] [3 6 1 4 5 2 7] [3 6 1 2 4 5 7] [3 6 1 2 5 4 7] [3 6 1 5 4 2 7] [3 6 1 5 2 4 7] [3 6 4 1 2 5 7] [3 6 4 1 5 2 7] [3 6 4 2 1 5 7] [3 6 4 2 5 1 7] [3 6 4 5 1 2 7] [3 6 4 5 2 1 7] [3 6 2 1 4 5 7] [3 6 2 1 5 4 7] [3 6 2 4 1 5 7] [3 6 2 4 5 1 7] [3 6 2 5 1 4 7] [3 6 2 5 4 1 7] [3 6 5 1 4 2 7] [3 6 5 1 2 4 7] [3 6 5 4 1 2 7] [3 6 5 4 2 1 7] [3 6 5 2 1 4 7] [3 6 5 2 4 1 7] [3 2 1 6 4 5 7] [3 2 1 6 5 4 7] [3 2 6 1 4 5 7] [3 2 6 1 5 4 7] [3 2 6 4 1 5 7] [3 2 6 4 5 1 7] [3 2 6 5 1 4 7] [3 2 6 5 4 1 7] [4 1 6 3 2 5 7] [4 1 6 3 5 2 7] [4 1 6 2 3 5 7] [4 1 6 2 5 3 7] [4 1 6 5 3 2 7] [4 1 6 5 2 3 7] [4 1 3 6 2 5 7] [4 1 3 6 5 2 7] [4 1 3 2 6 5 7] [4 1 2 6 3 5 7] [4 1 2 6 5 3 7] [4 1 2 3 6 5 7] [4 6 1 3 2 5 7] [4 6 1 3 5 2 7] [4 6 1 2 3 5 7] [4 6 1 2 5 3 7] [4 6 1 5 3 2 7] [4 6 1 5 2 3 7] [4 6 3 1 2 5 7] [4 6 3 1 5 2 7] [4 6 3 2 1 5 7] [4 6 3 2 5 1 7] [4 6 3 5 1 2 7] [4 6 3 5 2 1 7] [4 6 2 1 3 5 7] [4 6 2 1 5 3 7] [4 6 2 3 1 5 7] [4 6 2 3 5 1 7] [4 6 2 5 1 3 7] [4 6 2 5 3 1 7] [4 6 5 1 3 2 7] [4 6 5 1 2 3 7] [4 6 5 3 1 2 7] [4 6 5 3 2 1 7] [4 6 5 2 1 3 7] [4 6 5 2 3 1 7] [4 3 1 6 2 5 7] [4 3 1 6 5 2 7] [4 3 1 2 6 5 7] [4 3 6 1 2 5 7] [4 3 6 1 5 2 7] [4 3 6 2 1 5 7] [4 3 6 2 5 1 7] [4 3 6 5 1 2 7] [4 3 6 5 2 1 7] [4 3 2 1 6 5 7] [4 3 2 6 1 5 7] [4 3 2 6 5 1 7] [4 2 1 6 3 5 7] [4 2 1 6 5 3 7] [4 2 1 3 6 5 7] [4 2 6 1 3 5 7] [4 2 6 1 5 3 7] [4 2 6 3 1 5 7] [4 2 6 3 5 1 7] [4 2 6 5 1 3 7] [4 2 6 5 3 1 7] [4 2 3 1 6 5 7] [4 2 3 6 1 5 7] [4 2 3 6 5 1 7] [5 1 4 6 3 2 7] [5 1 4 6 2 3 7] [5 1 4 3 6 2 7] [5 1 4 3 2 6 7] [5 1 4 2 6 3 7] [5 1 4 2 3 6 7] [5 1 6 4 3 2 7] [5 1 6 4 2 3 7] [5 1 6 3 4 2 7] [5 1 6 3 2 4 7] [5 1 6 2 4 3 7] [5 1 6 2 3 4 7] [5 1 3 4 6 2 7] [5 1 3 4 2 6 7] [5 1 3 6 4 2 7] [5 1 3 6 2 4 7] [5 1 3 2 4 6 7] [5 1 3 2 6 4 7] [5 1 2 4 6 3 7] [5 1 2 4 3 6 7] [5 1 2 6 4 3 7] [5 1 2 6 3 4 7] [5 1 2 3 4 6 7] [5 1 2 3 6 4 7] [5 4 1 6 3 2 7] [5 4 1 6 2 3 7] [5 4 1 3 6 2 7] [5 4 1 3 2 6 7] [5 4 1 2 6 3 7] [5 4 1 2 3 6 7] [5 4 6 1 3 2 7] [5 4 6 1 2 3 7] [5 4 6 3 1 2 7] [5 4 6 3 2 1 7] [5 4 6 2 1 3 7] [5 4 6 2 3 1 7] [5 4 3 1 6 2 7] [5 4 3 1 2 6 7] [5 4 3 6 1 2 7] [5 4 3 6 2 1 7] [5 4 3 2 1 6 7] [5 4 3 2 6 1 7] [5 4 2 1 6 3 7] [5 4 2 1 3 6 7] [5 4 2 6 1 3 7] [5 4 2 6 3 1 7] [5 4 2 3 1 6 7] [5 4 2 3 6 1 7] [5 6 1 4 3 2 7] [5 6 1 4 2 3 7] [5 6 1 3 4 2 7] [5 6 1 3 2 4 7] [5 6 1 2 4 3 7] [5 6 1 2 3 4 7] [5 6 4 1 3 2 7] [5 6 4 1 2 3 7] [5 6 4 3 1 2 7] [5 6 4 3 2 1 7] [5 6 4 2 1 3 7] [5 6 4 2 3 1 7] [5 6 3 1 4 2 7] [5 6 3 1 2 4 7] [5 6 3 4 1 2 7] [5 6 3 4 2 1 7] [5 6 3 2 1 4 7] [5 6 3 2 4 1 7] [5 6 2 1 4 3 7] [5 6 2 1 3 4 7] [5 6 2 4 1 3 7] [5 6 2 4 3 1 7] [5 6 2 3 1 4 7] [5 6 2 3 4 1 7] [5 3 1 4 6 2 7] [5 3 1 4 2 6 7] [5 3 1 6 4 2 7] [5 3 1 6 2 4 7] [5 3 1 2 4 6 7] [5 3 1 2 6 4 7] [5 3 4 1 6 2 7] [5 3 4 1 2 6 7] [5 3 4 6 1 2 7] [5 3 4 6 2 1 7] [5 3 4 2 1 6 7] [5 3 4 2 6 1 7] [5 3 6 1 4 2 7] [5 3 6 1 2 4 7] [5 3 6 4 1 2 7] [5 3 6 4 2 1 7] [5 3 6 2 1 4 7] [5 3 6 2 4 1 7] [5 3 2 1 4 6 7] [5 3 2 1 6 4 7] [5 3 2 4 1 6 7] [5 3 2 4 6 1 7] [5 3 2 6 1 4 7] [5 3 2 6 4 1 7] [5 2 1 4 6 3 7] [5 2 1 4 3 6 7] [5 2 1 6 4 3 7] [5 2 1 6 3 4 7] [5 2 1 3 4 6 7] [5 2 1 3 6 4 7] [5 2 4 1 6 3 7] [5 2 4 1 3 6 7] [5 2 4 6 1 3 7] [5 2 4 6 3 1 7] [5 2 4 3 1 6 7] [5 2 4 3 6 1 7] [5 2 6 1 4 3 7] [5 2 6 1 3 4 7] [5 2 6 4 1 3 7] [5 2 6 4 3 1 7] [5 2 6 3 1 4 7] [5 2 6 3 4 1 7] [5 2 3 1 4 6 7] [5 2 3 1 6 4 7] [5 2 3 4 1 6 7] [5 2 3 4 6 1 7] [5 2 3 6 1 4 7] [5 2 3 6 4 1 7]], [2 1] [[6 1 4 3 2 5 7] [6 1 4 3 5 2 7] [6 1 4 2 3 5 7] [6 1 4 2 5 3 7] [6 1 4 5 3 2 7] [6 1 4 5 2 3 7] [6 1 3 4 2 5 7] [6 1 3 4 5 2 7] [6 1 3 2 4 5 7] [6 1 3 2 5 4 7] [6 1 3 5 4 2 7] [6 1 3 5 2 4 7] [6 1 2 4 3 5 7] [6 1 2 4 5 3 7] [6 1 2 3 4 5 7] [6 1 2 3 5 4 7] [6 1 2 5 4 3 7] [6 1 2 5 3 4 7] [6 1 5 4 3 2 7] [6 1 5 4 2 3 7] [6 1 5 3 4 2 7] [6 1 5 3 2 4 7] [6 1 5 2 4 3 7] [6 1 5 2 3 4 7] [6 4 1 3 2 5 7] [6 4 1 3 5 2 7] [6 4 1 2 3 5 7] [6 4 1 2 5 3 7] [6 4 1 5 3 2 7] [6 4 1 5 2 3 7] [6 4 3 1 2 5 7] [6 4 3 1 5 2 7] [6 4 3 2 1 5 7] [6 4 3 2 5 1 7] [6 4 3 5 1 2 7] [6 4 3 5 2 1 7] [6 4 2 1 3 5 7] [6 4 2 1 5 3 7] [6 4 2 3 1 5 7] [6 4 2 3 5 1 7] [6 4 2 5 1 3 7] [6 4 2 5 3 1 7] [6 4 5 1 3 2 7] [6 4 5 1 2 3 7] [6 4 5 3 1 2 7] [6 4 5 3 2 1 7] [6 4 5 2 1 3 7] [6 4 5 2 3 1 7] [6 3 1 4 2 5 7] [6 3 1 4 5 2 7] [6 3 1 2 4 5 7] [6 3 1 2 5 4 7] [6 3 1 5 4 2 7] [6 3 1 5 2 4 7] [6 3 4 1 2 5 7] [6 3 4 1 5 2 7] [6 3 4 2 1 5 7] [6 3 4 2 5 1 7] [6 3 4 5 1 2 7] [6 3 4 5 2 1 7] [6 3 2 1 4 5 7] [6 3 2 1 5 4 7] [6 3 2 4 1 5 7] [6 3 2 4 5 1 7] [6 3 2 5 1 4 7] [6 3 2 5 4 1 7] [6 3 5 1 4 2 7] [6 3 5 1 2 4 7] [6 3 5 4 1 2 7] [6 3 5 4 2 1 7] [6 3 5 2 1 4 7] [6 3 5 2 4 1 7] [6 2 1 4 3 5 7] [6 2 1 4 5 3 7] [6 2 1 3 4 5 7] [6 2 1 3 5 4 7] [6 2 1 5 4 3 7] [6 2 1 5 3 4 7] [6 2 4 1 3 5 7] [6 2 4 1 5 3 7] [6 2 4 3 1 5 7] [6 2 4 3 5 1 7] [6 2 4 5 1 3 7] [6 2 4 5 3 1 7] [6 2 3 1 4 5 7] [6 2 3 1 5 4 7] [6 2 3 4 1 5 7] [6 2 3 4 5 1 7] [6 2 3 5 1 4 7] [6 2 3 5 4 1 7] [6 2 5 1 4 3 7] [6 2 5 1 3 4 7] [6 2 5 4 1 3 7] [6 2 5 4 3 1 7] [6 2 5 3 1 4 7] [6 2 5 3 4 1 7] [6 5 1 4 3 2 7] [6 5 1 4 2 3 7] [6 5 1 3 4 2 7] [6 5 1 3 2 4 7] [6 5 1 2 4 3 7] [6 5 1 2 3 4 7] [6 5 4 1 3 2 7] [6 5 4 1 2 3 7] [6 5 4 3 1 2 7] [6 5 4 3 2 1 7] [6 5 4 2 1 3 7] [6 5 4 2 3 1 7] [6 5 3 1 4 2 7] [6 5 3 1 2 4 7] [6 5 3 4 1 2 7] [6 5 3 4 2 1 7] [6 5 3 2 1 4 7] [6 5 3 2 4 1 7] [6 5 2 1 4 3 7] [6 5 2 1 3 4 7] [6 5 2 4 1 3 7] [6 5 2 4 3 1 7] [6 5 2 3 1 4 7] [6 5 2 3 4 1 7]], [1 6] [[7 1 6 5 4 3 2] [7 4 6 5 3 2 1] [7 6 1 5 4 3 2] [7 6 4 5 3 2 1] [7 6 3 5 4 2 1] [7 6 2 5 4 3 1] [7 6 5 1 4 3 2] [7 6 5 4 1 3 2] [7 6 5 4 3 1 2] [7 6 5 4 2 3 1] [7 6 5 3 4 2 1] [7 6 5 2 4 3 1] [7 3 6 5 4 2 1] [7 2 6 5 4 3 1] [7 5 6 4 3 2 1]], [4 4] [[1 4 6 7 5 3 2] [1 4 5 7 6 3 2] [1 3 4 7 6 5 2] [1 3 6 7 5 4 2] [1 3 5 7 6 4 2] [1 2 4 7 6 5 3] [1 2 6 7 5 4 3] [1 2 3 7 6 5 4] [1 2 5 7 6 4 3] [1 5 6 7 4 3 2] [2 4 6 7 5 3 1] [2 4 5 7 6 3 1] [2 3 4 7 6 5 1] [2 3 6 7 5 4 1] [2 3 5 7 6 4 1] [2 5 6 7 4 3 1] [3 4 6 7 5 2 1] [3 4 5 7 6 2 1] [3 5 6 7 4 2 1] [4 5 6 7 3 2 1]], [2 6] [[1 7 6 5 4 3 2] [2 7 6 5 4 3 1] [3 7 6 5 4 2 1] [4 7 6 5 3 2 1] [5 7 6 4 3 2 1] [6 7 5 4 3 2 1]], [6 2] [[1 3 4 5 6 7 2] [1 2 4 5 6 7 3] [1 2 3 4 6 7 5] [1 2 3 4 5 7 6] [1 2 3 5 6 7 4] [2 3 4 5 6 7 1]], [1 2] [[7 1 4 3 2 5 6] [7 1 4 3 5 2 6] [7 1 4 2 3 5 6] [7 1 4 2 5 3 6] [7 1 4 5 3 2 6] [7 1 4 5 2 3 6] [7 1 3 4 2 5 6] [7 1 3 4 5 2 6] [7 1 3 2 4 5 6] [7 1 3 2 5 4 6] [7 1 3 5 4 2 6] [7 1 3 5 2 4 6] [7 1 2 4 3 5 6] [7 1 2 4 5 3 6] [7 1 2 3 4 5 6] [7 1 2 3 5 4 6] [7 1 2 5 4 3 6] [7 1 2 5 3 4 6] [7 1 5 4 3 2 6] [7 1 5 4 2 3 6] [7 1 5 3 4 2 6] [7 1 5 3 2 4 6] [7 1 5 2 4 3 6] [7 1 5 2 3 4 6] [7 4 1 3 2 5 6] [7 4 1 3 5 2 6] [7 4 1 2 3 5 6] [7 4 1 2 5 3 6] [7 4 1 5 3 2 6] [7 4 1 5 2 3 6] [7 4 3 1 2 5 6] [7 4 3 1 5 2 6] [7 4 3 2 1 5 6] [7 4 3 2 5 1 6] [7 4 3 5 1 2 6] [7 4 3 5 2 1 6] [7 4 2 1 3 5 6] [7 4 2 1 5 3 6] [7 4 2 3 1 5 6] [7 4 2 3 5 1 6] [7 4 2 5 1 3 6] [7 4 2 5 3 1 6] [7 4 5 1 3 2 6] [7 4 5 1 2 3 6] [7 4 5 3 1 2 6] [7 4 5 3 2 1 6] [7 4 5 2 1 3 6] [7 4 5 2 3 1 6] [7 3 1 4 2 5 6] [7 3 1 4 5 2 6] [7 3 1 2 4 5 6] [7 3 1 2 5 4 6] [7 3 1 5 4 2 6] [7 3 1 5 2 4 6] [7 3 4 1 2 5 6] [7 3 4 1 5 2 6] [7 3 4 2 1 5 6] [7 3 4 2 5 1 6] [7 3 4 5 1 2 6] [7 3 4 5 2 1 6] [7 3 2 1 4 5 6] [7 3 2 1 5 4 6] [7 3 2 4 1 5 6] [7 3 2 4 5 1 6] [7 3 2 5 1 4 6] [7 3 2 5 4 1 6] [7 3 5 1 4 2 6] [7 3 5 1 2 4 6] [7 3 5 4 1 2 6] [7 3 5 4 2 1 6] [7 3 5 2 1 4 6] [7 3 5 2 4 1 6] [7 2 1 4 3 5 6] [7 2 1 4 5 3 6] [7 2 1 3 4 5 6] [7 2 1 3 5 4 6] [7 2 1 5 4 3 6] [7 2 1 5 3 4 6] [7 2 4 1 3 5 6] [7 2 4 1 5 3 6] [7 2 4 3 1 5 6] [7 2 4 3 5 1 6] [7 2 4 5 1 3 6] [7 2 4 5 3 1 6] [7 2 3 1 4 5 6] [7 2 3 1 5 4 6] [7 2 3 4 1 5 6] [7 2 3 4 5 1 6] [7 2 3 5 1 4 6] [7 2 3 5 4 1 6] [7 2 5 1 4 3 6] [7 2 5 1 3 4 6] [7 2 5 4 1 3 6] [7 2 5 4 3 1 6] [7 2 5 3 1 4 6] [7 2 5 3 4 1 6] [7 5 1 4 3 2 6] [7 5 1 4 2 3 6] [7 5 1 3 4 2 6] [7 5 1 3 2 4 6] [7 5 1 2 4 3 6] [7 5 1 2 3 4 6] [7 5 4 1 3 2 6] [7 5 4 1 2 3 6] [7 5 4 3 1 2 6] [7 5 4 3 2 1 6] [7 5 4 2 1 3 6] [7 5 4 2 3 1 6] [7 5 3 1 4 2 6] [7 5 3 1 2 4 6] [7 5 3 4 1 2 6] [7 5 3 4 2 1 6] [7 5 3 2 1 4 6] [7 5 3 2 4 1 6] [7 5 2 1 4 3 6] [7 5 2 1 3 4 6] [7 5 2 4 1 3 6] [7 5 2 4 3 1 6] [7 5 2 3 1 4 6] [7 5 2 3 4 1 6]], [3 5] [[1 4 7 6 5 3 2] [1 6 7 5 4 3 2] [1 3 7 6 5 4 2] [1 2 7 6 5 4 3] [1 5 7 6 4 3 2] [2 4 7 6 5 3 1] [2 6 7 5 4 3 1] [2 3 7 6 5 4 1] [2 5 7 6 4 3 1] [3 4 7 6 5 2 1] [3 6 7 5 4 2 1] [3 5 7 6 4 2 1] [4 6 7 5 3 2 1] [4 5 7 6 3 2 1] [5 6 7 4 3 2 1]], [3 2] [[1 4 7 3 2 5 6] [1 4 7 3 5 2 6] [1 4 7 2 3 5 6] [1 4 7 2 5 3 6] [1 4 7 5 3 2 6] [1 4 7 5 2 3 6] [1 4 3 7 2 5 6] [1 4 3 7 5 2 6] [1 4 3 2 7 5 6] [1 4 2 7 3 5 6] [1 4 2 7 5 3 6] [1 4 2 3 7 5 6] [1 6 7 4 3 2 5] [1 6 7 4 2 3 5] [1 6 7 3 4 2 5] [1 6 7 3 2 4 5] [1 6 7 2 4 3 5] [1 6 7 2 3 4 5] [1 6 4 7 3 2 5] [1 6 4 7 2 3 5] [1 6 4 3 7 2 5] [1 6 4 3 2 7 5] [1 6 4 3 5 7 2] [1 6 4 2 7 3 5] [1 6 4 2 3 7 5] [1 6 4 2 5 7 3] [1 6 4 5 7 2 3] [1 6 4 5 3 7 2] [1 6 4 5 2 7 3] [1 6 3 7 4 2 5] [1 6 3 7 2 4 5] [1 6 3 4 7 2 5] [1 6 3 4 2 7 5] [1 6 3 4 5 7 2] [1 6 3 2 7 4 5] [1 6 3 2 4 7 5] [1 6 3 2 5 7 4] [1 6 3 5 7 2 4] [1 6 3 5 4 7 2] [1 6 3 5 2 7 4] [1 6 2 7 4 3 5] [1 6 2 7 3 4 5] [1 6 2 4 7 3 5] [1 6 2 4 3 7 5] [1 6 2 4 5 7 3] [1 6 2 3 7 4 5] [1 6 2 3 4 7 5] [1 6 2 3 5 7 4] [1 6 2 5 7 3 4] [1 6 2 5 4 7 3] [1 6 2 5 3 7 4] [1 6 5 7 3 2 4] [1 6 5 7 2 3 4] [1 6 5 4 7 2 3] [1 6 5 4 3 7 2] [1 6 5 4 2 7 3] [1 6 5 3 7 2 4] [1 6 5 3 4 7 2] [1 6 5 3 2 7 4] [1 6 5 2 7 3 4] [1 6 5 2 4 7 3] [1 6 5 2 3 7 4] [1 3 7 4 2 5 6] [1 3 7 4 5 2 6] [1 3 7 2 4 5 6] [1 3 7 2 5 4 6] [1 3 7 5 4 2 6] [1 3 7 5 2 4 6] [1 3 2 7 4 5 6] [1 3 2 7 5 4 6] [1 2 7 4 3 5 6] [1 2 7 4 5 3 6] [1 2 7 3 4 5 6] [1 2 7 3 5 4 6] [1 2 7 5 4 3 6] [1 2 7 5 3 4 6] [1 5 7 4 3 2 6] [1 5 7 4 2 3 6] [1 5 7 3 4 2 6] [1 5 7 3 2 4 6] [1 5 7 2 4 3 6] [1 5 7 2 3 4 6] [1 5 4 7 3 2 6] [1 5 4 7 2 3 6] [1 5 4 3 7 2 6] [1 5 4 3 2 7 6] [1 5 4 2 7 3 6] [1 5 4 2 3 7 6] [1 5 3 7 4 2 6] [1 5 3 7 2 4 6] [1 5 3 4 7 2 6] [1 5 3 4 2 7 6] [1 5 3 2 7 4 6] [1 5 3 2 4 7 6] [1 5 2 7 4 3 6] [1 5 2 7 3 4 6] [1 5 2 4 7 3 6] [1 5 2 4 3 7 6] [1 5 2 3 7 4 6] [1 5 2 3 4 7 6] [2 1 4 7 3 5 6] [2 1 4 7 5 3 6] [2 1 4 3 7 5 6] [2 1 6 7 4 3 5] [2 1 6 7 3 4 5] [2 1 6 4 7 3 5] [2 1 6 4 3 7 5] [2 1 6 4 5 7 3] [2 1 6 3 7 4 5] [2 1 6 3 4 7 5] [2 1 6 3 5 7 4] [2 1 6 5 7 3 4] [2 1 6 5 4 7 3] [2 1 6 5 3 7 4] [2 1 3 7 4 5 6] [2 1 3 7 5 4 6] [2 1 5 7 4 3 6] [2 1 5 7 3 4 6] [2 1 5 4 7 3 6] [2 1 5 4 3 7 6] [2 1 5 3 7 4 6] [2 1 5 3 4 7 6] [2 4 7 1 3 5 6] [2 4 7 1 5 3 6] [2 4 7 3 1 5 6] [2 4 7 3 5 1 6] [2 4 7 5 1 3 6] [2 4 7 5 3 1 6] [2 4 1 7 3 5 6] [2 4 1 7 5 3 6] [2 4 1 3 7 5 6] [2 4 3 7 1 5 6] [2 4 3 7 5 1 6] [2 4 3 1 7 5 6] [2 6 7 1 4 3 5] [2 6 7 1 3 4 5] [2 6 7 4 1 3 5] [2 6 7 4 3 1 5] [2 6 7 3 1 4 5] [2 6 7 3 4 1 5] [2 6 1 7 4 3 5] [2 6 1 7 3 4 5] [2 6 1 4 7 3 5] [2 6 1 4 3 7 5] [2 6 1 4 5 7 3] [2 6 1 3 7 4 5] [2 6 1 3 4 7 5] [2 6 1 3 5 7 4] [2 6 1 5 7 3 4] [2 6 1 5 4 7 3] [2 6 1 5 3 7 4] [2 6 4 7 1 3 5] [2 6 4 7 3 1 5] [2 6 4 1 7 3 5] [2 6 4 1 3 7 5] [2 6 4 1 5 7 3] [2 6 4 3 7 1 5] [2 6 4 3 1 7 5] [2 6 4 3 5 7 1] [2 6 4 5 7 1 3] [2 6 4 5 1 7 3] [2 6 4 5 3 7 1] [2 6 3 7 1 4 5] [2 6 3 7 4 1 5] [2 6 3 1 7 4 5] [2 6 3 1 4 7 5] [2 6 3 1 5 7 4] [2 6 3 4 7 1 5] [2 6 3 4 1 7 5] [2 6 3 4 5 7 1] [2 6 3 5 7 1 4] [2 6 3 5 1 7 4] [2 6 3 5 4 7 1] [2 6 5 7 1 3 4] [2 6 5 7 3 1 4] [2 6 5 1 7 3 4] [2 6 5 1 4 7 3] [2 6 5 1 3 7 4] [2 6 5 4 7 1 3] [2 6 5 4 1 7 3] [2 6 5 4 3 7 1] [2 6 5 3 7 1 4] [2 6 5 3 1 7 4] [2 6 5 3 4 7 1] [2 3 7 1 4 5 6] [2 3 7 1 5 4 6] [2 3 7 4 1 5 6] [2 3 7 4 5 1 6] [2 3 7 5 1 4 6] [2 3 7 5 4 1 6] [2 3 1 7 4 5 6] [2 3 1 7 5 4 6] [2 5 7 1 4 3 6] [2 5 7 1 3 4 6] [2 5 7 4 1 3 6] [2 5 7 4 3 1 6] [2 5 7 3 1 4 6] [2 5 7 3 4 1 6] [2 5 1 7 4 3 6] [2 5 1 7 3 4 6] [2 5 1 4 7 3 6] [2 5 1 4 3 7 6] [2 5 1 3 7 4 6] [2 5 1 3 4 7 6] [2 5 4 7 1 3 6] [2 5 4 7 3 1 6] [2 5 4 1 7 3 6] [2 5 4 1 3 7 6] [2 5 4 3 7 1 6] [2 5 4 3 1 7 6] [2 5 3 7 1 4 6] [2 5 3 7 4 1 6] [2 5 3 1 7 4 6] [2 5 3 1 4 7 6] [2 5 3 4 7 1 6] [2 5 3 4 1 7 6] [3 1 4 7 2 5 6] [3 1 4 7 5 2 6] [3 1 4 2 7 5 6] [3 1 6 7 4 2 5] [3 1 6 7 2 4 5] [3 1 6 4 7 2 5] [3 1 6 4 2 7 5] [3 1 6 4 5 7 2] [3 1 6 2 7 4 5] [3 1 6 2 4 7 5] [3 1 6 2 5 7 4] [3 1 6 5 7 2 4] [3 1 6 5 4 7 2] [3 1 6 5 2 7 4] [3 1 2 4 7 5 6] [3 1 2 6 7 4 5] [3 1 2 6 4 7 5] [3 1 2 6 5 7 4] [3 1 2 5 7 4 6] [3 1 2 5 4 7 6] [3 1 5 7 4 2 6] [3 1 5 7 2 4 6] [3 1 5 4 7 2 6] [3 1 5 4 2 7 6] [3 1 5 2 7 4 6] [3 1 5 2 4 7 6] [3 4 7 1 2 5 6] [3 4 7 1 5 2 6] [3 4 7 2 1 5 6] [3 4 7 2 5 1 6] [3 4 7 5 1 2 6] [3 4 7 5 2 1 6] [3 4 1 7 2 5 6] [3 4 1 7 5 2 6] [3 4 1 2 7 5 6] [3 4 2 7 1 5 6] [3 4 2 7 5 1 6] [3 4 2 1 7 5 6] [3 6 7 1 4 2 5] [3 6 7 1 2 4 5] [3 6 7 4 1 2 5] [3 6 7 4 2 1 5] [3 6 7 2 1 4 5] [3 6 7 2 4 1 5] [3 6 1 7 4 2 5] [3 6 1 7 2 4 5] [3 6 1 4 7 2 5] [3 6 1 4 2 7 5] [3 6 1 4 5 7 2] [3 6 1 2 7 4 5] [3 6 1 2 4 7 5] [3 6 1 2 5 7 4] [3 6 1 5 7 2 4] [3 6 1 5 4 7 2] [3 6 1 5 2 7 4] [3 6 4 7 1 2 5] [3 6 4 7 2 1 5] [3 6 4 1 7 2 5] [3 6 4 1 2 7 5] [3 6 4 1 5 7 2] [3 6 4 2 7 1 5] [3 6 4 2 1 7 5] [3 6 4 2 5 7 1] [3 6 4 5 7 1 2] [3 6 4 5 1 7 2] [3 6 4 5 2 7 1] [3 6 2 7 1 4 5] [3 6 2 7 4 1 5] [3 6 2 1 7 4 5] [3 6 2 1 4 7 5] [3 6 2 1 5 7 4] [3 6 2 4 7 1 5] [3 6 2 4 1 7 5] [3 6 2 4 5 7 1] [3 6 2 5 7 1 4] [3 6 2 5 1 7 4] [3 6 2 5 4 7 1] [3 6 5 7 1 2 4] [3 6 5 7 2 1 4] [3 6 5 1 7 2 4] [3 6 5 1 4 7 2] [3 6 5 1 2 7 4] [3 6 5 4 7 1 2] [3 6 5 4 1 7 2] [3 6 5 4 2 7 1] [3 6 5 2 7 1 4] [3 6 5 2 1 7 4] [3 6 5 2 4 7 1] [3 2 1 4 7 5 6] [3 2 1 6 7 4 5] [3 2 1 6 4 7 5] [3 2 1 6 5 7 4] [3 2 1 5 7 4 6] [3 2 1 5 4 7 6] [3 2 4 7 1 5 6] [3 2 4 7 5 1 6] [3 2 4 1 7 5 6] [3 2 6 7 1 4 5] [3 2 6 7 4 1 5] [3 2 6 1 7 4 5] [3 2 6 1 4 7 5] [3 2 6 1 5 7 4] [3 2 6 4 7 1 5] [3 2 6 4 1 7 5] [3 2 6 4 5 7 1] [3 2 6 5 7 1 4] [3 2 6 5 1 7 4] [3 2 6 5 4 7 1] [3 2 5 7 1 4 6] [3 2 5 7 4 1 6] [3 2 5 1 7 4 6] [3 2 5 1 4 7 6] [3 2 5 4 7 1 6] [3 2 5 4 1 7 6] [3 5 7 1 4 2 6] [3 5 7 1 2 4 6] [3 5 7 4 1 2 6] [3 5 7 4 2 1 6] [3 5 7 2 1 4 6] [3 5 7 2 4 1 6] [3 5 1 7 4 2 6] [3 5 1 7 2 4 6] [3 5 1 4 7 2 6] [3 5 1 4 2 7 6] [3 5 1 2 7 4 6] [3 5 1 2 4 7 6] [3 5 4 7 1 2 6] [3 5 4 7 2 1 6] [3 5 4 1 7 2 6] [3 5 4 1 2 7 6] [3 5 4 2 7 1 6] [3 5 4 2 1 7 6] [3 5 2 7 1 4 6] [3 5 2 7 4 1 6] [3 5 2 1 7 4 6] [3 5 2 1 4 7 6] [3 5 2 4 7 1 6] [3 5 2 4 1 7 6] [4 1 6 7 3 2 5] [4 1 6 7 2 3 5] [4 1 6 3 7 2 5] [4 1 6 3 2 7 5] [4 1 6 3 5 7 2] [4 1 6 2 7 3 5] [4 1 6 2 3 7 5] [4 1 6 2 5 7 3] [4 1 6 5 7 2 3] [4 1 6 5 3 7 2] [4 1 6 5 2 7 3] [4 1 3 6 7 2 5] [4 1 3 6 2 7 5] [4 1 3 6 5 7 2] [4 1 3 2 6 7 5] [4 1 3 2 5 7 6] [4 1 3 5 7 2 6] [4 1 3 5 2 7 6] [4 1 2 6 7 3 5] [4 1 2 6 3 7 5] [4 1 2 6 5 7 3] [4 1 2 3 6 7 5] [4 1 2 3 5 7 6] [4 1 2 5 7 3 6] [4 1 2 5 3 7 6] [4 1 5 7 3 2 6] [4 1 5 7 2 3 6] [4 1 5 3 7 2 6] [4 1 5 3 2 7 6] [4 1 5 2 7 3 6] [4 1 5 2 3 7 6] [4 6 7 1 3 2 5] [4 6 7 1 2 3 5] [4 6 7 3 1 2 5] [4 6 7 3 2 1 5] [4 6 7 2 1 3 5] [4 6 7 2 3 1 5] [4 6 1 7 3 2 5] [4 6 1 7 2 3 5] [4 6 1 3 7 2 5] [4 6 1 3 2 7 5] [4 6 1 3 5 7 2] [4 6 1 2 7 3 5] [4 6 1 2 3 7 5] [4 6 1 2 5 7 3] [4 6 1 5 7 2 3] [4 6 1 5 3 7 2] [4 6 1 5 2 7 3] [4 6 3 7 1 2 5] [4 6 3 7 2 1 5] [4 6 3 1 7 2 5] [4 6 3 1 2 7 5] [4 6 3 1 5 7 2] [4 6 3 2 7 1 5] [4 6 3 2 1 7 5] [4 6 3 2 5 7 1] [4 6 3 5 7 1 2] [4 6 3 5 1 7 2] [4 6 3 5 2 7 1] [4 6 2 7 1 3 5] [4 6 2 7 3 1 5] [4 6 2 1 7 3 5] [4 6 2 1 3 7 5] [4 6 2 1 5 7 3] [4 6 2 3 7 1 5] [4 6 2 3 1 7 5] [4 6 2 3 5 7 1] [4 6 2 5 7 1 3] [4 6 2 5 1 7 3] [4 6 2 5 3 7 1] [4 6 5 7 1 2 3] [4 6 5 7 2 1 3] [4 6 5 1 7 2 3] [4 6 5 1 3 7 2] [4 6 5 1 2 7 3] [4 6 5 3 7 1 2] [4 6 5 3 1 7 2] [4 6 5 3 2 7 1] [4 6 5 2 7 1 3] [4 6 5 2 1 7 3] [4 6 5 2 3 7 1] [4 3 1 6 7 2 5] [4 3 1 6 2 7 5] [4 3 1 6 5 7 2] [4 3 1 2 6 7 5] [4 3 1 2 5 7 6] [4 3 1 5 7 2 6] [4 3 1 5 2 7 6] [4 3 6 7 1 2 5] [4 3 6 7 2 1 5] [4 3 6 1 7 2 5] [4 3 6 1 2 7 5] [4 3 6 1 5 7 2] [4 3 6 2 7 1 5] [4 3 6 2 1 7 5] [4 3 6 2 5 7 1] [4 3 6 5 7 1 2] [4 3 6 5 1 7 2] [4 3 6 5 2 7 1] [4 3 2 1 6 7 5] [4 3 2 1 5 7 6] [4 3 2 6 7 1 5] [4 3 2 6 1 7 5] [4 3 2 6 5 7 1] [4 3 2 5 7 1 6] [4 3 2 5 1 7 6] [4 3 5 7 1 2 6] [4 3 5 7 2 1 6] [4 3 5 1 7 2 6] [4 3 5 1 2 7 6] [4 3 5 2 7 1 6] [4 3 5 2 1 7 6] [4 2 1 6 7 3 5] [4 2 1 6 3 7 5] [4 2 1 6 5 7 3] [4 2 1 3 6 7 5] [4 2 1 3 5 7 6] [4 2 1 5 7 3 6] [4 2 1 5 3 7 6] [4 2 6 7 1 3 5] [4 2 6 7 3 1 5] [4 2 6 1 7 3 5] [4 2 6 1 3 7 5] [4 2 6 1 5 7 3] [4 2 6 3 7 1 5] [4 2 6 3 1 7 5] [4 2 6 3 5 7 1] [4 2 6 5 7 1 3] [4 2 6 5 1 7 3] [4 2 6 5 3 7 1] [4 2 3 1 6 7 5] [4 2 3 1 5 7 6] [4 2 3 6 7 1 5] [4 2 3 6 1 7 5] [4 2 3 6 5 7 1] [4 2 3 5 7 1 6] [4 2 3 5 1 7 6] [4 2 5 7 1 3 6] [4 2 5 7 3 1 6] [4 2 5 1 7 3 6] [4 2 5 1 3 7 6] [4 2 5 3 7 1 6] [4 2 5 3 1 7 6] [4 5 7 1 3 2 6] [4 5 7 1 2 3 6] [4 5 7 3 1 2 6] [4 5 7 3 2 1 6] [4 5 7 2 1 3 6] [4 5 7 2 3 1 6] [4 5 1 7 3 2 6] [4 5 1 7 2 3 6] [4 5 1 3 7 2 6] [4 5 1 3 2 7 6] [4 5 1 2 7 3 6] [4 5 1 2 3 7 6] [4 5 3 7 1 2 6] [4 5 3 7 2 1 6] [4 5 3 1 7 2 6] [4 5 3 1 2 7 6] [4 5 3 2 7 1 6] [4 5 3 2 1 7 6] [4 5 2 7 1 3 6] [4 5 2 7 3 1 6] [4 5 2 1 7 3 6] [4 5 2 1 3 7 6] [4 5 2 3 7 1 6] [4 5 2 3 1 7 6] [5 1 4 6 7 2 3] [5 1 4 6 3 7 2] [5 1 4 6 2 7 3] [5 1 4 3 6 7 2] [5 1 4 2 6 7 3] [5 1 6 7 3 2 4] [5 1 6 7 2 3 4] [5 1 6 4 7 2 3] [5 1 6 4 3 7 2] [5 1 6 4 2 7 3] [5 1 6 3 7 2 4] [5 1 6 3 4 7 2] [5 1 6 3 2 7 4] [5 1 6 2 7 3 4] [5 1 6 2 4 7 3] [5 1 6 2 3 7 4] [5 1 3 4 6 7 2] [5 1 3 6 7 2 4] [5 1 3 6 4 7 2] [5 1 3 6 2 7 4] [5 1 3 2 6 7 4] [5 1 2 4 6 7 3] [5 1 2 6 7 3 4] [5 1 2 6 4 7 3] [5 1 2 6 3 7 4] [5 1 2 3 6 7 4] [5 4 1 6 7 2 3] [5 4 1 6 3 7 2] [5 4 1 6 2 7 3] [5 4 1 3 6 7 2] [5 4 1 2 6 7 3] [5 4 6 7 1 2 3] [5 4 6 7 2 1 3] [5 4 6 1 7 2 3] [5 4 6 1 3 7 2] [5 4 6 1 2 7 3] [5 4 6 3 7 1 2] [5 4 6 3 1 7 2] [5 4 6 3 2 7 1] [5 4 6 2 7 1 3] [5 4 6 2 1 7 3] [5 4 6 2 3 7 1] [5 4 3 1 6 7 2] [5 4 3 6 7 1 2] [5 4 3 6 1 7 2] [5 4 3 6 2 7 1] [5 4 3 2 6 7 1] [5 4 2 1 6 7 3] [5 4 2 6 7 1 3] [5 4 2 6 1 7 3] [5 4 2 6 3 7 1] [5 4 2 3 6 7 1] [5 6 7 1 3 2 4] [5 6 7 1 2 3 4] [5 6 7 3 1 2 4] [5 6 7 3 2 1 4] [5 6 7 2 1 3 4] [5 6 7 2 3 1 4] [5 6 1 7 3 2 4] [5 6 1 7 2 3 4] [5 6 1 4 7 2 3] [5 6 1 4 3 7 2] [5 6 1 4 2 7 3] [5 6 1 3 7 2 4] [5 6 1 3 4 7 2] [5 6 1 3 2 7 4] [5 6 1 2 7 3 4] [5 6 1 2 4 7 3] [5 6 1 2 3 7 4] [5 6 4 7 1 2 3] [5 6 4 7 2 1 3] [5 6 4 1 7 2 3] [5 6 4 1 3 7 2] [5 6 4 1 2 7 3] [5 6 4 3 7 1 2] [5 6 4 3 1 7 2] [5 6 4 3 2 7 1] [5 6 4 2 7 1 3] [5 6 4 2 1 7 3] [5 6 4 2 3 7 1] [5 6 3 7 1 2 4] [5 6 3 7 2 1 4] [5 6 3 1 7 2 4] [5 6 3 1 4 7 2] [5 6 3 1 2 7 4] [5 6 3 4 7 1 2] [5 6 3 4 1 7 2] [5 6 3 4 2 7 1] [5 6 3 2 7 1 4] [5 6 3 2 1 7 4] [5 6 3 2 4 7 1] [5 6 2 7 1 3 4] [5 6 2 7 3 1 4] [5 6 2 1 7 3 4] [5 6 2 1 4 7 3] [5 6 2 1 3 7 4] [5 6 2 4 7 1 3] [5 6 2 4 1 7 3] [5 6 2 4 3 7 1] [5 6 2 3 7 1 4] [5 6 2 3 1 7 4] [5 6 2 3 4 7 1] [5 3 1 4 6 7 2] [5 3 1 6 7 2 4] [5 3 1 6 4 7 2] [5 3 1 6 2 7 4] [5 3 1 2 6 7 4] [5 3 4 1 6 7 2] [5 3 4 6 7 1 2] [5 3 4 6 1 7 2] [5 3 4 6 2 7 1] [5 3 4 2 6 7 1] [5 3 6 7 1 2 4] [5 3 6 7 2 1 4] [5 3 6 1 7 2 4] [5 3 6 1 4 7 2] [5 3 6 1 2 7 4] [5 3 6 4 7 1 2] [5 3 6 4 1 7 2] [5 3 6 4 2 7 1] [5 3 6 2 7 1 4] [5 3 6 2 1 7 4] [5 3 6 2 4 7 1] [5 3 2 1 6 7 4] [5 3 2 4 6 7 1] [5 3 2 6 7 1 4] [5 3 2 6 1 7 4] [5 3 2 6 4 7 1] [5 2 1 4 6 7 3] [5 2 1 6 7 3 4] [5 2 1 6 4 7 3] [5 2 1 6 3 7 4] [5 2 1 3 6 7 4] [5 2 4 1 6 7 3] [5 2 4 6 7 1 3] [5 2 4 6 1 7 3] [5 2 4 6 3 7 1] [5 2 4 3 6 7 1] [5 2 6 7 1 3 4] [5 2 6 7 3 1 4] [5 2 6 1 7 3 4] [5 2 6 1 4 7 3] [5 2 6 1 3 7 4] [5 2 6 4 7 1 3] [5 2 6 4 1 7 3] [5 2 6 4 3 7 1] [5 2 6 3 7 1 4] [5 2 6 3 1 7 4] [5 2 6 3 4 7 1] [5 2 3 1 6 7 4] [5 2 3 4 6 7 1] [5 2 3 6 7 1 4] [5 2 3 6 1 7 4] [5 2 3 6 4 7 1]]})\n\n; SOURCE: https:\/\/stackoverflow.com\/questions\/26076077\/clojure-list-all-permutations-of-a-list\n(defn permutations [xs]\n  (if (= 1 (count xs))\n    (list xs)\n    (for [head xs\n          tail (permutations (disj (set xs) head))]\n      (into [head] tail))))\n\n; SOURCE: https:\/\/stackoverflow.com\/questions\/16264813\/clojure-idiomatic-way-to-call-contains-on-a-lazy-sequence\n(defn lazy-contains? [col key]\n  (= (some #{key} col) key))\n\n(defn pair [cs]\n  (let [v (vec cs)\n        s (count v)\n        s2 (\/ s 2)\n        s4 (\/ s 4)]\n    (for [x (range 0 s2)] (if (< x s4) [(nth v x) (nth v (- s s4 x 1))] [(nth v (+ (- s x 1) s4)) (nth v x)]))))\n\n(defn clue-x [v]\n  (count (reduce (fn [coll a]\n                   (if (empty? coll) [a]\n                     (if (> a (last coll)) (conj coll a) coll)))\n                 [] v)))\n\n(defn clue-y [v] (clue-x (reverse v)))\n\n(defn clue [v] [(clue-x v) (clue-y v)])\n\n(defn clue-and-permutation-vec [permutations] (map (fn [p] {(clue p) [p]}) permutations))\n\n(defn clue-and-permutation-map [v] (reduce #(merge-with into %1 %2) v))\n\n(defn clues-cmp [clue-a clue-b]\n  (let [[ax ay] clue-a\n        [bx by] clue-b]\n    (and (or (= ax 0) (= bx 0) (= ax bx))\n         (or (= ay 0) (= by 0) (= ay by)))))\n\n(defn possibilities-by-clue [cap clue]\n  (apply concat\n         (vals\n           (filter #(clues-cmp clue (first %1)) cap))))\n\n(defn pattern-for-street [idx patterns]\n  (mapv (fn [p] (distinct (mapv #(nth %1 idx) p))) patterns))\n\n(defn street-ok? [street pattern]\n  (every? true? (map-indexed #(.contains (nth pattern %1) %2) street)))\n\n(defn street-ok? [street pattern]\n  (every? true? (map-indexed #(lazy-contains? (nth pattern %1) %2) street)))\n\n(defn filter-streets [idx streets pattern]\n  (filter #(street-ok? %1 pattern) streets))\n\n; square -> streets -> street\n(defn filter-square [square patterns]\n  (map-indexed #(filter-streets %1 %2 (pattern-for-street %1 patterns)) square))\n\n(defn filter-possibilities [possibilities level repeat]\n  (loop [a (subvec possibilities 0 level)\n         b (subvec possibilities level)\n         counter 0]\n    (let [c (filter-square a b)]\n      (if (> counter repeat) (concat b c) (recur b c (inc counter))))))\n\n(defn pickup [rows pos]\n  (let [[h & tail] rows] (vec (concat [[(nth h pos)]] tail))))\n\n(defn filter-pickup [possibilities level repeat]\n  (loop [i 0]\n    (let [result (filter-possibilities (vec (pickup possibilities i)) level repeat)\n          empty (empty? (first result))]\n      (if empty (recur (inc i)) result))))\n\n(defn solve_puzzle [clues]\n  (let [level (\/ (count clues) 4)\n        cap (if (= level 7) cap7 (clue-and-permutation-map (clue-and-permutation-vec (permutations (range 1 (inc level))))))\n        paired (pair clues)\n        possibilities (mapv #(possibilities-by-clue cap %1) paired)\n        filtered (filter-possibilities possibilities level 11)\n        semi-result (apply concat filtered)\n        count (count semi-result)\n        result (apply concat (take-last level (if (> count level) (filter-pickup filtered level 9) semi-result)))]\n    result))\n","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"},{"id":19199,"user_id":571,"body":"(ns skyscrapers)\n(defn permutations [colls]\n  (if (= 1 (count colls))\n    (list colls)\n    (for [head colls\n          tail (permutations (disj (set colls) head))]\n      (cons head tail))))\n\n(defn visible-buildings [colls]\n  (loop [c colls tallest 0 cnt 0]\n    (if (= 0 (count c)) cnt\n      (recur (rest c) \n            (if (> (first c) tallest) (first c) tallest )\n            (if (> (first c) tallest) (inc cnt) cnt)))))\n\n\n(defn visible-buildings-both [p]\n  (seq [(visible-buildings p) (visible-buildings (reverse p))]))\n\n(defn permutations-grouped-by-visible [p]\n  (merge (merge (group-by visible-buildings-both p)(group-by visible-buildings p)) [0 p]))\n\n\n(defn possibles[p clues from to]\n  (let [cfrom (nth clues from) cto (nth clues to)]\n    (cond\n     (and (zero? cfrom) (zero? cto)) (vec (get p 0))\n     (and (zero? cfrom) (not= 0 cto)) (vec (map reverse (get p cto)))\n     (and (not= 0 cfrom) (zero? cto)) (vec (get p cfrom))\n     :else (vec (get p [cfrom cto])))))\n\n(defn grid-has-cols [grid cols]\n  (let [x (map (fn [i v] (some #(= % v) (nth cols i))) (iterate inc 0) (partition 7 (apply interleave grid)))]\n    (every? #(= true %) x)))\n    \n(defn cleaner [rows cols]\n  (let [c (map (fn[k v] (map set (partition (count (nth cols k)) (apply interleave v)))) (iterate inc 0) cols)]\n    (map (fn[i r]\n      (filter\n        (fn [e] \n          (and (some #(= % (nth e 0)) (nth (nth c 0) i))\n               (some #(= % (nth e 1)) (nth (nth c 1) i))\n               (some #(= % (nth e 2)) (nth (nth c 2) i))\n               (some #(= % (nth e 3)) (nth (nth c 3) i))\n               (some #(= % (nth e 4)) (nth (nth c 4) i))\n               (some #(= % (nth e 5)) (nth (nth c 5) i))\n               (some #(= % (nth e 6)) (nth (nth c 6) i)))) r)) (iterate inc 0) rows)))\n\n(defn findsolutionfrom [rows cols]\n  (first (for [r0 (nth rows 0) r1 (nth rows 1) r2 (nth rows 2) r3 (nth rows 3) r4 (nth rows 4) r5 (nth rows 5) r6 (nth rows 6)\n      :let [grid [r0 r1 r2 r3 r4 r5 r6]]\n      :when (grid-has-cols grid cols)] grid)))\n\n\n(defn solve_puzzle [clues]\n  (let [p (permutations-grouped-by-visible (map vec (permutations '[1 2 3 4 5 6 7])))\n        rows [(possibles p clues 27 7)(possibles p clues 26 8)(possibles p clues 25 9)(possibles p clues 24 10)(possibles p clues 23 11)(possibles p clues 22 12)(possibles p clues 21 13)]\n        cols [(possibles p clues 0 20)(possibles p clues 1 19)(possibles p clues 2 18)(possibles p clues 3 17)(possibles p clues 4 16)(possibles p clues 5 15)(possibles p clues 6 14)]]\n    (loop [r rows c cols n 10]\n      (if (= 0 n) (findsolutionfrom r c)\n      (let [rr (cleaner r c) cc (cleaner c rr)] \n        (recur rr cc (dec n)))))))","lang_id":5,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-25 20:02:33","updated_at":"2022-12-25 20:02:33"}]}