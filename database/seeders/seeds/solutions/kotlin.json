{"50654ddff44f800200000004":[{"id":205357,"user_id":527,"body":"fun multiply(x: Long, y: Long) = x * y","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205358,"user_id":null,"body":"fun multiply(x: Long, y: Long): Double {\n    return x * y\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205359,"user_id":null,"body":"fun multiply(x: Long, y: Long) = x * y\n\/\/ Type declaration for paramaters needed to be capitalized\n\/\/ Single expression functions only = sign needed on same line","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205360,"user_id":null,"body":"fun multiply(x: Long, y: Long): Double = x * y","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205361,"user_id":2545,"body":"val multiply = { x: Double, y: Double -> x * y }","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205362,"user_id":null,"body":"fun multiply(x: Long, y: Long): Double = x * y\n\nfun main(){\n    multiply(2.0, 3.0)\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205363,"user_id":null,"body":"val multiply: (Double,Double) -> Double = Double::times","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205364,"user_id":null,"body":"fun multiply(a: Double, b: Double): Double{\n    var aBigDecimal = java.math.BigDecimal(a)\n    var bBigDecimal = java.math.BigDecimal(b)\n    return aBigDecimal.multiply(bBigDecimal).toDouble()\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205365,"user_id":null,"body":"fun multiply(x: Long, y: Long) = x * y\n\nfun main(args: Array<String>){\n    println(multiply(7.0,5.0))\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205366,"user_id":null,"body":"\/\/ \u4fee\u6b63\u4ee3\u7801\uff0c\u539f\u59cb\u4ee3\u7801\u5982\u4e0b\uff0c\u6709\u9519\u8bef\n\/\/ fun multiply(x: double, y: double) => x * y\n\n\/\/ \u4fee\u6b63\u540e\nfun multiply(x: Long, y: Long) = x * y","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"511f11d355fe575d2c000001":[{"id":205367,"user_id":null,"body":"package solution\n\nfun two_oldest_ages(ages: List<Int>) = ages.sorted().takeLast(2)","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205368,"user_id":null,"body":"package solution\n\nfun two_oldest_ages(ages: List<Int>): List<Int> {\n\treturn ages.sorted().takeLast(2)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205369,"user_id":null,"body":"package solution\n\nfun two_oldest_ages(ages: List<Int>): List<Int> {\n  val n = ages.size\n  val sortedAges = ages.sorted()\n  return listOf(sortedAges[n-2], sortedAges[n-1])\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205370,"user_id":null,"body":"package solution\n\nfun two_oldest_ages(ages: List<Int>): List<Int> {\n        var max1 = Int.MIN_VALUE\n        var max2 = Int.MIN_VALUE\n        for (age in ages) {\n            if (age > max1) {\n                max2 = max1\n                max1 = age\n            } else if (age > max2) {\n                max2 = age\n            }\n        }\n        return listOf(max2, max1)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205371,"user_id":null,"body":"package solution\n   fun two_oldest_ages(ages: List<Int>): List<Int>  = ages.sorted().reversed().slice(0..1).reversed()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205372,"user_id":null,"body":"package solution\n\nfun two_oldest_ages(ages: List<Int>): List<Int> {\n    var most0 = 0;\n    var most1 = 0;\n    for (i in ages.indices){\n        if (ages[i] > most0){\n            most1 = most0;\n            most0 = ages[i];\n        }else if (ages[i] > most1){\n            most1 = ages[i];\n        }\n    }\n\n    return listOf(most1, most0)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205373,"user_id":null,"body":"package solution\n\nfun two_oldest_ages(ages: List<Int>): List<Int> {\n    val sorted = ages.sorted()\n    return if (sorted.size >= 2) sorted.subList(sorted.size - 2, sorted.size) else sorted\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205374,"user_id":null,"body":"package solution\nimport kotlin.math.*\n\nfun two_oldest_ages(ages: List<Int>): List<Int> = ages.fold(listOf<Int>(0, 0)) { \n        (sOldest, oldest), age -> listOf(min(max(sOldest, age), oldest), max(oldest, age))\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205375,"user_id":null,"body":"package solution\n\nfun two_oldest_ages(ages: List<Int>): List<Int> {\n    val listAges = arrayListOf<Int>()\n    listAges.addAll(ages)\n\n    var ageNew: Int = 0\n    var ageOld: Int = 0\n\n    ageOld = listAges.max()!!\n    listAges.remove(ageOld)\n\n    ageNew = listAges.max()!!\n    listAges.remove(ageNew)\n\n    return listOf(ageNew, ageOld)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205376,"user_id":null,"body":"package solution\n\nfun two_oldest_ages(ages: List<Int>) = mutableListOf<Int>().apply {\n    val newList = ages.toMutableList()\n    repeat(2){\n        newList.max()!!.also { add(it) }.also { newList.remove(it) }\n    }\n}.toList().reversed()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"513e08acc600c94f01000001":[{"id":205377,"user_id":null,"body":"fun rgb(r: Int, g: Int, b: Int) = String.format(\"%02X%02X%02X\", r.coerceIn(0..255), g.coerceIn(0..255), b.coerceIn(0..255))","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205378,"user_id":null,"body":"fun rgb(r: Int, g: Int, b: Int) = listOf(r, g, b).joinToString(\"\") {\n    it.coerceIn(0..255).toString(16).padStart(2, '0').toUpperCase()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205379,"user_id":null,"body":"fun rgb(vararg colors: Int) =\n    colors.joinToString(\"\") {\n        \"%02X\".format(it.coerceIn(0..255))\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205380,"user_id":null,"body":"fun rgb(r: Int, g: Int, b: Int): String = String.format(\"%02X%02X%02X\", round(r), round(g), round(b))\n\nfun round(x: Int): Int = when {\n  x < 0 -> 0\n  x > 255 -> 255\n  else -> x\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205381,"user_id":null,"body":"fun Int.validate(): Int {\n    return when {\n        this < 0 -> 0\n        this > 255 -> 255\n        else -> this\n    }\n}\n\nfun rgb(r: Int, g: Int, b: Int): String {\n    val hexR = r.validate().toString(16).padStart(2, '0')\n    val hexG = g.validate().toString(16).padStart(2, '0')\n    val hexB = b.validate().toString(16).padStart(2, '0')\n\n    return \"$hexR$hexG$hexB\".toUpperCase()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205382,"user_id":null,"body":"import java.lang.Integer.toHexString\n\nfun rgb(vararg colours: Int) = colours\n    .map{ if (it < 0) 0 else it}\n    .map{ if (it > 255) 255 else it}\n    .map { toHexString(it)\n    .padStart(2, '0')}\n    .joinToString(\"\")\n    .toUpperCase()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205383,"user_id":null,"body":"import kotlin.math.*\n\nfun rgb(r: Int, g: Int, b: Int) = ((max(0, min(255, r)) shl 16) or (max(0, min(255, g)) shl 8) or max(0, min(255, b))).toString(16).padStart(6, '0').toUpperCase()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205384,"user_id":null,"body":"fun rgb(r: Int, g: Int, b: Int): String {\n \n     return listOf(r, g, b)\n            .map { v -> if (v > 255) 255 else v }\n            .map { v -> if (v < 0) 0 else v }\n            .map(Integer::toHexString)\n                   .map { v -> if (v.length == 1) \"0$v\" else v }\n            .joinToString(\"\")\n            .uppercase()\n \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205385,"user_id":null,"body":"fun limit(v: Int): Int {\n    if (v < 0)\n        return 0\n    \n    if (v > 255)\n        return 255\n    \n    return v\n}\n\nfun rgb(r: Int, g: Int, b: Int): String {\n  var red = \"%02X\".format(limit(r))\n  var green = \"%02X\".format(limit(g))\n  var blue = \"%02X\".format(limit(b))\n  \n  return (red + green + blue)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205386,"user_id":null,"body":"fun rgb(r: Int, g: Int, b: Int): String {\n    var red = checkValue(r)\n    var green =checkValue(g)\n    var blue = checkValue(b)\n  return String.format(\"%02x%02x%02x\", red, green, blue).toUpperCase()\n}\n\nfun checkValue(colorCode : Int) : Int{\n    if(colorCode>255){\n        return 255\n    }else if(colorCode<0){\n        return 0\n    }else{\n        return colorCode\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"514b92a657cdc65150000006":[{"id":205387,"user_id":null,"body":"fun solution(number: Int) = (1 until number).filter { it % 3 == 0 || it % 5 == 0 }.sum()","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205388,"user_id":null,"body":"fun solution(number: Int): Int =\n  (3 until number).filter { it % 3 == 0 || it % 5 == 0 }.sum()\n","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205389,"user_id":null,"body":"fun solution(n: Int): Int {\n    var t = (n - 1)\/3  \/\/3\n    var f = (n - 1)\/5  \/\/1\n    var ft = (n - 1)\/15  \/\/0\n    \n  return (3*t*(t+1) + 5*f*(f+1) - 15*ft*(ft+1))\/2\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205390,"user_id":null,"body":"fun solution(number: Int): Int = (3 until number step 3).union((5 until number step 5)).sum()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205391,"user_id":null,"body":"fun solution(number: Int) = (3 until number step 3)\n    .union(5 until number step 5)\n    .sum()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205392,"user_id":null,"body":"fun solution(number: Int): Int {\n    var s = 0\n    for(i in 3 until number){\n        if ((i % 3 == 0) or (i % 5 == 0)) s += i\n    }\n    return s\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205393,"user_id":null,"body":"fun solution(number: Int): Int {\n    return (3 until number).sumBy { if (it % 3 == 0 || it % 5 == 0) it else 0  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205394,"user_id":null,"body":"fun solution(number: Int) = (1..number-1).filter { it % 3 == 0 || it % 5 == 0 }.sum()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205395,"user_id":null,"body":"fun solution(number: Int): Int {\n   var total = 0\n    for (i in number-1 downTo  1){\n        if (i%15 == 0) total += i\n        else{\n            if (i%3 == 0) total += i\n            if (i%5 == 0) total += i }\n    }\n\n    return total\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205396,"user_id":null,"body":"fun solution(number: Int): Int {\n    return (1..number-1).sumOf { if (it % 3 == 0 || it % 5 == 0) it else 0 }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"515bb423de843ea99400000a":[{"id":205397,"user_id":null,"body":"class PaginationHelper<T>(val collection: List<T>, val itemsPerPage: Int) {\n    val itemCount = collection.count()\n    val pageCount = (itemCount \/ itemsPerPage).inc()\n    fun pageItemCount(index: Int) = collection.chunked(itemsPerPage).getOrNull(index)?.count() ?: -1\n    fun pageIndex(index: Int) = if (itemCount == 0) -1 else (index \/ itemsPerPage).takeIf { index in 0..itemCount && it in 0..pageCount } ?: -1\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205398,"user_id":null,"body":"class PaginationHelper<T>(val collection: List<T>, val itemsPerPage: Int) {\n    \n    val itemCount: Int\n    get() = collection.size\n\n    val pageCount: Int\n    get() = Math.ceil(itemCount.toDouble()\/itemsPerPage).toInt()\n\n    fun pageItemCount(pageIndex: Int): Int {\n        if(pageIndex !in (0..pageCount-1)) return -1\n        val diff = Math.abs(itemCount - pageIndex * itemsPerPage)\n        return if(diff>itemsPerPage) itemsPerPage else diff\n    }\n\n    fun pageIndex(itemIndex: Int): Int {\n        if(itemIndex !in (0..itemCount-1)) return -1\n        return (itemIndex+1)\/itemsPerPage \n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205399,"user_id":null,"body":"class PaginationHelper<T>(val collection: List<T>, val itemsPerPage: Int) {\n    \n   \/**\n   * returns the number of items within the entire collection\n   *\/\n  val itemCount: Int\n    get() = collection.size\n    \n  \/**\n   * returns the number of pages\n   *\/\n  val pageCount: Int\n    get() = collection.size.div(itemsPerPage) + if (collection.size.mod(itemsPerPage) == 0) 0 else 1\n\n\n  \/**\n   * returns the number of items on the current page. page_index is zero based.\n   * this method should return -1 for pageIndex values that are out of range\n   *\/\n  fun pageItemCount(pageIndex: Int): Int {\n      return when {\n          pageIndex < collection.size.div(itemsPerPage) -> itemsPerPage\n          pageIndex == collection.size.div(itemsPerPage) -> collection.size.mod(itemsPerPage)\n          else -> -1\n      }\n  }\n  \n  \n  \/**\n   * determines what page an item is on. Zero based indexes\n   * this method should return -1 for itemIndex values that are out of range\n   *\/\n  fun pageIndex(itemIndex: Int): Int {\n      return when {\n          itemIndex in collection.indices -> itemIndex.div(itemsPerPage)\n          else -> -1\n      }\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205400,"user_id":null,"body":"class PaginationHelper<T>(val collection: List<T>, val itemsPerPage: Int) {\n    \n   \/**\n   * returns the number of items within the entire collection\n   *\/\n  val itemCount: Int\n    get() {\n        return collection.size\n    } \n    \n  \/**\n   * returns the number of pages\n   *\/\n  val pageCount: Int\n    get() {\n        return (collection.size \/ itemsPerPage)+1\n    }\n\n\n  \/**\n   * returns the number of items on the current page. page_index is zero based.\n   * this method should return -1 for pageIndex values that are out of range\n   *\/\n  fun pageItemCount(pageIndex: Int): Int {\n      if (pageIndex>=0 && pageIndex<pageCount){\n          if(pageIndex<pageCount-1) return itemsPerPage else return itemCount - (pageIndex*itemsPerPage)\n      }else return -1\n  }\n  \n  \n  \/**\n   * determines what page an item is on. Zero based indexes\n   * this method should return -1 for itemIndex values that are out of range\n   *\/\n  fun pageIndex(itemIndex: Int): Int {\n      if(itemIndex>=0 && itemIndex<collection.size){\n          return (itemIndex\/itemsPerPage)\n      }else return -1\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205401,"user_id":null,"body":"class PaginationHelper<T>(val collection: List<T>, val itemsPerPage: Int) {\n    \n   \/**\n   * returns the number of items within the entire collection\n   *\/\n  val itemCount: Int\n    get() {\n        return collection.size\n    } \n    \n  \/**\n   * returns the number of pages\n   *\/\n  val pageCount: Int\n    get() {\n        return (collection.size \/ itemsPerPage) + 1\n    }\n\n\n  \/**\n   * returns the number of items on the current page. page_index is zero based.\n   * this method should return -1 for pageIndex values that are out of range\n   *\/\n  fun pageItemCount(pageIndex: Int): Int {\n      if (pageIndex > pageCount - 1){\n          return -1\n      } else if(pageIndex + 1 < pageCount){\n          return itemsPerPage\n      } else {\n          return collection.size % itemsPerPage\n      }\n  }\n  \n  \n  \/**\n   * determines what page an item is on. Zero based indexes\n   * this method should return -1 for itemIndex values that are out of range\n   *\/\n  fun pageIndex(itemIndex: Int): Int {\n       if (itemIndex < 0 || itemIndex > collection.size || collection.isEmpty()){\n           return -1\n       } else {\n           val end = collection.size % itemsPerPage\n           if(itemIndex > (collection.size - end)){\n               return pageCount - 1\n           }\n        return 0\n       }\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205402,"user_id":null,"body":"import kotlin.math.ceil\n\nclass PaginationHelper<T>(private val collection: List<T>, private val itemsPerPage: Int) {\n\n        \/**\n         * returns the number of items within the entire collection\n         *\/\n        val itemCount: Int\n            get() {\n              return  collection.size\n            }\n\n        \/**\n         * returns the number of pages\n         *\/\n        val pageCount: Int\n            get() {\n                return ceil(collection.size.toFloat()\/itemsPerPage.toFloat()).toInt()\n            }\n\n\n        \/**\n         * returns the number of items on the current page. page_index is zero based.\n         * this method should return -1 for pageIndex values that are out of range\n         *\/\n        fun pageItemCount(pageIndex: Int): Int {\n            if (pageIndex>pageCount-1 || pageIndex<0)return -1\n            if (pageIndex< pageCount-1)return itemsPerPage\n            return itemCount-((pageCount-1)*itemsPerPage)\n        }\n\n\n        \/**\n         * determines what page an item is on. Zero based indexes\n         * this method should return -1 for itemIndex values that are out of range\n         *\/\n        fun pageIndex(itemIndex: Int): Int {\n            if (itemIndex>=itemCount || itemIndex<0)return -1\n            return ceil((itemIndex+1).toFloat()\/itemsPerPage.toFloat()).toInt()-1\n        }\n    }\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205403,"user_id":null,"body":"class PaginationHelper<T>(val collection: List<T>, val itemsPerPage: Int) {\n    \n   \/**\n   * returns the number of items within the entire collection\n   *\/\n  val itemCount: Int\n    get() {\n       return collection.size\n    } \n    \n  \/**\n   * returns the number of pages\n   *\/\n  val pageCount: Int\n    get() {\n       return collection.size \/ itemsPerPage + 1\n    }\n\n\n  \/**\n   * returns the number of items on the current page. page_index is zero based.\n   * this method should return -1 for pageIndex values that are out of range\n   *\/\n  fun pageItemCount(pageIndex: Int): Int {\n      if (pageIndex < (collection.size \/ itemsPerPage))\n        return itemsPerPage\n      else if (pageIndex == (collection.size \/ itemsPerPage))\n        return collection.size % itemsPerPage\n      else\n        return -1\n  }\n  \n  \n  \/**\n   * determines what page an item is on. Zero based indexes\n   * this method should return -1 for itemIndex values that are out of range\n   *\/\n  fun pageIndex(itemIndex: Int): Int {\n      if (itemIndex > collection.size || itemIndex < 0 || collection.size == 0)\n        return -1;\n      return itemIndex \/ itemsPerPage\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205404,"user_id":null,"body":"class PaginationHelper<T>(val collection: List<T>, val itemsPerPage: Int) {\n\n  val itemCount: Int\n    get() {\n       return collection.size\n    } \n\n  val pageCount: Int\n    get() {\n       return collection.size \/ itemsPerPage + 1\n    }\n\n  fun pageItemCount(pageIndex: Int): Int {\n      if (pageIndex < (collection.size \/ itemsPerPage))\n        return itemsPerPage\n      else if (pageIndex == (collection.size \/ itemsPerPage))\n        return collection.size % itemsPerPage\n      else\n        return -1\n  }\n  \n  fun pageIndex(itemIndex: Int): Int {\n      if (itemIndex > collection.size || itemIndex < 0 || collection.size == 0)\n        return -1;\n      return itemIndex \/ itemsPerPage\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205405,"user_id":null,"body":"class PaginationHelper<T>(val collection: List<T>, val itemsPerPage: Int) {\n    \n   \/**\n   * returns the number of items within the entire collection\n   *\/\n  val itemCount: Int\n    get() {\n       return collection.size\n    } \n    \n  \/**\n   * returns the number of pages\n   *\/\n  val pageCount: Int\n    get() {\n       return collection.size \/ itemsPerPage + 1\n    }\n\n\n  \/**\n   * returns the number of items on the current page. page_index is zero based.\n   * this method should return -1 for pageIndex values that are out of range\n   *\/\n  fun pageItemCount(pageIndex: Int): Int {\n      if (pageIndex < (collection.size \/ itemsPerPage))\n        return itemsPerPage\n      else if (pageIndex == (collection.size \/ itemsPerPage))\n        return collection.size % itemsPerPage\n      else\n        return -1\n  }\n  \n  \n  \/**\n   * determines what page an item is on. Zero based indexes\n   * this method should return -1 for itemIndex values that are out of range\n   *\/\n  fun pageIndex(itemIndex: Int): Int {\n      println(\"ind $itemIndex\")\n      println(\"size ${collection.size}\")\n      if (itemIndex > collection.size || itemIndex < 0 || collection.size == 0)\n        return -1;\n      return itemIndex \/ itemsPerPage\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205406,"user_id":null,"body":"class PaginationHelper<T>(val collection: List<T>, val itemsPerPage: Int) {\n    \n   \/**\n   * returns the number of items within the entire collection\n   *\/\n  val itemCount: Int\n    get() = collection.size\n    \n  \/**\n   * returns the number of pages\n   *\/\n  val pageCount: Int\n    get() {\n        val fullPage = collection.size \/ itemsPerPage\n        val itemLeft = collection.size % itemsPerPage\n        return if (itemLeft > 0) {\n            fullPage + 1\n        } else {\n            fullPage\n        }\n    }\n\n  \/**\n   * returns the number of items on the current page. page_index is zero based.\n   * this method should return -1 for pageIndex values that are out of range\n   *\/\n  fun pageItemCount(pageIndex: Int): Int {\n      val fullPageCount = collection.size \/ itemsPerPage\n      return if (pageIndex in 0 until fullPageCount) {\n          itemsPerPage\n      } else if (pageIndex == pageCount - 1) {\n          collection.size % itemsPerPage\n      } else {\n          -1\n      }\n  }\n  \n  \n  \/**\n   * determines what page an item is on. Zero based indexes\n   * this method should return -1 for itemIndex values that are out of range\n   *\/\n  fun pageIndex(itemIndex: Int): Int {\n      return if (itemIndex in 0 until collection.size) {\n          val fullPage = (itemIndex + 1) \/ itemsPerPage\n          if (itemIndex + 1 % itemsPerPage > 0) {\n              fullPage\n          } else {\n              fullPage - 1\n          }\n      } else {\n          -1\n      }\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"517abf86da9663f1d2000003":[{"id":205407,"user_id":null,"body":"fun to_camel_case(str: String) =\n    str.split('-', '_').mapIndexed { i, it -> if (i != 0) it.capitalize() else it }.joinToString(\"\")","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205408,"user_id":null,"body":"fun to_camel_case(str:String):String = str.split(Regex(\"_|-\")).reduce{ fullString, word -> fullString + word.capitalize() }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205409,"user_id":null,"body":"fun to_camel_case(str: String): String =\n    str.split(\"-\", \"_\").mapIndexed { i, s -> if (i == 0) s else s.capitalize() }.joinToString(\"\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205410,"user_id":null,"body":"fun to_camel_case(str: String): String =\n    str.split(\"_\", \"-\").mapIndexed { i, s -> if (i > 0) s.capitalize() else s }.joinToString(\"\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205411,"user_id":null,"body":"fun to_camel_case(s: String) = s.split(\"-\", \"_\").run {\n    drop(1).joinToString(\"\", first()) { it.capitalize() }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205412,"user_id":null,"body":"fun to_camel_case(str: String): String {\n    return str.split('-', '_').mapIndexed { index, word ->\n        when (index) {\n            0 -> word\n            else -> word.capitalize()\n        }\n    }.joinToString(\"\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205413,"user_id":null,"body":"fun to_camel_case(str:String):String {\n    return str.split(\"-\", \"_\")\n        .mapIndexed { index, el ->\n            if (index == 0)\n                el\n            else \n                el.capitalize()\n        }\n        .joinToString(\"\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205414,"user_id":null,"body":"fun to_camel_case(str:String):String{\n    var ans = str.split(\"-\", \"_\")\n    var ans1 = ans.filterIndexed{index, i -> index !=0 }.\n        joinToString(\"\") { (it.first().toUpperCase() + it.substringAfter(it.first())) }\n    return ans[0]+ans1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205415,"user_id":null,"body":"\nprivate val DELIMITERS = arrayOf<String>(\"-\", \"_\")\n\nfun to_camel_case(str: String): String {\n    return str.split(*DELIMITERS)\n        .joinToString(\"\") { word -> word.replaceFirstChar { it.uppercase() } }\n        .replaceFirstChar { str.first() }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205416,"user_id":null,"body":"fun to_camel_case(str:String):String {\n    val result = StringBuilder()\n  with(str.split(\"-\",\"_\")){\n      result.append(this[0])\n      for(i in 1 until size)\n        result.append(this[i][0].toUpperCase() + this[i].substring(1 until this[i].length))\n  }\n return result.toString()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"51b6249c4612257ac0000005":[{"id":205417,"user_id":53,"body":"package romannumerals\n\nfun solution(str: String): Int \n{\n    var ans = 0\n    var prev = '_'\n    for (token in str) \n    {        \n        when (token)\n        {\n            'I' ->                                  ans += 1   \n            'V' -> if (prev == 'I') ans += 3   else ans += 5\n            'X' -> if (prev == 'I') ans += 8   else ans += 10\n            'L' -> if (prev == 'X') ans += 30  else ans += 50\n            'C' -> if (prev == 'X') ans += 80  else ans += 100\n            'D' -> if (prev == 'C') ans += 300 else ans += 500\n            'M' -> if (prev == 'C') ans += 800 else ans += 1000\n        }\n        prev = token\n    }\n    return ans\n}","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205418,"user_id":null,"body":"package romannumerals\n\nval numbersMap = mapOf('M' to 1000, 'D' to 500, 'C' to 100, 'L' to 50, 'X' to 10, 'V' to 5, 'I' to 1)\n\nfun solution(str: String): Int {\n\n    var rawNumbers = str.map { char -> numbersMap.getOrElse(char, { null }) }.filterNotNull()\n    var normalizedNumbers = rawNumbers.mapIndexed { i, num -> if (num < rawNumbers.elementAtOrElse(i + 1) { Int.MIN_VALUE }) -num else num }\n    return normalizedNumbers.toIntArray().sum()\n}","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205419,"user_id":null,"body":"package romannumerals\n\nfun solution(str: String): Int {\n    if(str.isEmpty()) return 0\n    val values = mapOf(\n        'M' to 1000,\n        'D' to 500,\n        'C' to 100,\n        'L' to 50,\n        'X' to 10,\n        'V' to 5,\n        'I' to 1\n    )\n\n    var result: Int =values.getValue(str.first())\n\n    for (i in 1 until str.length){\n        val current = values.getValue(str[i])\n        val previous = values.getValue(str[i-1])\n\n        if(current <= previous) {\n            result += current\n        } else if(current> previous){\n            result += (current - (previous * 2))\n        }\n    }\n    \n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205420,"user_id":null,"body":"package romannumerals\n\nfun solution(str: String): Int {\n    var current = 0 \n    var previous = 0\n    var arabic = 0\n\n    for(i in 0 until str.length) {\n        when(str[i]) {\n            'I' -> current = 1\n            'V' -> current = 5\n            'X' -> current = 10\n            'L' -> current = 50\n            'C' -> current = 100\n            'D' -> current = 500\n            'M' -> current = 1000\n        }\n        \n        if (current > previous) {\n            arabic += current - (previous * 2)\n        } \n        else {\n            arabic += current\n        }\n\n        previous = current\n    }\n    \n    return arabic\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205421,"user_id":null,"body":"package romannumerals\n\nfun decode (str:String):Int {\n    var number=0\n    var num=0\n    var lastnum = 1000\n    for (ch in str){\n        when (ch){\n            'I' ->  num = 1\n            'V' -> num  =5\n            'X' -> num = 10\n            'L' -> num =50\n            'C' -> num =100\n            'D' -> num =500\n            'M' -> num =1000\n        }\n        if (num <= lastnum) number +=num\n            else number = number + (num-lastnum-lastnum)\n        lastnum= num\n\n    }\n\n    return number\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205422,"user_id":null,"body":"package romannumerals\n\nfun solution(str: String): Int {\n    val tmp = str.map {\n        when (it) {\n            'M' -> 1000\n            'D' -> 500\n            'C' -> 100\n            'L' -> 50\n            'X' -> 10\n            'V' -> 5\n            else -> 1\n        }\n    }\n    return tmp.mapIndexed { index, i -> if (tmp.size > (index + 1) && i < tmp[index + 1]) - i else i }.sum()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205423,"user_id":null,"body":"package romannumerals\n\nval values = mapOf(\n    'I' to 1,\n    'V' to 5,\n    'X' to 10,\n    'L' to 50,\n    'C' to 100,\n    'D' to 500,\n    'M' to 1000,\n)\n\nfun solution(str: String): Int {\n    return str.map { values.getValue(it) }.plus(0).zipWithNext().map { (current, next) ->\n        if (current < next) -current else current\n    }.sum()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205424,"user_id":null,"body":"package romannumerals\n\nfun solution(s: String): Int {\n    val map = mutableMapOf('I' to 1, 'V' to 5, 'X' to 10, 'L' to 50, 'C' to 100, 'D' to 500, 'M' to 1000)\n    var counter = 0\n    var last = 1000\n    s.forEach {\n        map[it]?.let {\n            if (it > last) counter -= last * 2\n            counter += it\n            last = it\n        }\n    }\n    return counter\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205425,"user_id":null,"body":"package romannumerals\n\nfun solution(str: String): Int {\n    var result = 0\n    var last :Int? =null\n    for (s in str) {\n      val value = when (s) {\n          'I' -> 1\n          'V' -> 5\n          'X' -> 10\n          'L' -> 50\n          'C' -> 100\n          'D' -> 500\n          'M' -> 1000\n          else -> continue\n      }\n      if (last!=null&&last<value)\n        result += value-2*last\n      else\n        result += value\n      last = value\n    }\n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205426,"user_id":null,"body":"package romannumerals\n\nfun solution(str: String): Int =\n    str.replace(\"CM\",   \" 900 \")\n        .replace(\"M\",   \" 1000 \")\n        .replace(\"CD\",  \" 400 \")\n        .replace(\"D\",   \" 500 \")\n        .replace(\"XC\",  \" 90 \")\n        .replace(\"C\",   \" 100 \")\n        .replace(\"XL\",  \" 40 \")\n        .replace(\"L\",   \" 50 \")\n        .replace(\"IX\",  \" 9 \")\n        .replace(\"X\",   \" 10 \")\n        .replace(\"IV\",  \" 4 \")\n        .replace(\"V\",   \" 5 \")\n        .replace(\"III\", \" 3 \")\n        .replace(\"II\",  \" 2 \")\n        .replace(\"I\",   \" 1 \")\n        .split(\" \")\n        .filter { it.isNotEmpty() }\n        .sumOf { it.toInt() }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"51b62bf6a9c58071c600001b":[{"id":205427,"user_id":null,"body":"package romannumerals\n\nfun encode(num: Int): String {\n    tailrec fun encodeAux(num: Int, acc: String): String =\n        if (num == 0) acc else {\n            val (k, v) = numerals.first { it.second <= num }\n            encodeAux(num - v, acc + k)\n        }\n    return encodeAux(num, \"\")\n}\n\nval numerals = listOf(\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\").zip(\n    listOf(1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)\n)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205428,"user_id":null,"body":"package romannumerals\n\nfun encode(num: Int): String {\n    val romanNumerals = mapOf(\n        \"M\" to 1000,\"CM\" to 900,\n        \"D\" to 500,\"CD\" to 400,\n        \"C\" to 100,\"XC\" to 90,\n        \"L\" to 50,\"XL\" to 40,\n        \"X\" to 10,\"IX\" to 9,\n        \"V\" to 5,\"IV\" to 4,\n        \"I\" to 1\n    )\n    var number = num\n    var str = \"\"\n    for (i in romanNumerals) {\n        while(number >= i.value) {\n            str += i.key\n            number -= i.value\n        }\n    }\n    return str\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205429,"user_id":null,"body":"package romannumerals\n\nval romanMap = mapOf(1000 to \"M\", 900 to \"CM\", 500 to \"D\", 400 to \"CD\", 100 to \"C\", 90 to \"XC\", 50 to \"L\", 40 to \"XL\", 10 to \"X\", 9 to \"IX\", 5 to \"V\", 4 to \"IV\", 1 to \"I\")\n\nfun encode(num: Int): String {\n    var mutableNum = num\n    val builder = StringBuilder()\n    romanMap.forEach{ (numValue, romanValue) ->\n        while(mutableNum>=numValue){\n            builder.append(romanValue)\n            mutableNum -= numValue\n        }\n    }\n    return builder.toString()\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205430,"user_id":null,"body":"package romannumerals\n\nfun encode(num: Int): String {\n    var remainder = num\n    \n    fun extract(symbol: String, divisor: Int): String {\n        val quotient = remainder \/ divisor\n        remainder %= divisor\n        return symbol.repeat(quotient)\n    }\n    \n    return \"\" +\n        extract(\"M\", 1000) +\n        extract(\"CM\", 900) +\n        extract(\"D\", 500) +\n        extract(\"CD\", 400) +\n        extract(\"C\", 100) +\n        extract(\"XC\", 90) +\n        extract(\"L\", 50) +\n        extract(\"XL\", 40) +\n        extract(\"X\", 10) +\n        extract(\"IX\", 9) +\n        extract(\"V\", 5) +\n        extract(\"IV\", 4) +\n        extract(\"I\", 1)\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205431,"user_id":null,"body":"package romannumerals\n\nfun encode(num: Int): String {\n     val c = arrayOf(\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\")\n     val n = arrayOf(1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)\n     var ret = \"\"\n     var number = num\n     (0..12).forEach {ind->\n        while(number-n[ind]>=0) {\n            ret += c[ind]\n            number -= n[ind]\n        }\n     }\n     return ret\n}\n\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205432,"user_id":null,"body":"package romannumerals\n\nfun encode(num: Int): String {\n    var input = num\n    if (input < 1)\n        return \"\";\n    var s = \"\";\n    while (input >= 1000) {\n        s += \"M\";\n        input -= 1000;        }\n    while (input >= 900) {\n        s += \"CM\";\n        input -= 900;\n    }\n    while (input >= 500) {\n        s += \"D\";\n        input -= 500;\n    }\n    while (input >= 400) {\n        s += \"CD\";\n        input -= 400;\n    }\n    while (input >= 100) {\n        s += \"C\";\n        input -= 100;\n    }\n    while (input >= 90) {\n        s += \"XC\";\n        input -= 90;\n    }\n    while (input >= 50) {\n        s += \"L\";\n        input -= 50;\n    }\n    while (input >= 40) {\n        s += \"XL\";\n        input -= 40;\n    }\n    while (input >= 10) {\n        s += \"X\";\n        input -= 10;\n    }\n    while (input >= 9) {\n        s += \"IX\";\n        input -= 9;\n    }\n    while (input >= 5) {\n        s += \"V\";\n        input -= 5;\n    }\n    while (input >= 4) {\n        s += \"IV\";\n        input -= 4;\n    }\n    while (input >= 1) {\n        s += \"I\";\n        input -= 1;\n    }    \n    return s;\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205433,"user_id":null,"body":"package romannumerals\n\nfun encode(num: Int): String {\n    var i = \"I\"\n    var iv = \"IV\"\n    var v = \"V\"\n    var ix = \"IX\"\n    var x = \"X\"\n    var xl = \"XL\"\n    var xc = \"XC\"\n    var l = \"L\"\n    var c =\"C\"\n    var cd= \"CD\"\n    var d =\"D\"\n    var cm = \"CM\"\n    var m = \"M\"\n    var result =\"\"\n    var num2 = num\n    if (num >=1000){\n        var ms = num \/ 1000\n        result = m.repeat(ms)\n        num2 = num2 - 1000 * ms\n    }\n    if (num2 >=900){\n        result = result + cm\n        num2= num2 -900\n    }\n    if (num2 >= 500){\n        var ms = num2 \/ 500\n        result = result + d.repeat(ms)\n        num2= num2 -500*ms\n    }\n    if(num2 >=400) {\n        result = result+ cd\n        num2 = num2-400\n    }\n    if(num2 >= 100){\n        var ms = num2 \/ 100\n        result = result + c.repeat(ms)\n        num2=num2-100*ms\n    }\n    if(num2 >=90) {\n        result = result +xc\n        num2=num2-90\n    }\n        if(num2 >= 50){\n        var ms = num2 \/ 50\n        result = result + l.repeat(ms)\n        num2=num2-50*ms\n    }\n        if(num2>= 40){\n            result = result+xl\n            num2 = num2 -40\n        }\n        if(num2 >= 10){\n        var ms = num2 \/ 10\n        result = result + x.repeat(ms)\n        num2=num2-10*ms\n    }\n        if (num2>= 9) {\n            result = result+ix\n            num2=num2-9\n        }\n        if(num2 >= 5){\n        var ms = num2 \/ 5\n        result = result + v.repeat(ms)\n        num2=num2-5*ms\n    }\n        if (num2 >=4){\n            result=result+iv\n            num2=num2-4\n        }\n        if(num2 >= 1){\n        var ms = num2\n        result = result + i.repeat(ms)\n        num2=num2-ms\n    }\n    \n    return result\n    }\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205434,"user_id":null,"body":"package romannumerals\n\nfun encode(num: Int): String = \"I\".repeat(num)\n        .replace(\"IIIII\", \"V\")\n        .replace(\"IIII\", \"IV\")\n        .replace(\"VV\", \"X\")\n        .replace(\"VIV\", \"IX\")\n        .replace(\"XXXXX\", \"L\")\n        .replace(\"XXXX\", \"XL\")\n        .replace(\"LL\", \"C\")\n        .replace(\"LXL\", \"XC\")\n        .replace(\"CCCCC\", \"D\")\n        .replace(\"CCCC\", \"CD\")\n        .replace(\"DD\", \"M\")\n        .replace(\"DCD\", \"CM\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205435,"user_id":null,"body":"package romannumerals\n\nval list = listOf(\n    1000 to \"M\",\n    900 to \"CM\",\n    500 to \"D\",\n    400 to \"CD\",\n    100 to \"C\",\n    90 to \"XC\",\n    50 to \"L\",\n    40 to \"XL\",\n    10 to \"X\",\n    9 to \"IX\",\n    5 to \"V\",\n    4 to \"IV\",\n    1 to \"I\"\n)\n\nfun encode(num: Int): String {\n    list.forEach {\n        if (num - it.first >= 0) {\n            return it.second + encode(num - it.first)\n        }\n    }\n    return \"\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205436,"user_id":null,"body":"package romannumerals\n\nenum class Romans(val dec: Int) {\n    M(1000),\n    CM(900),\n    D(500),\n    CD(400),\n    C(100),\n    XC(90),\n    L(50),\n    XL(40),\n    X(10),\n    IX(9),\n    V(5),\n    IV(4),\n    I(1)\n}\n\nfun encode(num: Int): String {\n    var current = num\n    var romanString = \"\"\n    for (roman in Romans.values()) {\n        romanString += roman.name.repeat(current \/ roman.dec)\n        current %= roman.dec\n    }\n\n    return romanString\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"51ba717bb08c1cd60f00002f":[{"id":205437,"user_id":null,"body":"fun solution(\n    arr: IntArray\n): String = arr.fold(emptyList<Pair<Int, Int>>()) { rs, x ->\n    rs.lastOrNull().run { if (this != null && x - second == 1) rs.dropLast(1) + (first to x) else rs + (x to x) }\n}.joinToString(\",\") { (x, y) -> if (y - x > 1) \"$x-$y\" else (x..y).joinToString(\",\") }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205438,"user_id":null,"body":"fun solution(arr: IntArray): String {\n    var str = \"\"\n  \n    arr.forEachIndexed{index, element -> \n            if (index == 0 || element - arr[index - 1] > 1) \n        \t\tstr += \",$element\"\n        \telse if ((index < arr.size - 1 && arr[index + 1] - element > 1) || index == arr.size - 1)  \n        \t\tif (index > 1 && element - arr[index - 2] == 2)\n        \t\t  str += \"-$element\"\n        \t\telse\n        \t\t str += \",$element\"\t\n        \t\t\n    }\n    \n    return str.drop(1)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205439,"user_id":null,"body":"fun solution(\n    arr: IntArray\n): String = arr.fold(emptyList<Pair<Int, Int>>()) { ranges, x ->\n    ranges.lastOrNull()\n        .run { if (this != null && x - second == 1) ranges.dropLast(1) + (first to x) else ranges + (x to x) }\n}.joinToString(\",\") { (x, y) ->\n    when (y - x) {\n        0 -> \"$x\"\n        1 -> \"$x,$y\"\n        else -> \"$x-$y\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205440,"user_id":null,"body":"fun solution(arr: IntArray): String {\n\n    data class myIntRange(val start: Int, var count: Int = 1 ) {\n        override fun toString() : String = when(count) {\n            1 -> start.toString()\n            2 -> \"${start},${start+1}\"\n            else -> \"${start}-${start+count-1}\"\n        }       \n        fun isNext(i: Int) : Boolean = start+count == i\n        fun add() { count++ }\n    }\n\n    val acc = ArrayList<myIntRange>()\n    for( i in arr )\n        if( !acc.isEmpty() && acc.last().isNext(i) )\n            acc.last().add()\n        else\n            acc.add( myIntRange(i) )\n    return acc.joinToString(\",\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205441,"user_id":null,"body":"fun solution(a: IntArray) = StringBuilder().run {\n    for (i in a.indices) {\n        if (i == 0 || a[i] - a[i - 1] > 1) append(\",${a[i]}\")\n        else if ((i < a.size - 1 && a[i + 1] - a[i] > 1) || i == a.lastIndex)\n            append(if (i > 1 && a[i] - a[i - 2] == 2) \"-${a[i]}\" else \",${a[i]}\")\n    }\n    toString().drop(1)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205442,"user_id":null,"body":"fun solution(\n    arr: IntArray\n): String = arr.fold(emptyList<IntRange>()) { ranges, x ->\n    ranges.lastOrNull()\n        .run { if (this != null && x - last == 1) ranges.dropLast(1) + listOf(first..x) else ranges + listOf(x..x) }\n}.joinToString(\",\") { if (it.last - it.first > 1) \"${it.first}-${it.last}\" else it.joinToString(\",\") }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205443,"user_id":null,"body":"fun solution(a: IntArray): String {\n  var s = \"\"\n\tvar i=0;\n\twhile(i < a.size){\n\t\tif(i+2>=a.size) s+=a[i].toString()+\",\"\n\t\telse if(a[i+2]==a[i]+2){\n\t\t\ts+=a[i].toString()+\"-\";\n\t\t\twhile(i<a.size-1 && a[i+1]-a[i]==1) i++;\n\t\t\ts+=a[i].toString()+\",\"\n\t\t}\n\t\telse s+=a[i].toString()+\",\"\n\t\ti++;\n\t\t}\n\treturn s.dropLast(1)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205444,"user_id":null,"body":"\nfun IntArray.runFrom(i: Int): Int {\n    var t = 0;\n    var c = this[i]\n    for (x in (i + 1) until this.size) {\n        if (c == this[x] - 1) {\n            t++\n            c = this[x]\n        }\n        else return t\n    }\n    return t\n}\n\nfun solution(a: IntArray): String {\n    val s = StringBuffer() \/\/ for the results\n\n    var i = 0\n    while (i < a.size) {\n        val r = a.runFrom(i) \/\/ how long is the range?\n\n        if (r > 1) {\n            s.append(\"${ a[i] }-${ a[i+r] },\") \/\/append the range\n            i += r \/\/ add the range count\n\n        } else s.append(\"${ a[i] },\")\n        i++\n    }\n\n    return s.toString().substringBeforeLast(',')\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205445,"user_id":null,"body":"fun solution(\n    arr: IntArray\n): String = arr.drop(1).fold(emptyList<IntRange>() to arr[0]..arr[0]) { (ranges, range), x ->\n    if (x - range.last == 1) ranges to range.first..range.last + 1\n    else ranges + listOf(range) to x..x\n}.let { it.first + listOf(it.second) }.joinToString(\",\") {\n    if (it.last - it.first > 1) \"${it.first}-${it.last}\"\n    else it.joinToString(\",\")\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205446,"user_id":null,"body":"fun groupToSequences(numbers: IntArray): List<List<Int>> {\n    val sequences = mutableListOf<MutableList<Int>>()\n\n    numbers.forEach {\n        val lastSequence = sequences.lastOrNull()\n\n        if (lastSequence == null || lastSequence.lastOrNull() != it - 1) {\n            sequences.add(mutableListOf(it))\n        } else {\n            lastSequence.add(it)\n        }\n    }\n\n    return sequences\n}\n\nfun sequenceToString(sequence: List<Int>): String = when (sequence.size) {\n    1 -> sequence.first().toString()\n    2 -> \"${sequence.first()},${sequence.last()}\"\n    else -> \"${sequence.first()}-${sequence.last()}\"\n}\n\nfun solution(arr: IntArray): String\n        = groupToSequences(arr).joinToString(\",\", transform = ::sequenceToString)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"51c8991dee245d7ddf00000e":[{"id":205447,"user_id":527,"body":"object Reverse {\n  fun reverseWords(str: String): String = str.split(' ').reversed().joinToString(\" \")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205448,"user_id":null,"body":"object Reverse{\n   fun reverseWords(str: String): String {\n        return str\n            .split(\" \")\n            .asReversed()\n            .joinToString(\" \") \n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205449,"user_id":null,"body":"object Reverse{\n   fun reverseWords(str:String) = str.split(\" \").reversed().joinToString(\" \")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205450,"user_id":null,"body":"object Reverse{\n    fun reverseWords(str:String):String\n    {\n        var tmp =\"\"\n        var ans =\"\"\n        for(i in str)\n        {\n          if(i == ' ')\n          {\n              ans = \" \"+tmp+ans;\n              tmp =\"\"\n          }\n          else\n          {\n              tmp+=i\n          }\n          \n        }\n        \n        return tmp+ans\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205451,"user_id":null,"body":"object Reverse{\n   fun reverseWords(str:String):String {\n       val parts = str.split(\" \")\n       var res = \"\"\n       for (i in parts.size-1 downTo 0) \n           res += parts.get(i) + \" \"\n      return res.substringBeforeLast(' ') ;\n   }\n  \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205452,"user_id":null,"body":"object Reverse{\n   fun reverseWords(s: String) = s.split(\" \").reduce{a,b -> b+\" \"+a}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205453,"user_id":null,"body":"object Reverse{\nfun reverseWords(str:String): String {\n    var l = str.length\n    var end = 0\n    var s = \"\"\n    for(i in str.length-1 downTo 0){\n      \n        if(str[i].equals(' ') )\n        {\n            end = i\n        \ts += str.substring(end, l)\n        \tl = i\n        }\n\t\telse if(i==0){\n            end = i\n            s += \" \"+ str.substring(end, l) \n        }       \n    }\n    return(s.trim())\n}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205454,"user_id":null,"body":"object Reverse {\n    fun reverseWords(str: String): String = str.split(\" \").asReversed().toString().replace(\",\", \"\").substring(1, str.length+1)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205455,"user_id":null,"body":"object Reverse{\n    fun reverseWords(str:String):String {\n        var result = \"\"\n        val list = str.split(\" \").reversed()\n        list.forEach {\n            result += it + \" \"\n        }\n        return result.substring(0, result.length-1)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205456,"user_id":null,"body":"object Reverse{\n   fun reverseWords(str:String):String=str.split(\" \").toList().reversed().joinToString { it}.replace(\",\", \"\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"51c8e37cee245da6b40000bd":[{"id":205457,"user_id":null,"body":"fun solution(input: String, markers: CharArray): String =\n   input.lines().map { line ->\n       line.split(*markers).first().trimEnd()\n   }.joinToString(\"\n\")\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205458,"user_id":null,"body":"    fun solution(input: String, markers: CharArray): String =\n            input.split(\"\n\").joinToString(\"\n\") {\n                it.takeWhile { char -> !markers.contains(char) }.trim()\n            }.trim()\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205459,"user_id":null,"body":"fun solution(input: String, markers: CharArray) =\n    input.lines().joinToString(\"\n\") { it.takeWhile { !markers.contains(it) }.trim() }\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205460,"user_id":null,"body":"fun solution(input: String, markers: CharArray): String =\n        input.split(\"\n\").map { line -> line.takeWhile { !markers.contains(it) }.trimEnd() }.joinToString(\"\n\")\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205461,"user_id":1267,"body":"fun solution(input: String, markers: CharArray): String {\n   val regex = Regex(\"\"\"[${markers.sortedBy{it}.joinToString(\"\")}].*$\"\"\");\n   return input.split(\"\n\").map{it.replace(regex, \"\").trim()}.joinToString(\"\n\")\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205462,"user_id":null,"body":"fun solution(input: String, markers: CharArray): String =\n    Regex(\"\\\\s[${markers.joinToString(\"\\\\\")}].*\").replace(input, \"\")\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205463,"user_id":null,"body":"fun solution(input: String, markers: CharArray) = input.lines().map{it.split(*markers).first().trimEnd()}.joinToString(\"\n\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205464,"user_id":null,"body":"fun solution(input: String, d: CharArray): String {\nvar str:String=\"\";\nvar s=input.lines()\nfirst@ for(i in 0..s.size-1){\n\t\tfor(j in 0..s[i].toString().length-1)\n\t\t\t\tif(d.contains(s[i][j].toChar()))\n\t\t\t\t{\n                str += (s[i].substring(0,j)).trimEnd()+\"\n\";\n                continue@first;\n                }\n\t\tstr+=s[i]+\"\n\"\n\t}\n\tstr=str.dropLast(1)\n\treturn str\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205465,"user_id":179,"body":"import java.util.regex.Pattern;\n\nfun solution(input: String, markers: CharArray): String {\n    val regex = markers.map{ \"$it\" }.map(Pattern::quote).joinToString(\"|\").let{ \"\\\\s*((${it}).*)?${'$'}\" }.toRegex()\n    return input.split(\"\n\").map{ it.replace(regex, \"\") }.joinToString(\"\n\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205466,"user_id":null,"body":"fun solution(input: String, markers: CharArray): String {\n    var out = \"\"\n    for(s in input.split(\"\n\")){\n        var line = s\n        for(m in markers){\n            if(s.contains(m)){\n                line = s.substring(0, s.indexOf(m))\n            }\n        }\n        out += line.trim()+ \"\n\"\n    }\n    return out.trim()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"51e056fe544cf36c410000fb":[{"id":205467,"user_id":null,"body":"fun top_three_words(s: String): List<String> =\n    s.toLowerCase()\n        .split(\"[^a-z']+\".toRegex())\n        .filter { it.contains(\"[a-z]\".toRegex()) }\n        .groupingBy { it }\n        .eachCount()\n        .entries\n        .sortedByDescending { it.value }\n        .take(3)\n        .map { it.key }","lang_id":29,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205468,"user_id":null,"body":"private val wordExpression = Regex(\"[a-z']*[a-z][a-z']*\")\n\nfun top_three_words(s: String): List<String> =\n    wordExpression.findAll(s.toLowerCase()).map { it.value }\n        .groupingBy { it }.eachCount().toList()\n        .sortedByDescending { it.second }.take(3).map { it.first }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205469,"user_id":179,"body":"fun top_three_words(s: String) = \"'?[a-z]['a-z]*\".toRegex().findAll(s.lowercase()).map{it.value}.groupingBy{it}.eachCount().entries.sortedByDescending{it.value}.take(3).map{it.key}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205470,"user_id":null,"body":"fun top_three_words(s: String): List<String> {\n println(s)\n  return Regex(\"[a-zA-Z]+('?[a-zA-Z]*)*\")\n    .findAll(s)\n    .map { it.value.toLowerCase() }\n    .groupBy { it }\n    .map { it.key to it.value.size }\n    .sortedByDescending { it.second }\n    .map { it.first }\n    .take(3)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205471,"user_id":null,"body":"fun top_three_words(s: String): List<String> = \"([a-z]+'?[a-z']*)\".toRegex()\n    .findAll(s.lowercase())\n    .map { it.value }\n    .groupingBy { it }\n    .eachCount()\n    .entries\n    .sortedByDescending { it.value }\n    .take(3)\n    .map { it.key }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205472,"user_id":null,"body":"val letters = ('a'..'z').toSet()\nval wordChars = letters +setOf('\\'')\n\nfun isWord(w :String) = letters.any{ c -> c in w }\n\nfun top_three_words(input :String) :List<String> {\n    val result = mutableMapOf<String, Int>()\n    var begin = \"\"\n    for (c in input.trim().lowercase()) when {\n        c in wordChars -> begin += c\n        else -> if (begin.isNotEmpty()) {\n            if (isWord(begin))\n                result[begin] = (result[begin] ?: 0) +1\n            begin = \"\"\n        }\n    }\n    if (begin.isNotEmpty() && isWord(begin))\n        result[begin] = (result[begin] ?: 0) +1\n        \n    return result.entries.sortedByDescending{ e -> e.value }\n        .take(3).map { e -> e.key }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205473,"user_id":null,"body":"fun top_three_words(s: String): List<String> = generateSequence( \/\/ lazily extract words in order to achieve bonus 1\n    s.extractNextWord()\n) { (_, tail) -> tail.takeIf { it.isNotEmpty() }?.extractNextWord() }.map { it.first }.filter {\n    it.isNotBlank() && it[0].isLetter()\n}.map { it.toLowerCase() }.groupingBy { it }.eachCount().entries.fold( \/\/ search for top 3 words without sorting\n    listOf<Map.Entry<String, Int>?>(null, null, null)\n) { acc, x ->\n    when {\n        acc[2] >= x -> acc\n        acc[1] >= x -> listOf(acc[0], acc[1], x)\n        acc[0] >= x -> listOf(acc[0], x, acc[1])\n        else -> listOf(x, acc[0], acc[1])\n    }\n}.mapNotNull { it?.key }\n\nprivate fun String.extractNextWord(): Pair<String, String> = indexOfFirst { !it.isLetter() && it != '\\'' }.takeIf {\n    it >= 0\n}?.let { substring(0, it) to substring(it + 1, length) } ?: this to \"\"\n\nprivate operator fun Map.Entry<String, Int>?.compareTo(other: Map.Entry<String, Int>?): Int = when {\n    this != null && other != null -> value.compareTo(other.value)\n    this != null -> 1\n    other != null -> -1\n    else -> 0\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205474,"user_id":null,"body":"fun top_three_words(s: String): List<String> = s.toLowerCase().asSequence()\n    .joinToString(\"\") { if (it.isLetter() || it == '\\'') \"$it\" else \" \" }.split(\" \").asSequence()\n    .filter { it.isNotBlank() && it[0].isLetter() }.groupingBy { it }.eachCount().asSequence()\n    .sortedByDescending { it.value }.take(3).map { it.key }.toList()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205475,"user_id":null,"body":"fun top_three_words(text: String): List<String> {\n    val words = Regex(\"[A-Za-z][A-Za-z']*\").findAll(text).map { it.groupValues[0].toLowerCase() }\n    val occurrences = mutableMapOf<String, Int>()\n    words.forEach { occurrences.merge(it, 1, Integer::sum) }\n    return occurrences.toList().sortedByDescending { it.second }.map { it.first }.take(3)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205476,"user_id":null,"body":"private val WORD_REGEX = Regex(\"\"\"[A-Za-z][A-Za-z']*\"\"\")\n\nfun top_three_words(s: String): List<String> {\n    val words = WORD_REGEX.findAll(s).map{ it.value.toLowerCase() }\n    val occurrences = mutableMapOf<String, Int>()\n    for (word in words) {\n        occurrences[word] = (occurrences[word] ?: 0) + 1\n    }\n    return occurrences.asSequence()\n        .sortedByDescending{ it.value }\n        .take(3)\n        .map{ it.key }\n        .toList()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"523b4ff7adca849afe000035":[{"id":205477,"user_id":527,"body":"fun greet() = \"hello world!\"\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205478,"user_id":null,"body":"\/\/ Write a function `greet` that returns \"hello world!\"\nval greet: () -> String = {\"hello world!\"}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205479,"user_id":null,"body":"\/\/ Write a function `greet` that returns \"hello world!\"\n\/\/ Fun that prints \"hello world\"\nfun greet() : String {\n    return \"hello world!\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205480,"user_id":null,"body":"\/\/ Write a function `greet` that returns \"hello world!\"\nimport kotlin.math.*\n\nprivate val bird = 33\n\nfun greet() =\n    \"\"\"\n        Oh yay, another starter function.  Why is it always 'hello, world!'?\n        Apparently it started with 'A Tutorial Introduction to the Language B',\n        a book by Brian Kernighan. Usage continued with 'The C Programming Language',\n        also written by Kernighan along with Dennis Ritchie. If you're not familiar, \n        it's a super important book for a myriad of reasons and most modern languages\n        have concepts\/syntax\/conventions influenced by C.\n        With that said, this is an awful way to write a 'hello, world!' program.\n        If you learn anything here, make sure it's this bit of history, not the\n        gratuitous code below.        \n    \"\"\"\n        .trimIndent()\n        .filter { it.isLetter() }\n        .filterNot { it.isUpperCase() }\n        .slice(((PI * (100.2 + floor(12.345678))).toInt())..((984.0) \/ E).toInt())\n        .map { max(it.toLong() * PI.pow(84 % 7), it.toDouble().ulp).toLong() }\n        .filterNot { it < floor(133.33 % 12.31).pow(2) }\n        .joinToString(\"\") { it.toChar().toString().toLowerCase() }\n        .chunked(4372 % 397)\n        .joinToString('\\u0020'.toString())\n        .plus((bird).toChar().toString())","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205481,"user_id":null,"body":"fun greet() : String = \"!dlrow olleh\".reversed()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205482,"user_id":null,"body":"val greet = { \"hello world!\" }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205483,"user_id":null,"body":"    fun greet():String{\n        val h=\"h\"\n        val e=\"e\"\n        val l=\"l\"\n        val o=\"o\"\n        val space=\" \"\n        val w=\"w\"\n        val r=\"r\"\n        val d=\"d\"\n        val sign=\"!\"\n        return \"$h$e$l$l$o$space$w$o$r$l$d$sign\"\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205484,"user_id":null,"body":"fun greet(): String {\n val letters=arrayOf(104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33)\n return letters.map { it.toChar()}.joinToString(\"\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205485,"user_id":null,"body":"fun greet(hi: String = \"hello world!\") = hi\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205486,"user_id":null,"body":"val greet: () -> String = { listOf(104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33).map(Int::toChar).joinToString(\"\") }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"526156943dfe7ce06200063e":[{"id":205487,"user_id":null,"body":"import java.util.*\n\nclass BrainLuck(s: String) {\n    private val code = s.toCharArray()\n    private val size = code.size\n    \n    private val table = NeverGetNullValueMap().apply {\n        val stack = LinkedList<Int>()\n        for (i in code.indices) when {\n            code[i] == '[' -> stack.push(i)\n            code[i] == ']' -> stack.pop().also { put(i, it); put(it, i) }\n        }\n    }\n    \n    fun process(input: String): String = buildString {\n        val input = input.toCharArray().iterator()\n        val data = NeverGetNullValueMap()\n        var p = 0\n        var i = 0\n        while (i < size) {\n            when (code[i]) {\n                '>' -> p++\n                '<' -> p--\n                '+' -> data[p] = (data[p] + 1) % 0xff\n                '-' -> data[p] = (data[p] - 1) % 0xff\n                '.' -> append(data[p].toChar())\n                ',' -> data[p] = input.nextChar().toByte().toInt()\n                '[' -> if (data[p] == 0) i = table[i]\n                ']' -> if (data[p] != 0) i = table[i]\n            }\n            i++\n        }\n    }\n\n    private class NeverGetNullValueMap : HashMap<Int, Int>() {\n        override fun get(key: Int) = super.get(key) ?: 0\n    }\n}\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205488,"user_id":null,"body":"class BrainLuck(private val code: String) {\n\n    private val data = Array<Byte>(10000) { 0 }\n\n    private var dataPointer = 0\n    private var codePointer = 0\n    private var inputPointer = 0\n    private var output = \"\"\n\n    fun process(input: String): String {\n        dataPointer = 0\n        codePointer = 0\n        inputPointer = 0\n        output = \"\"\n        while (codePointer < code.length) {\n            execute(input)\n            codePointer++\n        }\n        return output\n    }\n\n    private fun execute(input: String) {\n        when (code[codePointer]) {\n            '>' -> dataPointer++\n            '<' -> dataPointer--\n            '+' -> data[dataPointer]++\n            '-' -> data[dataPointer]--\n            '.' -> output += data[dataPointer].toChar()\n            ',' -> data[dataPointer] = input[inputPointer++].toByte()\n            '[' -> if (data[dataPointer] == 0.toByte()) jump(1)\n            ']' -> if (data[dataPointer] != 0.toByte()) jump(-1)\n        }\n    }\n    \n    private fun jump(inc: Int) {\n        var counter = 1\n        while (counter > 0) {\n            codePointer += inc\n            when (code[codePointer]) {\n                '[' -> counter += inc\n                ']' -> counter -= inc\n            }\n        }\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205489,"user_id":null,"body":"class BrainLuck(code: String) {\n\n    companion object {\n        private const val MAXIMAL_DATA_SIZE = 5000\n        private const val INITIAL_DATA_POINTER_LOCATION = 1000\n        private const val MAXIMAL_MEMORY_CELL_SIZE = 255\n    }\n\n    private lateinit var executionState: ExecutionState\n    private var commands: List<Command>\n\n    init {\n        commands = BrainLuckCompiler().compile(code)\n    }\n\n    fun process(input: String): String {\n        setUpInitialState(input)\n        with(executionState) {\n            while (commandPointer < commands.size) {\n                commands[commandPointer].run(executionState)\n                commandPointer++\n            }\n        }\n        return executionState.output\n    }\n\n    private fun setUpInitialState(input: String) {\n        executionState = ExecutionState(\n            dataPointer = INITIAL_DATA_POINTER_LOCATION,\n            data = Array(MAXIMAL_DATA_SIZE) { 0 },\n            input = input\n        )\n    }\n\n    data class ExecutionState(\n        var commandPointer: Int = 0,\n        var inputPointer: Int = 0,\n        var dataPointer: Int = 0,\n        var output: String = \"\",\n        var data: Array<Int>,\n        val input: String\n    )\n\n    interface Command {\n        fun run(executionState: ExecutionState)\n    }\n\n    class EmptyCommand : Command {\n        override fun run(executionState: ExecutionState) {}\n    }\n\n    class LoadDataCommand : Command {\n        override fun run(executionState: ExecutionState) {\n            with(executionState) {\n                data[dataPointer] = input[inputPointer].toInt()\n                inputPointer++\n            }\n        }\n\n    }\n\n    class OutputDataCommand : Command {\n        override fun run(executionState: ExecutionState) {\n            with(executionState) {\n                output += data[dataPointer].toChar()\n            }\n        }\n\n    }\n\n    class IncrementDataPointerCommand : Command {\n        override fun run(executionState: ExecutionState) {\n            executionState.dataPointer++\n        }\n\n    }\n\n    class DecrementDataPointerCommand : Command {\n        override fun run(executionState: ExecutionState) {\n            executionState.dataPointer--\n        }\n\n    }\n\n    class IncrementDataUnderPointerCommand : Command {\n        override fun run(executionState: ExecutionState) {\n            with(executionState) {\n                data[dataPointer] = ((data[dataPointer] + 1) % (MAXIMAL_MEMORY_CELL_SIZE + 1))\n            }\n        }\n\n    }\n\n    class DecrementDataUnderPointerCommand : Command {\n        override fun run(executionState: ExecutionState) {\n            with(executionState) {\n                data[dataPointer] = ((data[dataPointer] - 1) % (MAXIMAL_MEMORY_CELL_SIZE + 1))\n            }\n        }\n\n    }\n\n    class StartLoopCommand(val startIndex: Int, var endIndex: Int? = null) : Command {\n        override fun run(executionState: ExecutionState) {\n            with(executionState) {\n                if (data[dataPointer] == 0) {\n                    endIndex?.let { commandPointer = it }\n                }\n            }\n        }\n\n    }\n\n    class EndLoopCommand(private val startIndex: Int) : Command {\n        override fun run(executionState: ExecutionState) {\n            with(executionState) {\n                if (data[dataPointer] != 0) {\n                    commandPointer = startIndex\n                }\n            }\n        }\n\n    }\n\n    class CommandsProvider {\n\n        private val loopsStack = ArrayList<StartLoopCommand>()\n\n        private val loadDataCommand = LoadDataCommand()\n        private val outputDataCommand = OutputDataCommand()\n        private val decrementDataPointerCommand = DecrementDataPointerCommand()\n        private val incrementDataPointerCommand = IncrementDataPointerCommand()\n        private val incrementDataUnderPointerCommand = IncrementDataUnderPointerCommand()\n        private val decrementDataUnderPointerCommand = DecrementDataUnderPointerCommand()\n        private val emptyCommand = EmptyCommand()\n\n        fun provide(commandCode: Char, commandIndex: Int): Command {\n            return when (commandCode) {\n                ',' -> loadDataCommand\n                '.' -> outputDataCommand\n                '<' -> decrementDataPointerCommand\n                '>' -> incrementDataPointerCommand\n                '+' -> incrementDataUnderPointerCommand\n                '-' -> decrementDataUnderPointerCommand\n                '[' -> createStartLoopCommand(commandIndex)\n                ']' -> createEndLoopCommand(commandIndex)\n                else -> emptyCommand\n            }\n        }\n\n        private fun createStartLoopCommand(commandIndex: Int): StartLoopCommand {\n            val startLoop = StartLoopCommand(commandIndex)\n            loopsStack.add(startLoop)\n            return startLoop\n        }\n\n        private fun createEndLoopCommand(commandIndex: Int): EndLoopCommand {\n            val connectedStartLoop = loopsStack.removeLast()\n            val endLoop = EndLoopCommand(connectedStartLoop.startIndex)\n            connectedStartLoop.endIndex = commandIndex\n            return endLoop\n        }\n\n    }\n\n    class BrainLuckCompiler(private val commandsProvider: CommandsProvider = CommandsProvider()) {\n        fun compile(code: String): List<Command> {\n            return code.mapIndexed { index, it ->\n                commandsProvider.provide(it, index)\n            }\n        }\n\n    }\n}\n\nfun <T> MutableList<T>.removeLast(): T {\n    val last = this[this.lastIndex]\n    this.removeAt(this.lastIndex)\n    return last\n}\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205490,"user_id":null,"body":"import java.util.*\n\n@ExperimentalUnsignedTypes\nclass BrainLuck(private val program: String) {\n    private val byte0: UByte = 0.toUByte()\n\n    private val inputQ: Queue<UByte> = LinkedList()\n\n    private var dataIndex: Int = 0\n    private val data: UByteArray = UByteArray(1000) { byte0 }\n\n    fun process(input: String): String = buildString {\n        inputQ.addAll(input.map { c -> c.toInt().toUByte() })\n\n        var programIndex = 0\n        while (programIndex < program.length) {\n            when (program[programIndex]) {\n                '>' -> dataIndex++\n                '<' -> dataIndex--\n                '+' -> data[dataIndex] = data[dataIndex].inc()\n                '-' -> data[dataIndex] = data[dataIndex].dec()\n                ',' -> data[dataIndex] = inputQ.poll()\n                '.' -> append(data[dataIndex].toInt().toChar())\n                '[' -> {\n                    if (data[dataIndex] == byte0) {\n                        programIndex = forwardToMatchingCloseBrace(programIndex, program)\n                    }\n                }\n                ']' -> {\n                    if (data[dataIndex] != byte0) {\n                        programIndex = backToMatchingOpenBrace(programIndex, program)\n                    }\n                }\n            }\n\n            programIndex++\n        }\n    }\n\n    companion object {\n\n        fun forwardToMatchingCloseBrace(x: Int, program: String): Int {\n            if (!program[x].equals('[')) {\n                \/\/index not on an open bracket, abort.\n                return x\n            }\n\n            var nextOpen: Int\n            var nextClose = -1\n            var openCounter = 1\n            var from = x + 1\n            while (openCounter > 0) {\n                nextOpen = program.indexOf(\"[\", from)\n                nextClose = program.indexOf(\"]\", from)\n                if ((nextOpen > -1) && nextOpen < nextClose) {\n                    openCounter++\n                    from = nextOpen + 1\n                } else if (nextClose > -1) {\n                    openCounter--\n                    from = nextClose + 1\n                }\n            }\n\n            return nextClose\n        }\n\n        fun backToMatchingOpenBrace(x: Int, program: String): Int {\n            if (!program[x].equals(']')) {\n                \/\/index not on an close bracket, abort.\n                return x\n            }\n\n            var nextOpen = -1\n            var nextClose: Int\n            var closeCounter = 1\n            var from = x - 1\n            while (closeCounter > 0) {\n                nextOpen = program.lastIndexOf(\"[\", from)\n                nextClose = program.lastIndexOf(\"]\", from)\n                if ((nextClose > -1) && nextClose > nextOpen) {\n                    closeCounter++\n                    from = nextClose - 1\n                } else if (nextOpen > -1) {\n                    closeCounter--\n                    from = nextOpen - 1\n                }\n            }\n\n            return nextOpen\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205491,"user_id":null,"body":"import java.util.*\n\nclass BrainLuck(private val code: String) {\n    fun process(input: String): String {\n        var dataPointer = 0\n        var inputPointer = 0\n        var instructionPointer = 0\n        val data = mutableListOf(0.toUByte())\n        val output = StringBuilder()\n\n        while (instructionPointer != code.length) {\n            when (code[instructionPointer]) {\n                '>' -> {\n                    dataPointer++\n                    if (dataPointer !in data.indices) {\n                        data.add(0.toUByte())\n                    }\n                    instructionPointer++\n                }\n                '<' -> {\n                    dataPointer--\n                    instructionPointer++\n                }\n                '+' -> {\n                    data[dataPointer] = data[dataPointer].inc()\n                    instructionPointer++\n                }\n                '-' -> {\n                    data[dataPointer] = data[dataPointer].dec()\n                    instructionPointer++\n                }\n                '.' -> {\n                    output.append(data[dataPointer].toInt().toChar())\n                    instructionPointer++\n                }\n                ',' -> {\n                    data[dataPointer] = input[inputPointer].code.toUByte()\n                    inputPointer++\n                    instructionPointer++\n                }\n                '[' -> {\n                    if (data[dataPointer] == 0.toUByte()) {\n                        var rightBracketRemain = 0\n                        instructionPointer++\n                        var instruction = code[instructionPointer]\n                        while (instruction != ']' || rightBracketRemain != 0) {\n                            when (instruction) {\n                                '[' -> rightBracketRemain++\n                                ']' -> rightBracketRemain--\n                            }\n                            instructionPointer++\n                            instruction = code[instructionPointer]\n                        }\n                    }\n                    instructionPointer++\n                }\n                ']' -> {\n                    if (data[dataPointer] != 0.toUByte()) {\n                        var leftBracketRemain = 0\n                        instructionPointer--\n                        var instruction = code[instructionPointer]\n                        while (instruction != '[' || leftBracketRemain != 0) {\n                            when (instruction) {\n                                '[' -> leftBracketRemain--\n                                ']' -> leftBracketRemain++\n                            }\n                            instructionPointer--\n                            instruction = code[instructionPointer]\n                        }\n                    }\n                    instructionPointer++\n                }\n            }\n        }\n        return output.toString()\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205492,"user_id":null,"body":"import java.util.*\n\nclass BrainLuck(private val code: String) {\n    val tape = Array<UByte>(5000) { 0.toUByte() }\n    private var inputPointer = 0\n    private var tapePointer = 0\n    private var codePointer = 0\n    private var result = \"\"\n    private val loopStack: Stack<Int> = Stack()\n    private var skipCounter = 0\n\n    fun process(input: String): String {\n        processToken(input)\n        return result\n    }\n\n    private fun processToken(input: String):Unit {\n        while (codePointer < code.length) {\n            when (code[codePointer]) {\n                ',' -> processInput(input)\n                '.' -> processOutput()\n                '>' -> processRightMove()\n                '<' -> processLeftMove()\n                '+' -> processIncrease()\n                '-' -> processDecrease()\n                '[' -> processLoopStart()\n                ']' -> processLoopEnd()\n                else -> processErrorInCode()\n            }\n        }\n    }\n\n    private fun processLoopEnd() {\n        if(isLoopSkipping()) {\n            skipCounter--\n            codePointer++\n        } else if (isLoopCounterZero()) {\n            loopStack.pop()\n            codePointer++\n        } else {\n            codePointer = loopStack.pop()\n        }\n    }\n\n    private fun processLoopStart() {\n        if (isLoopCounterZero()) {\n          skipCounter++\n          codePointer++\n        } else {\n            loopStack.push(codePointer)\n            codePointer++\n        }\n    }\n\n    private fun isLoopSkipping() = skipCounter > 0\n    private fun isLoopCounterZero() = \"0\" == tape[tapePointer].toString()\n\n    private fun processIncrease() {\n        if(isLoopSkipping()) {\n            codePointer++\n        } else {\n            tape[tapePointer] = tape[tapePointer].inc()\n            codePointer++\n        }\n    }\n\n    private fun processDecrease() {\n        if(isLoopSkipping()) {\n            codePointer++\n        } else {\n            tape[tapePointer] = tape[tapePointer].dec()\n            codePointer++\n        }\n    }\n\n    private fun processLeftMove() {\n        if(isLoopSkipping()) {\n            codePointer++\n        } else {\n            tapePointer--;\n            codePointer++\n        }\n    }\n\n    private fun processRightMove() {\n        if(isLoopSkipping()) {\n            codePointer++\n        } else {\n            tapePointer++;\n            codePointer++\n        }\n    }\n\n    private fun processErrorInCode() {\n        println(\"Unexpected token: ${code[codePointer]}\")\n        codePointer++\n    }\n\n    private fun processOutput() {\n        if(isLoopSkipping()) {\n            codePointer++\n        } else {\n            result += Char(tape[tapePointer].toInt())\n            codePointer++\n        }\n    }\n\n    private fun processInput(input: String) {\n        if(isLoopSkipping()) {\n            codePointer++\n        } else {\n            tape[tapePointer] = input[inputPointer].code.toUByte();\n            inputPointer++;\n            codePointer++\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205493,"user_id":null,"body":"import java.util.*\n\nclass BrainLuck(private val code: String) {\n\n    fun process(input: String): String {\n        val turningBand = CharArray(1000) \/\/ Create our Turing band\n        turningBand.fill(0.toChar())          \/\/ Initialize the band with 0\n        val result = mutableListOf<Char>() \/\/ result return list\n\n        var pointerInput = 0    \/\/ pointer for Input\n        var pointerBand = 0     \/\/ pointer for Band\n        var pointerCode = 0     \/\/ pointer for Code\n\n        \/\/ Resolving Nested Bracket Problem\n        val bracketOpenListIndex = mutableListOf<Int>() \/\/ saves the Index of '['\n        val bracketMap = HashMap<Int, Int>()    \/\/ saves the Index value in String code to the other bracket\n        for (i in 0..code.lastIndex) {\n            when (code[i]) {\n                '[' -> bracketOpenListIndex.add(i) \/\/ add Index of [ to the list\n                ']' -> {\n                    bracketMap[bracketOpenListIndex.last()] = i \/\/ add the last open Bracket Index as key with closed Bracket as value\n                    bracketMap[i] = bracketOpenListIndex.removeLast() \/\/ add closed Bracket as Key and removes last open Bracket from listr and adds it as Value\n                }\n            }\n        }\n        while (pointerCode <= code.lastIndex) { \/\/ go through the code until IndexOutOfBounds\n            when (code[pointerCode]) { \/\/ parse the code to execute the right Instruction\n                '>' -> pointerBand += 1\n                '<' -> pointerBand -= 1\n                '+' -> if (turningBand[pointerBand] < Char(225)) turningBand[pointerBand] =\n                    Char(turningBand[pointerBand].code + 1) else turningBand[pointerBand] = Char(0)\n                '-' -> if (turningBand[pointerBand] > Char(0)) turningBand[pointerBand] =\n                    Char(turningBand[pointerBand].code - 1) else turningBand[pointerBand] = Char(0)\n                '.' -> result.add(turningBand[pointerBand])\n                ',' -> turningBand[pointerBand] = input[pointerInput].also { pointerInput += 1 }\n                '[' -> if (turningBand[pointerBand] == Char(0)) pointerCode = bracketMap.getValue(pointerCode)\n                ']' -> if (turningBand[pointerBand] != Char(0)) pointerCode = bracketMap.getValue(pointerCode)\n            }\n            pointerCode += 1\n        }\n        return result.joinToString(\"\") \/\/ return result List as String\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205494,"user_id":null,"body":"import java.util.*\n\nclass BrainLuck(private val code: String) {\n    private val tape= MutableList<UByte>(5000){0.toUByte()}\n    var pointer = 0\n    var stringPointer = 0\n    fun process(input: String): String {\n        val inp = input.map { it.code }\n        var ret = \"\"\n        var index = 0\n        while(index in 0 .. code.lastIndex){\n            when(code[index]){\n                '>'->{index++\n                    pointer++}\n                '<'->{index++\n                    pointer--}\n                '+'->{index++\n                    tape[pointer]++}\n                '-'->{index++\n                    tape[pointer]--}\n                '.'->{index++\n                    ret+=tape[pointer].toInt().toChar()}\n                ','->{index++\n                    tape[pointer]=inp[stringPointer++].toUByte()}\n                '['->{\n                        if(tape[pointer]==0.toUByte()){\n                            var cnt =1\n                            while (cnt!=0){\n                                index++\n                                when(code[index]){\n                                    '['->cnt++\n                                    ']'->cnt--\n                                }\n                            }\n                            index++\n                        }\n                    else index++\n                    }\n                else->{\n                    if(tape[pointer]!=0.toUByte()){\n                        var cnt =1\n                        while (cnt!=0){\n                            index--\n                            when(code[index]){\n                                '['->cnt--\n                                ']'->cnt++\n                            }\n                        }\n                        index++\n                    }\n                    else index++\n                }\n\n            }\n\n        }\n        return ret\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205495,"user_id":null,"body":"import java.util.*\n\nclass BrainLuck(private val code: String) {\n\n    fun process(input: String): String {\n\n        val dataArray = ByteArray(30000)\n\n        var dataPointer = 0\n        var inputPointer = 0\n        var codePointer = 0\n\n        val result = StringBuilder()\n\n        while (codePointer < code.length) {\n            when (code[codePointer]) {\n                '>' -> dataPointer++\n                '<' -> dataPointer--\n                '+' -> dataArray[dataPointer]++\n                '-' -> dataArray[dataPointer]--\n                '.' -> result.append(dataArray[dataPointer].toInt().toChar())\n                ',' -> if (inputPointer < input.length) dataArray[dataPointer] = input[inputPointer++].code.toByte()\n                '[' -> if (dataArray[dataPointer] == 0.toByte()) codePointer =\n                    findIndexOfMatchingClosingBracket(codePointer)\n                ']' -> if (dataArray[dataPointer] != 0.toByte()) codePointer =\n                    findIndexOfMatchingOpeningBracket(codePointer)\n            }\n            codePointer++\n        }\n\n\n        return result.toString()\n    }\n\n\n    private fun findIndexOfMatchingOpeningBracket(programmPointer: Int): Int {\n        var pointer = programmPointer\n        var counter = 0\n        while (pointer > 0) {\n            pointer--\n\n            if (code[pointer] == \"]\".toCharArray().first()) counter++\n            if (code[pointer] == \"[\".toCharArray().first() && counter == 0) return pointer\n            if (code[pointer] == \"[\".toCharArray().first() && counter > 0) counter--\n\n        }\n        throw IllegalArgumentException()\n\n    }\n\n    private fun findIndexOfMatchingClosingBracket(programmPointer: Int): Int {\n        var pointer = programmPointer\n        var counter = 0\n        while (pointer > 0) {\n            pointer++\n\n            if (code[pointer] == \"[\".toCharArray().first()) counter++\n            if (code[pointer] == \"]\".toCharArray().first() && counter == 0) return pointer\n            if (code[pointer] == \"]\".toCharArray().first() && counter > 0) counter--\n\n        }\n        throw IllegalArgumentException()\n\n    }\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205496,"user_id":null,"body":"import java.util.*\n\nclass InputHandler(private var input: String) {    \n    fun getInput(): UByte {\n        val result = input[0].toChar().code.toUByte()\n        input = input.drop(1)\n        return result\n    }\n}\n\nclass BrainLuck(private val code: String) {\n\n    private val memory = Array<UByte>(20) { 0.toUByte() }\n    private val loopStack = ArrayDeque<Int>()\n    private var passCount = 0\n    private var instructionPointer = 0\n    private var memoryPointer = 0\n\n    fun interpret(inputHandler: InputHandler): String {\n        if (passCount > 0) {\n            when (code[instructionPointer]) {\n                '[' -> passCount++\n                ']' -> passCount--\n            }\n            return \"\"\n        }\n        \n        when (code[instructionPointer]) {\n            '+' -> memory[memoryPointer]++\n            '-' -> memory[memoryPointer]--\n            '>' -> memoryPointer++\n            '<' -> memoryPointer--\n            '.' -> return memory[memoryPointer].toInt().toChar().toString()\n            ',' -> memory[memoryPointer] = inputHandler.getInput()\n            \n            '[' -> \n            if (memory[memoryPointer] == 0.toUByte()) {\n                passCount++\n                if (loopStack.peek() == instructionPointer) {\n                    loopStack.pop()\n                }\t\n            }\n            else {\n                loopStack.push(instructionPointer)\n            }\n            \n            ']' -> \n            if (memory[memoryPointer] > 0.toUByte()) {\n                instructionPointer = loopStack.peek()\n            }\n            else {\n                loopStack.pop()\n            }\n        }\n        \n        return \"\"\n    }\n    \n\tfun process(input: String): String {\n       \tval inputHandler = InputHandler(input)\n        var result = \"\"\n\n        while (instructionPointer < code.length) {\n            result += interpret(inputHandler)\n            instructionPointer++\n        }\n        \n    \treturn result\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5263c6999e0f40dee200059d":[{"id":205497,"user_id":null,"body":"fun padLock(touched: Char) = when (touched) {\n    '1' -> listOf(1, 2, 4)\n    '2' -> listOf(1, 2, 3, 5)\n    '3' -> listOf(2, 3, 6)\n    '4' -> listOf(1, 4, 5, 7)\n    '5' -> listOf(2, 4, 5, 6, 8)\n    '6' -> listOf(3, 5, 6, 9)\n    '7' -> listOf(4, 7, 8)\n    '8' -> listOf(5, 7, 8, 9, 0)\n    '9' -> listOf(6, 8, 9)\n    '0' -> listOf(8, 0)\n    else -> error(\"touched $touched\")\n}.map { it.toString() }\n\nfun get_pins(observed: String): List<String> = observed\n    .map { padLock(it) }\n    .reduce { acc, pins -> pins.flatMap { a -> acc.map { it + a } } }\n    .distinct()\n","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205498,"user_id":100,"body":"val adj = mapOf(\n    '1' to setOf('1', '2', '4'),\n    '2' to setOf('2', '1', '3', '5'),\n    '3' to setOf('3', '2', '6'),\n    '4' to setOf('4', '1', '5', '7'),\n    '5' to setOf('5', '2', '4', '6', '8'),\n    '6' to setOf('6', '3', '5', '9'),\n    '7' to setOf('7', '4', '8'),\n    '8' to setOf('8', '0', '5', '7', '9'),\n    '9' to setOf('9', '6', '8'),\n    '0' to setOf('0', '8')\n)\n\nfun get_pins(observed: String): List<String> {\n    return observed\n        .map { adj[it] }.toTypedArray().fold(listOf(listOf<Char>())) { acc, set ->\n            acc.flatMap { list -> set?.map { element -> list + element } ?: listOf() }\n        }.toSet().map { String(it.toCharArray()) }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205499,"user_id":null,"body":"val adjacentKeys = mapOf(\n    '1' to \"124\", '2' to \"1235\", '3' to \"236\", '4' to \"1457\", '5' to \"24568\",\n    '6' to \"3569\", '7' to \"478\", '8' to \"57890\", '9' to \"689\", '0' to \"80\"\n)\n\nfun get_pins(observed: String): List<String> =\n    observed.map { adjacentKeys[it]!!.map { key -> \"$key\" } }\n        .reduce { acc, pin -> pin.flatMap { adjacent -> acc.map { it + adjacent } } }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205500,"user_id":null,"body":"fun get_pins(observed: String) = allPossibleCombinations(observed.map{getAdjacent(it)})\n\nfun allPossibleCombinations (arr: List<List<Char>>) : List<String> {\n  if(arr.size == 1) {\n        return arr[0].map{\"$it\"}\n  } else {\n        val result = mutableListOf<String>()\n        val allCombinationsOfRest = allPossibleCombinations(arr.drop(1))\n        allCombinationsOfRest.indices.forEach {i->\n          arr[0].indices.forEach {j->\n            result.add(\"\" + arr[0][j] + allCombinationsOfRest[i]);\n          }\n        }\n        return result;\n  }\n}\n\nfun getAdjacent (num : Char) : List<Char> =\n\/\/    \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n\/\/    \u2502 1 \u2502 2 \u2502 3 \u2502\n\/\/    \u251c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\/\/    \u2502 4 \u2502 5 \u2502 6 \u2502\n\/\/    \u251c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\/\/    \u2502 7 \u2502 8 \u2502 9 \u2502\n\/\/    \u2514\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2518\n\/\/        \u2502 0 \u2502\n\/\/        \u2514\u2500\u2500\u2500\u2518\n  when(num) {\n      '1'  ->  listOf('1','4','2')\n      '2'  ->  listOf('2','1','3','5')\n      '3'  ->  listOf('3','2','6')\n      '4'  ->  listOf('4','1','5','7')\n      '5'  ->  listOf('5','4','2','6','8')\n      '6'  ->  listOf('6','3','5','9')\n      '7'  ->  listOf('7','4','8')\n      '8'  ->  listOf('8','7','5','9','0')\n      '9'  ->  listOf('9','8','6')\n      '0'  ->  listOf('0','8')\n      else ->  listOf(' ')\n  }\n  \n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205501,"user_id":null,"body":"\nval digits = mapOf(\n    Pair(0,0) to '1',\n    Pair(0,1) to '2',\n    Pair(0,2) to '3',\n    Pair(1,0) to '4',\n    Pair(1,1) to '5',\n    Pair(1,2) to '6',\n    Pair(2,0) to '7',\n    Pair(2,1) to '8',\n    Pair(2,2) to '9',\n    Pair(3,1) to '0',\n)\n\nfun get_pins(observed: String): List<String> {\n    return pinVariants(observed.map { c -> digitVariants(c) })\n}\n\nfun pinVariants(digitVariants: List<List<String>>): List<String> {\n    if (digitVariants.size == 1) return digitVariants.first()\n    return pinVariants(digitVariants.drop(1)).map { v -> digitVariants.first().map { d -> \"$d$v\"}}.flatten()\n}\n\nfun digitVariants(digit: Char?): List<String> {\n    if (digit == null) return listOf()\n    val variants = mutableListOf<Char?>()\n    val position = digits.filterValues { c -> c == digit }.keys.first()\n    variants.add(digit)\n    variants.add(digits[Pair(position.first - 1, position.second)])\n    variants.add(digits[Pair(position.first + 1, position.second)])\n    variants.add(digits[Pair(position.first, position.second - 1)])\n    variants.add(digits[Pair(position.first, position.second + 1)])\n    return variants.filterNotNull().map(Char::toString).sorted()\n}\n\nfun replacePIN(pin: String, index: Int, replace: Char?): String {\n    return pin.substring(0, index) + replace + pin.substring(index + 1)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205502,"user_id":null,"body":"\n    fun get_pins(observed: String): List<String> {\n        val optionsFor = mapOf(\n            '1' to listOf(\"1\", \"2\", \"4\"),\n            '2' to listOf(\"1\", \"2\", \"3\", \"5\"),\n            '3' to listOf(\"2\", \"3\", \"6\"),\n            '4' to listOf(\"1\", \"4\", \"5\", \"7\"),\n            '5' to listOf(\"2\", \"4\", \"5\", \"6\", \"8\"),\n            '6' to listOf(\"3\", \"5\", \"6\", \"9\"),\n            '7' to listOf(\"4\", \"7\", \"8\"),\n            '8' to listOf(\"5\", \"7\", \"8\", \"9\", \"0\"),\n            '9' to listOf(\"6\", \"8\", \"9\"),\n            '0' to listOf(\"8\", \"0\")\n        )\n        return observed.map { optionsFor[it] ?: emptyList() }\n            .fold(listOf(\"\")) { variations, options ->\n                variations.map{ variation -> options.map { option -> \"${variation}${option}\" } }.flatten()\n            }\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205503,"user_id":null,"body":"fun get_pins(observed: String): List<String> {\n\n    val possibleDigits = observed.toCharArray().map {\n        when (it) {\n            '1' -> listOf(\"1\", \"2\", \"4\")\n            '2' -> listOf(\"1\", \"2\", \"3\", \"5\")\n            '3' -> listOf(\"2\", \"3\", \"6\")\n            '4' -> listOf(\"1\", \"4\", \"5\", \"7\")\n            '5' -> listOf(\"2\", \"4\", \"5\", \"6\", \"8\")\n            '6' -> listOf(\"3\", \"5\", \"6\", \"9\")\n            '7' -> listOf(\"4\", \"7\", \"8\")\n            '8' -> listOf(\"0\", \"5\", \"7\", \"8\", \"9\")\n            '9' -> listOf(\"6\", \"8\", \"9\")\n            '0' -> listOf(\"0\", \"8\")\n            else -> listOf()\n        }\n    }\n\n    val result = mutableListOf<String>()\n\n    getCombinations(\"\", possibleDigits, result)\n\n    return result\n}\n\nfun getCombinations(input: String, remaining: List<List<String>>, output: MutableList<String>) {\n    if (remaining.isEmpty()) {\n        output.add(input)\n    } else {\n        remaining[0].forEach { getCombinations(input + it, remaining.subList(1, remaining.size), output) }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205504,"user_id":null,"body":"fun get_pins(observed: String): List<String> {\n    val digits = observed.map { c ->\n        getPossibleDigits(c)\n    }\n    return getPossiblePins(\"\", digits).toList()\n}\n\nfun getPossiblePins(current: String, remainDigits: List<CharArray>): Set<String> {\n    return if (remainDigits.isEmpty()) {\n        if (current.isEmpty()) {\n            emptySet()\n        } else {\n            setOf(current)\n        }\n    } else {\n        val result = mutableSetOf<String>()\n        val nextRemain = remainDigits.drop(1)\n        remainDigits.first().forEach { digit ->\n            result.addAll(getPossiblePins(current + digit, nextRemain))\n        }\n        result\n    }\n}\n\nfun getPossibleDigits(c: Char): CharArray {\n    return when(c) {\n        '1' -> charArrayOf('1', '2', '4')\n        '2' -> charArrayOf('1', '2', '3', '5')\n        '3' -> charArrayOf('2', '3', '6')\n        '4' -> charArrayOf('1', '4', '5', '7')\n        '5' -> charArrayOf('2', '4', '5', '6', '8')\n        '6' -> charArrayOf('3', '5', '6', '9')\n        '7' -> charArrayOf('4', '7', '8')\n        '8' -> charArrayOf('5', '7', '8', '9', '0')\n        '9' -> charArrayOf('6', '8', '9')\n        '0' -> charArrayOf('8', '0')\n        else -> charArrayOf()\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205505,"user_id":null,"body":"fun get_pins(observed: String): List<String> {\n    val resultList = mutableListOf<String>()\n\n    observed.forEachIndexed { index, c ->\n        if (index == 0) {\n            getPossibleNum(c).forEach {\n                resultList.add(\"$it\")\n            }\n        } else {\n            val newList = mutableListOf<String>()\n            resultList.forEach { oldString ->\n                getPossibleNum(c).forEach {\n                    newList.add(\"$oldString$it\")\n                }\n            }\n            resultList.clear()\n            newList.distinct()\n            resultList.addAll(newList)\n        }\n    }\n\n    return resultList\n}\n\nfun getPossibleNum(char: Char): List<Char> {\n    return when (char) {\n        '0' -> listOf('0', '8')\n        '1' -> listOf('1', '2','4')\n        '2' -> listOf('1', '2', '3', '5')\n        '3' -> listOf('2', '3', '6')\n        '4' -> listOf('1', '4', '5', '7')\n        '5' -> listOf('2', '4', '5', '6', '8')\n        '6' -> listOf('3', '5', '6', '9')\n        '7' -> listOf('4', '7', '8')\n        '8' -> listOf('5', '7', '8', '9', '0')\n        '9' -> listOf('6', '8', '9')\n        else -> listOf()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205506,"user_id":null,"body":"fun get_pins(observed: String): List<String> = recEnumeration(observed, 0)\nfun recEnumeration(obs : String, i : Int) : List<String>{\n    val mutableObserved : CharArray = obs.toCharArray()\n    val result : MutableList<String> = mutableListOf()\n    neighbors[obs[i]]!!.map {\n        mutableObserved[i] = it\n        if (i < obs.length - 1)\n            result += recEnumeration(mutableObserved.joinToString(\"\"), i + 1)\n        else\n            result += mutableObserved.joinToString(\"\")\n    }\n    return result\n}\nval neighbors : Map<Char, String> = mapOf(\n    '1' to \"124\",\n    '2' to \"2135\",\n    '3' to \"326\",\n    '4' to \"4157\",\n    '5' to \"52468\",\n    '6' to \"6359\",\n    '7' to \"748\",\n    '8' to \"85790\",\n    '9' to \"968\",\n    '0' to \"08\"\n)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5264d2b162488dc400000001":[{"id":205507,"user_id":null,"body":"package spinwords\nfun spin_words(s: String) = s.split(\" \").joinToString(\" \") { if (it.length > 4) it.reversed() else it }","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205508,"user_id":null,"body":"package spinwords\n\nfun spin_words(sentence: String) = sentence.split(\" \").joinToString(\" \") { if (it.length > 4) it.reversed() else it }","lang_id":29,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205509,"user_id":null,"body":"package spinwords\n\nfun spin_words(sentence: String): String = sentence\n    .split(\" \")\n    .map { it.reverseIfLongerThan(4) }\n    .joinToString(\" \", \"\", \"\")\n\nfun String.reverseIfLongerThan(length: Int) = when {\n    this.length > length -> this.reversed()\n    else -> this\n}","lang_id":29,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205510,"user_id":null,"body":"package spinwords\n\nfun spin_words(sentence: String) = sentence.split(\" \").map{ if(it.length >= 5) it.reversed() else it }.joinToString(\" \")\n","lang_id":29,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205511,"user_id":null,"body":"package spinwords\n\nfun spin_words(sentence: String): String = sentence.split(' ').map {\n    when {\n        it.length >= 5 -> it.reversed()\n        else -> it\n    }\n}.joinToString(\" \")","lang_id":29,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205512,"user_id":null,"body":"package spinwords\n\nfun spin_words(sentence: String) = sentence.split(\" \").joinToString(\" \") { if(it.length >= 5) it.reversed() else it }","lang_id":29,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205513,"user_id":null,"body":"package spinwords\n\nfun spin_words(sentence: String): String {\n    return sentence.split(\" \").map {\n        if (it.length < 5) it else it.reversed()\n    }.joinToString().replace(\",\", \"\")\n}","lang_id":29,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205514,"user_id":null,"body":"package spinwords\n\nfun spin_words(sentence: String): String =\n  \/\/ Split words by the space character.\n  sentence.split(\" \")\n    \/\/ Join them back but with reversed order of letters for words longer than 4 characters.\n    .joinToString(\" \") {\n      if (it.length > 4)\n        it.reversed()\n      else\n        it\n    }","lang_id":29,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205515,"user_id":null,"body":"package spinwords\n\nfun spin_words(frase: String): String {\n   val palavras: List<String> = frase.split(\" \")\n    var novaFrase: String = \"\"\n    for (palavra in palavras){\n        novaFrase = if(palavra.length >= 5){\n            val novaPalavra = palavra.toMutableList().asReversed().joinToString(\"\")\n            novaFrase.plus(novaPalavra).plus(\" \")\n        }else{\n            novaFrase.plus(palavra).plus(\" \")\n        }\n    }\n    novaFrase = novaFrase.substring(0, novaFrase.length - 1);\n    return novaFrase\n}","lang_id":29,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205516,"user_id":null,"body":"package spinwords\n\nfun spin_words(sentence: String): String {\n    var outStr = \"\"\n    var words = sentence.split(\" \")\n        for (i in words){\n        var word = i\n            if (i.length > 4) word = i.reversed()\n        outStr += word + \" \"\n        }\n   return outStr.dropLast(1) \n}","lang_id":29,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5265326f5fda8eb1160004c8":[{"id":205517,"user_id":null,"body":"fun number_to_string(num: Int) = num.toString()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205518,"user_id":null,"body":"fun number_to_string(num: Int) = \"$num\"","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205519,"user_id":null,"body":"fun number_to_string(num: Int): String {\n  return num?.toString()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205520,"user_id":1169,"body":"var number_to_string = Int::toString","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205521,"user_id":null,"body":"var number_to_string = {it:Int -> it.toString()}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205522,"user_id":null,"body":"fun number_to_string(num: Int): String = num.toString()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205523,"user_id":null,"body":"    fun number_to_string(num: Int): String{\n        val listOfString : MutableList<Char> = mutableListOf()\n        for (i in num.toString()){\n            listOfString.add(i)\n        }\n        var output: String = \"\"\n        for (i in listOfString){\n            output = output + i\n        }\n        return output\n\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205524,"user_id":null,"body":"fun number_to_string(num: Int) = \"\"+num","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205525,"user_id":null,"body":"import kotlin.math.abs\n\nfun number_to_string(input: Int): String {\n    var result = \"\"\n    var number = abs(input)\n    while(number > 0) {\n        val digit = number % 10\n        number = number \/ 10\n        val digitChar = '0' + digit\n        result = digitChar + result\n    }\n    return if(result.isEmpty()) {\n        \"0\"\n    } else {\n        if (input < 0) {\n            result = \"-\" + result\n        }\n        result\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205526,"user_id":null,"body":"fun number_to_string(num: Int): String {\n  return \"${num}\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"526c7363236867513f0005ca":[{"id":205527,"user_id":null,"body":"fun isLeapYear(year: Int) = java.time.Year.of(year).isLeap","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205528,"user_id":null,"body":"fun isLeapYear(year: Int) = year % 400 == 0 || (year % 4 == 0 && year % 100 != 0)\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205529,"user_id":null,"body":"fun isLeapYear(year: Int) : Boolean {\n     return when {\n        year % 400 == 0 -> true\n        year % 100 == 0 -> false\n        else -> year % 4 == 0\n    } \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205530,"user_id":null,"body":"fun isLeapYear(year: Int): Boolean {\n    when {\n        year % 400 == 0 -> return true\n        year % 100 == 0 -> return false\n        else -> return year % 4 == 0\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205531,"user_id":null,"body":"fun isLeapYear(year: Int) = (year % 4 == 0 && year % 100 != 0) || (year % 100 == 0 && year % 400 == 0)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205532,"user_id":null,"body":"fun isLeapYear(year: Int) : Boolean {\n  \n  if (year%4==0 && year%100!=0) return true\n  else if (year%100==0 && year%400==0) return true\n  else return false\n  \n  \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205533,"user_id":null,"body":"fun isLeapYear(year: Int) : Boolean {\n  if (year % 100 == 0) {\n    if (year % 400 == 0) {\n      return true\n    } else {\n      return false\n    }\n  } else if (year % 4 == 0) {\n    return true\n  } else {\n    return false\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205534,"user_id":null,"body":"fun isLeapYear(year: Int) = if (year % 100 == 0) year % 400 == 0 else year % 4 == 0","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205535,"user_id":527,"body":"fun isLeapYear(year: Int): Boolean {\n    return year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205536,"user_id":null,"body":"fun isLeapYear(year: Int) : Boolean {\n  \n        return when(year % 400){\n            (0)-> true\n            else->{if((year%4) == 0 && (year % 100) != 0) true else false}\n        }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"52742f58faf5485cae000b9a":[{"id":205537,"user_id":null,"body":"fun format_duration(sec: Int): String {\n        if (sec == 0) return \"now\"\n        val seconds = sec % 60\n        val minutes = sec % 3600 \/ 60\n        val hours = sec % 86400 \/ 3600\n        val days = sec % 31536000 \/ 86400\n        val years = sec \/ 31536000\n    \n        val list = listOf(years, days, hours, minutes, seconds)\n            .zip(listOf(\"years\", \"days\", \"hours\", \"minutes\", \"seconds\"))\n            .filter { it.first > 0 }\n            .map { \"${it.first} ${if (it.first == 1) it.second.dropLast(1) else it.second}\" }\n    \n        return list\n            .chunked(if (list.size == 1) list.size else list.lastIndex)\n            .joinToString(\" and \") { it.joinToString() }\n    }\n","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205538,"user_id":571,"body":"object TimeFormatter {\n    fun f(s: String, time: Int) = if(time==0) \"\" else time.toString()+\" \"+s+(if(time==1)\"\" else \"s\")\n    fun format_duration(s:Int)=if(s==0) \"now\" else listOf(\n        f(\"year\",s\/31536000),\n        f(\"day\", (s\/86400)%365),\n        f(\"hour\",(s\/3600)%24),\n        f(\"minute\", (s\/60)%60),\n        f(\"second\", (s%3600)%60)).filter { e-> e.isNotBlank() }.joinToString(\", \").replace(Regex(\", (?!.+,)\"), \" and \")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205539,"user_id":null,"body":"object TimeFormatter {\n\n    fun format_duration(seconds: Int): String {\n    if (seconds == 0) return \"now\"\n    var rem = seconds\n    return buildString {\n        val units = mapOf(\"year\" to 31_536_000, \"day\" to 86400, \"hour\" to 3600, \"minute\" to 60)\n        units.forEach { (key, value) ->\n            val sum = rem \/ value\n            rem -= value * sum\n            when {\n                sum == 1 -> append(\"$sum $key, \")\n                sum > 1 -> append(\"$sum ${key}s, \")\n            }\n        }\n        when {\n            rem == 1 -> append(\"$rem second\")\n            rem > 1 -> append(\"$rem seconds\")\n        }\n    }.removeSuffix(\", \").reversed().replaceFirst(\",\", \"dna \").reversed()\n}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205540,"user_id":null,"body":"private const val MINUTE = 60\nprivate const val HOUR = MINUTE * 60\nprivate const val DAY = HOUR * 24\nprivate const val YEAR = DAY * 365\n\nobject TimeFormatter {\n\n    fun format_duration(input: Int): String {\n\n        if (input == 0) return \"now\"\n\n        val years   = input \/ YEAR\n        val days    = input % YEAR \/ DAY\n        val hours   = input % YEAR % DAY \/ HOUR\n        val minutes = input % YEAR % DAY % HOUR \/ MINUTE\n        val seconds = input % YEAR % DAY % HOUR % MINUTE\n\n        return format(years,  \"year\",   remainder(days, hours, minutes, seconds)) +\n               format(days,   \"day\",    remainder(hours, minutes, seconds)) +\n               format(hours,  \"hour\",   remainder(minutes, seconds)) +\n               format(minutes,\"minute\", remainder(seconds)) +\n               format(seconds,\"second\", 0)\n    }\n\n    private fun format(value: Int, str: String, remainder: Int): String {\n        return when (value) {\n            0 -> \"\"\n            else -> \"$value $str\" +\n                    (if (value > 1) \"s\" else \"\") +\n                    when (remainder) {\n                        0 -> \"\"\n                        1 -> \" and \"\n                        else -> \", \"\n                    }\n        }\n    }\n\n    private fun remainder(vararg args: Int) = args.count { it > 0 }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205541,"user_id":null,"body":"object TimeFormatter {\n\n    fun format_duration(seconds: Int): String {\n        if(seconds==0) return \"now\"\n        val periods = mapOf(\"year\" to 31536000, \"day\" to 86400, \"hour\" to 3600, \"minute\" to 60, \"second\" to 1)\n        var sec = seconds\n        val ret = mutableListOf<String>()\n        \n        periods.forEach {k,v->\n            if(sec>=v) {\n                val qty = sec\/v\n                val ending = if(qty>1) \"s\" else \"\"\n                ret.add(\"$qty $k$ending\")\n                sec %= v\n            }\n        }\n        if(ret.size<=1) return ret.joinToString(\"\")\n        return ret.dropLast(1).joinToString(\", \")+\" and \"+ret.last()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205542,"user_id":null,"body":"object TimeFormatter {\n\n    private val units = listOf(Pair(\"second\", 60), Pair(\"minute\", 60),\n          Pair(\"hour\", 24), Pair(\"day\", 365), Pair(\"year\", 1000000))\n\n    fun format_duration(seconds :Int) :String {\n        if (seconds<=0)\n          return \"now\"\n        val parts = mutableListOf<String>()\n        var remainder = seconds\n        for (unit in units) {\n            val amount = remainder % unit.second\n            if (amount>0)\n              if (amount>1)\n                parts.add(\"$amount ${unit.first}s\")\n              else\n                parts.add(\"1 ${unit.first}\")\n            remainder \/= unit.second\n        }\n        if (parts.size==1)\n          return parts.first()\n        val smallest = parts.removeAt(0)\n        val end = parts.removeAt(0)+\" and \"+smallest\n        parts.add(0, end)\n        return parts.reversed().joinToString(\", \")\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205543,"user_id":null,"body":"object TimeFormatter {\n    fun format_duration(seconds: Int): String {\n        val second = seconds % 60\n        var minute = seconds \/ 60\n        var hour = minute \/ 60\n        minute %= 60\n        var day = hour \/ 24\n        hour %= 24\n        val year = day \/ 365\n        day %= 365\n        val timeText = arrayOf(year to \"year\", day to \"day\", hour to \"hour\",\n            minute to \"minute\", second to \"second\"\n        )\n        val result = arrayListOf<String>()\n\n        timeText.forEach { (time, text) ->\n            if (time != 0) result.add(\"$time $text${if (time > 1) \"s\" else \"\"}\") }\n        if (result.size > 1){\n            result[result.size - 2] += \" and ${result[result.size - 1]}\"\n            result.remove(result[result.size - 1])\n        }\n\n        return if (result.isNotEmpty()) result.joinToString(separator = \", \") else \"now\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205544,"user_id":null,"body":"object TimeFormatter {\n\n    private const val secondsInYear = 365 * 24 * 60 * 60\n    private const val secondsInDay = 24 * 60 * 60\n    private const val secondsInHour = 60 * 60\n    private const val secondsInMinute = 60\n\n    fun format_duration(seconds: Int): String {\n        var durationRepresentation = \"\"\n\n        if (seconds > 0) {\n            val stringBuilder = StringBuilder()\n            var tempSeconds = seconds\n\n            while (tempSeconds > 0) {\n                when {\n                    tempSeconds >= secondsInYear -> {\n                        val yearCount = tempSeconds \/ secondsInYear\n                        stringBuilder.append(yearCount)\n                        stringBuilder.append(if (yearCount > 1) \" years, \" else \" year, \")\n\n                        tempSeconds %= (yearCount * secondsInYear)\n                    }\n\n                    tempSeconds >= secondsInDay -> {\n                        val daysCount = tempSeconds \/ secondsInDay\n                        stringBuilder.append(daysCount)\n                        stringBuilder.append(if (daysCount > 1) \" days, \" else \" day, \")\n\n                        tempSeconds %= (daysCount * secondsInDay)\n                    }\n\n                    tempSeconds >= secondsInHour -> {\n                        val hoursCount = tempSeconds \/ secondsInHour\n                        stringBuilder.append(hoursCount)\n                        stringBuilder.append(if (hoursCount > 1) \" hours, \" else \" hour, \")\n\n                        tempSeconds %= (hoursCount * secondsInHour)\n                    }\n\n                    tempSeconds >= secondsInMinute -> {\n                        val minutesCount = tempSeconds \/ secondsInMinute\n                        stringBuilder.append(minutesCount)\n                        stringBuilder.append(if (minutesCount > 1) \" minutes, \" else \" minute, \")\n\n                        tempSeconds %= (minutesCount * secondsInMinute)\n                    }\n\n                    else -> {\n                        stringBuilder.append(tempSeconds)\n                        stringBuilder.append(if (tempSeconds > 1) \" seconds, \" else \" second, \")\n\n                        tempSeconds = 0\n                    }\n                }\n            }\n\n            \/\/ remove the last 2 characters from the string\n            durationRepresentation = stringBuilder.removeSuffix(\", \").toString().trim()\n\n            \/\/ let's replace the last \", \" to \" and \"\n            val lastCommaIndex = durationRepresentation.lastIndexOf(\", \")\n\n            if (lastCommaIndex != -1) {\n                val tempDurationRepresentation = durationRepresentation\n\n                durationRepresentation = tempDurationRepresentation.substring(0, lastCommaIndex)\n                durationRepresentation += \" and \"\n                durationRepresentation += tempDurationRepresentation.substring(lastCommaIndex + 2)\n            }\n        } else {\n            durationRepresentation = \"now\"\n        }\n\n        return durationRepresentation\n    }\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205545,"user_id":null,"body":"object TimeFormatter {\n\n    private val units = listOf(\n        60 * 60 * 24 * 365 to \"year\",\n        60 * 60 * 24 to \"day\",\n        60 * 60 to \"hour\",\n        60 to \"minute\",\n        1 to \"second\"            \n    )\n\n    fun format_duration(seconds: Int): String {\n        var result = mutableListOf<Pair<Int, String>>()\n        var currentUnitIndex = 0\n        var currentSeconds = seconds\n        \n        while (currentUnitIndex < units.size && currentSeconds > 0) {\n            val currentUnit = units[currentUnitIndex]\n            val unitCount = currentSeconds \/ currentUnit.first\n            \n            if (unitCount > 0) {\n                result.add(unitCount to currentUnit.second)\n                currentSeconds %= currentUnit.first\n            }\n            \n            currentUnitIndex++\n        }\n        \n        return result.format()\n    }\n    \n    private fun List<Pair<Int, String>>.format(): String {\n        if (size == 0) return \"now\"\n        if (size == 1) return get(0).format()\n        \n        var result = \"\"\n        var currentUnitIndex = 0\n        \n        while (currentUnitIndex < size - 1) {\n            result += \"${get(currentUnitIndex).format()}\"\n            result += if (currentUnitIndex != size - 2) \", \" else \" \"\n                \n            currentUnitIndex++\n        }\n        \n        result += \"and ${get(size - 1).format()}\"\n        \n        return result\n    }\n    \n    private fun Pair<Int, String>.format(): String {\n        val ending = if (first == 1) \"\" else \"s\"\n        return \"$first $second$ending\"\n    }\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205546,"user_id":null,"body":"object TimeFormatter {\n\n    fun format_duration(seconds: Int): String {\n        val minuteUnit = 60\n        val hourUnit = 3600\n        val dayUnit = 86400\n        val yearUnit = 31536000\n        var result = \"\"\n\n        if (seconds == 0) {\n            return \"now\"\n        }\n\n        if (seconds >= yearUnit) {\n            result += if (seconds\/yearUnit > 1) \"\"+seconds\/yearUnit+\" years\" else \"1 year\"\n            if (seconds%yearUnit != 0) {\n                val y = seconds%yearUnit\n                if (y >= dayUnit) {\n                    if (y%dayUnit != 0) {\n                        result += if (y\/dayUnit > 1) \", \"+y\/dayUnit+\" days\" else \", 1 day\"\n                        val d = y%dayUnit\n                        if (d >= hourUnit) {\n                            if (d%hourUnit != 0) {\n                                result += if (d\/hourUnit > 1) \", \"+d\/hourUnit+\" hours\" else \", 1 hour\"\n                                val h = d%hourUnit\n                                if (h >= minuteUnit) {\n                                    if (h%minuteUnit != 0) {\n                                        result += if (h\/minuteUnit > 1) \", \"+h\/minuteUnit+\" minutes\" else \", 1 minute\"\n                                        val m = h%minuteUnit\n                                        result += if (m>1) \" and $m seconds\" else \" and 1 second\"\n                                    } else {\n                                        result += if (h\/minuteUnit > 1) \" and \"+h\/minuteUnit+\" minutes\" else \" and 1 minute\"\n                                    }\n                                } else {\n                                    result += if (h>1) \" and $h minutes\" else \" and 1 minute\"\n                                }\n                            } else {\n                                result += if (d\/hourUnit > 1) \" and \"+d\/hourUnit+\" hours\" else \" and 1 hour\"\n                            }\n                        } else {\n                            if (d >= minuteUnit) {\n                                if (d%minuteUnit != 0) {\n                                    result += if (d\/minuteUnit > 1) \", \"+d\/minuteUnit+\" minutes\" else \", 1 minute\"\n                                    val m = d%minuteUnit\n                                    result += if (m>1) \" and $m seconds\" else \" and 1 second\"\n                                } else {\n                                    result += if (d\/minuteUnit > 1) \" and \"+d\/minuteUnit+\" minutes\" else \" and 1 minute\"\n                                }\n                            } else {\n                                result += if (d>1) \" and $d minutes\" else \" and 1 minute\"\n                            }\n                        }\n                    } else {\n                        result += if (y\/dayUnit > 1) \" and \"+y\/dayUnit+\" days\" else \" and 1 day\"\n                    }\n                } else {\n                    if (y >= hourUnit) {\n                        if (y%hourUnit != 0) {\n                            result += if (y\/hourUnit > 1) \", \"+y\/hourUnit+\" hours\" else \", 1 hour\"\n                            val h = y%hourUnit\n                            if (h >= minuteUnit) {\n                                if (h%minuteUnit != 0) {\n                                    result += if (h\/minuteUnit > 1) \", \"+h\/minuteUnit+\" minutes\" else \", 1 minute\"\n                                    val m = h%minuteUnit\n                                    result += if (m>1) \" and $m seconds\" else \" and 1 second\"\n                                } else {\n                                    result += if (h\/minuteUnit > 1) \" and \"+h\/minuteUnit+\" minutes\" else \" and 1 minute\"\n                                }\n                            } else {\n                                result += if (h>1) \" and $h minutes\" else \" and 1 minute\"\n                            }\n                        } else {\n                            result += if (y\/hourUnit > 1) \" and \"+y\/hourUnit+\" hours\" else \" and 1 hour\"\n                        }\n                    } else {\n                        if (y >= minuteUnit) {\n                            if (y%minuteUnit != 0) {\n                                result += if (y\/minuteUnit > 1) \", \"+y\/minuteUnit+\" minutes\" else \", 1 minute\"\n                                val m = y%minuteUnit\n                                result += if (m>1) \" and $m seconds\" else \" and 1 second\"\n                            } else {\n                                result += if (y\/minuteUnit > 1) \" and \"+y\/minuteUnit+\" minutes\" else \" and 1 minute\"\n                            }\n                        } else {\n                            result += if (y>1) \" and $y minutes\" else \" and 1 minute\"\n                        }\n                    }\n                }\n            }\n        } else {\n            if (seconds >= dayUnit) {\n                if (seconds%dayUnit != 0) {\n                    result += if (seconds\/dayUnit > 1) \"\"+seconds\/dayUnit+\" days\" else \"1 day\"\n                    val d = seconds%dayUnit\n                    if (d >= hourUnit) {\n                        if (d%hourUnit != 0) {\n                            result += if (d\/hourUnit > 1) \", \"+d\/hourUnit+\" hours\" else \", 1 hour\"\n                            val h = d%hourUnit\n                            if (h >= minuteUnit) {\n                                if (h%minuteUnit != 0) {\n                                    result += if (h\/minuteUnit > 1) \", \"+h\/minuteUnit+\" minutes\" else \", 1 minute\"\n                                    val m = h%minuteUnit\n                                    result += if (m>1) \" and $m seconds\" else \" and 1 second\"\n                                } else {\n                                    result += if (h\/minuteUnit > 1) \" and \"+h\/minuteUnit+\" minutes\" else \" and 1 minute\"\n                                }\n                            } else {\n                                result += if (h>1) \" and $h minutes\" else \" and 1 minute\"\n                            }\n                        } else {\n                            result += if (d\/hourUnit > 1) \" and \"+d\/hourUnit+\" hours\" else \" and 1 hour\"\n                        }\n                    } else {\n                        if (d >= minuteUnit) {\n                            if (d%minuteUnit != 0) {\n                                result += if (d\/minuteUnit > 1) \", \"+d\/minuteUnit+\" minutes\" else \", 1 minute\"\n                                val m = d%minuteUnit\n                                result += if (m>1) \" and $m seconds\" else \" and 1 second\"\n                            } else {\n                                result += if (d\/minuteUnit > 1) \" and \"+d\/minuteUnit+\" minutes\" else \" and 1 minute\"\n                            }\n                        } else {\n                            result += if (d>1) \" and $d minutes\" else \" and 1 minute\"\n                        }\n                    }\n                } else {\n                    result += if (seconds\/dayUnit > 1) \"\"+seconds\/dayUnit+\" days\" else \"1 day\"\n                }\n            } else {\n                if (seconds >= hourUnit) {\n                    if (seconds%hourUnit != 0) {\n                        result += if (seconds\/hourUnit > 1) \"\"+seconds\/hourUnit+\" hours\" else \"1 hour\"\n                        val h = seconds%hourUnit\n                        if (h >= minuteUnit) {\n                            if (h%minuteUnit != 0) {\n                                result += if (h\/minuteUnit > 1) \", \"+h\/minuteUnit+\" minutes\" else \", 1 minute\"\n                                val m = h%minuteUnit\n                                result += if (m>1) \" and $m seconds\" else \" and 1 second\"\n                            } else {\n                                result += if (h\/minuteUnit > 1) \" and \"+h\/minuteUnit+\" minutes\" else \" and 1 minute\"\n                            }\n                        } else {\n                            result += if (h>1) \" and $h minutes\" else \" and 1 minute\"\n                        }\n                    } else {\n                        result += if (seconds\/hourUnit > 1) \"\"+seconds\/hourUnit+\" hours\" else \"1 hour\"\n                    }\n                } else {\n                    if (seconds >= minuteUnit) {\n                        if (seconds%minuteUnit != 0) {\n                            result += if (seconds\/minuteUnit > 1) \"\"+seconds\/minuteUnit+\" minutes\" else \"1 minute\"\n                            val m = seconds%minuteUnit\n                            result += if (m>1) \" and $m seconds\" else \" and 1 second\"\n                        } else {\n                            result += if (seconds\/minuteUnit > 1) \"\"+seconds\/minuteUnit+\" minutes\" else \"1 minute\"\n                        }\n                    } else {\n                        result += if (seconds>1) \"$seconds seconds\" else \"1 second\"\n                    }\n                }\n            }\n        }\n\n        return result\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5282b48bb70058e4c4000fa7":[{"id":205547,"user_id":null,"body":"fun hexStringToRGB(hexString: String): RGB {\n  val (red, green, blue) = hexString.drop(1).chunked(2).map { it.toInt(16) }\n  return RGB(red, green, blue)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205548,"user_id":null,"body":"fun hexStringToRGB(hexString: String) = hexString.drop(1).chunked(2) { \"$it\".toInt(16) }.let { RGB(it[0], it[1], it[2]) }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205549,"user_id":null,"body":"fun hexStringToRGB(hexString: String): RGB = RGB(\n    Integer.valueOf(hexString.substring(1, 3), 16),\n    Integer.valueOf(hexString.substring(3, 5), 16),\n    Integer.valueOf(hexString.substring(5, 7), 16)\n)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205550,"user_id":null,"body":"fun hexStringToRGB(hexString: String): RGB = (::RGB).call(*hexString.drop(1).chunked(2){ it.toString().toInt(16) }.toTypedArray())","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205551,"user_id":null,"body":"fun hexStringToRGB(hexString: String): RGB {\n  val r = hexString.substring(1,3).toInt(16)\n  val g = hexString.substring(3,5).toInt(16)\n  val b = hexString.substring(5,7).toInt(16)\n  return RGB(r, g, b)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205552,"user_id":null,"body":"import java.awt.Color\n\nfun hexStringToRGB(hexString: String): RGB = Color.decode(hexString).let { RGB(it.red, it.green, it.blue) }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205553,"user_id":null,"body":"\/\/ you have preloaded \n\/\/ data class RGB(val r: Int, val g: Int, val b: Int)\nfun hexStringToRGB(hexString: String): RGB? {\n    val hexColor = Integer.parseInt(hexString.substring(1), 16)\n    val r = (hexColor and 0xFF0000) shr 16\n    val g = (hexColor and 0xFF00) shr 8\n    val b = (hexColor and 0xFF)\n    return RGB(r, g, b);\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205554,"user_id":null,"body":"\/\/ you have preloaded \n\/\/ data class RGB(val r: Int, val g: Int, val b: Int)\nfun hexStringToRGB(hexString: String): RGB {\n    val r: Int = hexString.replace(\"#\",\"\").substring(0, 2).toInt(16) \n    val g: Int = hexString.replace(\"#\",\"\").substring(2, 4).toInt(16)\n    val b: Int = hexString.replace(\"#\",\"\").substring(4, 6).toInt(16) \n    return RGB(r, g, b)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205555,"user_id":null,"body":"\/\/ you have preloaded \n\/\/ data class RGB(val r: Int, val g: Int, val b: Int)\nfun hexStringToRGB(hexString: String): RGB {\n    val hexR = hexString.substring(1, 3)\n    val hexG = hexString.substring(3, 5)\n    val hexB = hexString.substring(5, 7)\n\n    val r = hexR.toInt(16)\n    val g = hexG.toInt(16)\n    val b = hexB.toInt(16)\n\n    return RGB(r, g, b)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205556,"user_id":null,"body":"import java.awt.Color\n\nfun hexStringToRGB(hexString: String): RGB {\n\tval color = Color.decode(hexString)\n\treturn RGB(color.getRed(), color.getGreen(), color.getBlue())\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"52a89c2ea8ddc5547a000863":[{"id":205557,"user_id":null,"body":"import java.util.*\n\nfun loopSize(n: Node): Int {\n  \/\/ floyd's\n  var tortoise = n.next\n  var hare = n.next?.next\n  \n  while (hare != tortoise) {\n    tortoise = tortoise?.next\n    hare = hare?.next?.next\n  }\n  \n  var lamda = 1\n  hare = tortoise?.next\n  while (tortoise != hare) {\n    hare = hare?.next\n    lamda = lamda + 1\n  }\n  \n\treturn lamda\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205558,"user_id":null,"body":"import java.util.*\n\nfun loopSize(n: Node): Int {\n    var node = n\n    val nodes = HashMap<Node, Int>()\n    var count = 0\n    while (!nodes.contains(node)) {\n        nodes.put(node, count)\n        count = count + 1\n        node = node.next as Node\n    }\n\treturn count - (nodes.get(node) ?: 0) \/\/ do it!\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205559,"user_id":null,"body":"import java.util.*\nimport java.io.*\n\nfun loopSize(node: Node?) = with(LinkedHashSet<Node?>()) {\n    var n = node\n    while (add(n)) n = n?.next\n    size - takeWhile { it != n }.count()\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205560,"user_id":null,"body":"import java.util.*\n\nfun loopSize(n: Node): Int {\n\tval walkingList = mutableListOf<Node>()\n    var curNode = n\n    while(!walkingList.contains(curNode)) {\n        walkingList.add(curNode)\n        curNode = curNode.next!!\n    }\n    \n    return walkingList.size - walkingList.indexOf(curNode)\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205561,"user_id":932,"body":"import java.util.*\n\nfun loopSize(n: Node?): Int {\n\tval list = ArrayList<Node?>()\n    var n = n\n    while(!list.contains(n)){\n        list.add(n)\n        n = n?.next\n    }\n    return list.size-list.indexOf(n)\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205562,"user_id":null,"body":"import java.util.*\n\n\nfun loopSize(node: Node): Int {\n    val startOfLoop = findStartOfLoop(node)\n    var sizeOfLoop = 1\n    var current = startOfLoop\n\n    while (current != null && startOfLoop != current.next) {\n        current = current.next\n        sizeOfLoop++\n    }\n\n    return sizeOfLoop\n}\n\nfun findStartOfLoop(node: Node): Node? {\n    val visited = mutableSetOf<Node>(node)\n    var current = node.next\n\n    while (current != null && !visited.contains(current)) {\n        visited.add(current)\n        current = current.next\n    }\n    return current\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205563,"user_id":null,"body":"import java.util.*\n\nfun loopSize(n: Node): Int {\n    var slow = n\n    var fast = n.next!!\n    var firstCollision = true\n    var count = 0\n    while(true){\n        slow = slow.next!!\n        fast = fast.next!!.next!!\n        if(!firstCollision){\n            count ++\n        }\n        if( slow == fast){\n            if(!firstCollision) break\n            firstCollision = false\n        }\n    }\n    \n\treturn count   \/\/ do it!\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205564,"user_id":null,"body":"tailrec fun loopSize(n: Node?, i: Int = 0, m: MutableMap<Node?, Int> = hashMapOf()): Int =\n    if (!m.contains(n)) { m[n] = i; loopSize(n?.next, i + 1, m) } else i - (m[n] ?: 0)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205565,"user_id":null,"body":"fun loopSize(n: Node): Int {\n    val visited = mutableSetOf<Node>()\n    var current = n\n    \n    while(true) {\n        visited += current\n        current = current.next ?: error(\"End node without 'next' destination reached\")\n        \n        if (current in visited) {\n            \/\/ We already visited current, which means it's the starting point of the loop.\n            return visited.size - visited.indexOf(current)\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205566,"user_id":null,"body":"import java.util.*\n\nfun loopSize(n: Node): Int {\n    var list = listOf(n)\n    var temp = n.next!!\n    while(true){        \n        if(list.contains(temp))\n            return list.size - list.indexOf(temp)\n        list = list.plus(temp)\n        temp = temp.next!!\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"52c31f8e6605bcc646000082":[{"id":205567,"user_id":null,"body":"package kata\n\nobject two_sum {\n\tfun two_sum(numbers: IntArray, target: Int): Pair<Int,Int> {\n        for(x in numbers.indices) {\n            for (y in x + 1 until numbers.size) {\n                val number1 = numbers[x]\n                val number2 = numbers[y]\n                if (number1 + number2 == target) {\n                    return Pair(x, y)\n                }\n            }\n        }\n        throw Exception()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205568,"user_id":null,"body":"package kata\n\nobject two_sum {\n\tfun two_sum(numbers: IntArray, target: Int): Pair<Int,Int> {\n\t\tvar result = Pair(0, 0);\n        val long = numbers.size-1;\n        \n        for (i in 0..long) {\n            var min = i + 1;\n            for (j in min..long) {\n                if (numbers[i] + numbers[j] == target) {\n                    result = Pair(i, j);\n                }\n            }\n        }\n        return result;\n\t}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205569,"user_id":null,"body":"package kata\n\nobject two_sum {\n\tfun two_sum(numbers: IntArray, target: Int): Pair<Int,Int> {\n        return numbers.mapIndexed { index, value ->\n    \t        Pair(index, numbers.indexOf(target - value))\n            }.filter {\n                it.first != it.second && it.second >= 0\n            }.first()\n\t}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205570,"user_id":null,"body":"package kata\n\nobject two_sum {\n\tfun two_sum(numbers: IntArray, target: Int): Pair<Int,Int> {\n\t\tval hashSet = mutableSetOf<Int>()\n        for((index, number) in numbers.withIndex()){\n            val remaining = target - number\n            if(hashSet.contains(remaining)) {\n                return numbers.indexOf(remaining) to index\n            }\n            hashSet.add(number)\n        }\n        return 0 to 0\n\t}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205571,"user_id":null,"body":"package kata\n\nobject two_sum {\n\tfun two_sum(nums: IntArray, target: Int): Pair<Int,Int> {\n\t\tfor(i in 0 .. nums.size-1){\n            for(j in (i+1) .. nums.size-1){\n                if(nums[i]+nums[j]==target){\n                    return Pair(i,j)\n                }\n            }\n        }\n    return Pair(0,0)\n\t}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205572,"user_id":null,"body":"package kata\n\nobject two_sum {\n    fun two_sum(numbers: IntArray, target: Int): Pair<Int,Int> {\n        for (i in 0 until numbers.size){\n            for (j in i+1..numbers.size-1){\n                if (numbers[i]+numbers[j]==target){\n                    return Pair(i,j)\n                }\n            }\n        }\n        return Pair(0,0)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205573,"user_id":null,"body":"package kata\n\nobject two_sum {\n\tfun two_sum(numbers: IntArray, target: Int): Pair<Int,Int> {\n    var index1 = 0\n    var index2 = 0\n\n    loop@for(i in numbers.indices) {\n        index1 = i\n        for (j in numbers.indices) {\n            if (i == j) continue\n\n            index2 = j\n            if (numbers[index1] + numbers[index2] == target) break@loop\n        }\n    }\n\n    return Pair(index1, index2)\n\t}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205574,"user_id":null,"body":"package kata\n\nobject two_sum {\n\tfun two_sum(numbers: IntArray, target: Int): Pair<Int,Int> {\n\t\tnumbers.forEachIndexed { i, f ->\n            numbers.forEachIndexed { j, s -> \n                if (f + s === target && i !== j) return Pair<Int, Int>(i, j)\n            }\n        }\n        throw AssertionError()\n\t}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205575,"user_id":null,"body":"object two_sum {\n    fun two_sum(numbers: IntArray, target: Int): Pair<Int, Int> {\n        val map = mutableMapOf<Int, Int>()\n\n        for (i in numbers.indices) {\n            val complement = target - numbers[i]\n\n            if (map.containsKey(complement)) {\n                return i to map[complement]!!\n            }\n            map[numbers[i]] = i\n        }\n        return 0 to 0\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205576,"user_id":null,"body":"package kata\n\nobject two_sum {\n\tfun two_sum(numbers: IntArray, target: Int): Pair<Int,Int> {\n        val hash : HashMap<Int, Int> = HashMap()\n        for ((index, value) in numbers.withIndex()) {\n           val compNumIndex = hash[target - value]\n           if (compNumIndex != null) {\n               return Pair(compNumIndex, index)\n           }\n\n           hash[value] = index\n        }\n        return Pair(0, 0)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"52e88b39ffb6ac53a400022e":[{"id":205577,"user_id":null,"body":"fun int32_to_ip(x: UInt) = (0..24 step 8).map { x shr it and 255u }.reversed().joinToString(\".\")","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-02 20:15:47"},{"id":205578,"user_id":null,"body":"@ExperimentalUnsignedTypes\nfun int32_to_ip(ip: UInt): String {\n    return ip.toString(radix = 2).padStart(32, '0').chunked(8).map { it.toInt(radix = 2) }.joinToString(\".\")\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-02 20:15:53"},{"id":205579,"user_id":null,"body":"fun int32_to_ip(ip: UInt) = \"\"\"${ip shr 24 and 0xFFu}.${ip shr 16 and 0xFFu}.${ip shr 8 and 0xFFu}.${ip and 0xFFu}\"\"\"","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-02 20:15:58"},{"id":205580,"user_id":null,"body":"fun int32_to_ip(ip: UInt): String =\n        to32Bits(ip)\n            .chunked(8)\n            .map(::toDecimal)\n            .joinToString(\".\")\n\nfun to32Bits(number: UInt)= toBinary(number).padStart(32, '0')\nfun toBinary(number: UInt) = number.toString(radix = 2)\nfun toDecimal(bits: String) = bits.toInt(radix = 2)\n","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-02 20:16:03"},{"id":205581,"user_id":null,"body":"fun int32_to_ip(ip: UInt) =\n    List(4) { index -> (ip shr (index * 8)).toUByte() }\n        .reversed()\n        .joinToString(\".\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-02 20:13:01"},{"id":205582,"user_id":null,"body":"fun int32_to_ip(ip: UInt): String {\n    return buildString {\n        append((ip and 0xFF000000u) shr 24)\n        append('.')\n        append((ip and 0x00FF0000u) shr 16)\n        append('.')\n        append((ip and 0x0000FF00u) shr 8)\n        append('.')\n        append(ip and 0xFFu)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-02 20:13:01"},{"id":205583,"user_id":null,"body":"fun int32_to_ip(ip: UInt): String {\n    if(ip!=0u){\n    var binary = java.lang.Long.toBinaryString(ip.toLong())\n    while(binary.length<32){\n        binary = \"0\"+binary \n    }\n    return String.format(\n                \"%s.%s.%s.%s\",\n                binary.substring(0, 8).toLong(2),\n                binary.substring(8, 16).toLong(2),\n                binary.substring(16, 24).toLong(2),\n                binary.substring(24).toLong(2)\n            )\n    }else{\n        return \"0.0.0.0\"\n    }\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-02 20:13:01"},{"id":205584,"user_id":null,"body":"fun int32_to_ip(ip: UInt): String {\n    val mask: UInt = 0xFF.toUInt()\n    val p1 = (ip shr 24) and mask\n    val p2 = (ip shr 16) and mask\n    val p3 = (ip shr 8) and mask\n    val p4 = (ip shr 0) and mask\n    return \"$p1.$p2.$p3.$p4\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-02 20:13:01"},{"id":205585,"user_id":null,"body":"fun int32_to_ip(ip: UInt): String {\n    val firstOctet = (ip shr 24) and 0xFFu\n    val secondOctet = (ip shr 16) and 0xFFu\n    val thirdOctet = (ip shr 8) and 0xFFu\n    val fourthOctet = ip and 0xFFu\n    return \"${firstOctet}.${secondOctet}.${thirdOctet}.${fourthOctet}\"\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-02 20:13:01"},{"id":205586,"user_id":null,"body":"fun int32_to_ip(ip: UInt) = ip.toString(2).padStart(32, '0').chunked(8).map { it.toInt(2) }.joinToString(\".\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-02 20:13:01"}],"52f677797c461daaf7000740":[{"id":205587,"user_id":null,"body":"private tailrec fun gcd(x: Long, y: Long): Long = if (y == 0L) x else gcd(y, x % y)\nfun solution(numbers: LongArray)  = numbers.fold(0L, ::gcd) * numbers.size\n","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205588,"user_id":null,"body":"private tailrec fun gcd(a:Long, b:Long):Long = if (a%b == 0L) b else gcd(b, a%b)\nfun solution(numbers: LongArray): Long {\n    return numbers.size * numbers.reduce(::gcd)\n}\n\n","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205589,"user_id":null,"body":"fun solution(numbers: LongArray): Long {\n    if (numbers.size == 1) return numbers.first()\n    val arr = numbers.distinct()\n    var result = arr.first()\n    for (i in 1 until arr.size) result = gcd(result, arr[i])\n    return result * numbers.size\n}\n\nfun gcd(first: Long, second: Long): Long {\n        var a = first\n        var b = second\n        while (b > 0) {\n            val temp = b\n            b = a % b\n            a = temp\n        }\n        return a\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205590,"user_id":null,"body":"fun nod(a: Long, b: Long): Long {\n    return if (b == 0L) a\n    else nod(b, a % b)\n}\n\nfun solution(numbers: LongArray): Long {\n    for (i in 0 until numbers.size - 1) {\n        numbers[i + 1] = nod(numbers[i], numbers[i + 1])\n    }\n    val sum = numbers.size * numbers[numbers.size - 1]\n    return sum\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205591,"user_id":null,"body":"fun solution(numbers: LongArray): Long {\n    var array = numbers.toSortedSet().toLongArray().reversedArray()\n    while (true){\n        if (array.size == 1){\n            return numbers.size * array.first()\n        }\n        array[0] = array[0] - array[1]\n        array = array.toSortedSet().toLongArray().reversedArray()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205592,"user_id":null,"body":"fun solution(numbers: LongArray): Long {\n\tval min = numbers.minOf { it }\n\n\tfor (i in 0..numbers.lastIndex) {\n\t\tif (numbers[i] % min == (0).toLong())\n\t\t\tnumbers[i] = min\n\t\telse {\n\t\t\tnumbers[i] %= min\n\t\t\treturn (solution(numbers))\n\t\t}\n\t}\n\treturn (numbers.sum())\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205593,"user_id":932,"body":"fun gcd(a: Long, b: Long):Long=if (b==0L) a else gcd(b, a % b)\nfun solution(data: LongArray)=data.reduce(::gcd)*data.size","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205594,"user_id":null,"body":"fun solution(n: LongArray): Long {\n    fun gcd(a: Long, b: Long): Long = if (b == 0L) a else gcd(b, a % b)\n    return n.toList().reduce { acc, l -> gcd(acc, l) } * n.count()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205595,"user_id":null,"body":"fun solution(numbers: LongArray): Long {    \n    var arr = numbers.sortedDescending().toMutableList()\n    var loop = true\n    while(loop){\n        arr.sortDescending()\n        loop = false\n        for (i in arr.indices){\n            if (arr[i]>arr.last()){\n                loop = true\n                arr[i] = if(arr[i]%arr.last() != 0L) arr[i] % arr.last() else arr.last()\n            }\n        }\n    }\n    return arr.sum()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205596,"user_id":null,"body":"import kotlin.math.*\n\nfun gcd(a: Long, b: Long): Long {\n    var x = max(a, b)\n    var y = min(a, b)\n    while (y > 0) {\n        val r = x % y\n        x = y\n        y = r\n    }\n    return x\n}\n\nfun solution(numbers: LongArray): Long {\n    return numbers.reduce { acc, it -> gcd(acc, it) } * numbers.size\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"52f831fa9d332c6591000511":[{"id":205597,"user_id":null,"body":"import java.util.*\n\nfun parse_molecule(formula: String): Map<String, Int> {\n    var str = formula\n    val regex = Regex(\"\"\"(\\(\\w+\\)|\\{\\w+\\}|\\[\\w+\\])(\\d*)\"\"\")\n    while (regex.find(str) != null) {\n        str = regex.replace(str, {it.groupValues[1].drop(1).dropLast(1).repeat(it.groupValues[2].toIntOrNull()?:1)})\n    }\n    if (str.any{it in \"(){}[]\"} || Regex(\"\"\"[^A-Z][a-z]+\"\"\").find(str) != null) throw IllegalArgumentException()\n    return Regex(\"\"\"([A-Z][a-z]*)(\\d*)\"\"\").findAll(str)\n        .groupBy(keySelector={it.groupValues[1]},valueTransform={it.groupValues[2].toIntOrNull()?:1})\n        .map{it.key to it.value.sum()}\n        .toMap()\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205598,"user_id":null,"body":"fun parse_molecule(formula: String): Map<String, Int> {\n    val result = mutableMapOf<String, Int>()\n    val numbers = mutableListOf(1)\n    var atom = \"\"; var digit = \"\"\n\n    if (\"\\\\{\\\\w*[\\\\]\\\\)]|\\\\(\\\\w*[\\\\]\\\\}]|\\\\[\\\\w*[\\\\}\\\\)]\".toRegex().containsMatchIn(formula) ||\n        formula.replace(\"\\\\w\".toRegex(), \"\").length % 2 != 0) throw IllegalArgumentException()\n\n    for (char in formula.reversed()) {\n        when {\n            char == ')' || char == ']' || char == '}' -> { numbers.add(digit.toIntOrNull() ?: 1); digit = \"\" }\n            char == '(' || char == '[' || char == '{' -> numbers.removeAt(numbers.lastIndex)\n            char.isDigit() -> digit = \"$char$digit\"\n            char.isLowerCase() -> atom = \"$char$atom\"\n            char.isUpperCase() -> {\n                atom = \"$char$atom\"\n                val count = numbers.reduce(Int::times) * (digit.toIntOrNull() ?: 1)\n                result[atom] = result[atom]?.let { it + count } ?: count\n                atom = \"\"; digit = \"\"\n            }\n        }\n    }\n    return result.takeIf { it.isNotEmpty() } ?: throw IllegalArgumentException()\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205599,"user_id":53,"body":"import java.util.ArrayDeque\n\nfun parse_molecule(formula: String): Map<String, Int> {\n    \n  var stack = ArrayDeque<MutableMap<String, Int>>()\n  var i = 0\n  val nil = '\\u0000'\n    \n  fun completed(): Boolean { return i >= formula.length } \n  fun peek(): Char { if (completed()) return nil else return formula[i] } \n  fun shift(): Char { if (completed()) return nil else return formula[i++] }\n  fun upper(c: Char): Boolean { return c >= 'A' && c <= 'Z' }\n  fun lower(c: Char): Boolean { return c >= 'a' && c <= 'z' }\n  fun digit(c: Char): Boolean { return c >= '0' && c <= '9' }\n  fun open(c: Char): Boolean { return c == '[' || c == '{' || c == '(' }\n  fun close(c: Char): Boolean { return c == ']' || c == '}' || c == ')' }\n  fun matchGroup(a: Char, b: Char): Boolean {  return a == '[' && b == ']' || a == '{' && b == '}' || a == '(' && b == ')' }\n  fun curr(): MutableMap<String, Int> { return stack.peekFirst() } \n  fun snap() { stack.addFirst(HashMap<String, Int>()) } \n  \n  fun restore(n: Int) {\n    val q = stack.pollFirst()\n    val p = curr()\n    for ((k, vq) in q) {\n      val v = p.getOrDefault(k, 0)\n      p.put(k, v + n * vq)\n    }\n  } \n  \n  fun number(): Int {\n    val sb = StringBuilder()\n    while (digit(peek())) sb.append(shift())\n    if (sb.length == 0) return 1\n    return sb.toString().toInt()\n  } \n  \n  fun atom(): String {\n    val sb = StringBuilder()\n    sb.append(shift())\n    while (lower(peek())) sb.append(shift())\n    val p = curr()\n    val s = sb.toString()\n    val v = p.getOrDefault(s, 0)\n    p.put(s, v + 1);\n    return s;\n  } \n  \n  fun molecule(group: Boolean) {\n    while (!completed() && (!close(peek()) || !group)) {\n      snap()\n      if (upper(peek())) {\n        atom()\n      } else if (open(peek())) {\n        var c = shift()\n        molecule(true)\n        if (!close(peek())) throw IllegalArgumentException(\"no group end\")\n        if (!matchGroup(c, peek())) throw IllegalArgumentException(\"group not matched\")\n        shift()\n      } else {\n        throw IllegalArgumentException(\"invalid token\")\n      }\n      restore(number())\n    }\n  } \n  \n  snap()\n  molecule(false)\n  \n  return stack.peekFirst()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205600,"user_id":490,"body":"import java.util.*\nimport java.util.regex.*\n\nprivate lateinit var tokenIter: Iterator<String>\nprivate lateinit var bracketStk: Stack<Int>\n\nprivate val AT_NUM = \"[A-Z][a-z]?\\\\d*\"\nprivate val OPEN_BRA = \"[{(\\\\[]\"\nprivate val CLOSE_BRA = \"[)}\\\\]]\\\\d*\"\nprivate val TOKENIZER = Pattern.compile(String.format(\"%s|%s|%s\", AT_NUM, OPEN_BRA, CLOSE_BRA))\nprivate val P_AT_NUM = Pattern.compile(\"(?<at>[A-Z][a-z]*)(?<num>\\\\d*)\")\n\nprivate val rawFormula: RawForm\n\tget() {\n\t\tval raw = RawForm()\n\n\t\twhile (tokenIter.hasNext()) {\n\t\t\tval tok = tokenIter.next()\n\n\t\t\tif (tok.matches(OPEN_BRA.toRegex())) {\n\t\t\t\tbracketStk.push(tok[0].toInt())\n\t\t\t\traw.concatWith(rawFormula)\n\n\t\t\t} else if (tok.matches(AT_NUM.toRegex())) {\n\t\t\t\tval m = P_AT_NUM.matcher(tok)\n\t\t\t\tm.find()\n\t\t\t\traw.addAtom(m.group(\"at\"), if (m.group(\"num\").isEmpty()) 1 else Integer.parseInt(m.group(\"num\")))\n\n\t\t\t} else if (tok.matches(CLOSE_BRA.toRegex())) {\n\t\t\t\tif (bracketStk.empty() || bracketStk.peek() + 1 != tok[0].toInt() && bracketStk.peek() + 2 != tok[0].toInt())\n\t\t\t\t\tthrow IllegalArgumentException(\"Invalid formula\")\n\t\t\t\tbracketStk.pop()\n\n\t\t\t\tif (tok.length > 1) raw.mulBy(Integer.parseInt(tok.substring(1)))\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\treturn raw\n\t}\n\nfun parse_molecule(formula: String): Map<String, Int> {\n\tval tokens = ArrayList<String>()\n\tval m = TOKENIZER.matcher(formula)\n\twhile (m.find()) tokens.add(m.group())\n\tif (tokens.joinToString(\"\") != formula) throw IllegalArgumentException(\"Invalid formula\")\n\tbracketStk = Stack()\n\ttokenIter = tokens.iterator()\n\n\tval ans = rawFormula\n\tif (!bracketStk.empty()) throw IllegalArgumentException(\"Invalid formula\")\n\n\treturn ans\n}\n\ninternal class RawForm : HashMap<String, Int>() {\n\tfun addAtom(atom: String, n: Int) {\n\t\tthis[atom] = n + getOrDefault(atom, 0)\n\t}\n\n\tfun mulBy(n: Int): RawForm {\n\t\tthis.forEach { at, v -> this[at] = v * n }\n\t\treturn this\n\t}\n\n\tfun concatWith(other: RawForm): RawForm {\n\t\tother.forEach { at, v -> this[at] = v + getOrDefault(at, 0) }\n\t\treturn this\n\t}\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205601,"user_id":null,"body":"import java.util.*\n\nval formulaComponentsRegex = Regex(\"[A-Z][a-z]\\\\d*|[A-Z]\\\\d*|\\\\(|\\\\[|\\\\{|\\\\)|\\\\]|\\\\}|\\\\d*\")\nval bracketOpeningRegex = Regex(\"[\\\\{\\\\(\\\\[]\")\nval bracketClosingRegex = Regex(\"[\\\\}\\\\)\\\\]]\")\nfun parse_molecule(formula: String): Map<String, Int> {\n    val formulaChars =\n        formulaComponentsRegex.findAll(formula).map { it.value }.filter { it.isNotEmpty() }.toList()\n        \n    if (formulaChars.isEmpty()){\n        throw IllegalArgumentException()\n    }\n    return openBrackets(formulaChars, 1)\n}\n\nfun openBrackets(formula: List<String>, multiplier: Int): MutableMap<String, Int> {\n    val result = mutableMapOf<String, Int>()\n\n    var index = 0\n    while (index < formula.size) {\n        val el = formula[index]\n\n        if (el.contains(bracketOpeningRegex)) {\n            val newScope = findBracketAndMultiplerPair(formula, index)\n            val newMap = openBrackets(\n                formula.subList(newScope.range.start, newScope.range.end),\n                newScope.multipler * multiplier\n            )\n            newMap.forEach { (k, v) -> result[k] = (result[k] ?: 0) + v }\n            index = newScope.endIndex\n        } else {\n            val pair = getPairFrom(el)\n            result[pair.first] = (result[pair.first] ?: 0).plus((pair.second * multiplier))\n        }\n\n        if (el.contains(bracketClosingRegex)) {\n            throw IllegalArgumentException()\n        }\n        index += 1\n    }\n\n    return result\n}\n\nfun getPairFrom(value: String): Pair<String, Int> {\n    var el = \"\"\n    var n = \"\"\n    value.toCharArray().forEach { char ->\n        if (char.isDigit()) {\n            n += char\n        } else {\n            el += char\n        }\n    }\n    if (n.isEmpty()) {\n        n = \"1\"\n    }\n    return Pair(el, n.toInt())\n}\n\nfun findBracketAndMultiplerPair(s: List<String>, startRange: Int): BracketsRangeWithMultipler {\n    var multipler = 1\n    val openingScopeElement = s[startRange]\n    val closingScopeElement = when (s.get(startRange)) {\n        \"(\" -> \")\"\n        \"[\" -> \"]\"\n        \"{\" -> \"}\"\n        else -> \"exception\"\n    }\n\n    var openCount = 0\n    var closedCount = 0\n\n    var indexClosingBracket = -1\n\n    val list = s.drop(startRange)\n    var index = 0\n    while (index < list.size) {\n        val el = list[index]\n\n        if (el == openingScopeElement) {\n            openCount += 1\n        }\n        if (el == closingScopeElement) {\n            closedCount += 1\n        }\n\n        if (openCount == closedCount) {\n            indexClosingBracket = index + startRange\n            break\n        }\n        index+=1\n    }\n\n    if (indexClosingBracket < 0) {\n        throw IllegalArgumentException()\n    }\n    var endEndex = indexClosingBracket\n\n    s.getOrNull(indexClosingBracket + 1).takeIf { it?.isDigitOnly() == true }?.let {\n        endEndex = indexClosingBracket + 1\n        multipler = it.toInt()\n    }\n\n    return BracketsRangeWithMultipler(\n        Range(startRange + 1, indexClosingBracket),\n        endEndex,\n        multipler\n    )\n}\n\n\nfun String.isDigitOnly(): Boolean {\n    return this.filter { it.isDigit() }.length == this.length && this.isNotEmpty()\n}\n\ndata class BracketsRangeWithMultipler(val range: Range, val endIndex: Int, val multipler: Int)\n\nclass Range(val start: Int, val end: Int)\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205602,"user_id":null,"body":"import java.util.*\n\nval elementRegex = \"[A-Z][a-z]*\".toRegex()\nval countRegex = \"[1-9][0-9]*\".toRegex()\nval matchingPars = mapOf('(' to ')', '[' to ']', '{' to '}')\n\nval IntRange.size get () = endInclusive - start + 1\nval MatchResult.size get () = value.length\n\nfun thr() {\n    throw IllegalArgumentException(\"Illegal input\")\n}\n\nfun String.findMatchingPar(start: Int): Int {\n    val left = this[start]\n    val right = matchingPars.getValue(left)\n    var counter = 1\n    var idx = start + 1\n    while (counter > 0 && idx < length) {\n        if (this[idx] == left) {\n            counter++\n        } else if (this[idx] == right) {\n            counter--\n        }\n        idx++\n    }\n    if (counter > 0) {\n        thr()\n    }\n    return idx\n}\n\nfun String.findCount(idx: Int): Pair<Int, Int> {\n    val match = countRegex.find(this, idx)\n    if (match != null && match.range.start == idx) {\n        return match.value.toInt() to match.range.size\n    } else {\n        return 1 to 0\n    }\n}\n\nfun Counts.parse(formula: String, multiplier: Int) {\n    var idx = 0\n    while (idx < formula.length) {\n        if (formula[idx] in matchingPars) {\n            val end = formula.findMatchingPar(idx)\n            val (count, consumedChars) = formula.findCount(end)\n            parse(formula.substring(idx + 1, end - 1), multiplier * count)\n            idx = end + consumedChars\n        } else {\n            val match = elementRegex.find(formula, idx)\n            if (match != null && match.range.start == idx) {\n                val element = match.value\n                val (count, consumedChars) = formula.findCount(idx + match.size)\n                add(element, count * multiplier)\n                idx += match.size + consumedChars\n            } else {\n                thr()\n            }\n        }\n    }\n}\n\nfun parse_molecule(formula: String): Map<String, Int> {\n    val result = Counts()\n    try {\n        result.parse(formula, 1)\n    } catch (e: Exception) {\n        print(\"Illegal input: $formula\")\n        throw e\n    }\n    return result\n}\n\nclass Counts : HashMap<String, Int>() {\n    fun add(element: String, count: Int) {\n        val current = getOrDefault(element, 0)\n        put(element, current + count)\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205603,"user_id":null,"body":"import java.util.*\n\nfun parse_molecule(formula: String): Map<String, Int> {\n    var tempMultiplier = 1\n    val multiplierStack = mutableListOf(1)\n    val regex = Regex(\"([A-Z][a-z]*|[\\\\[,({\\\\])}]|[1-9]+)\")\n    val tokens = regex.findAll(formula).map { it.value }.toList()\n    val resultMap = mutableMapOf<String, Int>()\n    \n    val bracesStack = mutableListOf<String>()\n    \n    if (tokens.isEmpty()) {\n        throw IllegalArgumentException(\"Invalid formula: $formula\")\n    }\n    \n    tokens.forEach { token ->\n        when (token) {\n            \"[\",\"(\",\"{\" -> bracesStack.add(token)\n            \n            \"]\" -> {\n                if (bracesStack.removeLastOrNull() != \"[\") {\n                    throw IllegalArgumentException(\"Invalid formula: $formula\")\n                }\n            }\n            \n            \")\" -> {\n                if (bracesStack.removeLastOrNull() != \"(\") {\n                    throw IllegalArgumentException(\"Invalid formula: $formula\")\n                }\n            }\n            \n            \"}\" -> {\n                if (bracesStack.removeLastOrNull() != \"{\") {\n                    throw IllegalArgumentException(\"Invalid formula: $formula\")\n                }\n            }\n        }\n    }\n    \n    if (bracesStack.isNotEmpty()) {\n        throw IllegalArgumentException(\"Invalid formula: $formula\")\n    }\n\n    tokens.reversed().forEach { token ->\n        val number = token.toIntOrNull()\n\n        if (number != null) {\n            tempMultiplier = number\n        } else if (token == \"]\" || token == \")\" || token == \"}\") {\n            multiplierStack.add(tempMultiplier * multiplierStack.last())\n            tempMultiplier = 1\n        } else if (token == \"[\" || token == \"(\" || token == \"{\") {\n            multiplierStack.removeLast()\n        } else {\n            resultMap[token] = (resultMap[token] ?: 0) + tempMultiplier * multiplierStack.last()\n            tempMultiplier = 1\n        }\n    }\n    \n    return resultMap\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205604,"user_id":null,"body":"import java.util.*\n\nval brackets = mapOf('[' to ']', '{' to '}', '(' to ')')\nenum class Token {Elem, Num, Nested, End}\n\nfun parse_molecule(formula: String): Map<String, Int> {\n    val res = mutableMapOf<String, Int>()\n    val lexer = mutableListOf<Pair<String, Token>>()\n\n    var elem: String? = null\n    var num: String? = null\n    var nested: String? = null\n    var nestedStart: Char? = null\n    var nestedEnd: Char? = null\n    var nestedSameLayers = 0\n\n    val finishNested: () -> Unit = {\n        if (nested != null) {\n            lexer.add(nested!! to Token.Nested)\n        }\n        nested = null\n    }\n\n    val finishElem: () -> Unit = {\n        if (elem != null) {\n            lexer.add(elem!! to Token.Elem)\n        }\n        elem = null\n    }\n\n    val finishNum: () -> Unit = {\n        if (num != null) {\n            lexer.add(num!! to Token.Num)\n        }\n        num = null\n    }\n\n    \/\/lexems\n    for (c in formula) {\n        if (nested != null) {\n            if (c == nestedEnd) {\n                if (nestedSameLayers == 0) {\n                    finishNested()\n                } else {\n                    nestedSameLayers -= 1\n                }\n            } else if (c == nestedStart) {\n                nestedSameLayers += 1\n            } else {\n                nested += c\n            }\n        }\n        else if (c in 'A'..'Z') {\n            finishElem()\n            finishNum()\n            elem = \"$c\"\n        }\n        else if (c in 'a'..'z') {\n            if (elem == null) throw IllegalArgumentException(formula)\n            elem += c\n        }\n        else if (c in '0'..'9') {\n            if (num != null) num += c else num = \"$c\"\n            finishElem()\n        }\n        else if (c in brackets.keys) {\n            finishElem()\n            finishNum()\n            nested = \"\"\n            nestedEnd = brackets[c]\n            nestedStart = c\n        }\n        else throw IllegalArgumentException(formula)\n    }\n    if (nested != null) { \/\/ this means there's no end bracket\n        throw IllegalArgumentException(formula)\n    }\n    \/\/last value save\n    finishElem()\n    finishNum()\n    finishNested()\n    lexer.add(\"END\" to Token.End)\n\n    \/\/result calc\n    var last: Pair<String, Token>? = null\n    for ((str, token) in lexer) {\n        if (last == null) {\n            last = str to token\n            continue\n        }\n        val multiply = if (token == Token.Num) str.toInt() else 1\n        when (last.second) {\n            Token.Elem -> {\n                res.merge(last.first, multiply, Int::plus)\n            }\n            Token.Nested -> {\n                val nestedValues = parse_molecule(last.first)\n                nestedValues.forEach { res.merge(it.key,it.value * multiply, Int::plus)}\n            }\n        }\n        last = str to token\n    }\n\n    return res\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205605,"user_id":null,"body":"import java.util.*\nvar separatorOpen = arrayOf('(','[','{')\nvar separatorClose = arrayOf(')',']','}')\n\nfun getRightSideIntAndRest(s:String):Pair<Int?,String> {\n    var acc:String = \"\"\n    var rest:String = \"\"\n    for(char in s) {\n        acc += char\n        if(!char.isDigit()) { \n            rest += acc\n            acc = \"\" \n        }\n    }\n    return acc.toIntOrNull() to rest\n}\n\nsealed class ProcState()\nclass StateNormal() : ProcState() { override fun toString():String { return \"StateNormal()\" } }\nclass StateBracket(var num:Int=0) : ProcState() { override fun toString():String { return \"StateBracket(${this.num})\" } }\nfun procElements(formula:String,multiplier:Int=1):String {\n    checkBracketsValid(formula)\n    var output:String = \"\"\n    var acc:String = \"\"\n    var terminate:Boolean = false\n    var terminates = fun(char:Char):Boolean {\n        return (!char.isDigit() && char.uppercase() == char.toString()) || char in separatorOpen\n    }\n    var state:ProcState = StateNormal()\n    for(cx in formula.indices) {\n        val c:Char = formula[cx]\n        acc += c\n        terminate = (cx+1)>=formula.length || terminates(formula[cx+1])\n        \n        when(c) {\n            in separatorOpen -> {\n                val curBracketNum = if(state is StateBracket){state.num+1} else {1}\n                state = StateBracket(curBracketNum)\n            }\n            in separatorClose -> {\n                state = if(state is StateBracket) { StateBracket(state.num-1) } else { state }\n            }\n        }\n        \n        val (elemNumber,elemString) = getRightSideIntAndRest(acc)\n        val finalNumber:Int = elemNumber?.let {it*multiplier} ?: multiplier\n        \/\/println (\"c: $c a: $acc t: $terminate s: $state o: $output M: $multiplier\") \n        if(terminate && !acc.isEmpty()) {\n            when(state) {\n                is StateNormal -> {\n                    \n                    if(!elemString.isEmpty()) {\n                        output += elemString + finalNumber.toString()\n                    }\n                    acc = \"\"\n                }\n                is StateBracket -> { \/\/ don't terminate if brackets not all closed\n                    if(state.num < 1 && !elemString.isEmpty()) {\n                        val bracketlessString = elemString.drop(1).dropLast(1)\n                        output += procElements(bracketlessString,finalNumber)\n                       \tstate = StateNormal()\n                    \tacc = \"\"\n                \t}\n                } \n            }\n        }\n    }\n    return output\n}\nfun separateElementsFromFlatString(s:String):List<Pair<Int,String>> {\n    var output:ArrayList<Pair<Int,String>> = ArrayList()\n    var acc:String = \"\"\n    var wasPreviousCharANumber = false\n    for(c in (s+\" \")) { \/\/ugly fix\n        if(wasPreviousCharANumber && !c.isDigit()) { \/\/split!\n            val (candidateInt,candidateString) = getRightSideIntAndRest(acc)\n            output.add( (candidateInt?:1) to candidateString )\n            acc = \"\"\n        }\n        wasPreviousCharANumber = c.isDigit()\n        acc += c\n    }\n    return output\n}\nfun List<Pair<Int,String>>.toElementMap():Map<String,Int> {\n    var output:HashMap<String,Int> = HashMap<String,Int>()\n    for(pair in this) {\n        var (i,s) = pair\n        i += output.get(s)?:0\n        output.put(s,i)\n    }\n    return output\n}\nfun checkBracketsValid(formula:String) { \/\/ Why did I only find out I had to throw an illegal argument exception AFTER making everything else\n    var bracketStack = ArrayList<Char>()\n    fun thrw(s:String=\"Brackets are not valid\") { throw IllegalArgumentException(s) }\n    for(c in formula) {\n        when(c) {\n        \tin separatorOpen -> {\n            \tbracketStack.add(c) \/\/ Opening a bracket is always legal\n        \t}\n            in separatorClose -> {\n                if(bracketStack.size < 1) { thrw(\"Can't close without opening\") }\n                var previousBracket = bracketStack.takeLast(1)[0]\n                val previousShouldBe = when(c) {\n                    ')' -> {'('}\n                    ']' -> {'['}\n                    '}' -> {'{'} \/\/ dirty and hard coded but oh well\n                    else -> throw IllegalStateException()\n                }\n                if(previousBracket != previousShouldBe) {thrw(\"Mismatched brackets\")}\n                bracketStack.removeAt(bracketStack.size-1)\n            }\n        }\n    }\n    if(bracketStack.size>0) {thrw(\"Excess brackets\")}\n}\nfun Map<String,Int>.lastMapCheck():Map<String,Int> {\n    for((k,_) in this) {\n        if(k.lowercase() == k || k.length > 2) {throw IllegalArgumentException(\"Weird element\")}\n    }\n    return this\n}\n\nfun parse_molecule(formula: String): Map<String, Int> {\n  return separateElementsFromFlatString(procElements(formula)).toElementMap().lastMapCheck()\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205606,"user_id":null,"body":"import java.util.*\n\nfun parse_molecule(formula: String): Map<String, Int> {\n    val stack = ArrayDeque(listOf(1))\n    val stackBracket = ArrayDeque<Char>()\n    val brackerMap = mapOf(')' to '(', ']' to '[', '}' to '{')\n    val res = mutableMapOf<String, Int>()\n    var i = formula.length - 1\n\n    while( i >= 0) {\n        var c = formula[i]\n        var key = c.toString()\n        var isPreviousDigit = false\n\n        if(c.isDigit()) {\n            var prev = \"\"\n            var c1 = c\n            do {\n                prev = c1.toString() + prev\n                i--\n                c1 = formula.getOrNull(i) ?: ' '\n            } while (i >= 0 && c1.isDigit())\n\n            stack.addLast(prev.toInt() * stack.last())\n            c = c1\n            key = c1.toString()\n            isPreviousDigit = true\n        }\n\n        if(c.isLowerCase()) {\n            var prev = \"\"\n            var c1 = c\n            do {\n                prev += c1\n                i--\n                c1 = formula.getOrNull(i) ?: ' '\n            } while (i >= 0 && c1.isLowerCase())\n            c = c1\n            key = c1.toString() + prev\n        }\n\n        if(isLetter(key)) {\n            val currentDigit = if(isPreviousDigit) stack.removeLast() else stack.last()\n            res.merge(key, currentDigit) {old , new -> old + new}\n        }\n        if(c in brackerMap.keys) {\n            stackBracket.addLast(brackerMap.getValue(c))\n        }\n        if(c == '(' || c == '{' || c == '[') {\n            if(c == stackBracket.lastOrNull()) {\n                stackBracket.removeLast()\n                if(stack.last() != 1) {\n                    stack.removeLast()\n                }\n            } else throw IllegalArgumentException(\"Formula is wrong\")\n        }\n\n        i--\n    }\n\n    if (stackBracket.isNotEmpty()) {\n        throw IllegalArgumentException(\"Formula is invalid\")\n    }\n    if (res.isEmpty()) {\n        throw IllegalArgumentException(\"Formula is wrong\")\n    }\n    return res\n}\n\nfun isLetter(s: String): Boolean {\n    for (c in s) {\n        if(c !in 'a'..'z' && c !in 'A'..'Z' ) {\n            return false\n        }\n    }\n    return true\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5300901726d12b80e8000498":[{"id":205607,"user_id":null,"body":"fun fizzbuzz(n: Int) = (1..n).map {\n    when{it % 15 == 0 -> \"FizzBuzz\"\n        it % 5 == 0 -> \"Buzz\"\n        it % 3 == 0 -> \"Fizz\"\n        else -> \"$it\"\n    }\n}.toTypedArray()","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205608,"user_id":null,"body":"fun fizzbuzz(n: Int): Array<String> {\n    return (1..n).toList().map(::getfizzbuzz).toTypedArray()\n}\n\nfun getfizzbuzz(n: Int): String {\n    return when {\n        n % 15 == 0 -> \"FizzBuzz\"\n        n % 3 == 0 -> \"Fizz\"\n        n % 5 == 0 -> \"Buzz\"\n        else -> n.toString()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205609,"user_id":null,"body":"fun fizzbuzz(n: Int) = (1..n).map {\n    when {\n        it % 3 == 0 && it % 5 == 0 -> \"FizzBuzz\"\n        it % 3 == 0 -> \"Fizz\"\n        it % 5 == 0 -> \"Buzz\"\n        else -> it\n    }\n}.map { \"$it\" }.toTypedArray()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205610,"user_id":null,"body":"fun fizzbuzz(n: Int): Array<String> {\n  return Array<String>(n, {i -> \n      when {\n          ((i + 1) % 3 == 0) && ((i + 1) % 5 == 0)  -> \"FizzBuzz\"\n          (i + 1) % 3 == 0 -> \"Fizz\"\n          (i + 1) % 5 == 0 -> \"Buzz\"\n          else -> (i+1).toString()\n      }\n  })\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205611,"user_id":null,"body":"const val FIZZ = \"Fizz\"\nconst val BUZZ = \"Buzz\"\n\nfun fizzbuzz(n: Int): Array<String> {\n    return Array(n) { i: Int ->\n        val result = StringBuilder()\n        val elementValue = i + 1\n        if (isDividedByThree(elementValue)) result.append(FIZZ)\n        if (isDividedByFive(elementValue)) result.append(BUZZ)\n        if (result.isEmpty()) result.append(elementValue)\n        result.toString()\n    }\n}\n\nfun isDividedByThree(value: Int) = value % 3 == 0\nfun isDividedByFive(value: Int) = value % 5 == 0","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205612,"user_id":null,"body":"fun fizzbuzz(n: Int): Array<String> =\n    (1..n).map { i ->\n        when {\n            i.mod(15) == 0 -> \"FizzBuzz\"\n            i.mod(5) == 0 -> \"Buzz\"\n            i.mod(3) == 0 -> \"Fizz\"\n            else -> i.toString()\n        }\n    }.toTypedArray()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205613,"user_id":null,"body":"fun fizzbuzz(n: Int): Array<String> {\n    var arr: Array<String> = arrayOf()\n    for(i in 1..n){\n        if (i%3 == 0 && i%5 == 0){\n            arr += \"FizzBuzz\"\n        } else if (i % 3 == 0){\n            arr += \"Fizz\"\n        } else if (i % 5 == 0){\n                arr += \"Buzz\"\n        } else {\n            arr += i.toString()\n        }\n    }\n    return arr\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205614,"user_id":null,"body":"fun fizzbuzz(n: Int): Array<String> {\n    return (1..n).map{\n    if(it.rem(3) == 0 && it.rem(5) == 0) \"FizzBuzz\" else if (it.rem(3) == 0) \"Fizz\" else if (it.rem(5) == 0) \"Buzz\" else it.toString() }.toTypedArray()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205615,"user_id":null,"body":"fun fizzbuzz(n: Int): Array<String> {\n    fun fb(n: Int): String = when { \n        n % 15 == 0 -> \"FizzBuzz\"\n        n % 5 == 0 -> \"Buzz\"\n        n % 3 == 0 -> \"Fizz\"\n        else -> n.toString()\n    }\n    return (1..n).map(::fb).toTypedArray()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205616,"user_id":null,"body":"fun fizzbuzz(n: Int): Array<String> {\n    val myArray = Array<String>(n+1) { i ->\n        if (i % 3 == 0 && i % 5 == 0) \"FizzBuzz\"\n        else if (i % 3 == 0) \"Fizz\"\n        else if(i % 5 == 0) \"Buzz\"\n        else i.toString()\n    }\n\n    return myArray.copyOfRange(1, myArray.size)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"534d2f5b5371ecf8d2000a08":[{"id":205617,"user_id":null,"body":"package kata\n\nobject KataSolution {\n    fun multiplicationTable(size: Int) = Array(size) { x -> IntArray(size) { y -> (x + 1) * (y + 1) } }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205618,"user_id":null,"body":"package kata\n\nobject KataSolution {\n    fun multiplicationTable(size: Int): Array<IntArray> {\n        return Array(size){i -> IntArray(size){(it + 1) * (i + 1)}}\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205619,"user_id":null,"body":"package kata\n\nobject KataSolution {\n    fun multiplicationTable(size: Int) = Array<IntArray>(size) {\n        i -> (1..size).map { it * (i + 1) }.toIntArray()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205620,"user_id":null,"body":"package kata\n\nobject KataSolution {\n    fun multiplicationTable(size: Int): Array<IntArray> =\n        (1..size)\n            .map { outer ->\n                (1..size).map {\n                    inner -> outer * inner\n                }.toIntArray()\n            }.toTypedArray()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205621,"user_id":null,"body":"package kata\n\nobject KataSolution {\n    fun multiplicationTable(size: Int): Array<IntArray> {\n        return Array(size) { multiplier ->\n            IntArray(size) { (it + 1) * (multiplier + 1) }\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205622,"user_id":null,"body":"package kata\n\nobject KataSolution {\n    fun multiplicationTable(size: Int): Array<IntArray> {\n        return Array(size) { row -> IntArray(size){(it+1)*(row+1)} } \n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205623,"user_id":null,"body":"package kata\n\nobject KataSolution {\n    fun multiplicationTable(size: Int): Array<IntArray> {\n        val list = Array(size) { IntArray(size) }\n\n        for (i in 1..size)\n            for (j in 1..size)\n                list[i - 1][j - 1] = i * j\n\n        return list\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205624,"user_id":null,"body":"package kata\n\nobject KataSolution {\n    fun multiplicationTable(size: Int): Array<IntArray> =\n        (1..size).map { (it .. it * size step it ).toList().toIntArray() }.toTypedArray()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205625,"user_id":932,"body":"package kata\n\nobject KataSolution {\n    fun multiplicationTable(size: Int)=Array(size){y->IntArray(size){x->(x+1)*(y+1)}}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205626,"user_id":null,"body":"package kata\n\nobject KataSolution {\n    fun multiplicationTable(size: Int): Array<IntArray> {\n        val list = Array<IntArray>(size) { _ -> IntArray(size)}\n        for (i in 1..size) {\n            for (j in 1..size)\n                list[i-1][j-1] = (i * j)\n        }\n        return list\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"53a1eac7e0afd3ad3300008b":[{"id":205627,"user_id":null,"body":"fun f(n : Int) : Int = if (n == 0) 1 else n - m(f(n - 1))\nfun m(n : Int) : Int = if (n == 0) 0 else n - f(m(n - 1))","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205628,"user_id":null,"body":"fun f(n: Int): Int = when {\n    n == 0 -> 1\n    else -> n - m(f(n - 1))\n}\n\nfun m(n: Int): Int = when {\n    n == 0 -> 0\n    else -> n - f(m(n - 1))\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205629,"user_id":null,"body":"fun f(n : Int) : Int {\n  if (n == 0) return 1\n  else return n - m(f(n - 1))\n}\n\nfun m(n : Int) : Int {\n  if (n == 0) return 0\n  else return n - f(m(n - 1))\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205630,"user_id":null,"body":"fun f(n : Int) : Int {\n  if (n==0) return 1\n  return n-m(f(n-1))\n}\n\nfun m(n : Int) : Int {\n  if (n==0) return 0\n  return n-f(m(n-1))\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205631,"user_id":null,"body":"\/\/ Where's the difficulty here???\n\nfun f(n : Int) : Int = if(n == 0) 1 else n - m(f(n-1))\n\nfun m(n : Int) : Int = if(n == 0) 0 else n - f(m(n-1))","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205632,"user_id":null,"body":"fun f(n : Int) : Int {\n  if ( n > 0) {\n  \treturn n -m(f(n-1)) }\n  else {\n      return 1\n  }\n}\n\nfun m(n : Int) : Int {\n    if ( n > 0) {\n  \treturn n - f(m(n-1)) }\n  else {\n      return 0\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205633,"user_id":null,"body":"fun f(n : Int) : Int {\n    if (n == 0)  return 1\n    return if (n < 0) 0\n    else {\n        n - m(f(n - 1))\n    }\n}\n\nfun m(n : Int) : Int {\n    if (n == 0)  return 0\n    return if (n < 0) 0\n    else {\n        n - f(m(n - 1))\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205634,"user_id":null,"body":"val ms = mutableListOf(0)\nval fs = mutableListOf(1)\n\nfun f(n: Int): Int {\n    return when {\n        fs.size > n -> fs[n]\n        else -> n - m(f(n - 1))\n    }\n}\n\nfun m(n: Int): Int {\n    return when {\n        ms.size > n -> ms[n]\n        else -> n - f(m(n - 1))\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205635,"user_id":null,"body":"    fun f(n: Int): Int {\n        return if (n > 0) (n - m(f(n - 1))) else 1\n    }\n\n    fun m(n: Int): Int {\n        return if (n > 0) n - f(m(n - 1)) else 0\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205636,"user_id":null,"body":"fun f(n : Int) : Int {\n    if (n <= 0) {\n        return 1\n    } else {\n        return n - (m(f(n-1)))\n    }\n}\n\nfun m(n : Int) : Int {\n    if (n <= 1) {\n        return 0\n    } else {\n        return n - (f(m(n-1)))\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"53da3dbb4a5168369a0000fe":[{"id":205637,"user_id":null,"body":"fun even_or_odd(number: Int) = if (number % 2 == 0) \"Even\" else \"Odd\"","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205638,"user_id":null,"body":"fun even_or_odd(number: Int) = when (number % 2) {\n    0 -> \"Even\"\n    else -> \"Odd\"\n}","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205639,"user_id":null,"body":"fun even_or_odd(number: Int): String {\n return if (number%2 ===0) \"Even\" else \"Odd\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205640,"user_id":null,"body":"fun even_or_odd(number: Int): String {\n\nval res: String\n\n    when{\n        number % 2 == 0 -> res=\"Even\"\n        else -> res =\"Odd\"\n    }\n    return res\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205641,"user_id":null,"body":"fun even_or_odd(n: Int) = if (n % 2 == 0) \"Even\" else \"Odd\"","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205642,"user_id":null,"body":"fun even_or_odd(number: Int) = if (number and 1 == 1) \"Odd\" else \"Even\"","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205643,"user_id":1624,"body":"fun even_or_odd(number: Int): String = listOf(\"Even\", \"Odd\")[((number % 2) + 2) % 2]\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205644,"user_id":null,"body":"fun even_or_odd(number: Int): String {\n    return when {\n        Integer.toBinaryString(number).last().toString() == \"0\" -> \"Even\"\n        else -> \"Odd\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205645,"user_id":null,"body":"fun even_or_odd(number: Int) = if (number and 1 == 0) \"Even\" else \"Odd\"\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205646,"user_id":null,"body":"fun even_or_odd(number: Int): String {\n if(number.toDouble() \/ 2.0 - Math.floorDiv(number, 2) == 0.0){\n   return \"Even\"\n }else{\n   return \"Odd\"\n }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"53ee5429ba190077850011d4":[{"id":205647,"user_id":null,"body":"package solution\n\nfun double_integer(i:Int) = i*2","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205648,"user_id":null,"body":"package solution\n\nfun double_integer(i: Int) = i shl 1","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205649,"user_id":527,"body":"package solution\n\nfun double_integer(i: Int): Int = i * 2","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205650,"user_id":null,"body":"package solution\n\nfun double_integer(i:Int):Int {\n    val i = i * 2\n    return i\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205651,"user_id":null,"body":"package solution\n\nfun double_integer(i:Int):Int {\n    \/\/ Double the integer and return it!\n    return i.times(2)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205652,"user_id":null,"body":"package solution\n\nfun double_integer(i:Int):Int {\n    \/\/ Double the integer and return it!\n    return i shl 1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205653,"user_id":null,"body":"package solution\n\nfun double_integer(i:Int):Int {\n    \/\/ Double the integer and return it\n    return i*2\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205654,"user_id":null,"body":"\npackage solution\n\nfun double_integer(i:Int):Int =\n    \/\/ Double the integer and return it!\n     i * 2\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205655,"user_id":null,"body":"package solution\n\nfun double_integer(i:Int):Int {\n    \/\/ Double the integer and return it!\n    var I = i\n    I+=I\n    return I\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205656,"user_id":null,"body":"package solution\n\nfun double_integer(i:Int):Int {\n    var multiply = i * 2\n    return multiply\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"543bfbecdef6345f52000e4d":[{"id":205657,"user_id":null,"body":"package com.codewars.hybris95\n\nclass Leetspeak : Encoder() {\n\n  override fun encode(source: String?): String =\n    (source ?: \"\").map { \n        when (it.toLowerCase()) {\n            'a' -> \"4\"\n            'e' -> \"3\"\n            'l' -> \"1\"\n            'm' -> \"\/^^\\\\\"\n            'o' -> \"0\"\n            'u' -> \"(_)\"\n            else -> it\n        } }.joinToString(\"\")\n    \n    \n}\n\nabstract class Encoder {\n    abstract fun encode(source: String?): String\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205658,"user_id":null,"body":"package com.codewars.hybris95\n\nclass Leetspeak: Encoder() {\n    private val dictionary = mapOf(\"a\" to \"4\", \"e\" to \"3\", \"l\" to \"1\", \"m\" to \"\/^^\\\\\", \"o\" to \"0\", \"u\" to \"(_)\")\n    override fun encode(source: String?) =\n        source?.chunked(1)?.joinToString(\"\") { dictionary[it.toLowerCase()] ?: it } ?: \"\"\n}\n\nabstract class Encoder {\n    abstract fun encode(source: String?): String\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205659,"user_id":null,"body":"package com.codewars.hybris95\n\n\nclass Leetspeak : Encoder() {\n\n    override fun encode(source: String?): String {\n        return (source ?: \"\").asSequence().map {\n            when (it.toLowerCase()) {\n                'a' -> \"4\"\n                'e' -> \"3\"\n                'l' -> \"1\"\n                'm' -> \"\/^^\\\\\"\n                'o' -> \"0\"\n                'u' -> \"(_)\"\n                else -> it.toString()\n            }\n        }.joinToString(\"\")\n    }\n}\n\nabstract class Encoder {\n    abstract fun encode(source: String?): String\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205660,"user_id":null,"body":"package com.codewars.hybris95\n\nclass Leetspeak : Encoder() {\n\n  override fun encode(source: String?): String = source\n    ?.toCharArray()\n    ?.joinToString(separator = \"\") {\n        when ( it.toLowerCase().toString() ) {\n            \"a\" -> \"4\"\n            \"e\" -> \"3\"\n            \"l\" -> \"1\"\n            \"m\" -> \"\/^^\\\\\"\n            \"o\" -> \"0\"\n            \"u\" -> \"(_)\"\n            else -> it.toString()\n        }\n    }\n    ?: \"\"\n}\n\nabstract class Encoder {\n    abstract fun encode(source: String?): String\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205661,"user_id":null,"body":"package com.codewars.hybris95\n\nclass Leetspeak : Encoder() {\n\n  override fun encode(source: String?): String {\n    if (source == null) return \"\"\n    return source.chunked(1).map {when(it) {\n        \"a\",\"A\" -> \"4\"\n        \"e\",\"E\" -> \"3\"\n        \"l\",\"L\" -> \"1\"\n        \"m\",\"M\" -> \"\/^^\\\\\"\n        \"o\",\"O\" -> \"0\"\n        \"u\",\"U\" -> \"(_)\"\n        else -> it\n     }}.joinToString(\"\")\n  }\n}\n\nabstract class Encoder {\n    abstract fun encode(source: String?): String\n    \n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205662,"user_id":null,"body":"package com.codewars.hybris95\n\nabstract class Encoder {\n    abstract fun encode(source: String?): String\n}\n\nclass Leetspeak: Encoder() {\n  override fun encode(source: String?): String =\n        (source ?: \"\").asSequence().map {\n            when (it.lowercaseChar()) {\n                'a' -> \"4\"\n                'e' -> \"3\"\n                'l' -> \"1\"\n                'm' -> \"\/^^\\\\\"\n                'o' -> \"0\"\n                'u' -> \"(_)\"\n                else -> it.toString()\n            }\n        }.joinToString(\"\")\n}\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205663,"user_id":null,"body":"package com.codewars.hybris95\n\nclass Leetspeak: Encoder() {\n\n    @Override\n    override fun encode(source: String?) = (source ?: \"\").split(\"\").map { when (it.toLowerCase()) {\n        \"a\" -> \"4\"\n        \"e\" -> \"3\"\n        \"l\" -> \"1\"\n        \"m\" -> \"\/^^\\\\\"\n        \"o\" -> \"0\"\n        \"u\" -> \"(_)\"\n        else -> it\n    } }.joinToString(\"\")\n    \/*\n    {\n        \/\/ TODO - Encode the source string into a 133tSp34k string\n        return \"133tSp34k\";\n    }\n    *\/\n    \n}\n\nabstract class Encoder {\n    abstract fun encode(source: String?): String\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205664,"user_id":null,"body":"package com.codewars.hybris95\n\nclass Leetspeak : Encoder() {\n\n    override fun encode(source: String?): String {\n        source ?: return \"\"\n        var s = \"\"\n        for (i in source) {\n            s += when (i) {\n                'A', 'a' -> \"4\"\n                'E', 'e' -> \"3\"\n                'L', 'l' -> \"1\"\n                'M', 'm' -> \"\/^^\\\\\"\n                'O', 'o' -> \"0\"\n                'U', 'u' -> \"(_)\"\n                else -> i\n            }\n        }\n        return s\n    }\n}\n\nabstract class Encoder {\n    abstract fun encode(source: String?): String\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205665,"user_id":null,"body":"package com.codewars.hybris95\n\nclass Leetspeak : Encoder() {\n\n  override fun encode(source: String?) : String =\n      (source ?: \"\")\n          .replace('a', '4')\n          .replace('A', '4')\n          .replace('e', '3')\n          .replace('E', '3')\n          .replace('l', '1')\n          .replace('L', '1')\n          .replace(\"m\", \"\/^^\\\\\")\n          .replace(\"M\", \"\/^^\\\\\")\n          .replace('o', '0')\n          .replace('O', '0')\n          .replace(\"u\", \"(_)\")\n          .replace(\"U\", \"(_)\");\n}\n\nabstract class Encoder {\n    abstract fun encode(source: String?): String\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205666,"user_id":null,"body":"package com.codewars.hybris95\n\nclass Leetspeak : Encoder() {\n\n  override fun encode(source: String?) : String =\n      source\n      ?.replace('a', '4')\n      ?.replace('A', '4')\n      ?.replace('e', '3')\n      ?.replace('E', '3')\n      ?.replace('l', '1')\n      ?.replace('L', '1')\n      ?.replace(\"m\", \"\/^^\\\\\")\n      ?.replace(\"M\", \"\/^^\\\\\")\n      ?.replace('o', '0')\n      ?.replace('O', '0')\n      ?.replace(\"u\", \"(_)\")\n      ?.replace(\"U\", \"(_)\") ?: \"\";\n}\n\nabstract class Encoder {\n    abstract fun encode(source: String?): String\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"544675c6f971f7399a000e79":[{"id":205667,"user_id":null,"body":"fun string_to_number(str: String) = str.toInt()","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205668,"user_id":53,"body":"fun string_to_number(str: String): Int {\n    return Integer.parseInt(str)\n}","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205669,"user_id":null,"body":"fun string_to_number(str: String): Int {\n  val isNegative = str.first() == '-'\n\n  var digit = 0\n  var result = 0\n\n  str.filter { it != '-' }.reversed().forEach { d ->\n    result += (d.toInt() - '0'.toInt()) * pow(10, digit)\n    digit++\n  }\n\n  return if (isNegative) -1 * result else result\n}\n\nprivate fun pow(base: Int, pow: Int): Int {\n  if (pow == 0) return 1\n\n  var result = base\n  repeat(pow - 1) {\n    result *= base\n  }\n  return result\n}","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205670,"user_id":null,"body":"fun string_to_number(str: String): Int {\n    var res:Int\n    if(str[0].equals('-')) res = str.substring(1).toInt() * -1\n    else res = str.toInt()\n    return res\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205671,"user_id":null,"body":"fun string_to_number(str: String): Int {\n    try {\n        return str.toInt()\n    }\n    catch (ex: Exception) {\n        return 0\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205672,"user_id":null,"body":"fun string_to_number(number: String) = number.toInt()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205673,"user_id":null,"body":"fun string_to_number(str: String): Int {\n    var result = str.toInt()\n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205674,"user_id":null,"body":"fun string_to_number(str: String): Int {\n    var converter = str.toInt()\n    return converter\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205675,"user_id":null,"body":"import kotlin.math.roundToInt\n\n    fun string_to_number(str: String): Int {\n        val response : Int = try {\n            getInt(str)\n        } catch (e: NumberFormatException) {\n            getFloat(str)\n        }\n        return response\n    }\n\n    private fun getInt(str: String): Int {\n        return str.toInt()\n    }\n\n    private fun getFloat(str: String): Int {\n        val response : Int = try {\n            str.toFloat().roundToInt()\n        } catch (e: NumberFormatException) {\n            0\n        }\n        return response\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205676,"user_id":null,"body":"fun main(){\n    println(string_to_number(\"1234\"))\n    println(string_to_number(\"605\"))\n    println(string_to_number(\"1405\"))\n    println(string_to_number(\"-7\"))\n}\nfun string_to_number(str: String): Int {\n    val stringToInt = str.toInt()\n    return stringToInt\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"54521e9ec8e60bc4de000d6c":[{"id":205677,"user_id":null,"body":"import kotlin.math.max\n\nfun max_sequence(arr: List<Int>): Int {\n    var max = 0\n    arr.indices.forEach { outer ->\n        (outer..arr.size).forEach { inner ->\n            max = max(arr.subList(outer, inner).sum(), max)\n        }\n    }\n    return max\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205678,"user_id":null,"body":"fun max_sequence(arr: List<Int>): Int {\n    if (arr.isEmpty() || arr.max()!! < 0)\n        return 0\n\n    var max = 0\n    var currentSum = 0\n    for (num in arr) {\n        if (currentSum + num < 0){\n            currentSum = 0\n            continue\n        }\n\n        currentSum += num\n\n        if (currentSum > max){\n            max = currentSum\n        }\n    }\n\n    return max\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205679,"user_id":null,"body":"fun max_sequence(arr: List<Int>): Int {\n    \/\/ Kadane's algorithm.\n    \/\/ Finds the maximum sum of a contiguous subsequence in an array or list of integers.\n\n    var sum = 0\n    var max = 0\n    \n    arr.forEach {v->\n        sum = if(v>sum+v) v else sum+v\n        max = if(sum>max) sum else max\n    }\n    \n    return max\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205680,"user_id":null,"body":"fun max_sequence(arr: List<Int>): Int {\n    return arr.indices.map { first ->\n        (first..arr.size).map { last -> arr.subList(first, last).sum()}\n    }.flatten().maxOrNull() ?: 0\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205681,"user_id":null,"body":"fun max_sequence(arr: List<Int>): Int = \n    arr.fold(0 to 0) { accAndResult, i ->\n        with(accAndResult.first + i) {\n            Pair(Math.max(this, 0), Math.max(this, accAndResult.second))\n        }\n    }.second","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205682,"user_id":null,"body":"fun max_sequence(arr: List<Int>): Int {\n    var max = 0\n    for(out in arr.indices){\n        for(i in out..arr.size){\n            max = if(arr.subList(out, i).sum() > max) arr.subList(out, i).sum() else max\n        }\n    }\n    return max\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205683,"user_id":null,"body":"import kotlin.math.max\n\nfun max_sequence(arr: List<Int>) = arr\n    .fold(0 to 0) { (x, a), b ->\n        max(a+b, b).let { max(x, it) to it }\n    }\n    .component1()\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205684,"user_id":null,"body":"fun max_sequence(arr: List<Int>) = 1.rangeTo(arr.size)\n        .map{ arr.windowed(it) }\n        .flatten()\n        .map{ it.sum() }\n        .filter{ it > 0 }\n        .max() ?: 0","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205685,"user_id":179,"body":"fun max_sequence(arr: List<Int>): Int {\n            \n    var max = 0\n    var curr = 0\n    \n    arr.forEach {\n        curr += it\n        when {\n            curr > max -> max = curr\n            curr < 0 -> curr = 0\n        }\n    }\n    \n    return max\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205686,"user_id":null,"body":"fun max_sequence(arr: List<Int>): Int = when {\n        arr.isEmpty() -> 0\n        arr.none { it > 0 } -> 0\n        else -> arr.mapIndexed { index, _ -> arr.windowed(index+1).map { it.sum() }.max() }.filterNotNull().max()!!\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"545991b4cbae2a5fda000158":[{"id":205687,"user_id":null,"body":"fun include(arr: IntArray, item: Int) = item in arr","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205688,"user_id":527,"body":"val include = IntArray::contains","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205689,"user_id":null,"body":"fun include(arr: IntArray, item : Int) = arr.contains(item)\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205690,"user_id":null,"body":"fun include(arr: IntArray, item : Int) = arr.any { it == item }\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205691,"user_id":null,"body":"fun include(arr: IntArray, item : Int): Boolean = arr.contains(item) ?: false \n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205692,"user_id":null,"body":"fun include(arr: IntArray, item : Int): Boolean {\n    return if (arr.contains(item)) true else false\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205693,"user_id":null,"body":"fun include(arr: IntArray, i : Int) = i in arr","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205694,"user_id":1169,"body":"var include = IntArray::contains","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205695,"user_id":null,"body":"fun include(arr: IntArray, item : Int): Boolean {\n    if(arr.count{i -> i == item} > 0) return true else return false\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205696,"user_id":null,"body":"fun include(arr: IntArray, item : Int): Boolean {\n    arr.forEach { if(it == item) return true}\n    return false\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"54a91a4883a7de5d7800009c":[{"id":205697,"user_id":null,"body":"fun incrementString(str: String) : String {\n    val i = str.takeLastWhile { it.isDigit() }\n    return str.dropLast(i.length) + ((i.toIntOrNull() ?: 0) + 1).toString().padStart(i.length, '0')\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205698,"user_id":527,"body":"fun incrementString(str: String): String {\n    return str.replace(Regex(\"([0-8]?)(9*)$\")) { m ->\n        val (d, ds) = m.destructured\n        \"${if (d.isEmpty()) 1 else d.toInt() + 1}${ds.replace('9', '0')}\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205699,"user_id":null,"body":"fun incrementString(str: String): String {\n    val (letters, numbers) = separateStringAndFinalNumbers(str)\n    val increasedNumbers = increaseNumbers(numbers)\n    return letters + increasedNumbers\n}\n\nprivate fun increaseNumbers(numbers: String): String {\n    return when (numbers) {\n        \"\" -> \"1\"\n        else -> (numbers.toInt() + 1).toString().padStart(numbers.length, '0')\n    }\n}\n\nfun separateStringAndFinalNumbers(str: String): Pair<String, String> {\n    val lastNonNumericChar = str.lastOrNull() { it.isLetter() }\n    val highestNonNumericIndex = str.indexOfLast { it == lastNonNumericChar }\n    val letters = str.slice(0..highestNonNumericIndex)\n    val finalNumbers = str.slice(highestNonNumericIndex + 1..str.lastIndex)\n    return Pair(\n        letters,\n        finalNumbers\n    )\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205700,"user_id":null,"body":"fun incrementString(str: String) = str.replace(Regex(\"\\\\d+\"), \"\") +\n        (str.replace(Regex(\"\\\\D+\"), \"\").takeIf { it != \"\" } ?: \"0\").let {\n            \"${it.toInt().inc()}\".padStart(it.count(), '0')\n        }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205701,"user_id":null,"body":"fun incrementString(str: String) = str.takeLastWhile { it.isDigit() }.let {\n    if (it.isEmpty()) str + \"1\"\n    else str.replace(it, \"%0${it.length}d\".format(it.toInt() + 1))\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205702,"user_id":null,"body":"fun incrementString(str: String) : String {\n    val index = str.indexOfAny(charArrayOf('0', '1', '2', '3', '4', '5', '6', '7', '8', '9'))\n    if (index != -1)\n        return str.substring(0, index) + String.format(\"%0\" + (str.length - index) + \"d\", str.substring(index).toInt() + 1)\n    return str + \"1\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205703,"user_id":null,"body":"fun incrementString(str: String): String {\n    return str.takeLastWhile { it.isDigit() }.let {\n        when (it.length) {\n            0 -> \"1\"\n            else -> str.removeSuffix(it) + (it.toInt() + 1).toString().padStart(it.length, '0')\n        }\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205704,"user_id":null,"body":"fun incrementString(str: String): String {\n    var zeros = \"\"\n    var number = \"\"\n    var base = \"\"\n    var output:String\n    str.forEach {\n        when {\n            it == '0' && number.isEmpty() -> {\n                zeros += '0'\n            }\n\n            it.isDigit() -> number += it\n            else -> base += it\n        }\n    }\n    when {\n        number.isEmpty() && zeros.isEmpty() -> output = base + \"1\"\n        number.isEmpty() && zeros.isNotEmpty() -> {\n            zeros = zeros.dropLast(1) + '1'\n            output = base + zeros\n        }\n        else->output=base + zeros + (number.toInt().inc()).toString()\n    }\n    return output\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205705,"user_id":null,"body":"fun incrementString(str: String) : String {\n  val s = str.filter { !it.isDigit() }\n  val d = str.filter { it.isDigit() }\n  if (d.length == 0) return s + \"1\"\n    \n  val n = (d.toInt() + 1).toString()\n  val digit = if (n.length < d.length) \"0\".repeat(d.length - n.length) + n else n\n  return s + digit\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205706,"user_id":null,"body":"fun incrementString(str: String) : String {\n  var returnStr = str\n    if (str.isBlank() || str[str.lastIndex].isDigit().not()) return \"${str}1\"\n\n    for (i in 0..returnStr.lastIndex) {\n        val numberAttempt = returnStr.substring(i, returnStr.lastIndex + 1)\n        if (numberAttempt.toIntOrNull() != null) {\n            val numberIncremented = numberAttempt.toInt() + 1\n            val zeroesToAdd = numberAttempt.length - numberIncremented.toString().length\n            val numberString = \"0\".repeat(if (zeroesToAdd < 0) 0 else zeroesToAdd) + \"$numberIncremented\"\n            returnStr = returnStr.replaceRange(i until returnStr.lastIndex + 1, numberString)\n            break\n        }\n    }\n    return returnStr\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"54b724efac3d5402db00065e":[{"id":205707,"user_id":null,"body":"package morsecode\n\nfun decodeWord(wordCode: String): String {\n    return wordCode.split(\" \")\n        .map { MorseCode[it] }\n        .joinToString(\"\")\n}\n\nfun decode_morse(code: String): String {\n    return code.trim().split(\"   \")\n        .joinToString(\" \") { decodeWord(it) }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205708,"user_id":null,"body":"package morsecode\n\nfun decode_morse(code: String): String {\n  return code.split(\" \")\n             .map({ x -> MorseCode[x] ?: \" \" })\n             .joinToString(\"\")\n             .replace(\"  \",\" \")\n             .trim()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205709,"user_id":null,"body":"package morsecode\n\nfun decode_morse(code: String) = code\n    .trim()\n    .split(\"   \").joinToString(\" \") {\n        it.split(\" \").joinToString(\"\") {\n            MorseCode.getOrDefault(it, \"\")\n        }\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205710,"user_id":null,"body":"package morsecode\n\nfun decode_morse(code: String): String {\n        val phrase = StringBuilder()\n        val codes = code.split(\" \")\n        codes.forEach{\n            val morseCharDecoded = getCharFromMorseCode(it)\n            if (phrase.isBlank() ||\n                morseCharDecoded.isNotBlank() ||\n                morseCharDecoded.isBlank() && phrase.last() != ' '\n            ){\n                phrase.append(morseCharDecoded)\n            }\n        }\n        return phrase.trim().toString()\n    }\n\n    private fun getCharFromMorseCode(morseCode: String): String =\n        when (morseCode) {\n            \".-\" -> \"A\"\n            \"-...\" -> \"B\"\n            \"-.-.\" -> \"C\"\n            \"-..\" -> \"D\"\n            \".\" -> \"E\"\n            \"..-.\" -> \"F\"\n            \"--.\" -> \"G\"\n            \"....\" -> \"H\"\n            \"..\" -> \"I\"\n            \".---\" -> \"J\"\n            \"-.-\" -> \"K\"\n            \".-..\" -> \"L\"\n            \"--\" -> \"M\"\n            \"-.\" -> \"N\"\n            \"---\" -> \"O\"\n            \".--.\" -> \"P\"\n            \"--.-\" -> \"Q\"\n            \".-.\" -> \"R\"\n            \"...\" -> \"S\"\n            \"-\" -> \"T\"\n            \"..-\" -> \"U\"\n            \"...-\" -> \"V\"\n            \".--\" -> \"W\"\n            \"-..-\" -> \"X\"\n            \"-.--\" -> \"Y\"\n            \"--..\" -> \"Z\"\n            \".----\" -> \"1\"\n            \"..---\" -> \"2\"\n            \"...--\" -> \"3\"\n            \"....-\" -> \"4\"\n            \".....\" -> \"5\"\n            \"-....\" -> \"6\"\n            \"--...\" -> \"7\"\n            \"---..\" -> \"8\"\n            \"----.\" -> \"9\"\n            \"-----\" -> \"0\"\n            \"\" -> \" \"\n            \".-.-.-\" -> \".\"\n            \"--..--\" -> \",\"\n            \"---...\" -> \".\"\n            \"..--..\" -> \"?\"\n            \"-.-.--\" -> \"!\"\n            \"...---...\" -> \"SOS\"\n            \"-....-\" -> \"''\"\n            \"-..-.\" -> \"\/\"\n            \"-.--.-\" -> \"()\"\n            \".--.-.\" -> \"@\"\n            \"-...-\" -> \"=\"\n            else -> throw IllegalArgumentException(\"Not all characters are valid \"+morseCode)\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205711,"user_id":null,"body":"package morsecode\n\nfun decode_morse(code: String): String =\n    code\n        .trim()\n        .split(\"   \")\n        .joinToString(\" \") { wordEncoded ->\n            wordEncoded\n                .split(\" \")\n                .joinToString(\"\") { letterEncoded ->\n                    MorseCode.getOrDefault(letterEncoded, \"\")\n                }\n        }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205712,"user_id":null,"body":"package morsecode\n\nfun decode_morse(code: String) = code.split(\" \")\n        .joinToString(\"\") { MorseCode[it] ?: \" \" }\n        .replace(\"  \", \" \")\n        .trim()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205713,"user_id":null,"body":"package morsecode\n\nconst val MORSE_WORD_SEPARATOR = \"   \"\nconst val MORSE_CHAR_SEPARATOR = \" \"\nfun decode_morse(code: String): String {\n    val decoded = mutableListOf<String>()\n    val words = code.split(MORSE_WORD_SEPARATOR)\n    words.forEach{\n        val chars = it.split(MORSE_CHAR_SEPARATOR)\n        chars.forEach {\n            decoded.add(getMorseCode(it))\n        }\n        decoded.add(\" \")\n    }\n    return decoded.joinToString(\"\").trim()\n}\n\nfun getMorseCode(code:String):String = MorseCode[code] ?: \"\"","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205714,"user_id":null,"body":"package morsecode\n\nfun decode_morse(code: String): String =        \n    code.split(\"   \").joinToString(\" \") { word ->\n        word.split(\" \").joinToString(\"\") { letter ->\n            MorseCode[letter] ?: \"\"\n        }\n    }.trim()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205715,"user_id":null,"body":"package morsecode\n\nfun decode_morse(code: String): String {\n    return code.trim().split(\" \").map{MorseCode[it] ?: \" \"}.joinToString(\"\").replace(Regex(\"\\\\s++\"), \" \")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205716,"user_id":null,"body":"package morsecode\n\nfun decode_morse(code: String): String = code.trim().split(\" \").joinToString(\"\") { MorseCode[it] ?: \" \" }.replace(\" +\".toRegex(), \" \")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"54b72c16cd7f5154e9000457":[{"id":205717,"user_id":1251,"body":"fun decode_bits(bits: String): String {\n    val bis = bits.trim { it == '0' }\n    val timeUnit = Regex(\"0+|1+\").findAll(bis).fold(bis.length) { smallest, x -> if (x.value.length < smallest) x.value.length else smallest }\n    return bis.replace(\"111\".repeat(timeUnit), \"-\")\n              .replace(\"000\".repeat(timeUnit), \" \")\n              .replace(\"1\".repeat(timeUnit), \".\")\n              .replace(\"0\".repeat(timeUnit), \"\")\n}\n\nfun decode_morse(code: String) = code.split(\" \").map { if (it == \"\") \" \" else MORSE_CODE[it] }.joinToString(\"\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205718,"user_id":1381,"body":"fun decode_bits(bits: String): String {\n    val sanitized = bits.trim('0')\n    val timeUnit = Regex(\"0+|1+\").findAll(sanitized).minBy { it.value.length }!!.value.length\n    return sanitized\n        .replace(Regex(\"1{$timeUnit,}\")) { if (it.value.length == timeUnit) \".\" else \"-\" }\n        .replace(Regex(\"0+\")) { if (it.value.length == timeUnit) \"\" else if (it.value.length == timeUnit * 3) \" \" else \"   \" }\n}\n\nfun decode_morse(code: String): String {\n    return Regex(\"[-.]+| {3}\").findAll(code).map { it.value }\n        .map { if (it.isBlank()) \" \" else MORSE_CODE[it] }\n        .joinToString(\"\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205719,"user_id":null,"body":"fun decode_bits(bits: String): String = bits.trim('0')\n    .let { it to (Regex(\"(0+|1+)\").findAll(it).map { it.value.length }.min() ?: 0) }\n    .run { first.replace(\"0\".repeat(second), \"0\").replace(\"1\".repeat(second), \"1\") }\n    .replace(\"111\", \"-\").replace(\"1\", \".\")\n    .replace(\"0000000\", \"   \").replace(\"000\", \" \").replace(\"0\", \"\")\n\nfun decode_morse(code: String): String = code.trim()\n    .split(\" \").joinToString(\"\") { MORSE_CODE[it] ?: \" \" }.replace(Regex(\" +\"), \" \")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205720,"user_id":null,"body":"fun decode_bits(\n    bits: String\n): String = bits.trim { it == '0' }.let { \"0+|1+\".toRegex().findAll(it) }.asSequence().map { it.value }.run {\n    this to map { it.length }.min()!!.let {\n        mapOf(\n            \"1\".repeat(it) to \".\",\n            \"111\".repeat(it) to \"-\",\n            \"000\".repeat(it) to \" \",\n            \"0000000\".repeat(it) to \"  \"\n        )\n    }\n}.let { (tokens, bitsToMorse) -> tokens.joinToString(\"\") { bitsToMorse[it].orEmpty() } }\n\nfun decode_morse(\n    code: String\n): String = code.trim().split(\" \").joinToString(\"\") { MORSE_CODE[it] ?: \" \" }.replace(\" +\".toRegex(), \" \")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205721,"user_id":null,"body":"fun bitRate(bits: String): Int {\n    val trimmedBits = bits.trim('0')\n    return Regex(\"0+|1+\").findAll(trimmedBits).map { it.value.length }.min() ?: 0\n}\n\nfun decode_bits(bits: String): String {\n    val bitCode = BitCode(bitRate(bits))\n    return bits\n        .trim('0')\n        .split(bitCode.emptySpace)\n        .joinToString(\"\") { bitCode[it] ?: \" \" }\n        .replace(\"  \", \" \")\n}\n\nfun decode_morse(code: String): String {\n    return code\n        .trim()\n        .split(\" \")\n        .joinToString(\"\") { MORSE_CODE[it] ?: \" \" }\n        .replace(\"  \", \" \")\n}\n\nclass BitCode(bitRate: Int) {\n    val emptySpace = \"0\".repeat(bitRate)\n    val whiteSpace = \"0\".repeat(bitRate * 3)\n    val dotSpace = \"1\".repeat(bitRate)\n    val dashSpace = \"1\".repeat(bitRate * 3)\n\n    operator fun get(s: String): String? {\n        return when (s) {\n            emptySpace -> \"\"\n            whiteSpace -> \" \"\n            dotSpace -> \".\"\n            dashSpace -> \"-\"\n            else -> null\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205722,"user_id":null,"body":"fun decode_bits(bits: String): String {\n    val morseData = bits.trim('0')\n    val timeUnit = \"(1+|0+)\".toRegex()\n        .findAll(morseData)\n        .map { it.groupValues.last().length }\n        .min() ?: 1\n\n    return morseData\n        .replace(\"1{${3*timeUnit}}\".toRegex(), \"-\")\n        .replace(\"0{${7*timeUnit}}\".toRegex(), \"   \")\n        .replace(\"0{${3*timeUnit}}\".toRegex(), \" \")\n        .replace(\"1{${timeUnit}}\".toRegex(), \".\")\n        .replace(\"0{${timeUnit}}\".toRegex(), \"\")\n}\n\nfun decode_morse(code: String): String {\n    return code.split(\"   \").joinToString(\" \") {\n        it.split(\" \").joinToString(\"\") { letter -> MORSE_CODE[letter] ?: \"\"}\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205723,"user_id":null,"body":"fun gcd(numbers: List<Int>) =\n    numbers.min()?.let { minimalPossibleGcd ->\n        (minimalPossibleGcd downTo 1).firstOrNull { candidate ->\n            numbers.all { it % candidate == 0 }\n        }\n    } ?: 1\n\n\nfun decode_bits(bits: String) =\n    bits\n        .trim { it == '0' }\n        .fold(emptyList<String>()) { acc, c ->\n            if (acc.lastOrNull()?.lastOrNull() == c) acc.dropLast(1) + (acc.last() + c)\n            else acc + c.toString()\n        }\n        .map { it.length }\n        .let(::gcd)\n        .let { rate ->\n            bits\n                .trim { it == '0' }\n                .filterIndexed { index, _ -> index % rate == 0 }\n                .split(\"0000000\")\n                .joinToString(\"   \") { wordAsBits ->\n                    wordAsBits.split(\"000\").joinToString(\" \") { characterAsBits ->\n                        characterAsBits.split(\"0\").joinToString(\"\") {\n                            if (it.length == 3) \"-\" else \".\"\n                        }\n                    }\n                }\n        }.orEmpty()\n        \nfun decode_morse(code: String): String =\n    code\n        .trim()\n        .split(\"   \")\n        .joinToString(\" \") { wordEncoded ->\n            wordEncoded\n                .split(\" \")\n                .joinToString(\"\") { letterEncoded ->\n                    MORSE_CODE.getOrDefault(letterEncoded, \"\")\n                }\n        }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205724,"user_id":null,"body":"fun decode_bits(\n    bits: String\n): String = bits.trim { it == '0' }.let { \"0+|1+\".toRegex().findAll(it) }.asSequence().map { it.value }.run {\n    this to map { it.length }.min()!!.let {\n        mapOf(\"1\" to \".\", \"111\" to \"-\", \"000\" to \" \", \"0000000\" to \"  \").mapKeys { (s) -> s.repeat(it) }::getOrDefault\n    }\n}.let { (tokens, bitsToMorse) -> tokens.joinToString(\"\") { bitsToMorse(it, \"\") } }\n\nfun decode_morse(\n    code: String\n): String = code.trim().split(\" \").joinToString(\"\") { MORSE_CODE[it] ?: \" \" }.replace(\" +\".toRegex(), \" \")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205725,"user_id":null,"body":"operator fun Char.times(int: Int) = generateSequence { this }.take(int).joinToString(\"\")\n\nfun decode_bits(bits: String) =\n    with(bits.trim('0').replace(\"10\", \"1-0\").replace(\"01\", \"0-1\").split('-').minBy { it.length }!!.length) {\n        bits.trim('0')\n            .replace('1' * (this * 3), \"-\")\n            .replace('1' * this, \".\")\n            .replace('0' * (this * 7), \"   \")\n            .replace('0' * (this * 3), \" \")\n            .replace('0' * this, \"\")\n    }\n\nfun decode_morse(code: String) = code.trim().split(\"   \").joinToString(\" \") {\n    it.split(\" \").map { MORSE_CODE[it] ?: \"\" }.joinToString(\"\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205726,"user_id":null,"body":"fun bitRate(bits: String): Int {\n    val trimmedBits = bits.trim('0')\n    return Regex(\"0+|1+\").findAll(trimmedBits)\n        .fold(trimmedBits.length) { min, i -> if (i.value.length < min) i.value.length else min }\n}\n\nfun decode_bits(bits: String): String {\n    val bitCode = BitCode(bitRate(bits))\n    return bits\n        .trim('0')\n        .split(bitCode.emptySpace)\n        .joinToString(\"\") { bitCode[it] ?: \" \" }\n        .replace(\"  \", \" \")\n}\n\nfun decode_morse(code: String): String {\n    return code\n        .trim()\n        .split(\" \")\n        .joinToString(\"\") { MORSE_CODE[it] ?: \" \" }\n        .replace(\"  \", \" \")\n}\n\nclass BitCode(bitRate: Int) {\n    val emptySpace = \"0\".repeat(bitRate)\n    val whiteSpace = \"0\".repeat(bitRate * 3)\n    val dotSpace = \"1\".repeat(bitRate)\n    val dashSpace = \"1\".repeat(bitRate * 3)\n\n    operator fun get(s: String): String? {\n        return when (s) {\n            emptySpace -> \"\"\n            whiteSpace -> \" \"\n            dotSpace -> \".\"\n            dashSpace -> \"-\"\n            else -> null\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"54bd6b4c956834c9870001a1":[{"id":205727,"user_id":null,"body":"import java.lang.reflect.Field\nimport java.lang.reflect.Modifier\n\nval bagel: Bagel\n    get() {\n        try {\n            val f = java.lang.Boolean::class.java.getField(\"TRUE\")\n            val modifiers = Field::class.java.getDeclaredField(\"modifiers\")\n            modifiers.isAccessible = true\n            modifiers.setInt(f, f.modifiers and Modifier.FINAL.inv())\n            f[null] = false\n        } catch (e: Exception) {\n            \/\/ TODO: handle exception\n        }\n\n        return Bagel()\n    }\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205728,"user_id":null,"body":"val bagel: Bagel\n\tget() = Bagel()\nobject org{object junit{object Assert{fun assertEquals(a: Any?, b: Any?){}}}}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205729,"user_id":null,"body":"class java{\n    class lang{\n        class Boolean{\n            companion object {\n              val TRUE = false          \n          }\n        }\n    }\n}\n\n\nvar bagel: Bagel = Bagel()\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205730,"user_id":null,"body":"class java {\n    class lang {\n        class Boolean {\n            companion object {\n                val TRUE = false\n            }\n        }\n    }\n}\n\nval bagel: Bagel\n    get() = Bagel()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205731,"user_id":null,"body":"val bagel: Bagel\n\tget() {        \n        var fields = java.lang.Boolean::class.java.getField(\"TRUE\")\n        val modifiers = java.lang.reflect.Field::class.java.getDeclaredField(\"modifiers\")\n        fields.isAccessible = true\n        modifiers.isAccessible = true\n        modifiers.setInt(fields, fields.getModifiers() and java.lang.reflect.Modifier.FINAL.inv())\n        fields.set(null, false)\n        \n        return Bagel()\n    }\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205732,"user_id":null,"body":"val bagel: Bagel\n\tget() = Bagel()\n\nobject java {\n    object lang {\n        object Boolean {\n            val TRUE = false\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205733,"user_id":null,"body":"val bagel: Bagel\n\tget() = Bagel() \/\/ fix it!\n\nclass java{\n    class lang{\n        class Boolean{\n            companion object {\n              val TRUE = false          \n          }\n        }\n    }\n}    ","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205734,"user_id":null,"body":"val bagel: Bagel\n\tget() = Bagel() \/\/ fix it!\n\n    \nclass java {\n  class lang {\n    class Boolean {\n      companion object {\n        const val TRUE = false\n      }\n    }\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205735,"user_id":null,"body":"import java.lang.reflect.Field\nimport java.lang.reflect.Modifier\n\nval bagel: Bagel\n\t    get() {\n\n        val f = java.lang.Boolean::class.java.getField(\"TRUE\")\n        f.isAccessible = true\n        val modifiers = Field::class.java.getDeclaredField(\"modifiers\")\n        modifiers.isAccessible = true\n        modifiers.setInt(f, f.modifiers and Modifier.FINAL.inv())\n        f.set(null, false)\n\n        return Bagel()\n    }\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205736,"user_id":null,"body":"class BiggerBagel() {\n\n    companion object {\n        \/\/ Test specifically uses java.lang.Boolean.TRUE\n        \/\/ I'll assume that is a clue\n        fun getBagel(): Bagel = java.lang.Boolean.TRUE.javaClass.getDeclaredField(\"value\").let {\n            it.isAccessible = true\n            it.set(\/* obj = *\/ java.lang.Boolean.TRUE, \/* value = *\/ java.lang.Boolean.FALSE)\n            return@getBagel Bagel()\n        }\n    }\n}\n\nval bagel = BiggerBagel.getBagel()\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"54bd79a7956834e767001357":[{"id":205737,"user_id":null,"body":"import java.lang.reflect.Field\nimport java.lang.reflect.Modifier\nimport kotlin.random.Random\n\n\/\/ This is truly, truly horrible ...\n\/\/ Please, CodeWars, don't make us do this kind of thing ;-)\nprivate object hack {\n    init {\n        val field = Random::class.java.getDeclaredField(\"defaultRandom\")\n        field.isAccessible = true\n\n        val modField = Field::class.java.getDeclaredField(\"modifiers\")\n        modField.isAccessible = true\n        modField.setInt(field, field.modifiers.and(Modifier.FINAL.inv()))\n        \n        field.set(Random::class.java, Random(0))\n    }\n    val random = Random(0)\n}\n\nfun guess(): Double = hack.random.nextDouble()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205738,"user_id":null,"body":"val guess = object : () -> Any {\n    var counter = 5\n    override operator fun invoke() = object : Any() {\n        override fun equals(other: Any?): Boolean = counter-- > 0\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205739,"user_id":null,"body":"fun <T>T.assertEquals(a: Double, b: Double) = true\n\nfun guess(): Double = kotlin.random.Random.nextDouble()\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205740,"user_id":null,"body":"import net.bytebuddy.ByteBuddy\nimport net.bytebuddy.agent.ByteBuddyAgent\nimport net.bytebuddy.description.method.MethodDescription\nimport net.bytebuddy.dynamic.loading.ClassReloadingStrategy\nimport net.bytebuddy.implementation.FixedValue\nimport net.bytebuddy.matcher.ElementMatchers\n\nfun guess(): Double {\n\n    ByteBuddyAgent.install()\n\n    val mkay = System.currentTimeMillis().toDouble();\n    \n    ByteBuddy()\n            .redefine(kotlin.random.Random.javaClass)\n            .method(ElementMatchers.named<MethodDescription>(\"nextDouble\"))\n            .intercept(FixedValue.value(mkay))\n            .make()\n            .load(kotlin.random.Random::class.java.classLoader, ClassReloadingStrategy.fromInstalledAgent())\n            .loaded   \n    \n    return mkay\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205741,"user_id":null,"body":"import java.lang.reflect.Field\nimport java.lang.reflect.Modifier\nimport java.security.AccessController\nimport java.security.PrivilegedAction\nimport kotlin.random.Random\n\n\n fun guess(): Double {\n        val newValue = MyRandom()\n        newValue.nextRandomValue = Math.random()\n        \n        setFinalStatic(Random::class.java.getDeclaredField(\"defaultRandom\"), newValue)\n        return newValue.nextRandomValue\n    }\n\n    @Throws(Exception::class)\n    fun setFinalStatic(field: Field, newValue: Any?) {\n        field.setAccessible(true)\n        val modifiersField: Field = Field::class.java.getDeclaredField(\"modifiers\")\n\n        \/\/ wrapping setAccessible\n        AccessController.doPrivileged(PrivilegedAction<Any?> {\n            modifiersField.setAccessible(true)\n            null\n        })\n        modifiersField.setInt(field, field.getModifiers() and Modifier.FINAL.inv())\n        field.set(null, newValue)\n    }\n\n    class MyRandom : Random() {\n        var nextRandomValue = 1.0\n\n        override fun nextDouble(): Double {\n            return nextRandomValue\n        }\n\n        override fun nextBits(bitCount: Int): Int {\n            return 0\n        }\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205742,"user_id":470,"body":"var i = 0.99\nfun guess(): Double = ++i\n\nclass kotlin {\n    class random {\n        class Random {\n            companion object {\n                fun nextDouble(): Double = i\n            }\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205743,"user_id":null,"body":"import java.lang.reflect.Modifier\nimport kotlin.random.Random\nimport kotlin.reflect.full.memberProperties\nimport kotlin.reflect.jvm.javaField\n\n\nclass Guesser {\n    private val myRnd = Random(1)\n\n    init {\n        val defaultRandom = Random.Default::class.memberProperties.find { it.name == \"defaultRandom\" }!!\n        val defaultRandomField = defaultRandom.javaField!!\n\n        val modifiers = defaultRandomField.javaClass.getDeclaredField(\"modifiers\")\n        modifiers.isAccessible = true\n        modifiers.setInt(defaultRandomField, defaultRandomField.modifiers and Modifier.FINAL.inv())\n\n        defaultRandomField.isAccessible = true\n        defaultRandomField.set(null, Random(1))\n    }\n\n    fun predict(): Double = myRnd.nextDouble()\n}\n\nval guesser = Guesser()\n\nfun guess(): Double = guesser.predict()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205744,"user_id":null,"body":"var secret = 0.0\nfun guess(): Double = ++secret\n\nclass kotlin {\n  class random {\n    companion object Random {\n      fun nextDouble(): Double {\n        return secret\n      }\n    }\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205745,"user_id":null,"body":"var value = 0.0\nval secret: Double get() {\n  value += 1.0\n  return value\n}\n\nfun guess(): Double {\n  return secret\n}\n\nclass kotlin {\n  class random {\n    companion object Random {\n      fun nextDouble(): Double {\n        return secret - 1.0\n      }\n    }\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205746,"user_id":null,"body":"private var value = 1.0\n\nfun guess(): Double = ++value\n\nobject kotlin {\n    object random {\n        object Random {\n            fun nextDouble(): Double = value\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"54bf1c2cd5b56cc47f0007a1":[{"id":205747,"user_id":null,"body":"fun duplicate_count(text: String) = text.groupBy(Char::toLowerCase).count { it.value.count() > 1 }","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205748,"user_id":null,"body":"fun duplicate_count(text: String): Int {\n    return text.groupingBy { it.toLowerCase() }.eachCount().values.count { it > 1 }\n}","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205749,"user_id":null,"body":"fun duplicate_count(text: String) = text.groupBy(Char::toLowerCase).count { it.value.size > 1}","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205750,"user_id":null,"body":"fun duplicate_count(text: String): Int {\n     return text\n        .toLowerCase()\n        .split(\"\")\n        .filter { s -> s != \"\" }\n        .groupingBy { s -> s }\n        .eachCount()\n        .filter { entry -> entry.value > 1 }\n        .size\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205751,"user_id":null,"body":"fun duplicate_count(text: String): Int = text.toLowerCase().groupBy { it }.count{it.value.size > 1}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205752,"user_id":null,"body":"fun duplicate_count(text: String): Int {\n    val lowercasedText = text.toLowerCase()\n    \/\/ This is an unordered collection (a set) of everything in `text',\n    \/\/ without repetition. E.g. aaabbbccc1833 -> bac318\n    val allChars = lowercasedText.toSet()\n    var duplicatesCount = 0\n    \n    for (char in allChars) {\n        if (lowercasedText.count{ it == char } > 1) {\n            ++duplicatesCount\n        }\n    }\n    return duplicatesCount\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205753,"user_id":null,"body":"fun duplicate_count(text: String): Int {\n    val counter = HashMap<Char, Int>()\n    text.toLowerCase().forEach {\n        counter.merge(it, 1, Integer::sum)\n    }\n    return counter.values\n        .filter { it > 1 }\n        .count()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205754,"user_id":null,"body":"fun duplicate_count(text: String):Int = text.toLowerCase().groupBy { it }.filter { it.value.count() > 1 }.count()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205755,"user_id":null,"body":"fun duplicate_count(text: String): Int {\n    var characters : HashMap<Char,Int> = HashMap()\n    text.lowercase().toCharArray().forEach { \n        if(!characters.contains(it)){\n            characters.put(it,0)\n        }else{\n            characters.put(it,1)\n        }\n    }\n\n    return characters.values.sum()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205756,"user_id":null,"body":"fun duplicate_count(text: String): Int {\n    var result = 0\n    for ((char, chars) in text.toUpperCase().groupBy{it}) {\n        if (chars.count() >1) {\n                    result++\n        }\n\n    }\n\treturn result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"54cb771c9b30e8b5250011d4":[{"id":205757,"user_id":null,"body":"import java.math.BigInteger\nimport java.math.BigInteger.*\n\n\nfun height(eggs: BigInteger, tries: BigInteger): BigInteger {\n    if (eggs == ZERO || tries == ZERO) return ZERO\n    val eggs = if (eggs > tries) tries else eggs\n    var acc = ZERO ; var e = ZERO\n    var binomial = tries\n    while (e < eggs) {\n        acc += binomial\n        e += ONE\n        binomial = binomial * (tries - e) \/ (e + ONE)\n    }\n    return acc\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205758,"user_id":null,"body":"import java.math.BigInteger\nimport java.math.BigInteger.ZERO\nimport java.math.BigInteger.ONE\nimport java.math.BigInteger.TWO\nimport java.math.BigInteger.valueOf\n\nfun height(n: BigInteger, m: BigInteger) :BigInteger {\n    val eggs = n.toInt();  val falls = m.toInt()\n    if (eggs<=0||falls<=0)\n        return ZERO\n    if (eggs>=falls)\n        return TWO.pow(falls).minus(ONE)\n    val partials = (2..eggs).runningFold(valueOf(falls.toLong())){ p, k ->\n        p.times(valueOf((falls+1-k).toLong())).div(valueOf(k.toLong())) }\n    return partials.sumOf{ it }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205759,"user_id":null,"body":"import java.math.BigInteger\n\nfun height(n: BigInteger, m: BigInteger): BigInteger {\n    var cur = BigInteger.ONE\n\n    return (0 until n.toInt()).fold(BigInteger.ZERO) { sum, i ->\n        cur = cur * (m - i.toBigInteger()) \/ (i + 1).toBigInteger()\n        sum + cur\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205760,"user_id":53,"body":"import java.math.BigInteger\n\nfun height(n: BigInteger, m: BigInteger): BigInteger {\n    var x = n\n    var t = BigInteger.ONE\n    var h = BigInteger.ZERO\n    while (x.compareTo(BigInteger.ZERO) != 0) {\n          var e = t.multiply(m.subtract(n).add(x)).divide(n.add(BigInteger.ONE).subtract(x))\n          x = x.subtract(BigInteger.ONE)\n          t = e\n          h = h.add(e)\n    }\n    return h\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205761,"user_id":null,"body":"import java.math.BigInteger\n\n\/*The height formula is based on Combinatorics: the formula nCk is the number of ways you can\n  choose a subset of k items from a set of n items, the formula = n! \/ (k! * (n-k)!) where the\n  n! is the product of all integers from 1 to n. the height formula is the sum of several nCi \n  where n is the number of drops and i is between 1 and the number of eggs (inclusive). \n  My first attempt separeately calculated each combination and added them, but this was calculating \n  the same thing more than once the breakthrough is that nC(k+1) = nCk * (n-k) \/ (k+1) and nC0 = 1, \n  this means that each term helps to calculate the next term.*\/\n\nfun height(eggs: BigInteger, drops: BigInteger) = height(eggs.toInt(), drops.toInt())\nfun height(eggs:Int, drops:Int): BigInteger {\n    var output = BigInteger.ZERO\n    if (drops == 0||eggs == 0) return output\n    var term = BigInteger.ONE\n    for (i in 0 until eggs) {\n        term = term * (drops - i).toBigInteger() \/ (i+1).toBigInteger()\n        if (term == BigInteger.ZERO) return output\n        output += term\n    }\n    return output\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205762,"user_id":168,"body":"import java.math.BigInteger\n\nfun height(n: BigInteger, m: BigInteger): BigInteger {\n    var c = BigInteger.ONE\n    var s = BigInteger.ZERO\n    var i = BigInteger.ZERO\n    while (i < n) {\n        c *= m - i\n        i += BigInteger.ONE\n        c \/= i\n        s += c\n    }\n    return s\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205763,"user_id":null,"body":"import java.math.BigInteger\n\nfun height(n: BigInteger, m: BigInteger): BigInteger {\n    if (n == BigInteger.ZERO || m == BigInteger.ZERO)\n        return BigInteger.ZERO\n    if (n >= m) \/\/ it makes no sense to have more eggs than tries\n        return BigInteger.valueOf(2L).pow(m.toInt()) - BigInteger.ONE \/\/ simple closed-formula for this edge case\n    if (n * BigInteger.valueOf(2L) >= m) \/\/ optimization\n        return BigInteger.valueOf(2L).pow(m.toInt()) - height(n = m - n - BigInteger.ONE, m = m) - BigInteger.valueOf(2L)\n    var num = m\n    var denom = BigInteger.ONE\n    var accNum = BigInteger.ONE\n    var accDenom = BigInteger.ONE\n    var f = BigInteger.ZERO\n    while (denom <= n) {\n        accNum *= num\n        accDenom *= denom\n        f += (accNum \/ accDenom)\n        denom++\n        num--\n    }\n    return f\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205764,"user_id":null,"body":"import java.math.BigInteger\n\nfun height(nEggs: BigInteger, nTries: BigInteger): BigInteger {\n    var temp = BigInteger.ONE\n    var result = BigInteger.ZERO\n    var egg = BigInteger.ONE\n    while (egg.compareTo(nEggs) <= 0) {\n        temp *= nTries - egg + BigInteger.ONE\n        temp \/= egg\n        result += temp\n        egg++\n    }\n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205765,"user_id":null,"body":"import java.math.BigInteger\n\nfun height(nEggs: BigInteger, nTries: BigInteger): BigInteger {\n    var temp = BigInteger.ONE\n    var result = BigInteger.ZERO\n    var egg = BigInteger.ONE\n    while (egg.compareTo(nEggs) <= 0) {\n        \/\/ temp *= (nTries - egg + 1) \/ egg\n        temp = temp.multiply(nTries.subtract(egg).add(BigInteger.ONE)).divide(egg)\n        \/\/ result += temp\n        result = result.add(temp)\n        \/\/egg++\n        egg = egg.add(BigInteger.ONE)\n    }\n    return result\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205766,"user_id":null,"body":"import java.math.BigInteger\n\n\/\/ It took a LONG time to finally arrive at a solution that ran sufficiently quickly\n\/\/ and without blowing up heap or stack.\n\/\/ Solutions went via plain recursive, recursive with memoisation, memoisation with\n\/\/ cache pruning, plain iterative, dynamic programming pre-computing full array of values,\n\/\/ dynamic programming only holding one previous array row to, finallly, the algorithmic\n\/\/ solution below. Rather a lot for a 3ky kata ...\nfun height(bigEggs: BigInteger, bigTries: BigInteger): BigInteger {\n    val eggs = bigEggs.toInt()\n    val tries = bigTries.toInt()\n    if (eggs >= tries) return BigInteger.TWO.pow(tries) - BigInteger.ONE\n    if (eggs == 0 || tries == 0) return BigInteger.ZERO\n    return combinationSum(tries, eggs)\n}\n\nprivate fun combinationSum(n: Int, r: Int): BigInteger {\n    var combinations = BigInteger.ONE\n    var total = BigInteger.ZERO\n    (1 .. r). forEach { ri ->\n        combinations = combinations * (n - ri + 1).toBigInteger() \/ ri.toBigInteger()\n        total += combinations\n    }\n    return total\n}\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"54d496788776e49e6b00052f":[{"id":205767,"user_id":null,"body":"fun sum_of_divided(l: IntArray): String {\n    \n    if (l.size == 0)\n        return \"\"\n    \n    fun getPrimeFactors(n : Int, withN: Boolean = true): List<Int> \n        = (2..(n - if (withN) 0 else 1)).filter { n % it == 0 && getPrimeFactors(it, false).size == 0 }   \n        \n    return l.flatMap { getPrimeFactors(it) }\n           .toSet()\n           .toList()\n           .sorted()\n           .joinToString(prefix = \"(\", postfix = \")\", separator = \")(\") {\n                prime -> \"$prime ${l.filter { it % prime == 0 }.sum()}\"\n           }\n}\n","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205768,"user_id":1251,"body":"fun sum_of_divided(l: IntArray): String {\n    val divisors = mutableMapOf<Int, Int>()\n    primesUpTo(l.max() ?: 0).forEach { prime ->\n        l.forEach { numberInInput ->\n            if (numberInInput % prime == 0) {\n                divisors[prime]?.let {\n                    divisors.put(prime, it + numberInInput)\n                } ?: run { divisors[prime] = numberInInput }\n            }\n        }\n    }\n    return divisors.toList().sortedBy { it.first }.joinToString(\"\") { \"(${it.first} ${it.second})\" }\n}\n\nprivate fun primesUpTo(limit: Int) = (2..limit).filter{ num -> (2 until num).none{ num % it == 0 } }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205769,"user_id":null,"body":"import java.lang.Math.abs\nimport java.util.*\n\nfun main(args: Array<String>) {\n    val lst = intArrayOf(15, 30, -45)\n\n    println(sum_of_divided(lst))\n}\n\n\nfun getPrimeFactors (number: Int) : Set<Int> {\n    val res = mutableSetOf<Int>()\n\n    var i = 2\n    var n = abs(number)\n    while (i * i <= n) {\n        while (n % i == 0) {\n            res.add(i)\n            n \/= i\n        }\n        i += 1\n    }\n    if (n > 1) {\n        res.add(n)\n    }\n    return res\n}\n\nfun sum_of_divided(l: IntArray): String {\n    val res = TreeMap<Int, Int>()\n\n    for (i in l) {\n        getPrimeFactors(i).map {\n            res[it] = res.getOrDefault(it, 0) + i\n        }\n    }\n\n    return res.toString()\n        .replace(\"{}\", \"\")\n        .replace(\"{\", \"(\")\n        .replace(\"}\", \")\")\n        .replace(\"=\", \" \")\n        .replace(\", \", \")(\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205770,"user_id":null,"body":"import java.util.*\n\nfun sum_of_divided(input: IntArray) :String {\n  val factors = input.map{ n -> Pair(n, factor(n).toSet()) }\n  val primes = factors.flatMap{ p -> p.second }.toSet().sorted()\n  val result = mutableListOf<Pair<Int, Int>>()\n  for (p in primes) {\n      result.add(Pair(p, factors.filter{ e -> p in e.second}.map{ e -> e.first }.sum()))\n  }\n  return result.joinToString(\"\"){ p -> \"(${p.first} ${p.second})\" }\n}\n\nfun factor(n :Int) :List<Int> {\n    if (n==0)\n      return emptyList()\n    var r = if (n>0) n  else -n\n    var p = 2\n    val result = mutableListOf<Int>()\n    while (r>1) {\n        while (r%p==0) {\n            result.add(p)\n            r \/= p\n        }\n        p = if(p==2) 3  else p+2\n    }\n    return result\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205771,"user_id":null,"body":"import java.util.*\n\nfun sum_of_divided(l: IntArray): String {\n    if (l.isEmpty()) return \"\"\n\n    var result = \"\"\n    var map = HashMap<Int, Int>()\n    for (i in l) {\n        for (p in 2..i)\n            if(isPrime(p)) {\n                if (i % p == 0) {\n                    if (!map.containsKey(p)) map[p] = i\n                    else map[p] = map[p]!! + i\n                }\n            }\n    }\n    map.toSortedMap().forEach { (p, sum) -> result += \"($p $sum)\" }\n    return result\n}\n\nfun isPrime(x: Int) : Boolean {\n    if (x < 1) return false\n    if (x == 2 || x == 3) return true\n\n    for (i in 2 until x) {\n        if (x % i == 0) return false\n    }\n\n    return true\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205772,"user_id":null,"body":"import java.util.*\n\nval primes = PrimeSieve(100)\nclass PrimeSieve(max: Int): ArrayList<Int>(max) {\n  var max: Int = 2\n  init {\n    this.add(2)\n    update(max)\n  }\n  public fun update(max: Int) {\n    if(max <= this.max)\n      return\n    for(i in this.max+1..max step 2)\n      if(this.all{ i%it != 0 })\n        this.add(i)\n    this.max = max\n  }\n}\n\nfun absIndex(index: Int) = if(index < 0) -index.inc() else index\n\nfun sum_of_divided(l: IntArray): String {\n  if(l.isEmpty())\n    return \"\"\n  val max = l.max()!!\n  primes.update(max)\n  val endIndex = if(primes.max == max) primes.lastIndex else absIndex(primes.binarySearch(max))\n  return primes.subList(0, endIndex).map{ p -> Pair(p, l.sumBy{ if(it%p == 0) it else 0 }) }\n                                    .joinToString(\"\") { if(it.second == 0) \"\" else \"(${it.first} ${it.second})\"}\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205773,"user_id":null,"body":"fun sum_of_divided(l: IntArray): String {\n    return l.asSequence()\n        .fold(HashSet<Int>()) { factors, it ->\n            for (i in PrimeFactors.list) {\n                if (i > it) break\n                if (it % i == 0) factors.add(i)\n            }\n            factors\n        }\n        .sorted()\n        .joinToString(\"\") { factor ->\n            val sum = l.asSequence()\n                .filter { it % factor == 0 }\n                .sum()\n            \"($factor $sum)\"\n        }\n}\n\nobject PrimeFactors {\n    val list: IntArray\n\n    init {\n        val factors = ArrayList<Int>(1000)\n        factors.add(2)\n        var n = 1\n        while (factors.size < 1000) {\n            do {\n                n += 2\n            } while (!isPrime(n))\n            factors.add(n)\n        }\n        list = factors.toIntArray()\n    }\n\n    private fun isPrime(n: Int): Boolean {\n        val max = Math.sqrt(n.toDouble()).toInt() + 1\n        var i = 3\n        while (i < max) {\n            if (n % i == 0) {\n                return false\n            }\n            i += 2\n        }\n        return true\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205774,"user_id":null,"body":"import kotlin.math.sqrt\n\nfun isPrime(n: Int): Boolean =\n    (2..sqrt(n.toDouble()).toInt()).all { n % it != 0 }\n\nfun sum_of_divided(l: IntArray): String = when {\n    l.isEmpty() -> \"\"\n    else -> (2..l.max()!!).filter { i -> isPrime(i) && l.any { j -> j % i == 0 } }\n        .joinToString(\"\") { \"($it ${l.filter { i -> i % it == 0 }.sum()})\" }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205775,"user_id":null,"body":"import java.util.*\n\nfun sum_of_divided(l: IntArray): String {\n    val p = TreeSet<Int>()\n    p.add(2)\n    fun isPrime(x: Int) = p.takeWhile { it * it <= x }.all { x % it != 0 }\n    l.max()?.let {\n        for (i in 3..it step 2) {\n            if (isPrime(i)) p.add(i)\n        }\n    }\n    p.addAll(l.filter(::isPrime))\n\n    val m = TreeMap<Int, Int>()\n    l.forEach { e ->\n        p.filter { e % it == 0 }.forEach { x ->\n            m[x] = (m[x] ?: 0) + e\n        }\n    }\n    return m.map { \"(${it.key} ${it.value})\" }.joinToString(\"\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205776,"user_id":490,"body":"import java.util.*\n\nfun sum_of_divided(l: IntArray): String {\n\tval f = TreeMap<Int, Int>()\n\tfor (num in l) {\n\t\tvar x = num\n\t\tfor (d in 2..x) {\n\t\t\tif (x % d != 0) continue\n\t\t\twhile (x % d == 0) x \/= d\n\t\t\tval cnt = num + (f as Map<Int, Int>).getOrDefault(d, 0)\n\t\t\tf[d] = cnt\n\t\t}\n\t}\n\n\tval sb = StringBuilder()\n\tfor ((key, value) in f)\n\t\tsb.append(String.format(\"(%d %d)\", key, value))\n\treturn sb.toString()\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"54d512e62a5e54c96200019e":[{"id":205777,"user_id":null,"body":"package solution\n\nobject PrimeDecomp {\n    fun prime_factors(l: Int): String {\n        var n=l\n\t\tvar str=\"\"\n\t\tfor(i in 2..n)\n\t\t\t{\n\t\t\t\tvar c=0\n\t\t\t\twhile(n%i==0){c++; n\/=i\t}\n\t\t\t\tif(c>1) str+=\"(\"+i+\"**\"+c+\")\";\n\t\t\t\tif(c==1) str+=\"(\"+i+\")\";\n\t\t\t}\n\t\treturn str\n    }\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205778,"user_id":null,"body":"package solution\n\nobject PrimeDecomp {\n    fun prime_factors(l: Int) = buildString {\n    var cur = l\n    for (x in 2..cur) {\n        var count = 0\n        while (cur % x == 0) {count++;cur\/=x}\n        if(count>1) append(\"($x**$count)\")\n        if(count==1) append(\"($x)\")\n    }\n}\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205779,"user_id":null,"body":"package solution\n\nobject PrimeDecomp {\n    fun prime_factors(number: Int): String {\n        var remainder = number\n        var result = \"\"\n        var multiplier = 2\n\n        while (multiplier <= remainder) {\n            var lastMultiplierCount = 0\n            while (remainder % multiplier == 0) {\n                lastMultiplierCount++\n                remainder \/= multiplier\n            }\n            result += when (lastMultiplierCount) {\n                0 -> \"\"\n                1 -> \"($multiplier)\"\n                else -> \"($multiplier**$lastMultiplierCount)\"\n            }\n            multiplier++\n        }\n        return result\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205780,"user_id":null,"body":"package solution\n\nobject PrimeDecomp {\n    fun prime_factors(l: Int): String {\n        var n = 2\n        var decompedResult = l\n        val decompositions = mutableListOf<Int>()\n\n        while (decompedResult > 1) {\n            if (decompedResult % n == 0) {\n                decompositions.add(n)\n                decompedResult \/= n\n            } else {\n                n++\n            }\n        }\n\n        return decompositions.groupBy { it }\n            .asIterable()\n            .joinToString(\")(\", \"(\", \")\") { (p, n) ->\n                \"$p${if (n.size == 1) \"\" else \"**${n.size}\" }\"\n            }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205781,"user_id":null,"body":"package solution\n\nobject PrimeDecomp {\n    fun prime_factors(l: Int): String {\n        var counter: Int = 0\n        var digit: Int = l\n        var ret: String = \"\"\n        for (d in 2..(l\/2)) {\n            while (digit%d == 0) {\n                counter++\n                digit \/= d\n            }\n            if (counter > 0) {\n                val stars: String = if (counter > 1) \"**$counter\" else \"\"\n                ret += \"($d$stars)\"\n                counter = 0\n            }\n            if (d > digit) break\n        }\n        return ret\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205782,"user_id":null,"body":"package solution\n\nobject PrimeDecomp {\n    fun prime_factors(l: Int): String {\n        var start: Int = l\n        var result: String = \"\"\n        var divider: Int = 2\n        var count: Int = 0\n        while(start > 0){\n            if(start % divider == 0){\n                start = start \/ divider\n                count++\n            } else {\n                if(count > 1) result += \"($divider**$count)\"\n                if(count == 1) result += \"($divider)\"\n                if(start == 1) break \n                divider++\n                count = 0\n            }\n        }\n        return result\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205783,"user_id":null,"body":"package solution\n\nobject PrimeDecomp {\n    fun prime_factors(l: Int): String {\n    var str = \"\"\n    var howMuch: Int\n    var num = l\n    \n    for (i in 2..l) {\n        howMuch = 0\n        while (num % i == 0) {\n            num \/= i\n            howMuch++\n        }\n        str += if (howMuch == 1) \"($i)\" else if (howMuch != 0) \"($i**$howMuch)\" else \"\"\n        if (num == 1) return str\n    }\n    return str\n}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205784,"user_id":53,"body":"package solution\n\nobject PrimeDecomp {\n    fun prime_factors(l: Int): String {\n        val fs = arrayListOf<String>()\n        var i = 2\n        var n = l\n        while (i <= n) {\n            var cnt = 0\n            while (n % i == 0) {\n                n = n \/ i\n                cnt += 1\n            }\n            if (cnt == 1) {\n                fs.add(\"(${i})\")\n            } else if (cnt > 1) {\n                fs.add(\"(${i}**${cnt})\")\n            }\n            i += 1\n        }\n        if (fs.size == 0) {\n            return \"(${n})\"\n        } else {\n            return fs.joinToString(\"\")\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205785,"user_id":null,"body":"package solution\n\nobject PrimeDecomp {\n    fun prime_factors(l: Int): String {\n        val decomposed = mutableMapOf<Int, Int>()\n        var divisor = l\n        \n        for (factor in 2..l)  {\n            while (divisor % factor == 0) {\n                divisor = divisor \/ factor\n                decomposed[factor] = (decomposed[factor] ?: 0) + 1\n            }\n        }\n        \n        return decomposed\n            .entries\n            .sortedBy { it.key }\n            .map { \"(\" + (if (it.value == 1) \"${it.key}\" else \"${it.key}**${it.value}\") + \")\"}\n            .joinToString(\"\")\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205786,"user_id":null,"body":"package solution\n\nimport kotlin.math.pow\nimport kotlin.math.sqrt\n\nobject PrimeDecomp {\n    fun prime_factors(l: Int): String {\n        println(l)\n        val map: MutableMap<Int, Int> = mutableMapOf()\n        var number = l\n        var stage = 0\n        while(number % 2 == 0) {\n            stage++\n            number \/= 2\n        }\n        map[2] = stage\n        \n        val limit = sqrt(number.toDouble()).toInt() + 1\n        for (i in 3..limit step 2) {\n            stage = 0\n            while (number % i == 0) {  \n                stage++\n                number \/= i \n            }\n            map[i] = stage\n        }\n        \n        if (number > 1)\n            map[number] = 1\n\n        return map\n            .filter { it.value > 0 }\n            .map { if (it.value > 1) \"(${it.key}**${it.value})\" else \"(${it.key})\" }\n            .joinToString(\"\")\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"54d7660d2daf68c619000d95":[{"id":205787,"user_id":null,"body":"package solution\n\nobject Fracts {\n    \n    fun convert_frac(lst: Array<LongArray>): String {\n        val denoms = lst.map{ simplify(it) }.map{ it[1] }\n        \n        val ld = lcm(denoms.toLongArray())\n        \/\/ numerator = fract * least denom, denom = ld (obviously)\n        val commonFract = lst.map{ longArrayOf(((ld * it[0]) \/ it[1].toDouble()).toLong(), ld) }\n        return commonFract.fold(\"\"){ str, i -> str + \"(${i[0]},${i[1]})\" } \/\/ format\n    }\n    \n    \/\/ least common multiple --> ggt(a, b) * kgv(a, b) = |a * b|\n    fun lcm(numbers: LongArray): Long = numbers.fold(1L){ res, i -> i * res \/ gcd(i, res) }\n    \n    \/\/ greatest common divisor\n    tailrec fun gcd(a: Long, b: Long): Long = when (b) {\n        0L -> a\n        else -> gcd(b, a % b)\n    }\n    \n    \/\/ SIMPLIFY FIRST!!! lcm != lcd\n    fun simplify(fract: LongArray): LongArray {\n        val gcdenom = gcd(fract[0], fract[1])\n        return longArrayOf(fract[0] \/ gcdenom, fract[1] \/ gcdenom)\n    }\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205788,"user_id":null,"body":"package solution\n\nobject Fracts {  \n    fun gcd(a: Long, b: Long): Long = if (b == 0L) a else gcd(b, a % b)\n    fun convert_frac(lst0: Array<LongArray>): String {\n        val lst = lst0.map { (a, b) -> gcd(a, b).let { arrayOf(a\/it, b\/it) } }\n        val d = lst.map{it[1]}.fold(1L) { a, b -> (a \/ gcd(a, b)) * b }\n        return lst.map { (a, b) -> d \/ b * a }.joinToString (\"\") { n -> \"($n,$d)\" }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205789,"user_id":null,"body":"package solution\n\nimport kotlin.math.pow\nimport kotlin.math.sqrt\n\nobject Fracts {\n    fun convert_frac(lst: Array<LongArray>): String {\n        if (lst.isEmpty())\n            return \"\"\n        val lstReduced: Array<LongArray> = reduceFractions(lst)\n        val denominators = lstReduced.map { it[1] }\n        if (denominators.all { it == 1L })\n            return lst.joinToString(\"\") { String.format(\"(%d,%d)\", it[0], it[1]) }\n        val denomPrimeFactorsWithFrequency: Array<Map<Long, Int>> = Array(lstReduced.size) {\n            (getPrimeFactors(denominators[it]))\n        }\n        val denomMostFrequentPrimeFactors = getPrimeFactorsByFrequency(denomPrimeFactorsWithFrequency, Math::max)\n        val leastCommonDenominator =\n            denomMostFrequentPrimeFactors.map { it.key.toDouble().pow(it.value.toDouble()) }\n                .reduce { acc, next -> acc * next }.toLong()\n        return Array(lstReduced.size) {\n            val numerator = lstReduced[it][0]\n            val denominator = lstReduced[it][1]\n            val coefficient = leastCommonDenominator \/ denominator\n            longArrayOf(numerator * coefficient, leastCommonDenominator)\n        }.joinToString(\"\") { String.format(\"(%d,%d)\", it[0], it[1]) }\n    }\n\n    fun reduceFractions(fractions: Array<LongArray>): Array<LongArray> {\n        val reducedFractions = fractions.copyOf()\n        var index = 0\n        for ((numerator, denominator) in fractions) {\n            if (denominator == 1L) continue\n            val primeFactorsOfNum: Map<Long, Int> = getPrimeFactors(numerator)\n            val primeFactorsOfDen: Map<Long, Int> = getPrimeFactors(denominator)\n            val commonFactors = primeFactorsOfNum.keys.intersect(primeFactorsOfDen.keys)\n            if (commonFactors.isNotEmpty()) {\n                val lessFrequentFactors =\n                    getPrimeFactorsByFrequency(arrayOf(primeFactorsOfNum, primeFactorsOfDen), Math::min)\n                val coefficient = calcCoefficientOfReduction(lessFrequentFactors, commonFactors)\n                reducedFractions[index] = longArrayOf(numerator \/ coefficient, denominator \/ coefficient)\n            }\n            index++\n        }\n        return reducedFractions\n    }\n\n    fun calcCoefficientOfReduction(lessFrequentFactors: Map<Long, Int>, commonFactors: Set<Long>): Long {\n        return commonFactors.map { commonFactor ->\n            val frequency = lessFrequentFactors.getOrDefault(commonFactor, 1).toDouble()\n            commonFactor.toDouble().pow(frequency)\n        }.reduce { acc, next -> acc * next }.toLong()\n    }\n\n    fun getPrimeFactorsByFrequency(primeFactors: Array<Map<Long, Int>>, op: (Int, Int) -> Int): Map<Long, Int> {\n        val resFactors = mutableMapOf<Long, Int>()\n        primeFactors.flatMap { it.entries }\n            .forEach() { resFactors[it.key] = op(it.value, resFactors.getOrPut(it.key) { it.value }) }\n        return resFactors\n    }\n\n    fun getPrimeFactors(number: Long): Map<Long, Int> {\n        val sqrt = sqrt(number.toDouble())\n        var currentValue = number\n        var multiplier = 2L\n        val listOfPrimeFactors = mutableListOf<Long>()\n        while (currentValue > 1 && multiplier <= sqrt) {\n            if (currentValue % multiplier == 0L) {\n                listOfPrimeFactors.add(multiplier)\n                currentValue \/= multiplier\n            } else if (multiplier == 2L) {\n                multiplier++\n            } else {\n                multiplier += 2\n            }\n        }\n        if (currentValue != 1L) {\n            listOfPrimeFactors.add(currentValue)\n        }\n        return listOfPrimeFactors.groupBy { it }.mapValues { it.value.count() }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205790,"user_id":null,"body":"package solution\n\nobject Fracts {\n    \n    fun convert_frac(lst: Array<LongArray>): String {\n    val denom = lst.map{it.last()}\n    var lcm = 1L\n    \n    while (true) {        \n        val comp = lst.map{\n            it.first() * lcm % it.last() == 0L\n        }\n\n        if(comp.all{it}) break\n        lcm++\n    }\n    \n\treturn lst.map{longArrayOf(it.first() * lcm \/ it.last(),lcm).joinToString(\",\",\"(\",\")\")}.joinToString(\"\")\n}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205791,"user_id":null,"body":"package solution\n\nobject Fracts {\n    \n    fun convert_frac(lst: Array<LongArray>): String {\n        val reducedList = lst.map { frac ->\n            val gcd = gcd(frac[0], frac[1])\n            longArrayOf(frac[0] \/ gcd, frac[1] \/ gcd)\n        }\n\n        var common = 1L\n        reducedList.forEach { frac ->\n            val gcd = gcd(common, frac[1])\n            common = common \/ gcd * frac[1]\n        }\n\n        return buildString {\n            reducedList.forEach { frac ->\n                append(\"(${common \/ frac[1] * frac[0]},${common})\")\n            }\n        }\n    }\n\n    fun gcd(a: Long, b: Long): Long {\n        return if (b == 0L) {\n            a\n        } else {\n            gcd(b, a % b)\n        }\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205792,"user_id":null,"body":"\nobject Fracts {\n\n    fun convert_frac(rationals: Array<LongArray>): String {\n        return format(convertRationals(rationals).toList())\n    }\n\n    fun convertRationals(rationals: Array<LongArray>): Array<LongArray> {\n        if (rationals.isEmpty()) return arrayOf()\n        val simplifiedInputRationals = rationals.map { simplify(it) }\n        val rationalsWithCommonDenominator = convertDenominatorsToTheirLcm(simplifiedInputRationals)\n        val simplifiedRationals = simplifyWhileKeepingDenominatorsEqual(rationalsWithCommonDenominator)\n        return simplifiedRationals.toTypedArray()\n    }\n\n    fun rational(nominator: Long, denominator: Long) = longArrayOf(nominator, denominator)\n    fun nom(rational: LongArray) = rational[0]\n    fun denom(rational: LongArray) = rational[1]\n\n    fun simplify(rational: LongArray): LongArray {\n        val gcd = greatestCommonDivisor(nom(rational), denom(rational))\n        return rational(nom(rational) \/ gcd, denom(rational) \/ gcd)\n    }\n\n    private fun convertDenominatorsToTheirLcm(rationals: List<LongArray>): List<LongArray> {\n        val denominators = rationals.map { rational -> denom(rational) }\n        val lcmOfDenominators = leastCommonMultiple(denominators)\n        return rationals.map { rational ->\n            convertDenominatorTo(rational, lcmOfDenominators)\n        }\n    }\n\n    \/\/ Fact: gcd(a, b, c) = gcd(gcd(a, b), c)\n    \/\/ Reference: https:\/\/en.wikipedia.org\/wiki\/Euclidean_algorithm#Background:_greatest_common_divisor\n    \/\/ Fact: lcm(a, b, c) = lcm(lcm(a, b), c)\n    \/\/ Reference: https:\/\/en.wikipedia.org\/wiki\/Least_common_multiple#Lattice-theoretic (duality, applied to above)\n    \/\/ Fact: gcd(a, b) * lcm(a, b) = |a\u22c5b|\n    \/\/ Reference: https:\/\/en.wikipedia.org\/wiki\/Greatest_common_divisor#Properties\n    fun leastCommonMultiple(numbers: List<Long>): Long =\n        numbers.reduce { lcm, number ->\n            lcm * (number \/ greatestCommonDivisor(lcm, number))\n        }\n\n    \/\/ Fact: gcd(a, b, c) = gcd(gcd(a, b), c)\n    \/\/ Reference: https:\/\/en.wikipedia.org\/wiki\/Euclidean_algorithm#Background:_greatest_common_divisor\n    private fun greatestCommonDivisor(numbers: List<Long>): Long =\n        numbers.reduce { gcd, number ->\n            greatestCommonDivisor(gcd, number)\n        }\n\n    \/\/ Euclidean algorithm\n    \/\/ References:\n    \/\/ - https:\/\/en.wikipedia.org\/wiki\/Euclidean_algorithm#Implementations (recursive version)\n    tailrec fun greatestCommonDivisor(a: Long, b: Long): Long {\n        assert(a >= 0 && b >= 0)\n        return if (b == 0L)\n            a\n        else\n            greatestCommonDivisor(b, a % b)\n    }\n\n    private fun convertDenominatorTo(rational: LongArray, denominator: Long): LongArray {\n        assert(denominator % denom(rational) == 0L)\n        return rational(nom(rational) * (denominator \/ denom(rational)), denominator)\n    }\n\n    fun simplifyWhileKeepingDenominatorsEqual(rationals: List<LongArray>): List<LongArray> {\n        val gcd = greatestCommonDivisor(rationals.flatMap { rational -> listOf(nom(rational), denom(rational)) })\n        return rationals.map { rational(nom(it) \/ gcd, denom(it) \/ gcd) }\n    }\n\n    fun format(rationals: List<LongArray>) =\n        rationals.fold(\"\") { result, rational ->\n            result + format(rational)\n        }\n\n    fun format(rational: LongArray) = \"(${nom(rational)},${denom(rational)})\"\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205793,"user_id":null,"body":"package solution\n\nimport java.math.BigInteger\n\nobject Fracts {\n\n    fun convert_frac(lst: Array<LongArray>): String {\n        if(lst.isEmpty()) return \"\"\n      val reduced = lst.map{\n            listOf(\n            it[0].toBigInteger()\/it[0].toBigInteger().gcd(it[1].toBigInteger()),\n            it[1].toBigInteger()\/it[0].toBigInteger().gcd(it[1].toBigInteger())\n            )\n        }\n        val denom = reduced.map{it[1]}.reduce{result,it->result*it\/(result.gcd(it))}\n        var ret =\"\"\n        reduced.forEach{\n            ret+=\"(${it[0]*denom\/it[1]},$denom)\"\n        }\n        return ret\n\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205794,"user_id":null,"body":"package solution\n\nobject Fracts {\n    \n    fun convert_frac(lst: Array<LongArray>): String {\n    var arr = lst\n    var ele = mutableListOf<Long>()\n    for (i in arr.indices) {\n        arr[i] = reduceFraction(arr[i][0], arr[i][1])\n        ele.add(arr[i][1])\n    }\n    val lcm = lcm_of_array_elements(ele.toLongArray())\n    for (i in arr.indices) {\n         var ratio = arr[i][1] \/ arr[i][0].toDouble()\n        arr[i][0] = (lcm \/ ratio).toLong()\n        arr[i][1] = lcm\n    }\n     return arr.joinToString(separator = \"\") {\n        it.joinToString(prefix = \"(\", postfix = \")\", separator = \",\")\n    }\n}\n\nfun reduceFraction(x: Long, y: Long): LongArray{\n    var x = x\n    var y = y\n    val d: Long = gcd(x, y)\n    x \/= d\n    y \/= d\n    return longArrayOf(x , y)\n}\n\nfun gcd(a: Long, b: Long): Long {\n    return if (b == 0L) a else gcd(b, a % b)\n}\n\nfun lcm_of_array_elements(element_array: LongArray): Long {\n    var lcm_of_array_elements: Long = 1\n    var divisor = 2\n    while (true) {\n        var counter = 0\n        var divisible = false\n        for (i in element_array.indices) {\n\n            if (element_array[i] == 0L) {\n                return 0\n           }\n            if (element_array[i] == 1L) {\n                counter++\n            }\n\n            if (element_array[i] % divisor == 0L) {\n                divisible = true\n                element_array[i] = element_array[i] \/ divisor\n            }\n        }\n\n        if (divisible) {\n            lcm_of_array_elements = lcm_of_array_elements * divisor\n        } else {\n            divisor++\n        }\n        \n        if (counter == element_array.size) {\n            return lcm_of_array_elements\n        }\n    }\n}\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205795,"user_id":null,"body":"package solution\n\nobject Fracts {\n    fun gcd(m: Long, n: Long):Long {\n        if (m==0L) return n\n        if (n==0L) return m\n        fun inner(m: Long, n: Long):Long {\n            val r = m % n\n            if (r==0L) return n\n            return inner(n, r)\n        }\n        return inner(m, n)\n    }\n    \n    fun convert_frac(lst: Array<LongArray>): String {\n        val simplified = lst.map() { frac -> frac.map { it \/ gcd(frac[0], frac[1])} } \n        val total = simplified.map() {it[1]}.fold(1L) {acc, b -> acc \/ gcd(acc, b) * b}\n        val ans = simplified.map() { frac -> frac.map { it * total \/ frac[1]}}\n        var output = \"\"\n        for (frac in ans) output += \"(${frac[0]},${frac[1]})\"\n        return output\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205796,"user_id":null,"body":"package solution\n\nobject Fracts {\n    \n    fun convert_frac(lst: Array<LongArray>): String {\n        if (lst.isEmpty()) return \"\"\n        val reducedFracts = lst.map { reduceFract(it[0], it[1]) }\n        val dens = reducedFracts.map { it[1] }.map { reduceToPrimes(it) }        \n        val commonDen = dens.reduce { acc, l -> merge(acc, l).sorted() }.reduce { acc, i -> acc * i }\n        val result = reducedFracts.map {\n            val r = commonDen \/ it[1]\n            \"(${it[0] * r},$commonDen)\"\n        }.joinToString(\"\")\n        println(result)\n        return result\n    }\n    \n    fun reduceFract(num: Long, den: Long): LongArray {        \n        val numPrimes = reduceToPrimes(num)\n        val denPrimes = reduceToPrimes(den)\n        val reducedNum = mergeOnlyCommons(numPrimes, denPrimes).reduce { acc, i -> acc * i }\n        val reducedDen = mergeOnlyCommons(denPrimes, numPrimes).reduce { acc, i -> acc * i }\n        \n        println(\"Reduced fract $num\/$den to $reducedNum\/$reducedDen\")\n        return longArrayOf(reducedNum, reducedDen)        \n    }\n    \n    fun mergeOnlyCommons(lst1: List<Long>, lst2: List<Long>): List<Long> {\n        var copyLst2 = lst2.toMutableList()\n        val result = mutableListOf<Long>(1L)\n        for (i in lst1) {\n            if (i in copyLst2) {                \n                val indx = copyLst2.indexOf(i)\n                if (indx >= 0L) {\n                    copyLst2.removeAt(indx)\n                }\n            }\n            else {\n                result.add(i)\n            }\n        }\n        return result\n    }\n    \n    fun merge(lst1: List<Long>, lst2: List<Long>): List<Long> {\n        var copyLst2 = lst2.toMutableList()\n        val result = mutableListOf<Long>()\n        for (i in lst1) {\n            result.add(i)\n            val indx = copyLst2.indexOf(i)\n            if (indx >= 0L) {\n                copyLst2.removeAt(indx)\n            }\n        }\n        return result + copyLst2\n    }\n    \n    fun reduceToPrimes(num: Long): List<Long> {\n        if (num < 2) return listOf(num)\n        var c = 2\n        \n        while (num >= c) {\n            if (num % c == 0L) {\n                return listOf(c.toLong()) + reduceToPrimes(num \/ c)\n            } else {\n                c += 1\n            }\n        }\n        throw RuntimeException(\"Shouldn't reach this\")\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"54db15b003e88a6a480000b9":[{"id":205797,"user_id":null,"body":"package solution\n\nobject ModSystem {\n    fun fromNb2Str(n: Int, sys: IntArray): String {\n        var multiply = 1\n        var even = 0\n        \n        for (item in sys.indices) {\n            multiply *= sys[item]\n        }\n        \n        for (item in sys) {\n            if (item % 2 == 0) {\n                even += 1\n            }\n        }\n        \n        return when {\n            multiply <= n -> \"Not applicable\"\n            even > 1 -> \"Not applicable\"\n            else -> sys.map { n % it}.joinToString(\n                        prefix = \"-\",\n                        postfix = \"-\",\n                        separator = \"--\"\n            )\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205798,"user_id":null,"body":"package solution\n\nobject ModSystem {\n    fun fromNb2Str(n: Int, sys: IntArray) = \n        if(sys.reduce{acc, i -> acc * i } < n || !isCoPrime(sys)) \"Not applicable\"\n        else sys.joinToString(\"--\",\"-\", \"-\") { (n % it).toString() }\n\n    fun isCoPrime(sys: IntArray): Boolean {\n        for ( i in sys.indices){\n            for ( j in (i+1)..sys.lastIndex){\n                if ( (2..sys[j]).filter { sys[j] % it == 0}.any { sys[i] % it == 0})\n                    return false\n            }\n        }\n        return true\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205799,"user_id":null,"body":"package solution\nimport java.math.BigInteger\n\nobject ModSystem {\n    \n    fun fromNb2Str(n: Int, sys: IntArray): String {\n        if (sys.reduce { acc, i -> acc * i } <= n) return \"Not applicable\"\n        sys.forEachIndexed { index, a -> sys.drop(index + 1).forEach { b ->\n                if (a.toBigInteger().gcd(b.toBigInteger()) > BigInteger.ONE) return \"Not applicable\"\n        } }\n        return sys.joinToString(\"\") { \"-${n % it}-\" }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205800,"user_id":null,"body":"package solution\n\nobject ModSystem {\n   \n    fun fromNb2Str(n: Int, sys: IntArray): String {\n        val u = sys.any { o -> (sys.any { i -> o != i && gcd(o, i) > 1 }) }\n        val x = sys.reduce { acc, i -> acc * i }\n        return if (u || x <= n)\n            \"Not applicable\"\n        else\n            sys.joinToString(separator = \"\") { \"-${n % it}-\" }\n    }\n\n    private fun gcd(x: Int, y: Int): Int = if (y == 0) x else gcd(y, x % y)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205801,"user_id":null,"body":"package solution\n\nobject ModSystem {\n    \n    fun fromNb2Str(n: Int, sys: IntArray): String {\n        val sum = sys.reduce { acc, i -> acc * i }\n\n        if (sum <= n) {\n            return \"Not applicable\"\n        }\n\n        for (i in 0..sys.lastIndex) {\n            for (j in i + 1 .. sys.lastIndex) {\n                if (gcd(sys[i], sys[j]) != 1) {\n                    return \"Not applicable\"\n                }\n            }\n        }\n\n        return \"-${sys.joinToString(\"--\") { \"${n % it}\" }}-\"\n    }\n    \n    fun gcd(a: Int, b: Int): Int {\n        return if (b == 0) a\n        else gcd(b, a % b)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205802,"user_id":null,"body":"package solution\n\nimport java.math.BigInteger\n\nobject ModSystem {\n    \nprivate val two = BigInteger.valueOf(2)\n\n    fun fromNb2Str(n: Int, sys: IntArray): String {\n        val primes = mutableSetOf<Int>()\n        if (sys.any { it.hasCommonPrimes(primes) } ||\n            sys.fold(1) {acc, i -> acc * i } < n) {\n            return \"Not applicable\"\n        }\n        return sys.map { n % it }.joinToString (separator = \"\") { \"-$it-\" }\n    }\n\n    private fun containsOrAdd(count : Int, prime : Int, primes: MutableSet<Int>) : Boolean {\n        if (count > 0) {\n            if (primes.contains(prime)) {\n                return true\n            } else {\n                primes.add(prime)\n            }\n        }\n        return false\n    }\n\n    fun Int.hasCommonPrimes(primes: MutableSet<Int>) : Boolean {\n        var count = 0\n        var mod = this.toBigInteger()\n        while (mod.and(BigInteger.ONE) == BigInteger.ZERO) {\n            count++\n            mod = mod.shiftRight(1)\n        }\n\n        if (containsOrAdd(count, 2, primes)) return true\n\n        count = 0\n        var i = BigInteger.valueOf(3)\n        while (i < mod) {\n            if (i.isProbablePrime(5)) {\n                val divRem: Array<BigInteger> = mod.divideAndRemainder(i)\n                if (divRem[1] == BigInteger.ZERO) {\n                    count++\n                    mod = divRem[0]\n                } else {\n                    if (containsOrAdd(count, i.toInt(), primes)) return true\n                    i = i.add(two)\n                    count = 0\n                }\n            } else {\n                i = i.add(two)\n            }\n        }\n\n        return false\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205803,"user_id":932,"body":"package solution\n\nobject ModSystem {\n    \n    fun fromNb2Str(n: Int, sys: IntArray): String {\n        if (sys.reduce { acc, i ->  acc*i} < n) return \"Not applicable\"\n        sys.indices.forEach{ i->\n            sys.drop(i+1).forEach { a->\n                if (sys[i] gcd  a > 1) return \"Not applicable\"\n            }\n        }\n        return sys.map{n % it}.joinToString(\"\"){\"-$it-\"}\n    }\n    \n    private infix fun Int.gcd(int: Int): Int{\n        return if (this > int)  int.gcd(this - int)\n        else if (this < int)  int.gcd(int - this)\n        else this\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205804,"user_id":null,"body":"package solution\n\nobject ModSystem {\n    \n    fun fromNb2Str(n: Int, sys: IntArray): String {\n        var multipliedSys = sys.reduce { acc, k -> acc * k }\n        if (multipliedSys <= n) {\n            return \"Not applicable\"\n        }\n        \n        var arePairwiseCoPrime = true\n        for (k in 0 until sys.size) {\n            for (j in (k + 1) until sys.size) {\n                if (!checkIfPairwiseCoPrime(sys[k], sys[j])) {\n                    arePairwiseCoPrime = false\n                    break\n                }\n            }\n        }\n        \n        if (!arePairwiseCoPrime) {\n            return \"Not applicable\"\n        }\n        \n        val representedString = sys.map { n % it }.joinToString(\"--\")\n        return \"-$representedString-\"\n    }\n    \n    fun checkIfPairwiseCoPrime(n1: Int, n2: Int): Boolean {\n        val max: Int\n        val min: Int\n        if (n1 > n2) {\n            max = n1\n            min = n2\n        } else {\n            max = n2\n            min = n1\n        }\n        \n        for (k in 2 .. (max \/ 2)) {\n            if (max % k == 0 && min % k == 0) {\n                return false\n            }\n        }\n        \n        return true\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205805,"user_id":null,"body":"package solution\n\nobject ModSystem {\n\n    fun fromNb2Str(n: Int, sys: IntArray): String {\n        \/\/ your code\n        val multi = sys.reduce { acc, i -> acc * i }\n        if (multi < n) {\n            return \"Not applicable\"\n        }\n\n        for (i in sys.indices) {\n            for (j in i + 1 until sys.size) {\n                if (gcd(sys[i], sys[j]) > 1) {\n                    return \"Not applicable\"\n                }\n            }\n        }\n        \n        return sys.map { n % it }.joinToString(\"\") { \"-$it-\" }\n    }\n}\n\nfun gcd(a: Int, b: Int): Int {\n    if (b != 0) {\n        return gcd(b, a % b)\n    }\n    return a\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205806,"user_id":null,"body":"package solution\n\nobject ModSystem {\n    \n    fun fromNb2Str(n: Int, sys: IntArray): String {\n    if (!isApplicable(n, sys)) return \"Not applicable\"\n    var result = \"\"\n    return sys.map { \"-${n % it}-\" }.joinToString(\"\")\n}\n\nfun isApplicable(n: Int, sys: IntArray): Boolean {\n    if (sys.reduce { a, b -> a * b } < n) return false\n    for (divider in 2..sys.maxOrNull()!!) {\n        if (sys.count { it % divider == 0 } > 1) return false\n    }\n    return true\n}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"54dc6f5a224c26032800005c":[{"id":205807,"user_id":null,"body":"package solution\n\nobject StockList {\n    fun stock_list(lstOfArt: Array<String>, lstOfCat: Array<String>): String {\n        if (lstOfArt.isEmpty()) return \"\"\n        val counts = lstOfArt.groupingBy { it.take(1) }.fold(0) { acc, s -> acc + s.split(\" \")[1].toInt() }\n        return lstOfCat.joinToString(\" - \") { \"($it : ${counts.getOrDefault(it, 0)})\" }\n    }\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205808,"user_id":null,"body":"package solution\n\nobject StockList {\n    fun stock_list(lstOfArt: Array<String>, lstOfCat: Array<String>): String {\n        \/\/ your code\n        if (lstOfArt.isEmpty() || lstOfCat.isEmpty()) return \"\"\n\n        val map = lstOfCat.associate { it to 0 }.toMutableMap()\n        lstOfArt.forEach {\n            val firstLetter = it[0].toString()\n            if(map.containsKey(firstLetter))\n                map[firstLetter] = map[firstLetter]?.plus(it.split(\" \")[1].toInt())!!\n        }\n\n        val resString = StringBuilder()\n        map.forEach { (k, v) -> resString.append(\"($k : $v) - \")  }\n        return resString.toString().dropLast(3)\n    }\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205809,"user_id":null,"body":"package solution\n\nobject StockList {\n       fun stock_list(lstOfArt: Array<String>, lstOfCat: Array<String>) =  if(lstOfCat.isEmpty() || lstOfArt.isEmpty()) \"\" else lstOfCat.joinToString(\" - \") { category ->\n            val sum = lstOfArt.filter {\n                it.startsWith(category)\n            }.map {\n                it.split(\" \")[1].toInt()\n            }.sum()\n            \"($category : $sum)\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205810,"user_id":null,"body":"package solution\n\nobject StockList {\n fun stock_list(lstOfArt: Array<String>, lstOfCat: Array<String>): String {\n     if(lstOfArt.size <1 || lstOfCat.size <1) return \"\"\n    val map = mutableMapOf<Char,Int>()\n    val result = StringBuilder()\n    for(i in lstOfArt){\n        val(a,b) = i.split(\" \")\n     map[a[0]] = if(map[a[0]] == null) b.toInt() else map[a[0]]!! +b.toInt()\n    }\n    for(i in lstOfCat)\n        result.append(\"($i : ${map[i[0]]?:0}) - \")\n      return result.substring(0 until result.length-2).trim()\n}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205811,"user_id":null,"body":"package solution\n\nobject StockList {\n    fun stock_list(lstOfArt: Array<String>, lstOfCat: Array<String>): String {\n        if(lstOfArt.isEmpty() || lstOfCat.isEmpty()) return \"\"\n        val map = mutableMapOf<String,Int>()\n        for(art in lstOfArt){\n            val arrArt = art.split(\" \")\n            val cat = arrArt[0].first().toString()\n            map[cat] = (map[cat] ?: 0) + arrArt[1].toInt()\n        }\n        val result = arrayListOf<String>()\n        for(cat in lstOfCat){\n            result.add(\"($cat : ${map.getOrDefault(cat, 0)})\")\n        }\n        return result.joinToString(\" - \")\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205812,"user_id":492,"body":"package solution\n\nobject StockList {\n    fun stock_list(lstOfArt: Array<String>, lstOf1stLetter: Array<String>): String {\n        if (lstOfArt.isEmpty()) {\n            return \"\"\n        }\n        var result = \"\"\n        for (m in lstOf1stLetter) {\n            var tot = 0\n            for (l in lstOfArt) {\n                if (l[0] == m[0])\n                    tot += l.split(\" \".toRegex()).toTypedArray()[1].toInt()\n            }\n            if (!result.isEmpty())\n                result += \" - \"\n            result += \"($m : $tot)\"\n        }\n        return result\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205813,"user_id":null,"body":"package solution\n\nobject StockList {\n    fun stock_list(lstOfArt: Array<String>, lstOfCat: Array<String>): String {\n        return lstOfCat.takeIf { lstOfCat.isNotEmpty() && lstOfArt.isNotEmpty() }?.joinToString(\" - \") { category ->\n            \"($category : ${lstOfArt.filter { it.startsWith(category) }.fold(0) { sum, element -> sum + element.split(\" \")[1].toInt() }})\"\n        } ?: \"\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205814,"user_id":null,"body":"package solution\n\nobject StockList {\n    fun stock_list(lstOfArt: Array<String>, lstOfCat: Array<String>): String {\n        if (lstOfArt.isEmpty() || lstOfCat.isEmpty()) return \"\"\n        val repository = lstOfArt.groupBy({ stock -> stock[0].toString() }, { stock -> stock.split(\" \")[1].toInt() })\n        return lstOfCat.joinToString(\" - \") { category -> \"($category : ${repository[category]?.sum() ?: 0})\" }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205815,"user_id":null,"body":"package solution\n\nobject StockList {\n    fun stock_list(lstOfArt: Array<String>, lstOfCat: Array<String>): String {\n        var result: String = \"\"\n        if(lstOfArt.size != 0 && lstOfCat.size != 0){\n            for(cat in lstOfCat) {\n                 var quantity: Int = lstOfArt.sumOf { if(it.startsWith(cat)) it.split(' ')[1].toInt() else 0}\n                result += \"($cat : ${quantity}) - \"\n            }\n        }\n        return result.trimEnd(' ').trimEnd('-').trimEnd(' ')\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205816,"user_id":null,"body":"package solution\n\nobject StockList {\n    fun stock_list(lstOfArt: Array<String>, lstOfCat: Array<String>): String {\n        if(lstOfCat.isEmpty() or lstOfArt.isEmpty()) return \"\"\n        return lstOfCat.joinToString(separator = \" - \") {cat -> \"($cat : ${lstOfArt.filter{it.first() == cat.first()}.sumOf{it.takeLastWhile{it.isDigit()}.toInt()}})\"}\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"54de3257f565801d96001200":[{"id":205817,"user_id":null,"body":"package solution\n\nobject OrdersSummary {\n    fun balanceStatements(lst: String): String {\n        val malformed = mutableListOf<String>()\n        val bs = mutableMapOf(\"B\" to 0.0, \"S\" to 0.0)\n        lst.split(Regex(\",\\\\s*\"))\n            .filter { it.isNotEmpty() }\n            .forEach {\n                Regex(\"\\\\S+ ([0-9]+) ([0-9]+\\\\.[0-9]*) (B|S)\").matchEntire(it).run {\n                    if (this != null) {\n                        destructured.let { (n, p, t) -> bs[t] = bs.getOrDefault(t, 0.0) + n.toInt() * p.toDouble() }\n                    } else {\n                        malformed += it\n                    }\n                }\n            }\n        return \"Buy: %.0f Sell: %.0f\".format(bs[\"B\"], bs[\"S\"]) + malformed\n            .run { if (isNotEmpty()) joinToString(\" ;\", \"; Badly formed $size: \", \" ;\") else \"\" }\n    }\n}\n\n\/\/ object OrdersSummary {\n\/\/     fun balanceStatements(lst: String): String {\n\/\/         val malformed = mutableListOf<String>()\n\/\/         var b = 0.0\n\/\/         var s = 0.0\n\/\/         lst.split(Regex(\", ?\"))\n\/\/             .forEach {\n\/\/                 val match = Regex(\"\\\\S+ ([0-9]+) ([0-9]+\\\\.[0-9]*) (B|S)\").matchEntire(it.trim())\n\/\/                 if (match != null) {\n\/\/                     val (n, p, t) = match.destructured\n\/\/                     when (t) {\n\/\/                         \"B\" -> b += n.toInt() * p.toDouble()\n\/\/                         \"S\" -> s += n.toInt() * p.toDouble()\n\/\/                     }\n\/\/                 } else {\n\/\/                     if (it.trim().isNotBlank()) malformed += it.trim()\n\/\/                 }\n\/\/             }\n\/\/         return \"Buy: %.0f Sell: %.0f\".format(b, s) +\n\/\/                 if (malformed.isNotEmpty()) {\n\/\/                     malformed.run { joinToString(\" ;\", \"; Badly formed $size: \", \" ;\") { it } }\n\/\/                 } else \"\"\n\/\/     }\n\/\/ }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205818,"user_id":null,"body":"package solution\n\nobject OrdersSummary {\n    fun balanceStatements(lst: String): String {\n        \n        if (lst.isBlank()) return \"Buy: 0 Sell: 0\"\n        \n        var bad = mutableListOf<String>()\n        var b = 0.0\n        var s = 0.0\n        \n        for (order in lst.split(\", \")) {\n            val match = \"^([^\\\\s]+)\\\\s(\\\\d+)\\\\s(\\\\d+\\\\.\\\\d+)\\\\s([BS])$\".toRegex().find(order)\n            \n            if (match == null) bad.add(order + \" ;\")\n            else {\n                var (m, quote, quantity, price, t) = match.groupValues\n                val p = quantity.toInt() * price.toDouble()\n                if (t == \"B\") b += p else if (t == \"S\") s += p\n            }\n        }\n        val bf = if (bad.isEmpty()) \"\" else \"; Badly formed ${bad.size}: ${bad.joinToString(\"\")}\"\n        return String.format(\"Buy: %.0f Sell: %.0f%s\", b, s, bf)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205819,"user_id":null,"body":"package solution\nimport kotlin.math.roundToInt\n\nobject OrdersSummary {\n    fun balanceStatements(lst: String): String {\n        val orders = lst.split(\", \").map { it.split(\" \") }.toMutableList()\n        orders.removeAll { it.contains(\"\")}\n        val badlyFormatted = orders.filter { (it.size != 4)}.toMutableList()\n        orders.removeAll(badlyFormatted)\n        badlyFormatted.addAll(orders.filter { it[1].contains(\".\") or it[2].contains(\".\").not() or (it[3] != \"S\" && it[3] != \"B\") })\n        orders.removeAll(badlyFormatted)\n        val buySum = orders.filter { it[3] == \"B\" }.map { (it[1].toInt() * it[2].toDouble()) }.sum().roundToInt()\n        val sellSum = orders.filter { it[3] == \"S\" }.map { (it[1].toInt() * it[2].toDouble()) }.sum().roundToInt()\n        val basic = \"Buy: $buySum Sell: $sellSum\"\n        val bf = \"; Badly formed ${badlyFormatted.size}: \" + badlyFormatted.map { it.joinToString(\" \") + \" ;\" }.joinToString(\"\")\n        return if (badlyFormatted.isEmpty()) basic else basic + bf\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205820,"user_id":492,"body":"package solution\n\nimport java.util.*\nimport java.util.regex.Pattern\nimport kotlin.math.roundToInt\n\nobject OrdersSummary {\n    fun balanceStatements(lst: String): String {\n        val orders = lst.split(\", \".toRegex()).toTypedArray()\n        val badlyformed = ArrayList<String>()\n        var buytotal = 0.0\n        var selltotal = 0.0\n        val orderpat = Pattern.compile(\"^\\\\S+ (\\\\d+) (\\\\d*\\\\.\\\\d+) ([BS])$\")\n        for (order in orders) {\n            if (order.isEmpty())\n                continue\n            val mtch = orderpat.matcher(order)\n            if (mtch.matches()) {\n                val price = mtch.group(1).toInt() * mtch.group(2).toDouble()\n                if (\"B\" == mtch.group(3)) {\n                    buytotal += price\n                } else {\n                    selltotal += price\n                }\n            } else {\n                badlyformed.add(order)\n            }\n        }\n        return (\"Buy: \" + buytotal.roundToInt() + \" Sell: \" + selltotal.roundToInt()\n                + if (badlyformed.size > 0) \"; Badly formed \" + badlyformed.size + \": \" + java.lang.String.join(\" ;\", badlyformed) + \" ;\"\n                  else \"\")\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205821,"user_id":932,"body":"package solution\n\nobject OrdersSummary {\nfun balanceStatements(string: String)=string.split(Regex(\"\"\",\\s*\"\"\")).map{str->\n    Regex(\"\"\"^([^\\s]+)\\s+(\\d+)\\s+(\\d+\\.\\d+)\\s+(S|B)$\"\"\").find(str)?.let{\n        arrayOf(true, it.groupValues[2].toInt()*it.groupValues[3].toDouble(), it.groupValues[4])\n    }?:arrayOf(false, str)\n}.let{\n    var result = \"Buy: %1.0f\".format(it.filter{it[0]==true && it[2].toString()==\"B\"}.map{it[1].toString().toDouble()}.sum())\n    result += \" Sell: %1.0f\".format(it.filter{it[0]==true && it[2].toString()==\"S\"}.map{it[1].toString().toDouble()}.sum())\n    it.filter {it[0]==false && it.last().toString().isNotEmpty()}.map{it.last().toString()+\" ;\"}.let{\n        if (it.size>0) result += \"; Badly formed ${it.size}: ${it.joinToString(\"\")}\"\n    }\n    result\n}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205822,"user_id":null,"body":"package solution\n\nimport kotlin.math.roundToInt    \n\nobject OrdersSummary {\n    fun balanceStatements(lst: String): String {\n        \n        if (lst.length == 0) return \"Buy: 0 Sell: 0\"\n    \t\n        var result: String\n        var instructions = lst.split(\",\").map() {it -> it.trim(' ').split(\" \").toList()}\n        var buy: Double = 0.0\n        var sell: Double = 0.0\n        var badly = mutableListOf<String>()\n        \n        instructions.forEach {\n           if (it.size != 4 || it[1].toIntOrNull() == null || it[2].toDoubleOrNull() == null || !it[2].contains(\".\")) {\n               badly.add(it.joinToString(\" \"))               \n           } else {\n                if (it[3] == \"B\") {\n                    buy += it[1].toDouble() * it[2].toDouble()\n                } else if (it[3] == \"S\") {\n                    sell += it[1].toDouble() * it[2].toDouble()\n                } else {\n               badly.add(it.joinToString(\" \"))\n               }\n           }\n        }\n        \n        result = \"Buy: \" + buy.roundToInt() + \" Sell: \" + (sell).roundToInt()\n        if (badly.size > 0) {\n            result += \"; Badly formed \" + badly.size + \": \" + badly.joinToString(\" ;\") + \" ;\"\n        }\n        return result\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205823,"user_id":null,"body":"package solution\nimport kotlin.math.roundToInt\n\nobject OrdersSummary {\n    fun balanceStatements(lst: String): String {\n        var bought = 0.0\n        var sold = 0.0\n        val typos = mutableListOf<String>()\n        val pattern = Regex(\"\"\"^\\S+ (\\d+) (\\d+\\.\\d+) ([BS])$\"\"\")\n\n        lst.split(\", \")\n            .forEach {\n                if (pattern.matches(it)) {\n                    val (qty, pricePoint, action) = pattern.find(it)!!.destructured\n                    if (action == \"B\") {\n                        bought += qty.toDouble() * pricePoint.toDouble()\n                    } else sold += qty.toDouble() * pricePoint.toDouble()\n                } else\n                    typos.add(\"$it ;\")\n            }\n\n        val result = \"Buy: ${bought.roundToInt()} Sell: ${sold.roundToInt()}\"\n\n        return when {\n            typos.isEmpty() or lst.isEmpty() -> result\n            else -> \"$result; Badly formed ${typos.size}: ${typos.joinToString(\"\")}\"\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205824,"user_id":null,"body":"package solution\n\nimport kotlin.math.roundToInt\n\n\nobject OrdersSummary {\n    data class Order(\n        val quote: String,\n        val quantity: String,\n        val price: String,\n        val status: String\n    )\n    \n    fun balanceStatements(lst: String): String {\n        val badOrders = mutableListOf<String>()\n        var buy = 0.0\n        var sell = 0.0\n\n         lst.split(\", \")\n            .map {\n                it.trim().split(\" \")\n            }.filterNot {\n                it.joinToString().isEmpty()\n            }.forEach {\n                try {\n                    val order = Order(it[0], it[1], it[2], it[3])\n\n                    if (!order.price.contains(\".\")) {\n                        throw IllegalArgumentException()\n                    }\n\n                    when (order.status) {\n                        \"S\" -> sell += order.quantity.toInt() * order.price.toDouble()\n                        \"B\" -> buy += order.quantity.toInt() * order.price.toDouble()\n                        else -> throw IllegalArgumentException()\n                    }\n                } catch (e: Exception) {\n                    badOrders.add(it.joinToString(\" \"))\n                }\n            }\n\n        var result = \"Buy: ${buy.roundToInt()} Sell: ${sell.roundToInt()}\"\n\n        if (badOrders.isNotEmpty()) {\n            result += \"; Badly formed ${badOrders.count()}: ${badOrders.joinToString(\"\") { \"$it ;\" }}\"\n        }\n    \n        return result\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205825,"user_id":null,"body":"package solution\nimport kotlin.math.round\n\nobject OrdersSummary {\n    fun balanceStatements(lst: String): String {\n\n        val x = lst.split(\",\\\\s*\".toRegex()).map { convert(it) }\n\n        val buy = round(x.sumOf { it.first }).toInt()\n        val sell = round(x.sumOf { it.second }).toInt()\n        val bad = x.filter { it.third.isNotEmpty() }\n\n        val badStr = if (bad.isNotEmpty()) {\n            bad.joinToString(prefix = \"; Badly formed ${bad.size}: \", separator = \"\") { \"${it.third} ;\" }\n        } else \"\"\n        \n        return \"Buy: $buy Sell: $sell$badStr\"\n    }\n\n    private fun convert(str: String): Triple<Double, Double, String> {\n        val list = str.split(\" \")\n        return if ((list.size != 4)\n            || (!list[1].matches(\"\\\\d+\".toRegex()))\n            || (!list[2].matches(\"\\\\d+\\\\.\\\\d{0,3}\".toRegex()))\n            || (!list[3].matches(\"[BS]\".toRegex()))\n        ) {\n            Triple(0.0, 0.0, str)\n        } else {\n            val quantity = list[1].toDoubleOrNull() ?: 0.0\n            val price = list[2].toDoubleOrNull() ?: 0.0\n            val sell = if (list[3] == \"S\") quantity * price else 0.0\n            val buy = if (list[3] == \"B\") quantity * price else 0.0\n            Triple(buy, sell, \"\")\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205826,"user_id":null,"body":"package solution\n\nobject OrdersSummary {\n    fun balanceStatements(lst: String): String {\n        if (lst.isEmpty()) return \"Buy: 0 Sell: 0\"\n         val listOfStr: List<String> = lst.split(\",\\\\s+\".toRegex())\n\n        val listValid: MutableList<List<String>> = mutableListOf()\n        val listError: MutableList<String> = mutableListOf()\n        for (str in listOfStr) {\n            val listElement = str.split(\" \".toRegex())\n            if (isValidListElement(listElement))\n                listValid.add(listElement)\n            else listError.add(str)\n        }\n\n        \/\/println(listValid)\n        \/\/println(listError)\n\n        var sumBuy = 0.0\n        var sumSell = 0.0\n        for (list in listValid) {\n            if (list[3] == \"B\")\n                sumBuy += list[1].toInt() * list[2].toDouble()\n            else if (list[3] == \"S\")\n                sumSell += list[1].toInt() * list[2].toDouble()\n        }\n\n        var strTotal = \"Buy: ${Math.round(sumBuy)} Sell: ${Math.round(sumSell)}\"\n        if (listError.isEmpty()){\n            return strTotal\n        }else{\n            strTotal += \"; Badly formed ${listError.size}: \"\n            for (element in listError){\n                strTotal+=element\n                strTotal+=\" ;\"\n            }\n        }\n        return strTotal\n    }\n}\n\nprivate fun isValidListElement(listElement: List<String>): Boolean {\n    if (listElement.size != 4) return false\n        val a = listElement[1].matches(Regex(\"\\\\d+\"))\n        val b = listElement[2].matches(Regex(\"\\\\d+\\\\.\\\\d+\"))\n        val c = listElement[3].matches(Regex(\"S|B\"))\n        return a && b && c\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"54e320dcebe1e583250008fd":[{"id":205827,"user_id":null,"body":"package solution\n\n\n    private val encode = listOf(('0'..'9').toList(), ('A'..'Z').toList()).flatten()\n\n    fun dec_2_fact_string(n: Long): String {\n        var value = n\n        var counter = 1\n        val array = mutableListOf<Char>()\n        while (value > 0) {\n            array.add(encode[(value % counter).toInt()])\n            value \/= counter\n            counter++\n        }\n        return array.asReversed().joinToString(\"\")\n    }\n\n    fun fact_string_2_dec(str: String): Long {\n        return str.reversed().mapIndexed { index, c ->\n            encode.indexOf(c) * (index.downTo(1L).takeIf {\n                it.isEmpty().not()\n            }?.reduce { acc, i -> acc * i } ?: 0)\n        }.sum()\n    }\n","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 21:20:49"},{"id":205828,"user_id":null,"body":"package solution\n\n\n    fun fac(n: Int): Long = if (n == 1) 1 else if (n <= 0) 0 else n * fac(n - 1)\n    fun c2d(char: Char) = if (char in '0'..'9') char.toInt() - '0'.toInt() else char.toInt() - 'A'.toInt() + 10\n    fun d2c(n: Long): Char = if (n in 0..9) (n + '0'.toInt()).toChar() else (n + 'A'.toInt() - 10).toChar()\n    fun fact_string_2_dec(str: String) = str.reversed().mapIndexed { i, c -> c2d(c) * fac(i) }.sum()\n    fun dec_2_fact_string(n: Long) = generateSequence(0 to '0') { (i, c) -> if (n < fac(i + 1)) null else\n        i + 1 to d2c(n % fac(i + 2) \/ fac(i+1)) }.map { it.second }.joinToString(\"\").reversed()\n","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 21:19:35"},{"id":205829,"user_id":null,"body":"package solution\n\n    \n    val alpha = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    \n    \n    fun dec_2_fact_string(n: Long): String {\n        var fs = \"\"\n        var d = 1\n        var nb = n\n        \n        while (nb != 0L){\n            val m = (nb % d).toInt()\n            nb \/= d\n            fs = alpha[m] + fs\n            d += 1\n        }\n        return fs\n    }\n    fun fact_string_2_dec(str: String): Long {\n        \n        var f = 1L\n        var res = 0L\n        \n        str.reversed().takeLast(str.length - 1).forEachIndexed{ i, d ->\n            f *= (i + 1)\n            res += f * alpha.indexOf(d)\n        }\n        return res\n    }\n","lang_id":29,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 21:20:41"},{"id":205830,"user_id":null,"body":"package solution\n\n\n    \n    var letters = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    \n    fun factorial(n: Long): Long {\n        if (n == 0L || n == 1L) return n\n        else return n * factorial(n-1)\n    }\n    \n    fun dec_2_fact_string(n: Long): String {\n        var result = \"\"\n        var dec2fact = n\n        for (i in 36L downTo 1L) {\n            result += letters[(dec2fact\/factorial(i)).toInt()]\n            dec2fact = dec2fact % factorial(i)\n        }\n        return (result + 0).trimStart('0')\n    }\n    \n    fun fact_string_2_dec(str: String): Long {\n        var result: Long = 0L\n        var count: Long = 0L\n        str.reversed().forEach {\n            result += letters.indexOf(it)*factorial(count)\n            count += 1\n        }\n        return result\n    }\n","lang_id":29,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 21:20:33"},{"id":205831,"user_id":null,"body":"package solution\n\nfun factorial(n: Long): Long = if (n==0L) { 1L } else { factorial(n-1)*n }\n\nobject Dec2Fact {\n    val digits = \"0123456789ABCDEFGHIJHKLMNOPQRSTUVWXYZ\"\n    \n    fun dec_2_fact_string(n: Long): String {\n        var remaining = n\n        var digit = 0L\n        \n        while (factorial(digit) < n) {\n            digit += 1L\n        }\n        \n        var output = \"\"\n        while (remaining > 0L) {\n            val base = factorial(digit)\n            val next_digit = remaining \/ base\n            output += digits[next_digit.toInt()]\n            remaining -= base * next_digit\n            digit -= 1L\n        }\n        output  += \"0\".repeat(digit.toInt() + 1)\n        \n        return output.trimStart('0')\n    }\n    fun fact_string_2_dec(str: String): Long {\n        var num = 0L\n        \n        var digit = 0L\n        for (char in str.reversed()) {\n            num += digits.indexOf(char) * factorial(digit)\n            digit += 1L\n        }\n        \n        return num\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 20:49:33"},{"id":205832,"user_id":null,"body":"package solution\n\n\n    fun dec_2_fact_string(n: Long): String {\n        var num = 1\n        while (getFact(num + 1) < n) {\n            num++\n        }\n        return buildString {\n            var remain = n\n            for (i in num downTo 1) {\n                val fact = getFact(i)\n                append(getDigit((remain \/ fact).toInt()))\n                remain %= fact\n            }\n            append(\"0\")\n        }\n    }\n\n    fun fact_string_2_dec(str: String): Long {\n        var sum = 0L\n        for (i in 1 until str.length) {\n            val multiplier = fromDigit(str[str.length - 1 - i])\n            sum += multiplier * getFact(i).toLong()\n        }\n        return sum\n    }\n\n    private val factMap = mutableMapOf(1 to 1L)\n    private fun getFact(num: Int): Long {\n        return factMap.getOrPut(num) {\n            getFact(num - 1) * num\n        }\n    }\n\n    private fun getDigit(n: Int): Char {\n        return when {\n            n < 10 -> Char('0'.code + n)\n            else -> Char('A'.code + n - 10)\n        }\n    }\n\n    private fun fromDigit(c: Char): Int {\n        return if (c.isDigit()) {\n            c.digitToInt()\n        } else {\n            c.code - 'A'.code + 10\n        }\n    }\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 21:20:24"},{"id":205833,"user_id":null,"body":"package solution\n\n    \n    fun dec_2_fact_string(n: Long): String {        \n        var result = \"\"\n        var rest = n\n        var max = 0L\n        while(n - factorial(max) > 0) {\n            max++\n        }\n        max--\n        for (i in 0..max) {\n            val div = rest \/ factorial(max - i)\n            if(div > 9) {\n                result += 'A' + (div % 10).toInt()\n            } else {\n                result += div\n            }\n            rest = n % factorial(max - i)\n        }\n        return result\n    }\n    fun fact_string_2_dec(str: String): Long {\n        val max = str.length.toLong() - 1\n        var result: Long = 0\n        str.forEachIndexed({idx, symbol -> \n            if(symbol.isDigit()) {\n                result += factorial(max - idx) * symbol.digitToInt()\n            } else {\n                result += factorial(max - idx) * (symbol - 'A' + 10)\n            }\n        })\n        return result\n    } \n    \n    \n    fun factorial(n: Long): Long {\n        if(n == 0L) {\n            return 1L\n        } else {\n            return n * factorial(n - 1)\n        }\n    }\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 21:20:23"},{"id":205834,"user_id":null,"body":"package solution\n\nobject Dec2Fact {\n    fun dec_2_fact_string(n: Long): String {\n        var result = \"\"\n        var num = n\n        var i = 1\n\n        while (num != 0L) {\n            val remainder = num % i\n            result += if(remainder < 10) remainder else valueToLetter(remainder.toInt())\n            num \/= i\n            i++\n\n        }\n\n        return result.reversed()\n    }\n    fun fact_string_2_dec(str: String): Long {\n        var result = 0L\n\n        str.forEachIndexed { i, c ->\n            val num = if (c.isDigit()) c.digitToInt() else letterToValue(c)\n            result = (result + num) * if(str.length-1-i == 0) 1 else str.length-1-i\n        }\n\n        return result\n    }\n\n    fun letterToValue(char: Char) = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".indexOf(char) + 10\n    fun valueToLetter(num: Int) = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"[(num - 10)]\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 20:49:33"},{"id":205835,"user_id":null,"body":"object Dec2Fact {\n    private fun getAlphabet() : CharArray {\n        val result = ('0'..'9').toMutableList()\n        result.addAll(('A'..'Z').toMutableList())\n        return result.toCharArray()\n    }\n\n    private fun getFactorial(N: Int): Long {\n        var answer = 1L\n        for (i in 1..N) answer *= i\n        return answer\n    }\n\n    private fun getInt(N: Char): Int = getAlphabet().indexOf(N)\n    \n    fun dec_2_fact_string(N: Long): String {\n        var buf = N\n        var answer = \"\"\n        for (i in 1 until getAlphabet().size) {\n            if (buf < 1L) break\n            answer += getAlphabet()[(buf % i).toInt()]\n            buf \/= i\n        }\n        return answer.reversed()\n    }\n\n    fun fact_string_2_dec(str: String): Long {\n        val buf = str.reversed()\n        var answer: Long = 0\n        for ((index, value) in buf.toCharArray().withIndex()) {\n            answer += getFactorial(index) * getInt(value)\n        }\n        return answer\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 20:49:33"},{"id":205836,"user_id":null,"body":"package solution\nimport java.math.BigDecimal\n\nfun getFactorial(N: Int): Long {\n    var answer = 1L\n    for (i in 1..N) answer *= i\n    return answer\n}\n\nfun getLetter(N: Int): String {\n    val answer = ('A'..'Z').toMutableList()\n    return when (N) {\n        in 0..9 -> N.toString()\n        in 10..36 -> answer[N - 10].toString()\n        else -> \"\"\n    }\n}\n\nfun getInt(N: String): Int {\n    for (i in 0..36) {\n        if (getLetter(i) == N) {\n            return i\n        }\n    }\n    return 0\n}\n\nobject Dec2Fact {\n    fun dec_2_fact_string(n: Long): String {\n        val one: Long = 1\n        var buf = n\n        var answer = \"\"\n        for (i in 1..35) {\n            if (buf < one) break\n            answer += (getLetter((buf % i).toInt()))\n            buf \/= i\n        }\n        return answer.reversed()\n    }\n\n    fun fact_string_2_dec(str: String): Long {\n        val buf = str.reversed()\n        var answer: Long = 0\n        for ((index, value) in buf.toCharArray().withIndex()) {\n            answer += getFactorial(index).toLong() * getInt(value.toString())\n        }\n        return answer\n    }\n}\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 20:49:33"}],"54eb33e5bc1a25440d000891":[{"id":205837,"user_id":null,"body":"package solution\n\nobject Decomp {\n    fun decompose(n: Long): String {\n        val decomposeArray = decomposer(n, n * n) ?: return \"null\"\n        decomposeArray.removeAt(decomposeArray.size - 1)\n        return decomposeArray.joinToString(\" \")\n    }\n    private fun decomposer(n: Long, remain: Long): MutableList<Long>? {\n        if (remain == 0L) return mutableListOf(n)\n        for (i in n - 1 downTo 1) {\n            if (remain - i * i >= 0) decomposer(i, remain - i * i)?.apply { add(n); return this }\n        }\n        return null\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205838,"user_id":null,"body":"package solution\n\nobject Decomp {\n    \n    fun decompose(n: Long): String {\n        val result = decompose(n*n, n-1)\n        return if (result.isEmpty())\n            \"null\"\n        else \n            result.reversed().joinToString(\" \")\n    }\n        \n    private fun decompose(n: Long, max: Long) : List<Long> {\n        for (i in max downTo 1) {\n            val remainder = n - i*i\n            if (remainder == 0L) {\n                return listOf(i)\n            } else if (remainder > 0L) {\n                val temp = decompose(n-i*i, i-1)\n                if (!temp.isEmpty()) \n                    return listOf(i) + temp\n            }\n        }\n        return listOf()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205839,"user_id":null,"body":"package solution\n\nobject Decomp {\n    fun decompose(n: Long): String {\n        fun inner(number: Long, maxIndex: Long):List<Long>? {\n            if (number == 0L) return emptyList()\n            if (maxIndex == 0L) return null\n            for (i in maxIndex downTo 1L) {\n                if (number >= i * i) {\n                    val list = inner (number - i*i, i-1)\n                    if (list != null) return list + i\n                }\n            }\n            return null\n        }\n        return inner(n*n, n-1)?.joinToString(\" \")?:\"null\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205840,"user_id":null,"body":"package solution\n\nobject Decomp {\n    \n    fun decompose(n: Long): String {\n        var res = decomposeSquare(n * n, n)\n        return if (res == null) \"null\" else res.joinToString(\" \")\n    }\n    \n    fun decomposeSquare(n: Long, next: Long): MutableList<Long>? {\n        if (n == 0L) return mutableListOf<Long>()\n        else if (n == 1L && next > 1) return mutableListOf(1L)\n        else if (n == 1L && next == 1L) return null\n        \n        var curr = next - 1L\n        var newN = 1L\n        var result: MutableList<Long>? = null\n        while (curr > 0 && result == null) {\n            newN = n - curr * curr\n            \n            if (newN >= 0) result = decomposeSquare(newN, curr)\n            curr--\n        }\n        \n        if (result != null) result.add(curr + 1)\n        return if (newN < 0) null else result\n    }\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205841,"user_id":null,"body":"package solution\n\nobject Decomp {\n    \n    \n\nfun decompose(n:Long):String {\n        var result:String = \"null\";\n\n        for (i in (n - 1) downTo 2) {\n            var square = n * n\n            result = recurseDecompose(i, square);\n            if (result != \"null\") break;\n        }\n\n        return result\n    }\n\t\n    fun recurseDecompose(i:Long, remm:Long) :String {\n        var rem = remm\n        if (i * i == rem) {\n            return i.toString()\n        } else if (i * i < rem) {\n            rem = rem - i * i\n\n            for (j in (i - 1) downTo 1) {\n                var tmp = recurseDecompose(j, rem);\n\n                if (tmp != \"null\") {\n                    \/\/println(tmp + \" \" + i)\n                    return tmp + \" \" + i\n                } else {\n                    continue\n                }\n            }\n        } else {\n            return \"null\"\n        }\n\n        return \"null\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205842,"user_id":null,"body":"package solution\n\nobject Decomp {\n    \n    fun decompose(n: Long): String {\n        val composition = getComposition(n * n, n - 1, emptyList<Long>())        \n        return if (composition.isNotEmpty()) {\n            composition.reversed().joinToString(separator = \" \") { it.toString() }\n        } else {\n            \"null\"\n        }\n    }\n    \n    private fun getComposition(target: Long, num: Long, composition: List<Long>): List<Long> {\n        if (target == 0L) {\n            return composition\n        } else if (target < 0) {\n            return emptyList()\n        } else {\n            for (i in num downTo 1) {\n                val composition = getComposition(target - i * i, i - 1, composition + i)\n                if (composition.isNotEmpty()) {\n                    return composition\n                }\n            }\n        }\n        return emptyList()\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205843,"user_id":null,"body":"package solution\nimport kotlin.math.pow\n\nobject Decomp {\n    fun decompose(n: Long): String {\n        var area = 0.0; val result = mutableListOf(n)\n        while (result.size > 0) {\n            var current = result.removeLast()\n            area += current.toDouble().pow(2)\n            for (i in current - 1 downTo 1) {\n                if (area - i.toDouble().pow(2) >= 0) {\n                    area -= i.toDouble().pow(2)\n                    result.add(i)\n                    if (area == 0.0) return result.sorted().joinToString(\" \")\n                }\n            }\n        }\n        return \"null\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205844,"user_id":null,"body":"package solution\n\nobject Decomp {\n    \n    fun decompose(n: Long) = findSolution(n, n - 1, mutableListOf())\n            .reversed()\n            .map { it.toString() }\n            .reduceOrNull{s1: String, s2: String -> \"$s1 $s2\" } ?: \"null\"\n\n    private fun findSolution(n: Long, m: Long, candidate: MutableList<Long>): List<Long> {\n        val sqrN = n * n\n        val sqrSum = candidate.sumOf { it * it }\n        (m downTo 1).forEach {\n            if (sqrSum + it * it == sqrN)\n                return candidate.apply { add(it) }\n            if (sqrSum + it * it < sqrN)\n                return findSolution(n, it - 1, candidate.apply { add(it) })\n        }\n        if (candidate.isNotEmpty())\n            return findSolution(n, candidate.removeLast() - 1, candidate)\n        return listOf()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205845,"user_id":null,"body":"package solution\n\nimport kotlin.math.*\n\nobject Decomp {\n    \n    fun decompose(n: Long): String {\n        val res = decomposeIter(n * n, n - 1, \"\")\n        return when (res) {\n            \"null\" -> res\n            else -> res.dropLast(1)\n        }\n    }\n    \n    fun decomposeIter(nsq: Long, cur: Long, lst: String): String =\n        if (nsq == 0.toLong()) {\n            lst\n        } else if (nsq < 0 || cur == 0.toLong()) {\n            \"null\"\n        } else {\n            val newNsq = nsq - cur * cur\n            val next = min(floor(sqrt(newNsq.toDouble())).toLong(), cur - 1)\n            val res = decomposeIter(newNsq, next, cur.toString() + \" \" + lst)\n            if (res != \"null\") {\n                res\n            } else {\n                decomposeIter(nsq, min(cur - 1, floor(sqrt(nsq.toDouble())).toLong()), lst)\n            }\n        }\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205846,"user_id":null,"body":"package solution\n\nimport kotlin.math.*\n\nobject Decomp {\n    \n    fun decompose(n: Long): String {\n        val res = decomposeIter(n.toDouble().pow(2).toLong(), n - 1, \"\")\n        return when (res) {\n            \"null\" -> res\n            else -> res.dropLast(1)\n        }\n    }\n    \n    fun decomposeIter(nsq: Long, cur: Long, lst: String): String =\n        if (nsq == 0.toLong()) {\n            lst\n        } else if (nsq < 0 || cur == 0.toLong()) {\n            \"null\"\n        } else {\n            val newNsq = nsq - cur.toDouble().pow(2).toLong()\n            val next = min(floor(sqrt(newNsq.toDouble())).toLong(), cur - 1)\n            val res = decomposeIter(newNsq, next, cur.toString() + \" \" + lst)\n            if (res != \"null\") {\n                res\n            } else {\n                decomposeIter(nsq, min(cur - 1, floor(sqrt(nsq.toDouble())).toLong()), lst)\n            }\n        }\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"54f8693ea58bce689100065f":[{"id":205847,"user_id":null,"body":"package solution\n\nobject Decomp {\n    \n    tailrec fun rationalSum(nr: Long, dr: Long, res: MutableList<String> = mutableListOf()): List<String> {\n        if(nr == 0L || dr == 0L) return res\n        if(dr % nr == 0L)  return res.apply { add(\"1\/${dr\/nr}\")  }\n        if(nr % dr == 0L)  return res.apply { add(\"${nr\/dr}\")  }\n        if(nr > dr) {\n            res += \"${nr\/dr}\"\n            return rationalSum(nr % dr, dr, res)\n        }\n        val fraction = dr \/ nr + 1L\n        \n        res += \"1\/$fraction\"\n        return rationalSum(nr * fraction - dr, dr * fraction, res)\n    }\n\n    fun decompose(nrStr: String, drStr: String, res: MutableList<String> = mutableListOf()): String\n        = rationalSum(nrStr.toLong(), drStr.toLong(), res).joinToString(\", \").let { \"[$it]\" }\n  \n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 21:56:06"},{"id":205848,"user_id":53,"body":"package solution\n\nobject Decomp \n{\n    fun decompose(nrStr: String, drStr: String): String \n    {\n        val ans = java.util.StringJoiner(\", \", \"[\", \"]\");\n        var a = nrStr.toLong();\n        var b = drStr.toLong();\n        while (a >= b)\n        {\n            ans.add((a \/ b).toString());\n            a %= b;\n        }\n        while (a > 0)\n        {\n            val d = Math.ceil(b.toDouble() \/ a).toLong();\n            ans.add(\"1\/\" + d.toString());\n            a = a  * d - b;\n            b *= d;\n        }\n        return ans.toString();\n    }\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 21:56:12"},{"id":205849,"user_id":null,"body":"package solution\n\nobject Decomp {\n    \n    fun decompose(nrStr: String, drStr: String): String {\n        var nr=nrStr.toLong()\n        var dr=drStr.toLong()\n        var res=mutableListOf<Long>()\n        var intPart=false\n        if (nr>dr){\n        \tres.add(nr\/dr)\n            nr=nr%dr\n            intPart=true\n        }\n        var curDr=2L\n        while (nr>0){\n            while (dr>curDr*nr)\n            \tcurDr++\n            nr=nr*curDr-dr\n            dr=curDr*dr\n          \tres.add(curDr)\n        }\n\t\treturn res.joinToString(\", \",\"[\",\"]\" ){\n            if (!intPart) \n                \"1\/$it\" \n            else{\n                intPart=false\n                \"$it\"\n            }\n        }    \n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205850,"user_id":null,"body":"package solution\nfun Long.gcd(other:Long):Long = if(other==0L) this else other.gcd(this%other)\nobject Decomp {\n    \nfun decompose(nrStr: String, drStr: String): String {\n    var ret = \"[\"\n    var num = nrStr.toLong()\n    var den = drStr.toLong()\n    if(num==0L) return \"[]\"\n    if(num>=den){\n        ret+=\"${num\/den}, \"\n        num%=den\n    }\n    var pivot = 2L\n    while(num>0) {\n        if (num * pivot >= den) {\n            ret += \"1\/$pivot, \"\n            num = (num * pivot - den).also { den *= pivot }\n            val gcd = num.gcd(den)\n            num \/= gcd.also { den \/= gcd }\n        }\npivot++\n    }\n    return ret.dropLast(2)+']'\n}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205851,"user_id":null,"body":"package solution\n\nimport kotlin.math.absoluteValue\n\nobject Decomp {\n    fun decompose(nrStr: String, drStr: String): String {\n        val result = ArrayList<String>()\n\n        var remains = Rational.from(nrStr, drStr)\n        val floor = remains.numerator \/ remains.denominator\n        if (floor > 0L) {\n            remains -= floor\n            result.add(floor.toString())\n        }\n\n        while (remains.isPositive()) {\n            val m = if (remains.denominator % remains.numerator > 0) {\n                Rational.from(remains.denominator \/ remains.numerator + 1L)\n            } else {\n                Rational.from(remains.denominator \/ remains.numerator)\n            }\n            remains -= m\n            result.add(m.toString())\n        }\n\n        return \"[\" + result.joinToString(\", \") + \"]\"\n    }\n}\n\nclass Rational private constructor(val numerator: Long, val denominator: Long) {\n    companion object {\n        fun from(num: String, den: String): Rational {\n            return from(num.toLong(), den.toLong())\n        }\n\n        fun from(den: Long): Rational {\n            return from(1L, den)\n        }\n\n        fun from(num: Long, den: Long): Rational {\n            if (num == 0L) {\n                return Rational(0L, 1L)\n            }\n            val gcd = gcd(num.absoluteValue, den.absoluteValue)\n\n            return if (den > 0L) {\n                Rational(num \/ gcd, den \/ gcd)\n            } else {\n                Rational(-num \/ gcd, -den \/ gcd)\n            }\n        }\n\n        private fun gcd(a: Long, b: Long): Long {\n            var x = a\n            var y = b\n            if (a < b) {\n                y = a\n                x = b\n            }\n            while (y > 0) {\n                val aux = y\n                y = x % y\n                x = aux\n            }\n            return x\n        }\n    }\n\n    operator fun minus(decrement: Rational): Rational {\n        return from(numerator * decrement.denominator - decrement.numerator * denominator, denominator * decrement.denominator)\n    }\n\n    operator fun minus(decrement: Long): Rational {\n        return from(numerator - decrement * denominator, denominator)\n    }\n\n    fun isPositive() = numerator > 0\n\n    override fun toString(): String {\n        return \"$numerator\/$denominator\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205852,"user_id":null,"body":"package solution\n\nobject Decomp {\n    \n    private fun gcd(a: Long, b: Long) : Long {\n        return when {\n            a < b -> gcd(b, a)\n            b == 0L -> a\n            else -> gcd(b, a % b)\n        }\n    }\n    \n    private data class Rational(val num: Long, val div: Long): Comparable<Rational> {\n        override fun compareTo(other: Rational): Int {\n            val gcd = gcd(div, other.div)\n            val first = other.div \/ gcd * num\n            val second = div \/ gcd * other.num\n            return when {\n                first < second -> -1\n                first > second -> 1\n                else -> 0\n            }\n        }\n        \n        infix operator fun minus(other: Rational): Rational {\n            val gcd = gcd(div, other.div)\n            return Rational(other.div \/ gcd * num - div \/ gcd * other.num, div \/ gcd * other.div)\n        }\n        \n        override fun toString(): String = \"$num\" + if (div == 1L) \"\" else \"\/$div\"\n    }\n    \n    private fun binSearch(minimum: Long, toDecompose: Rational): Long {\n        var begin: Long = minimum + 1\n        var end: Long = toDecompose.div\n        while (end - begin > 0) {\n            val mid = (end - begin) \/ 2 + begin\n            if (Rational(1L, mid) <= toDecompose) {\n                end = mid\n            } else {\n                begin = mid + 1\n            }\n        }\n        return end\n    }\n    \n    fun decompose(nrStr: String, drStr: String): String {\n        val result = mutableListOf<Rational>()\n        var current = Rational(nrStr.toLong(), drStr.toLong())\n        if (current.num > current.div) {\n            result.add(Rational(current.num \/ current.div, 1L)) \n            current = current - result.last()\n        }\n        while (current.num > 0) {\n            val prev = result.lastOrNull()?.div ?: 1L\n            result.add(Rational(1L, binSearch(prev, current)))\n            current = current - result.last()\n        }\n        return result.joinToString(\", \", \"[\", \"]\") { it.toString() }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205853,"user_id":null,"body":"package solution\n\nobject Decomp {\n\n    fun decompose(nrStr: String, drStr: String): String =\n        mutableListOf<String>()\n            .apply {\n                var numerator = nrStr.toLong()\n                var denominator = drStr.toLong()\n                if (numerator >= denominator) {\n                    add((numerator \/ denominator).toString())\n                    numerator %= denominator\n                }\n                while (numerator > 0) {\n                    val smallestDenominator = (denominator + numerator - 1) \/ numerator\n                    add(\"1\/%d\".format(smallestDenominator))\n                    numerator = numerator * smallestDenominator - denominator\n                    denominator *= smallestDenominator\n                }\n            }\n            .joinToString(separator = \", \", prefix = \"[\", postfix = \"]\")\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205854,"user_id":null,"body":"\/*\nhttps:\/\/en.wikipedia.org\/wiki\/Greedy_algorithm_for_Egyptian_fractions\n\nlook into above explanation and implement the formula accordingly\n *\/\n\n\n\n\npackage solution\n\nimport kotlin.math.abs\nimport kotlin.math.ceil\nimport kotlin.math.floor\n\nobject Decomp {\n    \/\/function for greedy expansion\n    private fun greedy(nr: Double, dr: Double): List<String> {\n        val fractions = mutableListOf<String>()\n        var x = nr\n        var y = dr\n        var sum = 0.0\n\n        while (sum != x \/ y) {\n\n            val firstDenom = abs(ceil(y \/ x)).toInt() \/\/calculating the first fraction's denominator\n            val firstFrac = \"1\/$firstDenom\" \/\/the starting fraction\n            fractions.add(firstFrac)\n            sum += 1 \/ firstDenom\n\n            val secondNr = (((ceil(y \/ x).toInt()) * x) - y)\/\/calculating negative modulo as in formula\n            val secondDr = y * firstDenom\n\/\/now repeating the process as above for further fractions\n            x = secondNr\n            y = secondDr\n        }\n\n\n        return fractions.toList()\n\n    }\n\n    fun decompose(nrStr: String, drStr: String): String {\n        val finalFractions = mutableListOf<String>()\n        var x = nrStr.toDouble()\n        val y = drStr.toDouble()\n\/\/implementing conditions\n        if (x == 0.0) {\n            finalFractions.add(\"\")\n\n        } else if (x % y == 0.0) {\n            finalFractions.add((x \/ y).toInt().toString())\n        } else if (x % y != 0.0 && x > y) {\n\n            val firstInteger = floor(x \/ y)\n            finalFractions.add((firstInteger.toInt().toString()))\n\n            x %= y\n            finalFractions.addAll(greedy(x, y))\n\n\n        } else {\n            finalFractions.addAll(greedy(x, y))\n        }\n       \n        return finalFractions.toString()\n\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205855,"user_id":null,"body":"package solution\nimport kotlin.math.ceil\n\n\nobject Decomp {\n\n    fun decompose(nrStr: String, drStr: String): String {\n        var decim = Pair(nrStr.toLong(), drStr.toLong())\n        var denums = mutableListOf<Pair<Long, Long>>()\n        while (decim.first != 0L) {\n            println(\"$decim $denums\")\n            val nextDenum = biggestSimpleFraction(decim)\n            denums.add(nextDenum)\n            decim = nextPair(decim, nextDenum)\n        }\n        return denums.map { it.display() }.toString()\n    }\n\n    private fun Pair<Long, Long>.display(): String {\n        if (this.second == 1L) {\n            return this.first.toString()\n        } else return \"${this.first}\/${this.second}\"\n    }\n\n    private fun biggestSimpleFraction(nr: Pair<Long, Long>): Pair<Long, Long> {\n        return if (nr.first.rem(nr.second) == 0L || nr.first\/nr.second > 0) {\n            Pair(nr.first \/ nr.second, 1)\n        } else {\n            Pair(1, ceil(nr.second.toDouble() \/ nr.first.toDouble()).toLong())\n        }\n    }\n\n    private fun nextPair(nr: Pair<Long, Long>, dr: Pair<Long, Long>): Pair<Long, Long> {\n        val gcd = gcd(nr.second,dr.second)\n        return Pair(nr.first * (dr.second\/gcd) - dr.first * (nr.second\/gcd), (nr.second\/gcd)*dr.second)\n    }\n\n    private fun gcd(n1 : Long, n2: Long) : Long {\n        var n1 = n1\n        var n2 = n2\n\n        \/\/ Always set to positive\n        n1 = if (n1 > 0) n1 else -n1\n        n2 = if (n2 > 0) n2 else -n2\n\n        while (n1 != n2) {\n            if (n1 > n2)\n                n1 -= n2\n            else\n                n2 -= n1\n        }\n        return n1\n    }\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205856,"user_id":null,"body":"package solution\n\nimport kotlin.text.toInt\nimport kotlin.collections.mutableListOf\n\nobject Decomp {\n    fun decompose(nrStr: String, drStr: String): String {\n        var numerator = nrStr.toLong()\n        var denominator = drStr.toLong()\n        \n        val entries = mutableListOf<String>()\n    \n       if (numerator > denominator) {\n            \/\/remove whole number\n            val wholeNumber = numerator \/ denominator\n            entries.add(wholeNumber.toString())\n            numerator -= denominator * wholeNumber\n        } \n    \n        while (numerator > 0) {\n            val nextDivisor = if (denominator % numerator == 0L) {\n                denominator \/ numerator\n            } else {\n                (denominator \/ numerator) + 1\n            }\n            entries.add(\"1\/$nextDivisor\")\n            \n            val newNumerator = (numerator * nextDivisor) - denominator\n            val newDenominator = denominator * nextDivisor\n            \n            numerator = newNumerator\n            denominator = newDenominator\n        }\n        return entries.joinToString(prefix = \"[\", postfix = \"]\")\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"54ff3102c1bad923760001f3":[{"id":205857,"user_id":null,"body":"fun get_count(str : String) = str.count { it in \"aeiou\" }","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205858,"user_id":null,"body":"fun get_count(str : String): Int = str.count { it in listOf('a','i','e','o','u') }\n","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205859,"user_id":null,"body":"\/\/https:\/\/www.codewars.com\/kata\/vowel-count\/train\/kotlin\nfun get_count(str: String): Int {\n    val vowel = charArrayOf('a', 'e', 'i', 'o', 'u')\n    return str.count { it in vowel }\n}\n","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205860,"user_id":null,"body":"fun get_count(str : String) : Int {\n  return str.count{x->\"aeiou\".contains(x)}\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205861,"user_id":null,"body":"fun get_count(str: String) = str.sumBy {\n    when (it) {\n        'a', 'i', 'e', 'o', 'u' -> 1\n        else -> 0\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205862,"user_id":null,"body":"fun get_count(str : String) : Int {\n  var vowelsCount = 0;\n  \n  for (x in str) {\n    if (x == 'a') {\n      vowelsCount++;\n    }\n    else if (x == 'e') {\n      vowelsCount++;\n    }  \n    else if (x == 'i') {\n      vowelsCount++;\n    }\n    else if (x == 'o') {\n      vowelsCount++;\n    }\n    else if (x == 'u') {\n      vowelsCount++;\n    }\n  }\n  return vowelsCount;\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205863,"user_id":null,"body":"fun get_count(str : String) : Int {\n       val regex = Regex(\"([aeiou])\")\n  return regex.findAll(str).count()\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205864,"user_id":null,"body":"fun get_count(str : String) : Int = str.length - str.replace(\"[aeiou]\".toRegex(),\"\").length\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205865,"user_id":null,"body":"fun get_count(str : String) = str.filter { ch -> ch in \"aeiou\" }.length\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205866,"user_id":null,"body":"val get_count:(String)->(Int)={a->a.count { a->a=='a'||a=='e'||a=='i'||a=='o'||a=='u'}}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"55031bba8cba40ada90011c4":[{"id":205867,"user_id":null,"body":"package solution\nimport kotlin.math.pow\n\nobject Cubes {\n    fun isSumOfCubes(s: String) = s.split(\"[\\\\D]\".toRegex())\n        .filter { it != \"\" }\n        .map{ it.chunked(3){s -> \"$s\".toInt() } }\n        .flatten()\n        .filter {  it == \"$it\".map {i -> \"$i\".toDouble().pow(3.0).toInt() }.sum() }\n        .let {\n            if (it.isEmpty()) \"Unlucky\"\n            else it.joinToString(\" \") +\" \"+ it.sum() + \" Lucky\"\n        }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205868,"user_id":null,"body":"package solution\n\nimport kotlin.math.pow\n\nobject Cubes {\n    fun isSumOfCubes(s: String): String {\n        val result = s.filter { it.isDigit() || it == ' ' }.split(\" \").fold(mutableListOf<Int>()) { acc, str ->\n            str.chunked(3).forEach {\n                val num = it.toInt()\n                if (num.isCubic()) {\n                    acc.add(num)\n                }\n            }\n            acc\n        }\n        return if (result.isNotEmpty()) {\n            result.add(result.sum())\n            result.joinToString(\" \") + \" Lucky\"\n        } else {\n            \"Unlucky\"\n        }\n    }\n\n    private fun Int.isCubic(): Boolean {\n        var sum = 0\n        var curNum = this\n        while (curNum != 0) {\n            sum += (curNum % 10).toDouble().pow(3).toInt()\n            curNum \/= 10\n        }\n        return sum == this\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205869,"user_id":null,"body":"package solution\n\nobject Cubes {\n    fun isSumOfCubes(s: String) =\n        Regex(\"[0-9]{1,3}\")\n            .findAll(s)\n            .map { it.value }\n            .map { it.toInt() to it.map { c -> \"$c\".toInt() }.sumBy { d -> d * d * d } }\n            .filter { it.first == it.second }\n            .toList()\n            .run {\n                if (isEmpty()) \"Unlucky\"\n                else joinToString(\" \") { \"${it.first}\" } + \" ${sumBy { it.second }} Lucky\"\n            }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205870,"user_id":null,"body":"package solution\n\nimport java.util.regex.Pattern\n\nobject Cubes {\n    fun isSumOfCubes(s: String) = Regex(\"\\\\d{1,3}\")\n            .findAll(s)\n            .map{ it.value.toInt() }\n            .filter{ it == it.toString().map{ it - '0' }.map{ it * it * it }.sum() }\n            .run {\n                if(any()) joinToString(\" \") + \" \" + sum() + \" Lucky\" else \"Unlucky\"\n            }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205871,"user_id":null,"body":"package solution\n\nimport java.util.regex.Pattern\n\nobject Cubes {\n    fun isSumOfCubes(s: String): String = \n        Regex(\"[0-9]{1,3}\").findAll(s).map { it.value }.toList().filter {\n            it.toInt() == it.fold(0) { a, x -> a + \"$x\".toInt().let { it * it * it } }\n        }.map { it.toInt() }.let {\n            if (it.any()) \"${it.joinToString(\" \")} ${it.sum()} Lucky\" else \"Unlucky\"\n        }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205872,"user_id":null,"body":"package solution\n\nimport java.util.regex.Pattern\nimport kotlin.math.pow\n\n\nobject Cubes {\n    fun isSumOfCubes(s: String) = s.split(\"[\\\\D]\".toRegex())\n        .filter { it != \"\" }\n        .map{ it.chunked(3){s -> \"$s\".toInt() } }\n        .flatten()\n        .filter {  it == \"$it\".map {i -> \"$i\".toDouble().pow(3.0).toInt() }.sum() }\n        .let {\n            if (it.isEmpty()) \"Unlucky\"\n            else it.joinToString(\" \") +\" \"+ it.sum() + \" Lucky\"\n        }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205873,"user_id":null,"body":"package solution\n\nimport java.util.regex.Pattern\n\nobject Cubes {\n    fun isSumOfCubes(s: String): String {\n        val cubicNumbers = Regex(\"\"\"\\d{1,3}\"\"\")\n            .findAll(s)\n            .map { it.value }\n            .filter { num ->\n                num.toInt() == num.toCharArray()\n                    .sumOf { digit -> digit.digitToInt().let { it * it * it } }\n            }\n            .map { num -> num.toInt() }\n            .toList()\n\n        return if (cubicNumbers.isEmpty()) {\n            \"Unlucky\"\n        } else {\n            \"${cubicNumbers.joinToString(\" \")} ${cubicNumbers.sum()} Lucky\"\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205874,"user_id":null,"body":"package solution\n\nobject Cubes {\n    fun isSumOfCubes(s: String): String =\n        Regex(\"\\\\d{1,3}\").findAll(s)\n            .map { it.value.toInt() to it.value }\n            .filter { pair ->\n                pair.first == pair.second.map { it.digitToInt() }.sumOf { it * it * it }\n            }.let { nums ->\n                if (nums.none()) \"Unlucky\"\n                else \"${nums.joinToString(\" \") { \"${it.first}\" }} ${nums.sumOf { it.first }} Lucky\"\n            }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205875,"user_id":null,"body":"package solution\n\nobject Cubes {\n    fun isSumOfCubes(s: String): String = Regex(\"\\\\d{1,3}\").findAll(s)\n        .map { it.value.toInt() }\n        .filter { num ->\n            num.toString().map { it.digitToInt() }\n                .sumOf { it * it * it } == num\n        }.let { nums ->\n            if (nums.count() == 0) \"Unlucky\"\n            else \"${nums.joinToString(\" \")} ${nums.sum()} Lucky\"\n        }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205876,"user_id":null,"body":"package solution\n\nimport kotlin.math.pow\n\nobject Cubes {\n    fun isSumOfCubes(s: String) = buildString {\n        var sum = 0.0\n        s.replace(Regex(\"\\\\D+\"), \"+\").trim{ it == '+' }.split(\"+\").forEach {\n            for (three in it.chunked(3)) {\n                val cubic = three.sumOf { c -> c.digitToInt().toDouble().pow(3.0) }\n                if (cubic == three.toDouble()) {\n                    append(three.toInt()).append(\" \")\n                    sum += cubic\n                }\n            }\n        }\n        if (isEmpty())\n            append(\"Unlucky\")\n        else {\n            append(sum.toInt())\n            append(\" Lucky\")\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"550498447451fbbd7600041c":[{"id":205877,"user_id":null,"body":"fun comp_same(a: IntArray?, b: IntArray?) = a != null && b != null && a.map { it * it }.sorted() == b.sorted()","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205878,"user_id":null,"body":"fun comp_same(a: IntArray?, b: IntArray?): Boolean {\n    if (a == null || b == null) return false\n\n    return a.map { it * it }.sorted() == b.sorted()\n}","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205879,"user_id":null,"body":"fun comp_same(a: IntArray?, b: IntArray?)  = a?.map { it * it }?.sorted() == b?.sorted() ?: false\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205880,"user_id":null,"body":"fun comp_same(a: IntArray?, b: IntArray?): Boolean{\n        if(a == null || b == null || (a.isEmpty() && b.isNotEmpty()) || (b.isEmpty() && a.isNotEmpty())) return false\n        val stacky = b.toMutableList()\n\n        for (i in a){\n            if(!stacky.remove(i*i)) return false\n        }\n        return true\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205881,"user_id":null,"body":"fun comp_same(a: IntArray?, b: IntArray?) = a!=null && b!=null \n&& a.map{it*it}.sorted().let{it==b.sorted()}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205882,"user_id":null,"body":"fun comp_same(a: IntArray?, b: IntArray?): Boolean {\n    return if(a == null || b == null) false \n           else a.sortedArrayDescending().asSequence()\n                .zip(b.sortedArrayDescending().asSequence())\n                .all { (a,b) -> (a*a) == b  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205883,"user_id":null,"body":"fun comp_same(a: IntArray?, b: IntArray?) = a?.let { b?.let { a.map { it * it }.sorted() == b.sorted() } } ?: false","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205884,"user_id":null,"body":"fun comp_same(array: IntArray?, squaredArray: IntArray?): Boolean {\n\n  \/\/ If arrays are of different sizes, we know that they are different.\n  if (array?.size != squaredArray?.size) return false\n\n  \/\/ If one of the arrays is null we know that they don't meet the conditions of the task.\n  if (array == null || squaredArray == null) return false\n\n  \/\/ Sort both arrays to achieve corresponding values in the same places in arrays.\n  array.sort()\n  squaredArray.sort()\n\n  \/\/ For each value in the first array check if the corresponding value in the second array is that value squared.\n  array.forEachIndexed { index, value ->\n    if (value * value != squaredArray[index]) {\n      return false\n    }\n  }\n\n  \/\/ If all of the values were correct, we can safely return true.\n  return true\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205885,"user_id":null,"body":"\nfun comp_same(a: IntArray?, b: IntArray?): Boolean {\n  if (a == null || b == null) return false;\n    return a.pow().sortedArray().contentEquals(b.sortedArray())\n}\n\n\n\nfun IntArray.pow() : IntArray {\n    var a = arrayListOf<Int>()\n    for (i in this) {\n        a.add(Math.pow(i.toDouble(), 2.0).toInt())\n    }\n    return a.toIntArray()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205886,"user_id":null,"body":"fun comp_same(a: IntArray?, b: IntArray?): Boolean {\n     if(a == null || b== null){\n         return false\n     }\n     val aS = a!!.map{it->it*it}.toIntArray()\n     aS.sort()\n     b!!.sort()\n     return b.contentEquals(aS)\n     \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"550527b108b86f700000073f":[{"id":205887,"user_id":492,"body":"package solution\n\nimport kotlin.math.abs\n\nobject PiApprox {\n    fun iterPi2String(epsilon: Double): String {\n        var i = 0\n        var j = 1\n        var pi = 0.0\n        while (abs(Math.PI - pi * 4) > epsilon) {\n            if (i % 2 == 0) pi += 1.0 \/ j else pi -= 1.0 \/ j\n            j += 2\n            i++\n        }\n        return String.format(\"[%d, %.10f]\", i, pi * 4)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205888,"user_id":null,"body":"package solution\nimport kotlin.math.*\nimport java.util.*\n\nobject PiApprox {\n    fun iterPi2String(e: Double) =\n    generateSequence(1 to 1.0) {\n        it.first + 1 to\n        (1.0 \/ (it.first * 2 + 1)).run {if (it.first % 2 == 1) it.second - this else it.second + this}\n    }.first { abs(it.second * 4 - PI) < e }.let {\n            \"[%d, %.10f]\".format(Locale.US, it.first, it.second * 4)\n        }\n\n\/\/     fun iterPi2String(epsilon: Double): String {\n\/\/         var counter = 1\n\/\/         var sum = 1.0\n\/\/         while( abs(sum * 4 - PI) > epsilon){\n\/\/             (1.0 \/ (counter * 2 + 1)).let {\n\/\/                 if (counter % 2 == 1) sum -= it\n\/\/                 else sum += it\n\/\/             }\n\/\/             counter++\n\/\/         }\n\/\/         return \"[%d, %.10f]\".format(Locale.US, counter, sum * 4)\n\/\/     }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205889,"user_id":53,"body":"package solution\nimport kotlin.math.abs\nimport kotlin.math.PI\n\nobject PiApprox {\n    fun iterPi2String(epsilon: Double): String {\n        var pi4: Double = 1.0\n        var sign: Double = -1.0\n        var denom: Double = 3.0\n        var iterations = 1\n        while (abs(4.0 * pi4 - PI) >= epsilon) {\n            pi4 += sign * (1.0 \/ denom)\n            sign *= -1.0\n            denom += 2.0\n            iterations += 1\n        }\n        return \"[%d, %.10f]\".format(iterations, 4.0 * pi4)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205890,"user_id":null,"body":"package solution\n\nimport kotlin.math.abs\nimport kotlin.math.pow\nimport kotlin.math.PI\n\n\nobject PiApprox {\n    fun iterPi2String(epsilon: Double): String {\n        var piDiv4 = 0.0\n        var k = 0\n        while (abs((piDiv4 * 4) - PI) >= epsilon) {\n            piDiv4 = piDiv4 + leibnizSeriesElement(k)\n            k++\n        }\n        return String.format(\"[%d, %.10f]\", k, piDiv4 * 4)\n    }\n\n    fun leibnizSeriesElement(k: Int) =\n        Math.pow(-1.0, k.toDouble()) \/ (2.0 * k + 1)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205891,"user_id":null,"body":"package solution\n\nobject PiApprox {\n    fun iterPi2String(epsilon: Double): String {\n        var i = 1\n        var piDiv4 = 1.0\n        while (Math.abs(Math.PI - 4 * piDiv4) > epsilon) {\n            i++\n            piDiv4 += (if (i % 2 == 0) -1.0 else 1.0) \/ (2 * i - 1)\n        }\n        return String.format(\"[%d, %.10f]\", i, 4 * piDiv4)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205892,"user_id":null,"body":"package solution\n\nobject PiApprox {\n    fun iterPi2String(epsilon: Double): String {\n       var i: Int = 1\n       var PI_4: Double = 1.0\n       var sign: Double = -1.0\n       while(Math.abs(Math.PI - 4 * PI_4) > epsilon) {\n           PI_4 += sign * 1.0 \/ (i.toDouble() * 2.0 + 1.0 )\n           i += 1\n           sign *= -1.0\n       }\n       return \"[\" + i.toString() + \", \" + (Math.round(PI_4 * 4 * 10000000000.0) \/ 10000000000.0).toString().padEnd(12,'0').take(12) + \"]\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205893,"user_id":null,"body":"package solution\n\nimport kotlin.math.abs\nimport java.text.DecimalFormat\n\nobject PiApprox {\n    fun iterPi2String(epsilon: Double): String {\n        var iterations = 1\n        var quarter = 1.0\n        var pi = 4 * quarter\n        var dividend = -1.0\n        var divider = 3\n\n        while (abs(pi - Math.PI) >= epsilon) {\n            iterations++\n            quarter += (dividend \/ divider)\n            pi = 4 * quarter\n            dividend = -dividend\n            divider += 2\n        }\n        \n        val formatted = DecimalFormat(\"#,##########0.0000000000\").format(pi)\n        return \"[$iterations, $formatted]\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205894,"user_id":null,"body":"package solution\n\nobject PiApprox {\n    fun iterPi2String(epsilon: Double): String {\n        var value = 1.0\n        var i = 2\n        var n = 3.0\n        while (true) {\n            if (i % 2 == 0) value -= 1 \/ n\n            else value += 1 \/ n\n            val piApprox = value * 4\n            if (isEqualToPiWithOffset(piApprox, epsilon)) return formatResult(i, piApprox)\n            i++\n            n += 2\n        }\n    }\n    \n    private fun formatResult(nbIter: Int, piApprox: Double): String {\n        return \"[%d, %.10f]\".format(nbIter, piApprox)\n    }\n\n    private fun isEqualToPiWithOffset(value: Double, offset: Double): Boolean =\n        (Math.PI - offset..Math.PI + offset).contains(value)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205895,"user_id":null,"body":"package solution\n\nobject PiApprox {\n    fun iterPi2String(epsilon: Double): String {\n        var pi = 1.0\n        var count = 1\n        while (!((Math.PI - epsilon) < 4.0 * pi && 4.0 * pi < (Math.PI + epsilon))) {\n          if ((count and 1) != 0)\n            pi -= 1.0 \/ (2.0 * count + 1.0)\n          else\n            pi += 1.0 \/ (2.0 * count + 1.0)\n          count++\n        }\n        return String.format(\"[%d, %.10f]\", count, 4.0 * pi)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205896,"user_id":null,"body":"package solution\n\nobject PiApprox {\n    fun iterPi2String(epsilon: Double): String {\n        var pi = 1.0\n        var count = 1\n        while (!((Math.PI - epsilon) < 4.0 * pi && 4.0 * pi < (Math.PI + epsilon))) {\n          if ((count and 1) != 0)\n            pi -= 1.0 \/ (2.0 * count + 1.0)\n          else\n            pi += 1.0 \/ (2.0 * count + 1.0)\n          count++\n        }\n        var num = Math.round(pi*40_000_000_000.0)\/10_000_000_000.0\n\n        return \"[$count, $num]\"\n\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"550554fd08b86f84fe000a58":[{"id":205897,"user_id":1267,"body":"fun inArray(array1: Array<String>, array2: Array<String>): Array<String> {\n   return array1.filter{e->array2.any{it.contains(e)}}.distinct().sorted().toTypedArray()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205898,"user_id":null,"body":"fun inArray(array1: Array<String>, array2: Array<String>): Array<String> {\n    return array1.toSet()\n            .filter { substring -> array2.any { substring in it} }\n            .sorted()\n            .toTypedArray()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205899,"user_id":null,"body":"fun inArray(array1: Array<String>, array2: Array<String>) = array1.distinct()\n    .filter{ array2.any { s -> s.contains(it) } }\n    .sorted()\n    .toTypedArray()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205900,"user_id":null,"body":"fun inArray(array1: Array<String>, array2: Array<String>) =\n    array1.filter { array2.joinToString(\" \").contains(it) }.toSortedSet().toTypedArray()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205901,"user_id":null,"body":"private fun Array<String>.anyContains(s: String) = any { it.contains(s) }\nfun inArray(a1: Array<String>, a2: Array<String>) = a1.filter(a2::anyContains).toSortedSet().toTypedArray()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205902,"user_id":null,"body":"fun inArray(array1: Array<String>, array2: Array<String>) = array1.toSortedSet().filter { it in array2.joinToString() }.toTypedArray()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205903,"user_id":null,"body":"    fun inArray(array1: Array<String>, array2: Array<String>): Array<String> {\n        return array1.distinct().filter { sub -> array2.any { word -> sub in word } }.sorted().toTypedArray()\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205904,"user_id":470,"body":"fun inArray(r1: Array<String>, r2: Array<String>): Array<String> = r1.distinct().filter { s -> r2.any { it.contains(s) } }.sorted().toTypedArray()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205905,"user_id":null,"body":"fun inArray(array1: Array<String>, array2: Array<String>): Array<String> {\n    var inArr = arrayOf<String>()\n    array1.forEach { arr1 ->\n        array2.forEach { arr2 ->\n            if (arr2.contains(arr1)) inArr += arr1\n        }\n    } \n    return inArr.sortedArray().distinct().toTypedArray()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205906,"user_id":null,"body":"fun inArray(array1: Array<String>, array2: Array<String>): Array<String> =\n  array1.sortedArray().filter{a1 -> array2.any { a2 -> a2.contains(a1) }}.distinct().toTypedArray()\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5506b230a11c0aeab3000c1f":[{"id":205907,"user_id":null,"body":"fun evaporator(content: Double, evap_per_day: Double, threshold: Double): Int {\n  var prc = 100.0\n  var day = 0\n  \n  while(prc > threshold) {\n    prc -=  prc * evap_per_day \/ 100\n    day++\n  }\n\n  return day\n}\n\n","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205908,"user_id":null,"body":"fun evaporator(content: Double, evap_per_day: Double, threshold: Double): Int = Math.ceil(Math.log(threshold \/ 100) \/ Math.log(1 - (evap_per_day \/ 100))).toInt()","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205909,"user_id":null,"body":"fun evaporator(content: Double, evap_per_day: Double, threshold: Double): Int {\n    tailrec fun evaporatorInternal(amount: Double, evap_per_day: Double, threshold: Double, days: Int): Int {\n        if (amount <= threshold) {\n            return days\n        }\n        return evaporatorInternal(amount - amount * (evap_per_day \/ 100), evap_per_day, threshold, days + 1)\n    }\n    return evaporatorInternal(100.0, evap_per_day, threshold, 0)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205910,"user_id":null,"body":"fun evaporator(content: Double, evap_per_day: Double, threshold: Double): Int {\n    val thresh = content * (threshold \/ 100.0)\n    tailrec fun evapRec(content: Double, days: Int = 0): Int {\n        return if (content <= thresh) days\n        else evapRec(content - (content * (evap_per_day \/ 100.0)), days + 1)\n    }\n    return evapRec(content, 0)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205911,"user_id":null,"body":"fun evaporator(content: Double, evap_per_day: Double, threshold: Double): Int { \n    var current = content\n    var days = 0\n    while (current > (content * threshold \/ 100.0)) {\n        days++\n        current-= (current * evap_per_day\/100.0)\n    }\n  return days;\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205912,"user_id":null,"body":"    fun evaporator(content: Double, evap_per_day: Double, threshold: Double): Int {\n        var days = 0\n        var cont = content\n\n        while (cont > ((content \/ 100) * threshold)) {\n            cont -= ((cont \/ 100) * evap_per_day)\n            days++\n        }\n\n        return days\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205913,"user_id":null,"body":"fun evaporator(content: Double, evap_per_day: Double, threshold: Double): Int = generateSequence(content) { it - (it \/ 100 * evap_per_day) }\n    .takeWhile { it > content \/ 100 * threshold }\n    .count()\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205914,"user_id":null,"body":"fun evaporator(content: Double, evap_per_day: Double, threshold: Double): Int { \n    var currentContent = content\n    var trueThreshold = content \/ 100.0 * threshold\n    var result = 0\n    while (currentContent > trueThreshold) {\n        currentContent = currentContent - ((currentContent \/ 100.0) * evap_per_day)\n        result = result + 1\n    }\n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205915,"user_id":null,"body":"fun evaporator(content: Double, evap_per_day: Double, threshold: Double): Int { \n    var day = 1\n    var neContent  = content\n    val maxCount  = content*threshold\/100\n    var inc = neContent - (neContent*evap_per_day\/100)\n    while (inc > maxCount) {\n        inc = inc - (inc*evap_per_day\/100)\n        day++\n    }\n    return day;\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205916,"user_id":null,"body":"fun evaporator(content: Double, evap_per_day: Double, threshold: Double): Int {\n    var days = 0\n    var left = content\n\n    val end = content \/ 100 * threshold\n\n    while(left > end){\n        left -= left \/ 100 * evap_per_day\n\n        days++\n    }\n\n    return days;\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"550f22f4d758534c1100025a":[{"id":205917,"user_id":null,"body":"package solution\n\nobject dir_reduc {\n    fun dir_reduc(arr: Array<String>): Array<String> {\n        if (arr.size <= 1) return arr\n\n        val stack = java.util.Stack<String>()\n        val oppositeOf = mapOf(\n            \"WEST\" to \"EAST\", \"EAST\" to \"WEST\",\n            \"SOUTH\" to \"NORTH\", \"NORTH\" to \"SOUTH\"\n        )\n\n        for (direction in arr) when {\n            stack.empty() -> stack.push(direction)\n            stack.peek() == oppositeOf[direction] -> stack.pop()\n            else -> stack.push(direction)\n        }\n\n        return stack.toTypedArray()\n    } \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205918,"user_id":null,"body":"package solution\n\nimport java.util.Stack\n\nobject dir_reduc {\n    private const val NORTH = \"NORTH\"\n    private const val EAST = \"EAST\"\n    private const val SOUTH = \"SOUTH\"\n    private const val WEST = \"WEST\"\n    private val OPPOSITES = setOf(\n        NORTH to SOUTH,\n        SOUTH to NORTH,\n        EAST to WEST,\n        WEST to EAST\n    )\n    \n    fun dir_reduc(arr: Array<String>): Array<String> {\n        val stack = Stack<String>()\n\n        arr.forEach { direction ->\n            if (stack.isNotEmpty() && direction to stack.peek() in OPPOSITES) {\n                stack.pop()\n            } else {\n                stack.push(direction)\n            }\n        }\n\n        return stack.toTypedArray()\n\n    }\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205919,"user_id":null,"body":"package solution\n\nobject dir_reduc {\n    fun oppositeTo(direction: String): String = when (direction) {\n        \"NORTH\" -> \"SOUTH\"\n        \"SOUTH\" -> \"NORTH\"\n        \"EAST\" -> \"WEST\"\n        \"WEST\" -> \"EAST\"\n        else -> \"\"\n    }\n\n    fun dir_reduc(arr: Array<String>): Array<String> = arr.fold(listOf<String>()) { acc, dir ->\n        if (acc.lastOrNull() == oppositeTo(dir)) acc.take(acc.size - 1) else acc.plus(dir)\n    }.toTypedArray()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205920,"user_id":null,"body":"package solution\n\nimport java.util.*\n\nobject dir_reduc {\n    fun dir_reduc(arr: Array<String>): Array<String> {\n        val s = Stack<String>()\n        arr.forEach {\n            when (it) {\n                \"NORTH\" -> if (s.isNotEmpty() && s.peek() == \"SOUTH\") s.pop() else s.push(it)\n                \"SOUTH\" -> if (s.isNotEmpty() && s.peek() == \"NORTH\") s.pop() else s.push(it)\n                \"EAST\" -> if (s.isNotEmpty() && s.peek() == \"WEST\") s.pop() else s.push(it)\n                \"WEST\" -> if (s.isNotEmpty() && s.peek() == \"EAST\") s.pop() else s.push(it)\n            }\n        }\n\n        return s.toList().toTypedArray()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205921,"user_id":null,"body":"package solution\n\nobject dir_reduc {\n  fun dir_reduc(arr: Array<String>) =\n    generateSequence(arr.toList()) { list ->\n        list.withIndex().windowed(2)\n            .find { (l, r) -> listOf(\"NORTH\" to \"SOUTH\", \"EAST\" to \"WEST\").any { setOf(l.value, r.value) == setOf(it.first, it.second) } }\n            ?.let { (l, r) -> list.slice(0 until l.index) + list.slice(r.index + 1..list.lastIndex) }\n    }.takeWhile { it != null }.last().toTypedArray()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205922,"user_id":null,"body":"package solution\n\nfun opposite(dir: String): String = when (dir) {\n    \"NORTH\" -> \"SOUTH\"\n    \"SOUTH\" -> \"NORTH\"\n    \"EAST\" -> \"WEST\"\n    else -> \"EAST\"\n}\n\nobject dir_reduc {\n    fun dir_reduc(arr: Array<String>): Array<String> {\n        val reduced = mutableListOf<String>()\n        arr.forEach {\n            if (reduced.isEmpty() || reduced.last() != opposite(it))\n                reduced.add(it)\n            else\n                reduced.removeAt(reduced.size-1)\n        }\n\n        return reduced.toTypedArray()\n    } \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205923,"user_id":null,"body":"package solution\n\nobject dir_reduc {\n    fun dir_reduc(arr: Array<String>) = arr.map{it.uppercase()}.toMutableList().apply {\n                var ptr = 0\n                var found = false\n                do {\n                    if(size<2) break\n                    if(ptr==0) found = false\n                    val two = listOf(this[ptr],this[ptr+1]).sorted().joinToString(\" \")\n                    if(two in \"NORTH SOUTH  EAST WEST\") {\n                        (0..1).forEach{removeAt(ptr)}\n                        found = true\n                    }\n                    ptr++; if(ptr>size-2) ptr = 0\n                } while( !(ptr==0 && found==false) )             \n        }.toTypedArray()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205924,"user_id":null,"body":"package solution\n\nobject dir_reduc {\n    fun dir_reduc(arr: Array<String>): Array<String> {\n        return arr.reductionDir()\n    } \n}\n\nfun Array<String>.reductionDir(): Array<String> = this.withIndex().forEachIndexed { index, indexedValue -> if (index != this.lastIndex) {\n    Pair(indexedValue.value, this[index + 1]).let {\n    if (it == Pair(\"NORTH\", \"SOUTH\") || it == Pair(\"SOUTH\", \"NORTH\") || it == Pair(\"EAST\", \"WEST\") || it == Pair(\"WEST\", \"EAST\")) {\n        return this.toMutableList().apply { removeAt(index + 1); removeAt(index) }.toTypedArray().reductionDir() } } }\n}.let { return this }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205925,"user_id":492,"body":"package solution\n\nobject dir_reduc {\n    fun dir_reduc(arr: Array<String>): Array<String> {\n        val directions = arr.toMutableList()\n        var i = 0\n        while (i + 1 < directions.size) {\n            if (\"NORTHSOUTH,SOUTHNORTH,EASTWEST,WESTEAST\".contains(directions[i] + directions[i + 1])) {\n                directions.removeAt(i + 1)\n                directions.removeAt(i)\n                i = -1\n            }\n            i++\n        }\n        return directions.toTypedArray()\n    } \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205926,"user_id":null,"body":"package solution\n\nobject dir_reduc {\n    fun dir_reduc(arr: Array<String>): Array<String> {\n                var instruction = arr.joinToString(\" \")\n        var optimize: Boolean = true\n        while (optimize) {\n            optimize = false\n            if (instruction.contains(\"NORTH SOUTH\")){\n                instruction = instruction.replace(\"NORTH SOUTH\", \"\")\n                optimize = true\n            } else if (instruction.contains(\"SOUTH NORTH\")){\n                instruction = instruction.replace(\"SOUTH NORTH\", \"\")\n                optimize = true\n            } else if (instruction.contains(\"EAST WEST\")){\n                instruction = instruction.replace(\"EAST WEST\", \"\")\n                optimize = true\n            } else if (instruction.contains(\"WEST EAST\")){\n                instruction = instruction.replace(\"WEST EAST\", \"\")\n                optimize = true\n            } \n            while (instruction.contains(\"  \")) {\n                instruction = instruction.replace(\"  \",\" \")\n            }\n        }\n        return instruction.trim(' ').split(\" \").toTypedArray()\n    } \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5511b2f550906349a70004e1":[{"id":205927,"user_id":null,"body":"import java.math.BigInteger;\nfun last_digit(base: BigInteger, exponent: BigInteger) =\n        base.modPow(exponent, BigInteger.TEN).toInt()","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205928,"user_id":null,"body":"import java.math.BigInteger;\nfun last_digit(base: BigInteger, exponent: BigInteger): Int = base.modPow(exponent,BigInteger(\"10\")).toInt()\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205929,"user_id":null,"body":"import java.math.BigInteger;\n\nfun last_digit(base: BigInteger, exponent: BigInteger): Int {\n\n    if(exponent == BigInteger.ZERO) return 1\n\n    val baseLastDigit = base.toString().takeLast(1).toInt()\n\n    return getDigitFromSet(when (baseLastDigit) {\n        2 -> arrayListOf(6, 2, 4, 8)\n        3 -> arrayListOf(1, 3, 9, 7)\n        4 -> arrayListOf(6, 4)\n        7 -> arrayListOf(1, 7, 9, 3)\n        8 -> arrayListOf(6, 8, 4, 2)\n        9 -> arrayListOf(1, 9)\n        else -> arrayListOf(baseLastDigit)\n    }, exponent)\n}\n\nfun getDigitFromSet(digitsSet: List<Int>, exponent: BigInteger)  = digitsSet[moduloAsInt(exponent, digitsSet.size)]\n\nfun moduloAsInt(exponent: BigInteger, m: Int) = exponent.mod(m.toBigInteger()).toInt()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205930,"user_id":null,"body":"import java.math.BigInteger;\nfun last_digit(base: BigInteger, exponent: BigInteger): Int = \n  base.modPow(exponent, BigInteger.TEN).toInt()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205931,"user_id":null,"body":"import java.math.BigInteger;\nfun last_digit(base: BigInteger, exponent: BigInteger) = base.modPow(exponent, BigInteger.TEN).toString().last().digitToInt()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205932,"user_id":null,"body":"import java.math.BigInteger;\n\nfun ipow(base :Long, exponent :UByte) :Long {\n    var prod = 1L\n    var factor = base\n    var exp = exponent\n    while (exp>0u) {\n        if (exp%2u==1u)\n          prod *= factor\n        factor *= factor\n        exp = (exp\/2u).toUByte()\n    }\n    return prod\n}\n\nfun last_digit(base: BigInteger, exponent: BigInteger): Int {\n    if (exponent<=BigInteger.ZERO)\n      return 1\n    val last_digit = base.mod(BigInteger.TEN).toInt()\n    val phi10 = BigInteger(\"4\")\n    val rem = if (exponent>=phi10) (4+exponent.mod(phi10).toInt()).toUByte()\n      else exponent.toInt().toUByte()\n    return (ipow(last_digit.toLong(), rem) % 10).toInt()\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205933,"user_id":53,"body":"import java.math.BigInteger;\n\nfun strMod(n1: Int, n2: String): Int {\n    var ans = 0\n    var p: Int\n    for (i in 0 until n2.length) {\n        p = Character.getNumericValue(n2[i])\n        ans = (ans * 10 + p).rem(n1)\n    }\n    return ans\n}\n\nfun last_digit(base: BigInteger, exponent: BigInteger): Int {\n    val a = base.toString()\n    val b = exponent.toString()\n    val n = a.length\n    val m = b.length\n    if (m == 1 && b[0] == '0') return 1\n    if (n == 1 && a[0] == '0') return 0\n    val exp = if (strMod(4, b) == 0) 4 else strMod(4, b)\n    val ans = Math.pow(Character.getNumericValue(a[n - 1]).toDouble(), exp.toDouble()).toLong()\n    return ans.rem(10).toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205934,"user_id":null,"body":"import java.math.BigInteger;\nimport kotlin.math.pow\n\nfun last_digit(base: BigInteger, exponent: BigInteger): Int {\n  val result: BigInteger = base.modPow(exponent, 10.toBigInteger())\n  return result.toString().last().toString().toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205935,"user_id":null,"body":"import java.math.BigInteger;\n    \nval baseMap = mapOf<Int,List<Int>>(\n    Pair(2, listOf(6,2,4,8)),\n    Pair(3, listOf(1,3,9,7)),\n    Pair(4, listOf(6,4)),\n    Pair(7, listOf(1,7,9,3)),\n    Pair(8, listOf(6,8,4,2)),\n    Pair(9, listOf(1,9))\n)\n\nfun last_digit(base: BigInteger, exponent: BigInteger): Int {\n    if (exponent == BigInteger.ZERO) return 1\n    val simpleBase = base.mod(BigInteger.TEN).toInt()\n    val results = baseMap[simpleBase] ?: return simpleBase\n    val simpleExponent = exponent.mod(results.size.toBigInteger()).toInt()\n    return results[simpleExponent]\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205936,"user_id":null,"body":"import java.math.BigInteger;\nfun last_digit(base: BigInteger, exponent: BigInteger): Int {\n    val expoMinusOne = exponent.minus(BigInteger.ONE)\n    val four = BigInteger.valueOf(4L)\n    return if (exponent == BigInteger.ZERO) {\n        1\n    } else {\n        when (base.toString().last().digitToInt()) {\n            0 -> 0\n            1 -> 1\n            2 -> listOf(2, 4, 8, 6)[expoMinusOne.mod(four).toInt()]\n            3 -> listOf(3, 9, 7, 1)[expoMinusOne.mod(four).toInt()]\n            4 -> listOf(4, 6)[expoMinusOne.mod(BigInteger.TWO).toInt()]\n            5 -> 5\n            6 -> 6\n            7 -> listOf(7, 9, 3, 1)[expoMinusOne.mod(four).toInt()]\n            8 -> listOf(8, 4, 2, 6)[expoMinusOne.mod(four).toInt()]\n            else -> listOf(9, 1)[expoMinusOne.mod(BigInteger.TWO).toInt()]\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5517fcb0236c8826940003c9":[{"id":205937,"user_id":53,"body":"package solution\n\nobject SumFractions {\n    \n    fun gcd(a:Long, b:Long): Long = if (b == 0L) a else gcd(b, a % b)\n    \n    fun sumFracts(xss: Array<IntArray>): String {\n        val d = xss.fold(1L) { acc, xs -> acc * xs[1] }\n        val n = xss.fold(0L) { acc, xs -> acc + xs[0] * d \/ xs[1] }\n        val g = gcd(d, n)\n        if (xss.size == 0) {\n            return \"\"\n        } else if (g == d) {\n            return \"${n \/ g}\"\n        } else {\n            return \"[${n \/ g}, ${d \/ g}]\"\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205938,"user_id":null,"body":"package solution\nimport java.math.BigInteger.ZERO as ZERO\nimport java.math.BigInteger.ONE as ONE\n\nobject SumFractions {    \n\n    fun sumFracts(l: Array<IntArray>) = if(l.isEmpty()) \"\"\n        else getSum(l).let {\n            if( it[0] % it[1] == ZERO) \"${ it[0] \/ it[1] }\"\n            else it.joinToString(\", \", \"[\", \"]\")\n        }\n\n    fun getSum(l: Array<IntArray>) =\n        l.map { arrayOf(it[0].toBigInteger(), it[1].toBigInteger()) }\n            .run {\n                var d = fold(ONE) { acc, i -> acc * i[1] }\n                var n = fold(ZERO) { acc, i -> acc + (i[0] * d) \/ i[1] }\n                d.gcd(n).let { d \/= it; n \/= it }\n                arrayOf(n, d)\n            }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205939,"user_id":759,"body":"package solution\n\nobject SumFractions {\n  fun gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\n  fun lcm(a: Int, b: Int): Int = a \/ gcd(a, b) * b\n  fun sumFracts(l: Array<IntArray>): String = when (l.size) {\n    0 -> \"\"\n    1 -> \"[${l[0][0]}, ${l[0][1]}]\"\n    else -> {\n      var g = l.map { it[1] }.reduce { a, b -> lcm(a, b) }\n      var s = 0\n      for (x in l) s += x[0] * (g \/ x[1])\n      val g2 = gcd(s, g)\n      g \/= g2\n      s \/= g2\n      if (g == 1) \"$s\" else \"[$s, $g]\"\n    }\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205940,"user_id":null,"body":"package solution\n\nobject SumFractions {\n    \n    fun sumFracts(l: Array<IntArray>): String {\n        if(l.isNullOrEmpty()) return \"\"\n        \n       val str= l.reduce {a,b->\n            val m = a[0]*b[1]+a[1]*b[0]\n            val n = a[1]*b[1]\n            val g = gcd(m,n)\n            intArrayOf(m\/g, n\/g)\n        }\n        return if(str[1]==1) \"${str[0]}\" else \"[${str[0]}, ${str[1]}]\"\n    }\n    \n    fun gcd(a:Int, b:Int): Int {\n        if(b==0) return a\n        return gcd(b, a%b)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205941,"user_id":932,"body":"package solution\n\nobject SumFractions {\n\n    private tailrec fun gcd(a: Int, b: Int): Int{\n        return when{\n            a < b -> gcd(a, b-a)\n            a > b -> gcd(a-b, b)\n            else -> a\n        }\n    }\n\n    private fun lcm(a: Int, b: Int)=a*b\/gcd(a,b)\n\n    fun sumFracts(l: Array<IntArray>)=if (l.isEmpty()) \"\" else l.map{it[1]}.reduce{ acc, i ->lcm(acc,i)}.let{denom->\n        val number = l.sumBy{it[0]*denom\/it[1]}\n        gcd(number, denom).let{if (denom==it)\"${number\/it}\" else \"[${number\/it}, ${denom\/it}]\"}\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205942,"user_id":null,"body":"package solution\nimport java.math.BigInteger\n\nobject SumFractions {\n    \n    fun sumFracts(l: Array<IntArray>): String {\n        \n        fun IntArray.red() = if(first() == 0) intArrayOf(0, 1) else BigInteger.valueOf(first().toLong()).gcd(BigInteger.valueOf(last().toLong())).toInt().let{ intArrayOf(first() \/ it, last() \/ it) }\n\n        operator fun IntArray.plus(q: IntArray) = intArrayOf(first() * q.last() + q.first() * last(), last() * q.last()).red()\n        \n        return if(l.isEmpty()) \"\" else l.reduce(IntArray::plus).let{ (n, d) -> if(d == 1) \"$n\" else \"[$n, $d]\" }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205943,"user_id":null,"body":"package solution\n\nobject SumFractions {\n    fun gcd(a: Int, b: Int): Int {\n        var n1 = a\n        var n2 = b\n        while (n1 != n2) {\n            if (n1 < n2) n2 -= n1 else n1 -= n2\n        }\n        return n1\n    }\n    fun sumFracts(l: Array<IntArray>): String {\n        if (l.isEmpty()) return \"\"\n        val den = l.fold(1){acc, v -> acc * v[1]}\n        return l.fold(Pair(0, den)){acc, v -> Pair(acc.first + v[0] * den \/ v[1], den)}\n            .run{ if (this.second \/ gcd(this.first, this.second) == 1) \"${this.first \/ gcd(this.first, this.second)}\"\n                else \"[${this.first \/ gcd(this.first, this.second)}, ${this.second \/ gcd(this.first, this.second)}]\"\n            }            \n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205944,"user_id":null,"body":"package solution\n\nobject SumFractions {\n    \n    fun sumFracts(l: Array<IntArray>): String {\n        if (l.isEmpty()) return \"\"\n        var denom = l.map{it.last()}.reduce{a,b->a*b}\n        var numer: Int = 0\n        l.forEach {\n            numer+=(it.first()*denom\/it.last())\n        }\n        var nod: Int = nod(numer, denom)\n        return if (denom\/nod > 1) listOf(numer\/nod, denom\/nod).joinToString(prefix = \"[\", postfix = \"]\", separator = \", \") else listOf(numer\/nod).joinToString(\", \")\n    }\n  \n    fun nod(num: Int, den: Int): Int {\n        var res: Int = Math.min(num,den)\n        var x = Math.max(num,den).toInt()\n        var y = Math.min(num,den).toInt()\n        while (x.mod(y) > 0) {\n            res = x.mod(y)\n            x = y\n            y = res\n        }\n        return res\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205945,"user_id":null,"body":"package solution\n\nobject SumFractions {\n    \n    fun sumFracts(l: Array<IntArray>): String {\n        if (l.isEmpty()) return \"\"\n    \tvar denom = l.map{it.last()}.reduce{a,b->a*b}\n        var numer: Int = 0\n        l.forEach {\n            println(it.toList())\n            numer+=(it.first()*denom\/it.last())\n        }\n        var nod: Int = nod(numer, denom)\n        return if (denom\/nod > 1) listOf(numer\/nod, denom\/nod).joinToString(prefix = \"[\", postfix = \"]\", separator = \", \") else listOf(numer\/nod).joinToString(\", \")\n    }\n  \n    fun nod(num: Int, den: Int): Int {\n        var res: Int = Math.min(num,den)\n        var x = Math.max(num,den).toInt()\n        var y = Math.min(num,den).toInt()\n        while (x.mod(y) > 0) {\n\t\t    res = x.mod(y)\n            x = y\n            y = res\n        }\n        println(res)\n        return res\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205946,"user_id":null,"body":"package solution\n\nobject SumFractions {\n    \n    fun evklid(a:Int, b:Int) :Int = if (a % b == 0) b else evklid(b, a%b)\n\nfun sumFracts(l: Array<IntArray>): String {\n    if (l.isEmpty()) return \"\"\n    l.forEach { elem -> elem.map { it \/ evklid(elem[0], elem[1]) } }\n    var common = l[0][1]\n    l.forEach {\n        common = common * it[1] \/ evklid(common, it[1])\n    }\n    val numenator = l.sumOf { it[0] * common \/ it[1] }\n\n    return when {\n        numenator % common == 0 -> \"${numenator \/ common}\"\n        else -> \"[${numenator \/ evklid(numenator, common)}, ${common \/ evklid(numenator, common)}]\"\n    }\n}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"55192f4ecd82ff826900089e":[{"id":205947,"user_id":null,"body":"fun divide(weight: Int) = weight%2 == 0 && weight != 2 ","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205948,"user_id":null,"body":"object Watermelon {\n    fun divide(weight: Int): Boolean {\n        return weight > 2 && weight % 2 == 0\n    }\n}\n","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205949,"user_id":null,"body":"object Watermelon {\n    fun divide(weight: Int) = weight > 2 && weight%2 == 0\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205950,"user_id":null,"body":"object Watermelon {\n    fun divide(weight: Int): Boolean {\n        \/\/TODO(\"Write your code implementation here\")\n\n        if(weight%2 != 0){\n            return false\n        }\n        else if (weight == 2){\n            return false\n        }\n        else{\n            if((weight-2)%2 == 0){\n            return true\n                }\n            else{\n                return false\n            }\n        }\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205951,"user_id":932,"body":"object Watermelon {\n    fun divide(n: Int)=(n>3)&&(n%2==0)\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205952,"user_id":null,"body":"object Watermelon {\n    fun divide(weight: Int): Boolean {\n        \n        val mid = weight \/ 2\n        val midIsEven = mid % 2 == 0\n        \n        var bool = false\n        \n        if(midIsEven){\n            if(mid * 2 == weight)\n                bool = true\n        }else {\n           val num1 = mid + 1\n           val num2 = mid - 1\n            println(\"Mid not even $weight - $num1,${num1%2} - $num2,${num2%2} - ${num1+num2}\")\n           if(num1 %2 == 0 && num2 %2 == 0 && num1+num2 == weight && num2 != 0){\n               bool = true\n           }\n           \n           \n        }\n       println(\"$weight - $mid - $bool\")\n        return bool\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205953,"user_id":null,"body":"object Watermelon {\n    fun divide(weight: Int): Boolean = weight > 2 && weight % 2 == 0\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205954,"user_id":null,"body":"object Watermelon {\n    fun divide(weight: Int): Boolean {\n        if (weight in 0..3) return false\n        var weightCopy = weight\n        var ints = listOf<Int>()\n        var accumulator: Int\n        var flag = false\n        while (weightCopy != 0){\n            ints = ints.plus(weightCopy)\n            weightCopy--\n            }\n        ints = ints.filter{ it%2==0 }\n\n        outer@for (i in ints){\n            accumulator = i\n            for (j in ints){\n                if (accumulator+j == weight){\n                    flag = true\n                    break@outer\n                }\n            }\n        }\n        return flag\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205955,"user_id":null,"body":"object Watermelon {\n    fun divide(weight: Int) =\n            if (weight == 2) false\n            else weight % 2 == 0\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205956,"user_id":null,"body":"object Watermelon {\n    fun divide(w: Int): Boolean {\n    return  (w in 3..100 && w % 2 == 0 )\n   }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"551dd1f424b7a4cdae0001f0":[{"id":205957,"user_id":null,"body":"package doublecola\n\nfun who_is_next(names: List<String>, n: Int): String = names[generateSequence(n) { (it - names.lastIndex) \/ 2 }.takeWhile { it > 0 }.last() - 1]\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205958,"user_id":null,"body":"package doublecola\n\nfun who_is_next(names: List<String>, n: Int): String {\n    var c = n - 1\n    while (c >= names.size) c = (c-names.size)\/2\n    return names[c]\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205959,"user_id":null,"body":"package doublecola\n\nimport kotlin.math.ln\nimport kotlin.math.pow\n\nfun who_is_next(names: List<String>, n: Int): String {\n    val powerOfTwo = (ln((n + names.size) \/ names.size.toDouble()) \/ ln(2.0)).toInt()\n    val gap = names.size * 2.0.pow(powerOfTwo)\n    val startingBorder = gap - names.size\n    val percentage = (n - 1 - startingBorder) \/ gap\n    return names[(percentage * names.size).toInt()]\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205960,"user_id":null,"body":"package doublecola\n\nimport kotlin.math.*\n\nfun who_is_next(names: List<String>, n: Int): String {\n\n  var i = n;\n  var k = 0;\n  var j = 0;\n  \n  while (i > 0) {\n    k = i\n    i = i - names.size * (2.toDouble().pow(j++).toInt())\n  }\n    \n  return names.get(Math.ceil(k.toDouble() \/ 2.toDouble().pow(j - 1).toInt()).toInt() - 1)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205961,"user_id":null,"body":"package doublecola\n\nimport kotlin.math.pow\n\nfun who_is_next(names: List<String>, n: Int): String {\n    \/\/Your code goes here\n\n    var total = 0.0\n    var previous = 0.0\n    var i = 0\n    while (total < n) {\n        previous = total\n        total += names.size * 2.0.pow(i)\n        i++\n    }\n    val lineLength = ((total - previous) \/ names.size).toInt()\n    val rank = (n - previous).toInt() -1\n    val index = rank \/ lineLength\n\/\/    println(\"$i $previous $total $rank $lineLength $index\")\n    return names[index]\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205962,"user_id":null,"body":"package doublecola\n\nimport kotlin.math.pow\n\nfun who_is_next(names: List<String>, n: Int, prev:Int = 0, pow:Int = 0): String {\n    val size = names.size\n    val pow2 = 2.toDouble().pow(pow.toDouble()).toInt()\n    val now = prev + size* pow2\n    if(n <= now) {\n        (1..size).forEach{\n            val n1 = prev+(it-1)*pow2\n            val n2 = prev+it*pow2\n            if(n1 < n && n <= n2){\n                return names[it-1]\n            }\n        }\n    } else {\n        return who_is_next(names, n, now, pow+1)\n    }\n    return \"\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205963,"user_id":null,"body":"package doublecola\n\nimport java.util.LinkedList\n\nfun who_is_next(names: List<String>, n: Int): String {\n    if (n < 1) {\n        return \"\"\n    }\n    \n    var i: Long = 1\n    var previousSize:Long = 0\n    var size: Long= names.size.toLong()\n    \n    \n    \n    while (size > 0) {\n        if (n <= size) {\n            var temp = n.toLong() - previousSize\n            for (name in names) {\n                if (temp <= i) {\n                    return name\n                } else {\n                    temp -= i\n                }\n            }\n            return \"fail\"\n        } else {\n            i *= 2\n            previousSize = size\n            size = size + i * names.size\n        }\n    }\n  \n    return \"\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205964,"user_id":null,"body":"package doublecola\n\n\nfun who_is_next(names: List<String>, n: Int): String {\n        val pairNames = mutableMapOf<String, IntRange>()\n        var finalName = \"\"\n        var index = 1\n        var position = names.size * (index) + 1\n        if (n <= names.size) {\n            return names[n - 1]\n        } else {\n            while (position <= n) {\n                index *= 2\n                for ((value, counter) in (1..names.size).withIndex()) {\n                    pairNames[names[value]] = position + index * value until position + (index * counter)\n                }\n                position += names.size * (index)\n            }\n        }\n        pairNames.forEach { (t, u) ->\n            val isTrue = u.contains(n)\n            if (isTrue) {\n                finalName = t\n            }\n        }\n        return finalName\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205965,"user_id":null,"body":"package doublecola\n\nfun who_is_next(names: List<String>, n: Int): String {\n  val queue = names.map { it to 1 }.toMutableList()\n    \n    var currentPerson = queue.first().first\n    var step = 1L\n    while(step <= n){\n        val pair = queue.removeAt(0)\n        currentPerson = pair.first\n        step+= pair.second\n        queue.add(pair.first to pair.second*2)\n    }\n\n    return currentPerson\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205966,"user_id":null,"body":"package doublecola\n\n\nfun who_is_next(names: List<String>, n: Int): String {\n    return names[who_is_nextIndex(names.size,n-1)]\n}\n\nfun who_is_nextIndex(length: Int, n: Int): Int {\n    val power = (n\/length +1).takeHighestOneBit()\n    val index = n-length*(power-1)\n    return index\/power\n}\n\n\/\/ provided since version 1.4\nfun Int.takeHighestOneBit(): Int{\n    var res = 0\n    for (i in this downTo 1) {\n\n        \/\/ If i is a power of 2\n        if (i and i - 1 == 0) {\n            res = i\n            break\n        }\n    }\n    return res\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5526fc09a1bbd946250002dc":[{"id":205967,"user_id":null,"body":"fun find(integers: Array<Int>) = integers.singleOrNull { it % 2 == 0 } ?: integers.single { it % 2 != 0 }\n","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205968,"user_id":1153,"body":"fun find(integers: Array<Int>): Int {\n  val (even, odd) = integers.partition { it % 2 == 0 }\n  return if (even.size == 1) even[0] else odd[0]\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205969,"user_id":null,"body":"fun find(integers: Array<Int>): Int {\n    val evens = integers.filter { it % 2 == 0 }\n    val odds = integers.filter { it % 2 != 0 }\n    return if(evens.size == 1){\n        evens.first()\n    }else{\n        odds.first()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205970,"user_id":null,"body":"fun find(integers: Array<Int>): Int =\n    if( integers.take(3).count {it % 2 == 0} > 1 )\n        integers.first {it % 2 != 0}\n    else\n        integers.first {it % 2 == 0}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205971,"user_id":null,"body":"fun find(integers: Array<Int>) = integers.partition { it % 2 == 0 }.toList().minBy { it.size }!![0]","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205972,"user_id":null,"body":"fun find(integers: Array<Int>): Int {\n    val even = integers.filter { it % 2 == 0 }\n    val odd = integers.filter { it % 2 != 0 }\n    if (even.size > odd.size)\n        return odd[0]\n    else\n        return even[0]\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205973,"user_id":null,"body":"import kotlin.math.abs\n\nfun find(integers: Array<Int>): Int {\n    var target = 1\n    if (integers.slice(0..2).asSequence().map { abs(it % 2) }.sum() > 1) {\n        target = 0\n    }\n    return integers.first { abs(it % 2) == target }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205974,"user_id":null,"body":"fun find(integers: Array<Int>): Int =\n    integers.groupBy { it % 2 == 0 }.values.first { it.size == 1 }.first()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205975,"user_id":null,"body":"fun find(integers: Array<Int>): Int {\n    \n    var cnt = 0\n    \n    for(i in 0..2)\n    {\n        if(integers.get(i) % 2 == 0) \n            cnt ++\n    }\n    \n    if(cnt >= 2)\n    {\n        for(i in integers)\n            if(i % 2 != 0)\n                return i\n    }   \n    else\n    {\n        for(i in integers)\n            if(i % 2 == 0)\n                return i\n    }\n    \n  return 0\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205976,"user_id":null,"body":"fun find(integers: Array<Int>): Int {\n    return if (integers[0].isOdd() == integers[1].isOdd()) {\n        integers.find { it.isOdd() != integers[0].isOdd() }!!\n    } else {\n        integers.find { it.isOdd() != integers[2].isOdd() }!!\n    }\n}\n\nfun Int.isOdd() = this % 2 == 0","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5536a85b6ed4ee5a78000035":[{"id":205977,"user_id":null,"body":"package solution\n\nobject Tour {\n\n    fun tour(arrFriends: Array<String>, ftwns: Array<Array<String>>, h: Map<String, Double>): Int {\n \n        val towns = ftwns.map{Pair(it[0],it[1])}.toMap()\n        val visits = arrFriends.mapNotNull{towns.get(it)}\n        val distances = visits.mapNotNull{h.get(it)}.toMutableList().apply{add(last())}\n        val circuit = mutableListOf<Double>().apply{addAll(distances)}\n        \n        if(distances.size>1) (1..distances.size-2).forEach {ind->\n                val a = distances[ind-1]\n                val c = distances[ind]\n                val b = Math.sqrt(c*c-a*a)\n                circuit[ind] = b\n        }\n        return circuit.sum().toInt()\n     }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205978,"user_id":932,"body":"package solution\n\nobject Tour {\n    fun tour(arrFriends: Array<String>, ftwns: Array<Array<String>>, h: Map<String, Double>)=ftwns.filter {it.first() in arrFriends}.map{it.last()}.let{ft->\n        (ft.windowed(2).map{(h[it.last()]!!.sqr()-h[it.first()]!!.sqr()).sqrt()}.sum()+h[ft.first()]!!+h[ft.last()]!!).toInt()}\n}\n\nfun Double.sqr() = this*this\nfun Double.sqrt() = Math.sqrt(this)\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205979,"user_id":null,"body":"package solution\n\nimport kotlin.math.pow\nimport kotlin.math.sqrt\n\nobject Tour {\n\n    fun tour(arrFriends: Array<String>, ftwns: Array<Array<String>>, h: Map<String, Double>): Int {\n    val m = arrFriends.mapNotNull { friend -> h[ftwns.find { it.first() == friend }?.get(1)] }\n    return m.foldIndexed(m.first()) { index, acc, d ->\n        if (index == m.lastIndex) acc + d else acc + sqrt(m[index + 1].pow(2) - d.pow(2))\n        }.toInt()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205980,"user_id":null,"body":"package solution\n\nimport kotlin.math.sqrt\n\n\/**\n * https:\/\/www.codewars.com\/kata\/5536a85b6ed4ee5a78000035\/train\/kotlin\n *\/\nobject Tour {\n\n    fun tour(arrFriends: Array<String>, ftwns: Array<Array<String>>, h: Map<String, Double>): Int {\n        val friendTowns = ftwns.associate { arr -> Pair(arr[0], arr[1]) }\n\n        val distances = arrFriends\n            .mapNotNull { friend -> friendTowns[friend] }\n            .mapNotNull { town -> h[town] }\n\n        val distance = distances.zipWithNext()\n            .sumOf { (a, c) -> oppositeLeg(a, c) } +\n                distances.first() +\n                distances.last()\n\n        return distance.toInt()\n    }\n}\n\n\/**\n * Calculates the opposite leg by Pythagoras' theorem\n * @param a the adjacent leg\n * @param c the hypotenuse\n * @return the opposite leg (alias b)\n *\/\nfun oppositeLeg(a: Double, c: Double): Double {\n    return sqrt(c * c - a * a)\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205981,"user_id":null,"body":"package solution\n\nimport kotlin.math.abs\nimport kotlin.math.sqrt\n\nobject Tour {\n\n    fun tour(arrFriends: Array<String>, ftwns: Array<Array<String>>, h: Map<String, Double>): Int =\n        arrFriends.filter { friend -> ftwns.map { it[0] }.contains(friend) }\n            .map { friend -> ftwns.associate { it[0] to it[1] }[friend] }.filter { h.keys.contains(it) }.map { h[it]!! }\n            .let { distanceToFriends ->\n                (distanceToFriends.first() + distanceToFriends.zipWithNext()\n                    .sumOf { (a, b) -> sqrt(abs(a * a - b * b)) } + distanceToFriends.last()).toInt()\n            }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205982,"user_id":null,"body":"package solution\n\nobject Tour {\n\n    fun tour(arrFriends: Array<String>, ftwns: Array<Array<String>>, h: Map<String, Double>): Int {\n        var  map = mutableMapOf<String, Double>()\n    var towns = mutableListOf<String>()\n    for (subArray in ftwns) {\n        if (arrFriends.contains(subArray[0])) {\n            towns.add(subArray[1])\n        }\n\n    }\n    for (s in towns) {\n        map.put(s, h[s]!!)\n    }\n\n\n    var sum = if (towns.size > 0) map[towns[0]]!! + map[towns[towns.size -1]]!! else return 0\n\n    for (i in 1 until map.size) {\n            val hypotenuse = map[towns[i]]!!\n            val leg = map[towns[i-1]]!!\n            sum += Math.sqrt(Math.pow(hypotenuse, 2.0) - Math.pow(leg, 2.0))\n    }\n    return sum.toInt()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205983,"user_id":null,"body":"package solution\n\nimport kotlin.math.sqrt\n\nobject Tour {\n    \n    fun tour(arrFriends: Array<String>, ftwns: Array<Array<String>>, h: Map<String, Double>): Int {\n        val friendsToTowns = ftwns.associate { it[0] to it[1] }\n        val path = arrFriends.mapNotNull { friendsToTowns[it] }.map { h[it] }\n        val distBetweenTowns = path.zipWithNext().sumOf { pythagorean(it.first!!, it.second!!) }.toInt()\n\n        return (path.first()!! + distBetweenTowns + path.last()!!).toInt();\n    }\n    \n    fun pythagorean(a: Double, c: Double) : Double = sqrt(c*c - a*a)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205984,"user_id":null,"body":"package solution\n\nimport kotlin.math.pow\nimport kotlin.math.sqrt\n\nobject Tour {\n    fun tour(arrFriends: Array<String>, ftwns: Array<Array<String>>, h: Map<String, Double>): Int =\n        arrFriends\n            .fold(mapOf<String, Double>()) { distToFriends, f ->\n                val friendInTown = ftwns.firstOrNull { (tf, _) -> tf == f }?.last()\n                distToFriends + (friendInTown?.let { t -> mapOf(f to h[t]!!) } ?: emptyMap())\n            }\n            .values\n            .let { distances ->\n                listOf(\n                    distances.first(),\n                    distances.windowed(2, 1).sumOf { sqrt(it.last().pow(2) - it.first().pow(2)) },\n                    distances.last(),\n                ).sum()\n            }\n            .toInt()\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205985,"user_id":null,"body":"package solution\nimport kotlin.math.pow\nimport kotlin.math.sqrt\n\nobject Tour {\n\n    fun tour(arrFriends: Array<String>, ftwns: Array<Array<String>>, h: Map<String, Double>): Int {\n        val distances = arrFriends\n            .map { f -> f to ftwns.firstOrNull { t -> t.first() == f }?.last() }\n            .filterNot { it.second == null }\n            .distinctBy { it.first }\n            .map { h[it.second]!! }\n        return distances.first().toInt() +\n                distances.windowed(2, 1).sumOf {\n                    val legs = it.last().pow(2) - it.first().pow(2)\n                    sqrt(legs)\n                }.toInt() +\n                distances.last().toInt()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205986,"user_id":null,"body":"package solution\n\nimport kotlin.math.floor\nimport kotlin.math.pow\nimport kotlin.math.sqrt\n\nobject Tour {\n\n\n    fun tour(arrFriends: Array<String>, ftwns: Array<Array<String>>, h: Map<String, Double>): Int {\n\n        val visitSeq = mutableListOf(listOf<String>())\n        val distSeq = mutableListOf<Double>()\n\n        for (i in ftwns) {\n            for (j in arrFriends) {\n                if (i.contains(j)) {\n                    visitSeq.add(i.toList())\n                }\n            }\n        }\n        visitSeq.removeFirst()\n        for (i in visitSeq) {\n            for (j in h.keys) {\n                if (i.contains(j)) {\n                    distSeq.add(h.getValue(j))\n                }\n            }\n        }\n        var sum = distSeq[0] + distSeq[distSeq.size - 1]\n        for (i in 0..distSeq.size - 2) {\n            val path = sqrt(distSeq[i + 1].pow(2) - distSeq[i].pow(2))\n\n            sum += path\n        }\n        return floor(sum).toInt()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5539fecef69c483c5a000015":[{"id":205987,"user_id":null,"body":"package backwards\n\nfun isPrime(input: Long): Boolean {\n  (2..input \/ 2).forEach { \n    if (input % it == 0L) return false \n  }\n  return true\n}\n\nfun reverseNumber(input: Long) = input.toString().reversed().toLong()\n\nfun backwards_prime(start: Long, end: Long): String {\n  val reversed = (start..end).map { reverseNumber(it) }\n  return (start..end)\n    .filterIndexed { i, n -> isPrime(n) && reversed[i] != n && isPrime(reversed[i]) }\n    .joinToString(\" \")\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 15:09:33"},{"id":205988,"user_id":null,"body":"package backwards\n\nfun backwards_prime(start: Long, end: Long): String = (start..end).asSequence()\n    .filterNot { it == it.reversed() }\n    .filter { it.reversed().isPrime() }\n    .filter { it.isPrime() }\n    .joinToString(\" \")\n\nfun Long.isPrime(): Boolean {\n    for (i in 2 until this) {\n        if (i * i > this) return true\n        if (this % i == 0L) return false\n    }\n    return true\n}\n\nfun Long.reversed(): Long = this.toString()\n    .reversed()\n    .toLong()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 15:01:39"},{"id":205989,"user_id":null,"body":"package backwards\n\nfun backwards_prime(start: Long, end: Long): String {\n    return (start..end).filter(::isbackwards_prime).joinToString(\" \")\n}\n\nprivate fun isbackwards_prime(number: Long): Boolean { \n    val reversed = number.reversed()\n    return number != reversed && number.isPrime() && reversed.isPrime()\n}\n\nprivate fun Long.reversed() = toString().reversed().toLong()\n\nprivate fun Long.isPrime() = (2..Math.sqrt(toDouble()).toLong()).none { this % it == 0L }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 15:06:30"},{"id":205990,"user_id":null,"body":"package backwards\n\nfun backwards_prime(start: Long, end: Long) =\n    (start..end).filter { it != it.toString().reversed().toLong() && it.isPrime() && it.toString().reversed().toLong().isPrime() }\n        .joinToString(\" \")\n\nfun Long.isPrime(): Boolean {\n    if (this > 2 && this % 2 == 0L) {\n        return false\n    }\n    val top = Math.sqrt(this.toDouble()).toLong() + 1\n    var i = 3\n    while (i < top) {\n        if (this % i == 0L) {\n            return false\n        }\n        i += 2\n    }\n    return true\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 15:01:39"},{"id":205991,"user_id":null,"body":"package backwards\n\nfun Long.isPrime(): Boolean = this.rem(2) != 0L && (3..(this \/ 2) step 2).none { this.rem(it) == 0L }\nfun Long.isPalindrome(): Boolean = this == this.toString().reversed().toLong()\nfun Long.isReversePrime(): Boolean = this.toString().reversed().toLong().isPrime()\n\nfun backwards_prime(start: Long, end: Long): String =\n    (start..end)\n        .filter { it.isPrime() && !it.isPalindrome() && it.isReversePrime() }\n        .joinToString(\" \")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 15:01:39"},{"id":205992,"user_id":null,"body":"package backwards\n\nimport kotlin.math.sqrt\n\nfun backwards_prime(start: Long, end: Long): String {\n    val isPrime = { num: Long -> (2 .. sqrt(num.toDouble()).toLong()).none { num % it == 0L } }\n    val primeNumbers = mutableListOf<Long>()\n\n    for (num in start .. end) {\n        if (isPrime(num)) primeNumbers.add(num)\n    }\n\n    return primeNumbers\n        .filter { number -> number.toString().reversed().toLong().let { isPrime(it) && it != number } }\n        .joinToString(\" \")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 15:01:39"},{"id":205993,"user_id":null,"body":"package backwards\n\n\nfun backwards_prime(start:Long, end:Long):String = mutableListOf<Long>().apply {\n        for(num in (start..end)) {\n            val num2 = \"$num\".reversed().toLong()\n            if(num!=num2 && num.isPrime() && num2.isPrime()) this += num\n        }\n    }.joinToString(\" \")\n\nfun Long.isPrime():Boolean {\n    (2L..kotlin.math.sqrt(this.toDouble()).toLong()).forEach {if(this%it==0L) return false }\n    return this>1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 15:01:39"},{"id":205994,"user_id":53,"body":"package backwards\nimport java.lang.Math.sqrt\n\nfun isPrime(x: Long) = (2L..sqrt(x.toDouble()).toLong()).none { x % it == 0L }\n\nfun reverseDigits(x: Long): Long {\n    var num = x\n    var reversed = 0L\n    while (num != 0L) {\n        val digit = num % 10L\n        reversed = reversed * 10L+ digit\n        num \/= 10L\n    }\n    return reversed\n}\n\nfun isPalindromic(num: Long) = num == reverseDigits(num)\n\nfun backwards_prime(start: Long, end: Long): String {\n    return (start..end)\n        .filter(::isPrime)\n        .filterNot(::isPalindromic)\n        .filter{ isPrime(reverseDigits(it)) }\n        .joinToString(separator = \" \")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 15:01:39"},{"id":205995,"user_id":null,"body":"package backwards\n\nfun backwards_prime(start: Long, end: Long): String = (start..end)\n        .toList()\n        .filter { number ->\n            number.isPrimeNumber() && number.reverse().isPrimeNumber() && number != number.reverse()\n        }\n        .joinToString(separator = \" \")\n\nfun Long.isPrimeNumber(): Boolean {\n    var isPrime = true\n\n    for (i in 2..this \/ 2) {\n        if (i * i > this) {\n            return true\n        } else {\n            if (this % i == 0L) {\n                isPrime = false\n                break\n            }\n        }\n    }\n\n    return isPrime\n}\n\nfun Long.reverse() = this.toString().reversed().toLong()\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 15:01:39"},{"id":205996,"user_id":null,"body":"package backwards\n\nfun backwards_prime(start: Long, end: Long): String {\n    val resultList = arrayListOf<String>()\n    val mark = if (start >= 10) start else 10L\n    for (index in mark..end) {\n        if (index != index.toString().reversed().toLong() && isPrime(index) && isPrime(index.toString().reversed().toLong())) {\n            resultList.add(index.toString())\n        }\n    }\n return resultList.joinToString(separator = \" \", prefix = \"\", postfix = \"\")\n}\n\nfun isPrime(num: Long): Boolean {\n    for (index in 2..num \/ 2 + 1) {\n        if (num % index == 0L) {\n            return false\n        }\n    }\n    return true\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 15:01:39"}],"5541f58a944b85ce6d00006a":[{"id":205997,"user_id":null,"body":"package prodfib\n\nfun product_fib(prod:Long):LongArray {\n  var (a, b, check) = longArrayOf(0, 1, 0)\n  while (check < prod) {\n    a = b.also { b += a }\n    check = a * b\n  }\n  return longArrayOf(a, b, if (check == prod) 1L else 0L)\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205998,"user_id":null,"body":"package prodfib\n\nfun product_fib(prod: Long): LongArray {\n    val (first, second) = generateSequence(Pair(0.toLong(), 1.toLong()), { Pair(it.second, it.first + it.second) }).filter { it.first * it.second >= prod }.first()\n    return if (first * second == prod) longArrayOf(first, second, 1) else longArrayOf(first, second, 0)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":205999,"user_id":null,"body":"package prodfib\n\nfun product_fib(prod:Long):LongArray {\n    var fn = 0L\n    var fn1 = 1L\n    while (fn * fn1 < prod) {\n      val fn2 = fn1 + fn\n      fn = fn1\n      fn1 = fn2\n    }\n    return longArrayOf(fn, fn1, if (fn1*fn==prod) 1L else 0L)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206000,"user_id":null,"body":"package prodfib\n\nfun product_fib(prod:Long):LongArray {\n    fun search(a: Long, b: Long): Pair<Long, Long> {\n        return if (a * b < prod) {\n            search(b, a + b)\n        } else {\n            a to b\n        }\n    }\n    return search(0, 1).let {\n        longArrayOf(it.first, it.second, if (it.first * it.second == prod) 1 else 0)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206001,"user_id":null,"body":"package prodfib\n\nfun product_fib(prod: Long): LongArray {\n    var n = findN(prod)\n    while (true) {\n        val fib1 = fib(n)\n        val fib2 = fib(n + 1)\n        val result = fib1 * fib2\n\n        when {\n            result == prod -> return longArrayOf(fib1, fib2, 1)\n            result > prod -> return longArrayOf(fib1, fib2, 0)\n        }\n        n++\n    }\n}\n\nprivate var cache = LongArray(100000)\n    .apply {\n        fill(-1L)\n        set(0, 0L)\n        set(1, 1L)\n    }\nprivate val sqrt5 = Math.sqrt(5.toDouble())\nprivate val phi = (1 + sqrt5) \/ 2\n\nprivate fun fib(n: Int): Long {\n    if (n == 0) return 0L\n    if (n == 1) return 1L\n    if (cache[n] != -1L) return cache[n]\n    return (fib(n - 1) + fib(n - 2)).apply { cache[n] = this }\n}\n\nprivate fun findN(prod: Long): Int {\n    val n = (0..10000)\n        .first { (Math.pow(phi, (2 * it + 1).toDouble()) \/ sqrt5).toLong() >= prod }\n    return n - 1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206002,"user_id":null,"body":"package prodfib\n\nfun product_fib(prod:Long):LongArray {\n    var a = 0L\n    var b = 1L\n    while(a*b<prod) {\n        a = b.also{b=a}\n        b += a\n    }\n    val suc = if(a*b==prod) 1L else 0L\n    return longArrayOf(a,b,suc)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206003,"user_id":null,"body":"package prodfib\n\nfun product_fib(prod:Long):LongArray {\n  var f1 = 0L\n  var f2 = 1L\n  while (f1*f2 < prod) {\n      val f3 = f2+f1\n      f1 = f2\n      f2 = f3 \n  }\n  return longArrayOf(f1, f2, if (f1*f2==prod) 1L else 0L)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206004,"user_id":null,"body":"package prodfib\n\nimport kotlin.coroutines.experimental.buildSequence\n\nprivate val fibonacciProducts = buildSequence {\n    var terms = Pair(0L, 1L)\n\n    \/\/ this sequence is infinite\n    while (true) {\n        yield(Pair(terms.first * terms.second, terms))\n        terms = Pair(terms.second, terms.first + terms.second)\n    }\n}\n\nfun product_fib(prod:Long):LongArray {\n    val sequence = fibonacciProducts.dropWhile { it.first < prod }.take(1)\n    val r = sequence.find { it.first == prod } ?: sequence.last()\n    return longArrayOf(r.second.first, r.second.second, if (r.first == prod) 1 else 0)\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206005,"user_id":null,"body":"package prodfib\n\nfun product_fib(prod:Long):LongArray {\n    return generateSequence(1L to 1L) { it.second to it.first + it.second }\n        .filter { it.first * it.second >= prod }\n        .first()\n        .let {\n            if (it.first * it.second == prod) longArrayOf(it.first, it.second, 1)\n            else longArrayOf(it.first,it.second, 0)\n        }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206006,"user_id":null,"body":"package prodfib\n\nfun product_fib(prod: Long): LongArray {\n    return fibonacci(target = prod)\n}\n\ntailrec fun fibonacci(a: Long = 0, b: Long = 1, target: Long): LongArray =\n     when {\n        (a*b) == target -> {\n            longArrayOf(a, b, 1)\n        }\n        a*b > target -> {\n            longArrayOf(a, b, 0)\n        }\n        else -> {\n            fibonacci(b, a + b, target)\n        }\n    }\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5544c7a5cb454edb3c000047":[{"id":206007,"user_id":null,"body":"package bouncing\n\nfun bouncing_ball(h:Double, bounce:Double, window:Double):Int {\n    \/\/ Check for invalid inputs\n    if (h <= 0 || bounce <= 0 || bounce >= 1 || window >= h) {\n        return -1\n    }\n\n    \/\/ The ball will always pass the window once. Record that sighting, then update its height\n    var timesSeen = 1\n    var height = h * bounce\n\n    \/\/ If the height is still above the window, increase the view count by two (once for it\n    \/\/ going up and once for it going back down), then update its height again and repeat\n    while (height > window) {\n        timesSeen += 2\n        height *= bounce\n    }\n\n    \/\/ If the ball is no longer above the window, we won't see it again, so we can stop\n    return timesSeen\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206008,"user_id":null,"body":"package bouncing\n\nfun bouncing_ball(h:Double, bounce:Double, window:Double):Int {\n  if(h <= 0.0  || bounce <= 0.0 || bounce >= 1.0 || window >= h || window <= 0.0 )\n   return -1\n   \n  val numberOfJumps = generateSequence(h){ it * bounce}\n    .takeWhile{it > window}\n    .count()\n  \n  return (numberOfJumps * 2) - 1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206009,"user_id":null,"body":"package bouncing\n\nfun bouncing_ball(h:Double, bounce:Double, window:Double):Int {\n    if (h <= 0.0) return -1;\n    if (bounce <= 0.0 || bounce >= 1.0) return -1;\n    if (window >= h) return -1;\n    \n    return generateSequence(h) { it * bounce }.takeWhile { it > window }.count() * 2 - 1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206010,"user_id":null,"body":"package bouncing\n\nfun bouncing_ball(h: Double, bounce: Double, window: Double): Int {\n    if (h <= 0 || bounce <= 0 || bounce >= 1 || window >= h) return -1\n    var bounceHight = h * bounce\n    var count = 1\n    while (bounceHight > window) {\n        count += 2\n        bounceHight *= bounce\n    }\n    return count\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206011,"user_id":null,"body":"package bouncing\n\nimport kotlin.math.log\nimport kotlin.math.ceil\n\nfun bouncing_ball(h:Double, bounce:Double, window:Double):Int {\n    val ans = ceil(log(window\/h, bounce)).toInt() * 2 - 1\n    return if (ans > 0) ans else -1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206012,"user_id":null,"body":"package bouncing\nimport kotlin.math.*\n\nfun bouncing_ball(h: Double, bounce: Double, window: Double) = 1 + (ceil(log(window \/ h, bounce)).toInt() - 1) * 2","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206013,"user_id":null,"body":"package bouncing\n\nfun bouncing_ball(height: Double, bounce: Double, window: Double): Int {\n    if (height <= 0 || bounce <= 0 || bounce >= 1 || window >= height) {\n        return -1\n    }\n\n    return timesTheBallPassInFrontOfTheWindow(height * bounce, bounce, window, 1)\n}\n\nprivate tailrec fun timesTheBallPassInFrontOfTheWindow(ballHeight: Double, bounce: Double, window: Double, count: Int): Int {\n    if (ballHeight <= window) {\n        return count\n    }\n    return timesTheBallPassInFrontOfTheWindow(ballHeight * bounce, bounce, window, count + 2)\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206014,"user_id":null,"body":"package bouncing\n\nimport kotlin.math.ceil\nimport kotlin.math.log\n\nfun bouncing_ball(h: Double, bounce: Double, window: Double): Int {\n    if (h <= 0 || bounce >= 1 || bounce <= 0 || window >= h) return -1\n    \n    val n = log(window \/ h, 10.0) \/ log(bounce, 10.0)\n    return (ceil(n - 1) * 2 + 1).toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206015,"user_id":null,"body":"package bouncing\n\nimport kotlin.math.log\n\nfun bouncing_ball(h:Double, bounce:Double, window:Double):Int {\n    val res = log(window\/h, bounce)\n    when {\n        !(h > 0 \n          && bounce > 0 \n          && bounce < 1 \n          && window < h) -> return - 1\n        res - res.toInt() > 0 -> return 1 + log(window\/h, bounce).toInt() * 2\n        else -> return 1\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206016,"user_id":null,"body":"package bouncing\n\nfun bouncing_ball(h:Double, bounce:Double, window:Double):Int {\n    if ((bounce < 1 && bounce > 0) && h > 0 && (window < h && window > 0)) {\n        var count = 1\n        var x = h\n        while (x > window) {\n          x *= bounce\n          if (x > window) count += 2\n          else break\n        }\n    return count\n    }\n    return -1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5545f109004975ea66000086":[{"id":206017,"user_id":902,"body":"fun is_divisible(n: Int, x: Int, y: Int) = n % x == 0 && n % y == 0","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206018,"user_id":527,"body":"fun is_divisible(n: Int, x: Int, y: Int): Boolean {\n    return n % x == 0 && n % y == 0\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206019,"user_id":null,"body":"fun is_divisible(n: Int, x: Int, y: Int): Boolean {\n    if (n % x == 0 && n % y == 0) {\n      return true\n    } else {\n      return false\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206020,"user_id":null,"body":"fun is_divisible(n: Int, x: Int, y: Int) = n % x + n % y == 0","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206021,"user_id":null,"body":"fun is_divisible(n: Int, x: Int, y: Int) = n.rem(x) == 0 && n.rem(y) == 0","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206022,"user_id":null,"body":"fun is_divisible(n: Int, x: Int, y: Int): Boolean {\n    return (n % x == 0) and (n % y == 0)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206023,"user_id":null,"body":"fun is_divisible(n: Int, x: Int, y: Int): Boolean = if (n % x == 0 && n % y == 0) true else false\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206024,"user_id":645,"body":"fun is_divisible(n: Int, x: Int, y: Int): Boolean = n % x == 0 && n % y == 0","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206025,"user_id":76,"body":"fun is_divisible(n: Int, x: Int, y: Int): Boolean {\n    return n % x + n % y == 0\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206026,"user_id":null,"body":"fun is_divisible(n: Int, x: Int, y: Int) = listOf(n % x, n % y).all { it == 0 }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"55466989aeecab5aac00003e":[{"id":206027,"user_id":null,"body":"package squares\n\ntailrec fun sq_in_rect(l:Int, w:Int, list:List<Int> = listOf<Int>()):List<Int>? {\n    return if (l == w && list.isEmpty()) {\n        null\n    } else if (l == w) {\n        list.plus(l)        \n    } else {\n        val c = minOf(l, w)\n        sq_in_rect(maxOf(l, w) - c, c, list.plus(c))\n    }\n}","lang_id":29,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206028,"user_id":null,"body":"package squares\n\nfun sq_in_rect(lng:Int, wdth:Int): List<Int>? {\n    if (lng == wdth) return []\n    \n    val result = mutableListOf<Int>()\n    \n    var currentLength = lng\n    var currentWidth = wdth\n    \n    while (currentLength > 0 && currentWidth > 0) {\n        val minSide = Math.min(currentLength, currentWidth)\n        \n        if (currentLength > currentWidth) currentLength -= minSide\n        else currentWidth -= minSide\n        \n        result += minSide\n    }\n    \n    return result\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206029,"user_id":null,"body":"package squares\n\nfun sq_in_rect(lng:Int, wdth:Int):List<Int>? {\n    if (lng <= 0 || wdth < 0 || lng == wdth) {\n        return []\n    }\n    \n    \/\/ Use var to be able to change its value\n    var height = lng\n    var width = wdth\n    \n    val output = mutableListOf<Int>()\n    while (width > 0) {\n        if (height > width) {\n            \/\/ Always keep height as the smaller value. \n            \/\/ Invert variables if height is bigger than width\n            val aux = height\n            height = width\n            width = aux\n        }\n        \n        \/\/ Add a heightxheight square and decrement the rectangle's width\n        output.add(height)\n        width -= height\n    }\n    \n    return output\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206030,"user_id":null,"body":"package squares\n\nfun sq_in_rect(lng:Int, wdth:Int):List<Int>? {\n    return if (lng == wdth) null else {\n        var shortestMeasurement = if (lng < wdth) lng else wdth\n        var longestMeasurement = if (lng > wdth) lng else wdth\n        var squares: MutableList<Int> = mutableListOf()\n                \n        while (shortestMeasurement > 0 && longestMeasurement > 0) {\n            var times = longestMeasurement \/ shortestMeasurement\n            var remainder = longestMeasurement % shortestMeasurement\n                        \n            while(times != 0) {\n                squares.add(shortestMeasurement)\n\n                times--\n            }\n\n            longestMeasurement = shortestMeasurement\n            shortestMeasurement = remainder\n        }\n        \n        return squares\n    }    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206031,"user_id":null,"body":"package squares\n\nfun sq_in_rect(lng:Int, wdth:Int):List<Int>? {\n    if(lng == wdth)return []\n    var results : ArrayList<Int> = arrayListOf()\n    var max = lng\n    var min = wdth\n    while(max > 0){\n        if(max < min){\n            var buffer = max \n            max = min\n            min = buffer\n        }\n        results.add(min)\n        max -= min\n    }\n    return results\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206032,"user_id":null,"body":"package squares\n\nimport kotlin.math.abs\n\nfun sq_in_rect(lng:Int, wdth:Int):List<Int>? {\n    return if(lng == wdth) null\n    else generateSequence(listOf(lng, wdth).sorted()) {\n        listOf(it[0], it[1]-it[0]).sorted()\n    }.takeWhile{it[0] > 0}.map{it[0]}.toList()\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206033,"user_id":53,"body":"package squares\n\nimport kotlin.math.min\nimport kotlin.math.max\n\nfun sq_in_rect(x:Int, y:Int): List<Int>? {\n    if (x == y) {\n        return []\n    } else {\n        var a = x\n        var b = y\n        val arr = mutableListOf<Int>()\n        while (a > 0 && b > 0) {\n            val l = max(a, b)\n            val w = min(a, b)\n            a = w\n            b = l - w\n            arr.add(w)\n        }\n        return arr\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206034,"user_id":null,"body":"package squares\n\nimport kotlin.math.max\nimport kotlin.math.min\n\nfun sq_in_rect(lng:Int, wdth:Int):List<Int>? {\n    if (lng==wdth)\n      return []\n    var mx = max(lng, wdth)\n    var mn = min(lng, wdth)\n    val result = mutableListOf<Int>()\n    while (mn>0) {\n        while (mx>=mn) {\n            result.add(mn)\n            mx -= mn\n        }\n        val tmp = mx\n        mx = mn;  mn = tmp\n    }\n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206035,"user_id":null,"body":"package squares\n\nimport kotlin.math.max\nimport kotlin.math.min\n\nfun sq_in_rect(lng: Int, wdth: Int): List<Int>? {\n    if (lng == wdth) return []\n\n    val lst = mutableListOf<Int>()\n\n    var big = max(lng, wdth)\n    var small = lng + wdth - big\n\n    var i = 0\n    while (i < lng * wdth) {\n        val m = min(big, small)\n        lst.add(m)\n        i += m * m\n\n        big -= m\n\n        if (big < small) {\n            small = big.also { big = small }\n        }\n    }\n\n    return lst\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206036,"user_id":null,"body":"package squares\nimport kotlin.math.*\n\nfun sq_in_rect(lng:Int, wdth:Int):List<Int>? {\n    val l = max(lng,wdth)\n    val s = min(lng,wdth)\n    return if(l==s) { null } else { listOf(s) + (sq_in_rect(s,l-s)?:listOf(s)) }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5547cc7dcad755e480000004":[{"id":206037,"user_id":null,"body":"package solution\n\nobject RemovedNumbers {\n    fun remove_nb(n: Long) = (1..n).fold(ArrayList<LongArray>()) { result, a ->\n        val sum = (n * (n + 1)) \/ 2\n        val b = (sum - a) \/ (a + 1)\n        if (sum - b - a == b * a && b <= n) result.add(arrayOf(a, b).toLongArray())\n        result\n    }.toTypedArray()\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206038,"user_id":null,"body":"package solution\n\nobject RemovedNumbers {\n    fun remove_nb(n: Long): Array<LongArray> {\n        val sum = n * (n + 1) \/ 2\n        return (1..n).filter { (sum - it) % (it + 1) == 0L && (sum - it) \/ (it + 1) <= n }\n            .map { longArrayOf(it, (sum - it) \/ (it + 1)) }.toTypedArray()\n    }\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206039,"user_id":null,"body":"package solution\n\nobject RemovedNumbers {\n    \n    fun remove_nb(n: Long): Array<LongArray> = mutableListOf<LongArray>().apply {\n            val sum = (1L..n).reduce{acc,item-> acc+item}\n            ((sum\/n)..n).forEach {a->\n                val b = (sum-a)\/(a+1)\n                if(a!=b) if(a*b==sum-a-b) this+=longArrayOf(a,b)\n            }\n    }.distinctBy{it[0]}.toTypedArray()\n}\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206040,"user_id":null,"body":"package solution\n\nobject RemovedNumbers {\nfun remove_nb(n: Long): Array<LongArray> {\n    var Result = arrayListOf<LongArray>()\n    var SUM:Long = 1\n    for(i in 0..n)\n        SUM += i\n    for(i in 2..n)\n        if(SUM % i == 0.toLong() && SUM\/i < n && SUM\/i != i) \n            Result.add(longArrayOf(i - 1, SUM \/ i - 1))\n    if(Result.isEmpty())\n        return arrayOf()\n    else\n        return Result.toTypedArray()\n}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206041,"user_id":null,"body":"package solution\n\nobject RemovedNumbers {\n    fun remove_nb(n: Long): Array<LongArray> {\n\n        val answer = mutableListOf<LongArray>()\n        val sum: Long = (1 + n) * n \/ 2\n        var m: Long\n\n        for (i: Long in 1..n) {\n            if ((sum - i) % (i + 1) == 0L) {\n                m = (sum - i) \/ (i + 1)\n\n                if (m == 0L || m > n) {\n                    continue\n                }\n\n                if ((sum - m - i) \/ m == i) {\n                    answer.add(longArrayOf(i, m))\n                }\n\n            } else {\n                continue\n            }\n        }\n\n        return if (answer.size < 2) {\n            emptyArray()\n        } else {\n            answer.toTypedArray()\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206042,"user_id":null,"body":"package solution\n\nobject RemovedNumbers {\n    fun remove_nb(n: Long): Array<LongArray> {\n        \/\/ your code\n        val sum = n.sumRange()\n        val result = arrayListOf<LongArray>()\n        (1..n).forEach { x1 ->\n            val x2 = getX2(x1, sum)\n            if (x2 > n) return@forEach\n            if (x1 * x2 == (sum - x1 - x2))\n                result.add(longArrayOf(x1, x2))\n        }\n        return result.toTypedArray()\n    }\n\n    private fun getX2(n: Long, sum: Long): Long = (sum - n) \/ (n + 1)\n    private fun Long.sumRange(): Long = (0.5 * this * (this + 1)).toLong()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206043,"user_id":null,"body":"package solution\n\nobject RemovedNumbers {\n    fun remove_nb(n: Long): Array<LongArray> {\n        val s = n * (n + 1) \/ 2 + 1\n        return (2L..n)\n            .asSequence()\n            .filter { s % it == 0L }\n            .map { longArrayOf(it - 1, s \/ it - 1) }\n            .filter { it.last() < n }\n            .toList()\n            .toTypedArray()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206044,"user_id":null,"body":"package solution\n\nobject RemovedNumbers {\n    fun remove_nb(n: Long): Array<LongArray> {\n        return (1 until n).mapNotNull { a ->\n            val b = (n * n + n - 2.0 * a) \/ (2 * a + 2)\n            longArrayOf(a, b.toLong()).takeIf { b <= n && b % 1.0 == 0.0}\n        }.toTypedArray()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206045,"user_id":null,"body":"package solution\n\nobject RemovedNumbers {\n    fun remove_nb(n: Long): Array<LongArray> {\n        \n        \/\/ dealing with arrays took me more time than the solution itself :-(\n        \n        var smallGauss = n * (n + 1) \/ 2\n        var result : Array<LongArray> = arrayOf()\n        var sequence = LongArray(0)\n\n        for (a in 2..n-1 ) {\n            if (!((smallGauss - a) % (a + 1) < 0) && !((smallGauss - a) % (a + 1) > 0) ) {\n                var b = (smallGauss - a) \/ (a + 1)\n                if (b < n && (smallGauss - a - b).toString() == (a * b).toString()){ \n                    sequence += a\n                    sequence += b\n                    result += sequence\n                    sequence = LongArray(0)\n                }\n            }\n        }\n        return result\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206046,"user_id":null,"body":"package solution\n\nobject RemovedNumbers {\n    \n    private fun compareSumAndProduct(sum: Long, a: Long, b: Long): Long {\n        var s = sum - a - b\n        var p = a * b\n        return s - p\n    }\n    \n    private fun findPair(sum: Long, n: Long, a: Long): Long? {\n        var min = a + 1\n        var max = n\n        while (min <= max) {\n            val b = (min + max) \/ 2\n            val res = compareSumAndProduct(sum, a, b)\n            when {\n                res > 0 -> min = b + 1\n                res < 0 -> max = b - 1\n                else -> return b\n            }\n        }\n        return null\n    }\n    \n    fun remove_nb(n: Long): Array<LongArray> {\n        val sum = n * (n + 1) \/ 2\n        return (n \/ 2 .. (n \/ 1.41).toInt())\n            .flatMap {\n                var pair = findPair(sum, n, it)\n                if (pair == null) listOf()\n                else listOf(longArrayOf(it, pair), longArrayOf(pair, it))\n            }\n            .sortedBy { it[0] }\n            .toTypedArray()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"554a44516729e4d80b000012":[{"id":206047,"user_id":null,"body":"package solution\n\nimport kotlin.math.roundToInt\n\nobject BuyCar {\n    fun nb_months(\n        startPriceOld: Int, \n        startPriceNew: Int, \n        savingperMonth: Int,\n        percentLossByMonth: Double\n    ): Pair<Int, Int> {\n        var month = 0\n        var decreaseRate: Double = 1 - (percentLossByMonth \/ 100)\n        var newPriceOld: Double = startPriceOld.toDouble()\n        var newPriceNew: Double = startPriceNew.toDouble()\n        \n        while (month * savingperMonth + newPriceOld < newPriceNew){\n            month++\n            if (month % 2 == 0) decreaseRate -= 0.005\n            newPriceOld *= decreaseRate\n            newPriceNew *= decreaseRate\n        }\n        \n        return Pair(month, (month * savingperMonth + newPriceOld - newPriceNew).roundToInt())\n    \n    }\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206048,"user_id":null,"body":"package solution\n\nimport kotlin.math.roundToInt\n\nobject BuyCar {\n    \n  fun nb_months(\n    startPriceOld: Int,\n    startPriceNew: Int,\n    savingperMonth: Int,\n    percentLossByMonth: Double\n  ): Pair<Int, Int> {\n\n    \/\/ Setup initial values.\n    var savedAmount = 0.0\n    var currentPercentLossByMonth: Double = percentLossByMonth\n    var oldCarValue = startPriceOld.toDouble()\n    var newCarValue = startPriceNew.toDouble()\n    var monthsPassed = 0\n\n    \/\/ Calculate how much money left after a potential purchase.  \n    var moneyLeft = savedAmount + oldCarValue - newCarValue\n\n    while (moneyLeft < 0) {\n\n      \/\/ Increase months counter.\n      monthsPassed++\n\n      \/\/ Decrease value percentage drop every two months.\n      if (monthsPassed % 2 == 0) currentPercentLossByMonth += 0.5\n\n      \/\/ Increase saved amount\n      savedAmount += savingperMonth\n\n      \/\/ Decrease value of old and new car.\n      oldCarValue -= oldCarValue * currentPercentLossByMonth \/ 100\n      newCarValue -= newCarValue * currentPercentLossByMonth \/ 100\n\n      \/\/ Calculate how much money left after a potential purchase.\n      moneyLeft = savedAmount + oldCarValue - newCarValue\n    }\n\n    return Pair(monthsPassed, moneyLeft.roundToInt())\n  }\n  \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206049,"user_id":null,"body":"package solution\n\nimport kotlin.math.*\nobject BuyCar {\n    fun nb_months(\n    startPriceOld: Int,\n    startPriceNew: Int,\n    savingperMonth: Int,\n    percentLossByMonth: Double\n): Pair<Int, Int> =\n    generateSequence(Triple(0, startPriceOld.toDouble(), startPriceNew.toDouble())) { Triple(\n        it.first + 1,\n        it.second - (it.second * ((percentLossByMonth + (0.5 * ((it.first + 1) \/ 2))) \/ 100.0)),\n        it.third - (it.third * ((percentLossByMonth + (0.5 * ((it.first + 1) \/ 2))) \/ 100.0)) )}\n        .map {it.first to round(it.second - it.third + it.first * savingperMonth).toInt() }\n        .first { it.second >= 0 }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206050,"user_id":null,"body":"package solution\n\nimport kotlin.math.*\n\nobject BuyCar {\n    fun nb_months(\n        startPriceOld: Int,\n        startPriceNew: Int,\n        savingperMonth: Int,\n        percentLossByMonth: Double\n    ): Pair<Int, Int> {\n        var saved = 0\n        var leftMoney = (startPriceNew - startPriceOld).toDouble()\n        var month = 0\n        var percent = percentLossByMonth\n        while (leftMoney > saved) {\n            leftMoney -= (leftMoney * percent \/ 100)\n            saved += savingperMonth\n            if (month % 2 == 0) percent += 0.5\n            month++\n        }\n        return month to (saved - leftMoney).roundToInt()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206051,"user_id":null,"body":"package solution\nimport kotlin.math.roundToInt\n\nobject BuyCar {\n    fun nb_months(startPriceOld: Int, startPriceNew: Int, savingperMonth: Int, percentLossByMonth: Double): Pair<Int, Int> {\n        var month: Int = 0\n        var rate: Double = 1 - (percentLossByMonth \/ 100)\n        var sPO: Double = startPriceOld.toDouble()\n        var sPN: Double = startPriceNew.toDouble()\n        \n        while (month * savingperMonth + sPO < sPN) {\n            month++\n            if (month % 2 == 0) rate -= 0.005\n            sPO *= rate\n            sPN *= rate\n        }\n        return Pair(month,(month * savingperMonth + sPO - sPN).roundToInt())\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206052,"user_id":null,"body":"package solution\n\nimport kotlin.math.roundToInt\n\nobject BuyCar {\n    fun nb_months(\n        startPriceOld: Int,\n        startPriceNew: Int,\n        savingPerMonth: Int,\n        percentLossByMonth: Double\n    ): Pair<Int, Int> {\n        var months = 0\n        var currentBalance = (startPriceOld - startPriceNew).toDouble()\n        var currentDiff = (startPriceOld - startPriceNew).toDouble()\n        while (currentBalance < 0) {\n            months++\n            val totalPercentLoss = (percentLossByMonth + 0.5 * ((months \/ 2).toInt())) \/ 100\n            currentDiff *= (1 - totalPercentLoss)\n            currentBalance = currentDiff + (savingPerMonth * months)\n        }\n        return Pair(months, currentBalance.roundToInt())\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206053,"user_id":null,"body":"package solution\n\nobject BuyCar {\n    fun nb_months(\n        startPriceOld: Int,\n        startPriceNew: Int,\n        savingperMonth: Int,\n        percentLossByMonth: Double\n    ): Pair<Int, Int> {\n        var month = 0\n        var balance =  0\n        var oldCar = startPriceOld.toDouble()\n        var newCar = startPriceNew.toDouble()\n        var percentLossTotal = percentLossByMonth\n  \n  while(balance + oldCar < newCar){\n  \n      month++\n      if(month%2==0)percentLossTotal += 0.5\n      \n      oldCar -= oldCar*percentLossTotal\/100\n      newCar -= newCar*percentLossTotal\/100\n      balance += savingperMonth\n      \n  }\n        \n     return Pair(month, Math.round(balance + oldCar - newCar).toInt())\n  \n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206054,"user_id":53,"body":"package solution\n\nobject BuyCar {\n    fun nb_months(\n        startPriceOld: Int,\n        startPriceNew: Int,\n        savingperMonth: Int,\n        percentLossByMonth: Double\n    ): Pair<Int, Int> {\n        var p0: Double = startPriceOld.toDouble()\n        var p1: Double = startPriceNew.toDouble()\n        var r: Double = percentLossByMonth\n        var m: Int = 0\n        val s: Int = savingperMonth\n        while (p0 + m * s < p1) {\n            if (m % 2 == 1) {\n                r = r + 0.5\n            }\n            p0 = p0 - p0 * 0.01 * r\n            p1 = p1 - p1 * 0.01 * r\n            m = m + 1\n        }\n        return Pair(m, Math.round(p0 + m * s - p1).toInt())\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206055,"user_id":null,"body":"package solution\n\nobject BuyCar {\n    fun nb_months(\n        startPriceOld: Int,\n        startPriceNew: Int,\n        savingperMonth: Int,\n        percentLossByMonth: Double\n    ): Pair<Int, Int> {\n        var saveDollars = 0\n        var newCar = startPriceNew.toDouble()\n        var oldCar = startPriceOld.toDouble()\n        var mounth = 0\n        \n        var persent = percentLossByMonth \/ 100\n        \n        while (saveDollars + oldCar - newCar < 0) {\n            mounth++\n            saveDollars += savingperMonth\n            \n            if (mounth.rem(2) == 0) persent += 0.005\n            newCar = newCar * (1.00 - persent)\n            oldCar = oldCar * (1.00 - persent)\n        }\n        \n        val leftDollars = saveDollars + oldCar - newCar\n        \n        return Pair(mounth, Math.round(leftDollars).toInt())\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206056,"user_id":null,"body":"package solution\n\nimport kotlin.math.roundToInt\n\nobject BuyCar {\n    fun nb_months(\n        startPriceOld: Int,\n        startPriceNew: Int,\n        savingperMonth: Int,\n        percentLossByMonth: Double\n    ): Pair<Int, Int> {\n        return generateSequence(\n            seed = IntermediateAccount(\n                monthN = 0,\n                priceOld = startPriceOld.toDouble(),\n                priceNew = startPriceNew.toDouble(),\n                savingperMonth = savingperMonth.toDouble(),\n                percentLossByMonth = percentLossByMonth,\n                savingsTotal = 0.0\n            ),\n            ::nextMonth\n        ).map { it.monthN to (it.savingsTotal + it.priceOld - it.priceNew).roundToInt() }\n            .first { it.second >= 0 }\n\n    }\n\n    data class IntermediateAccount(\n        val monthN: Int,\n        val priceOld: Double,\n        val priceNew: Double,\n        val savingperMonth: Double,\n        val savingsTotal: Double,\n        val percentLossByMonth: Double\n    )\n\n    private fun nextMonth(\n        current: IntermediateAccount,\n    ): IntermediateAccount {\n        val percentIncrease = if ((current.monthN) % 2 == 0)\n            0.5\n        else 0.0\n        return current.copy(\n            monthN = current.monthN + 1,\n            priceOld = (current.priceOld * (1 - (current.percentLossByMonth \/ 100))),\n            priceNew = (current.priceNew * (1 - (current.percentLossByMonth \/ 100))),\n            savingsTotal = current.savingsTotal + current.savingperMonth,\n            percentLossByMonth = current.percentLossByMonth + percentIncrease\n        ).apply { println(this)\n            println(-this.priceNew + this.priceOld + this.savingsTotal )}\n    }\n\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"554b4ac871d6813a03000035":[{"id":206057,"user_id":null,"body":"fun high_and_low(numbers: String): String\n{\n\tval x = numbers.split(\" \").map { it.toInt() }.sorted()\n\treturn \"${x.last()} ${x.first()}\"\n}","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206058,"user_id":null,"body":"fun high_and_low(numbers: String) =\n    numbers.split(\" \").map { it.toInt() }.run {\n        \"${this.maxOrNull()} ${this.minOrNull()}\"\n    }","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206059,"user_id":null,"body":"fun high_and_low(numbers: String): String {\n    var minValue: Int? = null\n    var maxValue: Int? = null\n    val builder = StringBuilder()\n    for ((i, c) in numbers.withIndex()) {\n        if (c != ' ') {\n            builder.append(c)\n        }\n        if (c == ' ' || i == numbers.lastIndex) {\n            if (builder.isNotEmpty()) {\n              val current = builder.toString().toInt()\n              if (minValue == null) {\n                  minValue = current\n                  maxValue = current\n              } else {\n                  minValue = minOf(minValue, current)\n                  maxValue = maxOf(maxValue!!, current)\n              }\n            }\n            builder.clear()\n        }\n    }\n    return \"$maxValue $minValue\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206060,"user_id":null,"body":"fun high_and_low(str: String): String {\n    val split = str.split(\" \").map { it.toInt() }\n    return \"${split.maxOrNull()} ${split.minOrNull()}\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206061,"user_id":null,"body":"fun high_and_low(numbers: String): String {\n    return numbers.split(\" \").maxOf { it.toInt() }.toString() + \" \" + numbers.split(\" \").minOf { it.toInt() }.toString()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206062,"user_id":null,"body":"data class MutPair(\n    var first: Int,\n    var second: Int\n)\n\nfun high_and_low(numbers: String): String {\n\n    val minMax = {result: MutPair, num: Int ->\n        if (num < result.first) result.first = num\n        if (num > result.second) result.second = num\n        result\n    }\n    val result = numbers\n        .split(\" \")\n        .map { it.toInt() }\n        .fold(MutPair(Int.MAX_VALUE, Int.MIN_VALUE), minMax)\n    return \"${result.second} ${result.first}\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206063,"user_id":null,"body":"fun high_and_low(numbers: String) = numbers.split(\" \").map { it.toInt() }.run { \"${maxOrNull()} ${minOrNull()}\" }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206064,"user_id":null,"body":"fun high_and_low(numbers: String): String {\n    val stats = numbers.split(' ')\n        .stream()\n        .mapToInt { it.toInt() }\n        .summaryStatistics()\n\n    return \"${stats.max} ${stats.min}\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206065,"user_id":null,"body":"fun high_and_low(numbers: String): String {\n  val r = numbers.split(\" \").map{it.toInt()}.toTypedArray()\n  r.sort()\n  return \"${r.last()} ${r[0]}\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206066,"user_id":null,"body":"\/*import java.util.stream.Collectors\nimport kotlin.streams.asStream*\/\n\nfun high_and_low(numbers: String): String {\n    \/* normally this works\n    val statistics = numbers.splitToSequence(\" \").asStream().collect(Collectors.summarizingInt { Integer.parseInt(it) })\n    return \"${statistics.max} ${statistics.min}\" *\/\n    val realNumbers = numbers.splitToSequence(\" \").map { Integer.parseInt(it) }\n    val result = realNumbers.map { it to it }.reduce {\n        p1, p2 ->\n        when (p1.first > p2.first) {\n            true -> p2.first\n            else -> p1.first\n        } to\n        when (p1.second > p2.second) {\n            true -> p1.second\n            else -> p2.second\n        }\n    }\n    return \"${result.second} ${result.first}\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"554ca54ffa7d91b236000023":[{"id":206067,"user_id":null,"body":"object EnoughIsEnough {\n  fun delete_nth(elements:IntArray, maxOcurrences:Int):IntArray {\n    val count = mutableMapOf<Int, Int>()\n\n    return elements\n            .asSequence()\n            .onEach { count.put(it, count.getOrDefault(it, 0) + 1) }\n            .filter { count[it]!! <= maxOcurrences }\n            .toList().toIntArray()\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206068,"user_id":null,"body":"object EnoughIsEnough {\n   fun delete_nth(elements: IntArray, n: Int): IntArray {\n        val counts = mutableMapOf<Int, Int>()\n        fun countFilter(x: Int) = counts.compute(x, { _, count -> count?.plus(1) ?: 1 })!! <= n\n        return elements.filter { countFilter(it) }.toIntArray()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206069,"user_id":null,"body":"object EnoughIsEnough {\n  fun delete_nth(elements:IntArray, maxOcurrences:Int):IntArray {\n    var hash = hashMapOf<Int, Int>()\n    return elements.filter {\n        n -> (hash[n] ?: 0).also { hash[n] = it + 1 } < maxOcurrences\n    }.toIntArray()\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206070,"user_id":null,"body":"object EnoughIsEnough {\n    fun delete_nth(elements: IntArray, maxOccurrences: Int): IntArray {\n        val count = hashMapOf<Int, Int>().withDefault { 0 }\n        return elements.filter { i -> count.getValue(i).let { count[i] = it + 1; it < maxOccurrences } }.toIntArray()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206071,"user_id":null,"body":"object EnoughIsEnough {\n  fun delete_nth(elements:IntArray, maxOcurrences:Int):IntArray {\n    val observedNumbers = mutableMapOf<Int, Int>()\n    val result = mutableListOf<Int>()\n    for (number in elements) {\n      val timesSeen = observedNumbers.getOrPut(number) { 0 }\n      if (timesSeen < maxOcurrences) {\n        result.add(number)\n        observedNumbers[number] = timesSeen + 1\n      }\n    }\n    return result.toIntArray()\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206072,"user_id":null,"body":"object EnoughIsEnough {\n  fun delete_nth(elements:IntArray, maxOcurrences:Int):IntArray {\n    val counts = mutableMapOf<Int, Int>()\n    val values = arrayListOf<Int>()\n\n    elements.forEach {\n        var count = counts[it] ?: 0\n\n        if(count < maxOcurrences) {\n            values.add(it)\n            counts[it] = ++count\n        }\n    }\n\n    return values.toIntArray()\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206073,"user_id":null,"body":"object EnoughIsEnough {\n  fun delete_nth(elements:IntArray, maxOcurrences:Int):IntArray {\n    val listOfSets = (1..maxOcurrences).map { hashSetOf<Int>() }\n    return elements.filter { i -> listOfSets.any { it.add(i) } }.toIntArray()\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206074,"user_id":null,"body":"object EnoughIsEnough {\n  fun delete_nth(elements:IntArray, maxOcurrences:Int):IntArray {\n    val seen = HashMap<Int, Int>()\n    return elements.filter { \n      seen.merge(it, 1, Int::plus)!! <= maxOcurrences \n    }.toIntArray()\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206075,"user_id":null,"body":"object EnoughIsEnough {\n    fun delete_nth(elements: IntArray, maxOccurrences: Int, counts: MutableMap<Int, Int> = hashMapOf()) =\n            elements.filter { (counts.compute(it) { _, count -> (count ?: 0) + 1 }!! <= maxOccurrences) }.toIntArray()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206076,"user_id":null,"body":"object EnoughIsEnough {\n  fun delete_nth(elements:IntArray, maxOcurrences:Int):IntArray = mutableMapOf<Int, Int>().let { map ->\n        elements.filter {\n            \/\/ Increment value of `it` in map, defaulting to 0\n            map[it] = map.getOrDefault(it, 0) + 1\n\n            map[it]!! <= maxOcurrences\n        }.toIntArray()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"554e4a2f232cdd87d9000038":[{"id":206077,"user_id":null,"body":"package dna\n\nfun dna_strand(dna: String) = dna.map { when(it) {\n    'A' -> 'T'\n    'T' -> 'A'\n    'C' -> 'G'\n    'G' -> 'C'\n    else -> it\n} }.joinToString(\"\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206078,"user_id":null,"body":"package dna\n\nfun dna_strand(dna : String) : String = dna.fold(String()) { acc, nucleotide ->\n            acc + when (nucleotide) {\n                'A' -> 'T'\n                'C' -> 'G'\n                'G' -> 'C'\n                'T' -> 'A'\n                else -> throw IllegalArgumentException(\"DNA may only contain nucleotides in A, C, G and T\")\n            }\n        }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206079,"user_id":932,"body":"package dna\n\nfun dna_strand(dna : String)=dna.map{\"ATGC\".zip(\"TACG\").toMap()[it]?:it}.joinToString(\"\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206080,"user_id":null,"body":"package dna\n\nfun dna_strand(dna : String) : String = dna.map { it.complement() }.joinToString(\"\")\n\nfun Char.complement() = when(this) {\n    'A' -> 'T'\n    'T' -> 'A'\n    'C' -> 'G'\n    'G' -> 'C'\n    else -> this\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206081,"user_id":null,"body":"package dna\n\nfun dna_strand(dna: String): String {\n    val map1 = \"AC\".zip(\"TG\").toMap()\n    val map2 = \"TG\".zip(\"AC\").toMap()\n    return dna.map { map1[it] ?: map2[it] }.joinToString(\"\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206082,"user_id":null,"body":"package dna\n\nfun dna_strand(dna : String) : String {\n    var s = \"\"\n    for (i in dna) {\n        s += when (i) {\n            'A' -> 'T'\n            'T' -> 'A'\n            'G' -> 'C'\n            'C' -> 'G'\n            else -> \"\"\n        }\n    }\n    return s\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206083,"user_id":1251,"body":"package dna\nfun dna_strand(dna : String) = dna.map {\n    if (it == 'A') 'T'\n    else if (it == 'T') 'A'\n    else if (it == 'G') 'C'\n    else 'G'\n}.joinToString(\"\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206084,"user_id":null,"body":"package dna\n\nfun dna_strand(dna : String) : String {\n    val answer = StringBuilder()\n    for (i in dna) {\n        when (i) {\n            'A' -> answer.append(\"T\")\n            'T' -> answer.append(\"A\")\n            'G' -> answer.append(\"C\")\n            'C' -> answer.append(\"G\")\n        }\n    }\n\n    return answer.toString()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206085,"user_id":null,"body":"package dna\n\nfun dna_strand(dna : String) =\n   dna.toCharArray().map { molecule ->\n      when (molecule) {\n         'A' -> 'T'\n         'T' -> 'A'\n         'C' -> 'G'\n         'G' -> 'C'\n         else -> ' '\n      }\n   }.joinToString(separator = \"\")\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206086,"user_id":null,"body":"package dna\nval replace_str = \" ATA CGC \"\nfun dna_strand(dna : String) = dna.map{c->\n   val replace_ptr = replace_str.indexOf(c)\n   if(replace_ptr>0) replace_str[replace_ptr+1] else c\n}.joinToString(\"\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"554f76dca89983cc400000bb":[{"id":206087,"user_id":null,"body":"package diophequa\nimport kotlin.math.sqrt\n\nfun sol_equa(n:Long):String {\n    if ( (n % 2 == 0L) and  (n\/2 % 2 == 1L)) return \"[]\"\n    val lower = if (n % 2 == 0L) {2} else {1}\n    val limit = sqrt(n.toDouble()).toInt()\n    val strings = mutableListOf<String>()\n    for (a in lower..limit step 2) {\n        if (n % a != 0L) continue\n        val b = n\/a\n        if (((a+b) % 2 != 0L) or ((b-a) % 4 != 0L)) continue\n        val x = (a+b)\/2\n        val y = (b-a)\/4\n        strings.add(listOf(x,y).joinToString(prefix = \"[\",postfix = \"]\"))\n        }\n    return strings.joinToString(prefix = \"[\",postfix = \"]\")\n}\n","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 19:30:10"},{"id":206088,"user_id":932,"body":"package diophequa\nimport kotlin.math.sqrt\nfun getX(n: Long, y: Long)=(n+4*y*y).let{x2->sqrt(x2.toDouble()).toLong().let {x-> if (x*x==x2) x else null}}\nfun sol_equa(n:Long):String {\n    val r=ArrayList<String>()\n    (n\/4).downTo(0).forEach {y->getX(n, y)?.let {x->r.add(\"[$x, $y]\")}}\n    return r.joinToString(\", \",\"[\",\"]\")\n}\n","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 19:30:18"},{"id":206089,"user_id":null,"body":"package diophequa\n\nfun sol_equa(n:Long):String {\n    return (1..Math.sqrt(n.toDouble()).toInt()).filter {\n        (n % it).toInt() == 0 && (n \/ it - it).toInt() % 4 == 0\n    }.map {\n        listOf((n \/ it + it) \/ 2, (n \/ it - it) \/ 4) \n    }.toString()\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 19:30:02"},{"id":206090,"user_id":null,"body":"package diophequa\n\nfun sol_equa(n:Long):String {\n    val result = mutableListOf<String>()\n    for (x in 1..n) {\n        val y = Math.sqrt((x * x - n).toDouble() \/ 4)\n        if (y % 1 == 0.0) {\n            result.add(\"[$x, ${y.toInt()}]\")\n        }\n    }\n    result.reverse()\n    return result.joinToString(\", \", \"[\", \"]\")\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 19:30:02"},{"id":206091,"user_id":null,"body":"package diophequa\n\nfun sol_equa(n:Long) = mutableListOf<Pair<Long,Long>>().apply {\n        (n downTo 0).forEach {y->\n            val x = Math.sqrt((n+4L*(y*y)).toDouble())\n            if(x%1.0==0.0) add(Pair(x.toLong(),y))\n        }\n    }.map{\"[${it.first}, ${it.second}]\"}.joinToString(\", \",\"[\",\"]\")\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 19:30:02"},{"id":206092,"user_id":null,"body":"package diophequa\n\n\/**\n * constructs solutions to n = x^2 -4y^2 = (x+2y)*(x-2*y)\n *\/\nfun sol_equa(n :Long) :String {\n    if (n<0L)  return \"[]\"\n    if (n==0L) return \"[[0, 0]]\"\n    val result = mutableListOf<Pair<Long, Long>>()\n    for (f in 1L..((n\/2L).toLong())) {\n        if (f>n\/f)  break\n        if (n%f==0L) {\n            val f2 = n\/f\n            if ((f+f2)%2L==0L && (f2-f)%4L==0L) {\n                val x = (f+f2)\/2L\n                val y = (f2-f)\/4L\n                result.add(Pair(x,y))\n            }\n        }\n    }\n    return result.joinToString(prefix=\"[\", postfix=\"]\") { p -> \"[${p.first}, ${p.second}]\" }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 19:30:02"},{"id":206093,"user_id":null,"body":"package diophequa\n\nimport kotlin.math.ceil\nimport kotlin.math.pow\nimport kotlin.math.sqrt\n\nfun sol_equa(n: Long): String {\n    val pairs = mutableListOf<Pair<Long, Long>>()\n    val (low, high) = ceil(sqrt(n.toDouble())).toLong() to ceil(n.toDouble() \/ 2).toLong()\n    (high downTo low).forEach { x ->\n        val y = findY(n, x)\n        if (y.isInteger()) pairs.add(x to y.toLong())\n    }\n\n    return pairs\n        .sortedByDescending { it.first }\n        .joinToString(\", \", \"[\", \"]\") { (x, y) -> \"[$x, $y]\" }\n}\n\nfun findY(n: Long, x: Long) = sqrt((x.toDouble().pow(2) - n) \/ 4)\n\nfun Double.isInteger() = this == Math.floor(this) && !this.isInfinite()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 19:30:02"},{"id":206094,"user_id":492,"body":"package diophequa\n\nfun sol_equa(n:Long):String {\n    var res = \"[\"\n    var i:Long = 1\n    while (i < Math.sqrt(n.toDouble()) + 1)\n    {\n      if (n % i == 0L)\n      {\n        val p = i + (n \/ i).toLong()\n        val q = (n \/ i).toLong() - i\n        if ((p % 2 == 0L) && (q % 4 == 0L))\n        {\n          val c = \"[\" + java.lang.Long.toString((p \/ 2).toLong()) + \", \" + java.lang.Long.toString((q \/ 4).toLong()) + \"], \"\n          res += c\n        }\n      }\n      i++\n    }\n    if (res == \"[\") return \"[]\"\n    else return res.substring(0, res.length - 2) + \"]\"\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 19:30:02"},{"id":206095,"user_id":null,"body":"package diophequa\n\nfun sol_equa(n:Long):String {\n\n  \n  val divs = mutableListOf<Int>()\n  val limit = Math.sqrt(n.toDouble()).toInt()\n  \n  for (i in 1..limit) {\n    if (n % i == 0L)\n      divs.add(i)\n  }\n  \n  val res = mutableListOf<List<String>>()\n  for (x in (n \/ 2) + 1 downTo 1) {\n    for (d in divs) {\n      if ( (x - 2 *  ((x - d) \/ 2)) * (x + 2 * ((x - d) \/ 2)) == n) {\n        val r = listOf(x.toString(), ((x - d) \/ 2).toString())\n        res.add(r)\n        break\n      }\n    }\n  }\n  return res.toString()\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 19:30:02"},{"id":206096,"user_id":null,"body":"package diophequa\n\nfun sol_equa(n:Long):String {\n    \n    var result = mutableListOf<Pair<Long,Long>>()\n    \n    for (i in 1..n) {\n        if ((n % i).toString() == \"0\") {\n            \n            \/\/ 2x = i + n\/i\n            \/\/ 4y = n\/i - i \n            \n            if (((i + n\/i) % 2).toString() == \"0\" && (i + n\/i) \/ 2 >= 0) {\n                if (((n\/i - i) % 4).toString() == \"0\" && (n\/i - i ) \/ 4 >= 0) {\n                    var x = (i + n\/i) \/ 2\n                    var y = (n\/i - i) \/ 4\n\n                    result.add(Pair(x,y))\n                } \n            }\n        }\n    }\n\n    return \"[\" + result.joinToString().replace(\"(\",\"[\").replace(\")\",\"]\") + \"]\"\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 19:30:02"}],"555086d53eac039a2a000083":[{"id":206097,"user_id":null,"body":"fun lovefunc(flowerA: Int, flowerB: Int): Boolean = (flowerA + flowerB) %2 == 1","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206098,"user_id":1701,"body":"fun lovefunc(flowerA: Int, flowerB: Int): Boolean {\n  return flowerA % 2 !== flowerB % 2;\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206099,"user_id":null,"body":"fun lovefunc(flowerA: Int, flowerB: Int) = flowerA % 2 != flowerB % 2","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206100,"user_id":527,"body":"fun lovefunc(flowerA: Int, flowerB: Int): Boolean {\n    return flowerA % 2 != flowerB % 2\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206101,"user_id":null,"body":"fun lovefunc(flowerA: Int, flowerB: Int): Boolean {\n  \/\/ moment of truth\n    val sum: Int = flowerA + flowerB\n    return sum%2 != 0\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206102,"user_id":53,"body":"fun lovefunc(a: Int, b: Int): Boolean {\n  return (a+b)%2==1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206103,"user_id":null,"body":"fun lovefunc(flowerA: Int, flowerB: Int): Boolean {\n val soma = flowerA + flowerB \/\/ moment of truth\n    if (soma % 2 == 1 ){\n        return true\n    }\n    else return false\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206104,"user_id":null,"body":"fun lovefunc(flowerA: Int, flowerB: Int): Boolean {\n if (flowerA%2==0 && flowerB%2!==0) {\n        return true\n    }else if(flowerA%2!==0 && flowerB%2==0){\n        return true\n    }else return false\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206105,"user_id":null,"body":"fun lovefunc(flowerA: Int, flowerB: Int): Boolean {\n    return when {\n        flowerA % 2 == 0 && flowerB % 2 != 0 -> true\n        flowerA % 2 != 0 && flowerB % 2 == 0 -> true\n        else -> false\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206106,"user_id":null,"body":"fun lovefunc(flowerA: Int, flowerB: Int) = (flowerA % 2 == 0).xor(flowerB % 2 == 0)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5551dc71101b2cf599000023":[{"id":206107,"user_id":null,"body":"fun maxPizza(cuts: Int): Int {\n    return if (cuts < 0) -1 else cuts * (cuts + 1) \/ 2 + 1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206108,"user_id":null,"body":"fun maxPizza(cuts: Int): Int = if (cuts >= 0) (1..cuts).fold(1) { acc, i -> acc + i } else -1","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206109,"user_id":null,"body":"fun maxPizza(cuts: Int): Int = if (cuts < 0) -1 else 1 + cuts * (cuts + 1) \/ 2\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206110,"user_id":null,"body":"fun maxPizza(cuts: Int) = when {\n    cuts < 0 -> -1\n    cuts == 0 -> 1\n    else -> cuts * ( cuts + 1) \/ 2 + 1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206111,"user_id":null,"body":"import kotlin.math.pow\nfun maxPizza(cuts: Int): Int {\n    if (cuts>-1) {\n        return (cuts*cuts + cuts + 2)\/2\n    } else {\n        return -1\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206112,"user_id":168,"body":"fun maxPizza(cuts: Int): Int = when {\n    cuts < 0 -> -1\n    else     -> 1 + cuts * (cuts + 1) \/ 2\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206113,"user_id":null,"body":"fun maxPizza(c: Int): Int {\n    if(c<0){\n        return -1\n    } else {\n        return c*(c+1)\/2 + 1\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206114,"user_id":null,"body":"import kotlin.math.pow\n\nfun maxPizza(cuts: Int) = if(cuts < 0) -1 else ((cuts.toDouble().pow(2) + cuts + 2)\/2).toInt()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206115,"user_id":null,"body":"fun maxPizza(cuts: Int): Int {\n    var x = 7\n    if (cuts < 0) {\n        return -1\n    }\n    if (cuts == 0) {\n        return 1\n    }\n    if (cuts == 3) {\n        return x\n    }\n    for (cut in 4..cuts) {\n        x += cut\n    }\n    return x\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206116,"user_id":null,"body":"fun maxPizza(cuts: Int): Int {\n    if(cuts<0)\n        return -1;\n    var a=1;\n    var mas=0 .. cuts;\n    for(i in mas)\n        a+=i;\n    return a;\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5552101f47fc5178b1000050":[{"id":206117,"user_id":null,"body":"import kotlin.math.pow\nfun dig_pow(n: Int, p: Int) = n.toString().mapIndexed { i, c -> c.toString().toDouble().pow(p + i).toInt() }.sum().let { if (it % n == 0) it \/ n else -1 }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206118,"user_id":null,"body":"fun dig_pow(n: Int, p: Int): Int {\n    val sum = n.toString().map { digit -> Character.getNumericValue(digit) }\n            .mapIndexed { index, digit -> Math.pow(digit.toDouble(), (p + index).toDouble()).toInt() }\n            .reduce { acc, i -> acc + i }\n        \n        return if (sum.rem(n) == 0) sum\/n else -1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206119,"user_id":null,"body":"import kotlin.math.*\nfun dig_pow(n: Int, p: Int): Int {\n\n    var sum = mutableListOf<Int>()\n    var square = p\n\n    for (digit in n.toString()) {\n\n        var digitSquared = digit.toString().toDouble()\n                .pow(square).toInt()\n\n        sum.add(digitSquared)\n\n        square += 1\n    }\n\n    if (sum.sum() % n == 0) {\n        return sum.sum() \/ n\n    } else {\n        return -1\n    }\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206120,"user_id":null,"body":"import kotlin.math.pow\n\nfun dig_pow(n: Int, p: Int): Int {\n        if(n == 0) {\n        return -1\n    }\n\n    val sum = n.toString()\n        .split(\"\")\n        .filter(String::isNotBlank)\n        .map(String::toDouble)\n        .mapIndexed { index, i -> i.pow(p + index) }\n        .sum()\n\n    val i = sum \/ n.toDouble()\n\n    return if(i % 1.0 == 0.0) i.toInt() else -1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206121,"user_id":null,"body":"import kotlin.math.pow\n\nprivate infix fun Int.`^`(p: Int) = this.toDouble().pow(p).toInt()\n\npublic fun dig_pow(n: Int, p: Int) =\n        n.toString()\n            .map(Character::getNumericValue)\n            .foldIndexed(0) { index: Int, acc: Int, each: Int -> acc + (each `^` (p + index)) }\n            .let { if (it % n == 0) it \/ n else -1 }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206122,"user_id":null,"body":"import kotlin.math.pow\nfun dig_pow(n: Int, p: Int): Int  = n.toString().map { it.toString().toDouble() }.foldIndexed(0){i,n,str -> n.plus((str.pow(p+i)).toInt()) }.let { if (it % n == 0) it \/ n else -1 }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206123,"user_id":null,"body":"fun dig_pow(n: Int, p: Int): Int {\n    var sum = 0\n    for (i in 0 until n.toString().length) {\n        sum += (Math.pow(n.toString()[i].toDouble() - 48, p.toDouble() + i)).toInt()\n    }\n    return if (sum % n  == 0) sum \/ n\n    else - 1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206124,"user_id":null,"body":"import kotlin.math.pow\nfun dig_pow(n: Int, p: Int): Int {\n    var num = 0\n    n.toString().map {\n        it.digitToInt()\n    }.forEachIndexed { i, it ->\n        num += it.toDouble().pow(p + i).toInt()\n    }\n    return if ((num % n) == 0) num \/ n else -1\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206125,"user_id":null,"body":"import kotlin.math.pow\n\ninfix fun Int.`^`(p: Int) = this.toDouble().pow(p).toInt()\n\npublic fun dig_pow(n: Int, p: Int) = n.toString().map(Character::getNumericValue).foldIndexed(0) {\n    index: Int, acc: Int, each: Int -> acc + (each `^` (p + index)) \n}.let { if (it % n == 0) it \/ n else -1 }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206126,"user_id":null,"body":"import kotlin.math.ceil\nimport kotlin.math.floor\nimport kotlin.math.pow\n\nfun dig_pow(number: Int, initialPower: Int): Int {\n\n  \/\/ Get digits of a number as list.\n  val digits: List<Int> = getDigits(number)\n\n  \/\/ Raise each number to the appropriate power.\n  val sum = digits.mapIndexed { index, digit ->\n    digit.toDouble().pow(index + initialPower)\n  }\n    \/\/ Sum the results.\n    .sum()\n\n  val result = sum \/ number\n\n  return when (checkIfInteger(result)) {\n    \/\/ We can safely parse to int because we already know that the result is an integer value.\n    true -> result.toInt()\n    false -> -1\n  }\n}\n\nprivate fun checkIfInteger(value: Double): Boolean =\n  ceil(value) == floor(value)\n\n\/**\n * Rules of the task claim that parameters will always be positive integer values,\n * so we can simply parse them to string, and back to int.\n *\/\nprivate fun getDigits(number: Int): List<Int> =\n  number.toString().toCharArray().map { Character.getNumericValue(it) }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"555624b601231dc7a400017a":[{"id":206127,"user_id":527,"body":"fun josephus_survivor(n: Int, k: Int): Int = (1..n).fold(1){ i, j -> (i + k) % j } + 1","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 15:47:19"},{"id":206128,"user_id":null,"body":"fun josephus_survivor(n: Int, k: Int): Int {\n        var res = 0\n        for (i in 1..n) {\n            res = (res + k) % i\n        }\n        return res + 1\n    }","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 15:47:25"},{"id":206129,"user_id":null,"body":"fun josephus_survivor(n: Int, k: Int): Int {\n    var survivor = 0\n    for (i in 2..n) {\n        survivor = (survivor + k) % i\n    }\n\n    return survivor + 1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 15:32:35"},{"id":206130,"user_id":null,"body":"fun josephus_survivor(n: Int, k: Int) = (1..n).toMutableList().run { \n    var i = 0 \n    while( this.size > 1 ) { \n        i=(i-1+k)%this.size \n        this.removeAt(i) \n    }\n    this.first() \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 15:32:35"},{"id":206131,"user_id":645,"body":"fun josephus_survivor(n: Int, k: Int): Int = if (n == 1) 1 else (josephus_survivor(n - 1, k) + k - 1) % n + 1","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 15:32:35"},{"id":206132,"user_id":null,"body":"fun josephus_survivor(elementNum: Int, modulo: Int): Int {    \n    var elementList = (1..elementNum).toMutableList();\n    \n    return rec(elementList, 0, modulo);\n}\n\nfun rec(elementList: MutableList<Int>, index: Int, modulo: Int): Int {\n    if(elementList.size == 1) {\n        return elementList.first();\n    }\n    \n    var newIndex = (index + modulo - 1) % elementList.size;\n    \n    elementList.removeAt(newIndex);\n    \n    return rec(elementList, newIndex, modulo);\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 15:32:35"},{"id":206133,"user_id":null,"body":"fun josephus_survivor(n: Int, k: Int): Int {\n    return (1..n).reduce { x, ni -> (x + k - 1) % ni + 1 }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 15:32:35"},{"id":206134,"user_id":null,"body":"fun josephus_survivor(n: Int, k: Int): Int {\n    val circle = (1..n).toMutableList()\n    var indexOfLastEliminated = 0\n    while (circle.size > 1) {\n        indexOfLastEliminated += k - 1\n        while (indexOfLastEliminated > circle.lastIndex)\n            indexOfLastEliminated -= circle.size\n        circle.removeAt(indexOfLastEliminated)\n    }\n    return circle.first()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 15:32:35"},{"id":206135,"user_id":null,"body":"fun josephus_survivor(n: Int, k: Int): Int {\n    val survivors = MutableList(n) { it + 1 }\n    var victimIndex = (k - 1)  % survivors.size\n    \n    while (survivors.size > 1) {\n        survivors.removeAt(victimIndex)\n        victimIndex = (victimIndex + k - 1) % survivors.size\n    }\n    \n    return survivors.first()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 15:32:35"},{"id":206136,"user_id":null,"body":"fun josephus_survivor(n: Int, k: Int): Int {\n     val cirkle = mutableListOf<Int>()\n for (i in 1..n) {\n     cirkle.add(i)\n }\n var count = 1\n var index = 0\n while (cirkle.size != 1) {\n     if (index == cirkle.size) {\n         index = 0\n         continue\n     }\n     if (count % k == 0) {\n         cirkle.removeAt(index)\n         count = 1\n         continue\n     }\n     index++\n     count++\n }\n return cirkle[0]\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 15:32:35"}],"55685cd7ad70877c23000102":[{"id":206137,"user_id":null,"body":"class Kata {\n\n    fun make_negative(x: Int) = if(x <= 0) x else -x\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206138,"user_id":null,"body":"import kotlin.math.abs\n\nclass Kata {\n    fun make_negative(x: Int) = -abs(x)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206139,"user_id":null,"body":"import kotlin.math.absoluteValue\n\nclass Kata {\n\n    fun make_negative(x: Int) = -x.absoluteValue\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206140,"user_id":null,"body":"class Kata {\n\n    fun make_negative(x: Int): Int {\n        return if (x < 0) x else -x\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206141,"user_id":527,"body":"class Kata {\n\n    fun make_negative(x: Int): Int {\n        return -Math.abs(x)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206142,"user_id":null,"body":"class Kata {\n\n    fun make_negative(x: Int): Int {\n        \/\/ your code here\n        if(x > 0.0)\n            return x.unaryMinus()\n         else\n             return x\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206143,"user_id":null,"body":"class Kata {\n    fun make_negative(x: Int) = -Math.abs(x)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206144,"user_id":null,"body":"class Kata {\n\n    fun make_negative(x: Int): Int {\n        return if (x >= 0) -x else x\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206145,"user_id":null,"body":"class Kata {\n\n    fun make_negative(x: Int): Int {\n        var y=Math.abs(x)\n        return(y*(-1))\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206146,"user_id":null,"body":"class Kata {\n\n    fun make_negative(x: Int): Int {\n        if (x <= 0) return x\n        else return (-1)*x\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"556deca17c58da83c00002db":[{"id":206147,"user_id":null,"body":"fun tribonacci(signature: DoubleArray, n: Int) = generateSequence(Triple(signature[0], signature[1], signature[2])) {\n        Triple(it.second, it.third, it.first + it.second + it.third) }\n        .map { it.first }\n        .take(n)\n        .toList()\n        .toDoubleArray()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206148,"user_id":null,"body":"fun tribonacci(signature: DoubleArray, n: Int) = DoubleArray(n).also {\n    for (i in 0 until n) {\n        it[i] = if (i < signature.size) signature[i] else it[i - 3] + it[i - 2] + it[i - 1]\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206149,"user_id":null,"body":"fun tribonacci(signature: DoubleArray, n: Int) =\n  signature.toMutableList().apply {\n      repeat(n) {\n          add(takeLast(3).sum())\n      }\n  }.take(n).toDoubleArray()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206150,"user_id":null,"body":"fun tribonacci(signature: DoubleArray, n: Int): DoubleArray =\n    if (n - 3 > 0) tribonacci(signature + signature.takeLast(3).sum(), n - 1) else signature\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206151,"user_id":null,"body":"fun tribonacci(signature: DoubleArray, n: Int): DoubleArray {\n\n  val a = DoubleArray(n)\n\n  for(i in 0 until n){\n      if(i < 3){\n          a[i] = signature[i]\n      }else{\n          a[i] = a[i-3] + a[i-2] + a[i-1]\n      }\n  }\n  return a\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206152,"user_id":null,"body":"fun tribonacci(signature: DoubleArray, n: Int): DoubleArray {\n    var r = signature.toMutableList()\n    val s = signature.size\n    while (r.size<n){\n        r.add(r.takeLast(s).sum())\n    }\n    return r.takeLast(n).toDoubleArray()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206153,"user_id":null,"body":"fun tribonacci(signature: DoubleArray, n: Int): DoubleArray {\n    if (n == 0) {\n        return doubleArrayOf()\n    }\n    \n    val array = DoubleArray(n) { index -> \n        if (index < 3) {\n            return@DoubleArray signature[index]\n        }\n        return@DoubleArray 0.0\n    }\n    for (i: Int in 3..(n - 1)) {\n        array[i] = array[i - 3].plus(array[i - 2]).plus(array[i - 1])\n    }\n    \n    return array\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206154,"user_id":null,"body":"fun tribonacci(signature: DoubleArray, n: Int): DoubleArray {\n    val tribonacci = sequence<Double> {\n        var cur = signature[0]\n        var cur2 = signature[1]\n        var next = signature[2]\n        while (true) {\n            yield(cur)\n            val temp = cur + cur2 + next\n            cur = cur2\n            cur2 = next\n            next = temp\n        }\n    }\n    return tribonacci.take(n).toList().toDoubleArray()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206155,"user_id":null,"body":"fun tribonacci(sig: DoubleArray, n: Int): DoubleArray =\n  if (n <= sig.size) sig.copyOf(n)\n  else (sig.size until n).fold(sig.toMutableList()) { acc, _ ->\n    acc += acc.takeLast(sig.size).sum()\n    acc\n  }.toDoubleArray()\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206156,"user_id":null,"body":"fun tribonacci(signature: DoubleArray, n: Int): DoubleArray {\n    var memo: DoubleArray = signature\n    for (i in 3..n-1) {\n        memo += memo[i-3] + memo[i-2] + memo[i-1]\n    }\n    return memo.sliceArray(0..n-1)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"557cd6882bfa3c8a9f0000c1":[{"id":206157,"user_id":null,"body":"fun get_age(yearsOld: String) = yearsOld.take(1).toInt()","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206158,"user_id":null,"body":"package basic\n\nclass ParseIntCharProblem {\n    \n   fun get_age(yearsOld: String): Int {\n        \n       return yearsOld[0].digitToInt()\n       \n   }\n    \n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206159,"user_id":null,"body":"package basic\n\nclass ParseIntCharProblem {\n    \n   fun get_age(yearsOld: String): Int {\n       return yearsOld.first().digitToInt()\n       \/\/ your code here\n       \n   }\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206160,"user_id":null,"body":"package basic\n\nclass ParseIntCharProblem {\n    \n   fun get_age(yearsOld: String) = yearsOld.first().digitToInt()\n\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206161,"user_id":null,"body":"package basic\n\nclass ParseIntCharProblem {\n    \n   fun get_age(y: String): Int = y.first().digitToInt()\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206162,"user_id":null,"body":"package basic\n\nclass ParseIntCharProblem {\n    \n   fun get_age(yearsOld: String): Int {\n        \n       if (yearsOld == \"\" || yearsOld.length == 0) {\n           throw IllegalStateException(\"Empty string\")\n       }\n       \n       \n       return yearsOld[0].toString().toInt()\n   }\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206163,"user_id":null,"body":"package basic\n\nclass ParseIntCharProblem {\n    \n   fun get_age(yearsOld: String) = yearsOld.takeWhile { it.isDigit() }.toInt()\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206164,"user_id":null,"body":"package basic\n\n\nclass ParseIntCharProblem {\n    fun get_age(yearsOld: String) = yearsOld.first().toString().toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206165,"user_id":null,"body":"package basic\n\nclass ParseIntCharProblem {\n    fun get_age(yearsOld: String) = (yearsOld[0]+\"\").toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206166,"user_id":null,"body":"package basic\n\nclass ParseIntCharProblem {\n    \n   fun get_age(yearsOld: String): Int {\n   val res = yearsOld.split(\" \")\n   return res[0].toInt()\n   }\n   \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5583090cbe83f4fd8c000051":[{"id":206167,"user_id":null,"body":"object Kata {\n  fun digitize(n:Long):IntArray {\n    return n.toString().map(Character::getNumericValue).toIntArray().reversedArray()\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206168,"user_id":null,"body":"object Kata {\n  fun digitize(n:Long):IntArray {\n  \n  var result = n.toString().map { it.toString().toInt() }.toIntArray();\n\n    return result.reversedArray();\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206169,"user_id":null,"body":"object Kata {\n   fun digitize(n:Long):IntArray = n.toString().reversed().map { it.digitToInt() }.toIntArray()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206170,"user_id":null,"body":"object Kata {\n    fun digitize(n: Long) = \"$n\".reversed().map { \"$it\".toInt() }.toIntArray()\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206171,"user_id":null,"body":"object Kata {\n fun digitize(n: Long): IntArray {\n    if (n == 0L) {\n        return IntArray(1) {0}\n    }\n\n    var remain: Long = n\n    val list: MutableList<Int> = mutableListOf()\n\n    while ((remain != 0L)) {\n        val lastNumber: Int = (remain % 10).toInt()\n        remain \/= 10\n        list.add(lastNumber)\n    }\n\n    return list.toIntArray()\n}\n}\n\n  \n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206172,"user_id":null,"body":"object Kata {\n  fun digitize(n:Long):IntArray {\n     return n.toString()\n            .toList()\n            .map { it.toString().toInt() }\n            .asReversed()\n            .toIntArray()\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206173,"user_id":null,"body":"object Kata {\n  fun digitize(n:Long):IntArray {\n    var s = n.toString().reversed().toCharArray()\n    \n    var i = IntArray(s.size)\n    for(a in 1..s.size) i[a-1] = s[a-1].toString().toInt()\n    \n    return i\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206174,"user_id":null,"body":"object Kata {\n  fun digitize(n:Long):IntArray {\n      \n   var nToString = n.toString().reversed()\n   var result = nToString.map { it.toString().toInt() }\n   \n      return result.toIntArray()\n\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206175,"user_id":null,"body":"object Kata {\n  fun digitize(n:Long):IntArray {\n    \/\/ Code here\n    return n.toString().reversed().map{it.toString().toInt()}.toIntArray()\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206176,"user_id":277,"body":"object Kata {\n  fun digitize(number:Long):IntArray {\n    return StringBuilder().append(number)\n    .reverse()\n    .chars()\n    .map({ i-> i - 48 })\n    .toArray()\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5592e3bd57b64d00f3000047":[{"id":206177,"user_id":492,"body":"package solution\n\n    fun find_nb(m: Long): Long {\n        var n: Long = 0\n        var cubeSize: Long = 0\n        while (cubeSize < m) {\n            cubeSize += n * n * n\n            n++\n        }\n        return if (cubeSize == m) n - 1 else -1\n    }","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206178,"user_id":null,"body":"package solution\n\nobject ASum {\n\n    fun find_nb(m: Long): Long {\n        var sum = 0L\n        return generateSequence(1L) { it + 1 }\n            .onEach { sum += it*it*it }\n            .takeWhile { sum <= m }\n            .lastOrNull { sum == m } \n            ?: -1\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206179,"user_id":null,"body":"package solution\n\nimport kotlin.math.sqrt\n\nobject ASum {\n\n    \/**\n     * @see <a href=\"https:\/\/luckytoilet.wordpress.com\/2011\/05\/20\/simplifying-a-sum-of-consecutive-cubes\/\">Sum of consecutive cubes<\/a>\n     * @see <a href=\"http:\/\/jwilson.coe.uga.edu\/EMAT6680Fa2013\/Hendricks\/Essay%202\/Essay2.html\">Sum of consecutive numbers<\/a>\n     * @see <a href=\"https:\/\/en.wikipedia.org\/wiki\/Quadratic_equation\">Quadratic Equation<\/a>\n     *\/\n    fun find_nb(m: Long): Long {\n        \/\/ Step 1. Apply the sum of consecutive cubes:\n        \/\/ n^3 + (n-1)^3 + ... + 1^3 = m\n        \/\/ (n + (n-1) + ... + 1)^2 = m\n    \n        \/\/ Step 2. Applying the sum of consecutive numbers:\n        \/\/ (n * (n+1) \/ 2)^2 = m\n    \n        \/\/ Step 3. Transform into a quadratic equation:\n        \/\/ n^2 + n - 2*sqrt(m) = 0\n    \n        \/\/ Step 4. Applying the formula for finding the solutions of a quadratic equation:\n        \/\/ n1 = -0.5 + sqrt(1+8sqrt(m)) \/ 2\n        \/\/ n2 = -0.5 - sqrt(1+8sqrt(m)) \/ 2\n    \n        \/\/ assuming the solution should be the positive one; otherwise max(sol1, sol2) should be used instead\n        val solution = -0.5 + sqrt(1 + 8 * sqrt(m.toDouble())) \/ 2\n    \n        \/\/ make sure the solution is an integer\n        return if (solution.rem(1) == 0.toDouble()) {\n            solution.toLong()\n        } else {\n            -1L\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206180,"user_id":null,"body":"package solution\nimport kotlin.math.pow\n\nobject ASum {\n    fun find_nb(m: Long): Long {\n        var sum: Long = 0\n        var x: Double = 0.0\n        while(sum < m) sum+=(++x).pow(3).toLong()\n        if (sum==m) return x.toLong() else return -1\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206181,"user_id":null,"body":"package solution\n\nobject ASum {\n\n    fun find_nb(m: Long): Long {\n        var res: Long = 0\n        var i: Long = 0\n        while (res < m) {\n            i++\n            res += i * i * i\n        }\n        return if (res == m) i else -1\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206182,"user_id":null,"body":"package solution\n\nimport kotlin.math.sqrt\n\nobject ASum {\n    fun find_nb(m: Long): Long {\n        val n = ((-1 + sqrt(1 + 8 * sqrt(m.toDouble()))) \/ 2)\n        val isInteger = n % 1.0 == 0.0\n        return if (isInteger) n.toLong() else -1\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206183,"user_id":null,"body":"package solution\n\nobject ASum {\n\n    fun find_nb(m: Long): Long {\n        var i = 0L\n        var mr = m\n        while (mr > 0) {\n            i++\n            mr -= i*i*i\n        }\n        return if (mr == 0L) i else -1\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206184,"user_id":null,"body":"package solution\n\nimport kotlin.math.*\n\nobject ASum {\n    fun find_nb(m: Long): Long {\n        val tnt = floor(sqrt(2 * sqrt(m.toDouble()))).toLong()\n        if ((tnt * tnt * (tnt + 1) * (tnt + 1)) \/ 4 == m)\n            return tnt\n        else\n            return -1\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206185,"user_id":null,"body":"package solution\n\nobject ASum {\n    private tailrec fun sumq(check: Long, n: Long = 1L, sum: Long = 0L): Long =\n        when {\n            sum*sum == check -> n-1\n            sum*sum > check -> -1\n            else -> sumq(check, n+1, sum + n)\n        }\n    fun find_nb(m: Long): Long = sumq(m)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206186,"user_id":null,"body":"package solution\n\nimport kotlin.math.sqrt\n\nobject ASum {\n\n    fun find_nb(m: Long): Long {\n        val x = sqrt(m.toDouble())\n        val y = sqrt(x * 8 + 1)\n        if (x % 1 != 0.0 || y % 1 != 0.0) return -1\n        return ((y - 1) \/ 2).toLong()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"559536379512a64472000053":[{"id":206187,"user_id":null,"body":"package solution\n\n    fun play_pass(s: String, n: Int) = s.map { when {\n            it.isUpperCase() -> ((it - 'A' + n) % 26 + 65).toChar()\n            it.isDigit() -> '9' - (it - '0')\n            else -> it\n        } }.mapIndexed { idx, ch -> if (idx % 2 == 1) ch.toLowerCase() else ch }.reversed().joinToString(\"\")","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206188,"user_id":null,"body":"package solution\n\nobject PlayPass {\n\n    fun play_pass(s: String, n: Int): String {\n        fun playChar(c: Char): Char = when(c) {\n            in '0'..'9' -> '0' + ('9' - c)\n            in 'a'..'z' -> 'a' + ((c-'a') + n) % 26\n            in 'A'..'Z' -> 'A' + ((c-'A') + n) % 26\n            else        -> c\n        }\n        return s.map(::playChar)\n                .mapIndexed { idx, c -> if( idx % 2 > 0 ) c.toLowerCase() else c.toUpperCase() }\n                .reversed()\n                .joinToString(\"\")\n    }\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206189,"user_id":null,"body":"package solution\n\nobject PlayPass {\n\n    fun play_pass(s: String, n: Int) =\n        s.map { c ->\n            when {\n                c.isLetter() -> c.rotate(n)\n                c.isDigit() -> c.complementDigit()\n                else -> c\n            }\n        }.mapIndexed { pos, c -> if (pos.isOdd()) c.toLowerCase() else c }\n        .reversed()\n        .joinToString(\"\")\n\n    private fun Char.rotate(n: Int) = (((this + n) - 'A').rem('Z' - 'A'.dec()) + 'A'.toInt()).toChar()\n    private fun Char.complementDigit() = (9 - this.toString().toInt()).toString()[0]\n    private fun Int.isOdd() = this % 2 == 1\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206190,"user_id":null,"body":"package solution\n\nobject PlayPass {\n\n    fun play_pass(s: String, n: Int) = \n        s.toLowerCase()\n            .map{ if(it.isLetter()) ((it.toInt() - 97 + n) % 26 + 97).toChar() else it}\n            .mapIndexed { index, c -> if(index % 2 == 1) c.toLowerCase() else c.toUpperCase() }\n            .map{ if(it.isDigit()) \"${9 - \"$it\".toInt()}\"[0] else it }\n            .reversed()\n            .joinToString(\"\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206191,"user_id":null,"body":"package solution\n\nobject PlayPass {\n\n    fun play_pass(s: String, n: Int): String {\n        val abc = \"abcdefghijklmnopqrstuvwxyz\"\n        val sb = StringBuilder()\n        s.forEachIndexed { i, ch ->\n            when {\n                ch.isLetter() -> {\n                    var num = abc.indexOf(ch.toLowerCase())\n                    (0 until n).map { if (num == abc.lastIndex) num = 0 else num++ }\n                    sb.append(if (i % 2 == 0) abc[num].toUpperCase() else abc[num].toLowerCase())\n                }\n                ch.isDigit() -> sb.append(9 - ch.toString().toInt())\n                else -> sb.append(ch)\n            }\n        }\n\n        return sb.reversed().toString()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206192,"user_id":null,"body":"package solution\n\nobject PlayPass {\n\n    fun play_pass(s: String, n: Int): String =\n        s\n            .map {\n                when {\n                    it.isLetter() && it.isUpperCase() -> 'A' + (it - 'A' + n) % ('Z' - 'A' + 1)\n                    it.isLetter() && it.isLowerCase() -> 'a' + (it - 'a' + n) % ('z' - 'a' + 1)\n                    it.isDigit() -> '0' + ('9' - it)\n                    else -> it\n                }\n            }.withIndex()\n            .map { if (it.index % 2 == 0) it.value.toUpperCase() else it.value.toLowerCase() }\n            .reversed()\n            .joinToString(\"\") { \"$it\" }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206193,"user_id":null,"body":"package solution\n\nobject PlayPass {\n\n    fun play_pass(s: String, n: Int): String {\n        return s.map { if (it.isLetter()) ('A' + (((it - 'A') + n) % 26)) else it }\n            .map { if (it.isDigit()) ('9' - it) else it }.joinToString(\"\")\n            .mapIndexed { index, it -> if (index % 2 != 0) it.lowercase() else it }\n            .reversed()\n            .joinToString(\"\")\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206194,"user_id":null,"body":"package solution\n\nobject PlayPass {\n    val abc = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n    fun play_pass(s: String, n: Int): String {\n        var s1 = \"\"\n\n        s.forEachIndexed { index, c -> \n            s1 += when {\n                c.isLetter() -> {\n                    val temp = abc[(abc.indexOf(c) + n) % 26]\n                    if (index % 2 == 0) temp.uppercaseChar() else temp.lowercaseChar()\n                }\n                c.isDigit() -> (9 - c.digitToInt()).toString()\n                else -> c\n            }\n        }    \n        \n        return s1.reversed()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206195,"user_id":null,"body":"package solution\nimport java.util.*\n\nobject PlayPass {\n\n fun play_pass(s: String, n: Int): String {\n    return  s.lowercase(Locale.getDefault()).map{\n        if (it.isDigit())('9'- it)\n        else if(it.isLetter())\n            if(it.code + n <= 122)\n                Char (it.code + n)\n            else\n                Char('a'.code - 1 + it.code + n - 122  )\n        else it\n    }.joinToString(separator = \"\").mapIndexed{indx, letter -> if(indx % 2 == 0 ) letter.uppercaseChar() else letter }.reversed().joinToString(separator = \"\")\n\n}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206196,"user_id":null,"body":"package solution\n\nobject PlayPass {\n\n    fun play_pass(s: String, n: Int): String {\n        val builder = StringBuilder()\n        for (i in s.length - 1 downTo 0) {\n            val char = s[i]\n            when {\n                char.isDigit() -> builder.append((9 - char.digitToInt()))\n                char.isLetter() -> builder.append(convertLetter(char, n, i))\n                else -> builder.append(char)\n            }\n        }\n        return builder.toString()\n    }\n\n    private fun convertLetter(char: Char, n: Int, i: Int): Char {\n        val aValue = if (char.isLowerCase()) 97 else 65\n        val newChar = ((((char.code - aValue) + n) % 26) + aValue).toChar()\n        return if (i % 2 == 0) Character.toUpperCase(newChar) else Character.toLowerCase(newChar)\n    }\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"55983863da40caa2c900004e":[{"id":206197,"user_id":null,"body":"package solution\n\nfun next_bigger(n: Long): Long {\n    val text = n.toString().toMutableList()\n    for (i in text.size - 2 downTo 0) {\n        if (text[i] < text[i + 1]) {\n            val tail = text.subList(i + 1, text.size)\n            val min = tail.withIndex().filter { it.value > text[i] }.minBy { it.value }!!\n            text[i + 1 + min.index] = text[i]\n            text[i] = min.value\n            tail.sort()\n            return text.joinToString(\"\").toLong()\n        }\n    }\n    return -1\n}","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206198,"user_id":null,"body":"package solution\n\nfun next_bigger(n: Long) = with(n.toString()) {\n        val idx = toList().windowed(2).indexOfLast{ (a, b) -> a < b }\n        if(idx < 0) return -1L\n\n        val end = drop(idx).toList()\n        val min = end.filter{ it > elementAt(idx) }.min()!!\n\n        (take(idx) + min + (end - min).sorted().joinToString(\"\")).toLong()\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206199,"user_id":null,"body":"package solution\n\nfun next_bigger(n: Long): Long {\n    val list = n.toString().toList()\n    list.indices.reversed().forEach {\n        val currentDigit = list[it]\n        val followingDigits = list.subList(it, list.size)\n        val smallestLargerFollowingDigit = followingDigits.sorted().find { it > currentDigit }\n        smallestLargerFollowingDigit?.run {\n            return (list.subList(0, it) +\n                    smallestLargerFollowingDigit +\n                    (list.subList(it, list.size) - smallestLargerFollowingDigit).sorted())\n                .joinToString(separator = \"\")\n                .toLong()\n        }\n    }\n    return -1\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206200,"user_id":null,"body":"package solution\n\nfun next_bigger(n: Long): Long {\n    var str = n.toString().toCharArray()\n    for (index in str.lastIndex downTo 1)\n        if (str[index].toInt() > str[index - 1].toInt()) {\n            var ch = str[index - 1]\n            var indexToChange = index\n            for (i in index until str.size)\n                if (str[indexToChange] > str[i] && str[i] > str[index - 1]) indexToChange = i\n            str[index - 1] = str[indexToChange]\n            str[indexToChange] = ch\n            str.sort(index, str.size)\n            return str.joinToString(\"\").toLong()\n        }\n    return -1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206201,"user_id":null,"body":"    package solution\n      \n    fun Char.asInt() = Integer.parseInt(this.toString())\n\n    fun next_bigger(n: Long): Long {\n        val num = n.toString()\n        val nLength = num.length\n        val digits = mutableListOf(num.last().asInt()) \n        for (i in nLength - 2 downTo 0) {\n            val digit = num[i].asInt()\n            if (num[i + 1].asInt() > digit) { \n                return digits.apply {\n                    add(digit)\n                }.sorted()\n                    .let { list ->\n                        list[list.lastIndexOf(digit) + 1]\n                    }.let { next_biggerDigit ->\n                        digits.remove(next_biggerDigit)\n                        num.substring(0, i) +\n                                next_biggerDigit +\n                                digits.sorted()\n                                    .joinToString(\"\")\n                    }.toLong()\n            } else {\n                digits.add(digit)\n            }\n        } \n        return -1\n    }\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206202,"user_id":null,"body":"package solution\n\nfun getPivot(nums: List<Int>, compare: Int): Int{\n    for(i in nums.size - 1 downTo 1) {if(nums[i] > compare) return i}\n    return nums.size - 1\n}\n\nfun next_bigger(n: Long): Long {\n    val nums = n.toString().toMutableList()\n\n    for(i in nums.size - 1 downTo 1) {\n        if(nums[i-1].toString().toInt() < nums[i].toString().toInt()) {\n            val pivotIndex = getPivot(nums.map { it.toString().toInt() }.toList(), nums[i-1].toString().toInt())\n            nums[pivotIndex] = nums[i-1].also {nums[i-1] = nums[pivotIndex]}\n            return (nums.subList(0, i) + nums.subList(i, nums.size).sortedBy { it.toString().toInt() }).joinToString(\"\").toLong()\n        }\n    }\n    return -1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206203,"user_id":932,"body":"package solution\n\nfun next_bigger(n: Long): Long {\n    n.toString().let {src->\n        src.lastIndex.downTo(1).forEach{i->\n            if (src[i]>src[i-1]){\n                return src.drop(i).toCharArray().sorted().joinToString(\"\").let {lastStr->lastStr.filter { it>src[i-1]}.first().let {(src.substring(0,i-1)+it+lastStr.replaceFirst(it,src[i-1])).toLong()}}\n            }\n        }\n    }\n    return -1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206204,"user_id":null,"body":"package solution\n\nfun next_bigger(n: Long): Long {\n    val nList = n.toString().toMutableList().map { it.toString() }.map { it.toLong() }\n    var counter = (n + 1).toString().toMutableList().map { it.toString() }.map { it.toLong() }.joinToString(\"\").toLong()\n    if (n == n.toString().toList().sortedDescending().joinToString(separator = \"\").toLong()){\n        return -1L\n    } else {\n        while (nList.sortedByDescending { it }\n            != counter\n                .toString()\n                .toMutableList()\n                .map { it.toString() }\n                .map { it.toLong() }\n                .sortedByDescending { it }){\n            counter++\n        }\n    }\n    return counter\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206205,"user_id":null,"body":"package solution\n\nfun next_bigger(n: Long): Long {\n    var forReplace = '0'\n    val wholeStr = n.toString()\n    val lastPart = wholeStr.takeLastWhile {\n        val out = it >= forReplace\n        forReplace = it\n        out\n    }.toCharArray()\n    lastPart.sort()\n    val firstPart = wholeStr.dropLast(lastPart.size).ifEmpty { return -1 }\n    val middlePart = lastPart.find { it > forReplace }!!\n    lastPart[lastPart.indexOf(middlePart)] = forReplace\n    return (firstPart.dropLast(1) + middlePart + lastPart.joinToString(\"\")).toLong()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206206,"user_id":53,"body":"package solution\nimport java.util.Arrays\n\nfun next_bigger(n: Long): Long {\n    System.out.println(n)\n    val arr = n.toString().toCharArray().reversed().toTypedArray()\n    System.out.println(Arrays.toString(arr))\n    var i = 0\n    for (k in 1..arr.size-1) {\n        if (arr[k - 1].toLong() > arr[k].toLong()) {\n            i = k\n            break\n        }\n    }\n    if (i == -1) {\n        return -1\n    }\n    var slice = arr.copyOfRange(0, i)\n    var j = 0\n    for (k in 0..slice.size-1) {\n        if (arr[i].toLong() < slice[k].toLong()) {\n            j = k\n            break\n        }\n    }\n    if (i == j) {\n        return -1\n    }\n    slice[j] = arr[i]\n    var pre = \"\".toCharArray().toTypedArray()\n    if (i + 1 < arr.size) {\n        pre = arr.copyOfRange(i + 1, arr.size).reversed().toTypedArray()\n    }\n    return (pre + arrayOf(arr[j]) + slice).joinToString(\"\").toLong()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"559a28007caad2ac4e000083":[{"id":206207,"user_id":780,"body":"import java.math.BigInteger\n\nfun perimeter(n: Int): BigInteger = fibonacci(n+1).reduce{x,y -> x+y}.multiply(BigInteger(\"4\"))\n\nfun fibonacci(n: Int): Sequence<BigInteger> = generateSequence(Pair(BigInteger.ONE, BigInteger.ONE), { Pair(it.second, it.first + it.second) }).map { it.first }.take(n)","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206208,"user_id":null,"body":"package solution\n\nimport java.math.BigInteger\n\nobject SumFct {\nfun perimeter(n: Int) =\n    generateSequence(BigInteger.ZERO to BigInteger.ONE){it.second to it.first.plus(it.second) }\n        .map { it.first }\n        .take(n+2)\n        .fold(BigInteger.ZERO){acc, bi -> acc.plus(bi)}\n        .multiply(BigInteger(\"4\"))\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206209,"user_id":null,"body":"package solution\nimport java.math.BigInteger\nobject SumFct {\n    fun perimeter(n: Int) = generateSequence(BigInteger.ONE.let { Pair(it, it) }) { Pair(it.second, it.first + it.second) }.take(n + 1).sumOf { it.first * 4.toBigInteger() }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206210,"user_id":null,"body":"package solution\n\nimport java.math.BigInteger\n\nobject SumFct {\n    fun perimeter(n: Int): BigInteger {\n        val list = mutableListOf<BigInteger>(BigInteger.ONE, BigInteger.ONE)\n        var result: BigInteger = BigInteger.valueOf(2)\n        for (i in 2..n) {\n            list.add(list[i - 1] + list[i - 2])\n            result += (list[i - 1] + list[i - 2])\n        }\n        return result * BigInteger.valueOf(4)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206211,"user_id":null,"body":"package solution\n\nimport java.math.BigInteger\n\nobject SumFct {\n    fun perimeter(n: Int): BigInteger = sequence<BigInteger> {\n        var elements = BigInteger.ONE to BigInteger.ONE\n        while (true) {\n            yield(elements.first)\n            elements = elements.second to elements.first + elements.second\n        }\n    }.take(n.inc()).reduce { acc, it -> acc.add(it) }.multiply(BigInteger.valueOf(4))\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206212,"user_id":null,"body":"package solution\n\nimport java.math.BigInteger\n\nobject SumFct {\n\n    fun perimeter(n: Int): BigInteger {\n        var a = BigInteger.ONE\n        var b = BigInteger.ONE\n\n        repeat(n + 2) {\n            b = (a + b).also { a = b }\n        }\n        return (a - BigInteger.ONE) * 4.toBigInteger()\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206213,"user_id":null,"body":"package solution\n\nimport java.math.BigInteger\n\nobject SumFct {\n   fun perimeter(n: Int): BigInteger{\n    var lr : Array<BigInteger> = arrayOf(BigInteger(\"1\"), BigInteger(\"1\"),BigInteger(\"0\"))\n    var S:BigInteger = BigInteger(\"2\")\n    var k = 2\n    while(n+1-k>0){\n        lr[2] = lr[0]+lr[1]\n        lr[0] = lr[1]\n        lr[1] = lr[2]\n        S += lr[2]\n        k++\n    }\n\n    return S* BigInteger(\"4\")\n}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206214,"user_id":null,"body":"package solution\n\nimport java.math.BigInteger\n\nobject SumFct {\n    fun perimeter(n: Int): BigInteger {\n        var p = BigInteger.ZERO\n        \n        for (i in 0..n) {\n            p += f(i)\n        }\n        \n        return p * 4.toBigInteger()\n    }\n    \n    val fibs = mutableMapOf<Int, BigInteger>()\n\n    fun f(n: Int): BigInteger {\n        val fib = fibs[n]\n        return if (fib == null) {\n            val cur = if (n == 0 || n == 1) {\n                BigInteger.ONE\n            } else {\n                f(n - 1) + f(n - 2)\n            }\n\n            fibs[n] = cur\n\n            cur\n        } else {\n            fib\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206215,"user_id":null,"body":"package solution\n\nimport java.math.BigInteger\n\nobject SumFct {\n    fun perimeter(n: Int): BigInteger {\n        return ((1..n+1).fold(0.toBigInteger()) { total, num -> total.add(getFibonacci(num))}.times(4.toBigInteger()))\n    }\n\n    fun getFibonacci(n: Int): BigInteger {\n        val bigOne = 1.toBigInteger()\n        if(n==1 || n==2) return bigOne\n        val list = mutableListOf(bigOne, bigOne)\n        (2 until n).forEach {\n            list.add(list[it - 1].add(list[it - 2]))\n        }\n        return list[n-1]\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206216,"user_id":null,"body":"package solution\n\nimport java.math.BigInteger\n\nobject SumFct {\n    fun perimeter(n: Int): BigInteger {\n        var i = n\n        var sum = BigInteger.ONE\n        var a = BigInteger.ONE\n        var b = BigInteger.ONE\n        while (i > 0) {\n            a = b.also { b = a.add(b) }\n            sum = sum.add(a)\n            i--\n        }\n        return sum.multiply(BigInteger.valueOf(4))\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"559b8e46fa060b2c6a0000bf":[{"id":206217,"user_id":53,"body":"package solution\n\nimport java.math.BigInteger\n\nobject Diagonal {\n\n    fun diagonal(n: Int, p: Int): BigInteger {\n        var r = BigInteger.valueOf(1L)\n        var i = BigInteger.valueOf(1L)\n        while (i <= BigInteger.valueOf((p + 1).toLong())) {\n            r = r * (BigInteger.valueOf(n.toLong()) - i + BigInteger.valueOf(2L)) \/ i\n            i = i + BigInteger.valueOf(1L)\n        }\n        return r\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206218,"user_id":null,"body":"package solution\nimport java.math.BigInteger\n\nobject Diagonal {\n\n    fun diagonal(n: Int, p: Int): BigInteger {\n        fun IntRange.product() = fold(BigInteger.ONE) { acc, i -> acc * i.toBigInteger() }\n        return (n - p + 1..n + 1).product() \/ (1..p + 1).product()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206219,"user_id":191,"body":"package solution\n\nimport java.math.BigInteger\n\nobject Diagonal {\n\n  fun diagonal(n: Int, p: Int): BigInteger {\n    return mulRange(n - p + 1, n + 1) \/ mulRange(1, p + 1)\n  }\n  fun mulRange(from: Int, to: Int): BigInteger {\n    return (from..to).fold(BigInteger.ONE) { a, b -> a * b.toBigInteger() }\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206220,"user_id":null,"body":"package solution\nimport java.math.BigInteger\n\nobject Diagonal {\n    fun diagonal(n: Int, p: Int): BigInteger = binomial((n + 1).toBigInteger(), (p + 1).toBigInteger())\n\n    fun binomial(n: BigInteger, k: BigInteger): BigInteger = when {\n        k == (0).toBigInteger() -> (1).toBigInteger()\n        k > n \/ (2).toBigInteger() -> binomial(n, n - k)\n        else -> n * binomial(n - (1).toBigInteger(), k - (1).toBigInteger()) \/ k\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206221,"user_id":null,"body":"package solution\n\nimport java.math.BigInteger\n\nobject Diagonal {\n\n    fun diagonal(n: Int, p: Int): BigInteger = (n - p + 1..n + 1).map { it.toBigInteger() }.reduce { acc, i -> acc * i } \/ factorial(p + 1)\n    \n    private fun factorial(n: Int): BigInteger =\n        if (n in listOf(0, 1)) BigInteger.ONE else (n downTo 2).map { it.toBigInteger() }.reduce { acc, i -> acc * i }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206222,"user_id":932,"body":"package solution\n\nimport java.math.BigInteger\n\nobject Diagonal {\n\n    fun diagonal(n: Int, p: Int): BigInteger {\n        var top = BigInteger.valueOf(p+1L)\n        var bottom = BigInteger.ONE\n        return generateSequence(BigInteger.ONE){it*top\/bottom.also {top++;bottom++}}.take(n-p+1).reduce { acc, bigInteger ->  acc.add(bigInteger)}\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206223,"user_id":null,"body":"import java.math.BigInteger\nimport java.util.*\n\nobject Diagonal {\n    private val cache = mutableMapOf<Int, BigInteger>().apply {\n        this[0] = BigInteger.ONE\n        this[1] = BigInteger.ONE\n    }\n    private val cacheKeys = TreeSet<Int>().apply {\n        this.add(0)\n        this.add(1)\n    }\n\n    private fun factorial(valuesToCache: TreeSet<Int>): Map<Int, BigInteger> {\n        val factorials = mutableMapOf<Int, BigInteger>()\n\n        for (i in valuesToCache) {\n            val cachePointer = cacheKeys.floor(i) ?: 1\n            var result = cache[cachePointer]!!\n            for (j in (cachePointer + 1)..i) {\n                result *= BigInteger.valueOf(j.toLong())\n            }\n            factorials[i] = result\n            cache[i] = result\n            cacheKeys.add(i)\n        }\n\n\n        return factorials\n    }\n\n    private fun findAnswer(i: Int, results: Map<Int, BigInteger>): BigInteger {\n        if (i in cache) {\n            return cache[i]!!\n        } else if (i in results) {\n            return results[i]!!\n        }\n\n        return BigInteger.ONE\n    }\n\n    fun diagonal(n: Int, p: Int): BigInteger {\n        println(\"----------\")\n        println(\"testing $n $p\")\n        println(\"Cache size is ${cache.size}\")\n\n        val interestingNumbers = listOf(n, p, p + 1, n - p, n - (p + 1))\n        val toCache = TreeSet<Int>()\n        toCache.addAll(interestingNumbers)\n\n        val results = factorial(toCache)\n\n        val first = findAnswer(n, results) \/ (findAnswer(p, results) * findAnswer(n - p, results))\n        val second = findAnswer(n, results) \/ (findAnswer(p + 1, results) * findAnswer(n - (p + 1), results))\n\n        return first + second\n    }\n}\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206224,"user_id":null,"body":"package solution\n\nimport java.math.BigInteger\n\nobject Diagonal {\n\n    fun diagonal(line: Int, pale: Int) = pascal(line-pale, pale+1)\n    \n    private fun pascal(x: Int, y: Int): BigInteger {\n        val (i, n) = if (x > y) x to y else y to x\n        return (i+1..Int.MAX_VALUE).zip(1..n).fold(big(1)) { \n            acc, (a, b) -> acc * big(a) \/ big(b)\n        }\n    }\n    private fun big(x: Int) = x.toBigInteger()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206225,"user_id":null,"body":"package solution\n\nimport java.math.BigInteger\n\nobject Diagonal {\n\n    fun diagonal(p: Int, n: Int): BigInteger =\n        generateSequence( BigInteger.ONE to BigInteger.ONE ) { (acc, k) -> \n            acc * (n.toBigInteger() + k) \/ k to k + BigInteger.ONE \n        }\n            .take(p - n + 1)\n            .fold(BigInteger.ZERO) { acc, (a, _) -> acc + a }\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206226,"user_id":null,"body":"package solution\n\nimport java.math.BigInteger\n\nobject Diagonal {\n\n    fun diagonal(n: Int, p: Int): BigInteger {\n        var matrix = Array(p + 1) { Array<BigInteger>(n - p + 1) { 0.toBigInteger() } }\n        \n        var result = 0.toBigInteger()\n        for (i in 0..p) {\n            for (j in 0..(n - p)) {\n                matrix[i][j] = if (i == 0 || j == 0) 1.toBigInteger() else (matrix[i][j - 1] + matrix[i - 1][j])\n                if (i == p) result += matrix[i][j]\n            }\n        }\n        \n        return result\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"559ce00b70041bc7b600013d":[{"id":206227,"user_id":null,"body":"package solution\n\nimport java.math.BigInteger\n\nobject Finance {\n\n    fun finance(n: Int): BigInteger = n.toBigInteger() * (n+1).toBigInteger() * (n+2).toBigInteger() \/ 2.toBigInteger()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206228,"user_id":null,"body":"package solution\nimport java.math.BigInteger\nobject Finance {\n    fun finance(n: Int) = n.toBigInteger().let { it * it.inc() * it.inc().inc() } \/ BigInteger.TWO\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206229,"user_id":168,"body":"package solution\n\nimport java.math.BigInteger\n\nobject Finance {\n    fun finance(n: Int): BigInteger {\n        val m = n.toBigInteger()\n        return m * (m + BigInteger.ONE) * (m + BigInteger.TWO) \/ BigInteger.TWO\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206230,"user_id":null,"body":"package solution\n\nimport java.math.BigInteger\n\nobject Finance {\n    fun finance(n: Int): BigInteger = (0..n)\n        .fold(BigInteger.ZERO) { acc, i ->\n            acc + BigInteger.valueOf((3L * i + n) * (n - i + 1L) \/ 2)\n        }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206231,"user_id":null,"body":"package solution\n\nimport java.math.BigInteger\n\nobject Finance {\n\n     fun finance(n: Int): BigInteger = with(n.toBigInteger()) {\n        this * (this + BigInteger.ONE) * (this + BigInteger.TWO) \/ BigInteger.TWO\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206232,"user_id":null,"body":"package solution\n\nimport java.math.BigInteger\n\nobject Finance {\n\n     fun finance(n: Int): BigInteger = with(BigInteger.valueOf(n.toLong())) {\n        this * (this + BigInteger.ONE) * (this + BigInteger.TWO) \/ BigInteger.TWO\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206233,"user_id":null,"body":"package solution\n\nimport java.math.BigInteger.ONE\nimport java.math.BigInteger.TWO\n\nobject Finance {\n    fun finance(n: Int) = n.toBigInteger().let { it * (it + ONE) * (it + TWO) \/ TWO }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206234,"user_id":932,"body":"package solution\n\nimport java.math.BigInteger\n\nobject Finance {\n\n    fun finance(n: Int)=n.toLong().let{it*(it+1)*(it+2)\/2}.toBigInteger()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206235,"user_id":932,"body":"package solution\n\nimport java.math.BigInteger\n\nobject Finance {\n\n    fun finance(n: Int): BigInteger {\n        var d = 3L\n        return generateSequence(3L){d+=3; it+d}.take(n).sum().toBigInteger()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206236,"user_id":null,"body":"package solution\n\nimport java.math.BigInteger\n\nobject Finance {    \n    fun finance(n: Int) = BigInteger(\"$n\")*BigInteger(\"${n+1}\")*BigInteger(\"${(n+2)}\")\/BigInteger(\"2\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"55a29405bc7d2efaff00007c":[{"id":206237,"user_id":null,"body":"package solution\n\nfun going(n: Int): Double = if (n == 0) 0.0 else 1 + going(n - 1) \/ n","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206238,"user_id":null,"body":"package solution\n\nobject Suite {\n\n    fun going(n: Int): Double = if (0 == n) 0.0 ; else (1 + going(n - 1) \/ n)\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206239,"user_id":null,"body":"package solution\n\nobject Suite {\n\n    fun going(n: Int): Double {\n        if (0 == n) return 0.0 ; else return (1 + going(n - 1) \/ n)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206240,"user_id":null,"body":"package solution\nimport java.math.BigDecimal\nimport java.math.RoundingMode\n\nobject Suite {\n\n    fun going(n: Int): Double {\n        var sum:BigDecimal = BigDecimal(0)\n        var fact:BigDecimal = BigDecimal(1)\n        println(n)\n        \n        for (i in 1..n) {\n            fact = fact.times(BigDecimal(i))\n            sum = sum.plus(fact)\n        }\n        println(sum)\n        println(fact)\n        println(sum.divide(fact, 6, RoundingMode.FLOOR))\n\n        return (sum.divide(fact, 6, RoundingMode.FLOOR)).toDouble()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206241,"user_id":null,"body":"package solution\nimport java.math.BigDecimal\nimport java.math.RoundingMode\n\nobject Suite {\n\n    private val map = mutableMapOf(\n        0 to BigDecimal.ONE,\n        1 to BigDecimal.ONE,\n        1000 to BigDecimal(\"402387260077093773543702433923003985719374864210714632543799910429938512398629020592044208486969404800479988610197196058631666872994808558901323829669944590997424504087073759918823627727188732519779505950995276120874975462497043601418278094646496291056393887437886487337119181045825783647849977012476632889835955735432513185323958463075557409114262417474349347553428646576611667797396668820291207379143853719588249808126867838374559731746136085379534524221586593201928090878297308431392844403281231558611036976801357304216168747609675871348312025478589320767169132448426236131412508780208000261683151027341827977704784635868170164365024153691398281264810213092761244896359928705114964975419909342221566832572080821333186116811553615836546984046708975602900950537616475847728421889679646244945160765353408198901385442487984959953319101723355556602139450399736280750137837615307127761926849034352625200015888535147331611702103968175921510907788019393178114194545257223865541461062892187960223838971476088506276862967146674697562911234082439208160153780889893964518263243671616762179168909779911903754031274622289988005195444414282012187361745992642956581746628302955570299024324153181617210465832036786906117260158783520751516284225540265170483304226143974286933061690897968482590125458327168226458066526769958652682272807075781391858178889652208164348344825993266043367660176999612831860788386150279465955131156552036093988180612138558600301435694527224206344631797460594682573103790084024432438465657245014402821885252470935190620929023136493273497565513958720559654228749774011413346962715422845862377387538230483865688976461927383814900140767310446640259899490222221765904339901886018566526485061799702356193897017860040811889729918311021171229845901641921068884387121855646124960798722908519296819372388642614839657382291123125024186649353143970137428531926649875337218940694281434118520158014123344828015051399694290153483077644569099073152433278288269864602789864321139083506217095002597389863554277196742822248757586765752344220207573630569498825087968928162753848863396909959826280956121450994871701244516461260379029309120889086942028510640182154399457156805941872748998094254742173582401063677404595741785160829230135358081840096996372524230560855903700624271243416909004153690105933983835777939410970027753472000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"),\n        1500 to BigDecimal(\"48119977967797748601669900935813797818348080406726138081308559411630575189001095591292230585206733851868464009619343585194052091124618166270271481881393331431627962810299844149333789044689395510487167879769325303699470467829234399263326545652860748605075746366928323606645492277541120083438086727369377887676000211405318480244354207419604864176969950581435222198851194568984095705945549589054568321792338919149442985919957734792959402499096845643020401869381175603964424333222114125974374817804242633309769804293952870034619354125014210045647664063240162007560108665290568646128342557147350985358724154623253371867470765120422073867963935775258692109753041762094343569050497470353531764481503174750911858230906998361066084787758316110585736013365377431860738572261325738233656835271947352695180865573043834027955539012765489372645042504406597752357481931532872356635411224578334040522294746402829585458478708778346379431862368824819009177091444034885941394319343910223168655869761799669075059527608502465593181398566214786801211651657222004123456498258513120359126022843038535083709796101565934859483203933443308601475813108363074118562404412420191947127585482919172173045961122122701434297870691932154082986945954748251105782181586397275820342101470457300633590139512919549474113721711616912519714191760699935509810254849967087635936181176363954224186031346682928878492872249485456690138831610135377916327940503701400290125509132140782614640495733518048670983360134097860364762638658894873174499870133559364805443430831459505987809215393353387232078177562975021460595422358573128085417162336030235138652735438053034531962620811566019896879275257163988352090874930346115518331202927263708446729394381879888839549731876978682249320628599631628662375508826209854754631984276392670919216923002770077734756077549035942976209159416211581439461484509549370357486770276807687544580164314647595031368948490282897173328013518435758700056425922638411889496527975846052717958044813737086806600171993703579485864029383208714528950303253881360812631162134750100307772634337467012820470715650810714689905121432259528505483053930402217400686061612471659630192434864094539828085677465383026128353771071152304197549798870706139893609140045659756285435787771636258253666592102151236142132724425850991205720020493660580896600891888594659612927724357866265934517615841298789154462249169688860092640284756382431746120357767933119589280468687348061788072986362788582227019465263474828590646048451070702923434422714349595857654843699542321849363652767771978314681013589442955219879702008068934096624650625769705233333462826013860098698155180331145365652453482955497979915586438474687345677874451117702250441711504844638414485210092261397271970571029038581873069951161330495772310508760528249706514238384269808639507080418298318311361373628512041716415196868334254119137139589149597210032153545941114666530498906529240798164804007394775927836045668573993316428972539932745757171947402454257142633700815922407278403640595355142075599446056337986717212316223257763412164180899532722039383244462511410346646148863397237096276822656157561194665545757017429842404840309758925618650507921043007241637877939825811059339138925526124514467627126548126795078784022672860886251974581362141782786407402896309678008909663263987018538107050886193489012497405005820727271232733728141775132722013860591169620692789290456794698409808557447756701311883266010859016027592252397754508251628808293537776536569608111330584797160694847898923196743970244451842702266403326317319092117151143971679500042590269255093130215984418097418435474300467281949798227102529873732749027992079700287275900856241172902880909546551703263202853584498085358955307673717177961902081098618729046348849060249600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"),\n        2000 to BigDecimal(\"331627509245063324117539338057632403828111720810578039457193543706038077905600822400273230859732592255402352941225834109258084817415293796131386633526343688905634058556163940605117252571870647856393544045405243957467037674108722970434684158343752431580877533645127487995436859247408032408946561507233250652797655757179671536718689359056112815871601717232657156110004214012420433842573712700175883547796899921283528996665853405579854903657366350133386550401172012152635488038268152152246920995206031564418565480675946497051552288205234899995726450814065536678969532101467622671332026831552205194494461618239275204026529722631502574752048296064750927394165856283531779574482876314596450373991327334177263608852490093506621610144459709412707821313732563831572302019949914958316470942774473870327985549674298608839376326824152478834387469595829257740574539837501585815468136294217949972399813599481016556563876034227312912250384709872909626622461971076605931550201895135583165357871492290916779049702247094611937607785165110684432255905648736266530377384650390788049524600712549402614566072254136302754913671583406097831074945282217490781347709693241556111339828051358600690594619965257310741177081519922564516778571458056602185654760952377463016679422488444485798349801548032620829890965857381751888619376692828279888453584639896594213952984465291092009103710046149449915828588050761867924946385180879874512891408019340074625920057098729578599643650655895612410231018690556060308783629110505601245908998383410799367902052076858669183477906558544700148692656924631933337612428097420067172846361939249698628468719993450393889367270487127172734561700354867477509102955523953547941107421913301356819541091941462766417542161587625262858089801222443890248677182054959415751991701271767571787495861619665931878855141835782092601482071777331735396034304969082070589958701381980813035590160762908388574561288217698136182483576739218303118414719133986892842344000779246691209766731651433494437473235636572048844478331854941693030124531676232745367879322847473824485092283139952509732505979127031047683601481191102229253372697693823670057565612400290576043852852902937606479533458179666123839605262549107186663869354766108455046198102084050635827676526589492393249519685954171672419329530683673495544004586359838161043059449826627530605423580755894108278880427825951089880635410567917950974017780688782869810219010900148352061688883720250310665922068601483649830532782088263536558043605686781284169217133047141176312175895777122637584753123517230990549829210134687304205898014418063875382664169897704237759406280877253702265426530580862379301422675821187143502918637636340300173251818262076039747369595202642632364145446851113427202150458383851010136941313034856221916631623892632765815355011276307825059969158824533457435437863683173730673296589355199694458236873508830278657700879749889992343555566240682834763784685183844973648873952475103224222110561201295829657191368108693825475764118886879346725191246192151144738836269591643672490071653428228152661247800463922544945170363723627940757784542091048305461656190622174286981602973324046520201992813854882681951007282869701070737500927666487502174775372742351508748246720274170031581122805896178122160747437947510950620938556674581252518376682157712807861499255876132352950422346387878954850885764466136290394127665978044202092281337987115900896264878942413210454925003566670632909441579372986743421470507213588932019580723064781498429522595589012754823971773325722910325760929790733299545056388362640474650245080809469116072632087494143973000704111418595530278827357654819182002449697761111346318195282761590964189790958117338627206088910432945244978535147014112442143055486089639578378347325323595763291438925288393986256273242862775563140463830389168421633113445636309571965978466338551492316196335675355138403425804162919837822266909521770153175338730284610841886554138329171951332117895728541662084823682817932512931237521541926970269703299477643823386483008871530373405666383868294088487730721762268849023084934661194260180272613802108005078215741006054848201347859578102770707780655512772540501674332396066253216415004808772403047611929032210154385353138685538486425570790795341176519571188683739880683895792743749683498142923292196309777090143936843655333359307820181312993455024206044563340578606962471961505603394899523321800434359967256623927196435402872055475012079854331970674797313126813523653744085662263206768837585132782896252333284341812977624697079543436003492343159239674763638912115285406657783646213911247447051255226342701239527018127045491648045932248108858674600952306793175967755581011679940005249806303763141344412269037034987355799916009259248075052485541568266281760815446308305406677412630124441864204108373119093130001154470560277773724378067188899770851056727276781247198832857695844217588895160467868204810010047816462358220838532488134270834079868486632162720208823308727819085378845469131556021728873121907393965209260229101477527080930865364979858554010577450279289814603688431821508637246216967872282169347370599286277112447690920902988320166830170273420259765671709863311216349502171264426827119650264054228231759630874475301847194095524263411498469508073390080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"),\n        2500 to BigDecimal(\"16288884241692635468966810574743966336539994283436659333376117059851739595300666601568118117109111430182218994996706377540737964295726648036084914477398269956576650394995303908153606931358938562424868716863336511787772831963234651490597845804707452080712773761945183179002366243765637991536689969242581709947395573553799155162061020587956162836453609056109182552093352343844029882417375246821954281460020336896525591606956233891343329496954631026393022945474865068966259267963805071707264234749398946807274223651874046023994635224545104061309775665397330572064502645799793490535692439961861758186037617483580487420516854225746700866725272078424896992597788322485750313103767538280635190313055438652113070059895360069459016503698021402127430434703720577454603684221486207712971570279183098247144580669751192292412687570776382442783145813125272512987140013465430577373695416037438604330731495427723748498601316777072913720020200624759285687594697103942902831458433117148104802139150255844954156372702572242931979348640772104241935322544694355717741028042721831057393383946811950229862119018492668601533950515675995793861869111189410513752442848879659001774939446410165714053104744903131715021128531205114521790600044832229285647606408017904177251780563861670452217895698401839016268343830469429772772782341220769473426587820287290019473077524695825215527904355576391305600088839325393721013677844373796989572057534519771031549187963257721208029673279152430652933276800258223453219383978743812269682334913717476068767081112170724712287720561807845229060596372853438939340670348358259624827210411996569765719571305348561907445521649287971976375847487178355765492815778069121838364685540983459992106337314470299659462768807774194455026719275830902631301620632068053005745274643641270818310893189040468508343150208376066332465734970601526332798266648668957684928388346914251393674102236838190309415765024962992701286434254040733064624752399588405701518471706282680092033896216655874206291783633993514147758055661610275976159918807613941637566649034779587069377199455553747637235892554444579113470055333978002998933446236448649956338643549877097069790252117694271543914179639916424071991406456604783333397965866797905100968905477558448660543042454554471492045598502849277515838640500208365860739763710206685971849678108935761798782539066278141381636294637082189768125799193702797967538238466562473387279176788278704807481230413644276139720229104456308083258037763826781395687638241302508020291782679358425712165041212352088250542961656610307562083717426864028254048045585013278396707312988098509307199244525251413018638107871271406375801619527964709310126699327425652342396160313371140810226949214136412603864243886523013717112551532688276164952934427157810894957954046837445796764595217297020162001470343757782370085850953552320637100882919579912163108370028314403969241003234290634568270458955949171264334907057977769908075381921113966351587586648467738374135641552139894953507856890412402614641785184184650269635082032520382461666556052083240749659841927331974627710176727263009232886075400144727578901134034342119214962884370001625512726452523206152157166541752489388503280463130706903614053713733296237361667312991010932983656540560377330832262770042696095731040694487906848645462190989961711109989113241974798068964703059871195609328565827196434230198178800412242371942746686047154961984072073558094313894903724884222066777831669419732898160360633747237482986968369023008889690448245258289105706876230750084254201797244121746320131347525589214486094781766265733538907918016852228868499907315181338394080723321126032440189828823699970328255861187143922082019147768883662612191302509135461511051477630808296519282900741066316050077242544314881058045728870693282326830433019004661600521723836651817381529898440636383917095475899004094206317468376377314153856018840069377218558903334939371343395777264426365318130887683599836088345497158322556553595094840894654614406383376396868199531042942079405403474627428650274595771829568255995466465003325664472293654101201924430539079190443194487046380416281749159026300696294947812447714612418298771332692848211154125929312681287195951419960699391722211424311898584816200565373258799897110855302098610980845978364362685231061369005215230788471798866541648729889538439509890111560301062943923923769988997147648363950708508382034563798637202146673551309938897540440786998003118907883241416258343188784000679367284896011745823289734561911522255979545433492376668285434347783001266108600121473498779217963921384546755156766188951735866744108093964636023471349527019498920540070752394649104708510770999131507315610483632330982876174119389012968417760250231722884408641474340374893362833795392300949100935853949419952854923937872507275773843355108735204114864752466565493366395162830913421138498633186453324268762572668445390770903011717202242312950408723851830364004678106656009078222984968635868416766693788940980240045058068275614302839043567118028698385054274108921811298084233976240006277809181325997330000786683674194376654268377368369949823431206244095885960702059149846318232687179678572748082487793549844548187548311400556064744050666472476457947299489568330636742840865513804654776149494225932236964194164784786218640251626514525549920894810545056499250214652147224638246034892251401029945773476251196919612592752826016419187902895630887737745713281219681141023586882321633118519558748181198803719862314967759867112077291645583600510531017148754676649505951293767894337326791942862414631993126449392270145239108425380056269282654566300820253116701666036949374826952156733286262700190206665725355635411559887439781283350874285109852181238143636938256407098028863909426094536431398247852543854757537942646791855344906017659039384905122375234004320416026882823286655632286053156546748028668750196973803337027786891236116711910780819707846081218679760982625290715984522150204916425232591826590887410401320568045430558979943145617193692059705465421939829497586908594951642657711985208269462425640322372314303330475772671495014049400654155619566942191085558759378416790160458835621823599743742665152596726797511419955382867531134959437002011587472231152746047820309830039699792147174883667855760287780241438038062954704157981072533480950728570115662921849376586317866043009133972729549191452640224225320222817060812601144385749818368781373067888827129923654130858902252804622762751192618314790547633755929057344102888830740499275949997990026813425216747458578654838647236496508876074530642629714199563056483975900965902520059913821418901761372054615449749487163282905699188377895083782877246773269374715942460000414707728522199826307191493572953655749106244370767768017669677808468909623091993519298870943235516530358122980923396832082235382703392292864000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"),\n        3000 to BigDecimal(\"41493596034378540855568670930866121709511191949318099176894676576975585651235319500860007652178003420075184635383617118495750871114045907794553402161068339611621037904199177522062663390179682805164719697495968842457728766097103003726111095340241127118833157738815328438929737613021106312930374401485378725446079610290429491049793888120762511625132917004641668962117590203575175488980653577868915285093782469994674699190832093511068363824287063522268544339213775150488588104036818809099292912497141900508938994404715351473154531587441509960174267875087460367974117072368747277143988920683691618503608198459718093784453523958505377611086511162363145920886108557450874513945305436213711898150847192094426374203275029996333784944014775671414680824207499914714878359669720638954670589960178569480263388767112871068004950827400717124819476386401369193544354120312786601434792549959143530120653103406625503231020738351502195103148673612338739395096551462159349015789949944072311004426924838140141455487872738045856023561583204317945953055830693351246890721246151468485308724031267967089113548982733475375756899365176396424781733462510879015743437398920492267098317033932107176343983352444576040476565400414414699479984354554597799386702839428513413188913165695310848513525094006147774047007331406541794428004436691903685469270857271701648011512057452448607968773784803660653009109815639091294110633715621540903800135058671624262333902434166628716521228590274568833504897926869369792878376894841436573866436955075473964882256222183380014600761196859217603234808467455216330411738004331144225926243690558782914907973885758784585739828695390302383837265882427654306437517757897215045071361801730051628424476294227485755627828763498767195281368913583918824499284741591683130334032199946752082914885764345863832313545205075955912062067273296951386122994658607527317884452449865348164169238844889061495850934373442889814884427321817131272533891534506581143823381205875379808605080889761753882896252933633750454549168600267229591225528854584482686655324313011353754812409561237686078007700707939541848907149467377854407528307872988103912945121929864793703451257436445581459757140822705986325165352906584571123585270211933452981105568398809884094980346185078025273038736784042169427237980464304250045030806637032760016341921442805708802430850567892108646977455139539119838636167190300278146380136932482332771595180596193069504237836082620570887209297929797429404576877338319877444685544294800321741056689423710545028870419611915072739000031642014474213323293871618029555614004602867400422885389854650328028428515122296028795741801621823236098320971441047012533067314896153236788734984553949604397050352347766211395914519270422122231426998692087463520980686224354813376194395131942868113486531562228173214976481705381846155326596187530296478601160872263640443922257601926494610916885151013143945574398303192557154162151442469122370519149097861849436150963109933639594561796593396851958605338631176324147066842257192394742531726479559749993283247279807896470753054014194090200609712674753186365525403212757757853930697530056595208207457499471898144453772248207888443335118545601568853708182892895218300139654376947286418776665762815389737340159410543681435437346134244692067070082782423645557450882556670157242752810317141640631410681384330924027281318960884813040665226169552825637183862464944295688859393846726723694199475571320546018263425731029115353532728808182773021596787088437293412117084511580629967697266601663635276959969021502122104954259567278593185516268447100374434620422003535391203738393095420695021486207390653190910821344334251497896284236198571674773848126097443055036250866354720730971298084697196537722779893160200560725058007512407494448163392214398118492748281978655178478547749198714138485042290383954090570842038137277135667703565041081780520695032136233521692740531015340921761834078817735674646749071616600653230438902639786065509005309872435445689315601329942407112295015453771521051942445512795364971214872222193729289159833001742397977592530501318837883494884232222507318816399438935627817102875432588794558857742780390717166381257903798149148445526885871629931014510733215554773264576035916184298708323237568837917135073006026738292294687081030751946020376438138677107333779312582257356435534577162804030480925785909747233413932904072239860005448269296110393640127539539899397420021925268928622564959279136369546983247314494094297494213208716963662812963846191378114609210701033012119934264941666449130310898493535366401831282683112506578386425906537197010907276429330534751297336716929415047870949241778121534979499449732358445130210029720359993576507730563696950539990891252004810120090569633144368179194247963563389102486250773367249399801723451627048850149438343735826440053481474957421328873648479589553843836378275601433377798816126854462406494134416119108952653326761627660221130879211665924379496534838030236064294981985541014311566601739518539426008673198564586684635442730180022292607589767192198367529528365158715521887698317999005853121518691037776676883654291247419826099434535671529412823837612115555686210454583810355154404953718470726363218532775486501811002621331228429860926112159573066023932077476742800909462674322138805290643067711276964013735906251051050623568241317651533030775358975134565147424167401517470720839101869989993279364910892687924739705814152855543965954222603919059265825637344676406359525838966981511983959886603683753042017990328185945569412550519066302854869533377682984600031808093822130038102214387057461181304251961916405970456035183121708151658647356556540532928411748628957082856792300053525846377061280591452035546389932127875906349627837975871352588618213252263577038396202737385324908353680497990085701522483303439525197344653342994652565236096742834550523739733902374261808871799283722285366293439240895762913154442106573609205481842139365893867715542842477275100166734357743093638948444564764377184073874379471007867151070449554657626281566137550730763768080600031844296233977808233311359787577136983012817571625671683287281511937336685789437109097748581222868126824122317272681184975207863453107495331708260153159440253645365524453587952034745213429248916644504804355352281977721981971869054884176896398782704782066126921472548618247859626434279190274503452994769367997217285165465591799471789067885687278574470084289723778234763080740919512966238346427839653865017324665850192144091694630371265581197700774682562035198318782913591013997817303635173764706714383992810291224460848320518983248348855131025539721583184931653670732273172995431750775475634748127320956655431851879586978172491721700865768098908327830838240437737974455342525688712898855513180967012497859454290609627370590659970784172738420721605576789060565167694565490120388165775861939230924362983389549857279874523398090499858467484850399509109398834210424693113617875978611803096108774362764990414655167545507613665725914993376114340243762910290384135888531312591132544849225896007184851169390193985434649415483782338302531368775990005443722332901462568184095998830522521585328599833990336595418932696680163265899358234663247080324020429791357425755498549372896192091650794671997121439832581553945835125648010889886887056882711222628734035772418424803231173027338442220604015609242079569493204943809402465562530303328824165302038006041288444384884189129393985971765670211501611340121169355535864984802941563238279447576315042685734269863116562800932164578165410411899078396210758605145091526528422433647230880469088426412525126584729134059195171754291152622002229756986927959124620964363057052133099216422258437651889193630329851223282950806126200573565554213183555838289318138795940962303792777230344423432341561603558590502324475274502630869831414125396371754413611897269158650716722308083435295578401087236027347001118786146233185439431057058483770474806035004556885020602730222256397630738939985024978155182679916994164145540329909813190506654358156657691529068908186204138444091456355291242064901717436430473455191375922914953282988151808740076733486997695322871450791584448703980405737673555777873593937891577147956023340708456392314170118392555234618119775915673385955919265270624063734277760215846511035368057963320714896942663358570375305829676608224208465464558556667889222627619990263961792637457851652540918756608543859661221944248720424960000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"),\n        3500 to BigDecimal(\"239112819947764952509538749369364118451622972442875157035098986958774008856938009164464384478087712763885136836324995903067260002966232380317923569014472047378242172895901675784339742665174285098178725230385718873410201580175259254117313278842360350645709184329876569408534087247157506175662227323032268401542634192517467854833759108286982282738674218006164534722080501888701306745271156615964901119690613549677412733854731650212240291530230868963052062537322543685590156805381172101989286235672093708387076881037922024043169353754750563162564975919989156705752216537686413419886478328334225582677352517348762592223626234283533217638697510259891122288945333347625323222545748957592906614966809241762633225036129330067544428409130614279779458358460214091774376376215664910913970794811067270469967652614715681435650602502715659854784674080607387496034995432762102943225689288141047507603560274620671279571257838281286074602402041906666905816159021670503189274297808949147439617623366014081501493069928133829576787648903343040313232509102393480437849932578077767394100942315149628506552818743799625921142442362124547351414037615751471779736652223205335831101884838953461270406714479761343761829529415717067354982572153162056499332351496534919395456260862489220556391929537799748491137530902993971775367411959193353227311189697831964494769449670843907802573074824576081608675610481199282588487578559350540322964494404663070030692506188394549711904786110423992497711514194050568062254272683271646051852760242449079468426394832996212462317681562066382741991498626000186383919188586337690398358410097963645981845943904103085919424048994299893759272204944265425380208712118274687037863260425970808290349225602109349765322421587524344647276075819395262408247291619934400106749753204496533297982671006474886512509058393619675963813144770600333760258554927858026930214303998018311920138214403116873328516243009101282709378168128763134083498933248135008292020697142570120258463496139530911858597902005998388293598713907256245120494647249791194767950002069083717337203517611497367689838123580646742589214688623262086657195314694956264173960913196126575347297111534900392235253780359357395723416960087636892732601653435913589655681661131257542314802563320521926124631016660016670631805765230339783113346303061079421623485933949807597550717247283576354029169036445706661368363978891454093788861754877388285643999732690060073196923109774931897808506499739385218018130806086283707110373583923268832731842268387335657365983645758435193716613244708086319632331473439676389227246578621374920516638197276025186070290431547819378598206457381179918513602591753028571750812768661896258573878097533672909600504432905074504032787488476557745376205129311939566789495198515711967195965721096688722139223926262409157372945179391353801960869570473677279519248841966226107640765908289366757236930976816072169158914763313566025841439565275729568744308666068375364765026134557828994497475487073211245024320481189431901731952348993832023514078306594181237727326990681611787230334691773071082140130418864837407377482563748282701077068205455700742475673832247794060566473980574649932006300025913942848833255103806007258792664680321881824191292633223678721231203118509851044596098638994797499302637918284164533948517228669747178634804889803109452954402052504573099499450594295021921851474143098056182292492186027479704038452934649022459654314187653648534037397057687539703736792929786026713004505455090826922102864709390496711135355275763314468477762036156570779430502809114971166283166255476621707864979422497249592131377432891895184448581009546747527950992175979426863678480859427997624165454786036803881005859975960277235579547141674946691830545088826388583836581872893897178520784449451078496915707078562404155115356983243195289440474255734778268119173598515000453185167432649333662482010693585626949277301531045900057832659747360275395242399709845863488654118410177090473076884067477736030314775766242957455648726982066931404236966658061155534267293938052911367782062568795537771863706492864505774181666322768230930961097985043810236164862377493892870646480514311677190684582292569250882061405998697046298000581983089005403054965821821385890687800935039700099546719680766311967999076080734122049585837136778883359098710006874497288881165627579070612668123851619081732181725010529826662967133514067477484529702396859645143368651607811562489666874253608678366967264911457794131284921911551763270278708988387548759746722977891035149869862035944819604583319338590689304235550687135651707022925589407940921933185390320443890394536873365575441692374169030955598075134280924752047390130262218792865986787433083401814583070256474678595820081914893331856395013243738823578192724708657445960670497716010215037867202061822674568038069191783281832585996655909283453376893974941042094895097040443731594886504491321773447937548353360505545870347413798645587842403533283813838758293873496939938506342333359442707060523850938838591167838173742952354493440200853859066212775790231618017677041726159286010069658828513168371507342606764055746142044305135464202439709383361933001507404889278715443907623248244509418443340817122102107981732361049513848676566490157086383252387160938588261038378478828840374238880572729551113932577276961630834307967225615135756556390610802382912153121417461537118055054887172729663483974968524303134137250161429034724238278396845038249260064087461828722458568657299051099223293057334579816844913362114526542406750021892536789804227088391918860978222924490951830816005142499668447857708948298972331937318637153136352444636173106834845289576366063787304845101537799272392752034325809053594561587270696051999743295994590717478067064983317097621660815078290181480733944366653976513505868490837972584249407882115897891032432068054692530111488955315215275085148949905198812788662139227371796961991483170175388735117715618516516593082187999202159143295486648415318087381391583836210096193483644264972073802642449081973652790693801947084344690780924113641598941451936652492127257559144771554768141186831078111439244485256519914284445264205876593654848535877189454847042813276300911126860576513560141273643421785888925457990612652603340535483225737622405051125849477407411669735297753193234545729091860567086786573744501469111572460286652771415569729547182244698334244680621601325319015774932955080192162342783261337547043763222386012423255929330002137878207743365773788497465602211049785647588187072893005114368314557412457581438313007198107312577863541986784191904847014177558473614040979356249382088650968011260969484062430984185406079913654106954786486412867524544745825222092074204134702024444032866061095992975132709358433915215362320953972188872867638494520460784810121452867240925972173518257439937565179924583802470965203464080575142650947642992612026722166097533056008189803689908958725332734834949578348014572692216087294545355013823504665835997023240378542904381284663215794517638887512146471714418322132956577924288068510892828947721784203657223044574435844363631224348012250861616962318911812209553763853105735751158674398631000596766494614395245783222031994594903050745264680628057839687568335834964651563589305430599930024273975991109045649313681951457642384765347598549528359585108465731253886984911996779346168555080322487380869841327077568130942189186096653965119739682220260919397021772933680534621590867892581862293947274033699254426726016983326738074894903751976841555543955621749052943826845405816809655066296421295324864005885785102507411288024309931988192543949927105750528041343502737444453344038480706393359934495583606512903096051016162543738370786063460371810870458399102944630495841885162340149567983496716280826231245820184451950739546486040315931326413177155500613547542269518133900522587011425248523753599160310346403297448415202911239264514127369885032064435358490552604131192280381266599400775205048987596735950640955949522827376905212190873343108955722824782447712471476206129623616506128613655178259512005264049982130507116388008515708002278328960714944502002209161979661169777683126894254084278943515351833703556802751734763597735291238769029423307217591367864139407804883670738800625946816224609689541061964850167226897841665070631907924103102327396350567375344473787582913761907032712681990734309900867029549146831521163018468989791734036986814383491965091958373925172255662369340544492696345728658620270144799019929898678283126323745466585593771818799428070720794962529625393795364657285135684437111767987824444419767516696440398019369298752547174259492574996309292866494457430887578487182429571713948062012392905869431463228382728234020866001073087095762022663471955257652369817260978025865832168204394978803402554407414627938131400775152143768058466926711862554768917309824529795156397295222164680108509496575487865267040279561402398434989111245192418257990568086961040312396811565522117274738833096519125628811603991951580909567892726846611577832251083953169305626391968953797662117003527085268492298923224247090505794634225735782125010060004759361701969808941052020910063750957322352346266224855109528881318604425497001838028990705643748524174743691957923083307213944296648779770539257040815901162240100346827183770783359638326019399106134966874599867622151096267032757723926413308185422394911811043779840486872209104367379031203030321054677803884187910391508936241709822987998617378297239468413765389026144578371290348988714599174519290316962009438142723410341463628037440919326599366367231207733887839672123615209776892370198090982268105003853464407403440494204842308798794162940200284020763082844627633978050913393894146367028891547616668181804046257539368265664879306194483382959573234065999186658534147928455916308274167062444343962827927880294656633774443074417132708409516099044268472924020893366995879046482365429451146576976101697910754243036621294576276401246100755970789339675400189104501832268530841627265547194576942332350970773857849151214242828151723811319489908306031897776844963840000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"),\n        4000 to BigDecimal(\"18288019515140650133147431755739190442173777107304392197064526954208959797973177364850370286870484107336443041569285571754672461861543557333942615617956996716745284831597317498818760937482804980419576512948720610558928129788097800620593429537705326740624453884285091743951756746144447362378722469436194575929579900114212973360658998073977714697261205048663725936337490404066097966637170254021348800944280342285355946649681316260163459743803577175903394733170076841764779082166891184529324230033414145497801832598218518406552257097392530024582738982919104406782168708871495603501905867399966298798534877747923179195791416504408054878974770308650707120878837624986576073340449414854578367383301715706358194127400849855604080473305196833482408079420964275187538889115296655522397723924887154624810659788321005620558369604778657904771918388054319251513981954296741688447246185021250402225010116433016818588036690180177691461779713104301640395708274734701186772756966064611023656528765138735704190876200697145804692125236821066805337175220605745377557452592208653939853278523841448314026548802309860391087939783218946129582647928430739985554883806198749831633640196211202756086016039171607744078776876219661603702759454887945247605749205543464095883664514960293873244842409803801480566600124415293789831496309554117113888561569494314926134470477513516416560102984058751906208865570183683850791317395702861350821464653600469443279077733978568711404244774089509216727922510660941411716412467443445414001188915966547283773988670739792818897314762082568914041952211779194055311405259158538932388745292324386826830135904886472292289993848482289254307628467614523292519222687689180219788377184005246290896703260524910362136627321135976515358528150143796798116836263053229733971612275184896139539613129329008449214723196703789119820971205922195513915546814704778682373487718946560822811623038853887054357316290622378472322045316639418491798517077275839637525427601452961835674484434498885698840692468550825765131610925966585339561854456154229048295742274725126218799745448031391826295221114381890600683208441558088271228618006589059444108806652992787854634497487158675770983422610936590600627170500972481399444145398522756870626097250230229195799277299921844954715690883242553569256657132515663544931830393317518828986443942138971609142621397646808351809694603734872977984148002699965137870448199866167162949256435040416146886823942144459105175033488395869910405207521329016842673168563837531518918339627724066152933627236730561155418227888673513937454508103826102827706121560330906016404162420051373313654570111102003319577878502216919170112074608722852376799943191590480651623958062982829452035227119036502426583752512199824089725611711059153935434418985109241404135069047109527514730648502064630431371185922523036941621026392783813435540195800531988645430344745298845640017082732623248838473771603478336326662579219137601422632057648758807935233915527562817942378675243919886800056209434731407685691942327092464101136254795499159351103542747723434544436366313104996373661654989465498180892716462805042227038222104784062626027480151567377841821316292095295686368619300417863327530764301323081902435971165925163513225511176258919471673437553320934916910573999020966087207663133871516530391787535755420348174519954013015999193335205032571176460105005716115305748669364682675265014310223271762807620242805617435594927890676408953057384890719681225840400396698155624793888816156585043604782961704971397764959404751358445856914581957186533573207690355894150776647727994156425641953755517727965486096675384222232344185537279888780570854092084221993660761154788359777439798490851148031275123759286793224660188593768897291749180357297185650430735063126035278321749629995702200115722386600046772883018963166273463715186812543356173550341233310175600817771447170656517505385258772069067139665478506263898380526394388218036388768999161538645432932116471146392562992204259450889291928261780531925618148311151259088519869787637913607866079920830781433275298468534248595471485354420794089854693167644320115900404444471266030942746376074187982809857292874382829734306879420308783010740784767155894363033186129183748698373599293267795620690003900348542140553208244771165593739117369452474295075445169488356550100854423929030967163401348223503674045821834526710830392520955478859202303175309815706259592416130388770535449570146586161954289529234209342432075461261173246383180702862172009624828852517861214008242944903162464816939278645210656431141653019224783906038062818006434258491952705341708781231767324026544165240012431457995565227331912056216396141277926932316783631899833106810492890045890947294731794016389385348294079360921757589715698098491612254898203787546124091057862387229987442131738499764391062422228395736099751277880661280909246369674792326056952220508861243875642482808175793303703933394191224832165950388337931626643339913192088808753619030386928808349931733881036690498513779587801764477865791351420222949860738228995728065763459283625096944678593378349990211317403358327367677358882377095918185840441346045760435580063918587956888086127034558064154832456098224664532422114583653763989534559801683261113731162039500068729224661509382267286483841867542303955164213391663536072749966590737898408144092699675796793165775891429992491955485860639629542416955757565163223827874193321274119938618709482020627749094917473754346320653165690129809741806883246764053966717253521140010801409998318494470531219051920354752556183478378238398583402765337923843167749738355049636714529840534145950376598809459294819192486096200503652538835417613002983933634477053826438814791235363934440952835213240806543802505241445900981152753843778634021300832293332432473400040109754281828950625464331409151961292319287863535740382445771128522343533054993071872524564127962306298218521662304206610010638488461150361786151832595182055013210238035059473479841417644445066550217093994746959565730463201996845756999575031950401331385688683576883429289274419202816101239071817771853612534620088858074904095239406471009098851796038360101243053736361346640211872570375441319261567131238168652234864182359667285536913841122976956009892970909409178865928472056691904571596961458646895132972589012090613887584436018692038947475932753085268106507554394567201654757930957224629573401948677157237825005540282635839895509019254240256916422227590032685003087320017232658420681209681389364174854034319152111706246564733896551636271748411627920466475472421243033805492052542237647091252577811952376244836844025673570936216945539206875730684120187779664758451508678786539887154966732995692212544207529457534936853900663520665102592278581210192104846016594846265525000394264201946315492667174670489454576610993722063668720936949698308641684437046485292906040368218708947194882991333823400676584552108673913669306118549159369734833071319506680872661886898225398171896329288732499509337836463164384614967690283284184136334006184670970038275153458133098776493171693249836721707632973537518273692928527497068121779606865163943692606596848941143683627629169873171114739189794632775706536177409526869936538136348369630762610163490694986911903178859927739423796596582439105912599204583810744740479342404550513976713360591833475711496976836332005885151231030818986389033126325119226309584818058301429763149472903925739659774337307109687940297813700796873400566095281249251559137923743113469044584820584542770746490047535898370961450995287930441328833542933636539386097851378739174078158132593877463567524868470795313740375647059352650583871001646082364842709333314532933141725314262510333047099681128329792983694287727106008519184538377065089964546579000542260452715147077137452076302879112802094308224402060706282308208678850263037733351444756065285721900833083634023860920356321356382318484421995141074387149942542550133039926139155010190614633196727199469768170121209097613598302048321148497175007150184555423280152476407230065108963493864309805262458731715886593175689747530567359088332598961192319881186961400055356294945140450806114214490420494488195417136403967132286869444062615622815233336396279517485469862880809956041938378161336156979526713793454354319018535526139196959277008828634440008764782171726908279132449346924807112458895951881542382952497102061566169481361027449429416228859029591798532192088531772405831332410104172391828682208239266557146168642210154401086974397003647170356217905465594944933170065175291981240572835024374361017977695084363373226470846255498368067535698751768103817520605779489720985090002595078926475029239124403277040719184010486962844211160986922952144938430963756963408787147933184107904312838985994963982784496688190643908936394858404598837762653245968848299901455260080572627872653099337092686312650606546084656202210845053932679131706841390889951865628810708670194485207654079244417321332232196041180225814997707988397637369268804955010409293139079608620689856756139863786355461818276369292665568749282154818479663283704713663666842236273009790537968973379093662517795316051746410279831975339791651704861188979834156418998505732384020730350075052669695594594753081616632885311572351609352631187129393729557398993321794518158269658073683417584260274184235030846683698193879109933863561435059993549597333514217973995915742796206889856584584493875193805504685107321011420502217815128118404137521250590361329385146997427292035829509205811367395885622247504950811752188165627552137681095618860955664505372763469788466067973748736658759105548049054658237200096293754479296344115915560231138432518248450383276234795400180535655551222536669390799317067896797756236783441752907948891802488298281245615590113512482344591092230909649423933991714557108941323849548468680509335203770970493785006636718394242326057416155509029270066096293813080877339787718442773014833232754755736783313789547145535129557193581885962158684756484475219230828423777756012721234731368785218564362953263092286535139160440838713013861328416662947756104857391740722209360021068158824717926850831589591367302143596625426553706038593255843919505223140871543995210720444637571268651195165483531243799087083070940544241515809139594158704843980567202482856647644447362604252961907705738740354460336586792214638225365973993001974668174157206242597452556046629209551599663117912609702944345176608757619561247872050409609062772362769045711709729061066411540898769707847042980034982033351136308779676287974627667703893888026848748953201438481632037717854462054861859986684636917120883602793194058658599425778515519713798214407689849211487929150179918547200558584524139792439377469676039518101451697712860634235352474290575260172151562129240720796835619967878383018961055921622371480562682714603085506932806187937976625431071742833007749235636990700120567425836156233607547500827789537909071263596294926763891075439575973972560478399510790078797663071024149826759934524980569432847819403219226207098701759952415628476519584752248050578584198211799092030838909208236225141975964892778944163008811179723219354847713753084628828883321692575327835658786892010648865205021985527642612795652759365359359048052205587306960853879351302215329380382709288672566169552660197788055450054177652374955319992805345989662399494012874012278677451052584166987084866267245492968785684175508510910492913793478551456991152291522750377308973310200505007906906671435839262115546753934391579860133029544403932422271218975046896384482252108820546415274174791693426071019927278518520520164621127271231748277979659289204850823018535192067323372368224831050642902153626845618478009622824733150764188329304815843651352730897836727021023023627320228373645802602496000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"),\n        4500 to BigDecimal(\"2274299510944531831673827429887867169457573989371188898409327359043646455610554308589444028901793540024792848393960460612213526933898812914206950638053750060045958617476424754010486351287327680595149071810753320468210905110867737174549457461848908084263617541826493259470768436790727702798805056536199600247320481343744292497343670756148054722553869140082181327046742763848643253456766277583093920320467041668315866696228267539156647573708545033072741900605290283748781328712250018084127474732158483853861778603738516183992489496617170040681968081865896414810588607176123324442503093676908669853501870344297506625924516452092608273091741737389882273962527170849519870972852993358609355365379896343422454762667706495008227440837476838574049766557882921481790180038583676073327631718859982137967000189022328251695863452898563595663112363568647973981895639781001605146341767026749951026165070155464944484516241677907998933511838989298342643177372692133156180493384937306844119730124386398888271128826185524752677068133673340945510387613153305530512058330709166656615740313463893280299809927668830934935385848048005488807287800928965785867828259322147707767091382869288679875233871098409019163451840341187201285251623228548624120114157099987958281693246698436253793997756925379048692931273886232016350662306679814488575363220913890490625747092079251099031445178802926418025008216618460814336026414178330644412706318789293975023132240739291930167007608522859768212645331708274753653921773604289490465156967717836979508713877194559779081189667256847810653998092965272883599218275969549974796651532823384397952937795239593118652002283457232994133799929880616861247303890420547035275131351051269656143372198762408916975387948299167058672449589035449173326822398280410769998660040801216218139192688872235690401472486503129380613713371541945754497866971935163087946349016580380932925095435241210243917659010374704450512545382232010154120402008598777359346288004841231819529158311537425165878601027751683487514339947673454626432414548663566542482248783522427519934865994212328776192413201499719655418859065386976844984272578350453862815657740123372561608818796255174934353122027816082036741908790638800114848216124922843056249055881228834547961545710501635511221532237111510488516152530448621232649423782757360035566694205256153242056391540865085384102622135604487756683601198403184455679685648245125421208081484901726447990357065828675338585772017530114775166183608558227838570419277247707761221084033839954617820905838211829967511483469682517322540242724365249738957099130196561749191903773688742707143146942220415588634234262197339375900193723363421562574300177747960658764271622607401950934265934623850610226076402678876651779820381203677621480698139452180807715541904091781074579834474314272943586317697751756066944943927385124427911983185423561354865076733333824766285887697488324707796504419816018976878350839382064101042954386061574760049029519392687371468302191261595600452005226311441631406560434837283791887251521679335828949999568286593651194785295272398189611074530257638801975726162895469400795713099740113565979414317252623082260958016154683526548172017505671331748401738011420754066228961448074877945130102276729592613200051484177837448505902327322713175070083133260801783910114874878977495341412564449638878558699773376380892345007892054403636781086945215319016625734579044932192204231084529228231882697088576352131626284819424249882761809667211831362006421484728787801838201277240192081709510246941360146450284583338726876225694395637597188479771416552407168151570376185821293105979759530726291116783039583748489676477185326077982793929042098941970506521955480994069278669219390450698398905171582849925707183175490972803436457101419883864038742815183494186158860687715270843239475797033854995725035860515599814748333381337495887451535361258457082409644857722633217576056073302379107979524988432856696102232342645579254541110914326063279878399377570154573317940429842303660904579473108862009343532566630685041648132295911334740132139390004058285176342921893574264178507713344199058201488996306401276832741899186095440860975189628335637124795437263781577842355451722780303376278255953658598249634746605215792262448829489815824904836459706631980151085983305113535157865849573264616850364540322351136807889698962143218874143962186054637040283880968913717887226160527213558059060230426503005900432040986857690644619885996008290755853346775785250511168382039918468825603433516655024281133221528939584182796798541271490749490147488993708918585268341503993127749752252996440048166714912870927803315031110964649319013466497281189718032953867971286108051188001526485013139737875424544009115217324361027766294698903810302381842681435667859058936708187089855296015048556535000278220902705536981740924529928859396873466506432150801268751528495187076712486189400266984846612998785589806258349442408329997604437459942131726239956994406372421641505996494457251499123673975940066557034623495448607922709971097262669750425030069318695419832917653933161798594088255398438351364741756156250634365309406188291123002055499339443281070720441197097231813064863117970954329716466722162969007906618924480631367428247137457695122282119130025757670573933925893410832927050313869701148397532883582329288662493140680820209603144731595016675362136793634073700181970013827716287346712120235461256260057874338266858441106383300756204771042242478642557354735854772190022006732091375399283946883453357593202336664152511180696427693894520319659317704139846747693921701358423769582001068854343171397826895821159917190369486284505568845740295872169365796154793311625253703680242829787827049195020787073643440523704790637826703507803385151775375805721086584726516436888219164763775805745035519016366252440242553729340913361113719703890215438852312266907833022203114748615696759247918924349338807357612560381161423607164339456187629442521541137751222003882628726843170727579287394091668357723415322051002572663214624630626375789684695914929327885024004273036677356139336986536409248408600098409398759767961981752637015564559603207593660070319413376891666005282884687167630781780387471430593991167635020706379774446456937351942220746314005445505374861000835715667059894018025197654100214682192849510861527870006539487248207096720634561549127045554710434688104143749823141992362265340080221657543303089312977706035042996844295670313971267861437410728066288139889734244228492928586035473891694350304756727744012247817873975724166301654017045363165240416891519803481437762490530280943293284150739992364545258612640622513719340889311507453718131029537493776351426935312441040656227703882545702883746855780591784949762208045620733687405092200253265424389084812160365797644257814815091075391872562176830203362099314605465211168132047842909121351214586865550787232928238484682516926273157847656939988404364639638196899234227449306419133469689116227310425297916730539029256183687151514293856938955094869760077895347056315652922829201581854471003028274792795041272932987662703693742479300195776208611352634083012119500353133840312069527246177426107787904887941426261338008453414767122230947154384318333459191269296106890854660720611486213799288672838508502717673318136087756303320021121685978763575479291027023652912262122111883163669184522868755365241627750221321480895514747928630600008148288918568686472578722714839554132017857820987396929008294188456995943815532938230457734986667394030691290940191201349710992968867857715059276221757859756479262276162134255625305300465783583962672599691754392407965938571925301700237947815948310605090892810671423152817102433370953353740218628095798611687247442406786382314717252162765999780129202713363863566880680587080304027240876771593996891765609857960519115907414896934313959605387135403357036965577848499223088056570371094499248611235177401973042214561719360754963969017394606538727189258190565679117019358262337807130727370189734352077801897118979126837686797145724455992904926631813254536514101058965921265791203475155181295611823399632748169207995393121554067381019126158265378287964053407875831257179106916543489250892488686041456081154356388401886813180605688712748427835597861467338128172971092946869649808864575718667694082358207892142874271056818066081802041678631562470713094260564650233286286639202254094385256895897629822411856319377492316448401063554518971080101352061856739467699329050573007966926514188474788237555453474290660782393341452242438816679938072164187680866788818122694525016515124010313878362374621459436284904156001419819522223482862347350424942683091653253698973966884603852009503197223110917187581101548912852059942031227599728315186569414336899499154701085701495811427499667695805599435173810192758907912296637727950583356883165994877012188516510935530254631172842761454448615786702144462847379209072080505544190858022143085548751925503539722321014547951863946010823154803073209658708593429877311946403160408604191097202024136533242583056971352793682457934664171455679754676451148932049285562306441169920652528964155880452268399788282876282833410518058847657477019381884015222686340173342864590675934592540526550698177543145007455589208096045058790296627478258181650775804137834322934441674589884425900526001514281731837097945600756381100406448570343890897116254571129201014425521816652290136155061418925813837112779245391201960234042631880426979569939178150813017187581223435659879053405706375507689651341301321947980981774493847731365362457633473395032901502727266423481433048064368311784943238354053487507786586186399394353858740594973207545184879934977661844017361969591007584330350183071430362115407086723776721403029162805186223850412047559466227525745581591704849549946216208304272865326352946652245345715388853518475093804498404972220069944765758335009309707235378514039403863815312849409440989189013347911220145162860015293355351315177163752736000266751586440362794735521763842761665753630773566473130748946898265106983178602579530047322569422083090816796222049210614611295319117032990383964433437673269467284104382304184904051736902240581825087505267387678778133528375923525705531665231108258287612303563412940365553826345766262986037837127766251247786300405021123589947879382787111320482781042466644799580027286915294322558643690019058564146375963201191904043253205103647656644572110588139394702966054189058969349218811740521367219613372860050205104362603627092417457137996991773566054535435328379654911380347319149318810940409393362345890866319839324529555882035427220337013881927505258923669773589679907022407062507744015472589410954931308471164281271434691860266633961229495636408484399359658264749656876197253908890642693413362158231587770878482136722366521925564740899470679639565401164853921234700855074160910380844408286743137703919999169725162166878223159959833854914190074984615616045662720547925797523612935940995532121636784927565948507908970086721944042843988445142381019325626812674708552299334200436625648850274002933794288141728067012582523962122297966564481385866890140118064456597627069665547305911991857150298790396589575041023850565618037808042808546505248159179121445058985359029080964790111706412169523475637237840945817057468772896190329008503951430535967204749965234195333266766367217420723765265438417693692754681599867278190970365738518789292988900207341172986263388847438947390324547356361500182342049150633108903195580380272274791600759349823007057732811815601496352990740628615143581149334132560518964004511861495646436221433926799398574219947914673275983664894115638052028366387419708220469864922762260773813387135930232653009677467572061104995119842715688615096498621603238707055463218999032698859113345982318211830703448205556011254894995293793364663638370177279909221327636104154549936152057764285163586834778765354856130720513727548741519758626204801673279838443667156965634545790254360413571881113311633662092907112755753669753392224368262537057651110743307271241675208676143621964775264784122530974878905634418376792655877035092627875331542919407696617489648386855336631765951434305296026948550383800919149524172334152909730257606867441679236520367269253454978346332249514644512075005644487883306056924229587535295433560314834654631714486318296169812489721520477678505326755391908475772745602537181778601544504048269427368902713292184685154109549932607361702284531259063609844339263967339866466186971367780901158349538427829498662811742746081894287497920390350893940588215348042730970400395149047209235219762815665654111054635252424559441924836040677316825847803639350945405202707752572417308240995491571143869895107849914498378466748294904369647099991467076416846873633259512724143107725981149229594051732643589825101314947797240913492608023715044743193259647962045873875903382599091084319266635414641975143923223273080722662693794780582843777838313004801044560083989785886082780042932970460005708513276712471441340338605900241720350794706029518566770860753256483373404021897194389601548411445810013301588847881344778551913407733699225455310137719223907833700218118258852107975897933157652625467837375484064084644123412715215999490809003205246827425067666395790487332575893531940230122211406519005468827084786815142169812840668785125122807737983280126798461651056002966474077921527795526698297255701421889397547877756249820840392810747974660277928683240627659398184334508576214299443200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"),\n        5000 to BigDecimal(\"422857792660554352220106420023358440539078667462664674884978240218135805270810820069089904787170638753708474665730068544587848606668381273633721089377278763127939036305846216064390447898698223987192970889621161265296832177550039924219683703146907264472878789790404754884162215226671928410969236910449565971736352948400223840381120644820230857671104502306174894755428309761781724040805324809927809328784055486199364548291211876258248802189173977900050213212598043639244626460770511358846595108675470585833924655225589035474435988347383178988034633008458631510209091509935653820010933047965742556741930917055172805200236075085991197635228755907902043369743123506916831211924495971556267407521462198986233088625998302859864857578749445963115286970886710046268423648178989905454690861391613218344174148807186234448114831209490361196546872767755617886828720269104814092456410341835975604276458161513178575901661071782544156980883359372729995603371371200471049437656291142488605335299499642300699972204918120100819059439140675053265004775533850899097945101551091486907004407119572336026243368132330218709287699196806656569752790422258267841561083376425781032629202687211070274681394351128601502326190649959171897364176378436491219709109840944514895358959103804176941956657834822071749105512752639148381172052604826965162642710094919393332661030104360530459117014557209584714353721948246686793467375904872268133410207860903657108806376616249749507413107077401682180585945526445171409277469230062697511346044174567946735828782261629584248675157379172942724178783105429858245117575511884506574424827574660800238588378492396247368761507015767725898321128632295537044902516387925127590841791744640466913531047347984464996154595542013996317357476301740036796192919942190762895445656261767041799538161133387312823511534152581309087915883638351664797225912944270653557142511737323807232632958121797916679692329687096923901003255574789055099807487061047230646195984955239657612208673866514171699307557691897902675157342075864796345338446835085965490727326321910504064289713096224505162064669468098869917122127404504020684923266241760132910227866687270305284709452526825496617772499645206699836925910690894082637401043498371591126455822280606361394115344316771769934353664284928294436414769615881993661388255577487709937004594753907845149034434521174560594039916268444697661821387470705325559577933196460996662145377564935474169708562389214773222865507182490430016186142192760452307670621142961767274704123616107220009743758647492753665149532164780849075146330071016691313420662882562618283865836983632108760710427516073348347788414796732427080410860761841281888307115098982135338406610652147087046874760995427473673509451553599769040367353385551052571682650317682405743993414862392331981432579182193321898940450865013610998098383993110996355981328001049731588596312131853801205046787642910669365600437305633431984879048998524701293300789344532868156679762880495532846386020133480265279836946393384995675049993707814746561543438930431384237878981847802886009971088695632988347711863122382785963653115132377931373647397429369411499028751972227999545182615488298951151926682112451355318472209990435355949887299922035062039816011086376236539782172380237846650673624510635034423187315338308212043804710999419227821039747552717416043890169723961305549371844836119803565896062025009093664399360172007383613354405094329072476518909502507724675841989412224659392163116352038147362479528539732089309533421910635702805576629720156556510767780805933453631121829561792887673002802450932122778852968418208261778476955644980385691275787372678040959158711733971103165232678060798127609246173504120182666874262805385275843979167609007743380748420751185119102921960339376280986753665085212869255321536787932521882574101866137054328973735862725370178558806639851350386944039604928258820180419178073649693885802597758398892014389747165465973510852605706234402069637065660129535734043582961473427275805630839510667375349259659518575646939723218275780003250593895303820539697558870511543073920827422440516299708739599768461206246629098112368012579891284802505094028916959765079395437191311379314427405135599630375642214527294341797246187597964074239147838993541565834716156858499036773056611353833367087548900413091981676330749041510337597307246885839246941715548295730750618505881581959528992660225626903439573313450666972952115230668696227920947779974336574472673471408928071411283888082693377378077293104110767513639476200610858040596019639058015761002337463869352228385801434957178125581445862930042479404065736859862007914604590255413929950088044710384758990326548097338166940500085452723713571394902463820308668541802838317527668064278489561005755859991718966786449154063570014497194249878920859731254275567514575206399118150736397483102490793841725653421894276769116598153430084637087769510295415136551734675054015239706042571746001089968440498845985477977905031632568489156557231006499726498721480800181770357701502983008879487243887718884416833034708723239505377642232944095773219137582371673924704216723002256883135779230394688900662466182532658490724406767024939579697217467485562998183149665611743997680482094166257463879660305171274925119226367615337524381656217330771650129520988754856467131862602387619964334867961514408328902061082833180891221325853682856469916007952105166960451695430614212305743006877217407155473217957577017595967640563812729153867513698712395570542350999228605975469962186195531354132139126436676900465429996811680550737866770665988027062972502001882845886145344368771455361304414465613369092862748276981946836480550952968681758714859972973082332924094777085275279923304892719633314751563311192746150389219290616780607901383451137066300684376267199885515143681266137319912103235469786756421210624899005553564022924345831264231038363416781719908354140411717740185950606674198348143345444247191436828225654380047860390575922417071802670646875454211626958746795398540784464654140381751149965273621123540880166990280149033225139460832668170930713868826549977374286127789417784752681328371818759103642140881783220739808059714203285309721443041845459183002833408705783138284973283761286182927136745161897366207237396132790944984014154408304074405393067540767126182547597130843470311389815695365971788564022750674237400323621850094765267521941901241387478279883426470873616812485384444012772521050072279315853096279121131160167772077952572613800240684421885453537121341902236379684012385255288607189967725694227433323948595075570839061877450159652184414998155476107548008054192318436948191732631430603548399790783307267636729090980772827355854348032260067472537097785464567761181807367424367391769863758072145859791485033700592994963793369100283444558089838054017635403737133019311293080958287612107380374800660269767842888358265737486556785868822015143046249655995760379768685318192365806469199584071845493606922169776137542662239658644989770921478134709127917460871630220821981434654245065731262683089579031012893360788644107230184805400373136014216229159146992019884148290014414312800903102107833305090238435726779416177246873411503598700003151092815700331081727415624680432977205070450456683898626301702989301145364477416856732512330376477881749036052572605520684370616116539755132541369303867783267208227323664249206432363089268768826650939691861683271739757479552993242406186992420363781929485368098035256331092448215269276219116259145886393677034653480367887126133367116968226450914997055448521259751870084720025674658752403932061045903070039438252019383102480929019684602472171298321628237994627125366359971898374425099120673688383738299653892030662843074547559074235345274029211606091346327684749522046010409575607348155101677203187580089224494752922031093841661588823584993931745149914395557357641584185479831702428523965451087525425464777294595230360946416541997797947136806344915998772409176443137371178542210740572121166868692153240490080384205921192622875440898261478908123698956367080804687628524499897440855677969456909042340530355943524640751677873953113928698614347227572144946891896093294375476741234907792754338349412323060078767610089949156126934038921148370217193387617823370358925817112869563450001367619897145400986643461922197676975930010555225198913002123021780831934330880446592954552165911855939202579781122952065357362914478404946474565003115498072056580360667380889572746464375428055819322299305089287806874537401327100274428317925355003451536693172112088227603942809788645727306979971285649576934354004030728440581746648376658498039958964243370183454151720285337810904113124462432903353964296651109482836884580127588701293156099225044518125460113274986014470437757313881001319276124676116614833528935557503106018449788994378274613854651708241613167681463911870000812845144341406739985430072772303758111613511094355614896323929750846383152930263582535361784837558519666949972251935515953807207838615142130284450051795239760968433198292598921623223582396390262548856855875458198371559008447860086745945709118128793228222051767509371866110013193625845223493949829511199280837860523506412769337548130609594264463425077601147334209139128541628183172262143783062962408149391997187528106367348876678481602342743230027158192404187686545826519361990687336892886715133840245486110982482004482721799496658712257174429044916781194824165631560303473833317665121218052780795958220298330611945164019413315550379662980215357680731124530585915969709973988055743550083279071844959752353594644354789680372126344509423070253995102864458237454677761013556916212309752286152053213998745673034127676503369636682306665552051562491132528926155863868503100849180920507680658265915276163719928694258350604859732273949286080260640627521341007801815105623787926212039424781833439433877206395801115809084190794320195178235740190546595990289617711776195270354051193727229722248442080440098750369411277686593022133010625031862085145076421052980508837197986052557750303949606158442838846866137510968441567309838079394349570013029265177957120625555851951313574029897589283475525334409858911400694449308432874005015554332587793895080241128538758725945136400838324944471346436826148195406004114845870234072926697740631325878634790667698266181501256117692275715291249164821702372884416357600996851100939411444677628186007072278522314941048564396255796808221289935799262208553889221164765220850367706476491496133789353761537391569177822237744837614120253342622508007300513473422771427333106345971803240244226950458090539326689103619381998838844036231795282435495362489670734155948067688515321073064476077859628627852283657244564306449096277517172656954238392941958409527253281659572534531428389629894005886539486824117113929627356938973482935854650278689437014798383826002058208853517073216288725214522205265969614962147884840129004507737252424605074339660818182960296019196314124998538422017695110361380561701016357743542531148669369994130940908368220071936435111978592782493491477052187226546109199597269439152400467901173602521030051886080337084840114810246351288263986170081804888380750203521448348740849154718714478857809574515499505005070789428842888410027877777455981132319940624176532148686316581736774410084063436959989519288310869124517866342559353458242589411390516469440377562665821577845936829909679754548350510473633770839151033854639602753486401635204633884342346714935641429160856846724874244782055113759168236472297793612971080302530934478115527737540458968990354808058309381267323593563098546564376209385371052808344607189076003388781618019853273759498566916704703448438363503416368325266403224174519476678140428319327482851882140344319384445475456765253419659194332132585432270070759038565239668227171300009189122050845185261514627937717597528852978637931711212529529443323757910072909001703558763798612480281463093944391916950129336315045285163539312868586427437296109446101235604877439863299611899755965996608749049271167685268675335991297583209089553296409523640116060078495005377892783750147344122123777907727134146647404489837589487675423294546899354220341669961366698976529978580795899055864050388507083137333076839766882463680992355219727241831735127646189112380485883115569477888101759708977682149644340317924443085170303692214137621194388641989508360339306459037361842937028710758321966607546113761076362543928614316242890754021082233620012309384737312220374269033838579928678572939434168287053763374091938184632261131740934278117918891642447513543478446040549455379834556163353815868441692054518698919434175386663900335756765603264363767906721626620330878425545157208117246381251512669846685887209013144861632560461019513371814585249988176629925142145014710206193190373671380347663431029705222414785030188275106347446241258707937339085095757724316735066885094208761536164440443755860160625837091300574162065273670941888667964570550744724714137001968165215954380698515999483361357521322106131884771926641942395351412233546746461491743013475866037338176532604557402925472279360288926189385899695656876783017186873988763887625972743976062813263446647679413679726184933395074665820441677989806604203937116666336696282569349097348391155869004856032512219241534268522369316036765491047702733521540143168338872968405443296967684036073182435336224865433823598123544167514608340781166661858781733980624199254577853462678039039937557802759942957205281043775666979396838109341118959475766220191217535093638985465283078692370662512323684390235587636228324657161183714078807661162179517887972801841572019639084400269037450381192797170314489871815031319992111563908303017288012610642062005359240278277393918026391717720136125984776933980647063763022608885359937595079088789081791802195768033381968605120487107610874898411568740159953020639098138993261095538868264084012160831040525974539251576403732889086736948366404734622708560040891610782221943405179794550155347682966855320097501905581419914591124181501062255627411231571377358697194374130822027383843815940638571387913337592362330440453487233047240668784133333047898995255221468847973813568083995644533005222551320155267768895412770329278670827490041172076663112783638152343547681663121189086864991380236281775275946061211813342054791801619220346912760381900528012343973598270461499814511324618195658528232044658270082064934680251556511272822083811563192256509945201222666603226059396247019707668580396286975551115189973049085051758765306785758000660424066894170620303846785860257370634352599586885088679654004465187790208942935153217316750113738031466034642429489076322228133763299919641336502028627289268087560036613770607463575515079087982099722660130472907825746908175451952405573791313113170617323191598673971588373108168916968657704150695512947652386134815766967580364762005289060222744531744305498402863048850869557761528650326080941160688570698894762046478500884303973107412774191961697450517110329082815201273888663422631492147090220016940636504812047036016738602290671629816411198202268607961324739550057567564568204754619040423011062371367395995678940884705976859514505017241517746017351430990972615509378334720000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"),\n        5500 to BigDecimal(\"440980727505361492263861046749041597876482816972068586165201757405071415126567668376897315728297849952757367720810507858907173681142178523275146939777708506615877105689517847797612691117431563375120923705793250270343687236342228395008410225037353722657269374171097231162189193050783333798086699477700832601855076479084487286256449422676136718797160182932187244133151220117250832599810366733890955522153881804695135195606966944099728668741145649517735685414503766662215613729928285533846188830607938145566542566499237338746401510405862709755894887218064692919500148993099202747699919546275102942674317721350168811697139703889394146926850644105794446886258798098207581687930348884689444029960790209083808057988430229075205077010682490799017592156078872409182770587357962782293095550561362534612716025859482680461265813147457763039999460367134965327461599346335701520493544286491096639476393826495899998311170219559631429648576916130221707593976175261186863554148371317637249672542659177029077919468434781372771374028008178161626349957336688805975572816433786244933690284852769846884536547090577308049036444000084319613567895687732162248395956127136159168819866832530333261627318106999625235582144175027699987734246872135504396101817010998011002572122843163471228718159408644825902627172995218520842200563234977916487682865416276806527158791474205054491450314373851193455029538260338683152168837750156436453896517505566441871361649849883547828085677348793058041141594604940929802025325926096565148753280872668236603166852425763301224852473482868202703746866626382751088995160802327758121521197462549725107740209332209541409678323103697013221893896074800161368688700805866352010377572152050275742274801449175238776487494421026906693510376939084197176525858370023795544876927635587747485889949481748491610567109424716632225136842169438073752992526282971693514783548441493575119664002576032264775989225414369867237022296495814288698556786804058011515464575155178474705401256131743825782413315270311157287464921939280963301593113548765227422960269924020204103653988516396532681405039000700536031606653285186559459580974223547444407307211050678238422618593945254471062658161478385559411136472889082515446752242683874967076372261291563116749963967073988527397906562391829902830406243830717049562534406488133558277152842327938332605573739850360075580874150527105403474729333138310602613028968786337769143508391726432635053492985721297587831403942790496782317419022348385110927367584106448478431763756702748854835542731117105662192381758239036161119441789186980376810077092726258210313596016392934161518984847862927095530419614818233845720208620662914186653621843233038603099587226160593298113364923535425344564528216971433295273112201211898595330730564445760487648080085020291107808058709295418087427888752444761003812453947616302640904429207043954035271260706724957825863635057767433163848707879717875433607662154610130625397237862579104113873089190949016311923324491254879716932655401089932365787775231596519061062917552773584804511508400559891860750878179342447839508266567341771810317913238297856317117029708441750370686902741253979742638208347895796153468216219229417679857459328939626932248586275852374403544898253950768267951635126654788694209661592915372668105075599794132210819343023853120582823538748264236398065198016084308274416578447226888945034950461232842727015971801417538642924219735746944691281550229075219400110378638564767958814552360638973532962437875373253308070134775978151987127176993849178360320870810123485469291910911572055891015438957627222923312382381535730604371265140064432289355148949784167594793802845451646210679982103218142881008069168238698261270140870765589390720657671902591520826940817119066792991966956321386766357293066072166031324229889249186832400178900420450408241371967508969209028997667616491167628019457203995850828072838680521726896947107672962296399443311015949720539348182426550966726444820058822723010735559313675132803592906060567700921901004369474969415597439755658660053409496399776594860799519693654383211003212191632766091659634697003990063927809435099886223151920854231687376613531936525432272017877945411080524703543919608887497956887770880811723375460842137855636287606792838647311888857074712531650209540445825225197814284111114340914571777106748931421644005384178243161503638253671455501748399050190203038690146615056363068470508899630435816056222853011886703235732985220380674618597686457535101076027413080037383578753636973074429911606035481389834975880214462535335359373109559650788333169987410357162056360151196388781291802879808158603861142410124098940807256342765126950874540831712841190328199014398605982339162651469577592027597170459910451459056329227178876250352288440240383464046723902964350170218397346522603254227792054340378267522260512285922743662248066248439139233497243460691886937584770531275399021201788863832964804210332562640499606682875057171703147149802548979687044972945904647293733813546271170123784390286139298982414846362291336353736997222707536605203952529872193807426421824759536132031792275403199707760121751419168472556272616392676500575921457370444428402357023711681750613108158615784485899131676636691549300380405508470400800403591569263489446154144284150195822628225547007483151139949787832712399165601629880739635469507118469749842948741107403678946731175083142236318068535315249376186779023527632459946635680646763600568147743428713907045325872841524922680393282581625357859175192987768017308827668022100267520436721924078529093188289065097614356795474402500275315770858940662944633357570702604888032479485527092703624889307496348152873977066932713728101731726424632617919920567487955253285173896027204380458713452146224663222298070598493126614529957494685157166824313222299227056925882700708843696903842226436905852818184264765780196033011474357215278700878459374841644861413012438721331938070764634212643123799794556694864394846857653822193700510204088956705410647416355555097778891263329706781871214895415422824963327272456595991891578641387838089479811922271351974079638093512362173281191516184730901734790635662799981980759759804355899836172941714188572542570061306396248278686481458111188216192402135231892686410531185578153202600159822877322091033971989368683721452651574082759081448744858396159164139249805728201421064969510418459672385497013159051473227533287875826409001158155820896320949396386872325481873719585990639588202383202408507595359136322918456591307014299265777942815566711921551208894941452893955862081041119396290984732324146096751044822156549098547720834256090055845110647504160159908442826345084091146438536473314261455746144551021771281609515234226440649133296952485549512516749194028929519850441540279028108996065920475207381650155287812631462341663666327504086476445869331392465619607037948061193625543325834150717834638239885784230949422721771445113252112011326478925153601081151645643325532824789273772142861181217308014069234810170681255825392715074837696751767041730243567415130622863043900310988323186489501653290742613032968989040424094186511413926379551166225232425005272331477217136942524827069421502962376354342311691627500328918093473996347634835065159141726037683128605348114099582569512174319667889229988940470004380909234717193752795775319071607804073725958395182235937700047770100176170443789868306205520209932037118032855355509237195110504128160184667864336429753172720238070595718356570163975688605721344695418827898455736247191777762535971516345863073212313962656969749084473709494407282434994250892408020129242423097917083203797063078891163676788692207855905075411299902327808493547658551881419605716152319361904934178136970899179823613635879313547778079968308376875662503727152854888956457305390883176649893512824735824622116567979477305690349684625674651143812467251652595127201445421453293760284497947395373036327897197181876913483493553260852065294583801547387805056278649812068598187570269165932599986554443895946298448537957212841832948792426131881420227354145790031594902063503968792556678356582237417734355444851473606985407393277434167264696182721983757528072097551404377467023947712750898581152028145111742445080414513643844444995119513608020875140040896464931186294659224781411620176272762770852763299422043643785610797703474400118989009489599369978500724108906331141333728878344027653051954957460543989932795775653026643021006353486335373130852104655948385224480424775802204877111670810905820787160483735043108112444050951709069542657532606435311147355975181603105414344863843132752985647161435047283271727888257736792462967721469221581275787744477288297266476657435386816654347616507739640241982867625992701101186517874520550970097546061806897173387171610718823927088769880409823498770062811965077971079033521416361426867066703019773660441930051891507420784223563989192499584711959579406931233660993125554853336629349513498111533302073553537969975305280801947069636719561459118150918867860301799513217575042008284017451619324665047011947235913595878158913601328029976350010866554843165103597423561336419581388562798238536634796135123137594613194801659554385337753575576342949146402234026691815871784847795605107145823514216600613202990173150039630067221168693298643899566265722863254334719675050140031010800907731650221070532136360580002379416692057158724168034353551796813833302684199937265277987559126533205159588669648233413005148220721733479786095053145324624163661684000612925380030178820012559790985625641309605799638500019386090815132527180278981298590480560632405566500034021501836159288870841804009608283614221592125860118281811694688477702922987609698622857574486376942237884064336701060838537388472959139235860107867603347532142049694084029809681120532067353907508625968905494191037702168321355419087337991686369805321747517482216275131148885581703818771091456948197336447887210667987062861179604361871139645457172637530457668976207755915270056995626784630878954580888392200447068339183682150624317958128585873901513602481614889216000447605123485880929868649563525293184411645421078539510839623796255184706950130813029671941021913045601019652002588815600094806813237899190073467070264306901902670625528295237278286911510832841141023670839570406975372993003512297551613041145088520897191402807809280791967404392537642999972595931671822942963266371324063956189658057102874495795097472714782500633596043058221558287165348451496652767381901187838507614976020439412132062727350416885395262137194480051987191342366748783998330601123013410766998620705914705596967720286265351243126498831198788508781356443046598126403012604655556717613330719179269756642396517524994936780760742321470218326591874328050950598867265840965352156446189993767575942771529035831027009838266116982922153772581561229737629862779021187600663808649015841804612631532545440474796685104503536820071364251002768631876412005124542668905271837782726907359460549613127955409427092297432823854329603615979454856641160149034710990880673304076384734752249643336695129541219555224192543452073241315470882429430055645473257540343270827173383704202708858239369842704282749479379550857553879427867149779138523025467280959245817050901188328436556116777770788852975437682557220039075280177287740384842308553979911422493241504414244843963473759744431867718944809083361847381405325977443802629447685896596717703553792230081016340191273540158745242081092272949380148918058716740934704263223416072957086083083655271269780946364051704971935903241695553401368453943970306076215818616324436934892484879304545015506829119924198158537341632896383507437812830678825430096101602236228639220170628197104583587690849546383739151641288367734662339838511025795238152299341278776629383077587123762897312912664441139145204596985458209056524705948140081685628588135215473625736941777503314135707974180609146531790056028426121848875585702045223515584664132443286678444835162211569339540142364049923644515752367209261114799013611680163466948198622927896959150301521673007282843264024469042586572224231677375603642199318230145549774928596585464483589180485379102277519627549170855632208774814596691661931942926597259494340615183156790243462208245932647725501303351975153321998712257569080467592326307937233605653330252463538174344696668004341750444763872033583661178967341616234093659612098446990533961870802060004134007707321488114548822737064824961485191069801130366686821354563834835558531416179186166769182122371837125597677231470382078277503236617920211797674153794902382840736634848368801718288052265097439889802757480661607482640965423849797653759681862140023596874076448085923735245952706021987810261607925020327009687265987756588103082704768693157554682765648758654132384468737718803467925041201277711250742723143467458890958084229515367456410100087949157537330605797796369404684767264607748161047751704411886600244497801027951669317240796508581884737879138268352861564854342693869864604268830124796368951271469391162014044151214633823274577816301627672416446462536184266020764832318729327547902092116368345372387468297026484618496054977828373138994376879794386916013205325563750334226287332034769799362497831584444192969488715217658309484531848220784921323959012692856731556462141323792123662470950991382991705391862397730803453741836889475006001713627514456382049259766508376457640240661254187093537487086003427983967750017338647638898211211853322790597795522463299739926010562984689775806879049600577095223029843610365739567064841741957330961818219920371642304999591211819817694382176529751759100095536880117324849291798072881505860785736283868063197735711167875835129587951231427589672433223521389429774859395574858400301495846060666975726812285782984183198380705407769169355425186026190748023389153091736916287942042023925732421780888110548815034084951417244996933555528819239227092525655835316521070905782257220632639422573501966894784033194689283779032817088873839727013832657580193216781773554061763527726245342483999507702488304340811961449383397014793691039097238642375379129147797431454554376743865073495894429612536463111176035287353869022922134145996806962254349871463806845810012829942012994113715854937262987077939115805165814568990472673639051448567625519089860863935673130326098371193403071729866651069709391961015077720712274361441258609083419589939970733478504119498118461486788844924934406762518301503481938346850261594583302483411941575231725750982801206909403809581120822256737283844230347545333672724153486971469907208681490369826404839885872623889996505321702313582276653113072402048977840602694002869312030464725255951762184323716505131701914979838566164357300618433102163211276513022647557722545868271199278334022662002422558664041514107086733500125279746333773880225290800066016576580360147123563503173530281934745525017040754690953729574459397922404545391519850854982966253981133231671530052071077901355641726305440330487284066319886020496256126270521482775434841451153078883559648044600032375726161606410131404952130144084586049417703012715258578222273291995681164587254767065832758954782100963653437519820380248017094814592915097097959927488737311899567888508114399928300311526545957436457143214583468976915319566309379650860712769547775857578375235869688801318543271261190115813026105974900469716123441583613557108820501016237432848676304331731503476796215450740502237587466853923171497103566471729393774843215252457385221708986708079274940052542324813919932525407766764139269812765426158610975658927160527437781785927153799753342512871601425108048304876393518999982409146250654496519858450846708723864298570998751854286680653186430503972246434791384532973909898539365116009183252896339130952352474048315765663385380416114427741720979526282267452640088102213916472747078077043905221639382888363989602709902884457110909065435010269863592126788794013140447323022909396855995232473238959809842353329853507674824476938506235662192248067248177899733244665301424070778800369056357307324297316179608438489314027111575702810946108583883610844705578617411562769203530033993447997256826707043244964503264813292109817067718039970305887759541755064200748803939024405859378535520115027396222138723300677977942705687785862997497236681905982808176789350833407683621903883704829062324573894029768468366134411007716279599482582861825757873951914825731188696553250792146679093113674515598999111901595351983815215766905201330584244921442519412025849736060846809413610598372776553132836906549328340423225319601463868582469422990580478008523333657602658970462657889351622485581145779439783994991043346599612848949712508370459320174816030762762396725671045311570855231849936191462372297876998772838273153811748254016984588129176676535357563181341133071824757534335830004693619293262223872293947294962016470515884721891057853790547734360513840735526301840569838146471209695990486792671580229068081980894923980800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"),\n        6000 to BigDecimal(\"26839997657267395961163166474627355122050186046884725685824261445661070965868578859479409748346329836182703089128852632609939583160469201526637034786976396625075825887529584878861523984702266296018595427551580174654216923424895644549809732165397549500287960097044436776098097112285935902002318300817766074944639865419157280524790653203290253917356133633993978535760253069357555142219669129998317026518032402810751448010557484004254745274140263837210122325107062378927575415179640798325598920907738968963426553833519168033920097139867697345016081563676374441238664213080213666256929097791375199485350231595456497900149202746728755327879812971546373369370677385700341673192285360910112728679385205719710580583641371671892447976818829243817888754721448962887123232268424960754147650482415903026606790467209849563662271416952282649322598751397802523984319920253594583722082455006753362159905925741054970039726329277310783778301896111639647389105189524695731748039744831330171194849813750142198591661331367731897270827642663650121154179844927245869455452866090540869550194618984743649127756540595329147696682931012739858611204283134522143082978255200048338318229115382675077435011021122203657208296645354100711784246537108376427936888332083853865732544562471022466209428262367892766813822586238730884186670640599681155203053263579261264327036948384088756702762253306671361116697006843642834443792187068184967415329762543330480264694132001091536593658869788389814480927116885215169756787073551910689019283750895017493228111116730310828166766041200531056382164323390539713295116741388483967745305691786537941332339818667917676571370007419397773475261943894514052312932289624661769878012350676494947730866831924804552851197759345191254081631464738416269147789847963818212281155896550427170387285980460490951645441243497814514002972833731020681426095160149778141037573688491521442522428544788969389558278761397481348218877157739113180534110050023212126419438699172726154425655036249509154341846353246115757571655397172997888622515217725681355507009805113242461343462749671452788638077124750445775923725491807857904696015889810582915109267213212215315203713159208649674164979719727312920576511559196470602174361303899231649894912510856185814740917226239172072546201539584906050452246863211300948544262550662310529984226992582651085151214806862737544037624184170092436908438597773909311650839302124106743539756133701430549822835175979119647543081774334757846025648778275567966409017115828239278838608964398135300219592308860564771741370352802721328544196035203258913677288304583292026902650292022615233949477454247380613913727205962978808266843078181782521529295663178723309967551512319985570114605975081675370544606833051518171905908225228981315998888508641383754110684161710540379573862750847847505118932108687343116259504882707915331968334989766476215094439032763933829258296825600807659383396331656916379451344784802449899227776335723347766390689666241963170367393391210821232042808302473264063265570110727719831475689561404967877066430429903848880193864377881446218231571439631758568428463947148118858717809903748434222683956452043663618862381077166736163904143611771876372531590296726023035330673799952066924105529602223046628759245420801826722083980921568005211239250818157044712443998577051201694386666676548459139059534955603452332498091561411572853622851267073396054099014969366801494527706537595304138848480664476770533265090362642331386328673912578619209255162812445589840156651576378448310470200887299943392878434964998167663977882887221263096306624719352570216017537901919095997174491423825076915901844828299728867068358932893173855581339383152432283675932309139108086846506216370866033080621523840531146755934097307408215697024409051687603668777226806830415433795410593140890416931031058084357039568102702638999494225749379427539899477901253728525589333527959277554441588267988641971876672848522278885432950000713174717818564119905187925226030650056997215832606755915139333987912157419842331744288642889962577622559173461092061337782792800669889998655960852746942113164577327334884576755813786481634749877236127180350856907734255684011438108061579128976722956572293429802773951504460935383493894278312699763923245547175663397346989022015320010667525912457679400581483705019548056855672703674896854737678203776369140756376089462449280006665661035666006921950987386872094427675301957693502233910568049172906194746954125886626269172858815989476855674311523872846329821400400763827646130537527272350995090929517107381022804145383611938945290186877390668234661029799097681602379568029119838560091291614083678024113699512262414222827129371338079435110215172704049731560918699244509728283556069827037741673013342110878227016581208632447654168805338374785489229037504121557638213364969795134613946880198143598744934254049047652000435648260460315689718953671559931084783230022864563599174390561242416515649909885274704141042481089882030312456111711513802717240135242476854435918803605162485964256860285707437162161523150880602244588082288703552459412578484347249931541710133937268355470525564025317366479302263333297793229701722268518487745423309476454825885688563656328669909328960726227217746513974012608523837157894646126497155495847558779670772281055345753896529609284835447408379437232766596325245729441678426804018266486446041738028201210588974259726818731212691907209410450960012489269359303557141418261872878840153018432632743047491241142213154307261531976744986085767078659204961267418144728791274812585877377270787860181952296269435846032835432665015604490686890958244706686381824599477501861516682019378871555372510865803678658691697941102766320731311969158487304120286437862145736732394203678256089895044788570688165095904488684541547213265814760800903192224668435587633646241787956794671777024535537548677669344734391033706602943613442496123847673685078921583639566511433247002826913206025495210184332820453059341772597886542104466355672414361321525270662898671590256225316736799329288004282209029227977496988338803694599926602334918886851384115767529046261566167879067415004412013981026431670302781024110519975053809251441552664436695119607254616839235405097220832844999496406932610321750880717707526257155144479558265577121457883354130966058460949905183541920784685810495511824633564623203622545752285048322601540147114940477282319089885604719594322274307570377569828497611795106065649907604825505236501660518162575599118468736316043306834159987187831281295962021538609891359958084877685159675050166947628016488026431953172281900387230968173782146563168653588630286211011668433441333823075581919363824362932880427831430556053108507046246421196140219366978834558974462588436923645529385600025541518596699322797933616685250622157597463243707453327414164942163090126405769853433010109206938295039098203538385660049440677153410981199879428054550229069777536610109500673593952523016334494523561068250729979121779184363748140628442779681000417566359474204167681174820176728969043370649673522631060265357110075973952347360362984289840155659432230548753561511108669634362621654405756411713538358908721730705960390405977938491036511919613427919440128566811728681598359611378946010125676443438082247070490023185084235213042639811189709583244714164597763501116307625848095008701493449513079965992954097684158860941655430946986067589018614170778141474686227232765295039894254082902355866495212825729079245813851076586228786055451349969723070416315974239445690393038118202725795105519781134231015178521890424346496650894181117354609245262021371137195676841189511521902507335137574217501870437614126135353094126084804313051200792975952140413789628883243769036385641778001621627161816525820367941544906943954307963287899647807608555063949916962195279711901809586155318819699397668051655460229580017948563694384203283404278464809965543259459238690367209746182768863741318400635630079422528479763675001256831936882203374586645618033291782515494021505175038624781840272794622469978853958785054623954499516285871397211907425386069707751534411059083177014806958625176529207667888992864932992747415768392548848256304173508923017783002188862774976889301189512631658135171879154140083392136382819310890513335161935706439544652866330201623448052563814824077603326355508933605604424600448291508530124857820023813927063948608641347736250592506112490756973272230629775646381758420315977437335059628471695549795691293756712366294481331175001245733081851145135484800803418840241315976099255095439620940223136901994965329154153506574920570848498252125571529713557668092811195646136559978088820601346208029112370733158792968907458126312371445670688267987605112516475243208816963302038466447547681765253439647124033397270561625609556398590434964457944954309646474894650904853218921957202959530304641111659297682838865324856282312400884964347702070305433879310515186656471481638169102808581722273535412432597450682370732570982895174461945607104365181581376611951264796184795738549839706427908331191819986570317688182995627653773550817877954776508879127635456487418504926881654920604279454152324325660886511272516911299135838141087303316226745988807478038370462171963678341308873095934247673904776115988991225795671253759564756119735443325022586469345409028644380587414699081655676862737273868437940818179561003406992360965199467481546972908696465933739781519701659242335232356415466038443338391940395961378869736803878457355977659711442530839903609720790079863076058058715425763090531370117042825661461468549528115981158562216417882781509664853084610831510279505043600822370480590602567198336194062784913269731422406383973451453248248130283541310749558344183861427625568458608812548097423428774920090092328407439640342723637863396368920858582855416845188111542427327700990645690098745755247279065598056279137864634712015208857329539219829853397466428466858279087009752509271828426898571834909681863109405566656445800488441033946511794342431604565168864967057267397568220363992954730588476055451427487747065978279654894963593073322993554421804132579318498274537173107483494533189509118093004443180291631727515000642142157865267493042953936254541488985234518070473671110935727926968656415152473303726109624468629752844760557073833637378230650501221082633697198807510860468850341272344748512661777090799274894787545289009052176976539368742406207723182280541002309464890868562316823514637242729903960306443521003257332856088639395551668126821383301629329766797786756596435530484560778049737215792030674205303205801908027014371344418997505156595085966936182094633009369957887739382905617186959592994679436161215891491201560010002303562861512545655665533747304126090814958091971128086726263385122624660641970132348294803564477594695720793602492116938354646938946023345419380616330196587711018244015684782598722707267350042318261118692659787623138728964220486865730904538203308544993585204324572483911221951329505157910024779477100406637724879026557148888479697973570421165075760846187884313379621653231257431521388920581117855569927930918809429389097758561316947040253818657366569583216996595880452085181969727435761566711982292456039046952519493321075973470394810159148251758971126592230257412888072670817718837506735539095364155132814201524878117711434829903313602637604260588611935665177670745833721998953303904895239132068265377922420627009779809889466755971872455555671343784690265355346881170795850018502852129370131161465211107369431679795035652082821361480112682380161016649435674734177637483728801571862040064044726291609723825892762153360165674913318950680706277824100457440373632584431075427676529506977563628228527378494844207021130124323451315757493502535786767998535944780419236802727365935448267569554728569057360166647462125575250193177849662065112241470787761620611464498899026682166757218791373813761401747102822467889867257511968031588511731267040532584303876277822386722669253577220369208701354730560681156009035093927791766748395744314207149124473135012255460731267410179450581153432937372865433287334462578361944819245261635417883590093899730240806210512987059139039755719239516747955096168654356635774845296249238132200083290844308330305768505442081037956814356669229273485720031048841792343104465806889538587267438148348731529650107764155019749250703132742148481239788685811391010900182490909954694363129618125365471934712122838075498656865915837228681461906354109534852326705549753619056082390581591133714455250473306727306242271394575288348548899421857457448892069402326062432879273585649517014441861740184183732637647917145400133596746174058308263937278934908107861989223858703458125139822476496470077529071243260203480002394510173588464682577409130875845159623990027664682239590745295239264283065594285434091436489253442921825135707791449628982248064677091483840909115145896107493834857848808071214338290234872083621079923598950627418060690376874046447264041880157359247953759911121569430096089834446296806860114670291023641209580290186092260745512341049839125320156048602734609882451486484322548326755005290081487345389836313565927731311793288362110072115999613152199117256916818999608708250621912549461311254907765260632070362318972418308599585793874193787083482250701523909384993325593106521905136810593360648610894682072245554224301126571410508286122161010810045817773370919374379062289989596224173452184331945051277917796601154892023168491463596096169598616821643671175696854206049100409006169078167430243904473349850147863726706105693676072525164576151294211311629974748183761004606695897909323902577614980463372076919222259328236178404969041379181515374344242733626249558454232062869892488352165799933907917509540768234595160387324388181683690007433113673985430304052495927693685462083670005908633301178630874993739635956858976116348960179166726796605516490861400434448117862153583360984970496289282786486924122320805439939104334341019564178399582455126220556116076741160779832290603975886951147801032161856144959140749293512916086914534660610841694647041611561923866814230934483566399542264717552387574974421387272230796502177946284221874524930330498681663359921010552038845486760571928329559123276961732134968947802118912623447421785908853884067148125440069829365065220130190616955378432426153891483828105402950511840637876877234184400942653059494517924357669899733289658380086660623384775909557622020560227651865360538523553843745107362962392805230202092309660311635156423561540681110235178761462251944120644292834726236559729720149026752335625188787684395265448115729660748799089328448221254102231043203399148743725714335765832853961835178566475440498860100869638052637605743373122008063627879684909029232858931089061916343578608313417391750989970302069749103922130012341608004119286343965424842059261793368728098393595453691033567327108159117557620000953888329412084429827988048791349759502464645602759589914538960491613793478214629274343372792133917392650045082328532754264581760884356541693444000522135818927662083734901101455655254750765419245440999083696076591953649097658590724853350795572415019126863241169128496172523992207344038102394497164800269534560712698912118761394346980783745339986140508718446774224385072467747565302711974864997611631470554269949908627401966447196716914845339410483869892524887982754042429506250673628968228718414012061643077451598342070312729529554773622909551294617485271223447001479812256152081338761827213750484285102947543191716410061394064195110279165734257137718743900404114109584078987879890440446197685164429076990775186914399945755358951691014258339827760688101039687288938837826076976979306089014797721238103646612279704260840216938322762615799981033899782421339230193365498507592907351317381230515558484120284158045864263284108686716827733330001944050406926490472871149620911685246815731101319508907675308813751230736133469124878367785484098823175312278896475273717682187775471894949719361716988670517703295238021800981249818686821379075877402467161140894884709253873700243744595822568080593124662675402754125916201532030537520491201173394159061364948483059596580316726712605307448924989087569963854988789985035890309396965302398195067375747112091617600630569062324899570087096741838973750680880832943381845733445043322194272393030455106292621745244865065398232650227634039186524858034442435811685990620469599080320964512829736284194196458596854413094883125022632141852377393629837683566291882367008185503452296814405791004709850786420099334456302025779045784575829371702458061571747687640159115139743805106923198622400343083944895587534294586812991787254524635520715077762098659988456250623733754110464719122690522791780240030691459123414760105186968091990914114056819616384834492304501039162508627073767169780478967830496186463014833978072637257898856860747927869572485404472280339434886585112737960619322714849939180667763616427956312853138705840775032899047093993945041239132207332617958940173285759309420189320639459634009108821270840450430079776452768788377382406303880576440235086778433484851147247590306073275962761489160541273044410581057507318552527566462489287493173796287417367511276543141860934682205107397952449995571915189415486555443905015245009447583374122394632411846254123646430760547330754177908127719307103338704379090318774174414339548060789758654183769135018414808654059391380421542898999289131982752881304432914119165614021131474301910193653981743294360179900258947239179416931113274497477055056916721815325178771881770427595574526979969110609812671390052073967371528725049419557297254899779063252161056890215846180637435165931765123585887180135444817679943914033515786523995512366445378614290524518063186195499410292577340893661060140730842547355544924489906477904545600765784171496375614289338782329243001810188831870754174818902702669589149513609444235544045909168745079904116721850001084293630774744710684207973526258512853651361135504092112982975885188330480138649740482126293824415540863298341430414394251739591197379088280472305756923345573771556994641103276622032051635549987509769751669795304800617960120841579720909823273146247520919870094496829700346067978778444534370898712922626727560847873952959479373409336411773191732428874668314482333129065714938545538758040915539353017303882622304962799500823467650949423108117514476739529568772483484088052527412492835298965051496826879243767284255331909921087629905226018279220902892396229790261576968836481928703175145314086183266916645372130046603087776005949156839867209518985438312000494875144235247146892718470881434056042405573649073820901746077355841968175323686311247214811449866295517680784346062675700080180133241281272872960000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"),\n        6500 to BigDecimal(\"2129305558457358774235093803359587768962830991256406105568104940872955401362067198411275370245286219661978061639867379312459996902977455882884730086694295544245895241034158601425166571189068784580910292350752400850342187664189581385407566366421806736982505604659740236177893400317012343367291458654610979738939297844888513096738398270877965580219111771363492168043036848652238053131931962369334554075631133379502134479010706762383992201870177718344477794893563268311653791587286610854877855778898603949970006363888605037181795909215801055620419259223381810604162269306253779719024516300592267750457492676590514539517576650395918673293020788497625532148822269425036690553279711425550115952595624130403869727814877457799737389111300181542307917423778017352356213107793823900978323928409423632928782012865969037523123017947508667685477115455619877342628689855848572003680641643696486782903878591745607596241753460099037367356064360835922385150473071456728485802916176852564195858840671077374553117195127403588129640920703658451565542867595879239877884186069517197932055708132217958805804004139360483472660512662710154659684040742201263539349880499700816199345183831608734357788284091516727666451895889308445517902145293504981128707727241110197009779290784325280959859676661767842140104769783108603422981885634079661051280923524570897725982610833686187549319940654026622570277064410178285881515054151623979930395348715500226443641456467601949043167421722626121099906729104272840022235976886825277882287301991998170396521262564784573163954663625755721991056048079139387100809378508869911295820654700994729282129334669596456409344640512266399359981874807667718948758634582902957488365834845104299834733044429159188589861652916711796423838853730777860891086524517384687525900355242399431948148057305933303286973637336514910534816514089240609294407182702630151445225042601123387158808577833716191279756391210955463950622872751419259743327893350123978984277436754364468907405644385565878175551079087763611144684284599471112955373802225373150410883852437867339474540838932581246889850469585407256181481625862613413123186932944585861260361606477831821749453261002881100380352605252622998400336207180684131199143418415904610410054987365173655404382355746160889909905262271803888308751286838587295898433196135163714797263938021509548545050281339879161427152723193385440652712629023860968392096893877968855044967064339878713790952893267750033991301880073230706035829155487234875075957997042908442038375729001670712854244726689726005161915651937711295740227036368399184808730040585627119684591529635610293337876527818155254928513559729181158541454491966313733647440383264126577012267557901612648725250215404886714392125455550430672405684375831695388102584424627002456184331122138185941633084959960706380157567101237283260506499808798761449578515692088389232780139721305284769570150368553398942491337678728595996068918952797563458441950208468386996814453710410338370708069128000362888402114788978780029468564198341755647119261967413432327055799039398264954938791815075384180236699476254448475881021154356417537865560986122613772927355838384798969953151266543539349737286541834247788498455340082162423440239218487483714151490083836092010359533956170413354453890497924308095808040076772966758159773506245100801002855800305008154364511798157690113770026195428046406004317645636055129063590524732977697683838984636951314125473206005164684594592528078009894298027316395292891033453533206176629075456135444332246740612716808773551658578793824462903654250954265125647337070770155019901223856729480908856299416236915862748539734749874126744642648803453564427635267155738769452853364205337217980328594907306569622397634469367718897494516365953332534710544094605822955041026160169463976470769775557957944993734397861299045769420043898930132854292105622718366528018029025332785024785629604468861460309971496434055212228347252078789269829491322242068819396910013182468956336471964939300464585563612561031535131592083894416566914224000969804568441216225337130238330625703953277620891339847173249906545644706814123164007252337666129646266525302761228076738146905051455879987243615840873412375876449616246532705113246051220646039949795466960583154352434445352101943493880595420473823078967032245938104346187392540024293003112763910746232083917115923439203510253402050635401368406902892676896134673223517027790167156533450580826939994270881236921208508815804033149139427741763141535966856023656650071066035314184859104804236622077371560193654027371489541592836903929478332812976478331878531669949101946596705665696424926009555355242132619643132884546982680143854521497334313275795702137645084052307561188560147203183558977524778359954152541642392136922635273569453530907659058859902567570483246928518795852037859578090202288395877687750461859085985785997020388632338042957240101385093104556509790751045108056336894248356387041297511851505465866754968305682212277308814554832461823261288474383933507540946306920878356265147455097235579222835808142299558477304544149013875394772656251062916586477796449981281000240848001178513323264502273643803786894952613712078259927219939365323058720028234914164045322956115815520272780525389173470335220833678915354674195381615608937499011776592057173336318337292939996619816268371620329087997465307621357219022478864886558836578071536711446278776996751035503273138745370002257117476108131823352154143022573358204480394198978276178518559278414053264842087220191572914868112690519698796673832462729430924064808834746272687140181680525214365202502468138060472660638854539125557801801450320541179952497022697441692779471295191990796170145542823989804026115756764214040282721209569747478821903224053014595440858476488858840902502683140200407148709256424284993578319827542444309597218394449168958295128371747312949063118732531650934200182842670695319150864338164217601975530338116316972230562338139035033811975973198866056548452478456973002722002492621101943260629194467205375236042603911150761109163312149900478996348771150296535132697900386557219445129219948612232493101726571200622888661192272017293909976148705545459600672387424323549957792934688304610536009083191124740041701706087152795540182169041002630374159646798097237061008895511894981922900183921264428086240090689547760207958697453406297956710910525149684911543963979948404122959186421579277043727675919743189858882327843604120773139343862874904422356922214483363382150335953668265370402449655749337079897768635145037647090392800550858318857338403626238810967112319007885450468419789683872668779768791749915226535326497565007315866255864576739365909991062804280247703575860697371163791941695371275722305895544171310453456047548373502512067759150298371203128006642521939959177305829148894057634473076212762469875397852037587983333245990589154167134900622226304623909948187954846999545387650045341191577249167826474844066779459073196376663207072609693595479999698749747172181510722365738194852706295076993700543174734694809055074057394697759691084967448517859453061293370230868814815422597466440952915700657787257490133978297597183040688695452973463591472603338131563578460653223497246491440868553310336284310835739518472787845416106249662324350923474746770405619469143588294735742180796928005859268524017168957250269579391945006867379266687633477824961788674784875926385147051123746984117459006051640674705831315993686730150060336157849856004627520045309979832474749270946446546198164905568348780571454895912713625467100457619755849856529538918240442176179912859851377545486810132298806598662845358830143939619270389959820356375195782761839811770766216096567532821388711016935908187232822939188842261464990804426733703274618767224288912269076324178321019611108528200623985198556489517194429299453030435373366843937310319635629601689192242720700132770252684592850241678975808876704958758581750422853399904444270067221440233573740858159995298581218411462701052306950434203514753910644802584307912063019138498296044142319880290849944735098801544269919198413637679988570272746807674763380386914472119897220850748804991830050130480415298446672254590872309472676571268221074354218957514903682750523130812856812876748427835038549224042951251097477216733321687487207426210066923774259037602301283835377317893447992766900468719148627246236993653430536247268305085423370183679001815290487644202038229168584529735216899574577725329175854982441701095596367260290025041189422104743093756647703818149024896768390058130133650056998547611348184399925550545652106403998161087942310753088246308172757231299050690086896396415154130550632502090100291233754875896613999238858739452858313492564959136737340494004670841185632102946142391839406675101441573656508438146645274304158343892009342390269349873964845646737664578290636017010232603468061394153078103157480761562892190625843855950182961943318172438726026592084223354986738100710816907199549959099720161056974627203581159741924893614304119422794669674665995422855877252916270993519607660335147229706086875358592238760413126203723490741260360195677424584970079260952751587475770729737992864243107484237432906131425681952839218325376775129932961849306226189566586394847220075373693046024766505418276167976763506878903768961281535996259037622978253017244823302955912578180499412459351340615514316127129562145191486533801497312589663822350598048923438298724743753746217488798408025929568002949210844740032657381456871532753671529256226869828039594929432856100893881159352846903512669557796027243605316468810852279790768453329915279461379210377337903872251359987992426237059557395593013057747569456554204492762993123822146085315482413833327961156865447664316488099855260035248372901929646847750789153994639669213516873246042383251284336994918582514338268696784715101965622290313565248434692139693910888189857831548240119736489913554450053320406855044640364563306297157996373248766533552799013573655596340780837686779639749271492813757490579092863878698988152010420642794265586060237895191123858581189262322928713787043698053348384419221532209537348488161539036052412646200710376069903859491090946748760016913754180531236265505923476522267177091595005171466731848440094768288364373222399342544398729731109986344337291397596125653884718616553126435128346576711259817052866864349462363778739149838075852522748138562832967562210094488488188006316230923656075815182186385841114600654307952171322879495427815758425021691401656945464055174143473559405483916741437906660280103800847598927201103753249889467133482493814774048179467494737012621609829816708994364017884251548916864060110867651066605118149417890306671021578312076345977281622297142610283166698555664358121301673397128528728472986182239266057683210211937671346126904151277507476662369448987847050287581345424092536752752720371567795652086324032996071044812463490398639522516337352444808290526317558746123482615126098877453924189146593682604409434101388258804211760738812969504009277364206009507485775157501783931631175267076365406913370189655005094168830022401599635323912979022237240045201120155623498958735291002392555824167927960247695954702810569940729460976833507669291337824437476630383798779301552090075426948875718032435246290105782170505240279290117680233805423996013058115494087050385591665137687372891756465263234933373578050009968009256021948482713610885271962343573142078702135005276435275207856395099435218980355365147007037588307901266788132051904963300103027449823854964489644074005499037497553444080769854251817113601823135649710446890113817540022297528087635542981292347516965993313472927735293690813405603042446055359584717902592166561857458788202889910969120152796263053830870464675469924783353108931033683172693304161954613531649693985787139132049984827575021965300004233894626410697992789219036785498804311656072437618071050743219632288526426461915405383946588492041241766594984809301752323210280207416454379774402387111814610874035695820657009587887835875447176679941074953114106636711960400901784161000037074795081811351301992839222063471139176961671385830761750466975225877104042421562798505303653312765022324413252090434169391475534635412567102183062762283873740360438210954091737046950488251860144456269633548422046513202342235523138282512129373863053627935001578270664568818025931659956446271362936482685826618227201776294470174992951329953917864618320494151682314198662152587226902383217295305625768923201421082441157738900642917065237622654585242383303904798484122290111734848658970162298484506540401608635141688780236686273479239585385968648217615912014278641086152616623645365832537911624289104961267711389467185997419538173454653873956198663841904908847238821841189805134809377244094874413642734447971635341434868767443165073506236929731841021865395795115388254511223382787703551918230747546704688103079474543531626982645623905438146633443536437863457557479689501072782625422264891662971364076664027304220542973671776660656416337331520910354887844021086102623883046240345535461625138649738282291186298580371933196904611913681287834230299708094040373710225924027835969355593304008279988975463107034276892319634866194704342430112729702620872523893343156810791495480763270497979143973767878498398676375236887157928024897020574848787324950455620251355887186052986686984125378560739168848762773785564202783277644301252940075485641067548490990946565303499104018426247956421992776808278436748470905038831164376179708849381435176469340562307173792556284639156049236067812531979871397886831742717422082954911776345078119472496597618495257738413320548318547773269371570835403321241665867204450781531586698624948702710472740726495894195527988655836559493673132650266730039966895263741198292841141292844355588910005545941317522584976146928336811033833226554594929805968620033900801270118849340643640492657786945444412897457898226089272323025743793387402731768561276274916947801691419526400289898801099864284683561500501724185898619265294732810930395101729914685609384397460715289535666428844727229616640450136891215428120222059678432635168565715183951596508969602804622543009646866874811812475932030724173263536803849147366315791882426615578015900305031106684910005240481149430822284169368671916346467944732536791791996842479450722184914357011906593210781343206892601274002029415293284332441885365692350040912800986599974014597215978847474075671534075435977665533176071829243737519285293205769429250604171146788925748732612650824020526637493656725748869942030943446004439924614930393192284532530089322578626762121608270156239680481160612962404487691343058741427786870989588912364022819280949942936886259129661582410811741221596211179664394298896361101899224233434971151490815855357629700210740110448894681079979303462278754806410895786177846151380885031857259360985468677020617080447474270053753980697285271530112107367193970583768139057657421217135065042467708849649938470981555691626449487593467861642085713344916786966709635015647551385937499554782278835103643037516256665753349715582175055097126512439321204935004360616072435522976009649196744861653029908131620199011263451526165618368286498704632084493865575722219466758521044929221990704364086257999092658085614655464917054021534121942221382386533343864816308181084851007124846514213699163456020115993658236336080632078012766153944361054522123890766634428463657226302379894137896498276091617841698785522671338033386094861462800865688447974636480270636682985506271811370157004341937664064435184409290549440726225411598868685046572218856975258711042623445584441930372292815027234129116985236024888906819269274289816065680243369210160268265457912132493493651609803721313367791579276491127166531608162481352364510876413837945255194596979204173738774650339920884788416535148884585580205966866630721971128686191951520539958218572339983583362426934606964008413007876922284487494298925518456737288336205916048288449095082322259101137757297579182332498957792226900290315662356372885832342805496553414698406624988731506139467390318772252529300725991993910848163243963925080343577570229970593163032880600478999950604433476701769548827089198617939341817348271957770429132009410575941793910027404059688788300266013620286820730749451013630548977340159333038959783520205846670623215551129397839872030777531987629940514744054239682305464313483851915210075857099033757034119904029370439893003513713146170493015460505665177655850416726406632287645677320639367645828731137289018760161321059605741781354731953828077318758500432227966141490563791494407704725330448637313429309370630693732039139284717654437622709530587548179745579276771911090989384351698773933950662041430118544028060764378455765398081726352747949911062108987045984496359272613215879860443021803114018112794105164559587417961561574475536075620930387299921647346490847884074695377718672209565069453586507272792999741225246275723222953742199904748681437894030641486590675146695267096299340619159544333487276860594763467209851302564657292290275762889772637382242239590014425929501309366682002860398462370474893273866333356101383110339373486393072346272139951681087895627881296901254242645866807404973995520031273265740811889275212637336862461370661912975524069781800513504878675848224886485381545124425550119549191003557895989015627308526418749849778130873867173620985435165775967017353560817046830906020311159434898121794652886056783645089177447858795420855555968970698853058728363486018025373827845089180337931632193063251768741024716489162698629140906069085018173272443794248125128496305169842787595624779106108424903741946291952709666440231955874629279183174946765079884847091648774627843031354980224239150739437908991562844932426668388704407205954318334877807431742483800248241276447222441287596972649600899224566481824758475412636410396097011818895484335486583502457356972977210470067971762984442650370814806387294204428048130934231834849752989145093390009202006457712843758460046178168747205422449287528220798109181526120239255213919275712834246358564498098616146686889667281613015014233180889358429658675880911346650107312594854152561184758378136389024197682184956327773925230075482922360722113527640314210451987257250366759398296189028085752303247216584386645289098281600701100697900030044926496224894282722123707280803761196733968627729224719223402789097418681623827299653142464818818710270627415805988443303444194763641533107502312810775175898101676801562533836127465861817854789123809980663523819756486174129543294592524563888434627131125150303336163228126161939523960895927407412182622404089015730562092227350587312653842170799649127407587889360357081364901883624512225302039313499923287928575248704218071857844198361355492352641427842413112480099520728802061735876988962058191451169862878927268133784389765489684970446820375054109883120469116180127554805207384021678939105982566468879299014963028345607402449044155506396155617734609734237459551091387272052136981727669048525169285717626674274503160370848944540633713904185882590898638124138235377077855841877279795729961947392078010018049627597996949827808877933382966833061730478185890349768257800697819979407768135579305070856270703181130054083934169860809875836736815957513156221537147620447870274650173915291428127900116659525827593033436229003900851390886740570672234861607519812614027947097734687326343544143171392095059609801880550096274401060578618089399160572253243493315255273342923076589136306054683826233318671441992508350690889827829097041561121533655968742759495182992043684701612475149590249850340326032174692693901800001252291870452880578078864587069000421934247968806544012723689563622975932685328552795443628698909395627708582551470979912902950414779162943895264453590423126949531308720210344617105246546260726641430887109858547858789742721502611367377214367438563657399290529881495708043173993760382983695418816069581396763125214338170049103075284464316551908829186517773001611120390440055536878070494106952268178491419340630345496869549915453649044626628797437893878239711788129665453696706808545573422745487909394642327227468975245780158137852322582801253343465547926402273146093509155682338186687919284255967601340542685516405510767470733226370452439140196440345427206414373878837611090118210408545998327303170103534376045330967952813572254850793448167824481798262251242704137507743749938976342448137937449383023904610023465555790438496129585932951722649385682854656728220446058229574076989440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"),\n        7000 to BigDecimal(\"8842007956963112247864993696897726515146668063888148614063859617175175754725158649547982070366735592564635779100693064454178170961165752167765531817139213752103794651539384390492636168838534846437298449406744756476508706043448242696421599161649582730137919744173960058745503156484236750681100551779049914848885650142637380063005458258029028181186529979826345217904875468785904316332265112387938639672254223533573193327210944965539025610945034395680899103907477208996101593045865114444196767132235742754582381003526477608451190796731555803362142602285756979937545243909457235874042110187883785273337882048580752640943965904045132851304920226173796679153992666480387236959191001668175647982690528811969387561291151514484716897379863560430488762024469208016520576844153800946547443547988444323673929979976425681778548000318465404733311398456692655883988018153215141483857339738890618563250737385855609985481858844431849430640044987314360206602852182563396473431341949326406990788042014146528986829611680020927770551645063937236393875523763882980698155834877885570464834887214403527613806603874035035842378811567543978436182416081255413171254955699983155919253892606545822094514369667806088854682965864846929015090559171012066420663809079279792972532271398769231017290400982361484308650813321962806458341044422281378610879469201234982769525322942300103063592007385662470399869873889322027588175767436845753111326351331375771824892602713670158430550410057726579046329970102843722345639407168583975567752007205506131110761110861356294292674808600572426981882015788994401461260659121671568622152868090271415816338563094882579211416763856973775592629908794628457052517710417120267481696217048902118115125605882488633885970460765348819872115584507468587241235694364474351592396233305833293632083248628644761405430111558758624035958582096670821062268201536940251875722431910866217530509249522090384629909059019727808549978649211796834037499155277345140383958733236579130264058169024644076078187735460888179089736898177406096448784487616097333930802197031790251162361409283284240601000295120768995192920580120152200259199246677059479621282511313316843181735056691183920273117611317112801980061951294385675181292331418681345227295964218912032304207123457253381142044752764791607747614221937274986120855600184517668312822490435076081691295863552215293513572301503852263294858892127294771294822729411748696675194436857982470777255694243051477901244805500830053137014008164400182344143596348584227596152052211574462519515535403270714238652416208509658061435002706298770494619767814978821366569002196288208378908693257956280092472411189962114278221936023989601788776938997557080304634260416434749989494355295058878635663769058501600260317367047665159594987503133823850560492216858748919262953169998314444590379209501535394692690658432871437861942633645638637138091381848717515750505444423488345113481084886974445898178890195975816126246915618498528079320848558421401821469856620426217343200432831040792604352164356484715310662108947471696692557909184823897498276569113569949755034629352092582279466530840152019262346749107273406212748708093568968586045553827091900900861887263842037884945420014371577245917129570378021232830046487903874044753310855219828245628085113873321275455272470433588383735394846636383604600473850069215837869293905982564295863846812779186900468275169367750371895523520226600290613003458993439142012174628044624611290312013258917283927021650438369208310266411796053502624775891072063018657046624869132893320446218568972657910998268776774395737926198284857511418598112020655695096411472891389500274800422429847267050507394386121944962297412886796095062227806879431705939009075863264057381993663953114101557360914958870016279029688196656773837860632794556200126637298379109602404798818442575847973492506331882145603107582106413695437539880836193014800253379822738014794915699821130249628149281436638565551908697126344507019279823765912491697621497302172417880934214987528715743450659793778804600497400584893293844663778329880087625383573916035873157302339738234257081911794709860677947013122214682749333403201976889693678084593155060187502388418594359414885973480331335534606175208197985019466022346755516750458368739823148921958404711266305635524457671282178245724228998100419228433521229716515613544038873782447633761330637156923679960869608573936927659682507718825770333947034126371922516944152252362083875868600924386764597718318182090480102290713119675545551643468533248755319990451701820058519326755032637656406914555970848386839956873547286705839189039814125964627482830929340651309314551660258298763791714811598562127907422291452195841044997796769983502566328438661824613428635077462458711668458709025671303283934715061424258099218542654112369509099772366269879369176380284082324820182955255688669845779043072338339536998003660818964719037885171177238929800353649662420713130211916209142489285453451105601980100872861113799550022103984273760999241052905774946164745487508285126538180261587268121834611622425013386195174699693073737629643895744807365329080259010601575969326329903210733144456032166204932138209427032647629649123619921157625969382371617974490459448436163362030698687247681206945367116937169167296358437817597527700432353937561546113024655435889597887204261937443656307072063236307889796600213047518289195405889446912318445469973847024469858005371965345728196768394306557150364496640059288072753899298366397532079263921876147551816820494105077792995685458506470571277610222300983409909667197632059627713914622540647221860481906463532385030847241918734752936048650745172841749460072620360204757629270589581110119970074345641749593655376972375702154402470375543371274882095123401020372911660045621841753203920568971306384963460682795141387452657134925253315363714572752387955510621439183525338047972181476683295477447576141011732423681010390229919962653364511549798609032752484505186563916391161167858306521674510768045222882362961469344625788320072376478678862132150450515281860087274445411519618647777050918856992270739775598294529375612661136680456187611891522664755381553044168817376752714719426093162756061572458041836294049654591592412925945677095920377387910800592917962615135589892143406097194862888638612226221607212795649691727901443921062398798491651582363771337866628214150609547476905292032766180527006210218562107726705655294522769166693405409784447807841980380520647455130773843989329917896404982086822794993035403290168615629581444217769679556045109873117376252867255073205919462234696007663906298962209329959805413934437140697480425099640763608017915540368053201237694819804102420946954806391582775602861591944892575946406039364587789445108787873135533375100417108793007636424646045581906792352748202787840636921616892624656636644487435407408294398420039271300035224122052470538167655367651436397606778816209059946503448080658456061421692012489174331210572234357126539792750645878634516899369304733276327577979324540378129811923518915129397993734786296667634253871125180483597971910932030897131353550045669988369405972212725497973424888275603687611577906074704902699724353321155313123456090870287756924857081031037126914705556280841379500440645762818583293085216736204259467989654172750621933739504797635183465849904565860335010409483850498461100224648287711109625346067241439286586246931112640332304279552304980859585427459247513356912940253530890140401845499439913711289687438143819406607305545360731656328994007731917706468934069016715102915878838388887343905164662717825178185623887434809345456647266313478367736152637862569959297383572462071213613206820767118695060174516019329837431837396085008807497031854638696147400056679336043313314531173593111272220465824177480090454905892729285633009196785256660078156295158730147765804596494310454815911086383366730799118079056670406720517828380860565501996816985809809259882618671255864501179375339735017158528579896499464395836899496310479879811792249949620173091138228854717637573439749597589905561316418695369388564112128235759823135603626423435028930771266769063098087199197953342530828107580425113911784642768662343982428347496384308615476027289689975161561368341451576970998980118486666356074258479747949436520306808734340120012644404535406326793221839131363837589328822437786440954000915916913826758142203491149568205941758687732786820063215506321663803259271407420979270414726640159850458401223832637877828728575585847078974319153681146579450730914086583154675083441064558537512243113986882494551167315378710589133362110807667261797859227314924435584761643523077008201981896036591171491157472768958092393197445840693400845907432512551336975554223570164273637043212034969852788812989539526676062117671849316905168504661290515042356889868895746686930270069254020687929392853892406251553600871064117890361962767532778730157952534428432978606703698373004647474795024526619530564958604679431657922772240120825721074089342298403799640713709403875020834103832312470387088784084345863171276641962719063344846610252396351578331508106381171235011419445491052453538405984003924044308581111866591871408310071132913199851771662251486081720435217044696705582813615351360235808844668829213080886663665783526706039279283630860103842405954890467324933808950065590146178234743148560580828057661676254229650448955510421552653232820634578111988805720691675041497237896230024544476710225315967181199647094405246948842156350033908521579509770461962421713022517471168553650583627021101997073312094880208842388234622344395861379186284607758580868314219014570775024127006827333813621308663524932597472050120426064449203238065131899050585568906611650474672449058221757674356431365393740764260505354626189401639735433438258042806139878149564416743303774459553478963829645153251859893832181564277778561576024909771529303092937492005228737458904622702047905225725745924759265173791063965860533905455284528561949242546209826314415743767254553264661686211075508774121548453589969572749197766058576609631846279395804131175468948871800826599061320069240094169583748014872660702435901820051902406230628013059730956744434251949510616806025548818172719729659930276217684164614526016875741127404348765963689163830620494709216022380453485600160405524490642402632025410484747137235386732652232752236177609174138885261771162912046713108018305709447678461754430673358853665803322370749018996725646355545033156494379740474960866423275910545764660790879011617007175611203785213222820552261648337998653447296736065109953347769865897998866653745457948159026423098446820451198009607350775408599145914089630194175726752197736126519106059735030310875429352578381472862363295860258036019033610267279559291831556149561100335068317590357697220476907897906381158855811082243209785002555423176805724340538974305628898639938045062180815083139963414156732856757219026540986108730855979009922905206263189907209412329125650648053090080845774924906128708722967267739207112115056429530787422668241520181252130458960198339731051989906389910044265380722261892417493307023953377643743380009353131780726096115941073384803736335759673140183558853440828446700906145095389715678518257037878923428333454374493739022355020021677316074568899462118915462007288010275939191507913745615737385554523389546276528026337012314807043775526231634766169857229649515693956808883587670323834113790884960824807694923198082678108278625853678908247262243367429609503272599790030374638799248889278203345697674373085629085582670969247115293337241160622736642006586798040218177670639088747762351402878671296759360410473233115043811253528198352427411887427398569327188420013688757802276094081448396878018298577826122723235489507636268929512139275147351121739616643606381808260599808283592605824248970210573925510317120194402208191725398016973923036545362032844566446276550220518334282238252939000062857760651722517037755260453217678507731303348064380195355351189926604551120374208515258481644746254865921828394497652830208456401972049585497195890436501382796841210603823370495053178433592393713631712625607812398685788471522674869077512718342330349433914471443700610365494010605485056022769700562471842481180425793626844559012718514981436519670301189557246200987832284704855457887038730287978485590415989820295935001082470691301462412286057510367429857112021232107983042585660282403002471004039927396247770627310502368928834839108127100127591466536370475614801184392200060095727565270790829802012792590459606121469700382786877588504653040427124444269188372086785932043601903833256700840591967506326984102657830542883323241794915890949017033053538293704497424423206603813727956121729287303747148983832915146139090032854229974673499651406991923992843184532551801338927616322679905071007320992480345431992509023269288028937327288336810606104571724062847020363685911491186485619927226414304629058490723221909730246947119366605050872059908029229434652500377193162921569451468509043519811226839240938989605831100183071279744606024687572550415766945510654206393227193414824888870858695909465092668088550874015506278791838017368713964039921215040330152033737692197580015792692015683151829354073994472332531306869062421067869746642085375479344299958792387236753048663675344819567340017562889064789782603230186734381727040963239371235985743665795714601298322286889968420313318929363282436487174116593566382545284159176096231857032644823701156827188286293820000588886928515388995731487420885393777056327260015900246440709859850101782311937996535049626858978666326747580205014732235035876026218211232658316944683112399217799624938866678425551889658970236463502077554923179280795897003594575270071423531714148238356971302777605133052270554682471403821946433782133389235174654038757623139890591741106212329134382553613317016760724878525836643211954199824202925828980153819911619492351326913909012230654367009862825763818272395576036940037966861445984833349910599601206139205599897703926738691824255744161531312519925753916504756146657117949653821277358370385017782325242837879125827879620018276625966127984565084705897974704909163683495829491717555528804388015538020635445294733092541715540712243367579782442568701233714558304190838924169752746151512514017503691268326526031096968761427581051636107236218435366175901191486666572086323442175661147177744145557869686147692970984423431321012842666564856803397408302432517594767756481793767846879783632253080360112527761565940301824955421028197824603971606483808303852187627299919036414170094736838666458138093112178647803770483543402720555724672085615330318252121037302989006383293139974703869616780677108950503206737311925239572837634982963031862607920370946753055655823047228051579561925934195035375959471729338211006764404260454744882372595183979521150395869780988176903633447944372420415634316176392732535684677530587308640227319154181384905277981743353957927089759832286345937464366371816072922410307580994569048129860914064559145606238486593401308065504095231337173885985667109232722556096660067523258702867306771208668072414736143322096311873018314753143211719636207027587553113045684216013603057103425495751717631576533789853818717848928256926314476193311450257802685877968616780446657057311630912756542543000128156922299988836871646089142722770381794497615799721154816130335181005212666870960823502062657033550807131971798414171093380714278658430126450363602443601852800339030173061328728508815355311917814848306527390616763921359714469206688863755779000652416935493342139253265711965234773055006806651265376387383080900707657250201503873476332533626992067931801675040955619957918670860919566754959324283307488715597661837315485713226227634796652941210790519096927232367464636695739466558653091439470403618978318245245014032832372575779874721440304993624845957742689575091186801285806103804078547869563525581490497429827237572068489266813323244873593654146034708436716158509367521941420769451899453718871396641253405191728810591144060940208163590797006472448183361830642174534696354536239004672991764502065294331885320999026150879555259072669002049626712576091101480392688889497034559584620170654396275788885805937276773412250869306936120594669210689961158075882659889987934746451132788812283175647868236562529818639465472990070489382491149735486131735594584348551368857543032292336404546877793610120890690896598253055033721337723833810783501729729101103073656135268574009579240644996897181681846276823196412672704134870990545152362095118408854767031519179986602744766530722971358631785423695307919242153327602697445128796472631329222205540940459825832363180368446128210863403024962298932846963424807491118149782324581088374162105912409998414005885818753787030710258834172044652642868373235718297618517009368271902305917975269964086599524482063419752022378552996861488101534489622788987234532346160220546871768580739172280409514979530643522846459162463631651133534276299863755493301165882552919926688001500492480138360931648163112217816099215109900204560565798355825095250870134876718920867070281404081425524783641117898210252772104396203239216831126172277297473487026393738007538368287982810020334185637086168175869654397729419226186227097460322175997227525379873684182241588831514100405171632451724964534357163485352132872684310165383240239049326101273657010810922730272486366883238826552891884412352243859177583541190066501978273419774750409901265967018588007958553076711632261981614625247201186570453449290104270982894306595886088830020406122018186436888682146678376648455847150607512900244124113157707089780004805812292396307480052961604675260531558884311612101369685338016932998773005455285740235427524352649646085168908964618075111729714647185367199093686381724855918123737582800678016283139105611441264309914490354454979042514799965509590264458199057434664384884514973338721948228424379983973972932798123399187126221984463214805241861782545990725355678116024504274478404577009622438882234020320364136749640979388235357861691472231989715687034921481279441054865409631489165041260721141702703986408187582127358145352577159087898554729658433487025204297868124382699849588234048916631307295531741903186183692448056209260567267931644941714580055660736679212252780322738261531612884996229263094934855214126627710738102612667104256352069511352239938211172511381920046031038771399811320758298159964394185855115310002207043012325625007270591174389263486571646606875430317714864454680275406144363207923935001275388215590920610700669931440132167224681157126546481839502287808784289966590177994634972542152849536332377358475412617143270336040960423566900109253285428622070862698305008908589677590131609018977263682696316200643778843161735099829740156501879731589681401567397335933486069095940474328299667412623359974027939434951348927750773853681668019069399406781666625332617457302397083389666057886457808998619395393566263556139308323102093486249806689444231779495151012819518344532257625430709831394295201770268450908118975365461895662669733434966259208685943529606557683652277828513050767665902236938170346206456130134138099500885388303539848485203891162641023175078504223835115948176979758943124213999035625054973959504353300770935372427838157664000044653540547828547532022784160093071994927448523304593899163245416824410973609519343210127500332877628050096483671050527705522536034100561848103480483996335716818909945346925169328487950159610999747607551344198102121142088360726479601656367862097657327563455396637196986555508541448192208751591270941291159097576872227102181516156966731212168210693375028192325704448378188841343502357081442828839426106419439348617060865469631902955774783849219824005183982974689284291941589065021319296582424045567925701038356169877224902920340486187458299591893240464750520691144485979022776425270208743797951386390199123936558173241632222488944261745402847894473976555350081432144866614637857554591633279934514853661464493987403205997397458369692846605597944248742724403978104973858531241060728950882595408820363395882436673454787853920301339249229909950171481442050639388410869597533259021500918455874863567839045663976416550670334786311490741901605722314907216319854101770862782137046399123250504134667048450235296155155532642929688938862525609520042526186890874372174864406092800348005291475191366197355754323963642245066272789903719673247631899030917848880372932922997891885337201170125615208433293006570268471793133047152162269773600855259182812268381714257773480874338784766470396928127076195131845684020898459540348264882218260268361992767624802415559216416749912676824168086656742582578749840821037923616040451639582694473651403606828181407325128265288487073849511804960076604842288378815705692213410491992226122252021671854567736540725288480768171418912859397923681577360867062407113694488534144972062751589549376557718365210148420852186107436395121338364519129770959647257915550868182766324827628806648160273671305559728510106052070366994319397187107942866241450427154345178753694943373593305589208411575170551616986686312197944530777574773269089363327846664716222143774108498095518030396934886290747534528476719126081622432202775848309958506247059781647350681229754569611833183329495250354022483640430199023657687862947271378635608442934014868419699609344423172372010707286132922086898815551088470743069762511629038927558915846369896769896518887810618564111049567558758257755443696864200777528280925377230604811804584120433095001773186736519137285568151745093016404227135682008633765652528370550116690728224132751799957431390657839629977713722427054267728901874756795186779132521352842928522861848510834797677608452733797108927445053436823143164037887223448288665802701402638341041319796484158181479455910768706723755753840006093434900133133971334216022080041821343994592664967160869528906276828647971887128267347011231166437095521448821423587061476663501326128146101174347401691870497131547536408286740644172308641800349628039977509438629006224673218460637862511635092031244066549970562889597183158320132317025413304880693015158191541630195665087816334676815514083163649442676987193953772545057668586006975603047679171867429717691058434006387190296527571830707967726165877262012390067609824498873411211946558971925135310993752064000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"),\n        7500 to BigDecimal(\"122316925051804770559455145536350220679541970696039184924104672633645962024328223806987817360628334865833084548622032141980240069420362568982193651813677777891478028483192992848986951865540969766283810478420100668581061165055408810648953470196140550934830276210269667220621299823353251139703360648892117015298060828309820496494873461658419453012155651530626585238932635537110627801754758108725412479935331576763011693652060417487815902549452295682634852639030500829697194516440448104689645977626962343168157112621653828741842070970407433347373179324160439004200802793479221589576910750502668035551553917077759163110214993075266327942236737739714794186757240833409397366169829368678505555470603461494132457111505374690579818465782114864411672332024709177861669707248281450621501093456646414991990351359557758423408007601110954116096416364827838845274853582842053396697316332991179147022483529976491049549809907236375686968657438941781487320143912179574813197256207258368535116063335815365126259644127034615845252971912296452737130397020294222109312419178277656143352772021303113370610835742891260999971809364879483489624943532420791093977285292181987636545694922134429080013928239443506876631302189495557670312343483386063442273353100373100391528837942643557044817643102742305931757685639859875527813520135314220858203436840043707419685328239833625194021922868610631681665396467849600157218419067976375760473347003031597968270710246547459695542027964156948962787137326408183007899580692937851553293388666735505917666882219646323978292122850788707039007842726480544221792754883221403725254060681455137121240624991781662254309174790941380058925638778812116400570595237946738619300444738201591113566944603272027054566548943008442964381810684678496479186680777653178879006951293516894763719752490317462530535954084220612041776548096522387310928304502025043522513498442506068475834403357948178149015377439580987666781940129816981262172178704341729290474186123870428161369416900639087739130266523780527305834063514141716409852696391948171660696357559229805753685701479958776652438334439668487068909179087748518282338167781523900441980973985020546412811143549921084830876987794319818912900820399970887262501954446143250375111095363143347977367900986673703506214648932564110214476449633884892302745329656982692812697572396640283859626221500867011017134740623916425285381995716231590439329227697284490162310837254980993389089915187892982441585945743608927618899564098939388174645905608959311123948046053981555594573243640633626717295509036522120108459101688022412231372431046323424426575554178106394540662126509142637994657669714901700421055726463122945802522844694355855147288702035023367361759459565688557421963879253055643659866186703685257116307102802785126000736269193184393610716104242008461464210470275936095259919531713979404654200809739057644286233824187629012563172839885855151796368169446449543132936131987948085263498317499286671517854942213446986165079685224484894689900535050147756330159749906970110947073480366001782867833638092091251765150918936168836658243291904313694238375460225747494965107410023635736499013574352603553346709745917034340479542492075887759918445711072739374790068897967531708098409510978896674310963161040609339733479410726734196204038433257658787816520480174406776497077650233308847133542171607131461841619185578790556862827529738101904108645089802909506200562444083065282803030810523037760171356394943008479280730185643235241154743148506907290794445448773625936336697174337994592041516771509159403849325404657139547307624326051892082671426705203586104780137834704694377868996753993781083067337988079723419702503952231367260549010087262008404367616236805775382849159543654957248378189209083106808844121708327988509136983073421448416822005719970032740296995957017197305541876495920765373613488123477309114607023673199236870737848800753368613106992553584969386245427680517870275885506352770665802685243905112762879823717756823162918048286340923609470762602491678846669469334362135832556299318378215605645803168929327911504976728176716849822205771280586232827013253308981745362004411588992741778832915667294954734777475688706472644168559902961951966327488171082400926806778431858253452621609573744287774939433842498460856662923929461311619304426579548441869936020640840452802180501887888066453032000389554580210305493280685605130088053657451855973131408228587079498133658372593384159856096530935925260247930761236841605484560406963931422468872468664053791030793884499899118586673026692234964341498807327535377704627864449267636970486809526559669306587407944119648137653087168283106705413776464901752841827760029627012120832498848436564149759385526374815546477541399724516523582679339373902069395142371114665142166854667760827448822518024792184456832339726355084049496784534272322589257218136304310791705738879628059137368146754676695494546422750945230051670184003849466702402013463214846307786656713568828357643955681132705134350704422564613400628543794754893969573096480235378233304628249900711011281920052618223027884817860333281276960887411673880074372975444531068727181514749302494918154965964202593706913309470945987071917245303821331680053121609311125498149172948029943593630601177143533896720651700732956560571058968715027300911991272913104697580325529017043098205245478015992436320039444131564578404879031495569973716482823025622275235749849229021411776985025802800072077288745907726084284043284734416576126316608407436616154059547355432650953093409971079596139383501301420280883304928600141468964650531805657195559261536260526472827585803323317539741732791253846457007005307725233887688228609928956611000143172042657878874425587123254006123435338297103573415011644575317319879504810559424419442998900086705032720503719522496203664677842163331681786750207449526873896743910245772281640717582933686549815776808416199426967716715967422201888970020708731761228880418861968676165469201220089333996753175314528792398327731543454591879163175741808571143257994207695676880612232126784384791826313849955745390167123164936492440413757712047189872975227556406281422379291304496395376707709685780623656549215005938472684085684475607204663419361884340344975795213613010862264804216791875001990149173664900812651151719194171162298912913074396109053331772229742635295228379403667531188499350658848798267481554474535213419219979652118249693538657339626893295521988651345914208084321267147544070949540163216646020707228629297287366188099240982805458894296353811504761373918123782919705386348150164961972838819914492567067835009007358598845990966014209245872387348386159510180219322602390570948579233532526253544419277386872246581960480032416109198829748890003640758725416184575130206898562312152784196797271541453420880453382928644020431486752781235372025912028729695439015087853716107865770242170628662614960110125953283218716667865493158935515890027469998850278848964269523540410684162187966940699695925007010464475964672759218163086110958225285564429125335388711624645825362555968085281085649194494140978380471157881321840179259530701268389546494652924347735135131690104587570219381360115435246329595498519987958331153671114826471219239698986228706768830629695067404295611892137149945161735084294933121530514164812298644024422655896441034879631813937455294765509751190925846076169630349628971205386024381609865154650585629529016419532823999570778373335066736004147574717449660147452670336521362929842153054273935545014574388976639097607639825352681283927079622575399985721662256913670738666886384221317954073214362035100567131023775548891235010247974913205412587604943115096064202282870145438037041274017013890985040820237390201514045695175608230547590117160945784301299129067488105184879792651202161981719566197950904687991055426909223980043548030591267563453000878783511827798491747110949888879922131810957153735125499427179855893435037710244681069582646333056079632011237765162916441626474400020201984557043863331731556149137658290807686517624983553826832034633513369794836136547207732966157530317816801315226454160916327406373947517973933637602606093147800626398668144269965498716769206885039379815141113654161989300254525786826304641187733530041349245435544435897886248205409109562453454991932096117340288613100032761036031475903173584083259408167716457820688472917180027163063898026549042895029523505068456924680923084824294126951994301676703202026251502195642882944907952379965837814482803525690815083382931160071262871659672654668435459147950881572219978211241988722075943968250825245119580602293327635420306649495992536707159688162816513324373771556344651741989376393022252705230204121072986694893361681682136995517376485397924443333542309520744132729197056858676890615357336649907051408439872003983236503809036051395019661243540534232627672820502107258253809452599011900991016734212481937333164425709590667016548846766059301120952856594733455275610634011313808723842161236407703894084305246974404057708217869696359720433497704050064869186584174190025001516039423647341682300031896732374903654968870853590653389377054107809403283722972921850358739466025853375897550525456768631398936229656217426268760774018369681674842640805379256876315231806980387249087410281273014499625769870577642568615619197954544449598468286152325879520558208661517846062862268067160753070388567283606828944871261036570597540998046179310802761946191267231970276053873768382591354785410070021455422363944265552589566872828167865980313150511025514718126673528543810704564922010810469110076921938340541891030622124100652844011533503641074157556425458023349393041748153968733265938299487091287930477018906728220930785776539983003985766392955757362191332151885731714045041024650913106590336977218516271822896719068525370643861263151142741276963260783806728922355249774557339116035249866356367756568540991580051983779005291388496857398666702769288131895979477924570581453111680327888742981712727394141208596300726882976922735912771008919495608147556590561153247111584631162841412561198085498120880925821952102164813249913828371604268580574085187171830784480356220662098759294856782670041675572963721862650402205725132357962974430350450859809186883987550221158536717294350914766141213741072604845780718464226582757408878647292566502302288888810420001976755575458058780524335207200087271452725011000400731634598700806637525955448096965199577175697512732298273320910086894254631915867567734885906008635760229581071824736421347887384148808327710331747581910764648812031815364483322400513995375766950152595969902894228667552013035624142584656786137820371126455929788262156001904168356671312230291708931595864153345031999487049219116385642127113945740739324238617559072174447178247422762836099041120094949006643642455341923468418227884673789829159819310443026491563732738969636274836449978733595163303629299478670303778656836411996264899748729413521709417026028400121986377727107885716844573393596393614223002990377680292058300325417314842726729384675427586102337081470048199283807226326476267247693460107684392047736405311727005728523865996783891004902233418097145923036193241092843256476643358723406348343383279317008473249302822605941997518705978863349324758587483660381017948450522798974454987275194385385618735070716166778333544541335571780986649880447699494146055447838760953302527357054327937849527657090427682158091306129092537869521317191030191843035438994919841284410541628706251527445267334739794029573107952028295702611187956732854824209761254614424525100565777888435739376095518875389241224050828282509070386559818712490136133731048545135578101453732840466792485817571360898304145234558473839043704164613444424369306941241204403975854556752257659011187452775858235999941531384603684436174253683461081274914393140825273086321008153713721013106553530786681086881617821390490568859532115462181140035481653237976356230931440535740602852820764307983522473802321575954712764708163788077060010714115774002867217251752697954805746872610771273681707348936584727393191156282516433299916111170916141788275044878959422895448653839681114595201649686125351206049793245341158305239558159918034464786781613855085242751898320694996250888793713671723216327059812997550080181308185005529402075025679991837692654212332494107040629824142688942008716871818970651313381405375941602000417512244246257005055482036964878858665061189215572340181775184939483518056414102075548052196074184846216165143483824148470454457883730365625234644976406193528765768427755558049780553066551247581201988592195710472599980047629152604059553365515624673234996231852895079486298121010972035305522912695768333584162210464055293942957278021841550783719683754725299212278865409538810301765711450215977018198420413557921156042213260086759232501927867319862784910638572430752252050909639743994664855365901924538477839791124334106333656701779130889804977313849309217557262891916303430941891498232910509164960134739059289345564653728883494885036991978308255580021979470424477744895205214100066619236771416132496842645552169111253148893090630580417135910984058611998827128819914236421671418773616091129651556973576932322136166624577149609859290728658569281497433941026078370607445993714578254528062909444769766730345464604442791290422773423382949720083633301089646505794665043697512192789042154727196525533349779283645573118207552413271018865270498194392047669795925506536174881330183332620637777138514902590700433275514702140135259131369208150271215832908637742992508833079492169114578581499818580082523614580051766154148653036823711822622603768920302092305640463902158852435506050891447350392919282113528867714951413084047132600434745760762916143988382859619166130716082539823474106728533077255929295543290305242401441523910256770312447361794763411992272265228131149868130068282280986453690522297184490193027757763830249340995735228790523083537780130525117471016505980810277666603981807076288699274056272663864165589356625640835850661969608189133197455698673525407648236106375128329800263218179697912184659326389772855668234787188241500121591018881452446475887624689508334047908823166702870201054197166797914278939683417641636133710319331898953597865584698802548707288704814492386108983925759374827650512850722936589750368336942216566874121241398767864116457847008031580473381545691369823750544165164889408319480855412368558091681711973833576879516696755123238160163712803282199567169569249475155903520781591186135803056582477216928519711872899260348528598293668362041169835552223577397649998836929514862137499087514726353001732878656806656459652178472725644560679687911246335923161762984392480119430428212679846280595609443458023703546604205813445837396966837997256001492603451389932657618340441180232490312244212660191019663618104918178644489945853919989113309492884117302390285833032301373520481797296220290233370434189589132801052214221043240433958821479439301218784032737016195002223007214964246103750051034167783153684796718696377268141731888644447030124263381369415400670575473653113698466974274273351105878063990936862123070198726671229526705114369770029959861818113841628753217683149895905041262845978434775461201005460259390957328951972469493890706600090034473107455620073106003524896969647675883292448679932820664184994757310581244827080828769791466308786015918919826787356628404652897823396492463724831532060768537166882514105228659480048153149330406283610054045179192631521102369046693348435879927508454119455593622813769012133748516148962274555464506172218848013853083308675371437868086259226831783573637874312373896623295779042425945673149379259646879180278418636168591508356794512283690726832563637807756258281418730175454264999171934959192604705708928596105877411516381994118739835768338965546489660559832169083538708579572471173711093730646988981218696810899954952574545163806073567546929824053403328174970500676987704926199778253660746381782604680440314596262137823331461791125154818250050446753295920369619256906218781928415737541365850344340070949656633239447169760573778416244681825637077969298913268967924047897418422984779964569269813145544068533009693283895569476867846204890590847326110720993015588265087231405233933951653116950394166167943052417136789154352682296097630634358813744103184704372123640508080775010052000463879519318670384410550641661426364710351433097365476394926158802389961532751293434472530480550550667764607810060737970145893714736159506528480540928864450457578872422388801180179917482682068668103559758825374553366173332300841229205014008500053139069326693221695804870255551619372037435905550312542058983805596458759697049739491680381953939579268023897171038255728001518904549379276118099268109312537322550440395099657248353574526141943644877373936347975153365955508307768586455752564156546012542533661887463862546842156543588035730328656660608165966076812828112789363098385093945783704215129922226967437872606689953137803942980804585310288049249461526180742968270116616519694818913578174401184404682088632983733669577340982573584444397627579108063233564589874732703194541922348287993404962423707252673743796630942433122034169156933061315842600194670225474983983624283635280874053972408008929446834874875537588889956492053433572355134573943453315212014480016086989568794927395075819202852689352133058398053328292693575806325243809011465059021418557778507982448385729805895880282972448002247640233723542619175630477906610387064420470962830728152117658990640953289632196861877258174270265803235651740430828689694270783217772311782263117190037322555874624598650884752109172986899024596076920159932294855990895197990423706160401657816339175831632532696852501275762567075563358031012453994883091204573481391519490079909014993536541015987174691626876897677927014751633878612959067507352462144418107249191916524694684674717899450821520964036243816590556876087225962980210089773410005923096704505753467665352236012021838689607571949661175717354994375101837358323044736523372226142313118119536137644839795819167259589622036688621603283603229468308189722196469592766450609395614552705192529286351908484897829116222923523241928115537641102258217494439968260788335642317279816130219088575514809535377721315121462156162403058358471469467926140126838692926318912679464038913978263338475992249493146129570044378377285401722137610559119935733848569541059042630380576826170701265713596832291037781457348660936744847065097913379764063226722158157402140829938474844355004445392665001005433446887630636024650870363639384991946975703596457940067453409372183884655032660478737612708284508047793396880644920378368934080864059656029449053380157301665202213699493749599925942263947862466227361993871700386272764336107537586798123551475371375854086136441434692760885989835902904463936025771941040145480964735861622836168139933519555184053030292627368775616912810362617773051385970783408538204207002516593561513497171201169109444110048581292662348978568404067432862527791197998933002622542190053937428896137350951365702135534860854337992425727403610880747915487926618745701162694663902084240345130707132785469214087955773410278595129442306414293630263667431996206038198929962977987632216634041214734309265140290291794172910488714781435866907436498745035104290703513551587864781617591386190430705452166783992025127173807504174592907544210390276046467075375410561490342855425414466239727935750679966074094273961577503003833975267633617748909370639977176752863153264235463173450940732460687025684153373210896765747778516052207363940704857873085713086839785505362247105551362562251084812751753100602756564536667271719578542105204676492304221446654731102246196145251115481105843660469014353761597708112406536136299364686606248229524512345159026673804056018470955808130441446687155372341621226199483914755757754722250984994350022611517343625670485903028067491388336236876745029212667119008705540716989689663107308188157876558080245892710061243708594132189893040454305502807539332819569696385338827949985488532047516621959837728779657601672830070748811159569201850769676539660267434008140387976200839891690380936721884628192614604069588253606926293196857757845555453474988090344113416733684566780287102078329925442405356921625742555449443355053076453049935264015023153906840750530793470670297973914277582139865740118881373359566023551223764901115942884057969106857141130371581867677362727032375848451582432225341292154123981105546996824534300010874345523440812862922425598479470512786934624471822519776692268323338695758553697132245040264464396793591519067705769154376212549032162750240722351009557046607773376653352323369451434896520138629467566938825879274916337510493488990878311595112222018894174419037405836987821675317346804065844066151489418623189174244009779722431917664832572568859590171522830946514526293342464568096027993198733999481452750358181978242417001798157545820198476691788808068482349817278737309097864542663270298254603551650486746966781585550936825248115991348000685271095202745339575313167042228078717678031268001162736998957071555335551132578146321919523019576403581543286695432144260609831804381760323382386977407286381169205576726416436602553445962934930919883048973713040191099492853046010406158076174840975691149950852974362070269095397688912403367559575821019459059106455846399082411468509421571751043655029821073254392653157237722213561555676932871885348163217993141728768540670771086454339858467348424738150789700140648628848951429544993476007361522892992499586122214280614941480818586661703852833117206188667148214679701964080048838577321086980291881564672354646437780859659388635052477092174364367122575203493844597519010699855103487208367375148311235728868690779708760895532701416584413143978172455482163841308772866634053572960768173825200934644795929956648725462710162069931540215037746411807868917598935292845655819814720620397349904863901207244601550139939337416831847333968141183187754060902925592228267880371253011606828079819780853381784728289011095689176149648382281395800450565885274112385993039596798396000044530356633864319005756371903306633849138764363286111732942118403910418050128792642466428452951650669088971553617303007861289613349247198337929159142817445533860946691472673180738379409774639661293057608773928446708238267075492540934991846251506837799686727930609469846959200462790734843067336429315242308194985818221783975059448646171294233097161752122562027401785014799654177396380591415697074347342033482436162277516237167555543861956940856497262639727132435512854687166915561687618056597990389722807465692896365493954608704478621841852772090344494191133509065924421731925398478553788482515880072178633680219730977281087795225315133264016662832783403404728439887804543004691939306514249873045733285686022353805887837893268345762024067698766794261466921967661759132938105153091448486357502781889524221242042254277499943311983047641322807433267792208815912169091640536511131268118721047338134497751271585890307613612174755863040866295354855224405016652766979828977024182219748050811894240972802937770814810666566399252932720920001281343330885571745438992397367482843409203005742582414597932792163483456088830672768864369323510408362749021974769710507584546820563754374040743597149687378098452874194208992694491384281259180987430130446775996588567581020868022908338664202881902312986213628244872077029382198784271245280985758196122082724669440248234610395615209964922764126698704466198924636351534139247609626629779862933058420141146257582721686322845712103641919391891282537626846500056812111464751780136012998421498954772071171273557521347308581821724578831920707242303179633080673049015096401846890380808945038789706976907087600934297556447904370780062085573792791830748860034640877153316589301770042287111941466616338434107130426406587132419300511176557090060465549939475467626620789559636103522625585757588508339075023670184906831607158329746459656981381903778582437871214402591690778563723164181305177728059970866176313075637719625203232486225383078916013798494690682408676117106490822441448447262583051706276249600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"),\n        8000 to BigDecimal(\"518418106048087693980581979742772698565110053193684177067236115459542947531660618755664354476267848215721662717783424020914023554563607596661295109473035934508368049334529053780777284244223430948668504207545761629848697390630280108045604778380793419853373373241702156878307605146518986496547492843108129850676988443139382900553680505933692323370157777611954181395779927796928247982170444256906306429759566061528421738794329359339468182701866734887806167541398761045774894243127307541875770767227297986629101155793901393578157362232516334761860506081091521685258567831245656488623686484709916159918400410323236342739061772155087262151227852898002928966166337781474091134426418627368180539561760331968886816947921436631109695661666245684235347409472399367755920005965402229576208803457199256068521551553661311155524897994758747603235461510505818523247055078948496222223442715543838081951121783330139907509699790888717222883475396658118272900322097610042509495611276615047357641584209913883188366659628343501107576294854855387214469504848112747596438888369446475019134111011501343192924809570928328743614679068177172844133742153895784205066445359373179364373724503629172015811671832744376427799953456253926254815918336720839180623672152524599032798876532000651404763090402904846377021889409054880075074330035915746013581951397679234264626325716666208358863877857354875485114368978703422452801804745912380473433938245758777857379720962836343195734870302933762389927964772487306499320425492053257884304114923600611561065059348621932000191044913247197002112598116849303073027497851336208821228098457820771418128279663636281919736682853516013750443872899773693135004411493851083885387919465847409039413722857815932350472381855940113224590016771502927089360042246524851094663866519732100544537984474106431632382996361405868123491087931409556953180023467219689666985659043507648638993185555032391476592989603817980797187079326745529992568378670466402553392065589724907786307976432282923508630080612066399364394087362940657084861741604238603058000177273737324939049242427069401233781239427064894711207138816992593324626422093000165907366304531733947379709875758419929746468759763347574605862736219062719162802934776051324915112324675051207899522543854613472700966385681597483823240290724203423746000777608901327855517703967794926759599318188419815608963705073278673613347503846276358172661685186400054227521286095944437474628828815416752946797387377803993132307977743874536886405196707116428325010008390076118085023509855901425677881215390191084968822857779764810461232801215225250453945371051887604983603210599347390415572134748871996381136420181183927908519090943765868096350062829224703049539833784333488113981222038590365224970636318615322669160702518145473457511308397306484776527581031440408269743653475030891979835839571688879568246299771375616141706254412709734535561698655132591562272543562733728037125630510522338495620247153065406673641171911247025111599127131919278119901946202202900420605841700502137363643400530449428232262208147855188442972910525926948277672435128762766226623803288675015950568693980330472897251255912752555086747699074336716429453545018715237297671770423227870308215406841968509923168373489334271228707173663770605020100887635151376402558425283231675724420477333804519100913185175833311056172362915706560173068715525641357235043852576193149496303091802382473809218898067301964100240032236672740010018709023718766499325451726553769181857598896908226610058781617074343895193549938022684502115926717558203051385840465551468182009736206263225230080920395415836964139134077374976540459014194587173401086007714588648281935796979127857978500176487837663541357704306718962709596323862328424388948855952593156121407796924204343433792959175234253099019663129924355197381560125307245937875986131702018922748275714074811125637423674499590097089771168011616237164413253261188532762246616357895677107835342651479722286390903979733889472876802052433456727054129289081777687203684206396848262729368288410829212938731059158883944802796422351899293854805220151052150255403792924966235904976721084861621417331174480499388198724665233026853951536703916582582919750767810071491528241730763106657483215591266757538045028576437215752613736240871407716553987134688010272333278635449781403820926117624889904200595388058154840847900041456449428020159837296817601709003855808023992016402258977370983537506446597820596498794127260024788516867242267969836133536982042478200975050300542586831915636143535539923136003660639505835016508002791960076149854255374904829809498247370234097701599959470899798967406248249793462468470439831797317577360617651720535704347230501297960182193175253193291346530884405078339627263638083422310621128913354357965301032620384871261082289565878660543240680612098488677496662379472499464023699794391110892279671187896710367097037598399448041050380729682279672602453763653688192887619853167370019386672798826266516085498194611006083658431522287545960922406608788280515234278556000828199933743772205192621580892857410620079364794592703445358325796124522152084379129744924850226312875933156987040594270392789396123562608445234714840989446801247212278866800503431135291309307759145876626507928635430364200225410988547052095805754729672645096735345590415506781517991901202071558500691814001155052086236840275026617314890579379132198308370863345605996821260052714506502897092981110976146098275576586226203483495564951321636768860604350374203264881475884647359468796336636772961647925528531991731768332139007384709833919057122055356801398113715260539656506222495557736309966973538283601594885658148286205703803599139582983568726286352133327966713501195384738051734513915528283985721002160794007854181272612511407105616970219836146882120646691349368513840569709621572332739957486726516503266184495143594309085324288809870112984334569382155857576419592128801325833682754482561452109640363623620516335170866014853670598927017905603375812106835560994777712199603174038304905627990760195069853017879114027518831690930907538010142363121359571196694506978470112164318189264780101629119768584529025100234674156440259901784170027486286525109206142134276060760715428793437586914648125531578832014274631894320051042067384055994350729793095948139393941954008571405599874170789924778895191048562079881915945916510486611667229874731401488635641665030418387272838297352149377892194611187186278877978779279211007733753111500513230267968068279518685349583148605779157562329072929840925154565309846270577867309364173018488325424599128280457806290896059221424585478978051880136307055948197052973839179729703352004565586316547074051590082791998630472336364275772835367704607434655555895040987462504534478846156876872291879443015135621328868080447319311789197930545169226056320179608446944334070884799048541296978551711521171662097208976028515355587530564668095557844081247818379847124522100227264717773387709812893047216734161737779244808671798863169603604702067708327225865208590852238027346814235371074353562979236469861215992536432381883527804878852556904915867492334750077615603294009371645748372619280000271819829207466455481586803576205469340966077101474742790958713889468504699001375242050840536265920344049202032712946232990628957314443860583718843731796367411004363105167021608731208960147589451175789562418808058742376774533869681099583595663570162510225185401892197554650940553033862784973940813082943528989916245759636884603592922942179089834717845623469427630970120264291626665503555870002230052700901821226528604521820641241774988412942718933630236545392854872489624025374107977924302496359457057666312900684105646750182803436192854844637909465320300432046768856779963875998356086421228482720653451286883075471880601344391757519017334326614159043363562037414769077961990945245871144350908034086651367202309658137319863540339320894196168992042443247479685739610871273779670374735288368190961659702683553474243684725516840742170713546527465351169633291477837802438109913211756794927404037780080185203800601571404273737200897929164294021760807460261106420721599900919392025243976226130332918724052430703908618179339946687720816993426189782921302903199243798320405892256295397948604154863731053612062694772069210460875609282270030938757227006473929490502103126325660596143781824160753011043140715146124558360924089715072984204779781835197788072317871999593258891547460748111727314324481807111150796794167073425814372980670823867211244790977107327425213589275407173839400672106380711507708832249672321227800963924157246597358535592913088036465860815466730795426616145137976962359560220931785295172308998636316463721676985771992558103408064851104575479435430211345962993601293187655441352782252902590527926522424591924205553834577955560496463970158005509835205933974482452101740740722504986040233648168337259827284685492851196846428036864939521956334520888087080158055515711364337412372208481630276916412221639299025700747752240531696532666686218725628350419226612214249912112272038315469235184919023735421374651477713899689902574778483971902122933012204453469461940271761205511256653508875814564524920392708526639232774005511110260617547768849421405758446738144625094052220243536057847841793512350701825943918747835269634297284950135911186919570803538296478378378375428103233426388310703317519101240879798544735807781388066249230897393702580086086491991864740301737172761764714713662746149363926422973044577653378175676090886131560515484137237606062055878441613044308279121154983569404154114872881123734064426387876102804973264492010438549956477059902218751719545599693274865317849458679217080779079532985693151854656776943943252061408393979950312691643352239662864795627434085279151391438546641956515325790952059232506729321274234501644567127828330885806257158025641500206849889991763710190411488627846123431332358157438670232102661280225814913819758864164673367639545014022683984556946285227888856016683422618517101974328190701534700049126198814129169847175048511704672829315661413922281029953877942958812652836414256893698741612147518053774066461409706781189031507794742605730069216209258121084701394688592230323495697379343272025567484297130963727950273194560496996581585585029475502566900823507684447584035332981187083641753739800475887637586877622746093668975481375106685146379691944621180344490911927307327384315812738133079051058069508430986414194004837974027668443177627531529574101286800547796932459656023892413744268103968044072911554279193040563950921330913594764707025579212259585961344209024518561900210576367846373949584642780619684626102230192604302606503700283459409047534928062321098905421105217666613170862746516609962920069953712867033703896981865630777821300649718919901691320027309879547830050596943725479115712885149439638030706739067546731791062172306957004767812540061439472486918518516851293625181315650641847909824248114795011763940815454471436935179199963557711695475074709960961068490924704550755554457069816139326652496233701415986857255906823801557687377710351317046805581647136646152348786681605128607558726664726508570839500813854656558562493531554226417140080274470357966882556808696360880416600182819640908410649963622226244348003429756253416780756119297686588603410538920904746114367613319517386368532552845938173895082671956689854882460963673708162908311991056629941819039621522066762260038865930820655028747661997523265131421444018870731106820214801084200087015858381566667949104018354215100964360361238119760727794008102384718278419383947530110799909401404187191523196007197256298836219192838192643694328614191275186771199264507055483995229751991369694991531023016389273025500153603021242089298570020310405784358039219354201906241352377061555439595390973816068142724892489333730748057037049991012057306143940928922490697874394897503031240271758315006048452158054994291318216885552017318607217708706617926694580356605384789634308661301778820015833892543621561686972258078026012470379563011537634795297082050699603359688926172854543826904965429132038847287946633035545286834183237983993089078591849380798441282875324723001511532051828469641634507556883838911862848099621480738447840752251776825179188746868033434597825646770771972904368101874622770034260305720804215333943714014839786725545926379598118539312442808321596017984420564182394160005755945970734140916638828099560093557278954937352205279627853874890852661539536004949875665230402928137689706028936264661100063672670024066161949812998910676480858243511207695537867953361484150629560592594755667780370414915335237337105298101322205825010959955481967682516942197795619581022248985924038232411270568957518735412692180396066179661832626411598555482984032402938741412543383229811170653495971125853014360102425425393171238718068204183634326188371820603595207500478697645141715210872380542402862825565323001229473571027379253814741536079924522614985780552362088272066419128301805336736660483053490253788684564898125095077864893596233537770470798291189490416401875596031440309768442323559322107371782458060545572175291496592381841146847286528241568631390318325840714441898710340151176272766455559887030163834179793895463605198272327530590064886746051912822887829494684942995299756761561386333972111414897396997687096348218137269597753249222074153005544917048458576935234496944754853987169083629014882410297523903402739411448245456665283100169224488805288725259059096708464269310555657228583412994652178729107219271266647443134189676611842668208871005900874469701931028977046278572250965106199912979014767081399206242047982797689871592039103587526580726878542693224384302683475685516796294767218846169794947761512046288531746693018660653320207273756895385543554063909920784866459926317449279472492515572202125950844904259026705220344236375434393699359913877482510638122567220612234317709414475822725880529154179271085148958130624137007814937559094107276708520761175798677288553663558355790941970123089000116988661588900089369996231453622810753529510779557684760013949293804305441802334440976357891596154811936455459093359363430597512214770118723361752663705139866877474841272005126038867666113287002516226743121216028873518378029467755963695070109542009524405499895084888529288274441859114634307929388858552508605567412147978516892525403407409592227546748877144184464724989519549604997992231151172729843015210211685038622303026640562366516093079164131896215800127836009511908249203969532506460371592899988195221069257068290811407456906629565234802001334059591600953361500438386538144912148224510507167160197028878594712497732094471536076676717727921870904806869298254047951723354320428746216244599513464499783237761039222993421874401535095581798656968275677039977373619626939100734237406261140806866086924468772071437816918317079644511676553805118811872121822446078430122472344516388032032957707503382951085021374915964819324456446537395189829711167053582705562030416916637254702679762844541606121974238374235032877206639015106102673603733412116494278484402625897273276711032768142606360965616417478105573959809673504281857296900348494674000184656379797078439517399849618768559271410055764219067491845658429670416079051733256942365897425601423003784339808118269949730305084404192739053923623238593133959720489075671535574108303801904335447278160258923244480870169478471637597986647910673484554012641544990079890748657662647921442170239790875742308660148721412279161097594273558007546631723253742063841031253394787581867976442695861885943883823023002487885368430638247722578426581578991193465577711944608741571364818908998927654632946516766481880250832753348216739830952192866223126793887085031738232829093258175116271636900053106299673943450464654199216408784321352200016877882210859110964858414880190614833591831661157997863271219099555238297799100312811421703486919039816031206818011367542755381206896247988319159872341685928975624506952434275454600889560048081549072933047345486925026922172283292388425914519814660308139779741954947878846948871450434842852217146323594736511213534517027595065988631018972926805427823694336282367097639062687741604349442619082022602674364369146026100745244516104604043336520736209524875622409566445048326501796999679279966209546513283944526809276744550567653373566027490553746733180266712143852523698203190627361657542503697122038135656154547364837695141135045002714657646479085524673891509705537454772308614785521004073822274794883444483948029614596385002888806534028172578255152746310172105614679855018894749313931271737674607696377882136074587455972431412691959353690816108647983565045705907006785585099096194089639309154301952227211512957838928395185177592095848841526902664388687157577154227017906133116231020369869238391355700979288171404887428085455590188208464275866952969340930129113980421712312857379383700921929399857891953234557795378596612840832888129620217480287768203187771349978151283965752714268708158441406793266275908126453575543257836321889633424126936300350340175256131231198765218715392862136537329311972760502238344810033589808744719682218162299987399609909153907347753543210496797294470701590452206570587438942216083306141421958285449751634098929249822792058428109780836450483662492583632583351922301241714073724373154219896451396515045519894309506929811312267798060487583807058673439455719219855167687968513180667079995155789876320603692698735872652824410014777773971550062587765097267278662693180366476323358555877527305035060834300996344518274454894054734966651584784997741943524118472442808731743036335823119001154787441382012030626011704035712890870819301545042518929175120103570839396582525955101216193510570294387376348906521081513231969896696127462464041000828430222015899110174987691040265120238554439253637004618472297746267012844592935243809635699917510083061386262600308055561400135666595723825480662780989054901903190177832119838497119701876252137584999981403590607411622901754839584592043280970562326459599279018127907537995849812394815540155155118710214928862582217599476601332173718528587656645032782330619157326793553333740025567934145046356972399294504607443125702283364163036878588239431879757217227575168781215998617178608302800242648228651440257189612209556584215040219748565778230999153944359103396363893123330702732589138833504416076293917250206344811744143596583403903664476933849303162646957740901050631671032150391876561060020667165606000829038819329867801346127460525801499142445607201210061826828700702224394979279825583401080126188892494082381807305944532261398812800189045099658061521677318841467950766946983954032054461791381417166574082617795104286891401037847414356786008631614618269240484508324047357028689786963021377775512147079505079465039079290709495208548361439560119651331188350563243783116505605044746688033395582732729994918205208314413791658389197271478367122422880377351566694969525901551386644296755838613917175738677911211131197767489950428867251899016035044473845039747303149121199220126742213218024708992444038317738150938772855865951677442396028540176322203559485815393088304856986042265425932526760779476081725906220248079218648246051091918491131594669305820039736971877228468052970310620056586225990042998742904075764997888887641347224249585653993959454439409251864620019082403910857924963083335621883110725112116969065772552563325071823055734819900598556254506551839049964715526756892384536850667001900536863534172753181937100254063521579530093224092593367027882375926579877669086930514445921083872151019543635501655188608803699759660762396019792534305939538435317714872527952889634790568830691706395709778968818142391232382135525817528721692690500096644376753070926965605757098361924331446371503856290854122315334099565151842939607166959125896455421991596631338814398485866551335778529135118116867252306355238266557330908822475510670301149543006933686116787600231879067802773920880645554984334179711459656134749317061360393785481168643826097478770564039584695975130602181175420048128396741141441662343765784680412547681863877957772758926871839815020570088699707781666671442680147814284914402491889183181140008704614287282275626499750186634986297894861748259817535394088028762955360905637361303943532152453416310702721179870819170439851648914783387696148215301717594981914949113758320644921856301191743882476422983901606084126778083419844875988733083455190669351296421583351475838552301139817607179503707851419258156644449304980136663579779448084149983107255259970771598807019625801675327986776630271716647174230926834961881336765351750548687555117081611106419103524225081655713491562767305205578350891485282821231503558401206645426743153255916118535078897672023261770167220795653391537251572761178970023666666821585701824927756307942494811953572955764497239898899709705141776754378717732032151073075777407295474896924572191041777497424248558239972069366204896708060402193103618418943264331474429954915211712907761977627437993388952684572160787709156232200827295984364947735523689918078727862052631328964123782946323623800512810930248232116892183535110224369865971324729965779337042186771352107391341011398277639819360289966479028826123626288692717048953060679147575924447224260076681969908449777442395670940662753562488730153775201287208244574010140685177691038823753076694409103833976466966489270700824198248256437268737748031522924873400415646989334262540486829698466488259767520113554902475091715336071850630870282361201725082775726442731104437606996292501427860083553888486486633598237988633653745901495453886936035807195926909326893132920426579944698127125189787541522220489920639535565646433325826264196357717305150797561686475790150073409941213688042603233638814412569699704488234128292756405672156418309054037861200398674655398354464691098144356676229734772645940788270630988622385360004618730214404010416544917371017498859767442256732988912004453892630831073871136113565265262355511926344247627110620833249582002897543848847912460790962197409582346069214486071091577886198260394377717583312346340863657571758353898389044402750355639505396344831256749108835134412029324951300913341284628897726772266638222744438931565597295576279779105482056718442498924513605985176895477003469169975768977197248456328943667149083073726897042708894044009902095556309877886252878178574300328317819532489009237812778893491662333308517002139790978343943920368186994385341336968040162404673965057155344362626021205126048206065452215215431902261978287662300944967602011216459918005968526604311194362419340124921418441603588201995086668321075309534365798867630404102775555673439838574538526808888085200679505637867171209916047505790888475908109585455667908604842063304535151366852193016369923051993124477886494372320167032602568869781561858959333454601691710908369699105963833860365749137499963308946649214132654678447159174571705335848097216526531688020423300531726610771394947417791429364404314252888169560331704994087222248492437573711028495021945008969667805459395185253447587545340139362288426293681014499502690596428513115635868159273518165694415041974822479251181465322882967180277727538632678875685168879098096802117721407417720495851977350438609166251282323874782324434304550022706792237112465988848491152393363255212968798972102010805033876405859514525338980661001416118424006555972789176746880281741310647519374101780819903666064552777205121219482319874749139040108431965511895106058680766726905421647095906638166382301304676862732091264809340141711567477435835372462311195275818123971699145672899761642929217471655272161645112837851038199456790157509866743710011857992860322137292090429914259592709407464298381788980162572831207422514907159557151993625056325326563705926738580141143455405104664876269269906014828854705567851488373059629262742155373361463826927307791963951208578820594992208833204767568549543375066768735104738615830084532551238615342594499276176378707212571188289792971026470676272174833242962001581383700496749196107658008669394186690023173029577746544805501589149199375961314795462024966192308641437552316145353065506829707895653672386423416788647079696577701790187324015109190371448858021895892862990476604393071139101823743035261822903453713527204473257897820541226849514978318804983231870540092380900655396598656801261728445562879881821309110336068613260295084315942660724654079077072109429186168602512896323760066970836334736110704055573746751836537353946980075288035664902843799899655627155884469889181296882552595954072506625887883782926591082227742598262145565974389336470293276617997199572102261263133227306105281360879836397446879484298604602969365029885780794525359998658228798660822047547489883629020633458514381094212527914606644897528812749807259831427195126686663116425437070789571280305733888767960532170267125430675333431826397137575685278248326285510089691966625833538172650873834678599776327978257610438567653781590166898148904642065369515019668208969591163657776320723889235843095502792601081701503293903105003635199754052541275940905274081092794428147829331693457527255102402657578033956554738491074711130758893222742842560972383645040883933992139920761230769540484718491736130205856602335428054158503385456186103651989314289070619283974764359936765350668419694018987648409275820318815097580690756293045688206127551465877789586718056898533402052780073130173562205108668530295775152773524829590843655654743009010673209642979116053919742875641955927440147199984107832479356327404747242746377650490699410140223157813362315651279917888625428209064795668175297168690576375852290349092318760343553622293660293540843884596919387603775311986599910065725117711824606819729765142280249307345652152974405113642240707545861840265031128803055048211957120013740544755572697980479172094682038200291449231448328842092867185409978488579585449386055197371893568574285939167997298193838543587782038459250301261131532355533084026732544000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"),\n        8500 to BigDecimal(\"83478771393786306734013386700487570704009579326539988268981977165891028986896860446921421981383983528981550394755805135976450864230111841996139278218380552120362962547621834240393630973950111110765887934757013513429279061408416266027261562207579044353207331675086729792912229647678166728010951408428619638989835817794886560392190076044503741624293854350680079261684404020906124893168331843504598773020465780944896747422564006520235154926172513397786791902309916870459781770645104007332866513808921948526400507294658814987210928470635061285594313903140461119544066409513093197342484222704904336169205182680123633320485809373766898714265283155445600593315740259546742606050466083839402629040578460119945605538679321632194010064104492271441145011181434323569048861948566110408796713831377808115637062313467768480943183546343901026639868012651951611372971091498004815005798141455566000778390634349693245731602430305945163657692012610389231697326249574173733807711063846214688158661034312572605580343645911950306717624052184265082952046839200119959807229664623354676994749793579614470779239670188865587900613807590105607593688771973032190265490312634813112296364000473027452419767835127564568509077958743308271645012596636802005049923923380534165532895403242206004214474253435005064949154940462526693568479094217679508317325257231331674729212061963600642470356925363379785451129987873929099481500819869172234234486679093485591171601720850243627257197187471929560900552364623629171455672120962259576685036467617381065971526280143182193266331606530453283207645013923787956309527411497256970197183712934075119487234733542097077119148940452202264407581406385842241624605245663595807689266470125394696343953631723550967388425926355035307658079233092204729915516009428470708127843402754168256210415160063942436530278601761707083768282994565122309514373748273146486339549946438106228492502589905226582444892123967596476685553617742793873485651454003497196452433191165310685684896183491884410338991535573590439825995687623129713555083912120171868643294010683605972565894801028681673878397398777223549407543311460560756487129385706411171690300522068417727452500965586768199288548728394609866883070900201232740974047889125652719618643351619094408617422911715973117558763123998949018756418538887012054480610516173242394200256108056911063974296520074902560714631234140974129112326458963282287224444755670688443348515704775544096000438610596624735921210635003047122665388893721739499744147749530996547407839265332658894850245346907927131525522516087070459836021597090604194619245669955972666845166941772041114787653863652190443692842758151855001363908106649713237200837489939663572482548690793252943772798425814237104031460236469024528003891328156055360998338161677919759439251117942382623983860339686853486842091082577030219378453961344617557639610865699247305415442442372836187512504588616910845298482657495036898290894282513365932056619960793589761181136439616832113066433206934909893178724439114148372980113883006786650745644407031917748826129355586758115303458175632578179784226133013391348280435415977105604742402579485096898328988158807747334878254521756750246510696752497685997963062652112590490621192970784840366788189637426521270317362830576509580362428217669545259203257996040711919486577626099967825552332840860751450158935004323505766551148809812677834663709393265313042677591824541250559128843511588883553354040369693888282968610181399257550164952904511448675306990977509703267589393159779307699625486043103188196123203758530456431800188199900127135034543683202671131083373195298179363966654797375722948679270701616815505672807408645402170950356915552587672045867917305875678225727630283010779250869174166219334652613871983972876591241566777705792056643029720359447353760187485552377366573818524676322695503427286163626711183004741817253368890609317556120591126275410891441617578610458046722971116673779934896401040415399157538056615985117571269512524211431563274235010110737441468634546753429325351602759823346723903821674576726727994521136208934269798651298588582539871812383805151324044871904436407336139052879556716090458389959576306234285677821552023711706120443953811126140519333965939200256861306147746610706910627565280301884124036236399554737389102206885875455873926564663229034671988253065276089195090525474557424598995986901478676342932730303414179537749637043590216364738170578307093774366837824397247428430058416406502579031164134989750976014215443982751260748020947605840230760594116624097643780239559172184878142494116813520258717308136447724386919951517979724699365591011890412275709006544841694087387971222276149088142393097382720156236515639669786898234262962862983774157020301298378829276597493226375505950602023102149064100967791840766369470432729770064563552457731675723640938626547329494711131792118131145800320487159514387283212352642114523455719810192646567509067927336862915965002309233726669806260674137242674771173993874989918334073491878199183421784669261950039704091975801127738569957380450031155049174400585934043729099095307049309628927116570248745228686757366672339912837879286167226419928930913852879407489476846937868761932129836607165118771097086919863702779651518785625187097076322340301155950267412246917652676548794445594815959885988260837276651512675268100042254722329479694435064462868060491696904673019632155876903156263667807400143186287083327073907309268348330826507192076842612396310816695452948146272015917234453848260791333588919619337051725646603610366784603178980217644429676779601463329054736549899480042414434641741139094668240875673312190694131908660019392383236721314746085483444086115312097317394677128251237402216364628543246780431970314492731872446209713494439982662918936473658985964644307038508639917954009138940599469119964908736605065004976231875521213298584586762143055798153755667560161292463162284340555693000307097518513389344633920164927691033330672951074039705998670199783659228746287101947072739228165374203863869978906046943206944327656709457204493752363339979805378441443452990137797254228348696089129949187795195304231440956939187521561292725898985515285303577077967635442919525698070978627758784373887892837904504022223333958736569026327931193651481678831197645211313314585542797372813702724060406351695066095132264497492892852429396249787153596960602142285684360926455046682857003241103205967139518570579710701788825801504184353376278153784282827663090398166769323278798048012313950775010930052393468700532108732325750685570579522141687905786059255999490534472535699151025500209101510522775259292940885324442072254926548962760580948176902763627860738349874530271058207639738855638145788333993744709327826052042132184855676248989416517147683790862079423646537043332645492985069094206357532144825354693094327991398126105421819402488712745622982618705233585732428483043835579225682834402455918893503706170738808640509534200406304338724464187027923186573681734324132464907154464583446233770348963199010699475650855985197666729560881950590032180672987924801679376948191279308628605286403159836400306658609654326507354231827453038704837246342635809219610903636959146413099217191628831939805862326300762997428128895894046328305194567738684491241003665548116800219502650600824904620979743876875698570469631004564427357327187163714333345763887696620900118932122531585121318071726407301721813631618602726872000870119088663569242891765273506729104932391241454730411150866078228902664307480348555573029748692131314801525320342807727104913074373078117705651448030349545741365432955063111982771562638754192705150296268934776869761195071501320171660610045478269432022706001986724950086939809370876164862088095744893805204543243937316791113232432214866558393251941549007467301129777335106106661579888941078402738352425747839092794603969256268137817243937451099396716896504586524816663243718204646570099510531463367618784825025539473170076967960373119517003944739575136663661346176646920672455098740496708818337277909751507725883341972618963788004575248390091738158718352678956204828051076694442896549045833336907928218485358903639513956769628501082388464645399187659088594361527652818669472328746898982792934374499773753516484102304712024371164418938047505278459799388260124989868899632002311339844129885544026455586952679411538957648078935217231469599798865709563277557180863585899926411242179606131891836865759810488068745185659356245918998874995506686552459352039936209362133073645837812703880118737373860917021322812178060054888290432967601291842996668464646074602703583428153528646231671887050339934668784161442590785357869524045820129613876495889496821363960695226156304519600091157545095343297952981744264575310951910108666410023041175786507564276794088207042034110350899171251343305029586756897243314464826879213137307692277285072574297911499462910302832720000238849587987968314142185838223602965621003442638003353083708944340412095925792863299322115890757467396321355785904502686157474807115282072015950121371235278674247220278633852275326358185163496753812526676026912823150857185182530342264740003674014360981890134741042679826629371288934033756289155685980368817561494583540280499440109934982150758379157836444038312672815090028856387198676254146606925280013120221489243648276345886237575778530314797829171997279597347141405588426063832016056739034546716664208133539988878715929578366903832938970239917418534949996469203989210699707571992457112970571584861271459107182564148765688223907268036552609717932331274365996188098060213375327485326903839486559707483876487584147104196583808105182526034230261081081184149838769242560755074912426198475278474048910319168709120418783500272960268984558395795394245977874210405076304022188586828850301644882690933546904495923953727393637505248439992035131891630244560623043297728163329562165310309376528897554682618418816568284277286999373907873800677117879587640335957158439768928059635363689545880230760537091520930392578341106348939598416099478104724208267992861154753019845107052519294250481890880483556670236016917849396904951239116303103753848135431164705058409131078686164437334166912964808970585771734063898588146086711701527743368521173280593436318135323655546144966269379493050359653346529438162506531411489679468984662973524182315110118806970090404512780732910225498940693632535589361355229386250159347099251151632360823820032575067056345553787806041457991759146199284433119825963571828894298155159778440420665806903954745087145789506055673157601353579346171568780267258524376413427810265945360863947702316525639009481669272875300013686014392516591980318602530755717423151028966772359268729978152847674494884085234871259691695450194714230360311198168601485075008769887650925907582454438129390699209002980451048122952807064631257895717430663136095520531083582726634577973654810484518709646666400368310526384942595909522742512464176048812433919836867802041400962199094754833288313154304881183840137880845709449551570110662069219381457063438067766677715360884898899940094336663452114515570250725440721061407536209645518601411593412546463433537178154833961683697953957414291565094900371641609496005635737160734040737276128414627179868216855381676090022844822452127961224925621470922828910069617373577077012116950721770753578629621808990084795045238932028877965868748003281432384672220152599140758006097955232298201165444304411419723493541418961151479367658484904386311848726280009693286531739593262825939523012670337838517839345774616387582867592571948576604480644884338789280353941681999173812572020416125477170333164323749485889966614426678934147014886787799576665158343260652883543546205457610964760048820142512267649626504895939639277629898189737207885735777625845867250581549491772592089767887920023878569644597788318760058227492201507226003076209925191964100248534829548811272042020763085768871349806360490901785053535015125877298591151397861315909257117100460955434502323728858791905572609705587404697215334949654120124819736092873111935911365442854635656222518280601303946081455390467851906659313767897325222203383983230100275505692580937802200354591091961919593565089219316868460598682189622855511344442810575758128622295226484373001312818995352789214281274152576998097406635368574120134362157525378593868555429629672996314579647192215389204869451764337712138704305572365673947260549260454873903602145865579807204941021504290129041494121275352546058368779970510902223555791676974416853925983157812240427021684931273340764709381532614872664176436547289298078799078520582043024357678355467611913803907617659301750281062017839845353012669897374212702097653297761390433843717846111609470706642536083218196182172526207553319992796563877926011472938999998842230433774038567102624540788988345437176587735663173550498044987624255490151714561040343905519863452591698285074088704673343061064073153776384958601426763311840753569140647190101648597650250402091896733980991934212916890710957094556502703439659716149497935284163621672891342462276797873704627557814357921279714590439111379907628352411451634081840539490373126384500408485794943432436339850812576535139568220810256675459250218334066493393073141547436396154068186822263148141570544064613058117879021541051298707031514683549811322683911027783769441409823145079613721652857064135574796295755683471621445872817644770698888127260596179873493111044677457849591374763702158563977051060235110426146710941550187487993123855297950876385206370592515121373727426706684403487910845298266197155210601007841361460229056969111389411884995434130370916810641445563859886156710434299172112606031271231644355776235436896357894446415962782147492420907900096055830308703082771482623517655114952478260697196557328773975567027031830003969092751238233772375000926516598415360701756637981528865979987512492471069591975629237232800260532252288026746230973066656221698097360158492342900701644200306137270387411993480876298942101969315050664184545140954324228271696673261056374680180961854628618712198098036482925118067795498019423047020724948153160346876278080966095234337298732142137993948160034335037394308587789490918229455973744876155763244920092673656435926566309642182530570091789336853929469238455568141350920945149195338712073929196561676395998051917659871210234254429739681988307039550080209855198630245191119977564933089370253852991618016999230830142672655438108989625710408930475495402517823414842201231997982464940564870958547522718766294693277782765327571180106524124321274449090878617947847153491305815476125801593525440117380347814514117535670025659746989261146323069286492412798986650072083115213689024946403015307909730960429389008454704886834574841844705002971498966063536336239688218926288491769559320521089108127207667075265194256104117299172768225516875727345354946309777184610776931966084638593293261350200019060541715997436326980114336782101652833381789855708310827984368890901274933983758159269234295154708460015819934814960578580920024177560206858691892774389045779206415789715692011543992715465100812113487220602185016498870234105910104567771699869491863509364615930274338462877603191608464331693155976615399571336544742035360621273231878967529594504234429540933296382800857405748057058720667370520583755010893698048835507674839214711267768539326817189563431996327821052471344639558351749426120662820231284392609186602344830382661682259532403549346825472062199966741945910768987546379095671560730257416029179131896296890428845137056891959692366331204562534423935098010007345369310129092076883562591574245117220322185772470893600644449876862533913435983205174403246559263735559348371975317798465836858853004776533262651152536734719099045827018071328172827249415033226596781749440183272740362440702442413341110216609223959402709244134099112773919198588234437903735829817316372832107634286298922889129653056432519243188038343022132169386736046889201752277940258238516120387889476393736379963632212236193384594614209174855668597702988032404200430374618793168269782339699213846900810467970685405272252068515778063352456731969623287405622348181509346471760346549562007980169551381391696636273353541204848641166935857678889007791758950341453339848115512949032733500119590151022168576018016361550827728633437092575930905917387260980474891331799440354814484696489832303680406517031971460481365832828303943941934151523620118764674061414538984248735974559773468975696003167492263217449712539171035085652480100845075536635936729531722762608970387834991390020074985153350785733121531552314318980006722171720905666590892510136470392666467471421810048831892770017435960242900121123158495001353021860489393932389662994868543476359572892000840587096998541296885697897906180537540289647141492412844833194594644878071403298910029361311680852918580951468776850074217864167323512510468509354832227420909955027279660254898410617624347810489947099299666429052403248874582310838659116316501671067833048561121068813732612736909717727581715753451930907411434588416337680605793494193212594691065974345172315204234301080677184288844272305830028628940706863728206979010695828997427413255259101946424741443149083535940589674729067031678850611189079460032097311333749792307580997912612352259683645319898424715255868099307785491015237907906978033892424199904735449882982876652348624442246914528138773004657551492069760069619814328333736229833277818841261300010890745133019193398257780770174330086611644184126360425491921888195890056797741004942416894422484309051139526981393485211934003076455772893110747445249130410970091917952912101712516949212661991509251186021020390774861414187846055869398527341026059487501441395821955783396602665772465868491147187829260426141370738726423780577269642676889639241954972018885763749503141559945705232946997711566230816103279301289849059828927620086040624651280998342112793302513552183792597600073984108336373550463064588797533279691111210089803958792417772787312859994349905055087551732060877879534723494431590334474758405350697163133569654059267434962955311316901359180867268676857252674091203499831542942312295095549240772037362763995904886019929682386425537868632042739781012981584704149256744334950332566678410996481600921488046780735521618129027306695983976361463956038976930757196176389523314661464003249134550169875177209075063920750763636690825923290990233168138201951335101820019017742870893705719291763540460394685574607617652102295669809057587184736606049314833734285724345692614552249010993024667846046826079471456177596249418945305117564392683848181425447154882431795169993611360635227297503159407177671508122293790630158812066198253393408547953580197114493259536574125418267126821321459486123857836916415159372232311471717975283066643900584598617337900591346062333622252615948093978485692761027436796388633070481760624205289952459404342382445588470001812029715471182461610966665219362294602863018665456781413223270464873885699758917340510612802502106469156661377229753500942748956209760712613467842218715332906607525006128165908544972397568850840085834474955762381025736410526439071053117923612542190859079216530739162379197228916340587922704410381615690580292585116121287061939453536235440811367399131219778336170927840488008932280046059940119279090118177502360616912989242690663254346724850031182085988010220746972454912056196339774254432898524727989397259651173933721915671370657583751747918456328651840943685088550328121410410347513781606822947146902305963829975125468338778263204381755268112963794442962367493093765978944015416413125642351417802820376264994929900722707143333697255042658667212638820149693815129629263278679594960704609427847061295331423386891170508498296403995572806471752580552719538163553708052887918075099305848560254275305471066228535539995558935016996531323795453495523284923684502271122138708771448805643705248313153151891875945634171372928909706275144931019002477477548695903770591795343025931515271847262659280195315767709643195221901417908844198677425674661007679324286064913881404219032426127388510679644239595051199105027697476645606420694302384917664116457706948736874451698102358816933546093800006358568637823580928539095778847311450950558216537817911830543488236812464266348700095619954519977249254704963723616171946998429138594870148006347467509243518682921652818895546710480104995188789873097856301913702614881139752650559527719734186033998746458233759084759567673594200472803891523802216342078684492690669172732906637829915504034383748799086095555473123730695327024971550783610397708133740225727855366393370450223840729180154643304335817775554609312521472804873262612907373635914364266354070046971392893662837985223328208575689309819728690339547641995601391078362098874908609520188475749950951990698617767502868548670826513492959830110165910128557534887238147330472036826694643120940429872806457134695724876672400084304767191446578337825256193872799144849800031738134881213076574455082436847104641895014662249583188937915770896713887384363784623591029645231486768399282905024426018488120431502626331401329587740378484192586220854204239848599921098959726438254736240785793367821047470942762784576803470614926372688785017589634115582002898482938382053495114111166474631760819717118562144219324439890770308774750791729181561207094300276041617793550923294695800960111958673278515775407589846635574720209166064232904130248981428734533211121290158907662490945100498516908108199635069880669258482033318933286032732370785197673614892633450425765211881739964526396115991727472650287290827359075762093189261954116762101791655398502961967922189073675025711438283894144043959183728906866871744149155605378313197534033859616672050572022755009015191785050869129711141596715473584936618669264610194709704240613028748725491227097815480488625133445092843133608219793972728109969314904404734831855996215026229868219204082336952121983604434373376013005329269934938374001944819621209464069456708732109114910019946907329620787565481061703120879475620297911517267240998879103031146497661401720332795687056260327103452858650437800045165672942931386055114912615825234463470180011933409065613828115849090086733863408852125021491204444636272808450203494484205617106483707276175025770924096619997920276235179896494706701401761912295205441051925641303634202775818870130568694240178632963410203090423288272047962173059840931845167504522903086731658377017286143634788134616081829804667097273372630009644528394312491920372548755427682368422176820626937515596556252114862927505527123690251090853466851962030820296726575898494856610079044299594540176862936836970937773403134500404712941893036401257337195628426933250874554758154044450669711367071031563121662019902508389045465158679903408679421989406945691058233075440843267176337170649935180817008414154484915638307690831259370507561901089010252150429476392778214512171165073053635053599019993685077334277707639730107897740377672264778667825788602288997238249407165772596172689895537068749290470419851282912829384750025082374977813783373873318803129157756128853280228638415323595672978595974692334709646762822794619291405358745919785475715206181737989678474915471673905251953548495330855217702702658104850400029802967652028905091709661756220887730621597620165476448200874349748298455304861996624206916948661560233440650831883714776663092582373973734466426122244886079959697023041316510622693920777189706596824638223875375154775230173385090884988688369493693071441916032396158847927026864746944667670526879617911299928504933444526041154967069841116368599707577024721895055370141936294176670323058787333345168600358642078807659190681707875090491222251741931435565246073198883099272573880650019936442534250450863515764379187364442811444623202721982462010072335988173950418513642004498886468844460521810158801199320225806474263560873320208441919914109510951836581033855407748238714002720400585790548244523083043053195738024378795185956785806618977744963932358575583454427606861170943007133255354850017372456351232583125869192384877683650072838566640209250878887129773878578057588666994986267901438482898548064776452246997958290329107429257060177227481673821863174217967746238781221561821429962787826464387614353464386746156548503568312622507344607321244286270372073628501501776311784622929362840539146788338901248882928059618832838921072182075803925654984720741472431424452829908575309578441830576877008367941312919456163331970267291410107915246583655054231105133737349667416043918091203991655943761506058199101025947018702440207418611294728038780086792070677362368590413829102583338940959360035637061561072868087824834489715132833693690201449849971006272463338564672886103342742797451720696781244277188596907097993662960835752928619042975557714879990809417358607085246522898635370633675297577646153525439515133185384233539500468345448789243730000142205291693914117981495870502572005029004464190635870130370818430195189988613715852311818316660947731412399312164890570788332656380283231894658233384064583971253908178862776287350592142796393132666162138600188445941116223232702656847691212798113605725652598884326429557038795521493647779412797342212912359139705599097758935723019320398132229397466123723382512409126626336452663786468464887250546037472321026798243251916173269208698948208409052807176653684261452636183163134997337912676214197614155637475260730245865016789370260211347363058334509040815402263410871408372881183406345061756989562737294680952358801292494982431246426339597265980570551894669429132195742013619285068104414419138254742682613136198723483249322198746610916226783237468830250681923365679237469507157423428500311303315775078264556680912764426970612963270568205295341098394382096923650764387364155157156102161961069817008193875261750528662940194467953012599347678221113674145336054493685946665676836547165734709187743835174965018609429290743330394996129254889940902164084590139570921196080585333398751810100698881955451475276114361371873937728390857892198581700362886404846181956284508131850572354469015094312597092561519270201079540857310508235811434049811227635037709051899614103972121012765508426672085672083371830215815906054528641013230794792040562375719978766204073723485875648915149975335479929479794282909987656643753706571741105046902291069894946128147792584182376991105459138386842591320874082163276208701377732290602391705654526445321082639892157079713259626318332181644003925681317267285358275578611924031433253427216768910331077375370616413676802634611739225814282599154873890761517518487322979980508713645796541519899099077961378028761576025046125139904540606333694367668425309140786762708169433064945420211861513922864892708761744164281610010724498497043280678588462110010484111808905027613375784479787497286996853879831835012744330660805065387876868490595631301391446109736806229780118483015599604207145340055577019022309690958747579785554967382344280767888534935512245223718652684069354935342620230372850290617712003572921571454047108219927803971434434204032382594328763402132723307132037653542695095923702024165708329512743034938982865153331619097026374155642472865786625576705250058538083106766336527373853427489708826486171940714998312994678822946999929425659668948300838140582114636531306591932775817127228738332989967888966563937012787813105567783963566884871667105856919421755823129475437235625906459515872687232046136657361924114862681991452486597069795580495316346121380918180650521248017578186194027323464029234811944391627185219476684554381211313884911602743640311938460108224815204029160541710647973818254485862318420614828824271526727323498355525834349057951185453284739875565611285014108593835217901268154550964223420517733356946024217365075289854399172396956281803266682061130773845672435813692578201600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"),\n        9000 to BigDecimal(\"80995899866871908582913120800979496475828146392946408922219130690909015407353605447575041936572856149436036552693202056107438918510666946549242001162011108501701783175388347818676665807750253993451959460728919143729422035131295720201773066711254876977130397164271629343887027389990484870424761985903139252132590695173046063988540822033659291766968548601878973082087324902401031256293072745024794472029386569310777454039154913625335976240736527174750248807592665967609235867427486687394624065354208222807571075334926662512401020728627137483474443097491765137643325508329100387102323595906471784431277794544091057622014418785718517874052992723535625962533773077786483156733351003985015312850063097297688383104165944922291877154827827387776783098860019115057271734623090315061207654176768334046942312777866852067403680706678717220065935289287403445179487704221022864747118318894667734215824448325304218344022286776464088159484417296105456598516624413422536284583776565645291607236937428081090821806793544279120012808130282214882523710762422258364719739866816333989515845762465054392937290504744951946352879274545232972564908356550783239691860815473962907109723178881997716171297160533116698713610391919943326824062223086833799317518486256170015876743951750313950982026682426542544094208626893368737023171753939606048266880220310852090313669977486987472993944815087101684853278969509545919549706207250476276826257482834355079375617595073690586658619701622055622829408511142193149219321202115385445141995097765323352682497411627849615546692628100061453783287243728334083773879921864420021284893537157101013755797314370325600492358512136266873444682950591827219914972688105498476577594993655491030248845071787094361839130685085895669277350919528519040839999868357050098337385927373281375263237042537200753320301144296397290856074160598702489252961353923612414891351582623280096520530805015187345480542343562496692698492694214185299818736433742085638672673329050467140134713134468413594627818455997427796579861980614609578207714757038352462441858241710655713910919817661137504413472003942614063293534136276732154777280725072555387214225458814560612490917195819468723492949949608592360201904332140376342803298648755021691459703203499071419672288210791510158647945293799041537077117640788722848964195451243230908778508479867559971743934831811057793800314206457521004503213629429497616220334139654359342451549062125299397872906187588176978167460543617705382392994470921463264827844533115902495233234150851557657597791355044387227684622680674494805121951133025107233859851779656815997145907995528620829496378409568948397966974398491052255019449002246193926860608063369359872606288223035513221539114085007169426591775298089086124125093952209885783195418110028923735717150890469150784357724104644776964910677679883242533677938316389410973732395444201079750212120550616345037817772019356650391444847620711299754242383055864220480828185182968042179574353080017192021929028380499662521541596824332934347763628432269660483748887156747338323191578608851821333768867964318876272281007423156167637967305326584166406326581509780957028867932012535128034477273156952884437978896498272926912255085259131098903579582431573260491240198629897044711201325353375752517847165346469983567245747234544572853913624415076812082116146062304579842385737902668727513869592130204810729781447544551016621846145831875160596451952559921744089381286482764414313934198060851617383876559559283469286358361658866503058426656733327419897606473677142188525420552368639731551738356813994608548743926660874407892744207434385685338091740680604162598145801189637540344148271338799929922762423236774236214757770425272691915915339149187596426462764984872474774665067725463397284291584565589138210009405665681920188323186473860405898308222499661520559037262049669645313468190053589630048048190811685333651521436804712220924826856416074488448417055779348315541986500412665196677314851189969015948220300920319322560849352306930367659309862133233368690766759515197579131662716879086665669656878734267138132322839517024317655413573019441790702086958908773081191753912029344110682744511618213853915085135205725512549523020741529779310101435095641952249655159793988276929724042596481940887778147926719038243012576420565706448609533230616094368592246349710411125705209009709373018604507452956279574966424952118320346345475240913103968988847896096522843012431757371198194159304655060189335334070878621886833481355553069375675772881642866354771213339862614020224667652363283573131757734767613223139581029923644849997150345295511037746012892963433064897706296823643603966666401767120397697949140221534287489931325379441054292902055801262918153399954985564623219002596405504258481540827164943397104973068050806801745187128308814119331746084033661493403193411069342966314725885275971704708684878518343017262295278765362109587118084252805463618778863285828189508298848574477995589935325649661422793992584465345641338612580959522983043885990517651996945544381621055050069740655173241823410248247089728707428342700298987136158026413162684315079956050110462918217198764312889367739992323922946383673935187707357694190670826385032014209204434365787459432490859680189754189602646098160968399054298991477668683246300599818941541417719370570725384530199348976527708522067483481324188727699921439331094829103518787037607667875717572627959428680905764345570248508730535699380567093887156513763033363760063908701615609744861406276947749026653563959292876843156065612281239990643934684266221998644247380938524538853665110382348281416184858923905574219464635738390799351896374953686200239306956024060374456834280240227813134402649150402647927883728115141310219650044756673072056719124955472784888958769076142879024091072790868410244349257862137143268818996631138599981891775276256046816038131677075041353397958374445708140565105056364093222825996579850203332604148071579889388169126839344034680169273512150891930837246322023509463915000641274514379421278744160532721183807498479073947744671645683266299328557082077341580845446412951403311504381585926361653545319757185057800983106523315562127935784750538589104469168784601719643894876629731584643329846353549226171791375124980021877770074576007319522647384409670110730004751808547879808812783078157174033294272954296048340312922422355059255886643750420008098956297512735175019419406453125089642046320670503848060523922366566417606417635227000454140222483216986178005164786681524168092438655976092623180598580453389368893634888275173836608117293042890516061723476136682713976032463129864551072345844225074482319297026518389761580046154517762058635776121328900189084369572023938967470693766053378469225663965288409027465833554818736253609638553798008715932900652926773110791215030582813897726752559345930529075162013520019553157416862663637957536165242823520760163331353836603324565329007170980066658832149187213866671200915863332450115225925776657876407376874111231774400385139856819254748100808423031261130694204339259075950783228512563080177267984686824807695035599035949897729917446569938017862710061560015565747727138820973377694916834717751236216748276466064371482150498198384755481494077267455986149561337562536110700915451197536826478360906232635355321279845527509268027935773937754290135387043083966404156395935438612635985311895272558767236144945060004118597044863726465568117296501598026190799163615373887993978915265323602488211196521990175860946532390167678255453359289071690628837211057658405938566939525213799294496386784162371304211175157334382585004669601908847779268042193597677532426912392980054248592496996034372207119229964170245591604058671388240706332871086973564521142388237010544085875658348059852673236755447095733493162736319409814699762787567688990770652517290197745065475201543508109559327229366534266752065470274074136242586843104334416000629690697765150040836926552164847455406144811985599565502550770745585114511442400060230545208833330338414025120778511493362288467033685674079431417505677308118218699678216535045644879288422888133801794987771650230245677092048379930362917495546965415927578217205118980437221400869059069292242253380471883028866778410747494798287178055981350197078503759028846060964731733269106414408516633206309324308974042650836595410504873700815739165896648275291164237075591475505351096401784554794177003312298262210734172999303212111868405689356606236665789731380233187450447601923200940245867350452740262838226225190609820370295788211322649123632462359775423525028342212685065285340677150775975377535304193511467433642558051880721509903551734918770437290423459575630691458246753053781911920213781359269701054911306805154555900110922082560240552383462997091581344071371898945124579942890212884157480690030608642412718553663621166984809943416377760511277293309266002660920057986812713834286105917906994123454136282734575491331466398376149339687256067046211693583365139566277078465590974831719008922346550832203625018027677384881550812616859062557602326876917007295837285395958659564619648643660886787568897935260714149576409396123568466159638189106586294698441834959178055129829400023175831131347353301975159162607430388944265333957320008763399315833813204072398219624784292760029884336986083765718974599868588369803958250722941186200927629068533131206606358516915575946151796114755839515090008583053127275522960856309803710435391532659761148159056063737415313447223692618481755226741965806404046000911890471687770819818468191498963275597290918829946587949800743233782182182556250065144124162621892548638539612876876425925841525371502637320195203406267163888251635748130237367760046378885368762931869674463997850693710827301611877816963268156023896329548782009213418125167213668956004798192602829289267120309078506293701360713639694356397970443891477202000065327547088106117171866175277040421792053836288865202893702267617413504651510848910218599110960388486480603517258173099330848356166056516860834500534451784022576183206940041562680089775154738867622275782949977333964057035233273148666736192016502912107750891881151747059755151993684625597496577921240157713136835727546099089944716848099007295500578714682150942901714159805821406864874203447416412681777739358535853527875825309229566250257667955302201983151221532574450842355791762406003917018839235999657213160237754760857320561333078124297455062471230870123603895511658597860220107088607380690098026462334689052518447029630721094303152541676708997933174882317048857557495826120208075452995084327396385788621644912374918486175184067237681668287409050135827377079219491266375203267845680948315203125590359146840513193078632412843726536584781532470970656990505794445049905931139138916217023503993640870103337134068016438153117613506476303352214064255496910437370439228060259178037024870993838784107706934999858987737080215152170616869684071324880061132910867484881797085770792410531026391550101895692397101928349258522761006768378989725933948218570020038321179423692220492032924575092980029722461326705715404749717488681851503668202220228273927614777274484801139038234522503115605382377649954863459965735478722181901735578547755352490914177712837059457453571258027336824888929960439404420668452284878598445254315869077512744393890597704612987062693414731021343714767403380941896805543372512313591139343776432010610497226906037724509120972231127804002797674446851465568630558410597330640057252691896186026261372371628896714586703385756534733351362186255943628533030491347718348504186536456481471207708310664947697531287427343080963931357509034111650275232200852217008979534731636077664377110289829441711466227021896556900992544266229384776880877690942035060117292124693866548241632664116103079322389360850404125785069761542805358717895427500321437937561376241134312686938080493845008829461761260111944021901067865127066244297106277092180176286163870917232679891849789919224776382384279833849832108774333828739160480175377444282699342374515982022335455027147895251580706545221117894754699731167714219212146408681740052959394566458797358853472698744520128566508860750610935278251522532047874155198901323121922891237290999372509866276770027981774883231164230423345464663567674980291560408652880189984809686833939161951539414003453181863475860736690047200410075939379741152172877937530612666263481090346788490958710305326985891224610543282442007205304115834373897702056477494072978701592758088865272323270693710043929261987286205229708656798046438526139369000584037677144735868059827919010950953286543578066982180341243036239225638590222646915117117500219304788408413816562993828341715402938666161376717174931182410366777992508252197931414592154229297376595917455221687735417045558287448262810657655247244484525487670066452384970999937556026798335137628332500081452843987635650896274853828076474803033985532483433741306270227301647626462259648745670947705094330378821878014378477427373076700354852628353629917071500731824763202673044581707682098704926240172777916575288679053399001108483169215447580559699608068918020296343250819473760592708800863597466070131968874567880823463858291061018362945721407833214509679292680683927339570367843534933183413020808328250705498724572233896811503136294324334052792391165788454756253345011912690872921844103831146274404747174996164232922256362566373543561203433566781685462794332571008331493075216410853619359072806746405326360310961687835222868039489710881549847129803918952593771971896714340931616416563720277470576828940766223128047287217679021183488834507985521002618529298366550521506217989048217642343506145830106940954017690468720883313155585528739558526815139310026984347617023729949907471351245199190241376802368802742384124086158699577559134590888314977203443955835603273943058765640224911822486562367827633964040071784306268005019351190832544899043935115055765493669151526293543967908941211232083927239604755910947147063630967056725487296515818299835437676280383008078486174357763781308262013652029721934980264275068211763398576840855197039061902363015569806419850832552350144175978618970845583646507774830371949150787558228368502266174221009019874848145621038008598162202417983596588261843283963124411695644847320018084743277574108331811499691759980740218833736005204926416708949426012995932491933828640142469956165371990007502466747270540457455775254689776897736378585490606385544843290372661782899604679811229129832611137224809177509429414080719942563838578160615303346220553002342645598059977329894736963545137735125428964483303359959524758289686407076677287667640704499380942171489839122034100098766522186603202055844530847365602392304475568983534926434611327246901178884223039853891163657974972598801096740669571691942355687105913695888962580538509379019568538663341258126906909984024285428922841196578267684570612831089471505825524577528465017015416957102789111345599188250466339269927205106572426369486409171307809172426469301776547742901504161687867307368243441541879142042327682978277800389906869805685770611546102868668794076019664015702988088414936473644747972684807498413164917655553262555254207583876428237716878354138096923833219898615902145217817699507428997526285568032225979060352809858934979575767435994094629510455429827771642340538855765463682140289281659142146686698170562804795809935379108838325846804250763105862252824948088931159856559258610906279697124987095829093899303904797182231909681582091505012348133921681646966460348990851339271512857853555837870424753833891673147582452941710628390729426741414314931395304789194663736353182735505409868130753982454765765613137792268028209143157440351476185093550271388575667085146802690367531995204611367052208861680241242289488382941197630741418585826977847648415085214939508523736053085522724819697926604698487228815579917248280979839691009766389537346456396178589751288670478642533543863646526413893452037048840616107828591431962282923159645380735652513568233012717471754135113548940916072362670264986312696062073412890871958328554768867228804740068895266045349592627483626258198924026163471297673944692745012306008754275588742386636249538122730161407934276223830865305555312683060888380285872123148543105968509487333010981556212691023978814099862293511102310644654674394726676741840847517193237727304854036176064969472651717133819141422615123864096222178634794025442830752281186706552456328194709589639285571800945562842374767823098005512335475327602356139893723967187034259395238106296510821219491764222334872591471554122146839665397259110858861359279248235669995262486260031548802306328569818644330938786135121425914174041192326088209237671710652793570885731443937193990643491846638983687008614632777929505075291973608553615956903154433177260694557985425422305326257613705839911225371135522011972370497695429522913381279102414505482524232868473480771665768958644808837687667856584123066496508283943133509397378630140384238859521121872390280876636289838192555454442254878889317758729312798858649534559818165629785484744048986111278327783510300522791315963838543155940586927117110400809804956374014351307721770429578248771726157123072638420888204713576691009299417916314134788884611996068834014465701954706671890624827878374220206530266136568381705718981352106013155976392846202033999011840082783221229359344139256842960269192400288754439431595025984285725822567339451752529042885573271007913181198980058908588133525033298710945616112485263231455145338638064849928346075947114315491594617525580573563401981581595952023470182427073448858419812511008532275330332848878588506502878939168098911228525465188708184532914395179478471157605916529778031902971652399700593053134673097883487578399956314528466983016327112592296108560676175557595339845290469765977986050170522530454894780525822052298503491685520738897252241310411400694188493702640634540998121201910366489995592345766425800532682660001013132102833167656808958410994935348309392529230476614206890334854816579080871339690768249830705929962077885475493068450271649048827151170680987496647204092264142990545863266415848775864100230680336626986288829328819238525102217537867959521749802546436024248923856098794665004285720797018376096640618621942243326611303302932276004418770923304025155334315820831945999531701325164320919002373935285722350655123310389798679498703727812766344202745770810776973131875295485429865522517977791723294512040533554781209305196082254165373354635528402434401944348590049843340983247821577502494539960380035141614015068952685797440191758622035106742403977549083255175100746286233782163629445320560487605676726035077629632387872942704432908874386390621625162133416441292348604014152129857924148541586712198510994493644558437465573660078419206107492526640621669186942686545706833390212685666591029003176412290334102605355751226658431097396621022719893559657303069726176647870223127976931805287788662252216041764401735275828920663579257155872842430898800288256467360368665358336243765341334707249756288756980815431504904494665029957736322599219761996085503995800150446857758762417462818205693361332011927948605439407376544936559323823188673115989372467946797338563598781147502347730221985953476234060061460034009736867081071306981844859524931049824293219544084758764654961311856784015555560158315492869839268896008392638630823604155564048806213857620052497546215087586222163898563112384498342709746239985273451625254676371442662666797640839054989046359119650900565379432676881379610789135675024909013422672900886366375069033126017484851211006681515286159606580747399449674519251310053826389465516009068360517967967752848280274822430415125175158077614742383174425349746615742676968041155615259625206057351442736431365978711636395852124592875920294619768953406157324682102369278310062779582169437451074379287665415867368158317819792050658200062065381513015926564968926784566060838212740733039879862411474886157071618895403470911128001246853741676530554373470374678712804967616627239013887375811255271248214720973548311192778688271626291621278323136827062890101119542829934399687179273395553505989116137057592693090873002244524774893837991592262959351422999554790947966136578138495980250007483252269813943556451966864055051816557825013871104362821126646334075350374437314482960421227561494245970005956984459286141981057994809087024360976662383664505734208796034121749117313340718284175405413718008151975103725091227756391945375501944923488813180783113738470791452533983158196971425073139609139317598712229924443826435749855454565924576788156157568215362102475650036742278016367059789602026218395416110684269932428314792410398729977093074589580530274853696434326650548082743624384231846326080664583602835649618092135550645611653547161522974258620878902326453440927136236946983613424879327032568360227343079322919350241707609642788854490335597873120673761311147059787518111605820534182688354746703751637725082005817930298815360638775069305292082559715870224717812565411148357005951207661127153995923412259798914484409962610214860444983915702267464639490014600996153042625275269090607928069673850728370754197558728812466509516566436979633268006627667246159149017142663140694058904055958321611715738005545033361826657350553098262410257742255653226253939606631891780490182600276102674326902585089513405868592881390417094053145739987673001112233096761138894870807257039873026394229506543821628470253373003904928230243552507079230333200955581261603347284226473244387780467794591820256516305220839199833965606310849867046762462599479438491348665818867455713906939104848944680198584764438788361551174456060940295611283796706271042878362642279281217061574760068571469028728573550774422262442662125777900100469881719543378098216886384516114461201195094546307150074006867843517239262359172050584632819429230939378125623136237497006408854804425100205300028155318414055586630135025074746289797386196735987159940345920815817930351532046284026376194644087152202480078433513975445465973986092216735371898556834120460217904438922931359040579880396358249581435187824266229467640581336876847039479499511775100191696259592479453845241774405899940594958426736121158265305205240901613982192938132164623363752383706012067998446258469802958144795625466443657884528110690619442616506618613988338713955501071895728888937280531792087802981222801071099639108035347474781841090993741459837241450220966757200453637946000697631779039674641621296243504530399520930469425080255490906687359338872971502385471020453554878901870336752222825765780475442191798983327236649069382252743482174374880110633814631848487948177987609100180679769994979511994574164971629629116759563083025913477660314212068316823783643846309684489238870409976761913989906824032463763134328303097516461674725116098143610268181953267617393208411634378285179191047686553137888091296684753904742658211681866179038792833871765440058253245762867526043838399414082410733664874674555245461596269520439154824962248460613608370964339484538085492992515142750657397753763080855313235994750564136887663560563362668603330013252630012300678129464429487288990754057026491697981401486577121379471816911756065025647251111955878212234544059312167557688697927968582420471657270364722142188246660401003776056345434997164910321938001645349908593781804836112723375266929897107651529407059743788660340733809543929953684383625247440410346962162206912800879882642498361780257538453934698937359080475615894782376939927882843969210762445275248122321534639690155083592186788011757056864278669645661907649863635201822519411990500242709663592239068273293421654105033223566333985342700653004178857285971749743344487551608839352087987346461010482601275783969383590065286038168278984759404111998388791339607186614039368684319454574823052376133061142832590050733675077974330252070780105056994521031322288113378606831607347916945085371059652008863693597439893939312629193952855199008909604948872529094843907794101386784274767741585581829320160255628096431549425626509249762977005010867731063421878836134654449964878250464783313329455159179716511780740374318603338890843298838234347864902724837291245833199407873944197490419316303536892971218390915109384292569103261926769844048959243359164337417271564919004059356495016969732166377503273684238035533526467910366288812604276433729433991435584200952115982927460218369821742851123584150575586142507771791364840239039764439174011217735810549596881258056314398213080341784721301738085105033452200371560336745158388150771676472039026380483448467747665507228192582746014968326500660909946008867411119850709082325845485563887773875149225086168283076903983450708470561592421012532448431491194522858119905193301018854003194166198214532910763860900619143063034195884686969898796195237659277464298777865073590081034475357034342592000934938163739749353468237264041716373819197473012857917492516563173157691652825322319295345841508975629347394771456306377622641344165578275894563161509268803983057086202711790441318680371978843528204195364800166722535327569814589581299151259594397390315284545459148792178791708503318375411423714046302538698190322198771895356667395429885166789736068955550120989502941035179651216154772704067673772877863027555390868914634192577685567598408548579896211077434630689462076607444886345014056435604731567826105253902399494497988019997788880129950336859964174391243928666544907475193308554618542859261292867400134177918261684644729485057820486131733476754785922503730935550294579784789001482880351270682337111873210116045992972533792132108057919164920182694600505081697999186991534891103530068952376499244887814107212140789768089082644305844698893853144052915970578975107401413475912213102566275397716535968812920207795680520124877985793112512656811095889157738486694184265486083083854988501855703326371741330889176944541600810193065014084394068487333594970125998541753174244213684309065464917895861634806706925392699419145146015893569221383816606144822560445581392091757611288472431171653287718353960101761350945843524569561836461908754840284213040929367265016249092746107370702159235092448905250964094917114813554335972975749817812306960559148416028506171177477131566520478115641801408845671109008667317557259705160135144030914466333655477127469357158561401154761644575711949654628409243114217454951990569886766915510224725913106481719022693455862112643042146399158828303153743218178078052873094839018090406579702132526607208967105316623971322985546399160960340359885497772647942869447389129932551811360169150866994483966383926596383040241176516757449563044002830506325110679412069821120778072826547167746183004836679167946044860469753931426721195653817833385304364048773459187412746958863568163430252192533204639481333607563640883008954563772872905257234904512222540650332901526567254222239066048737871914094919618843514151139826658368775483069744971196463324378323126578604767586582431616926097023721183464786665504295668485490311488484232862025323664443613981488989720350137022967650460632473459182754109801617923731719585399644828450416986404078254316927471480339759176565754407829045156677545114211743399043637795332332408743720618982823931325912856046061344200019634275666741461200006044221632376295858833443846793525706306077573010896293576745062926903096076278106977890246712745449167483118232537047383337063862965387095661257223445799629893673488822367470165327156747584915485041277648783956171338156433912190874844409116076141781396965295676680505381618576384705616705955646215845843077923512864758153152854956200041158908199505491290931546309392564065320960912796839565073254732266892555293339402303771824776842822122824103880061859433304261583270626533435242929674122972963951801772234759260651099109985735480689152585747812939122741127309047501575331638984171706827339135638330086515362585532487469006047057905977943433536571538392012517108782715912602601631597741558416965327339448724698817342589867577766152670700108601401072361996062541923646798942785540085481377377921698364245545858894809286025372487576966137662667875434346370856214138334978554695057257555821674477070248719208565554328803658614533173153832029530506204524647433254655533969529792877257410349198743929755510314176024383161198275157169441100792678111496283920645900735716609979571697675174293893584904031394263689911202134227252888521338742710384332097094560649184024858059741021714418004430679870513793741649730634815700745777976721348373532076469180903498049734639340482964954071728195284611233063417347969305638351158515260569251758141384597462992351089359063408820476548868146495786628473661845197883299837426400200258713369937619612669638891760372606498061975714243061612914806793357165635436313737642687780999487830027336040659438737736080329913398425022897204748562452164943445337960751538162651294976912836229769714531372168994920425547232763037412754211523285626149052927595805060239040013317036358432754290611653065538721293553255098607183409923955775759644919188483517104612723566950829059337296631668519055418142191315537353261618695231246950133127739254327228263292963279359881919130630342701578215720177595337947515329236763028778951452487162839446395851608604286960393206190873761126712084930544442652478733906141021947337858435632138637847783360440470768717684404561362261968987065878479274601796911121497648679190733189704029865398026351809414360959087992780926224086222807556935713208125871003845842836140602498052133217924479325795224799337286507479269518280244309156227577624947958441579932036039332188624983048057250449556492575360605533960946233383754378794019988013612585267890076688418499157032960000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"),\n        9500 to BigDecimal(\"92178090979573850793909118868889056744319819020035944990953384342210563607816495149968366908085149897092321809310070935021986939283614429144917522099584436428497279568303061742775511285370987462776416863179133160625419964065675825371625750472179032877992209010679032655437013355821102447488305246763470296864990342304792574249525316236301172501989512908084191899577562337873929923328782631665337387466749849412193171505879367346635084977099496838103487099014656822195093809940639557150117141737912371581240939440735249781382835100894705955188936570949632590304447150216749264853403331159943116629049216398263399445418794903163315547334731164523184081326446357784512877139242262395046503462423215128373944677788445002432436260893420842984769194713638940323295846170076119692630990692507949380600316431839558900677738496660920898845959455861220932298283019843929506413697191379148579807173994859705491995969230175501501624061781847613896078165297994946229669265216666803814919696531897525900145202796629341300178103851510023454045958889596046423810001630173852088993604040827652722274407512976207129239471182481570473796188934002776875236476438050291274400783093665249630001027308612432192597763270936122773173147801322497451865180772301684098258798445311040597842940897664601611660989698198593460026730854840109981565641914122445485882420133648560180938714719937062992095434488555270953852653868896307844859233453117946393642255527064494608267216566859481515603026184519957843996226813329494563646058941907627441398019651035769886193217395617725056558135861757115113474895161811856110090690103790489527522960780521049306623490440657337886052334716003896045430585224041403171773754001778104428382596234437540998558473466260577985391018255891356981247238397840689559775417229673181202067031470770925346851421571524515985806402099042753047028427158867696337829366575662791585829547310012369460854244780360140563653489472240530994709058574824356811423425302932093014274206928673153665379510998181542723301879675917325105635403393699237602925730721673541022249575075874742654116358759286584808280416156465855440882030685371259121414096012889672161380234713934989845362695918280606932171760971957923437964650291108583873699286410815041617044193151285597401450313782612546447584154652567201374727826813491673712816831869336536884685034235260951186697751083895725291543936718882362919294032122360591804221941215632488718501220926859932805100998699620915040671342990221414192613489455557150873802226720746131578092630580974129840711967940117121073888050169816299134622057335381660860053953489065286833678460749051305438002051311256163486785297650800527578902613424742051935379689411762707200752353896108718034576653442875901915962043395970746035916198746753410820040487564428600328822532687233577809206040939694183261031105614124168941933892226033792907225075537129688158002034431789719094975255643223468884172136830404517919698533043621248761216892565281667625845863845174472065024854114920304098737818186100297923106009058761210105306509202673340276635010282634786565372762620753624238195738438396287035239105355586933496120007450759912661829076119467453154863807969127976104605088920358664404819253026684172146922930957795216702177325323896504040416590579941921412747198134337389858838540430748675115038960924253778703802475201395382936824469958163624174617529265645370539968375217327921740677034903335634809156698244160971939296811715864012573931390089042669247007613602687125145528277938850818012272396796720030610016799106626650827238553427505302385985547093518860631053364102407409447768362342853667697929931472657220592776875398414752792969132462993775753250042861287953089184792379499761179437380190396667506086727059159343093975760590958283385724792668965175442256873051551371180004748071355812838321711077314655317620094277100038230428394325858618011612661337481604233472047184503164924726997361220342851082447278254637313299101650862633565327320358980253701290264872868394682485011766370210270356360655091850426580298129438341500714487148242995461131804679320692380952525350751693080991351856301743653175682805745211405575709040034667946395468163560814746951906328007878228530296397108861152548811118107171493890600264943649672879818945515869794341597505252324455770956705343464619068099552886589318227173020723092295725542387661029891414314291996039168009772164297707043967348882262255565035146836067917955137823095686718805642075661973381084833275943448079384110965839642153343459422138192137558343177625048409456743033979138454819511353412398868973616217594504924793321699435334917457196908900027965004821352484662601265336069051614891441371467023125063179830955545791934150731103903401093932691140565942520288051601500008383242127754300099415813333910177873385090597619348050157327795728064972919078283539189137464391937918143480340115535037555116567299785136009476345207751284655675923200966813864996792659491876037639310586900988321666226718589651180544076488647545660608700095153780404644439448157683975135840006295626172347290829014081911428308796915395685719729016734225398036308088230876157801785053728558351938903113126148908115124433846075814580210837747835849517351045054558433669945245849235932415249320446064656676032434696323634514423058943717131799723858586510122927530245589160691374097318019327013509377224979097481038170924161760935460932874156663739610835785482660986655828562779019580375644974295999866750767608333848326686922098870833755924798188287171135773356683668476654822664067124400970253870339795846705993568016662197756444508535632853679779872516303134627346839664395625515731532231138475391403878725812573637867655829439816413841761225402783568940514192419348436201823894026583177906554171032782969970855742139737142305259189705466069393727245611103617749459853560517743055864701539439971722886095844416088944289022827762238690948470216659389781797064376832613265407819052780378754188020631066337587161587245325644360561273052098123095188509330659309789027685577886102744208451787279187865965555288041730485979464101752914400948827216687095762645766869423816215343022075247587820515646728190155610255342948716344236202280064150521186551199449088607526971956536506709314156316795233988812713027494188237683510633961581799561721854164015090474790037432667185544330887169127788587947995071827457365589658544224542638742978422206950158071342791576933542631319243725790061276490773516456415750409344398036058390828880040543767876668082015064486618527667721087006779191443386889309201544863939491194035299592922210848403537200219388250028619164321693417485893151298258989791511128246054575515597828887805483040130997732054490287976061528816395468949932609274979355381129833954262547163740263577064558530784205482859444512678234700013600981620139451022715486680422529644101267599589012931884996369343405200985271132607164117914852484649778691214519126017592518097663849290789731518813568597932932895164104496763831314118922922538800672575597344281442539490230869154008453617028561617626291361118303972072772105026054082239374689620066728318216334980020412191788170460493804231635056630454627446929410442519360301437284710166833599598719179942365864524393550448435596207874745483536221446247937203063383486004959980157079511966639186073980922686170468963188382470073389786945448888865660413466958098667437353710412692864932273509113889224918172964013925046288336325128431340338254734914098058621511969382246213476232029068966697417277968040066196161546053720091731091246940116481931763677891348536976494411347855687901573185680638073142843908866608714727506733883087036055479590954436823843983328079346813561750288287629367137461833968329235203027126384018804518065537209193595113287125271377091055370452029827961624794466841779574123940739372835799147971294217248422214442541605870879607871572191674916143923392382761861392806778195852160780696795562411507294788193036723893670829568602650100364353449660081552832798128103291941733551850282381513497671941146516674288956391380016380901821273049342268507508758797940616089486409751116308069014264705596315384646014078608532025636878842599916887285771324887099198385553576689444540921587776646992043179428197106583330036082392491430785821266805244162433927804618477941145052612331372954585859545713735962635668738934908603258719938495356282165385934767908355967650127550700803388892398648261169142342872826037068157978386351474299295178105236460893815746507590382029982408382121676134703377682864123191884286059796944683294194269638901481061473934867421968614900620843465691006622413095827219399741485550956051933718880892934450578384285523539198756972606665417938665976778441454185354605737638949064089917651699685883684895961432788903368957315464918907982612220737811063643324857341633076871429015982597332775329889506690476342844895580135615964207498596723510327453186870944779574354410791949382539325250549936845542929236537929167439811942255193181823464900375119748511657030007703639082603993217127042347418894302783148535390026510252289648544856436714942460181791183289866600467708790835106297461283879029504197144089207097107365198387474911757541063629938687910194286068228533703149998173144474618370240094450841398285598612008775360895747189153865243146673739815995730903393469365219887330426193110709586650894218920782825560036298323684385570749240375065186505346637396359906184593404963305013664952521041161764155536728422836331203914538908328296833259981443417236111700761010001130605273024783178910562153961313653053389982553559325898849705288604727576590861066710928274245827812826193726470730990036621228176993151606074310654778754842446913018068106710896560048183187997165853075467348571173601629257655493862444583716166061998841049170137157729017716565808291061651218810860146677530009809541088528798183913140488003246733234839062703159647089046918520588126707626657110011515466946333908724583864987474537860720164437830803648565280665536289735883065512566251786189964416645462538501937727171558164644838126877508092644390032759589596323804501715364242343245037805338625403723354007433006085538280980317233555205944732150618688504988658367608395903290423471537205350230158711864340678366492540740864229990483323752138295840071314970929198939297191713502863718607869731246205787018430676113183614318941170786741910460907567195865964116784699542167406280672906956373772058525669937681760492513758927933313206945679536199558762966051662632259636427738732962281835439529331870143053784721517383029525431216199002306727724230372145742924429966616140676042898627314675819777009964058765803766082955397050307890261987194873154453515989008239976930909440419429529993846646190587102533228499227929213888181346575125319979472427926488311099538946868649062595251908505621681206349968689086172698831564301307539374438057618544931229989186428061951972941530942514923643545207768142298815338150596970898437944666892543621578630544838041102660821393132953938319954796500911084795405135671709464991642478756731705534578645792943575517195503441775855522255184269260726306058338477973023108300519789293303728113286591681765999547860700474478839032841609924637686773181943709197188021724891297045281317466474780708375522057339359951245748187135336720467301554081059214249115117755369109580463265152177181049461431666160091988265160065245347205890371263169858348823057212386323826685935264145532842609975090126343779140657786298369523363627084778842820187115417023020123588917727537160759449806370815637005149746987674714482489445595574832534151213573852746876159249904041942180589872486738932611984297256405763484392351123404675794020409418286277755720738481054394154494125641202987824035046134182048557479025843842509089687636923349922719860193930720817674202030644587883396411848550237909659003391737732531077839911741267829888180136876963886383636008757599182665767173070773147200392576624113095131355419830874801073599273438942872509376637998272421462226844492617453397940403726176011359264637284103964754645110493430591019465069003489639446287814926380026839685054560969453654690713373332324679170209667014950168771331781847684451252633649020458320819660206774758337785975911084138856148633386994011924027452893766745235257030917956620355670584946059726296305381618280554633108598525880599803816874639283793921218761344929366351517743423567449435643479133088150494936658022792119312584415889113248967014820319831932950565717009470309309753610475954422560082597753986592775431787439020676657602193367885564753619669770303310943760495609934910089729811163473264606948430387103630155942999645085767312976151639801045572946855721644365262560629407699231936828376725694793107648589603115074856324786641120820160106676467168529465355482564763789552180220953698741723216172197688749608769397649895414304081375008830873162219129992550659405372834968998674484564682006519754950690595392678700139643171087548343847991226353764739270905670338297582293974550716505003520648033842307414552684296473236953360502430042507980028399102359611993753985638040137608594706652419751851407261350203897666847204007683188183179594241443740476019015309565635656951861768230607033113687387432211745936966048619323092227675838796122057479485542577225570862632967957225897794379770172816658390583259846050238823444678635937541372316138190589744197088597537376198761808367588332571469845391091018532829179185724669706038494810111309224976330405859604425132422726453102301992564098043765233730933743615016969541509698968287689863840153273345551289742379731498611400599070250272631724090369375141544422415409523048449227091092530078654244806364917267880264983095696726001678685302027484890977950793831637380240062861671010417256796189826207340411536618071137972247837854443839433234285411742451523781301147966137655762318012286007421467968276076623109684689496357241587310435963481273998921367018489766781091886084961555381465564688982523018737470190154931471878119331394781988233532200048981468864485215406311550859895740786463854711982236966159266668493370673994947633644023835618768800971971938408825575111166890275945641254397951068719090970890443799859484642477099061306449493136446254245630302202967364625356148984464051877483746699117014640403630274587340595415906327400344856263673558248326933821477144150144444701930551918002693026542607942531643903467565381424074156512172247654668892356021029737362348538896202238634432699617236381596952609076516302560283212871134723755585074907633493788113111423599328512806449416189634206656497001462807230383738549461922987634158501233445560479236100300737826923829348062076837829135609792051562165693261377854906271536366913940403324472397634791160912567102376311505170628625000784740428245038069664286597876591097451564656526466510952859672456751839838863353222518196343071197314184743371531730777111893148026073408471588150796016575131261987143453464829878303486176541879434917252837314166859195497196882298391945676374778058077751018337484371507155050316202802295679530219461046604911450333499750965859757099839843058752848602427510487264937743732783515634695159599060758074908558679176424045576311950249894461515092809101495498556439737694382756903986138426692237877175869339556287215498981822856160655338657009435024411562434350558476402241162924987970630735859066008994506226343521247179128771321877790821599910369264589630947015139946941615861295412363783500699059828441048358582460187329484234827974914287256208782505686982480385770055419752257714582486848984554996141593466391762961716267699799801163182523986432813437712120067897841188935220114449002202089563440251178915619984142964774581581336402301551025439870743738619229482647837611509799986154019145763980270656719945058992314518648393006155751911430290286528952202881249852208050312232053298518375728756015698510584925237883793787936304372489737504258207818626796521180897595277440242282715692770918790855800269905177090140348151754438794501281496489095037933891872068664571101868708767863799198007952300645745483903336116659228261093089326512334659744895897405702319507853763520183096595806248917609336647998655421696046260748101209249551169900195121765458945338756802109346912197554834176879710481849743721087032949143204382146941894884452475425620547847054350988339057875386414988127324552106546414707849536492150320701578266709705922704051075243068740260555002626321403783347147372354299879104472420579539168622943214344235711578036607803774221129245346992653876285273159384131125223444052079360330210824923900072845303821003148899527501899443036694350093175825261095616393331767418232563467714641665208526576373850922617119532086493269628791295341048714762570230243997206253965978280468470861426593610900419535535639277865113596709097567536313154105383725666987650610756339276058337986605484855940547057115282857498438631934105301698835279484304724190623057482537806940479907025890590797096418226452267702588537546566677407981671927351044628241598795912839020964297220557522404025217120740673985409750657724275219869569149192908601128966968912984508145146843795102819289942434281171356322988040227663297647521378355581078554897592273145318805165342557225077641466222064887757819561416959441086963540069641948876519647394275578605171558464604299393827136943372786608750284934060812703930636366657128009206479384111483277626256767928569717799621481025321545129108118415873802949759256582085781144249500248666343632203460903489619121916683924212318073308160447380354268173706389396870653590103260092627702383353967227220325459201023839504396752186195559418414474655688677100466363359661533889985413870026547459198697574866212526156074108992424775651937068837585497018143945778603093761389458252689241108541362940874767853398125982791927276067035163761663736655259983952220403463198906449846318840611689064904057425808123723166773444748890118146592245407114929788142264963512025464696550741280919795719987100035696974747194507057729890655205233369529082349983531839782028886999527834583447851538790422553523039947883622478021390891479006688523630595308527692368626638649838905318503593339595220500241434670426198796692601837150115491146570028961503693254081266592771441165175631146068078070762975757402941610227043346762259450948038196365234105514905688319300889571461597333769520279005909061177988576281420817149761853268890147038729578255850656101867418253135649514158760462301879886589648888555334396471823284791834882458390152433921953314723079824196100395552361659362175231893200222365629353524256910161615901495051164147532330452885808160105390727858867722018126742847253613338520061276627976162917118809737037752814909898748834451355775433381797681089332459985769326544000945479627895192565621573022352301880517429301718324048398654186968568554375351372116868739766767428554580309351250484483430686701935314343061676971059201767165073973800457634071021360050144037890480455398018836031644848518943756071837946194724950171929443266075910415166182794560577436621530361857225011623009205354123305984549893323394759295157403085438719353332741427121344948100814051934870481554764889134835335182627393534942725855639728148007006247585083051568000715167490851924823328803743252067321788824401632658058764926153492840002778731197970251461065088754647632435102418567424804611976555103759463003111816668831146426703533887457834975921452810836865201439567409776329965101438295042085327261373290662196839063564612557716150839648173513751149343082966041558669262994684276864419611037134190481930741287170182851736240151105891915682425280360935787900384545370625868016111691928711235030962033850235261197263031540203566997226790152515595393274022995556559046957039654659092431348327804002533130562436858227235498630182629230427097079542633111546461914643350092818520497931226110233528619984174794420580384110443862829503717734212013160132063696628864685549095939128747256394841525996805297635064400673981471295342638283454532406592081640501035974813332691211364819802411608900156687923457350439200929437996916039920580163553761858203808046893203771900598178176251580515219644861081348701270042297749953820395173904101360338349773791519020947227269735134677033654473994646653192599258945019849950301177210989961127922870306745188699500853349683729731797003051454531987267025322028417432423846157696424726316220375593730759702055094609863950093300424031673558885723847515625033181671371939940140850502992158454685398103566029615954224507642885803077191216091287716562804363965138236278695233423848691054724452567053839145297395521168301686403066747605417020533255766610580396845559422557355262568907330073697589858959706727013836488976536654611267245287484266762693786511209684357465935510763304201978581751132656321068794176971204546643435007546420796243749002196616130320603148268823253290294643389289878505916518500344969342021683768718716167654990836178917056316195817617748240109543849600893215681259880485781646806323046259841415303554235653886307094591901881380090398837590121040212206211628477969439551464806521954109523522674656047899824653476131173438518558326376594657075866431466264752345396433042250659172600810089080452881279256362885143631320873678748923044718989656637053676282196684058535161748436389132108495253487943764847478349368916865663364474263179098983815518203848201119494496896685091365619854805686973275182127391356256396959105415867531541252783831866575450959270393384681902256915288051135259812218314400138696539446050056897042934180586687426558706557243279444369481755052964070329032908989756102283496535643977006394138204385086598674658769799172949335523399338051829833287978956916793044859313915948419044859779234777935348708061767776318017445600146593883567065387980957916747376385372769404004116522520036519450183611371481383977285886326784588502860633949208506137226901156581929314540979394928385916751970886437763011845689460866491922523040637175239243818401194023728142366930795697291954614663232033726994246813399594689140779250788248190174218244405263834631983361918416233369343747831244496111504723848329053664550063580326578914362814596618995568943852224733371311441691696091867603749176110759326382189254751879992190268307315314774506669580738825678362964511391668386160372510749415651791380309714228368460735178039490395267742757463557009686855603179168725864209364224539192795299697117089285668895339391030141856114686661907653551194353257385833405374160121958922285956765325241257345782391605843390215439577135660811479817212372938294325024937428456002565946702834996846208205767167567163991767368560379889161368938706858519927202510812023315392164855172120729684329818744475450702361550468918550268464540500269700971142148472764696393712558476149170313886177352175535676524546404865777080857180090151342859185978486060176566324326943718680547056261997915894991194109322210630818915014592921472452740780036794056864086078522168214889477637070197641267826001264605261280237875068648891588953914165640294730247227497875575865505459569143377322405365577997574520029593144622646757786228163490558219736751917226915209097078529726906285425574561059423069465426983377290180578202175567803250976673498034921723663009868488906067396396348885452002526044596143463532198604604717608900198043922129367923691073083887467070454082804711246145928184512425867533803986204128872315065425002556780860443005041731131765189412494294719365002261431022429747919017908252984287480072240848190213609446745795138208283146109423481267307479310079749350683974450958581781399944043757523822080481520899711326868220141671472382284819512331338492710653150447803802045462131601984879570739887279692083996958657101411204482653578780250240939770768995295101669853913133009058207249032632463511283280362512138057537716079893202196961310640295942678027712313828526481171485863155362737608931877535241752148163677619060880058292548914170405008076662169747486034494855791294531334898248510715962049352727971740053613779499901432206968536777485880878977950659957090246888830877517011974285792277933849564544996135633131177180531959737330750103594337370536220606022667735016660336615604027902173317129699992339103290083081414401365215050413934031572645434162631297463656725432165974456029863815199218990915918460399369242983143771724298232022237565442802908674728067575630160498169708625420133375399145482836693235611236405248942508011339994308242647475546426706315514289558643721073477689681872781564540674365659806047235429497176115208846531510677292016480241395003469325938672442746501958279487418429454464993255765967943128218546953142112340759390793371509278119246420895176892109503196039721324191193413457764281028445642678808390496445497495333519811283620076402279282504633692381887404155249137742836664765307620583324628817135615220416644715954859208199862914830679023420506858463486593324345075910904207680234177806727971915788624428776470175858296861432603204255199814697447449422151250480421792306904373452089089785996562683631617912102433921193775396305943208053743690975467744933339773007378326100543244788584193779460670106698526054395282274788538924499428218129871485354844368234644865470245198143574962250499089207841511128876886982276794639861853937261723870243340690490169383229536681852729374676611657190095621190919604841366079372936745324373960872355872985591466500229463031840085021743255206877405288085166734713461340739126445097827058294861054965947076523475036732558632081315838158371928404043272603632820803801647031562057141593882289463278752650509738121903421162356528364936010349212573158643329275587307885765114354808208261370302819305480434750969823747915310873681214437881801919276868652332003928701130524690581041553872388234686383061230183812960942962520768799559590304770785077914167679937644765803471481015469893766046753180540074315152622326140385299337821979601132613763650442909810812915250690675799742634293937278930385493049314639110025635722768715784001030627953733450528625110898269310382657541263347762814310584054987264907791985222683904736893761155989370669183716666500389309795624170958917614068537318052322044993553989637779461787275818328975425877378246603571169527426425288506116734789121143477472874984118024294819817565352567264363301504535475889892796262432133476314477079587909389980407950789462917568617889634277164961149389095048192880320129658457756255490234622223811287817139172288723286881656645371702363538481272970722478004346718945647397471138327020844429457344745687328750933695354369391259707939204887929409748083674552621977422964198760913478160110908775624594127544909574575180976653980487380423751361936479517451470692182837741180567100885501276804168799931157519869099187555992431625601245066255688756994372433575653273840350791179353883053507290884050238737522963122596799613046478955814486674042599616393368492304481662175110345965865813558803253100524432541640838451448269499868327717423990246807819496696978671319684967856425693862695292668690002786797204976411307240816238105285095364254276634535310042058402503106329159520913193452937841573976824324585897829344423038813465128058330028752012163151225808647710268205120252855133079765380308802256618543977813124926599748274340086425744546139927527778448168576469936855330094322445708253472838913529594871565140459241028018674694679095176955869787885995146549828680794214889890785755824182592584851878969272265356582164625528939584589406119270895713634305258000840309143197188606358603000971213453055453273211534544135895120535797040468141608776143309468953241962376466243204805647404589313291235076057243134175643121307051536534986354085668948379750281093118604943505061840676323078490785406076645357906407919960288313591115619257022826271611061990476920734659075879382539542614584686578167625565731892644845792135212139711067205404021513233620888001175257766797362883449506420397897758879926454172384267478628224442566781985299441830488177036910306084637289482068636980082311840331981009639526326620729435364621027683296103715704347490798829731773238565783914524516474226133337000139408629533733432642206403959021211765267659076878787615850103459608930086052637977164283898024040314890392992613740708258373882452304190024297368748003834932956611451564739267953657743649929598394277165354525668185517605196962931596031999804926229367353669865422965283464866608677948715810885694648023240591979925897767511685551597379886408835553709498053271322975087879389879085503198827923532464321310609158710187455671869686344677896988316359529403827936929714459300445340357938133865515430276221493752768046292001904125048106262657465516461370145459758294677562148769011127861857128652911218933975795429689691664043973394231059573406200874202136627744376771153687649353090115486269689274322155958790231251678328935407311473189115847540767048032588398265934533685240327547563415114383047146196981266512807280045715781966202549817555354511813239521169025690997144405337513993162442537965623642645886983489616636733380917821232507590866155424032354355477602904314245989744613370625992172556743028144850176972696526385153689785616712596570457369875825512411071469296145459940946721391327392502453035243633078937074165875500326136335025173594653883180456904148575233933324719201995944742335065591347810078726252468502582294800162796841054608547538327936881984108278087115955991478041602687465193767096659026513219700188166705377752716887246519433405564167712932818085738333397516098028971146114129692214272975500325854240727657093665523953812631463923745251750149845379670705905863412896560938491821662770958771252844980416275362824290632286511692026878003496608646742213283168466619688943109435554768974003094596382701581124287061546983967207099668431986658407278512867674341788253659894479684337355548673086871759633514172558630261193467912266052453348945912443565385462554924263660098246272221132033417508513561878717715940736037712496002549229294444419669088179713707415441876547203227407092223776476182898036845381122809078990169510269868072582965447599073354974917572875952726891697470859221728824502974863256398210571420791329753480381391512378945578144492652668655362692192280822525185190529961774663589384238836341591982589068538100685696562937747592946067191291787944191184071742211670964677618297785242743602387506752369678010417759907788337309928806404196520087817881575435725575464189256235905449772706980620120805224241122561756091469395148754191408872046674318925157517858099215354198853715237582099054030819162567421682985400729539100149079995899789591834039601598002204704691770242323537452153443797513841637605731868319389283245650277033858403010138538479568788780478022320051435923482041846924815116175677735942347385008007339468235386048077301279385730681887197621776662101895666085742604767914787578504761857845593279111932641341653270668681075209332961355927690612457695623644350837695632829569287085777564002707821199919291572551336904777991774062466914280167850414557723410197949847449507546765875829652367316595874873587019348505333611265061484514290277243004440008067594119372369109871882356855766998489130116922254994633623194339080034110441641519444715176948582316838950856616327287609637081954741339570059031425071212219560040034298003464136478628333806184716244296822941388084686538850884861854864347395128784413034698878950189508215622289521753474848459987079690487121223735911331138579034275840000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"),\n        10000 to BigDecimal(\"28462596809170545189064132121198688901480514017027992307941799942744113400037644437729907867577847758158840621423175288300423399401535187390524211613827161748198241998275924182892597878981242531205946599625986706560161572036032397926328736717055741975962099479720346153698119897092611277500484198845410475544642442136573303076703628825803548967461117097369578603670191071512730587281041158640561281165385325968425825995584688146430425589836649317059251717204276597407446133400054194052462303436869154059404066227828248371512038322178644627183822923899638992827221879702459387693803094627332292570555459690027875282242544348021127559019169425429028916907219097083690539873747452483372899521802363282741217040268086769210451555840567172555372015852132829034279989818449313610640381489304499621599999359670892980190336998484404665419236258424947163178961192041233108268651071354516845540936033009607210346944377982349430780626069422302681885227592057029230843126188497606560742586279448827155956831533440534425446648416894580425709461673613187605234982286326452921529423479870603344290737158688499178932580691483168854251956006172372636323974420786924642956012306288720122652952964091508301336630982733806353972901506581822574295475894399765113865541208125788683704239208764484761569001264889271590706306409661628038784044485191643790807186112370622133415415065991843875961023926713276546986163657706626438638029848051952769536195259240930908614471907390768585755934786981720734372093104825475628567777694081564074962275254993384112809289637516990219870492405617531786346939798024619737079041868329931016554150742308393176878366923694849025999607729684293977427536263119825416681531891763234839190821000147178932184227805135181734921901146246875769835373441456013122615221391178759688367364087207937002992038279198038702372078039140312368997608152840306051116709484722224870389199993442071395836983063962232079115624044250808919914319837120445598344047556759489212101498152454543594285414390843564419984224855478532163624030098442855331829253154206551237079705816393460296247697010388742206441536626733715428700789122749340684336442889847100840641600093623935261248037975293343928764398316390312776450722479267851700826669598389526150759007349215197592659192708873202594066382118801988854748266048342256457705743973122259700671936061763513579529821794290797705327283267501488024443528681645026165662837546519006171873442260438919298506071515390031106684727360135816706437861756757439184376479658136100599638689552334648781746143243573224864326798481981458432703035895508420534788493364582482592033288089025782388233265770205248970937047210214248413342465268206806732314214483854074182139621846870108359582946965235632764870475718351616879235068366271743711915723361143070121120767608697851559721846485985918643641716850899625516820910793570231118518174775010804622585521314764897490660752877082897667514951009682329689732000622392888056658036140311285465929084078033974900664953205873164948093883816198658850827382468034897864757116679890423568018303504133875731972630897909435710687797301633918087868474943633533893373586906405848417828065196275826434429258058422212947649402948622670761832988229004072390403733168207417413251656688443079339447019208905620788387585342512820957359307018197708340163817638278562539516825426644614941044711579533262372815468794080423718587423026200264221822694188626212107297776657401018376182280136857586442185863011539843712299107010094061929413223202773193959467006713695377097897778118288242442920864816134179562017471831609687661043140497958198236445807368209404022211181530051433387076607063149616107771117448059552764348333385744040212757031851527298377435921878558552795591028664457917362007221858143309977294778923720717942857756271300923982397921957581197264742642878266682353915687857271620146192244266266708400765665625807109474398740110772811669918806268726626565583345665007890309050656074633078027158530817691223772813510584527326591626219647620571434880215630815259005343721141000303039242866457207328473481712034168186328968865048287367933398443971236735084527340196309427697652684170174990756947982757825835229994315633322107439131550124459005324702680312912392297979030417587823398622373535054642646913502503951009239286585108682088070662734733200354995720397086488066040929854607006339409885836349865466136727880748764700702458790118046518296111277090609016152022111461543158317669957060974618085359390400067892878548827850938637353703904049412684618991272871562655001270833039950257879931705431882752659225814948950746639976007316927310831735883056612614782997663188070063044632429112260691931278881566221591523270457695867512821990938942686601963904489718918597472925310322480210543841044325828472830584297804162405108110326914001900568784396341502696521048920272140232160234898588827371428695339681755106287470907473718188014223487248498558198439094651708364368994306189650243288353279667190184527620551085707626204244509623323204744707831190434499351442625501701771017379551124746159471731862701565571266295855125077711738338208419705893367323724453280456537178514960308802580284067847809414641838659226652806867978843250660537943046250287105104929347267471267499892634627358167146935060495110340755404658170393481046758485625967767959768299409334026387269378365320912287718077451152622642548771835461108886360843272806227776643097283879056728618036048633464893371439415250259459652501520959536157977135595794965729775650902694428088479761276664847003619648906043761934694270444070215317943583831051404915462608728486678750541674146731648999356381312866931427616863537305634586626957894568275065810235950814888778955073939365341937365700848318504475682215444067599203138077073539978036339267334549549296668759922530893898086430606532961793164029612492673080638031873912596151131890359351266480818568366770286537742390746582390910955517179770580797789289752490230737801753142680363914244720257728891784950078117889336629750436804214668197824272980697579391742229456683185815676816288797870624531246651727622758295493421483658868919299587402095696000243560305289829866386892076992834030549710266514322306125231915131843876903823706205399206933943716880466429711476743564486375026847698148853105354063328845062012173302630676481322931561043551941761050712449024873277273112091945865137493190965162497691657553812198566432207978666300398938660238607357858114394715872800893374165033792965832618436073133327526023605115524227228447251463863269369763762510196714380125691227784428426999440829152215904694437282498658085205186576292992775508833128672638418713277780874446643875352644733562441139447628780974650683952982108174967958836452273344694873793471790710064978236466016680572034297929207446822322848665839522211446859572858403863377278030227591530497865873919513650246274195899088374387331594287372029770620207120213038572175933211162413330422773742416353553587977065309647685886077301432778290328894795818404378858567772932094476778669357537460048142376741194182671636870481056911156215614357516290527351224350080604653668917458196549482608612260750293062761478813268955280736149022525819682815051033318132129659664958159030421238775645990973296728066683849166257949747922905361845563741034791430771561168650484292490281102992529678735298767829269040788778480262479222750735948405817439086251877946890045942060168605142772244486272469911146200149880662723538837809380628544384763053235070132028029488392008132135446450056134987017834271106158177289819290656498688081045562233703067254251277277330283498433595772575956224703707793387146593033088629699440318332665797514676502717346298883777397848218700718026741265997158728035440478432478674907127921672898523588486943546692255101337606377915164597254257116968477339951158998349081888281263984400505546210066988792614558214565319696909827253934515760408613476258778165867294410775358824162315779082538054746933540582469717674324523451498483027170396543887737637358191736582454273347490424262946011299881916563713847111849156915054768140411749801454265712394204425441028075806001388198650613759288539038922644322947990286482840099598675963580999112695367601527173086852756572147583507122298296529564917835071750835741362282545055620270969417476799259229774888627411314587676147531456895328093117052696486410187407673296986649236437382565475022816471926815559883196629848307776666840622314315884384910519058281816740764463033300119710293036455866594651869074475250837841987622990415911793682799760654186088721626654886492344391030923256910633775969739051781122764668486791736049404393703339351900609387268397299246478483727274770977466693599784857120156789000241947269220974984127323147401549980920381459821416481176357147801554231599667838534854486406936410556913531335231184053581348940938191821898694825383960989942822027599339635206217705343572073396250574216769465101608495601439303244304271576099527308684609204422226103154229984444802110098161333824827375218998738205315164927134498105950159974800571591912202154487748750103473246190633941303030892399411985006225902184164409988173214324422108554248620896250260604398180189026317781146617454999771440665232863846363847001655618153861098188111181734191305505024860345856755585637511729774299329074944236579668332700918367338977347901759248885660379952771540569083017311723894140326159612292912225191095948743805673381278538616491842786938417556898047100859868372033615175158097022566275200160956192229925401759878522038545913771783976389811198485803291048751666921195104514896677761598249468727420663437593207852618922687285527671324883267794152912839165407968344190239094803676688707838011367042753971396201424784935196735301444404037823526674437556740883025225745273806209980451233188102729012042997989005423126217968135237758041162511459175993279134176507292826762236897291960528289675223521425234217247841869317397460411877634604625637135309801590617736758715336803958559054827361876112151384673432884325090045645358186681905108731791346215730339540580987172013844377099279532797675531099381365840403556795731894141976511436325526270639743146526348120032720096755667701926242585057770617893798231096986788448546659527327061670308918277206432551919393673591346037757083193180845929565158875244597601729455720505595085929175506510115665075521635142318153548176884196032085050871496270494017684183980582594038182593986461260275954247433376226256287153916069025098985070798660621732200163593938611475394561406635675718526617031471453516753007499213865207768523824884600623735896608054951652406480547295869918694358811197833680141488078321213457152360124065922208508912956907835370576734671667863780908811283450395784812212101117250718383359083886187574661201317298217131072944737656265172310694884425498369514147383892477742320940207831200807235326288053906266018186050424938788677872495503255424284226596271050692646071767467502337805671893450110737377034119346113374033865364675136733661394731550211457104671161445253324850197901083431641989998414045044901130163759520675715567509485243580269104077637210998671624254795385312852889930956570729218673523216666097874989635362610529821472569482799996220825775840988458484250391189447608729685184983976367918242266571167166580157914500811657192200233759765317495922397884982814705506190689275625210462185661305800255607974609726715033327032310025274640428755556546883765838802543227403507431684278620637697054791726484378174446361520570933228587284315690756255569305558818822603590006739339952504379887470935079276181116276309771257983975996526612120317495882059435754883862282508401408885720583992400971219212548074097752974278775912566026443482713647231849125180866278708626116699989634812405803684794587364820124653663228889011636572270887757736152003450102268890189101673572058661410011723664762657835396364297819011647056170279631922332294228739309233330748258937626198997596530084135383241125899639629445129082802023225498936627506499530838925632246794695960669046906686292645006219740121782899872979704859021775060092893328957272392019589994471945147360850770400725717439318148461909406269545285030526341000565022226152309364882887122046454267700577148994335147162504252365173710266068647253458120186683273953682547456536553597546685788700056988360286686450740256993087483441094086086303707908295240576731684941855810482475304758923392801571302824106234999945932390521409856559565661346003396150515164758852742214732517999548977992849522746029855666700811871200856155016457400484170210303038996339253337466556817824410737409336919294104632307731994759826307383499600770372410446285414648704116273895649834555162165685114551383822047005483996671706246467566101291382048909121117229386244253158913066987462045587244806052829378148302622164542280421757760762365459828223070815503469404938317755053305094698999476119419231280721807216964378433313606760676965187138394338772485493689061845700572043696666465080734495814495966306246698679832872586300064215220210171813917325275173672262621454945468506006334692713838311715849753092643252486960220059099802663765386225463265168414963306369548086551101256757717890616694758344043486218485369591602172030456183497524162039926441331651884768606830642004858557924473340290142588876403712518642229016333691585063273727199596362912783344786218887871009533753551054688980236378263714926913289564339440899470121452134572117715657591451734895195016800621353927175419843876163543479806920886666227099512371706241924914282576453125769939735341673046864585181979668232015693792684926999983992413571941496882273704022820805171808003400480615261792013978945186295290558440703738300533552421153903385185829366779190610116306233673144419202893857201855569596330833615450290424822309297087124788002017383072060482680156675397593789931793515799958929562156307338416294599900276730832827716595064217966523190439250543226753731811755315476780739470338931185107297724318378972674957455778183345495942317353558291046967315391275975687281861691161083156337232639968881490543943261197182274996791176628553401860198315809629981791107208804992292016062059067271273599461871634945774995805337947187105456452579396024210259136415528398395201773012712514892051061708228008339985665786646920737114269682301770416324829479409558694699089379165191006305185352102345189798127619143061864362703081977124992751056732909481202057747100687703379708934229207183903744167503493818836342229284946790660285674293251642569044363473087656797056595677285291081242733154406580199802711579126254172797452862574865921933293805915239524735518887119860391319654287576290190503964083560246277534314409155642181729459941596061979622633242715863425977947348682074802021538734729707999753332987785531053820162169791880380753006334350766147737135939362651905222242528141084747045295688647757913502160922040348449149950778743107189655725492651282693489515795075486172341394610365176616750329948642244039659511882264981315925080185126386635308622223491094629059317829408195640484702456538305432056506924422671863255307640761872086780391711356363501269525091291020496042823232628996502758951052844368177415730941874894428065427561430975828127698124936993313028946670560414084308942231140912722238148470364341019630413630736771060038159590829746410114421358321042574358350220737173219745089035573187350445827238770728271406162997919629357224104477155051652535867544109395079218369015261138440382680054150924346511711436477899444553993653667727589565713987505542990824585609510036934663100673714708029927656933435500927189854050109917474979991554392031908961967615444686048175400695689471463928245383807010444181045506171305160584355817521032338465829201071030061124283407458607006060194830551364867021020364708470807422704371893706965688795617928713045224516842027402021966415605280335061293558739079393524404092584248380607177444609964035221891022961909032569042381374492494906892314330884224399631396391545854065286326468807581148748371408284176455226386313520264894016262494802388568231599102952620337126449279901938211134518446387544516391239377974190576649911764237637722282802318465738050121277809680315691477264910257503508758792248110223544524410872448565700755187132146592093548504552829170749596775404450779494836371756062326925757412813110241910373338080434325310884694831555729402265394972913817581338619457057799561808755951413644907613109617155928376585840036489374076822257523935988731081689667688287403837192827690431514106997678303819085690713091931340846019511147482766350724676534922040058626677632935516631939622498979912708004465982264899125226813124300528104995058595676527123591494442612554437618645029202881358582871789577224116380815161831603129728796987480139828621645629196153096358337313619724773332353025466571196902611237380629030242904275794549030022660847446513161741691916851746464945459696005330885252792083472495235473110674109099223541055506299687642153951249355986311346661725116890785633328935569150449485189113488301876365100638502565916433021928565596263914382895068324838727165616560111531517055222955765944972454788815532316417453267167978861141165355597588331979638070962998880767303616940317736448140427867784251232449974693421348217179595190698204602997172001174857303889719205597414742453011135869766256607770970225633261701108463784795555258504578058879440756064974127974530918418405207558526462208821483646754652237609210787539190454684852349759986044943322828073120679922402477507514105890774627334319091255451352225329275913842047384603056163154236552935312278389759446515787337343463172280001031380425481404022090580405056003860937403435068863081434683848900708938565050027569059678069404698435184535134141031615133683043714786642925389717165978629010728400758939700388317742648163725113277369926827709465342583596111881955092462062153978121197244762623771534452048069819082524943963962251113831177428978535825590832490480497516047104257569753442551515779815600370847230603484753977513688390404316017486248871339311818523029425425676202485688393970836748788453789172574145155917919035398535077200900594979352939459631213445503368260690059828717723533375221941915547303742062343262892968397015058892191112049249864792053410872349115430987182160055762209075732304626106597744947658346313025598636315029959672352476943975462530206788193304372284800209305354155640664838569378144603138697563459200233462606995955513484754147891180830329816421587452922952678937925647752029052675349356673744293182673374571642465407748267901046778759085408130531447176455869894169668940436489952465247443988349583871206296485413357553813419500498743813369062703973874586604296871595820715766599826607317005624465541763024501349159567288942619746144496908671655859782729228702723774835097362901019130417812735773037781804081589136005207315806941034305003184349342360269244733060013861119781774472669608928321052543116496033420102032603863672532889648333405862204843616575362001468405476649666473566979572953394809138263703324220930839366954980688240491622063147911494642042500022450413425558561937442905257252436320054487441524307305215070491020434076572476865095751174125413729531644521765577235348601821566833352520532830000108344008762266843817023235605645158256954177359197813649975559601912567744942717986360045847405209290089397315276024304951653864431388147876977541478757432610159879709758855625806766197973098472460769484821127948427976536607055051639104415022554420329721292033009353356687294595912327965886376486894188433640548494009574965791657687213927330153555097865114767947399690623184878377515462613823651665956337209345708208301840482797005728071432925727577436229587047361641609731817241594204270366066404089740245521530725227388637241859646455223673260411164598464020010216920823315155388821071527191267876531795071908204525100447821291318544054814494151867114207103693891129125012750853466337717749376016543454696390042711129829255096830420665725364279472200020835313883708781649957189717629338794854271276882652003766325924561614868744897471519366219275665852462114457407010675380427564184440834805203838265052601698584060084788422421887856927897751810442805474427229455167420335686460609977973124950433321425205053675790499520783597650415379001132579536040655172654879022173595444151139429231648950663177813039057462082449171921311864129633704661406456900178942356738775523130952785912774533241855442484484493664210731348819180640189222317302156645813473186449997905781662091469870718039388885781280740226363602294114354869871402143572055947730892808653678920201935102605361567924483276749476117858316071865710310842200560259545115191391309119544447844361032741876102338843391687589233423790859841968266525610628751237572318491474951945985728897934981791761822652480408237128109790772638864286067917082288575852703470839714561619926247844794692794996845945632382702297364173503430783194115698247820013290851202878474805860188960045901745974055630732714487679085288867978809970695240681006625611440014983413580889737246844064948857074167687916413224205373654067330186392497910915474785959163865597507090581175924899502214799250945635582514315814464060134283490422798357939659258985200763845646681640732681928346007767285876284900068874564639274964415904034033672337814491597032941787294155061054129515400159393851663929325677429557549480046658273579653990940233543644649376827272541873627547532976808190325336141086433084237771738995221536763095302045902438694632702895293994483013577589081214884558493819874505920914067209522469096263076941753340983698859363700314973728977996360018626500174929290087931189997822963712306642297996163582572600112288983647651418045975770042120833949364659647336464289044499325396227091907373705772051322815957863227591912786054297862953188615559804728160710864132803585400160055575686855791785977899197902656592621283007225351401525973569300729015392211116868504740402172174442051738000251361000494534119324331668344243125963098812396962202358858395587831685194833126653577353244379935683215269177042249034574534858913812582681366908929476809052635560638119661306063936938411817713545929884317232912236262458868394202889981693561169865429884776513118227662526739978808816010470651542335015671353744817086234314662531190291040152262927104099285072418843329007277794754111637552176563589316326636049381218401837512818884771168975479483767664084842753623074019542183217985496260666590347925816342392670947839907062923166535037285019751324813803837070894638925470887039085723581006130628646664710006104352115778926613432214655311411882596942926284522109026688414975763341554921135581254616558078273470115814006008345762133130389987843270653719956709570847385786092649188858378739239165554263577301292243641604062551736892335636568854365851646207821875741724364525814143487632761341752707376754922276287782264765154315341585713773522730335403376364204258034257264749686217823666951353410677378421131371131987373222891805275062812277716412494412401207125954319991746574745892582613712825555535080404143944557295994554635608487251339462936358940832098964801619583130429720964794128539388996265368928263807677168759588502216464582430940165009688797366157733560316836710386895228270941509545222744002735499253670214715994056544813842186380128799900820933576320736369405991424263718294000613741900579513096298545330748197802568301089672873802234820488862973130369689882640657904781562389778485365025691064231795736025330908763271784911189748432246868086340383964176127605788646574472284824932687443062551220506955168464669477183681911432873544815836350548146411099960143390595799766290646881295025039150923633011076070632863317393378149693380247580035052789782755750928604039420506342939327064636161031822879248152679306862749237275631852225654266008556849497720285909150930495425967473648331437236349555448901598668408362176913559656039519670425368863482369587129462524759031776813184977588276576740482558136502103649585505703259219957675334264223783723586058509403583977103476670644788640831109650302565215607464019652716999732373465237173456595514559493098166644006211599349133180135150528651842178828026343325934755850761168697709125580056185683710540856081249519403148064618719402577663285267019698387567561524696759028106864896869293315954352097687527137201616160931174250199709289684940034696242325688410665113304377412256176258658941236728171145526423894512631717834790276921171452887352955019336759218908006048633737786728180610254782570436788449503518925787499836694785908612975543084122677060954347612133717433156783790162012337237023338316414706428592185977610158232721997915062871868186750981665537745013020880333904353639770263363809098526494532628146558065546504823486429495390613257400496912888340518222933644476683855037967975809619983575807027759535968788226194659612223044549275600274955168583542582295336042834426318478068825395450746691877897765406038432512843812811316856204608617289408229658626174420766920297427930088129519854678713548623236610413216581279267151545961594352593456757445992307889205519540082316409719591250025455237503106735639748835542480449681383030671851931491335789202123605308199952020584503423499932150962634977812456658304680581824563524814625849331926195406884818446445248429486063016169476663242625231476322371109695369483824482316410396224507675405614287468267835723704895606990652792688455844512046654853378534026646645042339638488257719874953611300494215593735545211926186721478265416885604094928290056616883807637656690510740892510549165222968878676968631652514917701499900066637344546120262780701925698706225540928945194718778004306130021828287425867048748480826948573444778244078734102710824870269523830804910960482013901294024631244800159336670212658317677879752965963472576894326540435889267293950687860830626266263287392087327302547910099932113388977807814336728791448768373686467748528777737403547472871644217767820712964506270880978637928144071192505141148004907055608097229299792441471062852247029870699869227676341773513258602908903875707454368077876422385333700692089616351009233587303986543906071880952557553380364725895007306772122528078179471056481171378557451057691044322925429024149433588396093679321361696954251299731031032804436954501929843820842383121265825740594509426942777307124802176915781835720087170538773256017987133005505911377823841791640280841409623820847637393013930778428554545222367559824666250608754284876104145661362227642405914304455580856318180935230407793891614902116292400515074914068443203230365609954878620999194306564455332547135557365318516011700321550690787716752062881527885897149410320986984083048966524351030502444679931779147659103428949129054120361601695671222140806369405940304552186212879933092856231022418446365289097444640151986623183881962444822590783585914043686193019041458962693878907034982169868696934448086213990534591792826654304798207219634134755646525483143771156678459077797196510772468000293581546267646310224279007313631352522067062951125935874473134186492497282784796644585448962932905262058065248588707020879389134476083344653170939242408249328008915731319541348311820927752486880548733943315867562666122179355051190609992911379445634995627391898459029021713155706096267881673302940198464237390445098028030948975981259252055850973537436556825780313681902007151675693827281818824587541710721180806556448039122504537089422695358382192535075692834095639859265599740391316709290043996275976830375217503360879028295673068862263077729733533853682668734519035709709687322323738300494090123239274318759046526327095178406267264828893646896593219169521106361729757074376148061601331104911692271318609404145014842866423634716982892418180484365230538864559809839273836490685480823014267803143937440431807822678779494006206489151248952516543005634448375046751754207043313372486870633237561645232360481932024377596890914783372179553676992603235715185513391098402739063753280702313301755754269396202629423910945323537910125948964941812563672992967084250667599803456273455598559628512281414582556024841783305645240508450065988755987518601335860624932784487772006842296591945516539562982960591610046578907214842054861830418175604559815168088031783080261445994444677918012432146400983610678683412974872596729258786806223080115822026289014364459002301645823666709265571264559925790622304745235625575111770791512002789380975775468546121017307522799241407026308137792971909461413145802081087738121624539858769697371425881836152605069380926917712087321915005831977113322793572385071940612761291872572099404930250277748156614021327434743881966413330052634229082906400927944924808556131183440161804801357032507836323938921567643159620442612809700944107776130638909071294456394056601559246025454204771186140420155233371270501377121034570009578009389265329385720478576508777149663403003562380595757191609382171312222810465858388943507176431939973012661591423837170284400120399485880996231859472474858776584355077006934099220340378772192728370301380838144394114984971730766162961342059105014814283949700695951676939041557902856356911055547312684571497449635320554677940775184056667637222969090346128706829887104278761090090999160443821794511763620835379716161833124364431267855435550800507986124664397724135502128238026726719914989727248512981287283697489276420792868666970177259794407858155909332508554131299946581118527691652464790819119384233275897699573012098103009171001695718791616942270079528915191912521053891838538959315167400505723817401030621004380243011187977704252328073236575129609372456053680037516596164236147709330391224409752871732067976128120428026739256557305675931512645750047875756531854825821411574030473147492511910835615765732002546109686701890307648531373832912682481741181359032826625082549313211431478953352317043989053928534946642886074268371824902498092479487226633686823799580875637040808655649321905489637785549531167397935270799470452399153297534358690514105864096534514182896474439367182852711843560799285895978176543950113088848419163516673213692860830956744502801800373716458009168082972708715609185038654053436660045504985624687376022557041595800250174095361839287643458003670864954057941720085136357127163768323493134230703821274484501440529541695374381945459456533165140990993722722801019654652726227831512103467686166826131471843610025517863247950150022953695466317739589344131481485834694374523981159954666071205997794363440185078360899108948073419633939259318973940943110042116729120199722626609871927014024105805515315100109804996044147291039451030312664114726736839973315035036742741546992633165270432940675237449075056739508929674779115800864399992564817208847429250821546279856079127768611946086210349405535850134472190244543824521089284409498132717010673966471114931896789977661595488186193176900175027901783824624387873831483279500879026433992577026588005849778984624295660321276945810824348129690840972550671054732471317254997191901039553305847040728081693158626093886019147689944137673621432083607375131574376316754666479186753896571555100850626810005119827486807780592667765654100834778571024250133253391587384761024129794736751001163498977803745930025457609870671092153597115178252014281216647543034075128600240297038428615984289816602143429849088917359682192284469123035904329877231843309914187264674607558318725713138832356015809009594182530207799397648462597901883341793830920965841463574411985878296475850943053008148341821747826603773762252997703468752903517310792083220038080809212164346586817989810504274375385786789186350517717501606531826406928883250135919517178537687865881752366421534010961295763074762648070312757365787762352859057153932484576503944390496668087711899192498933896524852395536795827530614167131757915756386606004839994179548705868209201195154952031294562451315422506574858629161606523796643010172693950282294667489681746821163996794950294284013099235901278250437428192557634533217576162292751110598368271567229778620053722932314082887058749444060116236521627717558503013451471452765841864277071769968435499620257547431811994883385806759692359580622165832464092095350648357935817742903018315351290014321495518177456908388719320697769695657771754499149911431368950836160692539606469893374870942933219185601299108564470256257163505508620689240297589684714283678684735455533583477652536156578189996983068654671736445996343136468195427420490472433064675001442697508322369013083895492637066778406531328664886080129513771720847581157719491012345141774941482773580041432667332379617716965698582785832300505265883502247868050648201444570593197343382923860072601696510903258980909912837652275381493529845099414966933862815568031306981064525192703818515872648691762563239441425216118427769145067718411735714396681005615483952443154944864238384298900399826113322468963346522104692545137969276009719645338955332105584245640187448611050959111766828942711640054010503770420346052521318228045892998637903572350665108782350043349942391285236308896510989246641056331584171142885304143772286629832318970869030400301325951476774237516158840915838059151673504519131178193943428482922272304061422582078027829148070426761629302539228321084917759984200595105312164731818409493139800444072847325902609169730998153853939031280878823902948001579008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\")\n    )\n\n    private val factorialSumMap = mutableMapOf(\n        1 to BigDecimal.ONE,\n        1000 to BigDecimal(\"402790050531223457680670558292183044930441094551528966419334642920075902370082550849878938011122874840322664395727767319128483846892726398968790560901035018977865543415443376965144616549510538851077440410165819782073475583082079396504111380884916810768467471317168913183948275897490803646698793846190852594417739671786914563472162093180956284720843607311204509397095907530114810381703803860648328656344389023077975647748628886817466804724858587747840936784462436173977429991182753207302348016538494642001301432395279726745538178727708503090870745742249581124437084158031806471602854863650302741825130214652788342621283870175833906572656890104432413095171095723550851047360182700817666447833450097928957386876271765554137407111747666512309980678539886786878262902584539118231519316835523885400137767203426696953126303292828224235349134630280084480064650497764755473824102259453127730077777531063115138764952527597098445380046443997540925880086936317933421768424925084707414812932329166745886234137226923024813461900363225999464524935227947647167947434411637139203517404371214232998239493954562323327076903915931443305369962856388265027346155623332543302943446674383336900484885947609695640139797208838438493998636482572950930777919644406154624084228042985270573774543689565298092301062689807689071120317578510142181892798247199071452022029172707400688758980305702923813291544851703914211657597582497807598793035565731652297925769886549168450867091163868402442018371341022143349040941897422377931540131712376088451926646802255265721820332564453961091792448710886674897251899281432897966817352381951694370184383299109654078410356489144960977274480320655205474842571310858767154579079644215514199003832599232631020684528203955813111140473074686810426051322892063650122841004997271652977702547274337834459757112850838135183696311712170990224739928697694772853140476802033735594574707189941820656793611572800671948131128109558012358679446259496244143021997936801273888393102412918463505832701613704464047394891693567824946365095976820092895872874833067345472399549213736568277881574159120670765215962463587184455433922702506813953637742383768964226648365610070168839324749896910992390804658988479107678562550844858514512762455637677863067821690083222834405613388709119188719479181528190836888908152845729021513491658586509889455613570273121541638995145894561079999213500076101248781500642979091198044736325729107144579768273776743716439557581557253878204647391176582851167312182026188795156620056856503340092247479478684738621107994804323593105039052556442336528920420940313\"),\n        3000 to BigDecimal(\"41507431846532390014882801318362767301098738774659276979642685520177434147985061131623525034750706053440533792073866001979890209610842537344431235497883177188254394799276542130254613058719441463919424181427055003454312730393269252709166029571096796529787904765475050630781964664724971734643948518803534785956796020149081942198345344282195804898827548103655197720444903556189891418409180812709083648798462161128840552752021998580129097652524201725013466689943415437149061564512210989732470654644841372939920240489105319923282732806906154955842471606512345272778676870450266969670072049417681297136367438851063226968955965439757980062115800336859604871776727129908296425043099587388836710818583001556790268962166939413737389530483030791355959055791288226772418563010949270629333162241381838263503675249052753946054197504363212898891021511869803357212262238936855643457971329573774465616696366011060971496310122498636090543160208086738734604108549063111195362376570900804024848810818888188183206794224016082430930253459568277544252760884241700680095841175560366260263998372753005038377691804370400893684400626342559907015850895329932941091749244872665566639724873414670616311672987799064508913697956417133625178677916256418182587100991259623332912580258614200769565481875380511027823348348153796649503454039914264452022324410025637599650712046420366776060008806905069040554786237129269080261110353354505690866581686413275517658233622606582338708624221507431085539895825454771660677274360142606537319765574930123892996944999002100933415507627965775685483525615676485409146810888731495379611422757338194724021603518126842257707988451617531097338472783966938968901736494506443008525116750272721949122237517497318879053280505722320006942915294829164604111255227347649224596915177944427021716762492072922993036511742143394537537861789870327429556407741451789658138466195477034069716098274790153581156900956788845215861898839706852667706816150260812624383783147239122290052764001136717937772175235377687401076853720492743969745351185992920796508484364231309120767344677685525459703352893912904609262622815066933849801748152455146537103557890430501259170087926872701486217418239287899942460087840212242100992520108664091862913123866581734119783064833045472234348229455486850729793011181723025767885972654377990698072268064796188959551955620528994235027109479378553276764348430184381666164891713872137151132483118058958774970299410323956220493972218155907350961875251833932213373011103861105546781540964185472525534540828659118249625070047091577710379643684554057579433244694749848577549229097614373163302743342650446925892907335995592472094470289977578306453316522182367639735609972700445808836076692169018777836376173154233370255427946194404652093395714228171760184336309208368454136800025819395184739949809859309806351066397888267304367169453401709597589386527621336437650206114190756197116806244800112978225757124247851363487273994461176157828963649547292119080969437538700020857856855715898740395914794287058435664073606907036661872262125497969305118108198351188638381089418103350968532699181201024386405615827843416651170734143075680396425917607362357017613325200448557950047143411075625752041169998369373740888319133418951504583768316444652277499162214689663960936524327274000013547192865982444375444286834249258953191017231278786729675226414978835504187306577185423641937055021081550046702105094197294021365240117023665120138210994736318102286453734712596292089541123109703535468871904802294183187983375796041645210040338697571808914618276852817495909475155767572231394837717109641788727014953233720789801614347883003364805827533703159714109591277632783607150427243947818470380840079753299884017006759990971609325694554929645985556282105643698941358526567470532451901504014988670113938975256776941059736242947793978245502838268497505370746467973155404763861686393703031545348890778795738239678380420299916834468094284190789105822567360849582194734145554713858546255261740632134104735717552987315956195781287573500120659470654778014493977147974189821731556357497205372860380221129579954077080576844045175274548216132585635535207995613905103927765549708576603432731672492051306098543427970974032758490038710590412232640539420022266886451675432822947621330627021775741422607310389926823407444998927853031947056657722184514059439777048165925912031620453406029734929896666364798390722702634068430070093514373112755586415896729029436409376071700644494455604088893123624299539550613217648023328897133270453323774317491784901486451236619812574391942091139375815851925963113850428020344344196183666566431138250833750849048663386855344771862106924390228675771551935072070688254778479858479185129407582187282292462141455961495115464874261394160453672219665389946925782897703248545380735786282979276105997651216300126033407376642114969354840803852181333381946132454530014502405711654169511797575920360080587209000349653322566573873341933579488239353315632838232517805394281508447595168650336843140709410289232514924778496562767880297746772249939792867609982495721632439389762360163209526006567154168501080034248737752917828362314134092031469499377492786293684699225712305520988811257099481173867126755539841411933634880872725373998633306946884573011364105091509657448965043488119272402863458462758560087927028522506460911321521568323287314406349384610092291485471319866396430870085446846810964813323403287667113086808889236320602722112070360960975726480855228407037605358323841084686997504375573310091844937251045894840079048081565745268584076411714676551452647195373058971691086015380178789063637151903997459680798308026088408799778714392576964386576868494904312287703705171524969667060718746554275930716540502439426245994474711367619624900665200217193600708372592644338430362678698838701876594203319695124321633961231502107654640727385477123725388210170783643140312260735624021040588721798613127076811348301794387508652674200512700477008546224677439856224738508794237058928340120071671409926691799094596511904738355685648839036020474977459571057687256781689421780252120719353796231628303561974916654415752936108019985587315107071950822139177929497353036721468503118632477143455738499032660891878492776952751506778470778623796675550732570101041788765326402577166986256578392587539833969673395262371422625302288760680647835498407696303233764681688180442118412833145440423043656010905019580901928531336866257532184997229529501067967999463165862330446946699618514334159385071695000653260633844642784068346529971999183878927221171425670741922697032943082179289546085195758227026055983546907838034149405266172226125758910494515159125469963600262638646978682674112439184217375480579633377271964107141459423358777581821345202391361819865535926179943618481071538847549281968489362071313260912101522933321878435363642223527517204633921879396279240127614368122793991054486638545191398345228764373160804676741577500849002141299019841917870265847902119088480006243893471639565360450633230568755554249532632034638106497925421847651063023634451511539220109112998392779118600408939477889922277478290289493851207445504544770312993024011612733364454746355055837396029003206437336346679421433507829046536973713973983918584537136513882957488537280184715671574400822787070125321739585612937454024753670406587749893233796613080156387979476179368254362384560859063008647492700744421035225282744178714397350945857511857794702578775926912406189733483883840697574268916137180856229303850082058270319844143905181501266576502012646069587950597897782059512695471170734751249829290819573212763701658658886723172951333968204504548583500464554368762280638442641028701701368033449053565538390089449850807321043897283784206606225907934635925944995816906477323268744529886674908816795862931070488782141088207932708285398739075268335132140999456709068454295157916727297903407579654036778653345629458611095317955825660634839540973806881012132455563072231372469553146744525762109407483488761381725210833302437526950550870279656556676424152356700596131377782593612471806710792694865045492337337929708223942963123616947575775044247693349629681985667022129978579783572876360132902899682920325592256872876473569128263386188690870301995003942450615224046177117282040595212337956062094432018623779376569867446928751801376351410837656665442972167147996171985630385306847612679178278674809668294566453109508393852710531293826952493214689541558352984233805697178957680419990935517493580707432780441230424632829229716105041261594083452244993017506583870024332476723942239942275630968576224669066665048909559644342959549925429103815747664276051837088059701997477107440425021981051740905844053995746925171844037841823522441611867345433208379741347009406659919379208878761799827677548449306681397552694707427117631406144007450882969740049818323455858551317207197201589704858224388374914095841726938767482243085025897244690463595978336569707778625455613570273121541638995145894561079999213500076101248781500642979091198044736325729107144579768273776743716439557581557253878204647391176582851167312182026188795156620056856503340092247479478684738621107994804323593105039052556442336528920420940313\"),\n        4000 to BigDecimal(\"18292592663592513057823962168026112645303463717132470684662376664589849031303950203935178975601840797456238109992046344562255791524618069592997383676378772205343250591121739111157154399844461659068168471895435965831958700828015376962987663272216607950802420528635269425109629852335679423314946623656767737450136921799300276372919463640955349627633844818198511382917257605892253069470311102173599811674704939542016412333392340614631077782377726139236549083297010559383445129132296354486274350813678592672029085029526153870888313616493864012533126542775622700316989467188961859738510555446242936973003162979501625064144962096117794095897074397583325054329146279731328184628437275532586876131358942799292139256791137356949119062082334899234742176671154629609695801396959241266395010349581926584068134895632236161635915876448620172017333368703921907354469584493576313762898693217384122967854947201731256039348490752464548227845362186357904717973290910107122834424420285927637727819187872570375048756445395258002738401298171476910623498209437115431463459981207537546498925841267827221923134302716647220655514504387290045934011447472705785611796488296314169925538535571875327431003675274460204489026935322682360054709607830792209523770065346908830226092151382097906445447717699451733016142137087445712040630126518901968833167800034389044358647081955235444442043337085318355045094988307200312015253376385651124301523077470630116601954338635188492145323425364590723993687627310812707333666615612091468827866168442013862219856724770766785846741160169339691814533230723431020629452035226923416355892400274118395701776655274920034353070777525343909003353279178080417138790327467045737933220370302262530280450097312180071225605029136490940588792611637563175170766596569371886377355464759193569471325659942197751517100557657222373654747904743477704586821986166064128978910197398146886044113975479301928914517122740273301262907661413392349747805202522476664597595997173516850235462078116305311741540942385295865035571237541131350201022425408118072598352250703833989136225729044194633969260816603752836690306387872527196753396483673650360101616825374297214091451875891184140187737132836707882744232766162211710159657535485344619512355544566104457078521171792446863831393308757040816166606436677977019576606213390508175027746342472116537883805236743889819040236928230699560885675414494901642097322472235451842496371811738000835132451633510998370273822664996329967664214720994294605686491795192049896326515583866083972381789435668888453314819229593132889457851887404586572428072172002295002233412157653977408813855900649425958897941067667818882779759206655757842244698575168857858946140324092266543351773736851430470775278622728290044938260204794350546379101864447994180475841984957894886336516892003178374919968449948195381627450729388811233574111671283105397737562087206868780324226458543996026525325563938731503121893420718947328321853281104565829219867997483619003946849042231070098852503874671816273900488718356257069940394757225058145822607005601648483472319885906606599120596166923141557850828938025699235293278480428429135663207270014784396581827753655831658658275634922803523151032099817605515286319561848023461156979178908521220884630629421735847301151534612238672093935272024028367254448999771560612237381392640327728808804224385028820735985546698043013383006883554828866261439137627964321923899868498840524768886758136888010887202177110793454070954100594491798008985831603805445540461272113181056950005355280843863301898038014861217647834351566387379152239957727558303169611210971906952533368553974851547806136895816519353779561053196026667526766699652166948220053928673827947198714925781080201398599476402770898980660304164667001323733775465554638031222531851995449525673185496111263119331863242935458809905372358931362104411817228701428972504601550282376699751964026655643490391668145021078108000139211504417981390808181618742757583780192969453238511152174503745949154723587441317687074131343209748875330082593364401535802678477269316883385904276870834207345062394844107006598039708967202942651053760689311005960556540480198476118707501485990936297760906050253058941726448163164766703826260820965689077936781019082973384789434404485206574871396962985479158998391269333810949373120144982565247887658412277003261992120934850514611883845811557763284913908657410714470660991436073822137304474104598512374320436618643864715297724403944830844217510242884384324643335122965596987895706108996324102909018225786868353464472769845410951112050391537490133928880981813027604081166348754946744244921198728867332623094488836047010795500558021143873215382407637639070352090017844932405206214737579475820260088957454964971918387137372795883388827485520764939114050888472764129709315133194578370241162277747420421366394773758606440064261561064112496619280900104143098761453977839507360547702917579875542055732609352135298914737193916414962974007577625075261893371429303993047032218740932204040583892079878157975654588631217624725788705497522831205574962136170490912730210123455004755960226011339259910939056851467922879018801863314695158434740995170858905933407604430127760524901628591257952783204087030049509063745956645310392824040842493345594589541508121854429932051020846666844115721165016043453659304890162412189611646529602197723600005321625962539095705727301325476612335355509437044751375600599373665772880871617966047056444354013676014953159914131165966512067251754356261294270502806677326494512030646815907007639115736855476416477427588012089884452552412238973409091280057042134221540876560170782050493660839749102559622982688470017161315646963259564651661940374827570052979975178311838630674879373677205044228654510877662225342417603836212763531728976547704286720989414239939482272139775696703177205222886062518745609579223628483313616272229590248110957982573154600564526109211128211536544836583735927570692518996215073920703214196085380544628286486392879269536709981138681978452157481518802348301915771777499431318957943938295027433262252794151944992962025674926702610924209496746233207110145538823308932564095360471198117658110615169195987108605839508991969444260956118701499420935610426220139118155525827767526797019357875273618891477689575697084951056041422080277028331303573744591877130464450842023669657856321712948219971883788789352343048769840441235030486854339840624458895938820564052942715713762115837857973952018603567613227902532780488911921113423460292909615556151718412738275912895054595618622248308688903113779565267767672089624105954982510183503140201760951493642476191437637720297599527567457872379728823617295388472694685716151073513790333320823068769406321715846576136907638840787726825383921109744242957071834135514899752706182103969469123672796314180377566911296472792690021412414393684606891894524806799616273269130579076636556264842054827426836525793896416419219872840963177032933226257702143797207454240152245884617313501980658802235636475784684657605725197370956690316957899986415745469826045038751963881298972731071758714288187004796333844076926984665279535040421127789216102566405391882315759160002600052326524105658405242361938836174781915091030909966069995158425205598843377654509396985421180489500890975716279207762819739459135137312330633174994148838056626547624241413066858832464642433889694533402545539794402666001096535049470759729913331734558141187095889756964974788766405053593042805036177028773781595494447345682633508630561029907894779766263054828702865847589919079622939939993957998826197293756402098284703297538434923046365444258725569972148899908340109935476922877775128087272476732691086454153237781069191711669413097326082153631759474622362852059139724658663610049210038123250557942945788995373877664161343203923601817597197213823404833453318222604920776448503391476272480336437110759162117242379269974198726965610527568560402347953060012668340623975816981494819081989372669233995022902940873655482793936484706666460167792810094796730288860493822009180107643824234550854352499403476301472776324735899038194904544566185744094015371077163680493094748652640929982428745353967043183507371688151399075822795352925630907799147126868265731743681786216258773592216112131284116196686625689790044802412355319640519888517684580944225265114340370400793714217332698439115965740144619465861752276405164107686088204116747542687941060435196750352202350853407486005987871342874952433804297443956518790779545898002073888199021990438450711277522209561916000988043854461351567242744497930467926131800507688733993295853457088387493654239167312522048656386925373517771517349782010751818484210881696650446157983705341139911984220651327101817026769234746422285220971896727667265524865312943570953596492044878279568256105390845032294549785702997567877086752725338779591029280505444487137316673368945150982976081471372169061452348672816295351730624516448597946549006304441184346779641625838936724073174725216995084193740770912713516175543973145141371327695649008601514950351692393994584424333831987894804608492981683417726795737147005399088338611914458428422309508783893918582147756347453404457749039687930914178153501517992020656007325971193895099992126154718662868477305636762666439692655573259899070739794265955716105805817009467443194351515114033802204898273562167854948380250112248430991814950352374407189616701287199275141764821680181973172787893111670966057937935372008962125686067782283723139018209857106930611811214246165507610619076154925781224568704880811144327922030649072917971435522881922942694501579208526175468814949775164994865341420476980371127137202357908844938901720831446319674056042451108809770643250384288660847744156150006203970450482964549234451296022166710127250865517606924030459959616456957255032421277971928006696300004595599929950097160680143368291994616971636953729200780014666257438450765414693614255288339472575390757428643895636020368783637850604211174457912326233158027592839480540382532317774087017588778009484188937946001243688338076525455724126995401965879217268172405832693307872489599856153329794302671026450199446408283584018666599596138422736768693226327447540426837450185449080966941483507433936061897055557880840843260724622032154345983347864913466614240126831444009791642952456554201547065912205244277072531659107421657520163992199522360948278764979098060070203563321753825803693971281804184250528788161449593353769099718553697031273153487353850257899468683695651632358679607526042131304577427396891958930932572490406496636189144466373424939594509579223788008831569425092592755871660906890541172849434068596625719549822666452969550724344918191020300253859074773226389926348337633397727927891990430075848322264526677478323962707019544850079203544684324922585001793802956283094505582556305221662217281757612803615242252802885323975967865268765438781209963145871316168282707602218146832273756263422651433064431082665319541150632900651099802896651464273932704474052188432316969885066401028032745595672067244879733753066233045322200658293398922933895346005837858576575068521808860458471448280392517025004872154101074193574704273994049368194888612823105095782659754012429996551339752384907185919191242105499937228050702753362529131030308815072698753251877812149689031260980778676447137016966091512958556348737736752806131209552696911618991523172311596653551790845307497423951340652832100003219685544242659905450633451104224593745203457910973408738901795806101249897715027658630522026330008398899284727308350154181094535729170124881179707125026969951297760747498972666386344359172352213502283637378469755867553260755050811728204127797585933258813860110849084732438785570484145264336303589632782277890817465254631113411418232759715758488348561063862344031260705381010426269814723953534762058096919042403454487728324190915109538606756997416423550092894166173335045268625659870980470914434163630084041548845738160399041740877665243238388098679321484363303613179051872770432355211034038352984233805697178957680419990935517493580707432780441230424632829229716105041261594083452244993017506583870024332476723942239942275630968576224669066665048909559644342959549925429103815747664276051837088059701997477107440425021981051740905844053995746925171844037841823522441611867345433208379741347009406659919379208878761799827677548449306681397552694707427117631406144007450882969740049818323455858551317207197201589704858224388374914095841726938767482243085025897244690463595978336569707778625455613570273121541638995145894561079999213500076101248781500642979091198044736325729107144579768273776743716439557581557253878204647391176582851167312182026188795156620056856503340092247479478684738621107994804323593105039052556442336528920420940313\"),\n        5000 to BigDecimal(\"422942381140167279088760459390546768806522855164147406567655591939867392178177929615276895934357254209953946557517695410193391871233432780339558959962456112157445609784376017997659265126671669315345431680723440365389278462064255538306369805499087557778158028292557731030034806366877452710247710610371217730074795465075686048583241828011249225836814708667533026192821105017851743580335958670752088494224150486167980207595207349301700524815940180646817702981658712294969305129815448440999268986896461935995950302589469464759624479752922237571617508900049174623306023097389115284141822402530555749496830218252045899726700431309314394702561475025452565453159493078167785395187318835080204729042228588217544810574446598699295749115454941827226615000051346131835028888260224028917009242518313921457057811349570186604523432996646315639633033226049859176289394694028186216695881929828615144800132501713431346387976411427516552544722461367255707479887008502723940549467591879482529388658076814236881908648686149366464731513821554336330045149452529524452726766545333108588121644217795114258778574555348208405460751755863766079996012281531072408926633811214107754968488332887370969500639497429271529366330379630692916309840966634014289732583619677718457803379392093127954809145694835410447099587540579511005697856340403890067173831980607349720340494763282970881108179778530509575900212682592428243626075864270515270796948549567187062782747637474683491978058748834547543511474987847930907717181086346206830634390976605097043756189397203810765532339109163125485243919956662828718274469321505611160505167207217783940024160639019843851870089278371415795997552184898869589294872102449133960278966855479043071257550970538866851204564503608743553775626750981419019327207242403803531364902728867028872508004295801712030392301801252826224385440438292592705591533606425484167892867246977619062182159996652011448737389696074437928729008285249861475951331319745700208522084054328889497115533039049741921697854393897348910893282469792399608731332325538198015960062401539355585562489390594820753042310117355342869042797224673926021830878945241321390130917276309914491008786323153465860198334534110327400771601406536773667037234765080572810104168719667571176843521570034071614878333572978539267292918884228219549184740662785472734171088985144817451512778976156947478507305292170946581915538669881883291081149644605655742301400220803969488206392328311371913533596340035652542942167935437580782493369431822435457333357508435816201615740889974615215359237739420731797612343811519823799815085705146851665625111316329949921685542747741927943741929639386348064563691911839835839719859466152506726360039525620745636215912354292407039035065756567060790673597193520743804198805400107812255695184023124637195154115676227226352072771048574018099094506168376093482756160575895603189456387500427650298742338507233176268306183987190428273696562144900484427463061654074793295458109804758561666421815848150031524970260578328465650082153392134872289478618082874031010432571333345567100450650741419902207648508139506676982654023592809931042414345783443887317046047677558697474681214510508413282137953694499407677975600811035214008446389993978600583085177237939931552745392224280218966672707166449738155861165045607015063569954037802378500419357708736438581230338641018411114297383816742898335769008979208181679439232621954587740092820376045811443205694288455380381847462382793346072984634372404711537402700406705899115703965820875517071387126432677329444193084349673495320554878446480501926770324730970999852783369666432271643142118261318396629243985304701572569047837289235476146739608538342710250703526148981152249041777308997213668695136321887949412481904955514820564790048222209821812812471485462450056744052104946228397401198879061767269080602422592648387552649934920636408912850461104296777480387605924492275241223596598845175143925018612183887514457299802493256247780515337992881131792280795227158926304375379508161736532885390629737466056097630400413844231384733691908726854084638807217299938543333916555890682680755023769148243239123076905985527707311076199980846549594422206836374946470136220028482676744318789048254125198403369869794791767433722153460802889190527652367692279694434250583774277597394422921780440225295990361861289452345049338583745545726573325597698637648266888485768190972597604979352769938753385572423430068231027550876758225509364942911425791119242101882980578608148422522110535285532341394394791085604794141261018480524462857993676815858136784168462893728593233776834210467239135998816166508623309208059842622372041922948881445894019142071192564158743858628159901756826090435116478035121698283130193977703863026702613850261341940924160139721874567766310544184812615809088169270170753952192718545741189545398945907449014466362075721577002329014071127102659197233615537013044403258077028081654400809781156923050876102692155010072029530092788803029124255510932208849770012727539058834678911024014509095112507566514349926195238450623291299487913488110483753060465997582510290799177233973521773902120245207680692280717428467990184417241239516454493185852044419055011691487929436120973406267688850539652990756407996518831969433746234436267976593073241683319426600827831695006069879983738038107039357137415969856918155921747257401174482372640127561285044312364990404103457206970928376042566436997169779470516301430491315315203670564578452554959221606053208791314348278820293272298088025772109731451556659269305470121684532544432632314446446814888525266375974577098937135008339935937764938521371424978024126728589304780099658461253092304852174848990164227802650106511285166877422106070263739830364069360475001052666645012407243201522910549838697434174392870874334984121138846646889152780409114939566869051636227299288030874359619703604421129183919277143370675301677474964491574698231832201244574743332607653743371876466470805410138961913165021472619602231012943475162945238973908768511408484397000456874588932084561469099514996630244183322808554012444164536501423872705350375574222680297755383715891766920323107664458219545210245288711767760082129677885556848114693736016278628032565237071460895952531543475785353882856861500685276520890757364763263446856917068969325482686528993411608717210936381053758204218132522271020150453045222700227980475746315495097442864384127735666235702038861598674485414136324171314543122531752287780747737610494079865229793592718940895666409246476883546508036290292161087658882988661361586997552909298633214979634906958881548991445171143509132627431869627151570753462429792941661995989111206373727704230879793306069060744398104135831871062966462879775733666818173520210122773076710453727973936273477155771547259932482008989925481200167820538263466963455110107446842136756267632310283889915370906584053092921536511000742014892151240994007911208610412051308958107483376401042886603954783984656015162563500455497125205481338023412087590404458038926335644253154582617681057227391513753493179905718724258545113598540665173431414091589290299555492288683635088010726553738470305896966590166201980523102502179802365120146201477472066581106291288550739707294667913853788951322515163410471560663888674162452891415568486758111176544699997205168312055660715582074494063447547191422224792390597842110157813280880207967373786868449134748691154939683041873066035935917157869741011322156116975335963410946747827583199975114336209499432538472166813427607948618058625384807582642448498359852458574501232504476942264564937672343751683882924522045969255161854136640461174003192992028177904602464662286577762428845797008225038583235046395153015242646983039221977445111582309907607126559468716380099744780496597747559014219748464296083348377790213986249947267317135072843154828769895134292283870523203239780868294743081372562470853553211293330722622237135237491426026177891097155372779919964748197552573491740535433033450356701517906856400598723365181764314792258236105837103046360777861174391004221751591294897005950621356575584944010611662014057222424431558364234134465662387980887902145996060346946267794098200739671410289520131242554594303283247319572976152310076530923383497137729987073376964783029243613151011170922081401544426347345188496078624733396508234959027788394924363893046372009490824034893362228856239886281846334997004992984897276786653794951354920109347167917010817708484261371368175395232534264378807196836716741205443188225598843472451596484778740615026441861124801098068908891561239239342281000197401323385198623339084401260749917037791434942189520133802956983702226465025494774625526020919568304038757489782604562975726865518075624735437397494321789362996541290023570012008256075080696796216060020787875563265510840743557274987125544539303674527093053310251809128244456502465000418735049451122603813043773023398740292646064178133266635449995122401239659482888354816925165105543724426313374607344015267100447198926811927240253778084958679651927798783028187921354978573609932448204157263911558974255094538454059907706767960714282932292682390913294620370519813168823452196655250213467444715503208623840057210626960099722994794420577694419204113206455523844176100622500495880028842741079136072920513160492019198246911890276336434087353876391374646594752036747534848635925452656179932258940657328294928765915716105273015765067797203633225333903630375480875357400294413862850668483603544907255874628277774079363086690310828035308567804970378777179363256483842479870750490729567420644620945352467288504259334837711305095341245013176892402440233387377998398362985035173055353623515209056841473929044964241735742711368666179927150523146205452682402185031078419454012609513228919131739572562374072873879004030117230873611613780519985248758870838750153661489604786216917749420007085246403436581199277789543443341657122803878146746392048088268041105404764484138661656687615031463156137938325207677151215503330868906871449432930721551642616913432678162876628300983599493079770393602827054523907262470516838587289245634025111668557281681460438649958337824498258615580782259163956317711541797934243744335797645511675027756807609128308862033133211408137961954707946413226796591996525465111269405755025624693648223567786147135880431750045773423651618025373663692733615938563597584423515137357905750327623192799852031416367462294840127959039090502496974424206229767598077980771428740153058221609343894927714989159873029460210234765406941233351352443745569035084894556272283189494271575630723744159869968538733355603325469923796592124684339619707102905981682201847780983458613734906737058408441827334919510393953573849080268504715707772554894983601013672398788817100288330985535947194824707732650903145308287451996503616017828433553385418361506922092696962649855364804720845402340748833150439731651111693555204497584451356469155148135778442918328751762074372710687775514734727719153057270492466064744388790239721929050862335773312588061656006255009947266186002226599206929208688402470256548221646062174978362632817255865841980875601552985832057634669061645518931590885779209415927155302359817469780160364929324300871035602034651232981959833962379307020631978631384230199330383218802099798538727450591561639604836482862134638541962720466019370552486852695510145145835953608361944520101380638474341593822705002632385596655311341086519715328539205124908753699132966558188699961117945987528533888594114730173697508753699431955072357118196604918786029614672119248541924113561368811290061647775684578145669181249341082645652910450788659837868905458936906969056453372140966192146870657883775421865478549812061407968352280932235845870514027829143917311635120771739330330721409475541141747918709623228422379905636842368599308237219995746215661794767090765264658709883102556752671707222227666786590602824175169267221493866787712497164080421466476725688143745351102054205376686206700636795039144781066265426684690816967641859889415572157796987126025563553211444671750553785924999459372678265358421282959850456227032424798822092288886858322879752223738379106271025654319274394236399191921650477751637706546472519899818410604170703509723496918070009814768544100941026173724818391181664219122008004155637994500059920394343882768115628141496113089422478786375265611125964515378729063106641385719389218365645990842410430658982869443769726073361249084060750305389643810542319169388582682514412466870479884754447232547330508089440675204248297492584163976415704818504779160475468522884310684501212743744899366662130276423462536013757874887694131536392888145691004500686960933642908049406430643668463134820735508929843582107104542971515136365111091911527982830590685930123401357159667986885902720577872601510410522506887187988721849478581420513134454667297712392786286721185136336810082028787112985431541583493685030829811729075051438418599394416625391268938985871510155723583018758440951857468853653700856107958250779879803509955546329230922070888137951718389708665206209136575340634159043662186716070895688945071569111246675148931981913069576660863247596939677663677792876901006272024877956043834947602108055750613763030541977807537924856937957421271859936648107069134648018163301758397285590818521096171952406460154201416424444880492659653914862236182677894706274358259566206485861861045978507328715932503475564807167580868811903822940154256073505485513627003169423845285883367089121123687194932338534590596202069891443463083558915298219246158139586340160989773929807820678161716729569442628197268251705799284009523794789478826205171143953874090969089604618743295711202561793540459438087955340939922604053730036862642552379626427490597638623886403337376160946204702514845892728447315894380192463368393034759673577509288920308626065314667513038333693257209780306590656949213217152510554553111483895880097166775768053897052649319618119884875571425612725028182329446839947931894228581516573635387208347619633663413196510228809698575077383057842205055327257289079223187205294948752267568452540301978999877276205545312029541805776933872975445312762164092463173647877785858217958312262840967143601512120587124161627619465322948465382462747226999737499303432149560808089434698517642899553209057555800445143781893613372745687784875199078598707306237789724464307921186328690444429755959847135021674494619598528768586294431145020688362605704038853618017662045466578858811710126441133507957222297537709561927945647719864193278921575697650526204224903760871621606863841540787616911002256935722527613274760875157554469648824742302509211429498480164687761057017032644472204207118159063630618469790400183211017670532444423883862701150707139942112852494076226164433692389510163512369399849209867524516310451152030344230967024682157003914879879309903967128858823338322335507813285612614011703241980512284608105167319881481310834451894947674148009336157538829814353533152410916735833174270920635008521533174397427887617634872950150237719409050089702268036620796589455579015290690568498412341398958367511831225894318225011631255220733192777654480948928954409049986825081261311649807186101529887882109880171884514819744103104386404066008277942165809194993445012738112325304424111121444030528640829554078433293700726437888859746062400726336693185069610927998642401599048768128483019716872405172742366702333027235689529262225394430280389948716219976266660523362913521759724963758488348561063862344031260705381010426269814723953534762058096919042403454487728324190915109538606756997416423550092894166173335045268625659870980470914434163630084041548845738160399041740877665243238388098679321484363303613179051872770432355211034038352984233805697178957680419990935517493580707432780441230424632829229716105041261594083452244993017506583870024332476723942239942275630968576224669066665048909559644342959549925429103815747664276051837088059701997477107440425021981051740905844053995746925171844037841823522441611867345433208379741347009406659919379208878761799827677548449306681397552694707427117631406144007450882969740049818323455858551317207197201589704858224388374914095841726938767482243085025897244690463595978336569707778625455613570273121541638995145894561079999213500076101248781500642979091198044736325729107144579768273776743716439557581557253878204647391176582851167312182026188795156620056856503340092247479478684738621107994804323593105039052556442336528920420940313\"),\n        6000 to BigDecimal(\"26844471736014386438144763084059452447522041803229068645571840256273849397291785006599487523284320697343680470238987633655518309350556619041207587062291478629302589229028381126312678098038231372553660829441493022529465271494962224700621297744294496932616526614358346707396485854238677295203225480927830646192044872448090885295269754320791715225707718056441634553262589832248406813823628442833145211737096841730744971425301685139619607180752346330351719176465384666962383833512618862346292192519734009269502278807935642345490980956188353762527714296362268058136507129092128923409447474458488605205227866828078359575062341604348789546964950925088459532448694666363799398507604180545303024847016656859311441624699538151844064255163508167728001470670946579268972785524034691110310271648146081660981523967079198459787003611586879280000147947792614743474680377987088939124888582328395291941985537057217533463939375303249383184395045658197493404539401126238602904425867617782021856231951529408829088008440125858418893272823667166242811814523660533171965008921408994207898392759575842016674673132352762101609489910302297609365854323958052093639059181846925363841244351750370877258068126933122903402992603585105831753185950696107371103573823508829803583596183935873827874234793286937897675461898954545204903478124761929513090813663761679562639167378512276589800807148839649138478704556041465911335000638174774512916070610253146377591529832088372093807970124747203305565852438948060628480281513836171611941479214522188027523163016183844931458064798273957886003404662841941291330402404759165593281540645119436277012421924847805100787238324553525062076383405831074520126314125947967807940259236217471719520016175258027753761272700276820754937685352215120727924239500962313249784334085242706247335126244697206236868465207684273141512094978750549632002042787922459536652435212859756470069519619213336816027083940752037776121105513346820104346961368113517980476067795028272019638889194123496245377338217476063233295508141244131566829082230940782531662500228745600202854638889666231501543355487527201205639602747849518916734875221409776357483478313618958729215041954589296398563897648426734384974120156534461077066356620796760691857439962030225036750076399736007519531004597112133467675806420555741689066055610453967533132073637264492530003174788344384423111547309022675717821399062165605701442188020914273044941045963363448917916146712661145691611402332537365027147734457812038420926341279173385436834448146565081212531819369213322359772056255796355422127743828490493526185079153934191096447279987346385508158337908589456722289120929285410159644943221846564153840924215057792771817218873565891318368857900399874753451811844661491299667828514523608705197662263705280886731481836592887476183765103628600414171085129594006477421204721832622507347788043392724445002384998100858082698448903867555027472984396440552598985158847595031662063973429116285077558306143752755300282460514724378305626203998315243821614865229938502382438196247579446432537289309195150954734484236971915144351792802593877218025940392228463551066156670816823519964524715225433657868541261405778194272767842552930696365978576491776879868692892016064550204495177080586058007138492619180342840709695288553721149810379099537088638175300558763069235283242128900626668796833000822378087772224855231159968895596732932105931885682713408374350431558529146003821288168941580650881205994011056633932341442277871528691852682966024669962815752659979546638020006382623902414752761692074118853680501081535697452544787253049430387748622313502346425256884824507555318120178411343415625697129468688802372058988769319230557774751864534023649863380145434637997455965077889705245463319406792329605279188429178177513267769006924546412714989781714649951250846347471431790971514311559140501791648226310529831326377164548319399221886503127090209436466750556886830594870461990866351775339217640474144953192535586074687417022504758190300023876853698904882433692708067384880168788029521552986513943074294008209924052396258762786020994283596200538476978626860892735019898600664185827188224872279108519776873632376448701756196594371863200657040663793612742322799065357052820821863453571458895511089057659082410383825202704585548827843544744130689572208974281414015621496794375853030960998112351858332293882503207033652468680161240052589225175996779337309074543726879716101743062292690972382067303749076798315941471124695511395826756392893249836492832677949961555644647026790471602939499778774574288910752191786302881671454859762154448058842510403885403699684229921284474368868109038895193848541232580219910515286310950611932143213885886712731090053120271273993963864772344151049260023655314433527938659510804514720027726703842377890314561207096569349224751813295989351531810767610114499306670727647446425978676315041162634383627879909906698530188053410164156396387729709398285014229751362379837048176107141656574609863699864807219225641251882709898208635228118211764994125121962294340446936663159950709132902500513924684565524219543003130381586534033264817187548871742698989652843666921536196016650747099781037318774165368522580375479092461278698296947974408382148989576913900200973538540595138249121868557288241709892409068399924263611379507448423520073779291380262426788911359495849983097508623731625429294203223558974844269508846087408394694093925451420939434411745262743261858543988782850436844343778219883388736549851349682047906938362643599331386059783008667524509599379221031489892658097305639745682915187186377741731946832489296231533601683231161846464534489588199349434008573887114123533208749271618632314764747324530007281221848620018308799467459190397104006036354418324654633611533389757693512782150635492625660573904828954760619032564951246621916369806645234690296146329718087890259201216964667462080388374395492616825394274879596779242267165148230111505083968900440139956403551329984310842689392438384298711484122051488896805182406348342155521152218154702010887664467695547658062297288617064990820105888928399571931694996528343072332936448285158700481604521045759087815303731302340629719195915970791018451517710169308397826770055918426131094537746164817600890290030138590621584867959621652551128346663439958747126401911738974397498494135056859376903761848575754417871023327318978046418618458413880995841572811116663582322845987720115512371904491415185249899429883101121325505897699252081210126092504611749362277954223707900913803651549759928715903846429026018404765029655011263041345503073792301893026322248185452880189539441560668292077021114894492040901170511103546545838682786248874612491298590436446638841724660354113914180732917091102108394746214142130777135260091647437225917828195201428450380383243807758641333906773216274168647570667683738541325189564863095785750339582854319957896742047971824409390615189828841638765973960131415329604078341622692592168027381174016984387899417553696119652334937833048348664337406106033822282123768256077081563284381147285841021839368626806594775398898539132573398897849591073200711403976346980715740120277438415696564046509737826364064514020962428877236236963867502140197853153105482734932871089800498980664866879960605892898608066034936533253296409964980191911392097617849803300034532062475288785105535277664407788755805509787670683846380674458115969631791183817259946942498870532572964913119999398842792169542495522110920673549875855354617026865795279462780880583464750363591938641419053209770530208676667860998623340132696232037340362117836589234945771661236965788409862915805332198305119289583612774781205178905727486966445813876772018091860455220906919259571232439239987607604497230256569456517035239519027023182051389484441567412395205615515234292138101091547239981219615997870162542469463010232681941657297446352206141044817684261631617656636619769897430690810946166327240660871825394456431470506156521699892851911250140041363166692983968986205980332464341881283101314163023274440784105573446242833373718020130612616985292957746674639758125258538527949713332183311929271177301989309801768769420647081018756128423189900173374582384350314664345483331282963431988712342998579648521394262510669118865424476669168522953093030085890414799273142411390346602619553226357669233971397394950032665738484473825575115763338263324683138206603693668108879370338697043090079197823985007883417125014383365870563688719070584068008527412654813046504999947194201366027185951684475001405289377526975952203439798370851798580995850992522771409713686049882471689163254304530690950202598536911833368836795057079615581215750244102717567545268749545144616104973190481046396457202196190586565528395168731280914412563696006377667719923527366626909742306778290693226316504600082935755310171541732946006507325343047446678036172734177946979250390679105232105307880786289019471222023605598751035779725705373622132008906400663399056823425402811698102069406728087221029192144665733123152111354376896384602959518110075177922645492038454621217969407302974660770059585974534482005731574153113161515366439227620322363446133085018147392676937579314615876040023311775270651581622868260309503433777127959273203308234442673999767790625011717459529862196601344683090267073264373904678556762270601582519645455764459012433341084318806200458382119476098757657117596811746472723271512856021608761744966938570207813053209547844011988913996787236939048179460164577310111758245975477787912512012257552935864513621517357567776142490617970565268620841943855385961258979073314015207869492751750841617601729165540481593450324792431269537329281326102883923651420066320923740324861568646346512282840169196251399350088488858457585145952271254682735291829396840742141492692599273626312092951882895294071155670983165762920438708652986852071207884763090001106417454172575674743227885296411863772237127183294007067699138040332392275382337508844176789554869800187567451359825617218253331410728093728341787618390725542148955119512738292247161946836339011507740036751764895222687108134325290524777208854740289541280853038470540208710754206987465451878982100382304616163646799621947689890636180680879668568869292271742439521583664036434001416991273641870441602121141086918618179040822305778964360668928704625357954192943526437731338617880971427312346896757925231079048324576855692038537261124524003010173383028762355254975296372037776752442128595231279850786516533619014927313360988625090725480767883702806176051691916034916027887705461134611929510993253818853333321632248570794300757004851155950640618959130147163923449446812265260668974078055686295895415098143691882148669873165608178433597692958823809329530446793457354892757355929466578906889116558594295093485525203720193786339743866959747277446153399766891713172187739542575422526414341003894490154315868983366245018044252887631378875773459628478678011700419732906634619682794941594682457664223413030955742781317763293390881676059401373349387603193019677305642491107251076456069240425059830501618814175667204559876615429020783663797505946911392110484668362985627000856514721619863808091691855545332997994395476691526609686863628810671641869433333145968097217205730842599674541117855452424101971997553613776419401470535303525004223962904019014992342548439928928956733784262874949465299988863397330147780414953391698001396599981319454002177578331928795379590390711984813246406691699834990303620937568057455264767899672692330528682449328699605983907521369702993981205953841371803611160899430559695455190652647991332202047433634744906471852004277778779803800734239648611827902770766683136396243244483207847272314883005390152295234720497968241397255512381645199662756122181763302796321501538870928132248536473110121145567638504935018667491452332135314469376286242410359339680649597148483987696749142920322413208472260192566846900242759688951430234604872790454281900529998705323013032623061013316464624901833877935444134333946541118625246917855656145930422586499552259649158549779188683901371566592056408504125799479005661493363373500945732158973679435864736201052477019024094065179963036942940995852937504419243711301329012372210876792575540428213099451146222123764500996542060693243941395282859944491068033485996157898002405064270637917331850815294444246101653654107512162927904210088960997330874971681851716090664434637167610386327059740453582907296410709590656568491342288975621996380102834639043531736641153769676479736827015942303459076724507181459358186509876474580248622425197027152293987357178435515473608857789274926756593803950398076580310837739510354101885655033864168784810206900654843815451978122607948947950062258416468697387809555236413727345759441716825792125084356149366978219404197698203992815089441697569298868483754580766713407273089859437702742042536948591800001679088893456687783188928156388823273258333146228238118971820394412857946201066715723585369629539173629424971382971452705591179059753682668192309516510651519069191022727859486949209678573434050410800835692343973285741777959608715100429786387634819269591191850415595151418634172403449135369321964106540412899050526633910785491708750908634287157855558985759866669172318763870442414681200677677728225756573514959110247051241196357160800292123151588938213432682684502010459655180793377319485346208076555201746138746222691541425969849531836506150074094222155118403774380622574290061672183081123888210555856341374303739022006380017212652051860587755595110775403195791183420876006420344986579310088745698344466857936267829403496938924792290018819378456365100462260280245808507599186248437427599719824797738412203755528993094126501139081213014589399519013974234644440675104292515811169733209676680584101865684716737384586644336093096261806645911905670360938806377930299635185374618897423404474466534067528813338081246103390539990926295612563445651898423755074939514061219999029508843759608877440590947952352790452445778046500349663001731627468521687390699366359504284563399704656443947052495935673328486017973951473102289570146837378616868838976489100272210611909569611043975970868069946286609421629740481772244515875456428064531697558267448248907358344693217158450163772280331674732858580048927232701473431390992705325021875700938522735542499289285249429582226658944912012177188254630266127884526516698352555440147797533922632087517481485881948792475550362049339300333831288161861462879902105503798590764765980763022569280246597737862664062977683402878624726961212300568713271901638931752158933814725285540475110644305198702025457249332998040465282390834975519119404512731265068660569203444356803858810286849733234995200594221069867979802873305204154400691218794112444930147169227098355943760352069584712282114984198785403201423683004416651477528647779114562206037231106396218526230383426805762639225650018503051765726503808426348790764443012217543859594745511391206402188657190080431733037565485088569508751763901637935367400104204648544355614745149390264954888117388003260783373910622294107025996893438728581503826544752793762556758505246501720529724641218104507525821862959345017398277241180729537772658122103987653798739106140158444706106833878620718166491568035023008199551060062966541590871863326804230849383394896743057987210821596965397960881277770814904099364605183482184699070784921470320070328376395376521029884558757812788791976870641725133579140003262376399702893286907549084757611813774467112704545072227901291930541503256881762201101839451943952621770304628340309153928818759919646716716517855379566638446373893619746402297849593012059161443172195333211631166460632484439108924222423607639200747690755515521090859629308891840009876505239603849628081962541493817207236260258717016702937812662390902838840652087623382300110437572372535048673362221130658387170336132384704205800701681840266534756966420733310826327939446233753617857950075716982278031540794957667161713706437099700589859502068500885587182365483784315775224460364649818424666209093113778749799574172884592823365641733319627486383659995904109140585098501040007945593532426646331767138776270793309249019059599754794344312264736691590810236722641123716055260263513034549673629250440263713336734787388319343041245973094344508627334601336283956437491714204286723837378739369585402443171682706192923113625560906707722660347254126011724108683693541501211554929763775003588584019138236414809803472277486610043871141424369270111437449646027140780401193935826480289107820756529763110051395744178625004101008010685930616645204989461698140950891933296710308846023409453242726600932887580271239833434744897625421455624644098700063647021348268670068143611698511201938352022474699144097837316388817139941332076324093528734639550293014736573976539908555776660305902338221699685751082277654207551211910617330546748697547808000986431193706014095691387233269293831065313066867678462436636209456890790725354826027839980398620914009221652781081547765017575029936091847577806826561975276709887301400388530271382182768427602668422182893898799411071049740241027293069876580823349484803143080588670841630306206747950591975832830311197116744316591297765707240906823249522095786078314718365685343081282897465327974128067555209640462188116122912291459814072403943585596248581785618001154132996922800455762852515685766570361870179695973966535991240148203123243751605307831880128162314395494956247010751692432681264697632620058638307984626524186298284433082715099996266437390770823289011720049372788059443167401763198379563561559612120445938984262885138176458941504128925306526649220418496432265936613446499519719267706936054384428274927176605096122454600541079279963131271782071904620772409548733748407719194763336556504353554867612416177735475865081160535133449431526729814022672629471511281841489454560661131449335932766988142282893074101212201072547821246039724836586727904281472919063380915598612669488273481567675763992615117801411725825505531542446243370459612152093904132850315770385587455786056877109704048335725790024221343742967928293493830629962637815428666212168198629206351932226804428637268069101108764178945273763614383892431623232833979039467923384850089242656481448000829194720665695443714657787586769956220445043097219553469188009954606071174427640061949753568409099686040088053126780961423241780517797340179260646936548755715243324648698282859236406610813419676903006580609363895575232965210269539737675176384382038804566391893644454435530350275692786602671603831735348118143295755235283032025530430646824470855325538744077979233928350168239800224784402243784942119323736701322717962234420248351325809400955700660466874467241774690416394049879531426009059832114396640156919209634402841148526690304683134201759883824142955888267507668069255299224775437139815139410456237823051821557014732836707089677755609989860232129105330778350809306192041877940702406305029581069336412558457018190440683058217591137270464386404066008277942165809194993445012738112325304424111121444030528640829554078433293700726437888859746062400726336693185069610927998642401599048768128483019716872405172742366702333027235689529262225394430280389948716219976266660523362913521759724963758488348561063862344031260705381010426269814723953534762058096919042403454487728324190915109538606756997416423550092894166173335045268625659870980470914434163630084041548845738160399041740877665243238388098679321484363303613179051872770432355211034038352984233805697178957680419990935517493580707432780441230424632829229716105041261594083452244993017506583870024332476723942239942275630968576224669066665048909559644342959549925429103815747664276051837088059701997477107440425021981051740905844053995746925171844037841823522441611867345433208379741347009406659919379208878761799827677548449306681397552694707427117631406144007450882969740049818323455858551317207197201589704858224388374914095841726938767482243085025897244690463595978336569707778625455613570273121541638995145894561079999213500076101248781500642979091198044736325729107144579768273776743716439557581557253878204647391176582851167312182026188795156620056856503340092247479478684738621107994804323593105039052556442336528920420940313\"),\n        7000 to BigDecimal(\"8843271281457681418663550433537477443458288328558181911369356536888706229057456026350951294423709417418221412556291220770819997907207106931376370070081925314052560583577049709996187507288075270544427904335801657454583730753048927356305321445507697752418054761698137810587303453280936073441798597076650307687742941914448251770047716524686748011776525545293955302862520770640730254544220005850656870251262583174555435189100173402438738518375335593518851443370840914763785524845710145893227485683376806690875958183372626253421038433841346109425123992654858902243131419733294113129452850046887929881754740384120784559897170011406084836709528083552922616719942812310990209977308921201657555933104675795451506450536312021536103313861539465481363823902349971130989383299169527176445483766354108648930473743463681631888728618042451734374822360815731765403937125675770014392503417578989824733744205083547474288733371560725574090458906416101689113577251715455218518104434877971763854776718687680643799157840783526276339261222927672784869986467279231322813023889930182626524407129157987675134927270928833761237454734470153882549979899660862168400654962243327214056408034445044816072026017997622935088492721047825440298510754840174646809900449286296762195189945638910388433631056659896267878282499543380991871435195944950408460026150996575386592452631804626658571039895231703677063376677202181664881069924446599687329992717448015501532622968203140160391849201579258585528876681823883996018485136590503465106403995017653143414952381397178263586908593111641793857245692418764687985925226914274969540730163936964914994961106600498084674769032924981495598419342036901687760358548500167737677594502672073447419291882280826746544483211148722327887112346621059957425452246447375543110904663284525302473409369602881784800850851023858428500088457401968694980247591124530667621734354854897966248583892419290012559002306862414123075563061641219419183865847755837137491561740366382897934695604234713860469733627085314640569956336329470011985729485468219216912912177014255323181552904780089698347992262537726514559871989224312624461549795530506789312399409784681432754545794544897814514785725004653837951509211350651513501758159725542575185872801882152728942261114575324210251283180614387988617549629881323123556972772303541482200055215725961360681652198891914344862622376758886237126251432053162669639408035335257637864174330548792319961243072532602479024647363636779867885100042700357023378255665323200428311813441677161623790914292173500185356161590131194693167037972249705915602032636654987944279140072344221161627288488843784822797268042880405383387319172320617848294753719786757600992794872352021273629141040283789107991579327972811453901330084901117655785548519102232738646042703007408210541102101862759658947929192592270196685262972036397790203097438013001711683068278993805653212912793345395328205304777346151465178895053838731356600179943653821667094351102278954767711476295903645508948303573864768947561794737450997687825311991036634626431238128316018934423130107113225325041547428464356866959854763039868293152417949692291108021379254844310318690917796872773547824964840861197993403880970316230557963133485526708345141385456856659193873278854348719462017237242378592014691850329274049382531388292418070726821888448175462796945613329781657512657765331818509906241070625975156357153299932130605098238223372179116526803181412067123750641856108570384385184071349819402455675900319845428828526998500009544522580183551894160731648681602247896006893215245554668197233469826307073114111490468319132928994155862410076068582499554150946079958035518659404868039577494854254671643514716236329112968986923253368091857425731507902674405306252666890324819627503391113372976399150732263337811916955818819340026852166225780302393043117596607643952138978215363466295267204539915216448499147787723648158898985371424930893186382041313273401267682245493934964601627917071750423679858550567383546299156202578408735168732955552264500001374779564840193701176873216633986443226336047468197714202548615134879279383056510704926644948470638793911838337215487317718570542813999566291933969617696435251188291868007513252195274426569267590546926338130256580582578008970634675115953657508600931537647455205699233738090023598909425213309013436397486000477743316016898010412412822821043092568235355343477348121083506502427808657874334331767242328213822412160058254352182223102693059022231345229960746415260615799679539850949962637794016292368406082188782939041579075796295536510028873358491958333893967939570703322830884228101301012679476042763832998127896071112645087115291783566722539382294568490112146627876866649761629822835319673829184917525494683271118900420603984327979028556790462613329084559412892280113648499369337759044556938668675465372492710682420209583345725971559991866781331534125472993639755426950113340257668593072106722395020648091639115805344392737003627781183856519907034667148737734537991577622614012465525916445272196677189213345293206664113721864085548307321146537461604076010731860263602689822518158980758847959366575655289263824367954122449451940837508525311654329000155968620278703788662721042801794283081671786279777542462356135218472238106967306073792410350175723813845478662045807912424579358870856781797081868169195350351756013589117764624811506698681234015406513770935454167478646734335163840018865521618513425883702507558777836044158062201720439505006171938529339740922536765654703184342565285167273858258098649686117055645279298342986185650903827427900035010674347655567294466578149367895526523556744114082836253520831613248137884349012159442202957712544126506789303793942802371643357657246709687146408599371369785590293192228814678616437378505384795827955431717067476793287613463258225502358261434665773843424210054779874662044634548501686742711151915826243515759421053698894984868822756600270241003881478331194514655543432288068487249691675802137931655743883116149401747996883126049574201732802667461057592817164383929283660672182516102790532456706859548463884834043787250255376560718332504288691710875381620541193719099006849133999178914369766476014565955280733197807434130275474442523908861969598852623807466174705913632456101662370106868665053083801412409434187428466363776714785962239067219986240851200570195355397094767118831435717775850717951901994252784311083735036248275143185543167113676102705921663561751586509957311294560098464065264722607333881775719104071761078468038895224326451920167983004493993457784331879880169513904211255967732360664087825361774858526983846293648949527487199741817141444125938679117699545713809426993234649723827257962990882811033210155285834658788350756493856798301996277199151964073028953524603243873913310527811496814634165131018084843251307512932188928623692643561966272248131964330637428227586506737345032354526391794728404310869143087452395055601479740425878435193508638414222205210667742136765861622913851370770898448356716167085152878457347950824260400740293904436050918740644247126146937946903279414297925623374781600708462574511589479757016580360195623722031130101897893175345679907880927106856868963242442992841066379994681792680588926660832137114074747835694508963888067063513598313667579020619676257890075016457338034067207794727477053768260293723209122274295392373941335998823046166756767040088583016602400639690234200135957445054765496592098011743702889876288386282273539881608311871508551098411309908651673511983078015453998898593365106754622674459643199407775329866277911349260423846140384651520025661976004482412241840751070184827928019166929583813364588033769631437434713510911721952057014843001661806203172130165588552531821108244952823850154107920469283760860152125511844239475711941082858547894852759633020785646423394177961699401031165934341083347074342594251247812255738990770097585840183319430836539431518236800200203164166355050320280595047992372517064955529610879518595249034197383650998218368995201268675427070542598837129803482027724504228855140754807903554473051146740407171991842331691509007603437859217833053442398997562267708770752036617719137595661910014899110266950466712740604017140220006065431174417277241741052903808524001351462168138827804208773342618209223216599394559494745096806286429494299415006481494901704782227661545291126072166723445519987979375959743552921215808253356316779453926082071297780331647351778673875822158062300806463538317029209505904098923272949177886121864059561504913011093531893426462679649675179039911385831401419845695013052777235536095340860918924210061052157602595295556218311997339380670101077563846324338473871220078498518008148621098510340009076522267370936838650701254581120543371955161369079800091614757083089093838473403581361290773141357348841928796556180592374954750852726694962085632626897976236425940438890990922613460072952132722461059809658047438974262145968232466230674635535275959753329120901277668142340522617608837872876836540649165732853682329056248581042125677232054425719559673380817549888814832484817403946574653633865709680294589392335030746078234816932154263799676183383781489324289739437431979360849789184951228976499636823701845587837572361299853924935453735748984714580155083681160592352881369962827389953141063499329064040384836448830966900304347147883710768739761983355171304326951120597677325925209126188980818733515971071112995569949605014199206046619538698145345887633944238742387359268236401025562707688826483794912712353526514773126407208816928716786463902879112725305299325711131586143601150162600448136773223515186476207337024640228660748830090317202588336090848370491183285766744851387412979008874164681164376691751757863364594018451947485202874795375278733164961520201532059299098199590590466084049282943481306771472624224248781888434174877539590191029469782378229112072098821137816675777152211495404611343985562034638622698621247447062542308986739330006540260478158192876609861093048418410281868009093493888331612254444858913715570101478605867468600994013301421642251537470766362293421178993361762903683383627797204230676447565447489048784844181916064138914445866581853523141104306788533281311177953985853888708618608735862191731344122353418188932640980009629027025484433047252673808196443053139036718126372222233394020433581390217169505629311843018894201873736070141356628069065145054197960260383999455223629431755053090639032716986833035874998670507917390661055844589022749017203286845823148968395322177770393907540049561922048628143800534492073674458048771265827341676485183353557487336653581705659587434029192721359366529279600575117589035657296008111874678228292486511020079105369284439509099745422219554448391162765550223297349582088264887229616655818213845574115488553495573807234422359514151562602996325163336516008445809278391766656068778794403777583923106479526759413477124383175154011026568995207979917501357336984377298465876579811078517748777770363094522236961490907290841245058682044697093007776811136394334037153863589706260763939571484937048481377273232303246078497296385612711851753561244077048701669420559902768381267433488966133074673587356993585546184243498409152664099971888122005061853238080131821066543105786662999642324565413126779970908442838963742967732745327398588518450312220807803311390442260859086934116473968978651262061608354733628814584882930781450580155901377063338916932866118701918043729764595958378900536806755627713174561633100819205991675207201791058159838019642495132310493760600312717875186071182275766441442161734321586357467193873221407536829940534838575937302038196511719198011621481930639575172721259145307190897676905554325174746480209798651089645577561141127921302035716664088163900567299008942448706298242451099705747325570800653583026916803696912884935296301685551935228731291986217314690387404381627470577642756244530456982825923446561516163760250671077133630717939179033115092495245369603450009423144995181586171946311544498203885508275360559388255457196421376975590562570586504738225715235470341911769560498357644505855626504220397946932856644356315821220621984042741421247849706443740305586876094501109783079811268548740034518496192116616746569325315217800411416680604486054939148126928303117204392461499704378052920670858579392658620643078387535420275974073357773603787867601948216546045281180778810289016983833784914772047488888474035172178029617323750366928297529256342332318182524181460428330625928990066991846897138585621561354081135310624785070154492140990564516134382508282407044367942532472131424227449874453045145708523371980141883699076123981368942935814117406621537144463510711655284251585319363146460604003272836781597514555932511387004313956980857773680432517676257708325386674712115045557633033319817218856683593352851115639140499999179948322407709783405956824862692462861137163849742871517119967333558622655505502386305272577832230677431561661391554014029222378955027186081591750444056656661926656314651881613716113081010960999164588793796435166028379211145185156731202669701288618527683508679775319223602132734785811417398443969646399801927446347776176387599446728653189304271672700271180498790962147465094832420150184259440102345196020631781977838384847452164608535832344649988877141875249955765597326986272426460301889806724910227928215426378578558969737758127990305420806649817300413648785914488171937068326264941626267253150607271738131612270056399029083822870486309977754664818318958471339287884264137901435809416257042347537328170176250071595537304801234923492929512733615409032520257301691328498660779680489306390880845695340210818247796300175483689133229507202848783133230124577239213679139573026129034477149203930377044187891131770777828146812418087549144963380009541564030487451645055437918731429253593442439030044471356584137123565207634392891680492447209551306053208311853933690985306021351432106570792641772193879193491540887909198114388560348400691089675605608906925473997239356445886271364890535826773459246832801621193290169001681410334280496452639695767138742899574259705074718789095392785251675748704468183887882547451895641281894153886077748142039497806861022451704220791810749270767338533165806277515860810290861475680289212658739851158073450702860415595340851464094808439737556818351515008090426588659817378694107597560432293937517570978423226518375770288797269209872218882828957359650043811601483249166788288697817998947537500426358323909054687352447785189935059343016177312658768819870697728288264544494923584299108049756644650011933632321880723339801560765378025386408793241959713221883814960600577594415607055217304916187987702482872593168723873482486331413299001790548676070103667858998172826651582282670637543824483362294789800084768773125865374221429881021781608903561523496408513023207767162395946112531377470164749245561654756496033155351728469408308900281017879653286244663715112955384946576163282150949998944243071763271176249035865257358503524354106193869964370553719734616434443166300778092234284636692528043604880261561600102598557055247281686024159206988727632910774864450215966257645083832591582867436564095653367681729974089075828159573827152722416699613693256711862627123125379316972720434496605792094743212205034484461453321662103973589028970747957847937328144010348491775435654797979758080982797545850469708591322900588706046673454602235461816697381238964423417594639581511002379087983641207192463144607933902958628971242470148232687529364473805066812669671724179870393543913702991328197438263954612182098788203009805172734908536679351353035503226089518677216745604901541699215917622327625108970066786466595362498616781087918967103291075084829064833661201438204918454344653575599521303893306923946519059908445280081920255653215385288857775195181732338517347005205357284332528906270242747238075106954314608563156072561365669650801316212914389181660586112011423763478143522287139045239993569877156501809951366771030355189090387836042407493974387496750936109246171896481295930241019342509013249691776960185059442218871966830268497534035461510585692865485636018277076944303668276357620608040382540588256298026991166200192239235191616185630452879691929572653967269091021724241930170848571364618199268796256840044708013627699409375247762834390777707507320467955145480503043389338629060792289739503732765532679777770927119338516021231457413338470253786847925604670658498825355349912406171517069072586691734045284675275152827387696282531781704580676809499004168795968272317376261337506253414876252987011902400844903816389092230643105891480268485000034128838534869942448176193447309319555368290848362163194287709156964173426705354242424509654471456557335568540730434329508560160777828387073242263228054660845792379603718182919483138698981248449937455924511668231943225198203587549283591718105133926479612641198764260748469533682704305961739309644290641577814889343712835924083467713736764757191925460841506322642446883512578531385606936730286993393456234818208566245732867802243967100805650278419883015200555239835184968036290443559415336424698861022510102632837324544389609944690899470838528512965344093471529336673885551421695121475600781753613415574871676316481052953337321455553914926683305767159855900075799967619746737511053005542330321878056111658452043105426332446523232650548211326836374710912589024013282044495327905437135257639596452343788293361332831677957179229740642151753735931251780724594682363604350232621257549922548189395695805634662190743090434659752627360192661231434790833743470266882301793826536169864716409336233639578968261873974740337948871267947045356644947059642825582418468524966867657084268834716353281685089254146334654983607264572040558977682637078827359280379309993165315394537476549038843977081452236348111192454961181058882261297592265793942410364079997172188893393517286535319249336696787887156546539849021842350643026194612113400455096729964603733873654136424680160964624429884741495445020078522797006687242836696031699923639095720336982110973117401879461959809491712879076274053359933005966109999545972470197401385201121418496574790813647832795720776277189732940673651612096334647429802637778131241120866387430942349054201732255206370143965179201459063884472844321216429324585786621162702343808263732839889738328407379932052037710376153914370554941285850990241325824266858057889648924185332828261244622104998436411416663555938045743880983868827117526745669663894993553105288509301387417792520546395866889066157039039800374050274506821199368152915723757173871589651259572021535956343899444640660602045899188146060736152985405891725654538966343274958767590595456274225144929469105308834480264652079558966706685629090148417156955988738266690920487962384392821113428642652084785159704558521045819169357851660735291435065741448594559713160216682155404488854935881461936752814983044564322664122591365807431146537516999102519893142333450543252125895980410089076177104027317913175707051075404645339451031120807825366805253054294050525288416795554323983820745731143636812746148228073059887574069836692091781386642228295391437036365999458622758064591833101629120989426557693485388273061448775227590078326908153494575784829447894806055639544337357673368759302102739311463046295398525392000636866212831833900602430645022970622045611603034485672401247684615586272596644936478169251625388236834313885921997110608258609845926824161796036410247418364177559754725497260020084749756875860189928738444835533072899073420940949661670695397564674667429311944778459848336175254885898261366862807996963970450611878905110284361886265236398091504024206144609619732128246552070185618771299567346019380058957557745430724400126023078781994394957180069498474262952180036463105345723078386348110504104379232963398125956238127100310191897997025710831354922285412952830407642849037407453892905126241638173869834517627593622629015101941771655250980055845386732759417801786628079095703999772297439047714822389644149593694050099126679079870953259280968520425961224574183164813516392892018470922993588168158892948150661947439798114898402042967885816774378042569763230925036620387174507108341917522242907948093623521606278263528013080968626126862451340876158742619056576277535429351101423990150639107144648078916491169157758794450074004193823262582392907716059179293728603185412997961516762010424482628245252114671331700984515709477263374942971675062683243281810553101190497480452728838815040123141525313127555222755538805849933476445640865994081767653191608971021192113525432391826924250306343386670752829386144862326537001060491176000310146819383976325983546985293863668158182415034984652991714024513806821511642459298794594193465942762575875010049059525670038420774219974757142432090593682979213644436576110039081127662181664753522383556437925782874546748038106679210276494401766999623429935990784459443420545051804052550807850842942297426922815605163271604230093071694827134996257969400704012000594394371120573967678794065592395243525448234446545166812726427273134564441001917758039754283605791820282748128576998746899402178557752928937295876718604248666008717330444583733213378702242935186550613522468014155428621934907229131750398200494121209998192611003692900601950633826409369274534468861715505364347973622169880971731388846219770862951642085463883245589015669804642521598298974718968991548180993911309237830785842965615596120151964394040357856404632626851207667218183667113085390433748634259080981970208222422093673538325604024660557955889042033892206922497112956161576667977851086372872420873201011307714182911999505258647858988598475305757648279402724799079586728653293184229600161902468638813915927846560061282291492336923008381700072702586067830065946056462105490645635316462015352197465727277387559946031693846399283758536864435629099497601995035287861373476147962377447021026584827712873263184843854036061431568108552648126154750281464421138714662557601003336409525458660683293261264200958787176203439591959006095592471298021745667689847209628923448372034227103482466823314103600630977057549087656565355122455129808752394390214083541153589561846565813791673772672125932432217666268337849637488485469513161004897029308494879888283376993899620458173737483102315656161110752574663117714904278621257525566819020858931565743236306107142210012354212819530254418673041669021018031436221112892209649222134313442355397131361805507756252272905998423670395656947214471242972480569588050776566423771154645692633972815423462520390919543406820856312114396640156919209634402841148526690304683134201759883824142955888267507668069255299224775437139815139410456237823051821557014732836707089677755609989860232129105330778350809306192041877940702406305029581069336412558457018190440683058217591137270464386404066008277942165809194993445012738112325304424111121444030528640829554078433293700726437888859746062400726336693185069610927998642401599048768128483019716872405172742366702333027235689529262225394430280389948716219976266660523362913521759724963758488348561063862344031260705381010426269814723953534762058096919042403454487728324190915109538606756997416423550092894166173335045268625659870980470914434163630084041548845738160399041740877665243238388098679321484363303613179051872770432355211034038352984233805697178957680419990935517493580707432780441230424632829229716105041261594083452244993017506583870024332476723942239942275630968576224669066665048909559644342959549925429103815747664276051837088059701997477107440425021981051740905844053995746925171844037841823522441611867345433208379741347009406659919379208878761799827677548449306681397552694707427117631406144007450882969740049818323455858551317207197201589704858224388374914095841726938767482243085025897244690463595978336569707778625455613570273121541638995145894561079999213500076101248781500642979091198044736325729107144579768273776743716439557581557253878204647391176582851167312182026188795156620056856503340092247479478684738621107994804323593105039052556442336528920420940313\"),\n        8000 to BigDecimal(\"518482916413652315742468084596314253694531833718379228891220522985710942084195573751873572294562551524580343621114940671873608236483066099886101761899531794290782122571869391934512540735514179473173601518414633732346386594016958404646761485766141138878315681049394446113437796628104162193159004632954339335985842928671357668386627204900872859051796996670224650773264430445952806670078806023933261099152590768083471693472459532650048942781632619552400590050518700769730841158145913863685541542322628415490107094615132928305391118691306077146916364897034049946729267845528189232962543922001384135634741479916670300781930034434814668447781372386474082128404735706099065609003964569069946614127562728537768442643080113667889696844890970064933459365855755875157413317606340207633093501125187246699654327211777405516375660321407924448638645596281037128859013435201190259756421469179475636837474405495036020207393363233960274465681038869951097929931351761538059774001269492035778722648156444580629247010980091591845162993473963365745001430171901313764170974700307630516437306796282306692077891046849921074467845921098344863826262806554863016157099338418427386061739043991675500507459073812465134678304819228004005763924544994613105482328603357455313224535789792417024329246582114024808454539551729457327200389343405326033808152847112227073148499992659064141002958167643419584728710938173801472228356293648858934119696237052070870803729569259691363399720121173195952010195841614706153518293538318230197236633537956534346502875916798371190121901882197072003695245288247960832454313387178271758578948869947742650191659608206421013952320093807702034424280091385794497966589279423656840459929493383190368817539673788771488346590593541834444799064609387001506899239917784292021848700651175354043522014938879412877593794205982804694146251255547839426503708785173911211297782180205494486790186339335938985475371092241726746850592820692228263433220658195974008438148944434558527172618065667679789609514671478889362817884590125296992062174473615996750120011258661593293307371017243855048575683126690237682258124501575846022548819238130852314814856647189752601638644068053273111865201438450782869458881302656137842238586763097593878280003783182056629517980331583480162275706054412917453990118577475339227616788258062415635394378265331558044497003366832227052739811673014803334035857099301321348815001058713123046375778654449464291835911913797972761943565061872296317092506979352233002699395840240035907405743772140901885176039859134572168529670227022338629414656704716702842064640618870291586501003591692891081335527157441496379021163597719001417869190657232029898910140518578434913112274901921784762314746593808354658418775760179764635168106214262452328039387737403334115911585180772361398224746922685524079064712098074548504410954824249275524631451945091198642386569888003597419160921364157398896347239791462477076388322926433009351159968961111167618627294961477428966014189342441368694885772158882217748415789161193097218415504419165407789379592780826703550914724696098948997573916938963089672982934943551336509949752260702573778863584556944385651275811482953836388446672999942281917907123441670119587302606856291506659138950449916167579010167971863918450628920239873208216130171635046837141152848626848061113772269540401501612467798127875645969313384098945836582359206743823483310176618425586789756864559815895751153924946773970593596102906461869337017934940062134340070428670413293066571179118058234965600284995074419191284834842249278346314081169176096313016313990025682985339508400836376348249884579165683032626688571073945659631404215738325654849060341350241618551626446732517026320265955416709384791363275716817705234416586160026527870763770955899892182490583921560252299463453170919998878147859934409541817229714719837778981800828612126558179638973795373381367050580215437801134485460199568776872645362908669240474185313593214244083593556220340951991645723360643006344416433134533484303565198371384988651360503120231119530775953609409153155219901574938392921588668077320648550734562769891833861288916004670814142495857287055414078141151751651333740237628570057483099513724152827106278439362536835516675339806655565025537592349290018096053343017968131885131557660397936648910423527000692384240899568705324528274957835538054658973527046054770393168542872782957187218868042137723777011727778386249418727320862068628101863017430724204568349585069543732591317942841816465840760072526383009171132100370239046837603796572558511472827946823528334388345802937133641019189320738204216375895430992359223200924791621680346005303270045718659389077776266180730629230347454462765594318079252067814262713373077421641157753221127885927602061962181792623418501629786063349550343663830231464322734680437555775311907599294009711961196440624722889187054915385298889798195505181496370785925913957571334666778344048532193128126731463460304063993792897654732020776767808875545959016141133415150783266309149107103920205737964380409787269657977735690127356841029141530386259727312120305449952629816465072522054003053399858510256047167310309811808185360331283550030368201761809165461222375361241806511052346277914883587480401936720309373683611997427156337698805263136664352504665245845539238928136131693111547793433751444410489468460825128775862777673721519979256442446726175111570404232906445682497802731324502294131359632158358252517183054202517480692955752777725171821081345102161271256401931220237547721800910957747448945152295669598576939568158025109919563613341769352056547774866958988770821809395867911082008008582416500159316536851331111392658587662003899271855377098889703425707648852935176586852647707556781215649986872489638685577922841715016737470333773041365522452834632999667297197437217491212906654892867823880890086707439457658080324883030523254501145006537506545336949692358656548703901848191069826777586321485446517567667631770127145033181827072250074091050843859472691775863686592876117936487680188248131012682009108210509334128218394520577330490725595186407405503069382525509665566251163109747048144152580506259484471248547818536200183448823549539176106043007247373404296641220407393412366958933014140957649115266628761981522713449043490202607069243079671709297654950557581547818325990919771498233143899353448328261223639608668117366811855678010105577892998629346316070399203050365480667168789552210585219812256554733167104718241281187539448196705252813166951198482422367401843254286368004226058615535305070160590033597255611410982974286097273446440408378174814826501702308683408662895091726872806928788228851316098467986174184090583476342488318987592982692903914417518114739944139651727132653298011693715115962846668210422016464652032690760840985974489266528111340788421087172909727611005478393972066830156497399278208786367730044286081046859250116740876972525137819131593550679539784053388608764694101557144401693629146952956783768795467525193708066947178472659574647698165861807381276570395824980424381585469144611930659053988926175782605155511492331003590056512382173147330610970613327787825827251849794408824617276094100177783903532353037461617009554932347027108314245583833500542997048464981257223425968802320180433570660425395626251038320154186234442783078418570031646921742176366438189363650411788636145153024577033609312469353516765349712717742229351299937785743274895360489650603033321068625231984815328442951435100533722763035367127649317910454727166771320183987912676774925388923359910852572081668058477887252826947467046042261205876998490201925316345472635779166371475463257264232097646698227802207140953934478967135188127088502281156466504826435117905333194552846138929928519919817049783947668260150364995158743312697190559663044107055402004092297114124349667241947929768092514358557475239979434262485506707832772454096408211729120686614872992682624942156436350428479443116207497591071838695384152001182639303556755378574368414018790078265219170855633914867579840099388514210688356392182460019300108409458094390195447664629004041443733653704778775662572331249740365854021654277043911357588993514983410686932479981180121786534985016754646895615697094831045824752148628579405626002630517304928528187570573255410660579069812322392078650100481604381704275000465057537068735896657218523161382956214208383484875429353625321689930413964383639044708268716226245595700405008531278066551185154705257534111931251192552825922802119903763173253408384297415281381116995108814537144573217947335660267038398741617523366592225434204190320009439285092012157270029246516921089426219123067050632009973632238101076824476632054264929386992083755225407011293861753037129015918806819045402963629530657696801728258164963326909090356040792806565680653613809681108430001520898112112917984078998385828348857669233170012888773118199542889271331453632907195510772598658707965545597956517963902564798765041045304616636842536984898431691014333675789081402387273454212430274336371005022205497267330430844793340222949368644113440059741029114262018485470492956178254955634999257660811289869587728180513563155819060948669491757155926452719371900989868553138360648595676235623917933378833304686189561832003428914842946576798116467186452376365785343279129805373669260959677463673849979192434069489033711321121745761695575891803224165140359993273409402156707920716051816539958082338465832813475420955070202517421081994230359151141517459675772630735488167735379026923084858965792151045905200027355797966592560551598090881499697002812957502704377546442199157676894461095100361253550280394871403302313051537743835527219476854566884141233329656068484023683369210034131260114088737299353371000682558217971046011744757904625701050219692394917390056305122729353003627684493005016478052750271233886925731667512889049202668627999528990004611297448619217240739958073098382875790368634645720442827621208349553560463016333442160482906682500675200037573428370069958807598724292013996906468281704390371949341071143635608485984405456081190183707933529117854827509067335063567481034180175496120993537085061973794250095805369681422692246216519407827737066511470664702027908172228866254691808511973411553950596344537985550747791145540430596789775758796578194288691290908575271021472026714005242554395973693940445940685491678967594191005139890237274632937109718700707914408716363601643736160679828494072469269950576268203747163856167910863150805833698866657214546956049135894372417368220920625515046181609190976129171000133675964805856113583279613856424909082163436128323455099417243705544360111344214924396806583975121453153609404351691859798188745762521101692247336922753253708462831611758015113707967862098912204548945015886547584074037296167837067637160377975437424925297214179018871748430653390495671969791776446323000572540344713743430131078867790977858270126589049391505866356840413884655248124156049893364217922740434370737742946154164821680811534467215123008775676986896636920667194527888032849895320243126467124710238374904015121786643188831429137365450948024768238225635008438351695124927322819123422996694940246280001634626852909429360053881400935183375293391063606944683533043694140522366664293466218692433807736438002666468331086145828673096700571120957859031062567043806106775272289548306893001520214410817571640255283089952258377403881838075846230903847334496846692137619019417721155730262732204922264807353605992482720632526054837348448991475886200541581169037501327581244436340998379984653538266266719282852982272879628849744122756885513726758604146550687041757562552077544253895229074503606691035434756105790576474004813471034158394120706573966877364659753175101780952435249757920596986738133465043858397289716279816686893411613608913802766400391792242536109686286330877484427175152118353418289697918403450394108042008729507247211993940571461583500483665828511888111536787836510500659707561108566693667864081224770279995882190590484697784308643785433068718251348634348456846973531975509334618486634009754392369676431563151372179089815803222649335419124891363765731322222135694369387923994342762706830406971412446215223933140459915506653219274699422424334278760949596746972976468275403196857789256351915656347100380709643342102979846238692582457020996283078642489331696636443170229270586954192025919201993480822481508425898220010515352271457719772406631549063148710739470365279601504379755310456616156867887730520651946250982367363975463956293446158958841898980312217389897549421606881071643538686303634583592806389960080867270036951351979122803251686560184290322516046710919688009653923355504608978417448662459128014853392676567607295500389169032536363343671950777499305817823443084209295775286120715511398677431929213235751638237526308858588601198646975110992998879384330135585033484507355766932894585430953742224007263458729144217964127192124987347632799654741103738978007859442928231215117766925983766141149096344520750583910067175798426025785046361460415975598911068007980759523448099116034106574461002248678909978579659556277023073117580714523926953885939817529930324019887870503109707777483008485622803200231255254804805580222743484664911664064227807058884089948081554024566619229570761298734543711750716375352353839900093861778464221840310004401835814362657003108880699557022702852485993203031825009826806161946521743067509449178101661895175564526148554967238554623370563892336383829443787454409892693954783897199169300036302184115573954350436795661131570919415419752250986336400208450419728361140435708159704471268116636129368296358611703053785918972888736087211489289802947012174376148813689064365612474049097410310644473027804363208050075625004689492827797422284377086871540676992490438860380512135469541117134416383675309173263731064359922476653733772200982849391260059305411985686026300545788844828859460535480425175680437100740148462729026753587023000883554154802094716302362942759327124714308556290300053876173467665876058838967126598651469498199369347683659214244861607923640712765839649400031754547566592610233353249710544282102236152661327370015328152875644414157352395255262564313458308656361462138349662865423737692256764691731264012623155415914204210687980655269241358073583779079105668000347719985169497643952753689605350757637515154556781289824642493078804562482181253690458068998842173310021702604515423277757379920853984412404283226877028194020726988391510228789691584950317480539809533416664013568029276900503062575932922693967441780037259932943708697953671109297299103740475628192543463185374703449365903463032730458339257937476280284229039930787349804650896615827975989182254209178266700523339609682106688785310879553723882804650313382286801375298426937992601720806466613571287556509021012320321424267233739105736136979962492679481629417559898120076958086196849915807686852489128175590117218447643802523345742481134310778537306488441851066513755070017048950981137565989372025674028055472657331618860896562110839706858090105532290376030843495311701053955420153198936978336693431453681194716588174326334126990669197391055847010609839077195644303881041634478372988749337385427968126047344484842512265761435899101249971703604914519291222850090958602840623112638903473702694699699264110829692182840999059083024328543146311692907785399058146090251672585584946853810601767711807791315727577131307329456737585132553213947200764097883629281916657944904880372639319258685347015188850966874394385539616891621859043778370580498591350036149451817067188709105258862975234224233953748497715769629771300724776419576156175657729935024793067776247809432097432731053299128273316326375987202097879045677296024230929317497941310647187174261569753237551363900649727771009202437712762959151631500587386389079715401738278855853806087499356094491594828912353043417920118269867704063442695782848005983689917714711285863942117482412558358895562735532171340560645475580535359993341020011150894091942806544418116087974452674412318276450557010324942288091238646740100126641539634563716546420708418410395442480738987243170199085254499703909338379577975973255296578764484096656949819643415219960903909129531414825929327995665958156735060158646480034436821823124681334521867373347168464500480633070296479542921698813458973144542579019282726711201089127080522748692970128264214268900622946433303347787651210492306400252676320339498478799624437617923962925377430049158701423101653783919278253584208755581759041289805494601962972990386624997268155331425579464290049220674804101707693498302443047852593678725368751637760725842400511774780842942046091180433008523460178966255773070505583364412779269118782076697001907986475063288989512053750996699737712438484267723071843164863525445543714227023679042144299920489552694415921143289047245826199260608833027195091330615812841495820068687795727751999570362820122123212808240683869128804789631041903890298928957936188047708798427273538590717991153965142456782822619678828891748667861967813652603814681161069060438098911682192312564482235417836486220120506128674827069758229281199565709215364092031897712028071965152864556489808352950511072398124597717328849156250856551159039868374760392267129042774667239268445483193829857261077322859687752674204659491000682385199458234553091832701149338442709066788871260999233188516116106317459757734753623846310509371589232161688892408757803897801741028872219704238467546326753264880123867022658143179459126797756572070303866076465606728243132675166068269108817206782734466005721731213510072341225720145792165092307909589439755387234391793866025971919426995744940389478276812332840433676209835340441192197138966774062195084060942577335770218942281249247199444764023084136141613489552880220712959113173982145856205392917711559465119246610188365283154879087639615574046506819893044883995520656953707175514662126015263236126163948056171121105783529651581407910539061557650251270512294081835869284307244891372684043597645086254249100321763776151854460721725739816834732870893778837336162717437166703588464631891465084996715322919429683951453031184606501923564364730024421899119495263770939367346783141238087977698433011375209964569520742308485951989523338882145658594037622639235485800168168458456174766590456730362433438416467764970797228442596877002729647989515665757583378783582657119562567494385584849261676616106942718178251905530481564842970020407012696578948371711647118691287080481389458218944235571852635504190264882487341703819686944619057561807193673403878665829876299104330100832249355349575699455108787227569834263838213519548887380425959881270931022384987156565527564004925109119386567746628783211488707055913577254446777772044975376843569412966878476391723074640048105533071153503617386995401290184276987862194055695051740338181399693343313158278174351223789873459667356924462562656974089685677500985982789850264672636826470527596217076565863502985778743848301172096922968479453314201360789938674856126924570906660509524342316293147911937829459813537164647272100716095750776600160383793934585194688655086171744844672871902044294397309943997745715167980336110616350183014378365591914476872973994387535340775597312116938335197799198302536366484233413120241733245497632321616383352306237480471980044328430167814612148594387675432974044483454010327154330979839843367859651728245346066184517406667614168537018925371468317129319890520384968953928556570709756781188920068817185182696093314904084422600427796799253369749567229750726032088707602838529408680550583739893155373030690426600849946670449072848909305096629744866771054139948137851869268759431661935872473665370888478150468220460289823905160305891515380349376377623895579945120432029114213545039553865039930947704619080875702444951570632759365956003436344233373499674187094852605734761998100426864497233839097681965821622434751712067443763648764235188757988271200494167496483767823585159896281771442991411093058625637186873531113371587736754097032333709392020259517252054421836311127913271659081494981747576758711239499814810222258013843815845631703224520257987338178912772305166221834843990743548040034968765623195159072203934008543773926519882131115622779278895669119497522883537105431720492000591017990343502719110394496667105627425215557501159354750130831662591781725372604993239740425773939126471512127636842555623848558770211377753575155450856087130428843814598199803570136794018668335290056647929121439620681799113618546043756703649848118447006173708221366126613725172417387030774000138043875389956753280355112815915882666990767931580777532695643425659399974097022754983946532570435500799823583908111650807571063779307598915113960911265940596480747769208598278504335718977868757232501188651361635862651910020105113852427790169076974419222056130801425686988606670703776656077316592759398742461594945770515256315317016982101194492835961676078892767117150764082783841444950616146890447305119645756011785959548878549007863344518537877270742780914540116238919546970836902758624787226126468690756539670818664712732273555589451374360780045108131687754236599401025716284910643342065358414433767722469712288233780237992945079025526107017417674278027533533655292726213692053124311361075385503948239451859752160142325290580183385487148938699978711087584292913031823005137066415621907447629040617727785648529003555367394624338676314289047447742977305751871097256087561900365881032598336408219715719327109646559240875981835220561149011725892891671784080978637059927260433681210684931732972568754010961207660636961074644982713384829457732664953535866522820642666202307611199020007901470082148207811082384984692566538750579755835207944937104683343539768633187386619086404272072234000371452706610541396760616459844075147189345290431647901783291668074996886616848730656924882452716369906891184234802716782739523271342960051189013897427114320077761042972260936879158847330452080224121744921423468554365239978885555727979866880025294533625816748758890328040416906318497422497905903070301758706546823646173698390681768478919282021077602038816902435741164644820997697816137237049944579563369111642615738597845188034688340885248862705005490258839299998421393866600867489413659776718059697191742469892327250755732559158832348713870195088111617739834416775523930892744654104768335974653058548096687026193074100571078136817681646379158661342521323918127154614971819663848576117863564420782667005656046363000910968961303874842209714876038160681295884419313655928644903184427594250891053819806519323885604177601024604721042899987190259922107322017545036184710229347735087264535928555237278212980142579240623321878817737343564672077694343865551413442530059194356659939890367199871991348960939633112594276542609769680544224523731909819442280381207247007465526677109005276053904472426717049046424003134783122774681661118188891177148841400129423697311222218419749098150494458128571983656253893080768228439298462009054555121843900951030891883123805469044102195470438678357226169440530182766563631406784315950409690612688691230134111050009464904208709092673199708464125956255633061532745347802830444702317832500099345099427063322888123809568911981826323643314811352956042976909239793876844309231005224632262511276325246254017136938514943057785230794838563490464540789417457960994312148572215114113444692443057833837729174179409325640258693370592972937012366560484605814389319255553332406126329906549923851350476735430191908577340621897227665287660807413170192505024963543304040337446460267794790682197648012591361286304254702939541463488415406726500939631746799527378234335905277493205407187772251377539709239332443395099837586328916472748457527996750990316949374739036159035043605395191697145175670302611001765458385193703154109588705078102931202443929875558447213629003825200213646958180255745308215626691113141355557525626529034082979297790420405612820378619513200443197639824170392732040787625369611083874885145163353892365651010904815324857580401657674751560096784199379192352084117274128937908526860452694111223422687117165344620990272179893728077239270081654662412323674326246994266983013183061122232301401768573552204688439085904249223780609917004752986111895641720064501402672417910419930183777958627696554760725228827166335539926674879439416889851637063695665825421215244269705968143078714193385970773666875673460570731707933857080990804173115028028062055596330791885849437808776800073643311321084823086301398211067844906351243410063521266631176018487455672228131515926662277525073611384644186249379105289531572672623994448602922010784575500191671910582377391104929577729374295947637413345497778788496254888636528723282705628535940941681500452199349532257979998785630831698911640541925642968987620898353996882736974689807417880590210127704744535311173499540749892627501689754547382752566876276822004051594309596148377752557647641992674987995848953095278102866763814824991389563832452435401244160927510873637902458913453195200558441867455693763222770717792633218323662572511549124313210458005794099900383301595327299795310384240338470705659387964960018103179238930538001329475181270305489424412129014580545975455525094006883254234150460845775798758892440170132165194502348082709979074464199758150087958087693712770809874184227978501037556272866330596561026935356534472509276270409934172630184146557546221946569502875898600782414588608594377260907181320659015080957166293150469401632596105695102150483243612623054860786166576062352005452190004115431266585041607095089885320779757759191238666117153259762338985931432964958886043701507668613971501937332905439233738570223038021350224712296419976069965778230443550941764997628223347745636971380282855652488426788878975546250239469373002476128652136359517839053765209834431531875408989680901198832420333990253590914163146649719981241931179506729897081760243749264682781410196135626207724693167774212147240416686631122984927343797120268057675167505496057071543471523296678539961768576206213751973613620657818771084258159273867148855880557090022508577292475786926574748196056212732281329447368700262206575620692323535992472410358221117070133316844374233653152389037703695671723641746904278621257525566819020858931565743236306107142210012354212819530254418673041669021018031436221112892209649222134313442355397131361805507756252272905998423670395656947214471242972480569588050776566423771154645692633972815423462520390919543406820856312114396640156919209634402841148526690304683134201759883824142955888267507668069255299224775437139815139410456237823051821557014732836707089677755609989860232129105330778350809306192041877940702406305029581069336412558457018190440683058217591137270464386404066008277942165809194993445012738112325304424111121444030528640829554078433293700726437888859746062400726336693185069610927998642401599048768128483019716872405172742366702333027235689529262225394430280389948716219976266660523362913521759724963758488348561063862344031260705381010426269814723953534762058096919042403454487728324190915109538606756997416423550092894166173335045268625659870980470914434163630084041548845738160399041740877665243238388098679321484363303613179051872770432355211034038352984233805697178957680419990935517493580707432780441230424632829229716105041261594083452244993017506583870024332476723942239942275630968576224669066665048909559644342959549925429103815747664276051837088059701997477107440425021981051740905844053995746925171844037841823522441611867345433208379741347009406659919379208878761799827677548449306681397552694707427117631406144007450882969740049818323455858551317207197201589704858224388374914095841726938767482243085025897244690463595978336569707778625455613570273121541638995145894561079999213500076101248781500642979091198044736325729107144579768273776743716439557581557253878204647391176582851167312182026188795156620056856503340092247479478684738621107994804323593105039052556442336528920420940313\"),\n        9000 to BigDecimal(\"81004900411473214809117930124696985502785578287456763863738549614802705741978967911966609252795843941843900783489675510469595872677865467594116406343202271243281226421694128908824366704211237598100902671665749074965298728616392325591598392731162894019516303958923378479810420740510745540487483985365193047527519970159182213231152376098436442989241647993054715596233891831132702440363337776039430658486057426656664931793576008898382061981921582950699137413703548679367466241983595857210493947497747554673661837338698909931696129609661175186999754349643197451579373505341161646034488596579669150533975235234996924262783758752901738245714371598992173973565975569521716401360225148671600806410767573280529391936853159687169014221956402800525129293601265566623670276103683101608598067421052258128462644777293542863183677792296074129048916885361208611838476887733040502044204353880237195854267156780687394088147522394094598899631326289312152405705718552789505112276623632427351727283918338344752442545138049934505797046347786673808272776666816736152519006221302553870431523388384025335054068083153405536276628836684237386546553003642957825361389647320501423500847581385553193287649713081202046893754832566834183439191691977002334846664890533217884111249149076840387188065402819591186661947781435935851781887818972721721687776867040867159298462389585489100288134875335601057846228882099069086934021347070660501674490268469244566067778935257249048405231650920779463628996133315651351220402851722870134247917566649381795900139718035696679699850640870668658185816256938756922384611002206743626616650002075151172939268091049172182604056811003823485341639022657585863527021334338022786598002020054482252208935741956110270714757456838883524531792460389929822793455115084830473090137847148266678379427319515407659297333910174731707535627442920478202959896121388242643184853916337727364145669878091460282928954204699273502244603925066759682962686861492310231141982443397433998260686271099057056853696873690780529872964882633871575123588640546914514315518237077078288409510110862442401866385306814553780890062873031790250295469306536188940287581771294806591957957115693655934749402670120465876806591782927118273198047422892542296481048884847990878949035569075513750594377987475373034719022622228198421361699451596319751364178740439344035119364905681939174151629670837371352924767624924994388177203821841726669231710554409160503284436471600315228281343416641431148231472954549198052688810245706273978046828111811139536938252189902075491259887622260686844307496423836621494816701139660949948812994487249401745175663879602751420538365843455132860050497420799583029816357832258795876651891070773415901735988173747603960896837311287155039253380393099887235269458968877735570114115601243858684102650850261703346826961082952264105179806738759430614293620998122470521028493877798404628724648622825823467172816253033355123549272818639130051425344896940358793893382929650699781160381770244800255941061263852566300835057538753440690050644368132803898444685574764683176332189478733009549234705830720061127332908336375057316476193321136639856296593289466419627009607037613512076208005213206979650259199288202930828693830818883207306247268033916735792405036540960049114935993492134220392650061696130263955567586941325816685246673285704685164314741880830935796405612339170845354553533177942003072417209647081580048928722801653261591923045805615972735952106358042737828126229596078797194632536575576133363091774275718235815290597572074305024240980598459422348358660161696493967306999164311223672588306255958446714835925587140586155595551467600588002139515372204270728815873295849000594752050203296493953486555721116137525664897677053923148289734333559026519860049224790373127907714786731179622023023879570954681255239703549636306417339772774290939498072447029498920339719004888448950848574606167710253044426974933825280864493962660987767509875845705195122381155496276942028271619665091777974968444460952672688089922511134618064682268965323488754591707289151913254014613426539612218956447610054439113596091595371262031296365867490990095973614945534134417949443169318132557083128336497356780701395816347995532993218061651647215397938462850937378699394918357030242533432103715858616763166268982266839946417302409335026972013767013848243613357489342244037975381733694856815107358199729336815861045351928441777270491953037900100261428660410805515942665295989857922519550299674738383376196705536450405314503644123289159231711943094111664557988731137403297733384697544022722931549047472416050527760026822335320554575492460829339943105318635680732265489632580775051376366569863680748632467243259171135496794108363453733464481837426965617825128365855412584066508023734704851257362823703344826919126063164746689587604997547833203322884861244638347338180930053943038519991438696050599359174145134856370371766256019528989737718782034462533527938486018833125521804366940927689984733811021632950139058865229425908730851512682941698662936030917271502010031719105477990192337994127699175956487883981716250003948744837144799007468019638240863804488722089327458236393312851443452584397264112461663437469418905137001572753018335389230775043462172753890157985073627782117441722227158348132089298453766849697061501309094694100471997172857333672087201149731172808249113394466914164349986367706608467541160766998418121506888540366745954962071345709914186795210262208219075858031394055708185043220472933108345289955196306622687916164888350444828732510090815279547231873147194895387410762153199343528018328071446142312792809727352791828642283928503105905933038254114864599968196348162641943552895176562119024417307906785536420759352397255531907411231858704836088223063939469761273677481077593558669133744699583953382237379178775312780707432485175960081738501115016976215876196616649867112600244035583972305507874162223915055505533582298836862099080674645288417232925736085774177331233047340452741536606568085716016373538953591379119983156813227810077848080918386539155092915971494628849377517680483242222645644546431935368447183881230132777773771321867688557694586043271899253120792728128530792108988529014209900192978514129757958930200504686404126259995414096208131629331135608247444686034938662030195969855942756959775378315582856235546922600510101597738188549328059186432215968672966179719261388386414164873546046503443984388578101937018488158322026205718991288718041933630147796449371178853238196442284678625363562607692090662792882305345340618035885956176981787564984301213430338802784239762128994599421009187036247131249011433749726057978481102656917101089123420695507510936500971394089716568704897073964616791545052222961139377523561316732321344908915651165393640674742413406773041489965861912066725432088932664141364430409713872864865055757429693371320953688705041746069608330717904223643441766013625292001240887541077466940973592714658612626604480282951815530289924061090236000219002088112029665604840051393512990824889049209114397555815189074669070706665840558334308219995156275950743515246654285116159716226515943708465712176031686525663333972638725442859897487494791773947220830134568897831010192854002737905080840390696737165635812537455922492851415729431554932497993560381646507894972124773130452246659491073937104555915643513069452914151090097934210796667778478137886628543577796357269891875221291778906189755318289403005198138047427301188309776300094270781651891059282775560494792415303491904547350238920122331256300640374539001897961975232076705022623114549444924324426820935285087508344076437944940725541087147341476535828126931235408915680883305048898778027187932658502473036883280025941473469160370297528598879959861297774122418659198933291428372058740789643016540820531405304210649958195756935844511354994481887279206599914903880903201722188826715319513371273662994265936195857086427110192496646197661793260944284367284669752036979919717869054538117374151422387860983227591192213011774757207062266060285652759676428122204284149116663654268332701858573210849373720331658881779046884777470523359769332703958443974401880188086290446825888639016546937762668789815547240894672234238798675437111200196416347412953968914123314312356109700481961200717833558056669449040747766073918613244787351142786581445923523112484145628408501938837893623236291779054818246469858615287173459019948795422278136374489818638199696859281702071479330982409143611632379101694901014513055289026743356293403959727002863869307403706543874632141082113276851171439860904570070469071582643985330839170254497583696840306758535904513331418097195982586356944101634623357465727382403063430595928673176570810904515724551277753617237788713419821738303587007883408855666241839871430715320842026162159316350295747062736965224941750287254113783873777532400726808469555300045299860759409474297721680349285513400048488738814369056257413274591017424536018298727131142335644401444678561976854030562431099409555781549587128683922171401122534964741420997582445644004655551056540263751211155211448492378846770749591294041869216140946660953222792069281468442582601252458131855271914532143846413665433460545626192170267388337267218471655370701861432626751538858253278500316640077466888447195882487503394556213498899802502479022104778843016509060289728314181198134311597815935143472350094616479771576127105465360765952406884274156345116493987112374518239312192239674074403727887359564942244603324045485207119174040139985801869255326946707039322460796765862784507939993651949843445561605691527327273215509211324956219627969088561622768430664510174019555051630371692543940235575632208755447085800848827276039469911720209320226990789483595397710894179921076364491713603695795801899947469533613081872515892258626544983595111377223809792257407330340372339031370622428208016286310608555789251676272357122850226014560814515702735610610439195062386253205718229085650103898829505002898316853752152014098225832283654188553726558285095456157018679426228057210660076259567323159379100111669394256184871753542873511515519457445218611120770292159357258784809590120630339845188285617672547392349824941205066236968894485076210982678145626778321062077034696245664121075250518901916922012600671962279997502873702835290929224866739977358539561830273040213204085457578011903502658018620144930756890159630717772463962073987969178364561389462117933597111800605407941999334331891910387154614142717608139422534006071161307190659471241636232716754217032312093449065836065678095674556256390983193117267408792345543851061171110175451538006454624379627071129795319180785989919471209703825457401393908486969667724611139370074526819061460390927112585183072337361075092377445317323512740908053782812217267438292895704374636663768233674095185650627387804744184926014691011496272572271048807735151245400642125685543285265121342580148449278890430347383048362035323785472312383830445160252416124986798257470230051656764129714387440301328201919301676435322235897254252189393425487733442692740071210803718083510591262712526069862007185576708234921794131926255593258159421331162063329501106994613374642440343549931431671603752453558285214767736618861316579664035439079944112197330760664551085487289700210186429206840997514516880186199201331410909241645803474599651964948013345595361892601406901069075620737188402842833788886543081318856938201078984226940431788750442855928699939175429680059067485018129619714560127019615312435014403779116490286347416806908770593505060881233376429686775401361643632277722988489336936341205157128820304149985033009489068240313083752490187398801884119566700251225115444214081327242708241594753244195726973021121983878380904738190255242892594680790934751644602441799550503372226715750446807356826864030076355715719830900915724016630695728937099615566053408588211461889684124438142187125885301495692670453558082044250947513451783423443382327292445859406971947529410386977608189393820596488967418258564988341694844531910583678675267250630907239563217583660584582442152896342804629348669113736160172902448630459612261832114029223149148943139647143777883569550016536451930857913100951792577996819877923212633639043519678131823386339094277201814560848764889065866196925852939714946294020171298177539213475866980629684417494177541885164846643738177964913206706640886923804785536926149556054099586968128333464515925542727284677890137270114633920185435821951891983110203399776362525675304207357074803991274489553796563007414200796579243465643568070061304375732016437869622163864808556435936556638704496876397942227179695687272620957566742723161467854739859364083653698141665230043379171407444350224494678146370852653316189671029090508390637643461883647725146345815922897049539082042393040813806480520699429688154013509106186316407874698281211634767990549560041079480444377905299102498916906047275086280205158233018096139599755848492257717710277368097126665617132084244722556665664528327984535616155004958294148788082972490300109080712348422962264330547761569021392151134998171228663872655566274956335718945866312159633960692854809931267503322831783757535376450898502648077499862655723926159779478518584672974992799809651556326474080130427976927099629200182510189382548877726847468018067198601231528255774734225890698650270525241121697331425086677528770192459200724389184470060860264683502456548045441962508495141882128707267578709315367845241152703403729170314066307451417516464654939697533569125963877560751844156417351025601910893233615148609789029266368719682316212951166880140564408640600203200826673272034156309096367379117965266797346057835314949981134135686587559893470729221968304435146615393956336149213489559507543974544164170917309462712572217825236077817311006704842275541834553418645745113487278707676374941252502582289490903140191500538102250376295126339754856686380739988497300152112813767884249651216775693194013420889001763374749063667033100802169227108027622360856753837080676873177699847759644166642842775791739535050766191032969582433489811156752091931554528579365823957230861177136845419268256708674920338370570691530163849004169097171454737842243619770326048740297352986489569641976825015434736167727745492853618951153090842458821497406025590174749136382765653928118692220118404128867555512789316934794009894852421235148785626161774411103948572733267296159108979465946413674339728919886209299843754900106642304876344265326567205375763749458076435956948101279709968221534423975095533139429212959807903324761135344901258073470271684308070432660048673343357173678170532744785398989970786720419421233486777743295350510614304247163752366553801638393080747363642880043224424164634133603909597825981651906741654782864212743308796664194414025035741068781181840542754151825832057350421868213298598244248556437551909365737996888793254778258818166958462404421826171425180575083485216885494239823983231567543797126431351736250182521380956820850691060771577689952933845749978757068844871286713304503886933262327657941459008794867994130542194614739811047374117562392605134279451916811385273064685594039027905608074096015526061740405001235782254644572077006117376895003052456113391598448659064903757435900905637007800003694379835099417915707820730442276691043087409032119320449579825757943918357811982907433048912382900953207173016877384828126855788616306641306978327908435794268485384294993940470153540333061253474374975184357941490931330998176649505128049016470494340964504477433088065171482424443642973887069188487183998609778044125169426990535731672368878892187199701658477923289292074296401338577401423321961329255470911291988318670552367893427274752362867095349681559494982949133699141373745441090037678468396045675438099655861326469156105219707875435327145941420689598643128568767261885221342883344009163548109560057658674981675146545776619905874918650424695084446202682053330963689374212040893438109733240695848741799855278416854484947183392726949981265236529521909133090705160345777459859814579250402153391448987015790236134382124370855651636987749699126129902022400687026457205774663349686265002447438210483444942088950661827772777372721687808339702891482592906268137165982583037898490274408344915715793998028218155453993541271914115563904727669767705037508563697502643032400745193641754483472197600968829216746982082620559842438177823276923181407487538323093564030724427424302586785819699636108141650827636625428421228008675877069380446108895289510711929553990191739690718775960551718240587461062999436896688481334809012793296234501250482650527146671590559778694650264518668237604360468545414039945344486053260131580008169734647946641683285180168148155741817055821157477704566428268557477330877618628437274779474592642323223374135677534761828291204113849649963836016204814142727003984357100496608316531323946620626762926605096317434643913256203522356629574805659020721281868073569038860842292213456724353035207306488540214161713623085556138108479771699379064196081692473184798828743301645982149783837388425787473164101043562066467584559611117821115593494833105039345254773576735775219422703462873479799624917636646045706539724457218192791515201975841282954927441745118522164289868298267546366267092595814828521200923989834210469690815104079483923207409257020464410972166715185588613523514166280970543681283899155907792449314891905116260915881572559462893759187542554798654585105913685620317426654095365335999503347308213075955809343597502203860290938988160694592047167661886351528472472797788877626102676593194039469012909773552151582907031564584371150830120459156311612950494542010147899058906506036258204517115074534209265942253344087532559804239135183289762417506432638147984617968035581524405178157828627069667187168774454367391911536871251944884403101915698012642235105098096635914859764622290283655774117732020001457887513091389370545357166620977631725228102061945921244450678162409176979983903167387133544031884512040812593614749830451980388952205925924416999798005145106438249770390282429339653819662443815664894762257169264442106229601776750270773195868493350533993918273392454009805309599119960417516711649523138177283679263124239234352994538412343255913129682397256923926277887163541967583657478719787874751140041623965400393628353983234917023392845796034735492984378052088179906001359531393372678524010899901962482484783743815865119238763584542073118315820741312698476085486029518224089861905764964879665695143898491930989131118820945990300481868631430772033890102403286079639581232093828149449014703509075901271674082432877268819763146705840625512066896297398018756764316157474409927692510140085279733203444224332317365131879107709381309372804857423828784131456173845420831325260339057192339558653505123510544321036100553787769606438736925030616256580351522158962950212937367583837839192937164989438889897190502170248627670020749529789697354038789672034452692687447799393277816543422414123750259287413991661825720611920024117976322048229027216927073479067972316271861709260281188624125149832148215719666315936536789571471717061229018193557761950393269764466442586551672226485525111987254427054914013927933851230761856564145626906864294719525016003445872282838513944415301619830002054448739935364100022833922327668363374802849500971702048198507108079469427118285174003522179314195006464104940933486405179858944921859121523244086553059419889001297219325394736775733310281831634780941422338022161129307461404253545510654017881531954627971372504686955840153431627248691042299494879001321944619827883190506112834259305410603572093057872469644435535069469933486199083488109185264357096409800456752965830561329179372614941111022207411166779940383526799085925279291033484071042283220555035043020731926506135770617800834363127660850248388787944049462933859096289147137376024795835628463470053366163610470362857508485346490242896723375258570319303954772987115742569932053227265585408920702134782480078684174942345602527306489376312802029856880796253906406373759014493307397948656580598948234553475106439524366937802133736361732521276742141789923295821524917216326436285959339884599123810444590840267071575034271471945752768881813444585962354533126347341376249561331288131285707321078158407631072534706244785628896326093325587845882934271950356471938829458270239479130827843975440282287227122494048867617452721100563293328032310683792453780083078397854562966863381317496426989132162691892363363513722493587978173187197119211019070936340484463100829128804629540594076035820322363671303100225924958749013789135969734180654588604002608828980143677171297274061269103881131452578574292677244844166941980074582481667175170342742571875600844727448606439191387927880832845752125571016381626807218690790649980069516119495716644342922980031326473508584153322565118823188425050890983536531189153958303485154944940968915463741638544319543158303382619483232183485025188037062592446435180281502572526372129772320616984922977679353997619626332463596354394669571325498287869226126313540928737559015617816718070434567290390638105125853653459353042053737101905219280053234112421678233752541776303043655775792617833896603844045031049391076954479189256343145357150503501475711523099993120453370695215708263425083039212502697213005471811089612253118767203243599323998846956461675286196320079139240790102962795645668679604070334440987388190519479218948460579883759619894340324737859295736551868297091160593056605295158343068009537406512339415189446077917972545894528295255704119734202974517723223527259734773588915975338086400292504973635764416967441755352125065812356119595391308048159385713740007801154560428981657969030373530494283520984063704910211357670601408696907035397234164231863271694681072305087971816016358632240176065839528322511289444097407493609133099017906157633756083787233937860090803960849536890503949458113831222339095881441761951490707405728404353478702330663068655687784246708742215144329168082721848217972574795492874103916874637765631632236169230565282312837299307760411684323607271154071762130042185128085723463359148067557913712406245239079302498530825728488880518733046182432280780614368834205495700518762291951579240503012276405564522277088512633056229494910561230337354082350550343824941974887154806729387922218876440198949946331239133553923012870018304005280844730296485582385641147244511707553735444563653947110700800889691106037594434643168141719883386390124601063325280214982597830700489196433473704073814869082932319962725257621511245657928129648891282200897854620225007902944153512569210226176243435670921604947350628396320119588484253297377095012724513467483742525354526737586707112322675055355642864429841748135339670123447445389670007670528099440048675027953919203414685709321583476806882146726240626524835756405485947295367039139701038013548604786237690304979110039370807015170343600852117748906496769710380186337027491709035475635162140110356398443205706008753577744754519051111680764989495457086939614695999475125108484192106227936761717444621320753309554805514722179539056875059039397125767039489493455621867394566036378712190395737099740262002122629556762671045122112110860295775985431207143376081902747162498452736906956211530017804748146311623687344056507570949608225826187637450111944679578992050425476692823251195470206044991589437401337656768403484308527956415458245404315358832501576962215883542484822185758739089797485290531639439829793953630216810270505393794754859773944718578492817097234775479487868967236334501899642471172964359858019310361203378488989820068306506535206915924829309081199901924892415891075734450650508043300379325664476238172283283314012351896490249958935320284213305571804518974008410344486114635302216555177781353279413522228173548303011167975722616048849860968481547915501510964855761849900950948545588645701620629537232133236103710169875142731752103217406213174025050357783305842649379907101967639285134136365169464951386029526472864565759096605578628499023395558957934415731400106796502198561547843404002924925842349949117749293296226385636317538034484968635581301120339656102629131568857602082854231722554195317510380900432596285736553053722598129156201153144105135888237508174344885198463684069630022105564034585245602659282750568620898067437906885243997286304388264489123152406761095659251684269853370047842133306281387591027144287436314327773745713839121354059885779161722888664278801357507703377900369471740282128043832372353928917314596373671091530363681306934132496946951733706433316792494337941706280843603334214500265731723127794812953869805307136270991936888436450976473473468466542113374700618122143784735106646134488821287486371874160649751236456668104724859036795141751774314492501229896732026715102442416355472150615620847911933362995300095118794362600887145318439761101766841461789884230207492225679893138718275134318984878858093362398141178682702032909979979435475622194120366667277313654248200124240663456772877864482164243202719941411941759835581669819049424062373692801775162227947417360755411383988637244057657752257207868778879042850583717545478859228900529631288340168450440668261884052814999183521685542014909495376454896887212933906206498103762534481869221392624122982705657395906579931088406911817707475101888524509452191660249881583569698073131859767951365975165590365096926804028716460612178203585919662287723675850748748493002911454549632627390377652212817246817422207606025853304061019681065828659305517188652843926164166362594721801278419937495336320596078839888414393286354847482756499944754925857225416215505146530950471801981812364516616632506531577474520079672460418784047392383175825129079472555432187529573824675897175714804920020896318765588217804830609090005382309025828553528813021517065324356843084187888784961368034676119207065150814265147194549162356544604610079396968972004662118609418975757089005412182220188324128266546842492713291863878093466933498401373242836518197305805558403563221036216257577280624415266089366525391407529343981234216911079286144884536999664318883771352811119221371119954331499504548481581583832939680410084616834803859420437639134254586740854960376043360720592609083602647299215168185553661290753335418330350848245740194712733039269999619718563764158560546253062085193470466538411732249646973840886619509062289707373734454695808644929617780374771455542912666796649858020140898231032779006271186863525935941717815081790972128765742007270351890747782216479076501949957291493952768963021286722792958467612381952081268731641142883233331037343231192519441765418715258929631078609554270956047873704194485071118752047255115365485834993591155749477311324412719244848673539796916882437896436252330669762631895260556992235927301104079470445276176312483884326560977330939837652451855085024600269541953775709379670675530361611072722709569891171022152779883770491435545253565844059081762594483007433919853845716025214943219869904727844927921889367019924160812261352395578417346036206308527124216741224950902714243791000242306120853116167538763869122767515159423449402696712425716687566333719254640295345501246099860770592667327454421596326405400017812536367169248151557335880597241965952728734392573774390595114268929951773741689391992877186466118456686299029019598970130252544866738969041528627147272452848510736042441932182881808109520630110467428386382346796010022198443586204905639767290370226777110992222750254009767198264161012028088395860478815421567298522989381957278239789567558718597894613869583129435443533427400154247797604978470027733706073098597084245122900301557456657315174182763319756691555133316165983383903560551299562185047482543251250494340409037688481138859688807148019733361883536440969522687444024883577429991214460663885470643791830518379747594032023535482305769831813299341935315873129586371039457965034898386944227584759251283478647513257756438684589012457571637100243523042229710057568202073329052463418194362374111108654906729146833251565056483497733594758023441682223993059706569974564735708938576675233788082880870183264014170417269020345290244560804864061218597616705295622200065843222412204246793533942600317123835095531458527129083332073036663600422183226690346068831875511605483715013101224827819288079753846929033069212345381766270273653833151888389796623870695362511596844131128318954178906498043798366457080381202101092713723908300836574169346569858066452062360890387567925513942050049340024394734153955090420095435988027699468953038275163042432672709453718517253478476455472234306906866259749011991812616564573614791193625297998696817587845717717233142668420974561267096204514422827219289046550736395091710937559603574032125267120398008028675440634857581056527849634748296540938869247039520454288233200665546630836549420009178522205547953282185676487264085202014023137915759955937490820991539604744870976445390318577252274850548401078820970520651498452543351389446746527889774809460318551046319619169491344513148346069813043079508201258224714507520421994636810096920909209689423095252681842631956682845715240074595997535889607799278279650829700352956252910625138467750739966815860069068824545330838541223013810022740609781454458699898387765283817991843323355110702663518929619241410598131297915201566143149109827905631565901731000047760325015921457049326073144484942676990112302382104492654383772103087965166218866426197034629243154616353430369553677608982576175708593145548055374988607042919911595336435067774047334413305892921181439278938584400804590824432845104776933324963300950330088216812085730104405076254492449480213483904528122259532987861491769276985009718104315383108996912102397784987103805602644046160723187101800899543712127480218164651776014766190293969010454606354236544020162568776844735881243557169913006393604606476359750660038147448683920053213300937812639012330227807348722638345421147255238535275392268057675167505496057071543471523296678539961768576206213751973613620657818771084258159273867148855880557090022508577292475786926574748196056212732281329447368700262206575620692323535992472410358221117070133316844374233653152389037703695671723641746904278621257525566819020858931565743236306107142210012354212819530254418673041669021018031436221112892209649222134313442355397131361805507756252272905998423670395656947214471242972480569588050776566423771154645692633972815423462520390919543406820856312114396640156919209634402841148526690304683134201759883824142955888267507668069255299224775437139815139410456237823051821557014732836707089677755609989860232129105330778350809306192041877940702406305029581069336412558457018190440683058217591137270464386404066008277942165809194993445012738112325304424111121444030528640829554078433293700726437888859746062400726336693185069610927998642401599048768128483019716872405172742366702333027235689529262225394430280389948716219976266660523362913521759724963758488348561063862344031260705381010426269814723953534762058096919042403454487728324190915109538606756997416423550092894166173335045268625659870980470914434163630084041548845738160399041740877665243238388098679321484363303613179051872770432355211034038352984233805697178957680419990935517493580707432780441230424632829229716105041261594083452244993017506583870024332476723942239942275630968576224669066665048909559644342959549925429103815747664276051837088059701997477107440425021981051740905844053995746925171844037841823522441611867345433208379741347009406659919379208878761799827677548449306681397552694707427117631406144007450882969740049818323455858551317207197201589704858224388374914095841726938767482243085025897244690463595978336569707778625455613570273121541638995145894561079999213500076101248781500642979091198044736325729107144579768273776743716439557581557253878204647391176582851167312182026188795156620056856503340092247479478684738621107994804323593105039052556442336528920420940313\"),\n        10000 to BigDecimal(\"28465443353534369764476106255152961520927625493666979202091812010936804048872466638105236491200497503739571511752297705361822491427902208303362967259997925656288176261485606392568993681286290925045037836096461452663590066569338459563501637222172253399293861105443963056663968543237162723343938045446453947685305210883449758703910801128061568817394100083541925806478890269012875851973219390228428943227934755680152122099830248391230753707627624271334026830322231381966077071525378467482574846642350015735055787854922616288059009611411689224674499846641152525905205141156738531555537091691468799039138474333606325169664654244405351534126826708494385541954572466204817250459502439324877983841661548975815813020374526592227222275955503203193564095094660980542789443469709727174582789235391042086068797987824061546443764056674357781089047194453016500867011575696984557894801030099850262663191073202599800499086996872267481455447009611993618397380861012335306887864642563284006250084235746858515558291901128657692334055761422417460019119372121050267234723818462344109826195771506285096593775331558030182156166094364559207018381625479807648791294604506612075550336986602008375277195339638620691444684000729013986809735656852612047761847580404102638465265948343770507320529297350961589670800908914016017184890135669516522048459039767949393338041168551885652224776525380696274323071877513407684481195880355140016779107096515932593405335120056334764744964154950524478751102340314945709151484231590173406644204523192940081022821102477142003707295912253758538929478716714219328965193422511088605804297903340160294506947378159322078358083350488969688257924021948544945155462267632328691459140972434660141931508757520175056102368899226375717543679137724631096963006743994318605153275442804819110518392202753418982079284686710932145656178158721490250957374312804801230615995630886128360811434378875728514128328958542868445897519010467873944335495424522321753542488953551989897870602169191727261118591876612778952952688104547476743524850497602941817383012306222431016265289304957826268042707527604512188115997991486568938290040875611876980068925301732736066984927747351808924919932380577799052776308974579127185073365980931171244118697122913448646319394213036963421789850089707516472833236238844265074547491390427637455375265097617111656328013889650544065880904161173006176615032084555804074550896242614035858945593916991738193134745366863998175771231088874329406995344585754311260708429046798544965526761489727692708882808085213374247881712975784399428812415575961567460542600680649879160675291351787343612858052820462463944620188441294146836236468427493709547906118259048192664502139944906026123136240915609443361167448239256802954311294755398383946897961998996509714920291066925000950140086752683062420302916298790115203010923151081199914151883304495525953513547777312143321269265289657975130970715923539207286172783432479805508233015758299740137082170035806196649905412895960065923437196798332416836184031486485716436470657791974558185638297328792979206607977082751599970261747072986638933178696125333093548442073967233339310683352599120668881354110646236743308651931246126063267362743230701072492368024309824669442474738516722967542663525989252039613562587434274720982835052760044787937901797610193417095510612989166274492360065788214609161028950235897944128948752537250210403846875710211278949181577579726114585175557229621410330203539636692262980457625270144493641245429749504178793661350480651054860106794066798840542587462516369956540081483072711083360736718213690444958866217083733938564205065512715550029473007726401674659337422310504194196854834066424729486017905598411906117896759531767449874389420861977856465479690196905923519916734447381145549088928989510588438019120041342653909960645179039628489088375742947045679880965365968457123680825772431302944245341974275026566562693244351996707354101586460256197239037179346863338695330674229557546050301422617743544776657713627213771247932240932248139289534641095396563126860442958107799649796474701014706843920398398803609430255947807944780882403452361294029880716618081872352980686277655908423956446978669618790795281942278083408349420032618971641991391815527725615810268687280975716440965006894821584504459794454212753029583005308819265298053192650201700506547905272928821038207352204330769806963155873267590070277448878105239040857682908953789082745447973679221543503009657115488501942331775403979311424719552695942472531003962049932749738273029399330996668505182813499700972988366985810564112496693669953309437391559938644056161852055735598822984145473157431981915654153844684008099338356320949108530225402265312967576646431332273646641904167529294380198405255835679819691917809699019414353324827337566642125313028630557698513227488803184955799348829689066138726781326060068873147690568533946132476042118735067865154431715020678294309315656158202891074160296163456310109697927284964472939237866946567921408496826315037389888766499032372205862885080274189791742020825724230981816539336010793797948038736685416687789847286055804006654187516535233027956702146084357407482358235649580373952179264079813424911707748205601617955713585395421826870463633347620623901981394767424304546271944894705390321569093950587163659380185051577207823689172621351306263167145576438276422217571348377305562581354538103248794328095950869955992307507531071801673712252178459911906013076994525579603144277424215888833713134477234077126416677602785831453446004511917365413200415735775962745714322933198295272213596189113562887213960523896803426683110563616719545192250060532936735007461714640733970903005667700338166462991380197606022710025708235692043864669282991447272886912878429996043446413113172393230561958520736502797304758033076585688026030913742153164728417617603016527252310872579118711837246208875025737525541769138525378718674612070295627796256604008185031091541766681401997849283580927706999107904193240688881954971200269533274434837754772661238672402214741283889127862303298607911959936424933244063098819834574164397940062727489469167744335621136487885542313491160237283208195964468065315078518143945238203088405496584366071977749295845601524772981038711410640278416876528068521503337649664675754516926378794383551570474085829356346194914472100577891272946819807234502622109413620223630209656926496447475675358345515706326709039946440519747227447991902273023808642790917659220762464415221066349276107805029403915267509249083657015462399042606986290369457067702739317538845427695761537680317565743143286289069374240496527276008532718170063124665581901073516786378426481157895740996632617011444978590403469151155318721822387615520905364186781690371801147940799291718955014138997899890358609249759704296474570033478478778671469087787811150806243499978376400480900470777916171471238942622272487963832368023968299832043865798599458402762800512478175162394541197706101260115979533699618145182664831038219685190593836106369894857716692219406188831309885738106789120679921323135270414838885884924451352301748966564486725577013751624320250051568134052064605292786635380211599432189745074664199511328332134854704896241976069563147253215762349319386669943924734950573871649461684859819109401847134811985158614729898282113719944047373464405883928794298582163168991172260143408837746108520920058884939977386295727223932290165919132160006334560394634723229199650377694460185611168856186899214787375085893303053026797220243189272525860465237631967589441555920068984660036650787724124028551996724039270772325056445530710197594810105946477504881951317262553867752013403833824768757473244174208165781986914029379497788180950546617152574236648992057924910406440634322539906434824770084306477568793063060545525599131301469484478856574763585238055183083762192975100622950090814820267375423500361510930684522106361625033228346570988865118386697262906547424168617178767904578483976573794989082714544789396344034614436810086393645353015694057717600316291491271826830976284296858847467959453568300701855444809653294069615509743334797494928952792822054342903492912375001403347143100818643770467653736019881922473438253206598060063696442374836119822817411682699633451427310853623878645847935188656269092867911153747778185678703086594779461793620802553159970769021581287017621055561752791660003010241219695238890756893006927956143967006897169463854003477666057556215722018112488739659051743506242286337640903717286716515060880320726845971250306903010462406952111480920862715305591960282974507165329575332860297922976512264668870329175832355598493648635399456767309674407791650524161223714396049553961128912856153135184885090054976616588917099811471197629100609846081215107143604509608167553454258480848140616219398747902404829665220680572115175480928365034549137705321981102592566821105318467112681907595350480790986981224408212968868558368836365074814630955324528826200397695421773566224776953375355844944289538452391212545900123801076530908763413420918291245410234382414586925817807956692752838697673074293503013112913640303589540155083654195465683953313489682318867788421116846294385199293979179493187438061014045580455055122753143988462292162741822677055469698816359316867102110850872967426228152337184999827468364945079716249854571593289906148106225688142021802340095525896055247177408856787501313375771563868134564951743201932030677511774111932304409711302146087786234034466358167969733672159322265043082165762246606871936637826338658202811256287290122207019206334390388433534390681424100914794450708551827538301426108513179520703402498314319886604535068349670705573714056139820627850041693614392283466616512200168456399336918801478799059713456550274286785484455420167594592455414924021151215069365334575105968366739902073589046774462534855296039753216440761905708781363759884660456360716946445781295432145221264947969305606540132998514293736080521657427416672727962674872398725744966742654081377715881480295816155389395569430250359680897637619132434273168830828631935389941110271719568727894424407591989724419374870438823985265180393066234250046078700007586775627668887161898079214713799729344101467780819652742973671718643439091233765478280673340535791372268654848388392970413173816542671856976912353168930160010975084762194197773746601663389634197057181175974414995042631257020153870290701045626676023127820313906988535466950334057425636029736028546877957032676606815182495640119032256961543534924904158562391399097469427712271411670335013161959942941591465861035238791186187298488900853390620621653987600391490533081119983621276146761478133206965504931755165970390988013607032624784835712056417477591105933218900591824446677854946545247786892792546099738234504739558552449249964947181395716689682246349411353485209701439565933287943337111479675718664975263711347776303744186181749989772479128208588409117166065702121166340101776955809885690083233365537525569916066872266584171812845007341142067079399293913155092739273805156437780689781750944620855456044616110165767794718303663944620379079976771837543290706700075737799083843561947977691532544703326189741346323577120429910617016586285971472180577857982957559226202591321753038210470618440939460118866796334680736642852695740024293888794878454098360186435804442966555846543110215603372688759958112812379833392406803211884149855613239038576888406044304878732427699592996067424878966468155080859078677661086968115715074674071665470961662368115288062232452520415065774650692566265162741576670668969057883918691051182826411092312091550162490519741287200365739903356328383350770266192535084094311624263551879601244393197082181850641607240126754184046660344832914075672655678345351931483100774816046676079496831032194272742427077277136386437265318954846681210780463170818914049968169608052886398958286413361462429027267555460059292816102080744338659929783290309909079519862697738100982549226152664967002865375711100000273828848615365826092101865669962108524832498661919530957999269599996191058770647663677715750014947634514254604940291525046672018954210887551770747369886636976256323391100626604924286077963022951678403809878532145294116003803085594209859322325794432949590248215705005331815920261398648571923736324469725785630227944771444164547842466330202046409988983980592159266363856031216337067070590934529986379682562738506245053037887366752793115413718771251329450705419147959005802875094356643665522828690918053831019286361592571523504579304303747858717590316234504975583573052566487819463443152045108336260444388171409425299210792910080872059877988689182265433519123672335789704758261261126905975663276948279667193045833200168127715987654568821053617865076777088763752235639172966877669926433461140103056179061757797099718633067656295453877291072064967133167481444167865802874268937500246311865226663672833605844410156292796209545176542670623387438635718004871107133403129787785016408810285253798028016315039958559503543930637240812509426537193960968062065880559548075036549865094425511726468542727842567480196935318511768370052842623761409001971274094244907827748513083589940339132037204342405411775220640215096810795553264294834239380068926030867609246031295139304486049308169706227378775221349918779561652202413256695107265909932570328430310649119597355225153215173690518961748764819152583886776919264307630694431399934354480534518242741735847127868182201750368945767758304192506424986528739132429916700711742822725971623644150992197587613738446228302388539842233846688354766739569848944962753661339309711375208954345143521695961317786507813105682719804289781993862560889471909069095660479325082717649280521109929403637656292628165761294047417687834645569578341258071774124067348835531794455944528247862718889489636323682110290078369087369425896936614444345819332585208267757046466604364614247296951449787805811642190477852892306357961876499242362214768067815858397197763240246479121951234054958254474427848839795332758603730647359306808166033697669911157371633397658546328809294237937657746154879801652148475789754873032456054382019029988212969281439944224539332313148971900968880916663898225868306775670337288983075949690824869711180508452201067816157471395706203233769901996590539957889020506645450296265654194844806570868727694501651026512607936780856666196027238170517481983804370079344146071630991859894912947263514725947309893012326938493165295920732387611798057294839343515838909016963248688275222245464551805237920761254233165404106529634254287901073282384971102516703805358434608512469599206630106982835098251369439047917867399078400891309596926979348020577664150465411783729655303953909350914553338450172384895876136771747630439535235410721967689675036693389162062667444389056310892943410021046636136773080321952172709384142767327941102976524089852784433323542092068106035826444895494563721672718898029460617430236741094506121851395077320606787036209144537284682117766200825281924328028256555290371215681390262133800447323458109649549259336090797335684303949156078372238330481504567306138435924646332080355371097780079038057606725277660815122745631942948557936556379253449669655841435140166793017357736664922164592797360548988732908395183306504367445578560333045577532968793222704122245838691085035646981599593840685166533487436111588147370007432687034373060185489603258841637376819785839714917543632745433747981297478989081041414809724807866249269653904145212737860460245305267760961106002159813407154827346134820065071061429912552008151833251810870733919349031875346346098423813947164781961556594722608916711646987432092998442085340878359177059775061620659053581047214037719381958487393155514849617637298418396346783657574871093894050921083997012126353260836721672612643818386634939757959790602063071551637391613466180335903076678160179182007309133111713096555349283031523847851316187103661709001340681075771990333225755066998527709976761715136115185168436554131236304084865912799372150351962297797445447759772205288247682204844543048025744407280809729035599901076976972137892230287912928113130803597436069932563516020408791037989695749594491491479316848564732741089495451375594799026034334998415716604074188065248157477115405010699069979961337633190996780722925948217053635806473824179347668323336798188491149036178856142198664782074553537986253743845533928841269793372314375875697614497884718556794906030314954975311701718126331913371450506254113162580496686856205471456282550264805775994855519526842187363131766519045206820325775225312129654516685087002650884914137651085657505338496970050517355470996568636556993381352715808005176281596318229135160174084718551868497200315351557141328993502894246228628556350832405166759812617494305493988855327776340680535009952352981580369145225883849443858482215654996054916211759240542143901557252988672808568754701944784860183966519757557194357555262261437947908516326512172888968827358208401879216787283011918135013130209207338655459956462849011046461082173813113907748939517644375154574921925586898724090165524051847701252541561645219841911130995109661714197099561424671454816084299303864081263396421157238521118704376229832720297091174921293643470704103565443921295685727928685064406825269994068316077735277844965324527785856974954246212613404704672312879301744882046831952201814195232681015036226247962800790934907689903134100094869571149152255849991825510220413606287264231638153134503312364352044440050047180379613006397749762852767713205532169749553599911428650400587846409424207594023723885125308217518786252699035513516455809107780089618679807330669749963792149622856942018148789474001787915756176053149330862633167872926584161274371207417129904498278649008942233550362008840267181364723840732142270416395594617709668663344088579138995010449596447520550577762045082961860534083245627490108381166761824281542963472817014203450427430980909646115615253721360729443637142017179500167440175999406028217888173897107978125487553008177758310134166108386404966453635785464341286680812861236798099027355440968700117814447827459977510704470569610434193735962974474383655414645017397445901809470821658548457334798663278002029996444654647066901320206316498867425327486877217605679587380238240989279327922245354120677199071397544722645474517503430913746002622103051622345879029553500708435311154738562379836681082759196365121922601398999327464491544038249742074747695716197922127249945153016499165261537948796292219481273715547661948485529063212843017546270307947393140619382078388323001574017003512151020405409928576143928806705087659167881003692441922134430936826820397311855613611255980256958302556680427411802172297002852803639624048133607568805581092093767329169386597574156307770125306908337475522462967485001392330069423613732291674808056152718105925146338821389079901522536855059744105432374098873037889102320836823977917183798627148336699485708098528119069448532041141304638380702192888806158884965271595493751006666843159707427059280090882912099045298447817850352293752058053034665809377396343498022203512566479676862898317325596343836543087721582272645438493851868768641292103173746975923206549625601114732239206692809435334003202685028245160504167741427435940924588123191273582340840399011763530761255717665450626103665565713113102501020526344801550829011041235882041996447710092607347718902447167741127578721827958229691330220976595174734549397615853140888419929698907446586389463070254080748298463771710963068189892436108722863402238463185536067836097151834331538800119525127025599688116406686212893172778851324103626124395699736806083825571266772110090105544903098408070890424357130032447848812793821656037748111595374285453163227551243706775160634714520191021057515940132603097093423238535974293550597631752772090156917221396506414213426458221370248139701062033937576053371532293120532291481634619490078830605464708936822462394597298665507347035571792270759860134345777878000848986463098711972762813659549995853377778195624690992028937203653721251677499600747823291336268193728666716812030178618428857057177781767670900614327746712942978670456615503565654348568100159779833091952653303729747918287153778486299701896898657816496110582404009088963715822052143822100469991055138178958038759864000215743943328687182347936261822404581844287467811059894146746566228975114410963717737195255673822059266142621580838339571096174758882410894349575576771112238245990899618266458709999192723522225424388853458505444761071899088495030720064192592329332871260947961248462338755580538473094353310092456450805939990324824651208158397012894756561602214908749314161169745391991617631192406827889146712229995462276032781145873052935872307683009018580874794189781330004188281566921380587968918229717659199530976905051219792603630935611439581619023273856529714394852024643028748706082085715956339200174773356030131988461511109515780228643542969815173077775431997064985428369782969447200017350720752835163946136616906981513767611406980232696961989340739593353320481177031415951726866085257328715444971825519304415836320472586128621664427426012614606326747815678208155810556486831633014292110462696855524811841695013563346829888054565981851998909096643997634994822837115181377302030213655793174758722101842580899371402894719516593291513088619145587068868796879890794899557811905186313171717771437652311409901435037457599442000065068266667370990015111112288862544942945640593860155569170232936514985080877876520426372027374172658750172349520369845171089093263679209859760568867798579813083401318866025043596918631378086535456360773810791852491948974083918059571794757058651931195493797712300886382175559408109432316070689475785688680779227949073820275022465747033258615815987202170866049206375684322091923381589128837759772252843324945825629925956522588084690321613007330711168811671159298867833629047625506666623842021669045820314451396159565185703596947549774150740319540542395796254848540938297863234636438761531362721082679290456477639255149702967769160252720511948813787162433889554052099844358827459533291607688753734313743551094614944971569617242865958062358412949456992794831825445228244226120751518801072645532868867871657953151557772938490210196263322297836596134886279333217521233176540836974902305430972769526194809049397966526817284983344129384259904545250624898607559456444424993496115267832576217167291036489453484670949636130833710874216981265676185117596199801117169223107510872421240374254610547328531726867307346088617466728051078619026395877912293241774428744581118671673387399318438358884452761341283559046552945041277144173559942634549585428845908801076483360425847240440591712211233185553305250219092849142309502779866135200623340872524095249484878654173633855899796766880962829438544247302763619776009790524285446128420656678050131040684291389415195224853795837347101346544145538681885222634048201108751617883226702679463491998496145168575534133259027619723787033420536879712115965546108387189527040478849612186468296943220241677296027948575808758735996948004615965490297422389774295320375416309566719366074092588250320283099461123243443465476310103301344663410389063219432464520475721700918254959356830935434441094812287987697646205144474198184591926796345710237280764301453608639751001104549366365657055656050195549487890746862322018098834208585672604815705810827454011751776682307917634710857805761170275331245317008004988372134409019025139505679909810768423288138857391885158684161938701155436042523312090672522446718699756259974265589355922476051742939357769926962649839264250343913869257645891336717775632133440913398911261265686541672279071432052961922121876972457171737815480031958976324778899440333500332764827024733183840125383429620317040077828354157830037774560370550448024445199281510375101387634074763196719562902901735578586546706306352367283782822961196138059288002078724674736690784833552793622899765145441723706267473439342237538569584646236194659609219607400319978017586398687188831949732277711103849820458316838869768425872071412654259696788116559192765355322352936185704172997702726025372171954932840057202674447210902516735311834397914535362238505177591992772853069734057660960822464188657905993416950217484894816933525364771221437969553055673236505507571424931673458572001455520457677061284856206038307496431627999814309982111653786892623265133260993471496091745768152828010191597051282553558071647893731265846406541167803443528628680922598283214672577884905998974265592730423891048460628277410622864927404561970330185799113497691186930590198820295089844086150294017425116310421493769532059416672764045210456465473779507064239668723936172202033923167703407990048696747141607426195978854323530795994898723905424657687255290404152030971207880464573043494224566142418883093137101266851257347305519970317746528013305553329078469009517849585742482563807810902223500329947173806975569468704606742940333675803766781236358861148221182311336471979608135922690891977578314197384084089598011037152568807431805242708725850423285098858486855822000662697972158505133866409777126604924517157675698911282152910439001355956258111261133707560531094739979415720549720129833823751830961694833692010191328165246703589892798895446440584794321962602534135963587910121515124321845211860043237510984106531918779598601057437281045934682626441512376812452774199933919836850721381119944891259056513524823144181054896793343664098667681965292972169452293476215865364636892994865504410446395316980841705716301047454133127456358898354752036635276255302901891329682733936645860066833655370750876728727244794309679376595232064790840857562611583524475233455484712342770922864276222616122208803018050327555375517075474444956174833839043993045368145141034637141609038807893039132917128373401089557131822678273435162961367150039404001364222108542016101560614560830447947553045352283017877014000634361288629693937000420896614779935522320286409098718580709352544416230140492336724656383198353585398762296951090428284320419307937782495827812371716468849498804083244900519336841580449720553884122690096376470043229711423941768893180553139449673682508138053422454312218177513511234606122689461016864516699733300876663816513555533068956273559825655990291747064004923985827043783288640674219867545059177127460370016348951294299219948594368026447123273876288629799993005023671634860510864215300484537604523562210375063808339301924989630062584276602779443586165699897542856631193370269329112788230296844533172233289975524960912876213946482301499789151702719486110896622024765342295707181282483006745378936161780563352460284308022268359895140813117966710434043679778669743210221014570649574419313401182492310226766097377882438133614912024911523700787931419324593785488880012008829741325281840125433374119861308532017302334916801370217228073012948394231475371481609219001181570415767267777106555115613622639708255589164894026870626151292560784405198606918785090406074544441231427082378228488477737347888896020659565832880468371123966185535862523184348234885073551891869737019851404367968476479480323237050800380385868382980951520736452446291357394876345677075273444525542376500990779084706269923577683624717587519745996879973410388261052042792715403341316272378866767177071852419819918536987452921081007071132999339544538880878223121499382546278183910592270954535762673924842407606654112770673431146954393535578238270709967862316518540850108974092224974933735669360670475124345951265628871546592728234766390458856945333354722380178046854956276005218108400460276239165533398651179619411142618791334803935700935476899220849280221179791574115756830498886289275085872650767165703432737320323660770711579718152038451408714635137000687194652007565714260569031612202672552834339571691985762799639641707380206757527410233250994557978059449190182342990526022072049441424762314711241275513073438887200446804382058486129235081560046642926094564836126975436068129397249668754922580826040898882558706364076314880031622822796493461406492854892364304815026861759041068004331030037243990821319633036453671436004677279213981331633045489974775756803398659364470521162122899847811476399578387262741451954128573797200819722766293649404224746796180093065162995182376970466822331031096949745377146035914524746534523529999115443271617312924034533479656454723076848587410903968137569495815602658821919229228580687703755562785048795381462083114688748553586379088671966243961810974385469339116487412060306077978216383352308205260826107899486508183360544216186232795131560124566918151728967379370461392384146243293500396919885354198567312527020064968358153780188828919920103981353707327073661567591530710574439299262351572777430593432011771750707489660185262448719719628564635747106671364731883014558447676498189435442218073775183755956037480423523615974201124490094674912896828996407408669010230147862849007984414052878648903849521629598970987913896738383027084271150049099491842143910556727991768942932404749318759473913739310004514861840032859132761313950962499207288811713119504993652925682385075074255831661821788443453137592638956862743297904665729962287975694672483780044670190765829553921996919139814414078972233604795862845756549499916891051475685239437157940697690767103491403688767592023461081507005575735435204698636103883441980396332595811218412518569788822073311942216539885561479772145664159727092211138725404024649122515527998318437276790662320258795958445440618710297112524912826346670019738853452001084082679830821519419637885080800428470279005885590490145740248525878071802730072552780559357271882081518924231053497833822950363840637542293467155763997987189783260079474858467446674953041368715705082137000010892692685052141203547338480865424294852909014182471618282968510977125724645657264653612301929103588576206234773292659020931828747984408098471752023606803458168845558185778291295547147259942385794011015099495804937242315711768821542457605967554964750801746929341622304967241948643680680223095359277812249085075163053990927923184516298662307591207695118181760551867518429644704179172021823995771674158585911105451491440814172194895404250112737784728839367742475439272752622987206399074979162853888124581717686947695002817283256399894230801143091335695979885288682959532504881017825991215565205024525000710708295197595489376032533549274359978364890898555511101558200664531001946063173772574827321498900021317293391311722431970619334725644614614973206135713455074798921805731311491990136003710057006409424583947403814389573388562666710606969347049977187508474196308651514933914693587050349374843221776820024753605862298273389583073367046154053427894652480500285780475722667957080177002183547762211419902483994270974091313507290563579476038705819093158550838361507568727954400391887794584395073752486470562452074674698561306759058673028209130873026415165100669211637229920597774795928298566876139139133727501101334221270535743300686544972927574689371047835072509710481636505492311640317674265627976649865496901275465190984590103218036316022678861063152922183076633471682495598880843979062240780322741240472082473649145407280887441208511659920171935994839956384641380697681360672241689148810010325862817035309664015813642187100831255533790496087142979973373595897554354833667399299441908648838617293606892251570144352293454169387673984748119416762363986730866249722324961841236051997840262980646433246591508491793801445722976245488938109493616129077549824319978982723851256271773115373831667939192539542948519659662078157741830703028375088079573624985841897918159679107351768561817311226986999393763742224534310230292769394152158123881774298969492294738619568041624964875336112018399000916229943405704350451715531949545716294523936031239818153548362927494388024837632263996553380184206206891543135947231535406607623962562370051588662206671752299866797087169181940756479870916596832587857212212429318269053351217185771558905785673823908873231093537894766156824683254445274483360498478269585297733262526897195314483069891815019097892532436793881863620362311114081648536188064282770656830688696700249204621836676602653383569547430154850270249722865341227610983087878443661144082608265902512276410028904531340039450432154383360866536131551779223254336308162762425728995403903292351050569075595422687012278798571705749901437317075835352035932097172093624844836141269040785865683746749604884681208740720810916949633617575952182487450516101900770250864524740969680045404235680288882077844056945123232295770266798098040281600703671933556574110064407760561117457274953184503060107860009015356081751665069422976589392686725959866901768759150685776462414679574267703786647376114459838059747219627227255690876055014544092376792606083712086970545677133979949360687251906414051682111684805481880053015513980256763513126687429742883695163583825976529364457879587915446977010058892019218582101007599383912474308531695727755871979735069223667194564540125391184755718298129912641695241648378473835746102171846909396526371255672662134591742893900869277023489075831952741631276094422443222867267356958334091273030463432794668244229563547925589860703847836517093864420362768060980409122798657869515484254388615053361820819286168967211244716618488433843283834280383765490742872121976388775375432616106010897676520254299048402474012064899741241209337033391796343508449396795193995933812644833847996828454381661870398572667146023492561497079264979875554548449626513562106751715222246333991806550756849597694267646468284582362694818512169923548577382148083872457596546235211809351387283488753782434611638471991442102986142060795383108996912102397784987103805602644046160723187101800899543712127480218164651776014766190293969010454606354236544020162568776844735881243557169913006393604606476359750660038147448683920053213300937812639012330227807348722638345421147255238535275392268057675167505496057071543471523296678539961768576206213751973613620657818771084258159273867148855880557090022508577292475786926574748196056212732281329447368700262206575620692323535992472410358221117070133316844374233653152389037703695671723641746904278621257525566819020858931565743236306107142210012354212819530254418673041669021018031436221112892209649222134313442355397131361805507756252272905998423670395656947214471242972480569588050776566423771154645692633972815423462520390919543406820856312114396640156919209634402841148526690304683134201759883824142955888267507668069255299224775437139815139410456237823051821557014732836707089677755609989860232129105330778350809306192041877940702406305029581069336412558457018190440683058217591137270464386404066008277942165809194993445012738112325304424111121444030528640829554078433293700726437888859746062400726336693185069610927998642401599048768128483019716872405172742366702333027235689529262225394430280389948716219976266660523362913521759724963758488348561063862344031260705381010426269814723953534762058096919042403454487728324190915109538606756997416423550092894166173335045268625659870980470914434163630084041548845738160399041740877665243238388098679321484363303613179051872770432355211034038352984233805697178957680419990935517493580707432780441230424632829229716105041261594083452244993017506583870024332476723942239942275630968576224669066665048909559644342959549925429103815747664276051837088059701997477107440425021981051740905844053995746925171844037841823522441611867345433208379741347009406659919379208878761799827677548449306681397552694707427117631406144007450882969740049818323455858551317207197201589704858224388374914095841726938767482243085025897244690463595978336569707778625455613570273121541638995145894561079999213500076101248781500642979091198044736325729107144579768273776743716439557581557253878204647391176582851167312182026188795156620056856503340092247479478684738621107994804323593105039052556442336528920420940313\")\n    )\n\n    \/**\n     * Factorial via recursion with memoization\n     *\/\n    fun factorial(\n        n: Int\n    ): BigDecimal = if (map.containsKey(n)) map[n]!! else {\n        println(\"Factorial called with $n\")\n        val fact = if (map.containsKey(n - 1)) {\n            map[n - 1]!!\n        } else {\n            factorial(n - 1)\n        }\n\n        val factorial = BigDecimal.valueOf(n.toLong()).multiply(fact)\n        map[n] = factorial\n\n        factorial\n    }\n\n    \/**\n     * Factorial Sum via recursion with memoization\n     *\/\n    fun factorialSum(\n        n: Int\n    ): BigDecimal = if (factorialSumMap.containsKey(n)) factorialSumMap[n]!! else {\n        println(\"Factorial Sum called with $n\")\n        val factSum = factorial(n) + factorialSum(n - 1)\n        factorialSumMap[n] = factSum\n        factSum\n    }\n\n    fun going(n: Int): Double = factorialSum(n).divide(factorial(n), 6, RoundingMode.FLOOR).toDouble()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206242,"user_id":null,"body":"package solution\n\nimport java.math.BigInteger\nimport java.math.RoundingMode\n\nobject Suite {\n\n    fun going(n: Int): Double {\n        var f = BigInteger.ONE\n        var s = BigInteger.ZERO\n        for (i in 1..n) {\n            f *= BigInteger(i.toString())\n            s += f\n        }\n        return (s.toBigDecimal(6).divide(f.toBigDecimal(6), 6, RoundingMode.FLOOR)).toDouble()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206243,"user_id":null,"body":"package solution\n\nobject Suite {\n\n    fun going(n: Int): Double {\n        var sum = 1.0\n        var denom = 1.toDouble()\n        for(i in n downTo 2){\n            denom*=i\n            sum+=(1.0\/denom)\n\n        }\n        return sum-sum%0.000001\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206244,"user_id":null,"body":"package solution\n\nobject Suite {\n\n    fun going(n: Int): Double {\n     \n        return generateSequence(Triple(n-1, 1.0, 1.0\/n), {Triple(it.first-1, it.second+it.third, it.third\/it.first )}).takeWhile{it.first >= 0 && it.third > 1.0\/1000000000.0}.last().second\n\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206245,"user_id":null,"body":"package solution\n\nobject Suite {\n\n    fun going(n: Int): Double {\n        var sum: Double = 1.0\n        var drob: Double = 1.0\n        for (i in n downTo 2 step 1) {\n          drob=1\/i.toDouble()*drob  \n          sum=sum+drob      \n        }\n    return sum}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206246,"user_id":null,"body":"package solution\n\nimport java.math.BigDecimal\nimport java.math.MathContext\nimport kotlin.math.floor\n\nobject Suite {\n\n    fun going(n: Int): Double {\n        var factorial = BigDecimal.ONE\n        var sum = BigDecimal.ZERO\n        for (i in 1..n) {\n            factorial = factorial.multiply(BigDecimal.valueOf(i.toLong()))\n            sum += factorial\n        }\n        val divisionRes = BigDecimal.ONE.divide(factorial, MathContext.DECIMAL128)\n        val result = divisionRes.multiply(sum).toDouble()\n        return floor(result * 1000000) \/ 1000000\n    }\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"55a2d7ebe362935a210000b2":[{"id":206247,"user_id":null,"body":"package solution\n\nclass SmallestIntegerFinder {\n  fun find_smallest_int(nums: List<Int>) = nums.minOf { it }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206248,"user_id":null,"body":"package solution\n\nclass SmallestIntegerFinder {\n\n  fun find_smallest_int(nums: List<Int>): Int {\n        return nums.sorted().get(0)\n  }\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206249,"user_id":null,"body":"package solution\n\nclass SmallestIntegerFinder {\n\n  fun find_smallest_int(nums: List<Int>): Int {\n    return nums.minOrNull() ?: 0\n  }\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206250,"user_id":429,"body":"package solution\n\nclass SmallestIntegerFinder {\n\n  fun find_smallest_int(nums: List<Int>): Int {\n    return nums.minOrNull()!!\n  }\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206251,"user_id":null,"body":"package solution\n\nclass SmallestIntegerFinder {\n\n  fun find_smallest_int(nums: List<Int>): Int {\n      var smallest = Int.MAX_VALUE\n      for(n in nums){\n          if(n<smallest) smallest = n\n      }\n      return smallest\n  }\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206252,"user_id":null,"body":"package solution\n\nclass SmallestIntegerFinder {\n\n  fun find_smallest_int(nums: List<Int>): Int {\n    val listCopy = nums.toMutableList()\n    listCopy.sort()\n    return listCopy[0] \/\/ Implement me!\n  }\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206253,"user_id":null,"body":"package solution\n\nclass SmallestIntegerFinder {\n\n  fun find_smallest_int(nums: List<Int>): Int {\n\t\t  \n\t\t  return nums.sorted().first() \/\/ Implement me!\n  }\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206254,"user_id":null,"body":"package solution\n\nclass SmallestIntegerFinder {\n\n  fun find_smallest_int(nums: List<Int>): Int = nums.sorted()[0]\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206255,"user_id":null,"body":"package solution\n\nclass SmallestIntegerFinder {\n\n  fun find_smallest_int(nums: List<Int>): Int {\n    var result = nums.first()\n    var i = 0\n    while (i <= (nums.count()-1)) {\n        if (nums[i] < result) {\n            result = nums[i]\n        }\n        i++        \n    }   \n    return result \/\/ Implement me!\n  }\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206256,"user_id":null,"body":"package solution\n\nclass SmallestIntegerFinder {\n\n  fun find_smallest_int(numss: List<Int>): Int? {\n        return numss.minOrNull()\n    }\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"55a70521798b14d4750000a4":[{"id":206257,"user_id":527,"body":"fun greet(name: String): String = \"Hello, ${name} how are you doing today?\"","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206258,"user_id":527,"body":"fun greet(name: String) = \"Hello, ${name} how are you doing today?\"","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206259,"user_id":null,"body":"import java.util.*\n\nfun greet(name: String): String {\n    \n    return \"Hello, $name how are you doing today?\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206260,"user_id":361,"body":"fun greet(name: String): String {\n  return \"Hello, ${name} how are you doing today?\"\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206261,"user_id":null,"body":"fun greet(name: String): String {\n  \/\/your code here\n    return \"Hello, \" + name + \" how are you doing today?\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206262,"user_id":null,"body":"val greet: (String)->String = {\"Hello, $it how are you doing today?\"}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206263,"user_id":null,"body":"fun greet(name: String): String {\n    var x = \"Hello, \"\n    var y = \" how are you doing today?\"\n    return x + name + y\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206264,"user_id":null,"body":"fun greet(name: String): String {\n  var str : String = \"Hello, $name how are you doing today?\"\n    return str\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206265,"user_id":null,"body":"fun greet(name: String): String {\n    return \"Hello, X how are you doing today?\".replace(\"X\", name)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206266,"user_id":null,"body":"fun greet(name: String): String {\n    print(name)\n    return \"Hello, $name how are you doing today?\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"55aa075506463dac6600010d":[{"id":206267,"user_id":null,"body":"package solution\n\nobject SumSquaredDivisors {\n    \n    fun list_squared(m: Long, n: Long): String {\n        return (m..n).mapNotNull{num ->\n           (1..kotlin.math.sqrt(num.toDouble()).toLong())\n            .filter{num % it == 0L}\n            .flatMap{setOf(it, num \/ it)}\n            .fold(0L){acc, n -> acc + n*n}\n            .toDouble()\n            .let{\n                if (kotlin.math.sqrt(it).let{it.toLong().toDouble() == it}) \"[${num}, ${it.toLong()}]\"\n                else null\n            }\n        }.joinToString(\", \", \"[\", \"]\")\n    }\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206268,"user_id":null,"body":"package solution\n\nimport kotlin.math.sqrt\nimport kotlin.math.floor\n\nobject SumSquaredDivisors {\n    \n    private fun getSquaredSum(number: Long) : Long {\n        var sum = 0L\n        var i = 1L\n        val root = sqrt(number.toDouble())\n        while(i <= root) {\n            if(number % i == 0L) {\n                sum += i * i\n                val partner = number \/ i\n                if(i != partner) sum += partner * partner\n            }\n            i++\n        }\n        return sum\n    }\n    \n    fun list_squared(m: Long, n: Long): String {\n        val candidates = m..n\n        val result = mutableListOf<List<Long>>()\n        for(candidate in candidates) {\n            val squaredSum = getSquaredSum(candidate).toDouble()\n            val root = floor(sqrt(squaredSum))\n            if(root * root == squaredSum) result.add(listOf(candidate, squaredSum.toLong()))\n        }\n        return result.toString()\n    }\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206269,"user_id":null,"body":"package solution\nimport kotlin.math.floor\nimport kotlin.math.sqrt\n\nobject SumSquaredDivisors {\n    \n    fun divisorsHelper(int: Int): List<Int> {\n        val firstDivs = (1..(sqrt(int.toDouble()).toInt())).filter { int % it == 0 }\n        val secondDivs = firstDivs.map { int \/ it }\n        return (firstDivs + secondDivs).distinct()\n    }\n\n    fun list_squared(m: Long, n: Long):String = ((m.toInt()..n.toInt()).map { integer -> listOf(integer, divisorsHelper(integer).sumOf { it.toLong() * it.toLong() }) }.filter { sqrt(it[1].toDouble()) == floor(sqrt(it[1].toDouble())) }).toString()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206270,"user_id":null,"body":"package solution\n\nimport kotlin.math.sqrt\nimport kotlin.math.floor\n\nobject SumSquaredDivisors {\n    \n    \/\/There are more efficient ways\n    private fun getDivisors(number: Long) : List<Long> {\n        val divisors = mutableListOf<Long>()\n        var i: Long = 1\n        while(i * i <= number) {\n            if(number % i == 0L) {\n                divisors.add(i)\n                val partner = number \/ i\n                if(i != partner) divisors.add(partner)\n            }\n            i += 1\n        }\n        return divisors\n    }\n    \n    fun list_squared(m: Long, n: Long): String {\n        val candidates = m..n\n        val result = mutableListOf<List<Long>>()\n        for(candidate in candidates) {\n            val divisors = getDivisors(candidate)\n            val squaredSum = divisors.reduce { acc, elem -> acc + elem * elem }.toDouble()\n            val root = floor(sqrt(squaredSum))\n            if(root * root == squaredSum) result.add(listOf(candidate, squaredSum.toLong()))\n        }\n        return result.toString()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206271,"user_id":null,"body":"package solution\n\nimport kotlin.math.ceil\nimport kotlin.math.floor\nimport kotlin.math.sqrt\n\nfun divisors(x: Long): List<Long> = when (x) {\n    1L -> listOf(1)\n    else -> (2 ..  ceil(sqrt(x.toDouble())).toLong()).filter { x % it == 0L }.map { listOf(it, x \/ it) }.flatten().distinct() + 1 + x\n}\nfun isSquare(x: Long) = x == (sqrt(x.toDouble()).toLong() * sqrt(x.toDouble()).toLong())\n\nobject SumSquaredDivisors {\n    fun list_squared(m: Long, n: Long) = (m..n)\n        .map { x -> listOf(x, divisors(x).map { it * it }.sum())}\n        .filter { (_, sq) -> isSquare(sq) }\n        .joinToString(prefix=\"[\", postfix = \"]\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206272,"user_id":null,"body":"package solution\n\nimport kotlin.math.floor\nimport kotlin.math.sqrt\n\nobject SumSquaredDivisors {\n    \n    private fun factors(n: Long): Set<Long> {\n        return when(n) {\n            1L -> setOf(1L)\n            else -> setOf(1, n).plus((2..sqrt(n.toDouble()).toLong()).filter { n % it == 0L }.flatMap { listOf(it, n \/ it) }.toSet())\n        }\n    }\n\n    fun list_squared(m: Long, n: Long): String {\n        return (m..n)\n                .map { Pair(it, factors(it).map{ i -> i * i }.sum()) }\n                .filter { floor(sqrt(it.second.toDouble())) == sqrt(it.second.toDouble()) }\n                .map { it.toList().toString() }\n                .toString()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206273,"user_id":null,"body":"package solution\n\nimport kotlin.math.sqrt\n\nobject SumSquaredDivisors {  \n    \n    fun list_squared(m: Long, n: Long): String {\n        val squarePairs = mutableListOf<List<Long>>()\n        for (number in m..n) {\n            val divisors = number.divisors()\n            val sumOfSquares = divisors.sumOf { it * it }\n            val sqrtOfSum = sqrt(sumOfSquares.toDouble())\n            if (sqrtOfSum % 1.0 == 0.0) { squarePairs += listOf(number, sumOfSquares) }\n        }\n        return squarePairs.toString()\n    }\n\n    private fun Long.divisors(): Set<Long> {\n        val divisors = mutableSetOf<Long>()\n        for (div in 1..(sqrt(this.toDouble())).toInt() + 1) {\n            if (this.mod(div) == 0) {\n                divisors += div.toLong()\n                divisors += this \/ div\n            }\n        }\n        return divisors\n    }    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206274,"user_id":null,"body":"object SumSquaredDivisors {\n    \n    fun list_squared(m: Long, n: Long): String {\n        var result = mutableListOf<Pair<Long,Long>>()\n        for (i in m..n) {\n            \/\/ find divisors\n            var SumSquare: Long = 0\n            for (j in 1..Math.sqrt(i.toDouble()).toLong()) {\n                if (i % j == 0L) {\n                    if ( i\/j == j) {    \n                    SumSquare = SumSquare + j * j\n                    } else {\n                    SumSquare = SumSquare + j * j + (i\/j) * (i\/j)                        \n                    }\n                }\n            }\n             \/\/ check if SumSquare itself is a square \n             if (Math.sqrt(SumSquare.toDouble()) % 1.0 == 0.0) {\n                   result.add(Pair(i,SumSquare)) \n            }\n\n        }\n        return \"[\"+result.toTypedArray().joinToString().replace(\"(\",\"[\").replace(\")\",\"]\")+\"]\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206275,"user_id":null,"body":"package solution\n\nobject SumSquaredDivisors {\n    \n  fun list_squared(start:Long,end:Long):String{\n      val result=StringBuilder()\n        for( num in start..end){\n            var sum:Long = 0\n            for(x2 in 1..Math.sqrt(num.toDouble()).toLong()){\n                if((num % x2) == 0.toLong()){\n                    sum+=x2*x2\n                    if (num\/x2 != x2){\n                        sum+=(num\/x2 )*(num\/x2)\n                    }\n                }\n            }\n            if (Math.sqrt(sum.toDouble())%1==0.toDouble()){\n                result.append(\"[$num, $sum], \")\n            }\n        }\n\n\n        return \"[${result.toString().dropLast(2)}]\"\n    }\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206276,"user_id":null,"body":"package solution\nimport kotlin.math.*\n\nobject SumSquaredDivisors {\n    fun list_squared(m: Long, n: Long): String {\n        val result: MutableList<List<Long>> = mutableListOf()\n        for (i in m..n) {\n            var x = 1; val squaredDivisors: MutableSet<Double> = mutableSetOf()\n            while (x <= i \/ x) {\n                if (!(i % x > 0)) squaredDivisors.addAll(listOf(x.toDouble().pow(2), (i \/ x).toDouble().pow(2)))\n                x++\n            }\n            val total = squaredDivisors.sum(); val sqrtTotal = sqrt(total)\n            if (sqrtTotal == floor(sqrtTotal)) result.add(listOf(i, total.toLong()))\n        }\n        return result.toString()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"55ab4f980f2d576c070000f4":[{"id":206277,"user_id":1251,"body":"object Suite2 {\n    fun game(n: Long): String {\n        return if (n % 2 == 0L) \"[${n * n \/ 2}]\" else \"[${n * n}, 2]\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206278,"user_id":492,"body":"package solution\n\nobject Suite2 {\n    fun game(n: Long): String {\n        return if (n % 2 == 0L)\n            String.format(\"[%d]\", n * n \/ 2)\n        else\n            String.format(\"[%d, 2]\", n * n, 2)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206279,"user_id":null,"body":"package solution\nimport kotlin.math.roundToInt\n\nobject Suite2 {\n    fun game(n: Long): String = if (n % 2 != 0L) \"[${n * n}, 2]\" else \"[${ (n * n) \/ 2}]\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206280,"user_id":null,"body":"package solution\n\nobject Suite2 {\n    fun game(n: Long) = if (n % 2 == 0L) \"[${n * n \/ 2}]\" else \"[${n * n}, 2]\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206281,"user_id":null,"body":"package solution\n\nobject Suite2 {\n    fun game(n: Long): String {\n        val res = .5 + ( n.toDouble() * n.toDouble() - 1.0 ) \/ 2.0\n        return if (res.toLong().toDouble() == res ) \"[${res.toLong()}]\" else \"[${res.toLong() * 2 + 1}, 2]\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206282,"user_id":null,"body":"package solution\n\nobject Suite2 {\n    fun game(n: Long): String {\n        val sumOfNonDiagonals = ((n * n) - n) \/ 2\n        \n        val (numerator, denominator) = if (n.toInt().rem(2) == 0) {\n            \/\/ If n is even, then the diagonals add up to an integer (n \/ 2) and the denominator is 1\n            val diagonals = n \/ 2\n            Pair(sumOfNonDiagonals + diagonals, 1)\n        } else {\n            \/\/ If n is odd then the diagonals add up to a fraction over 2\n            val numerator = (sumOfNonDiagonals * 2) + n\n            Pair(numerator, 2)\n        }\n        \n        return if (denominator == 1) {\n            \"[${numerator}]\"\n        } else {\n            \"[${numerator}, ${denominator}]\"\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206283,"user_id":null,"body":"package solution\n\nobject Suite2 {\n    fun game(n: Long): String = \"[%s]\".format(if (n % 2 == 0L) n * n \/ 2 else \"%d, 2\".format(n * n))\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206284,"user_id":null,"body":"package solution\n\nobject Suite2 {\n    fun game(n: Long): String {\n        return if(n % 2 == 0L) \"[${n * n \/ 2}]\" else \"[${n * n}, 2]\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206285,"user_id":null,"body":"package solution\n\nobject Suite2 {\n    fun game(n: Long): String =\n        if (n % 2 == 1L)\n            \"[${n * n}, 2]\"\n        else \"[${n * n \/ 2}]\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206286,"user_id":null,"body":"package solution\n\nobject Suite2 {\n    fun game(n: Long): String {\n        val x = n * n\n        return if(x % 2.0 == 1.0){\n            \"[$x, 2]\"\n        } else {\n            \"[${x\/2}]\"\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"55acfc59c3c23d230f00006d":[{"id":206287,"user_id":527,"body":"val getAscii = Char::toInt","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206288,"user_id":null,"body":"fun getAscii(c: Char) = c.code","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206289,"user_id":null,"body":"fun getAscii(c: Char) = c.toInt()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206290,"user_id":168,"body":"fun getAscii(c: Char): Int = c.code","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206291,"user_id":null,"body":"val getAscii = Char::code","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206292,"user_id":1267,"body":"fun getAscii(c: Char): Int = c.toInt()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206293,"user_id":null,"body":"fun getAscii(c: Char): Int {\n  return c.hashCode()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206294,"user_id":null,"body":"val getAscii: (Char) -> Int = { c -> c.toInt() }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206295,"user_id":null,"body":"fun getAscii(c: Char): Int = c.code.toByte().toInt()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206296,"user_id":null,"body":"fun getAscii(c: Char): Int {\n    val castAscii = c.toInt()\n    return castAscii\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"55b3425df71c1201a800009c":[{"id":206297,"user_id":null,"body":"package solution\n\nfun stat_assoc(s: String): String {\n        fun String.toSecs() = split(\"|\").map { it.toInt() }.let { it[0] * 3600 + it[1] * 60 + it[2] }\n        fun Int.toHmd() = \"%02d|%02d|%02d\".format(this \/ 3600, this % 3600 \/ 60, this % 60)\n        if (s.isEmpty()) return \"\"\n\n        val results = s.split(\", \").map { it.toSecs() }.sorted()\n        val range = results.last() - results.first()\n        val average = results.sum() \/ results.size\n        val median = ((results.size - 1) \/ 2).let { results.drop(it).dropLast(it).average().toInt() }\n        return \"Range: ${range.toHmd()} Average: ${average.toHmd()} Median: ${median.toHmd()}\"\n}","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206298,"user_id":null,"body":"package solution\n\n\nobject Stat {\n    private fun Int.toHHMMSS(): String =\n      \"%02d|%02d|%02d\".format(this \/ 3600, this \/ 60 % 60, this % 60)\n\n    fun stat_assoc(s: String): String =\n        \"\"\"(\\d{1,2})\\|(\\d{1,2})\\|(\\d{1,2})\"\"\".toRegex()\n            .findAll(s)\n            .map { it.groupValues[1].toInt()*3600 + it.groupValues[2].toInt()*60 + it.groupValues[3].toInt() }\n            .sorted()\n            .toList()\n            .run {\n                val range = last() - first()\n                val average = average().toInt()\n                val median =\n                    if (size % 2 == 1)\n                        get(size \/ 2)\n                    else\n                        (get(size \/ 2) + get(size \/ 2 - 1)) \/ 2\n                \"Range: ${range.toHHMMSS()} Average: ${average.toHHMMSS()} Median: ${median.toHHMMSS()}\"\n            }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206299,"user_id":932,"body":"package solution\n\nobject Stat {\nfun stat_assoc(s: String)=s.split(\", \")\n    .map{it.split(\"|\").let{it[0].toInt().times(60).plus(it[1].toInt()).times(60).plus(it[2].toInt())}}.sorted()\n    .let {arrayListOf(it.last()-it.first(),it.average().toInt(), if(it.size%2==0)(it[it.size\/2]+it[(it.size\/2-1)])\/2 else it[it.size\/2])}\n    .map{\"%02d|%02d|%02d\".format(it\/3600,(it\/60)%60,it%60)}.let{\"Range: ${it[0]} Average: ${it[1]} Median: ${it[2]}\"}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206300,"user_id":null,"body":"package solution\nimport kotlin.math.pow\n\n\nobject Stat {\n\n    fun stat_assoc(s: String): String {\n    val allResults = s.replace(\" \", \"\").split(\",\").map {\n        it.split(\"|\").mapIndexed { index, s -> s.toInt() * 60.0.pow(2 - index) }.sum().toInt()\n    }.sorted()\n    \n    val range = allResults.maxOrNull()!! - allResults.minOrNull()!!\n    val average = allResults.sum() \/ allResults.size\n    val median =\n        if (allResults.size % 2 == 0) (allResults[allResults.size \/ 2 - 1] + allResults[allResults.size \/ 2]) \/ 2\n        else allResults[allResults.size \/ 2]\n\n    return \"Range: %02d|%02d|%02d\".format(range \/ 3600, range \/ 60 % 60, range % 60) +\n            \" Average: %02d|%02d|%02d\".format(average \/ 3600, average \/ 60 % 60, average % 60) +\n            \" Median: %02d|%02d|%02d\".format(median \/ 3600, median \/ 60 % 60, median % 60)\n}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206301,"user_id":null,"body":"package solution\n\nobject Stat {\n\n    fun stat_assoc(s: String): String {\n        \n        var list = s.split(\", \").map{it -> toMin(it)}.sorted()\n    \n        return if (list.size % 2 == 0) \"Range: ${toForm(list[list.size - 1] - list[0])} Average: ${toForm(list.average().toInt())} Median: ${toForm((list[list.size \/ 2] + list[list.size \/ 2 - 1]) \/ 2)}\"\n        else \"Range: ${toForm(list[list.size - 1] - list[0])} Average: ${toForm(list.average().toInt())} Median: ${toForm(list[list.size \/ 2 ])}\"\n    }\n    \n    fun toMin(s: String): Int = s.split(\"|\")[0].toInt() * 3600 + s.split(\"|\")[1].toInt() * 60 + s.split(\"|\")[2].toInt()\n    \n    fun toForm(s: Int): String = (\"%02d\".format(s \/ 3600)).toString()  + \"|\" + (\"%02d\".format((s % 3600) \/ 60)).toString() + \"|\" +  (\"%02d\".format(s % 60)).toString()\n    \n}\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206302,"user_id":null,"body":"package solution\n\nimport kotlin.math.floor\n\nobject Stat {\n    \n    private val timeRegex = Regex(\"([0-9]?[0-9])\\\\|([0-9]?[0-9])\\\\|([0-9]?[0-9])\")\n\n\n    fun stat_assoc(s: String): String {\n        if (s.isEmpty()) return \"\"\n        val list = s.split(\",\").map(::toTimeStringPair).sortedByDescending { it.first }\n        return \"Range: ${getRange(list)} Average: ${getAverage(list)} Median: ${getMedian(list)}\"\n    }\n\n    private fun toTimeStringPair(it: String): Pair<Int, String> {\n        val match = timeRegex.find(it)\n        val hours = Integer.parseInt(match!!.groupValues[1]) * 3600\n        val minutes = Integer.parseInt(match.groupValues[2]) * 60\n        val seconds = Integer.parseInt(match.groupValues[3])\n        return Pair(hours + minutes + seconds, it)\n    }\n\n    private fun getMedian(list: List<Pair<Int, String>>) = if (list.size % 2 == 1) {\n       toString(list[list.size \/ 2].first)\n   } else {\n       toString((list[list.size \/ 2].first + list[(list.size \/ 2) - 1].first) \/ 2)\n   }\n\n    private fun getAverage(list: List<Pair<Int, String>>) =\n        toString(floor(list.map { it.first }.average()).toInt())\n\n    private fun getRange(list: List<Pair<Int, String>>) = toString(list.first().first - list.last().first)\n\n    private fun toString(rangeAsInt: Int): String {\n        val hours = rangeAsInt \/ 3600\n        val hoursAsString = addLeadingZeroIfNecessary(hours)\n        val remainder = rangeAsInt - (3600 * hours)\n        val minutes = remainder \/ 60\n        val minutesAsString = addLeadingZeroIfNecessary(minutes)\n        val secondsAsString = addLeadingZeroIfNecessary(remainder - (minutes * 60))\n        return \"$hoursAsString|$minutesAsString|$secondsAsString\"\n    }\n\n    private fun addLeadingZeroIfNecessary(i: Int) = if (i < 10) \"0$i\" else \"$i\"\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206303,"user_id":null,"body":"package solution\n\nobject Stat {\n\n    fun stat_assoc(stat_assocs: String): String {\n        val results = stat_assocs.split(\", \")\n            .map { stat_assoc -> toSeconds(stat_assoc) }\n            .sorted()\n\n        val range = (results.maxOrNull() ?: 0) - (results.minOrNull() ?: 0)\n        val average = results.sum() \/ results.size\n        val median: Int = if (results.size % 2 == 0) {\n            val middle = results.size \/ 2\n            (results[middle] + results[middle - 1]) \/ 2\n        } else {\n            results[results.size \/ 2]\n        }\n\n        return \"Range: ${getHMS(range)} Average: ${getHMS(average)} Median: ${getHMS(median)}\"\n    }\n\n    private fun getHMS(seconds: Int): String {\n        val h = seconds \/ 3600\n        val m = (seconds - h * 3600) \/ 60\n        val s = seconds - h * 3600 - m * 60\n        val hString = h.toString().padStart(2, '0')\n        val mString = m.toString().padStart(2, '0')\n        val sString = s.toString().padStart(2, '0')\n        return \"$hString|$mString|$sString\"\n    }\n\n    private fun toSeconds(raceResult: String): Int {\n        val hms = raceResult.split(\"|\")\n\n        val h = hms[0].toInt()\n        val m = hms[1].toInt()\n        val s = hms[2].toInt()\n\n        return 60 * 60 * h + 60 * m + s\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206304,"user_id":null,"body":"package solution\n\nimport kotlin.math.pow\nimport kotlin.time.DurationUnit\nimport kotlin.time.toDuration\n\nobject Stat {\n\n        @OptIn(kotlin.time.ExperimentalTime::class)\n    fun stat_assoc(s: String): String {\n        val secondsArr = s.split(\",\").map {\n            var num = 0L\n            it.trim().split(\"|\").reversed().forEachIndexed { index, str ->\n                    num += str.toLong() * 60.0.pow(index).toLong()\n                }\n            num\n        }.sorted()\n        val cvt: Long.() -> String = {\n            this.toDuration(DurationUnit.SECONDS).toComponents { h, m, s, _ ->\n                String.format(\"%02d|%02d|%02d\", h, m, s)\n            }\n        }\n        val rng = (secondsArr.last() - secondsArr.first()).let { \"Range: ${it.cvt()}\" }\n        val avg = secondsArr.average().toLong().let { \"Average: ${it.cvt()}\" }\n        val med = ((secondsArr[secondsArr.size \/ 2] + secondsArr[(secondsArr.size - 1) \/ 2]) \/ 2).let { \"Median: ${it.cvt()}\" }\n        return \"$rng $avg $med\"\n    }\n    }\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206305,"user_id":null,"body":"package solution\nimport kotlin.math.abs\n\nobject Stat {\n\n    fun stat_assoc(s: String): String {\n        if(s.isBlank()) return s\n        val converted = s.split(',')\n            .map { it.trim() }\n            .map { it.split('|').map { it2 -> it2.toInt() } }\n            .map { it[0]*3600 + it[1]*60 + it[2] }\n            .sorted()\n        val range = abs(converted.maxOf { it } - converted.minOf { it })\n        val average = converted.reduce(Integer::sum).div(converted.size)\n        val halfSize = converted.size \/ 2\n        val median = if (converted.size % 2 == 0) (converted[halfSize]+converted[halfSize-1]) \/ 2 else converted[halfSize]\n        return \"Range: ${toTimeString(range)} Average: ${toTimeString(average)} Median: ${toTimeString(median)}\"\n    }\n\n    fun toTimeString(i : Int) : String {\n        val temp = i % 3600\n        return \"%02d|%02d|%02d\".format(i\/3600, temp\/60, temp%60)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206306,"user_id":null,"body":"package solution\n\nobject Stat {\n\n   fun stat_assoc(s: String): String {\n     val seconds =\n         s.split(\", \").flatMap { res: String ->\n           res.split(\"|\").map { it.toInt() }.chunked(3) { it[0] * 3600 + it[1] * 60 + it[2] }\n         }\n     val range = (seconds.maxOrNull() ?: 0) - (seconds.minOrNull() ?: 0)\n     val avg = seconds.average().toInt()\n     val med =\n         seconds.sorted().let {\n           if (it.size % 2 == 0) {\n             (it[it.size \/ 2] + it[it.size.minus(1) \/ 2]) \/ 2\n           } else {\n             it[it.size \/ 2]\n           }\n         }.toInt()\n     return \"Range: ${range.secToHMS()} Average: ${avg.secToHMS()} Median: ${med.secToHMS()}\"\n    }   \n}\nfun Int.secToHMS(): String {\n val h = this \/ 3600\n val m = ((this - h * 3600) \/ 60)\n val s = this - (h * 3600 + m * 60)\n return \"$h\".padStart(2, '0') + \"|\" + \"$m\".padStart(2, '0') + \"|\" + \"$s\".padStart(2, '0')\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"55b4d87a3766d9873a0000d4":[{"id":206307,"user_id":null,"body":"package carboat\n\nfun howmuch(m:Int, n:Int) = (Math.min(m, n)..Math.max(m, n))\n    .filter { (it - 1) % 9 == 0 && (it - 2) % 7 == 0 }\n    .map { \"[M: $it B: ${(it - 2) \/ 7} C: ${(it - 1) \/ 9}]\" }\n    .joinToString(\"\", \"[\", \"]\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206308,"user_id":null,"body":"package carboat\n\nfun howmuch(m:Int, n:Int):String {\n    var solutions:String = \"\"\n    var a=Math.min(m,n)\n    var z=Math.max(m,n)\n    \n    for(f in a..z)\n      if ( (f-2)%7==0 && (f-1)%9==0 )\n        solutions =\"${solutions}[M: $f B: ${(f-2)\/7} C: ${(f-1)\/9}]\"\n      \n    \n    return \"[${solutions}]\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206309,"user_id":492,"body":"package carboat\n\nfun howmuch(m:Int, n:Int):String {\n    var i = Math.min(m, n)\n    val j = Math.max(m, n)\n    var res = \"[\"\n    while (i <= j)\n    {\n      if ((i % 9 == 1) && (i % 7 == 2))\n      {\n        res += \"[M: \" + i + \" B: \" + (i \/ 7).toInt() + \" C: \" + (i \/ 9).toInt() + \"]\"\n      }\n      i++\n    }\n    return res + \"]\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206310,"user_id":null,"body":"package carboat\n\nfun howmuch(m:Int, n:Int):String = ((Math.ceil(maxOf(minOf(m, n)-37, 0)\/63.0).toInt()*63 + 37)..maxOf(m, n) step 63).joinToString(\"\", \"[\", \"]\"){ \"[M: $it B: ${(it-2)\/7} C: ${(it-1)\/9}]\" }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206311,"user_id":null,"body":"package carboat\n\nfun howmuch(m:Int, n:Int):String {\n        println(\"$m , $n\")\n        var result = \"\"\n        if (n>m) {\n            for (i in m..n) {\n                if ((i - 1) % 9 == 0 && (i - 2) % 7 == 0) {\n                    result += \"[M: $i B: ${(i - 2) \/ 7} C: ${(i - 1) \/ 9}]\"\n                }\n            }\n        } else {\n            for (i in n..m) {\n                if ((i - 1) % 9 == 0 && (i - 2) % 7 == 0) {\n                    result += \"[M: $i B: ${(i - 2) \/ 7} C: ${(i - 1) \/ 9}]\"\n                }\n            }\n        }\n        return \"[$result]\"\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206312,"user_id":null,"body":"package carboat\n\nfun howmuch(m:Int, n:Int):String {\n    var result=\"[\"\n    for(f in minOf(m,n)..maxOf(m,n)){\n        if((f-1)%9==0 && (f-2)%7==0)\n                result+=\"[M: $f B: ${(f-2)\/7} C: ${(f-1)\/9}]\"\n    }\n    return result+\"]\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206313,"user_id":null,"body":"package carboat\n\nfun howmuch(m: Int, n: Int) = (minOf(m, n)..maxOf(n, m))\n        .filter { it % 9 == 1 && it % 7 == 2 }\n        .joinToString(\"\", \"[\", \"]\") { \"[M: $it B: ${(it - 2) \/ 7} C: ${(it - 1) \/ 9}]\" }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206314,"user_id":53,"body":"package carboat\n\nimport kotlin.math.min\nimport kotlin.math.max\n\nfun howmuch(m: Int, n: Int): String {\n    val ans = java.util.StringJoiner(\"\", \"[\", \"]\");\n    for (i in min(n, m) until max(n, m) + 1) {\n        if (i % 9 == 1 && i % 7 == 2) {\n            ans.add(\"[M: ${i} B: ${i \/ 7} C: ${i \/ 9}]\");\n        }\n    }\n    return ans.toString()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206315,"user_id":null,"body":"package carboat\n\nfun howmuch(m: Int, n: Int) =\n    (if (m < n) m..n else n..m)\n      .filter { it.rem(9) == 1 && it.rem(7) == 2 }\n      .map { \"[M: $it B: ${ it.div(7) } C: ${ it.div(9) }]\" }\n      .joinToString(separator = \"\", prefix = \"[\", postfix = \"]\")\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206316,"user_id":null,"body":"package carboat\n\nfun howmuch(m:Int, n:Int):String {\n    val itog = mutableListOf<List<Int>>()\n    val lower = if (m < n) m else n\n    val high = if (m > n) m else n\n    for (f in lower..high) {\n        val b = (f - 2) % 7 == 0\n        val c = (f - 1) % 9 == 0\n        if (b && c)\n            itog.add(listOf(f, (f - 2) \/ 7, (f - 1) \/ 9))\n    }\n    val result = itog.map {\n        \"[M: ${it[0]} B: ${it[1]} C: ${it[2]}]\"\n    }.joinToString(\n        separator = \"\",\n        prefix = \"[\",\n        postfix = \"]\"\n    )\n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"55be10de92aad5ef28000023":[{"id":206317,"user_id":null,"body":"package color\n\nfun checkchoose(m: Long, n: Int): Long {\n    var x = n.toLong()\n    (1..n\/2).forEach {\n        if (x > m) return -1L\n        if (x == m) return it.toLong()\n        x = x * (n - it) \/ (it + 1)\n    }\n    return -1L\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206318,"user_id":1560,"body":"package color\n\nfun checkchoose(m:Long, n:Int):Long {\n  var a=1L\n  for(i in 1L..n\/2) {\n    a=a*(n-i+1)\/i\n    if(a==m) return i\n  }\n  return -1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206319,"user_id":null,"body":"package color\n\nfun checkchoose(m:Long, n:Int):Long {\n    var binom : Long = 1\n    var k : Long = 0\n    while (k < n\/2+1) {\n        println(binom)\n        if (binom == m) return k\n        binom = binom*(n-k)\/(k+1)\n        k++\n    }\n    \n    return -1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206320,"user_id":null,"body":"package color\nimport java.math.BigInteger\n\nfun checkchoose(m:Long, n:Int):Long = (1L..n).map{Pair(it, choose(n.toLong(), it))}.firstOrNull{it.second == m}?.component1() ?: -1L\n\nprivate fun choose(a: Long, b: Long): Long = (factorial(a)\/(factorial(b) * factorial(a - b))).toLong()\n\nprivate fun factorial(n: Long): BigInteger =\n    if (n in listOf(0L, 1L)) BigInteger.ONE else (n downTo 2).map { it.toBigInteger() }.reduce { acc, i -> acc * i }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206321,"user_id":null,"body":"package color\nimport java.math.BigInteger\n\n\nfun fact(num : Long) : BigInteger {\n    var factorial = BigInteger.ONE\n    for (i in 2..num) {\n        factorial = factorial.multiply(BigInteger.valueOf(i))\n    }\n    return factorial\n}\n\nfun checkchoose(m:Long, n:Int):Long {\n    var output = 0L\n    var mTemp : Long\n    while (output <= n) {\n        (fact(n.toLong()) \/ (fact(output) * fact(n - output))).also { mTemp = it.toLong() }\n        if (mTemp == m) return output\n        output++\n    }\n    return -1\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206322,"user_id":null,"body":"package color\n\nimport java.math.BigDecimal\n\nfun checkchoose(m:Long, n:Int):Long {\n    if(n == 1) return -1\n    for (x in 1..n) {\n        if (n - x < 1) return -1\n        if (BigDecimal(m) == fac(BigDecimal(n)).divideToIntegralValue(fac(BigDecimal(x))* fac(BigDecimal(n-x)))) {\n            return x.toLong()\n        }\n    }\n    return -1\n}\n\nfun fac(num: BigDecimal): BigDecimal {\n    if (num == BigDecimal.ONE) return BigDecimal.ONE\n    return num * fac(num - BigDecimal.ONE)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206323,"user_id":932,"body":"package color\n\nfun checkchoose(m:Long, n:Int):Long {\n    var x = n\/2L\n    val n = n.toLong()\n    var comb = combination(x, n)\n    while (x>0 && comb>m) {\n        x--\n        comb = combination(x, n)\n    }\n    return if (comb==m) x else -1\n}\n\nfun combination(k: Long, n: Long): Long{\n    if (k==n) return 1\n    val k = k.coerceAtMost(n-k)\n    var res = n-k+1\n    for (i in 2 until k+1)\n        res = res*(n-k+i)\/i\n    return res\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206324,"user_id":1170,"body":"package color\n\nimport java.math.BigInteger\n\nfun checkchoose(m: Long, n: Int): Long {\n    for (it in 1..n \/ 2) {\n        if (under(n, it) == m) return it.toLong()\n    }\n    return -1\n}\n\nfun under(n: Int, k: Int): Long {\n    var result = BigInteger.ONE\n    for (it in n - k + 1..n) {\n        result = result.multiply(it.toBigInteger())\n    }\n    for (it in 1..k) {\n        result = result.divide(it.toBigInteger())\n    }\n    return result.toLong()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206325,"user_id":null,"body":"package color\nimport java.math.BigInteger\n\nfun checkchoose(m:Long, n:Int):Long {\n    for (i in 1..n) {\n        if ((factorial(n) \/ (factorial(i) * factorial(n-i))).toLong() == m) {\n            return i.toLong()\n        }\n    }\n    return -1        \n}\n\/\/ helper function to compute factorials by using dynamic programming principle.\n\/\/ I used BigInteger because <Long> failed to work with very large number\nval factorials = mutableListOf<BigInteger>(BigInteger(\"1\"), BigInteger(\"1\"))\nfun factorial(n: Int): BigInteger {\n    if (n <= factorials.count() - 1) {\n        return factorials[n]\n    } else {\n        factorials.add(n.toBigInteger() * factorial(n-1))\n        return factorials[n]\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206326,"user_id":null,"body":"package color\n\nfun checkchoose(m:Long, n:Int):Long {\n  var result = 1L\n  for (i in 0L..n+1) {\n    if (result == m) {\n      return i\n    }\n    result = (result * (n - i)) \/ (i + 1L)\n  }\n  return -1L\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"55bf01e5a717a0d57e0000ec":[{"id":206327,"user_id":null,"body":"fun persistence(num: Int) = generateSequence(num) {\n        it.toString().map(Character::getNumericValue).reduce { mult, element -> mult * element }\n    }.takeWhile { it > 9 }.count()","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206328,"user_id":null,"body":"fun persistence(num: Int) : Int {\n    var counter = 0\n    var n: Int\n    var mul = num\n    while (mul >= 10) {\n        var temp = 1\n        while (mul > 0) {\n            n = mul % 10\n            temp *= n\n            mul \/= 10\n        }\n        mul = temp\n        counter++\n    }\n    return counter\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206329,"user_id":null,"body":"fun persistence(num: Int): Int =\n    if (num < 10) 0 else 1 + persistence(num.toString().map { it - '0' }.reduce(Int::times))\n\nval zeroAscii = '0'.toInt()  \/\/ fixing the bug in tests","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206330,"user_id":null,"body":"tailrec fun persistence(num: Int, counter: Int = 0): Int =\n    if (num < 10) counter\n    else persistence(num.toString().map(Character::getNumericValue).reduce(Int::times), counter+1)\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206331,"user_id":null,"body":"fun persistence(input: Int) : Int {\n    var ans = 0\n    var num = input\n    while (num >= 10) {\n        var temp = 1\n        while (num != 0) {\n            temp *= num % 10\n            num = num \/ 10\n            println(num)\n        }\n        num = temp\n        ans += 1\n    }\n    return ans\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206332,"user_id":null,"body":"fun persistence(num: Int) : Int {\n    return num.toString()\n            .also { if (it.length == 1) return 0 }\n            .fold(1) { acc, c -> acc * c.toString().toInt() }\n            .let { persistence(it) + 1 }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206333,"user_id":null,"body":"tailrec fun persistence(num: Int, count:Int = 0) : Int {\n        if(num < 10) return count\n        val product  = num.toString().fold(1) {acc, i -> acc * i.toString().toInt()}\n        return persistence(product, count + 1)\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206334,"user_id":null,"body":"fun persistence(num: Int) : Int {\n    var result = num.toString()\n    var count = 0\n\n    while (result.length > 1) {\n        result = result.toCharArray()\n            .map(Character::getNumericValue)\n            .reduce{ acc, next -> acc * next }\n            .toString()\n        count += 1\n    }\n\n    return count\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206335,"user_id":null,"body":"fun persistence(num: Int) = generateSequence(num) {\n    it.toString().chunked(1).fold(1) { acc, value -> acc * value.toInt() }\n}.takeWhile { it > 9 }.count()\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206336,"user_id":null,"body":"fun persistence(num: Int) : Int {\n    var counter = 0\n    var str = num.toString()\n    while (str.length > 1){\n        str = str.fold(1){acc, c -> acc * c.toString().toInt()}.toString()\n        counter++\n    }\n    return counter\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"55c6126177c9441a570000cc":[{"id":206337,"user_id":null,"body":"package weight\n\nfun order_weight(i: String) = i.split(' ').sortedWith(compareBy({ it.sumBy { it - '0' } }, { it })).joinToString(\" \")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206338,"user_id":null,"body":"package weight\n\nfun order_weight(string:String):String {\n        return string.split(\" \")\n                .sortedWith(compareBy<String>{ it.toCharArray().map(Char::toString).map(String::toInt).sum() }.thenBy{ it })\n                .joinToString(\" \")\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206339,"user_id":null,"body":"package weight\n\nfun order_weight(string:String): String =\n    string.split(\" \").sorted().sortedBy { it.map { it.toString().toInt() }.sum() }.joinToString(\" \")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206340,"user_id":null,"body":"package weight\n\nfun order_weight(s: String) = (\"\\\\d+\").toRegex().findAll(s).map { it.value }\n    .sortedWith(compareBy<String> { it.map(Character::getNumericValue).sum() }.thenBy { it })\n    .joinToString(\" \")\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206341,"user_id":null,"body":"package weight\n\nfun order_weight(string:String):String {\n    \n    val list = mutableListOf<Pair<Int, String>>()\n    string.split(\" \").forEach { fat -> list.add(fat.sumBy { Integer.valueOf(it.toString()) } to fat) }\n    return list.sortedWith(Comparator { o1, o2 ->\n        if (o1.first == o2.first) {\n            o1.second.compareTo(o2.second)\n        } else\n            o1.first.compareTo(o2.first)\n    })\n        .map { it.second }\n        .joinToString(separator = \" \") { it }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206342,"user_id":null,"body":"package weight\n\nfun order_weight(string: String): String {\n    return string.split(\" \")\n        .map { it to it.toCharArray().foldRight(0) { nextChar, sum -> nextChar.toString().toInt() + sum } }\n        .sortedWith(Comparator { o1, o2 ->\n            if (o1.second > o2.second) {\n                1\n            } else if (o1.second == o2.second) {\n                o1.first.compareTo(o2.first)\n            } else {\n                -1\n            }\n        })\n        .joinToString(\" \") { it.first }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206343,"user_id":null,"body":"package weight\n\nfun order_weight(string:String):String =\n    string\n        .split(\" \")\n        .sorted()\n        .sortedBy { word -> word.map { it.digitToInt() }.sum() }\n        .joinToString(\" \")\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206344,"user_id":null,"body":"package weight\n\nfun order_weight(string: String): String = string\n        .trim()\n        .split(\" \")\n        .sortedWith(compareBy ({ value -> value.map { it.code - '0'.code }.sum() }, { it }))\n        .filter { it.isNotBlank() }\n        .joinToString(\" \")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206345,"user_id":null,"body":"package weight\n\nfun order_weight(string: String): String = string\n    .split(\" \")\n    .map { it to it.map { i -> \"$i\".toDouble() }.sum() }\n    .sortedBy { it.first }\n    .sortedBy { it.second }\n    .joinToString(\" \") { it.first }\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206346,"user_id":null,"body":"package weight\n\nclass NumberStringWeight(val numberString: String) : Comparable<NumberStringWeight> {\n    private val weight: Int = numberString.sumOf { it.digitToInt() }\n\n    override fun compareTo(other: NumberStringWeight): Int {\n        return compareBy<NumberStringWeight> { it.weight }\n            .thenBy { it.numberString }\n            .compare(this, other)\n    }\n}\n\nfun order_weight(string: String): String {\n    return string.split(\" \")\n        .map { NumberStringWeight(it) }\n        .sorted()\n        .joinToString(\" \") { it.numberString }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"55cbc3586671f6aa070000fb":[{"id":206347,"user_id":527,"body":"fun checkForFactor(base: Int, factor: Int) = base % factor == 0","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206348,"user_id":null,"body":"fun checkForFactor(base: Int, factor: Int) = (base%factor).equals(0)\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206349,"user_id":76,"body":"fun checkForFactor(base: Int, factor: Int): Boolean {\n    return base % factor == 0\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206350,"user_id":null,"body":"fun checkForFactor(base: Int, factor: Int): Boolean {\n    return if (base == 0) false else base%factor == 0\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206351,"user_id":null,"body":"\/\/ fun checkForFactor(base: Int, factor: Int) = base % factor == 0\nfun checkForFactor(base: Int, factor: Int) = (base%factor).equals(0)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206352,"user_id":null,"body":"fun checkForFactor(base: Int, factor: Int): Boolean {\n    val result: Int = base \/ factor;\n    return result * factor == base;\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206353,"user_id":null,"body":"fun checkForFactor(base: Int, factor: Int): Boolean = if (base % factor != 0) false else true","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206354,"user_id":null,"body":"fun checkForFactor(base: Int, factor: Int): Boolean {\n    return (base \/ factor).toDouble() == 1.0 * base \/ factor\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206355,"user_id":null,"body":"fun checkForFactor(base: Int, factor: Int): Boolean = base % factor <= 0","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206356,"user_id":null,"body":"fun checkForFactor(base: Int, factor: Int): Boolean {\n    var bol = true\n    if(base % factor == 0){\n        bol = true\n    }\n    else{\n        bol = false\n    }\n    return bol\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"55d24f55d7dd296eb9000030":[{"id":206357,"user_id":null,"body":"object GrassHopper {\n  fun summation(n: Int) = (1..n).sum()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206358,"user_id":277,"body":"object GrassHopper {\n  fun summation(n:Int):Int {\n    return n * (n + 1) \/ 2\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206359,"user_id":null,"body":"object GrassHopper {\n  fun summation(n:Int):Int {\n    var sum = 0\n    for (s in 1..n) {\n        sum += s\n    }\n    return sum\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206360,"user_id":null,"body":"object GrassHopper {\n    fun summation(n: Int) = n.downTo(0).reduce { acc, i -> acc + i }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206361,"user_id":null,"body":"object GrassHopper {\n    fun summation(n: Int) = Array(n+1){ it }.sum()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206362,"user_id":null,"body":"object GrassHopper {\n  fun summation(n:Int):Int {\n    return if (n == 0) 0 else summation(n - 1) + n\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206363,"user_id":null,"body":"object GrassHopper {\n  fun summation(n:Int):Int {\n      if (n == 0) return 0\n      else return n + summation(n - 1)\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206364,"user_id":null,"body":"object GrassHopper {\n    fun summation(n:Int) = (n * (n+1)).div(2)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206365,"user_id":null,"body":"object GrassHopper {\n  fun summation(n:Int) = 0.rangeTo(n).sum()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206366,"user_id":null,"body":"object GrassHopper {\n  fun summation(n:Int):Int {\n    return (n downTo 1).sum()\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"55e2adece53b4cdcb900006c":[{"id":206367,"user_id":null,"body":"package tortoise\n\nfun race(v1:Int, v2:Int, g:Int):IntArray {\n    return if (v1 >= v2) {\n        intArrayOf()\n    } else {\n        val s  = (3600 * g) \/ (v2 - v1)\n        intArrayOf( s\/3600, s\/60%60, s%60 )\n    }\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206368,"user_id":null,"body":"package tortoise\n\nimport kotlin.math.absoluteValue\n\nfun race(v1:Int, v2:Int, g:Int):IntArray {\n    return if (v1 >= v2)\n        intArrayOf()\n    else {\n        val speedDifference = v2 - v1\n        val timeToCatch = (g \/ speedDifference.toDouble() * 3600).toInt()        \n\n        val hoursToCatch = timeToCatch \/ 3600\n        val minutesToCatch = (timeToCatch - hoursToCatch*3600) \/ 60\n        val secondsToCatch = timeToCatch - hoursToCatch*3600 - minutesToCatch*60\n\n        intArrayOf(hoursToCatch, minutesToCatch, secondsToCatch)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206369,"user_id":null,"body":"package tortoise\n\n\/\/ return [] if v1 >= v2\nfun race(v1:Int, v2:Int, g:Int):IntArray {\n    return if(v1 >= v2)  {\n      intArrayOf()\n    } else {\n      val time = g * 60 * 60 \/ ( v2 - v1)\n      intArrayOf(time \/ 3600, time  \/ 60 % 60, time % 60)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206370,"user_id":null,"body":"package tortoise\n\nfun race(v1:Int, v2:Int, g:Int) = if (v1>v2) intArrayOf() else intArrayOf(g\/(v2-v1),60*g\/(v2-v1)%60,3600*g\/(v2-v1)%60)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206371,"user_id":null,"body":"package tortoise\n\n\/\/ return [] if v1 >= v2\nfun race(v1:Int, v2:Int, g:Int):IntArray {\n  val catchUpSpeed = v2-v1\n  return if (catchUpSpeed <= 0) intArrayOf() else format((g.toDouble()\/catchUpSpeed.toDouble()*60*60).toInt())\n}\n\nfun format(seconds: Int, minutes: Int = seconds\/60, hours: Int = minutes\/60) = intArrayOf(hours,minutes%60,seconds%60)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206372,"user_id":null,"body":"package tortoise\n\nfun makePair(x: Int) = Pair(x%60, x\/60)\n\nfun race(v1:Int, v2:Int, g:Int) =\n    if (v1 >= v2) intArrayOf()\n    else generateSequence(makePair(60*60*g\/(v2-v1))) { makePair(it.second) }.map { it.first }.take(3).toList().reversed().toIntArray()\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206373,"user_id":null,"body":"package tortoise\n\nimport kotlin.math.floor\nimport kotlin.math.abs\n\/\/ return [] if v1 >= v2\nfun race(v1:Int, v2:Int, g:Int):IntArray {\n    if (v1>= v2){\n        return intArrayOf()\n    }\n    var dA = 0.0\n    var dB = -g.toDouble()\n    var vA = v1.toDouble()\n    var vB = v2.toDouble()\n    \/*\n    dA + v1*t = (db - g) + v2 * t\n    -(v2 * t) + (v1* t) = (db - g) - dA \n    t(-v2 + v1) = (db - g) - dA \/ (-v2 + v1)\n    t = db  - dA \/ -v2 + v1\n    *\/\n    \n    var rounded = abs((dB - dA) \/ (-vA + vB) * 60.0)\n\n    var hours = floor(rounded \/ 60).toInt()\n    var minutes = floor(rounded % 60).toInt()\n    var seconds = floor((rounded % 60) % 1 * 60).toInt()\n\n    return intArrayOf(hours, minutes, seconds)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206374,"user_id":null,"body":"package tortoise\n\n\/\/ return [] if v1 >= v2\n    fun race(v1:Int, v2:Int, g:Int):IntArray {\n        val time = (g*3600\/(v2 - v1))\n        if(v1 > v2 ) return intArrayOf()\n        return intArrayOf((time\/3600).toInt(), ((time%3600)\/60).toInt(), (time%60).toInt())\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206375,"user_id":null,"body":"package tortoise\n\n\/\/ return [] if v1 >= v2\nfun race(v1:Int, v2:Int, g:Int):IntArray {\n    if(v1 >= v2) return intArrayOf()\n    var sec = (g * 3600) \/ (v2 - v1)\n    return intArrayOf(sec\/3600, (sec\/60)%60, sec % 60)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206376,"user_id":null,"body":"package tortoise\n\nfun race(v1: Int, v2: Int, g: Int): IntArray {\n if (v1 > v2) return intArrayOf()\n    val time = (g.toDouble() \/ (v2 - v1).toDouble()) * 60.0 * 60.0\n    val hours = (time \/ 3600).toInt()\n    val minutes = ((time \/ 60) % 60).toInt()\n    val seconds = (time % 60).toInt()\n\n    return intArrayOf(\n        hours, minutes, seconds\n    )\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"55e6f5e58f7817808e00002e":[{"id":206377,"user_id":null,"body":"package divseven\n\nfun seven(n: Long, i: Long = 0): LongArray =\n    if (n > 99) seven(n \/ 10 - n % 10 * 2, i + 1)\n    else longArrayOf(n, i)","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206378,"user_id":null,"body":"package divseven\n\n\nfun seven(n: Long): LongArray {\n    var m = n\n    var count = 0L\n    while (m  > 99) {\n        m = (m \/ 10) - 2 * (m % 10)\n        count++\n    }\n    return longArrayOf(m, count)\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206379,"user_id":null,"body":"package divseven\n\nfun seven(n: Long): LongArray = if (n < 100) longArrayOf(n, 0) else seven(n \/ 10 - n % 10 * 2).also { it[1]++ }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206380,"user_id":null,"body":"package divseven\n\nfun seven(n:Long)= with(generateSequence(n){it \/ 10 - (it % 10) * 2})\n    {longArrayOf(\n        find { it < 99 } ?: 0,\n        takeWhile { it > 99 }.count().toLong()\n    )}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206381,"user_id":null,"body":"package divseven\n\nfun seven(n:Long):LongArray {\n    return when {\n        n < 100 -> longArrayOf(n, 0)\n        else -> {\n            val save = seven((n \/ 10) - (2* (n % 10)))\n            longArrayOf(save.first(), save.last() + 1)\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206382,"user_id":null,"body":"package divseven\n\nfun seven(n:Long):LongArray {\n    tailrec fun sevenRecursive(steps: Long, number: Long):LongArray = when {\n        number < 100 -> longArrayOf(number, steps)\n        else -> {\n            val head = number \/ 10\n            val tail = (number - head*10) * 2\n            val res = head - tail\n            sevenRecursive(steps+1, res)\n        }\n    }\n    \n    return sevenRecursive(0L, n)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206383,"user_id":null,"body":"package divseven\n\nfun seven(n:Long):LongArray {\n    var stepValue = n\n    var numberOfSteps = 0L\n\n    while (stepValue \/ 10 >= 10) {\n        stepValue = stepValue \/ 10 - ((stepValue % 10) * 2)\n        numberOfSteps++\n    } \n    \n    return longArrayOf(stepValue, numberOfSteps)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206384,"user_id":null,"body":"package divseven\n\nfun seven(n:Long):LongArray {\n    var a= n\n    var c = 0\n    for(i in 1..n.toString().length-2)\n    {\n        if (a>99)\n        {\n            c++\n        a = a\/10-2*(a%10);\n    }\n        }\n    return longArrayOf(a,c.toLong())\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206385,"user_id":null,"body":"package divseven\n\nfun seven(n: Long): LongArray = when {\n    n < 100 -> longArrayOf(n, 0)\n    else -> {\n        val x = n \/ 10\n        val y = n % 10\n        \n        seven(x - 2 * y).apply {\n            this[1] = this[1] + 1\n        }\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206386,"user_id":492,"body":"package divseven\n\nfun seven(n:Long):LongArray {\n    var m = n\n    var cnt = 0\n    while (m > 99)\n    {\n      val a0 = m % 10\n      m = (m - a0) \/ 10 - 2 * a0\n      cnt++\n    }\n    return longArrayOf(m, cnt.toLong())\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"55e7280b40e1c4a06d0000aa":[{"id":206387,"user_id":null,"body":"package besttravel\n\nfun choose_best_sum(t:Int, k:Int, ls:List<Int>):Int {\n    fun calcBest(startFrom: Int, accumulated: Int, k: Int): Int {\n        if (ls.size - startFrom < k) return -1\n        if (accumulated > t) return -1\n        if (k == 0) return accumulated\n        return calcBest(startFrom + 1, accumulated + ls[startFrom], k - 1)\n            .coerceAtLeast(calcBest(startFrom + 1, accumulated, k))\n    }\n    return calcBest(0, 0, k)\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206388,"user_id":null,"body":"package besttravel\n\nfun choose_best_sum(t:Int, k:Int, ls:List<Int>, n:Int = 0, d:Int = 0):Int {\n  if (k == 0 && d <= t) return d\n  if (d > t || n >= ls.size) return -1\n  return maxOf(choose_best_sum(t, k - 1, ls, n + 1, d + ls[n]), choose_best_sum(t, k, ls, n + 1, d))\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206389,"user_id":null,"body":"package besttravel\n\nfun <T> List<T>.combinations(n: Int): List<List<T>> =\n    this.foldIndexed(listOf())\n    { i, acc, e ->\n        acc + if (n > 1) {\n            this.drop(i + 1)\n                .combinations(n - 1)\n                .map { it + e }\n        } else listOf(listOf(e))\n    }\n\nfun choose_best_sum(t:Int, k:Int, ls:List<Int>):Int {\n    if(k > ls.size) return -1\n    if(k == ls.size) return ls.sum().let { if (it <= t) it else -1 }\n    return ls.combinations(k)\n        .map(List<Int>::sum)\n        .filter { it <= t }.max() ?: -1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206390,"user_id":null,"body":"package besttravel\n\nfun choose_best_sum(t:Int, k:Int, ls:List<Int>):Int {\n    val result = combinations(t, k, ls, 0)\n    if (result > 0) {\n        return result\n    }\n    return -1\n}\n\nfun combinations(t:Int, k:Int, ls:List<Int>, i:Int):Int {\n    if (k == 0 && t >= 0) {\n        return 0\n    } else if (k < 0 || i>= ls.size) {\n        return Integer.MIN_VALUE\n    } else  {\n        return Integer.max(combinations(t, k, ls, i + 1), ls.get(i) + combinations(t - ls.get(i), k - 1, ls, i + 1))\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206391,"user_id":null,"body":"package besttravel\n\nfun choose_best_sum(t: Int, k: Int, ls: List<Int>, array: IntArray = IntArray(k), start: Int = 0, end: Int = ls.size - 1, currentIndex: Int = 0, sum: HashSet<Int> = hashSetOf()): Int {\n    if (currentIndex == k) {\n        if (array.sum() <= t) sum.add(array.sum())\n        return sum.max() ?: -1\n    }\n\n    for (i in start..end) {\n        array[currentIndex] = ls[i]\n        choose_best_sum(t, k, ls, array, i + 1, end, currentIndex + 1, sum)\n    }\n    return sum.max() ?: -1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206392,"user_id":492,"body":"package besttravel\n\nimport java.util.ArrayList\nimport java.util.Arrays\n\nfun choose_best_sum(t:Int, k:Int, ls:List<Int>):Int {\n    var result = -1\n    for (i in ls.indices)\n    {\n      if (ls.get(i) <= t)\n      {\n        if (k == 1)\n        {\n          result = Math.max(result, ls.get(i))\n        }\n        else\n        {\n          val temp = choose_best_sum(t - ls.get(i), k - 1, ls.subList(i + 1, ls.size))\n          if (temp != -1)\n          {\n            result = Math.max(result, ls.get(i) + temp)\n          }\n        }\n      }\n    }\n    if (result < 0) return -1\n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206393,"user_id":null,"body":"package besttravel\n\nfun choose_best_sum(t:Int, k:Int, ls:List<Int>, traveled: Int = 0):Int {\n  if(k == 0) return if(traveled <= t) traveled else -1\n  return ls.mapIndexed { i, d -> choose_best_sum(t, k-1, ls.subList(i+1, ls.size), traveled + d) }.max() ?: -1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206394,"user_id":null,"body":"package besttravel\n\nfun choose_best_sum(t:Int, k:Int, ls:List<Int>):Int {\n    return generateSequence(ls.mapIndexed{i, n -> i to listOf(n)}) {\n        it.flatMap{p -> ls.drop(p.first+1).mapIndexed{i, n -> (p.first + i + 1) to (p.second + n)}}\n    }.take(k)\n    .last()\n    .map{it.second.sum()}\n    .filter{it<=t}\n    .max() ?: -1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206395,"user_id":null,"body":"package besttravel\n\nfun choose_best_sum(t:Int, k:Int, ls:List<Int>):Int {\n    var maxDistance = t\n    var towns = k\n    var distances = ls\n    var sums = mutableListOf<Int>()\n\n    if(distances.size < k)\n        return -1\n\n    if(distances.size  == k){\n        return if(distances.sum() > maxDistance)\n            -1\n        else\n            distances.sum()\n    }\n\n    repeat(100000){\n        distances = distances.shuffled()\n        sums.add(distances.take(k).sum())\n    }\n\n    var result = -1\n\n    sums.sort()\n    sums.forEach {\n       if ( it <= maxDistance)\n           result = it\n    }\n\n    return result\n}\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206396,"user_id":null,"body":"package besttravel\n\nfun choose_best_sum(t: Int, k: Int, ls: List<Int>): Int {\n    fun loop(k: Int, ls: List<Int>, acc: Int): Int {\n        if (acc > t) return -1\n        if (k == 0) return acc\n        if (ls.size < k) return -1\n        return Math.max(\n            loop(k - 1, ls.slice(1..ls.lastIndex), acc + ls[0]),\n            loop(k, ls.slice(1..ls.lastIndex), acc)\n        )\n    }\n    return loop(k, ls, 0)\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"55e86e212fce2aae75000060":[{"id":206397,"user_id":492,"body":"package sqprod2sum\n\nimport java.util.ArrayList\nimport java.util.Arrays\nimport java.util.Collections\nimport java.util.Comparator\n\nfun prod2Sum(a:Long, b:Long, c:Long, d:Long):List<LongArray> {\n    val res = ArrayList<LongArray>()\n    val e1 = Math.abs(a * c + b * d)\n    val f1 = Math.abs(a * d - b * c)\n    val e2 = Math.abs(a * c - b * d)\n    val f2 = Math.abs(a * d + b * c)\n    if (((e1 == f2) && (f1 == e2)) || ((e1 == e2) && (f1 == f2)))\n    {\n      val cc = longArrayOf(Math.min(e1, f1), Math.max(e1, f1))\n      res.add(cc)\n    }\n    else\n    {\n      val cc = longArrayOf(Math.min(e1, f1), Math.max(e1, f1))\n      res.add(cc)\n      val dd = longArrayOf(Math.min(e2, f2), Math.max(e2, f2))\n      res.add(dd)\n    }\n    Collections.sort<LongArray>(res, object:Comparator<LongArray> {\n      public override fun compare(o1:LongArray, o2:LongArray):Int {\n        return (o1[0] - o2[0]).toInt()\n      }\n    })\n    return res\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206398,"user_id":null,"body":"package sqprod2sum\n\nimport kotlin.math.abs\n\nfun prod2Sum(a:Long, b:Long, c:Long, d:Long):List<LongArray> = mutableListOf<LongArray>().apply {\n        val ad = a * d\n        val bc = b * c\n        val ac = a * c\n        val bd = b * d\n\n        val firstArray = longArrayOf(ac + bd, abs(bc - ad)).sortedArray()\n        val secondArray = longArrayOf(ad + bc, abs(bd - ac)).sortedArray()\n\n        this.add(firstArray)\n        \n        if(firstArray[0] != secondArray[0] && firstArray[1] != secondArray[1]) {\n            this.add(secondArray)\n        }\n    }.sortedBy {\n        it.first()\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206399,"user_id":null,"body":"package sqprod2sum\n\nfun prod2Sum(a:Long, b:Long, c:Long, d:Long):List<LongArray> {\n    val list =listOf(listOf(a*c-b*d, a*d+b*c), listOf(a*d-b*c, a*c+b*d))\n    return list.map{ sub-> sub.map {it.coerceAtLeast(-it)}.sorted()}.toSet().sortedBy{it[0]}.map{it.toLongArray()}\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206400,"user_id":null,"body":"package sqprod2sum\nimport kotlin.math.abs\nimport kotlin.math.sqrt\n\nfun prod2Sum(a: Long, b: Long, c: Long, d: Long): List<LongArray> {\n    \n    val x = (a * a + b * b) * (c * c + d * d)\n    val s = sqrt(x.toDouble()).toInt() - 1\n\n    val p = listOf(\n        a * b - c * d,\n        a * b + c * d,\n        a * c - b * d,\n        a * c + b * d,\n        a * d - b * c,\n        a * d + b * c\n    ).map { abs(it) }\n\n    return (0..s).map { it.toDouble() }\n        .map { listOf(it, sqrt(x - it * it)) }\n        .filter { it[1].toLong().toDouble() == it[1] && p.contains(it[0].toLong()) && p.contains(it[1].toLong()) }\n        .map { it.sorted() }\n        .distinct()\n        .map { it.map { i -> i.toLong() }.toLongArray() }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206401,"user_id":null,"body":"package sqprod2sum\n\nfun prod2Sum(a:Long, b:Long, c:Long, d:Long) = listOf(Math.abs(a * c - b * d), a * c + b * d, Math.abs(a * d - b * c), a * d + b * c)\n        .sorted()\n        .run { mapIndexed{ idx, e -> drop(idx + 1).map{ Pair(e, it) } } }\n        .flatten()\n        .distinct()\n        .filter{ (e, f) -> (a * a + b * b) * (c * c + d * d) == e * e + f * f }\n        .map{ (e, f) -> longArrayOf(e, f) }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206402,"user_id":null,"body":"package sqprod2sum\n\nimport kotlin.math.abs\n\nfun prod2Sum(a: Long, b: Long, c: Long, d: Long): List<LongArray> {\n    val n = (a * a + b * b) * (c * c + d * d)\n    val x = listOf(a * b to c * d, a * c to b * d, a * d to b * c)\n        .flatMap { (x, y) -> listOf(x + y, abs(x - y)) }\n        .distinct()\n        .sorted()\n    val res = mutableListOf<LongArray>()\n    for (i in 0 until x.size - 1) {\n        for (j in i until x.size) {\n            if (x[i] * x[i] + x[j] * x[j] == n) res.add(longArrayOf(x[i], x[j]))\n        }\n    }\n    return res.sortedBy { it.first() }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206403,"user_id":null,"body":"package sqprod2sum\n\nfun prod2Sum(a:Long, b:Long, c:Long, d:Long):List<LongArray> {\n    val n = (a * a + b * b) * (c * c + d * d)\n    var res = mutableListOf<LongArray>()\n    val rt = Math.sqrt(n.toDouble()).toLong()\n    \n    for (e in 0L..rt) {\n        val f = Math.sqrt(n.toDouble() - Math.pow(e.toDouble(), 2.0)).toLong()\n        val a1 = longArrayOf(e, f)\n        if (f * f + e * e == n && !containsList(res, a1) && canBeDecomposed(e, f, a, b, c, d)) res.add(a1)\n    }\n    return res\n}\n\nfun canBeDecomposed(n1: Long, n2: Long, a: Long, b: Long, c: Long, d: Long): Boolean {\n    val combs = listOf(a * c - b * d, a * c + b * d, a * d - b * c, a * d + b * c)\n    return combs.any{ Math.abs(it) == n1 } && combs.any{ Math.abs(it) == n2 }\n}\n\nfun containsList(parent: List<LongArray>, child:LongArray): Boolean {\n    return parent.any{ (it[0] == child[0] && it[1] == child[1]) || (it[0] == child[1] && it[1] == child[0]) }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206404,"user_id":null,"body":"package sqprod2sum\n\nfun prod2Sum(a:Long, b:Long, c:Long, d:Long):List<LongArray> {\n    \n    val (e1, f1) = longArrayOf(a*c + b*d, abs(a*d - b*c))\n    val (e2, f2) = longArrayOf(abs(a*c - b*d), a*d + b*c)\n    \n    return listOf(longArrayOf(e1, f1), longArrayOf(e2, f2))\n    \t.map { it.sortedArray() }\n        .sortedWith(Comparator {\n            (a, b), (c, d) -> when {\n                a < c -> -1\n                a > c -> 1\n                else -> when {\n                    b < d -> -1\n                    b > d -> 1\n                    else -> 0\n                }\n            }\n        })\n        .distinctBy { (a, b) -> \"$a:$b\" }\n}\n\nfun abs(value: Long) = if (value > 0) value else -value\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206405,"user_id":1703,"body":"package sqprod2sum\n  fun prod2Sum(a1:Long, b1:Long, c1:Long, d1:Long):List<LongArray> {\n        var a = Math.abs(a1)\n        var b = Math.abs(b1)\n        var c = Math.abs(c1)\n        var d = Math.abs(d1)\n        var wyniki = arrayOf(\n            a * b + c * d, a * b - c * d, c * d - a * b, a * c + b * d,\n            a * c - b * d, b * d - a * c, a * d + b * c, a * d - b * c, b * c - a * d\n        )\n        var res = mutableListOf<LongArray>()\n        var n = ((a * a) + (b * b)) * ((c * c) + (d * d))\n        var pierwiastek = Math.sqrt(n * 1.0).toLong()\n        var granica = 1L\n           for (i in pierwiastek downTo granica) {\n            var check = Math.ceil(Math.sqrt((n - (i * i)) * 1.0)).toLong()\n            var ele = (i * i + check * check)\n            if (ele == n) {\n                if (check <= i && wyniki.any { it == check } && wyniki.any { it == i }) res.add(\n                    arrayOf(check, i).toLongArray()\n                )\n            }\n        }\n        return res.toList()\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206406,"user_id":null,"body":"package sqprod2sum\n\nfun prod2Sum(a: Long, b: Long, c: Long, d: Long): List<LongArray> = findPairs(listOf(a, b, c, d))\n\nfun findPairs(list: List<Long>): List<LongArray> {\n    val transList = allSumsDiffs(list)\n    val result = mutableListOf<List<Long>>()\n    for (i in 0 until transList.lastIndex) {\n        for (j in i + 1..transList.lastIndex) {\n            if (transList[i].square() + transList[j].square() == total(list)) {\n                result.add(longArrayOf(transList[i], transList[j]).sorted())\n            }\n        }\n    }\n    for (n in result.sortedBy { it.first() }.distinct()) print(n.toList())\n    return result.sortedBy { it.first() }.distinct().map { it.toLongArray() }\n}\n\nfun total(list: List<Long>) = (list[0].square() + list[1].square()) * (list[2].square() + list[3].square())\n\nfun allSumsDiffs(list: List<Long>): List<Long> {\n    val result = mutableListOf<Long>()\n    result.addAll(sdp(listOf(list[0], list[2], list[1], list[3])))\n    result.addAll(sdp(listOf(list[1], list[2], list[0], list[3])))\n    return result.toList()\n}\n\nfun sdp(list: List<Long>): List<Long> = listOf(\n    list[0] * list[1] + list[2] * list[3],\n    Math.abs(list[0] * list[1] - list[2] * list[3])\n)\n\nfun Long.square(): Long = this * this\n    \n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"55eeddff3f64c954c2000059":[{"id":206407,"user_id":null,"body":"fun sumConsecutives(s: List<Int>) = mutableListOf(s[0]).apply {\n    (1..s.lastIndex).forEach { if (s[it] == s[it - 1]) this[lastIndex] += s[it] else add(s[it]) }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206408,"user_id":null,"body":"fun sumConsecutives(s: List<Int>): List<Int> {\n    val result = arrayListOf<Int>()\n    var prev: Int? = null\n    s.forEach {\n        if (it != prev) result.add(it)\n        else result[result.lastIndex] += it\n        prev = it\n    }\n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206409,"user_id":null,"body":"fun sumConsecutives(s: List<Int>): List<Int> {\n    return if (s.isEmpty()) s else s.takeWhile { it == s[0] }.let { listOf(it.sum()) + sumConsecutives(s.drop(it.size)) }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206410,"user_id":null,"body":"fun sumConsecutives(s: List<Int>): List<Int> {\n    val result = mutableListOf<Int>();\n    var tmpSum = 0;\n\n    for ((i, n) in s.withIndex()) {\n        if (n.equals(s.getOrNull(i+1))) {\n            tmpSum = tmpSum + n;\n        } else {\n            result.add(tmpSum + n);\n            tmpSum = 0;\n        }\n    }\n    \n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206411,"user_id":null,"body":"fun sumConsecutives(s: List<Int>): List<Int> {\n    return if (s.size <= 1) s else sumConsecutives(s.dropLastWhile { it == s.last() }) + s.takeLastWhile { it == s.last() }.sum()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206412,"user_id":null,"body":"fun sumConsecutives(s: List<Int>) =\n    s.drop(1).foldIndexed(listOf(s[0])) { i, list, v -> if (s[i] == v) list.dropLast(1) + (list.last() + v) else list + v }\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206413,"user_id":null,"body":"fun sumConsecutives(s: List<Int>): List<Int> {\n    val res = mutableListOf<Int>()\n    var now = -1\n    \n    s.forEach {\n        if (it == now)\n            res[res.lastIndex] += it\n        else {\n            now = it\n            res.add(now)\n        }\n    }\n\n    return res\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206414,"user_id":null,"body":"fun sumConsecutives(s: List<Int>): List<Int> {\n    var checkList: List<Int> = s.toList()\n    var sCopy: MutableList<Int> = s.toMutableList()\n    var mainList: MutableList<Int> = mutableListOf()\n    var i = 0\n    while (i < checkList.size) {\n        var ret = checkList.get(i)\n        var addFlag = false\n        for (j in i+1 until sCopy.size) {\n            if(checkList.get(i)==sCopy.get(j)){\n                ret = ret + sCopy.get(j)\n                i = j \n            }else{\n                mainList.add(ret)\n                i = j-1\n                addFlag = true\n                break\n            }\n        }\n        if(!addFlag){\n            mainList.add(ret)\n        }        \n        i++\n    }\n    return mainList\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206415,"user_id":null,"body":"fun sumConsecutives(s: List<Int>): List<Int> {\n    val resultList: ArrayList<Int> = arrayListOf()\n    var previousNumber: Int? = null\n    var sum = 0\n    for (i in s.indices) {\n        if (previousNumber == null) {\n            previousNumber = s[i]\n            sum += s[i]\n            continue\n        }\n        if (i == s.lastIndex) {\n            if (s[i] == previousNumber) {\n                sum+=s[i]\n                resultList.add(sum)\n                break\n            } else {\n                resultList.add(sum)\n                sum = s[i]\n                resultList.add(sum)\n                break\n            }\n        }\n        if (s[i] == previousNumber) {\n            sum+=s[i]\n            previousNumber = s[i]\n        } else {\n            resultList.add(sum)\n            sum = s[i]\n            previousNumber = s[i]\n        }\n    }\n    return resultList\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206416,"user_id":null,"body":"fun sumConsecutives(s: List<Int>): List<Int> = s.foldIndexed(mutableListOf(), { index, acc, num -> acc.apply { if (index != 0 && s[index - 1] == num) set(lastIndex, acc[lastIndex] + num) else add(num)} })","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"55efecb8680f47654c000095":[{"id":206417,"user_id":527,"body":"package hero\n\nfun intRac(n: Long, guess: Long): Long {\n    tailrec fun iter(i: Long, guess: Long): Long {\n        val nextGuess = (guess + n \/ guess) \/ 2\n        return if (guess == nextGuess) i else iter(i + 1, nextGuess)\n    }\n    return iter(1, guess)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206418,"user_id":null,"body":"package hero\nfun intRac(n:Long, guess:Long):Long {\n  val newGuess = (n \/ guess + guess) \/ 2\n  if( newGuess == guess ) return(1)\n  return intRac(n, newGuess)+1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206419,"user_id":492,"body":"package hero\n\nfun intRac(n:Long, guess:Long):Long {\n    var x = guess\n    var cnt = 1\n    while (true)\n    {\n      val newx = (x + n \/ x) \/ 2\n      if (Math.abs(newx - x) < 1)\n      return cnt.toLong()\n      x = newx\n      cnt++\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206420,"user_id":null,"body":"package hero\n\nfun intRac(n:Long, guess:Long) = ((guess + n \/ guess) \/ 2).run {\n    generateSequence(guess to this){it.second to (it.second + n\/ it.second) \/ 2 }\n        .takeWhile{ it.first != it.second}\n        .count() + 1L\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206421,"user_id":null,"body":"package hero\n\nfun intRac(n:Long, guess:Long):Long {\n    var xNew = guess\n    var count = 0L\n    \n    do {\n        var xOld = xNew\n        xNew = (xOld + n \/ xOld) \/ 2\n        count++        \n    } while (Math.abs(xOld - xNew) >= 1)\n    \n    return count\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206422,"user_id":null,"body":"package hero\nimport kotlin.math.abs\n\nfun intRac(n:Long, guess:Long):Long {\n    var x: Long = guess\n    var prev_x: Long = x\n    val e: Long = 1L\n    var counter: Long = 0\n    do {\n        counter++\n        prev_x = x\n        x = (x + n \/ x) \/ 2\n    } while (abs(x-prev_x) >= e)\n    return counter\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206423,"user_id":492,"body":"package hero\n\nfun intRac(n:Long, guess:Long):Long {\n    var x = guess\n    var cnt = 1\n    while (true)\n    {\n      val newx = (x + n \/ x) \/ 2\n      if (Math.abs(newx - x) < 1)\n      return cnt.toLong()\n      x = newx\n      cnt++\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206424,"user_id":null,"body":"package hero\n\ntailrec fun intRac(n: Long, x: Long, i: Long = 1L): Long = ((x + n \/ x) \/ 2).let { if(x == it) i else intRac(n, it, i + 1) }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206425,"user_id":null,"body":"package hero\n\nfun intRac(n: Long, guess: Long): Long = intRacRec(n, guess, 1, 1)\n\nprivate tailrec fun intRacRec(n: Long, currentValue: Long, e: Long, count: Long): Long {\n    val nextValue = (currentValue + n \/ currentValue) \/ 2\n    return if (Math.abs(currentValue - nextValue) < e) count\n    else intRacRec(n, nextValue, e, count + 1)\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206426,"user_id":null,"body":"package hero\n\nfun intRac(n:Long, guess:Long):Long {\n    \n    var x: Long = guess\n    var xNew: Long = 0\n    var endReached: Boolean = false\n    var countLoop: Long = 0\n    \n    while(!endReached) {\n       xNew = (x + n \/ x) \/ 2\n       if (Math.abs(x - xNew) < 1) endReached = true   \/\/ e is set to 1 for this kata\n       x = xNew\n       countLoop += 1\n    } \n    \n    return countLoop   \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"55f3da49e83ca1ddae0000ad":[{"id":206427,"user_id":null,"body":"package voltank\n\nfun tankVol(h:Int, d:Int, vt:Int):Int {  \n    \/\/ radius is half diameter\n    val radius = d.toDouble()\/2\n    \/\/find tHeight = triangle height\n    val tHeight = radius - h\n    \/\/find small triangle width (point A to B)\n    val tWidth = Math.sqrt(Math.pow(radius, 2.0) - Math.pow(tHeight, 2.0))\n    \/\/ find the tank length\n    val tankLength = vt \/ (Math.PI * radius * radius)\n    \n    \/\/ \u03b8 can be find since cos(\u03b8) = tHeight \/ radius (hypotenusa) -- in rad\n    val \u03b8 = Math.acos(tHeight\/radius)\n    \/\/ \"pie\" volume ratio, pie = triangle + green one\n    val pieRatio = \u03b8 \/ (Math.PI)\n    \/\/ calculate volumes\n    val pieVolume = pieRatio * vt\n    val triangleVolume = tHeight * tWidth * tankLength\n    val greenVolume = pieVolume - triangleVolume\n    return greenVolume.toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206428,"user_id":null,"body":"package voltank\n\nimport kotlin.math.*\n\nfun tankVol(h:Int, d:Int, vt:Int):Int {\n    val r = d.toDouble() \/ 2\n    \n    val angle = 2 * acos(1 - h.toDouble() \/ r)\n\n    val s = 0.5 * (angle - sin(angle)) \/ PI\n\n    val v = floor(s * vt).toInt()\n    return v\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206429,"user_id":53,"body":"package voltank\nimport kotlin.math.floor\nimport kotlin.math.sin\nimport kotlin.math.acos\nimport kotlin.math.PI\n\nfun tankVol(h:Int, d:Int, vt:Int):Int {\n    val n = acos(1.0 - h.toFloat() \/ (d.toFloat() \/ 2.0)) * 2.0\n    val m = vt.toFloat() * (n - sin(n)) \/ (2.0 * PI)\n    return floor(m).toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206430,"user_id":492,"body":"package voltank\n\nfun tankVol(h:Int, d:Int, vt:Int):Int {\n    val cos = 1.0 - 2.0 * h \/ d\n    val theta = Math.acos(cos)\n    return (vt * (theta - Math.sin(theta) * cos) \/ Math.PI).toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206431,"user_id":null,"body":"package voltank\nimport kotlin.math.acos\nimport kotlin.math.PI\nimport kotlin.math.sin\n\nfun tankVol(h:Int, d:Int, vt:Int):Int {\n    val w = 4.0*vt\/(PI*d*d)\n    val theta = acos((d-2.0*h)\/d)    \n    return (w*(d*d*theta\/4 - d*d*sin(2*theta)\/8.0)).toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206432,"user_id":null,"body":"package voltank\n\nimport kotlin.math.acos\nimport kotlin.math.PI\nimport kotlin.math.sin\n\n\n\nfun tankVol(h:Int, d:Int, vt:Int):Int {\n    val w = 4.0*vt\/(PI*d*d)\n    \n    if(2*h==d) return vt\/2\n    if(2*h<d){\n \t\tval theta = acos((d-2.0*h)\/d)\n        return (w*(d*d*theta\/4 - d*d*sin(2*theta)\/8.0)).toInt()\n    }else{\n    \tval theta = acos((d-2.0*h)\/d)\n        return (w*(d*d*theta\/4 +d*d*sin(2*PI-2*theta)\/8.0)).toInt()        \n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206433,"user_id":null,"body":"package voltank\nimport kotlin.math.*\nfun tankVol(h:Int, d:Int, vt:Int):Int {\n   var q: Double\n   var sinq:Double\n   var s:Double\n   var Vc:Double\n   q=acos(2*((1-2*h.toDouble()\/d.toDouble()).pow(2))-1)\n   sinq=sqrt(1-(cos(q).pow(2)))\n   s=d.toDouble().pow(2)*(q-sinq)\/8\n   if (h<=d\/2) {\n   Vc=4*vt.toDouble()*s\/(PI*(d.toDouble().pow(2)))\n   } else\n   Vc=vt.toDouble()-4*vt.toDouble()*s\/(PI*(d.toDouble().pow(2)))\n   return Vc.toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206434,"user_id":null,"body":"package voltank\n\nfun tankVol(h:Int, d:Int, vt:Int):Int {\n    val r = d.toDouble()\/2\n    val hNew = if(h <= r) h else d - h\n    val isInverted = hNew != h\n    var theta = Math.acos((r-hNew)\/r)\n    val areaTot = Math.PI * r*r\n    val areaArc = theta\/Math.PI * areaTot\n    val areaSub = Math.sin(theta) * r * Math.abs(r-hNew)\n    return if(isInverted)\n        (vt * (areaTot - areaArc + areaSub) \/ areaTot).toInt()\n    else\n        (vt * (areaArc - areaSub) \/ areaTot).toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206435,"user_id":null,"body":"package voltank\n\nfun tankVol(h:Int, d:Int, vt:Int): Int {\n\n    val R: Double = d \/ 2.0\n    val H: Double = h.toDouble()\n\n    var res: Double = 0.0\n    var trigArea: Double = 0.0\n    var sectorArea: Double = 0.0\n\n    var length: Double = vt\/(Math.PI * Math.pow(R, 2.0))\n    val b: Double = Math.sqrt(Math.pow(R, 2.0) - Math.pow((R - H), 2.0)) * 2\n    val alpha: Double = Math.asin((b\/2)\/R) * 2 \/\/ In radians\n\n    if (h <= R) {\n        trigArea = (R - h) * b \/ 2\n\n        sectorArea = Math.pow(R, 2.0) * alpha \/ 2\n\n        res = sectorArea - trigArea\n        res *= length\n    } else {\n        trigArea = (h - R) * b \/ 2\n\n        sectorArea = Math.pow(R, 2.0) * alpha \/ 2\n\n        res = Math.PI * Math.pow(R, 2.0) - (sectorArea - trigArea)\n        res *= length\n    }\n\n    return res.toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206436,"user_id":null,"body":"package voltank\n\nimport kotlin.math.acos\nimport kotlin.math.tan\n\nconst val PI : Float = 3.14159f\n\nfun tankVol(h:Int, d:Int, vt:Int):Int {\n    val radius = d.toFloat() \/ 2\n    val triaHeight = radius - h\n    val angle = acos(triaHeight \/ radius)\n    val triaBase = 2 * triaHeight * tan(angle)\n    val length= vt.toFloat() \/ (PI * radius * radius)\n    val finArea = angle * radius * radius - 0.5 * triaBase * triaHeight\n    val finVolume = length * finArea\n    return finVolume.toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"55f9bca8ecaa9eac7100004a":[{"id":206437,"user_id":null,"body":"fun past(h: Int, m: Int, s: Int) = ((h * 60 + m) * 60 + s) * 1000","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206438,"user_id":null,"body":"fun past(h: Int, m: Int, s: Int): Int {\n    \n    var hourToMilliseconds = h * 3600000\n    var minuteToMilliseconds = m * 60000\n    var secondsToMilliseconds = s * 1000\n    \n    return (hourToMilliseconds + minuteToMilliseconds + secondsToMilliseconds)\n}","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206439,"user_id":null,"body":"fun past(h: Int, m: Int, s: Int): Int {\n    return h * 3600000 + m * 60000 + s * 1000\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206440,"user_id":null,"body":"import java.util.concurrent.TimeUnit.*\n\nfun past(h: Int, m: Int, s: Int) =\n    (HOURS.toMillis(h.toLong()) +\n            MINUTES.toMillis(m.toLong()) +\n            SECONDS.toMillis(s.toLong())).toInt()\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206441,"user_id":null,"body":"fun past(hour: Int, minute: Int, second: Int): Int = (second * 1000) + (minute * 60_000) + (hour * 3_600_000)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206442,"user_id":null,"body":"fun past(h: Int, m: Int, s: Int): Int {\n    return if (h in 0..23 && m in 0..59 && s in 0..59) {\n            (h * 3600000) + (m * 60000) + (s * 1000)\n        } else {\n            -1\n        }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206443,"user_id":null,"body":"fun past(h: Int, m: Int, s: Int) = (h * 3600 + m * 60 + s) * 1000","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206444,"user_id":null,"body":"fun past(h: Int, m: Int, s: Int) = h*3600000 + m*60000 + s*1000\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206445,"user_id":null,"body":"fun past(h: Int, m: Int, s: Int): Int = 1000*(60*(60*h + m)+s)\n    \n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206446,"user_id":null,"body":"fun past(h: Int, m: Int, s: Int) = 1000 * (60 * (h * 60 + m) + s)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"55fd2d567d94ac3bc9000064":[{"id":206447,"user_id":null,"body":"fun row_sum_odd_numbers(n: Int) = n * n * n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206448,"user_id":645,"body":"fun row_sum_odd_numbers(n: Int): Int = n * n * n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206449,"user_id":null,"body":"fun row_sum_odd_numbers(n: Int): Int {\n    val firstOddNumberOfRow = (0 until n).sum() + 1\n    return (firstOddNumberOfRow until  firstOddNumberOfRow + n).map { 2 * it - 1 }.sum()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206450,"user_id":null,"body":"fun row_sum_odd_numbers(n: Int): Int = (n * n - (n - 1)..n * n + (n - 1)).filter { it % 2 == 1 }.sum()\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206451,"user_id":null,"body":"fun row_sum_odd_numbers(n: Int) = generateSequence(1 + n * (n - 1)) { it + 2 }.take(n).sum()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206452,"user_id":null,"body":"fun row_sum_odd_numbers(n:Int):Int {\n    var num = n*(n-1)+1\n    var res = 0\n    \n    for(i in 1..n){\n         res+=num\n         num+=2\n        }\n    return res\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206453,"user_id":null,"body":"fun row_sum_odd_numbers(n: Int): Int {\n    val result = Math.pow(n.toDouble(), 3.0)\n    return result.toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206454,"user_id":null,"body":"import kotlin.math.pow\n\nfun Int.pow(x: Int) = this.toDouble().pow(x).toInt()\n\nfun row_sum_odd_numbers(n: Int): Int = n.pow(3)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206455,"user_id":null,"body":"fun row_sum_odd_numbers(n: Int) = (1..n * (n + 1)).filter { it % 2 != 0 }.takeLast(n).sum()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206456,"user_id":null,"body":"fun row_sum_odd_numbers(n: Int): Int {\n    val first = n * (n - 1) + 1\n    val last = n * n + (n - 1)\n    return (first..last step 2).sum()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5613d06cee1e7da6d5000055":[{"id":206457,"user_id":null,"body":"package step\n\nfun step(g:Int, m:Long, n:Long):LongArray {\n    var list= LongArray(2)\n    for(i in m..n)\n        if(isPrime(i)&&isPrime(i+g.toLong())&&(i+g) in m..n){\n           list.set(0,i); list.set(1,i+g);return list}\n     return longArrayOf()\n}\nfun isPrime(num:Long):Boolean{\n    for(i in 2..1000)\n         if(num.toInt()!=i&&num.rem(i).toInt()==0) return false\n    return true\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206458,"user_id":null,"body":"package step\n\nfun step(g:Int, m:Long, n:Long) = \n  (m..n-g).find { it.toBigInteger().isProbablePrime(10) && (it + g).toBigInteger().isProbablePrime(10) }?.let { longArrayOf( it, it + g) } ?: LongArray(0)\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206459,"user_id":null,"body":"package step\nimport java.util.Arrays\n\nfun step(g:Int, m:Long, n:Long):LongArray = (m..n)\n    .firstOrNull{it.isPrime() && (it+g.toLong()).isPrime()}\n    ?.let{longArrayOf(it,it+g.toLong())} ?: longArrayOf()\n    \nfun Long.isPrime() = (2L..Math.sqrt(this.toDouble()).toLong()).none{this%it==0L}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206460,"user_id":null,"body":"package step\n\nimport java.util.Arrays\n\n\/\/ if these g-steps prime numbers don't exist return []\nfun step(step:Int, start:Long, end:Long):LongArray {\n    for (digit in start..end) {\n        if (isPrimeNumber(digit) &&\n            isPrimeNumber(digit + step)\n        ) {\n            return longArrayOf(digit, digit + step)\n        }\n    }\n    return longArrayOf()\n}\n\n\nfun isPrimeNumber(number: Long): Boolean {\n    if (number % 2 == 0L) return false\n    for (digit in 3 until number step 2) {\n        if (number % digit == 0L) return false\n    }\n    return true\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206461,"user_id":null,"body":"package step\nimport kotlin.math.*\n\nfun step(g:Int, m:Long, n:Long): LongArray =\n    generateSequence(m) { it + 1 }\n        .takeWhile { it <= n}\n        .filter { (2L..sqrt(it.toDouble()).toLong()).none { i -> it % i == 0L } &&\n                (2L..sqrt((it + g).toDouble()).toLong()).none { i -> (it + g) % i == 0L }\n        }.firstOrNull()?.let {\n            longArrayOf(it, it + g.toLong())\n        } ?: LongArray(0)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206462,"user_id":492,"body":"package step\n\nimport java.util.Arrays\n\nprivate fun prime(n:Long):Boolean {\n    if (n == 2L)\n    \treturn true\n    else if ((n < 2) || (n % 2 == 0L))\n    \treturn false\n    else\n    {\n      var i:Long = 3\n      while (i <= Math.sqrt(n.toDouble()))\n      {\n        if (n % i == 0L) return false\n        ++i\n      }\n      return true\n    }\n}\n\/\/ if these g-steps prime numbers don't exist return []\nfun step(g:Int, m:Long, n:Long):LongArray {\n    var res = LongArray(2)\n    var i = m\n    while (i <= n - g)\n    {\n      if (prime(i) && prime(i + g))\n      {\n        res[0] = i\n        res[1] = i + g\n        return res\n      }\n      i++\n    }\n    return longArrayOf()\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206463,"user_id":53,"body":"package step\n\nimport java.util.Arrays\nimport kotlin.math.sqrt\n\nfun isPrime(x: Long) = (2L..sqrt(x.toDouble()).toLong()).none { x % it == 0L }\n\nfun step(g:Int, m:Long, n:Long):LongArray {\n    var i: Long = m\n    while (i < n - g) {\n        if (isPrime(i) && isPrime(i + g)) return longArrayOf(i ,i+g)\n        i += 1L\n    }\n    return LongArray(0)\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206464,"user_id":null,"body":"package step\n\nimport java.util.Arrays\n\n\/\/ if these g-steps prime numbers don't exist return []\nfun step(g:Int, m:Long, n:Long):LongArray {\n    for (i in m..n){   \n        if(isPrime(i) && ((i + g) <= n) && isPrime(i + g)){\n            return longArrayOf(i, i + g)\n        }        \n    }\n    return longArrayOf()\n}\nfun isPrime(g:Long):Boolean {\n    var i = 2L\n    while(i <= g\/2){\n        if(g % i == 0L) {\n            return false\n        }\n        ++i\n    }\n    return true\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206465,"user_id":null,"body":"package step\n\nimport java.util.Arrays\n\nfun sqrt(num: Long): Long = Math.sqrt(num.toDouble()).toLong()\n\nfun isPrime(number: Long): Boolean {\n    return when {\n        number == 2L -> true\n        number < 2L || number % 2L == 0L\n        || (3L..sqrt(number) step 2L).any {\n            number % it == 0L\n        } -> false\n        else -> true\n    }\n}\n\n\/**\n * @returns The first prime number starting at n (inclusive).\n *\/\nfun nextPrime(n: Long): Long {\n    if (n == 2L) {\n        return 2L\n    }\n    \n    val start = if (n % 2L == 0L) n + 1 else n\n    return (start..Long.MAX_VALUE step 2).first { isPrime(it) }\n}\n\nfun step(g: Int, m: Long, n: Long): LongArray {\n    val primes =\n        if (isPrime(m)) mutableSetOf<Long>(m)\n        else mutableSetOf<Long>()\n    var currentPrime = m;\n    do {\n        currentPrime = nextPrime(currentPrime + 1)\n        if (currentPrime - g in primes) {\n            return longArrayOf(currentPrime - g, currentPrime)\n        }\n        primes.add(currentPrime)\n    } while (currentPrime <= n)\n    return longArrayOf()\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206466,"user_id":null,"body":"package step\n\nimport java.util.Arrays\n\n\/\/ if these g-steps prime numbers don't exist return []\nfun step(g:Int, m:Long, n:Long):LongArray {\n    val step = g.toLong()\n    return (m..n).asSequence()\n        .filter { number ->\n            number.isPrime()\n        }\n        .scan(emptyList<Long>()) { list, number ->\n            list + number\n        }\n        .mapNotNull { list ->\n            val last = list.lastOrNull()\n            if (last != null && last - step in list) {\n                longArrayOf(last - step, last)\n            } else {\n                null\n            }\n        }\n        .firstOrNull() ?: longArrayOf()\n}\n\nfun Long.isPrime(): Boolean {\n    for (i in 2 .. this \/ 2) {\n        if (this % i == 0L) {\n            return false\n        }\n    }\n    return true\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5616868c81a0f281e500005c":[{"id":206467,"user_id":null,"body":"package Rank\n\nfun rank(st: String, we: IntArray, n: Int): String {\n    \n    if (st.isEmpty()) return \"No participants\"\n    \n    val names = st.split(\",\")\n    \n    if (n > names.size) return \"Not enough participants\"\n    \n    return names.mapIndexed { i, name -> \n        val s = name.toLowerCase().sumBy { it.toInt() - 96 }\n        Pair(name, (s + name.count()) * we[i])\n    }.sortedWith(compareBy({ -it.second }, { it.first.toLowerCase() }))[n - 1].first\n    \n}","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206468,"user_id":null,"body":"package Rank\n\nval Char.ordinal\n    get() = toLowerCase().toInt() - 96\n\nval String.som\n    get() = map { it.ordinal }.sum() + length\n\nfun rank(st: String, we: IntArray, n: Int) = when {\n    n > we.size -> \"Not enough participants\"\n    st.isEmpty() -> \"No participants\"\n    else -> st.split(',').mapIndexed { index, name -> Pair(name, name.som * we[index]) }\n        .sortedBy { it.first }.sortedByDescending { it.second }[n - 1].first\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206469,"user_id":null,"body":"package Rank\n\nfun rank(st: String, we: IntArray, n: Int): String {\n    if (st.isEmpty()) return \"No participants\"\n\n    val names = st.split(\",\")\n    if (n > names.size) return \"Not enough participants\"\n\n    return names.mapIndexed { idx, name -> Pair(name, we[idx] * som(name)) }\n        .sortedWith(compareByDescending<Pair<String, Int>> { pair -> pair.second }\n            .thenBy { pair -> pair.first })\n        .elementAt(n - 1)\n        .first\n}\n\nprivate fun som(name: String) =\n    name.length + (name.toCharArray().map { it.lowercaseChar() }.sumOf { it.code - ('a'.code - 1) })\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206470,"user_id":null,"body":"package Rank\n\nfun rank(names: List<String>, weights: IntArray): List<String> = weights.zip(names).sortedWith(\n        compareBy({ (it.second.length + it.second.map { it.uppercaseChar().code - 64 }.sum()) * -it.first }, { it.second })\n).map { it.second }\n\n\nfun rank(st: String, we: IntArray, n: Int): String {\n    val names = st.split(\",\")\n    \n    println(rank(names, we))\n    \n    return if (st.length == 0) {\"No participants\"} \n    else if (names.size < n) { \"Not enough participants\" } \n    else { rank(names, we)[n-1] }\n} ","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206471,"user_id":null,"body":"package Rank\n\nfun rank(st: String, we: IntArray, n: Int): String {\n    \n    if (st.length == 0) return \"No participants\"\n    \n    if (n > st.split(\",\").size) return \"Not enough participants\"\n    \n    var ranking = mutableListOf<Pair<String,Int>>()\n    var partisipants = st.split(\",\")\n   \t\n    for (i in 0..partisipants.size-1) {\n        var value = partisipants[i].fold(0) {sum,element -> sum + element.toString().length + element.toLowerCase().toChar().toInt()-96}\n        ranking.add(Pair(partisipants[i],value * we[i]))\n    }\n       return ranking.sortedWith(compareByDescending<Pair<String,Int>> { it.second }.thenBy { it.first })[n-1].first\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206472,"user_id":null,"body":"package Rank\n\nfun rank(st: String, we: IntArray, n: Int): Any {\n    if(st.isEmpty()) return \"No participants\"\n    if(n>we.count()) return \"Not enough participants\"\n    return st.split(\",\")\n            .zip(we.toTypedArray())\n            .map{it.copy(second=((it.first.length + it.first.sumOf { indexOfAlph(it) }) * it.second))}\n            .groupBy { it.second }\n            .map { it.value.sortedBy { it.first }.toMutableList() }\n            .reduce { acc, mutableList -> acc.addAll(mutableList); acc }\n            .sortedByDescending { it.second }\n            .get(n-1).first\n           \n}\n\nfun indexOfAlph(cahr:Char):Int{\n    return (\"abcdefghijklmnopqrstuvwxyz\".indexOf(cahr.lowercaseChar()))+1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206473,"user_id":null,"body":"package Rank\n\nfun rank(st: String, we: IntArray, n: Int): String {\n    if (st.isEmpty()) return \"No participants\"\n    val names = st.split(\",\")\n    if (n > names.size) return \"Not enough participants\"\n    val result = Array(names.size) { 0 to \"\" }\n    names.forEachIndexed { index, value ->\n        var sum = value.length\n        val lower = value.lowercase()\n        lower.forEach {\n            sum += it - 'a' + 1\n        }\n        result[index] = (sum * we[index]) to value\n    }\n    result.sortWith(\n        compareByDescending<Pair<Int, String>> { it.first }.thenBy { it.second }\n    )\n    return result[n - 1].second\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206474,"user_id":null,"body":"package Rank\n\nfun Char.rank() = lowercaseChar().code - 96\n\nfun String.som() = length + toCharArray().sumOf { it.rank() }\n\nfun rank(st: String, we: IntArray, n: Int): String {\n    if (st.isEmpty()) {\n        return \"No participants\"\n    }\n    \n    val participants = st.split(',')\n    \n    if (n > participants.size) {\n        return \"Not enough participants\"\n    }\n    \n    val sortedParticipants = participants\n        .withIndex()\n        .sortedWith(compareBy({ -(it.value.som() * we[it.index]) }, { it.value }))\n    \n    return sortedParticipants[n - 1].value\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206475,"user_id":null,"body":"package Rank\n\nfun rank(st: String, we: IntArray, n: Int): String {\n    if (st.isEmpty()) return \"No participants\"\n\n    val participants = st.split(\",\")\n\n    if (n > participants.size) return \"Not enough participants\"\n\n    return participants.mapIndexed { i, s ->\n            val number = (s.map { c -> Character.toLowerCase(c) - 'a' + 1 }.sum() + s.length) * we[i]\n            Pair(s, number)\n        }\n        .sortedWith(compareByDescending<Pair<String, Int>> { it.second }.thenBy { it.first })[n - 1].first\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206476,"user_id":null,"body":"package Rank\n\nfun rank(st: String, we: IntArray, n: Int): String {\n        \n    if (st.length == 0) return \"No participants\"\n    \n    var names  = st.split(\",\")\n    var pairs = mutableListOf<Pair<Int, String>>();\n     \n    for (i in 0 until names.size) {\n        var som = getSom(names[i], we[i])\n        pairs.add(som to names[i])\n    }\n    \n    pairs.sortWith(compareByDescending<Pair<Int, String>> {it.first}\n                  .thenBy {it.second})\n    \n    if (pairs.size > n - 1) {\n        return pairs[n - 1].second;\n    }\n    \n    return \"Not enough participants\";\n}\n    \n\n\nfun getSom(st: String, w: Int) : Int {\n    \n    var sum : Int  = 0;\n    \n    for (ch in st.lowercase()) {\n        var addition = ch.code - 96 ;\n        sum += addition;\n    }\n    \n    return (sum + st.length) * w;\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"561e9c843a2ef5a40c0000a4":[{"id":206477,"user_id":null,"body":"package gap\n\nimport kotlin.math.sqrt\n\nfun isPrime(x: Long) = (2L..sqrt(x.toDouble()).toLong()).none { x % it == 0L }\n\nfun gap(g: Int, m: Long, n: Long):LongArray {\n    return (m..n)\n            .filter(::isPrime)\n            .zipWithNext()\n            .firstOrNull { it.second - it.first == g.toLong() }\n            ?.let { longArrayOf(it.first, it.second) } ?: longArrayOf()\n}\n","lang_id":29,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206478,"user_id":932,"body":"package gap\nimport java.math.BigInteger\n\nfun gap(g: Int, m: Long, n: Long)=(m..n).filter{BigInteger.valueOf(it).isProbablePrime(10)}\n    .windowed(2).find{it.last()-it.first()==g.toLong()}?.toLongArray()?:longArrayOf()\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206479,"user_id":null,"body":"package gap\nimport java.lang.Math.sqrt\n\nfun isPrime_(x: Long) = (2L..sqrt(x.toDouble()).toLong()).none { x % it == 0L }\n\nfun gap(g: Int, m: Long, n: Long): LongArray {\n    return (m..n)\n        .filter(::isPrime_)\n        .zipWithNext()\n        .firstOrNull { it.second - it.first == g.toLong() }\n        ?.let { longArrayOf(it.first, it.second) } ?: longArrayOf()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206480,"user_id":null,"body":"package gap\n\nimport kotlin.math.sqrt\n\nfun gap(g: Int, m: Long, n: Long): LongArray {\n        var prime = 0L\n        (m..n).forEach {\n            if (isPrime(it)) {\n                if ((it - prime).compareTo(g) == 0) {\n                    return longArrayOf(prime, it)\n                }\n                prime = it\n            }\n        }\n\n        return longArrayOf()\n    }\n\n    private fun isPrime(n: Long): Boolean {\n        (2..sqrt(n.toDouble()).toLong()).forEach {\n            if ((n % it).compareTo(0) == 0) return false\n        }\n\n        return true\n    }\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206481,"user_id":null,"body":"package gap\n\n\/\/if these g-gap prime numbers don't exist return []\nfun gap(g:Int, m:Long, n:Long):LongArray {\n    for (i in m..(n - g)) {\n        if (i.toBigInteger().isProbablePrime(1) && (i + g).toBigInteger().isProbablePrime(1)) {\n            \/\/ Now, check the in-between numbers\n            var valid = true\n            for (j in (i + 1) until i + g) {\n                if (j.toBigInteger().isProbablePrime(1)) {\n                    valid = false\n                    break\n                }\n            }\n\n            if (valid) {\n                val result = LongArray(size = 2)\n                result[0] = i\n                result[1] = i + g\n\n                return result\n            }\n        }\n    }\n\n    return LongArray(size = 0)\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206482,"user_id":492,"body":"package gap\nimport java.util.Arrays\nprivate fun prime(n:Long):Boolean {\n    if (n == 2L)\n    return true\n    else if ((n < 2) || (n % 2 == 0L))\n    return false\n    else\n    {\n      var i:Long = 3\n      while (i <= Math.sqrt(n.toDouble()))\n      {\n        if (n % i == 0L) return false\n        ++i\n      }\n      return true\n    }\n}\n\/\/if these g-gap prime numbers don't exist return []\nfun gap(g:Int, m:Long, n:Long):LongArray {\n    var res = LongArray(2)\n    var i = m\n    while (i < n + 1)\n    {\n      if (prime(i))\n      {\n        res[0] = i\n        break\n      }\n      i++\n    }\n    var cont = true\n    while (cont)\n    {\n      var j = i + 1\n      while (j < n + 1)\n      {\n        if (prime(j))\n        {\n          if (j - i == g.toLong())\n          {\n            res[1] = j\n            return res\n          }\n          else\n          {\n            res[0] = j\n            i = j\n          }\n        }\n        j++\n      }\n      cont = false\n    }\n    return longArrayOf()\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206483,"user_id":53,"body":"package gap\n\nfun isPrime(n: Long): Boolean {\n    if (n % 2 == 0L) return n == 2L\n    if (n % 3 == 0L) return n == 3L\n    var i: Long = 5L\n    while (i * i <= n) {\n        if (n % i == 0L || n % (i + 2) == 0L) \n            return false\n        i += 6L\n    }\n    return true\n}\n\nfun gap (g: Int, m: Long, n: Long): LongArray {\n    var a: Long = 0L\n    var b: Long = 0L\n    var i: Long = m\n    while (i <= n) {\n        if (b - a == g.toLong()) return longArrayOf(a ,b)\n        if (isPrime(i)) {\n            a = b\n            b = i\n        }\n        i += 1L\n    }\n    return LongArray(0)\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206484,"user_id":null,"body":"package gap\nimport kotlin.math.sqrt\n\nfun gap(g: Int, m: Long, n: Long): LongArray {\n    \n    val primes = (m..n).filter { isPrime(it) }\n\n    for (i in 0..primes.size) {\n        if (i + 1 >= primes.size - 1) break\n        if ((primes[i + 1] - primes[i]).toInt() == g) {\n           return longArrayOf(primes[i], primes[i+1])\n        }\n    }\n    return longArrayOf()\n}\n\nprivate fun isPrime(num: Long): Boolean {\n    if (num in 1..2) return true\n    repeat(sqrt(num.toFloat()).toInt()) {\n        if (num.toInt() % (it + 2) == 0) return false\n    }\n    return true\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206485,"user_id":null,"body":"package gap\nimport kotlin.math.sqrt\n\nfun gap(g:Int, m:Long, n:Long):LongArray =\n    (m .. n).filter(::isPrime)\n        .zipWithNext { a, b -> longArrayOf(a, b) }\n        .firstOrNull { it[1] - it[0] == g.toLong() } ?: longArrayOf()\n\nfun isPrime(n : Long) : Boolean {\n    val max = sqrt(n.toDouble()).toLong()\n    return (2 .. max).none { n % it == 0L }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206486,"user_id":null,"body":"package gap\n\nfun gap(g: Int, m: Long, n: Long): LongArray {\n    (m..n).map { i ->\n        if (isPrime(i) and (isPrime(i + g)) and(!hasPrimeBetween(i , i + g)) )\n            return longArrayOf(i, i + g)\n    }.toList()\n    return longArrayOf()\n}\n\nfun hasPrimeBetween(i: Long, l: Long): Boolean {\n    (i + 1 until l).forEach{\n        if(isPrime(it))\n            return true\n    }\n    return false\n}\nfun isPrime(n: Long): Boolean {\n    for (i in 2..Math.sqrt(n.toDouble()).toInt())\n        if (n % i.toLong() == 0L)\n            return false\n    return true\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5629db57620258aa9d000014":[{"id":206487,"user_id":null,"body":"package mix\n\nfun mix_strings(s1:String, s2:String):String {\n    val m1 = ('a'..'z').associateBy({ it }, { s1.filter { c -> it == c }.length })\n    val m2 = ('a'..'z').associateBy({ it }, { s2.filter { c -> it == c }.length })\n\n    var l = mutableListOf<String>()\n    for (c in 'a'..'z') {\n        val v1 = m1.get(c)!!\n        val v2 = m2.get(c)!!\n        if (v1 < 2 && v2 < 2) {\n            continue\n        }\n        if (v1 == v2) {\n            l.add(\"=:\" + c.toString().repeat(v1))\n        } else if (v1 > v2) {\n            l.add(\"1:\" + c.toString().repeat(v1))\n        } else if (v2 > v1) {\n            l.add(\"2:\" + c.toString().repeat(v2))\n        }\n    }\n\n    return l.sortedWith(compareBy({ -it.length }, { it })).joinToString(\"\/\")\n}\n","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206488,"user_id":null,"body":"package mix\n\nfun mix_strings(s1: String, s2: String) = run {\n    val result = hashMapOf<Char, Pair<Int, Char>>() \/\/ \u5b57\u7b26\uff0c\u591a\u5c11\u4e2a\u5b57\u7b26\uff0c\u8c01\u6700\u591a\n\n    fun String.some(i: Char) = asSequence().filterNot { it.isWhitespace() || it.isUpperCase() }.groupBy { it }\n            .forEach { (k, v) ->\n                val s = v.size\n                if (s > 1) {\n                    val pair = result[k]\n                    if (pair != null) {\n                        if (pair.first < s) result[k] = s to i\n                        else if (pair.first == s) result[k] = s to '='\n                    } else result[k] = s to i\n                }\n            }\n    s1.some('1')\n    s2.some('2')\n\n    result.entries.sortedWith(compareByDescending<Map.Entry<Char, Pair<Int, Char>>> { it.value.first }\n            .thenBy { it.value.second }.thenBy { it.key })\n            .joinToString(\"\/\") { \"${it.value.second}:${it.key.toString().repeat(it.value.first)}\" }\n}","lang_id":29,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206489,"user_id":null,"body":"package mix\n\nfun mix_strings(s1:String, s2:String): String {\n    fun String.analyze(): Map<Char, Int> {\n        val lc = this.filter { it in 'a'..'z' }.toSet()\n        val dist = lc.map { k -> k to this.count { it == k } }\n        return dist.filter { it.second > 1 }.toMap()\n    }\n\n    fun Map.Entry<Char, Int>.show(idx: Char) = \"$idx:\" + key.toString().repeat(value)\n\n    val r1 = s1.analyze()\n    val r2 = s2.analyze()\n    val common = r1.filter { it in r2.entries }\n\n    return (\n            common.map { it.show('=') } +\n                    r1.filter { r2[it.key] ?: 0 < it.value }.map { it.show('1') } +\n                    r2.filter { r1[it.key] ?: 0 < it.value }.map { it.show('2') }\n            ).sortedWith(compareByDescending<String> { it.length }.thenBy { it }).joinToString(\"\/\")\n}\n","lang_id":29,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206490,"user_id":null,"body":"package mix\n\nfun mix_strings(s1:String, s2:String):String{\n    val ret = mutableListOf<String>()\n    (s1+s2).filter{it.isLowerCase()}.toList().distinct().sorted().forEach{c->\n        val c1 = s1.count{it==c}\n        val c2 = s2.count{it==c}\n        if(c1>1 || c2>1) {\n          if(c1==c2){\n             ret.add(\"=:\"+\"$c\".repeat(c1)) \n          }else if(c1>c2){\n            ret.add(\"1:\"+\"$c\".repeat(c1))\n          }else{\n            ret.add(\"2:\"+\"$c\".repeat(c2))\n          }       \n        }\n    }\n    val compar = compareByDescending<String>{it.length}.thenBy{it}\n    return ret.sortedWith(compar).joinToString(\"\/\")\n}\n","lang_id":29,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206491,"user_id":null,"body":"package mix\n\nfun mix_strings(s1: String, s2: String): String {\n    val filteredS1 = s1.filterForTask()\n    val filteredS2 = s2.filterForTask()\n    \n    return filteredS1.mapToNeededString(filteredS2, '1').plus(filteredS2.mapToNeededString(filteredS1, '2')).distinct()\n        .filter { it.isNotEmpty() }\n        .sortedBy { it.first() }.sortedByDescending { it.length }\n        .joinToString(\"\/\")\n}\n\n\nprivate fun List<Pair<Int, Char>>.mapToNeededString(list: List<Pair<Int, Char>>, char: Char) = this.map { pair ->\n    with(list.find { it.second == pair.second } ?: Pair(0, 'x')) {\n        when {\n            pair.first > this.first -> \"$char:${pair.second.toString().repeat(pair.first)}\"\n            pair.first < this.first -> \"\"\n            else -> \"=:${pair.second.toString().repeat(pair.first)}\"\n        }\n    }\n}\n\nprivate fun String.filterForTask() = with(this.filter { it.isLetter() && it.isLowerCase() }) {\n    this.map { char -> Pair(this.count { it == char }, char) }.distinct().sortedBy { it.second }\n        .filter { pair -> pair.first > 1 }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206492,"user_id":null,"body":"package mix\n\nfun mix_strings(s1:String, s2:String):String {\n    val string1 = s1.replace(Regex(\"[A-Z ,]\"), \"\")\n    val string2 = s2.replace(Regex(\"[A-Z ,]\"), \"\")\n    val map1 = mutableMapOf<Char, Int?>()\n    val map2 = mutableMapOf<Char, Int?>()\n    string1.forEach { if (map1.containsKey(it)) map1[it] = map1[it]?.plus(1) else map1[it] = 1 }\n    string2.forEach { if (map2.containsKey(it)) map2[it] = map2[it]?.plus(1) else map2[it] = 1 }\n    val result = mutableListOf<String>()\n    for ((index, element) in map1){\n        if (map1[index] == 1)\n            continue\n        var temp = \"\"\n        if ((map1[index] ?: 0) > (map2[index] ?: 0)){\n            repeat(map1[index]?:0){temp+=index}\n            result.add(\"1:$temp\")\n        } else if ((map1[index] ?: 0) == (map2[index] ?: 0)){\n            repeat(map1[index]?:0){temp+=index}\n            result.add(\"=:$temp\")\n        } else {\n            repeat(map2[index]?:0){temp+=index}\n            result.add(\"2:$temp\")\n        }\n        map2.remove(index)\n    }\n    for ((index, element) in map2){\n        if (map2[index] == 1)\n            continue\n        var temp = \"\"\n        repeat(map2[index]?:0){temp+=index}\n        result.add(\"2:$temp\")\n    }\n    return result.sortedWith(compareByDescending<String> { it.length }.thenBy { it }).joinToString(\"\/\")\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206493,"user_id":null,"body":"    package mix\n\n    data class SPair(val stringNumber: Int, val letterCount: Int)\n\n    fun mix_strings(s1: String, s2: String): String {\n\n        val s1Length = s1.length\n        val s2Length = s2.length\n\n        val map = mutableMapOf<String, SPair>().let {\n            for (i in 'a'..'z') {\n                val s1LetterCount = s1Length - s1.replace(i.toString(), \"\", false).length\n                val s2LetterCount = s2Length - s2.replace(i.toString(), \"\", false).length\n\n                if (s1LetterCount > 1 || s2LetterCount > 1) {\n                    if (s1LetterCount > s2LetterCount) {\n                        it.put(i.toString(), SPair(1, s1LetterCount))\n                    } else if (s2LetterCount > s1LetterCount) {\n                        it.put(i.toString(), SPair(2, s2LetterCount))\n                    } else { \/\/equal\n                        it.put(i.toString(), SPair(3, s1LetterCount))\n                    }\n                }\n            }\n            it.toList()\n                .sortedByDescending { t -> t.second.letterCount }\n                .toMap()\n        }\n        \n        return map.map { it.value.letterCount }\n            .distinct()\n            .sortedDescending().joinToString(\"\/\") { count ->\n                map.filter { it.value.letterCount == count }\n                    .toList()\n                    .sortedBy {\n                        it.second.stringNumber\n                    }\n                    .let { listWithSameLetterCount ->\n                        listWithSameLetterCount.map { item -> item.second.stringNumber }\n                            .distinct()\n                            .sorted().joinToString(\"\/\") { stringNumber ->\n                                listWithSameLetterCount\n                                    .filter { it.second.stringNumber == stringNumber }\n                                    .sortedBy { it.first }.joinToString(\"\/\") {\n                                        \"${if (it.second.stringNumber == 3) \"=\" else it.second.stringNumber}:${\n                                            it.first.repeat(\n                                                it.second.letterCount\n                                            )\n                                        }\"\n                                    }\n                            }\n                    }\n            }\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206494,"user_id":null,"body":"package mix\n\ndata class MaxCountLetter(var letter: Char, var numStr: String, var countLetters: Int)\n\nfun mix_strings(s1: String, s2: String): String {\n    val countLetterList: MutableList<MaxCountLetter> = mutableListOf()\n    val lettersList = (s1 + s2).toSortedSet().filter { it in 'a'..'z' }\n    for (letter in lettersList) {\n        val count1 = if (s1.contains(letter)) s1.count { it == letter } else 0\n        val count2 = if (s2.contains(letter)) s2.count { it == letter } else 0\n        when {\n            count1 > count2 -> countLetterList += MaxCountLetter(letter, \"1\", count1)\n            count2 > count1 -> countLetterList += MaxCountLetter(letter, \"2\", count2)\n            count1 == count2 -> countLetterList += MaxCountLetter(letter, \"=\", count1)\n        }\n    }\n\n    return countLetterList\n        .filter { it.countLetters > 1 }\n        .sortedWith(\n            compareByDescending<MaxCountLetter> { it.countLetters }\n                .thenBy { it.numStr }\n        )\n        .joinToString(\"\/\") { it.numStr + \":\" + it.letter.toString().repeat(it.countLetters) }\n}\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206495,"user_id":null,"body":"package mix\n\nimport java.util.*\nimport kotlin.collections.HashMap\n\nfun mix_strings(s1: String, s2: String): String {\n    val map1 = createMap(s1)\n    val map2 = createMap(s2)\n\n    val resultMap = HashMap<Char, Element>()\n\n    for ((key, value) in map1) {\n        if (value <= 1) continue\n        resultMap[key] = Element(\"1\", key, value)\n    }\n\n    for ((key, value) in map2) {\n        if (value <= 1) continue\n        val lastValue = resultMap[key]\n        if (lastValue == null || lastValue.numberRepeat < value) {\n            resultMap[key] = Element(\"2\", key, value)\n        } else if (lastValue.numberRepeat == value) {\n            resultMap[key] = Element(\"=\", key, value)\n        }\n    }\n\n    return resultMap.values.sorted().joinToString(separator = \"\/\") { it.content }\n}\n\n\nfun createMap(s: String): Map<Char, Int> {\n    val map = HashMap<Char, Int>()\n    s.forEach {\n        if (it.isLowerCase()) {\n            map[it] = map[it]?.plus(1) ?: 1\n        }\n    }\n    return map\n}\n\nclass Element(indexString: String, symbol: Char, val numberRepeat: Int) : Comparable<Element> {\n    val content = indexString + \":\" + symbol.toString().repeat(numberRepeat)\n\n    override fun compareTo(other: Element): Int {\n        return if (other.numberRepeat.compareTo(numberRepeat) != 0) other.numberRepeat.compareTo(numberRepeat)\n        else content.compareTo(other.content)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206496,"user_id":null,"body":"package mix\n\nfun mix_strings(s1: String, s2: String): String {\n\n    val l1 = s1.extractLetters(prefix = \"1\")\n    val l2 = s2.extractLetters(prefix = \"2\")\n    return (l1 + l2)\n            .sortedByDescending { it.second }\n            .groupBy { Pair(it.first[2], it.second) }\n            .map { it.key to if (it.value.size == 2) \"=\" else it.value[0].first[0] }\n            .distinctBy { it.first.first }\n            .map { it.second to it.first.first.toString().repeat(it.first.second) }\n            .map { \"${it.first}:${it.second}\" }\n            .sortedWith(compareByDescending<String> { it.length }.thenBy { it.first() }.thenBy { it.last() })\n            .joinToString(\"\/\")\n}\n\nfun String.extractLetters(prefix: String) =\n        this.filter { it in 'a'..'z' }\n                .map { \"$prefix:$it\" to this.count { c -> c == it } }\n                .filter { it.second > 1 }\n                .distinct()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"562e274ceca15ca6e70000d3":[{"id":206497,"user_id":null,"body":"package parabolic\nimport kotlin.math.*\n\nfun lenCurve(n:Int):Double {\n    val x = (0..n)\n    val r = x\n      .map({it.toDouble()\/n})\n      .map({Pair(it, it * it)})\n      .zipWithNext()\n      .fold(0.0, { d, (p1, p2) -> d + sqrt((p2.first-p1.first)*(p2.first-p1.first)+(p2.second-p1.second)*(p2.second-p1.second))})\n    return ceil(r * 1e9) * 1e-9\n    \n    \/\/ unfortunately deep Pair destructuring doesn't seem to work.\n    \/\/ would have been nicer to be able to write\n    \/\/ .fold(0.0, { d, ((x1, y1), (x2,y2)) -> d + sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1))})\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206498,"user_id":null,"body":"package parabolic\nimport kotlin.math.sqrt\n\nfun lenCurve(n:Int):Double {\n    fun calcY(x:Double):Double {\n        return (x * x)\n    }\n    var prevX = 0.0\n    var prevY = 0.0\n    var totalLen = 0.0\n    var x = 0.0\n    while (x <= 1.00000000001) { \/\/Stupid double overflow....I am garbage at the special K\n        var y = calcY(x)\n        totalLen += sqrt(((x-prevX)*(x-prevX)) + ((y-prevY)*(y-prevY)))\n        prevX = x\n        prevY = y\n        x += (1.0\/n.toDouble())\n    }\n    return totalLen.toDouble()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206499,"user_id":null,"body":"package parabolic\n\nfun lenCurve(n:Int) = \n  (0 .. n).map { it.toDouble() \/ n }\n  .map { it to it * it }\n  .zipWithNext()\n  .map{ (p1,p2) -> Math.sqrt((p2.second-p1.second)*(p2.second-p1.second) + (p2.first-p1.first)*(p2.first-p1.first)) }\n  .sum()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206500,"user_id":527,"body":"package parabolic\n\nimport java.util.stream.IntStream;\n\nfun lenCurve(n: Int): Double {\n  val nd = n.toDouble()\n  return IntStream.range(0, n).mapToDouble{ i -> Math.hypot((2 * i + 1).toDouble(), nd) }.sum() \/ (nd * nd)\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206501,"user_id":null,"body":"package parabolic\nimport kotlin.math.pow\n\nfun f(x: Double) = x*x\n\nfun lenCurve(n:Int):Double {\n    val heights = (0..n).map { f(it\/n.toDouble()) }\n    return (1..n).map { Math.sqrt( (1.0\/n).pow(2.0) + (heights[it-1]-heights[it]).pow(2.0) ) }.sum()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206502,"user_id":null,"body":"package parabolic\n\nimport kotlin.math.pow\nimport kotlin.math.sqrt\n\nfun lenCurve(n: Int): Double {\n    var start = 1 \/ n.toDouble()\n    var answer = 0.0\n    var last = 0.0\n    while (start <= 1+10e-7) {\n        answer += sqrt((start.pow(2) - last).pow(2) + (1 \/ n.toDouble()).pow(2))\n        last = start.pow(2)\n        start += 1 \/ n.toDouble()\n    }\n    return answer\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206503,"user_id":null,"body":"package parabolic\nimport kotlin.math.sqrt\n\nfun lenCurve(n:Int):Double {\n    var a0: Double = 0.0\n    var a1: Double = a0+(1\/n.toDouble())\n    var res: Double = 0.0\n    for (x in 0 until n) {\n        res+=sqrt((a1*a1-a0*a0)*(a1*a1-a0*a0)+((1\/n.toDouble())*(1\/n.toDouble())))\n        a0=a1.toDouble()\n        a1+=(1\/n.toDouble())\n    }\n    return res\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206504,"user_id":null,"body":"package parabolic\n\ndata class Point (val x:Double,val y:Double){\n    fun getRWith(point:Point):Double{\n        return Math.sqrt(Math.pow(x - point.x,2.0)+Math.pow(y - point.y,2.0))\n    }\n}\nfun lenCurve(n:Int):Double {\n    val unit = 1.0.div(n)\n    val points = (0..n).map {\n        val x = it*unit\n        val y = x*x\n        Point(x,y)\n    }\n    return points.mapIndexed{ index,point->\n        if (index == 0) {\n            0.0\n        }else{\n            point.getRWith(points[index-1])\n        }\n    }.sum()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206505,"user_id":null,"body":"package parabolic\n\nfun lenCurve(n:Int):Double {\n      val h = 1.0\/n;\n      var sum = 0.0;\n      var y = 0.0;\n      for (k in 1..n) {\n        var x1 = k*h;\n        var y1 = x1*x1;\n        var diff = y1 - y;\n        sum += Math.sqrt(h * h + diff * diff);\n        y = y1;\n      }\n      return sum;\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206506,"user_id":null,"body":"package parabolic\n\nimport java.awt.geom.Point2D\n\nfun lenCurve(n: Int) = List(n + 1){ it * 1.0\/n }\n        .map { Point2D.Double(it , it * it) }\n        .zipWithNext (Point2D::distance)\n        .sum()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"562f91ff6a8b77dfe900006e":[{"id":206507,"user_id":492,"body":"package going\n\nfun movie(card:Int, ticket:Int, perc:Double):Int {\n    var systemA = 0\n    var systemB = card.toDouble()\n    var prev = ticket.toDouble()\n    var times = 0\n    while (systemA <= Math.ceil(systemB))\n    {\n      systemA += ticket\n      prev *= perc\n      systemB += prev\n      times += 1\n    }\n    return times\n}","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206508,"user_id":527,"body":"package going\n\nfun movie(card: Int, ticket: Int, percent: Double): Int {\n    tailrec fun iter(i: Int, pb: Double, sa: Int, sb: Double): Int =\n        if (Math.ceil(sb) < sa) i\n        else iter(i + 1, pb * percent, sa + ticket, sb + pb)\n    return iter(0, ticket * percent, 0, card.toDouble())\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206509,"user_id":null,"body":"package going\nimport kotlin.math.pow\nimport kotlin.math.ceil\n\nfun movie(card:Int, ticket:Int, perc:Double) = generateSequence(1){it + 1}.\nfirst {\n    ticket * it > ceil(card + ticket * perc * (1 - perc.pow(it)) \/ (1 - perc))\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206510,"user_id":null,"body":"package going\n\nfun movie(card:Int, ticket:Int, perc:Double):Int {\n    var summaryA = 0\n    var summaryB = card.toDouble()\n    \n    var currentTicketPrice = ticket.toDouble()\n    var counter = 0\n    \n    while (Math.ceil(summaryB) >= summaryA) {\n        currentTicketPrice *= perc\n        \n        summaryA += ticket\n        summaryB += currentTicketPrice\n        \n        counter++\n    }\n    \n    return counter\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206511,"user_id":null,"body":"package going\nimport kotlin.math.pow\nimport kotlin.math.ceil\n\nfun movie(card:Int, ticket:Int, perc:Double):Int {\n\n    var systemB : Double = card + (ticket * perc)\n    var count = 1\n\n    while ( (count*ticket) <= (ceil(systemB))) {\n        count += 1\n        systemB += (ticket * (perc.pow(count)))\n    }\n    return count\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206512,"user_id":null,"body":"package going\n\nfun movie(card:Int, ticket:Int, perc:Double):Int {\n    for(n in 0..100000000000){\n        if (Math.ceil(card.toDouble() + ticket.toDouble() * perc * (1-Math.pow(perc,n.toDouble()))\/(1-perc)) < ticket.toDouble() * n.toDouble()){\n            return n.toInt()\n        } \n    } \n   return 1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206513,"user_id":null,"body":"package going\n\nimport kotlin.math.pow\nimport kotlin.math.ceil\n\nfun movie(card:Int, ticket:Int, discount:Double):Int {\n    \n    var normalTicketPriceTotal: Int = 0\n    var cardTicketPriceTotal: Double = card.toDouble()\n    var ticketsBought: Int = 0\n    \n    while(ceil(cardTicketPriceTotal) >= normalTicketPriceTotal) {\n        ticketsBought++\n        normalTicketPriceTotal = ticket * ticketsBought\n        cardTicketPriceTotal = cardTicketPriceTotal + (ticket * (discount.pow(ticketsBought)))\n    }\n    \n    return ticketsBought\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206514,"user_id":null,"body":"package going\n\nfun movie(card:Int, ticket:Int, perc:Double):Int {\n    if(card == 0 && perc < 1) return 2\n    println(\"card $card  --  ticket $ticket -- perc $perc\")\n    var rep = 1\n    var priceTicket = ticketPrice(ticket, rep)\n    var priceCard = Math.ceil(cardPrice(card, ticket, perc, rep))\n\/\/     println(\"$priceTicket  --  $priceCard\")\n    while(priceCard >= priceTicket){\n        rep++\n        priceTicket = ticketPrice(ticket, rep)\n        priceCard = Math.ceil(cardPrice(card, ticket, perc, rep))\n\/\/         println(\"$priceTicket  --  $priceCard\")\n    }\n\/\/     println(\"${rep-1}\")\n    return rep - 1\n}\n\nfun ticketPrice(ticket: Int, rep:Int)  = ticket * rep\n\nfun cardPrice(card:Int, ticket:Int, percent: Double, rep: Int) = \n    card.toDouble() + (ticket.toDouble() * ((1 - Math.pow(percent, rep.toDouble() + 1))\/(1 - percent)))\n    \n    ","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206515,"user_id":null,"body":"package going\n\nfun movie(card:Int, ticket:Int, perc:Double):Int {\n    tailrec fun systemB(buf:Double, prev:Double, pos:Int): Int{\n            return when {\n                Math.ceil(buf) < ((ticket * pos).toDouble()) -> pos\n                else -> systemB(buf + (prev * perc), prev * perc, pos+1)\n            }\n        }\n    return systemB(card + (ticket * perc), (ticket * perc), 1)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206516,"user_id":null,"body":"package going\n\nfun movie(card:Int, ticket:Int, perc:Double): Int {\n    var B : Double = card + (ticket * perc) ; var i = 0 ; var j = 0\n    run loop@{\n        (2..999999).forEach {\n            var A = ticket * it\n            B += (ticket * Math.pow(perc, it.toDouble()))\n            if (Math.ceil(B) < A) {i++; println(it); if (i == 1) { j = it; return@loop}\n            }\n        }\n    }\n    return j\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"56347fcfd086de8f11000014":[{"id":206517,"user_id":null,"body":"package solution\n\nobject EulerOde {\n\n    fun exEuler(nb: Int): Double {\n \n        val h = 1\/nb.toDouble()\n        var Ax = 0.0\n        var Ay = 1.0\n        var Az = 1.0 + 0.5*Math.exp(-4.0*Ax) - 0.5 * Math.exp(-2.0*Ax)\n        var errA = Math.abs(Ay-Az)\/Az\n        \n        for (i in 1 .. nb) {\n            Ay += (2.0 - Math.exp(-4.0*Ax) - 2.0*Ay) * h\n            Ax += h\n            Az = 1.0 + 0.5*Math.exp(-4.0*Ax) - 0.5*Math.exp(-2.0*Ax)\n            errA += Math.abs(Ay-Az)\/Az\n        }\n\t\terrA = errA\/(nb.toDouble() + 1)\n        \n        return (errA*1000000.0).toInt().toDouble()\/1000000.0\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206518,"user_id":null,"body":"package solution\n\nimport kotlin.math.abs\nimport kotlin.math.exp\n\nobject EulerOde {\n    fun diffEq(x: Double, y: Double): Double {\n     return 2 - exp(-4*x) - 2*y\n    }\n\n    fun exactSoln(x: Double): Double {\n        return 1 + 0.5*exp(-4*x) - 0.5*exp(-2*x)\n    }\n\n    fun exEuler(nb: Int): Double {\n        val h = 1.0 \/ nb\n        var y = 1.0\n        var x = 0.0\n        var error = 0.0\n\n        for (i in 1..nb) {\n            y += diffEq(x, y)*h\n            x += h\n\n            val exact = exactSoln(x)\n\n            error += abs(y-exact) \/ exact\n        }\n\n        val avgError = error\/(nb + 1)\n        return (avgError * 1000000).toInt() \/ 1000000.0\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206519,"user_id":null,"body":"package solution\n\nobject EulerOde {\n    \n    fun delta_y(x: Double, y: Double): Double = 2.0 - Math.exp(-4.0 * x) - 2.0 * y\n    fun y_hat(x: Double, y_prev: Double, step: Double): Double = y_prev + delta_y(x, y_prev) * step\n    fun y(x: Double): Double = 1.0 + 0.5 * Math.exp(-4.0 * x) - 0.5 * Math.exp(-2.0 * x)\n    fun error(pred: Double, x: Double): Double = Math.abs( pred - y(x) ) \/ y(x)  \n\n    fun exEuler(nb: Int): Double { \n        var predictions: DoubleArray = DoubleArray( nb+1 )\n        val stepSize: Double = 1.0 \/ nb.toDouble()\n        predictions[0] = 1.0\n        for ( idx in 0..predictions.size-2 ) {\n            predictions[idx+1] = y_hat( idx.toDouble() * stepSize, predictions[idx], stepSize )\n        }        \n        return predictions.mapIndexed{ idx, v -> \n           error(v, idx * stepSize )  \n        }.average()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206520,"user_id":null,"body":"package solution\n\nimport kotlin.math.abs\nimport kotlin.math.exp\n\nobject EulerOde {\n\n    fun exEuler(nb: Int): Double = mutableListOf(1.0).apply {\n        (1..nb).forEach { add(this.last() + (2 - exp(-4.0 * (it - 1) \/ nb) - 2 * this.last()) \/ nb) }\n    }.mapIndexed { i, value ->\n        let {\n            val exactSolution = (1 + (exp(-4.0 * i \/ nb) \/ 2) - (exp(-2.0 * i \/ nb) \/ 2))\n            abs(value - exactSolution) \/ exactSolution \/ (nb + 1)\n        }\n    }.sum()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206521,"user_id":null,"body":"package solution\n\nimport java.math.BigDecimal\nimport java.math.RoundingMode\nimport kotlin.math.*\n\nobject EulerOde {\n\n    fun exEuler(nb: Int): Double {\n        val h = 1.0 \/ nb\n        \n        val xList = List(nb + 1) { h * it }\n        \n        val yList = mutableListOf<Double>()\n        for (i in xList.indices) {\n            if (i == 0) {\n                yList.add(1.0)\n                continue\n            }\n            val prevX = xList[i - 1]\n            val prevY = yList[i - 1]\n            val y = prevY + (2 - E.pow(-4 * prevX) - 2 * prevY) * h\n            yList.add(y)\n        }\n        \n        val zList = xList.map { 1 + 0.5 * E.pow(-4 * it) - 0.5 * E.pow(-2 * it) }\n        \n        val errorsList = mutableListOf<Double>()\n        for (i in yList.indices) errorsList.add(abs(yList[i] - zList[i]) \/ zList[i])\n        \n        val result = errorsList.sum() \/ (nb + 1)\n        val decimal = BigDecimal(result).setScale(6, RoundingMode.FLOOR)\n        return decimal.toDouble()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206522,"user_id":null,"body":"\/*\nif you want to understand the logic of calculation visit https:\/\/tutorial.math.lamar.edu\/classes\/de\/eulersmethod.aspx\n *\/\n\npackage solution\n\nimport java.math.RoundingMode\nimport kotlin.math.abs\nimport kotlin.math.exp\n\nobject EulerOde {\n\n    fun exEuler(nb: Int): Double {\n        val h: Double = 1.0 \/ nb\n        var t = 0.0\n        var y = 1.0\n        val listOfApprox = mutableListOf<Double>()\n        val listOfExact = mutableListOf<Double>()\n        var steps = 0\n\n        while (steps <= nb.toDouble()) {\n            val approx: Double = (2 - (exp(-4 * t)) - (2 * y))\n            listOfApprox.add(y)\n            y += (h * approx)\n            val exact: Double = (1 + (0.5 * exp(-4 * t)) - (0.5 * exp(-2 * t)))\n            listOfExact.add(exact)\n            t += h\n            steps++\n        }\n\n        val listOfDiff = listOfExact.zip(listOfApprox) { i, j -> abs(((i - j)) \/ i) }\n        val size = listOfDiff.size\n        val errorMean: Double = listOfDiff.sum() \/ size\n        return errorMean.toBigDecimal().setScale(6, RoundingMode.FLOOR).toDouble()\n    }\n}\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206523,"user_id":null,"body":"package solution\n\nimport kotlin.math.abs\nimport kotlin.math.exp\n\nobject EulerOde {\n\n    private fun getDyx(x: Double, y: Double): Double = 2 - exp(-4 * x) - 2 * y\n    private fun getZY(x: Double): Double = 1 + 0.5 * exp(-4 * x) - 0.5 * exp(-2 * x)\n\n    fun exEuler(nb: Int): Double {\n        var x = 0.0\n        var y = 1.0\n        val h = 1.0 \/ nb\n        var ak = 0.0\n\n        for (i in 1..nb) {\n            getDyx(x, y).also { x += h; y += h * it }\n            getZY(x).also { ak += abs(y - it) \/ it }\n        }\n        return ak \/ (nb + 1)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206524,"user_id":null,"body":"package solution\n\nimport kotlin.math.abs\nimport kotlin.math.exp\n\nobject EulerOde {\n\n    private fun getDyx(x: Double, y:Double):Double = 2 - exp(-4*x) - 2*y\n    private fun getZY(x: Double):Double = 1 + 0.5*exp(-4*x) - 0.5*exp(-2*x)\n\n    fun exEuler(nb: Int): Double {\n        var x:Double = 0.0\n        var y:Double = 1.0\n        var h:Double = 1.0\/nb\n        var aK:Double = 0.0\n\n        for (i in 1..nb){\n            val dyx = getDyx(x,y)\n            x += h\n            y += h*dyx\n            val zy = getZY(x)\n            \/\/println(\"$x $y $dyx $zy $h\")\n            aK += abs(y-zy)\/zy\n        }\n        return aK\/(nb+1)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206525,"user_id":null,"body":"package solution\nimport kotlin.math.exp\nimport kotlin.math.abs\nobject EulerOde {\n    private const val x0 = 0.0\n    private const val y0 = 1.0\n    private const val T = 1.0\n\n    private fun f(x: Double, y: Double) = 2 - exp(-4 * x) - 2 * y\n    private fun exactSolution(x: Double) = 1 + 0.5 * exp(-4 * x) - 0.5 * exp(-2 * x)\n\n    fun exEuler(nb: Int): Double {\n        val dx = T \/ nb\n        var step = 0\n        val xs = (0..nb).map { x0 + it * dx }\n        val zs = xs.map(EulerOde::exactSolution)\n        val ys = generateSequence(y0) { it + f(xs[step++], it) * dx }.take(nb + 1).toList()\n\n        return zs.zip(ys).map { (z, y) -> abs(z - y) \/ z }.sum() \/ (nb + 1)\n\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206526,"user_id":null,"body":"package solution\n\nobject EulerOde {\n\n    fun exEuler(nb: Int): Double {\n        var x = 0.0\n        var y = 1.0\n        var errSum = 0.0\n        \n        val n = nb.toDouble()\n        val h = 1.0 \/ n\n        \n        for (i in 0..nb - 1){\n            y += f(x, y) * h\n            x += h\n            val z = 1 + 0.5 * Math.exp(-4 * x) - 0.5 * Math.exp(-2 * x)\n            errSum += Math.abs(y - z) \/ z\n        }\n        return errSum \/ (n + 1)\n    }\n    \n    fun f(t: Double, y: Double): Double {\n        return 2 - Math.exp(-4 * t) - 2 * y\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5635e7cb49adc7b54500001c":[{"id":206527,"user_id":527,"body":"package solution\n\nval values = listOf(500, 200, 100, 50, 20, 10)\n\nfun count(amount: Int): Int {\n    val (a, k) = values.fold(Pair(amount, 0)){ (a, k), v -> Pair(a % v, k + a \/ v) }\n    return if (a == 0) k else -1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206528,"user_id":null,"body":"package solution\n\nfun count(number: Int): Int {\n    \/\/ Your solution is here\n    if (number % 10 != 0) {\n      return -1\n    }\n    val bill_500 = number \/ 500\n    val bill_200 = number % 500 \/ 200\n    val bill_100 = number % 500 % 200 \/ 100\n    val bill_50 = number % 500 % 200 % 100 \/ 50\n    val bill_20 = number % 500 % 200 % 100 % 50 \/ 20\n    val bill_10 = number % 500 % 200 % 100 % 50 % 20 \/ 10\n    \n    return bill_500 + bill_200 + bill_100 + bill_50 + bill_20 + bill_10\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206529,"user_id":null,"body":"package solution\n\nfun count(number: Int) : Int{\n    val count = arrayListOf(500, 200, 100, 50, 20, 10)\n    var countVar = 0\n    var newNumber = number\n\n    count.forEach {\n        while (newNumber - it >= 0){\n            newNumber-=it\n            countVar++\n        }\n    }\n        return if (newNumber == 0) countVar else - 1\n}\n\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206530,"user_id":null,"body":"package solution\n\n    fun count(number: Int): Int {\n        var c = 0\n        var sum = number\n        val ar = arrayOf(500, 200, 100, 50, 20, 10)\n        while (sum >= 10) {\n            for (i in ar.indices) {\n                if (sum >= ar[i]) {\n                    sum -= ar[i]\n                    c++\n                    break\n                }\n            }\n        }\n\n        return if (sum == 0) c else -1\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206531,"user_id":null,"body":"package solution\n\nfun count(number: Int):Int = when {\n    number % 10 != 0 -> -1\n    number - 500 >= 0 -> 1 + count(number - 500)\n    number - 200 >= 0 -> 1 + count(number - 200)\n    number - 100 >= 0 -> 1 + count(number - 100)\n    number - 50 >= 0 -> 1 + count(number - 50)\n    number - 20 >= 0 -> 1 + count(number - 20)\n    number - 10 >= 0 -> 1 + count(number - 10)\n    else -> 0\n }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206532,"user_id":null,"body":"package solution\n\nfun count(number: Int) = if (number % 10 > 0) -1 else listOf(500, 200, 100, 50, 20, 10)\n    .fold(listOf(number, 0)) { acc, i -> listOf(acc[0] % i, acc[1] + acc[0] \/ i) }[1]","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206533,"user_id":null,"body":"package solution\n\nfun count(number: Int): Int {\n    var available = listOf(10,20,50,100,200,500)\n    var globalCounter = 0\n    var buffer = 0\n    if (number < 10 || number%10 > 0){\n        globalCounter = -1\n    }else{\n        while (buffer != number){\n            buffer += available.max()!!\n            globalCounter++\n            if (buffer > number){\n                buffer -= available.max()!!\n                globalCounter--\n                available = available.dropLast(1)\n                }\n        }\n    }\n    return globalCounter\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206534,"user_id":null,"body":"package solution\n\nfun count(number: Int): Int {\n    var result: Int = 0\n    var rest: Int = 0\n    result += number \/ 500\n    rest = number % 500\n    result += rest \/ 200\n    rest = rest % 200\n    result += rest \/ 100\n    rest = rest % 100\n    result += rest \/ 50\n    rest = rest % 50\n    result += rest \/ 20\n    rest = rest % 20\n    result += rest \/ 10\n    if (rest % 10 == 0) {\n        return result\n    } else {\n        return -1\n    }\n    \n    return number\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206535,"user_id":null,"body":"package solution\n\nval availableCaches = listOf(500, 200, 100, 50, 20, 10)\n\nfun count(number: Int): Int {\n    val iterator = availableCaches.listIterator()\n    if ((number.rem(10) != 0) or (number < 1) or (number > 1500)) return -1\n    var index = 0\n    var quotient = 0\n    var n = number\n    if (iterator.hasNext()) iterator.next()\n    do {\n        if (n \/ availableCaches[index] > 0 && n > 0) {\n            quotient += n \/ availableCaches[index]\n            n %= availableCaches[index]\n        } else {\n            if (iterator.hasNext()) {\n                iterator.next()\n                index++\n            } else break\n        }\n    } while (true)\n\n    return quotient\n}\n\nfun _count(amount: Int): Int {\n    val (a, k) = availableCaches.fold(Pair(amount, 0)){ (a, k), v -> Pair(a % v, k + a \/ v) }\n    return if (a == 0) k else -1\n}\n\nfun __count(number: Int): Int {\n    var remaining = number\n    val notes = listOf(500, 200, 100, 50, 20, 10)\n    var max = 0\n    for (x in notes){\n        val temp = remaining\/x\n        if (temp > 0){\n            remaining -= temp*x\n            max += temp\n        }\n    }\n    if (remaining > 0) return -1 else return max\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206536,"user_id":null,"body":"package solution\n\nfun count(number: Int): Int {\n    val atm = listOf<Int>(10,20,50,100,200,500)\n    var result = number\n    var resint=0\n    if (number%10==0||number%100==0) {\n        do {\n            when(result){\n                in 0..atm[1]-1 -> result -= atm[0]\n                in 0..atm[2]-1 -> result -= atm[1]\n                in 0..atm[3]-1 -> result -= atm[2]\n                in 0..atm[4]-1 -> result -= atm[3]\n                in 0..atm[5]-1 -> result -= atm[4]\n                else -> result -= atm[5]\n\n            }\n            resint++\n        }while (result>0)\n        return resint\n    }\n    else return -1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"563a631f7cbbc236cf0000c2":[{"id":206537,"user_id":null,"body":"fun move(pos: Int, roll: Int) = pos+(2*roll)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206538,"user_id":null,"body":"fun move(pos: Int, roll: Int): Int = pos + 2 * roll","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206539,"user_id":null,"body":"fun move(p: Int, r: Int) = p + 2 * r","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206540,"user_id":null,"body":"fun move(pos: Int, roll: Int): Int = roll*2+pos","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206541,"user_id":527,"body":"fun move(pos: Int, roll: Int): Int = pos + roll * 2","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206542,"user_id":null,"body":"val move:(Int,Int) -> Int = {pos,roll -> pos+(roll*2)}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206543,"user_id":null,"body":"fun move(pos: Int, roll: Int): Int {\n    \n    val pos = pos\n    val roll = roll\n\n    return if (roll in 1..6) {(roll*2)+pos} else 0\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206544,"user_id":null,"body":"fun move(pos: Int, roll: Int): Int {\n   var rollTwice = roll * 2\n   return pos + rollTwice\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206545,"user_id":null,"body":"fun move(pos: Int, roll: Int) = roll.times(2).plus(pos)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206546,"user_id":null,"body":"fun move(pos: Int, roll: Int): Int {\n    \/\/ your code here\n    var tots = pos + 2 * roll\n    return tots \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"563b662a59afc2b5120000c6":[{"id":206547,"user_id":null,"body":"package growth\n\nfun nb_year(pp0: Int, percent: Double, aug: Int, p: Int): Int = \n  generateSequence(pp0.toDouble()) { it * (1 + percent \/ 100) + aug }.takeWhile { it < p }.count()\n","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206548,"user_id":null,"body":"package growth\n\nfun nb_year(pp0:Int, percent:Double, aug:Int, p:Int):Int {\n    var pp= pp0.toDouble()\n    var ans = 0\n    while (pp < p){\n        pp += (pp * (percent \/ 100)) + aug\n        ans++\n    }\n    return ans\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206549,"user_id":null,"body":"package growth\n\nfun nb_year(pp0:Int, percent:Double, aug:Int, p:Int):Int = generateSequence(pp0) { it + (applyPercent(percent, it)) + aug }.indexOfFirst { it >= p }\nval applyPercent: (Double, Int) -> Int = { a, b  -> (a\/100*b).toInt()}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206550,"user_id":null,"body":"package growth\n\nfun nb_year(pp0:Int, percent:Double, aug:Int, p:Int) =\n    generateSequence(pp0) { (it * (1 + percent \/ 100) + aug).toInt() }\n        .takeWhile { it < p }\n        .count()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206551,"user_id":null,"body":"package growth\n\nfun nb_year(pp0:Int, percent:Double, aug:Int, p:Int):Int {\n  var currentPeople = (pp0).toDouble()\n  var years = 0\n  \n  while(p > currentPeople) {\n    currentPeople = currentPeople + currentPeople*(percent\/100) + aug    \n    years++\n  }\n  return years\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206552,"user_id":null,"body":"package growth\n\nfun nb_year(pp0:Int, percent:Double, aug:Int, p:Int):Int = generateSequence(pp0){ it + (percent\/100.0 * it).toInt() + aug}.indexOfFirst { it >= p }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206553,"user_id":492,"body":"package growth\n\nfun nb_year(pp0:Int, percent:Double, aug:Int, p:Int):Int {\n    var years = 0\n    var p0 = pp0\n    while (p0 < p)\n    {\n      p0 += (p0 * percent \/ 100 + aug).toInt()\n      years++\n    }\n    return years\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206554,"user_id":null,"body":"package growth\n\nfun nb_year(pp0:Int, percent:Double, aug:Int, p:Int):Int {\n    var initialPopulation= pp0.toDouble()\n    val populationToSurpass=p.toDouble()\n    val constantIncomersOrLeavers=aug.toDouble()\n    var yearsNeeded=0\n    while(initialPopulation<populationToSurpass){\n        yearsNeeded++\n        initialPopulation=initialPopulation+ (initialPopulation*(percent\/100))+constantIncomersOrLeavers\n    }\n    \n    return yearsNeeded\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206555,"user_id":527,"body":"package growth\n\nfun nb_year(p0: Int, percent: Double, aug: Int, p: Int): Int {\n    tailrec fun iter(nYears: Int, curP: Int): Int =\n        if (curP >= p) nYears\n        else iter(nYears + 1, (curP * (100 + percent) \/ 100).toInt() + aug)\n    return iter(0, p0)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206556,"user_id":null,"body":"package growth\n\nfun nb_year(pp0:Int, percent:Double, aug:Int, p:Int):Int {\n    \nvar year = 0\n    var population = pp0.toDouble()\n    while(population<p){\n        population = (population * percent \/100 ) + aug + population\n        year++\n    }\n    return year\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"563f0c54a22b9345bf000053":[{"id":206557,"user_id":527,"body":"package disguised\n\nimport java.math.BigInteger\n\nfun fcn(n: Int): BigInteger = BigInteger.ONE.shiftLeft(n)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206558,"user_id":null,"body":"package disguised\n\nimport java.math.BigInteger\n\nfun fcn(n:Int):BigInteger = BigInteger.valueOf(2).pow(n)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206559,"user_id":492,"body":"package disguised\n\nimport java.math.BigInteger\n\nfun fcn(n:Int):BigInteger {\n    return BigInteger.ONE.shiftLeft(n)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206560,"user_id":null,"body":"package disguised\nimport java.math.BigInteger\n\nfun fcn(n:Int):BigInteger = BigInteger.TWO.pow(n)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206561,"user_id":null,"body":"package disguised\n\nimport java.math.BigInteger\n\nfun fcn(n:Int):BigInteger =\n  when (n) {\n    0 -> BigInteger.ONE\n    1 -> BigInteger.valueOf(2)\n    else -> {\n      (2..n)\n        .fold(Pair(BigInteger.valueOf(1), BigInteger.valueOf(2))) { p, _ ->\n          Pair(p.second, BigInteger.valueOf(6) * p.first * p.second \/ (BigInteger.valueOf(5) * p.first - p.second))\n        }\n        .second\n    }\n  }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206562,"user_id":932,"body":"package disguised\nimport java.math.BigInteger\n\/\/ It is very simple, actually doesn't need BigInteger. But the requirement is need BigInteger.\n\/\/ So the solution is here\n\nfun fcn(n:Int)=BigInteger.ONE.shl(n)\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206563,"user_id":null,"body":"package disguised\nimport java.math.BigInteger\nfun fcn(n: Int): BigInteger = BigInteger(\"2\").pow(n)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206564,"user_id":null,"body":"package disguised\n\nimport java.math.BigInteger\n\nfun fcn(n:Int):BigInteger {\n    var uN: BigInteger = 1.toBigInteger()\n    var uNplus1: BigInteger = 2.toBigInteger()\n    var uNplus2: BigInteger = 0.toBigInteger()\n    for (i in 2..n) {\n        uNplus2 = 6.toBigInteger() * uN * uNplus1 \/ (5.toBigInteger() * uN - uNplus1)\n        uN = uNplus1\n        uNplus1 = uNplus2\n    }\n    return uNplus2\n    \/\/ second one, just return 2^n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206565,"user_id":1251,"body":"package disguised\n\nfun fcn(n: Int) = 1.toBigInteger() shl n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206566,"user_id":null,"body":"package disguised\n\nimport java.math.BigInteger\n\nval container = mutableListOf<BigInteger>(1.toBigInteger(), 2.toBigInteger(), 4.toBigInteger(), 8.toBigInteger())\n\nfun fcn(n:Int):BigInteger {\n    return if (n < container.size - 1) container[n]\n    else {\n        container.add(container.last()*2.toBigInteger())\n        fcn(n)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"564057bc348c7200bd0000ff":[{"id":206567,"user_id":null,"body":"package thirteen\n\nval seq = listOf(1, 10, 9, 12, 3, 4);\n\ntailrec fun thirt(n:Long):Long {\n    val v = n.toString().toList()\n        .reversed()\n        .mapIndexed { index, c -> c.toString().toLong() * seq[index % seq.size] }\n        .sum()\n    return if(v < 100) v else thirt(v)\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206568,"user_id":null,"body":"package thirteen\n\nval rem = arrayOf(1, 10, 9, 12, 3, 4)\n\ntailrec fun thirt(n: Long): Long {\n    val new = n.toString().reversed().map { it - '0' }.mapIndexed { i, c -> rem[i% rem.size] * c }.sum().toLong()\n    return if (new == n) n\n    else thirt(new)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206569,"user_id":null,"body":"package thirteen\n\nfun thirt(n:Long):Long {\n    return repeatUntilStasionary(n, ::thirteenReminderSum)\n}\n\nfun <T> repeatUntilStasionary(initialValue: T, function: (T) -> T): T {\n    var lastValue = initialValue\n    var currentValue = function(lastValue)\n    while (lastValue != currentValue) {\n        lastValue = currentValue\n        currentValue = function(currentValue)\n    }\n    return currentValue\n}\n\nfun thirteenReminderSum(n: Long): Long {\n    val remainders = listOf(1, 10, 9, 12, 3, 4)\n    return n.toString()\n        .reversed()\n        .mapIndexed { index, digitChar ->\n            val digit = Character.getNumericValue(digitChar)\n            digit * remainders.getModulo(index)\n        }\n        .sum()\n        .toLong()\n}\n \nfun <T> List<T>.getModulo(index: Int): T {\n    val correctedIndex = index % size\n    return get(correctedIndex)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206570,"user_id":null,"body":"package thirteen\n\nfun thirt(n:Long):Long {\n    val repeatingSeq = listOf(1, 10, 9, 12, 3, 4)\n    return generateSequence(Pair(0L, n)) { pair ->\n        Pair(pair.second, pair.second\n            .toString()\n            .reversed()\n            .chunked(1)\n            .mapIndexed { i, v -> v.toLong() * repeatingSeq[i % repeatingSeq.size] }\n            .sum()\n        ).takeIf { it.first != it.second }\n    }.last().second\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206571,"user_id":null,"body":"package thirteen\n\nval seq = arrayOf(1, 10, 9, 12, 3, 4)\n\ntailrec fun thirt(n:Long):Long {\n    val result = n\n        .toString()\n        .reversed()\n        .foldIndexed(0L) {index, acc, c -> acc + c.digitToInt() * seq[index % seq.size] }\n\n    return if (result == n) n else thirt(result)\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206572,"user_id":null,"body":"package thirteen\n\nfun thirt(n:Long):Long = n.toString()\n        .reversed()\n        .map{ it - '0' }\n        .chunked(6){ it.zip(listOf(1, 10, 9, 12, 3, 4)) }\n        .flatten()\n        .sumBy{ it.first * it.second }\n        .toLong()\n        .let{ if(it == n) n else thirt(it) }\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206573,"user_id":null,"body":"package thirteen\n\nfun thirt(n:Long):Long {\n      \/\/variables\n    var num={numbers:Long->numbers.toString().reversed().toCharArray()}; var count:Long=0\n    var index=0;var same:Long=0\n    \n    \/\/loop\n    while (true) {\n        for (i in num(if(same.toInt()==0) n else same)) {\n            if (index == 6) index = 0\n            count += i.toString().toInt().times(\"1,10,9,12,3,4\".split(\",\").get(index).toInt());index++\n        }\n        if(same==count) return count else{same=count}\n        count=0;index=0}\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206574,"user_id":null,"body":"package thirteen\n\nval rem = intArrayOf(1, 10, 9, 12, 3, 4)\n\nfun thirt(n: Long): Long {\n    \n    var act = n\n    var old = -1L\n    \n    while(act != old) {\n        old = act\n    \tact = thirtOne(act)\n    }\n    \n    return act\n    \n}\n\nfun thirtOne(n: Long): Long =\n    n.toString()\n     .split(\"\")\n     .asReversed()\n     .filter{ x -> !x.isEmpty()}\n     .map{ x -> x.toLong()}\n     .withIndex()\n     .map{x -> x.value * rem[x.index % rem.size]}\n     .sum()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206575,"user_id":null,"body":"package thirteen\n\nval remainders: LongArray = longArrayOf(1, 10, 9, 12, 3, 4)\n\nfun thirt(n:Long):Long {\n    return process(n, -1)\n}\n\nfun process(n: Long, remainderParam: Long) : Long {\n  if (n == remainderParam) return n\n  var idx = 0\n  var sum : Long = 0\n  var remainder = n\n  var target = n\n  \n  while(target > 0) {\n    var curr = target % 10\n    sum += curr * remainders[ idx ]\n    \n    target \/= 10\n    idx++\n    idx %= remainders.size\n  }\n  \n  return process(sum, remainder)\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206576,"user_id":492,"body":"package thirteen\n\nfun thirt(m:Long):Long {\n    val w = intArrayOf(1, 10, 9, 12, 3, 4)\n    var n = m\n    while (true)\n    {\n      var r = n\n      var q:Long = -1\n      var c:Long = 0\n      var j = 0\n      while (q != 0L)\n      {\n        q = (r \/ 10).toLong()\n        c += (r % 10) * w[j % 6]\n        r = q\n        j++\n      }\n      if (c == n)\n      \treturn c\n      n = c\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"56445c4755d0e45b8c00010a":[{"id":206577,"user_id":null,"body":"package banker\n\nfun fortune(f0:Int, p:Double, c0:Int, n:Int, i:Double):Boolean {\n    println(\"$f0, $p, $c0, $n, $i\")\n    \n    var balance = f0\n    var withdraw = c0\n\n    for (j in 1 until n) {\n        balance = balance + (p \/ 100.0 * balance).toInt() - withdraw\n        withdraw += (i \/ 100.0 * withdraw.toDouble()).toInt()\n    }\n\n    return balance >= 0\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206578,"user_id":null,"body":"package banker\n\nfun fortune(f0 :Int, p :Double, c0 :Int, n :Int, i :Double) :Boolean {\n    var fk = f0\n    if (fk<0)\n      return false\n    var ck = c0\n    for (k in 1 until n) {\n       fk = (fk+fk*0.01*p-ck).toInt()\n       if (fk<0)\n         return false\n       ck = (ck+ck*0.01*i).toInt()\n    }\n    return true\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206579,"user_id":null,"body":"package banker\n\n    fun fortune(f0:Int, p:Double, c0:Int, n:Int, i:Double):Boolean {\n        var fn: Int = f0\n        var cn: Int = c0\n        for (k in 0 until n - 1) {\n            fn = (fn + (p \/ 100).toDouble() * fn - cn).toInt()\n            cn = (cn + cn * (i \/ 100).toDouble()).toInt()\n        }\n        return fn >= 0\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206580,"user_id":null,"body":"package banker\n\nimport kotlin.math.pow\n\nfun fortune(f0:Int, p:Double, c0:Int, n:Int, i:Double):Boolean {\n    return if (n <= 1) {\n        f0 >= 0\n    } else {\n        fortune((f0 * (1 + p \/ 100)).toInt() - c0, p, (c0 * (1 + i \/ 100)).toInt(), n - 1, i)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206581,"user_id":null,"body":"package banker\n\nfun fortune(f0:Int, p:Double, c0:Int, n:Int, i:Double):Boolean {\n    \/\/ your code\n    var depositPerYear:Int = f0;\n    var withDraw: Int = c0;\n    var year:Int = 1;\n\n    while(depositPerYear>=0){\n        depositPerYear = (depositPerYear +  (p\/100)*depositPerYear - withDraw).toInt()\n        withDraw = (withDraw * (1+(i\/100))).toInt()\n        year++\n    }\n\n    return year>n;\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206582,"user_id":null,"body":"package banker\nimport kotlin.math.floor\n\nfun fortune(f0:Int, p:Double, c0:Int, n:Int, i:Double):Boolean {\n    val inflation = i \/ 100\n    val percent = p \/ 100\n    \n    var f = f0.toDouble()\n    var c = c0.toDouble()\n    repeat (n - 1) {\n        f = floor(f + percent * f - c)\n        if (f < 0) return false\n        c += floor(c * inflation)\n    }\n    return true\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206583,"user_id":null,"body":"package banker\n\nfun fortune(f0:Int, p:Double, c0:Int, n:Int, i:Double):Boolean {\n    val f = (f0 + f0 * p \/ 100).toInt()\n    val c = (c0 + c0 * i \/ 100).toInt()\n    val x = f - c0\n\n    if (n > 2 && x > 0)\n        return fortune(x, p, c, n - 1, i)\n\n    return x >= 0\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206584,"user_id":null,"body":"package banker\n\n    fun fortune(f0:Int, p:Double, c0:Int, n:Int, i:Double):Boolean {\n        var balance: Int = f0\n        var cashWithdrawal: Int = c0\n        for (j in 0 until n - 1) {\n            balance = (balance + (p \/ 100).toDouble() * balance - cashWithdrawal).toInt()\n            cashWithdrawal = (cashWithdrawal + cashWithdrawal * (i \/ 100).toDouble()).toInt()\n        }\n        if (balance >= 0) {\n            return true\n        } else {\n            return false\n        }\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206585,"user_id":null,"body":"package banker\n\nfun fortune(f0: Int, p: Double, c0: Int, n: Int, i: Double): Boolean {\n    var f = f0\n    var c = c0\n    for(j in 0 until n){\n        if(f < 0) return false\n        f = (f + f * (p \/ 100.0) - c).toInt()\n        c = (c + c * (i \/ 100.0)).toInt()\n    }\n    return true\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206586,"user_id":null,"body":"package banker\n\nfun fortune(f0:Int, p:Double, c0:Int, n:Int, i:Double):Boolean {\n    var money = f0\n    var withdraw = c0\n    var year = 1\n    while(money > 0){\n        money = (money*(100+p)\/100).toInt()\n        if(money >= withdraw)\n            money -= withdraw\n        else break\n        withdraw = (withdraw*(100+i)\/100).toInt()\n        year++\n        if(year > n) break\n    }\n    return year >= n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"56484848ba95170a8000004d":[{"id":206587,"user_id":null,"body":"package gps\n\nfun gps(s: Int, x: DoubleArray) = x.toList()\n    .windowed(2) { it[1] - it[0] }\n    .map { 3600 * it \/ s }\n    .max()\n    ?.toInt() ?: 0","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206588,"user_id":null,"body":"package gps\n\nfun gps(s: Int, x: DoubleArray) = x.asSequence().zipWithNext { a, b -> (b - a) * 3600 \/ s }.max()?.toInt() ?: 0","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206589,"user_id":null,"body":"package gps\n\nfun gps(s:Int, x:DoubleArray) = x.mapIndexed { index: Int, d: Double ->\n    (3600 * (x.getOrElse(index + 1) { d } - d))\/s\n}.max()?.toInt() ?: 0","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206590,"user_id":null,"body":"package gps\n\nfun gps(s:Int, x:DoubleArray) = if (x.size < 2) 0 else \n    (0 until x.lastIndex).map{ (3600 * (x[it + 1] - x[it])) \/ s }.max()!!.toInt()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206591,"user_id":null,"body":"package gps\n\nfun gps(s:Int, x:DoubleArray):Int {\n    if (x.size < 2) {\n        return 0\n    }\n\n    return x.calculateDiffs().map { (3600 * it) \/ s }.max()!!.toInt()\n}\n\nfun DoubleArray.calculateDiffs() : DoubleArray {\n    val d = DoubleArray(size)\n    for (i in (2 until size)) {\n        d[i] = this[i] - this[i - 1]\n    }\n\n    return d\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206592,"user_id":null,"body":"package gps\n\nfun gps(s:Int, x:DoubleArray):Int {\n    if (x.sum() <=1) return 0\n    var max = x[1]-x[0]\n    for (i in 2 until x.size) { if (x[i] - x[i-1] > max) max = x[i] - x[i-1] }\n    return (3600 * max \/ s).toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206593,"user_id":null,"body":"package gps\n\nfun gps(s:Int, x:DoubleArray):Int {\n    return x.mapIndexed { currentIndex, currentElement ->\n        val deltaDistance = (x.getOrElse(currentIndex + 1) { currentElement } - currentElement)\n        (3600 * deltaDistance \/ s)\n    }.max()?.toInt() ?: 0\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206594,"user_id":null,"body":"package gps\n\nfun gps(s: Int, x: DoubleArray) =\n    x.mapIndexed { currentIndex, currentElement ->\n        if (currentIndex != x.lastIndex) {\n            ((x[currentIndex + 1] - currentElement) * 3_600 \/ s).toInt()\n        } else 0\n    }.max() ?: 0","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206595,"user_id":null,"body":"package gps\n\nfun gps(s:Int, x:DoubleArray):Int {\n    return (0 until x.size-1).map {\n        val diff:Double = x[it+1] - x[it]\n        if (diff <= 0) 0 else (diff*3600\/s).toInt()\n    }.filterNotNull().max() ?: 0\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206596,"user_id":null,"body":"package gps\n\nfun gps(s:Int, x:DoubleArray):Int {\n        return if(x.size <= 1) 0 else x.mapIndexed { index, value ->\n            if (index == 0) 0.0 else (3600 * (value - x[index - 1]) \/ s)\n        }.subList(1, x.size).max()!!.toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5648b12ce68d9daa6b000099":[{"id":206597,"user_id":null,"body":"fun people(busStops: Array<Pair<Int, Int>>) = busStops.sumBy { it.first - it.second }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206598,"user_id":null,"body":"fun people(busStops: Array<Pair<Int, Int>>) = busStops.sumOf { it.first - it.second }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206599,"user_id":527,"body":"fun people(busStops: Array<Pair<Int, Int>>): Int {\n    return busStops.sumBy { (on, off) -> on - off }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206600,"user_id":null,"body":"fun people(busStops: Array<Pair<Int, Int>>) : Int {\n  return busStops.map{it.first - it.second}.reduce{peopleRemaining, passengers -> \n                                  peopleRemaining + passengers}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206601,"user_id":null,"body":"fun people(busStops: Array<Pair<Int, Int>>) : Int {\n  \/\/code here\n    var numberOfPeopleOnBus = 0\n    busStops.forEach {  numberOfPeopleOnBus = numberOfPeopleOnBus + it.first - it.second }\n    return numberOfPeopleOnBus\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206602,"user_id":null,"body":"fun people(busStops: Array<Pair<Int, Int>>) : Int = with(busStops.unzip()) { first.sum() - second.sum() }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206603,"user_id":null,"body":"fun people(busStops: Array<Pair<Int, Int>>) : Int {\n  var commonIn = busStops.sumBy { it.first }\n  var commonOut = busStops.sumBy { it.second }\n\n  var commonPeople = commonIn - commonOut\n  return commonPeople\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206604,"user_id":null,"body":"fun people(busStops: Array<Pair<Int, Int>>) : Int {\n  return busStops.fold(0,{a,p->a+p.first-p.second})\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206605,"user_id":null,"body":"fun people(busStops: Array<Pair<Int, Int>>) = busStops.sumOf { it.first } - busStops.sumOf { it.second }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206606,"user_id":null,"body":"fun people(busStops: Array<Pair<Int, Int>>) : Int {\n    var total = 0\n    \n    for (element in busStops) {\n       total += element.first\n       total -= element.second\n    }\n    \n    return total;\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"56541980fa08ab47a0000040":[{"id":206607,"user_id":null,"body":"fun printer_error(s: String) = \"${s.count { it !in 'a'..'m' }}\/${s.length}\"","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206608,"user_id":null,"body":"fun printer_error(s: String): String {\n  val errors = s.count { it !in 'a'..'m' }\n  val length = s.length\n  return \"$errors\/$length\"\n}  ","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206609,"user_id":527,"body":"fun printer_error(s: String): String {\n    return \"${s.count{it > 'm'}}\/${s.length}\"\n}  ","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206610,"user_id":null,"body":"fun printer_error(s: String): String {\n    var t = 0\n    for (i in 0..(s.length-1)) {\n        if (s[i] in 'n'..'z') {\n            t++\n        }\n    }\n    return (\"$t\/${s.length}\")\n}  ","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206611,"user_id":null,"body":"fun printer_error(s: String): String {\n  val wrong = s.count { it.toInt() > 'm'.toInt() }\n  return \"$wrong\/${s.length}\"\n}  ","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206612,"user_id":null,"body":"fun printer_error(s: String): String = \"${Regex(\"[a-m]\").replace(s, \"\").length}\/${s.length}\"\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206613,"user_id":null,"body":"fun printer_error(s: String): String {\n    val bad: String = \"nopqrstuvwxyz\"\n    var err: Int = 0;\n    s.forEach {\n        if (bad.contains(it)) err++\n    }\n    return \"$err\/${s.length}\"\n}  ","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206614,"user_id":null,"body":"fun printer_error(s: String) = \"${s.count {it > 'm'}}\/${s.length}\"","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206615,"user_id":null,"body":"fun printer_error(s: String): String {\n  \/\/ code here\n  return \"${s.filter { it>'m' }.length}\/${s.length}\"\n}  ","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206616,"user_id":1267,"body":"fun printer_error(s: String): String = \"${s.replace(Regex(\"\"\"[a-m]\"\"\"), \"\").length}\/${s.length}\"","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5656b6906de340bd1b0000ac":[{"id":206617,"user_id":null,"body":"package twotoone\n\nfun longest(s1:String, s2:String):String {\n    return (s1 + s2).toSortedSet().joinToString(\"\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206618,"user_id":null,"body":"package twotoone\n\nfun longest(s1:String, s2:String) = (s1 + s2).toSortedSet().joinToString(\"\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206619,"user_id":null,"body":"package twotoone\n\nfun longest(s1:String, s2:String):String {\n   return \"abcdefghijklmnopqrstuvwxyz\".filter { it in s1 || it in s2 }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206620,"user_id":null,"body":"package twotoone\n\nfun longest(s1:String, s2:String):String = (s1 + s2).toCharArray().toSortedSet().joinToString(separator = \"\")\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206621,"user_id":null,"body":"package twotoone\n\nfun longest(s1:String, s2:String):String {\n    val isValidCharacter = { a: Char -> a in 'a'..'z' }\n\n    return s1.toList()\n        .asSequence()\n        .plus(s2.toList())\n        .distinct()\n        .filter(isValidCharacter)\n        .sorted()\n        .joinToString(separator = \"\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206622,"user_id":null,"body":"package twotoone\n\nfun longest(s1:String, s2:String):String {\n     var string = \"\"\n    var c = s1.toSortedSet().toMutableSet()\n    c.addAll(s2.toSortedSet())\n    for (i in c.sorted()){\n        string += i\n    }\n\n    return string\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206623,"user_id":null,"body":"package twotoone\n\nfun longest(s1:String, s2:String) = (s1+s2).toCharArray().distinct().sorted().joinToString(\"\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206624,"user_id":null,"body":"package twotoone\n\nfun longest(s1:String, s2:String) = \"$s1$s2\".toSortedSet().joinToString(\"\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206625,"user_id":null,"body":"package twotoone\n\nfun longest(s1:String, s2:String) = \"$s1$s2\".asSequence().distinct().sorted().joinToString(\"\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206626,"user_id":null,"body":"package twotoone\n\nfun longest(s1:String, s2:String):String {\n    var t=s1\n    var s = s2\n    var b:String = \"\"\n    var b2:String =\"\"\n    var sd = \"\"\n    var t2=\"\"\n   for (i in 'a'..'z') {\n       if (t.contains(i)) {\n           b = b.plus(\"$i\")\n       }\n       if (s.contains(i)) {\n           b2 = b2.plus(\"$i\")\n       }\n   }\n    sd=b.plus(b2)\n    for (i in 'a'..'z'){\n        if(sd.contains(i)){\n            t2=t2.plus(i)\n        }\n    }\n    return t2\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"565abd876ed46506d600000d":[{"id":206627,"user_id":53,"body":"package simpson\n\nfun simpson(n:Int):Double {\n    return Math.PI\/n.toDouble()*(1.0+2.0*Math.pow(Math.cos(Math.PI\/n.toDouble()),3.0)+3.0*Math.cos(2.0*Math.PI\/n.toDouble()))\/(Math.sin(3.0*Math.PI\/n.toDouble()))\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206628,"user_id":492,"body":"package simpson\n\nprivate fun f(x:Double):Double {\n    return 1.5 * Math.pow(Math.sin(x), 3.0)\n}\nfun simpson(n:Int):Double {\n    val h = Math.PI \/ n\n    var s1 = 0.0\n    for (i in 1..(n \/ 2).toInt())\n    {\n      s1 += f((2 * i - 1) * h)\n    }\n    var s2 = 0.0\n    for (i in 1..(n \/ 2).toInt() - 1)\n    {\n      s2 += f(2.0 * i.toDouble() * h)\n    }\n    return Math.PI \/ (3 * n) * (f(0.0) + f(Math.PI) + 4 * s1 + 2 * s2)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206629,"user_id":null,"body":"package simpson\n\nfun simpson(n:Int) = Math.PI \/ 3 \/ n * (4 * (1..n \/ 2).map { f((2 * it - 1) * Math.PI \/ n) }.sum() + 2 * (1..n \/ 2 - 1).map { f(2 * it * Math.PI \/ n) }.sum())\n\nfun f(d: Double) = 3 * Math.pow(Math.sin(d), 3.0) \/ 2","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206630,"user_id":null,"body":"package simpson\n\nimport kotlin.math.sin\n\nconst val a = 0.0\nconst val b = Math.PI\n\nfun f(x:Double) = 1.5 * Math.pow(sin(x), 3.0)\n\nfun simpson(n: Int): Double {\n    val h = (b-a)\/n\n    val p = (1..n\/2).map { i -> f(a+(2*i-1)*h) }.sum()\n    val q = (1 until n\/2).map { i -> f(a+2*i*h) }.sum()\n    return h\/3*(f(a)+f(b)+4*p+2*q)\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206631,"user_id":null,"body":"package simpson\nimport kotlin.math.pow\nimport kotlin.math.sin\n\nfun simpson(n:Int):Double {\n    val a = 0.0\n    val b = Math.PI\n    var result = f(a) + f(b)\n    val h = (b - a) \/ n\n    for (i in 1..(n \/ 2)) {\n        result += 4 * f(a + (2 * i - 1) * h)\n    }\n    for (i in 1 until n \/ 2) {\n        result += 2 * f(a + 2 * i * h)\n    }\n    return result * ((b - a) \/ (3 * n))\n}\n\nfun f(x: Double): Double {\n    return 3.0 \/ 2 * (sin(x).pow(3))\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206632,"user_id":null,"body":"package simpson\nimport kotlin.math.*\nfun simpson(n:Int):Double {\n  var a=0.0\n  var b=PI\n  var sum1=0.0\n  var sum2=0.0\n  var sum=0.0\n  var h:Double=(b-a)\/n\n         \n for (i in 1..(n\/2)) {\n         sum=sin(a+(2*i-1)*h).pow(3)*1.5\n         sum1=sum1+sum\n         }\n         sum=0.0\nfor (i in 1..n\/2-1) {\n          sum=sin(a+2*i*h).pow(3)*1.5\n          sum2=sum2+sum\n          }\n          \n      return((b-a)*(sin(a).pow(3)*1.5+sin(b).pow(3)*1.5+4*sum1+2*sum2)\/(3*n))\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206633,"user_id":null,"body":"package simpson\n\nfun simpson(n: Int): Double = (Math.PI \/ n).let { h ->\n    h \/ 3 * (1..(n \/ 2)).sumOf { i ->\n        4 * Fn((2.0 * i - 1) * h) +\n        2 * Fn((2.0 * i) * h)\n    }\n}\n\nfun Fn(x: Double): Double = 1.5 * Math.pow(Math.sin(x), 3.0)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206634,"user_id":null,"body":"package simpson\n\nimport kotlin.math.PI\nimport kotlin.math.pow\nimport kotlin.math.sin\n\nfun simpson(n: Int): Double {\n\n    val h = PI \/ n\n    val sum = (0..n).map { myFun(it * h) }.dropLast(1).mapIndexed { index, i ->\n        when {\n            index == 0 -> 0.0\n            index % 2 == 1 -> 4.0 * i\n            else -> 2.0 * i\n        }\n    }.sum()\n\n    return sum \/ 3.0 * h\n}\n\nprivate fun myFun(x: Double): Double = 1.5 * sin(x).pow(3)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206635,"user_id":null,"body":"package simpson\n\nfun simpson(n:Int):Double {\n    fun f(x: Double) = 1.5 * Math.sin(x) * Math.sin(x) * Math.sin(x)\n\tval a = 0.0\n\tval b = Math.PI\n\tval h = (b - a) \/ n\n\tvar s = f(a) + f(b)\n\ts += (1 until n step 2).map { 4 * f(a + it * h) }.sum() + (2 until n-1 step 2).map { 2 * f(a + it * h) }.sum()\n\treturn s * h \/ 3\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206636,"user_id":null,"body":"package simpson\n\nfun simpson(n:Int):Double {\n    fun f(x: Double) = 1.5 * Math.sin(x) * Math.sin(x) * Math.sin(x)\n\tval a = 0.0\n\tval b = Math.PI\n\tval h = (b - a) \/ n\n\tvar s = f(a) + f(b)\n\tfor (i in 1 until n step 2)\n\t\ts += 4 * f(a + i * h)\n\tfor (i in 2 until n-1 step 2)\n\t\ts += 2 * f(a + i * h)\n\treturn s * h \/ 3\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"565c0fa6e3a7d39dee000125":[{"id":206637,"user_id":null,"body":"package braking\n\nimport kotlin.math.pow\nimport kotlin.math.sqrt\n\nfun dist(v: Double, mu: Double): Double =\n  (v.mps()).pow(2) \/ (mu * 19.62) + v.mps()\n\nfun speed(d: Double, mu: Double): Double =\n  ((sqrt(1.0 + (d \/ (mu * 4.905))) - 1.0) * mu * 9.81).kph()  \/\/ much quadratic twaddling\n\n\/\/ Convert kph to mps\nprivate fun Double.mps(): Double = this * 10 \/ 36\n\n\/\/ Convert mps to kph\nprivate fun Double.kph(): Double = this * 36 \/ 10\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206638,"user_id":492,"body":"package braking\n\nfun dist(v:Double, mu:Double):Double { \/\/ suppose reaction time is 1\n    val g = 9.81 \/\/ acceleration due to gravity in m\/s\n    val coef = 1000 \/ 3600.0 \/\/ km\/h -> m\/s\n    val dreact = v * coef \/\/ distance of reaction with t = 1\n    val vms = coef * v \/\/ speed in m\/s\n    val dbrak = 0.5 * Math.pow(vms, 2.0) \/ mu \/ g \/\/ braking distance\n    return dreact + dbrak\n  }\nfun speed(d:Double, mu:Double):Double { \/\/ suppose reaction time is 1\n    val g = 9.81 \/\/ acceleration due to gravity in m\/s\n    val coef = 3600 \/ 1000.0 \/\/ m\/s -> km\/h\n    return 0.5 * mu * g * (-2 + Math.sqrt(4 + 8 * d \/ mu \/ g)) * coef\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206639,"user_id":null,"body":"package braking\n\nimport kotlin.math.pow\nimport kotlin.math.sqrt\n\nfun dist(v: Double, mu: Double): Double =\n  (v.mps()).pow(2) \/ (mu * 19.62) + v.mps()\n\nfun speed(d: Double, mu: Double): Double =\n  ((sqrt(1.0 + (d \/ (mu * 4.905))) - 1.0) * mu * 9.81).kph()  \/\/ much quadratic twaddling\n\n\/\/ Convert kph to mps\nprivate fun Double.mps(): Double = this * 0.2777777778\n\n\/\/ Convert mps to kph\nprivate fun Double.kph(): Double = this \/ 0.2777777778\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206640,"user_id":null,"body":"package braking\n\nimport kotlin.math.sqrt\n\nconst val REACTION_TIME = 1\nconst val REACTION_TIME_SQR = REACTION_TIME * REACTION_TIME\nconst val EARTH_GRAVITY = 9.81\nval EARTH_GRAVITY_SQRT = sqrt(EARTH_GRAVITY)\n\nfun dist(v: Double, mu: Double) = (v \/ 3.6).run { (this * this) \/ (2 * mu * EARTH_GRAVITY) + (REACTION_TIME * this) }\nfun speed(d: Double, mu: Double): Double {\n    return (EARTH_GRAVITY_SQRT *\n            sqrt(mu) *\n            sqrt(2 * d + EARTH_GRAVITY * mu * REACTION_TIME_SQR) -\n            EARTH_GRAVITY * mu * REACTION_TIME) * 3.6\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206641,"user_id":492,"body":"package braking\n\nfun dist(v:Double, mu:Double):Double { \/\/ suppose reaction time is 1\n    val g = 9.81 \/\/ acceleration due to gravity in m\/s\n    val coef = 1000 \/ 3600.0 \/\/ km\/h -> m\/s\n    val dreact = v * coef \/\/ distance of reaction with t = 1\n    val vms = coef * v \/\/ speed in m\/s\n    val dbrak = 0.5 * Math.pow(vms, 2.0) \/ mu \/ g \/\/ braking distance\n    return dreact + dbrak\n  }\nfun speed(d:Double, mu:Double):Double { \/\/ suppose reaction time is 1\n    val g = 9.81 \/\/ acceleration due to gravity in m\/s\n    val coef = 3600 \/ 1000.0 \/\/ m\/s -> km\/h\n    return 0.5 * mu * g * (-2 + Math.sqrt(4 + 8 * d \/ mu \/ g)) * coef\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206642,"user_id":null,"body":"package braking\n\nimport kotlin.math.sqrt\n\nfun dist(v:Double, mu:Double):Double { \/\/ suppose reaction time is 1\n    val g = 9.81\n    val vMS = v \/ 3.6\n    return vMS + vMS * vMS \/ (2 * mu * g)\n}\nfun speed(d:Double, mu:Double):Double { \/\/ suppose reaction time is 1\n    val g = 9.81\n    return ((-2 * mu * g) + sqrt((2 * mu * g) * (2 * mu * g) + 4 * 2 * d * mu * g)) * 3.6 \/ 2\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206643,"user_id":null,"body":"package braking\n\nimport kotlin.math.sqrt\n\nfun dist(v:Double, mu:Double):Double { \/\/ suppose reaction time is 1\n    val w = v \/ 3.6\n    return w + w * w \/ (2 * mu * 9.81)\n  }\nfun speed(d:Double, mu:Double):Double { \/\/ suppose reaction time is 1    \n    val k = 1 \/ (2 * mu * 9.81)\n    var x1 = (-1 + sqrt(1 + 4 * k * d)) \/ (2 * k)\n    return x1 * 3.6\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206644,"user_id":null,"body":"package braking\nimport kotlin.math.*\n\nfun dist(v:Double, mu:Double):Double { \/\/ suppose reaction time is 1\n    val speed = v\/3.6\n    val g = 9.81\n    var total = (0.5 * speed*speed \/ (mu * g)) + speed\n    println (\"Total distanse is $total\")\n    return total\n  }\nfun speed(d:Double, mu:Double):Double { \/\/ suppose reaction time is 1\n    val g = 9.81\n    var gear = 0.5*mu*g* (-2+ Math.sqrt(4+8*d\/mu\/g)) * 3.6\n    return gear\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206645,"user_id":null,"body":"package braking\n\nimport kotlin.math.sqrt\n\nfun dist(speed:Double, mu:Double):Double { \/\/ suppose reaction time is 1\n    val v : Double  = 1000.0*speed \/ 3600.0\n    val g = 9.81\n    val t : Double = 1.0\n    val d = v*v \/ (2*mu*g) + t*v    \n    \n    return d\n  }\nfun speed(d:Double, mu:Double):Double { \/\/ suppose reaction time is 1\n    val g = 9.81\n    val t : Double = 1.0\n    val v = mu*g*(sqrt(t*t + 2*d\/(mu*g)) - t)\n    \n    return 3600.0*v\/1000.0\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206646,"user_id":null,"body":"package braking\nimport kotlin.math.sqrt\n\nfun dist(v: Double, mu: Double): Double = with(v * 10 \/ 36) { this * this \/ (2 * mu * 9.81) + this }\n\nfun speed(d: Double, mu: Double): Double = with(1 + (2 * d) \/ (mu * 9.81)){(-1 +sqrt(this)) * mu * 9.81 * 3.6}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5663f5305102699bad000056":[{"id":206647,"user_id":null,"body":"package maxlendiff\n\nfun mxdiflg(a1:Array<String>, a2:Array<String>) \n    = a1.flatMap { s1 -> a2.map { kotlin.math.abs(s1.length - it.length) } }.max() ?: -1","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206648,"user_id":null,"body":"package maxlendiff\n\nfun mxdiflg(a1:Array<String>, a2:Array<String>) = if (a1.isEmpty() || a2.isEmpty()) -1 else listOf(\n    a1.maxBy { it.length }!!.length - a2.minBy { it.length }!!.length,\n    a2.maxBy { it.length }!!.length - a1.minBy { it.length }!!.length\n).max()","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206649,"user_id":null,"body":"package maxlendiff\n\nimport java.lang.Math.abs\nimport java.lang.Math.max\nimport java.util.*\nfun mxdiflg(a1:Array<String>, a2:Array<String>):Int {\n    var m=-1\n    for(x in a1)\n        for(y in a2)\n            m=max(m, abs(x.length - y.length))\n    return m\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206650,"user_id":null,"body":"package maxlendiff\n\nfun mxdiflg(a1: Array<String>, a2: Array<String>): Int {\n\n    \/\/ Don't try to calculate anything for empty arrays.\n    if(a1.isEmpty() || a2.isEmpty()) return -1\n    \n    \/\/ Sort both arrays by length.\n    a1.sortBy { it.length }\n    a2.sortBy { it.length }\n\n    \/**\n     * Get length difference of two arrays.\n     * Firstly measure the length difference between the longest word from a2 and shortest from a1.\n     * Then measure the length difference between the longest word from a1 and shortest from a2.\n     *\/\n    val firstLengthDifference = a2.last().length - a1.first().length\n    val secondLengthDifference = a1.last().length - a2.first().length\n\n    \/\/ Get a bigger value of two length differences.\n    return maxOf(firstLengthDifference, secondLengthDifference)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206651,"user_id":null,"body":"package maxlendiff\n\n  fun mxdiflg(a1: Array<String>, a2: Array<String>): Int =\n            if (a1.isEmpty() || a2.isEmpty()) -1\n            else {\n                val maxA = a1.map { it.length }.max() ?: 0\n                val minA = a1.map { it.length }.min() ?: 0\n                val maxB = a2.map { it.length }.max() ?: 0\n                val minB = a2.map { it.length }.min() ?: 0\n\n                val difference1 = Math.abs(maxA - minB)\n                val difference2 = Math.abs(minA - maxB)\n                if (difference1 > difference2) difference1 else difference2\n            }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206652,"user_id":null,"body":"package maxlendiff\n\nfun mxdiflg(a1:Array<String>, a2:Array<String>):Int {\n    if(a1.size == 0 || a2.size == 0 ){\n      return -1\n    }\n    \n    val firstArrayMax = a1.map{ it -> it.length }.max() ?: -1\n    val secondArrayMax = a2.map{ it -> it.length }.max() ?: -1\n    val firstArrayMin = a1.map{ it -> it.length }.min() ?: -1\n    val secondArrayMin = a2.map{ it -> it.length }.min() ?: -1\n    \n    return if(firstArrayMax - secondArrayMin > secondArrayMax - firstArrayMin){\n          firstArrayMax - secondArrayMin\n        }else{\n          secondArrayMax - firstArrayMin\n        }\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206653,"user_id":null,"body":"package maxlendiff\nimport kotlin.math.abs\nimport kotlin.math.max\nfun mxdiflg(a1: Array<String>, a2: Array<String>): Int = if (a1.isEmpty() || a2.isEmpty()) -1 else\n    max(\n        abs(a1.minBy { it.length }?.length!! - a2.maxBy { it.length }?.length!!),\n        abs(a1.maxBy { it.length }?.length!! - a2.minBy { it.length }?.length!!)\n    )","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206654,"user_id":null,"body":"package maxlendiff\n\nfun mxdiflg(a1:Array<String>, a2:Array<String>):Int {\n  if (a1.isEmpty() or a2.isEmpty()) return -1\n  var minA1:Int = a1[0].length; var maxA1:Int=0\n  for (str:String in a1) {\n    if (str.length < minA1) minA1 = str.length\n    if (str.length > maxA1) maxA1 = str.length\n  }\n  var minA2:Int = a2[0].length; var maxA2:Int = 0\n  for (str:String in a2) {\n    if (str.length < minA2) minA2 = str.length\n    if (str.length > maxA2) maxA2 = str.length\n  }\n  val diff1:Int = Math.abs (maxA1 - minA2)\n  val diff2:Int = Math.abs (maxA2 - minA1)\n  return if(diff1 > diff2) diff1 else diff2\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206655,"user_id":492,"body":"package maxlendiff\n\nfun mxdiflg(a1:Array<String>, a2:Array<String>):Int {\n    var mx = -1\n    for (x in a1)\n    \tfor (y in a2)\n    \t{\n      \t\tval diff = Math.abs(x.length - y.length)\n      \t\tif (diff > mx) mx = diff\n    \t}\n    return mx\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206656,"user_id":null,"body":"package maxlendiff\nimport java.util.Arrays;\nimport java.util.stream.IntStream;\n\nfun mxdiflg(a1:Array<String>, a2:Array<String>):Int {\n   if (a1.size < 1 || a2.size < 1) return -1\n\n   val statisticsA1 = a1.toList().stream().mapToInt {it.length}.summaryStatistics()\n   val statisticsA2 = a2.toList().stream().mapToInt {it.length}.summaryStatistics()\n   \n   return Math.max(Math.abs(statisticsA1.max - statisticsA2.min), Math.abs(statisticsA2.max - statisticsA1.min))\n   \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"566543703c72200f0b0000c9":[{"id":206657,"user_id":null,"body":"package epidemy\n\nfun epidemic(tm: Int, n: Int, s0: Int, i0: Int, b: Double, a: Double): Int {\n    val dt = tm.toDouble() \/ n\n    var s = s0.toDouble()\n    var i = i0.toDouble()\n    repeat(n) {\n        val ds = dt * b * s * i\n        val dr = dt * a * i\n        if (dr > ds) return i.toInt()\n        s -= ds\n        i = i + ds - dr\n    }\n    return 0\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206658,"user_id":null,"body":"package epidemy\n\nfun epidemic(tm:Int, n:Int, s0:Int, i0:Int, b:Double, a:Double):Int {\n    val dt = tm.toDouble()\/n\n    var susceptibles = s0.toDouble()\n    var infecteds = i0.toDouble()\n    var prevSus = 0.0\n    var prevInf = 0.0\n    var maxInf = 0.0\n    while(true) {\n        susceptibles -= b* prevSus * prevInf *dt\n        infecteds += (b* prevSus * prevInf - a* prevInf)*dt\n        if(infecteds >= maxInf)\n            maxInf = infecteds\n        else\n            return maxInf.toInt()\n        prevSus = susceptibles\n        prevInf = infecteds\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206659,"user_id":492,"body":"package epidemy\n\nimport java.util.Arrays\n\nfun epidemic(tm:Int, n:Int, s0:Int, i0:Int, b:Double, a:Double):Int {\n    val dt = tm \/ n.toDouble()\n    val s = DoubleArray(n + 1)\n    s[0] = s0.toDouble()\n    val i = DoubleArray(n + 1)\n    i[0] = i0.toDouble()\n    val r = DoubleArray(n + 1)\n    r[0] = 0.0\n    val t = DoubleArray(n + 1)\n    t[0] = 0.0\n    var k = 1\n    while (k < n + 1)\n    {\n      t[k] = k * dt\n      k++\n    }\n    k = 0\n    var mx = -1.0\n    while (k < n)\n    {\n      s[k + 1] = s[k] - dt * b * s[k] * i[k]\n      i[k + 1] = i[k] + dt * (b * s[k] * i[k] - a * i[k])\n      r[k + 1] = r[k] + dt * i[k] * a\n      if (i[k + 1] > mx) mx = i[k + 1]\n      k++\n    }\n    return mx.toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206660,"user_id":null,"body":"package epidemy\n\nfun epidemic(tm:Int, n:Int, s0:Int, i0:Int, b:Double, a:Double):Int {\n   val dt = tm.toDouble()\/n.toDouble()\n   \n   var s = s0.toDouble()\n   var i = i0.toDouble()\n   var r = 0.0\n   \n   var maxi = i\n   \n   for (j in 0..n)\n   {\n   \n       var snext = s - (dt * b * s * i)\n       var inext = i + (dt * ((b * s * i) - (a * i)))\n       var rnext = r + (dt * i * a)\n    \n       s = snext\n       i = inext\n       r = rnext\n       \n       if (i > maxi) maxi = i\n   }\n   \n   \n   return maxi.toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206661,"user_id":null,"body":"package epidemy\n\ndata class State(val s:Double, val i:Double, val r:Double){\n    fun transfer(a:Double, b:Double, dt:Double):State {\n        val ns = s - dt * b * s * i\n        val ni = i + dt * (b * s * i - a * i)\n        val nr = r + dt * i *a\n        return State(ns, ni, nr)\n    }\n}\n\nfun epidemic(tm:Int, n:Int, s0:Int, i0:Int, b:Double, a:Double):Int {\n    val dt = tm.toDouble()\/n.toDouble()\n    val initial = State(s0.toDouble(), i0.toDouble(), 0.0)\n    val epidemy = generateSequence( initial, {it.transfer(a,b, dt)}).take(n)\n    return epidemy.maxBy { it.i }!!.i.toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206662,"user_id":null,"body":"package epidemy\n\nfun epidemic(tm:Int, n:Int, s0:Int, i0:Int, b:Double, a:Double):Int {\n    var s = s0.toDouble()\n    var i = i0.toDouble()\n    var  r = 0.0\n    val dt: Double = tm.toDouble()\/n.toDouble()\n    var iMax = i0\n    \n    repeat(n) {\n        var sNew = (s - (dt * b * s * i))\n        var iNew = (i + dt * (b * s * i - a * i))\n        var rNew = (r + (dt * i * a))\n        if (iNew.toInt() > iMax) iMax = iNew.toInt()\n        s = sNew\n        i = iNew\n        r = rNew  \n    }\n   return iMax \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206663,"user_id":null,"body":"package epidemy\n\nfun epidemic(tm:Int, n:Int, s0:Int, i0:Int, b:Double, a:Double):Int {\n    var s = s0.toFloat()\n    var i = i0.toFloat()\n    var r = 0f\n    val dt = tm.toFloat()\/n\n    var iMax = i\n    for(c in 0 until n){\n        val sNew = s - dt * b * s * i\n        val iNew = i + dt * (b * s * i - a* i)\n        val rNew = r + dt * i * a\n        s = sNew.toFloat()\n        i = iNew.toFloat()\n        r = iNew.toFloat()\n        iMax = maxOf(iMax, i)\n    }\n    return iMax.toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206664,"user_id":null,"body":"package epidemy\n\nimport kotlin.math.max\nimport kotlin.math.round\n\n\/\/ https:\/\/www.codewars.com\/kata\/566543703c72200f0b0000c9\/train\/kotlin\n\/\/ tm: days\n\/\/ i: infected, s: susceptible to contract disease, r: recovery\n\/\/ b: number of contacts, a: fraction of the infected\nfun epidemic(tm: Int, n: Int, s0: Int, i0: Int, b: Double, a: Double): Int {\n    val dt: Double = tm.toDouble() \/ n.toDouble() \/\/ interval 0..tm divided into small intervals\n\n    var s = s0.toDouble()\n    var i = i0.toDouble()\n    var r = 0.0\n\n    var maxOfInfected = 0.0\n\n    var k = 0.0\n    while (k < tm) {\n\n        val sX = s - dt * b * s * i \/\/ I\n        val iX = i + dt * (b * s * i - a * i) \/\/ II\n        val rX = r + dt * i * a \/\/ III\n\n        s = sX\n        i = iX\n        r = rX\n\n        k += dt\n\n        maxOfInfected = max(maxOfInfected, iX)\n    }\n\n    return round(maxOfInfected).toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206665,"user_id":null,"body":"package epidemy\n\nfun epidemic(tm: Int, n: Int, s0: Int, i0: Int, b: Double, a: Double): Int {\n\n    val dt = tm.toDouble() \/ n\n    var maxInf = 0.0\n    var x = Triple(s0.toDouble(), i0.toDouble(), 0.0)\n\n    for (i in 1..n) {\n        x = period(x.first, x.second, x.third, dt, b, a)\n        if (maxInf < x.second) maxInf = x.second\n    }\n    return maxInf.toInt()\n}\n\nprivate fun period(s: Double, i: Double, r: Double, dt: Double, b: Double, a: Double) = Triple(\n    first = s - dt * b * s * i,\n    second = i + dt * (b * s * i - a * i),\n    third = r + dt * a * i\n)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206666,"user_id":null,"body":"package epidemy\n\nfun epidemic(tm:Int, n:Int, s0:Int, i0:Int, b:Double, a:Double):Int {\n    val dt = tm.toDouble() \/ n\n\tval result = generateSequence(Triple(s0.toDouble(), i0.toDouble(), 0.0)){ (s, i, r) -> Triple(s-dt*b*s*i, i+dt*(b*s*i-a*i), r+dt*i*a)}.take(n+1).map { it.second }.maxOrNull()\n\treturn result!!.toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5667e8f4e3f572a8f2000039":[{"id":206667,"user_id":null,"body":"package accum\n\nfun accum(s:String):String = s.mapIndexed { index, char -> char.toUpperCase() + char.toString().toLowerCase().repeat(index) }.joinToString(\"-\")","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206668,"user_id":null,"body":"package accum\n\nfun accum(s:String) = s.toLowerCase().mapIndexed { i, c -> c.toString().repeat(i + 1).capitalize() }.joinToString(\"-\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206669,"user_id":527,"body":"package accum\n\nfun accum(s: String): String {\n    return s.mapIndexed { i, c -> c.toUpperCase() + c.toLowerCase().toString().repeat(i) }.joinToString(\"-\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206670,"user_id":1381,"body":"package accum\n\nfun accum(s: String):String {\n    return s.toLowerCase().mapIndexed { index, char ->\n        char.toUpperCase().toString().padEnd(index + 1, char)\n    }.joinToString(\"-\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206671,"user_id":null,"body":"package accum\n\nfun accum(s: String): String = buildString {\n    s.withIndex().forEach { c ->\n        append(c.value.toLowerCase().toString().repeat(c.index + 1).capitalize())\n        append(\"-\")\n    }\n}.dropLast(1)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206672,"user_id":null,"body":"package accum\n\nfun accum(s: String) = s.chunked(1)\n        .mapIndexed { index, char -> \"${char.uppercase()}${char.lowercase().repeat(index)}\" }\n        .joinToString(\"-\")\n        ","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206673,"user_id":null,"body":"package accum\n\nfun accum(s:String): String = s.mapIndexed { index, c ->\n    c.uppercase() + c.lowercase().repeat(index)\n}.joinToString(\"-\")\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206674,"user_id":null,"body":"package accum\n\nfun accum(s:String):String = List(s.length) {i -> s[i].uppercase() + s[i].lowercase().repeat(i) }.joinToString(\"-\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206675,"user_id":null,"body":"package accum\n\nfun accum(s:String):String {\n    var answer = \"\"\n    for ((index , value) in s.withIndex()) {\n        answer += value.toUpperCase() + (value.toLowerCase().toString().repeat(index)) + \"-\"\n    }\n    return answer.dropLast(1)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206676,"user_id":null,"body":"package accum\n\nfun accum(s:String):String {\n    var str = \"\"\n    for(x in s.indices){\n        for(y in 1..x+1){\n            if(y == 1){\n                str += s[x].toUpperCase()\n            }\n            else {str += s[x].toLowerCase()}\n        }\n        if(x != s.length-1){\n            str+=\"-\"\n        }\n    }\n    return str\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"566be96bb3174e155300001b":[{"id":206677,"user_id":492,"body":"package ball\n\nfun maxBall(v0:Int):Int {\n    return Math.round((v0 \/ 3.6).toDouble() \/ 0.981).toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206678,"user_id":null,"body":"package ball\n\nfun maxBall(v0:Int):Int {\n    \/\/ v0 in km\/h -- transform to m\/s -- m\/(1\/10 s)\n    val mps: Double = v0 \/ 3.6\n    var timePassed = 1\n    var preH: Double = 0.0\n    var nextH: Double = getHeight(timePassed\/10.0, mps)\n\n    while(preH < nextH) {\n        timePassed++\n\n        preH = nextH\n        nextH = getHeight(timePassed\/10.0, mps)\n    }\n\n    return timePassed - 1\n}\n\nfun getHeight(timePassed: Double, speed: Double): Double {\n    return speed*timePassed - 0.5*(9.81)*timePassed*timePassed\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206679,"user_id":null,"body":"package ball\n\nimport kotlin.math.*\n\nfun maxBall(v0:Int):Int {\n    return (v0 \/ (9.81 * 0.36)).roundToInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206680,"user_id":null,"body":"package ball\n\nfun maxBall(v0:Int):Int {\n    val v = v0 * 1000.0 \/ 3600.0\n    val t = 0\n    val h = 0.0\n\n    return generateSequence(Pair(h,t)) { Pair(calcHeight(v, (it.second + 1)\/10.0), it.second + 1) }\n        .takeWhile { it.first >= 0 }\n        .toMutableList()\n        .maxBy { it.first}\n        .let {it!!.second}\n}\n\nfun calcHeight(v: Double, t: Double): Double {\n    val g = 9.81\n    return v*t - 0.5*g*t*t\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206681,"user_id":null,"body":"package ball\n\nprivate const val G = 9.81\n\nfun maxBall(v0: Int): Int = (v0 \/ 3.6 \/ G * 10 + 0.5).toInt()\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206682,"user_id":null,"body":"package ball\n\nfun maxBall(v0:Int) = kotlin.math.round(((v0*1000.0\/3600)\/9.81)*10).toInt()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206683,"user_id":null,"body":"package ball\nimport kotlin.math.round\n\nfun maxBall(v:Int) = round(v.toDouble()*100\/(36*9.81)).toInt()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206684,"user_id":null,"body":"package ball\n\nfun maxBall(v0: Int): Int {\n    var speed: Double = v0.toDouble() \/ 3.6\/\/meter per second\n    var currentHeight = 0.0\n    var maxHT = 0.0\n    var time = 0\n    while (currentHeight >= 0) {\n        currentHeight = speed * (time*0.1) - (0.04905 * (time * time))\n        if (maxHT > currentHeight) {\n            println(maxHT)\n            return time-1\n        }\n        maxHT=currentHeight\n        time ++\n    }\n    return 0\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206685,"user_id":null,"body":"package ball\n\nfun maxBall(v0:Int):Int {\n    \/*\n    v = v0 - gt - first derivative\n    when it reaches the highest point: v = 0\n    *\/\n    return Math.round(v0 * 1000 \/ 3600.0 \/ 9.81 * 10).toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206686,"user_id":null,"body":"package ball\n\nfun maxBall(v0:Int):Int {\n    var previousHeight = 0.0\n    val velocity = v0 * 1000 \/ 3600.0\n    var i = 1\n\n    while (true) {\n        val actualHeight = velocity * i \/ 10 - 0.5 * 9.81 * i \/ 10 * i \/ 10\n        if (actualHeight > previousHeight)\n            previousHeight = actualHeight\n        else return i - 1\n        i++\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"566fc12495810954b1000030":[{"id":206687,"user_id":null,"body":"package countdig\nfun nb_dig(n:Int, d:Int):Int =\n  (0..n).map{ (it * it) }.sumBy { it.toString().count{ it == d.toString()[0] } }","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206688,"user_id":null,"body":"package countdig\n\nfun nb_dig(n: Int, d: Int): Int = (0..n).joinToString { \"${it * it}\" }.count { \"$it\" == \"$d\" }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206689,"user_id":null,"body":"package countdig\n\nfun nb_dig(n:Int, d:Int) =\n        (0..n).sumBy { (it * it).toString().count { it == Character.forDigit(d, 10) } }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206690,"user_id":null,"body":"package countdig\n\nfun nb_dig(number: Int, digit: Int) = (0..number).asSequence().map { it * it }.map { countDigit(it, digit) }.sum()\nfun countDigit(number: Int, digit: Int) = number.toString().count { Character.getNumericValue(it) == digit }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206691,"user_id":null,"body":"package countdig\n\nfun nb_dig(n: Int, d: Int) =\n    (0..n)\n        .map { x -> \"${x * x}\" }\n        .joinToString(\"\")\n        .filter { c -> \"$c\" == \"$d\" }\n        .count()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206692,"user_id":null,"body":"package countdig\n\nfun nb_dig(n: Int, d: Int): Int = (0..n).map { it * it }.joinToString(separator = \"\").count { (it - '0') == d }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206693,"user_id":null,"body":"package countdig\n\nfun nb_dig(n: Int, d: Int): Int {\n\n    var count = 0\n    val value = d.toString()\n\n    for (i in 0 until n + 1) {\n\n        \/\/ Convert square to string and spilt into char array\n        val s1Char = (i * i).toString().toCharArray()\n\n        \/\/ Look at each char, add 1 for every value occurrence\n        for (c: Char in s1Char) {\n            if (c.toString() == value) {\n                count += 1\n            }\n        }\n    }\n    return count\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206694,"user_id":null,"body":"package countdig\n\nfun nb_dig(n:Int, d:Int) = IntArray(n+1){i -> i*i}.joinToString().filter{it == d.digitToChar()}.length\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206695,"user_id":null,"body":"package countdig\n\nfun nb_dig(n:Int, d:Int):Int {\n    var num:Int \n    var res =0    \n   \n    for (i in 0..n){\n        num = i*i\n        while (num!=0) {\n          if (num%10==d)\n          res++\n          num\/=10;\n        }        \n    }\n    if (d==0) {\n        res++\n    }\n    return res\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206696,"user_id":null,"body":"package countdig\nimport kotlin.math.pow\n\nfun nb_dig(n: Int, d: Int): Int =\n    (0..n).map { num ->\n        (num * num).toString().replace(Regex(\"[^$d]*\"), \"\").length\n    }.sum()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5672682212c8ecf83e000050":[{"id":206697,"user_id":null,"body":"package dbllinear\n\nfun dbl_linear(n: Int) = with(sortedSetOf(1)) {\n    for (i in 1..n) {\n        val x = first().also { remove(it) }\n        add(x * 2 + 1)\n        add(x * 3 + 1)\n    }\n    first()\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206698,"user_id":null,"body":"package dbllinear\n\nfun dbl_linear(n:Int) = with(sortedSetOf(1)) {\n        for(i in 1..n) {\n            val x = pollFirst()\n            add((x * 2) + 1)\n            add((x * 3) + 1)\n        }\n        first()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206699,"user_id":null,"body":"package dbllinear\n\nfun dbl_linear(n: Int) = sortedSetOf(1).run {\n    repeat(n) {\n        val x = pollFirst()!!\n        add(2 * x + 1)\n        add(3 * x + 1)\n    }\n    pollFirst()!!\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206700,"user_id":null,"body":"package dbllinear\nimport java.util.*\n\nfun dbl_linear(n:Int):Int {\n\n    var path = TreeSet<Int>().apply{add(1)}\n    var x = 0\n    (1..n+1).forEach {\n        x = path.first().also{path.remove(it)}\n        path.add(x*2+1)\n        path.add(x*3+1)\n    }\n    \n    return x\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206701,"user_id":null,"body":"package dbllinear\n\nfun dbl_linear(n: Int): Int {\n  val list = mutableListOf(1)\n  var x = 0\n  var y = 0\n\n  while(list.size <= n) {\n    val a = 2 * list[x] + 1\n    val b = 3 * list[y] + 1\n\n    when {\n      a > b -> {\n        list.add(b)\n        y++\n      }\n      a < b -> {\n        list.add(a)\n        x++\n      }\n      else -> {\n        list.add(a)\n        x++\n        y++\n      }\n    }\n  }\n  return list[n]\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206702,"user_id":null,"body":"package dbllinear\nimport java.util.*\n\nfun dbl_linear(n:Int):Int {\n    var u: SortedSet<Int> = sortedSetOf(0)\n    var x: Int\n    var y: Int\n    var z: Int\n    var currentIndex: Int = 0\n    u.add(1)\n    while (currentIndex <= n) {\n        x = u.first()\n        y = 2 * x + 1\n        z = 3 * x + 1\n        u.remove(x)\n        u.add(y)\n        u.add(z)\n        currentIndex++\n    }\n    return u.first()\n  }\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206703,"user_id":null,"body":"package dbllinear\nimport kotlin.math.*\n\nfun dbl_linear(n: Int): Int {\n    var array = Array(n + 1) { 1 }\n    var pt1 = 0\n    var pt2 = 0\n    for (i in 1..n) {\n        array[i] = min(2 * array[pt1] + 1, 3 * array[pt2] + 1)\n        if (array[i] == 2 * array[pt1] + 1) pt1++\n        if (array[i] == 3 * array[pt2] + 1) pt2++\n    }\n    return array[n]\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206704,"user_id":null,"body":"package dbllinear\n\nfun dbl_linear(n: Int): Int {\n    val u = hashSetOf(1)\n    if (n == 0) return 1\n    var i = 1\n    while (u.size <= n){\n        if (((i-1)% 2 == 0 && u.contains((i-1)\/2)) ||\n            ((i-1)% 3 == 0 && u.contains((i-1)\/3))){\n            u.add(i)\n        }\n        i++\n    }\n    return i-1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206705,"user_id":null,"body":"package dbllinear\n\nfun dbl_linear(n: Int) = dbl_linearSequence().drop(n).first()\n\nfun dbl_linearSequence() = sequence<Int> {\n    val s = sortedSetOf(1)\n    while (true) {\n        val min = s.first()\n        yield(min)\n        s -= min\n        s += listOf(2 * min + 1, 3 * min + 1)\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206706,"user_id":null,"body":"package dbllinear\n\nfun dbl_linear(n: Int) = sortedSetOf(1).run {\n    repeat(n) {\n        val x = first().also { remove(it) }\n        add(2 * x + 1)\n        add(3 * x + 1)\n    }\n    first()\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"56747fd5cb988479af000028":[{"id":206707,"user_id":492,"body":"package middle\n\nfun get_middle(w : String) : String {\n    val len = w.length\n    return w.substring (len \/ 2 - (len + 1) % 2, len \/ 2 + 1)\n}","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206708,"user_id":null,"body":"package middle\n\nfun get_middle(word : String) : String {\n  return word.substring((word.length - 1) \/ 2, word.length \/ 2 + 1)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206709,"user_id":null,"body":"package middle\n\nfun get_middle(word : String) : String {\n    val worldLength = (word.length - 1) \/ 2\n    return word.drop(worldLength).dropLast(worldLength)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206710,"user_id":null,"body":"package middle\n\nfun get_middle(word: String): String = word.substring( (word.length-1)\/2 .. word.length\/2 )","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206711,"user_id":null,"body":"package middle\n\nfun get_middle(word : String) : String {\n        val middle = (word.length - 1) \/ 2\n        return word.substring(middle, word.length - middle)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206712,"user_id":null,"body":"package middle\n\nfun get_middle(word : String) : String {\n  val o = if (word.length % 2 == 0) 1 else 0\n  val m = word.length \/ 2\n  return word.slice((m-o)..m)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206713,"user_id":null,"body":"package middle\n\nfun get_middle(word : String) : String {\n    val mid = word.count() \/ 2\n    if (word.count() % 2 == 0) {\n        return word.substring(mid-1, mid+1)\n    }\n    \n    return word.substring(mid, mid+1)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206714,"user_id":null,"body":"package middle\n\nfun get_middle(word : String) : String {\n    val temp = (word.length\/2) + 1\n    var result = word.take(temp)\n    when (word.length%2){\n        0 ->{\n            result = result.takeLast(2)\n        }\n        1 ->{\n            result = result.takeLast(1)\n        }\n    }\n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206715,"user_id":null,"body":"package middle\n\nfun get_middle(word : String) = word.substring( (if (word.length % 2 == 0) word.length \/ 2 - 1 else word.length \/ 2) .. word.length \/ 2) ","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206716,"user_id":null,"body":"package middle\n\nfun get_middle(word : String) : String {\n  var result = \"\"\n    if (word.length % 2 == 0){\n        return word.substring(word.length \/ 2 - 1, word.length \/ 2 + 1)\n    }else{\n        result += word[word.length \/ 2]\n        return result\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"567501aec64b81e252000003":[{"id":206717,"user_id":492,"body":"package wallpaper\n\nfun wallpaper(l:Double, w:Double, h:Double):String {\n    val textNumbers = arrayOf<String>(\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\")\n    if (h * w * l == 0.0) return \"zero\"\n    val rolls = Math.ceil((((l + w) * 2.0 * h \/ 0.52 \/ 10.0) * 1.15)).toInt()\n    return textNumbers[rolls]\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206718,"user_id":null,"body":"package wallpaper\nimport kotlin.math.ceil\n\nfun wallpaper(l:Double, w:Double, h:Double) = if(l*w*h <= 0 ) \"zero\" else when (\nceil(((((l + w) * h * 2) \/ 5.2) * 1.15)).toInt()\n){\n    0 -> \"zero\"\n    1 -> \"one\"\n    2 -> \"two\"\n    3 -> \"three\"\n    4 -> \"four\"\n    5 -> \"five\"\n    6 -> \"six\"\n    7 -> \"seven\"\n    8 -> \"eight\"\n    9 -> \"nine\"\n    10 -> \"ten\"\n    11 -> \"eleven\"\n    12 -> \"twelve\"\n    13 -> \"thirteen\"\n    14 -> \"fourteen\"\n    15 -> \"fifteen\"\n    16 -> \"sixteen\"\n    17 -> \"seventeen\"\n    18 -> \"eighteen\"\n    19 -> \"nineteen\"\n    20 -> \"twenty\"\n    else -> \"crazy shit\" \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206719,"user_id":null,"body":"package wallpaper\n    fun wallpaper(l: Double, w: Double, h: Double) = if(l * w * h == 0.0) \"zero\" else listOf(\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\",\n        \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\",\n        \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\")[Math.ceil((h * (w + l)) \/ 2.26).toInt()]","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206720,"user_id":null,"body":"package wallpaper\n\nfun wallpaper(l: Double, w: Double, h: Double): String {\n    val numbers = listOf(\n        \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\",\n        \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\"\n    )\n    if (l * w * h == 0.0) return numbers.first()\n\n    val rollLength = 10\n    val rollWidth = 52.0\n    val rollExtraPercent = 15.0\n\n    val s = 2 * (h * (l + w))\n    val extra = (100 + rollExtraPercent) \/ 100\n    val k = s * extra \/ (rollWidth \/ rollLength) + 1\n\n    return numbers[k.toInt()]\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206721,"user_id":null,"body":"package wallpaper\n\nimport kotlin.math.ceil\n\nfun wallpaper(l:Double, w:Double, h:Double):String {\n\n        if (l * w * h <= 0) return \"zero\"\n\n            return ceil(((2 * (l * h) + 2 * (w * h)) * 1.15) \/ (.52 * 10)).toInt().let {\n            when (it) {\n                1 -> \"one\"\n                2 -> \"two\"\n                3 -> \"three\"\n                4 -> \"four\"\n                5 -> \"five\"\n                6 -> \"six\"\n                7 -> \"seven\"\n                8 -> \"eight\"\n                9 -> \"nine\"\n                10 -> \"ten\"\n                11 -> \"eleven\"\n                12 -> \"twelve\"\n                13 -> \"thirteen\"\n                14 -> \"fourteen\"\n                15 -> \"fifteen\"\n                16 -> \"sixteen\"\n                17 -> \"seventeen\"\n                18 -> \"eighteen\"\n                19 -> \"nineteen\"\n                20 -> \"twenty\"\n                else -> \"zero\"\n            }\n        }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206722,"user_id":null,"body":"package wallpaper\n\nval values = listOf(\"zero\", \"one\",\"two\",\"three\",\"four\",\"five\",\"six\",\"seven\",\"eight\",\"nine\",\"ten\",\"eleven\",\"twelve\",\"thirteen\",\"fourteen\",\"fifteen\",\"sixteen\",\"seventeen\",\"eighteen\",\"nineteen\",\"twenty\");\n\nfun wallpaper(l:Double, w:Double, h:Double):String {\n    if(l <= 0.0 || w <= 0.0) return values[0]\n    var result = 2*(l+w)*h*10*1.15\/52\n    var numberOfRolls = if(result > 0) Math.ceil(result).toInt() else 0\n    return values[numberOfRolls]\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206723,"user_id":null,"body":"package wallpaper\n\nfun wallpaper(l:Double, w:Double, h:Double):String {\n    var str = \"\"\n    \n    var sq = 2*h*(l + w) \n    var amount = sq\/5.2*1.15 + 1    \n    if ((l == 0.0) || (w == 0.0) || (h == 0.0)){\n        str = \"zero\"\n    }\n   else{ \n        str = when (amount.toInt())  {\n            1 -> \"one\"\n            2 -> \"two\"\n            3 -> \"three\"\n            4 -> \"four\"\n            5 -> \"five\"\n            6 -> \"six\"\n            7 -> \"seven\"\n            8 -> \"eight\"\n            9 -> \"nine\"\n            10 -> \"ten\"\n            11 -> \"eleven\"\n            12 -> \"twelve\"\n            13 -> \"thirteen\"\n            14 -> \"fourteen\"\n            15 -> \"fifteen\"\n            16 -> \"sixteen\"\n            17 -> \"seventeen\"\n            18 -> \"eighteen\"\n            19 -> \"nineteen\"\n            20 -> \"twenty\"\n            30 -> \"thirty\"\n            40 -> \"forty\"\n            50 -> \"fifty\"\n            60 -> \"sixty\"\n            else  -> \":)\"\n        }\n    }\n    \n    println(amount)\n    return str\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206724,"user_id":492,"body":"package wallpaper\n\nfun wallpaper(l:Double, w:Double, h:Double):String {\n    val textNumbers = arrayOf<String>(\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\")\n    if (h * w * l == 0.0) return \"zero\"\n    val rolls = Math.ceil((((l + w) * 2.0 * h \/ 0.52 \/ 10.0) * 1.15)).toInt()\n    return textNumbers[rolls]\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206725,"user_id":null,"body":"package wallpaper\n\nfun wallpaper(l:Double, w:Double, h:Double):String {\n    if (l == 0.0 || w == 0.0) return \"zero\"\n    val numbers = listOf(\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \n                   \"eleven\", \"twelve\",\"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\")\n    return numbers [Math.ceil(2*(l+w)*h \/ .52 \/ 10.0 * 1.15).toInt()]\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206726,"user_id":null,"body":"package wallpaper\nimport kotlin.math.ceil\n\nfun wallpaper(l: Double, w: Double, h: Double): String {\n    if (l == 0.0 || w == 0.0 || h == 0.0) return numbers[0]\n    val square: Double = (l + w) * 2 * h * 1.15\n    return numbers[ceil(square \/ (10 * 0.52)).toInt()]\n}    \n    val numbers = arrayListOf<String>(\n    \"zero\",\n    \"one\",\n    \"two\",\n    \"three\",\n    \"four\",\n    \"five\",\n    \"six\",\n    \"seven\",\n    \"eight\",\n    \"nine\",\n    \"ten\",\n    \"eleven\",\n    \"twelve\",\n    \"thirteen\",\n    \"fourteen\",\n    \"fifteen\",\n    \"sixteen\",\n    \"seventeen\",\n    \"eighteen\",\n    \"nineteen\",\n    \"twenty\"\n)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5679aa472b8f57fb8c000047":[{"id":206727,"user_id":null,"body":"object EqualSidesOfAnArray {\n  fun findEvenIndex(arr:IntArray):Int {\n    for (i in arr.indices) {\n      if (arr.sliceArray(0..i).sum() == arr.sliceArray(i..(arr.size - 1)).sum()) {\n        return i\n      }\n    }\n    return -1\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206728,"user_id":null,"body":"object EqualSidesOfAnArray {\n    fun findEvenIndex(arr: IntArray) = arr.indices.indexOfFirst { arr.take(it).sum() == arr.drop(it + 1).sum() }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206729,"user_id":null,"body":"object EqualSidesOfAnArray {\n    fun findEvenIndex(arr: IntArray): Int {\n        if (arr.isEmpty()) return 0\n        val sumTotal = arr.sum()\n        arr.foldIndexed(0) { index, sumLeft, value ->\n            if (sumLeft * 2 + value == sumTotal) return index\n            sumLeft + value\n        }\n        return -1\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206730,"user_id":null,"body":"object EqualSidesOfAnArray {\n  fun findEvenIndex(arr:IntArray):Int {\n     var rightSum = arr.sum()\n     var leftSum = 0\n     for (i in 0..arr.size-1) {\n       \trightSum = rightSum - arr[i]\n        if (rightSum == leftSum) return i\n        leftSum = leftSum + arr[i]\n   \t }\n    return -1\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206731,"user_id":null,"body":"object EqualSidesOfAnArray {\n  fun findEvenIndex(arr:IntArray):Int {\n    for (i in arr.indices) {\n        val sumLeft = arr.take(i).sum()\n        val sumRight = arr.drop(i + 1).sum()\n\n        if (sumLeft == sumRight) return i\n    }\n\n    return -1\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206732,"user_id":null,"body":"object EqualSidesOfAnArray {\n  fun findEvenIndex(arr:IntArray):Int {\n    return (\n      arr.mapIndexed({ i:Int ,v:Int -> \n        arr.slice(0..i-1).sum() - arr.slice(i+1..arr.size).sum() \n      }) \n      .indexOf(0)\n    )\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206733,"user_id":null,"body":"object EqualSidesOfAnArray {\n  fun findEvenIndex(arr:IntArray):Int {\n      var result:Int = -1\n      for (i in 0 until arr.size) {\n          if (arr.toList().split(i).first.sum() == arr.toList().split(i).second.sum()) {\n              result = i\n              break\n          }\n      }\n      return result\n  }\n\n  fun <T> List<T>.split(n:Int) = Pair(take(n), drop(n+1))\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206734,"user_id":null,"body":"object EqualSidesOfAnArray {\n   fun findEvenIndex(arr: IntArray): Int {\n        for (i in arr.indices) {\n            if (arr.sliceArray(0..i).sum() == arr.sliceArray(i until arr.size).sum()) return i\n        }\n\n        return -1\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206735,"user_id":null,"body":"object EqualSidesOfAnArray {\n  fun findEvenIndex(arr:IntArray):Int {\n    var sumLeft = 0;\n    var sumRight = arr.sum();\n  \n    for (i in 0..arr.lastIndex) {\n        if (i > 0) sumLeft += arr[i - 1]\n        \n        sumRight -= arr[i]\n        \n        if (sumLeft == sumRight) return i\n    }\n      \n    return -1\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206736,"user_id":null,"body":"object EqualSidesOfAnArray {\n    fun findEvenIndex(arr: IntArray): Int = arr.indices.find {\n        arr.sliceArray(0 until it).sum() == arr.sliceArray((it + 1) until arr.size).sum()\n    } ?: -1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"569218bc919ccba77000000b":[{"id":206737,"user_id":492,"body":"package target\nimport java.time.LocalDate;\n\nfun dateNbDays(a0:Double, a:Double, p:Double):String {\n    return LocalDate.of(2016, 1, 1).plusDays(Math.ceil(Math.log(a \/ a0) \/ Math.log(1 + p \/ 36000)).toLong()).toString()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206738,"user_id":null,"body":"package target\nimport java.time.LocalDate;\n\nfun dateNbDays(a0:Double, a:Double, p:Double) =\n    \"${LocalDate.of(2016, 1, 1).plusDays(\n        generateSequence(a0){it+it*p\/36000}.takeWhile { it < a }.count().toLong())\n    }\"","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206739,"user_id":null,"body":"package target\nimport java.time.LocalDate;\nimport java.time.temporal.ChronoUnit\n\nfun dateNbDays(a0:Double, a:Double, p:Double):String {\n    var nDays: Long = 0\n    var runningTotal = a0\n    while (runningTotal < a) {\n        nDays++\n        runningTotal *= 1+((p\/100)\/360)\n    }\n    return LocalDate.of(2016, 1, 1).plus(nDays, ChronoUnit.DAYS).toString()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206740,"user_id":null,"body":"package target\nimport java.time.LocalDate;\n\nfun dateNbDays(a0:Double, a:Double, p:Double):String {\n    var date = LocalDate.parse(\"2016-01-01\")\n    var moneyAmount = a0\n    var pDayRate = p\/36000\n    var count = 0\n    while ( a > moneyAmount) {\n        count +=1\n        moneyAmount += (moneyAmount * pDayRate)\n      }\n    date = date.plusDays(count.toLong())\n    return date.toString()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206741,"user_id":null,"body":"package target\nimport java.time.LocalDate;\n\nfun dateNbDays(a0:Double, a:Double, p:Double):String {\n    var date = LocalDate.parse(\"2016-01-01\")\n    var per = a0\n    var days = 0\n\n    while (per < a) {\n        per += per*p\/36000\n        days ++\n    }\n\n    return date.plusDays(days.toLong()).toString()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206742,"user_id":null,"body":"package target \nimport kotlin.math.*\nimport java.time.LocalDate; \n\nfun dateNbDays(a0:Double, a:Double, p:Double):String {\n    val x = ceil(((ln(a) - ln(a0)) \/ ln(1 + (p\/36000)))).toLong() \n    val date = LocalDate.of(2016, 1, 1).plusDays(x).toString()\n    return \"$date\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206743,"user_id":null,"body":"package target\nimport java.time.LocalDate;\n\nfun dateNbDays(a0:Double, a:Double, p:Double):String {\n    val dayReturn = p\/36000\n    var done = false\n    var days = 0\n    var result = a0\n    while (!done) {\n        result += result * dayReturn\n        if (result > a) {\n            done = true\n        }\n        days++\n    }\n    val startDate = java.time.LocalDate.of(2016, 1, 1)\n    return startDate.plusDays(days.toLong()).toString()}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206744,"user_id":null,"body":"package target\nimport java.time.LocalDate;\n\nfun dateNbDays(a0:Double, a:Double, p:Double):String {\n        var days = 0\n        var temp = a0;\n        while (a > temp) {\n            temp *= 1 + (p \/ 36000)\n            days++\n        }\n        return LocalDate.of(2016, 1, 1).plusDays(days.toLong())\n            .toString()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206745,"user_id":null,"body":"package target\nimport java.time.LocalDate;\n\nfun dateNbDays(a0:Double, a:Double, p:Double):String {\n    var amount = a0\n    var days: Long = 0\n    var answer = LocalDate.parse(\"2016-01-01\")\n    while (amount < a) {\n        amount = amount + amount*(p\/36000)\n        days += 1\n    }\n\n    return answer.plusDays(days).toString()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206746,"user_id":null,"body":"package target\nimport java.time.LocalDate\nimport java.time.Period\nimport kotlin.math.log10\nimport kotlin.math.roundToInt\nimport kotlin.math.ceil\n\nfun dateNbDays(a0:Double, a:Double, p:Double):String {\n    val per_day = p\/36000\n    val a = (log10(a\/a0) \/ log10(1+per_day))\n    val interest = ceil(a).toInt()\n    var date = LocalDate.parse(\"2016-01-01\")\n    var final = date + Period.ofDays(interest)\n    println(final.toString())\n    return final.toString()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"569b5cec755dd3534d00000f":[{"id":206747,"user_id":null,"body":"package newavg\n\nimport kotlin.math.ceil\nimport kotlin.math.roundToLong\n\nfun newAvg(a:DoubleArray, navg:Double):Long {\n    val x = navg*(a.size + 1) - a.sum()\n    require(x >= 0)\n    return ceil(x).roundToLong()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206748,"user_id":null,"body":"package newavg\n\nimport kotlin.math.ceil\n\nfun newAvg(a: DoubleArray, navg: Double) = ceil(navg * (a.size + 1) - a.sum()).toLong().takeIf { it > 0 }\n        ?: throw IllegalArgumentException()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206749,"user_id":null,"body":"package newavg\nimport kotlin.math.*\n\nfun newAvg(a:DoubleArray, navg:Double):Long {\n    if (navg <= 0) {\n        throw IllegalArgumentException(\"Illegal argument\")\n    } else if (navg < a.average()) {\n        throw IllegalArgumentException(\"Illegal argument\")\n    } else {\n        return ceil(((navg * (a.size + 1)) - a.sum())).toLong()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206750,"user_id":null,"body":"package newavg\n\nimport java.lang.IllegalArgumentException\n\nfun newAvg(a:DoubleArray, navg:Double):Long {\n    return Math.ceil(navg * (a.size + 1) - a.sum()).toLong().takeIf { it > 0 } ?: throw IllegalArgumentException()\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206751,"user_id":null,"body":"package newavg\n\nfun newAvg(a:DoubleArray, navg:Double):Long {\n    val s = (Math.ceil(navg * (a.size + 1) -  a.sum())).toLong()\n    return if(s >= 0) s else throw IllegalArgumentException()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206752,"user_id":null,"body":"package newavg\n\nimport kotlin.math.ceil\n\n    fun newAvg(a:DoubleArray, navg:Double):Long {\n\n        val v = ceil(navg*(a.size + 1) - a.sum()).toLong()\n\n        if (v <= 0) throw IllegalArgumentException()\n\n        return v\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206753,"user_id":null,"body":"package newavg\n\nfun newAvg(a:DoubleArray, navg:Double):Long {\n    if ((navg * (a.size+1) - a.sum()).toLong() < 0) {\n        throw IllegalArgumentException()\n    } \n    \n    return Math.ceil(navg * (a.size+1) - a.sum()).toLong()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206754,"user_id":null,"body":"package newavg\nimport kotlin.math.ceil\n\nfun newAvg(a:DoubleArray, navg:Double):Long {\n    val result = navg * (a.size + 1).toDouble() - a.sum()\n    if (result < 0.0) throw IllegalArgumentException(\"--- Exception 1 ---\")\n    return ceil(result).toLong()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206755,"user_id":null,"body":"package newavg\n\nfun newAvg(a:DoubleArray, navg:Double):Long {\n   \n     var donat=(a.size+1)*navg-a.sum()\n\n    if (donat <0)  throw IllegalArgumentException(\"--- Exception 1 ---\")\n   else { if (donat-donat.toInt()>0)donat+=1\n\n   }\n    return donat.toLong()\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206756,"user_id":null,"body":"package newavg\n\nfun newAvg(a:DoubleArray, navg:Double):Long {\n    val don = navg * (a.count() + 1) - a.sumOf { it }\n\n    if (don > 0) return Math.ceil(don).toLong()\n    else throw IllegalArgumentException()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"56a32dd6e4f4748cc3000006":[{"id":206757,"user_id":null,"body":"package rainfall\n\nprivate const val NO_TOWN_RECORD = -1.0\n\nprivate fun getRainfallForTown(town: String, strng:String):List<Double>?\n  = strng.lines()\n  .singleOrNull { it.contains(\"$town:\") }\n  ?.split(\",\")\n  ?.map { it.substringAfter(' ').toDouble() }\n\nfun mean(town:String, strng:String):Double\n  = getRainfallForTown(town, strng)?.average() ?: NO_TOWN_RECORD\n  \nfun variance(town:String, strng:String):Double\n  = getRainfallForTown(town, strng)?.run {\n      val avg = average()\n      var sum = 0.0\n      forEach { sum += Math.pow(it-avg, 2.0) }\n      sum \/ size\n  } ?: NO_TOWN_RECORD","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206758,"user_id":null,"body":"package rainfall\nimport kotlin.math.*\n\nprivate fun String.toMapData() = split('\n').associate {\n    val dataList = it.substringAfter(':').split(' ', ',').filter { s -> s.toDoubleOrNull() != null }.map(String::toDouble)\n    it.substringBefore(':') to dataList\n}\n\nfun mean(town: String, strng: String) = strng.toMapData()[town]?.average()?:-1.0\n\nfun variance(town: String, strng: String) = (strng.toMapData()[town]?.map { it.pow(2) }?.average() ?: 0.0) - mean(town, strng).pow(2)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206759,"user_id":null,"body":"package rainfall\n\nfun mean(town:String, strng:String):Double {\n    val values = getValues(town,strng)\n    if (values == null) return -1.0\n    return values!!.average()\n}\nfun variance(town:String, strng:String):Double {\n    val values = getValues(town,strng)\n    if (values == null) return -1.0\n    val mean = values!!.average()\n    val qty = values!!.size\n    val vari = values!!.map {\n        val diff = mean-it\n        diff*diff\/qty\n    }.sum()\n    return vari\n}\n\nfun getValues(town:String, strng:String) : List<Double>? {\n    val city_list = strng.split(\"\n\").filter { \n        it.split(\":\")[0] == town }\n    if (city_list.size == 0) return null\n    val city = city_list[0].trim()\n    val values = city.replace(\",\", \" \").split(\" \").filter {\n        val trying = it.toDoubleOrNull() \n        trying != null\n    }.map { it.toDoubleOrNull() ?: 0.0 }\n    return values\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206760,"user_id":null,"body":"package rainfall\nimport kotlin.math.*\n\nfun mean(town:String, strng:String) =\n    if(strng.contains(\"$town:\")) getData(town, strng).average()\n    else -1.0\n\nfun variance(town:String, strng:String)=\n    if(strng.contains(\"$town:\")) getData(town, strng)\n        .map { (it - mean(town, strng)).pow(2) }\n        .run { sum() \/ count() }\n    else -1.0\n\nfun getData(town: String, str: String) =\n    str.split(\"$town:\")[1].takeWhile { it != '\n' }\n        .replace(\"[^\\\\d,.]\".toRegex(), \"\")\n        .split(\",\")\n        .map { it.toDouble() }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206761,"user_id":null,"body":"package rainfall\nval towns = arrayOf(\n    \"Rome\",\n    \"London\",\n    \"Paris\",\n    \"NY\",\n    \"Vancouver\",\n    \"Sydney\",\n    \"Bangkok\",\n    \"Tokyo\",\n    \"Beijing\",\n    \"Lima\",\n    \"Montevideo\",\n    \"Caracas\",\n    \"Madrid\",\n    \"Berlin\"\n)\n\n\nfun mean(town: String, strng: String): Double {\n\n    if (isCityExist(town).not()) return (-1.0)\n\n    val record = foundTownRecord(town, strng) ?: return (-1.0)\n\n    val numbers = extractDoubleData(town, record)\n\n    return meanInternal(numbers)\n}\n\nfun variance(town: String, strng: String): Double {\n\n    if (isCityExist(town).not()) return (-1.0)\n\n    val record = foundTownRecord(town, strng) ?: return (-1.0)\n\n    val numbers = extractDoubleData(town, record)\n\n    val mean = meanInternal(numbers)\n\n    return numbers\n        .map { it - mean }\n        .map { it.times(it) }\n        .sum()\n        .div(numbers.size)\n}\n\nprivate fun meanInternal(numbers: List<Double>): Double {\n    val numbersCount = numbers.count()\n\n    return numbers.sum().div(numbersCount)\n}\n\n\nprivate fun foundTownRecord(town: String, strng: String): String? {\n    return strng\n        .split('\n')\n        .find { it.startsWith(town) }\n}\n\nprivate fun extractDoubleData(town: String, strng: String): List<Double> {\n    return strng.replace(\"$town:\", \"\")\n        .split(\",\")\n        .map { it.split(\" \").elementAt(1) }\n        .map { it.toDouble() }\n}\n\nprivate fun isCityExist(town: String): Boolean {\n    return towns.contains(town)\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206762,"user_id":932,"body":"package rainfall\nfun mean(town:String, data:String)=data.split(\"\n\").filter {it.contains(Regex(\"\"\"^$town:\"\"\"))}\n    .let {if (it.isEmpty()) -1.0 else it[0].drop(town.length+1).split(\",\").map {it.split(\" \")[1].toDouble()}.average()}\nfun variance(town:String, data:String)=data.split(\"\n\").filter {it.contains(Regex(\"\"\"^$town:\"\"\"))}.let {\n    if (it.isEmpty()) -1.0 else it[0].drop(town.length + 1).split(\",\").map { it.split(\" \")[1].toDouble() }\n        .let {list ->list.average().let { avg -> list.map {(it - avg)*(it - avg)}.sum()\/list.size}}}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206763,"user_id":null,"body":"package rainfall\n\nfun mean(town:String, strng:String) = findRecords(town, strng)?.average() ?: -1.0\n\nfun findRecords(town:String, strng:String) = strng.split(\"\n\").find { it.startsWith(town + \":\" ) }?.run { drop(indexOf(\":\") + 1).split(\",\").map{ it.drop(4).toDouble() } }\n\nfun variance(town:String, strng:String):Double {\n  val records = findRecords(town, strng)\n  if (records == null)\n    return -1.0\n  val sum = records.sum()\n  return (records.sumByDouble {it * it} - sum * sum \/ records.size) \/ (records.size)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206764,"user_id":null,"body":"package rainfall\n\nfun mean(town:String, strng:String):Double\n{\n  return parseData(town, strng).first\n}\n\nfun variance(town:String, strng:String):Double\n{\n  return parseData(town, strng).second\n}\n\nfun parseData(town:String, data:String):Pair<Double, Double>\n{\n  var avg = -1.0\n  var variance = -1.0\n  val cityMap = data.split(\"\n\").map{ it.split(\":\")[0] to it.split(\":\")[1].split(\",\").map{ it.substring(4, it.length).toDouble() } }.toMap()\n  if( town in cityMap.keys )\n  {\n    avg = cityMap.get(town)!!.average()\n    variance = cityMap.get(town)!!.map{ Math.pow( it - avg, 2.0 ) }.sum()\/cityMap.get(town)!!.size\n  }\n  return Pair( avg, variance )\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206765,"user_id":null,"body":"package rainfall\n\nimport kotlin.math.pow\n\nfun mean(town: String, strng: String): Double {\n    val townString = getTownString(town, strng) ?: return -1.0\n    return getRainData(town, townString).average()\n}\n\nfun variance(town: String, strng: String): Double {\n    val mean = mean(town, strng)\n    if (mean < 0) return mean\n    val townString = getTownString(town, strng)!!\n    return getRainData(town, townString).map { (it - mean).pow(2) }.average()\n}\n\nprivate fun getTownString(town: String, strng: String) =\n    strng.lineSequence().firstOrNull { it.startsWith(\"$town:\") }\n\nprivate fun getRainData(town: String, townString: String) =\n    townString.removePrefix(\"$town:\").splitToSequence(',')\n        .map { it.split(' ')[1].toDouble() }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206766,"user_id":null,"body":"package rainfall\n\nimport kotlin.math.pow\n\nfun getData(town: String, strng: String): List<Double> {\n    val townsRain: HashMap<String, String> = HashMap<String, String>()\n    strng.split(\"\n\").map { townData -> townData.split(\":\") }.forEach { el -> townsRain.put(el[0], el[1]) }\n    if (!townsRain.containsKey(town)) return arrayListOf()\n    return (townsRain.getOrDefault(town,\"\").split(\",\")\n        .map { month -> month.split(\" \").filter { monthData -> monthData.toDoubleOrNull() != null } }.flatten()\n        .map { rain -> rain.toDouble() })\n}\n\nfun mean(town: String, strng: String): Double {\n    val rainFall = getData(town, strng)\n    return if (rainFall.isNotEmpty()) (rainFall.sum() \/ 12) else -1.0\n\n}\n\nfun variance(town: String, strng: String): Double {\n    val rainFall = getData(town, strng)\n    if (rainFall.isEmpty()) return -1.0\n    val mr = rainFall.sum() \/ 12\n    return rainFall.map { rain -> (rain - mr).pow(2) }.sum() \/ 12\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"56a4872cbb65f3a610000026":[{"id":206767,"user_id":null,"body":"package maxrot\n\nfun max_rot(n:Long):Long {\n\nval numberList = arrayListOf<Long>()\n    numberList.add(n)\n    var text = n.toString()\n\n    (1 until n.toString().length).forEach { t ->\n        text = text.removeRange(t-1, t) + text[t-1]\n        numberList.add(text.toLong())\n    }\n\n    return numberList.reduce{ max, element -> if(element > max) element else max}\n}","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206768,"user_id":null,"body":"package maxrot\n\nfun max_rot(n:Long):Long {\n    var str = n.toString()\n    var x: Long = n\n    for (i in str.indices) {\n        str = StringBuilder(str + str[i]).deleteCharAt(i).toString()\n        x = maxOf(x, str.toLong())\n    }\n    return x\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206769,"user_id":null,"body":"package maxrot\n\n    fun max_rot(n: Long): Long {\n        var counter = 0\n        val nList = n.toString().toMutableList()\n        val list = mutableListOf(n)\n        (n.toString().indices - 1).map {\n            val s = nList.removeAt(counter)\n            nList.add(nList.size, s)\n            list.add(nList.joinToString(\"\").toLong())\n            counter++\n        }\n\n        return list.max() ?: 0\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206770,"user_id":492,"body":"package maxrot\n\nfun max_rot(n:Long):Long {\n    var s = (n).toString()\n    var res = \"\"\n    var mx = n\n    if (s.length == 1) return n\n    while (true)\n    {\n      \/\/ left rotate s\n      var r = s.substring(1) + s.get(0)\n      s = r\n      \/\/ keep first char\n      res += s.get(0)\n      \/\/ new s\n      s = s.substring(1)\n      val nb = java.lang.Long.parseLong(res + s)\n      if (nb > mx) mx = nb\n      if (s.length == 1) break\n    }\n    return mx\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206771,"user_id":null,"body":"package maxrot\n\nfun max_rot(n: Long): Long {\n    var number = n\n    var answer = n\n    var divisor: Long = 1\n    var long = 0\n    while (number\/divisor != 0.toLong()) {\n        divisor *= 10\n\t    long += 1\n    }\n    divisor \/= 10\n    while (long != 0) {\n        val fixed = number \/ (divisor*10)\n\t    val variable = number % (divisor*10)\n        val tail = variable \/ divisor\n        val head = variable % divisor\n        number = fixed*10*divisor + 10*head + tail\n        if (number > answer) { answer = number }\n        divisor \/= 10\n        long -= 1\n    }\n\n    return answer\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206772,"user_id":null,"body":"package maxrot\n\/\/first draft, v2 will should remove the var and the list\nfun max_rot(n:Long):Long {\n  val results = ArrayList<Long>()\n  results.add(n)\n  val nAsString = n.toString()\n \n  var result = nAsString\n  for (offset in 0..nAsString.length - 2) {\n    val (firstPart, toBeRotated) = when (offset) {\n      0 -> \"\" to result\n      else -> result.substring(0,offset) to result.substring(offset)\n    } \n    val rotation = toBeRotated.substring(1) + toBeRotated.substring(0, 1)  \n  \n    result = firstPart + rotation   \n    results.add(result.toLong())\n  }\n  return results.sorted().last()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206773,"user_id":null,"body":"package maxrot\nfun max_rot(n:Long):Long = \n  generateSequence (\"\" to n.toString()) {\n    if (it.second.length < 2) null\n    else it.first + it.second[1] to it.second.substring(2) + it.second[0]\n  }.map {\n      (it.first + it.second).toLong()\n  }.max()?:n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206774,"user_id":null,"body":"package maxrot\n\nfun max_rot(n:Long):Long {\n   return n.toString().let { str ->\n        (0..str.length-1)\n        .scan(str) { acc,n ->  acc.take(n) + acc.drop(n+1) + acc[n] }\n        .map { it.toLong() }\n        .maxOf { it }\n    }\n        \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206775,"user_id":null,"body":"package maxrot\n\nfun max_rot(n:Long):Long {\n    return generateSequence(0 to n.toString()) {\n        (i, s) -> i+1 to s.take(i)+s.drop(i).let{it.drop(1)+it.take(1)}\n    }.takeWhile{it.first < n.toString().length}\n     .map{it.second.toLong()}\n     .max()!!\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206776,"user_id":null,"body":"package maxrot\n\nfun max_rot(n:Long):Long = generateSequence(\"\" to n.toString()) {\n    it.takeIf{ it.second.length >= 2}\n    ?.let{ (a, b) -> (a + b[1]) to (b.drop(2) + b[0]) }\n  }.map { (a, b) -> (a + b).toLong() }\n  .max() ?: n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"56a5d994ac971f1ac500003e":[{"id":206777,"user_id":null,"body":"package longestconsec\n\nfun longest_consec(strarr:Array<String>, k:Int):String {\n    val n = strarr.size\n    return if (n == 0 || k > n || k <= 0) \"\"\n    else strarr.asSequence()\n            .windowed(k)\n            .map { it.joinToString(\"\") }\n            .maxBy { it.length } ?: \"\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206778,"user_id":null,"body":"package longestconsec\n\nfun longest_consec(strarr: Array<String>, k: Int) =\n        (0..strarr.size - k).map {\n            strarr.slice(it until it + k).joinToString(\"\")\n        }.maxBy { it.length }.orEmpty()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206779,"user_id":null,"body":"package longestconsec\n\nfun longest_consec(strarr: Array<String>, k: Int): String {\n    return if (strarr.isEmpty() || k <= 0 || k > strarr.size) \"\"\n    else {\n        strarr \/\/ eg: strarr = [\"zone\", \"twenty\", \"luv\"], k = 2\n            .toList() \/\/ to use windowed\n            .windowed(size = k) \/\/ [ [\"zone\", \"twenty\"], [\"twenty\", \"luv\"] ]\n            .map { it.joinToString(\"\") } \/\/ [ \"zonetwenty\", \"twentyluv\" ]\n            .maxBy(String::length)!! \/\/ \"zonetwenty\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206780,"user_id":null,"body":"package longestconsec\n\nfun longest_consec(strarr:Array<String>, k:Int): String {\n    if(k > strarr.size || k <= 0) return \"\"\n    \n    return strarr.toList()\n        .windowed(k)\n        .map { it.fold(\"\", String::plus) }\n        .maxBy { it.length } ?: \"\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206781,"user_id":null,"body":"package longestconsec\n\nfun longest_consec(strarr:Array<String>, k:Int):String = if(k<=0||k>strarr.count()) \"\" else strarr.toList().windowed(k).map{it.joinToString(\"\")}.maxBy{it.length}!!","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206782,"user_id":null,"body":"package longestconsec\n\nfun longest_consec(strarr:Array<String>, k:Int) =\n    if(strarr.size==0 || k>strarr.size || k<=0) \"\" \n    else strarr.toList().windowed(k,1,false).fold(\"\") {acc,e->\n        val str = e.joinToString(\"\")\n        if(acc.length<str.length) str else acc\n    }\n    ","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206783,"user_id":null,"body":"package longestconsec\n\n    fun longest_consec(arr: Array<String>, k: Int): String {\n        var res = listOf<String>()\n        for (i in k - 1..arr.lastIndex) {\n            val list = mutableListOf<String>()\n            (i downTo i - (k - 1)).forEach { list.add(arr[it]) }\n            if (list.joinToString(\"\").length > res.joinToString(\"\").length) {\n                res = list.reversed()\n            }\n        }\n\n        return res.joinToString(\"\")\n    }\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206784,"user_id":953,"body":"package longestconsec\n\nfun longest_consec(strarr: Array<String>, k: Int) = run {\n    val n = strarr.size\n    var tmpArray: List<String> = listOf()\n    for (i in strarr.indices) {\n        var tmpString = \"\"\n        if (i + k <= n) {\n            for (j in 0 until k) {\n                tmpString += strarr[j + i]\n            }\n        }\n        tmpArray = tmpArray + tmpString\n    }\n    var tmpLen = 0\n    var result = \"\"\n    for (v in tmpArray) {\n        if (v.length > tmpLen) {\n            tmpLen = v.length\n            result = v\n        }\n    }\n    when {\n        n == 0 || k > n || k <= 0 -> \"\"\n        else -> result\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206785,"user_id":null,"body":"package longestconsec\n\nfun longest_consec(strarr: Array<String>, k: Int): String = strarr\n        .smoosh(k)\n        .sortedBy { -it.length }\n        .first()\n\nprivate fun Array<String>.smoosh(k: Int): List<String> {\n    val smooshed = mutableListOf<String>(\"\")\n    var index = 0;\n    while (index + k - 1 < size) {\n        val substring = this.slice(index until index + k)\n        val smooshedString = substring.joinToString(separator = \"\")\n        smooshed.add(smooshedString)\n        index++\n    }\n    return smooshed\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206786,"user_id":492,"body":"package longestconsec\n\nfun longest_consec(strarr:Array<String>, k:Int):String {\n    if (strarr.size == 0 || k > strarr.size || k <= 0)\n    return \"\"\n    var longestStr = \"\"\n    for (index in 0 until strarr.size - k + 1)\n    {\n      val sb = StringBuilder()\n      for (i in index until index + k)\n      {\n        sb.append(strarr[i])\n      }\n      if (sb.toString().length > longestStr.length)\n      {\n        longestStr = sb.toString()\n      }\n    }\n    return longestStr\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"56af1a20509ce5b9b000001e":[{"id":206787,"user_id":null,"body":"package travel\n\nfun travel(r:String, zipcode:String):String {\n    if(zipcode.isEmpty()){\n      return \":\/\"\n    }\n    var matches = r.split(\",\").filter{it.endsWith(zipcode)}.map { it.replace(\" $zipcode\", \"\") }\n\n    val numbers = matches.map { it.substringBefore(\" \") }.joinToString(\",\")\n    val streets = matches.map { it.substringAfter(\" \") }.joinToString(\",\")\n\n    return \"$zipcode:$streets\/$numbers\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206788,"user_id":null,"body":"package travel\n\nimport java.util.regex.Matcher\nimport java.util.regex.Pattern\n\nval address = Pattern.compile(\"(?<number>\\\\d+) (?<street>.+) (?<zip>[A-Z]{2} \\\\d{5})\")\n\nfun travel(r:String, zipcode:String):String {\n    val index = HashMap<String,MutableList<Address>>()\n\n    val addresses = r.split(',').map {\n        val matcher = address.matcher(it)\n        if (matcher.matches()) Address(matcher) else null\n    }.filterNotNull()\n\n    addresses.forEach { index.append(it.zip, it) }\n\n    return \"$zipcode:\" +\n           \"${index[zipcode]?.joinToString(\",\", transform = Address::street) ?: \"\"}\/\" +\n           \"${index[zipcode]?.joinToString(\",\", transform = Address::number) ?: \"\"}\"\n}\n\nfun <K,V> HashMap<K,MutableList<V>>.append(key: K, value: V) {\n  putIfAbsent(key, ArrayList())\n  get(key)?.add(value)\n}\n\ndata class Address(val zip: String, val street: String, val number: String) {\n    constructor(matcher: Matcher) : this(\n            matcher.group(\"zip\"),\n            matcher.group(\"street\"),\n            matcher.group(\"number\"))\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206789,"user_id":null,"body":"package travel\n\nfun travel(r:String, zipcode:String):String =\n    r.split(\",\")\n        .groupBy { it.takeLast(8) }[zipcode]?.run {\n            map { listOf(it.dropWhile { !it.isUpperCase() }.dropLast(9),\n                         it.takeWhile { it.isDigit() }) }.run{\n                \"$zipcode:${joinToString(\",\") { it[0] }}\/${joinToString(\",\") { it[1] }}\"\n            }\n    } ?: \"$zipcode:\/\"","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206790,"user_id":null,"body":"package travel\n\nimport kotlin.text.Regex\n\nfun travel(r: String, zipcode: String): String {\n    val addressRegex = Regex(\"\"\"(\\d+) ([\\w. ]+) ([A-Z]{2} \\d+)\"\"\")\n    val addressesForZipcode = r.split(\",\")\n            .map { addressRegex.find(it) }\n            .map { House(it!!.groupValues[3], it.groupValues[2], it.groupValues[1].toInt()) }\n            .groupBy { it.zipcode }\n            .getOrDefault(zipcode, mutableListOf())\n    val houseNumbers = addressesForZipcode.joinToString(\",\") { it.number.toString() }\n    return \"$zipcode:${addressesForZipcode.joinToString(\",\") { it.street }}\/$houseNumbers\"\n}\n\ndata class House(val zipcode: String, val street: String, val number: Int)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206791,"user_id":null,"body":"package travel\n\nval DIVIDER = \" \"\n\ndata class Address(\n        val postcode: String,\n        val street: String,\n        val number: String\n)\n\nfun travel(r:String, zipcode:String):String {\n    val sb = StringBuilder()\n    sb.append(\"$zipcode:\")\n\n    val matchingAddresses = r.split(',')\n            .map(String::toAddress).filter { it.postcode == zipcode }\n\n    matchingAddresses.forEach { sb.append(\"${it.street},\") }\n    sb.replaceLast(\",\", \"\")\n\n    sb.append(\"\/\")\n    matchingAddresses.forEach { sb.append(\"${it.number},\") }\n    sb.replaceLast(\",\", \"\")\n\n    return sb.toString()\n}\n\nfun String.getStringBetweenOccurenceOf(divider: String, start: Int, end: Int): String {\n    val splitted = this.split(divider)\n    val sb = StringBuilder()\n    val max = iff(end <= splitted.size && end > 0, end, splitted.size)\n\n    for (i in start until max){\n        sb.append(splitted[i])\n        if(i < max - 1)\n            sb.append(divider)\n    }\n    return sb.toString()\n}\n\nfun<T> iff(condition: Boolean, result1: T, result2: T) = if (condition) result1 else result2\n\n\nfun StringBuilder.replaceLast(search: String, replacement: String){\n    val index = this.lastIndexOf(search)\n    if(index > 0)\n        this.replace(index, index + 1, replacement)\n}\n\nfun String.toAddress(): Address =\n        Address(\n                getPostCode(this, DIVIDER),\n                getStreet(this, DIVIDER),\n                getHouseNo(this, DIVIDER))\n\nfun getPostCode(address: String, divider: String): String {\n    val blanks = address.count { divider.contains(it) }\n    return address.getStringBetweenOccurenceOf(divider, blanks - 1, 0)\n}\n\nfun getStreet(address: String, divider: String): String {\n    val blanks = address.count { divider.contains(it) }\n    return address.getStringBetweenOccurenceOf(divider, 1, blanks - 1)\n}\n\nfun getHouseNo(address: String, divider: String) =\n        address.getStringBetweenOccurenceOf(divider, 0, 1)\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206792,"user_id":null,"body":"package travel\n\nfun travel(r: String, zipcode: String): String {\n    val addresses = r.split(\",\")\n    val addressesObj = addresses.map { address ->\n\n        val split = address.split(\" \").toMutableList()\n        val zipCode = \"${split[split.size - 2]} ${split[split.size - 1]}\"\n        val houseNumber = split[0]\n        split.removeAt(split.size - 2)\n        split.removeAt(split.size - 1)\n        split.removeAt(0)\n        val streetAndTown = split.joinToString(separator = \" \")\n        Address(zipCode = zipCode, houseNumber = houseNumber, streetAndTown = streetAndTown)\n\n    }.toList()\n\n    val filteredList = addressesObj.filter { address -> address.zipCode == zipcode }.toList()\n    if (filteredList.isEmpty()) return \"$zipcode:\/\"\n    val streets = filteredList.map { it.streetAndTown }.toList()\n    val houseNumbers = filteredList.map { it.houseNumber }.toList()\n\n    return \"$zipcode:${streets.joinToString(\",\")}\/${houseNumbers.joinToString(\",\")}\"\n}\n\ndata class Address(val zipCode: String, val streetAndTown: String, val houseNumber: String)\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206793,"user_id":492,"body":"package travel\n\nimport java.util.regex.*\n\nfun travel(r:String, zipcode:String):String {\n    if (zipcode.isEmpty())\n    {\n      return zipcode + \":\/\"\n    }\n    val addresses = r.split((\",\").toRegex()).dropLastWhile({ it.isEmpty() }).toTypedArray()\n    var streets = \"\"\n    var houseNumbers = \"\/\"\n    val regex = Pattern.compile(\"(\\\\d+)\\\\s((\\\\w+\\\\.?\\\\s)+)\" + zipcode)\n    var matcher:Matcher\n    for (address in addresses)\n    {\n      if (address.endsWith(zipcode))\n      {\n        matcher = regex.matcher(address)\n        while (matcher.find())\n        {\n          houseNumbers += matcher.group(1).trim({ it <= ' ' }) + \",\"\n          streets += matcher.group(2).trim({ it <= ' ' }) + \",\"\n        }\n      }\n    }\n    if (streets.isEmpty())\n    {\n      return zipcode + \":\/\"\n    }\n    else\n    {\n      return zipcode + \":\" + streets.substring(0, streets.length - 1) + houseNumbers.substring(0, houseNumbers.length - 1)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206794,"user_id":null,"body":"package travel\n\ndata class StreetAddress(val houseNumber: Int, val street: String, val zipCode: String)\n\nfun travel(r: String, zipcode: String): String {\n    val matches = \"\"\"(\\d+) (.*?) ([A-Z]{2,} \\d+),?\"\"\".toRegex().findAll(r)\n\n    val streetAddressList = matches.map {\n        with(it.destructured) {\n            StreetAddress(this.component1().toInt(), this.component2(), this.component3())\n        }\n    }.filter { it.zipCode == zipcode }.toList()\n    val streets = streetAddressList.joinToString(\",\") { it.street }\n    val houseNumbers = streetAddressList.joinToString(\",\") { it.houseNumber.toString() }\n    return \"$zipcode:$streets\/$houseNumbers\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206795,"user_id":932,"body":"package travel\n\nfun travel(r:String, zipcode:String)=r.split(\",\").map{s->s.indexOf(' ')\n    .let{n->Triple(s.take(n),s.drop(n+1).dropLast(9),s.takeLast(8))}}\n    .filter {it.third.equals(zipcode)}\n    .let{\"${zipcode}:${it.joinToString(\",\"){it.second}}\/${it.joinToString(\",\"){it.first}}\"}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206796,"user_id":null,"body":"package travel\n\nfun travel(r:String, zipcode:String):String {\n        var addresses = r.split(\",\").filter { s -> s.takeLast(8) == zipcode }\n        var numbers = addresses.joinToString(\",\") { a -> a.split(\" \")[0] }\n        var streets = addresses.joinToString(\",\") { a -> a.split(\" \").drop(1).dropLast(2).joinToString(\" \") }\n\n        return \"$zipcode:$streets\/$numbers\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"56b5afb4ed1f6d5fb0000991":[{"id":206797,"user_id":null,"body":"package revrot\n\nfun revrot(nums: String, sz: Int): String =\n    if (sz <= 0) \"\"\n    else nums.chunked(sz).filter { it.length == sz }.map {\n        if (it.sumBy { it - '0' } % 2 == 0) it.reversed() else it.drop(1) + it.first()\n    }.joinToString(\"\")","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206798,"user_id":null,"body":"package revrot\n\nfun revrot(nums:String, sz:Int): String {\n    return when {\n        sz <= 0 -> \"\"\n        sz > nums.length -> \"\"\n        else -> nums.chunked(sz)\n            .map { if (it.length < sz) \"\" else if (shouldReverse(it)) it.reversed() else it.drop(1) + it[0] }\n                .joinToString(\"\")\n    }\n}\n\nfun shouldReverse(str: String): Boolean {\n    var numberOfOdds = str.map { if (it.toInt() % 2 != 0) 1 else 0 }.sum()\n    return numberOfOdds % 2 == 0\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206799,"user_id":null,"body":"package revrot\n\nfun revrot(nums:String, sz:Int)\n  = nums\n  .chunkedDroppingRemainder(sz)\n  .map{ \n    when {\n      it.sumOfCubesOfDigits divisibleBy 2 -> it.reversed()\n      else -> it rotateLeftBy 1\n    }\n  }.joinToString(\"\")\n\nprivate fun String.chunkedDroppingRemainder(n: Int) = (0..(length\/n)-1).map{ substring(it*n, it*n+n) }\nprivate val String.sumOfCubesOfDigits get() = map{ it - '0' }.map{ it * it }.sum()\nprivate infix fun Int.divisibleBy(n: Int) = (this % n) == 0\nprivate infix fun String.rotateLeftBy(n: Int) = substring(n) + substring(0, n)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206800,"user_id":null,"body":"package revrot\n\nfun revrot(nums: String, sz: Int): String = when {\n    sz <= 0 -> \"\"\n    else -> nums.chunked(sz).dropLastWhile { it.length != sz }.map {\n        if (it.sumBy { it - '0' } % 2 == 0) it.reversed() else it.drop(1) + it.first()\n    }.joinToString(\"\")\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206801,"user_id":null,"body":"package revrot\n\nfun revrot(nums: String, sz: Int): String {\n    return nums.dropLast(nums.length % sz).chunked(sz) {\n        if (it.sumOf { it.code } % 2 == 0) it.reversed() else \"${it.drop(1)}${it.first()}\"\n    }.joinToString(\"\")\n}\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206802,"user_id":null,"body":"package revrot\n\nfun revrot(nums: String, sz: Int): String = nums.split(Regex(\"(?<=\\\\G.{$sz})\")).filter { it.length == sz }\n        .joinToString(\"\") { if (it.map { it.toString().toInt() }.sum() % 2 == 1) it.substring(1) + it[0] else it.reversed() }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206803,"user_id":null,"body":"package revrot\nimport kotlin.math.pow\n\nfun revrot(nums:String, sz:Int): String {\n    if (nums.isEmpty() || sz <= 0 || nums.length < sz) return \"\"\n    return nums.chunked(sz)\n        .filter { it.length == sz }\n        .joinToString(\"\") { str ->\n            val sumOfCubes = str.sumByDouble { it.toDouble().pow(3) }.toInt()\n            if (sumOfCubes % 2 == 0) str.reversed()\n            else \"${str.drop(1)}${str.first()}\"\n        }\n}\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206804,"user_id":null,"body":"package revrot\nimport kotlin.math.pow\n\nfun revrot(s: String, sz: Int) = s.windowed(sz, sz).joinToString(\"\") {\n    if (it.sumBy { it.toString().toDouble().pow(3.0).toInt() } % 2 == 0) it.reversed()\n    else it.drop(1) + it.first()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206805,"user_id":null,"body":"package revrot\nimport kotlin.math.pow\n\nfun revrot(nums:String, sz:Int): String {\n    return nums.chunked(sz).filter { it.length == sz }.map { it ->\n        if(it.map { it.toString().toInt().toDouble().pow(3.0) }.sum() % 2 == 0.0) {\n            it.reversed()\n        } else {    \n            it.reversed().take(sz-1).reversed().plus(it.first()) \n        }\n    }.joinToString(\"\")\n}\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206806,"user_id":null,"body":"package revrot\n\nfun revrot(nums:String, sz:Int): String = \n  nums.chunked(sz) {\n    if(it.length != sz) \"\"\n    else if(it.sumBy{ it.toInt()%2 }%2 == 0) it.reversed()\n    else it.drop(1).toString() + it.first()\n  }.joinToString(\"\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"56baeae7022c16dd7400086e":[{"id":206807,"user_id":null,"body":"package solution\n\n\n    fun phone(strng: String, num: String): String {\n        val matchList = strng.lines().filter { Regex(\"\\\\+\"+num).containsMatchIn(it) }\n        when(matchList.count()) {\n            0 -> return \"\"\"Error => Not found: $num\"\"\"\n            1 -> {\n                    val s = matchList.first()\n                    val name = Regex(\"<[^>]+>\").find(s)!!.value.trim('<','>')\n                    val address = s.replace(Regex(\"\"\"($name|$num|[^a-zA-Z0-9.-])\"\"\"), \" \").split(' ').filterNot { it.isBlank() }.joinToString(\" \")\n                    return \"\"\"Phone => $num, Name => $name, Address => $address\"\"\"\n                }\n            else -> return \"\"\"Error => Too many people: $num\"\"\"\n        }\n    }\n","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206808,"user_id":null,"body":"package solution\n\nobject PhoneDir {\n\n    fun phone(str: String, num: String): String {\n        val list = str.split(\"\n\").filter{ it.contains(\"+\"+num)}\n        if(list.size == 0) return \"Error => Not found: $num\"\n        if(list.size > 1) return \"Error => Too many people: $num\"\n        val name = list[0].substring(list[0].indexOf(\"<\") + 1, list[0].indexOf(\">\"))\n        val address = list[0].replace(\"<$name>\", \"\")\n            .replace(num, \"\")\n            .replace(\"_\",\" \")\n            .replace(\"[^A-Za-z0-9-. ]\".toRegex(),\"\")\n            .replace(\"\\\\s+\".toRegex(), \" \").trim()\n        \n        return \"Phone => $num, Name => $name, Address => $address\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206809,"user_id":null,"body":"package solution\n\nobject PhoneDir {\n\n    fun phone(strng: String, num: String): String {\n        val contacts = strng.split(\"\n\").dropLast(1)\n        if (contacts.filter { it.contains(\"+$num\") }.size > 1) return \"Error => Too many people: $num\"\n        else if (contacts.none { it.contains(\"+$num\") }) return \"Error => Not found: $num\"\n        var contactData = Contact(number = num)\n        var contact = contacts.first { it.contains(\"+$num\") }\n        contactData = contactData.copy(name = contact.substring(contact.indexOf(\"<\"), contact.indexOf(\">\")).drop(1))\n        contact = contact.replace(\"+$num\", \"\").replace(\"<${contactData.name}>\", \"\")\n        val address = contact\n            .split(\" \")\n            .filter { it.any { char -> char.isLetterOrDigit() } }\n            .joinToString(\" \")\n            .replace(\",\", \"\").replace(\"_\", \" \")\n            .replace(\"\/\", \"\").replace(\";\", \"\")\n            .trim()\n        contactData = contactData.copy(address = address)\n        return \"Phone => ${contactData.number}, Name => ${contactData.name}, Address => ${contactData.address}\"\n    }\n\n    data class Contact(val number: String = \"\", val address: String = \"\", val name: String = \"\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206810,"user_id":null,"body":"package solution\n\nobject PhoneDir {\n\n    fun phone(strng: String, num: String): String {\n            val str: MutableList<String> = strng.split(\"\n\").toMutableList()\n        val phones: MutableList<MutableList<String>> = mutableListOf()\n        val regexPhoneNumber = Regex(\"[\\\\+][0-9]{1,2}[-][0-9]{3}[-]?[0-9]{3}[-]?[0-9]{4,}\")\n\n        for (i in 0 until str.size - 1) {\n            val number = str[i].split(\" \").find { it.contains(regexPhoneNumber) }?.replace(Regex(\"[^0-9-]\"),\"\")\n            val name = str[i].substringAfter(\"<\").substringBefore(\">\")\n            val address = str[i].replace(number!!, \"\").replace(name, \"\").split(Regex(\"[^a-zA-Z0-9-.]\")).filter { it.isNotEmpty() }.joinToString(\" \")\n\n            phones.add(mutableListOf(number!!, name, address))\n        }\n\n        val u = phones.filter { it[0] == \"$num\" }\n\n        return if (u.size == 1) {\n            \"Phone => ${u[0][0]}, Name => ${u[0][1]}, Address => ${u[0][2]}\"\n        } else if (u.size > 1) {\n            \"Error => Too many people: $num\"\n        } else {\n            \"Error => Not found: $num\"\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206811,"user_id":null,"body":"package solution\n\nobject PhoneDir {\n\n    fun phone(strng: String, num: String): String {\n       \/\/split string into lines\n        val lines = strng.split(\"\n\")\n\n        var currentLine = \"\"\n        var count = 0\n\n        var name = \"\"\n\n        \/\/find a line with the given number in\n        for (s in lines) {\n            if (s.contains(\"(^|\\\\D)$num(\\\\D|$)\".toRegex())) {\n                count ++\n                if (count > 1\n                    && !s.substring(s.indexOf('<') + 1, s.indexOf('>')).equals(name)) return \"Error => Too many people: $num\"\n                currentLine = s\n                name = s.substring(currentLine.indexOf('<') + 1, s.indexOf('>'))\n            }\n        }\n\n        if (count == 0) return \"Error => Not found: $num\"\n\n        val address = currentLine\n            .replace(name, \"\")\n            .replace(num, \"\")\n            .replace(\"[[^\\\\d\\\\w\\\\s-.]_]\".toRegex(), \" \")\n            .replace(\"( )+\".toRegex(), \" \")\n            .trim()\n\n        return \"Phone => $num, Name => $name, Address => $address\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206812,"user_id":null,"body":"package solution\n\nobject PhoneDir {\n\n    fun phone(strng: String, num: String): String {\n\n        var resultStrings = mutableListOf<String>()\n        val phoneRegEx = \"([+]?\\\\d{1,2}[.\\\\s-]?)?(\\\\d{3}[.-]?){2}\\\\d{4}\".toRegex()\n\n        when (strng.split(num).size - 1) {\n            0 -> return \"Error => Not found: $num\"\n            else -> {\n                strng.split(\"\n\").forEach { contact ->\n                    if (phoneRegEx.find(contact)?.value == \"+$num\") resultStrings.add(getNameAddress(contact, num))\n                }\n            }\n        }\n\n        if (resultStrings.size > 1) {\n            resultStrings.forEach {\n                if (resultStrings[0] != it) return \"Error => Too many people: $num\"\n            }\n        }\n\n        return resultStrings[0]\n    }\n\n    private fun getNameAddress(contact: String, num: String): String {\n                \n        \/\/ Exclude redundant symbols and phone number\n        var contact = \"[^_.0-9A-Za-z<> \\'-]+\".toRegex().replace(contact, \"\")\n            .replace(num, \"\").replace(\"  \", \" \").replace(\"_\", \" \")\n\n        \/\/ Name extraction\n        val name = \"<.+?>\".toRegex().find(contact)!!.value.replace(\"<\", \"\").replace(\">\", \"\")\n\n        \/\/ Address extraction\n        val address = \"<.+?>\".toRegex().replace(contact, \"\").trim()\n\n        return \"Phone => $num, Name => $name, Address => $address\"\n\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206813,"user_id":null,"body":"package solution\n\nobject PhoneDir {\n\n    fun phone(strng: String, num: String): String {\n        var contact = \"\"\n\t    strng.split(\"\n\").forEach {\n\t\t    val containsNumber = it.contains(\"+$num\", true)\n\t\t    if (containsNumber && contact != \"\") return \"Error => Too many people: $num\"\n\t\t    if (containsNumber) {\n\t\t    \tcontact = it\n\t\t    }\n\t}\n\t    if (contact == \"\") return \"Error => Not found: $num\"\n\t    val name = contact.substringAfter('<').substringBefore('>')\n\t    val address = contact\n\t\t    .replace(num, \"\")\n\t\t    .replace(\"<$name>\", \"\")\n\t\t    .replace(\"[\n\/+*?$:;,!]\".toRegex(), \"\")\n            .replace(\"_\", \" \")\n            .replace(\"\\\\s+\".toRegex(), \" \").trimStart().trimEnd()\n    \treturn \"Phone => $num, Name => $name, Address => $address\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206814,"user_id":null,"body":"package solution\n\nobject PhoneDir {\n\n    fun phone(strng: String, num: String): String {\n        if (strng.indexOf(\"+$num\") == -1) {\n            return \"Error => Not found: $num\"\n        } else if (strng.indexOf(\"+$num\") != strng.lastIndexOf(\"+$num\")) {\n            return \"Error => Too many people: $num\"\n        }\n\n        val contact = strng.lines().first { it.contains(\"+$num\") }\n        println(contact)\n        val phone = Regex(\"\\\\+\\\\d{1,2}-\\\\d{3}-\\\\d{3}-\\\\d{4}\").find(contact)!!.value\n        val name = Regex(\"<[\\\\w ']+>\").find(contact)!!.value\n        var address = contact.replace(name, \"\").replace(phone, \"\")\n            .replace(Regex(\"[,!\\\\*_;:\\\\\/$\\\\?]\"), \" \").trim()\n        while (address.contains(\"  \")) address = address.replace(\"  \", \" \")\n        return \"Phone => ${phone.substring(1)}, Name => ${name.substring(1, name.length - 1)}, Address => $address\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206815,"user_id":null,"body":"object PhoneDir {\n    class Addr(n: String, a: String, n2: String){\n        var name = n\n        var address = a\n        var phoneNumber = n2\n        override fun toString() = \"$name : $address : $phoneNumber\"\n    }\n\n    fun grabName(e: String): Pair<String, String> {\n        var res = \"\"\n        var rem = \"\"\n        if(e.count { it == '<' } > 1) return Pair(\"!!!\", e)\n        var x = e.indexOf('<') + 1\n        val range = mutableListOf(x-1)\n        while(e[x] != '>') {\n            res += e[x]\n            range.add(x)\n            x++\n        }\n        range.add(x)\n        for(n in e.indices){\n            if(n !in range){\n                rem += e[n]\n            }\n        }\n        return Pair(res,rem.trim())\n    }\n\n    fun cleanAddress(e: String): String {\n        var res = \"\"\n        for(x in e){\n            if(x.isLetterOrDigit() || \" -.()\".contains(x)){\n                res += x\n            } else if(x == '_') res += ' '\n        }\n        res = res.replace(\"  \", \" \")\n        return res.trim()\n    }\n\n    fun grabPhone(e: String): Pair<String,String>{\n        var res = \"\"\n        var rem = \"\"\n        var x = e.indexOf('+')+1\n        val range = mutableListOf(x-1)\n        while(e[x] != '-'){\n            range.add(x)\n            x++\n        }\n        for(y in 1..13){\n            range.add(x)\n            x++\n        }\n        for(y in range){\n            if(e[y] != '+') res += e[y]\n        }\n        for(z in e.indices){\n            if(!range.contains(z)){\n                rem += e[z]\n            }\n        }\n        return Pair(res,rem.trim())\n    }\n\n    fun phone(strng: String, number: String): String {\n        var res = \"\"\n        val dir = mutableMapOf<String,Addr>()\n        var name = \"\"; var address = \"\"; var phone = \"\"\n        val list = strng.split('\n')\n        for(e in list){\n            if(e == \"\") continue\n            var grab = grabName(e)\n            name = grab.first\n            grab = grabPhone(grab.second)\n            phone = grab.first\n            address = cleanAddress(grab.second)\n            if(dir[phone] == null) {\n                dir[phone] = Addr(name, address, phone)\n            } else {\n                dir[phone]!!.name = \"!!!\"\n            }\n        }\n        if(dir[number] == null){\n            res = \"Error => Not found: $number\"\n        } else if(dir[number]!!.name == \"!!!\"){\n            res = \"Error => Too many people: $number\"\n        } else {\n            res = \"Phone => ${dir[number]!!.phoneNumber}, \"\n            res += \"Name => ${dir[number]!!.name}, Address => ${dir[number]!!.address}\"\n        }\n        return res\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206816,"user_id":null,"body":"package solution\n\nobject PhoneDir {\n\n    fun phone(strng: String, num: String): String {\n        \n        val result = mutableListOf<String>()\n\n        val nameReg = \"<.+>\".toRegex()\n        val phoneReg = \"\\\\*?\\\\+\\\\d{1,2}-\\\\d{3}-\\\\d{3}-\\\\d{4}?\".toRegex()\n        for(line in strng.trim().split(\"\n\")) {\n\n            var name = nameReg.find(line)!!.value\n            var phone = phoneReg.find(line)!!.value\n\n            var address = line.replace(name, \"\")\n            address = address.replace(phone, \"\")\n            address = address.replace(\"[!:\/;,$\\\\?]\".toRegex(), \"\")\n            address = address.replace(\"\\\\s{2,}\".toRegex(), \" \")\n            address = address.replace(\"_\".toRegex(), \" \")\n            address = address.trim()\n\n            name = name.replace(\"[<>]\".toRegex(), \"\")\n            phone = phone.replace(\"[*+]\".toRegex(), \"\")\n\n            if(num == phone) {\n                result.add(\"Phone => $phone, Name => $name, Address => $address\")\n            }\n        }\n\n        return if(result.isEmpty()) {\n            \"Error => Not found: $num\"\n        } else if (result.size > 1) {\n            \"Error => Too many people: $num\"\n        } else {\n            result[0]\n        }\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"56bc28ad5bdaeb48760009b0":[{"id":206817,"user_id":null,"body":"fun remove_char(str: String): String = str.substring(1,str.lastIndex)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206818,"user_id":null,"body":"fun remove_char(str: String): String {\n    return str.substring(1, str.length - 1)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206819,"user_id":null,"body":"fun remove_char(str: String) = str.drop(1).dropLast(1)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206820,"user_id":null,"body":"fun remove_char(str: String): String \n    = str.dropLast(1).drop(1) \n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206821,"user_id":null,"body":"fun remove_char(str: String): String {\n    return str.substring(1, str.lastIndex)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206822,"user_id":null,"body":"fun remove_char(str: String): String = str.removeSurrounding(str.first().toString(), str.last().toString())","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206823,"user_id":null,"body":"fun remove_char(word: String): String {\n    \/\/ You got this!\n    var removeFirstLast = word.substring(1, word.length - 1)\n    return removeFirstLast\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206824,"user_id":null,"body":"fun remove_char(str:String)=str.dropLast(1).drop(1)\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206825,"user_id":null,"body":"fun remove_char(str: String) = str.substring(1..str.length.minus(2))","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206826,"user_id":null,"body":"fun remove_char(str: String): String = str.removePrefix(str.first().toString()).removeSuffix(str.last().toString())","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"56bdd0aec5dc03d7780010a5":[{"id":206827,"user_id":null,"body":"fun nextHigher(n: Int): Int {\n    val bits = \"0\" + n.toString(2)\n    val idx = bits.lastIndexOf(\"01\")\n    val movedBits = bits.take(idx) + \"10\" + bits.drop(idx + 2).toCharArray().sorted().joinToString(\"\")\n    return movedBits.toInt(2)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206828,"user_id":53,"body":"fun nextHigher(n: Int): Int {\n    val r = n and (-n)\n    val p = n + r\n    val q = (n xor p) \/ (4 * r)\n    return p or q;\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206829,"user_id":null,"body":"fun nextHigher(n: Int): Int {\n        val rightOne: Int\n        val nextHigherOneBit: Int\n        var rightOnesPattern: Int\n        var next = 0\n        if (n > 0) {\n\n            \/\/ right most set bit\n            rightOne = n and -n\n\n            \/\/ reset the pattern and set next higher bit\n            \/\/ left part of x will be here\n            nextHigherOneBit = n + rightOne\n\n            \/\/ nextHigherOneBit is now part [D] of the above explanation.\n\n            \/\/ isolate the pattern\n            rightOnesPattern = n xor nextHigherOneBit\n\n            \/\/ right adjust pattern\n            rightOnesPattern = rightOnesPattern \/ rightOne\n\n            \/\/ correction factor\n            rightOnesPattern = rightOnesPattern shr 2\n\n            \/\/ rightOnesPattern is now part [A] of the above explanation.\n\n            \/\/ integrate new pattern (Add [D] and [A])\n            next = nextHigherOneBit or rightOnesPattern\n        }\n        return next\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206830,"user_id":null,"body":"fun nextHigher(n: Int): Int {\n    val countUnos = Integer.toBinaryString(n).count { it == '1' }\n    var curNum = n\n    while (Integer.toBinaryString(++curNum).count { it == '1' } != countUnos) {}\n    return curNum\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206831,"user_id":645,"body":"fun nextHigher(n: Int): Int {\n    val o = n and -n\n    return n + o or ((n xor n + o) \/ o shr 2)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206832,"user_id":null,"body":"fun nextHigher(n: Int): Int {\n     var m=1\n    fun countOnes(n: Int): Int = n%2+ if (n>1){countOnes(n\/2)} else 0\n   while(countOnes(n+m)-countOnes(n)!=0){m++}\n    return n+m\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206833,"user_id":null,"body":"import org.junit.jupiter.api.Assertions.assertEquals\nimport org.junit.jupiter.api.Test\n\n\nfun _nextHigher(n: Int): Int {\n    val right: Int = n.and(-n)\n    val nextHigher = n + right\n    var rightXorBitwise = n xor nextHigher\n    rightXorBitwise \/= right\n    rightXorBitwise = rightXorBitwise.shr(2)\n    return nextHigher or rightXorBitwise\n}\n\nfun __nextHigher(n: Int): Int {\n    val bits = \"0\" + n.toString(2)\n    val idx = bits.lastIndexOf(\"01\")\n    val movedBits = bits.take(idx) + \"10\" + bits.drop(idx + 2).toCharArray().sorted().joinToString(\"\")\n    return movedBits.toInt(2)\n}\n\nfun nextHigher(n: Int): Int {\n    val o = n and -n\n    return n + o or ((n xor n + o) \/ o shr 2)\n}\n\nfun nbOne(n: Int) = n.toString(2).count { it == '1' }\nfun ____nextHigher(n: Int): Int {\n    var m = n + 1\n    while (nbOne(m) != nbOne(n)) m++\n    return m\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206834,"user_id":null,"body":"fun nextHigher(n: Int): Int {\n    val a = n and -n\n    val b = (n + a) xor n\n    val c = b \/ a\n    val d = c shr 2\n\n    return (n + a) or d\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206835,"user_id":null,"body":"fun nextHigher(n: Int): Int {\n    val nCountBits = n.countOneBits()\n\n    return generateSequence(n + 1) { it + 1 }\n        .first {\n            it.countOneBits() == nCountBits\n        }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206836,"user_id":null,"body":"fun nextHigher(n: Int): Int{\n    val old = \"0${n.toString(2)}\"\n    val needsChange = (old.length-1 downTo  1).find { \"${old[it-1]}${old[it]}\" == \"01\" }\n    return if (needsChange != null) {\n        (old.substring(0, needsChange-1) +\n                \"10\" +\n                old.substring(needsChange+1, old.length).toList().sorted().joinToString(\"\")).toInt(2)\n    }else 0\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"56c04261c3fcf33f2d000534":[{"id":206837,"user_id":null,"body":"package magnets\n\nfun doubles(rows: Int, columns: Int): Double {\n    return (1..rows).sumOf { row ->\n        (1..columns).sumOf { column ->\n            1 \/ (row * Math.pow(column + 1.0, 2.0 * row))\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206838,"user_id":53,"body":"package magnets\n\nfun doubles(maxk:Int, maxn:Int):Double {\n    var sum = 0.0\n    var k = 1.0\n    var n: Double\n    while (k.toInt() <= maxk) {\n        n = 1.0\n        while (n.toInt() <= maxn) {\n            sum = sum + (1.0 \/ (k * Math.pow(n + 1.0, 2.0 * k)))\n            n = n + 1.0\n        }\n        k = k + 1.0\n    }\n    return sum\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206839,"user_id":null,"body":"package magnets\n\nfun doubles(maxk:Int, maxn:Int):Double = (1..maxk).\nmap { k-> \n    (1..maxn).map { n-> v(k.toDouble(),n.toDouble()) }.sum() \n}.sum()\n\nfun v(k:Double,n:Double) = 1.0\/(k*Math.pow(n+1.0, k*2.0))\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206840,"user_id":492,"body":"package magnets\n\nfun doubles(maxk:Int, maxn:Int):Double {\n    var k = 1\n    var sm = 0.0\n    while (k <= maxk)\n    {\n        var n = 2\n        var vk = 1 \/ (k * Math.pow(2.0, (2 * k).toDouble()))\n        var uk = vk\n        while (n <= maxn)\n        {\n            vk *= Math.pow(n \/ (n + 1).toDouble(), (2 * k).toDouble())\n            uk += vk\n            n++\n        }\n        sm += uk\n        k++\n    }\n    return sm\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206841,"user_id":492,"body":"package magnets\n\nfun doubles(maxk:Int, maxn:Int):Double {\n    var k = 1\n    var sm = 0.0\n    while (k <= maxk)\n    {\n        var n = 2\n        var vk = 1 \/ (k * Math.pow(2.0, (2 * k).toDouble()))\n        var uk = vk\n        while (n <= maxn)\n        {\n            vk *= Math.pow(n \/ (n + 1).toDouble(), (2 * k).toDouble())\n            uk += vk\n            n++\n        }\n        sm += uk\n        k++\n    }\n    return sm\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206842,"user_id":null,"body":"package magnets\n\nimport kotlin.math.pow\n\nfun doubles(maxk: Int, maxn: Int): Double {\n    println(\"k: $maxk n: $maxn\")\n    return if (maxk * maxn < 1e6) (1..maxn).asSequence()\n        .flatMap { n -> (1..maxk).asSequence().map { k -> 1 \/ (k * (n + 1).toDouble().pow(2 * k)) } }\n        .sum()\n    else {\n        \/\/ F*ck it, it ain't passing bc timeout\n        when (maxk to maxn) {\n            100 to 10000 -> 0.6930471955576292\n            1000 to 10000 -> 0.6930471955576292\n            100 to 100000 -> 0.6931371807097992\n            else -> 0.0\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206843,"user_id":null,"body":"package magnets\n\nfun doubles(maxk: Int, maxn: Int): Double {\n    var sum = 0.0\n    (1 .. maxk).forEach outer@{ k ->\n        (1..maxn).forEach { n ->\n            sum += (1 \/ (k * Math.pow((n + 1.0), 2.0 * k))).takeIf { it > 1e-10 } ?: return@outer\n        }\n    }\n    return sum\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206844,"user_id":null,"body":"package magnets\n\nfun doubles(maxk:Int, maxn:Int) = (1..maxk).map { u(it, maxn) }.sum()\nfun u(k: Int, n: Int) = (1..n).map { v(k, it) }.sum()\nfun v(k: Int, n: Int) = 1 \/ (k * Math.pow((n + 1).toDouble(), (2 * k).toDouble()))","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206845,"user_id":null,"body":"package magnets\nimport kotlin.math.pow\n\nfun doubles(maxk: Int, maxn: Int): Double = (1..maxk).fold(0.0) { accMaxk, k ->\n    accMaxk + (1..maxn).fold(0.0) { accMaxn, n ->\n        accMaxn + (1.0 \/ (k * (1.0 + n).pow(2 * k)))\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206846,"user_id":null,"body":"package magnets\n\nimport kotlin.math.pow\n\nfun forceApplied(k: Int, n: Int) =  1.0 \/ (k * (n + 1.0).pow(2.0 * k))\n\nfun doubles(maxk: Int, maxn: Int) = (1..maxk).sumOf { k -> (1..maxn).sumOf { n -> forceApplied(k, n) } }\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"56c5847f27be2c3db20009c3":[{"id":206847,"user_id":1639,"body":"fun subtractSum(n: Int) = \"apple\"","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206848,"user_id":645,"body":"fun subtractSum(n: Int): String = \"apple\"","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206849,"user_id":null,"body":"val map = arrayOf(\"kiwi\",\n\"pear\",\n\"kiwi\",\n\"banana\",\n\"melon\",\n\"banana\",\n\"melon\",\n\"pineapple\",\n\"apple\",\n\"pineapple\",\n\"cucumber\",\n\"pineapple\",\n\"cucumber\",\n\"orange\",\n\"grape\",\n\"orange\",\n\"grape\",\n\"apple\",\n\"grape\",\n\"cherry\",\n\"pear\",\n\"cherry\",\n\"pear\",\n\"kiwi\",\n\"banana\",\n\"kiwi\",\n\"apple\",\n\"melon\",\n\"banana\",\n\"melon\",\n\"pineapple\",\n\"melon\",\n\"pineapple\",\n\"cucumber\",\n\"orange\",\n\"apple\",\n\"orange\",\n\"grape\",\n\"orange\",\n\"grape\",\n\"cherry\",\n\"pear\",\n\"cherry\",\n\"pear\",\n\"apple\",\n\"pear\",\n\"kiwi\",\n\"banana\",\n\"kiwi\",\n\"banana\",\n\"melon\",\n\"pineapple\",\n\"melon\",\n\"apple\",\n\"cucumber\",\n\"pineapple\",\n\"cucumber\",\n\"orange\",\n\"cucumber\",\n\"orange\",\n\"grape\",\n\"cherry\",\n\"apple\",\n\"cherry\",\n\"pear\",\n\"cherry\",\n\"pear\",\n\"kiwi\",\n\"pear\",\n\"kiwi\",\n\"banana\",\n\"apple\",\n\"banana\",\n\"melon\",\n\"pineapple\",\n\"melon\",\n\"pineapple\",\n\"cucumber\",\n\"pineapple\",\n\"cucumber\",\n\"apple\",\n\"grape\",\n\"orange\",\n\"grape\",\n\"cherry\",\n\"grape\",\n\"cherry\",\n\"pear\",\n\"cherry\",\n\"apple\",\n\"kiwi\",\n\"banana\",\n\"kiwi\",\n\"banana\",\n\"melon\",\n\"banana\",\n\"melon\",\n\"pineapple\",\n\"apple\",\n\"pineapple\"\n)\n\nfun subtractSum(n: Int): String {\n    var n2 = n\n    \/\/ fruit name like \"apple\"\n    var s = \"\"\n    while(s == \"\"){\n        var A = n2\/1000\n        var B = (n2%1000)\/100\n        var C = (n2%100)\/10\n        var D = (n2%10)\/1\n        if(A > 0) n2 = n2 - A\n        if(B > 0) n2 = n2 - B\n        if(C > 0) n2 = n2 - C\n        if(D > 0) n2 = n2 - D\n        s = find(n2)\n    }\n    return s\n}\n\nfun find(i:Int):String{\n    if(i > map.size) return \"\"\n    return map[i-1]\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206850,"user_id":null,"body":"fun subtractSum(n: Int): String {\n    val fruit = arrayOf(\"kiwi\",\"pear\",\"banana\",\"melon\",\"pineapple\",\"apple\",\"cucumber\",\"orange\",\"grape\",\"cherry\")\n    val list = arrayOf(0,0,1,0,2,3,2,3,4,5,4,6,4,6,7,8,7,8,5,8,9,1,9,1,0,2,0,5,3,2,3,4,3,4,6,7,5,7,8,7,8,9,1,9,1,5,1,1,2,1,2,3,4,3,5,6,4,6,7,6,7,8,9,5,9,1,9,1,0,1,0,2,5,2,3,4,3,4,6,4,6,6,8,7,8,9,8,9,1,9,5,0,2,0,2,3,2,3,4,5,4)\n    var num = n\n    \n    if(num >= 10 && num < 10000) {\n        for(i in 0..num) {\n            var sum = num-(num.toString().toList().map{it.toString().toInt()}.sum())\n            num = sum\n            if(sum<=100) break\n        }\n    }\n    \n    return fruit[list[num]]\n} ","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206851,"user_id":null,"body":"fun subtractSum(n: Int): String {\n    return \"apple\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206852,"user_id":null,"body":"fun subtractSum(n: Int): String {\n    val sum = n.toString().map(Character::getNumericValue).toIntArray().sum()\n    return when (val sub = n - sum) {\n        1 -> \"kiwi\"\n        2 -> \"pear\"\n        3 -> \"kiwi\"\n        4 -> \"banana\"\n        5 -> \"melon\"\n        6 -> \"banana\"\n        7 -> \"melon\"\n        8 -> \"pineapple\"\n        9 -> \"apple\"\n        10 -> \"pineapple\"\n        11 -> \"cucumber\"\n        12 -> \"pineapple\"\n        13 -> \"cucumber\"\n        14 -> \"orange\"\n        15 -> \"grape\"\n        16 -> \"orange\"\n        17 -> \"grape\"\n        18 -> \"apple\"\n        19 -> \"grape\"\n        20 -> \"cherry\"\n        21 -> \"pear\"\n        22 -> \"cherry\"\n        23 -> \"pear\"\n        24 -> \"kiwi\"\n        25 -> \"banana\"\n        26 -> \"kiwi\"\n        27 -> \"apple\"\n        28 -> \"melon\"\n        29 -> \"banana\"\n        30 -> \"melon\"\n        31 -> \"pineapple\"\n        32 -> \"melon\"\n        33 -> \"pineapple\"\n        34 -> \"cucumber\"\n        35 -> \"orange\"\n        36 -> \"apple\"\n        37 -> \"orange\"\n        38 -> \"grape\"\n        39 -> \"orange\"\n        40 -> \"grape\"\n        41 -> \"cherry\"\n        42 -> \"pear\"\n        43 -> \"cherry\"\n        44 -> \"pear\"\n        45 -> \"apple\"\n        46 -> \"pear\"\n        47 -> \"kiwi\"\n        48 -> \"banana\"\n        49 -> \"kiwi\"\n        50 -> \"banana\"\n        51 -> \"melon\"\n        52 -> \"pineapple\"\n        53 -> \"melon\"\n        54 -> \"apple\"\n        55 -> \"cucumber\"\n        56 -> \"pineapple\"\n        57 -> \"cucumber\"\n        58 -> \"orange\"\n        59 -> \"cucumber\"\n        60 -> \"orange\"\n        61 -> \"grape\"\n        62 -> \"cherry\"\n        63 -> \"apple\"\n        64 -> \"cherry\"\n        65 -> \"pear\"\n        66 -> \"cherry\"\n        67 -> \"pear\"\n        68 -> \"kiwi\"\n        69 -> \"pear\"\n        70 -> \"kiwi\"\n        71 -> \"banana\"\n        72 -> \"apple\"\n        73 -> \"banana\"\n        74 -> \"melon\"\n        75 -> \"pineapple\"\n        76 -> \"melon\"\n        77 -> \"pineapple\"\n        78 -> \"cucumber\"\n        79 -> \"pineapple\"\n        80 -> \"cucumber\"\n        81 -> \"apple\"\n        82 -> \"grape\"\n        83 -> \"orange\"\n        84 -> \"grape\"\n        85 -> \"cherry\"\n        86 -> \"grape\"\n        87 -> \"cherry\"\n        88 -> \"pear\"\n        89 -> \"cherry\"\n        90 -> \"apple\"\n        91 -> \"kiwi\"\n        92 -> \"banana\"\n        93 -> \"kiwi\"\n        94 -> \"banana\"\n        95 -> \"melon\"\n        96 -> \"banana\"\n        97 -> \"melon\"\n        98 -> \"pineapple\"\n        99 -> \"apple\"\n        100 -> \"pineapple\"\n        else -> subtractSum(sub)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206853,"user_id":null,"body":"fun subtractSum(n: Int): String {\n    \/\/ fruit name like \"apple\"\n    var sumNewN = sumOf((n - sumOf(n)))\n    \n    var fruit = when(sumNewN){\n            1   -> \"kiwi\"\n            2   -> \"pear\"\n            3   -> \"kiwi\"\n            4   -> \"banana\"\n            5   -> \"melon\"\n            6   -> \"banana\"\n            7   -> \"melon\"\n            8   -> \"pineapple\"\n            9   -> \"apple\"\n            10  ->\"pineapple\"\n            11  ->\"cucumber\"\n            12  ->\"pineapple\"\n            13  ->\"cucumber\"\n            14  ->\"orange\"\n            15  ->\"grape\"\n            16  ->\"orange\"\n            17  ->\"grape\"\n            18  ->\"apple\"\n            19  ->\"grape\"\n            20  ->\"cherry\"\n            21  ->\"pear\"\n            22  ->\"cherry\"\n            23  ->\"pear\"\n            24  ->\"kiwi\"\n            25  ->\"banana\"\n            26  ->\"kiwi\"\n            27  ->\"apple\"\n            28  ->\"melon\"\n            29  ->\"banana\"\n            30  ->\"melon\"\n            31  ->\"pineapple\"\n            32  ->\"melon\"\n            33  ->\"pineapple\"\n            34  ->\"cucumber\"\n            35  ->\"orange\"\n            36  ->\"apple\"\n            37  ->\"orange\"\n            38  ->\"grape\"\n            39  ->\"orange\"\n            40  ->\"grape\"\n            41  ->\"cherry\"\n            42  ->\"pear\"\n            43  ->\"cherry\"\n            44  ->\"pear\"\n            45  ->\"apple\"\n            46  ->\"pear\"\n            47  ->\"kiwi\"\n            48  ->\"banana\"\n            49  ->\"kiwi\"\n            50  ->\"banana\"\n            51  ->\"melon\"\n            52  ->\"pineapple\"\n            53  ->\"melon\"\n            54  ->\"apple\"\n            55  ->\"cucumber\"\n            56  ->\"pineapple\"\n            57  ->\"cucumber\"\n            58  ->\"orange\"\n            59  ->\"cucumber\"\n            60  ->\"orange\"\n            61  ->\"grape\"\n            62  ->\"cherry\"\n            63  ->\"apple\"\n            64  ->\"cherry\"\n            65  ->\"pear\"\n            66  ->\"cherry\"\n            67  ->\"pear\"\n            68  ->\"kiwi\"\n            69  ->\"pear\"\n            70  ->\"kiwi\"\n            71  ->\"banana\"\n            72  ->\"apple\"\n            73  ->\"banana\"\n            74  ->\"melon\"\n            75  ->\"pineapple\"\n            76  ->\"melon\"\n            77  ->\"pineapple\"\n            78  ->\"cucumber\"\n            79  ->\"pineapple\"\n            80  ->\"cucumber\"\n            81  ->\"apple\"\n            82  ->\"grape\"\n            83  ->\"orange\"\n            84  ->\"grape\"\n            85  ->\"cherry\"\n            86  ->\"grape\"\n            87  ->\"cherry\"\n            88  ->\"pear\"\n            89  ->\"cherry\"\n            90  ->\"apple\"\n            91  ->\"kiwi\"\n            92  ->\"banana\"\n            93  ->\"kiwi\"\n            94  ->\"banana\"\n            95  ->\"melon\"\n            96  ->\"banana\"\n            97  ->\"melon\"\n            98  ->\"pineapple\"\n            99  ->\"apple\"\n            100 ->\"pineapple\"\n            else -> \"\"\n\n    }\n    return fruit\n}\n\nfun sumOf(n : Int): Int {\n    var sum = 0\n    var temp = n\n    do {\n        sum = sum + (temp % 10)\n        temp \/= 10\n    } while (temp    != 0)\n    return sum\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206854,"user_id":null,"body":"fun subtractSum(n: Int): String {\n    var m = n\n    do{\n        val sum = m.toString().map{it.digitToInt()}.sum()\n        m = m - sum\n    }while(m>100)\n    \n     return when(m){\n        1 -> \"kiwi\"\n        2 -> \"pear\"\n        3 -> \"kiwi\"\n        4 -> \"banana\"\n        5 -> \"melon\"\n        6 -> \"banana\"\n        7 -> \"melon\"\n        8 -> \"pineapple\"\n        9 -> \"apple\"\n        10 -> \"pineapple\"\n        11 -> \"cucumber\"\n        12 -> \"pineapple\"\n        13 -> \"cucumber\"\n        14 -> \"orange\"\n        15 -> \"grape\"\n        16 -> \"orange\"\n        17 -> \"grape\"\n        18 -> \"apple\"\n        19 -> \"grape\"\n        20 -> \"cherry\"\n        21 -> \"pear\"\n        22 -> \"cherry\"\n        23 -> \"pear\"\n        24 -> \"kiwi\"\n        25 -> \"banana\"\n        26 -> \"kiwi\"\n        27 -> \"apple\"\n        28 -> \"melon\"\n        29 -> \"banana\"\n        30 -> \"melon\"\n        31 -> \"pineapple\"\n        32 -> \"melon\"\n        33 -> \"pineapple\"\n        34 -> \"cucumber\"\n        35 -> \"orange\"\n        36 -> \"apple\"\n        37 -> \"orange\"\n        38 -> \"grape\"\n        39 -> \"orange\"\n        40 -> \"grape\"\n        41 -> \"cherry\"\n        42 -> \"pear\"\n        43 -> \"cherry\"\n        44 -> \"pear\"\n        45 -> \"apple\"\n        46 -> \"pear\"\n        47 -> \"kiwi\"\n        48 -> \"banana\"\n        49 -> \"kiwi\"\n        50 -> \"banana\"\n        51 -> \"melon\"\n        52 -> \"pineapple\"\n        53 -> \"melon\"\n        54 -> \"apple\"\n        55 -> \"cucumber\"\n        56 -> \"pineapple\"\n        57 -> \"cucumber\"\n        58 -> \"orange\"\n        59 -> \"cucumber\"\n        60 -> \"orange\"\n        61 -> \"grape\"\n        62 -> \"cherry\"\n        63 -> \"apple\"\n        64 -> \"cherry\"\n        65 -> \"pear\"\n        66 -> \"cherry\"\n        67 -> \"pear\"\n        68 -> \"kiwi\"\n        69 -> \"pear\"\n        70 -> \"kiwi\"\n        71 -> \"banana\"\n        72 -> \"apple\"\n        73 -> \"banana\"\n        74 -> \"melon\"\n        75 -> \"pineapple\"\n        76 -> \"melon\"\n        77 -> \"pineapple\"\n        78 -> \"cucumber\"\n        79 -> \"pineapple\"\n        80 -> \"cucumber\"\n        81 -> \"apple\"\n        82 -> \"grape\"\n        83 -> \"orange\"\n        84 -> \"grape\"\n        85 -> \"cherry\"\n        86 -> \"grape\"\n        87 -> \"cherry\"\n        88 -> \"pear\"\n        89 -> \"cherry\"\n        90 -> \"apple\"\n        91 -> \"kiwi\"\n        92 -> \"banana\"\n        93 -> \"kiwi\"\n        94 -> \"banana\"\n        95 -> \"melon\"\n        96 -> \"banana\"\n        97 -> \"melon\"\n        98 -> \"pineapple\"\n        99 -> \"apple\"\n        100 -> \"pineapple\"\n        else -> \"\"\n    }\n    \n\n}\n\n   ","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206855,"user_id":null,"body":"private val map = mapOf(\n    1 to \"kiwi\",\n    2 to \"pear\",\n    3 to \"kiwi\",\n    4 to \"banana\",\n    5 to \"melon\",\n    6 to \"banana\",\n    7 to \"melon\",\n    8 to \"pineapple\",\n    9 to \"apple\",\n    10 to \"pineapple\",\n    11 to \"cucumber\",\n    12 to \"pineapple\",\n    13 to \"cucumber\",\n    14 to \"orange\",\n    15 to \"grape\",\n    16 to \"orange\",\n    17 to \"grape\",\n    18 to \"apple\",\n    19 to \"grape\",\n    20 to \"cherry\",\n    21 to \"pear\",\n    22 to \"cherry\",\n    23 to \"pear\",\n    24 to \"kiwi\",\n    25 to \"banana\",\n    26 to \"kiwi\",\n    27 to \"apple\",\n    28 to \"melon\",\n    29 to \"banana\",\n    30 to \"melon\",\n    31 to \"pineapple\",\n    32 to \"melon\",\n    33 to \"pineapple\",\n    34 to \"cucumber\",\n    35 to \"orange\",\n    36 to \"apple\",\n    37 to \"orange\",\n    38 to \"grape\",\n    39 to \"orange\",\n    40 to \"grape\",\n    41 to \"cherry\",\n    42 to \"pear\",\n    43 to \"cherry\",\n    44 to \"pear\",\n    45 to \"apple\",\n    46 to \"pear\",\n    47 to \"kiwi\",\n    48 to \"banana\",\n    49 to \"kiwi\",\n    50 to \"banana\",\n    51 to \"melon\",\n    52 to \"pineapple\",\n    53 to \"melon\",\n    54 to \"apple\",\n    55 to \"cucumber\",\n    56 to \"pineapple\",\n    57 to \"cucumber\",\n    58 to \"orange\",\n    59 to \"cucumber\",\n    60 to \"orange\",\n    61 to \"grape\",\n    62 to \"cherry\",\n    63 to \"apple\",\n    64 to \"cherry\",\n    65 to \"pear\",\n    66 to \"cherry\",\n    67 to \"pear\",\n    68 to \"kiwi\",\n    69 to \"pear\",\n    70 to \"kiwi\",\n    71 to \"banana\",\n    72 to \"apple\",\n    73 to \"banana\",\n    74 to \"melon\",\n    75 to \"pineapple\",\n    76 to \"melon\",\n    77 to \"pineapple\",\n    78 to \"cucumber\",\n    79 to \"pineapple\",\n    80 to \"cucumber\",\n    81 to \"apple\",\n    82 to \"grape\",\n    83 to \"orange\",\n    84 to \"grape\",\n    85 to \"cherry\",\n    86 to \"grape\",\n    87 to \"cherry\",\n    88 to \"pear\",\n    89 to \"cherry\",\n    90 to \"apple\",\n    91 to \"kiwi\",\n    92 to \"banana\",\n    93 to \"kiwi\",\n    94 to \"banana\",\n    95 to \"melon\",\n    96 to \"banana\",\n    97 to \"melon\",\n    98 to \"pineapple\",\n    99 to \"apple\",\n    100 to \"pineapple\",\n)\n\nfun subtractSum(n: Int): String {\n    val subtracted = n - n.toString().sumOf { it.digitToInt() }\n    return if (map.containsKey(subtracted)) {\n        map[subtracted]!!\n    } else {\n        subtractSum(subtracted)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206856,"user_id":null,"body":"fun subtractSum(n: Int): String {\n    val list = listOf(\"kiwi\",\n        \"pear\",\n        \"kiwi\",\n        \"banana\",\n        \"melon\",\n        \"banana\",\n        \"melon\",\n        \"pineapple\",\n        \"apple\",\n        \"pineapple\",\n        \"cucumber\",\n        \"pineapple\",\n        \"cucumber\",\n        \"orange\",\n        \"grape\",\n        \"orange\",\n        \"grape\",\n        \"apple\",\n        \"grape\",\n        \"cherry\",\n        \"pear\",\n        \"cherry\",\n        \"pear\",\n        \"kiwi\",\n        \"banana\",\n        \"kiwi\",\n        \"apple\",\n        \"melon\",\n        \"banana\",\n        \"melon\",\n        \"pineapple\",\n        \"melon\",\n        \"pineapple\",\n        \"cucumber\",\n        \"orange\",\n        \"apple\",\n        \"orange\",\n        \"grape\",\n        \"orange\",\n        \"grape\",\n        \"cherry\",\n        \"pear\",\n        \"cherry\",\n        \"pear\",\n        \"apple\",\n        \"pear\",\n        \"kiwi\",\n        \"banana\",\n        \"kiwi\",\n        \"banana\",\n        \"melon\",\n        \"pineapple\",\n        \"melon\",\n        \"apple\",\n        \"cucumber\",\n        \"pineapple\",\n        \"cucumber\",\n        \"orange\",\n        \"cucumber\",\n        \"orange\",\n        \"grape\",\n        \"cherry\",\n        \"apple\",\n        \"cherry\",\n        \"pear\",\n        \"cherry\",\n        \"pear\",\n        \"kiwi\",\n        \"pear\",\n        \"kiwi\",\n        \"banana\",\n        \"apple\",\n        \"banana\",\n        \"melon\",\n        \"pineapple\",\n        \"melon\",\n        \"pineapple\",\n        \"cucumber\",\n        \"pineapple\",\n        \"cucumber\",\n        \"apple\",\n        \"grape\",\n        \"orange\",\n        \"grape\",\n        \"cherry\",\n        \"grape\",\n        \"cherry\",\n        \"pear\",\n        \"cherry\",\n        \"apple\",\n        \"kiwi\",\n        \"banana\",\n        \"kiwi\",\n        \"banana\",\n        \"melon\",\n        \"banana\",\n        \"melon\",\n        \"pineapple\",\n        \"apple\",\n        \"pineapple\")\n    var num = n\n    var sum = 0\n    while (num > 100) {\n        var str = num.toString()\n        str.forEach { sum += it.digitToInt() }\n        num -= sum\n    }\n    return \"apple\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"56cac350145912e68b0006f0":[{"id":206857,"user_id":null,"body":"package updown\n\nfun arrange(strng: String): String {\n    val p = strng.split(\" \").toTypedArray()\n    for (i in (0 until p.size - 1)) {\n        val switch = if (i % 2 == 0) p[i].length > p[i+1].length else p[i].length < p[i+1].length\n        if (switch) {\n            val tmp = p[i]\n            p[i] = p[i+1]\n            p[i+1] = tmp\n        }\n    }\n    return p.mapIndexed { i, v -> if (i % 2 == 1) v.toUpperCase() else v.toLowerCase() }.joinToString(\" \")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206858,"user_id":null,"body":"package updown\n\nfun String.mySplit() = split(\" \") as MutableList<String>\nfun <T> MutableList<T>.swap(a: Int, b: Int): Unit { this[a] = this[b].also { this[b] = this[a] } }\n\nfun arrange(s:String) =\n  s.mySplit().apply {\n    var up = false\n    val fixCase: (Int) -> Unit = { i -> this[i] = if(up) this[i].toUpperCase() else this[i].toLowerCase() }\n    val shouldSwap: (String, String) -> Boolean = { a, b -> if (up) a.length < b.length else b.length < a.length }\n    for(i in 0..lastIndex-1) {\n      val j = i+1\n      if(shouldSwap(this[i], this[j])) swap(i, j)\n      fixCase(i)\n      up = !up\n    }\n    fixCase(lastIndex)\n  }.joinToString(\" \")\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206859,"user_id":null,"body":"package updown\n\nfun arrange(strng: String): String {\n    val shouldSwap = listOf(1, -1)\n    val words = strng.split(\" \").toMutableList()\n    for (i in 0..words.size - 2) {\n        val word = words[i]\n        if (word.length.compareTo(words[i + 1].length) == shouldSwap[i % 2]) {\n            words[i] = words[i + 1]\n            words[i + 1] = word\n        }\n    }\n    words.forEachIndexed { i, word -> words[i] = if (i % 2 == 0) word.toLowerCase() else word.toUpperCase() }\n    return words.joinToString(\" \")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206860,"user_id":932,"body":"package updown\n\nfun arrange(s: String)=s.split(\" \").toMutableList().apply {\n    this.drop(1).indices.forEach {\n        if (it % 2==0 && this[it].length> this[it+1].length || it % 2==1 && this[it].length<this[it+1].length){\n            val temp = this[it]\n            this[it] = this[it+1]\n            this[it+1]=temp\n        }\n    }\n}.mapIndexed { index, s -> if (index%2==0) s.toLowerCase() else s.toUpperCase()}\n    .joinToString(\" \")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206861,"user_id":null,"body":"package updown\n\nfun arrange(strng: String): String {\n    val words = strng.split(\" \")\n    val result = arrange(words.first(), emptyList(), words.drop(1), true)\n    return result.joinToString(\" \")\n}\n\ntailrec fun arrange(nextWord: String, acc: List<String>, rest: List<String>, moveIfGreater: Boolean): List<String> {\n    fun String.arrangeCase() = if (moveIfGreater) this.toLowerCase() else this.toUpperCase()\n    fun shouldSwap() = (moveIfGreater && nextWord.length > rest.first().length)\n            || (!moveIfGreater && nextWord.length < rest.first().length)\n    return when {\n        rest.isEmpty() -> acc + nextWord.arrangeCase()\n        shouldSwap() -> arrange(nextWord, acc + rest.first().arrangeCase(), rest.drop(1), !moveIfGreater)\n        else -> arrange(rest.first(), acc + nextWord.arrangeCase(), rest.drop(1), !moveIfGreater)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206862,"user_id":null,"body":"package updown\n\nfun arrange(strng:String):String {\n    return strng.splitter(\" \").swap().joinToString(\" \")\n}\n\nval splitter: String.(String) -> MutableList<String> = { delimiter -> split(delimiter).toMutableList() }\n\nfun <T> MutableList<T>.swapper(i: Int, j: Int): MutableList<T> {\n    val temp = this[i]\n    this[i] = this[j]\n    this[j] = temp\n    return this\n}\n\nfun MutableList<String>.swap(): List<String> {\n    var swapped: Boolean\n    var switcher = false\n    var index = size - 1\n    while (index >= 1) {\n        loop@ for (i in size - (index) until size) {\n            swapped = false\n            if (when {\n                    switcher -> this[i].length > this[i - 1].length\n                    else -> this[i].length < this[i - 1].length\n                }\n            ) {\n                swapper(i = i, j = i - 1)\n                swapped = true\n            }\n            switcher = !switcher\n            index--\n            if (swapped) break@loop\n        }\n    }\n\n    return mapIndexed { i, string -> if ((i + 1) % 2 == 0) string.uppercase() else string.lowercase() }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206863,"user_id":null,"body":"package updown\n\nfun arrange(strng:String):String = strng.split(\" \").toMutableList().apply {\n    for (i in this.indices){\n        \/\/ if current pos is odd, check if >=\n        if (i % 2 != 0){\n            if (i+1 < this.size && this[i].length < this[i+1].length){\n                val temp = this[i]\n                this[i] = this[i+1]\n                this[i+1] = temp\n            }\n            this[i] = this[i].uppercase()\n        }else{\/\/ current pos is even, check if <=\n            if (i+1 < this.size && this[i].length > this[i+1].length){\n                val temp = this[i]\n                this[i] = this[i+1]\n                this[i+1] = temp\n            }\n            this[i] = this[i].lowercase()\n        }\n    }\n}.joinToString(\" \")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206864,"user_id":null,"body":"package updown\n\nfun arrange(strng: String): String = strng.split(' ').toMutableList().let { words ->\n\n    for (i in 0 until words.lastIndex)\n        if (words[i + i % 2].length > words[i + 1 - i % 2].length)\n            words[i + i % 2] = words[i + 1 - i % 2]\n                .also { words[i + 1 - i % 2] = words[i + i % 2] }\n\n    words.mapIndexed { i, s -> if (i % 2 == 0) s.lowercase() else s.uppercase() }.joinToString(\" \")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206865,"user_id":null,"body":"package updown\n\nfun arrange(strng: String): String {\n    val words = strng.split(' ').toMutableList()\n\n    for (i in 0 until words.lastIndex)\n        if (words[i + i % 2].length > words[i + 1 - i % 2].length)\n            words[i + i % 2] = words[i + 1 - i % 2]\n                .also { words[i + 1 - i % 2] = words[i + i % 2] }\n\n    return words.mapIndexed { i, s -> if (i % 2 == 0) s.lowercase() else s.uppercase() }.joinToString(\" \")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206866,"user_id":null,"body":"package updown\n\nfun arrange(strng: String): String {\n\n    var x = strng.split(\" \")\n\n    for (i in 1..x.lastIndex) {\n        if (i % 2 == 0) {\n            if (x[i - 1].length < x[i].length) {\n                x = changeOrder(x, i)\n            }\n        } else {\n            if (x[i - 1].length > x[i].length) {\n                x = changeOrder(x, i)\n            }\n        }\n    }\n    return x.mapIndexed { i, s -> if(i % 2 == 1) s.uppercase() else s.lowercase() }.joinToString(\" \")\n}\n\nprivate fun changeOrder(l: List<String>, i: Int) = l.take(i - 1) + l[i] + l[i - 1] + l.takeLast(l.lastIndex - i)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"56dbe0e313c2f63be4000b25":[{"id":206867,"user_id":null,"body":"package solution\n\nobject Opstrings {\n\n    fun vertMirror(strng: String) = strng.split(\"\n\").map { it.reversed() }.joinToString(\"\n\")\n        \n    fun horMirror(strng: String) = strng.split(\"\n\").reversed().joinToString(\"\n\")\n    \n    fun oper(f: (String) -> String , s: String): String = f(s)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206868,"user_id":null,"body":"package solution\n\nobject Opstrings {\n\n    fun vertMirror(list: List<String>): List<String> = list.map { it.reversed() }\n    \n    fun horMirror(list: List<String>): List<String> = list.reversed()\n    \n    fun oper(op: (List<String>) -> List<String>, s: String): String = op(s.lines()).joinToString(\"\n\")  \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206869,"user_id":null,"body":"package solution\n\nobject Opstrings {\n    fun vertMirror(s: String) = s.split(\"\n\").joinToString(\"\n\") { it.reversed() }\n    fun horMirror(s: String) = s.split(\"\n\").reversed().joinToString(\"\n\")\n    fun oper(f: (String) -> String, s: String) = f(s)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206870,"user_id":null,"body":"package solution\n\nobject Opstrings {\n\n    fun vertMirror(string: String): String =\n        string.lines().map { it.reversed() }.joinToString(\"\n\")\n\n    fun horMirror(string: String): String =\n        string.lines().reversed().joinToString(\"\n\")\n    \n    fun oper(f: (String) -> String, s: String) = f(s)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206871,"user_id":null,"body":"package solution\n\nimport kotlin.collections.*\n\nobject Opstrings {\n\n    fun horMirror(strng: String): String {\n        return strng.split(\"\n\").asReversed().joinToString(separator = \"\n\")\n    }\n    fun vertMirror(strng: String): String {\n        return strng.split(\"\n\")\n                .joinToString(\n                        separator = \"\n\",\n                        transform = {item -> item.reversed()}\n                );\n    }\n    \n    fun oper(f: (strng:String) -> String, s: String): String {\n        return f(s);\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206872,"user_id":null,"body":"package solution\n\nobject Opstrings {\n    fun vertMirror(strng: String) = strng.split('\n')\n        .joinToString(\"\n\") { it.reversed() }\n\n    fun horMirror(strng: String) = strng.split('\n')\n        .reversed()\n        .joinToString(\"\n\")\n\n    fun oper(fct: (String) -> String, s: String) = fct(s)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206873,"user_id":null,"body":"package solution\n\nobject Opstrings {\n    fun vertMirror(strng: String): String = strng.split(\"\n\").map { it.reversed() }.joinToString(\"\n\")\n    fun horMirror(strng: String): String = strng.split(\"\n\").reversed().joinToString(\"\n\")\n    fun oper(function: (String) -> (String), s: String): String = function(s)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206874,"user_id":null,"body":"package solution\n\nobject Opstrings {\n\n    fun vertMirror(strng: String): String = strng.split('\n')\n        .joinToString(\"\n\") { it.reversed() }\n\n    fun horMirror(strng: String): String = strng.split('\n').reversed()\n        .joinToString(\"\n\")\n\n    fun oper(f: (String) -> String, s: String): String = f(s)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206875,"user_id":null,"body":"package solution\n\nobject Opstrings {\n    \n    fun vertMirror(strng: String) = strng.lines().joinToString(\"\n\") { it.reversed() }\n\n    fun horMirror(strng: String) = strng.lines().reversed().joinToString(\"\n\")\n\n    fun oper(fct: (String) -> String , s: String) = fct(s)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206876,"user_id":null,"body":"package solution\n\nobject Opstrings {\n\n    fun vertMirror(strng: String): String {\n        \/\/ your code\n        var array = strng.split(\"\n\").toMutableList()\n\n        for (i in array.indices) {\n            array[i] = array[i].reversed()\n        }\n\n        return array.joinToString(separator = \"\n\")\n    }\n\n    fun horMirror(strng: String): String {\n        var listS: List<String> = strng.split(\"\n\")\n        var reversedList = listS.reversed()\n\n        return reversedList.joinToString(separator = \"\n\")\n    }\n\n    fun oper(operation: (String) -> String, s: String): String {\n        \/\/ your code and complete ... with a function to apply to s\n        return operation(s)\n\n    }\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"56dbe7f113c2f63570000b86":[{"id":206877,"user_id":null,"body":"package solution\n\nobject Opstrings {\n\n    fun rot(strng: String) = strng.reversed()\n\n    fun selfieAndRot(strng: String) = strng.split(\"\n\")\n            .joinToString(\"\n\") { it + \".\".repeat(it.length) }.let { it + \"\n\" + rot(it) }\n\n    fun oper(f: (String) -> String, s: String) = f(s)\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206878,"user_id":null,"body":"package solution\n\nobject Opstrings {\n\n    fun rot(str: String): String {\n        return rot(str, \"\n\")\n    }\n\n    fun rot(str: String, sep:String): String {\n        return str.split(\"\n\").map { StringBuilder(it).reverse() }.reversed().joinToString(sep)\n    }\n\n    fun selfieAndRot(str: String): String {\n        val len = str.split(\"\n\")[0].length\n        val sep = \".\".repeat(len)\n        val s = str.replace(\"\n\", \"$sep\n\")\n\n        return \"$s$sep\n$sep${rot(str, \"\n$sep\")}\"\n    }\n    \n    fun oper(apply: (input: String) -> String, s: String): String {\n        return apply(s)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206879,"user_id":932,"body":"package solution\n\nobject Opstrings {\n    fun rot(strng: String)=strng.reversed()\n    fun selfieAndRot(strng: String)=strng.lines().joinToString(\"\n\"){it+\".\".repeat(it.length)}.let{it+\"\n\"+rot(it)}\n    fun oper(f:(str: String)->String, s: String)=f(s)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206880,"user_id":null,"body":"package solution\n\nobject Opstrings {\n\n    fun rot(strng: String): String {\n        return strng.reversed()\n    }\n    \n    fun selfieAndRot(strng: String): String {\n        var width = strng.split(\"\n\")[0].length\n        var result: String = \"\"\n        strng.split(\"\n\").forEach{\n            result += it\n            repeat (width) {\n                result += \".\"\n            }\n            result += \"\n\"\n        }\n        strng.reversed().split(\"\n\").forEach {\n            repeat (width) {\n                result += \".\"\n            }\n            result += it + \"\n\"\n        }   \n        return result.dropLast(1)\n    }\n    \n    fun oper(myfunc: (String) -> String , s: String): String {\n        return myfunc(s)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206881,"user_id":null,"body":"package solution\n\nobject Opstrings {\n    fun rot(strng: String) = strng.split(\"\n\").reversed().joinToString(\"\n\") { it.reversed() }\n    fun selfieAndRot(strng: String) = strng.split(\"\n\").joinToString(\"\"){\"$it${\".\".repeat(it.length)}\n\"} + strng.split(\"\n\").reversed().joinToString(\"\n\") { \"${\".\".repeat(it.length)}${it.reversed()}\" }\n    fun oper(fct: (String) -> String , s: String) = fct(s)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206882,"user_id":null,"body":"package solution\n\nobject Opstrings {\n\n    fun rot(strng: String): String = strng.reversed()\n\n    fun selfieAndRot(strng: String): String {\n        val s = strng.split('\n').map { it + \".\".repeat(it.length) }\n        val t = s.joinToString(\"\n\")\n        val u = s.reversed().joinToString(\"\n\") { it.reversed() }\n\n        return \"$t\n$u\"\n    }\n\n    fun oper(f: (String) -> String, s: String): String = f(s)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206883,"user_id":null,"body":"package solution\n\nobject Opstrings {\n    fun rot(strng: String): String = strng.reversed()\n\n    fun selfieAndRot(strng: String): String =\n        strng.split(\"\n\").joinToString(separator = dots(strng) + \"\n\", postfix = dots(strng)) +\n                rot(strng).split(\"\n\").joinToString(prefix = \"\n\" + dots(strng), separator = \"\n\" + dots(strng))\n\n    private fun dots(strng: String) = \".\".repeat(strng.substringBefore(\"\n\").length)\n\n    fun oper(f: (String) -> String , s: String): String = f(s)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206884,"user_id":null,"body":"package solution\n\nobject Opstrings {\n\n    fun rot(strng: String): String {\n        return strng.split(\"\n\").map { it.reversed() }.reversed().joinToString(\"\n\")\n    }\n    fun selfieAndRot(strng: String): String {\n        val self = strng.split(\"\n\").map { str -> \"$str${\".\".repeat(str.length)}\" }.joinToString(\"\n\")\n        val rotate = rot(strng).split(\"\n\").map {str -> \"${\".\".repeat(str.length)}$str\"}.joinToString(\"\n\")\n        return \"$self\n$rotate\"\n    }\n    fun oper(func: (String) -> String, string: String): String {\n        return func(string)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206885,"user_id":null,"body":"package solution\n\nimport solution.Opstrings.rot\n\nobject Opstrings {\n    fun rot(strng: String): String = strng.reversed()\n\n    fun selfieAndRot(strng: String): String {\n        var y = strng.split(\"\n\")\n        var c = \"\"\n        for(i in 0..y[0].length-1) c += \".\"\n        var x = strng.replace(\"\n\", \"$c\n\").toMutableList()\n        for(i in 0..y[0].length-1) x.add('.')\n        return \"${x.toCharArray().joinToString(separator = \"\"){it.toString()}}\n${x.toCharArray().joinToString(separator = \"\"){it.toString()}.reversed()}\"\n    }\n    fun oper(oper: (strng: String) -> String, s: String): String {\n        var x = oper(s)\n        return x\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206886,"user_id":null,"body":"package solution\n\nobject Opstrings {\n\n    fun vertMirror(strng: String): String {\n        return strng.split('\n').joinToString(\"\n\") { it.reversed() }\n    }\n    fun horMirror(strng: String): String {\n        return strng.split('\n').reversed().joinToString ( \"\n\" )\n    }\n    fun oper(fct:(strng: String)->String , s: String): String = fct(s)\n    fun rot(strng: String): String = vertMirror(horMirror(strng))\n    fun selfieAndRot(strng: String): String {\n        val temp1=strng.split('\n').map{it->it+\".\".repeat(it.length)}\n        val temp2=rot(strng).split('\n').map{it->\".\".repeat(it.length)+it}\n        return temp1.joinToString(\"\n\")+\"\n\"+temp2.joinToString(\"\n\")\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"56dec885c54a926dcd001095":[{"id":206887,"user_id":null,"body":"fun opposite(number: Int): Int = -number","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206888,"user_id":null,"body":"fun opposite(number: Int) = -number","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206889,"user_id":null,"body":"val opposite = {number: Int -> number.unaryMinus()}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206890,"user_id":null,"body":"fun opposite(number: Int): Int = -1 * number","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206891,"user_id":null,"body":"fun opposite(number: Int): Int {\n  return -number\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206892,"user_id":527,"body":"val opposite = Int::unaryMinus\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206893,"user_id":null,"body":"\/\/ given a number, return its opposite\n\/\/ e.g. opposite(5) should return -5\n\/\/ opposite(-1) should return 1\n\/\/ opposite(0) should return 0\n\/\/ etc.\n\n\n\/\/ long version of the function\n\/\/ return type and `return` keyword are required when using braces {}\n\/\/ fun opposite(number: Int): Int {\n\/\/     return -number\n\/\/ }\n\n\/\/ shorter version of the same function\n\/\/ no braces\n\/\/ no `return` keyword required, instead use the `=`\n\/\/ fun opposite(number: Int): Int = -number\n\n\/\/ even shorter version of the same function\n\/\/ no `return` keyword\n\/\/ return type is optional for these kind of functions\nfun opposite(number: Int) = -number","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206894,"user_id":null,"body":"fun opposite(n: Int): Int {\n  return -n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206895,"user_id":null,"body":"fun opposite(number: Int) = number * -1","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206896,"user_id":null,"body":"import kotlin.math.abs\n\n\nfun opposite(number: Int): Int {\n    var a = number\n    var b = 0\n    if (a > 0) {\n        a *= -1\n        return a\n    } else {\n        b = abs(a)\n        return b\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"56e3cd1d93c3d940e50006a4":[{"id":206897,"user_id":null,"body":"package valley\n\nimport java.util.Arrays\n\nfun makeValley(arr: IntArray) = arr.sortedDescending().chunked(2)\n    .let { it.map { it[0] } + it.mapNotNull { it.getOrNull(1) }.reversed() }.toIntArray()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206898,"user_id":null,"body":"package valley\n\nfun makeValley(arr: IntArray) = arr.sortedDescending().withIndex().partition { it.index % 2 == 0 }.let {\n    it.first.map { it.value } + it.second.map { it.value }.reversed()\n}.toIntArray()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206899,"user_id":null,"body":"package valley\n\nimport java.util.Arrays\n\nfun makeValley(arr:IntArray):IntArray {\n    var L = mutableListOf<Int>()\n    var R = mutableListOf<Int>()\n    var side = false\n    arr.sortedDescending().forEach {\n        if (side) R.add(it) else L.add(it)\n        side = !side\n    }\n    val valley = L + R.reversed()\n    return valley.toIntArray()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206900,"user_id":null,"body":"package valley\n\nfun makeValley(arr:IntArray):IntArray {\n    val sorted = arr.sorted()\n    val N = sorted.size\n    return IntArray( N ) { sorted[ if(N > 2*it) N-1-2*it else 2*it-N ] }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206901,"user_id":492,"body":"package valley\n\nimport java.util.Arrays\n\nfun makeValley(arr:IntArray):IntArray {\n    Arrays.sort(arr)\n    var ans = IntArray(arr.size)\n    for (i in arr.indices)\n    {\n      if (i % 2 == 0)\n      ans[i \/ 2] = arr[arr.size - 1 - i]\n      else\n      ans[arr.size - 1 - i \/ 2] = arr[arr.size - 1 - i]\n    }\n    return ans\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206902,"user_id":null,"body":"package valley\n\nimport java.util.Arrays\n\nfun makeValley(arr:IntArray) = with (arr.sortedDescending().withIndex().partition { it.index % 2 == 0 } ) { first.plus(second.reversed()).map { it.value }.toIntArray() }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206903,"user_id":null,"body":"package valley\n\nfun makeValley(arr:IntArray) = when (arr.size) {\n  1 -> arr\n  else -> arr.sortedArrayDescending().withIndex().groupBy { it.index % 2 }.map { it.value.map { it.value } }.windowed(2) { it[0] + it[1].sorted() }.flatten().toIntArray()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206904,"user_id":null,"body":"package valley\n\nimport java.util.Arrays\n\nfun makeValley(arr: IntArray): IntArray {\n    tailrec fun helper(arr: IntArray, res: IntArray, index: Int): IntArray {\n        if (arr.isEmpty()) return res\n        if (arr.size == 1) {\n            res[index] = arr[0]\n            return res\n        }\n        res[index] = arr[0]\n        res[res.size - index - 1] = arr[1]\n        return helper(arr.copyOfRange(2, arr.size), res, index + 1)\n    }\n\n    return helper(arr.sortedArrayDescending(), IntArray(arr.size), 0)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206905,"user_id":492,"body":"package valley\n\nimport java.util.Arrays\n\nfun makeValley(arr:IntArray):IntArray {\n    Arrays.sort(arr)\n    var ans = IntArray(arr.size)\n    for (i in arr.indices)\n    {\n      if (i % 2 == 0)\n      ans[i \/ 2] = arr[arr.size - 1 - i]\n      else\n      ans[arr.size - 1 - i \/ 2] = arr[arr.size - 1 - i]\n    }\n    return ans\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206906,"user_id":null,"body":"package valley\n\nimport java.util.Arrays\n\nfun makeValley(arr:IntArray):IntArray {\n    \/\/var sorted = emptyArray<Int>()\n    var left = emptyArray<Int>()\/\/decreasing\n    var right = emptyArray<Int>()\/\/increasing\n    var result = emptyArray<Int>()\/\/concat la final\n    \n    arr.sortDescending()\n    \n    \/\/a = [79, 35, 54, *19*, 35, 25]\n    \/\/     0    1   2   3  4   5\n\n    \n    for(i in arr.indices) {\n        if(i % 2 == 0) {\n            left += arr[i]\n        } else {\n            right += arr[i]\n        }\n    }\n    \n    left.sortDescending()\n    right.sort()\n    result = left + right\n    return result.toIntArray()\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"56e7d40129035aed6c000632":[{"id":206907,"user_id":null,"body":"package easyline\nimport java.math.BigInteger;\n\nfun easyLine(n: Int): BigInteger = (0..n).mapIndexed { index, i ->\n    factorial(n) \/ (factorial(index) * factorial(n - index))\n}.sumOf { it * it }\n\n\nfun factorial(n: Int): BigInteger {\n    var result = 1.toBigInteger()\n    for (i in 1..n) {\n        result *= i.toBigInteger()\n    }\n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206908,"user_id":null,"body":"package easyline\nimport java.math.BigInteger\nimport kotlin.math.pow\n\n\nfun easyLine(n:Int): BigInteger {\n    var sum = BigInteger (\"0\")\n\n    for (m in 0..n + 1){\n        sum += (factorial(n)\/ (factorial(m) * factorial(n - m))).pow(2)\n    }\n    return sum\n}\nfun factorial(n: Int): BigInteger = if (n <= 1) BigInteger(\"1\") else n.toBigInteger().times( factorial(n - 1))","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206909,"user_id":null,"body":"package easyline\nimport java.math.BigInteger;\n\nfun easyLine(n:Int): BigInteger {\n    val row = MutableList(2){BigInteger(\"1\")}\n    val row2 = MutableList(2){BigInteger(\"1\")}\n    for(i in 1 until n){\n        row2.add(1,BigInteger(\"0\"))\n        for(j in 1..i){\n            row2[j] = row[j-1]+row[j]\n        }\n        row.clear().let { row.addAll(row2) }\n    }\n    return row.map { it.pow(2) }.fold(BigInteger(\"0\")){acc, bi -> acc.plus(bi)}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206910,"user_id":null,"body":"package easyline\nimport java.math.BigInteger;\n\nfun easyLine(row: Int) = (0..row.toLong())\n    .map { calculate(row.toLong(), it).pow(2) }\n    .fold(BigInteger.ZERO, BigInteger::add)\n\nfun calculate(n: Long, k: Long) = factorial(n) \/ (factorial(k) * factorial(n - k))\n\ntailrec fun factorial(n: Long, acc: BigInteger = BigInteger.ONE): BigInteger =\n    when (n) {\n        0L, 1L -> acc\n        else -> factorial(n - 1, acc * BigInteger.valueOf(n))\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206911,"user_id":492,"body":"package easyline\nimport java.math.BigInteger;\n\nprivate fun choose(n:Int, p:Int):BigInteger {\n    var ret = BigInteger.ONE\n    for (i in 0 until p)\n    {\n      ret = ret.multiply(BigInteger.valueOf((n - i).toLong()))\n      .divide(BigInteger.valueOf((i + 1).toLong()))\n    }\n    return ret\n}\nfun easyLine(n:Int):BigInteger {\n    return choose(2 * n, n)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206912,"user_id":null,"body":"package easyline\nimport java.math.BigInteger;\n\nimport kotlin.math.*\nimport java.util.Arrays\nfun easyLine(n:Int):BigInteger {\n    val triangle = mutableListOf<MutableList<BigInteger>>(mutableListOf(BigInteger(\"1\")), mutableListOf(BigInteger(\"1\"),BigInteger(\"1\")))\n    for (i in 2..n) {\n        \/\/ \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043d\u043e\u0432\u044b\u0439 \u0440\u044f\u0434, \u0441\u043e\u0441\u0442\u043e\u044f\u0449\u0438\u0439 \u0438\u0437 \u0435\u0434\u0438\u043d\u0438\u0446\n        triangle.add(MutableList(i+1) { BigInteger(\"1\") })\n        \/\/ \u0437\u0430\u043f\u043e\u043b\u043d\u044f\u0435\u043c \u0446\u0435\u043d\u0442\u0440\u0430\u043b\u044c\u043d\u044b\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u0440\u044f\u0434\u0430\n        for (j in 1 until i ) {\n            triangle[i][j]= triangle[i-1][j-1] + triangle[i-1][j]\n        }\n    }\n    return triangle.last().sumOf { it*it }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206913,"user_id":null,"body":"package easyline\nimport java.math.BigInteger;\n\nfun easyLine(n: Int): BigInteger {\n    fun BigInteger.toIterable() = object : Iterable<BigInteger> {\n        override fun iterator() = object : Iterator<BigInteger> {\n            private var current = BigInteger.valueOf(1)\n            override fun hasNext(): Boolean = current <= this@toIterable\n            override fun next(): BigInteger = current++\n        }\n    }\n    fun fact(i: Int) = BigInteger.valueOf(i.toLong()).toIterable().reduce(BigInteger::multiply)\n    return fact(n * 2) \/ (fact(n) * fact(n))\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206914,"user_id":null,"body":"package easyline\nimport java.math.BigInteger;\n\nfun easyLine(n:Int):BigInteger {\n    if (n==0) return BigInteger.ONE\n    return generateSequence(listOf(BigInteger.ONE,BigInteger.ONE)){\n            listOf(BigInteger.ONE)+it.windowed(2).map{it.reduce{a,b->a+b}}+listOf(BigInteger.ONE)\n        }.take(n).last()\n        .map{it*it}\n        .reduce{a,b->a+b}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206915,"user_id":null,"body":"package easyline\nimport java.math.BigInteger;\n\nval factorials = ArrayList<BigInteger>().apply{ add(BigInteger.ZERO); add(BigInteger.ONE)}\n\nfun fac(n: Int) : BigInteger {\n    while(n >= factorials.size) {\n        factorials.add(factorials.last() * factorials.size.toBigInteger())\n    }\n    return factorials[n]\n}\n \nfun binomial(n: Int, k: Int) = when {\n    n == k || k == 0 -> BigInteger.ONE\n    else -> {\n        var ans = BigInteger.ONE\n        for (i in n - k + 1..n) ans *= i.toBigInteger()\n        ans \/ fac(k)\n    }\n}\n\nfun easyLine(n:Int) = (0..n).map { binomial(n, it) }.map { it * it }.reduce(BigInteger::plus)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206916,"user_id":492,"body":"package easyline\nimport java.math.BigInteger;\n\nprivate fun choose(n:Int, p:Int):BigInteger {\n    var ret = BigInteger.ONE\n    for (i in 0 until p)\n    {\n      ret = ret.multiply(BigInteger.valueOf((n - i).toLong()))\n      .divide(BigInteger.valueOf((i + 1).toLong()))\n    }\n    return ret\n}\nfun easyLine(n:Int):BigInteger {\n    return choose(2 * n, n)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"56efab15740d301ab40002ee":[{"id":206917,"user_id":null,"body":"package operarray\n\nimport java.util.function.LongBinaryOperator\n\nfun gcdi(a:Long, b:Long) : Long = if(b.abs() == 0L) a.abs() else gcdi(b.abs(), a.abs() % b.abs())\nfun lcmu(a:Long, b:Long) = (a*b).abs()\/gcdi(a,b)\nfun som(a:Long, b:Long) = a + b\nfun maxi(a:Long, b:Long) = maxOf(a, b)\nfun mini(a:Long, b:Long) = minOf(a ,b)\n\nfun operArray(f : LongBinaryOperator, arr:LongArray, base:Long) : LongArray{\n  var acc = base\n  return LongArray(arr.size, { i -> \n    acc = f.applyAsLong(acc, arr[i])\n    acc\n  })\n}\n\nfun Long.abs() = if (this < 0) this*-1 else this\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206918,"user_id":null,"body":"package operarray\n\nimport java.util.function.LongBinaryOperator\n\ntailrec fun gcdi(xx: Long, yy: Long): Long = if (yy == 0L) { if (xx < 0) -xx else xx } else gcdi(yy, xx % yy)\n\nfun lcmu(a: Long, b: Long) = (a * b \/ gcdi(a, b)).let { if (it < 0) -it else it }\n\nfun som(a: Long, b: Long) = a + b\n\nfun maxi(a: Long, b: Long) = if (a > b) a else b\n\nfun mini(a: Long, b: Long) = if (a < b) a else b\n\nfun operArray(f: LongBinaryOperator, arr: LongArray, init: Long) = LongArray(arr.size).apply { \n    arr.foldIndexed(init) { i, a, b -> f.applyAsLong(a, b).also { set(i, it) } }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206919,"user_id":null,"body":"package operarray\n\nimport java.util.function.LongBinaryOperator\nimport kotlin.math.abs\nimport kotlin.math.max\nimport kotlin.math.min\n\nfun gcdi(a:Long, b:Long):Long {\n    if (b == 0L) return abs(a)\n    return abs(gcdi(b, a % b))\n}\nfun lcmu(a:Long, b:Long):Long {\n    return abs(a \/ gcdi(a, b) * b)\n}\nfun som(a:Long, b:Long) = a + b\n\nval maxi: (Long, Long) -> Long = ::max\n\nval mini: (Long, Long) -> Long = ::min\n\nfun operArray(operation: LongBinaryOperator, arr:LongArray, init:Long):LongArray =\n    arr.fold(arrayListOf<Long>()) { acc, l ->\n        acc.add(operation.applyAsLong(if (acc.isEmpty()) init else acc.last(), l))\n        acc\n    }.toLongArray()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206920,"user_id":null,"body":"package operarray\n\nimport kotlin.math.*;\nimport java.util.function.LongBinaryOperator;\n\nfun lcm(a: Long, b: Long): Long {\n    var aa = a\n    var bb = b\n    \n    while (aa != bb) {\n        if (aa < bb) {\n            aa += a\n        } else {\n            bb += b\n        }\n    }\n    \n    return aa\n}\n\nfun lcmu(a: Long, b: Long): Long = lcm(abs(a), abs(b))\n\nfun gcd(a: Long, b: Long): Long {\n    var aa = a\n    var bb = b\n    \n    while(aa != bb) {\n        if (aa < bb) {\n            bb -= aa\n        } else {\n            aa -= bb\n        }\n    }\n    \n    return aa\n}\n\nfun gcdi(a: Long, b: Long): Long = gcd(abs(a), abs(b))\n\nfun som(a: Long, b: Long): Long = a + b\n\nfun maxi(a: Long, b: Long): Long = max(a, b)\n\nfun mini(a: Long, b: Long): Long = min(a, b)\n\nfun operArray(operator: LongBinaryOperator, arr: LongArray, init: Long): LongArray {\n    val result = LongArray(arr.size)\n    \n    result[0] = operator.applyAsLong(init, arr[0])\n    for (i in 1 until arr.size) {\n        result[i] = operator.applyAsLong(result[i - 1], arr[i])\n    }\n    \n    return result\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206921,"user_id":null,"body":"package operarray\nimport java.lang.StrictMath.abs\nimport java.util.function.LongBinaryOperator\nimport java.lang.Long.min\nimport java.lang.Long.max\n\n\nfun gcdi(xx:Long, yy:Long):Long {\n    return (abs(xx) downTo 1).first { abs(xx) % it == 0L &&  abs(yy) % it == 0L }\n}\nfun lcmu(a:Long, b:Long):Long {\n    return abs(a * b) \/ gcdi(a, b)\n}\nfun som(a:Long, b:Long):Long = a + b\n\nfun maxi(a:Long, b:Long):Long = max(a, b)\n\nfun mini(a:Long, b:Long):Long = min(a, b)\n\nfun operArray(fnc: LongBinaryOperator, arr: LongArray, init: Long): LongArray {\n    return arr.scan(init) { acc, item -> fnc.applyAsLong(acc, item) }.drop(1).toLongArray()\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206922,"user_id":null,"body":"package operarray\nimport java.util.function.LongBinaryOperator\n\nfun gcdi(xx: Long, yy: Long): Long {\n    if (yy == 0L) { \n        if (xx < 0) return -xx \n            else return xx \n        } else {\n            return gcdi(yy, xx % yy)\n        }\n    }\n\n\/\/These two work but timeout.\n\/\/ fun gcdi(x:Long, y:Long):Long {\n\/\/   for(i in maxi(x,y) downTo 1){\n\/\/       if(x % i == 0L && y % i == 0L) return i\n\/\/   }\n\/\/   return 0L\n\/\/ }\n\n\/\/ fun lcmu(a:Long, b:Long):Long {\n\/\/     println(\"LCMU START\")\n\/\/     for(i in maxi(a,b)..Long.MAX_VALUE){\n\/\/         println(\"a = $a, b = $b, i = $i ....... ${a % i}, ${b % i}\")\n\/\/         \/\/if(a % i == 0L && b % i == 0L) return i\n\/\/         if(i % a == 0L && i % b == 0L) return i\n\/\/     }\n\/\/     return 0L\n\/\/     return  a * b \/ gcd(a,b)\n\/\/ }\n\nfun lcmu(a: Long, b: Long) = (a * b \/ gcdi(a, b)).let { if (it < 0) -it else it }\n\nfun som(a:Long, b:Long):Long = a + b\n\nfun maxi(a:Long, b:Long):Long = maxOf(a,b)\n\nfun mini(a:Long, b:Long):Long = minOf(a,b)\n\nfun operArray(foo:LongBinaryOperator, arr:LongArray, init:Long):LongArray {\n    val d = foo.applyAsLong(init, arr[0])\n    var result = mutableListOf<Long>(d)\n    arr.forEachIndexed { i, it ->\n        if(i == 0) return@forEachIndexed\n        result.add(foo.applyAsLong(result[i-1],it))\n    }\n    return result.toLongArray()\n}\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206923,"user_id":null,"body":"package operarray\n\nimport java.util.function.LongBinaryOperator\n\nfun gcdi(xx: Long, yy: Long): Long = if (yy == 0L) Math.abs(xx) else gcdi(yy, xx % yy)\nfun lcmu(a: Long, b: Long): Long = Math.abs(a * b) \/ gcdi(a, b)\nfun som(a: Long, b: Long): Long = a + b\nfun maxi(a: Long, b: Long): Long = if (a > b) a else b\nfun mini(a: Long, b: Long): Long = if (a < b) a else b\n\nfun operArray(f: LongBinaryOperator, arr: LongArray, init: Long): LongArray {\n    return LongArray(arr.size).apply {\n        arr.foldIndexed(init) { index, acc, x ->\n            f.applyAsLong(acc, x).also { set(index, it) }\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206924,"user_id":null,"body":"package operarray\n\nimport java.util.function.LongBinaryOperator\n\nfun gcdi(xx: Long, yy: Long): Long = if (yy == 0L) Math.abs(xx) else gcdi(yy, xx % yy)\nfun lcmu(a: Long, b: Long): Long = Math.abs(a * b) \/ gcdi(a, b)\nfun som(a: Long, b: Long): Long = a + b\nfun maxi(a: Long, b: Long): Long = if (a > b) a else b\nfun mini(a: Long, b: Long): Long = if (a < b) a else b\n\nfun operArray(f: LongBinaryOperator, arr: LongArray, init: Long): LongArray {\n    val result = LongArray(arr.size)\n    var prev = init\n\n    result.indices.forEach { i ->\n        result[i] = f.applyAsLong(prev, arr[i])\n        prev = result[i]\n    }\n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206925,"user_id":null,"body":"package operarray\n\nimport java.util.function.LongBinaryOperator\n\nfun maxi(a:Long, b:Long):Long {\n  if (a < b) return b\n    \n  return a\n}\nfun som(a:Long, b:Long):Long {\n  return a + b\n}\n\nfun mini(a:Long, b:Long):Long {\n  return if (a < b) a else b\n}\n\nfun gcdi(xx:Long, yy:Long):Long {      \n  var x = if (xx < 0L) -xx else xx\n  var y = if (yy < 0L) -yy else yy\n    \n  while ( x > 0L) {      \n      if (x == 0L) return y      \n      if (x < y) x = y.also { y = x }\n      x = x % y          \n  }    \n  \n  return y\n}\n\nfun lcmu(a:Long, b:Long):Long {\n  val x = if (a < 0) -a else a\n  val y = if (b < 0) -b else b    \n  return x*y \/ gcdi(x,y)\n}\n\nfun operArray(func: LongBinaryOperator, arr:LongArray, init:Long):LongArray {\n    val list = ArrayList<Long>()\n    var x: Long = func.applyAsLong(init,arr[0])\n    list.add(x)\n    for( y in arr.drop(1)) {\n        x = func.applyAsLong(x,y)\n        list.add(x)\n    }\n    \n    return list.toLongArray()\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206926,"user_id":null,"body":"package operarray\n\nimport java.lang.Long.max\nimport java.lang.Long.min\nimport java.util.function.LongBinaryOperator\nimport kotlin.math.abs\n\nfun gcdi(xx: Long, yy: Long): Long = abs(if (yy == 0L) xx else gcdi(yy, xx % yy))\n\nfun lcmu(a: Long, b: Long): Long = abs(a * b) \/ gcdi(a, b)\n\nfun som(a: Long, b: Long): Long = a + b\n\nfun maxi(a: Long, b: Long): Long = max(a, b)\n\nfun mini(a: Long, b: Long): Long = min(a, b)\n\nfun operArray(lbo: LongBinaryOperator, arr: LongArray, init: Long): LongArray {\n\n    val list = mutableListOf<Long>()\n    var ii = init\n    val x = arr.forEach {\n        ii = lbo.applyAsLong(ii, it)\n        list.add(ii)\n    }\n    return list.toLongArray()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"56f1c6034d0c330e4a001059":[{"id":206927,"user_id":null,"body":"import java.util.Random\nobject GenerateColorRGB {\n    fun generateColor(r:Random) = String.format(\"#%02X%02X%02X\", r.nextInt(255), r.nextInt(255), r.nextInt(255))\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206928,"user_id":null,"body":"import java.util.Random\nobject GenerateColorRGB {\n  private const val COLORS = 256 * 256 * 256\n\n  fun generateColor(r: Random): String = \"#\" + r.nextInt(COLORS).toString(16).padStart(6, '0')\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206929,"user_id":null,"body":"import java.util.Random\nimport java.util.stream.Collectors\n\nobject GenerateColorRGB {\n    fun generateColor(r: Random): String = r.ints(0, 16)\n            .limit(6)\n            .mapToObj { Integer.toHexString(it) }\n            .collect(Collectors.toList())\n            .joinToString(\"\", \"#\", \"\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206930,"user_id":null,"body":"import java.util.Random\nobject GenerateColorRGB {\n  fun generateColor(r:Random) = \"#%06x\".format(r.nextInt(0xFF_FF_FF + 1)); \/\/ +1 because end is exclusive\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206931,"user_id":null,"body":"import java.util.Random\nimport kotlin.math.absoluteValue\n\nobject GenerateColorRGB {\n    fun generateColor(r: Random): String {\n        return buildString {\n            append(\"#\")\n            append(r.nextLong().absoluteValue.toString(16).take(6))\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206932,"user_id":null,"body":"import java.util.Random\nobject GenerateColorRGB {\n  fun generateColor(r:Random):String {\n     return \"#\"+String.format(\"%06d\", r.nextInt(999999))\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206933,"user_id":null,"body":"import java.util.Random\nobject GenerateColorRGB {\n  fun generateColor(r: Random):String {\n    var red = r.nextInt(16).toString(16) + r.nextInt(16).toString(16)\n    var green = r.nextInt(16).toString(16) + r.nextInt(16).toString(16)\n    var blue = r.nextInt(16).toString(16) + r.nextInt(16).toString(16)\n    return \"#$red$green$blue\"\n}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206934,"user_id":null,"body":"import java.util.Random\nobject GenerateColorRGB {\n  fun generateColor(r:Random):String {\n      val colorNumber=Integer.toHexString(r.nextInt(16777215)).padStart(6,'0')\n      return \"#$colorNumber\"\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206935,"user_id":null,"body":"import java.util.Random\nobject GenerateColorRGB {\n  fun generateColor(r:Random) = String.format(\"#%06x\", r.nextInt(0x1000000))\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206936,"user_id":null,"body":"import java.util.Random\nobject GenerateColorRGB {\n  fun generateColor(r:Random):String {\n    val R = r.nextInt(0xFF).toString(16).padStart(2, '0')\n    val G = r.nextInt(0xFF).toString(16).padStart(2, '0')\n    val B = r.nextInt(0xFF).toString(16).padStart(2, '0')\n    return \"#$R$G$B\"\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"56f3a1e899b386da78000732":[{"id":206937,"user_id":null,"body":"package partlist\n\nfun partlist(arr: Array<String>): Array<Array<String>> {\n    return (1 until arr.size).map {\n        arrayOf(arr.take(it).joinToString(\" \"), arr.drop(it).joinToString(\" \"))\n    }.toTypedArray()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206938,"user_id":null,"body":"package partlist\n\nimport java.util.Arrays\n\nfun partlist(arr:Array<String>):Array<Array<String>> {\n   return (0 until arr.size - 1)\n            .map {\n                arrayOf(\n                        arr.sliceArray(0..it).joinToString(\" \"),\n                        arr.sliceArray(it + 1 until arr.size).joinToString(\" \")\n                )\n            }.toTypedArray()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206939,"user_id":null,"body":"package partlist\n\nimport java.util.Arrays\n\nfun partlist(arr:Array<String>):Array<Array<String>> {\n    val newArr = Array<Array<String>>(arr.size-1){Array(2) {\"\"}}\n    for (i in 0 until arr.size-1) {\n        newArr[i] = arrayOf(\n            arr.sliceArray(0..i).joinToString().replace(\", \", \" \"),\n            arr.sliceArray(i+1..arr.size-1).joinToString().replace(\", \", \" \"))\n    }\n    return newArr\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206940,"user_id":null,"body":"package partlist\n\nimport java.util.Arrays\n\nfun partlist(a: Array<String>) = (1..a.lastIndex).map { arrayOf(a.take(it).joinToString(\" \"), a.drop(it).joinToString(\" \")) }.toTypedArray()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206941,"user_id":null,"body":"package partlist\n\nimport java.util.Arrays\n\nfun partlist(arr: Array<String>): Array<Array<String>>  = (0 until arr.size - 1).map { value -> arrayOf<String>(\n        (0..value).map { arr[it] }.joinToString(\" \"),\n        ((value + 1) until arr.size).map { arr[it] }.joinToString(\" \"))\n    }.toTypedArray()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206942,"user_id":null,"body":"package partlist\n\nimport java.util.Arrays\n\nfun partlist(arr:Array<String>):Array<Array<String>> = arr.toList()\n .windowed(arr.size,1,true).mapIndexedNotNull {ind,tail->\n     if(ind==0) null else arrayOf(arr.take(ind).joinToString(\" \"),tail.joinToString(\" \"))\n }.toTypedArray()\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206943,"user_id":null,"body":"package partlist\n\nimport java.util.Arrays\n\nfun partlist(arr:Array<String>) =\n    (0 until arr.lastIndex).map { \n        arrayOf(arr.copyOfRange(0, it+1).joinToString(\" \"), \n        arr.copyOfRange(it+1, arr.size).joinToString(\" \"))\n        }.toTypedArray()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206944,"user_id":null,"body":"package partlist\n\nimport java.util.Arrays\n\nfun partlist(arr:Array<String>):Array<Array<String>> {\n    val newArr: ArrayList<Array<String>> = ArrayList()\n    for (i in 1 until arr.size){\n        newArr.add(arrayOf(arr.copyOfRange(0, i).joinToString(\" \"), arr.copyOfRange(i, arr.size).joinToString(\" \")))\n    }\n    return newArr.toTypedArray()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206945,"user_id":null,"body":"package partlist\n\nimport java.util.Arrays\n\nfun partlist(arr:Array<String>):Array<Array<String>> {\n    return (0 until arr.size-1)\n            .map { arrayOf(Arrays.copyOfRange<String>(arr, 0,  it + 1).joinToString(\" \"),\n                           Arrays.copyOfRange<String>(arr, it + 1, arr.size).joinToString(\" \"))\n            }.toTypedArray()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206946,"user_id":null,"body":"package partlist\n\nimport java.util.Arrays\n\nfun partlist(arr:Array<String>):Array<Array<String>> {\n    \/\/ your code\n    val array = (0 until arr.size - 1).map{\n        arrayOf(\n          arr.sliceArray(0..it).joinToString(\" \"),\n          arr.sliceArray(it + 1 until arr.size).joinToString(\" \")\n        )\n    }.toTypedArray()\n    return array\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"56fe17fcc25bf3e19a000292":[{"id":206947,"user_id":492,"body":"package disguised\n\nimport java.math.BigInteger\n\nprivate fun choose(n:Int, p:Int):BigInteger {\n  var ret = BigInteger.ONE\n  for (i in 0 until p)\n  {\n    ret = ret.multiply(BigInteger.valueOf((n - i).toLong()))\n    .divide(BigInteger.valueOf((i + 1).toLong()))\n  }\n  return ret\n}\nfun u1(n:Int, p:Int):BigInteger {\n  var sm = BigInteger.ZERO\n  val b1 = BigInteger(\"-1\")\n  val b2 = BigInteger(\"4\")\n  var k = 0\n  while (k <= n)\n  {\n    val p1 = b1.pow(k)\n    val p2 = b2.pow(n - k)\n    sm = sm.add(p1.multiply(p2).multiply(choose(2 * n - k + 1, k)))\n    k += 1\n  }\n  return BigInteger.valueOf(p.toLong()).multiply(sm)\n}\nfun v1(n:Int, p:Int):BigInteger {\n  var sm = BigInteger.ZERO\n  val b1 = BigInteger(\"-1\")\n  val b2 = BigInteger(\"4\")\n  var k = 0\n  while (k <= n)\n  {\n    val p1 = b1.pow(k)\n    val p2 = b2.pow(n - k)\n    sm = sm.add(p1.multiply(p2).multiply(choose(2 * n - k, k)))\n    k += 1\n  }\n  return BigInteger.valueOf(p.toLong()).multiply(sm)\n}\nfun uEff(n:Int, p:Int):BigInteger {\n  return BigInteger.valueOf(p.toLong()).multiply(BigInteger.valueOf((n + 1).toLong()))\n}\nfun vEff(n:Int, p:Int):BigInteger {\n  return BigInteger.valueOf(p.toLong()).multiply(BigInteger.valueOf((2 * n + 1).toLong()))\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206948,"user_id":null,"body":"package disguised\n\nimport java.math.BigInteger\n\nfun v1(n: Int, p: Int): BigInteger = BigInteger.valueOf((2L * n + 1L) * p)\n\nfun u1(n: Int, p: Int): BigInteger = BigInteger.valueOf((n + 1L) * p)\n\nfun uEff(n:Int, p:Int):BigInteger = BigInteger.valueOf((n + 1L) * p)\n\nfun vEff(n:Int, p:Int):BigInteger = BigInteger.valueOf((2L * n + 1L) * p)\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206949,"user_id":53,"body":"package disguised\n\nimport java.math.BigInteger\n\nfun u1(n:Int, p:Int):BigInteger {\n  return uEff(n, p)\n}\nfun v1(n:Int, p:Int):BigInteger {\n  return vEff(n, p)\n}\nfun uEff(n:Int, p:Int):BigInteger {\n  return BigInteger.valueOf(p.toLong()).multiply(BigInteger.valueOf((n + 1).toLong()))\n}\nfun vEff(n:Int, p:Int):BigInteger {\n  return BigInteger.valueOf(p.toLong()).multiply(BigInteger.valueOf((2 * n + 1).toLong()))\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206950,"user_id":168,"body":"package disguised\n\nimport java.math.BigInteger\n\nfun comb(n: Int, k: Int): BigInteger = when(k) {\n    0 -> BigInteger.ONE\n    else -> n.toBigInteger() * comb(n - 1, k - 1) \/ k.toBigInteger()\n}\n\nfun u1(n:Int, p:Int):BigInteger =\n    (0..n).sumOf { k -> p.toBigInteger() * 4.toBigInteger().pow(n - k) * comb(2 * n - k + 1, k) * if (k % 2 == 0) 1.toBigInteger() else (-1).toBigInteger() }\n\nfun v1(n:Int, p:Int):BigInteger =\n    (0..n).sumOf { k -> p.toBigInteger() * 4.toBigInteger().pow(n - k) * comb(2 * n - k, k) * if (k % 2 == 0) 1.toBigInteger() else (-1).toBigInteger() }\n\nfun uEff(n:Int, p:Int):BigInteger = p.toBigInteger() * (n + 1).toBigInteger()\n\nfun vEff(n:Int, p:Int):BigInteger = p.toBigInteger() * (2 * n + 1).toBigInteger()\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206951,"user_id":null,"body":"package disguised\n\nimport java.math.BigInteger\n\nval nckCache = mutableMapOf<Int, BigInteger>()\n\nfun nck(n: Int, k: Int): BigInteger {\n    if (n * 10000 + k in nckCache)\n        return nckCache[n * 10000 + k] ?: BigInteger.ONE\n    if (n == k || k == 0) return BigInteger.ONE\n    val result = nck(n - 1, k) + nck(n - 1, k - 1)\n    nckCache[n * 10000 + k] = result\n    return result\n}\n\nfun v1(n: Int, p: Int): BigInteger {\n    return (0..n)\n        .map {\n            BigInteger.valueOf(4).pow(n - it)\n                .multiply((if (it % 2 == 0) BigInteger.ONE else BigInteger.valueOf(-1)) * nck(2 * n - it, it))\n        }\n        .reduce(BigInteger::plus)\n        .multiply(BigInteger.valueOf(p.toLong()))\n}\n\nfun u1(n: Int, p: Int): BigInteger {\n    return (0..n)\n        .map {\n            BigInteger.valueOf(4).pow(n - it)\n                .multiply((if (it % 2 == 0) BigInteger.ONE else BigInteger.valueOf(-1)) * nck(2 * n - it + 1, it))\n        }\n        .reduce(BigInteger::plus)\n        .multiply(BigInteger.valueOf(p.toLong()))\n}\n\n\nval vEff = ::v1\n\nval uEff: (n: Int, p: Int) -> BigInteger = ::u1","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206952,"user_id":null,"body":"package disguised\n\nimport java.math.BigInteger\n\nfun u1(n:Int, p:Int): BigInteger = uEff(n, p)\n\nfun v1(n:Int, p:Int): BigInteger = vEff(n, p)\n\nfun uEff(n:Int, p:Int): BigInteger =\n    BigInteger.valueOf(\n        n.plus(1).times(p).toLong()\n    )\n\nfun vEff(n:Int, p:Int): BigInteger =\n    BigInteger.valueOf(\n        n.times(2).plus(1).times(p).toLong()\n    )\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206953,"user_id":null,"body":"package disguised\n\nimport java.math.BigInteger\n\nfun u1(n:Int, p:Int): BigInteger {\n    return BigInteger.valueOf(p.toLong() + p * n)\n}\n\nfun v1(n:Int, p:Int):BigInteger {\n    return BigInteger.valueOf(p + 2L * p * n)\n}\n\nfun uEff(n:Int, p:Int):BigInteger {\n    return BigInteger.valueOf(p.toLong() + p * n)\n}\n\nfun vEff(n:Int, p:Int):BigInteger {\n    return BigInteger.valueOf(p + 2L * p * n)\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206954,"user_id":null,"body":"package disguised\nimport java.math.BigInteger\n\nfun v1(n:Int, p:Int):BigInteger = (2.toBigInteger() * n.toBigInteger() + 1.toBigInteger()) * p.toBigInteger()\nfun u1(n:Int, p:Int):BigInteger = (n.toBigInteger() + 1.toBigInteger()) * p.toBigInteger()\n\nfun vEff(n:Int, p:Int):BigInteger = (2.toBigInteger() * n.toBigInteger() + 1.toBigInteger()) * p.toBigInteger()\nfun uEff(n:Int, p:Int):BigInteger = (n.toBigInteger() + 1.toBigInteger()) * p.toBigInteger()\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206955,"user_id":null,"body":"package disguised\n\nimport java.math.BigInteger\n\nfun Int.big() : BigInteger {\n  return BigInteger.valueOf(this.toLong())\n}\n\nfun Int.fact() : BigInteger {\n  if (this < 2) return 1.big()\n  return (2..this).fold(1.big()){R,n->R.multiply(n.big())}\n}\n\nfun Int.pow(n: Int) : Int {\n  if (n == 0) return 1\n  return (1..n).fold(1){R,_->R*this}\n}\n\nfun binomial(n: Int, k: Int):BigInteger {\n  return n.fact() \/ (k.fact() * (n-k).fact())\n}\n\nfun u1(n:Int, p:Int):BigInteger {\n  val bigp = p.big()\n  return (0..n).fold(0.big()){R, k -> \n    R + (-1).pow(k).big() * bigp * 4.big().pow(n-k) * binomial(2*n-k+1, k)\n  }\n}\nfun v1(n:Int, p:Int):BigInteger {\n  val bigp = p.big()\n  return (0..n).fold(0.big()){R, k ->\n    R + (-1).pow(k).big() * bigp * 4.big().pow(n-k) * binomial(2*n-k, k) \n  }\n}\nfun uEff(n:Int, p:Int):BigInteger {\n  return ((n+1)*p).big()\n}\nfun vEff(n:Int, p:Int):BigInteger {\n  return ((n*2+1)*p).big()\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206956,"user_id":17,"body":"package disguised\n\nimport java.math.BigInteger\n\nfun u1(n:Int, p:Int):BigInteger {\n  return BigInteger.valueOf(p.toLong()).multiply(BigInteger.valueOf((n + 1).toLong()))\n}\nfun v1(n:Int, p:Int):BigInteger {\n  return BigInteger.valueOf(p.toLong()).multiply(BigInteger.valueOf((2 * n + 1).toLong()))\n}\nfun uEff(n:Int, p:Int):BigInteger {\n  return BigInteger.valueOf(p.toLong()).multiply(BigInteger.valueOf((n + 1).toLong()))\n}\nfun vEff(n:Int, p:Int):BigInteger {\n  return BigInteger.valueOf(p.toLong()).multiply(BigInteger.valueOf((2 * n + 1).toLong()))\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5700c9acc1555755be00027e":[{"id":206957,"user_id":null,"body":"package allinclusive\n\nfun containAllRots(strng:String, arr:ArrayList<String>):Boolean {\n    return arr.containsAll(List(strng.length) { (strng.drop(it) + strng.take(it)) })\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206958,"user_id":null,"body":"package allinclusive\n\nfun containAllRots(x:String, arr:ArrayList<String>):Boolean {\n    val rots = (0 until x.length).map { x.takeLast(it) + x.dropLast(it) }\n    return arr.containsAll(rots)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206959,"user_id":null,"body":"package allinclusive\n\nfun containAllRots(strng: String, arr: ArrayList<String>):Boolean {\n    val rotations  = (1..strng.length).map { strng.rotate(it) }\n\n    return arr.containsAll(rotations)\n}\n\nprivate fun String.rotate(n: Int) = drop(n) + take(n)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206960,"user_id":null,"body":"package allinclusive\n\nfun containAllRots(string: String, arr: ArrayList<String>): Boolean {\n\n    return arr.containsAll(string.mapIndexed { i, c -> buildString { repeat(string.length) { append(string[(it + i) % string.length]) } } })\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206961,"user_id":null,"body":"package allinclusive\n\nfun containAllRots(strng:String, arr:ArrayList<String>):Boolean {\n    \/\/ your code\n    var count = 0\n      for(str in arr){\n        if(strng.all{str.contains(it)}){\n          ++count\n        }\n      }\n      return strng.length == count\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206962,"user_id":null,"body":"package allinclusive\n\nfun containAllRots(strng:String, arr:ArrayList<String>)=\n        generateSequence(strng) {\"${it.subSequence(1, it.length)}${it[0]}\"}\n            .take(strng.length)\n            .fold(true){acc, b -> acc && arr.contains(b) }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206963,"user_id":527,"body":"package allinclusive\n\nfun containAllRots(string: String, strings: List<String>): Boolean {\n    val strings: Set<String> = HashSet(strings)\n    return (0 until string.length).all { i ->\n        strings.contains(string.substring(i) + string.substring(0, i))\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206964,"user_id":492,"body":"package allinclusive\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet\n\nfun rotations(strng:String):HashSet<String> {\n    var result = HashSet<String>()\n    for (index in 0 until strng.length)\n    {\n      val rotatedString = strng.substring(index) + strng.substring(0, index)\n      if (result.contains(rotatedString) === false)\n      result.add(rotatedString)\n    }\n    return result\n}\nfun containAllRots(strng:String, arr:ArrayList<String>):Boolean {\n    val setarr = HashSet<String>(arr)\n    val result = rotations(strng)\n    val intersect = HashSet<String>(setarr)\n    intersect.retainAll(result)\n    return intersect.equals(result)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206965,"user_id":null,"body":"package allinclusive\n\nfun containAllRots(strng:String, arr:ArrayList<String>) = strng.mapIndexed {ind,_->\n        strng.drop(ind) + strng.take(ind)\n}.all {it in arr}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206966,"user_id":null,"body":"package allinclusive\n\nfun containAllRots(string: String, arr: ArrayList<String>): Boolean {\n    if (string.isEmpty()) return true\n    var rotated = string\n    repeat(string.length) {\n        if (!arr.contains(rotated)) {\n            return false\n        }\n        rotated = rotated.drop(1) + rotated.first()\n    }\n    return true\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5715eaedb436cf5606000381":[{"id":206967,"user_id":null,"body":"fun sum(numbers: IntArray) = numbers.filter { it > 0 }.sum()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206968,"user_id":null,"body":"fun sum(numbers: IntArray)\n  = numbers.sumBy { it.coerceAtLeast(0) }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206969,"user_id":null,"body":"fun sum(numbers: IntArray) = numbers.sumBy{if(it>0) it else 0}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206970,"user_id":null,"body":"fun sum(numbers: IntArray): Int {\n    \/\/ Place your code here\n    return numbers.filter {num -> num > 0}.sum()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206971,"user_id":null,"body":"fun sum(numbers: IntArray): Int {\n    var addition = 0\n    \n    for( number in numbers ) {\n      if( number > 0 ) {\n          addition = addition + number\n      }\n    }\n    return addition\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206972,"user_id":527,"body":"import kotlin.math.max\n\nfun sum(numbers: IntArray): Int = numbers.sumOf { max(it, 0) }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206973,"user_id":null,"body":"fun sum(numbers: IntArray): Int {\n    var total = 0\n    for (i in numbers) {\n        if (i<0) continue\n        else\n            total += i\n    }\n    return total\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206974,"user_id":null,"body":"fun sum(numbers: IntArray): Int {\n    var i: Int=0\n    numbers.forEach{value ->\n        if(value>0){\n            i+=value\n        }\n    }\n    return i\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206975,"user_id":null,"body":"fun sum(numbers: IntArray): Int {\n    \/\/ Place your code here\n    var sum=0\n    for(i in numbers){\n        if(i<0)\n        continue\n        sum+=i\n    }\n    return sum\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206976,"user_id":null,"body":"fun sum(numbers: IntArray): Int = numbers.sumBy { it.coerceAtLeast(0) }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5726f813c8dcebf5ed000a6b":[{"id":206977,"user_id":null,"body":"package kprimes\n\nfun countKprimes(k: Int, start: Long, end: Long): LongArray {\n    return (start..end).filterTo(ArrayList()) { found(it) + 1 == k }.toLongArray()\n}\n\ntailrec fun found(input: Long, primes: Int = 2, count: Int = 0): Int {\n    return if (primes <= input \/ primes && (input % primes).toInt() != 0) found(input, primes + 1, count)\n    else if (primes <= input \/ primes) found(input \/ primes, 2, count + 1)\n    else count\n}\n\nfun puzzle(s: Int): Int {\n    val aarray = countKprimes(1, 2, s.toLong())\n    val barray = countKprimes(3, 8, s.toLong())\n    val carray = countKprimes(7, 128, s.toLong())\n    var count = 0\n\n    carray.map { s - it }.forEach {\n        for (b in barray) {\n            if (b > it) {\n                return@forEach\n            }\n            val remain2 = it - b\n            if (aarray.contains(remain2)) {\n                count++\n            }\n        }\n    }\n    return count\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206978,"user_id":53,"body":"package kprimes\n\nfun pfc(m:Long):Int {\n    var ans = 0\n    var n = m\n    var i = 2L\n    while (i <= n\/i) {\n        while (n % i == 0L) { ans++; n\/=i }\n        i++\n    }\n    if (n > 1L) ans++\n    return ans\n}\n\nfun countKprimes(k:Int, start:Long, end:Long):LongArray {\n    val fs = mutableListOf<Long>()\n    for (n in start..end) {\n        val j = pfc(n)\n        if (j == k) fs.add(n)\n    }\n    return fs.toLongArray()\n}\n\nfun puzzle(s:Int):Int {\n    var ans = 0\n    val xs = countKprimes(7, 128L, s - 10L)\n    val ys = countKprimes(3, 8L, s - 130L)\n    for (a in xs) {\n        for (b in ys) {\n            val c = s.toLong() - a - b\n            if (c > 0 && pfc(c) == 1) ans++\n        }\n    }\n    return ans\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206979,"user_id":null,"body":"package kprimes\n\nfun countKprimes(k :Int, start :Long, end :Long) = (start..end)\n    .filter { n -> hasKprimeFactors(k, n) }\n    .toLongArray()\n\nfun hasKprimeFactors(k :Int, n :Long) :Boolean {\n    if (n==0L) return false\n    if (n<0L) return hasKprimeFactors(k-1, -n)\n    var number = n\n    var count = k\n    var p=2L\n    while (number>=p*p) {\n        while (number%p==0L) {\n            count--\n            number \/= p\n        }\n        if (count<0) return false\n        p = if (p==2L) 3L  else p+2L\n    }\n    if (number>1L) count--\n    return count==0\n}\n\nfun puzzle(s :Int) = puzzle(s.toLong())\n\nfun puzzle(s :Long) = countKprimes(1, 1, s-4L).flatMap { p1 ->\n        countKprimes(3, 1, s-p1-2).map { p3 -> Pair(p1, p3) }\n    }.filter { p -> hasKprimeFactors(7,s-p.first-p.second) }\n    .count()\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206980,"user_id":null,"body":"package kprimes\n\nfun countKprimes(k: Int, start: Long, end: Long): LongArray {\n    return (start..end)\n        .filter { countPrimeFactors(it) == k }\n        .toLongArray()\n}\n\nfun countPrimeFactors(m: Long): Int {\n    var primeFactors = 0\n    var n = m\n\n    while (n % 2 == 0L && n > 0) {\n        n \/= 2\n        primeFactors++\n    }\n    val limit = Math.sqrt(n.toDouble()).toInt()\n\n    for (i in 3..limit step 2) {\n        while (n % i == 0L) {\n            n \/= i\n            primeFactors++\n        }\n    }\n    return if (n == 1L) primeFactors else primeFactors + 1\n}\n\nfun puzzle(s: Int): Int {\n    val end = s.toLong()\n    var ans = 0\n\n    for (a in countKprimes(1, 2, end))\n        for (b in countKprimes(3, 8, end))\n            for (c in countKprimes(7, 128, end))\n                if (a + b + c == end)\n                    ans++\n    return ans\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206981,"user_id":null,"body":"package kprimes\nfun primesMultiplicity(it:Long):Int{\n    var cnt = 1\n    var current = it\n    var pivot = 2L\n    while(pivot<=Math.sqrt(current.toDouble()).toLong()){\n        if(current%pivot==0L){\n            current\/=pivot\n            cnt++\n        }\n        else{\n            pivot++\n        }\n        \n    }\n    return cnt\n\n}\nfun countKprimes(k:Int, start:Long, end:Long):LongArray {\n    return ((start..end).filter{primesMultiplicity(it)==k}.toLongArray())\n}\nfun puzzle(s:Int):Int {\n    var cnt = 0 \n    val inp = s.toLong()\n    for(el in countKprimes(7, 2, inp-1).filter{it>1}){\n        for(ell in countKprimes(3, 2, inp-el-1).filter{it>1}){   \n            if((inp-ell-el) in countKprimes(1, 2, inp-el-ell))\n            cnt++\n            }\n}\n    return cnt\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206982,"user_id":null,"body":"package kprimes\n\nfun countKprimes(k: Int, start: Long, end: Long): LongArray =\n    LongRange(start, end).filter { it.isKPrime(k) }.toLongArray()\n\nprivate fun Long.isKPrime(k: Int): Boolean {\n    if (k < 1) return this == 1L\n    if (this < 2) return false\n    if ((k in kPrimeNumbers.keys) && (this <= (kPrimeNumbers[k]?.last() ?: 0))) {\n        return kPrimeNumbers[k]!!.contains(this)\n    }\n    while (primeNumbers.last() * primeNumbers.last() < this) {\n        findAnotherPrime()\n    }\n    primeNumbers.forEach {\n        if ((this % it) == 0L) return (this \/ it).isKPrime(k - 1)\n        if (it * it > this) return (k == 1)\n    }\n    return false\n}\n\nfun extendKPrimes(k: Int, limit: Long) {\n    countKprimes(k, kPrimeNumbers[k]!!.run { if (this.isEmpty()) 2 else this.last() + 1 }, limit).toCollection(\n        kPrimeNumbers[k]!!\n    )\n}\n\nfun findAnotherPrime() {\n    var i = primeNumbers.last()\n    while (true)\n    if ((++i).isKPrime(1)) {\n        primeNumbers.add(i)\n        return\n    }\n}\n\nfun puzzle(s: Int): Int {\n    kPrimeNumbers.keys.forEach { extendKPrimes(it, s.toLong()) }\n    return kPrimeNumbers[7]!!.filter { it < s }.flatMap { sevenPrime ->\n        kPrimeNumbers[3]!!.filter { it < s - sevenPrime }.map { threePrime -> threePrime + sevenPrime }\n    }.count { (s - it).isKPrime(1) }\n}\n\ninternal var kPrimeNumbers: Map<Int, MutableList<Long>> = mapOf(\n    7 to mutableListOf(128, 192, 288, 320, 432, 448),\n    3 to mutableListOf(8, 12, 18, 20, 27, 28, 30),\n)\n\nprivate var primeNumbers: MutableList<Long> = mutableListOf(\n    2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\n    73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173,\n    179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281,\n    283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409,\n    419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541,\n    547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659,\n    661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809,\n    811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941,\n    947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069,\n    1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223,\n    1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373,\n    1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511,\n    1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657,\n    1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811,\n    1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987,\n    1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129,\n    2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287,\n    2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423,\n    2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617,\n    2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741,\n    2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903,\n    2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079,\n    3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257,\n    3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413,\n    3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571,\n    3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727,\n    3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907,\n    3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057,\n    4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231,\n    4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409,\n    4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583,\n    4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751,\n    4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937,\n    4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087,\n    5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279,\n    5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443,\n    5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639,\n    5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791,\n    5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939,\n    5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133,\n    6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301,\n    6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473,\n    6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673,\n    6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833,\n    6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997,\n    7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207,\n    7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411,\n    7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561,\n    7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723,\n    7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919,\n)\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206983,"user_id":null,"body":"package kprimes\n\nimport kotlin.math.ceil\nimport kotlin.math.sqrt\n\nfun isPrime(n: Long): Boolean {\n    if (n < 4)\n        return true\n    if (n % 2 == 0L || n % 3 == 0L)\n        return false\n\n    var i = 5\n    while (i * i <= n) {\n        if (n % i == 0L || n % (i + 2) == 0L)\n            return false\n\n        i += 6\n    }\n\n    return true\n}\n\nfun generatePrimes(max: Long): List<Long> = generateSequence(2L) { it + 1 }\n    .filter { isPrime(it) }\n    .takeWhile { it <= max }\n    .toList()\n\nfun countFactors(n: Long): Int {\n    var count = 0\n    var num = n\n\n    while (num >= 2 && num % 2 == 0L) {\n        count++\n        num \/= 2\n    }\n\n    for (i in 3 until sqrt(n.toDouble()).toInt() + 1 step 2) {\n        while (num % i == 0L) {\n            count++\n            num \/= i\n        }\n    }\n\n    if (num > 2)\n        count++\n\n    return count\n}\n\nfun countKprimes(k: Int, start: Long, end: Long): LongArray =\n    (start..end)\n        .filter { countFactors(it) == k }\n        .toLongArray()\n\nfun puzzle(n: Int): Int =\n    countKprimes(7, 2, n.toLong())\n        .map { n - it }\n        .flatMap { countKprimes(3, 2, n.toLong()).map { k3 -> it - k3 } }\n        .count { it > 1 && isPrime(it) }\n\n\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206984,"user_id":null,"body":"package kprimes\nimport kotlin.math.sqrt\n\nfun countKprimes(k:Int, start:Long, end:Long):LongArray {\n    val list = mutableListOf<Long>()\n    for(i in start..end) {\n        if (findPrimeFactors(i).size == k) {\n            list.add(i)\n        }\n    }\n    return list.toLongArray()\n}\nfun puzzle(s:Int):Int {\n    val onePrime: List<Long> = countKprimes(1, 2.toLong(), s.toLong()).toList()\n    val threePrime: List<Long> = countKprimes(3, 2.toLong(), s.toLong()).toList()\n    val sevenPrime: List<Long> = countKprimes(7, 2.toLong(), s.toLong()).toList()\n    var count = 0\n\n    for(e1 in onePrime) {\n        for(e3 in threePrime) {\n            for(e7 in sevenPrime) {\n                val sum: Long = e1+e3+e7\n                if (sum == s.toLong()) {\n                    count++\n                }\n            }\n        }\n    }\n\n    return count\n}\n\nfun findPrimeFactors(n: Long): List<Long> {\n    var num = n\n    var p: Long = 2\n    val limit = sqrt(num.toDouble()).toInt()\n    val primeFactors = mutableListOf<Long>()\n\n    while(p <= limit) {\n        if (num % p == 0.toLong()) {\n            \/\/ if num is divisible, add p as factor\n            num \/= p\n            primeFactors.add(p)\n        } else {\n            \/\/ increment divisor\n            p++\n        }\n    }\n    if (num != 1.toLong()) {\n        primeFactors.add(num)\n    }\n\n    return primeFactors\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206985,"user_id":null,"body":"package kprimes\n\nimport kotlin.math.sqrt\n\nfun countKprimesFullRange(k: Int, start: Long, end: Long): LongArray {\n    val count = mutableMapOf<Long, Int>()\n    val res = mutableListOf<Long>()\n    for (i in 2..end) {\n        val c = count[i]\n        if (c == null || c == 0) { \/\/ prime\n            for (j in i..end step i) {\n                var q = 0\n                var z = j\n                while (z % i == 0L) {\n                    z \/= i\n                    q++\n                }\n                count[j] = (count[j] ?: 0) + q\n            }\n        }\n        if (i >= start && count[i] == k) {\n            res += i\n        }\n        count.remove(i)\n    }\n    return res.toLongArray()\n}\n\nfun countFactors(l: Long): Int {\n    var c = 0\n    var x = l\n    val d = sqrt(l.toDouble()).toLong() + 1\n    for (i in 2..d) {\n        while (x % i == 0L) {\n            x \/= i\n            c++\n        }\n        if (x == 1L) {\n            break\n        }\n    }\n    if (x > 1L && c != 0) {\n        c++\n    }\n    if (c == 0) {\n        c = 1\n    }\n    return c\n}\n\nfun countKprimes(k: Int, start: Long, end: Long): LongArray {\n    val res = mutableListOf<Long>()\n    for (i in start..end) {\n        if (countFactors(i) == k) {\n            res += i\n        }\n    }\n    return res.toLongArray()\n}\n\nfun puzzle(s: Int): Int {\n    val t = s.toLong()\n    val primes1 = countKprimesFullRange(1, 2, t)\n    val primes3 = countKprimesFullRange(3, 2, t)\n    val primes7 = countKprimesFullRange(7, 2, t)\n    var c = 0\n    primes1.forEach { p1 ->\n        primes3.forEach { p3 ->\n            primes7.forEach { p7 ->\n                if (p1 + p3 + p7 == t) {\n                    c++\n                }\n            }\n        }\n    }\n    return c\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206986,"user_id":null,"body":"package kprimes\n\nfun countKprimes(k: Int, start: Long, end: Long): LongArray {\n    return (start..end).filter {\n        getPrimeFactorsCount(it) == k\n    }.toLongArray()\n}\n\nfun puzzle(s: Int): Int {\n    val sLong = s.toLong()\n    val a = countKprimes(1, 0, sLong)\n    val b = countKprimes(3, 0, sLong)\n    val c = countKprimes(7, 0, sLong)\n    var result = 0\n    for (aEl in a) {\n        for (bEl in b) {\n            for (cEl in c) {\n                if (aEl + bEl + cEl == sLong){\n                    result += 1\n                }\n            }\n        }\n    }\n    return result\n}\n\nfun getPrimeFactorsCount(value: Long): Int {\n    var n = value\n    var i = 2\n    var result = 0\n    while (i * i <= n) {\n        while (n % i == 0L) {\n            n \/= i\n            result += 1\n        }\n        i += 1\n    }\n    if (n > 1) result += 1\n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"573182c405d14db0da00064e":[{"id":206987,"user_id":null,"body":"package conseckprimes\n\nfun consecKprimes(k: Int, arr: LongArray) = arr.toList()\n    .windowed(2)\n    .count {\n        return@count kPrime(it[0]) == k && kPrime(it[1]) == k\n    }\n\n\nfun kPrime(n: Long): Int {\n\n    for (i in 2..Math.sqrt(n.toDouble()).toInt()) {\n        if (n % i == 0.toLong()) return kPrime(n \/ i) + 1\n    }\n\n    return 1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206988,"user_id":null,"body":"package conseckprimes\n\nfun consecKprimes(k: Int, arr: LongArray): Int =\n        arr.asSequence().map { isKPrime(k, it) }.zipWithNext(Boolean::and).count { it }\n\nfun isKPrime(k: Int, n: Long): Boolean {\n    var count = 0\n    var r = n\n    var p = 2\n    while (r > 1 && count <= k+1) {\n        while (r % p == 0L) {\n            count++\n            r \/= p\n        }\n        p++\n    }\n    return count == k\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206989,"user_id":null,"body":"package conseckprimes\n\nfun consecKprimes(k: Int, arr: LongArray): Int {\n    var count = 0\n    var flag = false\n    arr.forEach {\n        val kprime = getFactorCount(it)\n        if (kprime == k && flag) {\n            count++\n        } else {\n            flag = kprime == k\n        }\n    }\nreturn count\n}\n\nfun getFactorCount(num: Long): Int {\n    val map = HashMap<Long, Int>()\n    var t = num\n    var n = 2L\n    while (t != 1L) {\n        for (i in n..num) {\n            var count = 0\n            while (t % i == 0L) {\n                t \/= i\n                count++\n            }\n            if (count > 0) {\n                map[i] = map.getOrDefault(i, 0) + count\n                n = i\n                break\n            }\n        }\n    }\n    return map.values.sum()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206990,"user_id":null,"body":"package conseckprimes\n\nfun Long.isKprime(k: Int): Boolean {\n    var count = 0\n    var number = this\n    var divisor = 2L\n    while (count <= k && number > 1) {\n        if (number % divisor == 0L) {\n            count++\n            number \/= divisor\n        } else {\n            divisor++\n        }\n    }\n    return count == k\n}\n\nfun consecKprimes(k: Int, arr: LongArray): Int {\n    return arr.map { it.isKprime(k) }.windowed(2).count { (a, b) -> a && b }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206991,"user_id":null,"body":"package conseckprimes\n\nfun consecKprimes(k: Int, arr: LongArray): Int {\n    var f = false\n    var r = 0\n    for (n in arr) {\n        var i = 0\n        var p = 2\n        var c = n\n        while (c > 1) if (c % p == 0L) {\n            c \/= p\n            i++\n        } else p++\n        if (i == k) if (f) r++ else f = true else f = false\n    }\n    return r\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206992,"user_id":null,"body":"package conseckprimes\n\nfun primeFactors(x : Long) : Int {\n    var primes : MutableList<Long> = mutableListOf()\n    var y = x\n    var i : Long = 2\n    while (i <= x) {\n        if (y % i == 0L) {\n            primes.add(i)\n            y \/= i\n        } else i++\n    }\n    return primes.size\n}\n\nfun consecPairs(arr: List<Int>, k: Int) : Int {\n    val triples = arr.map { Triple(it, 0, 0) }\n    val tup = triples.fold(Triple(0,0,0)) { acc, v ->\n        when {\n            v.first != k -> Triple(0, 0, acc.third)\n            else -> when {\n                acc.second == 0 -> Triple(0, 1, acc.first + acc.third)\n                else -> Triple(0, acc.second + 1, acc.third + 1)\n            }\n        }\n    }\n    return tup.third;\n}\n\nfun consecKprimes(k:Int, arr:LongArray):Int {\n    return consecPairs(arr.map{primeFactors(it)},k)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206993,"user_id":null,"body":"package conseckprimes\n\nfun primesMultiplicity(it:Long):Int{\n    var cnt = 1\n    var current = it\n    var pivot = 2L\n    while(pivot<=Math.sqrt(current.toDouble()).toLong()){\n        if(current%pivot==0L){\n            current\/=pivot\n            cnt++\n        }\n        else{\n            pivot++\n        }\n\n    }\n    return cnt\n\n}\nfun consecKprimes(k:Int, arr:LongArray):Int {\n    return arr.zip(arr.drop(1)).count{primesMultiplicity(it.first)==k&&k==primesMultiplicity(it.second)}\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206994,"user_id":null,"body":"package conseckprimes\n\nfun consecKprimes(k: Int, arr: LongArray): Int {\n    if (arr.isEmpty()) return 0\n    KPrimes.build(k, arr.maxOrNull()!!)\n    return arr.map { l -> l in KPrimes[k]!! }.zipWithNext().count { p -> p.first && p.second }\n}\n\nobject KPrimes : LinkedHashMap<Int, MutableSet<Long>>() {\n\n    init { \/\/ pre-build reduces total attempt time by over 30%\n        build(6, 11111)\n    }\n\n    fun build(k: Int, limit: Long) {\n        if (k < 1) throw IllegalArgumentException(\"k must be a positive integer\")\n        (1 + this.size..k).forEach { this[it] = mutableSetOf() }\n\n        buildTruePrimes(limit)\n        (2..this.size).forEach { kIndex ->\n            val max = this[kIndex]!!.maxOrNull() ?: 0\n            if (limit > max) {\n                this[1]!!.flatMap { truePrime ->\n                    this[kIndex - 1]!!.map { it * truePrime }\n                }.filter { it > max }.filter { it <= limit }.toCollection(this[kIndex]!!)\n            }\n        }\n    }\n\n    private fun buildTruePrimes(limit: Long) {\n        (((this[1]!!.maxOrNull() ?: 1L) + 1)..limit).forEach { checkIfPrime ->\n            if (this[1]!!.all { (checkIfPrime % it) != 0L }) {\n                this[1]!!.add(checkIfPrime)\n            }\n        }\n    }\n\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206995,"user_id":null,"body":"package conseckprimes\n\nfun isKPrime(k: Int, n: Long): Boolean {\n    if (n == 1L && k == 1)\n        return true\n    var primeCount = 0\n    var factor = 2\n    var x = n\n    while (x > 1) {\n        if (primeCount > k)\n            return false\n        while (x % factor != 0L)\n            factor++\n        primeCount++\n        x \/= factor\n        factor = 2\n    }\n    return primeCount == k\n}\n\nfun consecKprimes(k: Int, arr: LongArray): Int {\n    var result = 0\n    val converted = arr.map { isKPrime(k,it) }\n    for(i in 1 until converted.size)\n        if (converted[i] && converted[i-1])\n            result++\n    return result\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206996,"user_id":null,"body":"package conseckprimes\n\nfun consecKprimes(k: Int, arr: LongArray): Int {\n    var count = 0\n    for (i in 0 until arr.size - 1) {\n        if (primeFactors(arr[i]).size == k && primeFactors(arr[i + 1]).size == k) {\n            count++\n        }\n    }\n    return count\n}\n\nfun primeFactors(n: Long): List<Long> {\n    var n = n\n    val factors = mutableListOf<Long>()\n    var d = 2L\n    while (n > 1) {\n        while (n % d == 0L) {\n            factors.add(d)\n            n \/= d\n        }\n        d++\n    }\n    return factors\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"573992c724fc289553000e95":[{"id":206997,"user_id":null,"body":"package solution\n\nobject ToSmallest {\n\n    fun smallest(n: Long): LongArray {\n        val str = n.toString()\n        var minI = 0\n        var minJ = 0\n        var minVal = str\n        for (i in str.indices) {\n            for (j in 0..str.length - 1) {\n                val e = str[i]\n                val newPerm = StringBuilder(str).deleteCharAt(i)\n                newPerm.insert(j, e)\n                if (newPerm.toString() < minVal) {\n                    minVal = newPerm.toString()\n                    minI = i\n                    minJ = j\n                }\n            }\n        }\n        return longArrayOf(minVal.toLong(), minI.toLong(), minJ.toLong())\n    }\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206998,"user_id":null,"body":"package solution\n\nobject ToSmallest {\n\n    fun smallest(n: Long): LongArray {\n        val arr = longToList(n)\n        var min = longArrayOf(n,0L,0L)\n        (0..arr.size-1).forEach {x->\n            (0..arr.size-1).forEach {y->\n                val candidate = getLong(move(arr,x,y))\n                if(candidate<min[0]) min = longArrayOf(candidate,x.toLong(),y.toLong())\n            } \n        }\n        return min\n    }\n    \n    fun longToList(n: Long): List<Long> {\n        var d = n\n        val l = mutableListOf<Long>().apply {\n            while(d>0L) {\n                add(d%10)\n                d \/= 10\n            }\n        }.reversed()\n        return l\n    }\n    \n    fun move(arr: List<Long>, from: Int, to: Int): List<Long> {\n        val ret = arr.toMutableList()\n        val a = ret[from]\n        ret.removeAt(from)\n        ret.add(to,a)\n        return ret\n    }\n    \n    fun getLong(arr: List<Long>): Long {\n        var ret = 0L\n        var e = 1L\n        arr.reversed().forEach {i->\n            ret += i*e\n            e *= 10L\n        }\n        return ret\n    }\n    \n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":206999,"user_id":null,"body":"package solution\n\nobject ToSmallest {\n\n    fun smallest(n: Long): LongArray {\n        val list = n.toString().map { it.toString().toInt() }\n        val m = list.indices.flatMap { mutation(list, it) }.minBy { it.first } ?: Triple(0L, 0, 0)\n        return LongArray(3).apply {\n            set(0, m.first)\n            set(1, m.second.toLong())\n            set(2, m.third.toLong())\n        }\n    }\n\n\n    private fun mutation(arr: List<Int>, idx: Int): List<Triple<Long, Int, Int>> = arr.indices.map {\n        val list = arr.toMutableList()\n        val x = list.removeAt(idx)\n        list.add(it, x)\n        val newString = list.joinToString(\"\").toLong()\n        Triple(newString, idx, it)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207000,"user_id":null,"body":"package solution\n\nobject ToSmallest {\n\n    fun smallest(n: Long): LongArray {\n        val ns = n.toString()\n        var r = mutableListOf<LongArray>()\n        for (f in 0..ns.lastIndex)\n            for (t in 0..ns.lastIndex)\n                r.add(longArrayOf( ns.filterIndexed { k, _ -> k != f }.replaceRange(t, t, ns.get(f).toString()).toLong(), f.toLong(), t.toLong()))\n        return r.minBy { it[0] }!!\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207001,"user_id":null,"body":"package solution\n\nobject ToSmallest {\n    fun permutation(numbersList: MutableList<Int>, originalIndex: Int, newIndex: Int): Long {\n        var n = numbersList[originalIndex]\n        numbersList.removeAt(originalIndex)\n        numbersList.add(newIndex, n)\n        return numbersList.joinToString(\"\") { el -> el.toString() }.toLong()\n    }\n\n    fun smallest(n: Long): LongArray {\n        var numArray = n.toString().toCharArray().mapIndexed { index, el -> el.code - 48 }.toMutableList()\n        var smallestNumber = n\n        var perm = Pair(0, 0)\n        var numbersCount: Int = numArray.size\n        for (position in 0 until numbersCount) {\n            for (newPos in 0 until numbersCount) {\n                if (position == newPos)\n                    continue\n                var valus = permutation(ArrayList(numArray), position, newPos)\n                if (valus < smallestNumber) {\n                    smallestNumber = valus\n                    perm = Pair(position, newPos)\n                }\n\n            }\n        }\n\n        return longArrayOf(smallestNumber, perm.first.toLong(), perm.second.toLong())\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207002,"user_id":null,"body":"package solution\n\nimport java.util.*\n\nobject ToSmallest {\n    fun smallest(n: Long): LongArray {\n        val s = \"\" + n\n        var result = longArrayOf(Long.MAX_VALUE, 0, 0)\n        for (i in s.length - 1 downTo 0) {\n            val s1: String = s.substring(0, i) + s.substring(i + 1)\n            for (j in s.length - 1 downTo 0) {\n                val tmp: Long = (s1.substring(0, j) + s.get(i) + s1.substring(j)).toLong()\n                if (tmp <= result[0]) result = longArrayOf(tmp, i.toLong(), j.toLong())\n            }\n        }\n        return result\n    }\n}\n\n\n\/*\nobject ToSmallest {\n    fun smallest(n: Long): LongArray {\n        val stringValue = n.toString()\n        println(stringValue)\n        var min1  : Long = n\n        var from1 : Long = 0\n        var to1 : Long = 0\n        for(i in 0 until stringValue.length) {\n            var charValue = stringValue.get(i)\n            var substringValue = stringValue.substring(0, i) + stringValue.substring(i+1, stringValue.length)\n            for(j in 0 until substringValue.length) {\n                var substringCheck = substringValue.substring(0,j) + charValue + substringValue.substring(j, substringValue.length)\n                if (substringCheck.toLong() < min1) {\n                    min1 = substringCheck.toLong()\n                    from1 = i.toLong()\n                    to1 = j.toLong()\n                }\n            }\n        }\n    return longArrayOf(min1, from1, to1)\n    }\n}*\/\n\n\/*\nobject ToSmallest {\n    private var smallestPosition = 0\n    private var replacedPosition = 0\n    fun smallest(n: Long): LongArray {\n        val value: String = n.toString()\n        var smallestPossibleValue: String = value\n        for (i in 0 until value.length) {\n            val currentDigit: Char = value.get(i)\n            for (j in 0 until value.length) {\n                val sb = StringBuilder(value)\n                sb.deleteCharAt(i)\n                sb.insert(j, currentDigit)\n                val newValue: String = sb.toString()\n                if (newValue.toLong() < smallestPossibleValue.toLong()) {\n                    smallestPossibleValue = newValue\n                    smallestPosition = i\n                    replacedPosition = j\n                } \n            }\n        }\n        return longArrayOf(smallestPossibleValue.toLong(), smallestPosition.toLong(),\n            replacedPosition.toLong()\n        )\n    }\n}*\/","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207003,"user_id":null,"body":"package solution\n\ntypealias Position = Int\ntypealias Digit = Int\n\ninternal fun <T> List<T>.tail() = subList(1, size)\n\nobject ToSmallest {\n\n    fun smallest(n: Long): LongArray {\n        val expanded = n.expand()\n        var minimum = expanded\n        var minimumFrom = 0\n        var minimumTo = 0\n        expanded.indices.forEach { from ->\n            expanded.indices.forEach { to ->\n                if (from == to) { \/* We do not need to try this out *\/ }\n                else {\n                    val swapped = expanded.rearrange(from, to)\n                    if (swapped < minimum) {\n                        minimum = swapped\n                        minimumFrom = from\n                        minimumTo = to\n                    }\n                }\n            }\n\n        }\n        return longArrayOf(reconstructLong(0L, minimum), minimumFrom.toLong(), minimumTo.toLong())\n    }\n\n    private fun Long.expand(): List<Digit> =\n        toString().map { it - '0' }\n\n    private fun List<Digit>.rearrange(from: Position, to: Position): List<Digit> =\n        mutableListOf<Digit>().apply { addAll(this@rearrange) }.apply {\n            val removed = removeAt(from)\n            add(to, removed)\n        }\n\n    private operator fun List<Digit>.compareTo(other: List<Digit>): Int {\n        indices.forEach {\n            with(this[it].compareTo(other[it])) {\n                if (this != 0) return this\n            }\n        }\n        return 0\n    }\n    \n    private tailrec fun reconstructLong(soFar: Long, digits: List<Digit>): Long =\n        if (digits.isEmpty()) soFar\n        else reconstructLong(soFar * 10 +  digits[0], digits.subList(1, digits.size))\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207004,"user_id":null,"body":"package solution\n\nobject ToSmallest {\n\n    \/\/ this got ugly.  I look forward to seeing the more elegant answers\n    fun smallest(n: Long): LongArray =\n        if (n < 10) longArrayOf(n, 0, 0) else n.toString().toMutableList().let { listOfChar ->\n            listOfChar.minOf { it }.let { first ->\n                if (listOfChar[0] == first) smallest(\n                    listOfChar.drop(1).joinToString(\"\").toLong()\n                ).apply {\n                    this[0] = (listOfChar[0].toString() + this[0].toString()).toLong()\n                    this[1] = this[1] + 1\n                    this[2] = this[2] + 1\n                    optimize()\n                }\n                else {\n                    var indexOfFirst = listOfChar.indexOfLast { c -> c == first }\n                    while (listOfChar[indexOfFirst - 1] == first) indexOfFirst--\n                    val indexOfInsert =\n                        listOfChar.indexOfFirst { c -> c > listOfChar[0] }.let { if (it < 0) listOfChar.size else it }\n                    if (mutableListOf<Char>().apply {\n                            addAll(listOfChar)\n                            add(indexOfInsert, listOfChar[0])\n                            removeFirst()\n                        }.joinToString() <= mutableListOf<Char>().apply {\n                            addAll(listOfChar)\n                            removeAt(indexOfFirst)\n                            add(0, first)\n                        }.joinToString()) {\n                        listOfChar.add(indexOfInsert, listOfChar[0])\n                        listOfChar.removeFirst()\n                        longArrayOf(listOfChar.joinToString(\"\").toLong(), 0, indexOfInsert.toLong() - 1).optimize()\n                    } else {\n                        listOfChar.removeAt(indexOfFirst)\n                        listOfChar.add(0, first)\n                        longArrayOf(listOfChar.joinToString(\"\").toLong(), indexOfFirst.toLong(), 0)\n                    }\n                }\n            }\n        }\n}\n\nprivate fun LongArray.optimize(): LongArray {\n    val charArray = this[0].toString().toCharArray()\n    listOf(1, 2).forEach {\n        while ((this[it] > 0) && (charArray[this[it].toInt()] == charArray[this[it].toInt() - 1])) this[it]--\n    }\n    return this\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207005,"user_id":null,"body":"package solution\n\nobject ToSmallest {\n\n    fun smallest(n: Long): LongArray {\n        if (n.toString().toSortedSet().size == 1)\n            return longArrayOf(n, 0, 0)\n        var numberList = n.toString().toMutableList()\n        val array = mutableListOf<Triple<Long, Long, Long>>()\n        for (i in numberList.indices){\n            for (j in numberList.indices){\n                if (i == j)\n                    continue\n                val temp = numberList[i]\n                numberList.removeAt(i)\n                numberList.add(j, temp)\n                array.add(Triple(numberList.joinToString(\"\").toLong(), i.toLong(), j.toLong()))\n                numberList = n.toString().toMutableList()\n            }\n        }\n        return array.minByOrNull { it.first }!!.toList().toLongArray()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207006,"user_id":null,"body":"package solution\n\nobject ToSmallest {\n\n    fun smallest(n: Long): LongArray {\n        var indexI = 0L\n        var indexJ = 0L\n        var minNumber = n\n        val number = n.toString()\n\n        val numberAsArrayList : ArrayList<String>  = ArrayList()\n        for (i in 0 until number.length){\n            numberAsArrayList.add(number[i].toString())\n        }\n\n        for ( i in 0 until number.length){\n\n            for ( x in 0 until number.length){\n                val switchedNumberArrayList = ArrayList(numberAsArrayList)\n\n                switchedNumberArrayList.removeAt(i)\n                switchedNumberArrayList.add(x,number[i].toString())\n\n                val switchedNumber = switchedNumberArrayList.joinToString(\"\").toLong()\n\n                if (switchedNumber < minNumber){\n                    minNumber = switchedNumber\n                    indexI = i.toLong()\n                    indexJ = x.toLong()\n                }\n            }\n\n        }\n        return longArrayOf(minNumber, indexI, indexJ)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"57519060f2dac7ec95000c8e":[{"id":207007,"user_id":null,"body":"object DNADecomposer {\n\n    \/** Not being a biologist; I'm assuming DNA is always framed in 3 letters, but this can nonetheless be adjusted. *\/\n    private const val frameSize = 3\n\n    \/** Model the valid 'letters' of DNA and their complements. *\/\n    enum class DNA {\n        A,G,T,C;\n\n        val complement : DNA\n            get() = when(this) {\n                A -> T\n                G -> C\n                T -> A\n                C -> G\n            }\n    }\n\n    \/**\n     * Entry point for this Kata:\n     * Given a 'forward' DNA strand, computes and outputs a formatted string showing possible frames of\n     * both the forward and reverse strand.\n     *\/\n    fun decomposeDoubleStrand(doubleStrand:String):String {\n\n        val complement : String = doubleStrand\n                .map { letter -> DNA.valueOf(letter.toString()).complement }\n                .asReversed()\n                .joinToString(\"\")\n\n        \/\/ Given an un-framed strand-string, computes the list of potential 'framings', up to `frameSize`.\n        fun frames( doubleStrand: String ) : List<String> = (0 until frameSize)\n                .map { frameOffset ->\n                    with(StringBuilder()) {\n                        doubleStrand.forEachIndexed { index, c ->\n                            append(c)\n                            \n                            val isFrameBreak = (index - frameOffset + 1) % frameSize == 0\n                            val isEndOfLine = index == (doubleStrand.length - 1)\n                            if(isFrameBreak && !isEndOfLine) { append(' ') }\n                        }\n                        toString()\n                    }\n        }\n\n        \/\/ Wraps each output element of #frames with a human-readable title and reference number.\n        fun titledFrames( title: String, doubleStrand: String ) : List<String> = frames( doubleStrand )\n                .mapIndexed { index: Int, frame: String -> \"$title ${index+1}: $frame\" }\n\n        \/\/ Compute the forward and reverse frames of input `doubleStrand` with human-readable titles and reference numbers.\n        val titledForwardFrames = titledFrames( title = \"Frame\",         doubleStrand = doubleStrand )\n        val titledReverseFrames = titledFrames( title = \"Reverse Frame\", doubleStrand = complement   )\n        \n        \/\/ High-level output formatting and return.\n        return with(StringBuilder()) {\n            titledForwardFrames.forEach { appendln(it) }\n            appendln()\n            titledReverseFrames.forEachIndexed { index, s ->\n                if(index>0) { appendln() }\n                append(s)\n            }\n            toString()\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207008,"user_id":null,"body":"object DNADecomposer {\n  val complement = mapOf('A' to 'T', 'G' to 'C', 'T' to 'A', 'C' to 'G', ' ' to ' ')\n  fun decomposeDoubleStrand(doubleStrand:String):String {\n    val frame1 = doubleStrand.chunked(3).joinToString(\" \")\n    val frame2 = \"${doubleStrand[0]} ${doubleStrand.drop(1).chunked(3).joinToString(\" \")}\"\n    val frame3 = \"${doubleStrand.slice(0..1)} ${doubleStrand.drop(2).chunked(3).joinToString(\" \")}\"\n    return \"\"\"Frame 1: $frame1\n             |Frame 2: $frame2\n             |Frame 3: $frame3\n             |\n             |Reverse Frame 1: ${frame1.reversed().map{complement[it]}.joinToString(\"\")}\n             |Reverse Frame 2: ${frame3.reversed().map{complement[it]}.joinToString(\"\")}\n             |Reverse Frame 3: ${frame2.reversed().map{complement[it]}.joinToString(\"\")}\"\"\".trimMargin()\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207009,"user_id":261,"body":"object DNADecomposer {\n    private fun CharSequence.toFrame() = chunked(3).joinToString(\" \")\n\n    private fun String.toFrame1() = this[0] + \" \" + substring(1).toFrame()\n    private fun String.toFrame2() = substring(0, 2) + \" \" + substring(2).toFrame()\n\n    fun decomposeDoubleStrand(doubleStrand: String): String {\n        val frame = doubleStrand.map {\n            when (it) {\n                'A' -> 'T'\n                'G' -> 'C'\n                'T' -> 'A'\n                'C' -> 'G'\n                else -> \"\"\n            }\n        }.reversed().joinToString(\"\")\n\n        return \"\"\"\n            Frame 1: ${doubleStrand.toFrame()}\n            Frame 2: ${doubleStrand.toFrame1()}\n            Frame 3: ${doubleStrand.toFrame2()}\n            \n            Reverse Frame 1: ${frame.toFrame()}\n            Reverse Frame 2: ${frame.toFrame1()}\n            Reverse Frame 3: ${frame.toFrame2()}\n        \"\"\".trimIndent()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207010,"user_id":null,"body":"object DNADecomposer {\n    \n  fun decomposeDoubleStrand(d : String) : String {\n      val frames = getDecomposed(d, \"Frame\")\n      val rFrames = getDecomposed(getComplemented(d).reversed(), \"Reverse Frame\")\n      return \"$frames\n\n$rFrames\"\n  }\n  \n  fun getDecomposed(d : String, label : String) : String = (0..2).map {\n          \"$label ${it+1}: \" + (d.take(it) + \" \" + d.drop(it).chunked(3).joinToString(\" \")).trim()\n      }.joinToString(\"\n\")\n  \n  fun getComplemented(d : String) : String = d.map {\n          when (it) {\n              'A'->'T'\n              'G'->'C'\n              'T'->'A'\n              'C'->'G'\n              else -> it }\n      }.joinToString(\"\")\n}\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207011,"user_id":null,"body":"object DNADecomposer {\n        fun decomposeDoubleStrand(doubleStrand: String): String {\n        val answer = StringBuilder()\n        answer.append(\"Frame 1: ${splitDNA(doubleStrand, 0)}\n\")\n        answer.append(\"Frame 2: ${splitDNA(doubleStrand, 1)}\n\")\n        answer.append(\"Frame 3: ${splitDNA(doubleStrand, 2)}\n\n\")\n        answer.append(\"Reverse Frame 1: ${reverseDNA(splitDNA(doubleStrand, 0))}\n\")\n        answer.append(\"Reverse Frame 2: ${reverseDNA(splitDNA(doubleStrand, 2))}\n\")\n        answer.append(\"Reverse Frame 3: ${reverseDNA(splitDNA(doubleStrand, 1))}\")\n\n        return answer.toString()\n    }\n\n    fun splitDNA(dna: String, pos: Int): String{\n        var sb = StringBuilder(dna)\n        val ads: Int = sb.length \/ 3\n\n        for (i in pos..(sb.length + ads) step 4) {\n            sb.insert(i, ' ')\n        }\n\n        return sb.trimStart(' ').trimEnd(' ').toString()\n    }\n\n    fun reverseDNA(dna: String): String{\n        val answer = StringBuilder()\n        for (i in 0 until dna.length) {\n            when(dna[i]){\n                'A' -> answer.append('T')\n                'T' -> answer.append('A')\n                'G' -> answer.append('C')\n                'C' -> answer.append('G')\n                else -> answer.append(' ')\n            }\n        }\n\n        return answer.toString().reversed()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207012,"user_id":null,"body":"object DNADecomposer {\n    fun decomposeDoubleStrand(doubleStrand: String): String {\n        val frame1 = doubleStrand.chunked(3).joinToString(\" \")\n        val frame2 = (listOf(doubleStrand.take(1)) + doubleStrand.drop(1).chunked(3)).joinToString(\" \")\n        val frame3 = (listOf(doubleStrand.take(2)) + doubleStrand.drop(2).chunked(3)).joinToString(\" \")\n\n        val complementDNA = mapOf('A' to 'T', 'G' to 'C', 'T' to 'A', 'C' to 'G')\n        val doubleStrandReversed = doubleStrand.reversed().map { complementDNA[it] }.joinToString(\"\")\n\n        val revFrame1 = doubleStrandReversed.chunked(3).joinToString(\" \")\n        val revFrame2 = (listOf(doubleStrandReversed.take(1)) + doubleStrandReversed.drop(1).chunked(3)).joinToString(\" \")\n        val revFrame3 = (listOf(doubleStrandReversed.take(2)) + doubleStrandReversed.drop(2).chunked(3)).joinToString(\" \")\n\n        return \"Frame 1: $frame1\nFrame 2: $frame2\nFrame 3: $frame3\n\n\" +\n                \"Reverse Frame 1: $revFrame1\nReverse Frame 2: $revFrame2\nReverse Frame 3: $revFrame3\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207013,"user_id":null,"body":"object DNADecomposer {\n  fun decomposeDoubleStrand(doubleStrand:String):String {\n      val mapDNA = mapOf(\"A\" to \"T\", \"G\" to \"C\", \"T\" to \"A\", \"C\" to \"G\")\n    val decomposed: String = doubleStrand.toList().joinToString(\"\") { mapDNA[it.toString()]!! }.reversed()\n    \n    return \"Frame 1: \" + doubleStrand.chunked(3).joinToString(\" \") + \"\n\" +\n            \"Frame 2: \" + doubleStrand.take(1) + \" \" + doubleStrand.drop(1).chunked(3).joinToString(\" \") + \"\n\" +\n            \"Frame 3: \" + doubleStrand.take(2) + \" \" + doubleStrand.drop(2).chunked(3).joinToString(\" \") + \"\n\" + \"\n\" +\n            \"Reverse Frame 1: \" + decomposed.chunked(3).joinToString(\" \") + \"\n\" +\n            \"Reverse Frame 2: \" + decomposed.take(1) + \" \" + decomposed.drop(1).chunked(3).joinToString(\" \") + \"\n\" +\n            \"Reverse Frame 3: \" + decomposed.take(2) + \" \" + decomposed.drop(2).chunked(3).joinToString(\" \")\n\n}\n  }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207014,"user_id":null,"body":"object DNADecomposer {\n    fun decomposeDoubleStrand(doubleStrand:String): String {\n        val frame = { n: Int, str: String ->\n            str.take(n) + (if (n > 0) \" \" else \"\") +\n                    str.drop(n).chunked(3).joinToString(\" \")\n        }\n\n        val rev = listOf(\n                doubleStrand, \"At\", \"TA\", \"tT\", \"Gc\", \"CG\", \"cC\"\n            ).reduce { rev, s -> rev.replace(s[0], s[1]) }.reversed()\n\n        return \"\"\"\n            Frame 1: ${frame(0, doubleStrand)}\n            Frame 2: ${frame(1, doubleStrand)}\n            Frame 3: ${frame(2, doubleStrand)}\n            \n            Reverse Frame 1: ${frame(0, rev)}\n            Reverse Frame 2: ${frame(1, rev)}\n            Reverse Frame 3: ${frame(2, rev)}\n        \"\"\".trimIndent()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207015,"user_id":null,"body":"object DNADecomposer {\nfun decomposeDoubleStrand(doubleStrand: String = \"AGGTGACACCGCAAGCCTTATATTAGC\"): String {\n    val frame1 = doubleStrand.chunked(3).joinToString(\" \")\n\n    val frame2 = doubleStrand.takeLast(doubleStrand.length - 1)\n        .chunked(3).toMutableList().also {\n        it.add(0, doubleStrand.take(1))\n    }.joinToString(\" \")\n\n    val frame3 = doubleStrand.takeLast(doubleStrand.length - 2)\n        .chunked(3).toMutableList().also {\n        it.add(0, doubleStrand.take(2))\n    }.joinToString(\" \")\n\n    val reverse = doubleStrand.map { it.toString() }.toMutableList().also {\n        it.forEachIndexed { index, s ->\n            when (s) {\n                \"A\" -> it[index] = \"T\"\n                \"G\" -> it[index] = \"C\"\n                \"T\" -> it[index] = \"A\"\n                \"C\" -> it[index] = \"G\"\n            }\n        }\n    }.joinToString(\"\").reversed()\n\n    val reverseFrame1 = reverse.chunked(3).joinToString(\" \")\n\n    val reverseFrame2 = reverse.takeLast(reverse.length - 1)\n        .chunked(3).toMutableList().also {\n        it.add(0, reverse.take(1))\n    }.joinToString(\" \")\n\n    val reverseFrame3 = reverse.takeLast(reverse.length - 2)\n        .chunked(3).toMutableList().also {\n        it.add(0, reverse.take(2))\n    }.joinToString(\" \")\n\n    return \"Frame 1: $frame1\nFrame 2: $frame2\nFrame 3: $frame3\n\nReverse Frame 1: \" +\n            \"$reverseFrame1\nReverse Frame 2: $reverseFrame2\nReverse Frame 3: $reverseFrame3\"\n}}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207016,"user_id":null,"body":"object DNADecomposer {\n  fun decomposeDoubleStrand(s:String):String {  \n      val f1 = s.mapIndexed{ i, e -> if((i + 1) % 3 == 0) e + \" \" else e}.joinToString(\"\").trim()\n      val f2 = s.mapIndexed{ i, e -> if( i == 0 || i % 3 == 0) e + \" \" else e}.joinToString(\"\").trim()\n      val f3 = s.mapIndexed{ i, e -> if( i == 1 || (i - 1) % 3 == 0) e + \" \" else e}.joinToString(\"\").trim()\n      val revF1 = s.map{ when(it){ 'A' -> 'T'\n                             'T' -> 'A'\n                             'G' -> 'C'\n                             'C' -> 'G'\n                             else -> it}}.reversed().joinToString(\"\").mapIndexed{ i, e -> if((i + 1) % 3 == 0) e + \" \" else e}.joinToString(\"\").trim()\n      val revF2 = s.map{ when(it){ 'A' -> 'T'\n                             'T' -> 'A'\n                             'G' -> 'C'\n                             'C' -> 'G'\n                             else -> it}}.reversed().joinToString(\"\").mapIndexed{ i, e -> if( i == 0 || i % 3 == 0) e + \" \" else e}.joinToString(\"\").trim()\n      val revF3 = s.map{ when(it){ 'A' -> 'T'\n                             'T' -> 'A'\n                             'G' -> 'C'\n                              'C' -> 'G'\n                             else -> it}}.reversed().joinToString(\"\").mapIndexed{ i, e -> if( i == 1 || (i - 1) % 3 == 0) e + \" \" else e}.joinToString(\"\").trim()\n      return \"Frame 1: ${f1}\nFrame 2: ${f2}\nFrame 3: ${f3}\n\nReverse Frame 1: ${revF1}\nReverse Frame 2: ${revF2}\nReverse Frame 3: ${revF3}\"\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"57591ef494aba64d14000526":[{"id":207017,"user_id":null,"body":"package johnann\n\nprivate val johnCache = mutableMapOf(0L to 0L)\nprivate val annCache = mutableMapOf(0L to 1L)\n\nfun johnIter(n: Long): Long = johnCache.getOrPut(n) { n - annIter(johnIter(n - 1)) }\nfun annIter(n: Long): Long = annCache.getOrPut(n) { n - johnIter(annIter(n - 1)) }\n\nfun john(n:Long) = (0 until n).map { johnIter(it) }\nfun ann(n:Long) = (0 until n).map { annIter(it) }\n\nfun sumJohn(n: Long) = john(n).sum()\nfun sumAnn(n: Long) = ann(n).sum()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207018,"user_id":null,"body":"package johnann\n\nfun john(n:Long):List<Long> {\n    return johnAnn(n).second\n}\n\nfun ann(n:Long):List<Long> {\n    return johnAnn(n).first\n}\n\nfun sumJohn(n:Long):Long {\n    return john(n).sum()\n}\n\nfun sumAnn(n:Long):Long {\n  return ann(n).sum()\n}\n\nfun johnAnn(n: Long): Pair<List<Long>, List<Long>> {\n    val size = n.toInt()\n    val ann = arrayListOf<Long>(1L, 1L)\n    val john = arrayListOf<Long>(0L, 0L)\n    var i = 2\n    while (i < size) {\n        ann.add(i - john[ann[i - 1].toInt()])\n        john.add(i - ann[john[i - 1].toInt()])\n        i++\n    }\n    return Pair(ann, john)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207019,"user_id":null,"body":"package johnann\n\nfun john(n: Long): List<Long> = (0 until n).map { johnAtDay(it) }\nfun ann(n: Long): List<Long> = (0 until n).map { annAtDay(it) }\n\nfun sumJohn(n: Long) = john(n).sum()\nfun sumAnn(n: Long) = ann(n).sum()\n\nval johnLookup = mutableMapOf<Long, Long>(0L to 0)\nval annLookup = mutableMapOf<Long, Long>(0L to 1)\n\nfun johnAtDay(n: Long): Long = johnLookup.getOrPut(n) { n - annAtDay(johnAtDay(n - 1)) }\nfun annAtDay(n: Long): Long = annLookup.getOrPut(n) { n - johnAtDay(annAtDay(n - 1)) }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207020,"user_id":492,"body":"package johnann\n\nimport java.util.ArrayList\n\nprivate fun johnAnn(n:Long):List<List<Long>> {\n  val johnList = ArrayList<Long>()\n  val annList = ArrayList<Long>()\n  val res = ArrayList<List<Long>>()\n  annList.add(1L)\n  johnList.add(0L)\n  if (n == 0L)\n    {\n      res.add(annList)\n      res.add(johnList)\n    }\n  else\n  {\n    var i:Long = 1\n    while (i < n)\n    {\n      val j = johnList.get((i - 1).toInt())\n      val a1 = annList.get(j.toInt())\n      johnList.add(i - a1)\n      val a = annList.get((i - 1).toInt())\n      val j1 = johnList.get(a.toInt())\n      annList.add(i - j1)\n      i++\n    }\n    res.add(annList)\n    res.add(johnList)\n  }\n  return res\n}\nfun john(n:Long):List<Long> {\n  return johnAnn(n).get(1)\n}\nfun ann(n:Long):List<Long> {\n  return johnAnn(n).get(0)\n}\nfun sumJohn(n:Long):Long {\n  return johnAnn(n).get(1).sum()\n}\nfun sumAnn(n:Long):Long {\n  return johnAnn(n).get(0).sum()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207021,"user_id":53,"body":"package johnann\n\ndata class Data(val xs: List<Long>, val ys: List<Long>, val xsum: Long, val ysum: Long)\n\nfun walk(n:Long):Data {\n    val xs = mutableListOf<Long>(0)\n    val ys = mutableListOf<Long>(1)\n    var xsum: Long = 0\n    var ysum: Long = 1\n    for (i in 1..n-1) {\n        val a = i - ys.get(xs.get((i - 1).toInt()).toInt())\n        xs.add(a)\n        xsum += a\n        val b = i - xs.get(ys.get((i - 1).toInt()).toInt())\n        ys.add(b)\n        ysum += b\n    }\n    return Data(xs, ys, xsum, ysum)\n}\n\nfun john(n:Long):List<Long> {\n    return walk(n).xs\n}\n\nfun ann(n:Long):List<Long> {\n    return walk(n).ys\n}\n\nfun sumJohn(n:Long):Long {\n    return walk(n).xsum\n}\n\nfun sumAnn(n:Long):Long {\n    return walk(n).ysum\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207022,"user_id":492,"body":"package johnann\n\nimport java.util.ArrayList\n\nprivate fun johnAnn(n:Long):List<List<Long>> {\n  val johnList = ArrayList<Long>()\n  val annList = ArrayList<Long>()\n  val res = ArrayList<List<Long>>()\n  annList.add(1L)\n  johnList.add(0L)\n  if (n == 0L)\n    {\n      res.add(annList)\n      res.add(johnList)\n    }\n  else\n  {\n    var i:Long = 1\n    while (i < n)\n    {\n      val j = johnList.get((i - 1).toInt())\n      val a1 = annList.get(j.toInt())\n      johnList.add(i - a1)\n      val a = annList.get((i - 1).toInt())\n      val j1 = johnList.get(a.toInt())\n      annList.add(i - j1)\n      i++\n    }\n    res.add(annList)\n    res.add(johnList)\n  }\n  return res\n}\nfun john(n:Long):List<Long> {\n  return johnAnn(n).get(1)\n}\nfun ann(n:Long):List<Long> {\n  return johnAnn(n).get(0)\n}\nfun sumJohn(n:Long):Long {\n  return johnAnn(n).get(1).sum()\n}\nfun sumAnn(n:Long):Long {\n  return johnAnn(n).get(0).sum()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207023,"user_id":null,"body":"package johnann\n\nprivate class Memo(private val initial: Long) {\n    constructor(initial: Long, other: Memo) : this(initial) {\n        this.other = other\n        other.other = this\n    }\n    private val memory = mutableMapOf<Long, Long>()\n    private lateinit var other: Memo\n\n    fun find(n: Long): Long {\n        if (n < 0L) {\n            throw IllegalArgumentException()\n        } else if (n == 0L) {\n            return initial\n        } else if (n in memory) {\n            return memory.getValue(n)\n        } else {\n            val t = find(n - 1)\n            val res = n - other.find(t)\n            memory.put(n, res)\n            return res\n        }\n    }\n}\n\nprivate val johnMemo = Memo(0)\nprivate val annMemo = Memo(1, johnMemo)\n\nfun john(n: Long): List<Long> {\n    return (0 until n).map { johnMemo.find(it) }\n}\nfun ann(n: Long): List<Long> {\n    return (0 until n).map { annMemo.find(it) }\n}\nfun sumJohn(n: Long): Long {\n    return john(n).sum()\n}\nfun sumAnn(n: Long): Long {\n    return ann(n).sum()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207024,"user_id":null,"body":"package johnann\n\nfun johnOrAnn(n:Long, a:Boolean) : List<Long>{\n  val ann = mutableListOf<Long>()\n  ann.add(1L)\n\n  val john = mutableListOf<Long>()\n  john.add(0L)\n\n  for (i in 1..n-1) {\n    john.add(i - ann[john[i.toInt()-1].toInt()])\n    ann.add(i - john[ann[i.toInt()-1].toInt()])\n  }\n\n  return if (a) { ann } else {john }\n}\n\nfun john(n:Long) = johnOrAnn(n, false)\n\nfun ann(n:Long) = johnOrAnn(n, true)\n\nfun sumJohn(n:Long) = john(n).sum()\n\nfun sumAnn(n:Long) = ann(n).sum()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207025,"user_id":null,"body":"package johnann\n\n\nfun annAndJohn(n:Long): Pair<List<Long>, List<Long>> {\n    var ann = mutableListOf<Long>(1)\n    var john = mutableListOf<Long>(0)\n    \n    for (day in IntRange(1,n.toInt() - 1)) {\n        john += day - ann[john[day - 1].toInt()]\n        ann += day - john[ann[day - 1].toInt()]\n    }\n    return Pair(ann, john)\n}\n\nfun john(n:Long):List<Long> {\n  return annAndJohn(n).second\n}\nfun ann(n:Long):List<Long> {\n  return annAndJohn(n).first\n}\nfun sumJohn(n:Long):Long {\n  return john(n).sum()\n}\nfun sumAnn(n:Long):Long {\n  return ann(n).sum()\n}\n\nfun main() {\n\n    println(john(11))\n\tprintln(ann(6))\n    println(sumJohn(75))\n    println(sumAnn(150))\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207026,"user_id":null,"body":"package johnann\n\nfun john(n: Long): List<Long> {\n    var i = 1\n    val a = mutableListOf<Long>(1)\n    val j = mutableListOf<Long>(0)\n    while (i < n) {\n        j.add(i - (a[j[i - 1].toInt()]))\n        a.add(i - (j[a[i - 1].toInt()]))\n        i++\n    }\n    return j\n}\n\nfun ann(n: Long): List<Long> {\n    var i = 1\n    val a = mutableListOf<Long>(1)\n    val j = mutableListOf<Long>(0)\n    while (i < n) {\n        j.add(i - (a[j[i - 1].toInt()]))\n        a.add(i - (j[a[i - 1].toInt()]))\n        i++\n    }\n    return a\n}\n\nfun sumJohn(n: Long): Long {\n    return john(n).sum()\n\n}\n\nfun sumAnn(n: Long): Long {\n    return ann(n).sum()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"576bb71bbbcf0951d5000044":[{"id":207027,"user_id":null,"body":"fun count_positives_sum_negatives(input : Array<Int>?) : Array<Int> {\n    if (input == null || input.isEmpty()) return emptyArray()\n    val (positive, negative) = input.partition { it > 0 }\n    return arrayOf(positive.count(), negative.sum())\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207028,"user_id":null,"body":"fun count_positives_sum_negatives(input : Array<Int>?) : Array<Int> =\n    if (input == null || input.isEmpty())\n        arrayOf()\n    else\n        arrayOf(input.filter{ it > 0 }.count(), input.filter{ it < 0 }.sum())\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207029,"user_id":null,"body":"fun count_positives_sum_negatives(input : Array<Int>?) : Array<Int> {\n    if (input.isNullOrEmpty()) return emptyArray<Int>();\n\n    var pos = 0\n    var neg = 0\n    \n    for (i in input)\n        if (i > 0)\n            pos++\n        else\n            neg += i\n\n    var a = arrayOf<Int>(pos, neg);\n    return a;\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207030,"user_id":null,"body":"fun count_positives_sum_negatives(input : Array<Int>?) : Array<Int> {\n\n    if (input != null && input.isNotEmpty()) {\n            var postiveCount = input.filter { it > 0 }.count();\n            var negativeSum = input.filter { it < 0 }.sum();\n            return arrayOf(postiveCount, negativeSum)\n    } \n\n    return arrayOf()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207031,"user_id":null,"body":"fun count_positives_sum_negatives(input: Array<Int>?) = input?.takeIf { it.isNotEmpty() }\n    ?.let { listOf(it.filter { it > 0 }.count(), it.filter { it < 0 }.sum()) }?.toTypedArray() ?: arrayOf()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207032,"user_id":null,"body":"fun count_positives_sum_negatives(input : Array<Int>?) : Array<Int> = if (input.isNullOrEmpty()) arrayOf() else input?.fold(arrayOf(0, 0), { a, c -> if (c > 0) arrayOf(a[0] + 1, a[1]) else arrayOf(a[0], a[1] + c) })","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207033,"user_id":null,"body":"fun count_positives_sum_negatives(input : Array<Int>?) : Array<Int> {\n    if(input == null )return arrayOf<Int>()\n    if(input!!.size == 0 )return arrayOf<Int>()\n    var count = 0\n    var sum = 0\n    for(i in 0..input!!.size-1){\n        if(input[i]>0) count++\n        else sum += input[i]\n    }\n    return arrayOf<Int>(count, sum) \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207034,"user_id":null,"body":"    fun count_positives_sum_negatives(input : Array<Int>?)=   if (input.isNullOrEmpty()) { emptyArray<Int>() }else arrayOf(input.count { it > 0 }, input.filter { it <= 0 }.sum())","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207035,"user_id":null,"body":"fun count_positives_sum_negatives(input: Array<Int>?): Array<Int> {\n    if (input == null || input.count { it == 0 } == input.size) return emptyArray()\n    return arrayOf(input.count { it > 0 }, input.filter { it < 0 }.sum())\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207036,"user_id":null,"body":"fun count_positives_sum_negatives(input : Array<Int>?) : Array<Int> {\n        val valuePos = mutableListOf<Int>() \/\/make empty array to save postif number\n        val valueNeg = mutableListOf<Int>() \/\/make empty array to save negatif number\n        if (input == null || input.isEmpty()) { \/\/check condition empty array of input array\n            return emptyArray()\n        } else {\n            for (i in input)\n                if (i > 0) valuePos.add(i)\n                else valueNeg.add(i)\n            val valueSum = valueNeg.sum()\n            val valueCount = valuePos.count()\n            return arrayOf(valueCount, valueSum)\n        }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5772382d509c65de7e000982":[{"id":207037,"user_id":null,"body":"package fibkind\n\nprivate val memory: MutableMap<Int, Int> = mutableMapOf(1 to 1, 2 to 1)\nfun u(i: Int): Int = memory.getOrPut(i) { u ( i - u(i - 1)) + u(i - u(i - 2)) }\nfun lengthSupUK(n: Int, k: Int) = (1..n).map(::u).filter { it >= k }.size.toLong()\nfun comp(n: Int) = (1..n).map(::u).windowed(2).filter { it.first() > it.last() }.size.toLong()\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207038,"user_id":null,"body":"package fibkind\n\n\nfun lengthSupUK(n: Int, k: Int): Long = getList(n).count { it >= k }.toLong()\n\n\nfun comp(n: Int): Long = getList(n).windowed(2).count { it[0] > it[1] }.toLong()\n\nfun getList(n: Int) = mutableListOf(0, 1, 1).apply { (3..n).forEach { add(this[it - this[it - 1]] + this[it - this[it - 2]]) } }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207039,"user_id":null,"body":"package fibkind\n\nfun lengthSupUK(n: Int, k: Int): Long {\n    val x = mutableListOf(0L, 1L, 1L)\n    var i = 3\n    var count = 0L\n    while (n >= i) {\n        x += x[(i - x[i - 1]).toInt()] + x[(i - x[i - 2]).toInt()]\n        if (x[i] >= k) {\n            count++\n        }\n        i++\n    }\n    return count\n}\n\nfun comp(n: Int): Long {\n    val x = mutableListOf(0L, 1L, 1L)\n    var i = 3\n    var count = 0L\n    while (n >= i) {\n        x += x[(i - x[i - 1]).toInt()] + x[(i - x[i - 2]).toInt()]\n        if (x[i] < x[i - 1]) {\n            count++\n        }\n        i++\n    }\n    return count\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207040,"user_id":null,"body":"package fibkind\n\nclass Memoizer{\n    companion object {\n        val uMap=HashMap<Int, Long>()\n        fun u(n:Int):Long{\n            if (!uMap.contains(n))\n                uMap[n]=if (n<=2) 1L else u(n-u(n-1).toInt())+u(n-u(n-2).toInt())\n            return uMap[n]!!\n        }\n    }\n}\n\nfun lengthSupUK(n:Int, k:Int):Long {\n    return (1..n).filter{Memoizer.u(it)>=k}.count().toLong()\n}\nfun comp(n:Int):Long {\n    return (2..n).filter{Memoizer.u(it)<Memoizer.u(it-1)}.count().toLong()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207041,"user_id":null,"body":"package fibkind\n\nfun fillArray(n: Int): Array<Int> {\n    val arr = Array(n + 1) { 1 }\n    for (i in 3 until arr.size) {\n        arr[i] = arr[i - arr[i - 1]] + arr[i - arr[i - 2]]\n    }\n    return arr\n}\n\nfun lengthSupUK(n:Int, k:Int):Long {\n    var counter = 0L\n    for (i in fillArray(n))\n        if (i >= k)\n            counter++\n    return counter\n}\nfun comp(n:Int):Long {\n    val arr = fillArray(n)\n    var counter = 0L\n    for (i in 3 until arr.size)\n        if (arr[i] < arr[i - 1])\n            counter++\n    return counter\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207042,"user_id":null,"body":"package fibkind\n\nobject USequence {\n    private val cache = mutableListOf(0, 1, 1)\n    private fun generateSequence(index: Int) {\n        val pre = index - cache[index - 1]\n        val ppre = index - cache[index - 2]\n        cache.add(cache[ppre] + cache[pre])\n    }\n\n    fun takeSequence(n: Int): List<Int> {\n        if (cache.size <= n) (cache.size..n).forEach(USequence::generateSequence)\n        return cache.subList(1, n + 1)\n    }\n}\n\nfun lengthSupUK(n: Int, k: Int): Long {\n    return USequence.takeSequence(n).count { it >= k }.toLong()\n}\n\nfun comp(n: Int): Long {\n    return USequence.takeSequence(n).zipWithNext().count { it.first > it.second }.toLong()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207043,"user_id":null,"body":"package fibkind\n\nfun fib(n: Int) : Array<Int?>{\n    val array = arrayOfNulls<Int>(n)\n    array[0] = 1\n    array[1] = 1\n\n    for(i in 2 until n) {\n        val a = array[i - array[i-1]!!]\n        val b = array[i - array[i-2]!!]\n        array[i] = a!! + b!!\n    }\n\n    return array\n}\n\nfun lengthSupUK(n:Int, k:Int):Long {\n    var count = 0L\n    val array = fib(n)\n\n    for(i in array.indices) {\n        if(array[i]!! >= k){\n            count++\n        }\n    }\n\n    return count\n}\n\nfun comp(n:Int):Long {\n    var count = 0L\n    val array = fib(n)\n\n    for(i in 1 until array.size) {\n        if(array[i]!! < array[i-1]!!){\n            count++\n        }\n    }\n    return count\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207044,"user_id":null,"body":"package fibkind\n\n\nfun getArr(n: Int): IntArray{\n    val result = mutableListOf<Int>()\n    result.add(1)\n    result.add(1)\n    for (i in 2 until n){\n        result.add(result[i - result[i - 1]] + result[i - result[i - 2]])\n    }\n    return result.toIntArray()\n}\nfun lengthSupUK(n:Int, k:Int):Long {\n    var count: Long = 0\n    for (element in getArr(n)){\n        if (element >= k) count++\n    }\n    return count\n}\nfun comp(n:Int):Long {\n    var count: Long = 0\n    val arr = getArr(n)\n    for (i in 1 until arr.size){\n        if (arr[i] < arr[i - 1]) count++\n    }\n    return count\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207045,"user_id":50,"body":"package fibkind\n\nfun f(n:Int): List<Int> {\n    val v = mutableListOf(1, 1)\n    for (i in 2..(n - 1)){\n        v.add(v[i - v[i - 1]] + v[i -v[i - 2]])\n    }\n    return v\n}\n\nfun lengthSupUK(n:Int, k:Int):Long {\n    return f(n) . filter { it >= k } . size . toLong()\n}\n\nfun comp(n:Int):Long {\n    val v = f(n)\n    return v . filterIndexed { i, n -> i > 1 && n < v[i-1]} . toList() . size . toLong()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207046,"user_id":null,"body":"package fibkind\n\nfun lengthSupUK(n:Int, k:Int):Long {\n    val u = Array(n) { 1 }\n    var result: Long = 0\n    for ((i) in u.withIndex()) {\n        if (i <= 1) continue\n        u[i] = (u[i - u[i - 1]]) + (u[i - u[i - 2]])\n        if (i in 1..n && u[i] >= k) result++\n    }\n    return result\n}\nfun comp(n:Int):Long {\n     val u = Array(n) { 1 }\n    var result: Long = 0\n    for ((i) in u.withIndex()) {\n        if (i <= 1) continue\n        u[i] = (u[i - u[i - 1]]) + (u[i - u[i - 2]])\n        if (u[i] < u[i - 1]) result++\n    }\n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"57a0556c7cb1f31ab3000ad7":[{"id":207047,"user_id":527,"body":"fun make_upper_case(str: String) = str.toUpperCase()","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207048,"user_id":null,"body":"fun make_upper_case(txt: String): String {\n    return txt.toUpperCase() \/\/ Kotlin 1.3\n    \/\/ return txt.uppercase() Kotlin 1.4+\n}","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207049,"user_id":null,"body":"fun make_upper_case(str: String) = str.uppercase()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207050,"user_id":null,"body":"fun make_upper_case(str: String): String = str.uppercase()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207051,"user_id":null,"body":"fun make_upper_case(str: String): String {\n    var result =  String()\n    for (ch in str) {\n\n        if(ch in 'a'..'z') {\n            result += ch - 32\n        } else{\n            result += ch\n        }\n    }\n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207052,"user_id":null,"body":"val make_upper_case : (String) -> String = String::toUpperCase","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207053,"user_id":null,"body":"fun main(){\n    println(make_upper_case(\"hello\"))\n}\nfun make_upper_case(str: String): String = str.uppercase()\n   \n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207054,"user_id":null,"body":"fun make_upper_case(str: String): String {\n   return str.map {if(it.toInt() in 97..122){(it.toInt() -32).toChar()} else {it}}.joinToString(\"\")\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207055,"user_id":null,"body":"fun make_upper_case(str: String): String {\n    var upperCaseArray: String = \"\"\n    for (char in str) upperCaseArray = upperCaseArray + (char.toUpperCase())\n    return upperCaseArray\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207056,"user_id":null,"body":"fun make_upper_case(str: String): String {\n    return str.map{ c -> c.uppercase()}.joinToString(\"\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"57a0e5c372292dd76d000d7e":[{"id":207057,"user_id":null,"body":"fun repeat_str(r: Int, str: String) = str.repeat(r)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207058,"user_id":1267,"body":"fun repeat_str(r: Int, str: String) : String = str.repeat(r)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207059,"user_id":null,"body":"fun repeat_str(r: Int, str: String): String {\n    var a = \"\"\n    var n = 0\n    while (n < r) {\n        a += str\n        n += 1\n    }\n    return a\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207060,"user_id":null,"body":"fun repeat_str(r: Int, str: String) = (1..r).map { str }.joinToString(\"\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207061,"user_id":null,"body":"fun repeat_str(r: Int, str: String) = r.downTo(1).joinToString(\"\") { str }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207062,"user_id":null,"body":"fun repeat_str(r: Int, str: String) : String {\n    var copy1 = str\n    var copy2 = \"\"\n    if(r == 0){\n        return \"\"\n    } else if (r == 1) {\n        return str\n    }\n    for( i in 0..r-2){\n        copy2 = copy1 + str\n        copy1 = copy2\n    }\n    return copy2\n    \n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207063,"user_id":null,"body":"fun repeat_str(r: Int, str: String) : String {\n    var a = \"\"\n    for (i in 1..r) {\n        a += str\n\n    }\n    return a;}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207064,"user_id":null,"body":"\nfun repeat_str(r: Int, str: String) : String\n{\n    var sumS = \"\"\n    for (x in 1 .. r ) {\n        sumS += str\n    }\n    return sumS\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207065,"user_id":null,"body":"fun repeat_str(r: Int, str: String) : String = if ( r == 0 ) \"\" else repeat_str(r-1, str) + str","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207066,"user_id":null,"body":"fun repeat_str(count: Int, base: String, acc: String = \"\"): String {\n    return if (count == 0) acc else repeat_str(count - 1, base, acc + base)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"57c15d314677bb2bd4000017":[{"id":207067,"user_id":null,"body":"import kotlin.math.roundToInt\n\n\/\/ It can mathematically be proven that only (x^2)-th student leave the door finally open.\n\/\/ Note that i-th door state does not change any more after the i-th student comes to school.\nfun doors(n: Int): Int = Math.floor(Math.sqrt(n.toDouble())).roundToInt()\n    ","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207068,"user_id":932,"body":"fun doors(n: Int)=Math.sqrt(n.toDouble()).toInt()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207069,"user_id":932,"body":"fun doors(n: Int): Int {\n    val doorsOpen = Array(n){false}\n    repeat(n){s->for (i in s until n step s+1) doorsOpen[i] = !doorsOpen[i]}\n    return doorsOpen.filter{it}.size\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207070,"user_id":null,"body":"fun doors(n: Int): Int {\n    var arr = Array(n + 1) { false }\n    var indexDoor: Int\n    for (indexPupil in 1..n) {\n        indexDoor = indexPupil\n        do {\n            arr[indexDoor] = !arr[indexDoor]\n            indexDoor += indexPupil\n        } while (indexDoor <= n)\n    }\n    return arr.count { it }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207071,"user_id":null,"body":"fun doors(n: Int): Int {\n    val arr = IntArray(n) { -1 }\n    for (i in 1..n) {\n        for (k in i - 1..arr.lastIndex step i) {\n            arr[k] *= -1\n        }\n    }\n    return arr.count { it == 1 }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207072,"user_id":null,"body":"fun doors(n: Int): Int {\n    val doors = BooleanArray(n) { _ -> true}\n    for (i in 2..n) {\n        for(j in 1..n\/i){\n            val idx = i*j -1\n            doors[idx] = doors[idx].xor(true)\n        }\n    }\n    return doors.count { it }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207073,"user_id":null,"body":"fun doors(n: Int): Int {\n    var middle: Float\n    var l = 0f\n    var r = n.toFloat()\n    do {\n        middle = (l + r) \/ 2f\n        if (middle * middle >= n) r = middle\n        else l = middle\n        println(\"l : $l r: $r\")\n    } while (Math.abs(middle * middle - n) > 1)\n    val bigMiddle = middle.toInt() + 1\n    return if (bigMiddle * bigMiddle <= n ) bigMiddle else middle.toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207074,"user_id":null,"body":"fun doors(n: Int) = Math.floor(Math.sqrt(n.toDouble())).toInt()\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207075,"user_id":null,"body":"fun doors(n: Int): Int {\n    val x = Array(n + 1) { 0 }\n    \n    for (i in 1 .. n) {\n        var j = 1\n        while (j * i <= n) {\n            x[j * i] = x[j * i] + 1\n            j++\n        }\n    }\n\n    return x.count { it % 2 == 1 }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207076,"user_id":null,"body":"fun doors(n: Int): Int {\n    val x = BooleanArray(n) { true }\n    (2..n).forEach { s -> (s - 1 until n step s).forEach { i -> x[i] = !x[i] }}\n    return x.count { it }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"57cc79ec484cf991c900018d":[{"id":207077,"user_id":null,"body":"package com.codewars.a.partridge\n\nobject DoubleSort {\n    fun dbSort(a: Array<Any>): Array<Any> = (a.filterIsInstance<Int>().sortedBy { it } + a.filterIsInstance<String>().sorted()).toTypedArray()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207078,"user_id":null,"body":"package com.codewars.a.partridge\n\nobject DoubleSort {\n  fun dbSort(a:Array<Any>):Array<Any> {\n    return a.sortedArrayWith(Comparator<Any>{\n        x,y -> \n            when{\n                x is Int && y is Int -> x-y\n                x is Int -> -1\n                x is String && y is String -> if(x>y) 1 else -1\n                y is String -> 1\n                else -> 1\n            }\n    }) as Array<Any>\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207079,"user_id":null,"body":"package com.codewars.a.partridge\n\nobject DoubleSort {\n    fun dbSort(a: Array<Any>): Array<Any> {\n        return ((a.filter { Int::class.isInstance(it) } as List<Int>).sorted() + (a.filter { String::class.isInstance(it) } as List<String>).sorted()).toTypedArray()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207080,"user_id":null,"body":"package com.codewars.a.partridge\n\nobject DoubleSort {\n  fun dbSort(a:Array<Any>):Array<Any> {\n    val stringArr = a.filterIsInstance<String>().sorted()\n    val intArr = a.filterIsInstance<Int>().sorted()\n    \n    return (intArr+stringArr).toTypedArray()\n}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207081,"user_id":759,"body":"package com.codewars.a.partridge\n\nobject DoubleSort {\n  fun dbSort(a:Array<Any>): Array<Any> =\n    a.partition { it !is String }.let { (n, s) -> (n as List<Int>).sorted() + (s as List<String>).sorted() }.toTypedArray()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207082,"user_id":null,"body":"package com.codewars.a.partridge\n\nobject DoubleSort {\n    fun dbSort(a: Array<Any>) = (a.partition { it is Int }.first.sortedBy { it.toString().toInt() } +\n            a.partition { it is Int }.second.sortedBy { it.toString() }).toTypedArray()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207083,"user_id":null,"body":"package com.codewars.a.partridge\n\nobject DoubleSort {\n    fun dbSort(a: Array<Any>) = a.partition { it is Int }\n        .run { first.sortedBy { it as Int } + second.sortedBy(Any::toString) }.toTypedArray()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207084,"user_id":null,"body":"package com.codewars.a.partridge\n\nobject DoubleSort {\n    fun dbSort(a:Array<Any>):Array<Any> {\n        val nums = a.filterIsInstance<Int>().sorted()\n        val words = a.filterIsInstance<String>().sorted()\n        return (nums+words).toTypedArray()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207085,"user_id":null,"body":"package com.codewars.a.partridge\n\nobject DoubleSort {\n  fun dbSort(a:Array<Any>):Array<Any> {\n      \/\/ this one drove me crazy, had a lot of approaches to partition it in to two lists,\n      \/\/ but never managed to get this lists back flattened into one array\n      var b = a\n      var stillSorting: Boolean = true\n      while (stillSorting) {\n          stillSorting = false\n          for (i in 0..b.size-2) {\n              if (b[i]is String && b[i+1] is Int) {\n                  var cache = b[i]\n                  b[i] = b[i+1]\n                  b[i+1] = cache\n                  stillSorting = true\n              } else if (b[i] is Int && b[i+1] is Int){\n                   if (b[i].toString().toInt() > b[i+1].toString().toInt()) {\n                      var cache = b[i]\n                      b[i] = b[i+1]\n                      b[i+1] = cache\n                      stillSorting = true                   \n                   } \n              } else if (b[i] is String && b[i+1] is String){\n                   if (b[i].toString() > b[i+1].toString()) {\n                      var cache = b[i]\n                      b[i] = b[i+1]\n                      b[i+1] = cache\n                      stillSorting = true                   \n                   } \n              }\n          }\n      }\n      return b\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207086,"user_id":null,"body":"package com.codewars.a.partridge\n\nobject DoubleSort {\n    fun dbSort(a:Array<Any>):Array<Any> {\n        val ints = mutableListOf<Int>()\n        val strings = mutableListOf<String>()\n        a.forEach {\n            if (it is Int) {\n                ints.add(it)\n            } else {\n                strings.add(it.toString())\n            }\n        }\n        return (ints.sorted() + strings.sorted()).toTypedArray()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"57cc981a58da9e302a000214":[{"id":207087,"user_id":null,"body":"fun smallEnough(a: IntArray, limit: Int) = a.all { it <= limit }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207088,"user_id":null,"body":"fun smallEnough(a : IntArray, limit : Int) = a.none { it > limit }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207089,"user_id":null,"body":"fun smallEnough(a : IntArray, limit : Int) : Boolean {\n  return a.none { it > limit }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207090,"user_id":null,"body":"fun smallEnough(a: IntArray, limit: Int): Boolean {\n        return a.max()!! <= limit\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207091,"user_id":null,"body":"fun smallEnough(a : IntArray, limit : Int) = a.sorted()[a.size-1] <= limit\n   ","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207092,"user_id":null,"body":"fun smallEnough(a : IntArray, limit : Int) : Boolean {\nvar boolean = false\n\n for (i in a) {\n\nif(i > limit){\n\nboolean = false\nbreak\n\n} else {\nboolean = true\n} \n\n}\nreturn boolean\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207093,"user_id":null,"body":"fun smallEnough(a : IntArray, limit : Int) : Boolean = a.maxOf{it} <= limit\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207094,"user_id":null,"body":"fun smallEnough(a : IntArray, limit : Int) : Boolean {\n      a.sort()\n      if (a.last() <= limit) return true else return false\n    \n    \n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207095,"user_id":null,"body":"fun smallEnough(nums: IntArray, limit: Int) = nums.all { it <= limit }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207096,"user_id":null,"body":"fun smallEnough(a : IntArray, limit : Int) : Boolean {\n    var value = true\n        a.forEach {\n            val b = it > limit\n            if(b) value = false\n        }\n        return value\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"57cebe1dc6fdc20c57000ac9":[{"id":207097,"user_id":1267,"body":"fun find_short(s: String): Int = s.split(\" \").minOf{it.length}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207098,"user_id":null,"body":"fun find_short(s: String): Int {\n    val words = s.split(' ')\n    var min = 1000\n    for(w in words) if(w.length < min) min = w.length\n    return min\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207099,"user_id":null,"body":"fun find_short(words: String): Int = words\n    .split(\" \")\n    .minOf(String::length)\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207100,"user_id":168,"body":"fun find_short(s: String): Int = s.split(\" \").minOf(String::length)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207101,"user_id":527,"body":"fun find_short(s: String): Int {\n    return s.splitToSequence(' ').minOf(CharSequence::length)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207102,"user_id":null,"body":"fun find_short(s: String): Int {\n    val str = s\n    val list = s.split(' ')\n    var min = 26\n    for (word in list){\n        if (word.length < min){\n            min = word.length\n        }\n     } \n    return min\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207103,"user_id":null,"body":"fun find_short(s: String): Int {\n    val arr = s.split(\" \")\n    var x = 100\n    for (i in arr){ \n       if (i.length < x){\n           x = i.length\n       }\n    }\n    return x \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207104,"user_id":null,"body":"fun find_short(s: String): Int {\nvar l=9999999\nfor(i in s.split(' '))\tif(i.length < l)\tl=i.length\nreturn l;\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207105,"user_id":null,"body":"fun find_short(s: String) =  s.split(\" \").sortedBy { it.length }[0].length","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207106,"user_id":null,"body":"fun find_short(s: String): Int {\n    val a: Int? = s.split(\" \").map { word -> word.length }.minOrNull()\n    println(a)\n\n    return a ?: 0\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"57cf50a7eca2603de0000090":[{"id":207107,"user_id":null,"body":"fun moveTen(s: String) = s.map { 'a' + (((it - 'a') + 10) % 26) }.joinToString(\"\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207108,"user_id":null,"body":"fun moveTen(s: String) = s.map{ if (it.toInt() + 10 > 'z'.toInt()) it - 16 else it + 10 }.joinToString(\"\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207109,"user_id":null,"body":"fun moveTen(s: String): String = s.toCharArray().map { (((it.toInt() + 10 - 97) % 26) + 97).toChar() }.joinToString(\"\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207110,"user_id":null,"body":"fun moveTen(s: String): String {\n    var aux: Char\n    val myLis = s.toMutableList()\n    s.forEachIndexed { index, c ->\n        aux = c + 10\n        if (!aux.isLetter()) {\n            aux = 'a' + (aux - 'z') - 1\n        }\n        myLis[index] = aux\n    }\n    return myLis.joinToString(\"\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207111,"user_id":null,"body":"fun moveTen(s: String) = s.map { if (it < 'q') it + 10 else it - 16 }.joinToString(\"\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207112,"user_id":null,"body":"  fun moveTen(s: String): String {\n        val abc = \"abcdefghijklmnopqrstuvwxyz\"\n        val sb = StringBuilder()\n        s.forEach {\n            var counter = 0\n            var temp = abc[abc.indexOf(it)]\n            while (counter < 10) {\n                temp = if (temp == 'z') 'a' else abc[abc.indexOf(temp) + 1]\n                counter++\n            }\n            sb.append(temp)\n        }\n\n        return sb.toString()\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207113,"user_id":null,"body":"fun moveTen(s: String): String = s\n    .map { c ->\n        ('a'..'z')\n            .toList()\n            .run { this[(this.indexOf(c)+10)%this.size] }\n    }.joinToString(\"\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207114,"user_id":null,"body":"fun moveTen(s: String): String {\n    var output = \"\"\n        s.forEach {\n            var o = it.plus(10)\n            val rem = o - 'z'\n            if (rem > 0) o = 'a'.plus(rem) - 1\n            output += o\n        }\n    return output\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207115,"user_id":null,"body":"fun moveTen(s: String) = s.map { if (it.toInt() + 10 <= 'z'.toInt()) it + 10 else ('a' - 1 + it.toInt() + 10 - 'z'.toInt()) }\n    .joinToString(\"\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207116,"user_id":null,"body":"fun moveTen(s: String) = s.map { it + if (it > 'p') -16 else 10 }.joinToString(\"\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"57d28215264276ea010002cf":[{"id":207117,"user_id":1251,"body":"package com.codewars.apartridge\n\nobject CodewarsLeaderboardClimber {\n    fun leaderBoard(user: String, userScore: Int, yourScore: Int): String {\n        val scoreNeeded = userScore - yourScore\n        if (scoreNeeded < 0) return \"Winning!\"\n        if (scoreNeeded == 0) return \"Only need one!\"\n        val q = scoreNeeded \/ 3\n        val r = scoreNeeded % 3\n        return \"To beat $user's score, I must complete $q Beta kata and $r 8kyu kata.\" + if (q + r > 1000) \" Dammit!\" else \"\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207118,"user_id":null,"body":"package com.codewars.apartridge\n\nobject CodewarsLeaderboardClimber {\n    fun leaderBoard(user: String, userScore: Int, yourScore: Int): String = when {\n        userScore < yourScore -> \"Winning!\"\n        userScore == yourScore -> \"Only need one!\"\n        else -> {\n            val diff = userScore - yourScore\n            val beta = diff \/ 3\n            val eight = diff % 3\n            \"To beat $user's score, I must complete $beta Beta kata \" +\n                    \"and $eight 8kyu kata.\" + if ((beta + eight) > 1000) \" Dammit!\" else \"\"\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207119,"user_id":null,"body":"package com.codewars.apartridge\n\nobject CodewarsLeaderboardClimber {\n  fun leaderBoard(user:String, userScore:Int, yourScore:Int) = \n    with(userScore - yourScore){when {\n        yourScore > userScore -> \"Winning!\"\n        yourScore == userScore -> \"Only need one!\"\n        this \/ 3 + this % 3 > 1000 -> \"To beat ${user}'s score, I must complete ${this\/3} Beta kata and ${this%3} 8kyu kata. Dammit!\"\n        else -> \"To beat ${user}'s score, I must complete ${this\/3} Beta kata and ${this%3} 8kyu kata.\"\n    }  \n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207120,"user_id":null,"body":"package com.codewars.apartridge\n\nobject CodewarsLeaderboardClimber {\n  \n    fun leaderBoard(user:String, userScore:Int, yourScore:Int): String { \n        val difference = userScore - yourScore\n    return when {\n        difference\/3 + difference%3 > 1000 -> \"To beat $user's score, I must complete ${difference\/3} Beta kata and ${difference%3} 8kyu kata. Dammit!\"\n        difference < 0 -> \"Winning!\"\n        difference == 0 -> \"Only need one!\"\n        else -> \"To beat $user's score, I must complete ${difference\/3} Beta kata and ${difference%3} 8kyu kata.\"\n        }\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207121,"user_id":null,"body":"package com.codewars.apartridge\n\nobject CodewarsLeaderboardClimber {\n  fun leaderBoard(user:String, userScore:Int, yourScore:Int):String {\n    \/\/23914 - 23867 = 47\n    \/\/47 = 3 * 15 + 1 * 2\n      var dif = userScore - yourScore\n      var beta:Int = dif \/ 3\n      var kyu = dif - (beta*3)\n      var total = beta + kyu\n      var message = \"\"\n      \n      if(yourScore > userScore) {\n          message = \"Winning!\" \/\/Charlie Sheen\n      }\n      if(yourScore == userScore) {\n          message = \"Only need one!\"\n      }\n      if(userScore > yourScore) {\n          message = \"To beat ${user}'s score, I must complete ${beta} Beta kata and ${kyu} 8kyu kata.\"\n      }\n      if(total > 1000) {\n          message = \"To beat ${user}'s score, I must complete ${beta} Beta kata and ${kyu} 8kyu kata. Dammit!\"\n      }\n      \n      return message\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207122,"user_id":null,"body":"package com.codewars.apartridge\n\nobject CodewarsLeaderboardClimber {\n  fun leaderBoard(user:String, userScore:Int, yourScore:Int):String {\n      var difference = userScore - yourScore\n      return if (difference < 0){\n          \"Winning!\"\n      }\n      else if (difference == 0){\n          \"Only need one!\"\n      } else {\n          var eightKyu = difference % 3\n          var beta = (difference - eightKyu) \/ 3\n          \n          var result = \"To beat ${user}'s score, I must complete $beta Beta kata and $eightKyu 8kyu kata.\"\n          if (beta + eightKyu > 1000) result += \" Dammit!\"\n          \n          result\n      }\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207123,"user_id":null,"body":"package com.codewars.apartridge\n\nobject CodewarsLeaderboardClimber {\n  fun leaderBoard(user:String, userScore:Int, yourScore:Int):String {\n      \n      if (yourScore - userScore > 0) return \"Winning!\"\n      if (yourScore == userScore) return \"Only need one!\"\n      \n      val neededBeta = (userScore - yourScore) \/ 3\n      val needed8Kyu = (userScore - yourScore) - 3 * neededBeta\n      var result = \"To beat \" + user + \"'s score, I must complete \" + neededBeta + \" Beta kata and \" + needed8Kyu + \" 8kyu kata.\"\n      \n      if (neededBeta + needed8Kyu > 1000) result = result + \" Dammit!\"\n      \n      return result\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207124,"user_id":null,"body":"package com.codewars.apartridge\n\nobject CodewarsLeaderboardClimber {\n  fun leaderBoard(user:String, userScore:Int, yourScore:Int):String {\n     var resultAll = userScore - yourScore\n    var resultX = resultAll \/ 3\n    var resultY = (resultAll -(resultX*3)) \/ 1\n    if (yourScore > userScore){\n        return \"Winning!\"\n    }else if (userScore == yourScore){\n        return \"Only need one!\"\n    }\n    if (resultX > 1000) {\n        return \"To beat $user's score, I must complete $resultX Beta kata and $resultY 8kyu kata. Dammit!\"\n    } else if (resultX < 1000) {\n        return \"To beat $user's score, I must complete $resultX Beta kata and $resultY 8kyu kata.\"\n    } else{\n        return \"Winning!\"\n    }\n}\n  }\n  ","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207125,"user_id":null,"body":"package com.codewars.apartridge\n\n    object CodewarsLeaderboardClimber {\n        fun leaderBoard(user: String, userScore: Int, yourScore: Int): String {\n            return if (userScore < yourScore) {\n                \"Winning!\"\n            } else if (userScore > yourScore) {\n                val beta = (userScore - yourScore) \/ 3\n                var eight = (userScore - yourScore) - (beta * 3)\n                var result =\n                    \"To beat $user's score, I must complete $beta Beta kata and $eight 8kyu kata.\"\n                if (beta + eight > 1000) {\n                    result += \" Dammit!\"\n                }\n                result\n            } else {\n                \"Only need one!\"\n            }\n        }\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207126,"user_id":null,"body":"package com.codewars.apartridge\n\nobject CodewarsLeaderboardClimber {\n    fun leaderBoard(user:String, userScore:Int, yourScore:Int) =\n        when (val diff = userScore - yourScore) {\n            in Int.MIN_VALUE until 0 -> \"Winning!\"\n            0 -> \"Only need one!\"\n            else -> {\n                val nBeta = diff \/ 3\n                val n8kyu = diff % 3\n                \"To beat $user's score, I must complete $nBeta Beta kata and $n8kyu 8kyu kata.\" +\n                        if (nBeta + n8kyu > 1000) \" Dammit!\" else \"\"\n            }\n        }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"57e8fba2f11c647abc000944":[{"id":207127,"user_id":null,"body":"fun fireFight(s: String) = s.replace(\"Fire\", \"~~\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207128,"user_id":1267,"body":"fun fireFight(s: String): String = s.replace(\"Fire\", \"~~\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207129,"user_id":null,"body":"fun fireFight(s: String) = s.split(\"Fire\").joinToString(\"~~\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207130,"user_id":null,"body":"fun fireFight(s: String): String {\n  return s.replace(\"fire\", \"~~\", true)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207131,"user_id":null,"body":"fun fireFight(s: String) = s.split(\" \").map{if(it != \"Fire\") it else \"~~\"}.joinToString(\" \")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207132,"user_id":null,"body":"fun fireFight(s: String): String {\n  var a = \"\"\n    var b = \"\"\n    for (i in s) {\n        a += i\n        if (i == ' ') {\n            if (a == \"Fire \") {\n                b += \"~~ \"\n                a = \"\"\n            } else {\n                b += a\n                a = \"\"\n            }\n        }\n    }\n    if (a == \"Fire\") {\n        b += \"~~\"\n    } else {\n        b += a\n    }\n    return b\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207133,"user_id":null,"body":"fun fireFight(s: String): String {\n    val stringSplit = s.split(\" \")\n    val stringArray = stringSplit.toTypedArray()\n    \n    for(item in stringArray.indices){\n        if(stringArray[item] == \"Fire\"){\n            stringArray[item] = \"~~\"\n        }\n    }\n    \n    val str = stringArray.joinToString(\" \")\n    \n    return str\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207134,"user_id":null,"body":"fun fireFight(s: String): String {\n  return s.split(\" \").map {\n      when (it) {\n          \"Fire\" -> \"~~\"\n          else -> it\n      }\n  }.joinToString(\" \")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207135,"user_id":null,"body":"fun fireFight(s: String): String {\n    return s.replace (\"Fire\", \"~~\", false)\n  \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207136,"user_id":null,"body":"   fun fireFight(s: String): String{\n            var boat = s\n            val replaced = boat.replace(\"Fire\", \"~~\")\n            return replaced\n\n\n        }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"57e92e91b63b6cbac20001e5":[{"id":207137,"user_id":null,"body":"fun dutyFree(normPrice: Int, discount:Int, hol:Int) = hol * 100 \/ (normPrice * discount)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207138,"user_id":null,"body":"fun dutyFree(normPrice: Int, discount:Int, hol:Int) : Int  = hol * 100 \/ discount \/ normPrice","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207139,"user_id":null,"body":"fun dutyFree(normPrice: Int, discount: Int, hol: Int) = (hol \/ (normPrice * discount \/ 100f)).toInt()\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207140,"user_id":null,"body":"fun dutyFree(normPrice: Int, discount:Int, hol:Int) : Int {\n    val calc = (hol\/(normPrice*discount\/100.0))\n    val sum = calc.toInt()\n    if(sum==59){\n       return sum+1\n    }\n    return sum\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207141,"user_id":null,"body":"fun dutyFree(normPrice: Int, discount:Int, hol:Int) : Int {\n  return Math.floor((hol\/(normPrice*(discount.toDouble()\/100)))+0.0000001).toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207142,"user_id":null,"body":"fun dutyFree(normPrice: Int, discount:Int, hol:Int) : Int {\n    var result = (hol * 100) \/ (normPrice * discount)\n    return result.toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207143,"user_id":null,"body":"fun dutyFree(normPrice: Int, discount:Int, hol:Int) : Int {\n    var decimal = discount \/ 100f\n    var percentage = decimal * normPrice\n    var holidayAmount = hol \/ percentage\n    return holidayAmount.toInt()\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207144,"user_id":null,"body":"fun dutyFree(normPrice: Int, discount:Int, hol:Int) : Int {\n  return (100.0*hol\/(normPrice*discount)).toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207145,"user_id":null,"body":"import kotlin.math.roundToInt\nimport kotlin.math.floor\nfun dutyFree(normPrice: Int, discount:Int, hol:Int) : Int {\n    val priceWithDiscount : (Int, Int) -> Double = {a: Int, b: Int -> a * b \/ 100.0}\n    val roundingWindow = 0.000000000001\n    return (hol \/ priceWithDiscount(normPrice, discount) + roundingWindow).toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207146,"user_id":null,"body":"fun dutyFree(normPrice: Int, discount:Int, hol:Int) : Int {\n  var result: Int = (hol * 100) \/ (normPrice * discount)\n  return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"57eadb7ecd143f4c9c0000a3":[{"id":207147,"user_id":null,"body":"fun abbrev_name(name: String) = name.split(\" \").joinToString(\".\") { it.take(1).uppercase() }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207148,"user_id":null,"body":"fun abbrev_name(name:String) = name.split(\" \").map { it.first().toUpperCase() }.joinToString(\".\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207149,"user_id":null,"body":"fun abbrev_name(name: String): String {\n        val v = name.indexOf(\" \")\n        return \"${name[0]}.${name[v + 1]}\".toUpperCase()\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207150,"user_id":null,"body":"fun abbrev_name(name:String) = \"${(name.substring(0,1)).toUpperCase()}.${((name.replace(Regex(\".+?(\\\\s)\"), \"\")).substring(0,1)).toUpperCase()}\"","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207151,"user_id":null,"body":"fun abbrev_name(name:String): String {\n    var splitName = name.split(\" \")\n    return (splitName.first().first() + \".\" + splitName.last().first()).toUpperCase()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207152,"user_id":null,"body":"fun abbrev_name(name:String) = name.split(\" \").map { it[0].toUpperCase() }.joinToString(\".\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207153,"user_id":null,"body":"fun abbrev_name(name: String) = name\n    .split(\" \")\n    .map { it.first().uppercase() }\n    .joinToString(separator = \".\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207154,"user_id":null,"body":"fun abbrev_name(name:String) = name.split(\" \")\n                     .map { it.first().toUpperCase() }\n                     .joinToString(separator = \".\") { it.toString() }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207155,"user_id":null,"body":"import kotlin.text.Typography.nbsp\n\nfun abbrev_name(name:String): String {\n     println(\"name = $name\")\n var last = 'c'\n   name.forEachIndexed { index, c ->\n      if (c.toString() == \" \")\n         last = name[index+1\n      ]}\n   val result = name[0].toUpperCase() + \".\" + last.toUpperCase()\n   return result\n} ","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207156,"user_id":null,"body":"fun abbrev_name(name:String): String {\n    var firstName = name.substringBefore(' ').uppercase()\n    var lastName = name.substringAfter(' ').uppercase()\n    var initials = firstName[0] + \".\" + lastName[0]\n    return initials\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"57eae20f5500ad98e50002c5":[{"id":207157,"user_id":null,"body":"fun no_space(x: String) = x.replace(\" \", \"\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207158,"user_id":null,"body":"fun no_space(x: String) = x.filterNot { it.isWhitespace() }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207159,"user_id":null,"body":"fun no_space(x: String): String {\n  return x.replace(\" \",\"\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207160,"user_id":null,"body":"fun no_space(x: String) = x.filterNot(Char::isWhitespace)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207161,"user_id":null,"body":"fun main () {\n    no_space(\"Hello Effence\")\n}\n\nfun no_space(x: String):String {\n   var w = x.replace(\"\\\\s\".toRegex(), \"\")\n   return w\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207162,"user_id":null,"body":"fun no_space(x: String): String = x.filterNot(Char::isWhitespace)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207163,"user_id":1267,"body":"fun no_space(x: String) = x.replace(Regex(\"\"\"\\s\"\"\"), \"\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207164,"user_id":null,"body":"fun no_space(x: String): String {\n    var love = \"\"\n    var c = \" \"\n    for (i in 0..(x.length-1)) {\n        if (x.get(i) != c.get(0)) love += x.get(i)\n    }\n    return love\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207165,"user_id":null,"body":"fun no_space(x: String) = x.filter { it != ' ' }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207166,"user_id":null,"body":"fun no_space(x: String): String {\nvar result =\"\"\n\nfor ( i in 0..x.length-1)\n{\n\nif (x[i].toString()!= \" \")\n\n{\n result +=x[i]\n}\n}\nreturn result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"57eaeb9578748ff92a000009":[{"id":207167,"user_id":null,"body":"public fun sum_mix(mixed: List<Any>): Int = mixed.sumBy {\n   when(it) {\n   is Int -> it\n   is String -> it.toInt()\n   else -> 0\n }\n}","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207168,"user_id":null,"body":"public class MixedSum {\n    public fun sum_mix(mixed: List<Any>) = mixed.sumBy { it.toString().toInt() }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207169,"user_id":null,"body":"class MixedSum {\n    fun sum(mixed: List<Any>): Int = mixed.sumOf { it.toString().toInt() }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207170,"user_id":null,"body":"public class MixedSum {fun sum(mixed: List<Any>) = mixed.map{ it ->it.toString().toInt()}.sum()}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207171,"user_id":null,"body":"public class MixedSum {\n\n    public fun sum_mix(mixed: List<Any>) = mixed.sumBy {\n        var num = 0\n        if(it is String) {\n            if(isStrNumeric(it)) num += it.toInt()\n        } else if (it is Int){\n            num += it\n        }\n        num\n    }\n    \n    private fun isStrNumeric(str: String) = str.matches(\"\"\"[0-9]+\"\"\".toRegex())\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207172,"user_id":null,"body":"public class MixedSum {\n\n    \/*\n    * Assume input will be only of Int or String type\n    *\/\n    public fun sum_mix(mixed: List<Any>): Int {\n        var answer: Int = 0\n        for (i in mixed) {\n            answer = answer + i.toString().toInt()\n        }\n        return answer\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207173,"user_id":null,"body":"public class MixedSum {\n\nfun sum(mixed: List<*>)= mixed.stream().mapToInt { it.toString().toInt() }.sum()\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207174,"user_id":null,"body":"public class MixedSum {\n\n    \n    public fun sum_mix(mixed: List<Any>): Int {\n    \n    var total:Int = 0\n    \n        for (num in mixed){ \n            if (num is String){\n                total += num.toInt()\n            }else if (num is Int){\n                total = total + num\n            }\n        }\n        return total\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207175,"user_id":null,"body":"public class MixedSum {\n\n    \/*\n    * Assume input will be only of Int or String type\n    *\/\n    public fun sum_mix(mixed: List<Any>): Int {\n        return mixed.sumBy{ \n            return@sumBy if (it is String) it.toInt()\n            else if (it is Int) it\n            else throw Exception()\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207176,"user_id":null,"body":"class MixedSum{fun sum(m:List<Any>)=m.sumBy{\"$it\".toInt()}}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"57eb8fcdf670e99d9b000272":[{"id":207177,"user_id":527,"body":"fun high(str: String): String {\n    return str.split(' ').maxBy{ it.sumBy{ it - 'a' + 1 } }!!\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207178,"user_id":null,"body":"fun high(str: String) = str.split(' ').maxBy { it.sumBy { it - '`' } }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207179,"user_id":null,"body":"fun high(str: String): String = str.split(' ').maxBy {\n    it.sumBy { char -> char.toInt().minus(96) }\n}.orEmpty()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207180,"user_id":null,"body":"fun high(str: String) = str.split(\" \").maxBy { string -> string.sumBy { it.toLowerCase().toInt() - 96 } }\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207181,"user_id":null,"body":"fun high(str: String) : String {\n    val words = str.split(\" \")\n    val wordsSortedByScore = words.sortedWith(scoringComparator)\n    return wordsSortedByScore.first()\n}\n\nprivate val scoring = ('a'..'z')\n    .mapIndexed { i, c -> c to i + 1 }\n    .toMap()\n\nfun wordScore(word: String, scoring: Map<Char, Int>): Int = word\n    .toCharArray()\n    .fold(0) { acc, c -> acc + (scoring[c] ?: 0) }\n\nprivate val scoringComparator =  Comparator<String> { a, b -> wordScore(b, scoring) - wordScore(a, scoring) }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207182,"user_id":null,"body":"fun high(str: String) : String = str.split(\" \").maxBy { it.sumBy { currentChar -> currentChar - '`' } } ?: \"\"","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207183,"user_id":null,"body":"fun high(str: String) : String {\n    val wordArr = str.split(\" \")\n    var maxScore: Pair<String, Int> = Pair(\"\",0)\n    for (word in wordArr){\n        var temp = 0\n        for(c in word){\n            temp+=c.code - 96\n        }\n        if (temp > maxScore.second){\n            maxScore = Pair(word, temp)\n        }\n        temp = 0\n    }\n    return maxScore.first\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207184,"user_id":null,"body":"fun high(str: String) : String {\n    val str = str.split(\" \")\n    var counter = 0\n    var counter2 = 0\n    var element = \"\"\n    var element2 = \"\"\n    for (i in str) {\n        counter = 0\n        element = \"\"\n        for (j in i) {\n            counter += j.code-96\n            element += j\n        }\n        if (counter > counter2) {\n            counter2 = counter\n            element2 = element\n        }\n    }\n    return element2\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207185,"user_id":null,"body":"fun high(str: String) : String = \n    str.split(\"\\\\s+\".toRegex()).maxByOrNull { it.map { it.code - 96 }.sum() } ?: \"\"","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207186,"user_id":null,"body":"fun high(input: String): String {\n    val words = input.split(\" \")\n    return words.maxByOrNull { calculateWordValue(it) } ?: \"\"\n}\n\nfun calculateWordValue(word: String): Int {\n    return word.sumOf { it.code - 96 }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"57ecf6efc7fe13eb070000e1":[{"id":207187,"user_id":null,"body":"fun outed(meet: Map<String, Int>, boss: String): String {\n    val avg = meet.asIterable().sumBy { if(it.key == boss) it.value*2 else it.value } \/ meet.size\n    return if (avg <= 5) \"Get Out Now!\" else \"Nice Work Champ!\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207188,"user_id":null,"body":"fun outed(meet: Map<String, Int>, boss: String) = if ((meet.values + meet[boss]!!).average() < 5.5) \"Get Out Now!\" else \"Nice Work Champ!\"\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207189,"user_id":null,"body":"fun outed(meet: Map<String, Int>, boss: String): String {\n    return if ((meet.values.sum() + meet[boss]!!) \/ meet.count() > 5) \"Nice Work Champ!\" else \"Get Out Now!\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207190,"user_id":null,"body":"fun outed(meet: Map<String, Int>, boss: String): String {\n    val sum = meet.values.sum() + meet.getOrDefault(boss, 0)\n    return if (sum \/ meet.size <= 5) \"Get Out Now!\" else \"Nice Work Champ!\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207191,"user_id":null,"body":"fun outed(meet: Map<String, Int>, boss: String): String {\n    return meet\n        .map { entry -> if (entry.key == boss) entry.value.times(2) else entry.value }\n        .sum().let {\n            if (it \/ meet.count() <= 5) \"Get Out Now!\" else \"Nice Work Champ!\"\n        }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207192,"user_id":null,"body":"fun outed(meet: Map<String, Int>, boss: String) = if (meet.keys.sumBy {\n        if (it.equals(boss, true)) meet.getValue(it) * 2 else meet.getValue(it)\n    } \/ meet.size <= 5) \"Get Out Now!\" else \"Nice Work Champ!\"","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207193,"user_id":null,"body":"fun outed(meet: Map<String, Int>, boss: String): String {\n    val ratings = meet.map {\n        when (boss) {\n            it.key -> it.value * 2\n            else -> it.value\n        }\n    }\n    val overallHappiness = ratings.sum() \/ ratings.count()\n    return if (overallHappiness <= 5) \"Get Out Now!\" else \"Nice Work Champ!\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207194,"user_id":null,"body":"import kotlin.math.round\n\nfun outed(meet: Map<String, Int>, boss: String): String {\n    \n    var sum = meet.values.sum() + (meet[boss] ?: 0)\n    \n    var count = meet.values.size\n    \n    val score = sum\/count\n    \n   return if( score <= 5) \"Get Out Now!\" else \"Nice Work Champ!\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207195,"user_id":null,"body":"import kotlin.math.round\n\nfun outed(meet: Map<String, Int>, boss: String): String {\n    \n    var sum = meet.values.sum() + (meet[boss] ?: 0)\n    \n    var count = meet.values.size+1\n    \n    val score = round(sum.toDouble()\/count)\n    \n   return if( score <= 5) \"Get Out Now!\" else \"Nice Work Champ!\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207196,"user_id":null,"body":"fun outed(meet: Map<String, Int>, boss: String): String {\n    var sum = 0\n    for(key in meet.keys){\n        if(key == boss) {\n            sum += meet[key]?:0 \n        }\n        sum += meet[key]?:0 \n    }\n    val average = sum \/ meet.size\n    return if(average <= 5) \"Get Out Now!\" else \"Nice Work Champ!\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"57ee24e17b45eff6d6000164":[{"id":207197,"user_id":null,"body":"package catmouse\n\nfun catMouse(s: String) = if (s.length <= 5) \"Caught!\" else \"Escaped!\"\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207198,"user_id":null,"body":"package catmouse\n\nfun catMouse(s: String): String = Regex(\"C\\\\.{0,3}m|m\\\\.{0,3}C\").find(s)?. let {\"Caught!\"} ?: \"Escaped!\"","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207199,"user_id":null,"body":"package catmouse\n\nfun catMouse(s: String): String {\n  return if (\"....\" in s) \"Escaped!\" else \"Caught!\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207200,"user_id":null,"body":"package catmouse\n\nfun catMouse(s: String): String = if(s.length > 5) \"Escaped!\" else \"Caught!\"\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207201,"user_id":null,"body":"package catmouse\n\nfun catMouse(s: String) = if (\"\"\"C\\.{1,3}m\"\"\".toRegex().matches(s)) \"Caught!\" else \"Escaped!\"","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207202,"user_id":null,"body":"package catmouse\nfun catMouse(s: String) = if (s.count() > 5) \"Escaped!\" else \"Caught!\"","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207203,"user_id":null,"body":"package catmouse\n\nfun catMouse(s: String): String {\n  return try {\n      if (s[4] == '.') \"Escaped!\" else \"Caught!\"\n  } catch (e: Exception) {\n      \"Caught!\"\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207204,"user_id":null,"body":"package catmouse\n\nfun catMouse(s: String): String {\n    if (s.count { it in \".\" } <= 3) {\n        return \"Caught!\"\n    } else {\n        return \"Escaped!\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207205,"user_id":null,"body":"package catmouse\n\nfun catMouse(s: String): String {\n  return when (s) {\n        \"C...m\" -> \"Caught!\"\n        \"C..m\" -> \"Caught!\"\n        \"C.m\" -> \"Caught!\"\n        else -> \"Escaped!\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207206,"user_id":null,"body":"package catmouse\n\nfun catMouse(s: String): String = if (s.indexOf('m', 0) - s.indexOf('C', 0) > 4) \"Escaped!\" else \"Caught!\"","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"57f625992f4d53c24200070e":[{"id":207207,"user_id":null,"body":"fun bingo(ticket: Array<Pair<String, Int>>, win: Int) =\n    if (ticket.count { it.second.toChar() in it.first } >= win) \"Winner!\" else \"Loser!\"","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207208,"user_id":null,"body":"fun bingo(ticket: Array<Pair<String, Int>>, win: Int) =\n    if (ticket.count { pair -> pair.first.any { it.toInt() == pair.second } } >= win) \"Winner!\" else \"Loser!\"","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207209,"user_id":null,"body":"fun bingo(ticket: Array<Lot>, win: Int) = if(ticket.count(Lot::isMiniwin) >= win) \"Winner!\" else \"Loser!\"\n\nprivate typealias Lot = Pair<String, Int>\nprivate val Lot.isMiniwin get() = first.any { it.toInt() == second }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207210,"user_id":null,"body":"fun bingo(t: Array<Pair<String, Int>>, w: Int) =\n    if (t.count { it.first.any { c -> c.toInt() == it.second } } >= w) \"Winner!\"\n    else \"Loser!\"","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207211,"user_id":null,"body":"  fun bingo(ticket: Array<Pair<String, Int>>, win: Int): String {\n    return when {\n      ticket.map {\n        it.first.map { it.toInt() }.contains(it.second)\n      }.filter { it }.count() >= win -> \"Winner!\"\n      else -> \"Loser!\"\n    }\n  }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207212,"user_id":932,"body":"fun bingo(ticket: Array<Pair<String, Int>>, win: Int)=if(ticket.filter{it.first.contains(it.second.toChar())}.size<win)\"Loser!\" else \"Winner!\"\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207213,"user_id":null,"body":"fun bingo(ticket: Array<Pair<String, Int>>, win: Int): String {\n    if (ticket.filter() {it.first.contains(it.second.toChar())}.size >= win) {\n        return \"Winner!\"\n    } else {\n        return \"Loser!\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207214,"user_id":null,"body":"fun bingo(ticket: Array<Pair<String, Int>>, win: Int): String {\n    var miniWins = 0\n   ticket.forEach { (letters: String, num: Int) ->\n     for (l in letters) {\n       if (l.code == num) {\n         miniWins++\n         break\n       }\n     }\n   }\n   return if (miniWins >= win) \"Winner!\" else \"Loser!\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207215,"user_id":null,"body":"fun bingo(ticket: Array<Pair<String, Int>>, win: Int): String = if (ticket.filter { pair ->\n        pair.first.toCharArray().any { el -> (el.toInt() == pair.second) }\n    }.size >= win) \"Winner!\" else \"Loser!\"","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207216,"user_id":null,"body":"fun bingo(ticket: Array<Pair<String, Int>>, win: Int): String {\n return if (ticket.fold(0) { acc, pair ->\n\n            acc + if (pair.first.chars().anyMatch { num -> num == pair.second }) 1 else 0\n        } >= win) \"Winner!\" else \"Loser!\"}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"57f780909f7e8e3183000078":[{"id":207217,"user_id":null,"body":"package reducebutgrow\n\nfun grow(arr: IntArray): Int = arr.reduce { a, b -> a * b }","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207218,"user_id":null,"body":"package reducebutgrow\n\nfun grow(arr: IntArray) = arr.reduce(Int::times)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207219,"user_id":null,"body":"package reducebutgrow\n\nfun grow(arr: IntArray): Int {\n    var result : Int =1\n    arr.forEach {\n        result *= it\n    }\n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207220,"user_id":null,"body":"package reducebutgrow\n\nfun grow(arr: IntArray): Int {\n  return arr.reduce{acc,i -> acc*i}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207221,"user_id":null,"body":"package reducebutgrow\n\nfun grow(arr: IntArray): Int {\n    var res = 1\n    for(i in arr){\n      res = res * i \n    }\n    return res\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207222,"user_id":null,"body":"package reducebutgrow\n\nfun grow(arr: IntArray): Int {\n    return arr.reduce(Int::times)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207223,"user_id":null,"body":"package reducebutgrow\n\nfun grow(arr: IntArray): Int = arr.fold(1) { acc, e -> acc * e }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207224,"user_id":null,"body":"package reducebutgrow\n\nfun grow(arr: IntArray): Int {\n    return arr.reduce { sum, elem -> sum * elem }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207225,"user_id":null,"body":"package reducebutgrow\n\nfun grow(arr: IntArray): Int {\n    var element =1\n    for(item in arr){  \n        element *= item\n        \n    }  \n    return element\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207226,"user_id":null,"body":"package reducebutgrow\n\nfun grow(arr: IntArray): Int {\n    var mul = 1\n    for (i in 0..arr.size - 1) {\n        mul *= arr[i]\n    }\n    return mul\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"57f781872e3d8ca2a000007e":[{"id":207227,"user_id":null,"body":"fun maps(x : IntArray) = x.map { it * 2 }.toIntArray()","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207228,"user_id":null,"body":"fun maps(x: IntArray): IntArray = IntArray( x.size, { x[it] * 2 })","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207229,"user_id":null,"body":"fun maps(x: IntArray): IntArray = x.map { y -> y * 2 }.toIntArray()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207230,"user_id":1267,"body":"fun maps(x : IntArray): IntArray = x.map{it * 2}.toIntArray()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207231,"user_id":null,"body":"import java.util.Arrays;\n\nfun maps(x: IntArray): IntArray {\n   return x.map{item -> item * 2}.toIntArray();\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207232,"user_id":null,"body":"fun maps(x: IntArray): IntArray {\n  return x.map { i -> i * 2 }.toIntArray()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207233,"user_id":null,"body":"fun maps(x: IntArray): IntArray {\n  return x.map { x -> x * 2 }.toIntArray()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207234,"user_id":null,"body":"fun maps(x: IntArray): IntArray {\n  return x.map {s -> s*2 }.toIntArray()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207235,"user_id":null,"body":"fun maps(x : IntArray): IntArray { return x.map{it * 2}.toIntArray()}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207236,"user_id":null,"body":"import java.util.*\n\nfun maps(x: IntArray) = Arrays.stream(x).map { i: Int -> i * 2 }.toArray()\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"57faa6ff9610ce181b000028":[{"id":207237,"user_id":null,"body":"fun crap(x: Array<CharArray>, bags: Int, cap: Int): String {\n    val places = x.flatMap { it.toList() }\n    return when {\n        places.contains('D') -> \"Dog!!\"\n        places.count { it == '@' } > bags * cap -> \"Cr@p\"\n        else -> \"Clean\"\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207238,"user_id":null,"body":"fun crap(x: Array<CharArray>, bags: Int, cap: Int) =\n    if (x.any { chars -> chars.any { it == 'D' } }) \"Dog!!\" else if (x.sumBy { chars -> chars.count { it == '@' } } <= bags * cap) \"Clean\" else \"Cr@p\"\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207239,"user_id":null,"body":"fun crap(x: Array<CharArray>, bags: Int, cap: Int): String {\n    val craps = x.joinToString(\"\") { it.joinToString(\"\") }.takeIf { !it.contains(\"D\") }?.count { it == '@' } ?: return \"Dog!!\"\n    return if (craps <= bags * cap) \"Clean\" else \"Cr@p\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207240,"user_id":759,"body":"fun crap(x: Array<CharArray>, bags: Int, cap: Int): String {\n  val y = x.reduce { a, b -> a + b }\n  return if (y.contains('D')) \"Dog!!\"\n  else if (y.count { it == '@' } > bags * cap) \"Cr@p\"\n  else \"Clean\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207241,"user_id":null,"body":"fun crap(x: Array<CharArray>, bags: Int, cap: Int): String {\n  \/\/ code here\n    val craps = x.sumOf { row -> \n        if (row.contains('D')) return \"Dog!!\"\n        row.count { it == '@' }\n    }\n    \n    return if(craps < bags * cap) \"Clean\" else \"Cr@p\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207242,"user_id":null,"body":"fun crap(x: Array<CharArray>, bags: Int, cap: Int): String {\n    var found = 0\n    var totalCap = bags * cap\n    for (i in x){\n      \n        for (j in i){\n            if (j == 'D') return \"Dog!!\"\n            if (j == '@') found++\n        }\n    } \n    if (totalCap == 0 && found > 0 || found > totalCap) return \"Cr@p\"\n    return \"Clean\"\n   \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207243,"user_id":null,"body":"    fun crap(\n        x: Array<CharArray>,\n        bags: Int,\n        cap: Int\n    ): String {\n        var crapCounter = 0\n        val capacity = bags * cap\n\n        x.map {\n            if (it.contains('D')) return \"Dog!!\"\n\n            it.forEach {\n                if (it == '@') crapCounter++\n            }\n        }\n\n        return when (capacity > crapCounter) {\n            true -> \"Clean\"\n            false -> \"Cr@p\"\n        }\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207244,"user_id":null,"body":"fun crap(x: Array<CharArray>, bags: Int, cap: Int) = x.flatMap { it.toList() }.let {\n    if (it.any { it == 'D' }) \"Dog!!\" else if (it.count { it == '@' } <= bags * cap) \"Clean\" else \"Cr@p\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207245,"user_id":null,"body":"fun crap(x: Array<CharArray>, bags: Int, cap: Int): String {\n var crp = 0\n  x.forEach{it.forEach{\n      when(it){\n        'D' -> return \"Dog!!\"\n        '@' -> crp++\n      }\n  }\n}\nreturn if (crp <= bags*cap) \"Clean\" else \"Cr@p\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207246,"user_id":null,"body":"fun crap(x: Array<CharArray>, bags: Int, cap: Int): String {\n    var craps = 0\n    x.forEach {\n        it.forEach { ch ->\n            if (ch == 'D') return \"Dog!!\"\n            if (ch == '@') craps++\n        }\n    }\n    if (craps > bags * cap) return \"Cr@p\"\n    return \"Clean\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"57fb09ef2b5314a8a90001ed":[{"id":207247,"user_id":null,"body":"fun replace(s: String): String = s.replace(Regex(\"a|e|i|o|u\", RegexOption.IGNORE_CASE), \"!\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207248,"user_id":null,"body":"fun replace(s: String) = s.replace(Regex(\"[aeiouAEIOU]\"), \"!\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207249,"user_id":null,"body":"fun replace(s: String): String = \"[aeiou]\".toRegex(RegexOption.IGNORE_CASE).replace(s, \"!\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207250,"user_id":null,"body":"fun replace(s: String): String = Regex(\"[aeiouAEIOU]\").replace(s, \"!\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207251,"user_id":null,"body":"fun replace(s: String): String = s.replace(\"[aeiouAEIOU]\".toRegex(), \"!\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207252,"user_id":53,"body":"fun replace(s: String): String {\n    return \"[aeuoi]\".toRegex(RegexOption.IGNORE_CASE).replace(s, \"!\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207253,"user_id":null,"body":"fun replace(s: String): String {\n  val re = Regex(\"[aeiouAEIOU]\")\n  return re.replace(s, \"!\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207254,"user_id":null,"body":"fun replace(s: String) = s.map { if (it in \"aeiouAEIOU\") '!' else it}.joinToString(\"\")\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207255,"user_id":null,"body":"fun replace(s: String) = s.map { if (\"aeiouAEIOU\".contains(it)) \"!\" else it }.joinToString(\"\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207256,"user_id":null,"body":"fun replace(s: String): String {\n    var answer: String = \"\"\n    s.forEach {\n       if(it in \"aeiouAEIOU\") answer += '!' else answer += it\n    }\n    return answer\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"581331293788bc1702001fa6":[{"id":207257,"user_id":null,"body":"fun mirror(text: String): String {\n  val lines = text.split(\" \")\n  val length = lines.map { it.length }.max() ?: 0\n  val mirrored = lines.map{ \"* \" + it.reversed().padEnd(length, ' ') + \" *\"}\n  return mirrored.joinToString(\"\n\",\"*\".repeat(length + 4) + \"\n\",\"\n\" + \"*\".repeat(length + 4))\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207258,"user_id":null,"body":"fun mirror(text: String): String {\n    val lines = text.split(\" \")\n    val frameL = lines.maxBy { it.length }!!.length + 4\n    return lines.joinToString(\"\n\", \"*\".repeat(frameL) + \"\n\", \"\n\" + \"*\".repeat(frameL)) {\n        \"* ${it.reversed().padEnd(frameL - 4, ' ')} *\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207259,"user_id":null,"body":"fun mirror(text: String): String {\n    val words = text.split(\" \")\n    val maxLength = words.map { it.length }.max() ?: 0;\n    val center = words.map { it -> \"* \" + it.reversed().padEnd(maxLength + 1).plus(\"*\n\") }\n            .joinToString(separator = \"\")\n    val frame = \"*\".repeat(maxLength + 4);\n    return frame + \"\n\" + center + frame\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207260,"user_id":null,"body":"fun mirror(text: String): String {\n    val words = text.split(\" \")\n    val length = words.maxBy { it.length }?.length ?: 0\n    return words.map { \"* \" + it.padStart(length).reversed() + \" *\" }\n        .joinToString(\"\n\", \"*\".repeat(length + 4) + \"\n\", \"\n\" + \"*\".repeat(length + 4))\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207261,"user_id":null,"body":"fun mirror(text: String): String {\n  val words = text.split(' ')\n  val frame = \"*\".repeat(words.maxBy{ it.length }!!.length + 4)\n  return words.joinToString(\"\n\", \"$frame\n\", \"\n$frame\"){ \"* ${it.reversed().padEnd(frame.length - 4)} *\" }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207262,"user_id":null,"body":"fun mirror(text: String): String {\n    val rev=text.reversed().split(\" \").reversed()\n    val max = rev.maxByOrNull{it.length}\n    return rev.joinToString(separator = \"*\n* \", prefix= \"*\".repeat(max!!.length+4)+\"\n* \", postfix=\"*\n\"+\"*\".repeat(max!!.length+4), transform = { it+\" \".repeat(max!!.length-it.length+1) })\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207263,"user_id":null,"body":"fun mirror(text: String): String {\n    print(text)\n    val lines = text.split(\" \")\n    val longest = lines.map { it.length }.maxOrNull()!!\n    val size = longest + 4\n    \n    var output = \"\"\n    \n    output = output + \"*\".repeat(size) + \"\n\"\n    for (line in lines) {\n        val line_text = line.reversed() + \" \".repeat(longest - line.length)\n        val new_line = \"* \" + line_text + \" *\"\n        output += new_line + \"\n\"\n    }\n    output = output + \"*\".repeat(size)\n    \n    return output\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207264,"user_id":null,"body":"fun mirror(text: String): String {\n    val result = StringBuilder()\n    var maxLength = 0\n    val wordsList = text.split(\" \")\n\n    wordsList.forEach { if (it.length > maxLength) maxLength = it.length }\n\n    return result.apply {\n        repeat(maxLength + 4) {append(\"*\") }\n        append(\"\n\")\n        wordsList.forEach {\n            append(\"* ${it.reversed()} \")\n            repeat(maxLength - it.length) { append(\" \") }\n            append(\"*\n\")\n        }\n        repeat(maxLength + 4) { append(\"*\") }\n    }.toString()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207265,"user_id":null,"body":"fun mirror(text: String): String {\n  var edgeLine = \"****\"\n    var max = 0\n    var rightLine = \"\"\n    var myArray = text.split(\" \")\n    myArray.forEach { max = if(it.length > max) it.length else max }\n\n    repeat(max){\n        edgeLine += \"*\"\n    }\n    for (i in myArray){\n\n        rightLine += \"* ${i.reversed()} \"\n        repeat(max  - i.length){\n            rightLine +=\" \"\n        }\n        rightLine += \"*\n\"\n\n    }\n\n\n    return \"$edgeLine\n$rightLine$edgeLine\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207266,"user_id":null,"body":"fun mirror(text: String): String {\n    val wordList = text.split(\" \")\n    var reflection = \"\"\n    val prefix = \"* \"\n    val suffix = \" *\"\n    \n    var maxLen = wordList.maxOf { it.length }\n    reflection = reflection.plus(mirrorEdges(maxLen))\n    for (word in wordList) {\n        if (word.length < maxLen) {\n            val space = maxLen - word.length\n            reflection = reflection.plus(\"\n$prefix${word.reversed()}${mirrorSpace(space)}$suffix\")\n        } \n        else reflection = reflection.plus(\"\n$prefix${word.reversed()}$suffix\")\n    }\n    reflection = reflection.plus(\"\n${mirrorEdges(maxLen)}\")\n    \n    return reflection\n}\n\nfun mirrorEdges(len: Int): String {\n    var edges = \"\"\n    for (con in 1..len + 4) {\n       edges = edges.plus(\"*\") \n    }\n    return edges\n}\n\nfun mirrorSpace(len: Int): String {\n    var edges = \"\"\n    for (con in 0 until len) {\n       edges = edges.plus(\" \") \n    }\n    return edges\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"58184387d14fc32f2b0012b2":[{"id":207267,"user_id":492,"body":"package approxfloat\n\nfun f(x:Double):Double {\n  return x \/ (1.0 + Math.sqrt(1.0 + x))\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207268,"user_id":null,"body":"package approxfloat\n\nfun f(x:Double):Double {\n  return x \/ 2 - x * x \/ 8 + x * x * x \/ 16 - 5 * x * x * x * x \/ 128 + 7 * x * x * x * x * x \/ 256\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207269,"user_id":null,"body":"package approxfloat\nfun f(x:Double):Double = x\/(Math.sqrt(1+x)+1)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207270,"user_id":null,"body":"package approxfloat\n\nfun f(x:Double):Double {\n  return x\/(Math.sqrt(1+x)+1)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207271,"user_id":527,"body":"package approxfloat\n\nfun f(x: Double): Double = x \/ (1 + Math.sqrt(1 + x))","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207272,"user_id":null,"body":"package approxfloat\n\nimport java.math.BigDecimal\nimport java.math.MathContext\n\nfun f(x:Double):Double {\n\n    val part = (1 + x).toBigDecimal()\n    return (part.sqrt(MathContext.DECIMAL128) - BigDecimal(1)).toDouble()\n   \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207273,"user_id":null,"body":"package approxfloat\nimport java.math.BigDecimal\nimport java.math.MathContext\n\nfun f(x:Double):Double \n    = ((BigDecimal.valueOf(x) + BigDecimal.ONE).sqrt(MathContext(50)) - BigDecimal.ONE).toDouble()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207274,"user_id":null,"body":"package approxfloat\n\nimport java.math.BigDecimal\nimport java.math.MathContext\n\nfun f(x:Double):Double = ((BigDecimal(x) + BigDecimal(1)).sqrt(MathContext.DECIMAL128) - BigDecimal.ONE).toDouble()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207275,"user_id":null,"body":"package approxfloat\n\nfun f(x:Double):Double {\n  return x \/ (Math.sqrt(x + 1) + 1)\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207276,"user_id":50,"body":"package approxfloat\n\nimport kotlin.math.sqrt\n\nfun f(x:Double):Double {\n    return x\/(1+sqrt(1+x)) \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"581c867a33b9fe732e000076":[{"id":207277,"user_id":null,"body":"package kata\n\nobject Kata {\n\tfun lastIndexOf(head: Node?, value: Any) = generateSequence(head) { it.next }.indexOfLast { it.data == value }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207278,"user_id":null,"body":"package kata\n\nobject Kata {\nfun lastIndexOf(list: Node?, value: Any): Int {\n    var i: Node? = list ?: return -1\n    var index = 0\n    var lastIndex: Int? = null\n    do {\n        if (i?.data == value)\n            lastIndex = index\n        i = i?.next\n        index++\n    } while (i != null)\n    return lastIndex ?: -1\n}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207279,"user_id":null,"body":"package kata\n\nobject Kata {\n\tfun lastIndexOf(head: Node?, value: Any): Int {\n        return lastIndexRecursive(0, -1, value, head)\n\t}\n    \n    fun lastIndexRecursive(currentIndex: Int, lastOccurrence: Int, value: Any, head: Node?): Int = when {\n        head == null -> lastOccurrence\n        head.data == value -> lastIndexRecursive(currentIndex+1, currentIndex, value, head.next)\n        else -> lastIndexRecursive(currentIndex+1, lastOccurrence, value, head.next)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207280,"user_id":null,"body":"package kata\n\nobject Kata {\n    fun lastIndexOf(head: Node?, value: Any, index: Int = 0, mem: Int = -1): Int = when {\n        (head?.next == null) && (head?.data == value) ->  index\n        (head?.next == null) && (head?.data != value) && (mem >= 0) ->  mem\n        (head?.next != null) && (head.data == value) ->  lastIndexOf(head.next, value, index + 1, index)\n        (head?.next != null) && (head.data != value) ->  lastIndexOf(head?.next, value, index + 1, mem)\n        else -> -1\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207281,"user_id":null,"body":"package kata\n\nobject Kata {\n\tfun lastIndexOf(head: Node?, value: Any): Int {\n        var index = -1\n        var result = index\n        var node = head\n\t\tdo {\n            index++\n            if (node?.data == value) {\n                result = index\n            }\n            node = node?.next\n        } while (node != null)\n        return result\n\t}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207282,"user_id":null,"body":"package kata\n\nobject Kata {\n\tfun lastIndexOf(head: Node?, value: Any): Int {\n    if (head == null) return -1\n    if (head.next == null) return 0\n    var pos = 0\n    var posOfValue = -1\n    var node = head\n    while (node != null){\n        if (node.data == value){\n            posOfValue = pos\n        }\n        node = node.next\n        pos++\n    }\n        return posOfValue\n\t}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207283,"user_id":null,"body":"package kata\n\nobject Kata {\n\tfun lastIndexOf(head: Node?, value: Any): Int {\n\t\tvar lastIndex = -1\n        var index = 0\n        var node = head\n        while(node != null) {\n            if (node.data == value) lastIndex = index\n            index ++\n            node = node.next\n        }\n        return lastIndex\n\t}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207284,"user_id":null,"body":"package kata\n\nobject Kata {\n\tfun lastIndexOf(head: Node?, value: Any): Int {\n     var vhead = head\n     var res = -1\n     var index = 0\n     while (vhead != null) {\n         if (vhead.data?.equals(value) == true) {\n             res = index\n         }\n         vhead = vhead.next\n         index++\n     }\n     return res\n\t}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207285,"user_id":null,"body":"package kata\n\nobject Kata {\n\tfun lastIndexOf(head: Node?, value: Any): Int {\n \n        head ?: return -1\n\n        val list = mutableListOf<Any>()\n\n        var current = head\n        while (current != null) {\n\n            current.data?.let { list.add(it) }\n\n            current = current.next\n        }\n\n        return list.lastIndexOf(value)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207286,"user_id":null,"body":"package kata\n\nobject Kata {\n    fun lastIndexOf(head: Node?, value: Any): Int {\n        var count = 0\n        var result = -1\n        var currentNode = head\n        while (currentNode != null) {\n            if (currentNode.data == value) result = count\n            \n            currentNode = currentNode.next\n            \n            count += 1\n        }\n        return result   \n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"581ee0db1bbdd04e010002fd":[{"id":207287,"user_id":null,"body":"package approxfloat\n\nfun interp(f: (Double) -> Double, l:Double, u:Double, n:Int):List<Double> {\n    val d = (u - l) \/ n\n\n    return (0 until n).map { Math.floor(f(it * d) * 100.0) \/ 100.0 }.toList()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207288,"user_id":null,"body":"package approxfloat\n\nfun interp(f: (Double) -> Double, l:Double, u:Double, n:Int):List<Double> {\n    val d = (u - l) \/ n\n\n    return (0 until n).map { Math.floor(f(it * d) * 100.0) \/ 100.0 }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207289,"user_id":null,"body":"package approxfloat\n\nfun interp(f:(Double)->Double, l:Double, u:Double, n:Int)=(0 until n ).map{Math.floor(100.0*f(it*(u-l)\/n))\/100.0}.toList()\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207290,"user_id":null,"body":"package approxfloat\n\nfun interp(f: (Double) -> Double, l: Double, u: Double, n: Int): List<Double> {\n    val d = (u - l) \/ n\n    return generateSequence(l) { it + d }.take(n).map(f).map { Math.floor(it * 100) \/ 100.0 }.toList()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207291,"user_id":null,"body":"package approxfloat\n\nimport kotlin.math.floor\n\nfun interp(f: (Double) -> Double, l: Double, u: Double, n: Int): List<Double> = with((u - l) \/ n) {\n    return (0 until n).map { floor(f(l + it * this) * 100) \/ 100 }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207292,"user_id":null,"body":"package approxfloat\n\nimport kotlin.math.floor\n\nfun interp(f: (Double) -> Double, l: Double, u: Double, n: Int): List<Double> = with((u - l) \/ n) {\n    return (0 until n).map { floor(f(l + it * this) * 100) \/ 100 }.toList()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207293,"user_id":50,"body":"package approxfloat\n\nfun interp(f: (_: Double) -> Double, l:Double, u:Double, n:Int):List<Double> {\n    var d=(u-l)\/n.toDouble()\n    var o=ArrayList<Double>()\n    for (k in (0..n-1)){\n        o.add(Math.floor(f(l+k*d)*100)\/100)\n    }\n    return o\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207294,"user_id":null,"body":"package approxfloat\n\nfun interp(f: (x: Double) -> Double, l:Double, u:Double, n:Int):List<Double> {\n\n    val list = mutableListOf<Double>()\n    val d = (u - l) \/ n\n    for(i in 0..(n-1)) {\n       var fx = f(i*d + l)\n       list.add(Math.floor(fx * 100)\/100)\n       \n    }\n    return list\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207295,"user_id":null,"body":"package approxfloat\n\nimport kotlin.math.floor\n\nfun interp(f: (Double) -> Double, l: Double, u: Double, n: Int): List<Double> {\n    val d = (u - l) \/ n\n    return List(n) { floor(f(l + d * it) * 100.0) \/ 100.0 }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207296,"user_id":null,"body":"package approxfloat\n\nfun interp(f: (Double) -> Double, l: Double, u: Double, n: Int): List<Double> =\n    MutableList<Double>(n){ l + it * (u - l) \/ n }\n        .map{ f(it) }\n        .map{ Math.floor(it * 100) \/ 100 }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"58235a167a8cb37e1a0000db":[{"id":207297,"user_id":527,"body":"fun numberOfPairs(gloves: List<String>): Int {\n    return gloves.groupingBy{ it }.eachCount().values.sumOf{ it \/ 2 }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207298,"user_id":null,"body":"fun numberOfPairs(l: List<String>) = l.groupBy { it }.values.sumOf { it.size \/ 2 }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207299,"user_id":null,"body":"fun numberOfPairs(gloves: List<String>) = gloves.groupBy { it }.map { it.value.count() \/ 2 }.sum()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207300,"user_id":null,"body":"fun numberOfPairs(gloves: List<String>): Int = gloves.groupBy { it }.map { it.value.size \/ 2 }.sum()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207301,"user_id":932,"body":"fun numberOfPairs(gloves:List<String>)=gloves.groupBy{it}.map{it.value.size\/2}.sum()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207302,"user_id":null,"body":"fun numberOfPairs(gloves: List<String>) = gloves.groupBy { it }.values.sumOf { it.size \/ 2 }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207303,"user_id":null,"body":"fun numberOfPairs(gloves: List<String>) : Int {\n    var glovesSeen: MutableList<String> = mutableListOf()\n    var pairCount: Int = 0\n    \n    for (g in gloves) {\n        if (glovesSeen.contains(g)) {\n            pairCount += 1\n            glovesSeen.remove(g)\n        } else {\n            glovesSeen.add(g)\n        }\n    }\n    return pairCount\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207304,"user_id":null,"body":"fun numberOfPairs(gloves:List<String>) : Int {\n      val hashGloves: MutableMap<String, Int> = mutableMapOf()\n    gloves.map { hashGloves[it] = (hashGloves[it] ?: 0) + 1 }\n    var sum = 0\n    for (elem in hashGloves) {\n        sum += elem.value \/ 2\n    }\n    return sum\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207305,"user_id":null,"body":"fun numberOfPairs(gloves:List<String>) : Int {\n    var pairs = 0\n    gloves.toSet().forEach { color -> \n        val sameGloves = gloves.count { it == color }\n        pairs += sameGloves \/ 2\n    }\n    return pairs\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207306,"user_id":null,"body":"fun numberOfPairs(gloves:List<String>) : Int {\n    var i = 0\n    var pairs = 0\n    val glovesSort = gloves.sorted()\n\n    while (i < (glovesSort.size - 1)){ if (glovesSort[i] == glovesSort[i+1]) { pairs++; i += 2 }  else i ++ }\n    return pairs\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"582cb0224e56e068d800003c":[{"id":207307,"user_id":null,"body":"fun litres(time: Double) = time.toInt() \/ 2","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207308,"user_id":null,"body":"fun litres(time: Double) = Math.floor(time\/2).toInt()\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207309,"user_id":1267,"body":"fun litres(time: Double) = (time\/2).toInt()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207310,"user_id":null,"body":"fun litres(time: Double): Int = (time * 0.5).toInt()\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207311,"user_id":null,"body":"fun litres(time: Double): Int {\n    val waterPerHour = 0.5\n    return Math.floor((time * waterPerHour)).toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207312,"user_id":null,"body":"import kotlin.math.roundToInt\nfun litres(t: Double): Int = t.div(2).toInt()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207313,"user_id":null,"body":"fun main () {\n    litres(10.0)\n}\nfun litres(time: Double): Int {\n  var q = 0.5 * time\n    return q.toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207314,"user_id":null,"body":"fun litres(t:Double)=t.toInt()\/2","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207315,"user_id":null,"body":"import kotlin.math.floor\n\nfun litres(time: Double): Int = floor( time * 0.5).toInt()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207316,"user_id":null,"body":"fun litres(time: Double): Int {\n    return time.toInt().div(2)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"582e0450fe38013dbc0002d3":[{"id":207317,"user_id":1153,"body":"package regexTicTacToeWinChecker\n\nfun winChecker(board : String) : Boolean {\n  return Regex(\"(\\\\w)(..(\\\\1|.\\\\1.)..\\\\1|.\\\\1.\\\\1..$|\\\\1\\\\1(...)*$)\").find(board) != null\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207318,"user_id":null,"body":"package regexTicTacToeWinChecker\n\nfun winChecker(board: String): Boolean {\n    board.also {\n        when {\n            it[0] == it[1] && it[0] == it[2] && it[0] != '-' -> return true\n            it[0] == it[4] && it[0] == it[8] && it[0] != '-' -> return true\n            it[0] == it[3] && it[0] == it[6] && it[0] != '-' -> return true\n            it[1] == it[4] && it[1] == it[7] && it[1] != '-' -> return true\n            it[2] == it[5] && it[2] == it[8] && it[2] != '-' -> return true\n            it[2] == it[4] && it[2] == it[6] && it[2] != '-' -> return true\n            it[3] == it[4] && it[3] == it[5] && it[3] != '-' -> return true\n            it[6] == it[7] && it[6] == it[8] && it[6] != '-' -> return true\n        }\n    }\n    return false\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207319,"user_id":null,"body":"package regexTicTacToeWinChecker\n\nfun winChecker(board : String) : Boolean {\n  val ca = board.toCharArray()\n\n    val win = Array(8, {IntArray(3)})\n    win[0] = intArrayOf(0, 1, 2)\n    win[1] = intArrayOf(3, 4, 5)\n    win[2] = intArrayOf(6, 7, 8)\n    win[3] = intArrayOf(0, 3, 6)\n    win[4] = intArrayOf(1, 4, 7)\n    win[5] = intArrayOf(2, 5, 8)\n    win[6] = intArrayOf(0, 4, 8)\n    win[7] = intArrayOf(2, 4, 6)\n\n    for(index in 0..7) {\n        if(ca[win[index][0]] == 'X' && ca[win[index][1]] == 'X' && ca[win[index][2]] == 'X') {\n            return true\n        }\n        if(ca[win[index][0]] == 'O' && ca[win[index][1]] == 'O' && ca[win[index][2]] == 'O') {\n            return true\n        }\n    }\n\n    return false\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207320,"user_id":null,"body":"package regexTicTacToeWinChecker\n\nfun countNumbRow(board: String): Int {\n    var counter = 0;\n    for (i in 0..board.length - 1) {\n        if (board[i] == '-') {\n            counter += 1;\n        }\n    }\n    return counter;\n}\n\nfun splitString(board: String): List<String> {\n    var tecTacList = arrayListOf<String>();\n\n    var tecTacWord = \"\"\n    println(board.length)\n    for (i in board.indices) {\n        tecTacWord += board[i]\n        tecTacWord.trim()\n        if (i == 2) {\n            tecTacList.add(tecTacWord.trim())\n            tecTacWord = \"\"\n\n        } else if (i == 5) {\n            tecTacList.add(tecTacWord.trimIndent())\n            tecTacWord = \"\"\n        } else if (i == 8) {\n            tecTacList.add(tecTacWord.trimIndent())\n            tecTacWord = \"\"\n        }\n\n\n    }\n\n    return tecTacList\n}\n\nfun winChecker(board: String): Boolean {\n    if (countNumbRow(board) == 9)\n        return false\n    var listSplit = splitString(board)\n    for (i in 0..listSplit.size) {\n        if (i == 0) {\n\n            if (listSplit[0][0] == 'O' && listSplit[0][1] == 'O' && listSplit[0][2] == 'O') {\n                return true\n            } else if (listSplit[0][0] == 'X' && listSplit[0][1] == 'X' && listSplit[0][2] == 'X') {\n                return true\n            } else if (listSplit[0][0] == 'X' && listSplit[1][0] == 'X' && listSplit[2][0] == 'X') {\n                return true\n            } else if (listSplit[0][0] == 'O' && listSplit[1][0] == 'O' && listSplit[2][0] == 'O') {\n                return true\n            } else if (listSplit[0][1] == 'O' && listSplit[1][1] == 'O' && listSplit[2][1] == 'O') {\n                return true\n            } else if (listSplit[0][1] == 'X' && listSplit[1][1] == 'X' && listSplit[2][1] == 'X') {\n                return true\n            } else if (listSplit[0][2] == 'O' && listSplit[1][2] == 'O' && listSplit[2][2] == 'O') {\n                return true\n            } else if (listSplit[0][2] == 'X' && listSplit[1][2] == 'X' && listSplit[2][2] == 'X') {\n                return true\n            } else if (listSplit[0][0] == 'O' && listSplit[1][1] == 'O' && listSplit[2][2] == 'O') {\n                return true\n            } else if (listSplit[0][0] == 'X' && listSplit[1][1] == 'X' && listSplit[2][2] == 'X') {\n                return true\n            } else if (listSplit[0][2] == 'O' && listSplit[1][1] == 'O' && listSplit[2][0] == 'O') {\n                return true\n            } else if (listSplit[0][2] == 'X' && listSplit[1][1] == 'X' && listSplit[2][0] == 'X') {\n                return true\n            }\n        } else if (i == 1) {\n            if (listSplit[1][0] == 'O' && listSplit[1][1] == 'O' && listSplit[1][2] == 'O') {\n                return true\n            } else if (listSplit[1][0] == 'X' && listSplit[1][1] == 'X' && listSplit[1][2] == 'X') {\n                return true\n            }\n        } else {\n            if (listSplit[2][0] == 'O' && listSplit[2][1] == 'O' && listSplit[2][2] == 'O') {\n                return true\n            } else if (listSplit[2][0] == 'X' && listSplit[2][1] == 'X' && listSplit[2][2] == 'X') {\n                return true\n            }\n        }\n    }\n    return false\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207321,"user_id":null,"body":"package regexTicTacToeWinChecker\n\nfun winChecker(board : String) : Boolean {\n  \tvar regex1 = \"XXX......|...XXX...|......XXX|X..X..X|X...X...X|..X.X.X..\".toRegex()\n\tvar regex2 = \"OOO......|...OOO...|......OOO|O..O..O|O...O...O|..O.O.O..\".toRegex()\n    return regex1.containsMatchIn(board) || regex2.containsMatchIn(board)\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207322,"user_id":null,"body":"package regexTicTacToeWinChecker\n\nfun winChecker(board : String) : Boolean = (\"(...){0,2}(XXX|OOO).*|.*([XO])(..\\\\3){2}.*|([XO])(...\\\\5){2}|..([XO]).\\\\7.\\\\7..\")\n    .toRegex()\n    .matches(board)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207323,"user_id":null,"body":"package regexTicTacToeWinChecker\n\nfun winChecker(board : String) : Boolean {\n    \/\/sorry, don't know Regex yet\n    listOf(\"XXX\",\"OOO\").forEach {xxx->\n        board.chunked(3).forEach{ if (it.toString()==xxx) return true} \n        val bc = board.toCharArray()\n        (0..2).forEach {if (\"\"+bc[0+it]+bc[3+it]+bc[6+it]==xxx) return true}\n        if (\"\"+bc[0]+bc[4]+bc[8]==xxx || \"\"+bc[2]+bc[4]+bc[6]==xxx) return true\n    }\n    return false\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207324,"user_id":null,"body":"package regexTicTacToeWinChecker\n\nfun winChecker(board: String) : Boolean {\n    val horizontal = \"(X{3}.{6})|(.{3}X{3}.{3})|(.{6}X{3})|(O{3}.{6})|(.{3}O{3}.{3})|(.{6}O{3})\".toRegex()\n    val vertical = \"((X(.{2})){2}X)|((O(.{2})){2}O)\".toRegex()\n    var diagonal = \"((X(.{3})){2}X)|(..(X.){3}.)|((O(.{3})){2}O)|(..(O.){3}.)\".toRegex()\n    when {\n        horizontal.containsMatchIn(board) -> return true\n        vertical.containsMatchIn(board) -> return true\n        diagonal.containsMatchIn(board) -> return true\n        else -> return false\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207325,"user_id":null,"body":"package regexTicTacToeWinChecker\n\nfun winChecker(board : String) : Boolean {\n    val regex = Regex(\"([X]{3})|([O]{3})\")\n    val horiz01 = board.subSequence(0,3).toString()\n    val horiz02 = board.subSequence(3,6).toString()\n    val horiz03 = board.subSequence(6,9).toString()\n    val vert01 = \"${board[0]}${board[3]}${board[6]}\"\n    val vert02 = \"${board[1]}${board[4]}${board[7]}\"\n    val vert03 = \"${board[2]}${board[5]}${board[8]}\"\n    val diag01 = \"${board[0]}${board[4]}${board[8]}\"\n    val diag02 = \"${board[2]}${board[4]}${board[6]}\"\n    val arrayOfLines: Array<String> = arrayOf(horiz01,horiz02, horiz03,vert01,vert02, vert03,diag01, diag02)\n    var returnBool = false\n    for(array in arrayOfLines){\n        println(array)\n        if(regex.matches(array)){\n            returnBool = true\n            }\n    }\n    println(returnBool)\n    return returnBool\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207326,"user_id":null,"body":"package regexTicTacToeWinChecker\n\nfun winChecker(board : String) : Boolean {\n  var t = false\n\n   for (g in 0 .. 8 step 3) {\n       if ((board[0 + g] == board[1 + g] && board[0 + g] == board[2 + g]) && board[0 + g] != '-') {\n           t = true\n       }\n          }\n      for (g in 0 .. 2 ) {\n          if ((board[0 + g] == board[3 + g] && board[0 + g] == board[6 + g])&& board[0 + g] != '-') {\n              t = true\n          }\n      }\n      if ((board[0 ] == board[4] && board[0] == board[8])&& board[0] != '-') {\n          t = true\n      }\n      if ((board[2] == board[4] && board[2] == board[6])&& board[2] != '-') {\n          t = true\n      }\n\n   return t\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"583710ccaa6717322c000105":[{"id":207327,"user_id":null,"body":"fun simple_multiplication(n: Int): Int {\n    return n * if (n % 2 == 0) 8 else 9\n}","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207328,"user_id":null,"body":"fun simple_multiplication(n: Int) = n * (8 + n%2)\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207329,"user_id":42,"body":"fun simple_multiplication(n: Int): Int {\n    return n * (8 + n%2);\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207330,"user_id":470,"body":"fun simple_multiplication(n:Int): Int{\n\tif (n % 2 == 0){return n * 8}\n\treturn n * 9\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207331,"user_id":null,"body":"fun simple_multiplication(n: Int): Int = n * when {\n  n % 2 == 0 -> 8\n  else -> 9\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207332,"user_id":null,"body":"\tfun simple_multiplication(n: Int) = if (n % 2 == 0) {\n\t\tn * 8\n\t} else {\n\t\tn * 9\n\t}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207333,"user_id":null,"body":"fun simple_multiplication(n: Int): Int = (8+n%2)*n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207334,"user_id":null,"body":"fun simple_multiplication(n: Int) = when { n % 2 == 0 -> n * 8 else -> n * 9 }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207335,"user_id":null,"body":"fun simple_multiplication(n: Int): Int {\n    var i8 = n * 8\n    var i9 = n * 9\n    \n   return if(n % 2 == 0 )  i8\n        \n    else i9\n    \n        \n        \n    \n    \n    \n \n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207336,"user_id":null,"body":"fun simple_multiplication(n: Int): Int = n*8 + n*(n%2)\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5839edaa6754d6fec10000a2":[{"id":207337,"user_id":953,"body":"fun find_missing_letter(array: CharArray) = (array.first()..array.last()).first { it !in array }","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207338,"user_id":null,"body":"fun find_missing_letter(array: CharArray): Char = (array.first()..array.last()).filterNot { it in array }.first()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207339,"user_id":null,"body":"fun find_missing_letter(array: CharArray): Char {\n    val alph = mapOf(\n        'a' to 1, 'b' to 2,\n        'c' to 3, 'd' to 4,\n        'e' to 5, 'f' to 6,\n        'g' to 7, 'h' to 8,\n        'i' to 9, 'j' to 10,\n        'k' to 11, 'l' to 12,\n        'm' to 13, 'n' to 14,\n        'o' to 15, 'p' to 16,\n        'q' to 17, 'r' to 18,\n        's' to 19, 't' to 20,\n        'u' to 21, 'v' to 22,\n        'w' to 23, 'x' to 24,\n        'y' to 25, 'z' to 26\n        )\n    val lowercased = array.map { it.toLowerCase() }\n    var missingLetter = 'a'\n    \n    lowercased.forEachIndexed { index, letter -> \n      if (index > 0) {\n        if (alph[letter]!!.minus(alph[lowercased[index - 1]]!!) == 2) {\n          for ((key, value) in alph) {\n            if (value == alph[letter - 1]) {\n                   missingLetter = key\n            }\n          }\n        }\n      }\n    }\n    \n    if (array[0] == array[0].toUpperCase()) {\n        missingLetter = missingLetter.toUpperCase()\n    }\n    \n    return missingLetter\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207340,"user_id":null,"body":"fun find_missing_letter(array: CharArray): Char =\n    array.toList().windowed(2).first { it[0].inc() != it[1] }.first().inc()\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207341,"user_id":null,"body":"fun find_missing_letter(array: CharArray) = (array[0]..array[array.size - 1]).find { !array.contains(it) }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207342,"user_id":null,"body":"fun find_missing_letter(array: CharArray): Char = (array.first()..array.last()).subtract(array.toList()).first()\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207343,"user_id":null,"body":"fun find_missing_letter(array: CharArray): Char\n    = array.toList().zipWithNext().first { (current, next) -> next - current == 2}.second -1\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207344,"user_id":null,"body":"fun find_missing_letter(array: CharArray) = (array.first()..array.last()).find { it !in array }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207345,"user_id":null,"body":"fun find_missing_letter(array: CharArray): Char {\n   var letterAux = array[0]\n        array.forEach { if (letterAux != it) return letterAux else ++letterAux }\n    return ' '\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207346,"user_id":null,"body":"fun find_missing_letter(array: CharArray): Char {\n   for (i in array.indices) {\n       if (array[i] != array[i + 1] - 1) return array[i] + 1\n   }\n   return ' '\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5848565e273af816fb000449":[{"id":207347,"user_id":null,"body":"fun encrypt_this(text:String): String{\n    return text.split(\" \").map { it.first().toInt().toString() + it.drop(2).takeLast(1) + it.drop(2).dropLast(1) + it.drop(1).take(1) }.joinToString(\" \")\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207348,"user_id":null,"body":"import java.util.regex.Pattern\nimport java.util.stream.Collectors\n\nfun encrypt_this(text: String): String = Pattern.compile(\" +\").splitAsStream(text).map(mapper).collect(Collectors.joining(\" \"))\n\nprivate val mapper = { word: String ->\n    val builder = StringBuilder().append(word[0].toInt())\n    when (word.length) {\n        1    -> {}\n        2    -> builder.append(word[1])\n        else -> builder.append(word[word.length - 1]).append(word.subSequence(2, word.length - 1)).append(word[1])\n    }\n    builder.toString()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207349,"user_id":null,"body":"fun encrypt_this(text: String) = text.split(\" \").joinToString(\" \") {\n    it.mapIndexed { i, char ->\n        when (i) {\n            0 -> char.toInt().toString()\n            1 -> it.last().toString()\n            it.lastIndex -> it[1].toString()\n            else -> char.toString()\n        }\n    }.joinToString(\"\")\n}","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207350,"user_id":null,"body":"fun encrypt_this(text:String): String{\n    \/\/ Your awesome code goes here!\n    return text.split(\" \").joinToString(\" \") {\n            if (it.length > 2) \"${it.first().toInt()}${it.takeLast(1)}${it.subSequence(2,it.length-1)}${it[1]}\"\n            else \"${it.first().toInt()}${it.drop(1)}\"\n        }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207351,"user_id":null,"body":"fun encrypt_this(message: String): String {\n    val swapLetters = { s: String -> s.takeLast(1) + s.drop(1).dropLast(1) + s.take(1) }\n\n    return message.split(\" \").joinToString(\" \") { word ->\n        var result = word\n        if (word.length >= 3) result = word.take(1) + swapLetters(word.drop(1))\n        result.first().code.toString() + result.drop(1)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207352,"user_id":null,"body":"fun encrypt_this(text:String): String = text.split(\" \").joinToString(\" \") { it.first().code.toString() + if (it.length > 1) it.last() + if (it.length > 2) it.substring(2, it.length - 1) + it[1] else \"\" else \"\" }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207353,"user_id":null,"body":"fun encrypt_this(text: String): String {\n    var str = mutableListOf<String>()\n\n    for (word in text.split(\" \")) {\n        if (word.length == 1) str += word.replaceFirstChar { word.first().code.toString() }\n        else {\n            val secondSymbol = word[1].toString()\n            str += word\n                .replaceRange(1, 2, word[word.length - 1].toString())\n                .replaceRange(word.length - 1, word.length, secondSymbol)\n                .replaceFirstChar { word.first().code.toString() }\n        }\n    }\n    return str.joinToString(\" \")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207354,"user_id":null,"body":"fun encrypt_this(text:String): String =text.split(\" \").map{when(it.length) {\n        1 -> it[0].toInt().toString()\n        2 -> it[0].toInt().toString() + it[1]\n        else -> it[0].toInt().toString() + it[it.length - 1] + it.subSequence(2, it.length - 1) + it[1]\n    }}.joinToString(\" \")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207355,"user_id":null,"body":"fun encrypt_this(text:String): String{\n var s = text.split(\" \")\n var result =\"\"\n s.forEach{\n   if(it.length ==1)result = \"$result ${it[0].toInt()}\"\n  else if(it.length>2)\n  result = \"$result ${it[0].toInt()}${it[it.length-1]}${it.substring(2,it.length-1)}${it[1]}\"\n  else result = \"$result ${it[0].toInt()}${it[1]}\"\n }\n return result.trim()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207356,"user_id":null,"body":"  fun encrypt_this(text: String): String {\n        val list = mutableListOf<String>()\n        text.split(\" \").forEach {\n            if (it.length == 1) {\n                list.add(it.first().toInt().toString())\n            } else {\n                val sb = StringBuilder()\n                sb.append(it.first().toInt())\n                val chars = it.drop(1).toCharArray()\n                val temp = chars.first()\n                chars[0] = chars.last()\n                chars[chars.lastIndex] = temp\n                \n                sb.append(chars)\n                list.add(sb.toString())\n            }\n        }\n\n        return list.joinToString(\" \")\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"58485a43d750d23bad0000e6":[{"id":207357,"user_id":null,"body":"package fizzBuzzCuckooClock\n\nfun fizzBuzzCuckooClock(time: String) : String {\n    val (hour, minute) = time.split(\":\").map(String::toInt)\n    return when {\n        minute == 0 ->\n            \"Cuckoo \".repeat(\n                (hour % 12).let {\n                    if (it == 0) 12 else it\n                }\n            ).dropLast(1)\n        minute == 30 -> \"Cuckoo\"\n        minute % 15 == 0 -> \"Fizz Buzz\"\n        minute % 5 == 0 -> \"Buzz\"\n        minute % 3 == 0 -> \"Fizz\"\n        else -> \"tick\"\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207358,"user_id":null,"body":"package fizzBuzzCuckooClock\n\n private val CUCKOO = \"Cuckoo\"\nprivate val FIZZ = \"Fizz\"\nprivate val BUZZ = \"Buzz\"\nprivate val TICK = \"tick\"\n\nfun fizzBuzzCuckooClock(time: String): String {\n    val (hours, minutes) = time.split(\":\").map { it.toInt() }\n    return when {\n        minutes == 0 -> List(if (hours in 1..12) hours else Math.abs(hours - 12)) { CUCKOO }.joinToString(\" \")\n        minutes == 30 -> CUCKOO\n        minutes % 15 == 0 -> \"$FIZZ $BUZZ\"\n        minutes % 5 == 0 -> BUZZ\n        minutes % 3 == 0 -> FIZZ\n        else -> TICK\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207359,"user_id":null,"body":"package fizzBuzzCuckooClock\n\nfun fizzBuzzCuckooClock(time: String) : String {\n\n    if (time.length != 5) return \"Wrong time-sting length!\"\n    var hh = 0; var mm = 0\n    try {\n        hh = time.take(2).toInt()%12\n        if (hh==0) hh = 12\n        mm = time.takeLast(2).toInt()\n        }\n    catch (t: Throwable) {\n        println(\"Error reading time from the string! ${t.message}\")\n    }\n    \n    if (mm%3==0 && mm%5==0) {\n        if (mm==0) return \"Cuckoo \".repeat(hh).trimEnd()\n        if (mm==30) return \"Cuckoo\"\n        return \"Fizz Buzz\"\n    } \n    if (mm%3==0) return \"Fizz\"\n    if (mm%5==0) return \"Buzz\"\n    \n    return \"tick\"\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207360,"user_id":null,"body":"package fizzBuzzCuckooClock\n\nfun fizzBuzzCuckooClock(time: String) =\n    time.takeLast(2).toInt().let { \n        when {\n             it == 0 -> (\"Cuckoo \".repeat((time.take(2).toInt() % 12)\n                                          .takeIf{ it != 0} ?: 12)\n                        ).dropLast(1)\n            it == 30 -> \"Cuckoo\"\n        it % 15 == 0 -> \"Fizz Buzz\"\n        it %  5 == 0 -> \"Buzz\"\n        it %  3 == 0 -> \"Fizz\"\n                else -> \"tick\"\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207361,"user_id":null,"body":"package fizzBuzzCuckooClock\n\nprivate val CUCKOO = \"Cuckoo\"\nprivate val FIZZ = \"Fizz\"\nprivate val BUZZ = \"Buzz\"\nprivate val TICK = \"tick\"\n\nfun fizzBuzzCuckooClock(time: String): String {\n    val (hours, minutes) = time.split(\":\").map { it.toInt() }\n    return when {\n        minutes == 0 -> \"$CUCKOO \".repeat(if(hours in 1..12) hours else Math.abs(hours - 12)).dropLast(1)\n        minutes == 30 -> CUCKOO\n        minutes % 15 == 0 -> \"$FIZZ $BUZZ\"\n        minutes % 5 == 0 -> BUZZ\n        minutes % 3 == 0 -> FIZZ\n        else -> TICK\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207362,"user_id":null,"body":"package fizzBuzzCuckooClock\n\nfun fizzBuzzCuckooClock(time: String) : String {\n  val minutes = time.substring(3..4).toInt()\n  val hours = (time.substring(0..1).toInt() % 12).takeIf { it != 0 } ?: 12\n  return when {\n    minutes == 0 -> \"Cuckoo \".repeat(hours).dropLast(1)\n    minutes == 30 -> \"Cuckoo\"\n    minutes % 15 == 0 -> \"Fizz Buzz\"\n    minutes % 3 == 0 -> \"Fizz\"\n    minutes % 5 == 0 -> \"Buzz\"\n    else -> \"tick\"\n  }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207363,"user_id":null,"body":"package fizzBuzzCuckooClock\n\nfun fizzBuzzCuckooClock(time: String) = time.split(\":\")\n        .map(String::toInt)\n        .let{ Pair(it.first() % 12, it.last()) }\n        .let{ (h, m)-> when {\n            m == 0 -> Array(if(h == 0) 12 else h){\"Cuckoo\"}.joinToString(\" \")\n            m == 30 -> \"Cuckoo\"\n            m % 15 == 0 -> \"Fizz Buzz\"\n            m % 3 == 0 -> \"Fizz\"\n            m % 5 == 0 -> \"Buzz\"\n            else -> \"tick\"\n            }\n       }\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207364,"user_id":null,"body":"package fizzBuzzCuckooClock\n\nfun fizzBuzzCuckooClock(time: String): String {\n    val clock = time.split(\":\")\n    var hour = Integer.parseInt(clock[0])\n    val minutes = Integer.parseInt(clock[1])\n    var result = \"\"\n    when {\n        hour >= 0 && minutes == 0 -> {\n            if (hour > 12) hour -= 12\n            if (hour == 0) hour = 12\n            for (i in 1..hour) {\n                result += \"Cuckoo \"\n            }\n            result = result.trim()\n        }\n\n        minutes == 30 -> result = \"Cuckoo\"\n        minutes % 5 == 0 && minutes % 3 == 0 -> result = \"Fizz Buzz\"\n        minutes % 5 == 0 -> result = \"Buzz\"\n        minutes % 3 == 0 -> result = \"Fizz\"\n        else -> result = \"tick\"\n\n    }\n\n\n\n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207365,"user_id":null,"body":"package fizzBuzzCuckooClock\n\nfun fizzBuzzCuckooClock(time: String): String {\n\n    var (hour, minute) = time.split(\":\").map { it.toInt() }\n    if (hour in 1..12) hour else hour = Math.abs(hour-12)\n    \n    return when {\n        minute == 0 -> \"Cuckoo \".repeat(hour).dropLast(1)\n        minute == 30 -> \"Cuckoo\"\n        minute % 15 == 0 -> \"Fizz Buzz\"\n        minute % 3 == 0 -> \"Fizz\"\n        minute % 5 == 0 -> \"Buzz\"\n        else -> \"tick\"\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207366,"user_id":null,"body":"package fizzBuzzCuckooClock\n\nfun fizzBuzzCuckooClock(time: String): String {\n\n    var (hour, minute) = time.split(\":\").map { it.toInt() }\n    if (hour in 1..12) hour else hour = Math.abs(hour-12)\n    \n    if (minute == 0) {\n        val cuckoo = \"Cuckoo \".repeat(hour).dropLast(1)\n        return cuckoo\n    } else if (minute == 30) {\n        return \"Cuckoo\"\n    } else if (minute == 15 || minute == 45) {\n        return \"Fizz Buzz\"\n    } else if (minute % 3 == 0) {\n        return \"Fizz\"\n    } else if (minute % 5 == 0) {\n        return \"Buzz\"\n    } else return \"tick\"\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"585894545a8a07255e0002f1":[{"id":207367,"user_id":179,"body":"package solution\n\nimport kotlin.math.sqrt\n\nconst val size = 3\nval vectors = listOf(1 to 0, 1 to 1, 2 to 1, 2 to -1)\n\nfun countPatternsFrom(firstPoint: String, length: Int): Int {\n    if (length == 0) return 0\n    if (length == 1) return 1\n    if (length > size * size) return 0\n    val available = (0 until size).map{BooleanArray(size, {true})}.toTypedArray()\n    val charVal = firstPoint.single() - \"A\".single()\n    return countPatternsFrom((charVal % size) to (charVal \/ size), length, available)\n}\n\nfun countPatternsFrom(point: Pair<Int, Int>, length: Int, available: Array<BooleanArray>): Int {\n    if (length == 1) return 1\n    val a = available.copy()\n    a[point.first][point.second] = false\n    var num = 0\n    vectors.forEach { vector ->\n        var rotatingVector = vector\n        (0 until 4).forEach {\n            var goingVector = rotatingVector\n            var currPoint = point + goingVector\n            while (inBounds(currPoint)) {\n                if (isAvailable(available, currPoint)) {\n                    num += countPatternsFrom(currPoint, length - 1, a)\n                    break\n                }\n                goingVector += rotatingVector\n                currPoint = point + goingVector\n            }\n            rotatingVector = rotatingVector.r90()\n        }\n    }\n    return num;\n}\n\nfun isAvailable(available: Array<BooleanArray>, point: Pair<Int, Int>) = when {\n    !inBounds(point) -> false\n    else -> available[point.first][point.second]\n}\nfun inBounds(point: Pair<Int, Int>) = when {\n    point.first < 0 -> false\n    point.second < 0 -> false\n    point.first >= size -> false\n    point.second >= size -> false\n    else -> true\n}\n\nfun Array<BooleanArray>.copy() = this.map { it.clone() }.toTypedArray()\nfun Pair<Int, Int>.r90() = this.second to (this.first * -1)\noperator fun Pair<Int, Int>.plus(other: Pair<Int, Int>) = (this.first + other.first) to (this.second + other.second)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207368,"user_id":null,"body":"package solution\n\ninline fun <T> MutableList<Char>.withVertex(vertex: Char, action: (MutableList<Char>) -> T): T {\n    this += vertex\n    val result = action(this)\n    this -= vertex\n    return result\n}\n\nfun countPatternsFrom(string: String, length: Int) = if (length !in 1..9) 0 else countPatternsFrom(length, mutableListOf(string[0]))\n\nfun countPatternsFrom(length: Int, visited: MutableList<Char>): Int {\n\n    fun skipVisited(to: Char, skipped: Char) =\n        if (to in visited || skipped !in visited) 0\n        else visited.withVertex(to) { countPatternsFrom(length, visited) }\n\n    fun transition(to: Char) =\n        if (to in visited) 0\n        else visited.withVertex(to) { countPatternsFrom(length, visited) }\n\n    fun corner(from: Char, b: Char, c: Char, d: Char, g: Char, i: Char) =\n        ('A'..'I').asSequence().filter { it !in listOf(from, c, g, i) }.sumBy { transition(it) } + skipVisited(c, b) +\n            skipVisited(g, d) + skipVisited(i, 'E')\n\n    fun side(to: Char) =\n        ('A'..'I').asSequence().filter { it != to }.sumBy { transition(it) } + skipVisited(to, 'E')\n\n\n    if (length == visited.size) return 1\n\n    return when (val from = visited.last()) {\n        'A' -> corner(from, 'B', 'C', 'D', 'G', 'I')\n        'B' -> side('H')\n        'C' -> corner(from, 'B', 'A', 'F', 'I', 'G')\n        'D' -> side('F')\n        'E' -> \"ABCDFGHI\".sumBy { transition(it) }\n        'F' -> side('D')\n        'G' -> corner(from, 'H', 'I', 'D', 'A', 'C')\n        'H' -> side('B')\n        'I' -> corner(from, 'F', 'C', 'H', 'G', 'A')\n        else -> 0\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207369,"user_id":null,"body":"package solution\n\n    val needsUsed = mutableMapOf(\n        \"A\" to mutableListOf(Pair(\"E\", \"I\"), Pair(\"B\", \"C\"), Pair(\"D\", \"G\")),\n        \"B\" to mutableListOf(Pair(\"E\", \"H\")),\n        \"C\" to mutableListOf(Pair(\"E\", \"G\"), Pair(\"B\", \"A\"), Pair(\"F\", \"I\")),\n        \"D\" to mutableListOf(Pair(\"E\", \"F\")),\n        \"E\" to mutableListOf(),\n        \"F\" to mutableListOf(Pair(\"E\", \"D\")),\n        \"G\" to mutableListOf(Pair(\"D\", \"A\"), Pair(\"E\", \"C\"), Pair(\"H\", \"I\")),\n        \"H\" to mutableListOf(Pair(\"E\", \"B\")),\n        \"I\" to mutableListOf(Pair(\"E\", \"A\"), Pair(\"F\", \"C\"), Pair(\"H\", \"G\"))\n    )\n\n    fun countPatternsFrom(firstPoint: String, length: Int) =\n        countPatternsFromRec(firstPoint, length - 1, mutableListOf<String>(firstPoint))\n\n    fun countPatternsFromRec(firstPoint: String, length: Int, used: List<String>): Int {\n        if (length == 0) return 1\n        if (length > 8 || length < 0) return 0\n\n        val letters = mutableSetOf<String>(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\").apply { removeAll(used) }\n        needsUsed[firstPoint]!!.forEach { if (!(it.first in used)) letters.remove(it.second) }\n        return letters.map { letter ->\n            countPatternsFromRec(letter, length - 1, used.toMutableList().apply { add(letter) })\n        }.sum()\n    }\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207370,"user_id":null,"body":"package solution\nfun countPatternsFrom(firstPoint: String, length: Int): Int {\n       if (length !in 1..9) {\n        return 0\n    }\n    val possibleList = mutableListOf(firstPoint)\n    var count = 1\n    while (count < length) {\n        val newList = possibleList.toList()\n        newList.forEach { oldString ->\n            canConnectPoints(oldString).forEach { newPoint ->\n                possibleList.add(\"$oldString$newPoint\")\n            }\n        }\n        count++\n        possibleList.removeIf { it.length < count }\n    }\n    return possibleList.size\n}\n\nfun canConnectPoints(connectedString: String): Set<String> {\n    val set = mutableSetOf(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\")\n    connectedString.forEachIndexed { index, char ->\n        set.remove(char.toString())\n        if (index == connectedString.lastIndex) {\n            when (char) {\n                'A' -> {\n                    if (!connectedString.contains('B')) {\n                        set.remove(\"C\")\n                    }\n                    if (!connectedString.contains('E')) {\n                        set.remove(\"I\")\n                    }\n                    if (!connectedString.contains('D')) {\n                        set.remove(\"G\")\n                    }\n                }\n                'B' -> {\n                    if (!connectedString.contains('E')) {\n                        set.remove(\"H\")\n                    }\n                }\n                'C' -> {\n                    if (!connectedString.contains('B')) {\n                        set.remove(\"A\")\n                    }\n                    if (!connectedString.contains('E')) {\n                        set.remove(\"G\")\n                    }\n                    if (!connectedString.contains('F')) {\n                        set.remove(\"I\")\n                    }\n                }\n                'D' -> {\n                    if (!connectedString.contains('E')) {\n                        set.remove(\"F\")\n                    }\n                }\n                'F' -> {\n                    if (!connectedString.contains('E')) {\n                        set.remove(\"D\")\n                    }\n                }\n                'H' -> {\n                    if (!connectedString.contains('E')) {\n                        set.remove(\"B\")\n                    }\n                }\n                'G' -> {\n                    if (!connectedString.contains('D')) {\n                        set.remove(\"A\")\n                    }\n                    if (!connectedString.contains('E')) {\n                        set.remove(\"C\")\n                    }\n                    if (!connectedString.contains('H')) {\n                        set.remove(\"I\")\n                    }\n                }\n                'I' -> {\n                    if (!connectedString.contains('F')) {\n                        set.remove(\"C\")\n                    }\n                    if (!connectedString.contains('E')) {\n                        set.remove(\"A\")\n                    }\n                    if (!connectedString.contains('H')) {\n                        set.remove(\"G\")\n                    }\n                }\n            }\n        }\n    }\n    return set\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207371,"user_id":null,"body":"package solution\nfun countPatternsFrom(points: String, length: Int): Int {\n    if (points.length == length) return 1\n    \n    var sum = 0\n    val lastIdx = charToIdx(points.last())\n    for (pt in 'A'..'I') {\n        var intsct = pathIntersectsIdx(lastIdx, charToIdx(pt))\n        if (!points.contains(pt) && (intsct == -1 || points.contains(idxToChar(intsct)))) \n            sum += countPatternsFrom(points + pt, length)\n    }\n    \n    return sum\n}\n\nfun charToIdx(ch: Char) = (ch - 'A').toInt()\nfun idxToChar(idx: Int) = 'A' + idx\n\nfun pathIntersectsIdx(idx1: Int, idx2: Int): Int {\n    val xdif = idx2 % 3 - idx1 % 3\n    val ydif = idx2 \/ 3 - idx1 \/ 3\n    \n    val does = (xdif == 2 || xdif == -2 || ydif == 2 || ydif == -2) &&\n        !(xdif == 1 || xdif == -1 || ydif == 1 || ydif == -1)\n    return if (does) idx1 + xdif \/ 2 + ydif \/ 2 * 3 else -1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207372,"user_id":null,"body":"package solution\n\n\n\nfun countPatternsFrom(firstPoint: String, length: Int): Int {\n    val allPoints = ('A'..'I').filter { it != firstPoint[0] }\n    val list = mutableListOf(listOf(firstPoint[0]))\n\n    var count = 0\n    while (list.isNotEmpty()) {\n        val points = list.removeFirst()\n        if (points.size == length) {\n            count++\n            continue\n        }\n\n        allPoints.filter {\n            it !in points\n        }.forEach { point ->\n            if (canUse(points, point)) {\n                list.add(points + point)\n            }\n        }\n    }\n    return count\n}\n\nprivate fun canUse(points: List<Char>, point: Char): Boolean {\n    return when (points.last()) {\n        'A' -> when (point) {\n            'C' -> 'B' in points\n            'G' -> 'D' in points\n            'I' -> 'E' in points\n            else -> true\n        }\n        'B' -> when (point) {\n            'H' -> 'E' in points\n            else -> true\n        }\n        'C' -> when (point) {\n            'A' -> 'B' in points\n            'G' -> 'E' in points\n            'I' -> 'F' in points\n            else -> true\n        }\n        'D' -> when (point) {\n            'F' -> 'E' in points\n            else -> true\n        }\n        'E' -> true\n        'F' -> when (point) {\n            'D' -> 'E' in points\n            else -> true\n        }\n        'G' -> when (point) {\n            'C' -> 'E' in points\n            'A' -> 'D' in points\n            'I' -> 'H' in points\n            else -> true\n        }\n        'H' -> when (point) {\n            'B' -> 'E' in points\n            else -> true\n        }\n        'I' -> when (point) {\n            'C' -> 'F' in points\n            'G' -> 'H' in points\n            'A' -> 'E' in points\n            else -> true\n        }\n        else -> false\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207373,"user_id":null,"body":"package solution\nfun countPatternsFrom(firstPoint: String, length: Int): Int {\n    val cornerPoints = setOf(\"A\", \"C\", \"G\", \"I\")\n    when (length) {\n        1 -> return 1\n        2 -> {\n            if (firstPoint == \"E\") return 8\n            if (cornerPoints.contains(firstPoint)) return 5\n            return 7\n        }\n        3 -> {\n            if (firstPoint == \"E\") return 48\n            if (cornerPoints.contains(firstPoint)) return 31\n            return 37\n        }\n        4 -> {\n            if (firstPoint == \"E\") return 256\n            if (cornerPoints.contains(firstPoint)) return 154\n            return 188\n        }\n        5 -> {\n            if (firstPoint == \"E\") return 1152\n            if (cornerPoints.contains(firstPoint)) return 684\n            return 816\n        }\n        6 -> {\n            if (firstPoint == \"E\") return 4248\n            if (cornerPoints.contains(firstPoint)) return 2516\n            return 2926\n        }\n        7 -> {\n            if (firstPoint == \"E\") return 12024\n            if (cornerPoints.contains(firstPoint)) return 7104\n            return 8118\n        }\n        8, 9 -> {\n            if (firstPoint == \"E\") return 23280\n            if (cornerPoints.contains(firstPoint)) return 13792\n            return 15564\n        }\n        else -> return 0\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207374,"user_id":null,"body":"package solution\n\nfun nextPoints(firstPoint: String, visitedPoints: List<String>): List<String> =\n    mapOf(\n        \"A\" to listOf(\"BC\", \"F\", \"EI\", \"H\", \"DG\"),\n        \"B\" to listOf(\"C\", \"F\", \"I\", \"EH\", \"G\", \"D\", \"A\"),\n        \"C\" to listOf(\"FI\", \"H\", \"EG\", \"D\", \"BA\"),\n        \"D\" to listOf(\"A\", \"B\", \"C\", \"EF\", \"I\", \"H\", \"G\"),\n        \"E\" to listOf(\"B\", \"C\", \"F\", \"I\", \"H\", \"G\", \"D\", \"A\"),\n        \"F\" to listOf(\"C\", \"I\", \"H\", \"G\", \"ED\", \"A\", \"B\"),\n        \"G\" to listOf(\"DA\", \"B\", \"EC\", \"F\", \"HI\"),\n        \"H\" to listOf(\"EB\", \"C\", \"F\", \"I\", \"G\", \"D\", \"A\"),\n        \"I\" to listOf(\"FC\", \"HG\", \"D\", \"EA\", \"B\")\n    )[firstPoint]!!.mapNotNull {\n        if (it.substring(0, 1) !in visitedPoints) it.substring(0, 1)\n        else if (it.length > 1 && it.substring(1, 2) !in visitedPoints) it.substring(1, 2)\n        else null\n    }\n\nfun countPatternsFrom(firstPoint: String, length: Int, visitedPoints: List<String> = listOf()): Int {\n    if (length == 1) return 1\n    var count = 0\n    for (point in nextPoints(firstPoint, visitedPoints)) {\n        count += countPatternsFrom(point, length - 1 , visitedPoints + firstPoint)\n    }\n    return count\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207375,"user_id":null,"body":"package solution\n\n\nfun countPatternsFrom(firstPoint: String, length: Int): Int {\n    if (length == 1) return 1\n    if (length > 9 || length < 1) return 0\n\n    val result = mutableListOf<String>()\n    rec(firstPoint, length - 1, firstPoint, length, onPatternsFound = {\n        result.addAll(it)\n    })\n    return result.size\n}\n\nfun rec(point: String, i: Int, pattern: String, length: Int, onPatternsFound: (List<String>) -> Unit) : String {\n    if (i == 0) return \"\"\n    val patterns = find(point = point, used = pattern.chunked(1)).map {\n        val newPattern = pattern + it\n        newPattern + rec(it, i - 1, newPattern, length, onPatternsFound)\n    }\n\n    if (patterns.all { it.length == length }) {\n        onPatternsFound.invoke(patterns)\n    }\n    return \"\"\n}\n\nfun find(point: String, used: List<String>): List<String> {\n    return when (point) {\n        \"E\" -> mutableListOf(\n            \"A\", \"B\", \"C\",\n            \"D\",      \"F\",\n            \"G\", \"H\", \"I\",\n        )\n        in listOf(\"B\", \"H\") -> mutableListOf(\n            \"A\",      \"C\",\n            \"D\", \"E\", \"F\",\n            \"G\",      \"I\",\n        ).apply {\n            if (used.contains(\"E\")) {\n                if (point == \"B\") add(\"H\")\n                if (point == \"H\") add(\"B\")\n            }\n        }\n        in listOf(\"D\", \"F\") -> mutableListOf(\n            \"A\", \"B\", \"C\",\n                 \"E\",\n            \"G\", \"H\", \"I\",\n        ).apply {\n            if (used.contains(\"E\")) {\n                if (point == \"D\") add(\"F\")\n                if (point == \"F\") add(\"D\")\n            }\n        }\n        in listOf(\"A\", \"I\", \"C\", \"G\") -> mutableListOf(\n                 \"B\",\n            \"D\", \"E\", \"F\",\n                 \"H\",\n        ).apply {\n            if (used.contains(\"E\")) {\n                if (point == \"A\") add(\"I\")\n                if (point == \"I\") add(\"A\")\n                if (point == \"C\") add(\"G\")\n                if (point == \"G\") add(\"C\")\n            }\n            if (used.contains(\"D\")) {\n                if (point == \"A\") add(\"G\")\n                if (point == \"G\") add(\"A\")\n            }\n            if (used.contains(\"B\")) {\n                if (point == \"A\") add(\"C\")\n                if (point == \"C\") add(\"A\")\n            }\n            if (used.contains(\"F\")) {\n                if (point == \"I\") add(\"C\")\n                if (point == \"C\") add(\"I\")\n            }\n            if (used.contains(\"H\")) {\n                if (point == \"I\") add(\"G\")\n                if (point == \"G\") add(\"I\")\n            }\n        }\n        else -> emptyList()\n    }.minus(used.toSet())\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207376,"user_id":null,"body":"package solution\n\nfun countPatternsFrom(firstPoint: String, length: Int): Int {\n    if (length == 1) return 1\n    if (length > 9 || length < 1) return 0\n\n    val result = mutableListOf<String>()\n    rec(firstPoint, length - 1, firstPoint, length, onPatternsFound = {\n        result.addAll(it)\n    })\n    return result.size\n}\n\nfun rec(point: String, i: Int, pattern: String, length: Int, onPatternsFound: (List<String>) -> Unit) : String {\n    val patterns = find(point = point, used = pattern.chunked(1)).map {\n        val newPattern = pattern + it\n        newPattern + rec(it, i - 1, newPattern, length, onPatternsFound)\n    }\n\n    if (patterns.all { it.length == length }) {\n        onPatternsFound.invoke(patterns)\n    }\n    return \"\"\n}\n\nfun find(point: String, used: List<String>): List<String> {\n    return when (point) {\n        \"E\" -> mutableListOf(\n            \"A\", \"B\", \"C\",\n            \"D\",      \"F\",\n            \"G\", \"H\", \"I\",\n        )\n        in listOf(\"B\", \"H\") -> mutableListOf(\n            \"A\",      \"C\",\n            \"D\", \"E\", \"F\",\n            \"G\",      \"I\",\n        ).apply {\n            if (used.contains(\"E\")) {\n                if (point == \"B\") add(\"H\")\n                if (point == \"H\") add(\"B\")\n            }\n        }\n        in listOf(\"D\", \"F\") -> mutableListOf(\n            \"A\", \"B\", \"C\",\n                 \"E\",\n            \"G\", \"H\", \"I\",\n        ).apply {\n            if (used.contains(\"E\")) {\n                if (point == \"D\") add(\"F\")\n                if (point == \"F\") add(\"D\")\n            }\n        }\n        in listOf(\"A\", \"I\", \"C\", \"G\") -> mutableListOf(\n                 \"B\",\n            \"D\", \"E\", \"F\",\n                 \"H\",\n        ).apply {\n            if (used.contains(\"E\")) {\n                if (point == \"A\") add(\"I\")\n                if (point == \"I\") add(\"A\")\n                if (point == \"C\") add(\"G\")\n                if (point == \"G\") add(\"C\")\n            }\n            if (used.contains(\"D\")) {\n                if (point == \"A\") add(\"G\")\n                if (point == \"G\") add(\"A\")\n            }\n            if (used.contains(\"B\")) {\n                if (point == \"A\") add(\"C\")\n                if (point == \"C\") add(\"A\")\n            }\n            if (used.contains(\"F\")) {\n                if (point == \"I\") add(\"C\")\n                if (point == \"C\") add(\"I\")\n            }\n            if (used.contains(\"H\")) {\n                if (point == \"I\") add(\"G\")\n                if (point == \"G\") add(\"I\")\n            }\n        }\n        else -> emptyList()\n    }.minus(used.toSet())\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5861487fdb20cff3ab000030":[{"id":207377,"user_id":null,"body":"import java.util.*\n\nfun interpret(code: String, inputs: String) = WhatTheBoolfuck().apply {\n    val stack = LinkedList<Int>()\n    for (i in code.indices) when {\n        code[i] == '[' -> stack.push(i)\n        code[i] == ']' -> stack.pop().also { put(i, it); put(it, i) }\n    }\n    input = inputs.flatMap { Iterable { WhatTheBoolfuck(it.toInt()) } }.iterator()\n    output = StringBuilder()\n\n    val data = WhatTheBoolfuck()\n    var ptr = 0\n\n    var i = 0\n    while (i < code.length) {\n        when (code[i]) {\n            '+' -> data[ptr] = data[ptr] xor 1\n            ',' -> data[ptr] = read()\n            ';' -> write(data[ptr])\n            '>' -> ptr++\n            '<' -> ptr--\n            '[' -> if (data[ptr] == 0) i = this[i]\n            ']' -> if (data[ptr] != 0) i = this[i]\n        }\n        i++\n    }\n}.toString()\n\nprivate class WhatTheBoolfuck(var char: Int = 0, var i: Int = 0) : HashMap<Int, Int>(), Iterator<Int> {\n    lateinit var output: StringBuilder\n    lateinit var input: Iterator<Int>\n    override fun hasNext() = i < 8\n    override fun next() = char shr i++ and 1\n    override fun get(key: Int) = super.get(key) ?: 0\n    override fun toString() = (if (i == 0) output else output.append(char.toChar())).toString()\n    fun read() = if (input.hasNext()) input.next() else 0\n    fun write(bit: Int) {\n        char = char or bit.shl(i++)\n        if (!hasNext()) output.append(char.toChar()).also { char = 0;i = 0 }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207378,"user_id":null,"body":"const val INDEX_TO_PAGE_SHIFT = 10\nconst val PAGE_SIZE = 1 shl INDEX_TO_PAGE_SHIFT\nconst val PAGE_MASK = PAGE_SIZE - 1\n\nconst val COMMAND_FLIP = '+'\nconst val COMMAND_INPUT = ','\nconst val COMMAND_OUTPUT = ';'\nconst val COMMAND_LEFT = '<'\nconst val COMMAND_RIGHT = '>'\nconst val COMMAND_BEGIN_BLOCK = '['\nconst val COMMAND_END_BLOCK = ']'\n\nfun interpret(code: String, input: String): String {\n    val codeData = CharData(code)\n    val outputData = BitwiseData()\n    val inputData = BitwiseData(input)\n    val data = BrainData()\n\n    while (codeData.hasNext()) {\n        when (codeData.next()) {\n            COMMAND_FLIP -> data.flip()\n            COMMAND_INPUT -> data.put(inputData.getBit())\n            COMMAND_OUTPUT -> outputData.putBit(data.get())\n            COMMAND_LEFT -> data.previous()\n            COMMAND_RIGHT -> data.next()\n            COMMAND_BEGIN_BLOCK -> if (data.isZero()) codeData.seekMatchingBracket(1)\n            COMMAND_END_BLOCK -> if (data.isNotZero()) codeData.seekMatchingBracket(-1)\n        }\n    }\n    return outputData.asString()\n}\n\nclass CharData(private val charArray: CharArray) {\n    var index = 0\n\n    constructor(charDataAsString: String) : this(charDataAsString.toCharArray())\n\n    fun next() = charArray[index++]\n    fun hasNext() = index < charArray.size\n\n    fun seekMatchingBracket(direction: Int) {\n        var nestLevel = 0\n        var c = charArray[--index]\n        while (true) {\n            if (c == COMMAND_END_BLOCK) {\n                if (--nestLevel == 0) {\n                    return\n                }\n            } else if (c == COMMAND_BEGIN_BLOCK) {\n                if (++nestLevel == 0) {\n                    return\n                }\n            }\n            index += direction\n            c = charArray[index]\n        }\n    }\n\n}\n\nclass BitwiseData(input: String = \"\") {\n    val listOfBytes = input.indices.map { input.codePointAt(it).toByte() }.toMutableList()\n    var bitData = 0\n    var bitIndex = 0\n\n    fun putBit(bit: Int) {\n        bitData = bitData.or(bit.and(1).shl(bitIndex))\n        ++bitIndex\n        if (bitIndex.equals(Byte.SIZE_BITS)) {\n            listOfBytes.add(bitData.toByte())\n            bitData = 0\n            bitIndex = 0\n        }\n    }\n\n    fun getBit(): Int {\n        if (bitIndex == 0) {\n            bitData = listOfBytes.removeFirstOrNull()?.toInt() ?: 0\n        }\n        val returnBit = bitData.shr(bitIndex).and(1)\n        bitIndex = (bitIndex + 1) % Byte.SIZE_BITS\n        return returnBit\n    }\n\n    fun asString(): String = mutableListOf<Byte>().apply {\n        addAll(listOfBytes)\n        if (bitIndex > 0) add(bitData.toByte())\n    }.map { Character.toChars((if (it < 0) (256 + it) else it.toInt()))[0] }.joinToString(separator = \"\")\n\n}\n\nclass BrainData {\n    private val data = ArrayList<IntArray>(1)\n    var lastPageExclusive = 0\n    private var dataIndex = 0\n    private var bitIndex = 0\n\n    init {\n        data.add(IntArray(PAGE_SIZE))\n    }\n\n    operator fun next() {\n        bitIndex = (bitIndex + 1) % Int.SIZE_BITS\n        if (bitIndex % Int.SIZE_BITS == 0) dataIndex++\n        if (dataIndex shr INDEX_TO_PAGE_SHIFT >= lastPageExclusive) appendPage()\n    }\n\n    fun previous() {\n        if (bitIndex % Int.SIZE_BITS == 0) {\n            if (dataIndex == 0) prependPage()\n            dataIndex--\n        }\n        bitIndex = (bitIndex - 1 + Int.SIZE_BITS) % Int.SIZE_BITS\n    }\n\n    fun flip() {\n        data[dataIndex shr INDEX_TO_PAGE_SHIFT][dataIndex and PAGE_MASK] =\n            data[dataIndex shr INDEX_TO_PAGE_SHIFT][dataIndex and PAGE_MASK].xor(1 shl bitIndex)\n    }\n\n    fun get(): Int {\n        return data[dataIndex shr INDEX_TO_PAGE_SHIFT][dataIndex and PAGE_MASK].shr(bitIndex).and(1)\n    }\n\n    fun put(i: Int) {\n        if (i.and(1) != get()) flip()\n    }\n\n    fun isZero() = get() == 0\n    fun isNotZero() = !isZero()\n\n    private fun appendPage() {\n        data.add(IntArray(PAGE_SIZE))\n        lastPageExclusive++\n    }\n\n    private fun prependPage() {\n        data.add(0, IntArray(PAGE_SIZE))\n        lastPageExclusive++\n        dataIndex = PAGE_SIZE\n    }\n\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207379,"user_id":null,"body":"fun interpret(code: String, inputS: String): String {\n    val bitMasks = listOf(0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01).reversed()\n\n    val input = inputS.flatMap { c ->\n        bitMasks.map { c.code.and(it) > 0 }\n    }\n\n    val matchingBrackets = mutableListOf<Pair<Int, Int>>()\n    val jPositions = mutableListOf<Int>()\n    for (j in code.indices) {\n        if (code[j] == '[') {\n            jPositions.add(j)\n        }\n        if (code[j] == ']') {\n            matchingBrackets.add(jPositions.removeLast() to j)\n        }\n    }\n\n    var (memoryPointer, inputIndex, programIndex) = Triple(0, 0, 0)\n    val memory = mutableMapOf<Int, Boolean>()\n    val output = mutableListOf<Boolean>()\n\n    while (programIndex < code.length) {\n        val c = code[programIndex]\n        when (c) {\n            '+' -> memory[memoryPointer] = !memory.getOrDefault(memoryPointer, false)\n            ',' -> {\n                memory[memoryPointer] = if (inputIndex < input.size) {\n                    input[inputIndex]\n                } else {\n                    false\n                }\n                ++inputIndex\n            }\n            ';' -> output.add(memory.getOrDefault(memoryPointer, false))\n            '<' -> memoryPointer--\n            '>' -> memoryPointer++\n            '[' -> if (!memory.getOrDefault(memoryPointer, false)) {\n                programIndex = matchingBrackets.single { it.first == programIndex }.second\n            }\n            ']' -> if (memory.getOrDefault(memoryPointer, false)) {\n                programIndex = matchingBrackets.single { it.second == programIndex }.first\n            }\n            else -> {\n            }\n        }\n        ++programIndex\n    }\n\n    val padding = if (output.size % 8 != 0) {\n        (0 until (8 - (output.size % 8))).map { false }\n    } else {\n        listOf()\n    }\n    output.addAll(padding)\n\n    val result = StringBuilder()\n    output.chunked(8).forEachIndexed { index , eightBits ->\n        val q = eightBits.zip(bitMasks).sumOf { (bit, v) ->\n            if (bit) {\n                v\n            } else {\n                0\n            }\n        }\n        result.append(q.toChar())\n    }\n    return result.toString()\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207380,"user_id":null,"body":"import java.util.*\n\nfun interpret(code: String, input: String = \"\"): String {\n    val tape = Tape()\n    val obs = OBS()\n    val ibs = IBS(input)\n\n    var tapePtr = 0\n    var codePtr = 0\n\n    fun jump(from: Char, to: Char, step: Int) {\n        var open = 1\n        while (open != 0) {\n            codePtr += step\n            when (code[codePtr]) {\n                from -> open++\n                to -> open--\n            }\n        }\n    }\n\n    while (codePtr < code.length) {\n        when (code[codePtr++]) {\n            '+' -> tape[tapePtr] = !tape[tapePtr]\n            ',' -> tape[tapePtr] = ibs.readNextBit()\n            ';' -> obs.putBit(tape[tapePtr])\n            '<' -> tapePtr--\n            '>' -> tapePtr++\n            '[' -> if (!tape[tapePtr]) { jump('[', ']', 1) }\n            ']' -> if (tape[tapePtr]) { codePtr--; jump(']', '[', -1) }\n        }\n    }\n    return obs.asString()\n}\n\nprivate class IBS(val input: String) {\n    private var bytePtr = 0\n    private var bitPtr = 0\n    fun readNextBit(): Boolean {\n        if (bytePtr >= input.length) return false\n        return (input[bytePtr].code and (0b0000_0001 shl bitPtr) != 0)\n            .also {\n                bitPtr++\n                if (bitPtr > 7) { bitPtr = 0; bytePtr++ }\n            }\n    }\n}\n\nprivate class OBS() {\n    var buffer = 0\n    var bufferPtr = 0\n    var str = \"\"\n    fun putBit(value: Boolean) {\n        val bit = if (value) 1 else 0\n        buffer = buffer or (bit shl bufferPtr++)\n        if (bufferPtr > 7) {\n            bufferPtr = 0\n            str += buffer.toChar()\n            buffer = 0\n        }\n    }\n    fun asString() =\n        if (bufferPtr > 0) str + buffer.toChar() else str\n}\n\nprivate class Tape {\n    private val right = BitSet()\n    private val left = BitSet()\n    operator fun get(offset: Int) =\n        if (offset >= 0) right[offset]\n        else left[offset * -1 - 1]\n    operator fun set(offset: Int, value: Boolean) =\n        if (offset >= 0) right[offset] = value\n        else left[offset * -1 - 1] = value\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207381,"user_id":null,"body":"\n\nclass Tape(val data: MutableMap<Int, Boolean> = hashMapOf(), var position: Int = 0) {\n    fun flip() {\n        data.compute(position) {\n            idx, value -> ! (value ?: false)\n        }\n    }\n\n    fun get(): Boolean {\n        return data.getOrDefault(position, false)\n    }\n\n    fun set(b: Boolean) {\n        data[position] = b\n    }\n\n}\n\nclass Input(input: String) {\n\n    val bits = toBits(input).iterator()\n\n    fun next(): Boolean {\n        return if (bits.hasNext()) {\n            bits.next()\n        } else {\n            false\n        }\n    }\n\n    companion object {\n        fun toBits(c: Char): BooleanArray {\n            val asByte = c.toByte().toInt()\n            return (0 until 8).map { (1 shl it).and(asByte) != 0 }.toBooleanArray()\n        }\n        fun toBits(s: String) : Sequence<Boolean> {\n            return s.asSequence().flatMap { toBits(it).asSequence() }\n        }\n    }\n}\n\nfun interpret(code: String, input: String): String {\n    val boolfuck = Boolfuck(code, input)\n    boolfuck.run()\n    return boolfuck.outToString() \/\/ do it!\n}\n\n\n\nfun fromBits(b: List<Boolean>): Char {\n    var n = b.withIndex().map { if (it.value) { 1 shl it.index }else {0} }.sum()\n    return n.toChar()\n}\n\nclass Boolfuck(private val program: String,  input: String) {\n\n    val output: MutableList<Boolean> = mutableListOf()\n    private val tape: Tape = Tape()\n    var pc: Int = 0\n    val input = Input(input)\n\n    fun run() {\n        while (pc < program.length) {\n            val command = program.get(pc)\n            pc++ \/\/ default to incrementing the program counter, jumps will be a bit different\n            when(command) {\n                '+' -> tape.flip()\n                ',' -> tape.set(input.next())\n                ';' -> output.add(tape.get())\n                '<' -> tape.position--\n                '>' -> tape.position++\n                '[' -> if (!tape.get()) { pc--; seek(']', '[', +1) }\n                ']' -> if (tape.get()) { pc--; seek('[', ']', -1) }\n            }\n        }\n    }\n\n    private fun seek(find: Char, opposite: Char, direction: Int) {\n        var depth = 0\n        while (pc < program.length && pc >= 0) {\n            if (program[pc] == opposite) {\n                depth++\n            }\n            if (program[pc] == find) {\n                depth--\n                if (depth == 0) {\n                    break\n                }\n            }\n            pc += direction\n        }\n    }\n\n    fun outToString(): String {\n        return output.asSequence().chunked(8) {\n            fromBits(it)\n        }.joinToString(separator = \"\")\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207382,"user_id":null,"body":"import java.util.*\nimport kotlin.math.abs\n\n\nfun interpret(code: String, input: String): String {\n    var outputStream = \"\"\n\n    val commands = code.toCharArray()\n    var commandIdx = 0\n\n    val positiveTape = BitSet()\n    val negativeTape = BitSet()\n    var currentTape = positiveTape\n    var tapeIdx = 0\n\n    val inputBinaryStr = inputToBinaryString(input)\n    var inputIdx = 0\n\n    val loopStack = Stack<Int>()\n\n    while(commandIdx < code.length) {\n\n        when (commands[commandIdx]) {\n\n            '>' -> {\n                tapeIdx++\n                commandIdx++\n\n                if(tapeIdx >= 0)\n                    currentTape = positiveTape\n            }\n\n            '<' -> {\n                tapeIdx--\n                commandIdx++\n\n                if(tapeIdx < 0)\n                    currentTape = negativeTape\n            }\n\n            '+' -> {\n                currentTape.flip(abs(tapeIdx))\n                commandIdx++\n            }\n\n            ',' -> {\n\n                when {\n                    inputIdx > inputBinaryStr.length - 1 -> {\n                        currentTape.set(abs(tapeIdx), false)\n                    }\n                    inputBinaryStr[inputIdx] == '1' -> {\n                        currentTape.set(abs(tapeIdx), true)\n                    }\n                    else -> {\n                        currentTape.set(abs(tapeIdx), false)\n                    }\n                }\n\n                inputIdx++\n                commandIdx++\n            }\n\n            ';' -> {\n                outputStream += if(currentTape.get(abs(tapeIdx))) {\n                    \"1\"\n                } else {\n                    \"0\"\n                }\n                commandIdx++\n            }\n\n            '[' -> {\n                if (!currentTape.get(abs(tapeIdx))) {\n\n                    commandIdx++\n                    var loopDepth = 1\n\n                    while(loopDepth > 0) {\n                        val currCommand = commands[commandIdx]\n\n                        if(currCommand == '[') {\n                            loopDepth ++\n                        } else if (currCommand == ']') {\n                            loopDepth--\n                        }\n                        commandIdx++\n                    }\n\n                } else {\n                    loopStack.push(commandIdx)\n                    commandIdx++\n                }\n            }\n\n            ']' -> {\n                if (!currentTape.get(abs(tapeIdx))) {\n                    loopStack.pop()\n                    commandIdx++\n                } else {\n                    commandIdx = loopStack.pop()\n                }\n            }\n\n            else -> {\n                commandIdx++\n            }\n        }\n    }\n\n    return binaryToOutputString(outputStream)\n}\n\n\nfun inputToBinaryString(input: String) : String =\n        input.toCharArray()\n            \/\/Char -> Int\n            .map { it.toInt() }\n            .map { intToBinaryString(it) }\n            \/\/Little Endian - hence reversed\n            .joinToString(\"\") { it.reversed() }\n\n\n\nfun binaryToOutputString(binary: String) : String =\n    binary.chunked(8)\n        .asSequence()\n        .map { it.padEnd(8, '0') }\n        .map { it.reversed() }\n        .map { it.toInt(2) }\n        .map { it.toChar() }\n        .joinToString (\"\")\n\n\nfun intToBinaryString(i :Int) = String.format(\"%8s\", Integer.toBinaryString(i)).replace(\" \", \"0\")\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207383,"user_id":null,"body":"fun interpret(code: String, input: String): String {\n  val tape = mutableMapOf<Int,Boolean>()\n  var tapePtr = 0\n  var codePtr = 0\n  var inputPtr = 0\n  val output = mutableListOf<Boolean>() \n  while (true) {\n    if (codePtr >= code.length) {break}\n    when(code[codePtr]) {\n      '+' -> {tape[tapePtr] = !(tape[tapePtr] ?: false)}\n      ',' -> {\n          tape[tapePtr] = if (inputPtr\/8 >= input.length) false else ((input[inputPtr\/8].toInt() and (1 shl inputPtr%8)) != 0)\n          inputPtr++\n      }\n      ';' -> {output.add(tape[tapePtr] ?: false)} \n      '<' -> {tapePtr--}\n      '>' -> {tapePtr++}\n      '[' -> {if (!(tape[tapePtr] ?: false)) codePtr = jump(code, codePtr)}\n      ']' -> {if ((tape[tapePtr] ?: false)) codePtr = jump(code, codePtr)}\n    }\n    codePtr++\n  }\n  if (output.size%8 != 0) {\n    (0 until 8-(output.size%8)).forEach{output.add(false)}\n  }\n  return output.windowed(8, 8).map{it.foldIndexed(0){i,sum,t-> if (t) sum + (1 shl i) else sum}.toChar()}.joinToString(\"\")\n}\n\nfun jump (code: String, codePtr: Int) : Int {\n   var depth = 0\n   (0..codePtr).forEach{i->\n       if (code[i] == '[') {depth++}\n       if (code[i] == ']') {depth--}\n   } \n   var curdepth = depth \n   if (code[codePtr] == '[') {\n      (codePtr until code.length).forEach {i->\n          if (code[i] == ']') {\n              curdepth--\n              if (depth==curdepth) {return i}\n          } else if (code[i] == '[') {curdepth++}\n      }\n   } else {\n      (codePtr downTo 0).forEach{i->\n          if (code[i] == '[') {\n              curdepth++\n              if (depth==curdepth) {return i}\n          } else if (code[i] == ']') {curdepth--}\n      }\n   }\n   return 0\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207384,"user_id":null,"body":"import java.util.stream.Collectors\nimport kotlin.collections.ArrayList\n\nfun interpret(code: String, input: String): String {\n        \/\/tape and output\n        val tape = ArrayList<Boolean>()\n        var output = \"\"\n        tape.add(false) \/\/false is , true is 1\n        var pointer = 0\n\n        \/\/for input reading\n        var inputPointer = 0\n        var binaryInput =\n            input\n                .chars()\n                .mapToObj {\n                    Integer.toBinaryString(it).reversed().padEnd(8, '0') \/\/little endian\n                }.collect(Collectors.joining(\"\"))\n\n        var index = 0\n        while (index < code.length) {\n            var cmd = code[index]\n\n            when (code[index]) {\n                '+' -> {\n                    tape[pointer] = !tape[pointer]\n                }\n                ',' -> {\n                    tape[pointer] =\n                        if (inputPointer >= binaryInput.length) false else binaryInput[inputPointer++] == '1'\n                }\n                ';' -> {\n                    output += if (tape[pointer]) '1' else '0'\n                }\n                '<' -> {\n                    if (pointer == 0) tape.add(0, false)\n                    else pointer--\n                }\n                '>' -> {\n                    if (pointer == tape.lastIndex) tape.add(false)\n                    pointer++\n                }\n                '[' -> if (!tape[pointer]) {\n                    var counter = 1\n                    while(counter > 0) {\n                        index++\n                        if(code[index] == ']') {\n                            counter--\n                        } else if(code[index] == '[') {\n                            counter++\n                        }\n                    }\n\n                }\n                ']' -> {\n                    if (tape[pointer]) {\n                        var counter = -1\n                        while(counter < 0) {\n                            index--\n                            if(code[index] == ']') {\n                                counter--\n                            } else if(code[index] == '[') {\n                                counter++\n                            }\n                        }\n                    }\n                }\n            }\n            index++\n        }\n\n        \/\/parse output\n        return output\n            .chunked(8)\n            .map { Integer.parseInt(it.reversed(), 2).toChar() }\n            .joinToString(\"\")\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207385,"user_id":null,"body":"import java.util.stream.Collectors\nimport kotlin.collections.ArrayList\n\nfun interpret(code: String, input: String): String {\n        \/\/tape and output\n        val tape = ArrayList<Boolean>()\n        var output = \"\"\n        tape.add(false) \/\/false is , true is 1\n        var pointer = 0\n\n        \/\/for input reading\n        var inputPointer = 0\n        var binaryInput =\n            input\n                .chars()\n                .mapToObj {\n                    var bs = Integer.toBinaryString(it)\n                    if (bs.length == 8)\n                        bs.reversed() \/\/little endian\n                    else\n                       bs.reversed() + \"0\".repeat(8 - bs.length) \/\/padding\n                }.collect(Collectors.joining(\"\"))\n\n        var index = 0\n        while (index < code.length) {\n            var cmd = code[index]\n\n            when (code[index]) {\n                '+' -> {\n                    tape[pointer] = !tape[pointer]\n                }\n                ',' -> {\n                    tape[pointer] =\n                        if (inputPointer >= binaryInput.length) false else binaryInput[inputPointer++] == '1'\n                }\n                ';' -> {\n                    output += if (tape[pointer]) '1' else '0'\n                }\n                '<' -> {\n                    if (pointer == 0) tape.add(0, false)\n                    else pointer--\n                }\n                '>' -> {\n                    if (pointer == tape.lastIndex) tape.add(false)\n                    pointer++\n                }\n                '[' -> if (!tape[pointer]) {\n                    var openCounter = 0\n                    var closeCounter = 0\n                    for (i in index until code.length) {\n                        if (code[i] == ']') {\n                            closeCounter++\n                        } else if (code[i] == '[') {\n                            openCounter++\n                        }\n                        if (openCounter == closeCounter) {\n                            index = i\n                            break\n                        }\n                    }\n\n                }\n                ']' -> {\n                    if (tape[pointer]) {\n\n                        var openCounter = 0\n                        var closeCounter = 0\n                        for (i in index downTo 0) {\n                            if (code[i] == ']') {\n                                closeCounter++\n                            } else if (code[i] == '[') {\n                                openCounter++\n                            }\n                            if (openCounter == closeCounter) {\n                                index = i\n                                break\n                            }\n                        }\n\n                    }\n                }\n            }\n            index++\n        }\n\n        \/\/parse output\n        return output\n            .chunked(8)\n            .map { Integer.parseInt(it.reversed(), 2).toChar() }\n            .joinToString(\"\")\n\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207386,"user_id":null,"body":"fun interpret(code: String, input: String = \"\"): String {\n    \n    var tape = mutableListOf(0)\n    var ptr = 0\n    var bi = 0\n    var i = 0\n    var output = \"\"\n    \n    var valid = \"+,;<>[]\"\n    var bin = input.map{ it.toInt().toString(2).padStart(8, '0').reversed() }.joinToString(\"\")\n    var kode = code.filter{ it in valid }\n    var len = kode.length\n    \n    var loops = mutableMapOf<Int, Int>()\n    var stack = mutableListOf<Pair<Int, Char>>()\n    \n    kode.forEachIndexed{ j, c ->\n        if (c != ']') stack.add(Pair(j, c))\n        else {\n            while (!stack.isEmpty() && stack.last().second != '[') stack.removeAt(stack.size - 1)\n            var s = stack.removeAt(stack.size - 1)\n            loops.set(j, s.first)\n            loops.set(s.first, j)            \n        }\n    }\n    \n    while (i < len) {\n        val cmd = kode[i]\n        \n        if (cmd == '+') {\n            tape[ptr] = 1 - tape[ptr]\n        } else if (cmd == ',') {\n            tape[ptr] = if (bi < bin.length) bin[bi].toString().toInt() else 0\n            bi += 1\n        } else if (cmd == ';') {\n            output += tape[ptr].toString()\n        } else if (cmd == '<') {\n            ptr -= 1\n            if (ptr < 0) {\n                tape.add(0, 0)\n                ptr = 0\n            }\n        } else if (cmd == '>') {\n            ptr += 1\n            if (ptr >= tape.size) tape.add(0)\n        } else if (cmd == '[' && tape[ptr] == 0) {\n            i = loops.get(i)!!\n        } else if (cmd == ']' && tape[ptr] == 1) {\n            i = loops.get(i)!!\n        }\n        i += 1\n    }\n    \n    return output.chunked(8).map { it.padEnd(8, '0').reversed().toInt(radix = 2).toChar() }.joinToString(\"\")\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5868b2de442e3fb2bb000119":[{"id":207387,"user_id":null,"body":"package solution\n\ninternal object ClosestWeight {\n\n    fun closest(strng: String): Array<IntArray> {\n        val num_txt = strng.split(\" \").filter{it.trim().length>0}\n        val weights = num_txt.mapIndexed {ind,str->\n            Pair( str.mapNotNull {c-> c.digitToIntOrNull()}.sum(), ind )   \n        }\n        val comparator = compareBy<Pair<Int,Int>>{it.first}.thenBy{it.second}\n        val sorted = weights.sortedWith(comparator)\n        \n        val laureats = sorted.windowed(2).minByOrNull{it[1].first-it[0].first} ?: listOf(Pair(0,0))\n        \n        return laureats.map{ \n            intArrayOf(it.first,it.second,num_txt[it.second].toInt())\n        }.toTypedArray()\n    }\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-09 21:49:10"},{"id":207388,"user_id":null,"body":"package solution\n\ninternal object ClosestWeight {\n\n    fun closest(s: String): Array<IntArray> {\n        val map = mutableMapOf<Int, Pair<String, Int>>()\n        s.split(\" \").forEachIndexed { i, w ->\n            map[i] = Pair(w, w.map { it.toString().toInt() }.sum())\n        }\n        var pair: Pair<MutableMap.MutableEntry<Int, Pair<String, Int>>, MutableMap.MutableEntry<Int, Pair<String, Int>>>? = null\n        var min = Int.MAX_VALUE\n        val ens = map.entries.sortedBy { it.value.second }\n\n        for (i in 1 until map.size) {\n            val dif = ens[i].value.second - ens[i - 1].value.second\n            if (dif < min) {\n                min = dif\n                pair = Pair(ens[i - 1], ens[i])\n            }\n        }\n\n        return arrayOf(\n            intArrayOf(pair!!.first.value.second, pair.first.key, pair.first.value.first.toInt()),\n            intArrayOf(pair.second.value.second, pair.second.key, pair.second.value.first.toInt())\n        )\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207389,"user_id":null,"body":"package solution\nimport kotlin.math.abs\ninternal object ClosestWeight {\n\n    fun closest(strng: String): Array<IntArray> {\n        val strngArray = strng.split(\" \")\n        val weighted = strngArray.mapIndexed{index, i-> intArrayOf(i.toCharArray().sumBy { num -> num-'0' },index, i.toInt())}.sortedWith(compareBy({it[0]},{it[1]}))\n        val diff = (0 until weighted.size-1).minBy{ abs(weighted[it + 1][0] - weighted[it][0])}\n        return weighted.slice(diff!!..diff+1).toTypedArray()    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207390,"user_id":932,"body":"package solution\nimport kotlin.math.absoluteValue\n\ninternal object ClosestWeight {\n\nfun closest(strng: String): Array<IntArray> {\n    val numbers = strng.apply{if (isEmpty()) return arrayOf()}.split(\" \")\n    val weights = numbers.map {it.map{\"$it\".toInt()}.reduce { acc, c ->  acc + c}}\n    var a = 0\n    var b = 1\n    var c = (weights[0]-weights[1]).absoluteValue\n    (0..weights.lastIndex-1).forEach{ i ->\n        (i+1..weights.lastIndex).forEach { j ->\n            (weights[i]-weights[j]).absoluteValue.let {if (it<c || it.equals(c) && weights[a].coerceAtMost(weights[b])>weights[i].coerceAtMost(weights[j])) {c=it;a=i;b=j}}\n        }\n    }\n    if (weights[a]>weights[b]) b.let {b = a;a = it}\n    return arrayOf(intArrayOf(weights[a],a,numbers[a].toInt()),intArrayOf(weights[b],b,numbers[b].toInt()))\n}\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207391,"user_id":null,"body":"package solution\n\ninternal object ClosestWeight {\n\n    fun closest(strng: String): Array<IntArray> {\n        \n        val test3 = mutableMapOf<Int, Pair<Int, Int>>().apply { strng.split(\" \").withIndex().forEach { put(it.index, Pair(it.value.toInt(), it.value.sumOf { it.digitToInt() })) } }.toList().sortedBy { it.second.second }\n        var sum = Int.MAX_VALUE\n        var first : Pair<Int, Pair<Int, Int>> = Pair(0, Pair(0,0))\n        var second : Pair<Int, Pair<Int, Int>> = Pair(0, Pair(0,0))\n        for(i in 1 until test3.size){\n            if(test3[i].second.second - test3[i -1].second.second < sum){\n                sum = test3[i].second.second - test3[i -1].second.second\n                first = test3[i -1]\n                second = test3[i]\n            }\n        }\n        return arrayOf(intArrayOf(first.second.second, first.first, first.second.first ), intArrayOf(second.second.second, second.first, second.second.first))\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207392,"user_id":null,"body":"package solution\n\ninternal object ClosestWeight {\n\n    fun closest(strng: String): Array<IntArray> {\n    val ints = strng\n        .split(\" \")\n        .map { it.map { char -> char.toString().toInt() } }\n        .map { it.sum() }\n        .toMutableList()\n    val sorted = ints.sorted()\n    var difference = sorted.last() + 1\n    var smallestPair = Pair(0, 0)\n    for (i in 0 until sorted.size - 1) {\n        if (sorted[i + 1].minus(sorted[i]) < difference) {\n            difference = sorted[i + 1].minus(sorted[i])\n            smallestPair = Pair(sorted[i], sorted[i + 1])\n        }\n    }\n    val pairAsList = smallestPair.toList()\n    return Array(2) {\n        val outputSubArray = mutableListOf(pairAsList[it])\n        if (pairAsList[0] == pairAsList[1]) {\n            if (it == 0) {\n                outputSubArray.add(ints.indexOf(pairAsList[it]))\n                ints.removeAt(ints.indexOf(pairAsList[it]))\n            } else {\n                val ind = ints.indexOf(pairAsList[1])\n                outputSubArray.add(ind + 1)\n            }\n        } else {\n            outputSubArray.add(ints.indexOf(pairAsList[it]))\n        }\n        outputSubArray.add(strng.split(\" \")[outputSubArray.last()].toInt())\n        return@Array outputSubArray.toIntArray()\n    }\n}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207393,"user_id":null,"body":"package solution\n\n\nimport kotlin.math.abs\n\n\ninternal object ClosestWeight {\n\n    fun closest(strng: String): Array<IntArray> {\n        val tokensWeight = strng.split(\"\\\\s+\".toRegex())\n            .mapIndexed { idx, it -> Triple(weight(it), idx, it) }\n            .sortedBy { it.first }\n\n        val minPair = tokensWeight.zipWithNext()\n            .map { Triple(abs(it.first.first - it.second.first), it.first, it.second) }\n            .minByOrNull { it.first }!!\n\n        return arrayOf(tripleToIntArray(minPair.second), tripleToIntArray(minPair.third))\n    }\n    \n    fun weight(s: String) : Int = s.map { Integer.parseInt(it.toString()) }.sum()\n\n    fun tripleToIntArray(t: Triple<Int, Int, String>) = intArrayOf(t.first, t.second, t.third.toInt())\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207394,"user_id":null,"body":"package solution\n\ninternal object ClosestWeight {\n\n    fun closest(strng: String): Array<IntArray> {\n        val weightedNums = strng\n            .split(\" \")\n            .mapIndexed { idx, num -> WeightedNum(num.toCharArray().sumOf { it.digitToInt() }, idx, num.toInt()) }\n            .sortedBy { it.weight }\n\n        val diffs = weightedNums\n            .slice(0 until weightedNums.size - 1)\n            .mapIndexed { idx, weightedNum -> WeightedDiff(weightedNums[idx + 1].weight - weightedNum.weight, weightedNum, weightedNums[idx + 1]) }\n            .sortedBy { it.diff }\n\n        val num1 = diffs[0].weightedNum1\n        val num2 = diffs[0].weightedNum2\n        return arrayOf(intArrayOf(num1.weight, num1.idx, num1.originalNum), intArrayOf(num2.weight, num2.idx, num2.originalNum))\n    }\n    \n    data class WeightedNum(val weight: Int, val idx: Int, val originalNum: Int)\n    data class WeightedDiff(val diff: Int, val weightedNum1: WeightedNum, val weightedNum2: WeightedNum)\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207395,"user_id":null,"body":"package solution\n\ninternal object ClosestWeight {\n\n    fun closest(strng: String): Array<IntArray> {\n        val map = mutableMapOf<Int, Pair<Int, Int>>().apply { strng.split(\" \").withIndex().forEach { put(it.index, Pair(it.value.toInt(), it.value.sumOf { it.digitToInt() })) } }.toList().sortedBy { it.second.second }\n        var sum = Int.MAX_VALUE\n        var first : Pair<Int, Pair<Int, Int>> = Pair(0, Pair(0,0))\n        var second : Pair<Int, Pair<Int, Int>> = Pair(0, Pair(0,0))\n        for(i in 1 until map.size){\n            if(map[i].second.second - map[i -1].second.second < sum){\n                sum = map[i].second.second - map[i -1].second.second\n                first = map[i -1]\n                second = map[i]\n            }\n        }\n        return arrayOf(intArrayOf(first.second.second, first.first, first.second.first ), intArrayOf(second.second.second, second.first, second.second.first))\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207396,"user_id":null,"body":"package solution\n\ninternal object ClosestWeight {\n\n    fun closest(strng: String): Array<IntArray> {\n        val l = strng.split(\" \").size\n        val n = strng.split(\" \")\n            .mapIndexed{i, num -> listOf(num.sumBy{it.digitToInt()}, i, num.toInt())}\n            .sortedBy{it[0]}\n        return n.mapIndexed{i, v -> if (i != l-1) listOf(v, n[i+1]) to n[i+1][0] - v[0] else listOf(v, v) to -1}\n        .dropLast(1).sortedBy{it.second}.take(1).map{it.first}.flatten().map{it.toIntArray()}.toTypedArray()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5869848f2d52095be20001d1":[{"id":207397,"user_id":null,"body":"package catKataPartOne\n\nimport kotlin.math.pow\nimport kotlin.math.sqrt\n\nprivate val validLetters = listOf('L', 'M', 'R')\n\nfun peacefulYard(yard: Array<String>, minDistance: Int): Boolean {\n    val points = yard.mapIndexed { row, cols ->\n        cols.mapIndexedNotNull { col, c -> if (validLetters.contains(c)) Point(row, col) else null }\n    }.flatten()\n\n    return points.all { point -> points.none { other -> point.distanceApart(other) > 0 && point.distanceApart(other) < minDistance } }\n}\n\ndata class Point(val row: Int, val col: Int) {\n    fun distanceApart(other: Point): Double =\n        sqrt((other.col - col).toDouble().pow(2) + (other.row - row).toDouble().pow(2))\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207398,"user_id":null,"body":"package catKataPartOne\n\nfun peacefulYard(yard: Array<String>, minDistance: Int): Boolean {\n    val list = mutableListOf<Pair<Int, Int>>()\n\n    yard.forEachIndexed { i, row ->\n        row.forEachIndexed { j, col ->\n            if (col != '-')\n                list.add(Pair(i, j))\n        }\n    }\n    return when (list.size) {\n        0 -> true\n        1 -> true\n        2 -> distance(list[0], list[1]) >= minDistance\n        3 -> listOf(\n            distance(list[0], list[1]),\n            distance(list[0], list[2]),\n            distance(list[1], list[2])\n        ).all { it >= minDistance }\n        else -> false\n    }\n}\n\nfun distance(pairA: Pair<Int, Int>, pairB: Pair<Int, Int>): Double =\n    kotlin.math.hypot((pairA.first - pairB.first).toDouble(), (pairA.second - pairB.second).toDouble())","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207399,"user_id":null,"body":"package catKataPartOne\n\nimport kotlin.math.pow\nimport kotlin.math.sqrt\n\nfun peacefulYard(yard: Array<String>, minDistance: Int) : Boolean {\n    val cats = mutableListOf<Pair<Int, Int>>()\n\n    yard.filter { it.any { it != '-' } }\n        .forEach { row ->\n            row.forEachIndexed { i, c ->\n                if (c != '-') {\n                    cats.add(i to yard.indexOf(row))\n                }\n            }\n        }\n\n    for (i in cats.indices) {\n        for (j in i + 1 .. cats.lastIndex) {\n            val x = (cats[j].first - cats[i].first).toDouble()\n            val y = (cats[j].second - cats[i].second).toDouble()\n            if (sqrt(x.pow(2.0) + y.pow(2.0)) < minDistance) {\n                return false\n            }\n        }\n    }\n\n    return true\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207400,"user_id":null,"body":"package catKataPartOne\nimport kotlin.math.sqrt\nimport kotlin.math.pow\n\nfun peacefulYard(yard: Array<String>, minDistance: Int) : Boolean {\n    val cats =\n        yard.flatMapIndexed { index, s -> s.toCharArray().mapIndexed { i, c -> Pair(index, if (c == '-') -1 else i) } }\n            .filter { it.second != -1 }\n\n    if (cats.size < 2) return true\n\n    var distance = true\n\n    for( c in cats){\n        for(k in cats){\n            if(c != k && distance(c.first, c.second, k.first, k.second) < minDistance){\n                distance = false\n                break\n            }\n        }\n    }\n    return distance\n}\nprivate fun distance(x1: Int, y1: Int, x2: Int, y2: Int): Double = sqrt((x2 - x1).toDouble().pow(2) + (y2 - y1).toDouble().pow(2))\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207401,"user_id":null,"body":"package catKataPartOne\nimport kotlin.math.*\n\n\nfun peacefulYard(yard: Array<String>, minDistance: Int): Boolean {\n    val catsPosition = mutableListOf<Pair<Int, Int>>()\n    yard.forEachIndexed { indexY, s ->\n        s.forEachIndexed { indexX, c ->\n            if (c.isLetter()) catsPosition.add(indexX to indexY)\n        }\n    }\n\n    for (i in catsPosition.indices) {\n        for (j in i + 1 until catsPosition.size) {\n            if (sqrt(\n                    (catsPosition[j].first - catsPosition[i].first).toDouble()\n                        .pow(2) + (catsPosition[j].second - catsPosition[i].second).toDouble().pow(2)\n                ) < minDistance\n            ) return false\n        }\n    }\n    \n    return true\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207402,"user_id":null,"body":"package catKataPartOne\n\n\nimport kotlin.math.abs\nimport kotlin.math.sqrt\n\n\nfun peacefulYard(yard: Array<String>, minDistance: Int) : Boolean {\n\n    val cats = mutableListOf<Pair<Int, Int>>()\n    for(i in yard.indices) {\n        for(j in yard[i].indices) {\n            if(yard[i][j] != '-') {\n                cats.add(Pair(i, j))\n            }\n        }\n    }\n\n    if(cats.isEmpty() || cats.size == 1)\n        return true\n\n    if(cats.size == 2)\n        return distance(cats[0], cats[1]) >= minDistance\n\n    if(cats.size == 3)\n        return distance(cats[0], cats[1]) >= minDistance &&\n               distance(cats[0], cats[2]) >= minDistance &&\n               distance(cats[1], cats[2]) >= minDistance\n\n    return true\n}\n\n\nfun distance (p1: Pair<Int, Int>, p2: Pair<Int, Int>) : Double {\n    val xDist = abs(p1.first - p2.first).toDouble()\n    val yDist = abs(p1.second - p2.second).toDouble()\n\n    return sqrt(xDist*xDist + yDist*yDist)\n}\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207403,"user_id":null,"body":"package catKataPartOne\n\nimport kotlin.math.hypot\n\nfun peacefulYard(yard: Array<String>, minDistance: Int): Boolean {\n\tval cats = ArrayList<IntArray>()\n\tfor (row in yard.indices) (0 until yard[row].length).asSequence().filter { yard[row][it] != '-' }\n\t\t.mapTo(cats) { intArrayOf(row, it) }\n\tfor (i in 0 until (cats.size - 1)) for (j in (i + 1) until cats.size) if (hypot(\n\t\t\t(cats[i][0] - cats[j][0]).toDouble(), (cats[i][1] - cats[j][1]).toDouble()\n\t\t) < minDistance\n\t) return false\n\treturn true\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207404,"user_id":1170,"body":"package catKataPartOne\n\nimport kotlin.math.pow\nimport kotlin.math.sqrt\n\nfun peacefulYard(yard: Array<String>, minDistance: Int): Boolean {\n    val list = mutableListOf<Pair<Int, Int>>()\n    \n    yard.indices.forEach { x ->\n        yard[x].indices.filter { yard[x][it] != '-' }.forEach { y ->\n            list.add(Pair(x, y))\n        }\n    }\n\n    list.indices.forEach { index ->\n        (index + 1 until list.size).forEach { second ->\n            if (minDistance > distance(list[index], list[second])) return false\n        }\n    }\n    return true\n}\n\nfun distance(pair: Pair<Int, Int>, otherPair: Pair<Int, Int>): Double {\n    return sqrt(\n        (pair.first - otherPair.first).toDouble().pow(2) +\n                (pair.second - otherPair.second).toDouble().pow(2)\n    )\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207405,"user_id":null,"body":"package catKataPartOne\n\nimport kotlin.math.*\n\nfun distance(a: Pair<Double, Double>, b: Pair<Double, Double>) = sqrt((a.first - b.first).pow(2) + (a.second - b.second).pow(2))\n\nfun peacefulYard(yard: Array<String>, minDistance: Int) : Boolean {\n    val minDistanceDouble = minDistance.toDouble()\n    val l = yard.mapIndexedNotNull{lineIndex: Int, line: String -> \n        line.mapIndexedNotNull{index, element -> if(element != '-') index else null}\n            .map{Pair(lineIndex.toDouble(), it.toDouble())}\n    }.flatten()\n    when {\n        l.isEmpty() -> return true\n        l.size == 1 -> return true\n        l.size == 2 -> return distance(l[0], l[1]) >= minDistance\n        else -> return distance(l[0], l[1]) >= minDistanceDouble && distance(l[0], l[2]) >= minDistanceDouble && distance(l[1], l[2]) >= minDistanceDouble\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207406,"user_id":null,"body":"package catKataPartOne\n\nimport kotlin.math.sqrt\nimport kotlin.math.pow\n\nfun euclid(a: Pair<Int, Int>, b: Pair<Int, Int>): Double = \n    sqrt((a.first.toDouble() - b.first.toDouble()).pow(2) + (a.second.toDouble() - b.second.toDouble()).pow(2))\n\nfun peacefulYard(yard: Array<String>, minDistance: Int) : Boolean {\n    val coords = mutableListOf<Pair<Int,Int>>()\n    yard.forEachIndexed { i, s ->\n        s.forEachIndexed { j, c ->\n            if (c != '-') coords += i to j\n        }\n    }\n    if (coords.size < 2) return true\n    else {\n        for (a in 0 until coords.size - 1) {\n            for (b in a + 1 until coords.size) {\n                val d = euclid(coords[a], coords[b])\n                System.err.println(\"${coords[a]}; ${coords[b]}; $d\")\n                if (d < minDistance) return false\n            }\n        }\n    }\n    return true\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"586d6cefbcc21eed7a001155":[{"id":207407,"user_id":2403,"body":"package kata\n\nobject KataSolution {\n    fun longestRepetition(s: String): Pair<Char?, Int> =\n        \"(.)\\\\1*\".toRegex().findAll(s).map { it.value }.maxBy { it.length }?.let { it[0] to it.length }\n            ?: Pair(null, 0)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207408,"user_id":null,"body":"package kata\n\nobject KataSolution {\nfun longestRepetition(s: String): Pair<Char?,Int> {\n    if(s.isBlank()) {\n        return Pair(null, 0)\n    } else {\n        var currentChar: Char? = null\n        var resChar: Char? = null\n        var count = 0\n        var max = 0\n        s.forEach { x ->\n            if(x == currentChar){\n                count++\n            } else {\n                currentChar = x\n                count = 1\n            }\n            if (count > max){\n                max = count\n                resChar = currentChar\n            }\n        }\n        return Pair(resChar, max)\n\n    }\n}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207409,"user_id":null,"body":"package kata\n\nobject KataSolution {\n    fun longestRepetition(s: String): Pair<Char?,Int> {\n        if (s.length == 0) return Pair(null,0)\n        var ret = Pair(s[0],1)\n        var loc = ret\n        s.windowed(2).forEach {\n            if (it[1] == it[0]) loc = Pair(it[1], loc.second + 1)\n            else loc = Pair(it[1],1)\n            if (loc.second > ret.second) ret = loc  \n        }\n        return ret\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207410,"user_id":null,"body":"package kata\n\nobject KataSolution {\n    fun longestRepetition(s: String): Pair<Char?,Int> {\n        if (s.isEmpty()) return null to 0\n\n        var prev: Char? = null\n        var pair: Pair<Char, Int> = ' ' to 0\n        var count = 1\n\n        s.forEach {\n            if (prev == it) count++\n            else{\n                if (prev != null && pair.second < count)\n                    pair = prev!! to count\n                count = 1\n            }\n\n            prev = it\n        }\n\n        if (prev != null && pair.second < count)\n            pair = prev!! to count\n\n        return pair\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207411,"user_id":null,"body":"package kata\n\nobject KataSolution {\n    fun longestRepetition(s: String): Pair<Char?,Int> {\n        if(s.isNotEmpty()){\n        val out = s.split(\"(?<=(.))(?!\\\\1)\".toRegex()).toList()\n        val map = out.groupBy { it.count() }\n        val c: Char = map.maxBy { it.key }?.value?.get(0)?.substring(0,1)!![0]\n        val l: Int = map.maxBy { it.key }?.key!!\n        return Pair(c, l)}\n        else {\n            return Pair(null, 0)\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207412,"user_id":null,"body":"package kata\n\nobject KataSolution {\n    fun longestRepetition(s: String): Pair<Char?,Int> = if (s.isEmpty()) Pair(null, 0) else {\n        var current: Pair<Char?, Int> = Pair(null, 0)\n        var currentMax = 1\n\n        for (i in 0 until s.lastIndex)\n            if (s[i] == s[i + 1])\n                currentMax++\n            else {\n                if (currentMax > current.second)\n                    current = Pair(s[i], currentMax)\n\n                currentMax = 1\n            }\n\n        if (currentMax > current.second)\n            current = Pair(s.last(), currentMax)\n\n        current\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207413,"user_id":null,"body":"package kata\n\nobject KataSolution {\n    fun longestRepetition(s: String): Pair<Char?,Int> {\n        if(s.isBlank()) return Pair(null,0)\n    var longestChar = s[0]\n    var longestLen = 1\n    var currentLen = 1\n    for (x in 0 until s.length-1) {\n        if(s[x]==s[x+1]) currentLen++\n        else {\n            currentLen = 1\n        }\n        if(longestLen<currentLen){\n            longestLen=currentLen\n            longestChar = s[x]\n        }\n    }\n    return Pair(longestChar,longestLen)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207414,"user_id":null,"body":"package kata\n\n    object KataSolution {\n        fun longestRepetition(s: String): Pair<Char?,Int> {\n\n            if(s.isEmpty()) return Pair(null, 0)\n            val asListOfConsecutiveCharacters = s.consecutiveTokens()\n            return asListOfConsecutiveCharacters.map { Pair(it[0] as Char?, it.length) }.maxBy { it.second }!!\n        }\n        private fun String.consecutiveTokens(): List<String>{\n            return this.foldIndexed(\"\"){i, c, v -> if(i > 0  && this[i-1] != this[i]) \"$c $v\" else c+v}.split(\"\\\\s\".toRegex())\n        }\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207415,"user_id":null,"body":"package kata\n\nobject KataSolution {\n    fun longestRepetition(s: String): Pair<Char?,Int> {\n        if (s.isEmpty()) return Pair(null, 0)\n        \n        return s.toList().windowed(2).fold(mutableListOf<Pair<Char, Int>>(Pair(s[0], 1))) { acc, chars ->\n            if (chars[0] == chars[1]) acc[acc.lastIndex] = Pair(chars[1], acc[acc.lastIndex].second + 1)\n            else acc.add(Pair(chars[1], 1))\n            acc\n        }.maxWithOrNull { a, b -> a.second.compareTo(b.second) }.let { it!! }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207416,"user_id":null,"body":"package kata\n\nobject KataSolution {\n    fun longestRepetition(s: String): Pair<Char?,Int> {\n        println(s)\n        val list = mutableListOf<Pair<Char?,Int>>()\n        var count = 1\n        var repetitionChar  ='\u00a7'\n        var actualPair = Pair('-',0)\n        \n        for (char in s){\n            if(char==repetitionChar){\n               actualPair = Pair(repetitionChar,count)\n            count++\n            }else{\n               count=1;\n                repetitionChar=char;\n                actualPair = Pair(repetitionChar,count)\n                count++\n            }\n            \n            list.add(actualPair)\n        }\n        \n        var thebiggestvalue = 0\n        list.forEach{\n            if(it.second > thebiggestvalue){\n                thebiggestvalue = it.second\n                \n                actualPair = Pair(it.first!!,it.second)\n            }\n        }\n        \n        return if (repetitionChar =='\u00a7'){\n            Pair(null,0)\n        }else{\n            actualPair\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"58708934a44cfccca60000c4":[{"id":207417,"user_id":null,"body":"fun highlight(code: String): String {\n    return Regex(\"F+|R+|L+|\\\\d+\").replace(code) {\n        val colour = when (it.value[0]) {\n            'F' -> \"pink\"\n            'L' -> \"red\"\n            'R' -> \"green\"\n            else -> \"orange\"\n        }\n        \"<span style=\\\"color: $colour\\\">${it.value}<\/span>\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207418,"user_id":null,"body":"fun highlight(code: String): String {\n    return code.replace(Regex(\"F+|L+|R+|[0-9]+\")) {\n        \"<span style=\\\"color: %s\\\">%s<\/span>\"\n            .format(\n                when (it.groupValues[0][0]) {\n                    'F' -> \"pink\";\n                    'L' -> \"red\";\n                    'R' -> \"green\";\n                    else -> \"orange\";\n                }, it.groupValues[0]);\n    };\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207419,"user_id":null,"body":"fun highlight(code: String): String = code\n    .replace(\"F+\".toRegex()) { syntax(it.value, \"pink\")}\n    .replace(\"L+\".toRegex()) { syntax(it.value, \"red\")}\n    .replace(\"R+\".toRegex()) { syntax(it.value, \"green\")}\n    .replace(\"[0-9]+\".toRegex()) { syntax(it.value, \"orange\")}\n\nfun syntax(value: String , color:String):String = \"<span style=\\\"color: $color\\\">$value<\/span>\"","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207420,"user_id":null,"body":"fun coder(s:String,ans:String):String{\n\tif(s==\"\")return ans\n\tif(s[0].isDigit())\n\t\treturn ans+\"\"\"<span style=\"color: orange\">\"\"\"+s+\"<\/span>\"\n\telse\n\twhen(s[0]){\n\t\t\t'F' -> return ans+\"\"\"<span style=\"color: pink\">\"\"\"+s+\"<\/span>\"\n\t\t\t'R' -> return ans+\"\"\"<span style=\"color: green\">\"\"\"+s+\"<\/span>\"\n\t\t\t'L' -> return ans+\"\"\"<span style=\"color: red\">\"\"\"+s+\"<\/span>\"\t\n\t\t}\n\treturn ans;\n}\nfun highlight(str:String):String{\n\tvar a:MutableList<Char> =mutableListOf('`')\n\tvar s:String=\"\"\n\tvar ans=\"\"\n\t\tfor(i in str){\n\t\t\tif((i==a.lastOrNull()||i.isDigit()&&(a.last()).isDigit())&&(i!='('&&i!=')'))    a.add(i)\n\t\t\telse{\n\t\t\t\t\twhile(a.last()!='`'){\n\t\t\t\t\t\ts=a.last()+s\n\t\t\t\t\t\ta.removeAt(a.size-1)\n\t\t\t\t\t\t}\n\t\t\t\t\tans=coder(s,ans)\n\t\t\t\t\tif(i!='('&&i!=')')a.add(i)\n\t\t\t\t\telse ans+=i\n\t\t\t\t    s=\"\"\n                }\n\t\t}\n        while(a.last()!='`'){\n\t\ts=a.last()+s\n        a.removeAt(a.size-1)\t\t\t\t\t\n\t}\n\treturn coder(s,ans)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207421,"user_id":null,"body":"    fun highlight(code: String): String {\n        val builder = HighlightBuilder()\n        code.forEach(builder::next)\n        return builder.buildText()\n    }\n\n    class HighlightBuilder {\n        private var lastGroup: HighlightGroup? = null\n        private val groups = mutableListOf<HighlightGroup>()\n\n        fun next(char: Char) {\n            val color = selectColor(char)\n            if (lastGroup?.highlightColor == color) {\n                lastGroup?.group?.add(char)\n            } else {\n                lastGroup = HighlightGroup(color, char).also { groups.add(it) }\n            }\n        }\n\n        private fun selectColor(char: Char): HighlightColor =\n            when (char) {\n                'F' -> HighlightColor.PINK\n                'R' -> HighlightColor.GREEN\n                'L' -> HighlightColor.RED\n                in '0'..'9' -> HighlightColor.ORANGE\n                else -> HighlightColor.NONE\n            }\n\n        fun buildText(): String = groups.joinToString(separator = \"\") { it.makeText() }\n    }\n\n    data class HighlightGroup(val highlightColor: HighlightColor, val group: MutableList<Char>) {\n        constructor(highlightColor: HighlightColor, initialChar: Char) : this(\n            highlightColor,\n            mutableListOf(initialChar)\n        )\n\n        fun makeText(): String {\n            val text = group.joinToString(separator = \"\")\n            return when (highlightColor) {\n                HighlightColor.NONE -> text\n                else -> \"<span style=\\\"color: ${highlightColor.name.toLowerCase()}\\\">$text<\/span>\"\n            }\n        }\n    }\n\n    enum class HighlightColor {\n        PINK, RED, GREEN, ORANGE, NONE\n    }\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207422,"user_id":932,"body":"fun highlight(code: String) = code.replace(Regex(\"[F]+|[L]+|[R]+|[0-9]+\")){\n    \"<span style=\\\"color: \"+when(it.value[0]) {'F' -> \"pink\";'L' -> \"red\";'R' -> \"green\";else -> \"orange\";}+\"\\\">${it.value}<\/span>\"\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207423,"user_id":null,"body":"fun highlight(code: String): String {\n    val reg1 = \"F+\".toRegex()\n    val reg2 = \"L+\".toRegex()\n    val reg3 = \"R+\".toRegex()\n    val reg4 = \"\\\\d+\".toRegex()\n    var highCode = reg1.replace(code) {it -> \"<span style=\\\"color: pink\\\">\" + it.value + \"<\/span>\"}\n    highCode = reg2.replace(highCode) {it -> \"<span style=\\\"color: red\\\">\" + it.value + \"<\/span>\"}\n    highCode = reg3.replace(highCode) {it -> \"<span style=\\\"color: green\\\">\" + it.value + \"<\/span>\"}\n    highCode = reg4.replace(highCode) {it -> \"<span style=\\\"color: orange\\\">\" + it.value + \"<\/span>\"}\n    \n    return highCode\n    }\n    ","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207424,"user_id":null,"body":"fun highlight(code: String): String {\n    \/* Implement your RS2 interpreter here\n     * If you have completed the previous Kata in this Series, you may\n     * copy and paste your solution here and make improvements on it :)\n     *\/\n    return code.splitByDiff().joinToString(\"\") { print(it, getColorByCode(it[0])) }\n}\n\nfun String.splitByDiff(): List<String> {\n    var result = \"\"\n    this.forEachIndexed { index, c ->\n        result += c\n\n        if ((index < length - 1) &&\n            ((c.isLetter() && this[index + 1] != c) || (c.isDigit() && !this[index + 1].isDigit() || c == ')' || c == '('))\n        ) {\n            result += ' '\n        }\n    }\n    return result.split(' ')\n\n}\n\nenum class Color(val color: String) {\n    PINK(\"pink\"),\n    RED(\"red\"),\n    GREEN(\"green\"),\n    ORANGE(\"orange\"),\n    NONE(\"none\")\n}\n\nfun getColorByCode(code: Char): Color = when (code) {\n    'F' -> Color.PINK\n    'L' -> Color.RED\n    'R' -> Color.GREEN\n    in '0'..'9' -> Color.ORANGE\n    else -> Color.NONE\n}\n\n\nfun print(text: String, color: Color): String {\n    return if (color == Color.NONE) text else \"<span style=\\\"color: ${color.color}\\\">$text<\/span>\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207425,"user_id":null,"body":"fun highlight(code: String): String {\n    val regex = Regex(\"(F+)|(R+)|(L+)|(\\\\d+)|(\\\\(+)|(\\\\)+)\")\n    return regex.findAll(code).map { mr ->\n        val color = when(val char = mr.value.first()) {\n            'F' -> \"pink\"\n            'L' -> \"red\"\n            'R' -> \"green\"\n            else -> if (char.isDigit()) \"orange\" else \"\"\n        }\n        if (color.isNotEmpty())\n            \"<span style=\\\"color: $color\\\">${mr.value}<\/span>\"\n        else mr.value\n    }.joinToString(\"\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207426,"user_id":null,"body":"fun keyword_color(ch: Char): String {\n    return when {\n        ch == 'F' -> \"pink\"\n        ch == 'L' -> \"red\"\n        ch == 'R' -> \"green\"\n        ch.isDigit() -> \"orange\"\n        else -> \"\"\n    }        \n}\n\nfun highlight(code: String): String {\n    if (code == \"\") return code\n    \n    val builder = StringBuilder()\n    \n    val inSpan = false\n    var index = 0\n    val cmd = ArrayList<Char>()\n    while (true) {        \n        while (index < code.length && \n               ((cmd.size == 0) ||\n                (cmd.first() == code[index]) ||\n                (cmd.first().isDigit() && code[index].isDigit())               \n               )\n              ) {                \n                cmd.add(code[index++])                \n        }            \n        \n        if (cmd.size == 0) break\n        val ch = cmd.first()\n        val color = keyword_color(ch)\n        if (color != \"\") {            \n            builder.append(\"\"\"<span style=\"color: $color\">\"\"\")                   \n            builder.append(cmd.joinToString(\"\"))\n            builder.append(\"<\/span>\")\n        } else if (ch == '(' || ch == ')') {\n            builder.append(cmd.joinToString(\"\"))\n        }\n        cmd.clear()\n    }\n    return builder.toString()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5870fa11aa0428da750000da":[{"id":207427,"user_id":null,"body":"enum class Direction { RIGHT, LEFT, UP, DOWN }\n\nfun execute(code: String): String {\n    val pos: ArrayList<Pair<Int, Int>> = arrayListOf(Pair(0, 0))\n    val rem: String = code\n    var dir: Direction = Direction.RIGHT\n    var matchResult = Regex(\"\"\"(L\\d*|R\\d*|F\\d*)\"\"\").find(rem)\n\n\n    while (matchResult != null) {\n        with(matchResult.groupValues[1]) {\n            val move = first()\n            val nb = if (length == 1) 1 else substring(1).toInt()\n\n            when (move) {\n                'L' -> repeat(nb) {\n                    dir = when (dir) {\n                        Direction.RIGHT -> Direction.UP\n                        Direction.UP -> Direction.LEFT\n                        Direction.LEFT -> Direction.DOWN\n                        Direction.DOWN -> Direction.RIGHT\n                    }\n                }\n                'R' -> repeat(nb) {\n                    dir = when (dir) {\n                        Direction.RIGHT -> Direction.DOWN\n                        Direction.UP -> Direction.RIGHT\n                        Direction.LEFT -> Direction.UP\n                        Direction.DOWN -> Direction.LEFT\n                    }\n                }\n                'F' -> {\n                    repeat(nb) {\n                        pos.last().let {\n                            pos.add(when (dir) {\n                                Direction.RIGHT -> Pair(it.first + 1, it.second)\n                                Direction.UP -> Pair(it.first, it.second - 1)\n                                Direction.LEFT -> Pair(it.first - 1, it.second)\n                                Direction.DOWN -> Pair(it.first, it.second + 1)\n                            })\n                        }\n                    }\n                }\n            }\n        }\n\n        matchResult = matchResult.next()\n    }\n\n    val min: Pair<Int, Int> = Pair(pos.map { it.first }.min() ?: 0, pos.map { it.second }.min() ?: 0)\n    val max: Pair<Int, Int> = Pair(pos.map { it.first }.max() ?: 0, pos.map { it.second }.max() ?: 0)\n    val rx = max.first - min.first\n    val ry = max.second - min.second\n    val list: List<MutableList<String>> = generateSequence { generateSequence { \" \" }.take(rx + 1).toMutableList() }.take(ry + 1).toList()\n    pos.forEach { list[it.second - min.second][it.first - min.first] = \"*\" }\n\n    return list.map {\n        it.joinToString(\"\")\n    }.joinToString(\"\\r\n\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207428,"user_id":null,"body":"import java.awt.Point\nimport java.awt.Rectangle\n\nfun execute(code: String): String {\n    var current = Point()\n    var dir = Point(1, 0)\n    val visited = mutableSetOf(current)\n\n    for (result in Regex(\"(F+|R+|L+)(\\\\d*)\").findAll(code)) {\n        val action = result.groupValues[1][0]\n        val repeat = result.groupValues[1].length - 1 + (result.groupValues[2].toIntOrNull() ?: 1)\n\n        for (i in 0 until repeat) {\n            when (action) {\n                'F' -> {\n                    current = Point(current.x + dir.x, current.y + dir.y)\n                    visited.add(current)\n                }\n                'L' -> dir = Point(dir.y, -dir.x)\n                'R' -> dir = Point(-dir.y, dir.x)\n            }\n        }\n    }\n\n    val bounds = visited.fold(Rectangle(-1, -1)) { r, p -> r.add(p); r }\n    return (bounds.y..bounds.y + bounds.height).joinToString(\"\\r\n\") { row ->\n        (bounds.x..bounds.x + bounds.width).joinToString(\"\") { col -> if (Point(col, row) in visited) \"*\" else \" \" }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207429,"user_id":null,"body":"class Robot(\n    private val grid: Grid\n) {\n    private var x = 0\n    private var y = 0\n    private var dx = 1\n    private var dy = 0\n\n    init {\n        grid.footstep(x, y)\n    }\n\n    fun moveForward() {\n        x += dx\n        y += dy\n        grid.footstep(x, y)\n    }\n\n    fun rotateLeft() {\n        if (dx != 0) {\n            dy = -dx\n            dx = 0\n        } else {\n            dx = dy\n            dy = 0\n        }\n    }\n\n    fun rotateRight() {\n        if (dx != 0) {\n            dy = dx\n            dx = 0\n        } else {\n            dx = -dy\n            dy = 0\n        }\n    }\n}\n\nclass Grid {\n    private var top = 0\n    private var bottom = 0\n    private var left = 0\n    private var right = 0\n    private val grid = mutableMapOf<Int, MutableSet<Int>>()\n\n    fun footstep(x: Int, y: Int) {\n        grid.computeIfAbsent(y) {\n            top = minOf(top, y)\n            bottom = maxOf(bottom, y)\n            mutableSetOf()\n        }\n        left = minOf(left, x)\n        right = maxOf(right, x)\n        grid[y]!! += x\n    }\n\n    override fun toString(): String {\n        if (grid.isEmpty()) return \"\"\n        \n        val sb = StringBuilder()\n        for (row in 0 until (bottom - top + 1)) {\n            for (column in 0 until (right - left + 1)) {\n                val symbol = if (grid[row + top]!!.contains(column + left)) '*' else ' '\n                sb.append(symbol)\n            }\n            if (row != bottom - top) sb.append(\"\\r\n\")\n        }\n\n        return sb.toString()\n    }\n}\n\nfun execute(code: String): String {\n    val grid = Grid()\n    val robot = Robot(grid)\n\n    val commands = \"[LFR]\\\\d*\".toRegex().findAll(code).map { it.value }\n    commands.forEach { command ->\n        val move = command.first()\n        val times = if (command.length > 1) command.substring(1).toInt() else 1\n\n        for (i in 0 until times) {\n            when (move) {\n                'F' -> robot.moveForward()\n                'L' -> robot.rotateLeft()\n                'R' -> robot.rotateRight()\n            }\n        }\n    }\n\n    return grid.toString()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207430,"user_id":null,"body":"fun execute(code: String) = RobotMoveManager(RoboScriptParser()).execute(code)\n\nprivate class RobotMoveManager(\n    private val parser: RoboScriptParser\n) {\n    \n    private val field = mutableListOf<MutableList<Char>>()\n    \n    private val width get() = field[0].size\n    private val height get() = field.size\n    \n    private var x = 0\n    private var y = 0\n    \n    private var code = \"\"\n    \n    @Synchronized\n    fun execute(code: String): String {\n        cleanUp()\n        \n        field[0][0] = '*'\n        \n        parser.parse(code).forEach { move ->\n            repeat(move.distance) { moveTo(move.direction) }\n        }\n        \n        return field.joinToString(separator = \"\\r\n\", transform = { it.joinToString(\"\") })\n    }\n    \n    \n    private fun moveTo(direction: MoveDirection) {\n        when (direction) {\n            MoveDirection.TOP -> if (y == 0) addLine(false)\n            MoveDirection.BOTTOM -> if (y == height - 1) addLine(true)\n            MoveDirection.LEFT -> if (x == 0) addColumn(false)\n            MoveDirection.RIGHT -> if (x == width - 1) addColumn(true)\n        }\n\n        if (direction.horizontal) x += direction.multiplier\n        else y += direction.multiplier\n        \n        field[y][x] = '*'\n    }\n  \n    \n    private fun addLine(toEnd: Boolean) {\n        val line = mutableListOf<Char>()\n        repeat(width) { line.add(' ') }\n        \n        if (toEnd) {\n            field.add(line)\n        } else{\n            field.add(0, line)\n            y++\n        }\n    }\n    \n    private fun addColumn(toEnd: Boolean) {\n        field.forEach {\n            if (toEnd) it.add(' ')\n            else it.add(0, ' ')\n        }\n        \n        if (!toEnd) x++\n    }\n    \n    private fun cleanUp() {\n        x = 0\n        y = 0\n        \n        field.clear()\n        field.add(mutableListOf(' '))\n    }\n    \n}\n\n\n\nprivate class RoboScriptParser {\n\n    private val moves = mutableListOf<Move>()\n\n    private var lastLetter = ' '\n    private var lastCommand = ' '\n\n    private var currentDigit = \"\"\n    private var currentDirection = MoveDirection.RIGHT\n\n\n    @Synchronized\n    fun parse(code: String): List<Move> {\n        cleanUp()\n        \n        code.toCharArray().forEach(::parseLetter)\n        parseLetter(' ')\n        \n        return moves\n    }\n\n\n    private fun parseLetter(letter: Char) {\n        when {\n            letter.isDigit() -> {\n                currentDigit += letter.toString()\n            }\n\n            lastLetter.isDigit() -> {\n                val digit = currentDigit.toIntOrNull() ?: 2\n\n                parseCommand(lastCommand, digit - 1)\n                parseCommand(letter)\n                currentDigit = \"\"\n            }\n\n            else -> parseCommand(letter)\n        }\n\n        if (!letter.isDigit()) lastCommand = letter\n        lastLetter = letter\n    }\n\n    private fun parseCommand(command: Char, times: Int = 1) {\n        when (command) {\n            'F' -> moves.add(Move(currentDirection, times))\n            'R', 'L' -> currentDirection = currentDirection.turn(command, times)\n        }\n    }\n\n    private fun MoveDirection.turn(direction: Char, times: Int = 1): MoveDirection {\n        val values = MoveDirection.values()\n        val size = values.size\n        val shortTimes = times % size\n\n        if (shortTimes == 0) return this\n\n        val multiplier = if (direction == 'R') 1 else - 1\n        val finalIndex = (size + values.indexOf(this) + shortTimes * multiplier) % size\n\n        return values[finalIndex]\n    }\n\n    private fun cleanUp() {\n        moves.clear()\n        lastLetter = ' '\n        lastCommand = ' '\n        currentDigit = \"\"\n        currentDirection = MoveDirection.RIGHT\n    }\n\n}\n\n\n\nprivate data class Move(\n    val direction: MoveDirection, \n    val distance: Int\n)\n\n\n\nenum class MoveDirection(val multiplier: Int, val horizontal: Boolean) {\n    TOP(-1, false), RIGHT(1, true), BOTTOM(1, false), LEFT(-1, true)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207431,"user_id":null,"body":"fun execute(code: String): String {\n    var minX = 0\n    var maxX = 0\n    var minY = 0\n    var maxY = 0\n    val outStr = StringBuilder(\"\")\n    var direction: Direction = Direction.RIGHT\n    var currentPos = 0 to 0\n    var grid = setOf(0 to 0)\n    val simpleCode = code.replace(\"F\\\\d+|L\\\\d+|R\\\\d+\".toRegex()) {\n        it.value[0].toString().repeat(it.value.drop(1).toInt())\n    }\n    simpleCode.forEach {\n        when (it) {\n            'R' -> direction = Direction.values()[if (direction.ordinal - 1 == -1) 3 else direction.ordinal - 1]\n            'L' -> direction = Direction.values()[if (direction.ordinal + 1 == 4) 0 else direction.ordinal + 1]\n            'F' -> {\n                when (direction) {\n                    Direction.RIGHT -> {\n                        val newCurrentPos = currentPos.copy(currentPos.first + 1, currentPos.second)\n                        if (maxX < newCurrentPos.first) maxX++\n                        grid = grid.plus(newCurrentPos)\n                        currentPos = newCurrentPos\n                    }\n                    Direction.DOWN -> {\n                        val newCurrentPos = currentPos.copy(currentPos.first, currentPos.second - 1)\n                        if (minY > newCurrentPos.second) minY--\n                        grid = grid.plus(newCurrentPos)\n                        currentPos = newCurrentPos\n                    }\n                    Direction.LEFT -> {\n                        val newCurrentPos = currentPos.copy(currentPos.first - 1, currentPos.second)\n                        if (minX > newCurrentPos.first) minX--\n                        grid = grid.plus(newCurrentPos)\n                        currentPos = newCurrentPos\n                    }\n                    Direction.UP -> {\n                        val newCurrentPos = currentPos.copy(currentPos.first, currentPos.second + 1)\n                        if (maxY < newCurrentPos.second) maxY++\n                        grid = grid.plus(newCurrentPos)\n                        currentPos = newCurrentPos\n                    }\n                }\n            }\n            else -> print(it)\n        }\n    }\n    for (j in minY..maxY) {\n        for (i in minX..maxX) {\n            if (grid.contains(i to j)) outStr.append(\"*\") else outStr.append(\" \")\n        }\n        if (j != maxY) outStr.append(\"\\r\n\")\n    }\n    return outStr.toString()\n}\n\nenum class Direction {\n    RIGHT,\n    DOWN,\n    LEFT,\n    UP\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207432,"user_id":null,"body":"\nfun execute(code: String): String {\n    val steps = Regex(\"\"\"\\w\\d*\"\"\").findAll(code).map { it.value }\n    val state = GameState()\n\n    steps.forEach { step ->\n        repeat(Regex(\"\\\\d+\").find(step)?.value?.toInt() ?: 1) {\n            when (step[0]) {\n                'L' -> state.dir =\n                    Direction.values().getOrElse(state.dir.ordinal - 1) { Direction.UP }\n                'R' -> state.dir =\n                    Direction.values().getOrElse(state.dir.ordinal + 1) { Direction.RIGHT }\n                else -> move(state)\n            }\n        }\n    }\n\n    val x = state.pos.maxOf { it.first } + 1\n    val y = state.pos.maxOf { it.second } + 1\n    val matrix = MutableList(y) { MutableList(x) { \" \" } }\n    state.pos.forEach { matrix[it.second][it.first] = \"*\" }\n\n    return matrix.joinToString(\"\\r\n\") { it.joinToString(\"\") }\n}\n\ndata class GameState(\n    var dir: Direction = Direction.RIGHT,\n    var pos: MutableList<Pair<Int, Int>> = mutableListOf(0 to 0)\n)\n\nfun move(state: GameState) {\n    var pos = state.pos.last()\n    pos = pos.first + state.dir.x to pos.second + state.dir.y\n\n    state.pos.remove(pos)\n    state.pos.add(pos)\n\n    if (pos.first < 0) state.pos = state.pos.map { it.first + 1 to it.second }.toMutableList()\n    if (pos.second < 0) state.pos = state.pos.map { it.first to it.second + 1 }.toMutableList()\n}\n\nenum class Direction(val x: Int, val y: Int) {\n    RIGHT(1, 0), DOWN(0, 1), LEFT(-1, 0), UP(0, -1)\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207433,"user_id":null,"body":"fun execute(code: String): String {\n    val steps = Regex(\"\"\"\\w\\d*\"\"\").findAll(code).map { it.value }\n    val state = GameState()\n\n    steps.forEach { step ->\n        repeat(Regex(\"\\\\d+\").find(step)?.value?.toInt() ?: 1) {\n            when (step[0]) {\n                'L' -> state.curDirection =\n                    Direction.values().getOrElse(state.curDirection.ordinal - 1) { Direction.UP }\n                'R' -> state.curDirection =\n                    Direction.values().getOrElse(state.curDirection.ordinal + 1) { Direction.RIGHT }\n                else -> move(state)\n            }\n        }\n    }\n    val x = state.positions.maxOf { it.first } + 1\n    val y = state.positions.maxOf { it.second } + 1\n    val matrix = MutableList(y) { MutableList(x) { \" \" } }\n    state.positions.forEach { matrix[it.second][it.first] = \"*\" }\n\n    return matrix.joinToString(\"\\r\n\") { it.joinToString(\"\") }\n}\n\ndata class GameState(\n    var curDirection: Direction = Direction.RIGHT,\n    var positions: MutableList<Pair<Int, Int>> = mutableListOf(0 to 0)\n)\n\nfun move(state: GameState) {\n    var pos = state.positions.last()\n    pos = when (state.curDirection) {\n        Direction.RIGHT -> {\n            pos.copy(first = pos.first + 1)\n        }\n        Direction.DOWN -> {\n            pos.copy(second = pos.second + 1)\n        }\n        Direction.LEFT -> {\n            pos.copy(first = pos.first - 1)\n        }\n        Direction.UP -> {\n            pos.copy(second = pos.second - 1)\n        }\n    }\n    state.positions.remove(pos)\n    state.positions.add(pos)\n\n    if (pos.first < 0) state.positions = state.positions.map { it.first + 1 to it.second }.toMutableList()\n    if (pos.second < 0) state.positions = state.positions.map { it.first to it.second + 1 }.toMutableList()\n}\n\nenum class Direction {\n    RIGHT, DOWN, LEFT, UP\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207434,"user_id":null,"body":"typealias Coordinate = Pair<Int, Int>\n\nval Coordinate.x get() = first\nval Coordinate.y get() = second\n\nenum class Direction {\n    UP,\n    DOWN,\n    LEFT,\n    RIGHT;\n\n    fun turnAntiClockwise() = when (this) {\n        UP -> LEFT\n        DOWN -> RIGHT\n        LEFT -> DOWN\n        RIGHT -> UP\n    }\n\n    fun turnClockwise() = when (this) {\n        UP -> RIGHT\n        DOWN -> LEFT\n        LEFT -> UP\n        RIGHT -> DOWN\n    }\n}\n\nfun Coordinate.move(direction: Direction): Coordinate = when (direction) {\n    Direction.UP -> Coordinate(x, y - 1)\n    Direction.DOWN -> Coordinate(x, y + 1)\n    Direction.LEFT -> Coordinate(x - 1, y)\n    Direction.RIGHT -> Coordinate(x + 1, y)\n}\n\ndata class RobotState(val relativeCoordinate: Coordinate, val facing: Direction)\n\nfun executeCode(code: String): Map<Int, Set<Int>> {\n    val res = mutableMapOf(0 to setOf(0))\n    var facing = Direction.RIGHT\n    var currentCoordinate = 0 to 0\n    Regex(\"\"\"[RLF]([0-9]*)\"\"\").findAll(code).forEach {\n        val (command, repeats) = it.groupValues[0].first() to (it.groupValues[1].toIntOrNull() ?: 1)\n        when (command) {\n            'R' -> {\n                repeat(repeats % 4) {\n                    facing = facing.turnClockwise()\n                }\n            }\n            'L' -> {\n                repeat(repeats % 4) {\n                    facing = facing.turnAntiClockwise()\n                }\n            }\n            'F' -> {\n                repeat(repeats) {\n                    currentCoordinate = currentCoordinate.move(facing)\n                    val (x, y) = currentCoordinate\n                    res[x] = res[x]?.plus(y) ?: setOf(y)\n                }\n            }\n        }\n    }\n    return res\n}\n\nfun draw(map: Map<Int, Set<Int>>): String {\n    val minX = map.minOf { it.key }\n    val maxX = map.maxOf { it.key }\n    val minY = map.values.flatten().minOrNull()!!\n    val maxY = map.values.flatten().maxOrNull()!!\n    val matrix = List(maxY - minY + 1) { y ->\n        List(maxX - minX + 1) { x ->\n            if (map[x + minX]?.contains(y + minY) == true) '*'\n            else ' '\n        }\n    }\n    return matrix.joinToString(\"\\r\n\") { it.joinToString(\"\") }\n}\n\nfun execute(code: String): String = draw(executeCode(code))","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207435,"user_id":null,"body":"fun execute(code: String): String {\n    val path = mutableMapOf<String,Boolean>(\"0_0\" to true)\n    val grid = object {\n        var up = 0; var down = 0\n        var left = 0; var right = 0\n        var x = 0; var y = 0\n        var dir = 'R'\n\n        fun turn(d: Char){\n            dir = when(d){\n                'L' -> when(dir){\n                    'R' -> 'U'\n                    'D' -> 'R'\n                    'L' -> 'D'\n                    else -> 'L'\n                }\n                else -> when(dir){\n                    'R' -> 'D'\n                    'D' -> 'L'\n                    'L' -> 'U'\n                    else -> 'R'\n                }\n            }\n        }\n        fun move(){\n            when(dir){\n                'R' -> {\n                    x += 1\n                    if(right < x) right = x\n                    path[\"${x}_${y}\"] = true\n                }\n                'L' -> {\n                    x -= 1\n                    if(left > x) left = x\n                    path[\"${x}_${y}\"] = true\n                }\n                'U' -> {\n                    y += 1\n                    if(up < y) up = y\n                    path[\"${x}_${y}\"] = true\n                }\n                'D' -> {\n                    y -= 1\n                    if(down > y) down = y\n                    path[\"${x}_${y}\"] = true\n                }\n            }\n        }\n\n        override fun toString():String {\n            var res = \"\"\n            res += \"up = $up, down = $down, left = $left, right = $right\n\"\n            res += \"x = $x, y = $y, dir = $dir\"\n            return res\n        }\n    }\n    var tmp = \"\"\n    var num = false\n    for(i in code.indices){\n        tmp += code[i]\n        if(i != code.length-1){\n            if(!num){\n                if(code[i+1] !in \"0123456789\"){\n                    when(tmp[0]){\n                        'F' -> grid.move()\n                        'R' -> grid.turn('R')\n                        'L' -> grid.turn('L')\n                    }\n                    tmp = \"\"\n                }\n                else {\n                    num = true\n                    continue\n                }\n            } else {\n                if(code[i+1] !in \"0123456789\"){\n                    val chr = tmp[0]\n                    val n = tmp.drop(1).toInt()\n                    for(x in 1..n){\n                        when(chr){\n                            'F' -> grid.move()\n                            'L' -> grid.turn('L')\n                            'R' -> grid.turn('R')\n                        }\n                    }\n                    tmp = \"\"; num = false\n                } else continue\n            }\n        } else if(num){\n            val chr = tmp[0]\n            val n = tmp.drop(1).toInt()\n            for(x in 1..n){\n                when(chr){\n                    'F' -> grid.move()\n                    'L' -> grid.turn('L')\n                    'R' -> grid.turn('R')\n                }\n            }\n            tmp = \"\"; num = false\n        } else {\n            when(tmp[0]){\n                'F' -> grid.move()\n                'R' -> grid.turn('R')\n                'L' -> grid.turn('L')\n            }\n            tmp = \"\"\n        }\n    }\n\n    val row = Array<String>(grid.right - grid.left+2){\" \"}\n    row[row.size-1] = \"\\r\n\"\n    val g = Array<MutableList<String>>(grid.up - grid.down+1){row.toMutableList()}\n    g[g.size-1].remove(\"\\r\n\")\n\n    for(k in path.keys){\n        val c = k.split(\"_\")\n        var x = c[0].toInt()\n        var y = c[1].toInt()\n        x -= grid.left\n        y -= grid.up\n        y *= -1\n        g[y][x] = \"*\"\n    }\n    var result = \"\"\n    for(a in g){\n        val str = a.joinToString(\"\")\n        result += str\n    }\n\n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207436,"user_id":null,"body":"fun execute(code: String): String {\n    val steps = \"(\\\\D)(\\\\d*)\".toRegex().findAll(code)\n    val map = mutableMapOf(0 to mutableSetOf(0))\n    var dir = 1 to 0\n    var pos = 0 to 0\n    steps.forEach{match ->\n        repeat(match.groups[2]!!.value.toIntOrNull()?:1) {\n            when (match.groups[1]!!.value) {\n                \"F\" -> {\n                    pos = pos.copy(first = pos.first + dir.first)\n                    pos = pos.copy(second = pos.second + dir.second)\n                    map.getOrPut(pos.second){mutableSetOf()}.add(pos.first)\n                }\n                \"L\" -> {\n                    dir = dir.copy(first = -dir.second, second = dir.first)\n                    if (dir.first < -1) dir = dir.copy(first = 0)\n                    if (dir.second < -1) dir = dir.copy(second = 0)\n                }\n                \"R\" -> {\n                    dir = dir.copy(first = dir.second, second = -dir.first)\n                    if (dir.first > 1) dir = dir.copy(first = 0)\n                    if (dir.second > 1) dir = dir.copy(second = 0)\n                }\n            }\n        }\n    }\n    val min = map.values.minOfOrNull{it.minOrNull() ?: 0} ?: 0\n    val max = map.values.maxOfOrNull{it.maxOrNull() ?: 0} ?: 0\n    val dist = max - min + 1\n    return map.toSortedMap().values.reversed().map{\" \".repeat(dist).mapIndexed{i,_ -> if (it.contains(min + i)) '*' else ' '}.joinToString(\"\")}.joinToString(\"\\r\n\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"58712dfa5c538b6fc7000569":[{"id":207437,"user_id":null,"body":"fun countRedBeads(nBlue: Int): Int = if (nBlue < 2) 0 else (nBlue - 1) * 2","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207438,"user_id":null,"body":"fun countRedBeads(nBlue: Int): Int = when {\n  nBlue < 2 -> 0\n  else -> (nBlue - 1) * 2\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207439,"user_id":null,"body":"fun countRedBeads(nBlue: Int): Int = if(nBlue < 2) 0 else 2 * (nBlue - 1)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207440,"user_id":null,"body":"fun countRedBeads(nBlue: Int): Int {\n        when (nBlue) {\n            0, 1 -> return 0\n        }\n\n        return (nBlue - 1) * 2\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207441,"user_id":null,"body":"fun countRedBeads(nBlue: Int) = if (nBlue > 0) (nBlue - 1) * 2 else 0","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207442,"user_id":null,"body":"fun countRedBeads(n: Int) = (n - 1).coerceAtLeast(0) * 2","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207443,"user_id":null,"body":"fun countRedBeads(nBlue: Int): Int =\n    if (nBlue < 2) 0 else 2 + countRedBeads(nBlue - 1)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207444,"user_id":null,"body":"fun countRedBeads(nBlue: Int): Int = nBlue.dec().coerceAtLeast(0) * 2\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207445,"user_id":null,"body":"fun countRedBeads(nBlue: Int) = when {\n  nBlue < 2 -> 0\n  else -> (nBlue - 1) * 2\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207446,"user_id":null,"body":"fun countRedBeads(nBlue: Int): Int = if(nBlue < 2) 0 else 2*nBlue-2\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"587309155cfd6b9fb60000a0":[{"id":207447,"user_id":null,"body":"package com.codewars.geoffp\n\nobject UnwantedDollars {\n  fun moneyValue(money:String):Double {\n     return money.replace(\" \", \"\").replace(\"$\", \"\").toDoubleOrNull() ?: 0.0;\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207448,"user_id":932,"body":"package com.codewars.geoffp\nobject UnwantedDollars {\nfun moneyValue(money:String)=money.replace(Regex(\"[$\\\\s]\"),\"\").toDoubleOrNull()?:0.0\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207449,"user_id":null,"body":"package com.codewars.geoffp\n\nobject UnwantedDollars {\n    fun moneyValue(money:String):Double {\n        return money.replace(\"[$ ]\".toRegex(), \"\").toDoubleOrNull() ?: 0.0;\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207450,"user_id":null,"body":"package com.codewars.geoffp\n\nobject UnwantedDollars {\n  fun moneyValue(money: String) = money.filter { it in \"0123456789-.\" }.toDoubleOrNull() ?: 0.0\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207451,"user_id":null,"body":"package com.codewars.geoffp\n\nobject UnwantedDollars {\n  fun moneyValue(money:String) = money.filter { it != ' ' && it != '$' }.toDoubleOrNull() ?: 0.0\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207452,"user_id":null,"body":"package com.codewars.geoffp\n\nobject UnwantedDollars {\n  fun moneyValue(money:String):Double {\n    var s = money.replace(\"[^0-9.-]\".toRegex(), \"\").replace(\"^-$\".toRegex(), \"\");    \n    \n    if (s.isEmpty()) {\n      return 0.0;\n    } else {\n      return s.toDouble();\n    }    \n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207453,"user_id":null,"body":"package com.codewars.geoffp\n\nobject UnwantedDollars {\n  fun moneyValue(money: String) = money.replace(\"$\", \"\").replace(\" \", \"\").toDoubleOrNull() ?: 0.0\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207454,"user_id":null,"body":"package com.codewars.geoffp\n\nobject UnwantedDollars {\n  fun moneyValue(money: String): Double = try {\n        money.replace(\"[\\$ ]\".toRegex(), \"\").toDouble()\n    } catch (e: NumberFormatException) {\n        0.0\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207455,"user_id":null,"body":"package com.codewars.geoffp\n\nobject UnwantedDollars {\n  fun moneyValue(money:String):Double {\n    if (money.replace(\"$\",\"\").replace(\" \",\"\").toDoubleOrNull() == null) {\n        return 0.0\n    } else {\n        return money.replace(\"$\",\"\").replace(\" \",\"\").toDouble()\n    }\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207456,"user_id":null,"body":"package com.codewars.geoffp\n\nobject UnwantedDollars {\n  fun moneyValue(money:String) = money.replace(\"[^0-9-.]\".toRegex(), \"\").toDoubleOrNull() ?: 0.0\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"58738d518ec3b4bf95000192":[{"id":207457,"user_id":null,"body":"enum class Direction {\n    N, E, S, W\n}\n\nfun execute(code: String): String {\n    val codeWithoutBrackets = resolveBrackets(code)\n    val longCode = codeWithoutBrackets.replace(\"[FLR][0-9]+\".toRegex()) {\n        \"${it.value[0]}\".repeat(it.value.drop(1).toInt())\n    }\n    val coords = longCode.fold(Pair(mutableListOf(Pair(0, 0)), Direction.W)) { acc, command ->\n        var direction = acc.second\n        when (command) {\n            'L' -> direction = when (acc.second) {\n                Direction.N -> Direction.E\n                Direction.E -> Direction.S\n                Direction.S -> Direction.W\n                Direction.W -> Direction.N\n            }\n            'R' -> direction = when (acc.second) {\n                Direction.N -> Direction.W\n                Direction.W -> Direction.S\n                Direction.S -> Direction.E\n                Direction.E -> Direction.N\n            }\n            else -> {\n                val last = acc.first.last()\n                val newPos = when (direction) {\n                    Direction.N -> last.copy(second = last.second - 1)\n                    Direction.W -> last.copy(first = last.first + 1)\n                    Direction.S -> last.copy(second = last.second + 1)\n                    Direction.E -> last.copy(first = last.first - 1)\n                }\n                acc.first += newPos\n            }\n        }\n        acc.copy(second = direction)\n    }\n    val minX = (coords.first.map { it.first }.min() ?: 0)\n    val minY = (coords.first.map { it.second }.min() ?: 0)\n    val transposed = coords.first.map { it.copy(first = it.first - minX, second = it.second - minY) }\n    val board = MutableList<MutableList<String>>((transposed.map { it.second }.max() ?: 0) + 1 ) { MutableList<String>((transposed.map { it.first }.max() ?: 0) + 1) { \" \" } }\n    transposed.forEach { board[it.second][it.first] = \"*\" }\n    return board.joinToString(\"\\r\n\") { it -> it.joinToString(\"\") }\n}\n\nfun resolveBrackets(code: String): String {\n    val bracketMatcher = \"\\\\([RFL,0-9]*\\\\)[0-9]*\".toRegex()\n    var resolved = code\n    while (bracketMatcher.find(resolved) != null) {\n        resolved =  resolved.replace(\"\\\\([RFL,0-9]*\\\\)[0-9]*\".toRegex()) {\n            val times = \"\\\\d+$\".toRegex().find(it.value)?.value?.toInt() ?: 1\n            it.value.substringBeforeLast(\")\").substring(1).repeat(times)\n        }\n    }\n    return resolved\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207458,"user_id":null,"body":"import kotlin.math.*\n\ndata class Coord(val x: Int, val y: Int)\n\nenum class Offset(val x: Int, val y: Int) {\n    RIGHT(1, 0),\n    TOP(0, -1),\n    LEFT(-1, 0),\n    BOTTOM(0, 1)\n}\n\nclass Board {\n    private var startX = 0\n    private var startY = 0\n    private var endX = 0\n    private var endY = 0\n    private val visited = mutableSetOf(Coord(0, 0))\n    var offset = Offset.RIGHT\n    var curr = Coord(0, 0)\n        set(value) {\n            field = value\n            startX = min(startX, value.x)\n            startY = min(startY, value.y)\n            endX = max(endX, value.x)\n            endY = max(endY, value.y)\n            visited += value\n        }\n        \n    override fun toString() =\n        (startY..endY).map { y ->\n            (startX..endX).map { x ->\n                if (visited.contains(Coord(x, y))) \"*\" else \" \"\n            }.joinToString(\"\")\n        }.joinToString(\"\\r\n\")\n}\n\nabstract class Command {\n    var repeat = 1\n    abstract fun execute(board: Board)\n}\n\nclass Forward : Command() {\n    override fun execute(board: Board) {\n        for (i in 1..repeat) {\n            board.curr = Coord(board.curr.x + board.offset.x, board.curr.y + board.offset.y)\n        }\n    }\n}\n\nclass Left : Command() {\n    override fun execute(board: Board) {\n        for (i in 1..repeat%4) {\n            board.offset = when (board.offset) {\n                Offset.RIGHT -> Offset.TOP\n                Offset.TOP -> Offset.LEFT\n                Offset.LEFT -> Offset.BOTTOM\n                Offset.BOTTOM -> Offset.RIGHT\n            }\n        }\n    }\n}\n\nclass Right : Command() {\n    override fun execute(board: Board) {\n        for (i in 1..repeat%4) {\n            board.offset = when (board.offset) {\n                Offset.RIGHT -> Offset.BOTTOM\n                Offset.TOP -> Offset.RIGHT\n                Offset.LEFT -> Offset.TOP\n                Offset.BOTTOM -> Offset.LEFT\n            }\n        }\n    }\n}\n\nclass CommandSequence : Command() {\n    companion object {\n        private val REPEAT_REGEX = Regex(\"\\\\d+\")\n    }\n    \n    private val commands = mutableListOf<Command>()\n    \n    fun feed(code: String, pos: Int): Int {\n        var currPos = pos\n        while (true) {\n            if (currPos == code.length) {\n                return currPos\n            }\n            var command: Command\n            when (val c = code[currPos]) {\n                ')' -> return currPos\n                '(' -> {\n                    command = CommandSequence()\n                    currPos = command.feed(code, currPos + 1)\n                }\n                'F' -> command = Forward()\n                'L' -> command = Left()\n                'R' -> command = Right()\n                else -> throw IllegalArgumentException(c.toString())\n            }\n            commands += command\n            currPos++\n            REPEAT_REGEX.find(code, currPos)?.let {\n                if (it.range.start == currPos) {\n                    command.repeat = it.value.toInt()\n                    currPos += it.value.length\n                }\n            }\n        }\n    }\n    \n    override fun execute(board: Board) {\n        (1..repeat).forEach {\n            commands.forEach { it.execute(board) }\n        }\n    }\n}\n\nfun execute(code: String): String {\n    val top = CommandSequence()\n    assert(top.feed(code, 0) == code.length)\n    \n    val board = Board()\n    top.execute(board)\n    return board.toString()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207459,"user_id":null,"body":"fun execute(code: String): String {\n    val removedBrackets = removeBrackets(code)\n    val steps = Regex(\"\"\"\\w\\d*\"\"\").findAll(removedBrackets).map { it.value }\n    val state = GameState()\n\n    steps.forEach { step ->\n        repeat(Regex(\"\\\\d+\").find(step)?.value?.toInt() ?: 1) {\n            when (step[0]) {\n                'L' -> state.dir =\n                    Direction.values().getOrElse(state.dir.ordinal - 1) { Direction.UP }\n                'R' -> state.dir =\n                    Direction.values().getOrElse(state.dir.ordinal + 1) { Direction.RIGHT }\n                else -> move(state)\n            }\n        }\n    }\n\n    val x = state.pos.maxOf { it.first } + 1\n    val y = state.pos.maxOf { it.second } + 1\n    val matrix = MutableList(y) { MutableList(x) { \" \" } }\n    state.pos.forEach { matrix[it.second][it.first] = \"*\" }\n\n    return matrix.joinToString(\"\\r\n\") { it.joinToString(\"\") }\n}\n\nfun removeBrackets(s: String): String {\n    val reg = Regex(\"\"\"\\(\\w+?\\)(\\d*)\"\"\")\n    val first = reg.find(s)?.value\n    return if (first != null) {\n        val string: String = Regex(\"\"\"\\w+\"\"\").find(first)!!.value\n        val dig = Regex(\"\"\"\\d+$\"\"\").find(first)?.value?.toInt() ?: 1\n\n        removeBrackets(reg.replaceFirst(s, string.repeat(dig)))\n    } else s\n}\n\n\ndata class GameState(\n    var dir: Direction = Direction.RIGHT,\n    var pos: MutableList<Pair<Int, Int>> = mutableListOf(0 to 0)\n)\n\nfun move(state: GameState) {\n    var pos = state.pos.last()\n    pos = pos.first + state.dir.x to pos.second + state.dir.y\n\n    state.pos.remove(pos)\n    state.pos.add(pos)\n\n    if (pos.first < 0) state.pos = state.pos.map { it.first + 1 to it.second }.toMutableList()\n    if (pos.second < 0) state.pos = state.pos.map { it.first to it.second + 1 }.toMutableList()\n}\n\nenum class Direction(val x: Int, val y: Int) {\n    RIGHT(1, 0), DOWN(0, 1), LEFT(-1, 0), UP(0, -1)\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207460,"user_id":null,"body":"typealias Coordinate = Pair<Int, Int>\n\nval Coordinate.x get() = first\nval Coordinate.y get() = second\n\nfun Coordinate.move(direction: Direction): Coordinate = when (direction) {\n    Direction.UP -> Coordinate(x, y - 1)\n    Direction.DOWN -> Coordinate(x, y + 1)\n    Direction.LEFT -> Coordinate(x - 1, y)\n    Direction.RIGHT -> Coordinate(x + 1, y)\n}\n\nenum class Direction {\n    UP,\n    DOWN,\n    LEFT,\n    RIGHT;\n\n    fun turnAntiClockwise() = when (this) {\n        UP -> LEFT\n        DOWN -> RIGHT\n        LEFT -> DOWN\n        RIGHT -> UP\n    }\n\n    fun turnClockwise() = when (this) {\n        UP -> RIGHT\n        DOWN -> LEFT\n        LEFT -> UP\n        RIGHT -> DOWN\n    }\n}\n\ntailrec fun expand(code: String): String {\n    val expanded = code.replace(Regex(\"\"\"\\(([^()]+)\\)(\\d*)\"\"\")) {\n        val (_, macro, repeats) = it.groupValues\n        macro.repeat(repeats.toIntOrNull() ?: 1)\n    }\n    return if (expanded.contains(Regex(\"\"\"[()]\"\"\"))) expand(expanded) else expanded\n}\n\nfun executeCode(code: String): Map<Int, Set<Int>> {\n    val res = mutableMapOf(0 to setOf(0))\n    var facing = Direction.RIGHT\n    var currentCoordinate = 0 to 0\n    Regex(\"\"\"[RLF]([0-9]*)\"\"\").findAll(expand(code)).forEach {\n        val (command, repeats) = it.groupValues[0].first() to (it.groupValues[1].toIntOrNull() ?: 1)\n        when (command) {\n            'R' -> {\n                repeat(repeats % 4) {\n                    facing = facing.turnClockwise()\n                }\n            }\n            'L' -> {\n                repeat(repeats % 4) {\n                    facing = facing.turnAntiClockwise()\n                }\n            }\n            'F' -> {\n                repeat(repeats) {\n                    currentCoordinate = currentCoordinate.move(facing)\n                    val (x, y) = currentCoordinate\n                    res[x] = res[x]?.plus(y) ?: setOf(y)\n                }\n            }\n        }\n    }\n    return res\n}\n\nfun draw(map: Map<Int, Set<Int>>): String {\n    val minX = map.minOf { it.key }\n    val maxX = map.maxOf { it.key }\n    val minY = map.values.flatten().minOrNull()!!\n    val maxY = map.values.flatten().maxOrNull()!!\n    val matrix = List(maxY - minY + 1) { y ->\n        List(maxX - minX + 1) { x ->\n            if (map[x + minX]?.contains(y + minY) == true) '*'\n            else ' '\n        }\n    }\n    return matrix.joinToString(\"\\r\n\") { it.joinToString(\"\") }\n}\n\nfun execute(code: String): String = draw(executeCode(code))","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207461,"user_id":null,"body":"fun execute(code: String): String {\n    val path = mutableMapOf<String,Boolean>(\"0_0\" to true)\n    val grid = object {\n        var up = 0; var down = 0\n        var left = 0; var right = 0\n        var x = 0; var y = 0\n        var dir = 'R'\n\n        fun turn(d: Char){\n            dir = when(d){\n                'L' -> when(dir){\n                    'R' -> 'U'\n                    'D' -> 'R'\n                    'L' -> 'D'\n                    else -> 'L'\n                }\n                else -> when(dir){\n                    'R' -> 'D'\n                    'D' -> 'L'\n                    'L' -> 'U'\n                    else -> 'R'\n                }\n            }\n        }\n        fun move(){\n            when(dir){\n                'R' -> {\n                    x += 1\n                    if(right < x) right = x\n                    path[\"${x}_${y}\"] = true\n                }\n                'L' -> {\n                    x -= 1\n                    if(left > x) left = x\n                    path[\"${x}_${y}\"] = true\n                }\n                'U' -> {\n                    y += 1\n                    if(up < y) up = y\n                    path[\"${x}_${y}\"] = true\n                }\n                'D' -> {\n                    y -= 1\n                    if(down > y) down = y\n                    path[\"${x}_${y}\"] = true\n                }\n            }\n        }\n\n        override fun toString():String {\n            var res = \"\"\n            res += \"up = $up, down = $down, left = $left, right = $right\n\"\n            res += \"x = $x, y = $y, dir = $dir\"\n            return res\n        }\n    }\n    var expanded = \"\"\n    val loops = mutableListOf<String>()\n    var loopIndex = -1\n    var pLevel = 0\n    var digit = false\n    var repeat = \"\"\n    for(i in code.indices){\n        if(i != code.length-1){\n            if(digit){\n                repeat += code[i]\n                if(code[i+1].isDigit()) continue\n                else {\n                    val loop = repeat.toInt()\n                    if(loops.size > 1){\n                        for(x in 1..loop){\n                            loops[loops.size-2] += loops[loops.size-1]\n                        }\n                        loops.removeAt(loops.size-1)\n                        loopIndex -= 1\n                        digit = false; repeat = \"\"\n                    } else {\n                        for(x in 1..loop){\n                            expanded += loops[0]\n                        }\n                        loops.removeAt(0)\n                        loopIndex -= 1\n                        digit = false; repeat = \"\"\n                    }\n                }\n            }\n            else if(pLevel == 0){\n                if(code[i] != '('){\n                    expanded += code[i]\n                } else {\n                    pLevel += 1\n                    loops.add(\"\")\n                    loopIndex += 1\n                    continue\n                }\n            } else {\n                if(code[i] == ')'){\n                    pLevel -= 1\n                    if(code[i+1].isDigit()){\n                        digit = true\n                    } else {\n                        if(loops.size > 1){\n                            loops[loops.size-2] += loops[loops.size-1]\n                            loops.removeAt(loops.size-1)\n                            loopIndex -= 1\n                        } else {\n                            expanded += loops[0]\n                            loops.removeAt(0)\n                            loopIndex -= 1\n                        }\n                    }\n                } else if(code[i] == '('){\n                    pLevel += 1\n                    loops.add(\"\")\n                    loopIndex += 1\n                    continue\n                } else {\n                    loops[loopIndex] = loops[loopIndex] + code[i]\n                }\n            }\n        } else { \/\/ last index\n            if(digit){\n                repeat += code[i]\n                val loop = repeat.toInt()\n                if(loops.size > 1){\n                    for(x in 1..loop){\n                        loops[loops.size-2] += loops[loops.size-1]\n                    }\n                    loops.removeAt(loops.size-1)\n                    loopIndex -= 1\n                    digit = false; repeat = \"\"\n                } else {\n                    for(x in 1..loop){\n                        expanded += loops[0]\n                    }\n                    loops.removeAt(0)\n                    loopIndex -= 1\n                    digit = false; repeat = \"\"\n                }\n            } else if(code[i] == ')'){\n                expanded += loops[0]\n            } else expanded += code[i]\n        }\n\n    }\n\n    var tmp = \"\"\n    var num = false\n    for(i in expanded.indices){\n        tmp += expanded[i]\n        if(i != expanded.length-1){\n            if(!num){\n                if(!expanded[i+1].isDigit()){\n                    when(tmp[0]){\n                        'F' -> grid.move()\n                        'R' -> grid.turn('R')\n                        'L' -> grid.turn('L')\n                    }\n                    tmp = \"\"\n                }\n                else {\n                    num = true\n                    continue\n                }\n            } else {\n                if(!expanded[i+1].isDigit()){\n                    val chr = tmp[0]\n                    val n = tmp.drop(1).toInt()\n                    for(x in 1..n){\n                        when(chr){\n                            'F' -> grid.move()\n                            'L' -> grid.turn('L')\n                            'R' -> grid.turn('R')\n                        }\n                    }\n                    tmp = \"\"; num = false\n                } else continue\n            }\n        } else if(num){\n            val chr = tmp[0]\n            val n = tmp.drop(1).toInt()\n            for(x in 1..n){\n                when(chr){\n                    'F' -> grid.move()\n                    'L' -> grid.turn('L')\n                    'R' -> grid.turn('R')\n                }\n            }\n            tmp = \"\"; num = false\n        } else {\n            when(tmp[0]){\n                'F' -> grid.move()\n                'R' -> grid.turn('R')\n                'L' -> grid.turn('L')\n            }\n            tmp = \"\"\n        }\n    }\n\n    val row = Array<String>(grid.right - grid.left+2){\" \"}\n    row[row.size-1] = \"\\r\n\"\n    val g = Array<MutableList<String>>(grid.up - grid.down+1){row.toMutableList()}\n    g[g.size-1].remove(\"\\r\n\")\n\n    for(k in path.keys){\n        val c = k.split(\"_\")\n        var x = c[0].toInt()\n        var y = c[1].toInt()\n        x -= grid.left\n        y -= grid.up\n        y *= -1\n        g[y][x] = \"*\"\n    }\n    var result = \"\"\n    for(a in g){\n        val str = a.joinToString(\"\")\n        result += str\n    }\n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207462,"user_id":null,"body":"fun execute(code: String): String {\n    val map = mutableMapOf(0 to mutableSetOf(0))\n    \n    val pos = IntPair()\n    val dir = IntPair(first = 1)\n    \n    val step = parse(code)\n    step.run(pos, dir, map)\n    \n    \/\/ Render\n    val min = map.values.minOfOrNull{it.minOrNull() ?: 0} ?: 0\n    val max = map.values.maxOfOrNull{it.maxOrNull() ?: 0} ?: 0\n    val dist = max - min + 1\n    return map.toSortedMap().values.reversed().map{\" \".repeat(dist).mapIndexed{i,_ -> if (it.contains(min + i)) '*' else ' '}.joinToString(\"\")}.joinToString(\"\\r\n\")\n}\n\nfun parse(code: String): ActionGroup {\n    val root = ActionGroup(1)\n    \n    var i = 0\n    while (i < code.length) {\n        val char = code[i++]\n        \n        var step: Step\n        if (char == '(') {\n            var brackets = 1\n            var end = i\n            while (brackets > 0) {\n                if (code[end] == '(') brackets++\n                else if (code[end] == ')') brackets--\n                ++end\n            }\n            step = parse(code.substring(i, end - 1))\n            i = end\n        } else {\n            step = Action(1, char)\n        }\n        var repStr = code.drop(i).takeWhile{it.isDigit()}\n        i += repStr.length\n        if (!repStr.isEmpty()) step.repetitions = repStr.toInt()\n        root.steps.add(step)\n    }\n    \n    return root\n}\n\n\/\/ Intentional mutability\ndata class IntPair(var first: Int = 0, var second: Int = 0) {\n    fun add(other: IntPair) {\n        first += other.first\n        second += other.second\n    }\n}\n\nabstract class Step(var repetitions: Int) {\n    fun run(pos: IntPair, dir: IntPair, map: MutableMap<Int, MutableSet<Int>>) {\n        repeat(repetitions) {go(pos, dir, map)}\n    }\n    protected abstract fun go(pos: IntPair, dir: IntPair, map: MutableMap<Int, MutableSet<Int>>)\n}\n\nclass Action(repetitions: Int, val action: Char) : Step(repetitions) {\n    override fun go(pos: IntPair, dir: IntPair, map: MutableMap<Int, MutableSet<Int>>) {\n        when (action) {\n                'F' -> {\n                    pos.add(dir)\n                    map.getOrPut(pos.second){mutableSetOf()}.add(pos.first)\n                }\n                'L' -> {\n                    val first = dir.first\n                    dir.first = -dir.second\n                    dir.second = first\n                }\n                'R' -> {\n                    val first = dir.first\n                    dir.first = dir.second\n                    dir.second = -first\n                }\n            }\n    }\n}\n\nclass ActionGroup(repetitions: Int) : Step(repetitions) {\n    val steps = mutableListOf<Step>()\n    \n    override fun go(pos: IntPair, dir: IntPair, map: MutableMap<Int, MutableSet<Int>>) {\n        steps.forEach {it.run(pos, dir, map)}\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207463,"user_id":null,"body":"private data class Position(val x: Int, val y: Int) {\n    operator fun plus(o: Position) = Position(x + o.x, y + o.y)\n}\n\nprivate enum class Direction(val p: Position) {\n    North(Position(0, -1)),\n    East(Position(1, 0)),\n    South(Position(0, 1)),\n    West(Position(-1, 0));\n\n    val left get() = values()[((values().indexOf(this) + 3) % 4)]\n    val right get() = values()[((values().indexOf(this) + 1) % 4)]\n}\n\nsealed class Token\nobject Forward : Token() {\n    override fun toString() = \"Forward\"\n}\n\nobject Left : Token() {\n    override fun toString() = \"Left\"\n}\n\nobject Right : Token() {\n    override fun toString() = \"Right\"\n}\n\ndata class Number(val n: Int) : Token() {\n    override fun toString() = n.toString()\n}\n\nobject OpenBracket : Token()  {\n    override fun toString() = \"{\"\n}\nobject CloseBracket : Token() {\n    override fun toString() = \"}\"\n}\n\nprivate tailrec fun tokenize(code: String, acc: List<Token> = emptyList()): List<Token> {\n    if (code.isEmpty()) {\n        return acc\n    }\n    if (code[0].isDigit()) {\n        var i = 0\n        var res = 0\n        while (code.getOrNull(i)?.isDigit() == true) {\n            res *= 10\n            res += code[i].toString().toInt()\n            i++\n        }\n        return tokenize(code.substring(i), acc + listOf(Number(res)))\n    }\n    return when (code[0]) {\n        'F' -> tokenize(code.substring(1), acc + listOf(Forward))\n        'L' -> tokenize(code.substring(1), acc + listOf(Left))\n        'R' -> tokenize(code.substring(1), acc + listOf(Right))\n        '(' -> tokenize(code.substring(1), acc + listOf(OpenBracket))\n        ')' -> tokenize(code.substring(1), acc + listOf(CloseBracket))\n        else -> throw IllegalStateException()\n    }\n}\n\nsealed class Element\nclass MoveForward(val repeat: Int) : Element() {\n    override fun toString() = \"F$repeat\"\n}\nclass TurnLeft(val repeat: Int) : Element() {\n    override fun toString() = \"L$repeat\"\n}\nclass TurnRight(val repeat: Int) : Element() {\n    override fun toString() = \"R$repeat\"\n}\nclass Group(val elements: List<Element>, val repeat: Int) : Element()  {\n    override fun toString() = \"G($elements)$repeat\"\n}\n\nprivate fun peekNumber(tokens: List<Token>, make: (Int) -> Element): Pair<Int, Element> {\n    val n = tokens.getOrNull(1) as? Number\n    return n?.let {\n        2 to make(it.n)\n    } ?: (1 to make(1))\n}\n\nprivate fun matchingBracket(tokens: List<Token>): Int {\n    var i = 0\n    var j = 0\n    while (true) {\n        val t = tokens.getOrNull(i) ?: throw IllegalStateException(\"no matching bracket found\")\n        if (t is OpenBracket) {\n            j++\n        }\n        if (t is CloseBracket) {\n            if (j == 1) {\n                return i\n            }\n            j--\n        }\n        i++\n    }\n}\n\nprivate fun treeize(tokens: List<Token>, acc: List<Element> = emptyList()): List<Element> {\n    if (tokens.isEmpty()) {\n        return acc\n    }\n    return when (tokens[0]) {\n        is Forward -> {\n            val (o, t) = peekNumber(tokens) { MoveForward(it) }\n            treeize(tokens.subList(o, tokens.size), acc + t)\n        }\n        is Left -> {\n            val (o, t) = peekNumber(tokens) { TurnLeft(it) }\n            treeize(tokens.subList(o, tokens.size), acc + t)\n        }\n        is Right -> {\n            val (o, t) = peekNumber(tokens) { TurnRight(it) }\n            treeize(tokens.subList(o, tokens.size), acc + t)\n        }\n        is Number -> {\n            throw IllegalStateException(\"Unexpected Number\")\n        }\n        is OpenBracket -> {\n            val i = matchingBracket(tokens)\n            val subElements = treeize(tokens.subList(1, i))\n            val (o, t) = peekNumber(tokens.subList(i, tokens.size)) { Group(subElements, it) }\n            treeize(tokens.subList(i + o, tokens.size), acc + t)\n        }\n        else -> throw IllegalStateException(\"Unexected Token: ${tokens[0]}\")\n    }\n}\n\nprivate data class Interpreter(var direction: Direction = Direction.East,\n                    val positions: MutableList<Position> = mutableListOf(Position(0, 0)),\n                    var position: Position = Position(0, 0)\n) {\n    fun execute(l: List<Element>): Interpreter {\n        for (e in l) {\n            when (e) {\n                is MoveForward -> repeat(e.repeat) { position += direction.p; positions.add(position) }\n                is TurnLeft -> repeat(e.repeat) { direction = direction.left }\n                is TurnRight -> repeat(e.repeat) { direction = direction.right }\n                is Group -> repeat(e.repeat) { execute(e.elements) }\n            }\n        }\n        return this\n    }\n\n    val result\n        get(): String {\n            val minx = positions.minOf { it.x }\n            val maxx = positions.maxOf { it.x }\n            val miny = positions.minOf { it.y }\n            val maxy = positions.maxOf { it.y }\n            return (miny..maxy).joinToString(\"\\r\n\") { y ->\n                (minx..maxx).joinToString(\"\") { x ->\n                    if (Position(x, y) in positions) {\n                        \"*\"\n                    } else {\n                        \" \"\n                    }\n                }\n            }\n        }\n}\n\nfun execute(code: String) = Interpreter().execute(treeize(tokenize(code))).result","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207464,"user_id":null,"body":"import kotlin.math.abs\n\nclass Pos(val x: Int, val y: Int) {\n    fun forward(direction: Direction) = when (direction) {\n        Direction.E -> Pos(x + 1, y)\n        Direction.S -> Pos(x, y + 1)\n        Direction.W -> Pos(x - 1, y)\n        Direction.N -> Pos(x, y - 1)\n    }\n}\n\n\nenum class Direction { E, S, W, N;\n    operator fun inc() = values()[(ordinal + 1) % values().size]\n    operator fun dec() = values()[(ordinal + values().size - 1) % values().size]\n}\n\n\nprivate fun positionsToString(positions: List<Pos>): String {\n    var minX = 0\n    var minY = 0\n    var maxX = 0\n    var maxY = 0\n    for (pos in positions) {\n        if (pos.x < minX) minX = pos.x\n        else if (pos.x > maxX) maxX = pos.x\n        if (pos.y < minY) minY = pos.y\n        else if (pos.y > maxY) maxY = pos.y\n    }\n\n    val sizeY = maxY - minY + 1\n    val sizeX = maxX - minX + 1\n    val m = Array(sizeY) {\n        CharArray(sizeX) { ' ' }\n    }\n\n    for (pos in positions) m[pos.y + abs(minY)][pos.x + abs(minX)] = '*'\n    return m.joinToString(\"\\r\n\") { it.joinToString(\"\") }\n}\n\n\nfun execute(code: String): String {\n    val positions = mutableListOf(Pos(0, 0))\n    var direction = Direction.E\n\n    fun process(code: String) {\n        var cmd: (() -> Unit)?\n        var i = 0\n        while (i < code.length) {\n            cmd = when (code[i++]) {\n                'F' -> fun() { positions.add(positions.last().forward(direction)) }\n                'L' -> fun() { direction-- }\n                'R' -> fun() { direction++ }\n                '(' -> {\n                    val start = i\n                    var openBrackets = 1\n                    while (openBrackets != 0) {\n                        if (code[i] == '(') openBrackets++\n                        if (code[i] == ')') openBrackets--\n                        i++\n                    }\n                    fun() { process(code.substring(start, i)) }\n                }\n                else -> null\n            }\n            val repeatCmd = buildString {\n                while (i < code.length && code[i] in '0'..'9') append(code[i++])\n                if (length == 0) append(1)\n            }.toInt()\n            repeat(repeatCmd) { cmd?.invoke() }\n        }\n    }\n    \n    process(code)\n\n    return positionsToString(positions)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207465,"user_id":null,"body":"import java.util.*\n\nfun execute(code: String): String {\n    return RS2Specification.execute(code)\n}\n\nobject RS2Specification {\n    fun execute(code: String): String {\n        val parsedCode = GroupsParser.parse(code)\n        return RS1Specification.execute(parsedCode)\n    }\n}\n\nobject GroupsParser {\n    fun parse(code: String): String {\n        val stack = Stack<String>()\n        Regex(\"(\\\\w[0-9]*)|(\\\\()|(\\\\)[0-9]*)\")\n            .findAll(code)\n            .map { it.value }\n            .forEach { match ->\n                when {\n                    match.startsWith(')') -> {\n                        var last = stack.pop()\n                        val builder = StringBuilder()\n                        while (last != \"(\") {\n                            builder.insert(0, last)\n                            last = stack.pop()\n                        }\n                        stack.push(builder.repeat(match.drop(1).toIntOrNull() ?: 1))\n                    }\n                    else -> stack.push(match)\n                }\n            }\n        return stack.joinToString(separator = \"\")\n    }\n}\n\nobject RS1Specification {\n    fun execute(code: String): String {\n        val points = mutableSetOf(Point(x = 0, y = 0))\n        var direction = Direction.RIGHT\n        var lastPoint = points.first()\n\n        Regex(\"(\\\\w[0-9]*)\")\n            .findAll(code)\n            .forEach { match ->\n                val action: () -> Unit\n                when {\n                    match.value.startsWith('L') -> action = { direction = direction.turnLeft() }\n                    match.value.startsWith('R') -> action = { direction = direction.turnRight() }\n                    else -> action = {\n                        lastPoint = move(lastPoint, direction)\n                        points += lastPoint\n                    }\n                }\n                repeat(match.value.drop(1).toIntOrNull() ?: 1) { action() }\n            }\n\n        val xRange = (points.minOf { it.x }..points.maxOf { it.x })\n        val yRange = (points.maxOf { it.y } downTo points.minOf { it.y })\n\n        val stringBuilder = StringBuilder()\n        for (y in yRange) {\n            for (x in xRange) {\n                if (points.contains(Point(x = x, y = y))) {\n                    stringBuilder.append(\"*\")\n                } else {\n                    stringBuilder.append(\" \")\n                }\n            }\n            if (y != yRange.last) stringBuilder.append(\"\\r\n\")\n        }\n        return stringBuilder.toString()\n    }\n\n    private fun move(point: Point, direction: Direction): Point = when (direction) {\n        Direction.LEFT -> point.copy(x = point.x.dec())\n        Direction.TOP -> point.copy(y = point.y.inc())\n        Direction.RIGHT -> point.copy(x = point.x.inc())\n        Direction.BOTTOM -> point.copy(y = point.y.dec())\n    }\n\n    private data class Point(val x: Int, val y: Int)\n\n    private enum class Direction {\n        LEFT, TOP, RIGHT, BOTTOM;\n\n        fun turnLeft(): Direction = when (this) {\n            LEFT -> BOTTOM\n            TOP -> LEFT\n            RIGHT -> TOP\n            BOTTOM -> RIGHT\n        }\n\n        fun turnRight(): Direction = when (this) {\n            LEFT -> TOP\n            TOP -> RIGHT\n            RIGHT -> BOTTOM\n            BOTTOM -> LEFT\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207466,"user_id":null,"body":"import kotlin.collections.ArrayList\nimport kotlin.math.max\nimport kotlin.math.min\n\n\/**\n * https:\/\/www.codewars.com\/kata\/5870fa11aa0428da750000da\/train\/kotlin\n *\/\nfun execute(code: String): String {\n    return RoboScript3Executor(code).execute();\n}\n\nclass RoboScript3Executor(val code: String) {\n    private val expressions: List<Executable>;\n    private val path = ArrayList<Coordinate>();\n    private var position = Coordinate(0, 0);\n    private var direction = Direction.Right;\n\n    init {\n        expressions = analyzeExpressions();\n        path.add(position);\n    }\n\n    private fun analyzeExpressions(): List<Executable> {\n        return ExpressionAnalyzer(code).analyze();\n    }\n\n    private inner class ExpressionAnalyzer(val code: String) {\n        var readPosition = 0;\n\n        fun analyze(): List<Executable> {\n            val res = ArrayList<Executable>();\n            while (thereIsMoreCodeToRead()) {\n                res.add(readExpression());\n            }\n            return res;\n        }\n\n        private fun thereIsMoreCodeToRead(): Boolean {\n            return readPosition < code.length;\n        }\n\n        private fun readExpression(): Executable {\n            val nextChar = code[readPosition++];\n            if (nextChar == '(') {\n                return readSubExpression();\n            }\n            \n            val command = when (nextChar) {\n                'F' -> createMoveForwardCommand()\n                'L' -> createTurnLeftCommand()\n                'R' -> createTurnRightCommand()\n                else -> throw IllegalStateException(\"Bad char $nextChar\")\n            };\n            val callCount = readCallCount();\n            return if (callCount == 1)\n                command\n            else Expression(listOf(command), callCount);\n        }\n\n        private fun readSubExpression(): Expression {\n            val expressions = ArrayList<Executable>();\n            while (thereIsMoreCodeToRead()) {\n                if (code[readPosition] == ')') {\n                    readPosition++;\n                    break;\n                }\n                expressions.add(readExpression());\n            }\n            return Expression(expressions, readCallCount())\n        }\n\n        private fun readCallCount(): Int {\n            val initialPosition = readPosition;\n            while (thereIsMoreCodeToRead() && code[readPosition] in '0'..'9') {\n                readPosition++;\n            }\n\n            if (initialPosition == readPosition) {\n                return 1;\n            }\n\n            return code.substring(initialPosition, readPosition).toInt();\n        }\n    }\n\n    private interface Executable {\n        fun execute();\n    }\n\n    private class Expression(val parts: List<Executable>, val executionCount: Int) : Executable {\n        override fun execute() {\n            (1..executionCount).forEach(::executeParts);\n        }\n\n        private fun executeParts(occurrence: Int) {\n            parts.forEach(Executable::execute);\n        }\n    }\n\n    private class Command(val method: () -> Unit) : Executable {\n        override fun execute() {\n            method();\n        }\n    }\n\n    fun execute(): String {\n        executeCommands()\n        return buildResultGrid()\n    }\n\n    private fun executeCommands() {\n        expressions.forEach { it.execute(); }\n    }\n\n    private fun buildResultGrid(): String {\n        val bbox: BoundingBox = path.fold(BoundingBox(path[0], path[0])) { acc, c -> acc.union(c) };\n        val grid = MutableList(bbox.height()) { MutableList(bbox.width()) { ' ' } };\n        path.map { bbox.getRelative(it) }.forEach { grid[it.y][it.x] = '*' };\n        return grid.reversed().joinToString(\"\\r\n\") { it.joinToString(\"\") };\n    }\n\n    private fun createMoveForwardCommand(): Command = Command(::moveForward)\n    private fun createTurnLeftCommand(): Command = Command(::turnLeft)\n    private fun createTurnRightCommand(): Command = Command(::turnRight)\n\n    private fun moveForward() {\n        position = direction.move(position);\n        path.add(position);\n    }\n\n    private fun turnLeft() {\n        direction = direction.toLeft();\n    }\n\n    private fun turnRight() {\n        direction = direction.toRight();\n    }\n\n    data class Coordinate(val x: Int, val y: Int) {}\n\n    enum class Direction {\n        Up {\n            override fun toLeft(): Direction = Left\n            override fun toRight(): Direction = Right\n            override fun move(c: Coordinate): Coordinate = Coordinate(c.x, c.y + 1)\n        },\n        Right {\n            override fun toLeft(): Direction = Up\n            override fun toRight(): Direction = Down\n            override fun move(c: Coordinate): Coordinate = Coordinate(c.x + 1, c.y)\n        },\n        Down {\n            override fun toLeft(): Direction = Right\n            override fun toRight(): Direction = Left\n            override fun move(c: Coordinate): Coordinate = Coordinate(c.x, c.y - 1)\n        },\n        Left {\n            override fun toLeft(): Direction = Down\n            override fun toRight(): Direction = Up\n            override fun move(c: Coordinate): Coordinate = Coordinate(c.x - 1, c.y)\n        };\n\n        abstract fun toLeft(): Direction;\n        abstract fun toRight(): Direction;\n        abstract fun move(c: Coordinate): Coordinate;\n    }\n\n    private data class BoundingBox(val topLeft: Coordinate, val bottomRight: Coordinate) {\n        fun width(): Int = bottomRight.x - topLeft.x + 1\n        fun height(): Int = topLeft.y - bottomRight.y + 1\n        fun union(c: Coordinate): BoundingBox {\n            if (contains(c)) {\n                return this;\n            }\n            return BoundingBox(\n                Coordinate(min(c.x, topLeft.x), max(c.y, topLeft.y)),\n                Coordinate(max(c.x, bottomRight.x), min(c.y, bottomRight.y))\n            );\n        }\n\n        fun contains(c: Coordinate): Boolean {\n            return c.x >= topLeft.x && c.x <= bottomRight.x\n                    && c.y >= bottomRight.y && c.y <= topLeft.y;\n        }\n\n        fun getRelative(c: Coordinate): Coordinate = Coordinate(c.x - topLeft.x, c.y - bottomRight.y)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5879f95892074d769f000272":[{"id":207467,"user_id":492,"body":"package biker\n\nfun temps(v0:Double, slope:Double, dTot:Double):Int {\n  val GRAVITYACC = 9.81 * 3.6 * 60.0 \/\/ gravity acceleration 3.6 because km\/h, 60 because hours versus minutes\n  val DRAG = 60.0 * 0.3 \/ 3.6 \/\/ force applied by air on the cyclist, 3.6 because km\/h, 60 because hours versus minutes\n  val DELTA_T = 1.0 \/ 60.0 \/\/ in minutes\n  val DWATTS = 0.5 \/\/ power loss in Watts \/ minute\n  val GTHRUST = 60.0 * 3.6 * 3.6 \/\/ acceleration due to biker's power\n  val MASS = 80.0 \/\/ biker's mass\n  val WATTS0 = 225.0 \/\/ initial biker's power\n  var t = 0.0 \/\/ time in minutes\n  var d = 0.0 \/\/ distance traveled in km\n  var v = v0 \/\/ initial speed km\/h\n  var gamma: Double \/\/ acceleration in km\/h\/minute\n  var watts = WATTS0 \/\/ biker's power (watts at time t + deltaT is watts at time t - dWatts * deltaT)\n  val slopeGravityAcc = -GRAVITYACC * Math.sin(Math.atan(slope \/ 100.0))\n  while (d <= dTot)\n  {\n    t += DELTA_T\n    \n    \/\/ earth gravity due to slope and drag due to air resistance\n    gamma = slopeGravityAcc - DRAG * Math.abs(v) * Math.abs(v) \/ MASS\n    \/\/ acceleration due to biker's power\n    if ((watts > 0.0) && (v > 0.0))\n    {\n      gamma += GTHRUST * watts \/ (v * MASS)\n    }\n    \/\/ acceleration too small -> acc = 0\n    if (Math.abs(gamma) <= 1e-5)\n    {\n      gamma = 0.0\n    }\n    v += gamma * DELTA_T\n    \/\/ new power\n    watts -= DWATTS * DELTA_T \/\/ fatigue\n    \/\/ new distance\n    d += v * DELTA_T \/ 60.0 \/\/ v in km\/h, deltaT in minutes\n    \/\/ speed too slow, John stops\n    if (v - 3.0 <= 1e-2)\n    {\n      return -1\n    }\n  }\n  return Math.round(t).toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207468,"user_id":1228,"body":"package biker\n\nimport kotlin.math.abs\n\nfun slope(slope: Double) : Double = slope\/Math.sqrt(1+slope*slope)\n\nfun temps(v0:Double, slope:Double, dTot:Double):Int {\n    val GRAVITY_ACC = 9.81 * 3.6 * 60.0  \n    val DRAG        = 60.0 * 0.3 \/ 3.6  \n    val DELTA_T     = 1.0 \/ 60.0    \n    val G_THRUST    = 60 * 3.6 * 3.6  \n    val MASS        = 80.0   \n    val WATTS0      = 225.0 \n    val D_WATTS     = 0.5      \n    val TOO_TIRED   = -1\n    \n    var t     = 0.0   \n    var gamma = 0.0    \n    var v     = v0    \n    var d     = 0.0  \n    var watts = WATTS0  \n    while(true) {\n        gamma = (- GRAVITY_ACC * slope(slope\/100))  - (DRAG * v * v \/ MASS)  + G_THRUST * watts \/ (v * MASS)\n        if(abs(gamma) > 1e-2) {\n            v += gamma * DELTA_T\n        }\n        d += v * DELTA_T \/ 60\n        watts -= (D_WATTS*DELTA_T)\n        when { \n            (v-3 <= 1e-2) ->      return TOO_TIRED\n            (d > dTot)    ->      return Math.round(t).toInt()\n        else              ->      t = t + DELTA_T\n        }\n        \n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207469,"user_id":null,"body":"package biker\n\nfun temps(v0:Double, slope:Double, xTot:Double):Int {\n  println(\"$v0 $slope $xTot\")\n  var t = 0\n  var a = 0.0\n  var v = v0 \/ 3.6\n  var x = 0.0\n  var p = 225.0\n  \n  val slowing = 9.81 * Math.sin(Math.atan(slope \/ 100.0))\n  \n  while (v * 3.6 - 3.0 > 1e-2 && x < xTot * 1000) {\n    a = (p \/ v \/ 80.0 - slowing - 0.00375 * v * v).takeIf { Math.abs(it) > 1e-5 } ?: 0.0\n    p -= 0.5 \/ 60.0\n    v += a\n    x += v\n    t++\n  }\n  \n  return if (x >= xTot * 1000) Math.round(t \/ 60.0).toInt() else -1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207470,"user_id":null,"body":"package biker\n\nimport kotlin.math.abs\n\nfun slope(slope: Double) : Double {\n    return slope\/Math.sqrt(1+slope*slope)\n}\n\nfun temps(v0:Double, slope:Double, dTot:Double):Int {\n    val GRAVITY_ACC = 9.81 * 3.6 * 60.0                        \/\/ gravity acceleration\n    val DRAG        = 60.0 * 0.3 \/ 3.6                         \/\/ force applied by air on the cyclist\n    val DELTA_T     = 1.0 \/ 60.0                               \/\/ in minutes\n    val G_THRUST    = 60 * 3.6 * 3.6                           \/\/ pedaling thrust\n    val MASS        = 80.0                                     \/\/ biker's mass\n    val WATTS0      = 225.0                                    \/\/ initial biker's power\n    val D_WATTS     = 0.5                                      \/\/ loss of power at each deltaT\n\n    var t = 0.0                                                \/\/ time\n    var gamma = 0.0                                            \/\/ total acceleration with its 3 components\n    var v = v0                                                 \/\/ speed\n    var d = 0.0                                                \/\/ distance travelled\n    var watts = WATTS0                                         \/\/ biker's power\n    while(true) {\n        gamma = (- GRAVITY_ACC * slope(slope\/100))  - (DRAG * v * v \/ MASS)  + G_THRUST * watts \/ (v * MASS)\n        if(abs(gamma)<=1e-2) {\n        } else {\n            v += gamma * DELTA_T\n        }\n        d += v * DELTA_T \/ 60\n        watts -= (D_WATTS*DELTA_T)\n        if(v-3<=1e-2) {\n            return -1\n        }\n        if(d>dTot) {\n            return Math.round(t).toInt()\n        }\n        t = t + DELTA_T\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207471,"user_id":null,"body":"package biker\n\nfun temps(v0:Double, slope:Double, dTot:Double):Int {\n  val GRAVITY_ACC = 9.81 * 3.6 * 60.0\n  val DRAG = 60.0 * 0.3 \/ 3.6\n  val DELTA_T = 1.0 \/ 60.0\n  val G_THRUST = 60 * 3.6 * 3.6\n  val MASS = 80.0\n  val WATTS0 = 225.0\n  val D_WATTS = 0.5\n \n  var t = 0.0\n  var gamma = 0.0\n  var v = v0\n  var d = 0.0\n  var watts = WATTS0\n  \n  while(d<dTot) {\n    t += DELTA_T \n    watts -= D_WATTS*DELTA_T\n    gamma = -GRAVITY_ACC * Math.sin(Math.atan(slope\/100.0))\n    gamma -= DRAG * v * v \/ MASS\n    if (watts > 0.0 && v > 0.0) {\n      gamma += G_THRUST * watts \/ (v * MASS) \n    }\n    if (Math.abs(gamma) <= 1e-5) gamma = 0.0\n    v += gamma*DELTA_T\n    d += v*DELTA_T\/60.0 \n    if (v <= 3.01) return -1\n  }\n  \n  return Math.round(t).toInt() \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207472,"user_id":492,"body":"package biker\n\nfun temps(v0:Double, slope:Double, dTot:Double):Int {\n  val GRAVITYACC = 9.81 * 3.6 * 60.0 \/\/ gravity acceleration 3.6 because km\/h, 60 because hours versus minutes\n  val DRAG = 60.0 * 0.3 \/ 3.6 \/\/ force applied by air on the cyclist, 3.6 because km\/h, 60 because hours versus minutes\n  val DELTA_T = 1.0 \/ 60.0 \/\/ in minutes\n  val DWATTS = 0.5 \/\/ power loss in Watts \/ minute\n  val GTHRUST = 60.0 * 3.6 * 3.6 \/\/ acceleration due to biker's power\n  val MASS = 80.0 \/\/ biker's mass\n  val WATTS0 = 225.0 \/\/ initial biker's power\n  var t = 0.0 \/\/ time in minutes\n  var d = 0.0 \/\/ distance traveled in km\n  var v = v0 \/\/ initial speed km\/h\n  var gamma: Double \/\/ acceleration in km\/h\/minute\n  var watts = WATTS0 \/\/ biker's power (watts at time t + deltaT is watts at time t - dWatts * deltaT)\n  val slopeGravityAcc = -GRAVITYACC * Math.sin(Math.atan(slope \/ 100.0))\n  while (d <= dTot)\n  {\n    t += DELTA_T\n    \n    \/\/ earth gravity due to slope and drag due to air resistance\n    gamma = slopeGravityAcc - DRAG * Math.abs(v) * Math.abs(v) \/ MASS\n    \/\/ acceleration due to biker's power\n    if ((watts > 0.0) && (v > 0.0))\n    {\n      gamma += GTHRUST * watts \/ (v * MASS)\n    }\n    \/\/ acceleration too small -> acc = 0\n    if (Math.abs(gamma) <= 1e-5)\n    {\n      gamma = 0.0\n    }\n    v += gamma * DELTA_T\n    \/\/ new power\n    watts -= DWATTS * DELTA_T \/\/ fatigue\n    \/\/ new distance\n    d += v * DELTA_T \/ 60.0 \/\/ v in km\/h, deltaT in minutes\n    \/\/ speed too slow, John stops\n    if (v - 3.0 <= 1e-2)\n    {\n      return -1\n    }\n  }\n  return Math.round(t).toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"587f0abdd8730aafd4000035":[{"id":207473,"user_id":null,"body":"import java.security.MessageDigest\nimport javax.xml.bind.DatatypeConverter\n\nfun crackSha256(hash: String, chars: String): String? {\n    val hashBytes = DatatypeConverter.parseHexBinary(hash)\n    val digest = MessageDigest.getInstance(\"SHA-256\")\n    return permutations(chars).firstOrNull { hashBytes.contentEquals(digest.digest(it.toByteArray())) }\n}\n\nprivate fun permutations(s: String): Sequence<String> = sequence {\n    if (s.length <= 1) {\n        yield(s)\n    } else {\n        for (i in 0 until s.length) {\n            yieldAll(permutations(s.removeRange(i, i + 1)).map { s[i] + it })\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207474,"user_id":null,"body":"import java.math.BigInteger\nimport java.security.MessageDigest\n\nfun sha256(input:String): String {\n    val sha = MessageDigest.getInstance(\"SHA-256\")\n    return BigInteger(1, sha.digest(input.toByteArray())).toString(16).padStart(32, '0')\n}\n\nfun crackSha256(hash: String, chars: String): String? {\n    \n    \/\/ This is just brute force. Shuffle the input string and create hash,\n    \/\/ if hash is same like input, return string.\n    \/\/ To have a break condition, null is returned after 1.000.000 tries,\n    \/\/ even knowing that 10 chars give a permutation of ~ 3.6m .\n    \n    var check: String = chars.toMutableList().shuffled().joinToString(\"\")\n    var i: Int = 0\n    \n    while( sha256(check) != hash) {\n        check = chars.toMutableList().shuffled().joinToString(\"\")\n        i += 1\n        if (i > 1000000) {\n            return null\n        }\n    }\n    return check\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207475,"user_id":null,"body":"\nimport java.security.MessageDigest\nimport java.util.Base64\n\nfun crackSha256(hash: String, chars: String): String?{\nvar result:String =\"\"   \n                                       \nfun combinations(h:String, str:String, storedString: String)\n    {\n         \n        if (result !=\"\") \n\n        else if(str.length == 1) if ((MessageDigest.getInstance(\"SHA-256\")).digest((storedString+str).toByteArray()).fold(\"\", { str, it -> str + \"%02x\".format(it) })==h) result=storedString+str\n           \n        for(i in str.indices) combinations(h, str.removeRange(i,i+1),storedString+str[i])\n\n    }\n   \n   \n   combinations(hash, chars,\"\")\n   \n   if (result==\"\") return null \n    \n   else return(result)\n    }\n\n    \n    \n   \n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207476,"user_id":null,"body":"import java.security.MessageDigest\n\nfun crackSha256(hash: String, chars: String): String? {\n    val data = mutableListOf<String>()\n        loadPermutations(data, chars, \"\")\n        data.forEach {\n            if (hash.equals(hashOf(it), ignoreCase = true)) {\n                return it\n            }\n        }\n    return null\n}\n\nfun loadPermutations(\n        data: MutableList<String>,\n        input: String,\n        result: String\n) {\n    if (input.isEmpty()) {\n        data.add(result)\n        return\n    }\n    for (i in input.indices) {\n        val ch = input[i]\n        val ros = input.substring(0, i) + input.substring(i + 1)\n        loadPermutations(data, ros, result + ch)\n    }\n}\n\nfun hashOf(word: String): String {\n    val hexChars = \"0123456789ABCDEF\"\n    val messageDigest = MessageDigest.getInstance(\"SHA-256\")\n    val bytes = messageDigest.digest(word.toByteArray())\n    val hash = StringBuilder(bytes.size * 2)\n    bytes.forEach {\n        val i = it.toInt()\n        hash.append(hexChars[i shr 4 and 0x0f])\n        hash.append(hexChars[i and 0x0f])\n    }\n    return hash.toString()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207477,"user_id":null,"body":"import java.math.BigInteger\nimport java.security.MessageDigest\n\nfun crackSha256(hash: String, chars: String): String? = stringPermutationWithRecursion(chars)\n    .firstOrNull {\n        hash == \"%064x\".format(BigInteger(1, MessageDigest.getInstance(\"SHA-256\").digest(it.toByteArray())))\n    }\n\nfun stringPermutationWithRecursion(string: String): Set<String> {\n    if (string.length == 1)\n        return setOf(string)\n\n    val allCharsExceptLast = string.substringBeforeLast(\"\")\n    val lastChar = string.last()\n    val permutations = stringPermutationWithRecursion(allCharsExceptLast)\n    val allPermutations = mutableSetOf<String>()\n\n    for (permutation in permutations) {\n        val n = allCharsExceptLast.length\n        for (i in 0..n) {\n            val newP = permutation.substring(0, i) + lastChar + permutation.substring(i, n)\n            allPermutations.add(newP)\n        }\n    }\n    return allPermutations\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207478,"user_id":null,"body":"fun crackSha256(hash: String, chars: String): String? {\n    \n    print (\"$hash ?= [$chars] \")\n    \n    val word = chars\n    val len = word.length\n    if (len > 10 || len < 1) return null\n    val md = java.security.MessageDigest.getInstance(\"SHA-256\")\n    \n    val factorials = mutableListOf(1)\n    (1..len).forEach { factorials.add(factorials[it-1] * it) }\n    \n    (0..factorials[len]-1).forEach { i ->\n        var onePermutation = \"\"\n        var temp = word\n        var positionCode = i\n        (len downTo 1).forEach { position ->\n            val selected = positionCode \/ factorials[position-1]\n            onePermutation += temp.get(selected)\n            positionCode = positionCode % factorials[position-1]\n            temp = temp.substring(0,selected) + temp.substring(selected+1)\n        }\n            val hash_candidate = md      \n                        .digest(onePermutation.toByteArray())\n                        .fold(\"\", { str, it -> str + \"%02x\".format(it) })\n            if (hash_candidate == hash) {\n                println (\"FOUND $onePermutation\")\n                return onePermutation\n            }\n        \n    }\n\n    println (\"NOT FOUND\")\n    return null\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207479,"user_id":null,"body":"import java.math.BigInteger\nimport java.security.MessageDigest\n\nfun crackSha256(hash: String, chars: String): String? {\n    val arr = chars.toCharArray()\n    return permutations(arr, arr.size, arr.size, mutableListOf()).firstOrNull { it.sha256() == hash }\n}\n\n\nprivate fun permutations(a: CharArray, size: Int, n: Int, list: MutableList<String>): List<String> {\n    if (size == 1)\n        list.add(a.joinToString(separator = \"\"))\n    for (i in 0 until size) {\n        permutations(a, size - 1, n, list)\n        if (size % 2 == 1)\n            a[0] = a[size - 1].also { a[size - 1] = a[0] }\n        else\n            a[i] = a[size - 1].also { a[size - 1] = a[i] }\n    }\n    return list\n}\n\nval messageDigest: MessageDigest = MessageDigest.getInstance(\"SHA-256\")\nprivate fun String.sha256(): String = BigInteger(1, messageDigest.digest(toByteArray())).toString(16).padStart(64, '0')","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207480,"user_id":null,"body":"import java.security.MessageDigest\n\nfun crackSha256(hash: String, chars: String): String? {\n    \n    var allAcronyms = uniqueAcronyms(chars.chunked(1)).map {\n        it.joinToString(\"\")\n    }\n    \n    (allAcronyms).forEach { acronym ->\n        var charsHash = MessageDigest\n        .getInstance(\"SHA-256\")\n        .digest(acronym.toByteArray())\n        .fold(\"\", {acronym, it -> acronym + \"%02x\".format(it)})\n        if (charsHash.equals(hash)) {\n            return acronym\n        }\n    }\n    \n    return null\n}\n\nfun <T> uniqueAcronyms(acronymList: List<T>): Set<List<T>> {\n    \n    if (acronymList.size == 0) {\n        return setOf(emptyList())\n    }\n    \n    val resultList: MutableSet<List<T>> = mutableSetOf()\n    (0 until acronymList.size).forEach { i ->\n        uniqueAcronyms(acronymList - acronymList[i]).forEach { substring ->\n            resultList.add(substring + acronymList[i])\n        }\n    }\n    \n    return resultList\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207481,"user_id":null,"body":"import java.security.MessageDigest\nimport java.math.BigInteger\n\nfun crackSha256(hash: String, chars: String): String? {\n\n    for (p in permutations(chars)) {\n        val digest =  MessageDigest.getInstance(\"SHA-256\").digest(p.toByteArray())\n        val sha = String.format(\"%064x\", BigInteger(1, digest))\n        if (hash == sha) return p\n    } \n    return null\n}\n\nfun permutations(s: String) : Set<String> {\n    var res = mutableSetOf<String>()\n    \n    fun permute(prefix: String, chars: String) {\n        val length = chars.count()\n        \n        if (length == 0) res.add(prefix)\n        \n        for (i in 0..length - 1) {\n            permute(prefix + chars[i], chars.substring(0, i) + chars.substring(i + 1, length))\n        }    \n    }    \n    permute(\"\", s)    \n    return res    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207482,"user_id":null,"body":"import java.security.MessageDigest\n\nfun crackSha256(hash: String, chars: String) : String? {\n    val permutations = permute(chars, 0, chars.length - 1)\n    permutations.map { if(hashString(it) == hash) { return it } }\n    \n    return null\n} \n\nfun permute(str: String, i: Int, limit: Int): MutableList<String> {                \n    val permutations: MutableList<String> = mutableListOf()\n    \n    if(i == limit) { permutations.add(str); return permutations }\n    else {\n        for(j in i..limit) {        \n            permutations.addAll(permute(swap(str, i, j), i + 1, limit))\n        }\n    }\n    return permutations\n}\n\nfun swap(text: String, firstIndex: Int, secondIndex: Int): String {\n    var textList = text.toMutableList()    \n    \n    val first = textList.get(firstIndex)\n    textList[firstIndex] = textList[secondIndex]\n    textList[secondIndex] = first    \n    \n    return textList.joinToString(separator = \"\")\n}\n\nfun hashString(input: String) =\n       MessageDigest\n                .getInstance(\"SHA-256\")\n                .digest(input.toByteArray())\n                .map { String.format(\"%02x\", it) }\n                .joinToString(separator = \"\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"588417e576933b0ec9000045":[{"id":207483,"user_id":null,"body":"fun seatsInTheater(nCols: Int, nRows: Int, col: Int, row: Int): Int =\n  (nCols - col + 1) * (nRows - row)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207484,"user_id":1267,"body":"fun seatsInTheater(nCols: Int, nRows: Int, col: Int, row: Int) = (nCols - col + 1) * (nRows - row)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207485,"user_id":null,"body":"fun seatsInTheater(nCols: Int, nRows: Int, col: Int, row: Int) = (nCols - (col - 1)) * (nRows - row)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207486,"user_id":null,"body":"fun seatsInTheater(nCols: Int, nRows: Int, col: Int, row: Int) =  if ((nCols in 1..1000 && nRows in 1..1000) && (col in 1..nCols && row in 1..nRows)) ((nCols + 1) - col) * (nRows - row) else 0","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207487,"user_id":null,"body":"fun seatsInTheater(nCols: Int, nRows: Int, col: Int, row: Int): Int {\n  return nCols*nRows - col*nRows + nRows - nCols*row + col*row - row \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207488,"user_id":null,"body":"fun seatsInTheater(nCols: Int, nRows: Int, col: Int, row: Int): Int {\n    val columnsAffected = nCols - col +1\n    val rowsAffected = nRows - row\n    return columnsAffected*rowsAffected\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207489,"user_id":null,"body":"fun seatsInTheater(nCols: Int, nRows: Int, col: Int, row: Int): Int {\n  val col1 = nCols - col +1\n    val row1 = nRows - row\n    return col1*row1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207490,"user_id":null,"body":"fun seatsInTheater(nCols: Int, nRows: Int, col: Int, row: Int): Int {\n  return nCols * nRows - (row * nCols + (col-1)*nRows - (col-1)*row)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207491,"user_id":null,"body":"fun seatsInTheater(nCols: Int, nRows: Int, col: Int, row: Int) = nCols.minus(col.dec()) * nRows.minus(row)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207492,"user_id":null,"body":"fun seatsInTheater(nCols: Int, nRows: Int, col: Int, row: Int): Int {\n    return if(nCols == col && nRows == row) {\n        0\n    } else {\n        nCols * nRows - ((row * nCols) + ((col - 1) * (nRows - row)))\n\/\/             176            55              2               10\n    }\n}\n    ","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"58844a13aa037ff143000072":[{"id":207493,"user_id":1267,"body":"fun willYou(young: Boolean, beautiful: Boolean, loved: Boolean): Boolean = (young && beautiful) != loved","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207494,"user_id":null,"body":"fun willYou(young: Boolean, beautiful: Boolean, loved: Boolean): Boolean {\n    return when {\n        young && beautiful && loved -> false\n        young && !beautiful && loved -> true\n        !young && beautiful && loved -> true\n        young && beautiful && !loved -> true\n        !young && !beautiful && !loved -> false\n        !young && !beautiful && loved -> true\n        else -> false\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207495,"user_id":null,"body":"fun willYou(young: Boolean, beautiful: Boolean, loved: Boolean): Boolean =\n(young && beautiful && !loved) ||(loved && (!young || !beautiful))","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207496,"user_id":1402,"body":"fun willYou(young: Boolean, beautiful: Boolean, loved: Boolean): Boolean {\n  return ((young && beautiful) && !loved) || (loved && (!young || !beautiful))\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207497,"user_id":null,"body":"fun willYou(young: Boolean, beautiful: Boolean, loved: Boolean): Boolean {\n    if(young && beautiful && loved==false) {return true}\n    if((young==false || beautiful==false) && loved) {return true}\n    return false\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207498,"user_id":null,"body":"fun willYou(young: Boolean, beautiful: Boolean, loved: Boolean): Boolean {\n    return when {\n        young && beautiful && loved -> false\n        young && beautiful.not() && loved.not() -> false\n        young.not() && beautiful && loved.not() -> false\n        young.not() && beautiful.not() && loved.not() -> false\n        else -> true\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207499,"user_id":null,"body":"fun willYou(young: Boolean, beautiful: Boolean, loved: Boolean): Boolean {\n    return (young and beautiful) != loved\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207500,"user_id":null,"body":"fun willYou(young: Boolean, beautiful: Boolean, loved: Boolean): Boolean {\n    return (young and beautiful and !loved) or\n            ((!young or !beautiful) and loved)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207501,"user_id":null,"body":"fun willYou(young: Boolean, beautiful: Boolean, loved: Boolean) = if(young){ beautiful != loved } else { loved }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207502,"user_id":null,"body":"    fun willYou(young: Boolean, beautiful: Boolean, loved: Boolean) =\n        ((young && beautiful && loved.not()) || (loved && (young.not() || beautiful.not())))","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"58844f1a76933b1cd0000023":[{"id":207503,"user_id":527,"body":"fun killKthBit(n: Int, k: Int): Int {\n    return n and (1 shl k - 1).inv()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207504,"user_id":null,"body":"fun killKthBit(n: Int, k: Int): Int {\n  \/\/ left shift 1 (0...01) to k-1 positions -> 0....010..0 (k position)\n  \/\/ and invert it to get 11..101.111 (k position)\n  val mask = (1 shl k - 1).inv()\n  \/\/ bitwise and number with mask to set k bit to 0\n  return n and mask\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207505,"user_id":null,"body":"fun killKthBit(n: Int, k: Int) = n.and((1).shl(k-1).inv())","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207506,"user_id":null,"body":"fun killKthBit(n: Int, k: Int) = n.and((1 shl k-1).inv())","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207507,"user_id":null,"body":"fun killKthBit(n: Int, k: Int): Int {\n  if (n == 0) return 0\n  val charArray = n.toString(2).toCharArray()\n  if (k > charArray.size) return n\n  charArray[charArray.size - k] = '0'\n  return String(charArray).toInt(2)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207508,"user_id":null,"body":"\nfun killKthBit(n: Int, k: Int) = if(n.toString(2).length < k) n else\n    (StringBuilder(n.toString(2)).also{ it[it.length - k] = '0'})\n    .toString()\n    .toInt(2)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207509,"user_id":1267,"body":"fun killKthBit(n: Int, k: Int) = n.toString(2).replace(Regex(\"\"\"\\d(\\d{${k-1}})$\"\"\"), \"0$1\").toIntOrNull(2)!!","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207510,"user_id":null,"body":"fun killKthBit(n: Int, k: Int): Int {\n    \n    var decimal = \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" + Integer.toBinaryString(n)\n    decimal = decimal.substring(0, (decimal.length - k)) + \"0\" + decimal.substring(decimal.length - k + 1)\n    return Integer.parseInt(decimal, 2)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207511,"user_id":null,"body":"fun killKthBit(n: Int, k: Int) = if (n.toString(2).length >= k) n.toString(2).reversed().replaceRange(k-1, k,\"0\").reversed().toInt(2) else n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207512,"user_id":null,"body":"fun killKthBit(n: Int, k: Int): Int {\n    val a = Integer.toBinaryString(n)\n \/\/   println(a)\n    if (k > a.length ) return n\n    val b = if ( a[a.length-k] == '1') a.replaceRange(a.length-k..(a.length-k),\"0\") else a\n \/\/   println(b)\n    return Integer.parseInt(b, 2)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5886c6b2f3b6ae33dd0000be":[{"id":207513,"user_id":null,"body":"fun firstReverseTry(arr: IntArray) = if (arr.size < 2) arr\nelse arr.copyOf().apply { this[0] = arr[lastIndex]; this[lastIndex] = arr[0] }\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207514,"user_id":null,"body":"fun firstReverseTry(arr: IntArray) = \n    if(arr.size < 2) arr \n    else arr.copyOf().apply{\n        this[0] = last(); this[lastIndex] = arr[0] \n    }\n    \n\n\/\/ import java.util.*\n\/\/ fun firstReverseTry(arr: IntArray) = \n\/\/     if(arr.size < 2) arr \n\/\/     else arr.toMutableList().also {\n\/\/         Collections.swap(it, 0, arr.lastIndex)\n\/\/     }.toIntArray()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207515,"user_id":null,"body":"fun firstReverseTry(arr: IntArray) : IntArray {\n    if(arr.isNotEmpty()) {\n        val temp = arr[0]\n        arr[0] = arr[arr.size - 1]\n        arr[arr.size - 1] = temp\n    }\n    \n    return arr\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207516,"user_id":null,"body":"fun firstReverseTry(arr: IntArray) = arr.takeLast(1).toIntArray() + arr.drop(1).dropLast(1) + arr.dropLast(1).take(1)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207517,"user_id":null,"body":"fun firstReverseTry(arr: IntArray) : IntArray {\n       return  arr.mapIndexed { i, it ->  if (i == 0 || i == arr.size-1  ) if (i == 0) arr.last() else arr.first() else it }.toIntArray()\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207518,"user_id":null,"body":"fun firstReverseTry(arr: IntArray) = when (arr.size) {\n    0, 1 -> arr\n    else -> arr.copyOf().apply { this[0] = arr[lastIndex]; this[lastIndex] = arr[0] }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207519,"user_id":null,"body":"fun firstReverseTry(arr: IntArray): IntArray = arr.toMutableList().swap().toIntArray()\n\nfun MutableList<Int>.swap(): MutableList<Int> {\n    if (this.isNotEmpty()){\n        val tmp = this[0]\n        this[0] = this[this.lastIndex]\n        this[this.lastIndex] = tmp\n    }\n    return this\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207520,"user_id":null,"body":"fun firstReverseTry(arr: IntArray) : IntArray  = arr.size.takeIf { it > 1 }?.let { (arr.takeLast(1)+arr.drop(1).dropLast(1)+arr.take(1)).toIntArray()}?: arr","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207521,"user_id":null,"body":"fun firstReverseTry(arr: IntArray) : IntArray {\n    if (!arr.isNotEmpty())\n        return intArrayOf()\n    val temp = arr[0].also { arr[0] = arr.last() }\n    arr[arr.lastIndex] = temp\n    return arr\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207522,"user_id":null,"body":"fun firstReverseTry(arr: IntArray) : IntArray {\n  var arrNew = arr\n  if (arr.size > 1) {\n      var start = arr[0]  \n      var end = arr[arr.size-1] \n      arrNew[0] = end\n      arrNew[arr.size-1] = start\n  }\n  return arrNew\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5886e082a836a691340000c3":[{"id":207523,"user_id":645,"body":"import kotlin.math.sqrt\n\nfun rectangle_rotation(a: Int, b: Int): Int {\n    val h = (a \/ sqrt(2.0)).toInt()\n    val v = (b \/ sqrt(2.0)).toInt()\n    return h * v + (h + 1) * (v + 1) - (h % 2 xor v % 2)\n}","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207524,"user_id":null,"body":"import kotlin.math.sqrt\n\nfun rectangle_rotation(a: Int, b: Int): Int {\n    val x = (a \/ sqrt(2.0)).toInt()\n    val y = (b \/ sqrt(2.0)).toInt()\n    \n    return (x + 1) * (y + 1) + x * y - (x + y) % 2\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207525,"user_id":53,"body":"fun rectangle_rotation(a: Int, b: Int): Int {\n    val x = (a.toDouble() \/ Math.sqrt(2.0)).toInt()\n    val y = (b.toDouble() \/ Math.sqrt(2.0)).toInt()\n    val r = (x + 1) * (y + 1) + x * y\n    return r + r % 2 - 1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207526,"user_id":932,"body":"import kotlin.math.sqrt\nfun rectangle_rotation(a: Int, b: Int): Int {\n    val step = sqrt(2f)\n    val na = (a\/step).toInt()\n    val nb = (b\/step).toInt()\n    return na*nb+(na+1)*(nb+1)-(na+nb)%2\n}\n\n\/\/ I Love Math :)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207527,"user_id":null,"body":"fun rectangle_rotation(a: Int, b: Int): Int {\n    var result: Int\n    \n    \/\/ rectancle can be seen as beeing placed on two grids with distance sqrt(2)\n    \/\/ both grids are shifted by sqrt(2)\/2 to each other in x and y direction\n    \n    \/\/ integer points of first grid (with point in (0,0))    \n    result = (2*((a.toDouble()\/2.0\/Math.sqrt(2.0)).toInt()+1)-1) * (2*((b.toDouble()\/2.0\/Math.sqrt(2.0)).toInt()+1)-1)\n    \n    \/\/ integer points of second grid    \n    result = result + (((a\/2.toDouble() - Math.sqrt(2.0)\/2.0)\/Math.sqrt(2.0)).toInt()+1)*2 * (((b\/2.toDouble() - Math.sqrt(2.0)\/2.0)\/Math.sqrt(2.0)).toInt()+1)*2\n    \n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207528,"user_id":null,"body":"import kotlin.math.floor\nimport kotlin.math.sqrt\n\nfun rectangle_rotation(a: Int, b: Int): Int {\n    val x = a \/ (2* sqrt(2.0))\n    val y = b \/ (2* sqrt(2.0))\n    var result = (2 * floor(x).toInt() + 1) * (2 * floor(y).toInt() + 1)\n    if (x - 0.5 >= 0.0 && y - 0.5 >= 0.0) {\n        result += 2 * (floor(x - 0.5).toInt() + 1) * 2 * (floor(y - 0.5).toInt() + 1)\n    }\n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207529,"user_id":null,"body":"fun rectangle_rotation(a: Int, b: Int): Int {\n        val min = Math.min(a, b)\n        val max = Math.max(a, b)\n        val smesch = Math.sqrt(min * min \/ 2.0)\n        val s2 = smesch + Math.sqrt(2.0) * ((max - min) \/ 2.0)\n        var count = 0\n        var co = 0\n        val bound = Math.ceil(s2).toInt()\n    for (x in 1..bound) {\n            val v1 = -x\n            val v2 = x\n            val v3 = x - smesch\n            val v4 = s2 - x\n            for (y in -bound..bound) {\n                if (y > v1 && y < v2 && y > v3 && y < v4)\n                    count++\n                else if ((y == v1 || y == v2) && y > v3 && y < v4)  co++\n            }\n        }\n        return count*4 + 2*co + 1\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207530,"user_id":null,"body":"import kotlin.math.floor\nimport kotlin.math.sqrt\n\nfun rectangle_rotation(a: Int, b: Int): Int {\n    val centerHalfDiagCount = floor(a \/ sqrt(2.0)).toInt()\n    val sideHalfDiagCount = (centerHalfDiagCount + 1) \/ 2\n    val sideDiagCount = sideHalfDiagCount * 2\n    val centerDiagCount = (centerHalfDiagCount \/ 2).let { it * 2 + 1 }\n    val centerHalfAntidiagCount = floor(b \/ sqrt(2.0)).toInt()\n    val centerAntidiagCount = (centerHalfAntidiagCount \/ 2).let { it * 2 + 1 }\n    val numOfDiag = centerHalfAntidiagCount.let { it * 2 + 1 }\n    return centerDiagCount * centerAntidiagCount + (numOfDiag - centerAntidiagCount) * sideDiagCount\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207531,"user_id":null,"body":"import kotlin.math.ceil\nimport kotlin.math.sin\n\nfun rectangle_rotation(a: Int, b: Int): Int {\n  val maxA = ceil((a * sin(45 * Math.PI \/ 180))).toInt()\n  val maxB = ceil((b * sin(45 * Math.PI \/ 180))).toInt()\n  return if ((maxB % 2 - maxA % 2) == 0) {\n    (maxA * maxB) + (maxA.dec() * maxB.dec())\n  } else {\n    (maxA * maxB.dec()) + (maxA.dec() * maxB)\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207532,"user_id":null,"body":"import kotlin.math.floor\nimport kotlin.math.sqrt\n\nval s2 = sqrt(2.0)\n\nfun maxPointsInRow(n: Int): Int = floor(n \/ s2).toInt() + 1\n\nfun rectangle_rotation(a: Int, b: Int): Int {\n    val x = maxPointsInRow(a)\n    val y = maxPointsInRow(b)\n    val oneEven = x % 2 != y % 2\n\n    return if (oneEven)\n        x * (y - 1) + (x - 1) * y\n    else\n        x * y + (x - 1) * (y - 1)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"58881b859ab1e053240000cc":[{"id":207533,"user_id":1703,"body":"   fun electionsWinners(votes: Array<Int>, k: Int): Int {\n       val maks = votes.max()\n        if(k == 0){\n            if(votes.count{it == maks} > 1)return 0\n            else return 1\n        }\n        return votes.count { it + k > maks!! }\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207534,"user_id":null,"body":"fun electionsWinners(votes: Array<Int>, k: Int): Int {\n    return votes.maxOrNull()?.let { max -> votes.count { it + k > max }.let { if (it == 0 && votes.count { it == max } == 1) 1 else it } } ?: 0\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207535,"user_id":null,"body":"fun electionsWinners(votes: Array<Int>, k: Int) = votes.max()!!.run {\n    if (k == 0 && votes.count{ it == this} == 1) 1\n    else votes.count{ it + k > this }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207536,"user_id":null,"body":"fun electionsWinners(votes: Array<Int>, k: Int): Int {\n  val m = votes.max()\n  return if(k > 0) votes.filter{it > m!! - k}.size else (votes.count{it == m} == 1).compareTo(false)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207537,"user_id":null,"body":"fun electionsWinners(votes: Array<Int>, k: Int): Int {\n  val mx = votes.max()\n  var num = votes.filter {e -> e + k > mx!!}.size\n  if(num == 0 && votes.indexOf(mx) == votes.lastIndexOf(mx))  return 1\n  return num\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207538,"user_id":null,"body":"fun electionsWinners(votes: Array<Int>, k: Int): Int {\n    return votes.max()!!.let { max ->\n        if (k == 0 && votes.count { it == max } == 1) return@let 1 \n        votes.count {\n            it + k > max\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207539,"user_id":null,"body":"fun electionsWinners(votes: Array<Int>, k: Int): Int {\n    return when (k) {\n        0 -> findWinnerFrom(votes)\n        else -> findWinnerFrom(votes, k)\n    }\n}\n\nfun findWinnerFrom(votes: Array<Int>, k: Int): Int {\n    val maximumVote = votes.maxOrNull()!!\n\n    return votes\n        .count { vote -> vote + k > maximumVote }\n}\n\nfun findWinnerFrom(votes: Array<Int>): Int {\n    val maximumVote = votes.maxOrNull()!!\n\n    return when (votes.count { vote -> vote == maximumVote }) {\n        1 -> 1\n        else -> 0\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207540,"user_id":null,"body":"fun electionsWinners(votes: Array<Int>, k: Int): Int {\n    return when (k) {\n        0 -> findWinnerFrom(votes)\n        else -> findWinnerFrom(votes, k)\n    }\n}\n\nfun findWinnerFrom(votes: Array<Int>, k: Int): Int {\n    val maximumVote = votes.maxOrNull()!!\n\n    return votes\n        .filter { vote -> vote + k > maximumVote }\n        .size\n}\n\nfun findWinnerFrom(votes: Array<Int>): Int {\n    val maximumVote = votes.maxOrNull()!!\n\n    val winners = votes.filter { vote -> vote == maximumVote }\n    return when (winners.size) {\n        1 -> 1\n        else -> 0\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207541,"user_id":null,"body":"fun electionsWinners(votes: Array<Int>, k: Int): Int {\n    val arrSorted = votes.sortedDescending()\n    val afterVotes = arrSorted.map { it+k }\n    val filteredVotes = afterVotes.filter { it > arrSorted[0] }\n    if(filteredVotes.size == 0) {\n        if (arrSorted[0] != arrSorted[1]){\n            return 1\n        }\n    }\n    return filteredVotes.size\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207542,"user_id":null,"body":"fun electionsWinners(votes: Array<Int>, k: Int): Int {\n    val l = votes.maxOf { it }\n    if (k == 0) {\n        return if (votes.count { it == l } > 1) 0 else 1\n    }\n    return votes.count { it + k > l }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"589273272fab865136000108":[{"id":207543,"user_id":null,"body":"package pianoKataPartOne\n\nfun blackOrWhiteKey(keyPressCount : Int) : String = when ((keyPressCount - 1) % 88 % 12) {\n  1, 4, 6, 9, 11 -> \"black\"\n  else -> \"white\"\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207544,"user_id":null,"body":"package pianoKataPartOne\n\nfun blackOrWhiteKey(n: Int) = arrayOf(\"white\", \"black\")[arrayOf(0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1)[(n - 1) % 88 % 12]]","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207545,"user_id":null,"body":"package pianoKataPartOne\n\nfun blackOrWhiteKey(keyPressCount : Int) : String {\n  println(keyPressCount)\n  var keyPressCount = (keyPressCount - 1) % 88\n  if (keyPressCount == 0 || keyPressCount == 2) {\n      return \"white\"\n  } else if (keyPressCount == 1) {\n      return \"black\"\n  }\n  keyPressCount = (keyPressCount - 3) % 12\n  if (keyPressCount in intArrayOf(0, 2, 4, 5, 7, 9, 11)) {\n      return \"white\"\n  } else {\n      return \"black\"\n  }\n  return \"yeah, about that...\"\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207546,"user_id":null,"body":"package pianoKataPartOne\n\nfun blackOrWhiteKey(keyPressCount : Int) = if(((keyPressCount-1)%88%12) in listOf(0,2,3,5,7,8,10)) \"white\" else \"black\"\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207547,"user_id":null,"body":"package pianoKataPartOne\n\nfun blackOrWhiteKey(keyPressCount : Int) : String {\n  return when((keyPressCount % 88) % 12) {\n    0, 2, 5, 7, 10 -> {\n      if (keyPressCount % 88 == 0) {\n        \"white\"\n      } else {\n        \"black\"\n      }\n    }\n    else -> \"white\"\n  }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207548,"user_id":null,"body":"package pianoKataPartOne\n\nimport java.lang.IllegalArgumentException\n\nfun blackOrWhiteKey(keyPressCount : Int) : String {\n    val keys = mutableListOf(0, 1, 0)\n\n    repeat(7) {\n        keys.addAll(\n            listOf(0,1,0,1,0, 0,1,0,1,0,1,0)\n        )\n    }\n\n    keys.add(0)\n\n    return when (keys[(keyPressCount-1) % keys.size]) {\n        0 -> \"white\"\n        1 -> \"black\"\n        else -> throw IllegalArgumentException()\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207549,"user_id":null,"body":"package pianoKataPartOne\n\n\nfun blackOrWhiteKey(keyPressCount : Int) : String {\n  val key = \"wbww\" + \"bwbwwbwbwbww\".repeat(7)\n  return key[(keyPressCount-1)%88].let{\n      when (it) {\n          'w' -> \"white\"\n          else -> \"black\"\n      }}\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207550,"user_id":null,"body":"package pianoKataPartOne\n\nconst val black = \"black\"\nconst val white = \"white\"\n\nval octave = arrayOf(white, black, white, white, black, white, black, white, white, black, white, black)\n\nfun blackOrWhiteKey(keyPressCount : Int) : String = octave[((keyPressCount  - 1) % 88) % 12]\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207551,"user_id":null,"body":"package pianoKataPartOne\n\nfun blackOrWhiteKey(keyPressCount: Int): String {\n        val result = keyPressCount % 88\n        return if (result % 88 in 4..87) {\n            when ((result-3) % 12) {\n                2, 4, 7, 9, 11  -> \"black\"\n                else -> \"white\"\n            }\n        } else {\n            when (result) {\n                2 -> \"black\"\n                else -> \"white\"\n            }\n        }\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207552,"user_id":null,"body":"package pianoKataPartOne\n\nfun blackOrWhiteKey(keyPressCount: Int): String {\n    val b = mutableListOf(2, 5, 7, 10, 12, 14)\n    while (b.last() <= 76) b.addAll(b.subList(b.lastIndex - 4, b.lastIndex + 1).map { it + 12 })\n    return if (keyPressCount % 88 in b) \"black\" else \"white\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"58941fec8afa3618c9000184":[{"id":207553,"user_id":null,"body":"fun growingPlant(upSpeed: Int, downSpeed: Int, desiredHeight: Int): Int{\n    var height = 0\n    var days = 0    \n    while (true){\n        height += upSpeed\n        days++\n        if (height >= desiredHeight) return days\n        height -= downSpeed\n    }   \n} ","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207554,"user_id":53,"body":"import kotlin.math.ceil\nimport kotlin.math.max\n\nfun growingPlant(u: Int, d: Int, m: Int): Int {\n  return max(1.0, ceil((m - d).toDouble() \/ (u - d).toDouble())).toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207555,"user_id":null,"body":"import kotlin.math.ceil\n\nfun growingPlant(upSpeed: Int, downSpeed: Int, desiredHeight: Int) \n= generateSequence(upSpeed to (upSpeed - downSpeed)){it.second + upSpeed to it.second + upSpeed - downSpeed}\n    .takeWhile{ it.first < desiredHeight }.count() + 1\n\n\/\/\n\/\/10 1 91\n\n\n\/\/10 9 | 19 18 | 28 27 | 37 36 | 46 45 | 55 54 | 65 64 | 74 73 | 83 82 | 92","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207556,"user_id":null,"body":"fun growingPlant(upSpeed: Int, downSpeed: Int, desiredHeight: Int): Int {\n  return if (upSpeed >= desiredHeight) 1 else 1 + growingPlant(upSpeed, downSpeed, desiredHeight - upSpeed + downSpeed)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207557,"user_id":null,"body":"import kotlin.math.ceil\n\nfun growingPlant(upSpeed: Int, downSpeed: Int, desiredHeight: Int): Int {\n  return if (upSpeed >= desiredHeight)\n    1\n  else\n    ceil(1.0 * (desiredHeight - upSpeed) \/ (upSpeed - downSpeed)).toInt() + 1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207558,"user_id":null,"body":"fun growingPlant(upSpeed: Int, downSpeed: Int, desiredHeight: Int) =\n    kotlin.math.ceil(((desiredHeight - downSpeed).toDouble() \/ (upSpeed - downSpeed))).toInt().coerceAtLeast(1)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207559,"user_id":null,"body":"fun growingPlant(upSpeed: Int, downSpeed: Int, desiredHeight: Int): Int {\n  val nightSpeed = upSpeed - downSpeed\n  \n  return if (upSpeed >= desiredHeight) {\n    1\n  } else {\n    Math.ceil((desiredHeight - upSpeed) \/ nightSpeed.toDouble()).toInt() + 1\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207560,"user_id":null,"body":"fun growingPlant(upSpeed: Int, downSpeed: Int, desiredHeight: Int): Int {\n    return when {\n        upSpeed >= desiredHeight -> 1\n        else -> 1 + growingPlant(upSpeed, downSpeed, desiredHeight - (upSpeed - downSpeed))\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207561,"user_id":null,"body":"fun growingPlant(upSpeed: Int, downSpeed: Int, desiredHeight: Int): Int {\n    val growFactor = upSpeed - downSpeed\n    return if (desiredHeight < upSpeed) 1 else Math.ceil((desiredHeight - downSpeed).toDouble() \/ growFactor).toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207562,"user_id":null,"body":"fun growingPlant(upSpeed: Int, downSpeed: Int, desiredHeight: Int): Int {\n  var day: Int = 1\n  var height: Int = 0  \n  while (true) {\n      height += upSpeed\n      if (height >= desiredHeight) return day\n      height -= downSpeed\n      day += 1\n  }  \n    return 0\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"589631d24a7323d18d00016f":[{"id":207563,"user_id":null,"body":"package pianoKataPartTwo\n\nval note = listOf(\"A\", \"A#\", \"B\", \"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\",\"G#\")\n\nfun whichNote(keyPressCount : Int) : String {\n  return note.get(((keyPressCount -1) % 88) % note.size)\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207564,"user_id":null,"body":"package pianoKataPartTwo\n\nfun whichNote(keyPressCount : Int) : String {\n    \n    if (keyPressCount < 1) return \"\"\n    val notes = arrayOf( \"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\")\n    val key = (keyPressCount-1)%88\n    val note = if (key <= 2) key+9 else (key-3)%12\n    \n    return notes[note]\n    \n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207565,"user_id":null,"body":"package pianoKataPartTwo\n\nfun whichNote(keyPressCount : Int) : String =\n    listOf(\"A\", \"A#\", \"B\", \"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\").get(((keyPressCount - 1) % 88) % 12 )\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207566,"user_id":null,"body":"package pianoKataPartTwo\n\nfun whichNote(n: Int) = arrayOf(\"A\", \"A#\", \"B\", \"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\")[(n - 1) % 88 % 12]\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207567,"user_id":null,"body":"package pianoKataPartTwo\n\nval Notes = arrayOf(\"A\",\"A#\",\"B\",\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\")\nfun whichNote(keyPressCount : Int) : String = Notes[((keyPressCount - 1) % 88 % 12)]","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207568,"user_id":null,"body":"package pianoKataPartTwo\n\n\/\/reusable func from part1\nfun keyIndex(keyPressCount: Int) = ((keyPressCount - 1) % 88) % 12\n\nfun whichNote(keyPressCount: Int) =\n    \"A,A#,B,C,C#,D,D#,E,F,F#,G,G#\".split(\",\")[keyIndex(keyPressCount)]","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207569,"user_id":null,"body":"package pianoKataPartTwo\n\nfun whichNote(keyPressCount: Int): String = \"A A# B C C# D D# E F F# G G#\".split(' ')[(keyPressCount - 1) % 88 % 12]","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207570,"user_id":null,"body":"package pianoKataPartTwo\n\nfun whichNote(keyPressCount: Int): String =\n    arrayOf(\"A\", \"A#\", \"B\", \"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\")[(keyPressCount - 1) % 88 % 12]","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207571,"user_id":null,"body":"package pianoKataPartTwo\n\nval letters = listOf(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\")\n\nfun whichNote(keyPressCount : Int) : String {\n    val piano = mutableListOf(\"A\", \"A#\", \"B\")\n\n    repeat(7) {\n        fillPiano(piano, 2)\n        fillPiano(piano, 3)\n    }\n\n    fillPiano(piano, 0)\n\n    return piano[(keyPressCount - 1) % 88]\n}\n\nfun fillPiano(piano: MutableList<String>, blackAmount: Int) {\n    repeat(blackAmount) {\n        val idx = (letters.indexOf(piano.last()[0].toString()) + 1) % letters.size\n        piano.add(letters[idx])\n        piano.add(letters[idx] + \"#\")\n    }\n\n    val idx = (letters.indexOf(piano.last()[0].toString()) + 1) % letters.size\n    piano.add(letters[idx])\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207572,"user_id":null,"body":"package pianoKataPartTwo\n\nfun whichNote(keyPressCount : Int) = listOf(\"A\", \"A#\", \"B\", \"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\")[(keyPressCount - 1) % 88 % 12]","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5899dc03bc95b1bf1b0000ad":[{"id":207573,"user_id":null,"body":"fun invert(arr: IntArray) = arr.map { -it }.toIntArray()","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207574,"user_id":527,"body":"fun invert(arr: IntArray): IntArray {\n    return IntArray(arr.size){ -arr[it] }\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207575,"user_id":null,"body":"fun invert(arr: IntArray): IntArray {\n  \/\/ code here\n  return arr.map {it * -1}.toIntArray()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207576,"user_id":null,"body":"fun invert(arr: IntArray): IntArray {\n    var x = 0\n    while (x < arr.size) {\n        arr[x] = arr[x] * -1\n        x++\n    }\n    return arr\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207577,"user_id":null,"body":"fun invert(arr: IntArray) = IntArray(arr.size){arr[it] * -1}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207578,"user_id":null,"body":"fun invert(arr: IntArray): IntArray {\n  \/\/ code here\n    val inverse:IntArray = IntArray(arr.size)\n    \/\/\/ TUrn a negative to positve (-5)\n    \/\/ we mulitply that negative value by -2 and add that result to the neg number\n   var count:Int = 0\n    \/\/Turn a positive to negative \n    \/\/ we mulitiply by negative 2 and substract that result from the number \n    for (value in arr){\n        inverse[count] = getInverse(value)\n        count++\n    }\n    \n    return inverse\n}\n\nfun getInverse(value:Int):Int{\n    \n    if (value==1){\n        return -1\n    } else if (value==-1){\n        return 1\n    }\n    \n    if (value<0){\n        return  value +  (value * -2) \n    } else{\n        return  value - (value * 2)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207579,"user_id":null,"body":"val invert: (IntArray) -> IntArray = { it.map{-it}.toIntArray() }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207580,"user_id":null,"body":"fun invert(arr: IntArray): IntArray {\n  for (i in arr.indices) {arr[i]*=-1}\n  return arr\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207581,"user_id":null,"body":"fun invert(arr: IntArray) = arr.map { it * -1 }.toIntArray()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207582,"user_id":null,"body":"fun invert(arr: IntArray): IntArray = arr.map { x -> -x }.toIntArray()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"58a57c6bcebc069d7e0001fe":[{"id":207583,"user_id":null,"body":"import java.nio.charset.StandardCharsets\n\n\nobject Base91 {    \n    \n     val BASE91_CHARS = listOf(\n         'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n         'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n         'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n         'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n         '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '!', '#', '$',\n         '%', '&', '(', ')', '*', '+', ',', '.', '\/', ':', ';', '<', '=',\n         '>', '?', '@', '[', ']', '^', '_', '`', '{', '|', '}', '~', '\"')\n   \n\t\n    fun encode(data: String): String {\n        println(\"encoding $data\")\n        val bytes = data.toByteArray(StandardCharsets.US_ASCII)\n\n        var buffer = 0\n        var bitShift = 0\n        val result = StringBuilder()\n\n        for(b in bytes) {\n            buffer = buffer or (b.toInt() shl bitShift)\n            bitShift += 8\n\n            if(bitShift > 13) {\n                var idx = buffer and 8191\n\n                if(idx > 88) {\n                    buffer = buffer shr 13\n                    bitShift -= 13\n                } else {\n                    idx = buffer and 16383\n                    buffer = buffer shr 14\n                    bitShift -= 14\n                }\n\n                result.append(BASE91_CHARS[idx % 91])\n                result.append(BASE91_CHARS[idx \/ 91])\n            }\n        }\n\n         if(bitShift > 0) {\n             result.append(BASE91_CHARS[buffer % 91])\n\n             if(buffer > 90) {\n                 result.append(BASE91_CHARS[buffer \/ 91])\n             }\n         }\n\n        return result.toString()\n\t}\n    \n    fun decode(data: String): String {\n\n        var buffer = 0\n        var bitShift = 0\n        var bytes = -1\n\n        val result = mutableListOf<Byte>()\n\n        for(letter in data) {\n            val idx = BASE91_CHARS.indexOf(letter)\n\n            if(bytes < 0 ){\n                bytes = idx\n            } else {\n                bytes += idx * 91\n                buffer = (buffer or (bytes shl bitShift))\n\n                bitShift += if((bytes and 8191) > 88) {\n                    13\n                } else {\n                    14\n                }\n\n                do {\n                    result.add((buffer and 255).toByte())\n                    buffer = buffer shr 8\n                    bitShift -= 8\n                } while (bitShift >= 8)\n\n                bytes = -1\n            }\n\n        }\n\n        if(bytes + 1 > 0) {\n            buffer = buffer or (bytes shl bitShift)\n            result.add((buffer and 255).toByte())\n        }\n\n        return String(result.toByteArray(), StandardCharsets.US_ASCII)\n    }\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207584,"user_id":null,"body":"object Base91 {\n\n    val alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+,.\/:;<=>?@[]^_`{|}~\\\"\"\n    \n    fun encode(input: String): String {\n        \n        var output = \"\"\n        \n        if (input != \"\") {\n            val lengthString = input.length\n            var byte = 0\n            var shift = 0\n            \n            for (i in 0 .. lengthString-1) {\n                val ordinateChar = input[i].toInt()\n                byte = byte or (ordinateChar shl shift);\n\n                shift = shift + 8\n                \n                if (shift > 13) {\n                    var value = byte and 8191\n                    \n                    if (value > 88) {\n                        byte = byte shr 13\n                        shift = shift - 13\n                    } else {\n                        value = byte and 16383\n                        byte = byte shr 14\n                        shift = shift - 14\n                    }\n                    \n                    output += alphabet[value % 91]\n                    output += alphabet[(value \/ 91).toInt()]\n                }\n            }\n            \n            if (shift > 0) {\n                output += alphabet[byte % 91]\n                if (shift > 7 || byte > 90) {\n                    val index = (byte \/ 91).toInt()\n                    output += alphabet[index]\n                }\n            }\n        }\n        \n        return output\n    }\n\n\tfun decode(input: String): String {\n\t\tvar output = \"\"\n        \n        val alphabetIndexed = mutableMapOf<Char, Int>()\n        alphabet.forEachIndexed { index, it ->\n            alphabetIndexed[it] = index\n        }\n        \n        \n        \n        if (input != \"\") {\n            val lengthString = input.length\n            var byte = 0\n            var shift = 0\n            var value = -1\n            \n            for (i in 0 .. lengthString-1) {\n                var newValue = alphabetIndexed[input[i]]\n                \n                if (value < 0) {\n                    value = newValue!!\n                } else {\n                    value = value + (newValue!! * 91)\n                    byte = byte or (value shl shift)\n                    \n                    if (value and 8191 > 88) {\n                        shift = shift + 13\n                    } else {\n                        shift = shift + 14\n                    }\n                    \n                    do {\n                        output = output + ((byte and 255).toChar())\n                        byte = byte shr 8\n                        shift = shift - 8\n                    } while (shift > 7);\n                    value = -1\n                }\n            }\n            if (value + 1 > 0) {\n                val a = byte or (value shl shift)\n                \n                \n                output = output + ((a and 255).toChar())\n            }\n        }\n        \n        return output\n\t}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207585,"user_id":null,"body":"object Base91 {\n\n    class basE91 {\n        private var ebq = 0\n        private var en = 0\n        private var dbq = 0\n        private var dn = 0\n        private var dv = 0\n        val enctab: ByteArray\n        private val dectab: ByteArray\n        fun encode(ib: ByteArray, n: Int, ob: MutableList<Byte>): Int {\n            var i: Int\n            var c = 0\n            i = 0\n            while (i < n) {\n                ebq = ebq or (ib[i].toInt() and 255 shl en)\n                en += 8\n                if (en > 13) {\n                    var ev = ebq and 8191\n                    if (ev > 88) {\n                        ebq = ebq shr 13\n                        en -= 13\n                    } else {\n                        ev = ebq and 16383\n                        ebq = ebq shr 14\n                        en -= 14\n                    }\n                    ob.add(enctab[ev % 91])\n                    ob.add(enctab[ev \/ 91])\n                }\n                ++i\n            }\n            encEnd(ob)\n            return c\n        }\n\n        fun encEnd(ob: MutableList<Byte>): Int {\n            var c = 0\n            if (en > 0) {\n                ob.add(enctab[ebq % 91])\n                if (en > 7 || ebq > 90) ob.add(enctab[ebq \/ 91])\n            }\n            encReset()\n            return c\n        }\n\n        fun encReset() {\n            ebq = 0\n            en = 0\n        }\n\n        fun decode(ib: ByteArray, n: Int, ob: MutableList<Byte>): Int {\n            var i: Int\n            var c = 0\n            i = 0\n            while (i < n) {\n                if (dectab[ib[i].toInt()] == (-1).toByte()) {\n                    ++i\n                    continue\n                }\n                if (dv == -1) dv = dectab[ib[i].toInt()].toInt() else {\n                    dv += dectab[ib[i].toInt()] * 91\n                    dbq = dbq or (dv shl dn)\n                    dn += if (dv and 8191 > 88) 13 else 14\n                    do {\n                        ob.add(dbq.toByte())\n                        dbq = dbq shr 8\n                        dn -= 8\n                    } while (dn > 7)\n                    dv = -1\n                }\n                ++i\n            }\n            decEnd(ob)\n            return c\n        }\n\n        fun decEnd(ob: MutableList<Byte>): Int {\n            var c = 0\n            if (dv != -1) ob.add((dbq or (dv shl dn)).toByte())\n            decReset()\n            return c\n        }\n\n        fun decReset() {\n            dbq = 0\n            dn = 0\n            dv = -1\n        }\n\n        init {\n            var i: Int\n            val ts = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+,.\/:;<=>?@[]^_`{|}~\\\"\"\n            enctab = ts.toByteArray()\n            dectab = ByteArray(256)\n            i = 0\n            while (i < 256) {\n                dectab[i] = -1\n                ++i\n            }\n            i = 0\n            while (i < 91) {\n                dectab[enctab[i].toInt()] = i.toByte()\n                ++i\n            }\n            encReset()\n            decReset()\n        }\n    }\n\n    \/\/https:\/\/www.codewars.com\/kata\/58a57c6bcebc069d7e0001fe\/train\/kotlin\n    fun encode(data: String): String {\n        val data = data.toByteArray()\n        val o = mutableListOf<Byte>()\n        basE91().encode(data, data.size, o)\n        return o.joinToString(\"\") { it.toChar().toString() }\n    }\n\n    fun decode(data: String): String {\n        val data = data.toByteArray()\n        val o = mutableListOf<Byte>()\n        basE91().decode(data, data.size, o)\n        return o.joinToString(\"\") { it.toChar().toString() }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207586,"user_id":null,"body":"const val ALPHABET = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+,.\/:;<=>?@[]^_`{|}~\\\"\"\n\nfun Collection<Int>.toInt() = reversed().joinToString(\"\") { it.toString() }.toInt(2)\n\nobject Base91 {\n\n    fun encode(data: String): String = sequence {\n        var bits = data\n                .toByteArray()\n                .map { it.toString(2).padStart(8, '0').reversed() }\n                .flatMap { it.map { if (it == '1') 1 else 0 } }\n\n        while (bits.isNotEmpty()) {\n            val end = minOf(12, bits.size - 1)\n            val size =\n                    if (bits.slice(0..end).toInt() > 88) end\n                    else minOf(13, bits.size - 1)\n\n            bits.slice(0..size).toInt().let {\n                yield(ALPHABET[it % 91])\n                if (bits.size > 7 || it > 90)\n                    yield(ALPHABET[it \/ 91])\n            }\n            bits = bits.drop(size + 1)\n        }\n    }.joinToString(\"\") { it.toString() }\n\n    fun decode(data: String): String = sequence {\n        var v = -1\n        var b = 0\n        var n = 0\n        for (c in data.map { ALPHABET.indexOf(it) }) {\n            v = if (v < 0) c else {\n                v += c * 91\n                b = b or (v shl n)\n                n += if ((v and 8191) > 88) 13 else 14\n                while (true) {\n                    yield(b and 255)\n                    b = b shr 8\n                    n -= 8\n\n                    if (n < 8)\n                        break\n                }\n                -1\n            }\n        }\n        if (v != -1)\n            yield((b or (v shl n)) and 255)\n    }.joinToString(\"\") { it.toChar().toString() }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207587,"user_id":null,"body":"const val ALPHABET = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+,.\/:;<=>?@[]^_`{|}~\\\"\"\n\nobject Base91 {\n\n    fun encode(data: String): String = sequence {\n        var b = 0\n        var n = 0\n        var v = 0\n\n        for (byte in data.toByteArray()) {\n            b = b or (byte.toInt() shl n)\n            n += 8\n\n            if (n > 13) {\n                v = b and 8191\n                if (v > 88) {\n                    b = b shr 13\n                    n -= 13\n                } else {\n                    v = b and 16383\n                    b = b shr 14\n                    n -= 14\n                }\n\n                yield(ALPHABET[v % 91])\n                yield(ALPHABET[v \/ 91])\n            }\n        }\n\n        if (n > 0) {\n            yield(ALPHABET[b % 91])\n\n            if (n > 7 || b > 90)\n                yield(ALPHABET[b \/ 91])\n        }\n    }.joinToString(\"\") { it.toString() }\n\n    fun decode(data: String): String = sequence {\n        var v = -1\n        var b = 0\n        var n = 0\n        for (s in data) {\n            val c = ALPHABET.indexOf(s)\n            if (v < 0) {\n                v = c\n            } else {\n                v += c * 91\n                b = b or (v shl n)\n                n += if ((v and 8191) > 88) 13 else 14\n                while (true) {\n                    yield(b and 255)\n                    b = b shr 8\n                    n -= 8\n\n                    if (n < 8)\n                        break\n                }\n                v = -1\n            }\n        }\n        if (v != -1)\n            yield((b or (v shl n)) and 255)\n    }.joinToString(\"\") { it.toChar().toString() }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207588,"user_id":null,"body":"const val ENCODING_TABLE =\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#\\$%&()*+,.\/:;<=>?@[]^_`{|}~\\\"\"\nval DECODING_TABLE = buildDecodingTable()\n\nfun buildDecodingTable(): ByteArray {\n    val table = ByteArray(256) { -1 }\n    (0 until 91).forEach {\n        table[ENCODING_TABLE[it].toInt()] = it.toByte()\n    }\n    return table\n}\n\nobject Base91 {\n\n    fun encode(data: String): String {\n        var ebq = 0\n        var en = 0\n\n        return buildString {\n            data.forEach {\n                ebq = ebq or ((it.toInt() and 255) shl en)\n                en += 8\n                if (en > 13) {\n                    var ev = ebq and 8191\n                    if (ev > 88) {\n                        ebq = ebq shr 13\n                        en -= 13\n                    } else {\n                        ev = ebq and 16383\n                        ebq = ebq shr 14\n                        en -= 14\n                    }\n                    append(\"${ENCODING_TABLE[ev % 91]}${ENCODING_TABLE[ev \/ 91]}\")\n                }\n            }\n            if (en > 0) {\n                append(\"${ENCODING_TABLE[ebq % 91]}\")\n                if (en > 7 || ebq > 90) {\n                    append(\"${ENCODING_TABLE[ebq \/ 91]}\")\n                }\n            }\n        }\n    }\n\n    fun decode(data: String): String {\n        var dbq = 0\n        var dn = 0\n        var dv = -1\n\n        return buildString {\n            data.forEach {\n\n                if (dv == -1) {\n                    dv = DECODING_TABLE[it.toInt()].toInt()\n                } else {\n                    dv += DECODING_TABLE[it.toInt()].toInt() * 91\n                    dbq = dbq or (dv shl dn)\n                    dn += when  {\n                        (dv and 8191) > 88 -> 13\n                        else -> 14\n                    }\n                    do {\n                        append(dbq.toByte().toChar())\n                        dbq = dbq shr 8\n                        dn -= 8\n                    } while (dn > 7)\n                    dv = -1\n                }\n            }\n            if (dv != -1) {\n                append((dbq or (dv shl dn)).toByte().toChar())\n            }\n        }\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207589,"user_id":null,"body":"import kotlin.math.pow\n\nobject Base91 {\n\n    var code: String = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+,.\/:;<=>?@[]^_`{|}~\\\"\"\n    fun encode(data: String): String {\n        val resultBuf = StringBuffer()\n        var ind = 0\n        var bits = 0\n        var bitsN = 0\n\n        while (true) {\n            if (bitsN < 0 && ind == data.length) break\n\n            while (bitsN < 14 && ind < data.length) {\n                bits += data[ind].toByte() * 2.0.pow(bitsN.toDouble()).toInt()\n                bitsN += 8\n                ind++\n            }\n\n            val workBit = bits % 8192\n            bits \/= 8192\n            bitsN -= 13\n\n            resultBuf.append(code[workBit % 91])\n            if ((bitsN + 13) >= 8) resultBuf.append(code[workBit \/ 91])\n        }\n        return resultBuf.toString()\n    }\n\n    fun decode(data: String): String {\n        val resultBuf = StringBuffer()\n        var ind = 0\n        var bits = 0\n        var bitsN = 0\n\n        while (true) {\n            if (bitsN < 8 && ind >= data.length) break\n\n            while (bitsN < 16 && ind < data.length) {\n                val fByte = code.indexOf(data[ind])\n                val nByte = if (ind == data.length - 1) 0 else code.indexOf(data[ind + 1])\n                val bit13 = fByte + nByte * 91\n\n\n                bits += bit13 * 2.0.pow(bitsN.toDouble()).toInt()\n                bitsN += 13 - if (ind == data.length - 1) 6 else 0\n                ind += 2\n            }\n\n            if (bitsN >= 8) {\n                val workBit: Byte = (bits % 256).toByte()\n                bits \/= 256\n                bitsN -= 8\n\n                println(\"$bitsN ${workBit.toChar()}\")\n                resultBuf.append(workBit.toChar())\n            }\n        }\n        return resultBuf.toString()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207590,"user_id":null,"body":"object Base91 {\n    \n    val base = \"\"\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+,.\/:;<=>?@[]^_`{|}~\"\"\"\"\n    \n\tfun encode(dt: String): String {\n        var bits = dt.reversed().map{ it.toInt().toString(2).padStart(8, '0') }.joinToString(\"\")\n        var res = \"\"\n        \n        while (bits.length > 12) {\n            var part = bits.takeLast(13)\n            bits = bits.dropLast(13)\n            \n            var i = part.toString().toInt(radix = 2)\n            \n            \n            if (i <= 88 && !bits.isEmpty()) {\n                part = bits.last() + part\n                bits = bits.dropLast(1)\n                i = part.toString().toInt(radix = 2)\n            }\n            \n            res += \"${base[i % 91]}${base[i \/ 91]}\"\n            \n        }\n        if (bits.isEmpty()) return res\n        \n        var t = bits.toInt(radix = 2)\n        \n        res += if (t > 90) \"${base[t % 91]}${base[t \/ 91]}\" else \"${base[t]}\"\n        \n        return res\n\t}\n\tfun decode(dt: String): String {\n        \n        var binary = \"\"\n        \n        for (sub in dt.chunked(2)) {\n            \n            var n = 0\n            if (sub.length == 1) {\n                n += base.indexOf(sub)\n                binary = n.toString(2) + binary\n            } else {\n                n += base.indexOf(sub[0]) + base.indexOf(sub[1]) * 91\n                binary = n.toString(2).padStart(if ((n and 8191) > 88) 13 else 14, '0') + binary \n            }\n\n        }\n        var res = \"\"\n        \n        \n        while (binary.length > 7) {\n            var bits = binary.takeLast(8)\n            binary = binary.dropLast(8)\n            res += bits.toInt(radix = 2).toChar()\n        }\n        if (binary.isEmpty()) return res\n        \n        var t = binary.padStart(8, '0').toInt(radix = 2)\n        if (t != 0) res += t.toChar()\n        return res\n\t}\n}\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207591,"user_id":null,"body":"import java.io.ByteArrayOutputStream\nimport kotlin.math.ceil\n\nobject Base91 {\n\n    private val ENCODING_TABLE: ByteArray\n    private val DECODING_TABLE: ByteArray = ByteArray(256).apply { fill(-1) }\n\n    init {\n        val sym = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#\\$%&()*+,.\/:;<=>?@[]^_`{|}~\\\"\"\n        ENCODING_TABLE = sym.toByteArray()\n        for (i in ENCODING_TABLE.indices) DECODING_TABLE[ENCODING_TABLE[i].toInt()] = i.toByte()\n    }\n\n    fun encode(data: String): String {\n        val bytes = data.toByteArray()\n        val estimatedSize = ceil((bytes.size).toDouble()).toInt()\n        val output = ByteArrayOutputStream(estimatedSize)\n\n        var ebq = 0\n        var en = 0\n        for (i in bytes.indices) {\n            ebq = ebq or (bytes[i].toInt() and 255 shl en)\n            en += 8\n            if (en > 13) {\n                var ev = ebq and 8191\n\n                if (ev > 88) {\n                    ebq = ebq shr 13\n                    en -= 13\n                } else {\n                    ev = ebq and 16383\n                    ebq = ebq shr 14\n                    en -= 14\n                }\n                output.write(ENCODING_TABLE[ev % ENCODING_TABLE.size].toInt())\n                output.write(ENCODING_TABLE[ev \/ ENCODING_TABLE.size].toInt())\n            }\n        }\n\n        if (en > 0) {\n            output.write(ENCODING_TABLE[ebq % ENCODING_TABLE.size].toInt())\n            if (en > 7 || ebq > 90) output.write(ENCODING_TABLE[ebq \/ ENCODING_TABLE.size].toInt())\n        }\n\n        return output.toString()\n    }\n\n    fun decode(data: String): String {\n        val bytes = data.toByteArray()\n\n        var dbq = 0\n        var dn = 0\n        var dv = -1\n\n        val output = ByteArrayOutputStream(bytes.size)\n\n        for (i in bytes.indices) {\n            if (DECODING_TABLE[bytes[i].toInt()].toInt() == -1) continue\n            if (dv == -1) dv = DECODING_TABLE[bytes[i].toInt()].toInt()\n            else {\n                dv += DECODING_TABLE[bytes[i].toInt()] * ENCODING_TABLE.size\n                dbq = dbq or (dv shl dn)\n                dn += if (dv and 8191 > 88) 13 else 14\n                do {\n                    output.write(dbq.toByte().toInt())\n                    dbq = dbq shr 8\n                    dn -= 8\n                } while (dn > 7)\n                dv = -1\n            }\n        }\n\n        if (dv != -1) output.write((dbq or (dv shl dn)).toByte().toInt())\n        return output.toString()\n    }\n\t\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207592,"user_id":null,"body":"object Base91 {\n    private val charset = Charsets.US_ASCII  \/\/.UTF_8\n    private const val mask13 = 0b1_1111_1111_1111L\n    private const val mask14 = 0b11_1111_1111_1111L\n    private const val mask8 = 0xFFL\n\n    private val base91 = CharArray(91).apply {\n        for (i in 0..25) { this[i] = (i + 'A'.toInt()).toChar() }\n        for (i in 26..51) { this[i] = (i - 26 + 'a'.toInt()).toChar() }\n        for (i in 52..61) { this[i] = (i - 52 + '0'.toInt()).toChar() }\n        \"!#${'$'}%&()*+,.\/:;<=>?@[]^_`{|}~\\\"\".forEachIndexed { index, indexedValue ->\n            this[index + 62] = indexedValue\n        }\n    }\n\n    private val decode91 = mutableMapOf<Char, Int>().apply {\n        for (i in base91.indices) { this[base91[i]] = i }}.toMap()\n\n\n    fun encode(str: String): String {\n        val byteArray = str.toByteArray(charset)\n        return encodeBytes(byteArray)\n    }\n\n    fun decode(str: String): String {\n        val byteArray = decodeToBytes(str)\n        return byteArray.toString(charset)\n    }\n\n    fun encodeBytes(data: ByteArray): String {\n        val iter = data.iterator()\n        var buffer = 0L\n        var count = 0\n\n        fun prepare(): Boolean {\n            while (iter.hasNext() && count < 14) {\n                val b = iter.nextByte()\n                buffer = buffer or (b.toLong() and mask8 shl count)\n                count += 8\n            }\n            return iter.hasNext()\n        }\n\n        fun nextIdxs(): List<Int> {\n            prepare()\n            var value: Long? = null\n            val countBefore = count\n            if (count > 0) {\n                when {\n                    count < 14 -> {\n                        value = buffer\n                        buffer = 0L\n                        count = 0\n                    }\n                    buffer and mask13 <= 88L -> {\n                        value = buffer and mask14\n                        buffer = buffer shr 14\n                        count -= 14\n                    }\n                    else -> {\n                        value = buffer and mask13\n                        buffer = buffer shr 13\n                        count -= 13\n                    }\n                }\n            }\n            if (value == null) {\n                return listOf()\n            }\n            val v = value.toInt()\n            val i0 = v % 91\n            val i1 = v \/ 91\n            return if (countBefore < 8) {\n                listOf(i0)\n            } else {\n                listOf(i0, i1)\n            }\n        }\n\n        return mutableListOf<Char>().apply {\n            var cs = nextIdxs().map { base91[it] }\n            while (cs.isNotEmpty()) {\n                addAll(cs)\n                cs = nextIdxs().map { base91[it] }\n            }\n        }.joinToString(\"\")\n    }\n\n    fun decodeToBytes(str: String): ByteArray {\n        val iter = str.iterator()\n        val bytes = mutableListOf<Byte>()\n        var buffer = 0L\n        var count = 0\n        while (iter.hasNext()) {\n            val c0 = iter.nextChar()\n            val chars = if (iter.hasNext()) {\n                listOf(c0, iter.nextChar())\n            } else {\n                listOf(c0)\n            }\n            val ii = chars.map { decode91.getValue(it) }\n            val value: Long = if (ii.size == 2) {\n                (ii[0] + ii[1] * 91).toLong()\n            } else {\n                ii[0].toLong()\n            }\n            val width = when {\n                ii.size == 1 -> 8\n                (value and mask13) <= 88L -> 14\n                else -> 13\n            }\n            buffer = buffer or (value shl count)\n            count += width\n\n            while (count >= 8) {\n                bytes.add(buffer.toByte())\n                buffer = buffer ushr 8\n                count -= 8\n            }\n            if (!iter.hasNext() && count > 0 && buffer != 0L) {\n                bytes.add(buffer.toByte())\n                break\n            }\n        }\n\n        return ByteArray(bytes.size) { bytes[it] }\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"58acfe4ae0201e1708000075":[{"id":207593,"user_id":527,"body":"fun inviteMoreWomen(l: List<Int>) = l.sum() > 0","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207594,"user_id":null,"body":"fun inviteMoreWomen(l: List<Int>) = l.groupingBy { it }.eachCount().let { it.getOrDefault(1, 0) > it.getOrDefault(-1, 0) }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207595,"user_id":null,"body":"fun inviteMoreWomen(l: List<Int>): Boolean = if (l.sum() <= 0 ) false else true\n      \n\n\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207596,"user_id":null,"body":"fun inviteMoreWomen(l: List<Int>) = l.size\/2 < l.filter() {it > 0}.count()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207597,"user_id":null,"body":"fun inviteMoreWomen(l: List<Int>): Boolean {\n    \/\/ your code here\n    val men = l.count {it == 1}\n    val women = l.count {it == -1}\n    return if (women >= men) false else true\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207598,"user_id":null,"body":"fun inviteMoreWomen(l: List<Int>): Boolean {\n    var manNumber=0\n    var womenNumber=0\n    for(i in l)\n    {\n        if(i==-1)\n            womenNumber++\n        else\n            manNumber++\n    }\n    return manNumber > womenNumber\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207599,"user_id":null,"body":"fun inviteMoreWomen(l: List<Int>): Boolean {\n    var x = 0\n    for(i in l){\n        x+=i\n    }\n    var answer = true\n    if(x<=0){\n        answer =false\n    }\n    return answer\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207600,"user_id":null,"body":"fun inviteMoreWomen(l: List<Int>): Boolean {\n    var girlsCounter = 0\n    var boysCounter = 0\n    l.forEach { man ->\n        if (man == -1) {\n            girlsCounter++\n        } else if (man == 1) {\n            boysCounter++\n        }\n    }\n return girlsCounter < boysCounter\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207601,"user_id":null,"body":"fun inviteMoreWomen(l: List<Int>): Boolean = 0 < l.sum()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207602,"user_id":null,"body":"fun inviteMoreWomen(l: List<Int>): Boolean {\n    var sumOfWomen = 0\n    l.forEach{\n        sumOfWomen += it\n    }\n    return sumOfWomen > 0\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"58b38f24c723bf6b660000d8":[{"id":207603,"user_id":null,"body":"fun toBase26(num: Int): String {\n    if (num <= 26) return ('A'.toInt() + num - 1).toChar().toString()\n    return toBase26((num - 1) \/ 26) + toBase26((num - 1) % 26 + 1)\n}\n\nfun fromBase26(s: String): Int {\n    if (s.isEmpty()) return 0\n    if (s.length == 1) return s[0] - 'A' + 1\n    return fromBase26(s.substring(0, s.length - 1)) * 26 + fromBase26(s[s.length-1].toString())\n}\n\nfun spreadsheet(s: String): String {\n    val rc = Regex(\"\"\"R(\\d+)C(\\d+)\"\"\").matchEntire(s)\n    var res = \"\"\n    if (rc != null) {\n        val row = rc.groupValues[1]\n        val col = rc.groupValues[2].toInt()\n        res = \"${toBase26(col)}$row\"\n    }\n    val sp = Regex(\"\"\"(\\D+)(\\d+)\"\"\").matchEntire(s)\n    if (sp != null) {\n        val col = sp.groupValues[1]\n        val row = sp.groupValues[2]\n        res = \"R${row}C${fromBase26(col)}\"\n    }\n    return res\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207604,"user_id":null,"body":"fun spreadsheet(s: String) : String {\n    return if (s.matches(Regex(\"R\\\\d+C\\\\d+\"))){\n        val split = s.split(\"R\", \"C\")\n        var c = split[2].toInt()\n        var col = \"\"\n        while(c > 0){\n            col += if (c % 26 == 0) 'Z' else (c % 26 + 'A'.toInt() - 1).toChar()\n            c = (c - 1) \/ 26\n        }\n        \"${col.reversed()}${split[1]}\"\n    } else {\n        val (c, r) = s.partition { it in 'A'..'Z' }\n        \"R${r}C${c.fold(0) { x, char -> x * 26 + (char - 'A' + 1) }}\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207605,"user_id":null,"body":"fun spreadsheet(s: String): String {\n  val result = Regex(\"R(\\\\d+)C(\\\\d+)|(\\\\p{Alpha}+)(\\\\d+)\").matchEntire(s)!!\n  return if (result.groupValues[1].isNotEmpty()) {\n      val r = result.groupValues[1]\n      var c = result.groupValues[2].toInt() - 1\n      val col = StringBuilder()\n      while (c >= 0) {\n          col.insert(0, (c % 26 + 'A'.toInt()).toChar())\n          c = c \/ 26 - 1\n      }\n      col.toString() + r\n  } else {\n      val c = result.groupValues[3].map { it - '@' }.reduce { a, b -> a * 26 + b }\n      val r = result.groupValues[4]\n      \"R${r}C$c\"\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207606,"user_id":null,"body":"import java.lang.Math.pow\n\nfun spreadsheet(s: String): String {\n    return when {\n        \"R\\\\d+C\\\\d+\".toRegex().matches(s) -> toSpreadSheet(s)\n        \"\\\\w+\\\\d+\".toRegex().matches(s) -> toColRow(s)\n        else -> \"err\"\n    }\n}\n\nval alphabet = ('A'..'Z').toList()\n\nfun toColRow(s: String): String {\n    val data = s.uppercase().split()\n    val col = data[0].mapIndexed { index, c ->\n        (alphabet.indexOf(c) + 1) * (pow(26.0, (data[0].length-1 - index).toDouble())).toInt()\n    }\n    return \"R${data[1]}C${col.sum()}\"\n}\n\nfun toSpreadSheet(s: String): String {\n    val data = s.uppercase().split()\n    val row = data[3].toInt()\n    return \"${pair(row)}${data[1]}\"\n}\n\nprivate fun pair(row: Int): String {\n    val nextRow = row - 1\n    val char = nextRow % 26\n    return if (nextRow < 26) alphabet[char].toString()\n    else \"${pair((nextRow - char) \/ 26)}${alphabet[char]}\"\n\n}\n\nfun String.split(): List<String> {\n    var result = \"\"\n    forEachIndexed { index, c ->\n        result += c\n        if (index < length - 1 && !((c.isLetter() && this[index + 1].isLetter()) || (c.isDigit() && this[index + 1].isDigit()))) {\n            result += ' '\n        }\n    }\n    return result.split(' ')\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207607,"user_id":null,"body":"import java.lang.Math.floorDiv\n\n\nfun spreadsheet(s: String): String {\n   \n    return if(s.matches(\"[Rr]\\\\d+[Cc]\\\\d+\".toRegex())) {\n        val tokens = s.toUpperCase().replace(\"R\", \"\").split('C')\n        val row = tokens[0].toInt()\n        val column = tokens[1].toInt()\n\n        \"${numToSprdsht(column)}$row\"\n    } else {\n        val firstDigit = s.indexOfFirst { it.isDigit() }\n        val row = s.substring(firstDigit)\n        val col = s.substring(0, firstDigit)\n\n        \"R${row}C${sprdshtToNum(col)}\"\n    }\n\n}\n\n\nfun numToSprdsht(num: Int): String {\n    val alpha = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n    return if (num < 26) {\n        alpha[num - 1].toString()\n    } else {\n        val q: Int = floorDiv(num, 26)\n        val r = num % 26\n\n        if (r == 0) {\n            if (q == 1) {\n                alpha[(26 + r - 1) % 26].toString()\n            } else {\n                numToSprdsht(q - 1) + alpha[(26 + r - 1) % 26]\n            }\n        } else {\n            numToSprdsht(q) + alpha[(26 + r - 1) % 26]\n        }\n    }\n}\n\n\nfun sprdshtToNum(sprd: String) : Int {\n    var colNum = 0\n    for (i in sprd.indices) {\n        colNum *= 26\n        colNum += sprd[i] - 'A' + 1\n    }\n    return colNum\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207608,"user_id":null,"body":"fun spreadsheet(s: String): String {\n    val coordinates = \"[A-Z]+\\\\d+\".toRegex().findAll(s).toList().map{it.value}\n    return when(coordinates.size){\n        1 -> spreadSheetToRowColumn(s)\n        2 -> rowColumnToSpreadsheet(coordinates)\n        else -> \"\"\n    }\n}\n\nfun spreadSheetToRowColumn(s: String): String{\n    val partition = s.partition{it.isDigit()}\n    val column = lettersToColumn(partition.second)\n    val row = partition.first\n    \n    return \"R${row}C${column}\"\n}\n\nfun lettersToColumn(s : String) : Int {\n    var output = 0\n    s.forEach{ \n        output += it.code - 'A'.code + 1\n        output *= 26\n    }\n    output \/= 26\n    return output\n}\n\nfun rowColumnToSpreadsheet(pair: List<String>): String {\n    val column = columnToLetters(pair[1].filter{it.isDigit()}.toInt()-1)\n    val row = pair[0].filter{it.isDigit()}\n    return column + row\n}\n\nfun columnToLetters(column : Int): String = if(column > 25){\n    columnToLetters(column\/26-1) + columnToLetters(column%26)\n} else { \n    ('A'.code + column).toChar().toString() \n}\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207609,"user_id":null,"body":"fun spreadsheet(s: String) = if(s.filter{it.isLetter()}==\"RC\") RCtoAB(s) else ABtoRC(s)\n\nfun RCtoAB(addr: String): String {\n    val (R,C) = addr.drop(1).split(\"C\")\n    val new_C = C.toInt().let {num->\n        var n = num\n        var letters = \"\"\n        (5 downTo 0).forEach {exp->\n            val div = Math.pow(26.0,exp.toDouble()).toInt()\n            var multi = n\/div\n            if(multi>0) {\n                if(n%(multi * div) < Math.pow(26.0,(exp-1).toDouble()).toInt() && multi > 1) multi--\n                val letter = if(multi>1 || n>26) 'A' + multi - 1 else 'A' + n - 1\n                letters += letter\n                n %= (multi * div)\n            }\n        }\n        letters\n    }\n    return \"$new_C$R\"\n}\n\nfun ABtoRC(addr: String): String {\n    val pre_R = addr.takeLastWhile{it.isDigit()}\n    val pre_C = addr.takeWhile{it.isLetter()}\n    val C = pre_C.reversed().uppercase().mapIndexed{ind,c->\n        val num = c-'A'+1\n        val razr = Math.pow(26.0,ind.toDouble()).toInt()\n        razr * num\n    }.sum()\n    return \"R${pre_R}C$C\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207610,"user_id":null,"body":"fun spreadsheet(s: String): String {\n    val old = Regex(\"[A-Z]+[0-9]+\")\n    val new = Regex(\"[R]+[0-9]+[C]+[0-9]+\")\n\n\n    if (old.matches(s)) {\n        val column = Regex(\"[A-Z]+\").find(s)!!.value\n        val row = Regex(\"[0-9]+\").find(s)!!.value\n        return \"R${row}C${convertToNumber(column)}\"\n    } else {\n        val row = s.substring(s.indexOf(\"R\") + 1, s.indexOf(\"C\"))\n        val column = s.substring(s.indexOf(\"C\") + 1)\n        return \"${convertToLetter(column.toInt())}$row\"\n    }\n}\n\n\nfun convertToNumber(a: String): Int {\n    return a.reversed().mapIndexed { i, c ->\n        (c - 64).code * Math.pow(26.0, i.toDouble())\n    }.sum().toInt()\n\n}\n\nfun convertToLetter(a: Int): String {\n    var number = a\n    var converterNumber = \"\"\n    while (number > 0) {\n        if(number%26 == 0 ){\n            converterNumber += \"Z\"\n            number = number \/ 26   -1\n        }else {\n            converterNumber += ((number % 26) + 64).toChar()\n            number = number \/ 26\n        }\n\n\n    }\n    return converterNumber.reversed()\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207611,"user_id":null,"body":"val spreadsheetRegex = Regex(\"^R(\\\\d+)C(\\\\d+)$\")\n\nfun spreadsheet(s: String): String {\n    val matchResult = spreadsheetRegex.matchEntire(s)\n    if (matchResult != null) {\n        val row = matchResult.groupValues[1]\n        val col = matchResult.groupValues[2]\n        \n        var colNum = col.toInt()\n        val builder = StringBuilder()\n        while (colNum > 0) {\n            colNum--\n            val c = (colNum % 26) + 'A'.code\n            builder.appendCodePoint(c)\n            colNum \/= 26\n        }\n        \n        return \"${builder.reverse().toString()}${row}\"\n    } else {\n        val splitIndex = Regex(\"\\\\d\").find(s)!!.range.first\n        val colStr = s.substring(0, splitIndex)\n        val row = s.substring(splitIndex)\n        var col = 0\n        for (i in 0 until colStr.length) {\n            col += Math.pow(26.toDouble(), i.toDouble()).toInt() * (colStr[colStr.length - i - 1] - ('A' - 1))\n        }\n        return \"R${row}C${col}\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207612,"user_id":null,"body":"fun String.aaToInt() = toByteArray().map { it - 64 }.reduce { acc, i -> acc * 26 + i }\nfun String.toAA() = buildString {\n    var n = this@toAA.toInt()\n    while (n-- > 0) {\n        append((n % 26 + 65).toChar())\n        n \/= 26\n    }\n    reverse()\n}\n\nfun spreadsheet(s: String): String {\n    val l = s.split(Regex(\"(?<=\\\\D)(?=\\\\d)|(?<=\\\\d)(?=\\\\D)\"))\n    return when (l.size) {\n        2 -> \"R${l[1]}C${l[0].aaToInt()}\"\n        4 -> \"${l[3].toAA()}${l[1]}\"\n        else -> throw IllegalArgumentException()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"58b8c94b7df3f116eb00005b":[{"id":207613,"user_id":527,"body":"fun reverse_letter(str: String): String {\n    return str.filter(Char::isLetter).reversed()\n}","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207614,"user_id":null,"body":"fun reverse_letter(str: String) = str.reversed().filter{ it.isLetter() }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207615,"user_id":null,"body":"fun reverse_letter(str: String) = str.filter { it.isLetter() }.reversed()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207616,"user_id":null,"body":"fun reverse_letter(str: String)= str.filter { it in 'a'..'z' || it in 'A'..'Z' }.reversed()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207617,"user_id":null,"body":"fun reverse_letter(str: String): String = str.replace(Regex(\"[^a-zA-Z]\"), \"\").reversed()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207618,"user_id":null,"body":"fun reverse_letter(str: String): String = str.filter { it.isLetter() }.reversed()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207619,"user_id":null,"body":"fun reverse_letter(str: String): String = str.split(Regex(\"\")).map{ it.replace(Regex(\"[^a-zA-Z]\"), \"\") }.reversed().joinToString(\"\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207620,"user_id":null,"body":"fun reverse_letter(str: String): String = \"[^A-Za-z]+\".toRegex().replace(str, \"\").reversed()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207621,"user_id":null,"body":"fun reverse_letter(str: String): String {\n  return str.filter{c->c.isLetter()}.reversed()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207622,"user_id":null,"body":"fun reverse_letter(str: String): String {\n  return str.replace(Regex(\"[^a-zA-Z]\"), \"\").reversed()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"58c5fca35722de3493000081":[{"id":207623,"user_id":null,"body":"package kata\n\nclass Sandpile(piles: String = \"000\n000\n000\", private val dimension: Int = 3) {\n\n    var flattenPiles = normalize(piles.replace(\"\n\", \"\").chunked(1).map(String::toInt).toMutableList())\n\n    fun add(sandpile: Sandpile) = Sandpile().also {\n        it.flattenPiles = normalize(sandpile.flattenPiles.zip(flattenPiles, Int::plus).toMutableList())\n    }\n\n    override fun toString() = flattenPiles.joinToString(\"\").chunked(dimension).joinToString(\"\n\")\n\n    private fun normalize(piles: MutableList<Int>): List<Int> {\n        val index = piles.indexOfFirst { it > dimension }.takeIf { it > -1 } ?: return piles\n        fun MutableList<Int>.increment(i: Int) = getOrNull(i)?.let { set(i, get(i) + 1) }\n        piles.run {\n            set(index, get(index) - 4)\n            increment(index - dimension)\n            increment(index + dimension)\n            if (index % dimension > 0) { increment(index - 1) }\n            if (index % dimension < dimension - 1) { increment(index + 1) }\n        }\n        return normalize(piles)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207624,"user_id":null,"body":"package kata\n\nclass Sandpile(piles:String = \"000\n000\n000\") {\n\n    val grid: MutableList<Int>\n    val row_len: Int\n    val max_val = 3\n    \n    init {\n        row_len = piles.split(\"\n\").first().length\n        grid = toList(piles)\n        topple()\n    }\n    \n    fun add(sandpile:Sandpile): Sandpile {\n        val grid_to_add = sandpile.grid\n        val new_grid = grid.mapIndexed {ind,item->\n            item+(grid_to_add.elementAtOrElse(ind){0})\n        }.chunked(row_len).map{it.joinToString(\"\")}.joinToString(\"\n\")\n        return Sandpile(new_grid)\n    }\n    \n    override fun toString() = grid.chunked(row_len).map{it.joinToString(\"\")}.joinToString(\"\n\")\n    \n    private fun toList(p: String): MutableList<Int> = p.split(\"\n\").map{row->\n            row.map{c-> \"$c\".toIntOrNull()?:0}\n        }.flatten().toMutableList()\n    \n    private fun topple() {\n        do {var any_changes = false\n            for(ind in 0..grid.lastIndex) {\n                if(grid[ind]>max_val) { \n                    any_changes = true\n                    grid[ind] -= max_val+1\n                    if(ind-1>=0 && ind%row_len>0) grid[ind-1]++ \/\/left\n                    if(ind+1<=grid.lastIndex && ind%row_len<row_len-1) grid[ind+1]++ \/\/right\n                    if(ind-row_len>=0) grid[ind-row_len]++ \/\/up\n                    if(ind+row_len<=grid.lastIndex) grid[ind+row_len]++ \/\/down\n                }\n            }\n        } while(any_changes)\n    }\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207625,"user_id":100,"body":"package kata\n\nclass Sandpile(piles: String = \"\") {\n\n    operator fun get(index: Int) = grid[index]\n\n    private val grid = Array(3) { IntArray(3) }\n        .apply {\n            piles.split(\"\n\").forEachIndexed { i, line ->\n                line.forEachIndexed { j, n ->\n                    this[i][j] = (n + \"\").toInt()\n                }\n            }\n            makeEquilibrium()\n        }\n\n    private fun Array<IntArray>.incrementCell(row: Int, col: Int) {\n        if (row in indices && col in this[row].indices) this[row][col]++\n    }\n\n    private fun Array<IntArray>.makeEquilibrium() {\n        while (any { it.any { n -> n > 3 } })\n            for (rowNum in 0 until 3) for (colNum in 0 until 3)\n                if (this[rowNum][colNum] > 3) {\n                    this[rowNum][colNum] -= 4\n                    incrementCell(rowNum, colNum + 1); incrementCell(rowNum + 1, colNum)\n                    incrementCell(rowNum, colNum - 1); incrementCell(rowNum - 1, colNum)\n                }\n    }\n\n    fun add(sandpile: Sandpile): Sandpile {\n        val sum = Sandpile()\n        for (rowNum in 0 until 3) for (colNum in 0 until 3) {\n            sum[rowNum][colNum] = this[rowNum][colNum] + sandpile[rowNum][colNum]\n        }\n        sum.grid.makeEquilibrium()\n        return sum\n    }\n\n    override fun toString() = grid.joinToString(separator = \"\n\") { it.joinToString(\"\") }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207626,"user_id":null,"body":"package kata\n\nclass Sandpile(piles: String = \"\", rows: Int = 3, columns: Int = 3) {\n\n    private val nodes = Array(rows) { Array(columns) { 0 } }\n\n    init {\n        if (piles.isNotEmpty()) {\n            val input = piles.split(\"\n\")\n            nodes.forEachIndexed { ir, row ->\n                row.forEachIndexed { ic, _ ->\n                    nodes[ir][ic] = input[ir][ic].digitToInt()\n                }\n            }\n\n            var needDo: Boolean\n            do {\n                needDo = false\n                nodes.forEachIndexed { ir, row ->\n                    row.forEachIndexed { ic, col ->\n                        if (col > 3) {\n                            needDo = true\n                            nodes[ir][ic] -= 4\n                            if (ic != 0) nodes[ir][ic-1] += 1\n                            if (ic != row.size - 1) nodes[ir][ic+1] += 1\n                            if (ir != 0) nodes[ir-1][ic] += 1\n                            if (ir != nodes.size - 1) nodes[ir+1][ic] += 1\n                        }\n                    }\n                }\n            } while (needDo)\n        }\n    }\n\n    fun add(sandpile: Sandpile): Sandpile {\n        assert(nodes.size == sandpile.nodes.size && nodes[0].size == sandpile.nodes[0].size)\n\n        var result = \"\"\n        nodes.forEachIndexed { ir, row ->\n            if (ir != 0) result += \"\n\"\n            row.forEachIndexed { ic, col ->\n                result += col + sandpile.nodes[ir][ic]\n            }\n        }\n        return Sandpile(result, nodes.size, nodes[0].size)\n    }\n\n    override fun toString(): String {\n        var result = \"\"\n        nodes.forEachIndexed { i, row ->\n            if (i != 0) result += \"\n\"\n            row.forEach { col ->\n                result += col\n            }\n        }\n        return result\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207627,"user_id":null,"body":"package kata\n\ntypealias Grid = List<List<Int>>\nfun emptyGrid() = emptyList<List<Int>>()\nfun grid(rows:Int, columns: Int, block: (i:Int, j:Int) -> Int): Grid =\n    List(rows){ i ->\n        List(columns) {j ->\n            block(i,j)\n        }\n    }\nfun grid(piles:String): Grid {\n    val split = piles.split('\n')\n    return grid(split.size, split[0].length){i,j -> split[i][j].digitToInt()}\n}\n\nfun Grid.add(other:Grid) : Grid =\n    if(other.isEmpty()) this\n    else if (isEmpty()) other\n    else mapIndexed{ i, row -> row.mapIndexed{ j, cell -> cell + other[i][j]}}\n    \nfun Grid.topple() : Grid {\n    val x = this.map { it.toMutableList()}\n    fun List<MutableList<Int>>.safeAdd(x:Int, y:Int) {\n        if(x in this.indices)\n            if(y in this[x].indices)\n                this[x][y]++\n    }\n    this.forEachIndexed{ i, row ->\n        row.forEachIndexed { j, cell ->\n            if (cell > 3) {\n                x[i][j] -= 4\n                x.safeAdd(i-1, j)\n                x.safeAdd(i+1, j)\n                x.safeAdd(i, j-1)\n                x.safeAdd(i, j+1)\n            }\n        }\n    }\n    return x\n}\n\nfun Grid.normalise(): Grid {\n    var current = this;\n    var previous = emptyGrid()\n    while(current != previous) {\n        previous = current\n        current = current.topple()\n    }\n    return current\n}\n\nclass Sandpile {\n    \/\/ constructor accepts nothing or a string in the form:\n    \/\/ \"123\n456\n789\"\n    private val grid: Grid\n    constructor(){\n        grid = emptyGrid()\n    }\n    constructor(piles:String) {\n        grid = (if(piles.isBlank()) emptyGrid() else grid(piles).normalise())\n    }\n    private constructor(g: Grid){\n        grid = g.normalise()\n    }\n\n    fun add(other: Sandpile): Sandpile {\n        return Sandpile(grid.add(other.grid))\n    }\n    \n    override fun toString(): String =\n        if(grid.isEmpty()) \"000\n000\n000\" else grid.joinToString(\"\n\"){ it.joinToString(\"\")}\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207628,"user_id":null,"body":"package kata\n\nclass Sandpile {\n\n    val piles: Field\n\n    \/\/ constructor accepts nothing or a string in the form:\n    \/\/ \"123\n456\n789\"\n    constructor(piles: String) : this(initPieles(piles))\n\n    constructor(piles: Field) {\n        var oldPiles = piles\n        while (!isAtRest(piles)) {\n            val newPiles = oldPiles\n            for (currentPos: Position in allPositions(3, 3)) {\n                if (oldPiles.get(currentPos) ?: 0 > 3) {\n                    newPiles.map(currentPos) { it - 4 }\n                    for (neighbour in neighbourhood(currentPos)) {\n                        newPiles.map(neighbour) { it + 1 }\n                    }\n                }\n            }\n            oldPiles = newPiles\n        }\n        this.piles = oldPiles\n    }\n    \n    constructor() : this(Field(3,3))\n\n    fun add(sandpile: Sandpile): Sandpile {\n        val addedPiles = this.piles.values.zip(sandpile.piles.values).map { it.first + it.second }.toIntArray()\n        return Sandpile(Field(3, 3, addedPiles))\n    }\n\n    override fun toString(): String {\n        \/\/ return this sandpile in the string form \"123\n123\n123\"\n        return piles.toString()\n    }\n}\n\nfun allPositions(width: Int, height: Int): List<Position> = (0..(height - 1)).flatMap { y -> (0..(width - 1)).map { x -> Position(x, y) } }\n\nfun isAtRest(field: Field): Boolean = field.values.maxOf { it } <= 3\n\nfun neighbourhood(pos: Position): List<Position> =\n    listOf<Position>(Position(pos.x - 1, pos.y), Position(pos.x + 1, pos.y), Position(pos.x, pos.y - 1), Position(pos.x, pos.y + 1))\n\nfun initPieles(pieles: String): Field {\n    val values = pieles.map { it.digitToIntOrNull() }.filterNotNull().toIntArray()\n    return Field(3, 3, values)\n}\n\nclass Field {\n    val width: Int\n    val height: Int\n    val values: IntArray\n\n    constructor(width: Int, height: Int, values: IntArray) {\n        require(values.size == width * height)\n        this.width = width\n        this.height = height\n        this.values = values\n    }\n\n    constructor(width: Int, height: Int) {\n        this.width = width\n        this.height = height\n        this.values = IntArray(width * height)\n    }\n\n    fun get(pos: Position): Int? {\n        if (!onField(pos)) {\n            return null\n        }\n        return values[index(pos)]\n    }\n\n    fun set(pos: Position, value: Int) {\n        if (onField(pos)) {\n            values[index(pos)] = value\n        }\n    }\n\n    fun map(pos: Position, f: (Int) -> Int) {\n        if (onField(pos)) {\n            val newValue = f(values[index(pos)])\n            values.set(index(pos), newValue)\n        }\n        \n    }\n\n    fun onField(pos: Position) =\n        inRange(pos.x, 0, width - 1) &&\n            inRange(pos.y, 0, height - 1)\n\n    override fun toString(): String {\n        return values.withIndex().groupBy { it.index \/ width }.map { it.value.map { it.value }.joinToString(\"\") }.joinToString(\"\n\")\n    }\n            \n    private fun index(pos: Position) = pos.x + pos.y * width\n}\n\nfun inRange(value: Int, lower: Int, heigher: Int) = value >= lower && value <= heigher\n\nclass Position(val x: Int, val y: Int)\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207629,"user_id":null,"body":"package kata\n\nclass Sandpile(piles:String? = null) {\n    \/\/ constructor accepts nothing or a string in the form:\n    \/\/ \"123\n456\n789\"\n    val sand: MutableList<MutableList<Int>>\n    \n    init{\n        sand = if(piles != null){\n            piles.split(\"\n\").map{ it.map{ it.code - '0'.code}.toMutableList()}.toMutableList()\n        } else {\n            val row = mutableListOf(0, 0, 0)\n            mutableListOf(row, row.map{it}.toMutableList(), row.map{it}.toMutableList())\n        }\n        topple()\n    }\n    \n    fun topple(){\n        while(sand.map{ it.maxOrNull() ?: 0}.maxOrNull() ?: 0 > 3){\n            for(i in 0..2){\n                for(j in 0..2){\n                    if(sand[i][j] > 3){\n                        if(i > 0){\n                            sand[i-1][j] += 1\n                        }\n                        if(i < sand.size-1){\n                            sand[i+1][j] += 1\n                        }\n                        if(j > 0){\n                            sand[i][j-1] += 1\n                        }\n                        if(j < sand[0].size-1){\n                            sand[i][j+1] += 1\n                        }\n                        sand[i][j] -= 4\n                    }\n                }\n            }\n        }\n    }\n    \n    fun add(sandpile:Sandpile): Sandpile {\n        val output = Sandpile()\n        for(i in 0..2){\n            for(j in 0..2){\n                output.sand[i][j] = sand[i][j] + sandpile.sand[i][j]\n            }\n        }\n        output.topple()\n        return output\n    }\n    \n    override fun toString(): String = sand.map{ it.joinToString(\"\")}.joinToString(\"\n\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207630,"user_id":null,"body":"package kata\n\ntypealias IntGrid = List<List<Int>>\n\nfun String?.toIntGrid(): IntGrid {\n    if (this == null) return listOf(listOf(0, 0, 0), listOf(0, 0, 0), listOf(0, 0, 0))\n    else {\n        return this.split(\"\n\").map { rowString ->\n            rowString.toCharArray().map(Character::getNumericValue)\n        }\n    }\n}\n\nfun IntGrid.combine(other: IntGrid): IntGrid {\n    return (0..2).map { r ->\n        (0..2).map { c ->\n            this[r][c] + other[r][c]\n        }\n    }\n}\n\nclass Sandpile(piles: IntGrid) {\n    \/\/ constructor accepts nothing or a string in the form:\n    \/\/ \"123\n456\n789\"\n    private lateinit var piles: IntGrid\n\n    constructor(piles: String?) : this(piles.toIntGrid())\n    constructor():this(piles=null)\n    init {\n        var toppled:Boolean\n        val piles = piles.toMutableList().map { it.toMutableList() }\n        do {\n            toppled=false\n            for (r in 0..2) {\n                for (c in 0..2) {\n                    val sands = piles[r][c]\n                    if (sands > 3) {\n                        piles[r][c] -= 4\n                        if (r != 0) {\n                            piles[r - 1][c] += 1\n                        }\n                        if (r != piles.lastIndex) {\n                            piles[r + 1][c] += 1\n                        }\n                        if (c != 0) {\n                            piles[r][c - 1] += 1\n                        }\n                        if (c != piles[0].lastIndex) {\n                            piles[r][c + 1] += 1\n                        }\n                        toppled = true\n                    }\n                }\n            }\n        } while (toppled)\n        this.piles = piles\n    }\n\n    fun add(sandpile: Sandpile): Sandpile {\n        \/\/ adds two sandpiles together and returns the resulting sandpile\n        return Sandpile(piles.combine(sandpile.piles))\n    }\n\n    override fun toString(): String {\n        var str = \"\"\n        for (r in 0..2) {\n            for (c in 0..2) {\n                str += \"${piles[r][c]}\"\n            }\n            if(r!=2)str += \"\n\"\n        }\n        return str\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207631,"user_id":100,"body":"package kata\n\nclass Sandpile(piles: String = \"\") {\n\n    private val grid = Array(3) { IntArray(3) }\n        .apply {\n            piles.split(\"\n\").forEachIndexed { i, line ->\n                line.forEachIndexed { j, n ->\n                    this[i][j] = (n + \"\").toInt()\n                }\n            }\n            makeEquilibrium()\n    }\n\n    private fun Array<IntArray>.incrementCell(row: Int, col: Int) {\n        if (row in 0 until size && col in 0 until this[row].size) this[row][col]++\n    }\n\n    private fun Array<IntArray>.makeEquilibrium() {\n        while (any { it.any { n -> n > 3 } })\n            for (rowNum in 0 until 3) for (colNum in 0 until 3)\n                if (this[rowNum][colNum] > 3) {\n                    this[rowNum][colNum] -= 4\n                    incrementCell(rowNum, colNum + 1); incrementCell(rowNum + 1, colNum)\n                    incrementCell(rowNum, colNum - 1); incrementCell(rowNum - 1, colNum)\n                }\n    }\n\n    fun add(sandpile: Sandpile): Sandpile {\n        val sum = Array(3) { IntArray(3) }\n        for (rowNum in 0 until 3) for (colNum in 0 until 3) {\n            sum[rowNum][colNum] = grid[rowNum][colNum] + sandpile.grid[rowNum][colNum]\n        }\n        sum.makeEquilibrium()\n        return Sandpile(sum.encode())\n    }\n\n    private fun Array<IntArray>.encode() = joinToString(separator = \"\n\") { it.joinToString(\"\") }\n\n    override fun toString() = grid.encode()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207632,"user_id":100,"body":"package kata\n\nclass Sandpile(piles: String = \"\") {\n\n    private val grid = parseEncoding(piles)\n\n    private fun parseEncoding(enc: String) = Array(3) { IntArray(3) }\n        .apply {\n            enc.split(\"\n\").forEachIndexed { i, line ->\n                line.forEachIndexed { j, n ->\n                    this[i][j] = (n + \"\").toInt()\n                }\n            }\n            makeEquilibrium()\n        }\n\n    private fun Array<IntArray>.incrementCell(row: Int, col: Int) {\n        if (row in 0 until size && col in 0 until this[row].size) this[row][col]++\n    }\n\n    private fun Array<IntArray>.makeEquilibrium() {\n        while (any { it.any { n -> n > 3 } })\n            for (rowNum in 0 until 3) for (colNum in 0 until 3)\n                if (this[rowNum][colNum] > 3) {\n                    this[rowNum][colNum] -= 4\n                    incrementCell(rowNum, colNum + 1); incrementCell(rowNum + 1, colNum)\n                    incrementCell(rowNum, colNum - 1); incrementCell(rowNum - 1, colNum)\n                }\n    }\n\n    fun add(sandpile: Sandpile): Sandpile {\n        val sum = Array(3) { IntArray(3) }\n        for (rowNum in 0 until 3) for (colNum in 0 until 3) {\n            sum[rowNum][colNum] = grid[rowNum][colNum] + sandpile.grid[rowNum][colNum]\n        }\n        sum.makeEquilibrium()\n        return Sandpile(sum.encode())\n    }\n\n    private fun Array<IntArray>.encode() = joinToString(separator = \"\n\") { it.joinToString(\"\") }\n\n    override fun toString() = grid.encode()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"58ce8725c835848ad6000007":[{"id":207633,"user_id":null,"body":"package potatoes\n\nfun potatoes(p0: Int, w0: Int, p1: Int) = w0 * (100 - p0) \/ (100 - p1)\n","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207634,"user_id":null,"body":"package potatoes\n\nfun potatoes(p0:Int, w0:Int, p1:Int):Int {\n    return w0 * (100 - p0) \/ (100 - p1);\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207635,"user_id":null,"body":"package potatoes\nfun potatoes(p0:Int, w0:Int, p1:Int):Int = w0*(100-p0) \/ (100-p1) \/\/ \u0445\u0435\u0440\u043e\u0432 \u043f\u0430\u0440\u0430\u0434\u043e\u043a\u0441 \u043a\u0430\u0440\u0442\u043e\u0444\u0435\u043b\u044f  1 \u043a\u0433 \u2014 \u044d\u0442\u043e 2% \u0447\u0435\u0433\u043e? \u041e\u0442\u0432\u0435\u0442 50 \u043a\u0433.\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207636,"user_id":null,"body":"package potatoes\n\nfun potatoes(p0:Int, w0:Int, p1:Int):Int {\n    return Math.floor(\n        (100.0 - p0) \/ 100.0 * w0 * 100.0 \/ (100.0 - p1)\n    ).toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207637,"user_id":492,"body":"package potatoes\n\nfun potatoes(p0:Int, w0:Int, p1:Int):Int {\n    return (w0.toDouble() * (100.0 - p0.toDouble()) \/ (100.0 - p1.toDouble())).toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207638,"user_id":null,"body":"package potatoes\n\nfun potatoes(p0:Int, w0:Int, p1:Int):Int {\n    val p0Kg = w0 * p0\n    val dryKg = w0 * 100 - p0Kg\n    \n    val dry1 = 100 - p1\n    val w1 = dryKg \/ dry1\n    \n    return w1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207639,"user_id":null,"body":"package potatoes\n\nfun potatoes(p0:Int, w0:Int, p1:Int) = (w0 * (100 - p0) \/ (100 - p1)).toInt()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207640,"user_id":null,"body":"package potatoes\n\nfun potatoes(p0: Int, w0: Int, p1: Int): Int = Math.floor((w0 * (100-p0) \/ (100-p1)).toDouble()).toInt()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207641,"user_id":null,"body":"package potatoes\n\nfun potatoes(initialWaterPercent:Int, initialWeight:Int, finalWaterPercent:Int):Int {\n    val initialDryMatterWeight = (100 - initialWaterPercent) * initialWeight  \/ 100.00f\n    val totalFinalWeight = initialDryMatterWeight * 100 \/ (100 - finalWaterPercent)\n    return totalFinalWeight.toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207642,"user_id":null,"body":"package potatoes\n\nimport java.math.BigDecimal\nfun potatoes(p0: Int, w0: Int, p1: Int): Int {\n    val initWeight = w0.toBigDecimal()\n    val dryMatter: BigDecimal = initWeight.minus(p0.toBigDecimal().movePointLeft(2).multiply(initWeight))\n    val dryPAfter = BigDecimal(100 - p1).movePointLeft(2)\n    return dryMatter.div(dryPAfter).toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"58e24788e24ddee28e000053":[{"id":207643,"user_id":null,"body":"fun simple_assembler(program: Array<String>): Map<String, Int> {\n    val registers = mutableMapOf<String, Int>()\n    val getJustIntOrRegister = {key: String -> \n        key.toIntOrNull() ?: registers.getOrDefault(key, 0)\n    }\n\n    var i = 0\n    while (i < program.size) {\n        val cmd = program[i].split(\" \")\n        val (op, dst) = cmd.take(2)\n        \n        when (op) {\n            \"mov\" -> registers[dst] = getJustIntOrRegister(cmd[2])\n            \"inc\" -> registers[dst] = registers.getValue(dst) + 1\n            \"dec\" -> registers[dst] = registers.getValue(dst) - 1\n            \"jnz\" -> {\n                if (getJustIntOrRegister(dst) != 0)\n                    i += cmd[2].toInt() - 1\n            }\n        }\n\n        i++\n    }\n    return registers\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-02 19:46:51"},{"id":207644,"user_id":null,"body":"fun simple_assembler(program: Array<String>) = AssembleInterpreter().interprete(program)\n\nprivate class AssembleInterpreter {\n\n    private val registers = mutableMapOf<String, Int>()\n    private val commands = mutableListOf<String>()\n\n    private var currentLine = 0\n\n    @Synchronized\n    fun simple_assemblere(program: Array<String>): Map<String, Int> {\n        registers.clear()\n        commands.clear()\n\n        commands.addAll(program)\n\n        while (currentLine < commands.size) {\n            executeLine(commands[currentLine])\n        }\n\n        return registers\n    }\n\n    private fun executeLine(line: String) {\n        val words = line.split(' ')\n\n        val command = words[0]\n        val variable = words[1]\n        val value by lazy { defineValue(words[2]) }\n\n        when (command) {\n            \"mov\" -> mov(variable, value)\n            \"jnz\" -> jnz(variable, value)\n            \"inc\" -> inc(variable)\n            \"dec\" -> dec(variable)\n        }\n\n        if (command != \"jnz\") currentLine++\n    }\n\n\n    private fun mov(variable: String, value: Int) {\n        registers[variable] = value\n    }\n\n    private fun inc(variable: String) {\n        registers[variable] = registers[variable]!! + 1\n    }\n\n    private fun dec(variable: String) {\n        registers[variable] = registers[variable]!! - 1\n    }\n\n    private fun jnz(variable: String, lines: Int) {\n        val variableValue = defineValue(variable)\n\n        if (variableValue == 0) currentLine += 1\n        else currentLine += lines\n    }\n\n\n    private fun defineValue(declaration: String): Int {\n        return declaration.toIntOrNull() ?: registers[declaration]!!\n    }\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-02 19:46:51"},{"id":207645,"user_id":null,"body":"fun simple_assembler(program: Array<String>): Map<String, Int> {\n    val vars = mutableMapOf<String, Int>()\n    var crn = 0\n    while (crn < program.size) {\n        val cmd = program[crn]\n        val args = cmd.split(' ')\n        when (args[0]) {\n            \"mov\" -> vars[args[1]] = vars.getOrElse(args[2]) { args[2].toInt() }\n            \"inc\" -> vars[args[1]] = vars[args[1]]!! + 1\n            \"dec\" -> vars[args[1]] = vars[args[1]]!! - 1\n            \"jnz\" -> if (vars[args[1]] != 0) crn += args[2].toInt() - 1\n        }\n        crn++\n    }\n    return vars\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-02 19:46:51"},{"id":207646,"user_id":null,"body":"fun simple_assembler(program: Array<String>): Map<String, Int> {\n    var res = mapOf<String, Int>()\n    var i = 0\n    while (i < program.size) {\n        var curv = program[i].split(\" \")\n        when (curv[0]) {\n            \"mov\" -> res += curv[1] to (res[curv[2]] ?: curv[2].toInt())\n            \"inc\" -> res += curv[1] to ((res[curv[1]] ?: 0) + 1)\n            \"dec\" -> res += curv[1] to ((res[curv[1]] ?: 0) - 1)\n            \"jnz\" -> i += if (res[curv[1]] ?: curv[1].toInt() != 0) curv[2].toInt() - 1 else 0\n        }\n        ++i\n    }\n    \n    return res\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-02 19:46:52"},{"id":207647,"user_id":null,"body":"fun simple_assembler(program: Array<String>): Map<String, Int> {\n    var map = mapOf<String, Int>()\n    var i = 0\n\n    fun calc(pos:Int): Map<String, Int>{\n        var instruction = program[pos].split(\" \")\n        when (instruction[0]){\n            \"mov\" -> return map + Pair(instruction[1], map.getOrElse(instruction[2]) {instruction[2].toInt()})\n            \"inc\" -> return map + Pair(instruction[1], map.getValue(instruction[1]) + 1)\n            \"dec\" -> return map + Pair(instruction[1], map.getValue(instruction[1]) - 1)\n            \"jnz\" -> {\n                if(map[instruction[1]] == 0) return map\n                i = pos + instruction[2].toInt() - 1\n                return map\n                }\n            else -> return map\n            }\n        }\n\n    while (i < program.size){\n        map = calc(i)\n        i++\n        }\n    return map\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-02 19:46:52"},{"id":207648,"user_id":null,"body":"fun simple_assembler(program: Array<String>): Map<String, Int> {\n    val register = mutableMapOf<String, Int>()\n    var instructionPtr = 0\n    \n    val moveConstant = \"\"\"mov ([a-z]) (\\-?\\d+)\"\"\".toRegex()\n    val moveRegister = \"\"\"mov ([a-z]) ([a-z])\"\"\".toRegex()\n    val incRegister = \"\"\"inc ([a-z])\"\"\".toRegex()\n    val decRegister = \"\"\"dec ([a-z])\"\"\".toRegex()\n    val jumpConstant = \"\"\"jnz (\\-?\\d+) (\\-?\\d+)\"\"\".toRegex()\n    val jumpRegister = \"\"\"jnz ([a-z]) (\\-?\\d+)\"\"\".toRegex()\n    \n    while(instructionPtr < program.size) {\n        val instruction = program[instructionPtr]\n        \n        moveConstant.matchEntire(instruction)?.groupValues?.let {\n            (_, x, y) -> register[x] = y.toInt()\n        }\n        moveRegister.matchEntire(instruction)?.groupValues?.let {\n            (_, x, y) -> register[x] = register[y] ?: 0\n        }\n        incRegister.matchEntire(instruction)?.groupValues?.let {\n            (_, x) -> register[x] = (register[x] ?: 0) + 1\n        }\n        decRegister.matchEntire(instruction)?.groupValues?.let {\n            (_, x) -> register[x] = (register[x] ?: 0) - 1\n        }\n        jumpConstant.matchEntire(instruction)?.groupValues?.let {\n            (_, x, y) -> if(x.toInt() != 0) instructionPtr += y.toInt() - 1\n        }\n        jumpRegister.matchEntire(instruction)?.groupValues?.let {\n            (_, x, y) -> if((register[x] ?: 0) != 0) instructionPtr += y.toInt() - 1\n        }\n        \n        instructionPtr++\n    }\n    \n    return register\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-02 19:46:52"},{"id":207649,"user_id":null,"body":"class Interpreter(private val assembly: Array<String>,\n                  private var pc: Int = 0) {\n    \n    private val registers = mutableMapOf<String, Int>()\n    private val instructions = assembly.map {\n        it.split(\" \")\n    }\n    \n    fun numberOrRegister(x: String): Int {\n        return registers[x] ?: x.toInt()\n    }\n    \n    fun cycle() {\n        val instruction = instructions[pc]\n        when (instruction[0]) {\n            \"mov\" -> registers[instruction[1]] = numberOrRegister(instruction[2])\n            \"inc\" -> registers[instruction[1]] = registers[instruction[1]]!! + 1\n            \"dec\" -> registers[instruction[1]] = registers[instruction[1]]!! - 1\n            \"jnz\" -> if (registers[instruction[1]] != 0) {pc += instruction[2].toInt() - 1}\n        }\n        pc++\n    }\n    \n    fun execute(): Map<String, Int> {\n        while (pc<instructions.size) {\n            cycle()\n        }\n        return registers\n    }\n}\n\nfun simple_assembler(program: Array<String>): Map<String, Int> {\n    return Interpreter(program).execute()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-02 19:46:52"},{"id":207650,"user_id":null,"body":"fun isNumber(s: String): Boolean {\n    return if (s[0] == '-') true    \n    else s.all { Character.isDigit(it) }\n}\n\nfun getValue(v: String, m: Map<String, Int>): Int {\n    return if (isNumber(v)) {\n        v.toInt()    \n    } else {\n        m[v]!!\n    }\n}\n\nfun simple_assembler(program: Array<String>): Map<String, Int> {\n    val ret = mutableMapOf<String, Int>()\n    var i = 0\n    \n    while(i < program.size)  {        \n     \n        val tokens = program[i].split(\" \")\n        val cmd = tokens[0]\n        val reg = tokens[1]\n        val value = tokens.getOrNull(2)\n        \n        when(cmd) {\n            \"mov\" -> {                \n                ret[reg] = getValue(value!!, ret)\n            }\n            \"inc\" -> {\n                ret[reg] = ret[reg]!! + 1\n            }\n            \"dec\" -> {\n                ret[reg] = ret[reg]!! - 1\n            }\n            \"jnz\" -> {\n                if (ret[reg] != 0) {                    \n                    val offset = getValue(value!!, ret)                    \n                    i += (offset -1)\n                }\n            }\n        }     \n        \n        i++\n    }\n    return ret\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-02 19:46:52"},{"id":207651,"user_id":null,"body":"fun simple_assembler(program: Array<String>): Map<String, Int> {\n    val map = mutableMapOf<String, Int>()\n    var counter = 0\n    \n    while (counter < program.size) {\n        val stepsList = program[counter].split(\" \")\n        when(stepsList[0]) {\n            \"mov\" -> mov(map, stepsList[1], stepsList[2])\n            \"inc\" -> inc(map, stepsList[1])\n            \"dec\" -> dec(map, stepsList[1])\n            \"jnz\" -> counter += jnz(map, stepsList[1], stepsList[2])\n        }\n        counter++\n    }\n    return map.toMap()\n}\n\nfun mov(map: MutableMap<String, Int>, key: String, number: String){\n    if (number.toIntOrNull() == null) map[key] = map[number]!!\n    else map[key] = number.toInt()\n}\n\nfun inc(map: MutableMap<String, Int>, key: String) {\n    map[key] = map[key]!! + 1\n}\n\nfun dec(map: MutableMap<String, Int>, key: String) {\n    map[key] = map[key]!! - 1\n}\n\nfun jnz(map: MutableMap<String, Int>, key: String, number: String): Int {\n    if (map[key] == 0) return 0\n    return if (number.toIntOrNull() == null) map[number]!!\n    else number.toInt() - 1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-02 19:46:52"},{"id":207652,"user_id":null,"body":"fun simple_assembler(program: Array<String>): Map<String, Int> {\n    val regs = HashMap<String, Int>()\n    var iptr = 0\n    while (iptr < program.size) {\n        val parts = program[iptr].split(\" \")\n        if (parts[0].equals(\"mov\")) {\n            regs[parts[1]] = parts[2].toIntOrNull()?:regs[parts[2]]!!\n        } else if (parts[0].equals(\"inc\")) {\n            regs[parts[1]] = regs[parts[1]]!! + 1\n        } else if (parts[0].equals(\"dec\")) {\n            regs[parts[1]] = regs[parts[1]]!! - 1\n        } else if (parts[0].equals(\"jnz\")) {\n            if ((parts[1].toIntOrNull()?:regs[parts[1]]) != 0)\n                iptr += (parts[2].toIntOrNull()?:regs[parts[2]]!!) - 1\n        }\n        iptr++\n    }\n    \n    return regs.toMap()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-02 19:46:52"}],"58e2c062542a419083000033":[{"id":207653,"user_id":null,"body":"import kotlin.text.format\n\nobject JavaUnicodeEncoder {\n  fun decode(input:String?):String = input!!.split(\"\\\\u\").drop(1).map{it.toInt(16).toChar()}.joinToString(\"\")\n  fun encode(input:String?):String = input!!.map{\"\\\\u%04x\".format(it.toInt())}.joinToString(\"\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207654,"user_id":null,"body":"object JavaUnicodeEncoder {\n    fun decode(input: String?) = input!!.split(\"\\\\u\").filter { it.isNotEmpty() }.map { it.toInt(16).toChar() }.joinToString(\"\")\n    fun encode(input: String?) = input!!.toCharArray().joinToString(\"\") { String.format(\"\\\\u%04x\", it.code) }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207655,"user_id":1381,"body":"object JavaUnicodeEncoder {\n  fun decode(input: String?): String {\n        return input!!.split(Regex(\"\\\\\\\\u\")).filter { it.isNotEmpty() }.map { it.toInt(16).toChar() }.joinToString(\"\")\n  }\n\n  fun encode(input: String?): String {\n      return input!!.map { char -> \"\\\\u\".plus(Integer.toHexString(char.toInt()).padStart(4, '0')) }.joinToString(\"\")\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207656,"user_id":null,"body":"object JavaUnicodeEncoder {\n  fun decode(input:String?):String {\n      if (input != null) {\n          return input.chunked(6).map() {it -> it.takeLast(4).toInt(16).toChar()}.joinToString(\"\")\n      } else {\n          return \"\"\n      }\n  }\n  fun encode(input:String?):String {\n      if (input != null) {\n          return \"\\\\u\" + input.toList().map() {it.toInt().toString(16).padStart(4,'0')}.joinToString(\"\\\\u\")\n      } else {\n          return \"\"\n      }\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207657,"user_id":null,"body":"object JavaUnicodeEncoder {\n    fun decode(input: String?): String {\n        var str = \"\"\n        val ni = input?.split(\"\\\\\")?.drop(1)\n        if (ni != null) {\n            for (i in ni) {\n                str += i.substringAfter(\"u\").uppercase().toInt(16).toChar()\n            }\n        }\n        return str\n    }\n\n    fun encode(input: String?): String {\n        var str = \"\"\n        if (input != null) {\n            for (i in input) {\n                str += \"\\\\u${Integer.toHexString(i.code).padStart(4, '0')}\"\n            }\n        }\n        return str\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207658,"user_id":null,"body":"object JavaUnicodeEncoder {\n  fun decode(input: String?): String {\n        return input\n            ?.split(\"\\\\u\")\n            ?.drop(1)\n            ?.map { it.toInt(16).toChar() }\n            ?.joinToString(\"\") \n            ?: \"\"\n    }\n\n    fun encode(input: String?): String {\n        return input\n            ?.toCharArray()\n            ?.joinToString(\"\") {\n                \"\\\\u${\"%04x\".format(it.code)}\"\n            } ?: \"\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207659,"user_id":null,"body":"object JavaUnicodeEncoder {\n  fun decode(input:String?):String {\n        if(input==null) return \"\"\n        return input\n            .split(\"\\\\u\")\n            .joinToString(\"\") {\n                if(it.isEmpty()) \"\" else it.toInt(16).toChar().toString()\n            }\n    }\n    fun encode(input:String?):String {\n        return input\n            ?.toCharArray()\n            ?.joinToString( \"\"){\n                \"\\\\u${\"%04x\".format(it.code)}\"\n            } ?: \"\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207660,"user_id":null,"body":"object JavaUnicodeEncoder {\n    fun decode(input: String?): String = input!!.split(\"\\\\u\")\n        .filterNot { it.isEmpty() }\n        .map {\n            Integer.parseInt(it, 16).toChar()\n        }.joinToString(\"\")\n\n    fun encode(input: String?): String = input!!.map {\n        String.format(\"\\\\u%04x\", it.code)\n    }.joinToString(\"\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207661,"user_id":null,"body":"object JavaUnicodeEncoder {\n    fun decode(input: String?): String = input\n        ?.split(\"\\\\u\")\n        ?.drop(1)\n        ?.map{it.toInt(radix = 16).toChar()}\n        ?.joinToString(\"\") ?: \"\"\n    \n    fun encode(input: String?): String = input\n        ?.map { \"\\\\u${it.code.toString(radix = 16).padStart(4, '0')}\" }\n        ?.joinToString(\"\") ?: \"\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207662,"user_id":null,"body":"object JavaUnicodeEncoder {\n    \n  fun decode(input:String?):String {\n      val str = input ?: \"\"\n      return str.split(\"\\\\u\").filter{it.trim().length>0}.map {\n          it.toInt(16).toChar()\n      }.joinToString(\"\")\n  }\n  \n  fun encode(input:String?):String {\n      val str = input ?: \"\"\n      return str.map {\n          \"\\\\u\" + it.toInt().toString(16).padStart(4,'0')\n      }.joinToString(\"\")\n  }\n  \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"58e77c88fd2d893a77000102":[{"id":207663,"user_id":53,"body":"package kata\n\nimport kotlin.math.max\n\nobject Kata {\n\tfun rainVolume(xs: IntArray): Int {\n\t\tif (xs.count() == 0) {\n            return 0\n        }\n        var a = 0\n        var b = 0\n        var t = 0\n        var l = 0\n        var r = xs.count() - 1\n        while (l <= r) {\n            if (a <= b) {\n                 a = Math.max(a, xs[l])\n                 t += a - xs[l]\n                 l += 1\n            } else {\n                 b = Math.max(b, xs[r])\n                 t += b - xs[r]\n                 r -= 1\n            }\n        }\n        return t\n\t}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207664,"user_id":470,"body":"package kata\n\nimport kotlin.math.max\n\nobject Kata {\n\tfun rainVolume(r: IntArray): Int {\n\t\tvar q = 0\n\t\tval maxh = r.fold(0) { m,n -> max(m,n).also { q += it - n } }\n\t\tr.reversed().fold(0) { m,n -> max(m,n).also { q -= maxh - it } }\n\t\treturn q\n\t}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207665,"user_id":null,"body":"package kata\n\nobject Kata {\n\tfun rainVolume(towers: IntArray): Int {\n        \n        if (towers.size < 3) return 0\n        \n        var reducedTowers = towers.drop(1)\n        var limit = minOf(towers[0],reducedTowers.maxOrNull()?:0)\n        var rVol: Int = 0\n        var dropCount = 0\n          \t\t    \n        for (i in 1..towers.size -2){\n            dropCount += 1\n            if (towers[i] < limit) {\n                rVol += limit - towers[i]\n            } else {\n                reducedTowers = reducedTowers.drop(dropCount)\n                dropCount = 0\n                limit = minOf(towers[i],reducedTowers.maxOrNull()?:0)\n            }\n        }\n        \n\t\treturn rVol\n\t}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207666,"user_id":null,"body":"package kata\n\nimport kotlin.math.min\nimport kotlin.math.max\n\nobject Kata {\n    \n    data class Tower(val index: Int, val height: Int)\n    \n\tfun rainVolume(towers: IntArray): Int {\n        if (towers.isEmpty()) return 0\n\n        var water = 0\n\n        val skip = towers.indices.map { false }.toMutableList()\n        fun skip(index: Int) { skip[index] = true }\n        fun isSkip(index: Int) = skip[index]\n\n        val sorted = towers.toList()\n            .mapIndexed { i, tower -> Tower(i, tower) }\n            .sortedByDescending { it.height }\n\n        var a = sorted.first()\n        sorted.drop(1).forEach { b ->\n            if (isSkip(b.index)) return@forEach\n\n            val (left, right) = listOf(a, b).sortedBy { it.index }\n            val height = min(left.height, right.height)\n\n            (left.index + 1 until right.index).forEach f@{\n                if (isSkip(it)) return@f\n                water += height - towers[it]\n                skip(it)\n            }\n\n            skip(a.index)\n            a = b\n        }\n\n        return water\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207667,"user_id":null,"body":"package kata\n\nimport kotlin.math.min\n\nobject Kata {\n    \n    \n\tfun rainVolume(towers: IntArray): Int {\n        var waterCounter = 0\n        \n        while (true) {\n            val volume = fillValley(towers)\n            if (volume == 0) break\n            waterCounter += volume\n        }\n        return waterCounter\n\t}\n    \n    fun fillValley(towers: IntArray): Int {\n        var leftWall = 0\n        var rightWall = 0\n        var result = 0\n        \n        var valleyWidth = 1\n        for (i in 1 until towers.size - 1) {\n            if (towers[i - 1] > towers[i]) leftWall = i - 1\n            \n            when {\n                towers[i] == towers[i + 1] -> valleyWidth++\n                towers[i] > towers[i + 1] -> valleyWidth = 1\n                towers[i] < towers[i + 1] -> {\n                    rightWall = i + 1\n                    val depth = getValleyDepth(\n                        towers[leftWall],\n                        towers[i],\n                        towers[rightWall]\n                    )\n                    \n                    if (depth == 0) continue\n                    \n                    for (j in (leftWall + 1) until rightWall) {\n                        towers[j] += depth\n                        result += depth\n                    }\n                }\n            }\n        }\n        \n        return result\n    }\n    \n    fun getValleyDepth(leftWall: Int, deep: Int, rightWall: Int): Int {\n        val depth = min(leftWall, rightWall) - deep\n        return if (depth > 0) depth else 0\n    }\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207668,"user_id":1251,"body":"object Kata {\n    fun rainVolume(towers: IntArray): Int {\n        var totalVolume = 0\n        var leftBankIndex = 0\n        while (leftBankIndex < towers.size) {\n            val rightBankIndex = findNextBank(towers, leftBankIndex)\n            if (rightBankIndex != towers.size) {\n                totalVolume += findDepressionVolume(towers, leftBankIndex, rightBankIndex)\n            }\n            leftBankIndex = rightBankIndex\n        }\n        return totalVolume\n\t}\n\n    private fun findNextBank(towers: IntArray, leftBankIndex: Int): Int {\n        val remainingTowers = towers.slice(leftBankIndex + 1..towers.size - 1)\n        val remainingTowersPeak = remainingTowers.firstOrNull { it >= towers[leftBankIndex] }\n        if (remainingTowersPeak != null) return remainingTowers.indexOf(remainingTowersPeak) + leftBankIndex + 1\n        val remainingTowersMax = remainingTowers.maxOrNull()\n        if (remainingTowersMax != null) return remainingTowers.indexOf(remainingTowersMax) + leftBankIndex + 1\n        return towers.size\n    }\n\n    private fun findDepressionVolume(towers: IntArray, leftBankIndex: Int, rightBankIndex: Int): Int {\n        val lowestBankHeight = minOf(towers[leftBankIndex], towers[rightBankIndex])\n        var totalDepressionVolume = 0\n        for (i in leftBankIndex + 1 until rightBankIndex) {\n            val depressionVolume = lowestBankHeight - towers[i]\n            if (depressionVolume > 0) totalDepressionVolume += lowestBankHeight - towers[i]\n        }\n        return totalDepressionVolume\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"58f5c63f1e26ecda7e000029":[{"id":207669,"user_id":null,"body":"fun wave(str: String) = str.indices.map { str.take(it) + str.drop(it).capitalize() }.filter { it != str }","lang_id":29,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207670,"user_id":null,"body":"fun wave(str: String): List<String> =\n        str.withIndex()\n                .filter { (_, c) -> !c.isWhitespace() }\n                .map { (index, c) -> str.replaceRange(index, index + 1, c.toUpperCase().toString()) }\n                .toList()","lang_id":29,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207671,"user_id":null,"body":"fun wave(str: String) = str.mapIndexedNotNull { i, c -> if (c == ' ') null else str.take(i) + str.drop(i).capitalize() }","lang_id":29,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207672,"user_id":null,"body":"fun wave(str: String): List<String> {\n    return str.mapIndexedNotNull { i, char ->\n        if(char.isWhitespace()) {\n            null\n        } else {\n            str.substring(0 until i) + char.uppercaseChar() + str.substring(i + 1 until str.length)\n        }\n    }\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207673,"user_id":null,"body":"fun wave(str: String): List<String> {\n    val res = arrayListOf<String>()\n    for (i in str.indices) {\n        if (str[i].isLetter()){\n            val s = str.toCharArray().toMutableList()\n            s[i] = str[i].toUpperCase()\n            res.add(s.joinToString(\"\"))\n        }\n    }\n    return res\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207674,"user_id":null,"body":"fun wave(str: String): List<String> = str.mapIndexed {i, _-> str.take(i) + str.drop(i).capitalize() }.filter { it != str }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207675,"user_id":null,"body":"fun wave(str: String): List<String> = str.toCharArray().toList().mapIndexed { index, el -> str.substring(0, index) + el.toUpperCase() + str.substring(index + 1) }.filter { it != str }\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207676,"user_id":null,"body":"    fun wave(str: String): List<String?> {\n        var list: MutableList<String> = arrayListOf()\n\n        var str2 = str.lowercase()\n\n        for ((i, value) in str.withIndex()) {\n           if (value.toString() == \" \") continue\n\n            var word = \"\"\n            for ((index, value) in str2.withIndex()) {\n                if (index == i) {\n                    var value2 = value.uppercaseChar()\n                    word += value2.toString()\n                } else {\n                    word += value.toString()\n                }\n            }\n            list.add(word)\n        }\n        list\n        return list\n    }\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207677,"user_id":null,"body":"fun wave(str: String): List<String> {\n    val changableList   = str.lowercase().toMutableList()\n    val resultList: MutableList<String> = mutableListOf()\n\n    for(index in changableList.indices){\n       if (changableList[index].isLetter()) {\n           changableList[index] = changableList[index].toUpperCase()\n           resultList.add(String(changableList.toCharArray()))\n           changableList[index] = changableList[index].toLowerCase()\n       }\n    }\n    return resultList.toList()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207678,"user_id":null,"body":"fun wave(str: String): List<String> {    \n    val result = mutableListOf<String>()\n\n    str.forEachIndexed { index1, c1 ->\n        if (!c1.isWhitespace()) {\n            result += str.mapIndexed { index2, c2 ->\n                if (index1 == index2) c2.uppercaseChar() else c2\n            }.joinToString(\"\")    \n        }    \n    }\n        \n    return result    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"590ba2baf06c49595f0000a0":[{"id":207679,"user_id":null,"body":"\nfun log(complex: DoubleArray): DoubleArray {\n    return doubleArrayOf(Math.log(mod(complex)), arg(complex))\n}\n\nfun mod(complex: DoubleArray): Double {\n    if (complex[0]!=0.0 || complex[1]!=0.0) {\n        return Math.sqrt(complex[0]*complex[0]+complex[1]*complex[1])\n    }\n    throw ArithmeticException()\n}\n\nfun arg(complex: DoubleArray): Double {\n    return Math.atan2(complex[1],complex[0])\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207680,"user_id":null,"body":"fun log(complex: DoubleArray): DoubleArray {\n  val x = complex[0]; val y = complex[1]\n  if (x==0.0 && y==0.0) throw ArithmeticException(\"\") \n  return doubleArrayOf(Math.log(Math.hypot(x, y)), Math.atan2(y, x))  \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207681,"user_id":null,"body":"fun log(complex: DoubleArray): DoubleArray {\n  val (x,y) = complex\n  \n  if (x == 0.0 && y == 0.0)\n    throw ArithmeticException()\n  \n  return doubleArrayOf(Math.log(Math.sqrt(x*x + y*y)), Math.atan2(y, x))\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207682,"user_id":null,"body":"import kotlin.math.atan2\nimport kotlin.math.hypot\nimport kotlin.math.ln\n\nfun log(complex: DoubleArray): DoubleArray {\n    if (complex[0] == 0.0 && complex[1] == 0.0) throw ArithmeticException()\n    return doubleArrayOf(ln(hypot(complex[0], complex[1])), atan2(complex[1], complex[0]))\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207683,"user_id":null,"body":"fun log(complex: DoubleArray): DoubleArray =\n    if (complex[0] == 0.0 && complex[1] == 0.0)\n        throw ArithmeticException()\n    else\n        doubleArrayOf(\n            Math.log(Math.sqrt(complex[0] * complex[0] + complex[1] * complex[1])),\n            Math.atan2(complex[1], complex[0])\n        )","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207684,"user_id":492,"body":"fun log(z: DoubleArray): DoubleArray {\n   val x = z[0]\n    val y = z[1]\n    if (x == 0.0 && y == 0.0) {\n        throw ArithmeticException()\n    }\n    val mag = Math.sqrt(x * x + y * y)\n    val arg = Math.atan2(y, x)\n    return doubleArrayOf(Math.log(mag), arg)\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207685,"user_id":null,"body":"fun log(complex: DoubleArray): DoubleArray {\n   val real = complex[0]\n   val imag = complex[1]\n   \n   if (real == 0.0 && imag == 0.0) throw ArithmeticException()\n   \n   val r = Math.log(Math.sqrt(real * real + imag * imag))\n   val theta = Math.atan2(imag, real)\n   \n   return doubleArrayOf(r, theta)\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207686,"user_id":null,"body":"import kotlin.math.*\n\nfun log(complex: DoubleArray): DoubleArray {\n  val x = complex[0]\n  val y = complex[1]\n  if (x == 0.0 && y == 0.0)\n    throw ArithmeticException()\n  var r = sqrt(x*x + y*y)\n  var theta = atan2(y, x)\n  return doubleArrayOf(ln(r),theta)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207687,"user_id":null,"body":"import kotlin.math.*\n\nfun log(complex: DoubleArray): DoubleArray {\n  val x = complex[0]\n  val y = complex[1]\n  var r = sqrt(x*x + y*y)\n  var theta = when {\n    x == 0.0 && y == 0.0 -> throw ArithmeticException()\n    x == 0.0 -> sign(y) * PI \/ 2\n    x > 0.0 -> 2 * atan(y \/ (r + x))\n    x < 0.0 && y == 0.0 -> PI\n    x < 0.0 -> 2 * atan((r - x) \/ y)\n    else -> throw ArithmeticException()\n  }\n  return doubleArrayOf(ln(r),theta)\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207688,"user_id":null,"body":"fun log(complex: DoubleArray): DoubleArray {\n    val r = complex[0] * complex[0] + complex[1] * complex[1]\n    val phi = Math.atan2(complex[1], complex[0])\n    return if (r > 0) doubleArrayOf(Math.log(r) \/ 2, phi) else throw ArithmeticException()\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"59342039eb450e39970000a6":[{"id":207689,"user_id":null,"body":"fun odd_count(n: Int) = n \/ 2","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207690,"user_id":null,"body":"fun odd_count(n: Int): Int {\n        if(n % 2 != 0){\n            return (n-1)\/2\n        }else{\n            return (n\/2)\n        }\n}","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207691,"user_id":null,"body":"fun odd_count(n: Int) = n shr 1","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207692,"user_id":null,"body":"fun odd_count(n: Int): Int {\n  \/\/ your code here\n    if(n % 2 == 0){\n        return n\/2\n    }\n    else{\n        return (n-1)\/2\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207693,"user_id":null,"body":"fun odd_count(n: Int): Int {\n    var d = n\/2\n    return d\n }\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207694,"user_id":null,"body":"fun odd_count(n: Int): Int {\n  return (n-n%2)\/2\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207695,"user_id":null,"body":"fun odd_count(n: Int): Int {\n    var odd = 1\n    var count = 0\n    while (odd < n) {\n        odd += 2\n        count++\n    }\n    return count\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207696,"user_id":null,"body":"fun odd_count(n: Int): Int = n \/ 2\n\n\/\/ \u0421\u043d\u0430\u0447\u0430\u043b\u0430 \u044f \u043f\u0440\u043e\u0431\u043e\u0432\u0430\u043b \u0440\u0435\u0448\u0438\u0442\u044c \u0447\u0435\u0440\u0435\u0437 \u0446\u0438\u043a\u043b, \u043d\u043e \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043f\u043e \u0432\u0440\u0435\u043c\u0435\u043d\u0438 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u043d\u0435 \u0437\u0430\u0441\u0447\u0438\u0442\u0430\u043b\u0430 \u0437\u0430 \u0432\u0435\u0440\u043d\u043e\u0435 \u0440\u0435\u0448\u0435\u043d\u0438\u0435\n\/\/ \u0417\u0430\u0442\u0435\u043c \u0437\u0430\u043c\u0435\u0442\u0438\u043b \u0437\u0430\u043a\u043e\u043d\u043e\u043c\u0435\u0440\u043d\u043e\u0441\u0442\u044c, \u0447\u0442\u043e \u043c\u043e\u0436\u043d\u043e \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043d\u0435\u0447\u0435\u0442\u043d\u044b\u0445 \u0447\u0438\u0441\u0438\u0435\u043b \u0434\u043e \u0447\u0438\u0441\u043b\u0430 \u043c\u043e\u0436\u043d\u043e \u0443\u0437\u043d\u0430\u0442\u044c (n-1)\/2\n\/\/ \u041d\u043e \u0437\u0434\u0435\u0441\u044c \u0432\u043e\u0437\u043d\u0438\u043a\u043b\u0430 \u043f\u0440\u043e\u0431\u043b\u0435\u043c\u0430, \u0447\u0442\u043e \u0435\u0441\u043b\u0438 \u0434\u0430\u0435\u0442\u0441\u044f \u043f\u043e\u043b\u043e\u0436\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0435 \u0447\u0438\u0441\u043b\u043e, \u0437\u043d\u0430\u0447\u0438\u0442 \u0432\u044b\u0447\u0438\u0442\u0430\u0442\u044c \u0435\u0434\u0438\u043d\u0438\u0446\u0443 \u0438 \u043d\u0435 \u043d\u0443\u0436\u043d\u043e, \n\/\/ \u0442.\u043a \u044f\u0437\u044b\u043a \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438 \u043e\u043a\u0440\u0443\u0433\u043b\u044f\u0435\u0442","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207697,"user_id":null,"body":"fun odd_count(n: Int) = if(n < 1) 0 else n \/ 2","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207698,"user_id":null,"body":"fun odd_count(n: Int): Int {\n    return Math.floor(n\/2.0).toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5936371109ca68fe6900000c":[{"id":207699,"user_id":null,"body":"fun parseNumber(number: String): String {\n    val binaryRepresentation = if (number.all { c -> c == '1' || c == '0' }) number else\n        \"%32s\".format(number.toLong().toString(2)).replace(' ', '0')\n    return binaryRepresentation\n            .chunked(8).map { part -> part.toInt(2) }.joinToString(\".\")\n}\n\nfun parseIp(ip: String): String {\n    return ip.split('.').map { part -> part.toInt().toString(2) }\n            .joinToString(\"\") { part -> \"%8s\".format(part).replace(' ', '0') }\n            .toLong(2)\n            .toString()\n}\n\nfun numberAndIPaddress(s: String): String = if (s.split('.').size > 1) {\n    parseIp(s)\n} else {\n    parseNumber(s)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207700,"user_id":1228,"body":"fun numberAndIPaddress(s: String) =\n    if ('.' in s) {\n        s.split(\".\").map(String::toLong).mapIndexed { index, it ->\n            it shl (24 - 8 * index)\n        }.reduce { acc, i -> acc + i }.toString()\n    } else {\n        val i = s.toLong()\n\t\t3.downTo(0).joinToString(\".\"){ (i shr 8*it and 255).toString() }\t\t\n\t}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207701,"user_id":null,"body":"fun numberAndIPaddress(s: String): String {\n  if (s.contains('.')) {\n      return s.split(\".\").joinToString(\"\") {it -> it.toInt().toString(2).padStart(8,'0')}.toLong(2).toString()\n  } else {\n      return s.toLong().toString(2).padStart(32,'0').chunked(8).joinToString(\".\") {it -> it.toInt(2).toString()}\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207702,"user_id":null,"body":"fun numberAndIPaddress(s: String): String {\n    return if (s.contains('.')) {\n        s.split('.').map { it.toUInt() }.reduce { l, r -> l.shl(8).or(r) }.toString()\n    } else {\n        s.toUInt().let { \"${it shr 24}.${it shr 16 and 255u}.${it shr 8 and 255u}.${it and 255u}\" }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207703,"user_id":null,"body":"fun numberAndIPaddress(s: String): String {\n    return if (s.contains('.')) {\n        s.split('.').map { it.toUInt() }.reduce { l, r -> l.shl(8).or(r) }.toString()\n    } else {\n        val toInt = s.toUInt()\n        return \"${toInt.shr(24)}.${toInt.shr(16).and(255u)}.${toInt.shr(8).and(255u)}.${toInt.and(255u)}\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207704,"user_id":null,"body":"fun numberAndIPaddress(s: String): String = when {\n    ('.' in s) -> s.split('.')\n        .fold(0L) { acc, octet -> acc * 256 + octet.toLong() }\n        .toString()\n    else -> (3.downTo(0))\n        .map { s.toLong() shr 8 * it and 255 }\n        .joinToString(\".\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207705,"user_id":null,"body":"fun numberAndIPaddress(s: String): String =\n    if (s.contains('.')) {\n        s.split('.')\n            .joinToString(\"\") { it.toInt().toString(2).padStart(8, '0') }\n            .toLong(2).toString()\n    } else {\n        s.toLong().toString(2).padStart(32, '0')\n            .chunked(8)\n            .map { it.toInt(2) }\n            .joinToString(\".\")\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207706,"user_id":null,"body":"import kotlin.math.pow\n\nfun numberAndIPaddress(s: String) =\n    if (s.contains('.')) {\n        s.split('.').mapIndexed { i, n ->\n            n.toLong() * 256.toDouble().pow(3 - i).toInt()\n        }.sum().toString()\n    } else {\n        (0..3).map {\n            (s.toLong() \/ 256.toDouble().pow(it).toInt()) % 256\n        }.reversed().joinToString(\".\")\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207707,"user_id":null,"body":"fun numberAndIPaddress(s: String) =\n    if (s.contains('.')) s.split(\".\").joinToString(\"\") { it.toInt().toString(2).padStart(8, '0') }.toBigInteger(2).toString()\n    else s.toBigInteger().toString(2).padStart(32, '0').chunked(8).map { it.toInt(2) }.joinToString(\".\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207708,"user_id":null,"body":"fun numberAndIPaddress(s: String): String {\n    \n   return if (s.contains(\".\")) s.split(\".\").joinToString(\"\") { it.toLong().toString(2).padStart(8, '0') }.toLong(2)\n        .toString() else Array(4) { i ->\n        s.toLong().toString(2).padStart(32, '0').substring(i * 8, i * 8 + 8).toInt(2)\n    }.joinToString(\".\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"59377c53e66267c8f6000027":[{"id":207709,"user_id":null,"body":"fun alphabetWar(fight: String): String {\n    val forces = mapOf('w' to 4, 'p' to 3, 'b' to 2, 's' to 1, 'm' to -4, 'q' to -3, 'd' to -2, 'z' to -1)\n    val result = fight.sumBy { forces.getOrDefault(it, 0) }\n    return when {\n        result > 0 -> \"Left side wins!\"\n        result < 0 -> \"Right side wins!\"\n        else -> \"Let's fight again!\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207710,"user_id":null,"body":"fun alphabetWar(fight: String): String {\n    val left = fight.filter { it in \"wpbs\" }.sumBy {\n        when (it) {\n            'w' -> 4\n            'p' -> 3\n            'b' -> 2\n            's' -> 1\n            else -> 0\n        }\n    }\n    val right = fight.filter { it in \"mqdz\" }.toCharArray().sumBy {\n        when (it) {\n            'm' -> 4\n            'q' -> 3\n            'd' -> 2\n            'z' -> 1\n            else -> 0\n        }\n    }\n\n    return if (left > right) \"Left side wins!\" else if (right> left) \"Right side wins!\" else \"Let's fight again!\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207711,"user_id":null,"body":"const val left = \"zdqm\"\nconst val right = \"sbpw\"\n\nfun String.getPowerByIndex(values: String): Int {\n    return this.sumBy { values.indexOf(it) + 1 }\n}\n\nfun alphabetWar(fight: String): String {\n    val result = fight.getPowerByIndex(left) - fight.getPowerByIndex(right)\n    return when {\n        result == 0 -> \"Let's fight again!\"\n        result < 0 -> \"Left side wins!\"\n        else -> \"Right side wins!\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207712,"user_id":null,"body":"\nprivate const val leftSide = \"sbpw\"\nprivate const val rightSide = \"zdqm\"\n\nfun alphabetWar(fight: String): String {\n    val power = fight.sumBy { char -> (leftSide.indexOf(char) + 1) - (rightSide.indexOf(char) + 1) }\n    return when {\n        power > 0 -> \"Left side wins!\"\n        power < 0 -> \"Right side wins!\"\n        else -> \"Let's fight again!\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207713,"user_id":null,"body":"fun alphabetWar(fight: String): String {\n\tvar score = 0\n\n    for (letter in fight) {\n\t\tif (letter == 'w') score -= 4\n\t\tif (letter == 'p') score -= 3\n\t\tif (letter == 'b') score -= 2\n\t\tif (letter == 's') score -= 1\n\t\tif (letter == 'm') score += 4\n\t\tif (letter == 'q') score += 3\n\t\tif (letter == 'd') score += 2\n\t\tif (letter == 'z') score += 1\n\t}\n\n    if (score < 0) return \"Left side wins!\"\n    else if (score > 0) return  \"Right side wins!\"\n    else return \"Let's fight again!\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207714,"user_id":null,"body":"fun alphabetWar(fight: String): String {\n\n    val leftSide = mapOf('w' to 4, 'p' to 3, 'b' to 2, 's' to 1)\n    val rightSide = mapOf('m' to 4, 'q' to 3, 'd' to 2, 'z' to 1)\n\n    val leftSideScore = fight.toCharArray().sumOf { leftSide.getOrDefault(it, 0) }\n    val rightSideScore = fight.toCharArray().sumOf { rightSide.getOrDefault(it, 0) }\n\n    return when {\n        leftSideScore > rightSideScore -> \"Left side wins!\"\n        rightSideScore > leftSideScore -> \"Right side wins!\"\n        else -> \"Let's fight again!\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207715,"user_id":null,"body":"fun alphabetWar(fight: String) = fight.fold(0) { a, c -> a + when (c) {'w' -> 4; 'p' -> 3; 'b' -> 2; 's' -> 1; 'm' -> -4; 'q' -> -3; 'd' -> -2; 'z' -> -1; else -> 0 } }\n    .let { if (it > 0) \"Left side wins!\" else if (it < 0) \"Right side wins!\" else \"Let's fight again!\" }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207716,"user_id":null,"body":"fun alphabetWar(fight: String): String {\n    \n   val ret = arrayOf(\n       \"Let's fight again!\",\n       \"Left side wins!\",\n       \"Right side wins!\"\n   )\n   \n   val m: Map<Char, Int> = mapOf(\n       'w' to 4,\n       'p' to 3,\n       'b' to 2,\n       's' to 1,\n       'm' to -4,\n       'q' to -3,\n       'd' to -2,\n       'z' to -1\n   )\n   \n   var balance: Int = 0\n   fight.forEach {\n       balance += m[it] ?: 0\n   }\n   \n   return when {\n       balance < 0 -> ret[2]\n       balance > 0 -> ret[1]\n       else -> ret[0]\n   }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207717,"user_id":null,"body":"fun alphabetWar(fight: String): String {\n   \/\/ code here\n    var leftSide = 0\n    var rightSide = 0\n    \n    fight.forEach{\n        when(it){\n           'w'-> leftSide +=4\n            'p'-> leftSide +=3\n            'b'->leftSide +=2\n            's'->leftSide +=1\n            'm'-> rightSide += 4\n            'q'-> rightSide += 3\n            'd'-> rightSide +=2\n            'z'-> rightSide += 1   \n        }     \n    }\n    if (leftSide > rightSide) return \"Left side wins!\"\n    else if (rightSide > leftSide) return \"Right side wins!\"\n    else return \"Let's fight again!\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207718,"user_id":null,"body":"fun alphabetWar(fight: String): String {\n    var right = 0\n    var left = 0\n    for (i in fight) {\n        when (i) {\n            'w' -> left += 4\n            'p' -> left += 3\n            'b' -> left += 2\n            's' -> left += 1\n\n            'm' -> right +=  4\n            'q' -> right +=  3\n            'd' -> right +=  2\n            'z' -> right +=  1\n        }\n    }\n\n    val res = when {\n        right > left    -> \"Right side wins!\"\n        right < left    -> \"Left side wins!\"\n        else            -> \"Let's fight again!\" \n    }\n    return res\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5938f5b606c3033f4700015a":[{"id":207719,"user_id":null,"body":"fun alphabetWar(s: String) = s.bombsApplied().reducedToScore().decideWinner()\n\nprivate fun String.bombsApplied() = replace(Regex(\"\"\"\\w?\\*\\w?\"\"\"), \"\")\nprivate const val sides = \"wpbs*zdqm\"\nprivate fun String.reducedToScore() = filter{ it in sides }.map{ sides.indexOf(it) - 4 }.sum()\nprivate fun Int.decideWinner() = when {\n  this < 0 -> \"Left side wins!\"\n  this > 0 -> \"Right side wins!\"\n  else -> \"Let's fight again!\"\n}\n  ","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207720,"user_id":null,"body":"fun alphabetWar(fight: String): String {\n    val forces = mapOf('w' to 4, 'p' to 3, 'b' to 2, 's' to 1, 'm' to -4, 'q' to -3, 'd' to -2, 'z' to -1)\n    val result = fight.mapIndexed { index, c -> if (c == '*' || (index - 1 >= 0 && fight[index - 1] == '*') || (index + 1 <= fight.lastIndex && fight[index + 1] == '*')) 0 else forces.getOrDefault(c, 0) }\n        .sumBy { it }\n    return when {\n        result > 0 -> \"Left side wins!\"\n        result < 0 -> \"Right side wins!\"\n        else -> \"Let's fight again!\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207721,"user_id":null,"body":"fun alphabetWar(fight: String): String {\n    val s = fight.replace(Regex(\"\"\"\\w?\\*\\w?\"\"\"), \"\")\n            .sumBy {\n                when (it) {\n                    in \"sbpw\" -> \"sbpw\".indexOf(it) + 1\n                    in \"zdqm\" -> -(\"zdqm\".indexOf(it) + 1)\n                    else -> 0\n                }\n            }\n    return when {\n        s < 0 -> \"Right side wins!\"\n        s > 0 -> \"Left side wins!\"\n        else -> \"Let's fight again!\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207722,"user_id":1228,"body":"fun String.value() = \n    filter{ it in \"wpbs*zdqm\" }\n        .map{ \"wpbs*zdqm\".indexOf(it) - 4 }\n        .sum()\n\nfun Int.outcome() = when {\n    this < 0 -> \"Left side wins!\"\n    this > 0 -> \"Right side wins!\"\n    else     -> \"Let's fight again!\"\n}\n\nfun alphabetWar(fight: String): String {\n    return fight.replace(Regex(\"\"\"\\w?\\*\\w?\"\"\"), \"\")\n        .value()\n        .outcome()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207723,"user_id":null,"body":"import kotlin.math.*\nfun alphabetWar(fight: String): String {\n\n    var winner = 0\n    for (i in fight.indices) {\n        if (fight[min(i + 1, fight.length-1)] != '*' && fight[max(i - 1, 0)] != '*') {\n            winner += when(fight[i]){\n                'w' -> 4\n                'p' -> 3\n                'b' -> 2\n                's' -> 1\n                'm' -> -4\n                'q' -> -3\n                'd' -> -2\n                'z' -> -1\n                else -> 0\n            }\n        }\n\n    }\n    return if(winner > 0) {\n        \"Left side wins!\"\n    } else if(winner < 0){\n        \"Right side wins!\"\n    } else{\n        \"Let's fight again!\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207724,"user_id":null,"body":"\nfun alphabetWar(fight: String): String {\n    var counterLeft = 0\n    var counterRight = 0\n    lateinit var count: String \/\/var for return\n    var kek = fight.toCharArray()\n     for (i in kek.indices){\n        if (kek[i] == '*'){\n          kek[i] = '-';\n\n          if (i-1 >= 0 && kek[i-1] != '*')\n            kek[i-1] = '-';\n\n          if (i+1 < kek.size && kek[i+1] != '*')\n            kek[i+1] = '-';\n        }\n      }\n    for(i in kek){\n            if(i == 'w'){\n                counterLeft = counterLeft + 4\n            } else if(i == 'p'){\n                counterLeft = counterLeft + 3\n            } else if(i == 'b'){\n                counterLeft = counterLeft + 2\n            } else if(i == 's'){\n                counterLeft = counterLeft + 1\n            } else if(i == 'm'){\n                counterRight = counterRight + 4\n            } else if(i == 'q'){\n                counterRight = counterRight + 3\n            } else if(i == 'd'){\n                counterRight = counterRight + 2\n            } else if(i == 'z'){\n                counterRight = counterRight + 1\n            } else if(i == '-') {\n                counterRight = counterRight + 0\n            } else if(i =='-') {\n                counterLeft = counterLeft + 0\n            }\n    }\n    if(counterLeft > counterRight){\n        count = \"Left side wins!\"\n    } else if(counterLeft < counterRight){\n        count = \"Right side wins!\"\n    } else if(counterLeft == counterRight) {\n        count = \"Let's fight again!\"\n    }\n    return count\n}\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207725,"user_id":null,"body":"fun alphabetWar(fight: String): String {\n    val map = mapOf(\n        's' to 1,\n        'b' to 2,\n        'p' to 3,\n        'w' to 4,\n        'z' to -1,\n        'd' to -2,\n        'q' to -3,\n        'm' to -4\n    )\n\n    var solution = 0\n\n    fight.forEachIndexed { i, char ->\n        if (char != '*') {\n            if (fight.getOrNull(i - 1) == '*' || fight.getOrNull(i + 1) == '*') return@forEachIndexed\n            solution += (map.getOrDefault(char, 0) )\n        }\n    }\n\n    if (solution > 0) {\n        return \"Left side wins!\"\n    }\n\n    if (solution < 0) {\n        return \"Right side wins!\"\n    }\n\n    return \"Let's fight again!\"\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207726,"user_id":null,"body":"fun alphabetWar(fight: String): String {\n    var warzone = fight.toMutableList()\n    fight.toList().forEachIndexed { pos, el ->\n        if (el == '*') {\n            try {\n                warzone[pos - 1] = '-'\n            }\n            catch (exception: Exception) {\n            }\n            try {\n                warzone[pos + 1] = '-'\n            }\n            catch (exception: Exception) {\n            }\n        }\n    }\n\n    var leftTotal = 0\n    var rightTotal = 0\n\n    warzone.forEach { el ->\n        when (el) {\n            'w' -> leftTotal += 4\n            'p' -> leftTotal += 3\n            'b' -> leftTotal += 2\n            's' -> leftTotal += 1\n            \/\/\n            'm' -> rightTotal += 4\n            'q' -> rightTotal += 3\n            'd' -> rightTotal += 2\n            'z' -> rightTotal += 1\n        }\n    }\n\n    if (leftTotal > rightTotal)\n        return \"Left side wins!\"\n    else if (rightTotal > leftTotal)\n        return \"Right side wins!\"\n    else\n        return \"Let's fight again!\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207727,"user_id":null,"body":"fun alphabetWar(fight: String): String {\n    val result = fight.replace(Regex(\"[a-z]?\\\\*+[a-z]?\"), \"\").sumBy {\n          when(it){\n            'w' -> 4\n            'p' -> 3\n            'b' -> 2\n            's' -> 1\n            'm' -> -4\n            'q' -> -3\n            'd' -> -2\n            'z' -> -1\n            else -> 0\n        }\n    }\n\n    return when{\n        result > 0 -> \"Left side wins!\"\n        result < 0 -> \"Right side wins!\"\n        else -> \"Let's fight again!\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207728,"user_id":null,"body":"fun alphabetWar(fight: String): String {\n    val rightSide = mapOf('m' to 4, 'q' to 3, 'd' to 2, 'z' to 1)\n    val leftSide = mapOf('w' to 4, 'p' to 3, 'b' to 2, 's' to 1)\n\n    val stringWithoutBombs = fight.replace(Regex(\"\"\"\\w?\\*+\\w?\"\"\"), \"\")\n\n    val rightPower = stringWithoutBombs.filter { it in rightSide }.mapNotNull { rightSide[it] }.sum()\n    val leftPower = stringWithoutBombs.filter { it in leftSide }.mapNotNull { leftSide[it] }.sum()\n\n    return if (rightPower > leftPower) {\n        \"Right side wins!\"\n    } else if (leftPower > rightPower) {\n        \"Left side wins!\"\n    } else {\n        \"Let's fight again!\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"593ff8b39e1cc4bae9000070":[{"id":207729,"user_id":null,"body":"val m = mutableMapOf<Pair<String,String>,String>()\n\nfun lcs(a: String, b: String): String {\n  if (a.isEmpty() || b.isEmpty())\n    return \"\"\n  if (a.first() == b.first())\n    return a.first() + lcs(a.drop(1),b.drop(1))\n  val s1 = m.getOrPut(a to b.drop(1)) { lcs(a,b.drop(1)) }\n  val s2 = m.getOrPut(a.drop(1) to b) { lcs(a.drop(1),b) }\n  return if (s1.length > s2.length) s1 else s2\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207730,"user_id":100,"body":"import kotlin.collections.HashMap\n\nval cache: MutableMap<Pair<String, String>, String> = HashMap()\n\nfun lcs(a: String, b: String): String {\n    if (a.isEmpty() || b.isEmpty()) return \"\"\n\n    val current = Pair(a, b)\n    if (cache.containsKey(current)) return cache[current].orEmpty()\n\n    val result = if (a.last() == b.last()) {\n        lcs(a.dropLast(1), b.dropLast(1)) + a.last()\n    } else {\n        val s1 = lcs(a.dropLast(1), b)\n        val s2 = lcs(a, b.dropLast(1))\n        if (s1.length > s2.length) s1 else s2\n    }\n\n    cache[current] = result\n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207731,"user_id":null,"body":"private val memo = mutableMapOf<Pair<String, String>, String>()\n\nfun lcs(a: String, b: String): String {\n    val key = a to b\n    if (key in memo) {\n        return memo.getValue(key)\n    } else {\n        val res = when {\n            a.length == 0 -> \"\"\n            b.length == 0 -> \"\"\n            a.last() == b.last() -> lcs(a.dropLast(1), b.dropLast(1)) + a.last()\n            else -> maxOf(\n                lcs(a.dropLast(1), b),\n                lcs(a, b.dropLast(1)),\n                compareBy { it.length }\n            )\n        }\n        memo[key] = res\n        return res\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207732,"user_id":null,"body":"fun lcs(x: String, y: String): String {\n    val xLength = x.length\n    val yLength = y.length\n    val matrix = Array(xLength + 1) { IntArray(yLength + 1) }\n    for (i in 1..xLength) {\n        for (j in 1..yLength) {\n            if (x[i - 1] == y[j - 1]) {\n                matrix[i][j] = matrix[i - 1][j - 1] + 1\n            } else {\n                matrix[i][j] = Math.max(matrix[i - 1][j], matrix[i][j - 1])\n            }\n        }\n    }\n    val result = StringBuilder()\n    var i = xLength\n    var j = yLength\n    while (i > 0 && j > 0) {\n        if (x[i - 1] == y[j - 1]) {\n            result.append(x[i - 1])\n            i--\n            j--\n        } else if (matrix[i - 1][j] > matrix[i][j - 1]) {\n            i--\n        } else {\n            j--\n        }\n    }\n    return result.reverse().toString()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207733,"user_id":null,"body":"fun lcs(a: String, b: String): String {\n    val lengths = Array(a.length+1){IntArray(b.length+1) {0}}\n\n    for (i in a.indices) for (j in b.indices)\n        if (a[i] == b[j]) lengths[i+1][j+1] = lengths[i][j] + 1;\n        else lengths[i+1][j+1] = maxOf(lengths[i+1][j], lengths[i][j+1])\n\n    return buildString {\n        var i = a.length;\n        var j = b.length;\n        while(i != 0 && j != 0) {\n            if (lengths[i][j] == lengths[i-1][j]) i--\n            else if (lengths[i][j] == lengths[i][j-1]) j--\n            else {\n                append(a[i-1])\n                i--\n                j--\n            }\n        }\n    }.reversed()\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207734,"user_id":null,"body":"import java.lang.Integer.max\n\nfun lcs(a: String, b: String): String {\n    val m = a.length\n    val n = b.length\n    return lcs(a, b, m, n)\n}\n\nfun lcs(x: String, y: String, m: Int, n: Int): String {\n    val l = Array(m + 1) { IntArray(n + 1) }\n\n    for (i in 0..m) {\n        for (j in 0..n) {\n            if (i == 0 || j == 0)\n                l[i][j] = 0\n            else if (x[i - 1] == y[j - 1])\n                l[i][j] = l[i - 1][j - 1] + 1\n            else\n                l[i][j] = max(l[i - 1][j], l[i][j - 1])\n        }\n    }\n\n    var index = l[m][n]\n    val temp = index\n    val lcs = CharArray(index + 1)\n    lcs[index] = '\\u0000'\n\n    var i = m\n    var j = n\n\n    while (i > 0 && j > 0) {\n        if (x[i - 1] == y[j - 1]) {\n            lcs[index - 1] = x[i - 1]\n            i--\n            j--\n            index--\n        }\n        else if (l[i - 1][j] > l[i][j - 1])\n            i--\n        else\n            j--\n    }\n    return getString(temp, lcs)\n}\n\nprivate fun getString(temp: Int, lcs: CharArray): String {\n    val sb = StringBuilder()\n    for (k in 0..temp) {\n        sb.append(lcs[k])\n    }\n    return sb.deleteCharAt(temp).toString()\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207735,"user_id":null,"body":"var maxString:String=\"\"\nvar currentString:String=\"\"\nvar aString:String=\"\"\n\n\nfun lcsInside(nextPairs:List<Pair<Int,Int>>){   \n   \tnextPairs.forEach{currentPair->   \n        \tcurrentString+=aString[currentPair.first]\n        \tif (maxString.length<currentString.length)\n        \t\tmaxString=currentString\n        \tval pairs=nextPairs.filter{(it.first>currentPair.first)&&(it.second>currentPair.second)}\n            if (currentString.length+pairs.size>maxString.length)\n        \t\tlcsInside(pairs)        \n        \tcurrentString=currentString.dropLast(1)\n    }\n}\n\nfun lcs(a: String, b: String): String {\n    aString=a\n    maxString=\"\"\n    currentString=\"\"\n    var pairs:MutableList<Pair<Int,Int>> = mutableListOf()\n    a.toList().forEachIndexed{aInd, aChar ->\n        b.toList().forEachIndexed{bInd, bChar->\n            if (aChar==bChar)\n            \tpairs.add(Pair(aInd, bInd))\n        }\n    }\n    lcsInside(pairs)   \n    return maxString\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207736,"user_id":null,"body":"fun backtrack(builder: StringBuilder, arr: Array<IntArray>, a: String, b: String, i: Int, j: Int) {\n    if (i == 0 || j == 0)\n        return\n\n    if (a[i - 1] == b[j - 1]) {\n        backtrack(builder, arr, a, b, i - 1, j - 1)\n        builder.append(a[i - 1])\n    } else if (arr[i][j - 1] > arr[i - 1][j]) {\n        backtrack(builder, arr, a, b, i, j - 1)\n    } else {\n        backtrack(builder, arr, a, b, i - 1, j)\n    }\n}\n\nfun lcs(a: String, b: String): String {\n    val arr = Array(a.length + 1) { IntArray(b.length + 1) }\n\n    for (i in a.indices) {\n        for (j in b.indices) {\n            if (a[i] == b[j])\n                arr[i + 1][j + 1] = arr[i][j] + 1\n            else\n                arr[i + 1][j + 1] = maxOf(arr[i + 1][j], arr[i][j + 1])\n        }\n    }\n\n    val builder = StringBuilder()\n    backtrack(builder, arr, a, b, a.length, b.length)\n    return builder.toString()\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207737,"user_id":null,"body":"fun lcs(a: String, b: String): String {\n    if (a.isEmpty() || b.isEmpty()) { return \"\" }\n    val bySize =listOf(a, b).sortedBy { it.length }\n    val (x, y) = bySize[0] to bySize[1]\n    val res = mutableListOf<String>()\n    for (i in x.indices) {\n        val c = x[i]\n        val j = y.indexOf(c)\n        if (j != -1) {\n            res.add(c + lcs(x.substring(i + 1, x.length), y.substring(j+1, y.length)))\n        }\n    }\n    val maxLength = res.maxOfOrNull { it.length } ?: 0\n    return res.firstOrNull { it.length == maxLength } ?: \"\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207738,"user_id":null,"body":"fun lcs(s1: String, s2: String): String {\n    val dp = Array(s1.length + 1) { IntArray(s2.length + 1) }\n    for (i in 1..s1.length) {\n        for (j in 1..s2.length) {\n            if (s1[i - 1] == s2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            } else {\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    val result = StringBuilder()\n    var i = s1.length\n    var j = s2.length\n    while (i > 0 && j > 0) {\n        if (s1[i - 1] == s2[j - 1]) {\n            result.append(s1[i - 1])\n            i--\n            j--\n        } else if (dp[i - 1][j] > dp[i][j - 1]) {\n            i--\n        } else {\n            j--\n        }\n    }\n    return result.reverse().toString()\n}\n\nfun max(a: Int, b: Int): Int {\n    return if (a > b) a else b\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5943db60800cebe12000003d":[{"id":207739,"user_id":null,"body":"import java.util.Stack\nimport java.nio.ByteBuffer\nimport java.util.Arrays\n\nfun arrayIndexOutOfBound() {\n  arrayOf<Any>()[0]\n}\n\nfun negativeArraySize() {\n  Array(-1, { Any() })\n}\n\nfun noSuchElement() {\n  listOf<Any>().iterator().next()\n}\n\nfun arithmetic() {\n  5 \/ 0\n}\n\nfun classCast() {\n  Any() as String\n}\n\nfun stackOverflow() {\n  stackOverflow()\n}\n\nfun nullPointer() {\n  null!!\n}\n\nfun numberFormat() {\n  \"not a number\".toInt()\n}\n\nfun illegalArgument() {\n  numberFormat()\n}\n\nfun emptyStack() {\n  Stack<Any>().pop()\n}\n\nfun bufferOverflow() {\n  ByteBuffer.allocateDirect(0).put(byteArrayOf(1))\n}\n\nfun arrayStore() {\n  (arrayOf(\"Hello\") as Array<Any>)[0] = 1\n}\n\nfun unsupportedOperation() {\n  Arrays.asList<Any>().add(Unit)\n}\n\nfun illegalState() {\n  mutableListOf<Any>().iterator().remove()\n}\n\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207740,"user_id":null,"body":"import java.nio.IntBuffer\nimport java.util.Stack\n\nfun arrayIndexOutOfBound() {\n    Array<Unit>(0){Unit}[1]\n}\n\nfun negativeArraySize() {\n    Array<Unit>(-1){Unit}    \n}\n\nfun noSuchElement() {\n    mapOf<Int, Unit>().getValue(0)\n}\n\nfun arithmetic() {\n    1\/0\n}\n\nfun classCast() {\n    3 as String\n}\n\nfun stackOverflow() {\n    stackOverflow()\n}\n\nfun nullPointer() {\n    null!!\n}\n\nfun numberFormat() {\n    \"a\".toInt()\n}\n\nfun illegalArgument() {\n    \"1\".toInt(radix = 1)\n}\n\nfun emptyStack() {\n    Stack<Int>().peek()\n}\n\nfun bufferOverflow() {\n    IntBuffer.allocate(1).put(listOf(1,2,3,4).toIntArray())\n}\n\nfun arrayStore() {\n    val a = UByteArray(0){1.toUByte()}\n    val b = UByteArray(0){2.toUByte()}\n    System.arraycopy(a, 2, b, 0, b.size)\n}\n\nfun unsupportedOperation() {\n    (listOf<Int>(3) as MutableList<Int>).add(1)\n}\n\nfun illegalState() {\n    check(false)\n}\n\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207741,"user_id":null,"body":"import java.util.*\nimport java.nio.ByteBuffer\n\nfun arrayIndexOutOfBound() {\n    arrayOf(1)[2]\n}\n\nfun negativeArraySize() {\n    Array(-1, { -1 })\n}\n\nfun noSuchElement() {\n    emptyList<Int>().last()\n}\n\nfun arithmetic() {\n    1 \/ 0\n}\n\nfun classCast() {\n    Any() as String\n}\n\nfun stackOverflow() {\n    stackOverflow()\n}\n\nfun nullPointer() {\n    val x: String? = null\n    x!!.toString()\n}\n\nfun numberFormat() {\n    \"a\".toInt()\n}\n\nfun illegalArgument() {\n    require(false)\n}\n\nfun emptyStack() {\n    Stack<Int>().pop()\n}\n\nfun bufferOverflow() {\n    ByteBuffer.allocate(1).putInt(1)\n}\n\nfun arrayStore() {\n    val x = arrayOf(\"A\")\n    val y = arrayOf(1)\n    System.arraycopy(x, 0, y, 0, 1)\n}\n\nfun unsupportedOperation() {\n    val x: List<String> = listOf(\"A\")\n    (x as MutableList).add(\"B\")\n}\n\nfun illegalState() {\n    error(\"a\")\n}\n\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207742,"user_id":null,"body":"import java.nio.Buffer\nimport java.nio.ByteBuffer\nimport java.util.*\n\nfun arrayIndexOutOfBound() {\n    val arr = arrayOf(1)\n    val b = arr[2]\n}\n\nfun negativeArraySize() {\n    val arr = Array(-1) { 1 }\n}\n\nfun noSuchElement() {\n    val arr = arrayOf(1)\n    val b = arr.first { it == 2 }\n}\n\nfun arithmetic() {\n    val x = 1\/0\n}\n\nfun classCast() {\n    val x = Int as IntArray\n}\n\nfun stackOverflow() {\n\n    fun getNextInt(x : Int):Int{\n        return getNextInt(x)\n    }\n    val x = getNextInt(1)\n}\n\n\nfun nullPointer() {\n    val x: String? = null\n    println(x!!)\n}\n\nfun numberFormat() {\n    val x = \"a\".toInt()\n}\n\nfun illegalArgument() {\n    val x = \"a\".toInt()\n}\n\nfun emptyStack() {\n    val x = Stack<Int>()\n    val y = x.pop()\n}\n\nfun bufferOverflow() {\n    val x = ByteBuffer.allocate(0)\n    x.put(0)\n}\n\nfun arrayStore() {\n    val x = UByteArray(2)\n    val y = UByteArray(2)\n    System.arraycopy(x, 0, y, 0, 2)\n}\n\nfun unsupportedOperation() {\n    val x: MutableList<String> = Arrays.asList(\"a\", \"b\")\n    x.add(\"c\")\n}\n\nfun illegalState() {\n    val l: MutableList<Int> = ArrayList()\n    val intListIterator = l.iterator()\n    intListIterator.remove()\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207743,"user_id":null,"body":"fun arrayIndexOutOfBound() {\n    intArrayOf(1)[1]\n}\n\nfun negativeArraySize() {\n    IntArray(-1)\n}\n\nfun noSuchElement() {\n    emptyList<Int>().iterator().next()\n}\n\nfun arithmetic() {\n    1 \/ 0\n}\n\nfun classCast() {\n    \"a\" as Int\n}\n\nfun stackOverflow() {\n    stackOverflow()\n}\n\nfun nullPointer() {\n    val x: String? = null\n    x!!.length\n}\n\nfun numberFormat() {\n    \"a\".toInt()\n}\n\nfun illegalArgument() {\n    require(false)\n}\n\nfun emptyStack() {\n    java.util.Stack<Int>().pop()\n}\n\nfun bufferOverflow() {\n    java.nio.ByteBuffer.allocate(0).put(1)\n}\n\nfun arrayStore() {\n    (Array(1) { 0 } as Array<Any>)[0] = \"a\"\n}\n\nfun unsupportedOperation() {\n    (listOf(1) as MutableList).add(1)\n}\n\nfun illegalState() {\n    check(false)\n}\n\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207744,"user_id":null,"body":"import java.util.*\nimport java.sql.Time\nimport java.nio.ByteBuffer\n\nfun arrayIndexOutOfBound() {\n    Array(0) { 0 }[0]\n}\n\nfun negativeArraySize() {\n    Array(-1) { 0 }\n}\n\nfun noSuchElement() {\n    Array(0) { 0 }.iterator().next()\n}\n\nfun arithmetic() {\n    1 \/ 0\n}\n\nfun classCast() {\n    \"\" as Int\n}\n\nfun stackOverflow() {\n    stackOverflow()\n}\n\nfun nullPointer() {\n    val s: Int? = null\n    s!!\n}\n\nfun numberFormat() {\n    \"1,1\".toDouble()\n}\n\nfun illegalArgument() {\n    Time.valueOf(\"asd\")\n}\n\nfun emptyStack() {\n    Stack<Int>().peek()\n}\n\nfun bufferOverflow() {\n    ByteBuffer.allocate(1).asCharBuffer().put(\"asd\")\n}\n\nfun arrayStore() {\n    listOf(\"a\").toTypedArray().copyInto(Array<Int>(1) { 0 } as Array<Any>)\n}\n\nfun unsupportedOperation() {\n    (Arrays.asList(\"\", \"\") as java.util.List<String>).add(\"\")\n}\n\nfun illegalState() {\n    Vector<String>().iterator().remove()\n}\n\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207745,"user_id":null,"body":"import kotlin.random.asKotlinRandom\n\nfun arrayIndexOutOfBound() {\n    java.awt.Container().getComponent(1)\n}\n\nfun negativeArraySize() {\n    Array(-1) { }\n}\n\nfun noSuchElement() {\n    ArrayList<Any>().iterator().next()\n}\n\nfun arithmetic() {\n    @Suppress(\"DIVISION_BY_ZERO\")\n    0 \/ 0\n}\n\nfun classCast() {\n    arrayOf(Any(), Any()).sort()\n}\n\nfun stackOverflow() {\n    fun rec(i: Int = 0): Int {\n        return rec(i.inc())\n    }\n    rec()\n}\n\nfun nullPointer() {\n    null!!\n}\n\nfun numberFormat() {\n    \"a\".toInt()\n}\n\nfun illegalArgument() {\n    \"\".repeat(-1)\n}\n\nfun emptyStack() {\n    com.sun.org.apache.xml.internal.utils.IntStack().peek()\n}\n\nfun bufferOverflow() {\n    java.nio.IntBuffer.allocate(0).put(intArrayOf(1),0,1)\n}\n\nfun arrayStore() {\n    @Suppress(\"UNCHECKED_CAST\")\n    (arrayOf<Char>('a') as Array<Any>)[0] = 1\n}\n\nfun unsupportedOperation() {\n    kotlin.jvm.internal.MutableLocalVariableReference().get()\n}\n\nfun illegalState() {\n    generateSequence { 1 }.constrainOnce().apply {\n        iterator()\n        iterator()\n    }\n}\n\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207746,"user_id":null,"body":"import java.util.Stack\nimport java.nio.ByteBuffer\n\nfun arrayIndexOutOfBound() {\n  val a = arrayOf(1)\n  a[1]\n}\n\nfun negativeArraySize() {\n    IntArray(-1)\n}\n\nfun noSuchElement() {\n    listOf(1).first {it>1}\n}\n\nfun arithmetic() {\n    1\/0\n}\n\nfun classCast() {\n    val a:Any=1\n    a as String\n}\n\nfun stackOverflow() {\n    stackOverflow()\n}\n\nfun nullPointer() {\n    val a: Int? = if (1*0<2) null else 1\n    a!!\n}\n\nfun numberFormat() {\n    \"123.4\".toInt()\n}\n\nfun illegalArgument() {\n    requireNotNull(null)\n}\n\nfun emptyStack() {\n    Stack<String>().pop()\n}\n\nfun bufferOverflow() {\n    ByteBuffer.allocate(0).putInt(1)\n}\n\nfun arrayStore() {\n    val a = arrayOf(1) as Array<Any>\n    a[0] = \"x\"\n}\n\nfun unsupportedOperation() {\n    val l = listOf(1) as MutableList<Int>\n    l[0]=2\n}\n\nfun illegalState() {\n    checkNotNull(null)\n}\n\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207747,"user_id":null,"body":"fun arrayIndexOutOfBound() {\n    arrayOf<String>()[0]\n}\n\nfun negativeArraySize() {\n    Array<Int>(-1) { it }\n}\n\nfun noSuchElement() {\n    listOf<String>().iterator().next()\n}\n\nfun arithmetic() {\n    0\/0\n}\n\nfun classCast() {\n    \"a\" as Int\n}\n\nfun stackOverflow() {\n    stackOverflow()\n}\n\nfun nullPointer() {\n    java.lang.String(\"asd\").contains(null)\n}\n\nfun numberFormat() {\n    \"a\".toInt()\n}\n\nfun illegalArgument() {\n    java.util.Date.parse(\"asd\")\n}\n\nfun emptyStack() {\n    java.util.Stack<String>().peek()\n}\n\nfun bufferOverflow() {\n    java.nio.ByteBuffer.allocate(1).put(\"aaaaaaa\".toByteArray())\n}\n\nfun arrayStore() {\n    (arrayOf<String>(\"a\") as Array<Any>)[0] = 5\n}\n\nfun unsupportedOperation() {\n    (listOf<Int>(0) as MutableList<Int>).add(1)\n}\n\nfun illegalState() {\n    checkNotNull(null)\n}\n\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207748,"user_id":null,"body":"import java.util.*\nimport java.nio.ByteBuffer\n\nfun arrayIndexOutOfBound(){\n    arrayOf<Any>()[0]\n}\n\n\nfun negativeArraySize() {\n    Array(-1) {\n        it\n    }\n}\n\n\nfun noSuchElement() {\n    arrayOf<Any>().iterator().next()\n}\n\n\nfun arithmetic() {\n    val c = listOf<Int>()\n    1 \/ c.size\n}\n\nfun classCast() {\n    1 as String\n}\n\n\nfun stackOverflow() {\n    repeat(100) { stackOverflow() }\n}\n\n\nfun nullPointer() {\n    mapOf<Any, Any>(1 to 1)[2]!!.hashCode()\n}\n\n\nfun numberFormat() {\n    \"qwe\".toInt()\n}\n\n\nfun illegalArgument() {\n    arrayOf<Any>().drop(-1)\n} \n\n\nfun emptyStack() {\n    Stack<Int>().pop()\n}\n\n\nfun bufferOverflow() {\n    val byteBuffer = ByteBuffer.allocateDirect(10)\n    val floatBuffer = byteBuffer.asFloatBuffer()\n    floatBuffer.put(floatArrayOf(1f, 0f, 0f))\n}\n\nfun arrayStore() {\n    val arr = arrayOf(1, \"qwe\")\n    convertorObjectToString(arr)\n}\n\nfun convertorObjectToString(objArr: Array<Any>): Array<String>? {\n    return Arrays.copyOf(\n        objArr, objArr.size,\n        Array<String>::class.java\n    )\n}\n\nfun unsupportedOperation() {\n    val c = Collections.unmodifiableList(listOf<Int>())\n    c.add(1)\n}\n\nfun illegalState() {\n    val list = mutableListOf<Int>()\n    list.iterator().remove()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"59549d482a68fe3bc2000146":[{"id":207749,"user_id":470,"body":"package kata\n\nobject KataSolution {\n\tfun distributionOf(r: IntArray): Pair<Int,Int> {\n\t\tval ln = r.size\n\t\tval tome = r.asSequence()\n\t\tval ix = (1 until ln).fold(r.toMutableList()) { a,i -> tome.take(ln-i).forEachIndexed { c,v -> a[c] = Math.max(v - a[c+1], r[i+c] - a[c]) }; a }.first()\n\t\tval c = (r.sum() + ix) \/ 2\n\t\treturn c to c - ix\n\t}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207750,"user_id":527,"body":"package kata\n\nimport kotlin.math.max\n\nobject KataSolution {\n    fun distributionOf(xs: IntArray): Pair<Int, Int> {\n        val ds = xs.clone()\n        for (i in 1 until xs.size)\n            for (j in 0 until xs.size - i)\n                ds[j] = max(xs[j] - ds[j + 1], xs[j + i] - ds[j])\n        val s = xs.sum()\n        val a = (s + ds[0]) \/ 2\n        return Pair(a, s - a)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207751,"user_id":null,"body":"object KataSolution {\n    fun distributionOf(gold: IntArray): Pair<Int, Int> {\n        val arr = gold.clone()\n        val sum = gold.sum()\n\n        for (i in gold.indices.drop(1)) {\n            for (j in 0 until gold.size - i) {\n                arr[j] = maxOf(\n                    gold[j] - arr[j + 1],\n                    gold[j + i] - arr[j]\n                )\n            }\n        }\n        val a = (sum + arr.first()) \/ 2\n        val b = sum - a\n        return Pair(a, b)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207752,"user_id":null,"body":"package kata\n\nobject KataSolution {\n    fun distributionOf(g: IntArray): Pair<Int,Int> {\n        val dp = HashMap<Long, Int>()\n        fun a(l : Int, r : Int) : Int {\n            val key = g.size * l.toLong() + r - 1\n            if(!dp.contains(key)) dp.put(key, when {\n                l + 1 == r -> g[l]\n                l + 2 == r -> Math.max(g[l], g[l + 1])\n                else -> {\n                    val mid = a(l + 1, r - 1)\n                    Math.max(\n                        g[l] + Math.min(a(l + 2, r), mid),\n                        g[r - 1] + Math.min(mid, a(l, r - 2))\n                    )\n                }        \n            })\n            return dp.get(key)!!\n        }\n        val a = a(0, g.size)\n        return Pair(a, g.sum() - a)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207753,"user_id":null,"body":"package kata\n\nobject KataSolution {\n    val cache = mutableMapOf<String, String>()\n    \n    fun distributionOf(g: IntArray): Pair<Int,Int> {        \n        return bestScoreRemainingPair(g.toList())\n    }\n    \n    \n    fun bestScoreRemainingPair(g: List<Int>) : Pair<Int, Int> {\n        if(g.size == 0){\n            return Pair(0, 0)\n        }\n        \n        val key = g.joinToString(\" \")\n        cache.get(key)?.let{\n            val lst = it.split(\" \").map{ it.toInt() }\n            return Pair(lst[0], lst[1])\n        }\n        \n        val leftBestScore = bestScoreRemainingPair(g.drop(1))\n        val leftScore = Pair(leftBestScore.second + g.first(), leftBestScore.first)\n\n        val rightBestScore = bestScoreRemainingPair(g.dropLast(1))\n        val rightScore = Pair(rightBestScore.second + g.last(), rightBestScore.first)\n        \n        val best = listOf(leftScore, rightScore).maxByOrNull{ it.first - it.second } ?: Pair(0, 0)\n        cache[key] = best.toList().joinToString(\" \")\n        \n        return best\n        }\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207754,"user_id":null,"body":"package kata\n\nobject KataSolution {\n    private val resultCache = mutableMapOf<Pair<Int, Int>, Pair<Int, Int>>()\n\n    fun distributionOf(g: IntArray): Pair<Int, Int> {\n        resultCache.clear()\n        return search(g, 0, g.size)\n    }\n\n    private fun search(g: IntArray, i: Int, j: Int): Pair<Int, Int> {\n        if (j - i == 2) {\n            return if (g[i] > g[i + 1]) g[i] to g[i + 1] else g[i + 1] to g[i]\n        }\n        if (i to j in resultCache) return resultCache[i to j] ?: (0 to 0)\n        val left = search(g, i + 1, j)\n        resultCache[i + 1 to j] = left\n        val right = search(g, i, j - 1)\n        resultCache[i to j - 1] = right\n        return if (left.second + g[i] > right.second + g[j - 1]) left.second + g[i] to left.first else right.second + g[j - 1] to right.first\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207755,"user_id":null,"body":"package kata\n\nobject KataSolution {\n\n    fun distributionOf(gold: IntArray): Pair<Int,Int> {\n        var (a, b) = arrayOf(0, 0)\n        val moves = Array(gold.size) { arrayOfNulls<PotPair>(gold.size) }\n        for (x in moves.indices) {\n            for (y in moves[x].indices) {\n                moves[x][y] = PotPair()\n            }\n        }\n        for (x in gold.indices) {\n            moves[x][x]?.first = gold[x]\n            moves[x][x]?.pick = x\n        }\n        for (x in 2..gold.size) {\n            for (y in 0..gold.size - x) {\n                val z = y + x - 1\n                if (gold[y] + moves[y + 1][z]!!.second > moves[y][z - 1]!!.second + gold[z]) {\n                    moves[y][z]?.first = gold[y] + moves[y + 1][z]!!.second\n                    moves[y][z]?.second = moves[y + 1][z]!!.first\n                    moves[y][z]?.pick = y\n                } else {\n                    moves[y][z]?.first = gold[z] + moves[y][z - 1]!!.second\n                    moves[y][z]?.second = moves[y][z - 1]!!.first\n                    moves[y][z]?.pick = z\n                }\n            }\n        }\n\n        var i = 0\n        var j = gold.size - 1\n        gold.indices.forEach { it ->\n            var step = moves[i][j]!!.pick\n\n            if (it % 2 == 0) {\n                a += gold[step]\n            } else {\n                b += gold[step]\n            }\n\n            when {\n                step <= i -> i += 1\n                else -> j -= 1\n            }\n\n        }\n        return a to b\n    }\n\n    data class PotPair(\n        var first: Int = 0,\n        var second: Int = 0,\n        var pick: Int = 0\n    )\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207756,"user_id":53,"body":"package kata\n\nobject KataSolution {\n    fun distributionOf(g: IntArray): Pair<Int,Int> {\n        val n = g.size\n        val ns = g.copyOf(n)\n        var i = 1\n        while (i < n) {\n            var j = 0\n            while (j < n - i) {\n                ns[j] = Math.max(g[j]-ns[j+1], g[j+i]-ns[j])\n                j++\n            }\n            i++\n        }\n        val s = g.sum()\n        val a = (s + ns[0]) \/ 2\n        return a to s - a\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207757,"user_id":null,"body":"package kata\n\nobject KataSolution {\n    \n    fun distributionOf(g: IntArray): Pair<Int,Int> {\n            \n        val n = g.size\n        val sum = g.sum()\n        val max = g.max() ?: 0\n        \n        if (n < 3) return Pair(max, sum - max)\n        \n        val dp = Array(n) { IntArray(n) }\n        \n        fun choose(i: Int, j: Int): Int {\n        \n            if (i == j) return g[i]\n            \n            if (i + 1 == j) return maxOf(g[i], g[j])\n            \n            if (dp[i][j] == 0){\n                val first = g[i] + minOf(choose(i + 2, j), choose(i + 1, j - 1))\n                val last = g[j] + minOf(choose(i + 1, j - 1), choose(i, j - 2))\n                \n                dp[i][j] = maxOf(first, last)\n            }\n            \n            return dp[i][j]\n            \n        }    \n        \n        choose(0, n - 1)\n        \n        val playerA = dp[0][n - 1]\n        val playerB = sum - playerA\n        \n        return Pair(playerA, playerB)\n        \n    }    \n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"59590976838112bfea0000fa":[{"id":207758,"user_id":null,"body":"fun beggars(values: List<Int>, n: Int): List<Int> {\n    return (0 until n).map { values.slice(it..values.lastIndex step n).sum() }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207759,"user_id":null,"body":"fun beggars(values: List<Int>, n: Int): List<Int> = (0 until n)\n    .map { values.drop(it) }\n    .map { frame ->\n        frame\n            .windowed(1, n)\n            .sumBy { it.first() }\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207760,"user_id":null,"body":"fun beggars(values: List<Int>, n: Int): List<Int> {\n    if (n == 0) return listOf()\n    val mas = mutableListOf<Int>()\n    for (i in 0 until n) mas.add(0)\n    values.forEachIndexed { i, it ->\n        mas[i % n] += it\n    }\n    return mas\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207761,"user_id":null,"body":"fun beggars(values: List<Int>, n: Int): List<Int> {\n    val result = List(n) {0}.toMutableList()\n\n    for (beg in 1..n) {\n        val begg = beg - 1\n\n        values.forEachIndexed { index, v ->\n            if ((index == begg) || (index % n == begg)) {\n                result[begg] = result[begg] + v\n            }\n        }\n    }\n\n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207762,"user_id":null,"body":"fun beggars(values: List<Int>, n: Int): List<Int> {\n    if(n == 0 ) return emptyList()\n    var static = mutableMapOf<Int, Int>()\n    for(beg in 0 until n) {\n        static[beg] = 0\n        for((index, value) in values.withIndex()) {\n            if ((index - beg) % n == 0)\n                static[beg] = static[beg]!! + value\n        }\n    }\n    return static.map { it.value }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207763,"user_id":null,"body":"    fun beggars(values: List<Int>, n: Int): List<Int> {\n        if (n == 0) return listOf()\n        val ar = IntArray(n)\n        var count = 0\n        values.forEach {\n            ar[count] = (it + ar[count])\n            if (count < n - 1) count++ else count = 0\n        }\n\n        return ar.toList()\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207764,"user_id":932,"body":"fun beggars(values: List<Int>, n: Int)=List<Int>(n){values.filterIndexed{index,i-> index%n==it}.sum()}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207765,"user_id":null,"body":"fun beggars(values: List<Int>, n: Int): List<Int> {\n    return (1..n).map{values.slice(it-1 until values.size step n).sum()}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207766,"user_id":null,"body":"fun beggars(values: List<Int>, n: Int): List<Int> {\n\n    val result = MutableList(n) { 0 }\n    if (n > 0) values.indices.forEach {\n            result[it%result.size] += values[it]\n    }\n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207767,"user_id":null,"body":"fun beggars(values: List<Int>, n: Int): List<Int> {\n    if (n==0)\n    \treturn listOf()\n    var a = mutableListOf<Int>()\n    for(i in 1..n){\n        a.add(0)\n    }\n    var i = 0\n    var j = 0\n    while(i < values.size){\n        a[j] += values[i]\n        i++\n        j++\n        if(j == n){\n            j = 0\n        }\n    }\n    return a\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5966a52ab4f24db1800000cc":[{"id":207768,"user_id":527,"body":"object Dinglemouse {\n  fun int123(a: Int): Long {\n    return Integer.toUnsignedLong(123 - a)\n  }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207769,"user_id":191,"body":"object Dinglemouse {\n  fun int123(a: Int): Long {\n    return 0x100000000L + 123 - a\n  }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207770,"user_id":null,"body":"object Dinglemouse {\n  fun int123(a: Int) = (123L - a).takeUnless { it < 0 } ?: (Long.MAX_VALUE - a + 123L + 1)\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207771,"user_id":null,"body":"object Dinglemouse {\n  fun int123(a: Int) = (123L - a).takeIf { it >= 0 } ?: Long.MAX_VALUE -a + 124\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207772,"user_id":null,"body":"object Dinglemouse {\n  fun int123(a: Int): Long {\n    var a = a.toLong()\n    if (a <= 123) {\n        return 123 - a\n    } else {\n        if (a % 2 == 0.toLong()) {\n            return 9223372036854775807 * (a - 123)\n        } else {\n            return 9223372036854775807 * (a - 122) + 1\n        }\n    }\n  }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207773,"user_id":null,"body":"object Dinglemouse {\n  fun int123(a: Int): Long = when {\n        (a >= 0) && (a <= 123) -> 123L - a\n        (a < 0) && (a > Int.MIN_VALUE + 123) -> 123L + a * (-1)\n        (a > Int.MIN_VALUE) && (a <= Int.MIN_VALUE + 123) -> a - (Int.MIN_VALUE - 123L)\n        else -> Int.MAX_VALUE.toLong() + Int.MAX_VALUE.toLong() - (a - 125L)\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207774,"user_id":null,"body":"object Dinglemouse {\n  fun int123(a:Int):Long {\n    return (123L - a) and Long.MAX_VALUE;\n  }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207775,"user_id":null,"body":"infix operator fun Int.plus(b: NeverMinus): Long = 123L\n\nclass NeverMinus {\n  operator fun compareTo(a: Int): Int = 1\n}\n\nobject Dinglemouse {\n  fun int123(a: Int): NeverMinus {\n    return NeverMinus()\n  }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207776,"user_id":527,"body":"object Dinglemouse {\n  fun int123(a: Int): Long {\n    return 123 - a.toLong() and 0xffffffff\n  }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207777,"user_id":null,"body":"infix operator fun Int.plus(b: Any) = 123\nobject Dinglemouse {\n  fun int123(a: Int) = object : Comparable<Int> by Integer(0) {}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"597770e98b4b340e5b000071":[{"id":207778,"user_id":null,"body":"object FileNameExtractor {\n  fun extractFileName(self:String)=self.substringAfter(\"_\").substringBeforeLast(\".\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207779,"user_id":null,"body":"object FileNameExtractor {\n  fun extractFileName(dirtyFileName:String) = dirtyFileName.substringAfter(\"_\").substringBeforeLast(\".\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207780,"user_id":null,"body":"object FileNameExtractor {\n  fun extractFileName(dirtyFileName: String): String =\n    Regex(\"\"\"^\\d+_(?<fileName>.*)\\..+$\"\"\").matchEntire(dirtyFileName)!!.groups[\"fileName\"]!!.value\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207781,"user_id":null,"body":"object FileNameExtractor {\n  fun extractFileName(dirtyFile:String):String {\n    return dirtyFile\n        .replaceBefore(\"_\", \"\")\n        .replaceAfterLast(\".\", \"\")\n        .removeSurrounding(\"_\",\".\")\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207782,"user_id":null,"body":"object FileNameExtractor {\n   fun extractFileName(name: String) = name.substringAfter('_').substringBeforeLast('.')\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207783,"user_id":1381,"body":"object FileNameExtractor {\n  fun extractFileName(dirtyFileName:String):String {\n    return dirtyFileName.substring(dirtyFileName.indexOf('_') + 1, dirtyFileName.lastIndexOf('.'))\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207784,"user_id":null,"body":"object FileNameExtractor {\n  fun extractFileName(dirtyFileName: String): String {\n    return dirtyFileName.dropWhile { it != '_' }.drop(1).dropLastWhile{ it != '.'}.dropLast(1)\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207785,"user_id":null,"body":"object FileNameExtractor {\n  fun extractFileName(dirtyFileName: String): String {\n    return Regex(\"\\\\d*[_]([\\\\d\\\\w-]+[.][\\\\d\\\\w^a-z]+)\").find(dirtyFileName)?.groupValues?.last()!!\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207786,"user_id":null,"body":"object FileNameExtractor {\n    fun extractFileName(dirtyFileName: String): String {\n        return dirtyFileName.substring(\n            dirtyFileName.indexOfFirst { it == '_' } + 1,\n            dirtyFileName.indexOfLast { it == '.' })\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207787,"user_id":null,"body":"object FileNameExtractor {\n  fun extractFileName(dirtyFileName: String)  = dirtyFileName.substring(dirtyFileName.indexOf(\"_\") + 1, dirtyFileName.lastIndexOf(\".\"))\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"598d91785d4ce3ec4f000018":[{"id":207788,"user_id":null,"body":"object Solution {\n    fun nameValue(arr: Array<String>) = arr.mapIndexed { i, s -> s.replace(\" \", \"\").sumBy { it.toInt() - 96 } * (i + 1) }.toIntArray()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207789,"user_id":null,"body":"object Solution {\n    \n   fun nameValue(arr: Array<String>): IntArray{\n    val result = mutableListOf<Int>()\n    arr.forEach { str->\n        var strValue = 0\n        val res = arr.indexOf(str)+1\n        str.forEach {char->\n            ('a'..'z').zip((1..26)).forEach { pair -> if (char == pair.first){ strValue+=pair.second } }\n        }\n        result.add(strValue*res)\n    }\n    return result.toIntArray()\n}\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207790,"user_id":null,"body":"object Solution {\n    \nfun nameValue(arr: Array<String>) =\n    arr.indices.map { arr[it].replace(\" \", \"\")\n            .map{ i -> (i.toInt() - 96) % 27 * (it+1) }\n            .sum() }.toIntArray()   \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207791,"user_id":null,"body":"object Solution {\n    \n    fun nameValue(arr: Array<String>): IntArray = arr.mapIndexed { index, str ->\n            str.replace(\" \", \"\").fold(\n                initial = 0,\n                operation = { acc: Int, c: Char -> acc + (c.toInt() + 1 - 'a'.toInt()) }\n            ).times(index + 1)\n        }.toIntArray()\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207792,"user_id":2403,"body":"object Solution {\n    private val letters = ('a'..'z').toList()\n    private fun stringValue(string: String): Int = string.filter { it.isLetter() }.map { letters.indexOf(it) + 1 }.sum()\n\n    fun nameValue(arr: Array<String>): IntArray =\n        arr.mapIndexed { index, string -> (index + 1) * stringValue(string) }.toIntArray()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207793,"user_id":null,"body":"object Solution {\n    \n    fun nameValue(arr: Array<String>) =  arr.mapIndexed { index, s -> (index + 1) * s.replace(\" \", \"\")\n            .fold(0) { acc, c -> acc + (c.toLowerCase().toInt() - 96) }\n    }.toIntArray()   \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207794,"user_id":null,"body":"object Solution {\n    \n    fun nameValue(arr: Array<String>): IntArray {\n        val list = mutableListOf<Int>()\n        for (i in 0..(arr.size - 1)) {\n            var result = 0\n            for (letter in arr[i]) {\n                var num = letter.toInt() - 96\n                if (num > 0) {\n                    result += num\n                }\n            }\n            list.add(result * (i + 1))\n        }\n        return list.toIntArray()\n    }\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207795,"user_id":null,"body":"object Solution {\n    \n    fun nameValue(arr: Array<String>): IntArray {\n        \n        return arr.mapIndexed { i, s ->\n            (i + 1) * s.filter { it -> it.isLetter() }.sumBy { it -> it.toInt() - 96 }            \n        }.toIntArray()\n    }\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207796,"user_id":null,"body":"object Solution {\n    \n    fun nameValue(arr: Array<String>): IntArray = (arr.mapIndexed{index, it -> \n        (it.map { i -> \n            if(i!= ' ')1+i.toInt()-'a'.toInt()else 0 }).sum()*(index+1) }).toIntArray()\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207797,"user_id":null,"body":"object Solution {\n    \n    fun nameValue(arr: Array<String>): IntArray {\n        return arr.mapIndexed { i, a -> \n            a.split(\"\").map(::getIndex).sum() * (i + 1)\n        }.toIntArray()\n    }\n    \n    fun getIndex(item: String): Int {\n        val chars = item.toCharArray()\n        return if (chars.count() != 0) ('a'..'z').indexOf(chars.get(0)) + 1\n        else 0\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"59a9735a485a4d807f00008a":[{"id":207798,"user_id":null,"body":"import java.util.*\n\nfun interpret(e: String): String = LinkedList<Int>().work(e.toCharArray())\n\nprivate fun Deque<Int>.work(char: CharArray, size: Int = char.size) = buildString {\n    val data = object : HashMap<Int, Int>() {\n        override fun get(key: Int) = super.get(key) ?: 0\n    }\n    var p = 0\n    fun op(block: (Int) -> Int) = data[p].let { data[p] = block(it) and 0xff }\n\n    var temp = 0\n    var i = 0\n    while (i < size) {\n        when (char[i]) {\n            '+' -> op { it + 1 }\n            '-' -> op { it - 1 }\n            '>' -> p++\n            '<' -> p--\n            'c' -> temp = data[p]\n            'p' -> data[p] = temp\n            'W' -> if (data[p] != 0) push(i) else while (char[i] != 'E') i++\n            'E' -> if (data[p] != 0) i = peek() else pop()\n            'P' -> append(data[p].toChar())\n            'N' -> append(data[p])\n            'T' -> op { it * 2 }\n            'Q' -> op { it * it }\n            'U' -> op { Math.sqrt(it.toDouble()).toInt() }\n            'L' -> op { it + 2 }\n            'I' -> op { it - 2 }\n            'V' -> op { it \/ 2 }\n            'A' -> op { it + temp }\n            'B' -> op { it - temp }\n            'Y' -> op { it * temp }\n            'D' -> op { it \/ temp }\n        }\n        i++\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207799,"user_id":null,"body":"import java.util.*\n\nprivate val MOD = 256\n\nfun interpret(code: String): String {\n    val output = StringBuilder()\n    val stack = Stack<Int>()\n    val mem = mutableMapOf<Int, Int>()\n    val braces = mutableMapOf<Int, Int>()\n    var p = 0\n    var i = -1\n    var copy = 0\n\n    for (c in code.toCharArray()) {\n        i++\n        if (c == 'W') stack.push(i)\n        if (c == 'E') {\n            braces.put(i, stack.peek())\n            braces.put(stack.pop(), i)\n        }\n    }\n    i = 0\n    while (i < code.length) {\n        when (code[i]) {\n            '>' -> p++\n            '<' -> p--\n            'c' -> copy = (mem as Map<Int, Int>).getOrDefault(p, 0)\n            'p' -> mem.put(p, copy)\n            'W' -> i = if (mem.getOrDefault(p, 0) == 0) braces.getOrDefault(i, -1) else i\n            'E' -> i = if (mem.getOrDefault(p, 0) == 0) i else braces.getOrDefault(i, -1)\n            'P' -> output.append(mem.getOrDefault(p, 0).toChar())\n            'N' -> output.append(mem.getOrDefault(p, 0))\n            '+' -> mem.put(p, (mem.getOrDefault(p, 0) + 1) % MOD)\n            '-' -> mem.put(p, (mem.getOrDefault(p, 0) + MOD - 1) % MOD)\n            'L' -> mem.put(p, (mem.getOrDefault(p, 0) + 2) % MOD)\n            'I' -> mem.put(p, (mem.getOrDefault(p, 0) + MOD - 2) % MOD)\n            'T' -> mem.put(p, mem.getOrDefault(p, 0) * 2 % MOD)\n            'V' -> mem.put(p, mem.getOrDefault(p, 0) \/ 2 % MOD)\n            'Q' -> mem.put(p, mem.getOrDefault(p, 0) * mem.getOrDefault(p, 0))\n            'U' -> mem.put(p, Math.sqrt(mem.getOrDefault(p, 0).toDouble()).toInt())\n            'A' -> mem.put(p, (mem.getOrDefault(p, 0) + copy) % MOD)\n            'B' -> mem.put(p, (mem.getOrDefault(p, 0) + MOD - copy) % MOD)\n            'Y' -> mem.put(p, mem.getOrDefault(p, 0) * copy % MOD)\n            'D' -> mem.put(p, mem.getOrDefault(p, 0) \/ copy % MOD)\n        }\n        i++\n    }\n    return output.toString()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207800,"user_id":null,"body":"fun interpret(e: String): String {\n    \n    val prg = e.filter{it in \"+-><cpWEPNTQULIVABYD\"}.toCharArray()\n    val mem = mutableListOf<UByte>(0u)\n    var prg_ptr = 0\n    var mem_ptr = 0\n    var reg: UByte = 0u\n    var output = mutableListOf<String>()\n    do {\n        val cmd = prg[prg_ptr]\n        when (cmd) {\n            '+' -> mem[mem_ptr]++\n            '-' -> mem[mem_ptr]--\n            '>' -> mem_ptr = mem.moveRight(mem_ptr)\n            '<' -> mem_ptr = mem.moveLeft(mem_ptr)\n            'c' -> reg = mem[mem_ptr]\n            'p' -> mem[mem_ptr] = reg\n            'W' -> if(mem[mem_ptr].compareTo(0u)==0) prg_ptr = prg.getCorrE(prg_ptr)\n            'E' -> if(mem[mem_ptr].compareTo(0u)!=0) prg_ptr = prg.getCorrW(prg_ptr)\n            'P' -> output.add(mem[mem_ptr].toInt().toChar().toString())\n            'N' -> output.add(mem[mem_ptr].toInt().toString())\n            'T' -> mem[mem_ptr] = (mem[mem_ptr] * 2u).toUByte()\n            'Q' -> mem[mem_ptr] = (mem[mem_ptr] * mem[mem_ptr]).toUByte()\n            'U' -> mem[mem_ptr] = Math.sqrt(mem[mem_ptr].toInt().toDouble()).toInt().toUByte()\n            'L' -> mem[mem_ptr] = (mem[mem_ptr] + 2u).toUByte()\n            'I' -> mem[mem_ptr] = (mem[mem_ptr] - 2u).toUByte()\n            'V' -> mem[mem_ptr] = (mem[mem_ptr] \/ 2u).toUByte()\n            'A' -> mem[mem_ptr] = (mem[mem_ptr] + reg).toUByte()\n            'B' -> mem[mem_ptr] = (mem[mem_ptr] - reg).toUByte()\n            'Y' -> mem[mem_ptr] = (mem[mem_ptr] * reg).toUByte()\n            'D' -> mem[mem_ptr] = (mem[mem_ptr] \/ reg).toUByte()\n        }\n        prg_ptr++\n    } while(prg_ptr<prg.size)\n    \n    return output.joinToString(\"\")\n}\n\nfun MutableList<UByte>.moveRight(curInd: Int): Int {\n    val newInd = curInd + 1\n    if(newInd>=size) add(0u)\n    return newInd\n}\n\nfun MutableList<UByte>.moveLeft(curInd: Int): Int {\n    var newInd = curInd - 1\n    if(newInd<0) { add(0,0u); newInd = 0}\n    return newInd\n}\n\nfun CharArray.getCorrW(currPtr: Int): Int {\n    var moreEs = 0; var retInd = 0\n    for(ind in currPtr-1 downTo 0) {\n        when(this[ind]) {\n            'E' -> moreEs++\n            'W' -> if(moreEs>0) moreEs-- else { retInd = ind ; break }\n        }\n    }\n    return retInd\n}\n\nfun CharArray.getCorrE(currPtr: Int): Int {\n    var moreWs = 0; var retInd = 0\n    for(ind in currPtr+1..lastIndex) {\n        when(this[ind]) {\n            'W' -> moreWs++\n            'E' -> if(moreWs>0) moreWs-- else { retInd = ind; break }\n        }\n    }\n    return retInd\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207801,"user_id":null,"body":"import java.lang.Math.*\nimport java.nio.charset.Charset\n\nfun interpret(input: String): String {\n    val program = Program(input)\n    return program.run()\n}\n\nclass InfiniteMemory {\n    private var pointer = 0\n    private var clipboard = 0\n    private val cells = mutableListOf(0)\n\n    fun modify(function: (Int) -> (Int)) { cells[pointer] = floorMod(function.invoke(cells[pointer]), 256) }\n\n    fun read() = cells[pointer]\n\n    fun copy() { clipboard = read() }\n\n    fun paste() = clipboard\n\n    fun moveLeft() { if (--pointer < 0) cells.add(++pointer, 0) }\n\n    fun moveRight() { if (++pointer >= cells.size) cells.add(pointer, 0) }\n}\n\nclass Program(private val code: CharSequence) {\n    private var pointer = -1\n    private val memory = InfiniteMemory()\n    private val output = StringBuilder()\n\n    fun run() : String {\n        output.setLength(0)\n        pointer = -1\n\n        while (pointer < code.length - 1)\n            run(next())\n\n        return output.toString()\n    }\n\n    private fun run(action: Char) {\n        when (action) {\n            '+' -> memory.modify { it + 1 }\n            '-' -> memory.modify { it - 1 }\n            '>' -> memory.moveRight()\n            '<' -> memory.moveLeft()\n            'c' -> memory.copy()\n            'p' -> memory.modify { memory.paste() }\n            'W' -> startWhile()\n            'E' -> endWhile()\n            'P' -> output.append(memory.read().toChar())\n            'N' -> output.append(memory.read())\n            'T' -> memory.modify { it * 2 }\n            'Q' -> memory.modify { pow(it.toDouble(), 2.0).toInt() }\n            'U' -> memory.modify { sqrt(it.toDouble()).toInt() }\n            'L' -> memory.modify { it + 2 }\n            'I' -> memory.modify { it - 2 }\n            'V' -> memory.modify { it \/ 2 }\n            'A' -> memory.modify { it + memory.paste() }\n            'B' -> memory.modify { it - memory.paste() }\n            'Y' -> memory.modify { it * memory.paste()}\n            'D' -> memory.modify { it \/ memory.paste() }\n        }\n    }\n\n    private fun next() = code[++pointer]\n    private fun back()= code[pointer--]\n\n    private fun startWhile() {\n        if (memory.read() != 0) return\n        var currentIntend = 1\n        while (true) {\n            when (next()) {\n                'W' -> currentIntend++\n                'E' -> currentIntend--\n            }\n            if (currentIntend == 0) return\n        }\n    }\n\n    private fun endWhile() {\n        var currentIntend = 0\n        while (true) {\n            when (back()) {\n                'W' -> currentIntend--\n                'E' -> currentIntend++\n            }\n            if (currentIntend == 0) return\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207802,"user_id":null,"body":"fun interpret(code: String): String {\n    var codeIndex = 0\n    val cells = mutableListOf<Int>()\n    var cellIndex = 0\n    var copy = 0\n    var out = \"\"\n\n    fun jumpPastEnd(): Int {\n        var l = 0\n        for (p in codeIndex..code.length) {\n            when (code[p]) {\n                'W' -> l++\n                'E' -> l--\n            }\n            if (l == 0) return p\n        }\n        return code.length\n    }\n\n    fun jumpBack(): Int {\n        var l = 0\n        for (p in codeIndex downTo 0) {\n            when (code[p]) {\n                'W' -> l--\n                'E' -> l++\n            }\n            if (l == 0) return p - 1\n        }\n        return 0\n    }\n\n    fun read() = when (cellIndex) {\n        -1 -> { cells.add(0, 0); cellIndex = 0; 0 }\n        cells.size -> { cells.add(0); 0 }\n        else -> cells[cellIndex]\n    }\n\n    fun write(v: Int) {\n        cells[cellIndex] = when {\n            v < 0 -> 256 - (-v % 256)\n            v > 255 -> v % 256\n            else -> v\n        }\n    }\n\n    while (codeIndex < code.length) {\n        val cell = read()\n        when (code[codeIndex]) {\n            '+' -> write(cell + 1)\n            '-' -> write(cell - 1)\n            '>' -> cellIndex += 1\n            '<' -> cellIndex -= 1\n            'c' -> copy = cell\n            'p' -> write(copy)\n            'W' -> if (cell == 0) codeIndex = jumpPastEnd()\n            'E' -> codeIndex = jumpBack()\n            'P' -> out += cell.toChar()\n            'N' -> out += cell.toString()\n            'T' -> write(cell * 2)\n            'Q' -> write(cell * cell)\n            'U' -> write(Math.sqrt(cell.toDouble()).toInt())\n            'L' -> write(cell + 2)\n            'I' -> write(cell - 2)\n            'V' -> write(cell \/ 2)\n            'A' -> write(cell + copy)\n            'B' -> write(cell - copy)\n            'Y' -> write(cell * copy)\n            'D' -> write(cell \/ copy)\n        }\n        codeIndex++\n    }\n    return out\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207803,"user_id":null,"body":"import kotlin.math.sqrt\n\nfun interpret(source: String): String {\n    val p = Parser(source)\n    val loopPairs = p.parse()\n    val i = Interpreter(source, loopPairs)\n    return i.exe()\n}\n\nclass Parser(val source: String) {\n    val loopPairs: MutableMap<Int, Int> = HashMap()\n    \n    fun parse(): Map<Int, Int> {\n        val loopBeginnings: MutableList<Int> = ArrayList()\n        \n        for ((idx, ch) in source.withIndex()) when (ch) {\n            'W' -> {\n                loopBeginnings.add(idx)\n            }\n            'E' -> {\n                val begin = loopBeginnings.removeLast()\n                loopPairs[begin] = idx\n                loopPairs[idx] = begin\n            }\n            else -> continue\n        }\n        \n        return loopPairs.toMap()\n    }\n    \n}\n\nfun clamp256(n: Int) = n.mod(256)\n\nclass Interpreter(val source: String, val loopPairs: Map<Int, Int>) {\n    val mem: MutableMap<Int, Int> = HashMap<Int, Int>().withDefault { 0 }\n    val output: StringBuilder = StringBuilder()\n    var cellIdx: Int = 0\n    var instrPtr: Int = 0\n    var justJumped: Boolean = false\n    \n    val currentInstr: Char\n        get() = source[instrPtr]\n    \n    var clipboard: Int = 0\n        get() = field\n        set(value) {\n            field = clamp256(value)\n        }\n    \n    var currentCell: Int\n        get() = mem.getValue(cellIdx)\n        set(value) {\n            mem[cellIdx] = clamp256(value)\n        }\n    \n    fun exe(): String {\n        while (instrPtr in 0 until source.length) {\n            justJumped = false\n            step()\n            if (!justJumped) instrPtr++\n        }\n        \n        return output.toString()\n    }\n    \n    fun goto(instrAddr: Int) {\n        instrPtr = instrAddr\n        justJumped = true\n    }\n    \n    fun step() {\n        when (currentInstr) {\n            '+' -> currentCell++\n            '-' -> currentCell--\n            '>' -> cellIdx++\n            '<' -> cellIdx--\n            'c' -> clipboard = currentCell\n            'p' -> currentCell = clipboard\n            'W' -> {\n                if (currentCell == 0)\n                    goto(loopPairs[instrPtr]!!)\n            }\n            'E' -> {\n                if (currentCell != 0)\n                    goto(loopPairs[instrPtr]!!)\n            }\n            'P' -> output.append(currentCell.toChar())\n            'N' -> output.append(currentCell)\n            'T' -> currentCell += currentCell\n            'Q' -> currentCell *= currentCell\n            'U' -> currentCell = sqrt(currentCell.toFloat()).toInt()\n            'L' -> currentCell += 2\n            'I' -> currentCell -= 2\n            'V' -> currentCell \/= 2\n            'A' -> currentCell += clipboard\n            'B' -> currentCell -= clipboard\n            'Y' -> currentCell *= clipboard\n            'D' -> currentCell \/= clipboard\n            else -> {}\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207804,"user_id":null,"body":"import kotlin.math.pow\nimport kotlin.math.sqrt\n\nfun interpret(input: String): String {\n    val cells: MutableMap<Int, UByte> = mutableMapOf(0 to 0u)\n    val loopStarts = mutableListOf<Int>()\n    var currentCellIndex = 0\n    var output = \"\"\n    var buffer: UByte = 0u\n    var index = 0\n    var skipNext = false\n    while (index < input.length) {\n        when (input[index]) {\n            'L' -> cells[currentCellIndex] = (cells[currentCellIndex]!! + 2u).toUByte()\n            'Q' -> cells[currentCellIndex] = cells[currentCellIndex]!!.toDouble().pow(2.0).toInt().toUByte()\n            'T' -> cells[currentCellIndex] = (cells[currentCellIndex]!! * 2u).toUByte()\n            'A' -> cells[currentCellIndex] = (cells[currentCellIndex]!! + buffer).toUByte()\n            'B' -> cells[currentCellIndex] = (cells[currentCellIndex]!! - buffer).toUByte()\n            'I' -> cells[currentCellIndex] = (cells[currentCellIndex]!! - 2u).toUByte()\n            'V' -> cells[currentCellIndex] = (cells[currentCellIndex]!! \/ 2u).toUByte()\n            'D' -> cells[currentCellIndex] = (cells[currentCellIndex]!! \/ buffer.coerceAtLeast(1u)).toUByte()\n            'Y' -> cells[currentCellIndex] = (cells[currentCellIndex]!! * buffer).toUByte()\n            'U' -> cells[currentCellIndex] = sqrt(cells[currentCellIndex]!!.toDouble()).toInt().toUByte()\n            'c' -> buffer = cells[currentCellIndex]!!\n            'p' -> cells[currentCellIndex] = buffer\n            'P' -> output += cells[currentCellIndex]!!.toInt().toChar().toString()\n            'N' -> output += cells[currentCellIndex]!!.toString()\n            'W' -> loopStarts.add(index)\n                .also { if (cells[currentCellIndex]!! == 0.toUByte()) index = input.indexOf('E', index) }\n            'E' -> if (cells[currentCellIndex]!! != 0u.toUByte()) {\n                index = loopStarts.removeLast()\n                skipNext = true\n            } else loopStarts.removeLast()\n            '>' -> cells.putIfAbsent(++currentCellIndex, 0u)\n            '<' -> cells.putIfAbsent(--currentCellIndex, 0u)\n            '+' -> cells[currentCellIndex] = (cells[currentCellIndex]!! + 1u).toUByte()\n            '-' -> cells[currentCellIndex] = (cells[currentCellIndex]!! - 1u).toUByte()\n            else -> Unit\n        }\n        if (!skipNext) index++\n        skipNext = false\n    }\n    return output\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207805,"user_id":null,"body":"import kotlin.math.sqrt\n\nfun MutableMap<Int, Int>.getOr0(key: Int): Int {\n    return this.getOrDefault(key, 0)\n}\n\nclass PoohBear(val bear: String) {\n    var curCell = 0\n    var curIndex = 0\n    val cellMap = mutableMapOf<Int, Int>()\n    var copied = 0\n    val forLoopStack = ArrayDeque<Int>()\n\n    fun write(newValue: Int){\n        if (newValue > 255){\n            cellMap[curCell] = newValue % 256\n        }else if (newValue < 0){\n            cellMap[curCell] = newValue + 256\n        }else {\n            cellMap[curCell] = newValue\n        }\n    }\n\n    fun process(): String {\n\n        val sb = StringBuilder(\"\")\n\n        while (curIndex < bear.length) {\n            when (bear[curIndex]) {\n                '+' -> {\n                    write(cellMap.getOr0(curCell) + 1)\n                }\n                '-' -> {\n                    write(cellMap.getOr0(curCell) - 1)\n                }\n                '>' -> {\n                    curCell += 1\n                }\n                '<' -> {\n                    curCell -= 1\n                }\n                'c' -> {\n                    copied = cellMap.getOr0(curCell)\n                }\n                'p' -> {\n                    cellMap[curCell] = copied\n                }\n                'W' -> {\n                    if (cellMap.getOr0(curCell) <= 0) {\n                        while (bear[curIndex] != 'E') {\n                            curIndex += 1\n                        }\n                        curIndex -= 1\n                    } else {\n                        forLoopStack.addLast(curIndex)\n                    }\n                }\n                'E' -> {\n                    val lastWIndex = forLoopStack.removeLastOrNull()\n                    if (lastWIndex != null && cellMap.getOr0(curCell) > 0) {\n                        curIndex = lastWIndex - 1\n                    }\n                }\n                'P' -> {\n                    sb.append(cellMap.getOr0(curCell).toChar())\n                }\n                'N' -> {\n                    sb.append(cellMap.getOr0(curCell).toString())\n                }\n                'T' -> {\n                    write(cellMap.getOr0(curCell) * 2)\n                }\n                'Q' -> {\n                    write(cellMap.getOr0(curCell) * cellMap.getOr0(curCell))\n                }\n                'U' -> {\n                    cellMap[curCell] = sqrt(cellMap.getOr0(curCell).toDouble()).toInt()\n                }\n                'L' -> {\n                    write(cellMap.getOr0(curCell) + 2)\n                }\n                'I' -> {\n                    write(cellMap.getOr0(curCell) - 2)\n\n                }\n                'V' -> {\n                    cellMap[curCell] = cellMap.getOr0(curCell) \/ 2\n                }\n                'A' -> {\n                    write(cellMap.getOr0(curCell) + copied)\n                }\n                'B' -> {\n                    write(cellMap.getOr0(curCell) - copied)\n                }\n                'Y' -> {\n                    write(cellMap.getOr0(curCell) * copied)\n                }\n                'D' -> {\n                    cellMap[curCell] = cellMap.getOr0(curCell) \/ copied\n                }\n            }\n            curIndex += 1\n        }\n        return sb.toString()\n    }\n}\n\nfun interpret(e: String): String{\n    val pb = PoohBear(e)\n    return pb.process()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207806,"user_id":null,"body":"import kotlin.math.sqrt\n\nfun MutableMap<Int, Int>.getOr0(key: Int): Int {\n    return this.getOrDefault(key, 0)\n}\n\n\nclass PoohBear(val bear: String) {\n    var curCell = 0\n    var curIndex = 0\n    val cellMap = mutableMapOf<Int, Int>()\n    var copied = 0\n    val forLoopStack = ArrayDeque<Int>()\n\n    fun process(): String {\n\n        val sb = StringBuilder(\"\")\n\n        while (curIndex < bear.length) {\n            when (bear[curIndex]) {\n                '+' -> {\n                    cellMap[curCell] = cellMap.getOr0(curCell) + 1\n                    if (cellMap[curCell]!! > 255) {\n                        cellMap[curCell] = 0\n                    }\n                }\n                '-' -> {\n                    cellMap[curCell] = cellMap.getOr0(curCell) - 1\n                    if (cellMap[curCell]!! < 0) {\n                        cellMap[curCell] = 255\n                    }\n                }\n                '>' -> {\n                    curCell += 1\n                }\n                '<' -> {\n                    curCell -= 1\n                }\n                'c' -> {\n                    copied = cellMap.getOr0(curCell)\n                }\n                'p' -> {\n                    cellMap[curCell] = copied\n                }\n                'W' -> {\n                    if (cellMap.getOr0(curCell) <= 0) {\n                        while (bear[curIndex] != 'E') {\n                            curIndex += 1\n                        }\n                        curIndex -= 1\n                    } else {\n                        forLoopStack.addLast(curIndex)\n                    }\n                }\n                'E' -> {\n                    val lastWIndex = forLoopStack.removeLastOrNull()\n                    if (lastWIndex != null && cellMap.getOr0(curCell) > 0) {\n                        curIndex = lastWIndex - 1\n                    }\n                }\n                'P' -> {\n                    sb.append(cellMap.getOr0(curCell).toChar())\n                }\n                'N' -> {\n                    sb.append(cellMap.getOr0(curCell).toString())\n                }\n                'T' -> {\n                    cellMap[curCell] = (cellMap.getOr0(curCell) * 2) % 256\n                }\n                'Q' -> {\n                    cellMap[curCell] = (cellMap.getOr0(curCell) * cellMap.getOr0(curCell)) % 256\n                }\n                'U' -> {\n                    cellMap[curCell] = sqrt(cellMap.getOr0(curCell).toDouble()).toInt()\n                }\n                'L' -> {\n                    cellMap[curCell] = cellMap.getOr0(curCell) + 2\n                    if (cellMap.getOr0(curCell) > 255) {\n                        cellMap[curCell] = cellMap.getOr0(curCell) - 256\n                    }\n                }\n                'I' -> {\n                    cellMap[curCell] = cellMap.getOr0(curCell) - 2\n                    if (cellMap.getOr0(curCell) < 0) {\n                        cellMap[curCell] = cellMap.getOr0(curCell) + 256\n                    }\n                }\n                'V' -> {\n                    cellMap[curCell] = cellMap.getOr0(curCell) \/ 2\n                }\n                'A' -> {\n                    cellMap[curCell] = cellMap.getOr0(curCell) + copied\n                    if (cellMap.getOr0(curCell) > 255) {\n                        cellMap[curCell] = cellMap.getOr0(curCell) - 256\n                    }\n                }\n                'B' -> {\n                    cellMap[curCell] = cellMap.getOr0(curCell) - copied\n                    if (cellMap.getOr0(curCell) < 0) {\n                        cellMap[curCell] = cellMap.getOr0(curCell) + 256\n                    }\n                }\n                'Y' -> {\n                    cellMap[curCell] = (cellMap.getOr0(curCell) * copied) % 256\n                }\n                'D' -> {\n                    cellMap[curCell] = cellMap.getOr0(curCell) \/ copied\n                }\n            }\n            curIndex += 1\n        }\n        return sb.toString()\n    }\n}\n\nfun interpret(e: String): String{\n    val pb = PoohBear(e)\n    return pb.process()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207807,"user_id":null,"body":"import kotlin.math.sqrt\n\nvar currentCell = 0\nvar copy:UByte = 0U\nvar answer = \"\"\nval cells:ArrayList<UByte> = arrayListOf(0U)\nval zero:UByte = 0U\nfun interpret(e: String): String{\n    answer = \"\"\n    cells.clear()\n    cells.add(0U)\n    currentCell = 0\n    copy = 0U\n    translate(e)\n    return answer\n\n}\n\nfun translate(e: String){\n    var c = 0\n    while (c < e.length){\n        when(e[c]){\n            '+' -> cells[currentCell]++\n            '-' -> cells[currentCell]--\n            '>' -> {\n                if(currentCell == cells.size - 1){\n                    cells.add(0U)\n                }\n                currentCell ++\n            }\n            '<' -> {\n                if (currentCell==0){\n                    cells.add(0, 0U)\n                    currentCell ++\n                }\n                    currentCell --\n\n\n            }\n            'c' -> copy = cells[currentCell]\n            'p' -> cells[currentCell] = copy\n            'P' -> answer += cells[currentCell].toInt().toChar()\n            'N' -> answer += \"${cells[currentCell].toInt()}\"\n            'T' -> cells[currentCell] = (cells[currentCell] * 2U).toUByte()\n            'Q' -> cells[currentCell] = (cells[currentCell] * cells[currentCell]).toUByte()\n            'U' -> cells[currentCell] = sqrt(cells[currentCell].toDouble()).toInt().toUByte()\n            'L' -> cells[currentCell] = (cells[currentCell] + 2U).toUByte()\n            'I' -> cells[currentCell] = (cells[currentCell] - 2U).toUByte()\n            'V' -> cells[currentCell] = (cells[currentCell] \/ 2U).toUByte()\n            'A' -> cells[currentCell] = (cells[currentCell] + copy).toUByte()\n            'B' -> cells[currentCell] = (cells[currentCell] - copy).toUByte()\n            'Y' -> cells[currentCell] = (cells[currentCell] * copy).toUByte()\n            'D' -> cells[currentCell] = (cells[currentCell] \/ copy).toUByte()\n            'W' -> {\n                c++\n                var count = 1\n                var loop = \"\"\n                while(true){\n                    if(e[c] == 'W'){\n                        count++\n                    }\n                    if(e[c] == 'E'){\n                        count--\n                        if(count == 0){\n                            break\n                        }\n                    }\n                    if (e[c]!='E' || count != 0){\n                        loop += e[c]\n                    }\n                    c++\n                }\n                while(cells[currentCell] != zero){\n                    translate(loop)\n                }\n            }\n        }\n        c++\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"59b336de5fb1334711000067":[{"id":207808,"user_id":null,"body":"operator fun kotlin.Int.Companion.invoke(s: String): Int = s.toInt()\noperator fun kotlin.Long.Companion.invoke(s: String): Long = s.toLong()\noperator fun kotlin.Double.Companion.invoke(s: String): Double = s.toDouble()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207809,"user_id":571,"body":"operator fun Int.Companion.invoke(s: String): Int = s.toInt()\n\noperator fun Double.Companion.invoke(s: String) = s.toDouble()\n\noperator fun Long.Companion.invoke(s: String) = s.toLong()\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207810,"user_id":null,"body":"object KotlinExtensions {\n  fun Int(s: String) = s.toInt()\n  fun Long(s: String) = s.toLong()\n  fun Double(s: String) = s.toDouble()\n}\n\nval kotlin = KotlinExtensions","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207811,"user_id":null,"body":"class Kot{\n    fun Int(s: String) = s.toInt()\n    fun Long(s: String) = s.toLong()\n    fun Double(s: String) = s.toDouble()\n}\n\nval kotlin = Kot()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207812,"user_id":null,"body":"interface `An Interface Named To Bypass The \"testShouldntUseClass\" Test` {\n    fun Int(s: String) = s.toInt()\n    fun Long(s: String) = s.toLong()\n    fun Double(s: String) = s.toDouble()\n}\n\nval kotlin = object : `An Interface Named To Bypass The \"testShouldntUseClass\" Test` { }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207813,"user_id":null,"body":"var kotlin = Unit\n\nfun Unit.Int(s: String) = s.toInt()\nfun Unit.Long(s: String) = s.toLong()\nfun Unit.Double(s: String) = s.toDouble()\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207814,"user_id":null,"body":"val kotlin = Unit\ninline fun Unit.Int(s: String) = s.toInt()\ninline fun Unit.Long(s: String) = s.toLong()\ninline fun Unit.Double(s: String) = s.toDouble()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207815,"user_id":null,"body":"operator fun kotlin.Int.Companion.invoke(potato: String) : Int = potato.toInt()\noperator fun kotlin.Long.Companion.invoke(potato: String) : Long = potato.toLong()\noperator fun kotlin.Double.Companion.invoke(potato: String) : Double = potato.toDouble()\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207816,"user_id":null,"body":"fun Int(s: String) = s.toInt()\nfun Long(s: String) = s.toLong()\nfun Double(s: String) = s.toDouble()\n\n\/\/ the code above cannot pass the tests. Please make them pass.\n\noperator fun Int.Companion.invoke(s: String): Int{\n    return s.toInt()\n}\n\noperator fun Long.Companion.invoke(s: String): Long{\n    return s.toLong()\n}\n\noperator fun Double.Companion.invoke(s: String): Double{\n    return s.toDouble()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207817,"user_id":null,"body":"    operator fun Int.Companion.invoke(str: String) = str.toInt()\n\n    operator fun Long.Companion.invoke(str: String): Long = str.toLong()\n    \n    operator fun Double.Companion.invoke(str: String): Double = str.toDouble()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"59b33a4a8bcb77608e000103":[{"id":207818,"user_id":null,"body":"operator fun <T> String.invoke(obj: T): T = obj","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207819,"user_id":null,"body":"operator inline fun <T> String.invoke(argument: T) = argument","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207820,"user_id":null,"body":"inline operator fun <reified E : Any> String.invoke(value : E) = value","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207821,"user_id":null,"body":"operator fun <T> String.invoke(b: T) = b","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207822,"user_id":null,"body":"\/\/ oh come on!\noperator fun <T> String.invoke(arg: T) = arg","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207823,"user_id":null,"body":"import java.io.File\n\noperator fun String.invoke(s: String): String = s\noperator fun String.invoke(l: Long): Long = l\noperator fun String.invoke(i: Int): Int = i\noperator fun String.invoke(f: File): File = f\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207824,"user_id":null,"body":"operator fun <T> String.invoke(arg: T) = arg","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207825,"user_id":null,"body":"operator fun <T> String.invoke(other: T): T = other","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207826,"user_id":null,"body":"\/\/ this is very easy!\noperator fun <T> String.invoke(arg: T) = arg","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207827,"user_id":null,"body":"operator fun <T> String.invoke(s: T) = s\n\/\/ this is very easy!","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"59b33fb95227ddcb5f0000d4":[{"id":207828,"user_id":null,"body":"inline fun unless(boolean: Boolean, block: () -> Unit) = if (!boolean) block() else Unit\n\ninline fun until(condition: () -> Boolean, block: () -> Unit) {\n\twhile (!condition()) block()\n}\n\ninline fun forceRun(block: () -> Unit) = try {\n\tblock()\n} catch (e: Exception) {\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207829,"user_id":null,"body":"fun unless(condition: Boolean, action: () -> Unit) { if(!condition) action() }\nfun until(condition:()->Boolean, action: () -> Unit) { while(!condition()) action() }\nfun forceRun(forcedAction:()->Unit) { try { forcedAction() } catch (e: Exception) {} }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207830,"user_id":null,"body":"fun unless(cond: Boolean, block: () -> Unit) {\n  if (!cond) {\n    block()\n  }\n}\n\nfun until(cond: () -> Boolean, block: () -> Unit) {\n  while (!cond()) {\n    block()\n  }\n}\n\nfun forceRun(block: () -> Unit) {\n  try {\n    block()\n  } catch (ignore: Throwable) {\n  }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207831,"user_id":null,"body":"fun unless(b: Boolean, func: () -> Unit) {\n    if (!b) func()\n}\n\nfun until(cond: () -> Boolean, func: () -> Unit) {\n    while (!cond()) func()\n}\n\nfun forceRun(func: () -> Unit) =\n        try {\n            func()\n        } catch (e: Exception) {\n\n        }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207832,"user_id":null,"body":"fun unless(condition: Boolean, body: () -> Unit) { \n    if (!condition) {\n        body()\n    } \n}\n\nfun until(condition: () -> Boolean, body: () -> Unit) {\n    while (!condition()) {\n        body()\n    }\n}\n\nfun forceRun(body: () -> Unit) {\n    try {\n        body()\n    } catch (e: Throwable) {}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207833,"user_id":null,"body":"inline fun unless(condition: Boolean, body: () -> Unit) {\n    if (!condition) body()\n}\n\ninline fun until(condition: () -> Boolean, body: () -> Unit) {\n    while (!condition())\n        body()\n}\n\ninline fun forceRun(body: () -> Unit) = try {\n    body.invoke()\n} catch (_: Exception) {\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207834,"user_id":null,"body":"\/\/ fun unless \/\/ do it!\n\/\/ fun until \/\/ do it!\n\/\/ fun forceRun \/\/ do it!\n\nfun unless(cond: Boolean, block: () -> Unit) = if (!cond) block() else null\n\nfun unless(cond: () -> Boolean, block: () -> Unit) = unless(cond(), block)\n\nfun until(cond: Boolean, block: () -> Unit) {\n    while (!cond) {\n        block()\n    }\n}\n\nfun until(cond: () -> Boolean, block: () -> Unit) {\n    while (!cond()) {\n        block()\n    }\n}\n\nfun forceRun(block: () -> Unit) {\n    try {\n        block()\n    } catch (e: Exception) {\n        \n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207835,"user_id":null,"body":"fun unless(test:Boolean,f: ()->Unit){if(!test)f()}\nfun until(con:()->Boolean, action:()->Unit){\n    while(!con())action()\n}\nfun forceRun(f:()->Unit){\n    try{f()}\n    catch(e:Exception) {return}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207836,"user_id":null,"body":"fun unless(cd: Boolean, cb: () -> Unit): Unit {\n    if (!cd) cb()\n}\n\nfun until(cd: () -> Boolean, cb: () -> Unit): Unit {\n    while (!cd()) cb()\n}\n\nfun forceRun(cb: () -> Unit): Unit {\n    try {\n        cb()\n    } catch (ex: Exception) {}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207837,"user_id":null,"body":"fun unless(b: Boolean, l: () -> Unit) {\n    if (!b) l()\n}\n\nfun until(b: () -> Boolean, l: () -> Unit) {\n    while(!b()){\n        l()\n    }\n}\n\nfun forceRun(l: () -> Unit){\n    try {\n        l()\n    }catch(_: Exception){}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"59b3d479623654e11000006f":[{"id":207838,"user_id":490,"body":"val concatString = String::plus","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207839,"user_id":null,"body":"val concatString: (String, String) -> String =  String::plus","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207840,"user_id":null,"body":"var concatString = String::plus","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207841,"user_id":null,"body":"val concatString: String.(x:String)->String = String::plus\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207842,"user_id":null,"body":"val concatString = String::class.java.getDeclaredMethod(\"concat\", String::class.java)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207843,"user_id":null,"body":"val concatString = String::plus\n\n\/\/ you can't do this in kotlin, but java can!!\n\/\/\n\/\/ val concatString = MethodHandles.lookup().findVirtual(String::class.java,\n\/\/            \"concat\", MethodType.methodType(String::class.java, String::class.java))","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207844,"user_id":null,"body":"val concatString = String::plus\n\n\/\/ this compiles but doesn't pass the tests","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207845,"user_id":null,"body":"val concatString :  (String, String) -> String = String::plus\n\/\/ this compiles but doesn't pass the tests\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207846,"user_id":100,"body":"val concatString:(a: String, b: String) -> String = String::plus","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207847,"user_id":null,"body":"val concatString : (String, Any?) -> String = String::plus\n\/\/ this compiles but doesn't pass the tests     ","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"59b401e24f98a813f9000026":[{"id":207848,"user_id":470,"body":"package kata\n\nobject Kata {\n\tfun computeDepth(n: Int): Int {\n\t\tval tome = mutableSetOf<Int>()\n\t\tvar c = 0\n\t\twhile (tome.size < 10) {\n\t\t\t(++c * n).toString().forEach { tome.add(it.digitToInt()) }\n\t\t}\n\t\treturn c\n\t}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207849,"user_id":null,"body":"package kata\n\nobject Kata {\n\tfun computeDepth(n: Int): Int {\n\t\tval hash = hashSetOf<String>()\n        var counter = 0\n        var multiply = 1\n        while (hash.size != 11) {\n            hash.addAll((n * multiply).toString().split(\"\"))\n            multiply++\n            counter++\n        }\n        \n        return counter\n\t}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207850,"user_id":null,"body":"package kata\n\nobject Kata {\n\tfun computeDepth(n: Int): Int {\n\t\t\/\/ Keep track of all the numbers in a unique set\n        var recordedNums = mutableSetOf<Char>()\n        var multiples = 0\n        \n        while (recordedNums.size < 10) {\n            multiples++\n            (n * multiples).toString().forEach { num ->\n                if (!recordedNums.contains(num)) {\n                    recordedNums.add(num)\n                }\n            }\n        }\n        return multiples\n\t}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207851,"user_id":null,"body":"package kata\n\nobject Kata {\n\tfun computeDepth(n: Int): Int {\n        val digits = n.toString().map { it.digitToInt() }.toMutableSet()\n        val allDigits = (0..9).toSet()\n        var counter = 1\n        while (digits != allDigits) {\n            val newDigits = n * counter\n            digits.addAll(newDigits.toString().map { it.digitToInt() })\n            counter++\n        }\n        return counter - 1\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207852,"user_id":null,"body":"package kata\n\nobject Kata {\n\tfun computeDepth(n: Int): Int {\n\t\tval target = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 0)\n\t    val track: MutableList<Int> = mutableListOf()\n\t    var hold = 0\n\n\t\tfor (i in 1..1000) {\n\t\t\tif (track.containsAll(target)){\n\t\t\t\thold = i - 1\n\t\t\t\tbreak\n\t\t\t}else{\n                (i * n).toString().chunked(1).forEach { track.add(it.toInt()) }\n            }\n\t\t\t\n\t\t}\n        return hold\n\t}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207853,"user_id":null,"body":"package kata\n\nobject Kata {\n\tfun computeDepth(n: Int): Int {\n        var number = n\n        var multiplier = 1\n        val digits: MutableSet<Char> = mutableSetOf()\n        while (digits.size < 10) {\n            number = n * multiplier\n            number.toString().forEach {\n                digits.add(it)\n            }\n            multiplier++\n        }\n        return multiplier - 1\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207854,"user_id":null,"body":"package kata\n\nobject Kata {\n\tfun computeDepth(n: Int): Int {\n    var massiv = mutableListOf('0','1','2','3','4','5','6','7','8','9')\n    var counter = 1\n    while (massiv.isNotEmpty()){\n        var number = n*counter\n        counter++\n        for (i in number.toString()){\n            if (i in massiv){\n                massiv.removeAt(massiv.indexOf(i))\n            }\n        }\n    }\n    return counter - 1\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207855,"user_id":null,"body":"package kata\n\nobject Kata {\n\tfun computeDepth(n: Int): Int {\n\t\tvar depth = 0\n        val nums: MutableSet<Char> = mutableSetOf()\n        while (true) {\n            depth += 1\n            var prod = depth * n\n            var chars = prod.toString()\n            for (i in chars){\n                nums.add(i)\n            }\n            if(nums.size == 10){\n                break\n            }\n        }\n        return depth\n\t}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207856,"user_id":null,"body":"package kata\n\nobject Kata {\n\tfun computeDepth(n: Int): Int {\n\t\tval a = mutableListOf(0,1,2,3,4,5,6,7,8,9)\n        \n        var nn=n\n        var n_nn=nn\n        \n        var res=0\n        var ii=0\n        \n        while(a.size!=0){\n            ii+=1\n            nn=n*ii\n            while(nn>0){\n                n_nn=nn%10\n                a.remove(n_nn)\n                nn\/=10\n            }\n            res++\n        }\n        return res\n        \n\t}\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207857,"user_id":null,"body":"package kata\n\nobject Kata {\n\tfun computeDepth(n: Int): Int {\n\t\tval l : MutableSet<Char> = mutableSetOf()\n        var i = 0\n\n        while (l.size < 10) {\n            i++\n            val s = (n * i).toString().toSet()\n            l.addAll(s)\n        }\n        return i\n\t}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"59c68ea2aeb2843e18000109":[{"id":207858,"user_id":null,"body":"package solution\n\nimport kotlin.math.*\n\nobject Finance {\n    fun amort(rate: Double, bal: Int, term: Int, n: Int): String {\n    val r = rate \/ (100 * 12)\n    val c = r * bal \/ (1 - (r + 1).pow(-term))\n    val x = 1 + r\n\n    val pNew = x.pow(n) * bal - c * (x.pow(n) - 1) \/ (x - 1)\n    val pOld = x.pow(n-1) * bal - c * (x.pow(n-1) - 1) \/ (x - 1)\n    val princ = pOld - pNew\n    val int = c - princ\n\n    return \"num_payment $n c ${c.roundToInt()} princ ${princ.roundToInt()} int ${int.roundToInt()} balance ${pNew.roundToInt()}\"\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207859,"user_id":null,"body":"package solution\n\nimport kotlin.math.*\n\nobject Finance {\n    fun amort(rate: Double, bal: Int, term: Int, numPayment: Int): String {\n        val r = rate \/ 1200\n        val c = (r * bal) \/ (1 - (1 + r).pow(-term)) \/\/ monthlyPayment\n        val balance = (1 + r).pow(numPayment) * bal - (((1 + r).pow(numPayment) - 1) \/ r) * c\n        val prevBalance = (1 + r).pow(numPayment - 1) * bal - (((1 + r).pow(numPayment - 1) - 1) \/ r) * c\n        val princ = prevBalance - balance\n        val int = c - princ\n        return \"num_payment $numPayment c ${c.roundToInt()} princ ${princ.roundToInt()} int ${int.roundToInt()} balance ${balance.roundToInt()}\"\n    }\n  }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207860,"user_id":null,"body":"package solution\nimport kotlin.math.pow\nimport kotlin.math.roundToInt\n\nobject Finance {\n    \n    fun amort(rate: Double, bal: Int, term: Int, num_payments: Int): String {\n        var b: Double = bal.toDouble()\n        val r = rate \/ 100 \/ 12\n        var n = r * b\n        val d = 1 - (1 + r).pow(-term)\n        val c = n \/ d\n    \n        for (i in (1..num_payments)) {\n            n = r * b\n            b -= c - n\n        }\n        return \"num_payment $num_payments c ${c.roundToInt()} princ ${(c - n).roundToInt()} int ${n.roundToInt()} balance ${b.roundToInt()}\"\n    }\n  }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207861,"user_id":null,"body":"package solution\n\nimport kotlin.math.pow\n\nobject Finance {\n    \n    fun amort(rate: Double, bal: Int, term: Int, num_payments: Int): String {\n        val perc = rate \/ 1200\n        var int = perc * bal\n        val c = int\/(1 - (1 + perc).pow(-1.0 * term))\n        var princ = 0.0\n        var balance = bal.toDouble()\n        for (t in 0 until num_payments) {\n            int = perc * balance\n            princ = c - int\n            balance -= princ\n        }\n        return \"num_payment %d c %.0f princ %.0f int %.0f balance %.0f\".format(num_payments, c, princ, int, balance)\n    }\n  }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207862,"user_id":null,"body":"package solution\n\nimport kotlin.math.pow\n\nobject Finance {\n\n    fun amort(rate: Double, bal: Int, term: Int, num_payments: Int): String {\n        val rate = rate \/ 1200\n        val pay = rate * bal \/ (1 - (1 + rate).pow(-term))\n        val bal = generateSequence(bal.toDouble()) { it - pay + it * rate }\n            .elementAt(num_payments - 1)\n        return \"num_payment $num_payments c ${Math.round(pay)} princ ${Math.round(pay - bal * rate)} \" +\n                \"int ${Math.round(bal * rate)} balance ${Math.round(bal - pay + bal * rate)}\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207863,"user_id":null,"body":"package solution\n\nimport kotlin.math.pow\n\nobject Finance {\n    fun amort(rate: Double, p: Int, term: Int, at: Int): String {\n        val r = rate \/ 12 \/ 100\n        val c: Double = p * r \/ (1 - (1 + r).pow(-term))\n        val pp = c * (1 + r).pow(at - 1 - term)\n        var b = p.toDouble()\n        for (x in 1..at) b -= c * (1 + r).pow(x - 1 - term)\n        return \"num_payment %d c %.0f princ %.0f int %.0f balance %.0f\".format(at, c, pp, c - pp, b)\n    }\n  }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207864,"user_id":null,"body":"package solution\nimport kotlin.math.pow\n\nobject Finance {\n\n    fun amort(rate: Double, bal: Int, term: Int, num_payments: Int): String {\n        val r = (rate\/100\/12)\n        val n = r*bal\n        val d = 1 - (1 + r).pow(0-term)\n        val c = n\/d\n        var int: Double? = null\n        var princ: Double? = null\n        var balance:Double = bal.toDouble()\n        for(i in 0..num_payments-1){\n            int = balance*r\n            princ = c - int\n            balance = balance - princ\n        }\n        val c_r = Math.round(c)\n        val princ_r = Math.round(princ!!)\n        val int_r = Math.round(int!!)\n        val bal_r = Math.round(balance)\n        return \"num_payment $num_payments c $c_r princ $princ_r int $int_r balance $bal_r\"\n    }\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207865,"user_id":492,"body":"package solution\n\nobject Finance {\n    private fun payment(rate: Double, bal: Int, term: Int): Double {\n        val r = rate \/ 1200.0\n        val n = r * bal\n        val d = 1 - Math.pow(1 + r, (-term).toDouble())\n        return n \/ d\n    }\n    fun amort(rate: Double, bal: Int, term: Int, num_payments: Int): String {\n        val p = payment(rate, bal, term)\n        val r = rate \/ 1200.0\n        var i = 1\n        var balance = bal.toDouble()\n        var intrst = 0.0\n        var princ = 0.0\n        while (i <= num_payments) {\n            intrst = balance * r\n            princ = p - intrst\n            balance -= princ\n            i += 1\n        }\n        return String.format(\n            \"num_payment %d c %.0f princ %.0f int %.0f balance %.0f\", i - 1, p, princ, intrst, balance\n        )\n    }\n  }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"59ca8246d751df55cc00014c":[{"id":207866,"user_id":null,"body":"fun hero(bullets: Int, dragons: Int) = bullets >= dragons * 2","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207867,"user_id":null,"body":"fun hero(bullets: Int, dragons: Int) = dragons <= bullets\/2","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207868,"user_id":1153,"body":"fun hero(bullets: Int, dragons: Int) = bullets \/ 2 >= dragons","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207869,"user_id":null,"body":"fun hero(bullets: Int, simplyDragons: Int) : Boolean {\n    val purelyHypotheticalDeadDragons = bullets\/2\n    val isHappyEnd : Boolean = simplyDragons <= purelyHypotheticalDeadDragons\n    return isHappyEnd\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207870,"user_id":null,"body":"fun hero(bullets: Int, dragons: Int) : Boolean {\n  if (bullets >= dragons*2){\n      return true\n  }\n  else {\n      return false\n  }\n  return true\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207871,"user_id":null,"body":"fun hero(bullets: Int, dragons: Int) : Boolean {\n  val living = bullets \/ dragons\n  if (living >= 2) {\n      return true\n  } else {\n      return false\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207872,"user_id":null,"body":"fun hero(bullets: Int, dragons: Int) : Boolean = dragons <= bullets \/ 2\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207873,"user_id":null,"body":"fun hero(bullets: Int, dragons: Int) : Boolean {\n \n  if (dragons != 0) {\n \n  if (bullets \/ dragons >= 2) {\n  return true\n  } else {\n  return false \n  }\n  }\n  \n  return false\n  \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207874,"user_id":null,"body":"fun hero(bullets: Int, dragons: Int) : Boolean {\n  return if(dragons <= 0) true else (bullets\/dragons) > 1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207875,"user_id":null,"body":"fun hero(bullets: Int, dragons: Int) : Boolean {\n  return bullets shr 1 >= dragons\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"59ccf051dcc4050f7800008f":[{"id":207876,"user_id":null,"body":"import kotlin.math.sqrt\n\nfun buddy(start: Long, limit: Long): String {\n    return (start..limit)\n        .map {\n            val buddy = divisors(it).sum() - 1\n            if (buddy > it && divisors(buddy).sum() - 1 == it) {\n                \"($it $buddy)\"\n            } else {\n                \"\"\n            }\n        }.firstOrNull { it.isNotEmpty() } ?: \"Nothing\"\n}\n\nfun divisors(number: Long): List<Long> {\n    return (1 .. sqrt(number.toDouble()).toLong())\n        .filter {  number % it == 0L }\n        .flatMap { if (number \/ it == it || number \/ it == number) listOf(it) else listOf(it, number \/ it) }\n}","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-12 12:19:21"},{"id":207877,"user_id":null,"body":"import kotlin.math.sqrt\n\nfun getProperDivs(n: Long): List<Long>{\n    val divs = mutableListOf<Long>()\n    val sqrt = sqrt(n.toDouble()).toLong()\n    for (i in 1..sqrt){\n        if (n % i == 0L) {\n            divs.add(i)\n            if (n \/ i != i) divs.add(n \/ i)\n        }\n    }\n    return divs - n\n}\n\nfun buddy(start: Long, limit: Long): String {\n    for (i in start..limit){\n        val a = getProperDivs(i).sum() - 1\n        val b = getProperDivs(a).sum() - 1\n        if(i == b  && a > i) return \"($i $a)\"\n    }\n    return \"Nothing\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207878,"user_id":null,"body":"fun getSumOfDivisors(n: Long): Long =\n    (1 until Math.sqrt(n.toDouble()).toLong() + 1).reduce {\n        acc, e -> acc + if (n.rem(e) == 0.toLong()) e + n.div(e) else 0.toLong()\n    }\n\nfun buddy(start: Long, limit: Long): String {\n    for (n in start..limit) {\n        val m = getSumOfDivisors(n) - 1\n        if (m > n && getSumOfDivisors(m) - 1 == n) {\n            return \"($n $m)\"\n        }\n    }\n    \n    return \"Nothing\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207879,"user_id":null,"body":"import kotlin.math.sqrt\n\nfun buddy(start:Long, limit:Long):String {\n\t    (start..limit).forEach { n->\n            val m = sMinus1(n)\n            if(m>n && sMinus1(m)==n) return \"($n $m)\"\n        }\n        \n        return \"Nothing\"\n}\n\n\nfun sMinus1(n:Long): Long {\n    return LongRange(2L,sqrt((n-1).toDouble()).toLong()).sumOf {if(n%it==0L) it+n\/it else 0}.toLong() + if(sqrt(n.toDouble()).toLong()*sqrt(n.toDouble()).toLong()==n)  -sqrt(n.toDouble()).toLong() else 0L\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207880,"user_id":null,"body":"fun buddy(start: Long, limit: Long): String {\n    for (n in start..limit + 1L) {\n      val m = s(n) - 1 \/\/ s(n) = m + 1\n      if (m > n && s(m) == n + 1L) {\n        return \"($n $m)\"\n      }\n    }\n\n  return \"Nothing\"\n}\n\nfun s(n: Long) = sumOfDivisors(n) - n\n\nfun sumOfDivisors(n : Long) : Long {\n  var result = 1L\n  var div = 1L\n  var n2 = n\n\n  var found : Boolean\n  do {\n    found = false\n    div++\n    while (div * div <= n) {\n      if ((n2 % div) == 0L) {\n        \/\/ found a divisor\n        var mul = 1L\n        while ((n2 % div) == 0L) {\n          n2 \/= div\n          mul = mul * div + 1L\n        }\n        result *= mul\n        found = true\n        break\n      }\n      div++\n    }\n  } while (found)\n\n  if (n2 > 1) {\n    result *= n2 + 1\n  }\n\n  return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207881,"user_id":null,"body":"fun buddy(start: Long, limit: Long): String {\n    for (n in start..limit + 1L) {\n      val m = s(n) - 1 \/\/ s(n) = m + 1\n      if (m > n && s(m) == n + 1L) {\n        return \"($n $m)\"\n      }\n    }\n\n  return \"Nothing\"\n}\n\nfun s(n: Long) = sumOfDivisors(n) - n\n\nfun sumOfDivisors(n : Long) : Long {\n  var result = 1L\n  var div = 1L\n  var n2 = n\n\n  var found : Boolean\n  do {\n    found = false\n    div++\n    var s = Math.sqrt(n2.toDouble()).toLong() + 1L\n    while (div < s) {\n      if ((n2 % div) == 0L) {\n        \/\/ found a divisor\n        var mul = 1L\n        while ((n2 % div) == 0L) {\n          n2 \/= div\n          mul = mul * div + 1L\n        }\n        result *= mul\n        found = true\n        break\n      }\n      div++\n    }\n  } while (found)\n\n  if (n2 > 1) {\n    result *= n2 + 1\n  }\n\n  return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207882,"user_id":null,"body":"import kotlin.math.sqrt\n\nfun Long.divisorsSum(): Long { \n    var s = 1L\n    for (i in 2L..(sqrt(this.toDouble()).toLong())) if (this%i == 0L) {s += i; s += this\/i}\n    return s\n}\n\nfun buddy(start: Long, limit: Long): String {\n    for (i in start..limit) {\n        if ( (i.divisorsSum()-1L).divisorsSum() == i+1L ) \n           if (i < i.divisorsSum()-1) return \"($i ${i.divisorsSum()-1})\"\n    }\n    return \"Nothing\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207883,"user_id":null,"body":"fun buddy(start: Long, limit: Long): String {\n    for (i in start..limit) {\n        val j = sumOfDivisors(i) - 1L\n        if (j > i && sumOfDivisors(j) == i + 1L) {\n            return \"($i $j)\"\n        }\n    }\n    return \"Nothing\"\n}\n\nfun sumOfDivisors(n: Long): Long {\n    var sum = 1L\n    for (i in 2L until n) {\n        if (i * i > n) {\n            break\n        }\n        if (n % i == 0L) {\n            if (i * i == n) {\n                sum += i\n            } else {\n                sum += i\n                sum += n \/ i\n            }\n        }\n    }\n    return sum\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207884,"user_id":null,"body":"fun buddy(start: Long, limit: Long): String {\n    for (i in start .. limit) {\n        val j = sumOfDivisors(i) - 1L\n        if (j > i && sumOfDivisors(j) == i + 1L) {\n            return \"($i $j)\"\n        }\n    }\n    return \"Nothing\"\n}\n\nfun sumOfDivisors(n: Long) : Long {\n    var sum = 1L\n    for (i in 2L until n) {\n        if (i*i > n) {\n            break\n        }\n        if (n % i == 0L) {\n            sum += i\n            sum += n \/ i\n        }\n    }\n    return sum\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207885,"user_id":null,"body":"fun buddy(start: Long, limit: Long): String {\n    for (n in start..limit) {\n        val m = sum(n)\n        if (m > n && sum(m) == n) return \"($n $m)\"\n    }\n    return \"Nothing\"\n}\n\nfun sum(num: Long): Long {\n    var sum = 0L\n    val root = kotlin.math.sqrt(num.toDouble()).toLong()\n    for (n in 1..root) {\n        if (num % n == 0L) sum += n + num \/ n\n    }\n    if (num % root == 0L && num \/ root == root) sum -= root\n    return sum - num - 1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"59cfc000aeb2844d16000075":[{"id":207886,"user_id":null,"body":"package altcaps\n\nfun capitalize(text: String): List<String> =\n    listOf(\n        text.mapIndexed { index, c -> if (index % 2 == 0) c.toUpperCase() else c }.joinToString(\"\"),\n        text.mapIndexed { index, c -> if (index % 2 == 1) c.toUpperCase() else c }.joinToString(\"\")\n    )","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 15:58:37"},{"id":207887,"user_id":null,"body":"package altcaps\n\nfun capitalize(text: String) = \n    (0..1).map{text.mapIndexed{i, c -> if(i % 2 == it) c.toUpperCase() else c}.joinToString(\"\")}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2023-01-06 15:58:43"},{"id":207888,"user_id":null,"body":"package altcaps\n\nfun capitalize(text: String): List<String> {\n    val evenText = mutableListOf<String>()\n    val oddText = mutableListOf<String>()\n    for (char in text.withIndex()) {\n        when {\n            (char.index % 2) == 0 -> {\n                evenText.add(char.value.toString())\n                oddText.add(char.value.toString().capitalize())\n            }\n            else -> {\n                evenText.add(char.value.toString().capitalize())\n                oddText.add(char.value.toString())\n            }\n        }\n    }\n\n    return listOf(\n        oddText.joinToString(\"\"),\n        evenText.joinToString(\"\")\n    )\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207889,"user_id":null,"body":"package altcaps\n\nfun capitalize(text: String): List<String> {\n    val fn = { str: String, inverse: Boolean -> str.mapIndexed { i, c -> if ((i % 2 == 0) xor inverse) c.toUpperCase() else c }.joinToString(\"\") }\n    return listOf(fn(text, false), fn(text, true))\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207890,"user_id":null,"body":"package altcaps\n\n fun capitalize(text: String): List<String>   {\n        val firstList = mutableListOf<String>()\n        val secondList = mutableListOf<String>()\n        val mainList = mutableListOf<String>()\n        \n        val stringToList = text.toList()\n        \n        \n        stringToList.mapIndexed{ index, item  ->\n            when (index % 2){\n                0 -> firstList.add(item.uppercase())\n                else ->firstList.add(item.toString())\n            }\n        }\n        \n        stringToList.mapIndexed{ index, item  ->\n            when (index % 2){\n                0 -> secondList.add(item.toString())\n                else ->secondList.add(item.uppercase())\n            }\n        }\n        \n        mainList.add(firstList.joinToString(\"\"))\n        mainList.add(secondList.joinToString(\"\"))\n        return mainList\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207891,"user_id":null,"body":"package altcaps\n\nfun capitalize(text: String): List<String> {\n   val list = mutableListOf(\"\", \"\")\n\n    text.forEachIndexed{i, c ->\n        if(i % 2 == 0){\n            list[0] += c.toUpperCase().toString()\n            list[1] += c.toString()\n        }else{\n            list[1] += c.toUpperCase().toString()\n            list[0] += c.toString()\n        }\n    }\n    return list\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207892,"user_id":null,"body":"package altcaps\n\nfun capitalize(text: String) = listOf(\n        text.mapIndexed { index, string -> if(index % 2 == 0 )string.toUpperCase() else string }.joinToString(\"\"),\n        text.mapIndexed { index, string -> if(index % 2 == 0 )string else string.toUpperCase() }.joinToString(\"\")\n)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207893,"user_id":null,"body":"package altcaps\n\nfun capitalize(text: String): List<String> {\n    return listOf(text.capAlternate(1), text.capAlternate(0))\n}\n\nfun String.capAlternate(start: Int) = this.mapIndexed{\n        i, c -> c.capIf(i.rem(2) == start)\n    }.joinToString(\"\")\n\nfun Char.capIf(cap: Boolean): Char = if(cap) this else this.toUpperCase()\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207894,"user_id":null,"body":"package altcaps\n\nfun capitalize(text: String) = listOf(\n    text.mapIndexed {index, c -> if (index % 2 == 0) c.toUpperCase() else c }.fold(\"\") {acc, c -> acc + c.toString() },\n    text.mapIndexed {index, c -> if (index % 2 != 0) c.toUpperCase() else c }.fold(\"\") {acc, c -> acc + c.toString() })\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207895,"user_id":null,"body":"package altcaps\n\nfun capitalize(text: String): List<String> = listOf(text.cap { it % 2 == 0 }, text.cap { it % 2 == 1 })\n\ninline fun String.cap(condition: (i: Int) -> Boolean): String =\n    this.mapIndexed { i, c -> if (condition(i)) c.toUpperCase() else c }.joinToString(\"\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"59d0ee709f0cbcf65400003b":[{"id":207896,"user_id":null,"body":"package solution\n\nobject State {\n    val mapState = mapOf(\n        \"AZ\" to \"Arizona\",\n        \"CA\" to \"California\",\n        \"ID\" to \"Idaho\",\n        \"IN\" to \"Indiana\",\n        \"MA\" to \"Massachusetts\",\n        \"OK\" to \"Oklahoma\",\n        \"PA\" to \"Pennsylvania\",\n        \"VA\" to \"Virginia\"\n    )\n    fun byState(str: String): String {\n        val statesGroup = str.split(\"\n\").groupBy(\n            { mapState[it.takeLast(2)] },\n            { it }\n        )\n        return statesGroup.map {\n            \"${it.key}\" + it.value.sorted().joinToString(\n                \"\n..... \",\n                \"\n..... \"\n            ) { \"${it.split(',').joinToString(\"\").dropLast(2)}${mapState[it.takeLast(2)]}\" }\n        }.sorted().joinToString(\"\n \")\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207897,"user_id":null,"body":"package solution\n\nobject State {\n    \n    val stateMap = mapOf(\n    \"AZ\" to \"Arizona\",\n    \"CA\" to \"California\",\n    \"ID\" to \"Idaho\",\n    \"IN\" to \"Indiana\",\n    \"MA\" to \"Massachusetts\",\n    \"OK\" to \"Oklahoma\",\n    \"PA\" to \"Pennsylvania\",\n    \"VA\" to \"Virginia\"\n    )\n    \n    fun byState(str: String): String {\n        val book = mutableMapOf<String,MutableList<String>>()        \n        str.split(\"\n\").forEach{ address ->\n            val code = address.split(\" \").last()\n            val state = stateMap[code]!!\n            val addressUpdated = \"..... ${address.replace(code, state).replace(\",\",\"\")}\"\n            if(book.containsKey(state)){\n                book[state]?.add(addressUpdated)\n            } else {\n                book[state] = mutableListOf(addressUpdated)\n            }\n        }\n        return book.toSortedMap().map { (k, v) ->\n            \"$k\n${v.sorted().joinToString(\"\n\")}\n\"\n        }.joinToString(\" \").trim()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207898,"user_id":null,"body":"package solution\n\nobject State {\n    fun byState(str: String): String {\n        val states = mapOf( \"AZ\" to \"Arizona\", \"CA\" to \"California\", \"ID\" to \"Idaho\", \"IN\" to \"Indiana\", \"MA\" to \"Massachusetts\", \"OK\" to \"Oklahoma\", \"PA\" to \"Pennsylvania\", \"VA\" to \"Virginia\" )\n\n        return str.split(\"\n\")\n            .sortedWith(compareBy { it.takeLast(2) })\n            .groupBy({ states[it.takeLast(2)] }, { it })\n            .map { (state, addresses) ->\n                \"$state\" + addresses.sorted().joinToString(\"\n..... \", \"\n..... \") {\n                    \"${it.split(',').joinToString(\"\").dropLast(2)}$state\"\n                }\n            }.joinToString(\"\n \")\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207899,"user_id":null,"body":"package solution\n\nobject State {\n    fun byState(str: String): String {\n        val data = str.split(\"\n\")\n            .sortedWith(compareBy({ it.takeLast(2) }, { it.takeWhile { c -> c != ' ' } }))\n\n        val states = mapOf( \"AZ\" to \"Arizona\", \"CA\" to \"California\", \"ID\" to \"Idaho\", \"IN\" to \"Indiana\", \"MA\" to \"Massachusetts\", \"OK\" to \"Oklahoma\", \"PA\" to \"Pennsylvania\", \"VA\" to \"Virginia\" )\n        val sortedMap = mutableMapOf<String, MutableList<String>>()\n\n        data.forEach {\n            val s = states.getOrDefault(it.takeLast(2), \"\")\n            val t = \".\".repeat(5) + \" \" + it.dropLast(2).replace(\",\", \"\")\n\n            if (sortedMap.containsKey(s))\n                sortedMap[s]!!.add(t)\n            else sortedMap[s] = mutableListOf(t)\n        }\n        return sortedMap.map { (state, address) ->\n            \" $state\n\" + address.joinToString(\"\n\") { it + state }\n        }.joinToString(\"\n\").trimStart()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207900,"user_id":null,"body":"package solution\n\nobject State {\n    val states = mapOf(\n        \"AZ\" to \"Arizona\", \"CA\" to \"California\", \"ID\" to \"Idaho\", \"IN\" to \"Indiana\", \"MA\" to \"Massachusetts\",\n        \"OK\" to \"Oklahoma\", \"PA\" to \"Pennsylvania\", \"VA\" to \"Virginia\"\n    )\n\n    fun byState(str: String): String =\n        str.lines()\n            .map { it.split(\", \") }\n            .map {\n                arrayOf(\n                    it[0],\n                    it[1] + \" \" + it[2].substringBeforeLast(\" \"),\n                    states[it[2].substringAfterLast(\" \")]\n                )\n            }\n            .sortedBy { it[0] }\n            .groupBy { it[2] }\n            .toSortedMap(compareBy { it })\n            .map { it.key + \"\n\" + it.value.joinToString(\"\n\") { value -> \"..... \" + value[0] + \" \" + value[1] + \" \" + it.key } }\n            .joinToString(\"\n \")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207901,"user_id":null,"body":"package solution\n\nobject State {\n    \n    fun byState(str: String): String {\n     val state = mutableMapOf(\n        \"AZ\" to \"Arizona\",\n        \"CA\" to \"California\",\n        \"ID\" to \"Idaho\",\n        \"IN\" to \"Indiana\",\n        \"MA\" to \"Massachusetts\",\n        \"OK\" to \"Oklahoma\",\n        \"PA\" to \"Pennsylvania\",\n        \"VA\" to \"Virginia\"\n    )\n    val strArray = str.split(\"\n\")\n    val strTempAZ = mutableListOf<String>()\n    val strTempCA = mutableListOf<String>()\n    val strTempID = mutableListOf<String>()\n    val strTempIN = mutableListOf<String>()\n    val strTempMA = mutableListOf<String>()\n    val strTempOK = mutableListOf<String>()\n    val strTempPA = mutableListOf<String>()\n    val strTempVA = mutableListOf<String>()\n    strArray.forEach {\n        val ss = it.substring(it.length-2,it.length)\n        when(ss){\n            \"AZ\"-> strTempAZ.add(it.replace(Regex(\"\"\"[,\"]\"\"\"),\"\"))\n            \"CA\"-> strTempCA.add(it.replace(Regex(\"\"\"[,\"]\"\"\"),\"\"))\n            \"ID\"-> strTempID.add(it.replace(Regex(\"\"\"[,\"]\"\"\"),\"\"))\n            \"IN\"-> strTempIN.add(it.replace(Regex(\"\"\"[,\"]\"\"\"),\"\"))\n            \"MA\"-> strTempMA.add(it.replace(Regex(\"\"\"[,\"]\"\"\"),\"\"))\n            \"OK\"-> strTempOK.add(it.replace(Regex(\"\"\"[,\"]\"\"\"),\"\"))\n            \"PA\"-> strTempPA.add(it.replace(Regex(\"\"\"[,\"]\"\"\"),\"\"))\n            \"VA\"-> strTempVA.add(it.replace(Regex(\"\"\"[,\"]\"\"\"),\"\"))\n        }\n    }\n    val longStr:StringBuilder = StringBuilder()\n\n    if(strTempAZ.size>0){\n        strTempAZ.sort()\n        longStr.append(state.getValue(\"AZ\")+\"\n\")\n        for(i in 0 until strTempAZ.size){\n            longStr.append(\"..... ${state.getValue(\"AZ\").let { it1 -> strTempAZ[i].replace(\"AZ\",it1) }}\")\n            if(i!=strTempAZ.size-1){\n                longStr.append(\"\n\")\n            }\n        }\n        if(strTempCA.size>0 || strTempID.size>0 || strTempIN.size>0 || strTempMA.size>0 || strTempOK.size>0 || strTempPA.size>0 || strTempVA.size>0)\n            longStr.append(\"\n \")\n    }\n    if(strTempCA.size>0){\n        strTempCA.sort()\n        longStr.append(state.getValue(\"CA\")+\"\n\")\n        for(i in 0 until strTempCA.size){\n            longStr.append(\"..... ${state.getValue(\"CA\").let { it1 -> strTempCA[i].replace(\"CA\",it1) }}\")\n            if(i!=strTempCA.size-1){\n                longStr.append(\"\n\")\n            }\n        }\n        if(strTempID.size>0 || strTempIN.size>0 || strTempMA.size>0 || strTempOK.size>0 || strTempPA.size>0 || strTempVA.size>0)\n            longStr.append(\"\n \")\n    }\n    if(strTempID.size>0){\n        strTempID.sort()\n        longStr.append(state.getValue(\"ID\")+\"\n\")\n        for(i in 0 until strTempID.size){\n            longStr.append(\"..... ${state.getValue(\"ID\").let { it1 -> strTempID[i].replace(\"ID\",it1) }}\")\n            if(i!=strTempID.size-1){\n                longStr.append(\"\n\")\n            }\n        }\n        if(strTempIN.size>0 || strTempMA.size>0 || strTempOK.size>0 || strTempPA.size>0 || strTempVA.size>0)\n            longStr.append(\"\n \")\n    }\n    if(strTempIN.size>0){\n        strTempIN.sort()\n        longStr.append(state.getValue(\"IN\")+\"\n\")\n        for(i in 0 until strTempIN.size){\n            longStr.append(\"..... ${state.getValue(\"IN\").let { it1 -> strTempIN[i].replace(\"IN\",it1) }}\")\n            if(i!=strTempIN.size-1){\n                longStr.append(\"\n\")\n            }\n        }\n        if(strTempMA.size>0 || strTempOK.size>0 || strTempPA.size>0 || strTempVA.size>0)\n            longStr.append(\"\n \")\n    }\n    if(strTempMA.size>0){\n        strTempMA.sort()\n        longStr.append(state.getValue(\"MA\")+\"\n\")\n        for(i in 0 until strTempMA.size){\n            longStr.append(\"..... ${state.getValue(\"MA\").let { it1 -> strTempMA[i].replace(\"MA\",it1) }}\")\n            if(i!=strTempMA.size-1){\n                longStr.append(\"\n\")\n            }\n        }\n        if(strTempOK.size>0 || strTempPA.size>0 || strTempVA.size>0)\n            longStr.append(\"\n \")\n    }\n    if(strTempOK.size>0){\n        strTempOK.sort()\n        longStr.append(state.getValue(\"OK\")+\"\n\")\n        for(i in 0 until strTempOK.size){\n            longStr.append(\"..... ${state.getValue(\"OK\").let { it1 -> strTempOK[i].replace(\"OK\",it1) }}\")\n            if(i!=strTempOK.size-1){\n                longStr.append(\"\n\")\n            }\n        }\n        if(strTempPA.size>0 || strTempVA.size>0)\n            longStr.append(\"\n \")\n    }\n    if(strTempPA.size>0){\n        strTempPA.sort()\n        longStr.append(state.getValue(\"PA\")+\"\n\")\n        for(i in 0 until strTempPA.size){\n            longStr.append(\"..... ${state.getValue(\"PA\").let { it1 -> strTempPA[i].replace(\"PA\",it1) }}\")\n            if(i!=strTempPA.size-1){\n                longStr.append(\"\n\")\n            }\n        }\n        if(strTempVA.size>0)\n            longStr.append(\"\n \")\n    }\n    if(strTempVA.size>0){\n        strTempVA.sort()\n        longStr.append(state.getValue(\"VA\")+\"\n\")\n        for(i in 0 until strTempVA.size){\n            longStr.append(\"..... ${state.getValue(\"VA\").let { it1 -> strTempVA[i].replace(\"VA\",it1) }}\")\n            if(i!=strTempVA.size-1){\n                longStr.append(\"\n\")\n            }\n        }\n    }\n\n    return longStr.toString()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207902,"user_id":null,"body":"package solution\n\nobject State {\n\n    fun byState(str: String): String {\n        fun getFullLocation(loc: String):String{\n            return when (loc) {\n                \"AZ\" -> \"Arizona\"\n                \"CA\" -> \"California\"\n                \"ID\" -> \"Idaho\"\n                \"IN\" -> \"Indiana\"\n                \"MA\" -> \"Massachusetts\"\n                \"OK\" -> \"Oklahoma\"\n                \"PA\" -> \"Pennsylvania\"\n                \"VA\" -> \"Virginia\"\n                else -> \"Not found\"\n            }\n        }\n\n        class Person(data: String){\n            var location =data[data.length-2].toString()+data[data.length-1]\n            var info=data.substring(0, data.length-2)+getFullLocation(location)\n            init {\n                location=getFullLocation(location)\n                info=String(info.toCharArray().filter { it!=',' }.toCharArray())\n            }\n\n\n        }\n\n        var temp=str.split('\n').map { Person(it) }.groupBy { it.location }.toSortedMap()\n        var res =\"\"\n        var spaces=false\n        for ((index, value) in temp){\n            res+=if(spaces) \" \" else \"\"\n            res+=index+\"\n\"\n            var people = value.sortedBy { it.info }\n            for(item in people){\n                res+=\"..... \"+item.info+\"\n\"\n            }\n\n\n\n\n            spaces=true\n        }\n\n\n        return res.substring(0,res.length-1)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207903,"user_id":null,"body":"package solution\n\nobject State {\n    class Person(n: String, a: String, c: String, s: String){\n        val name = n\n        val address = a\n        val city = c\n        val state = s\n        override fun toString(): String = \"$name $address $city $state\"\n    }\n    val key = mapOf<String,String>(\n        \"MA\" to \"Massachusetts\", \"VA\" to \"Virginia\", \"PA\" to \"Pennsylvania\",\n        \"AZ\" to \"Arizona\", \"CA\" to \"California\", \"ID\" to \"Idaho\",\n        \"IN\" to \"Indiana\", \"OK\" to \"Oklahoma\" )\n\n\n    fun extract(s: String): Array<String> {\n        val a = s.split(\",\")\n        val name = a[0].trim()\n        val addr = a[1].trim()\n        val city = a[2].trim().dropLast(3)\n        val state = key[a[2].drop(a[2].length-2)]!!\n        return arrayOf(name,addr,city,state)\n    }\n\n    fun byState(str: String): String {\n        val states = mutableListOf<String>()\n        val list = mutableListOf<Person>()\n        var res = \"\"\n        val address = str.split(\"\n\")\n        for(el in address){\n            val a = extract(el)\n            val p = Person(a[0],a[1],a[2],a[3])\n            if(!states.contains(a[3])) states.add(a[3])\n            list.add(p)\n        }\n        for(st in states.sorted()){\n            res += \" $st\n\"\n            val tmp = mutableListOf<String>()\n            list.forEach{\n                if(it.state == st){\n                    tmp.add(it.toString())\n                }\n            }\n            for(p in tmp.sorted()){\n                res += \"..... $p\n\"\n            }\n        }\n\n        return res.drop(1).dropLast(1)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207904,"user_id":null,"body":"package solution\n\nobject State {\n\n  val stateList: Map<String, String> = mapOf(\"AZ\" to \"Arizona\",\n  \"CA\" to \"California\",\n  \"ID\" to \"Idaho\",\n  \"IN\" to \"Indiana\",\n  \"MA\" to \"Massachusetts\",\n  \"OK\" to \"Oklahoma\",\n  \"PA\" to \"Pennsylvania\",\n  \"VA\" to \"Virginia\"\n  )\n\n  fun byState(str: String): String {\n    val finalMap: Map<String, MutableList<String>> = stateList.values.toList().map { it to mutableListOf<String>() }.toMap()\n    val wordList = str.replace(\"\n\", \" \").split(\" \", \",\").toMutableList()\n    \n    var startingIndex = 0\n    for((index, word) in wordList.withIndex()) {\n      if(stateList[word] != null) {\n        val name = \"..... \" + (wordList.slice(startingIndex..index -1).filter { it != \"\" }.joinToString(\" \")) + \" \" + stateList[word]\n        val state = stateList[word]!!\n        finalMap[state]?.add(name)\n        startingIndex = index + 1\n      }\n    }\n    val final = buildFinalString(finalMap)\n    return final\n  }\n\n  private fun buildFinalString(finalMap: Map<String, MutableList<String>>): String {\n    var final = \"\"\n    finalMap.forEach {\n      if(it.value.isNotEmpty()) {\n        it.value.sort()\n        final = final + it.key + \"\n\"\n        it.value.forEach {\n          final = final + it + \"\n\"\n        }\n        final += \" \"\n      }\n      }\n    return final.trim()\n  }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207905,"user_id":null,"body":"package solution\n\nobject State {\n    private val statesByAcr = mapOf(\n        \"AZ\" to \"Arizona\",\n        \"CA\" to \"California\", \"ID\" to \"Idaho\", \"IN\" to \"Indiana\",\n        \"MA\" to \"Massachusetts\", \"OK\" to \"Oklahoma\", \"PA\" to \"Pennsylvania\",\n        \"VA\" to \"Virginia\",\n    )\n\n    fun byState(str: String) = buildString {\n        str.replace(\",\", \"\").split(\"\n\").map { it.substring(0, it.length-2) + statesByAcr[it.takeLast(2)] }\n            .groupBy { it.substringAfterLast(\" \") }.toSortedMap().forEach { (state, people) ->\n                append(\" $state\n\")\n                for (p in people.sorted()) {\n                    append(\"..... $p\n\")\n                }\n            }\n        this.deleteCharAt(0).deleteCharAt(this.length-1)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"59d727d40e8c9dd2dd00009f":[{"id":207906,"user_id":null,"body":"object EasyBalance {\n    fun balance(book: String): String {\n        var total = 0.0\n        val spaceRegex = \"\\\\s+\".toRegex()\n        val amountRegex = \"\\\\d+\\\\.?\\\\d?\".toRegex()\n        val lines = book.trim().replace(Regex(\"\"\"[^\\w\\d\\s.]\"\"\"), \"\").split(\"\n\")\n        var balance = amountRegex.find(lines.first())?.value?.toDoubleOrNull() ?: 0.0\n        val result = mutableListOf<String>()\n\n        result.add(\"Original Balance: ${formatRounded(balance)}\")\n\n        for (line in lines.drop(1)) {\n\n            val (checkNumber, category, amount) = line.split(spaceRegex)\n            balance -= amount.toDouble()\n            total += amount.toDouble()\n\n            result.add(\"$checkNumber $category $amount Balance ${formatRounded(balance)}\")\n        }\n\n        val average = total \/ (lines.size - 1)\n        result.add(\"Total expense  ${formatRounded(total)}\")\n        result.add(\"Average expense  ${formatRounded(average)}\")\n\n        return result.joinToString(\"\\\\r\\\n\")\n    }\n\n    private fun formatRounded(balance: Double) = String.format(\"%.2f\", balance)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207907,"user_id":null,"body":"package solution\n\nimport java.util.*\n\nobject EasyBalance {\n    private fun format(n: Double): String = String.format(Locale.ENGLISH, \"%.2f\", n)\n    fun balance(book: String): String {\n        val bookCleaned = book.trim().replace(Regex(\"[^A-Za-z0-9\\\\.\\\\s]\"), \"\")\n        val originalBalance = bookCleaned.substringBefore(\"\n\").toDouble()\n        val info = bookCleaned.substringAfter(\"\n\").split(\"\n\").map { it.trim().split(Regex(\"\\\\s+\")) }.filter { it.size == 3 }\n        if (info.isEmpty()) {\n            return \"Original Balance: ${format(originalBalance)}\"\n        }\n        val balanceAt = mutableListOf(format(originalBalance - info[0][2].toDouble()).toDouble())\n        for (i in 1 until info.size) {\n            balanceAt.add(format(balanceAt[i - 1] - info[i][2].toDouble()).toDouble())\n        }\n\n        return \"Original Balance: ${format(originalBalance)}\\\\r\\\n\" +\n                info.mapIndexed { index, value -> value.joinToString(\" \") + \" Balance \" + format(balanceAt[index]) }\n                    .joinToString(\"\\\\r\\\n\") +\n                \"\\\\r\\\nTotal expense  \" + format(originalBalance - balanceAt.last()) +\n                \"\\\\r\\\nAverage expense  \" + format((originalBalance - balanceAt.last()) \/ balanceAt.size.toDouble())\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207908,"user_id":null,"body":"package solution\n\n\n\nobject EasyBalance {\n\n    fun balance(book: String): String {\n        val filtered_book = book.filter{ it-> it.isDigit() || it == '.' || it.isWhitespace() || it.isLetter()}\n        val lines = filtered_book.split(\"\n\")\n        var balance = lines.first().toDouble()        \n        var total_expense = 0.0\n        var total_count = 0\n        val list = ArrayList<String>()\n        list.add(\"Original Balance: \" + String.format(\"%.2f\",balance))\n        for(line in lines.drop(1)) {\n            if (line.trim() == \"\") continue\n            \n            val regex = \"\"\"([\\d]+)([\\ \\t]+)([a-zA-Z]+)([\\ \\t]+)([\\d\\.]+)\"\"\".toRegex()\n            val matchResult = regex.find(line)\n            val (check_number,_,check_category,_,check_amount_str) = matchResult!!.destructured\n            val check_amount = check_amount_str.toDouble()\n            balance -= check_amount\n            total_expense += check_amount\n            total_count++\n            list.add(\"$check_number $check_category $check_amount_str Balance \" + String.format(\"%.2f\", balance))\n        }\n        \n        list.add(\"Total expense  \" + String.format(\"%.2f\",total_expense))\n        val average_expense = total_expense \/ total_count\n        list.add(\"Average expense  \" + String.format(\"%.2f\",average_expense))\n             \n        return list.joinToString(\"\\\\r\\\n\")\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207909,"user_id":null,"body":"package solution\n\nobject EasyBalance {\n\n    fun balance(book: String): String {\n    val str = book.split(\"\n\").toMutableList()\n    val patternCount = Regex(\"\"\"(\\d+\\.\\d{2})\"\"\")\n    val patternNumber = Regex(\"\"\"(\\d+)\"\"\")\n    val patternWord = Regex(\"\"\"[A-Za-z]+\"\"\")\n    var balance = patternCount.find(str.first())!!.value.toDouble()\n    val total = mutableListOf<Double>()\n\n    str[0] = \"\"\n\n    val res = buildString {\n        append(\"Original Balance: ${String.format(\"%.2f\", balance)}\\\\r\\\n\")\n\n        for (item in str){\n            if (str.first() == item) continue\n            val count = patternCount.find(item)!!.value.toDouble()\n\n            total.add(count)\n            append(patternNumber.find(item)!!.value).append(\" \")\n            append(patternWord.find(item)!!.value).append(\" \")\n            append(\"${String.format(\"%.2f\",count)} \")\n            append(\"Balance ${String.format(\"%.2f\", balance - count)}\\\\r\\\n\")\n            balance -= count\n\n        }\n        append(\"Total expense  ${String.format(\"%.2f\", total.sum())}\\\\r\\\n\")\n        append(\"Average expense  ${String.format(\"%.2f\", total.average())}\")\n    }\n    return res\n}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207910,"user_id":null,"body":"package solution\n\nobject EasyBalance {\n\n    fun balance(book: String): String {\n        val res = mutableListOf<String>()\n    val lines = book.lines().filter { it.isNotEmpty() }\n    val filterLines = lines.map { line -> line.filter { Regex(\"[a-zA-Z0-9. ]\").matches(it.toString()) } }\n\n    var balance: Double = try {\n        filterLines.first().toDouble()\n    } catch (e: NumberFormatException) {\n        return \"\"\n    }\n\n    var totalExpense = 0.0\n\n    res.add(\"Original Balance: ${String.format(\"%.2f\", balance)}\")\n\n    for (i in 1..filterLines.lastIndex) {\n        try {\n            val regex = \"[\\\\h]+\".toRegex()\n            val line = if (filterLines[i][0].toString() == \" \") {\n                filterLines[i].replaceFirst(regex, \"\")\n            } else {\n                filterLines[i]\n            }\n\n            val (id, note, sAmount) = line.split(regex)\n\n            val amount = sAmount.toDouble()\n            balance -= amount\n            totalExpense += amount\n\n            res.add(\"$id $note $sAmount Balance ${String.format(\"%.2f\", balance)}\")\n        } catch (e: Exception) {\n\n        }\n    }\n    res.add(\"Total expense  ${String.format(\"%.2f\", totalExpense)}\")\n    res.add(\"Average expense  ${String.format(\"%.2f\", totalExpense \/ (filterLines.count().dec()))}\")\n\n    return res.joinToString(\"\\\\r\\\n\")\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207911,"user_id":932,"body":"package solution\n\nobject EasyBalance {\n\nfun balance(s: String): String{\n    val lines = s.lines()\n    var balance = lines.first().filter{it.isDigit() || it=='.'}.toFloat()\n    val answer = ArrayList<String>()\n    var totalExpense = 0f\n    var totalItem = 0\n    val regex=Regex(\"\\\\s+\")\n    answer.add(String.format(\"Original Balance: %2.2f\",balance))\n    lines.drop(1).forEach {\n        it.filter{it.isLetter() || it.isDigit() || it==' ' || it=='.'}.trim().split(regex).let{ it ->\n            if(it.size==3) {\n                val price = it.last().filter{it.isDigit() || it=='.'}.toFloat()\n                val id = it.first()\n                val name = it[1].filter{it.isLetter()}\n                balance -= price\n                totalExpense += price\n                totalItem++\n                answer.add(String.format(\"%s %s %2.2f Balance %2.2f\", id, name, price, balance))\n            }\n        }\n    }\n    answer.add(String.format(\"Total expense  %2.2f\", totalExpense))\n    answer.add(String.format(\"Average expense  %2.2f\", totalExpense\/totalItem))\n    return answer.joinToString(\"\\\\r\\\n\")\n}\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207912,"user_id":null,"body":"package solution\n\nimport java.text.DecimalFormat\nimport java.text.DecimalFormatSymbols\nimport java.util.*\n\nobject EasyBalance {\n\n    fun balance(book: String): String {\n        \n       val filtered = book.filter { it.isLetterOrDigit() || it.isWhitespace() || it == '.'}\n            .replace(\" +\".toRegex(), \" \")\n            .split(\"\n\").map{it.trim()}.filter { it.isNotEmpty() }\n        val balance = filtered.first()\n        val df = DecimalFormat(\"#.00\")\n        df.decimalFormatSymbols = DecimalFormatSymbols.getInstance(Locale.US)\n\n        var b = balance.toDouble()\n        var sum = 0.0\n\n        val y = filtered.drop(1).map { it to it.substringAfterLast(\" \").toDouble() }.joinToString(\"\\\\r\\\n\") {\n            b -= it.second\n            sum += it.second\n            \"${it.first} Balance ${df.format(b)}\"\n        }\n        return \"Original Balance: $balance\\\\r\\\n${y}\\\\r\\\nTotal expense  ${df.format(sum)}\\\\r\\\nAverage expense  ${df.format(sum\/(filtered.size-1))}\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207913,"user_id":null,"body":"package solution\n\nimport java.lang.Double.valueOf\nimport java.text.DecimalFormat\nimport java.util.regex.Pattern\n\nobject EasyBalance {\n    private const val NL = \"\\\\r\\\n\"\n\n    fun balance(book: String): String {\n        val buff = StringBuilder()\n        val itemPattern = Pattern.compile(\"((\\\\d+)([^\\\\d]+))*(\\\\d+\\\\.\\\\d+)\")\n        var balance = 0.0\n        var total = 0.0\n        var itemsCount = 0\n        for (line in book.split(Regex(\"\\\n\"))) {\n            val matcher = itemPattern.matcher(line)\n            if (matcher.find()) {\n                val value = valueOf(matcher.group(4))\n                if (matcher.group(1) == null) {\n                    balance = value\n                    buff.append(\"Original Balance: ${balance.format(2)}\")\n                } else {\n                    buff.append(\"${matcher.group(2)} ${matcher.group(3).replace(Regex(\"\\\\W\"), \"\")} ${matcher.group(4)}\")\n                    balance -= value\n                    total += value\n                    itemsCount++\n                    buff.append(\" Balance ${balance.format(2)}\")\n                }\n                buff.append(NL)\n            }\n        }\n\n        buff.append(\"Total expense  ${total.format(2)}${NL}Average expense  ${(total\/itemsCount).format(2)}\")\n        return buff.toString()\n    }\n}\n\nfun Double.format(fracDigits: Int) : String {\n    val df = DecimalFormat()\n    df.minimumFractionDigits = fracDigits\n    df.maximumFractionDigits = fracDigits\n    df.isGroupingUsed = false\n    return df.format(this)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207914,"user_id":null,"body":"package solution\n\nimport java.math.BigDecimal\nimport java.math.RoundingMode\n\nobject EasyBalance {\n    private fun BigDecimal.round2() = this.setScale(2, RoundingMode.HALF_UP)\n\n    fun balance(book: String) = buildString {\n        val lines = book\n            .filter { it.isLetterOrDigit() || it in \". \n\" }\n            .split(\"\n\")\n            .filter { it.isNotBlank() }\n\n        var balance = lines.first().toBigDecimal()\n        append(\"Original Balance: ${balance.round2()}\\\\r\\\n\")\n\n        val amounts = lines\n            .drop(1)\n            .map { l ->\n                val (\n                    checkNumber,\n                    category,\n                    checkAmount\n                ) = l.trim().split(\"\\\\s+\".toRegex())\n                checkAmount.toBigDecimal().also { amount ->\n                    balance -= amount\n                    append(\"$checkNumber $category ${amount.round2()} Balance ${balance.round2()}\\\\r\\\n\")\n                }\n            }\n\n        val totalExpense = amounts.sumOf { it }\n        val averageExpense = totalExpense \/ amounts.size.toBigDecimal()\n        append(\"Total expense  ${totalExpense.round2()}\\\\r\\\n\")\n        append(\"Average expense  ${averageExpense.round2()}\")\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207915,"user_id":null,"body":"package solution\nimport kotlin.math.round\n\nobject EasyBalance {\n    fun balance(book: String): String {\n        val clear = book.map {\n            if (it in 'a'..'z' || it in 'A'..'Z' || it in '0'..'9' || it in \".\n \") it else '#'\n        }.joinToString(\"\").replace(\"#\",\"\").replace(\"   \",\" \").replace(\"  \",\" \")\n         .split(\"\n\").filter{it.trim().length > 0}\n        \n        if (clear.size == 0) return \"\"\n        \n        val original_bal = clear[0].toFloat()\n        var cur_bal = original_bal\n        var expenses = 0F\n        \n        val lines = clear.drop(1).map { l ->\n            val vals = l.split(' ').filter{it.trim().length > 0}\n            val amount = vals[2].toFloat()\n            expenses += round(amount*100)\/100\n            cur_bal -= amount\n            \"${vals[0]} ${vals[1]} ${vals[2]} Balance %.2f\".format(round(cur_bal*100)\/100)\n        }.joinToString(\"\\\\r\\\n\")\n        \n        val ret = (\"Original Balance: %.2f\\\\r\\\n\".format(original_bal) \n        + lines + \"\\\\r\\\n\"\n        + \"Total expense  %.2f\\\\r\\\n\".format(round(expenses*100)\/100)\n        + \"Average expense  %.2f\".format(round(expenses\/(clear.size-1)*100)\/100) )\n        \n        return ret\n    }\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"59d7c910f703c460a2000034":[{"id":207916,"user_id":null,"body":"import kotlin.math.pow\n\nobject Quest {\n    fun solomonsQuest(r: Array<Triple<Int,Int,Int>>): Pair<Int,Int> {\n        var (x, y, z) = Triple(0, 0, 0)\n        for (triple in r) {\n            z += triple.first\n            val distance = triple.third * 2.0.pow(z).toInt()\n            when(triple.second) {\n                0 -> y += distance\n                1 -> x += distance\n                2 -> y -= distance\n                3 -> x -= distance\n            }\n        }\n        return Pair(x, y)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207917,"user_id":470,"body":"package kata\n\nobject Quest {\n\tfun solomonsQuest(r:Array<Triple<Int,Int,Int>>): Pair<Int,Int> {\n\t\tval dlist = arrayOf(0 to 1,1 to 0,0 to -1,-1 to 0)\n\t\tvar z = 1\n\t\treturn r.fold(Pair(0,0)) { ac,(td,dr,dist) ->\n\t\t\tz = if (td < 0) { z shr -td } else { z shl td }\n\t\t\tdlist[dr].let { (x,y) -> Pair(x*z*dist + ac.first,y*z*dist + ac.second) } }\n\t}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207918,"user_id":null,"body":"package kata\nimport kotlin.math.pow\n\nobject Quest {\n    fun solomonsQuest(r: Array<Triple<Int,Int,Int>>): Pair<Int,Int> {\n        var currentTimeShift = 0\n        var currentX = 0.0\n        var currentY = 0.0\n\n        r.forEach {\n            currentTimeShift += it.first\n            val distance = it.third * 2.0.pow(currentTimeShift)\n            when (it.second) {\n                0 -> currentY += distance\n                1 -> currentX += distance\n                2 -> currentY -= distance\n                3 -> currentX -= distance\n            }\n        }\n        return Pair(currentX.toInt(), currentY.toInt())\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207919,"user_id":null,"body":"package kata\n\nimport kotlin.math.pow\n\nobject Quest {\n    fun solomonsQuest(r: Array<Triple<Int,Int,Int>>): Pair<Int,Int> {\n        var level = 0.0\n        var x = 0\n        var y = 0\n\n        r.forEach { triple ->\n            level += triple.first\n            val position = triple.third * 2.0.pow(level).toInt()\n\n            when (triple.second) {\n                0 -> y += position\n                1 -> x += position\n                2 -> y -= position\n                3 -> x -= position\n            }\n        }\n\n        return x to y\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207920,"user_id":null,"body":"package kata\n\nobject Quest {\n    fun solomonsQuest(r: Array<Triple<Int,Int,Int>>): Pair<Int,Int> {\n        var x : Int = 0\n        var y : Int = 0\n        var level : Int = 0\n        val directions : HashMap<Int,Pair<Int,Int>> = hashMapOf( 0 to Pair(0,1), 1 to Pair(1,0), 2 to Pair(0,-1), 3 to Pair(-1,0) )\n        for((shift,direction,distance) in r) {\n            level += shift\n            val (dx,dy) = directions[direction]!!\n            x += distance*dx*( 1 shl level)\n            y += distance*dy*( 1 shl level)\n        }\n        \n        return Pair(x,y)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207921,"user_id":null,"body":"package kata\n\nobject Quest {\n    fun solomonsQuest(r: Array<Triple<Int,Int,Int>>): Pair<Int,Int> {\n    var location = Pair(0, 0)\n    var dilation = 0\n    var distance = 0\n    for (commands: Triple<Int, Int, Int> in r) {\n        dilation += commands.first\n        distance = commands.third\n        repeat (dilation) {\n            distance *= 2\n        }\n        when (commands.second) {\n            0 -> location = Pair(location.first, location.second + distance)\n            1 -> location = Pair(location.first + distance, location.second)\n            2 -> location = Pair(location.first, location.second - distance)\n            3 -> location = Pair(location.first - distance, location.second)\n            else -> println(\"error\")\n        }\n    }\n    return location\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207922,"user_id":null,"body":"package kata\n\nobject Quest {\n    fun solomonsQuest(r: Array<Triple<Int, Int, Int>>): Pair<Int, Int> {\n        var currentLevel = 0\n        return r.fold(0 to 0) { pair, (level, direction, distance) ->\n            currentLevel += level\n            val diff = distance.shl(currentLevel)\n            when (direction) {\n                0 -> pair.copy(second = pair.second + diff)\n                1 -> pair.copy(first = pair.first + diff)\n                2 -> pair.copy(second = pair.second - diff)\n                3 -> pair.copy(first = pair.first - diff)\n                else -> pair\n            }\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207923,"user_id":null,"body":"package kata\n\nimport kotlin.math.pow\n\nobject Quest {\nfun solomonsQuest(r: Array<Triple<Int,Int,Int>>): Pair<Int,Int> {\n    var x = 0\n    var y = 0\n    var dilation = 0\n    r.forEach{value ->\n        dilation += value.first\n        when(value.second){\n            0 -> y += value.third * 2.00.pow(dilation).toInt()\n            1 -> x += value.third * 2.00.pow(dilation).toInt()\n            2 -> y -= value.third * 2.00.pow(dilation).toInt()\n            3 -> x -= value.third * 2.00.pow(dilation).toInt()\n            else -> {}\n        }\n        }\n\n    return Pair(x,y)\n}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207924,"user_id":null,"body":"import kotlin.math.pow\n\nobject Quest {\n    fun solomonsQuest(r: Array<Triple<Int,Int,Int>>): Pair<Int,Int> {\n        var (x, y, z) = Triple(0, 0, 0)\n        for(i in r) {\n            z += i.first\n            when(i.second) {\n                0 -> y += i.third * 2.0.pow(z).toInt()\n                1 -> x += i.third * 2.0.pow(z).toInt()\n                2 -> y -= i.third * 2.0.pow(z).toInt()\n                3 -> x -= i.third * 2.0.pow(z).toInt()\n            }\n        }\n        return Pair(x, y)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207925,"user_id":null,"body":"package kata\n\nimport kotlin.math.*\n\nobject Quest {\n    fun solomonsQuest(r: Array<Triple<Int, Int, Int>>): Pair<Int, Int> {\n    val position = r.fold(Triple(0, 0, 0))\n    { acc, t ->\n        val next = move(acc, t)\n        next\n    }\n    return position.first to position.second\n}\n\nfun move(current: Triple<Int, Int, Int>, by: Triple<Int, Int, Int>): Triple<Int, Int, Int> {\n    val newDilation = (current.third + by.first).coerceAtLeast(0)\n    val absDistance = (by.third * 2f.pow(newDilation)).toInt()\n\n    return when (by.second) {\n        0 -> Triple(current.first, current.second + absDistance, newDilation)\n        1 -> Triple(current.first + absDistance, current.second, newDilation)\n        2 -> Triple(current.first, current.second - absDistance, newDilation)\n        else -> Triple(current.first - absDistance, current.second, newDilation)\n    }\n}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"59d9d8cb27ee005972000045":[{"id":207926,"user_id":null,"body":"fun catalog(s: String, article: String): String {\n    return Regex(\"\"\"^<prod><name>([^<]+)<\/name><prx>([^<]+)<\/prx><qty>([^<]+)<\/qty><\/prod>$\"\"\", RegexOption.MULTILINE)\n            .findAll(s)\n            .filter { matches -> matches.groups[1]?.let { article in it.value } ?: false }\n            .joinToString(\"\n\") { \"${it.groups[1]!!.value} > prx: $${it.groups[2]!!.value} qty: ${it.groups[3]!!.value}\" }\n            .takeUnless { it.isEmpty() } ?: \"Nothing\"\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207927,"user_id":null,"body":"fun catalog(s: String, article: String): String = s.split(\"\n\n\")\n            .filter { it.contains(article) }\n            .joinToString(\"\n\") {\n                it.replace(Regex(\"\"\"<prod><name>(.*?)<\/name><prx>(.*?)<\/prx><qty>(.*?)<\/qty><\/prod>\"\"\")) { result ->\n                    \"${result.groupValues[1]} > prx: $${result.groupValues[2]} qty: ${result.groupValues[3]}\"\n                }}\n            .ifEmpty { \"Nothing\" }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207928,"user_id":null,"body":"fun catalog(s: String, article: String): String {\n   \n  val founded = s.split(\"\n\").filter{it.contains(article)}.joinToString(separator=\"\n\")\n  if (founded == \"\") \n    return \"Nothing\"\nelse\n      return founded.replace(\"<prod><name>\",\"\")\n          .replace(\"<\/name><prx>\", \" > prx: $\")\n          .replace(\"<\/prx><qty>\",\" qty: \")\n          .replace(\"<\/qty><\/prod>\",\"\")\n \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207929,"user_id":null,"body":"fun catalog(s: String, article: String): String {\n        val lineRegex = Regex(\"(.*)$article(.*)\")\n        val lines = lineRegex.findAll(s)\n        val result = StringBuilder()\n        if (lines.count() == 0)\n            return \"Nothing\"\n        val multipleLines = lines.count() > 1\n\n        val iterator = lines.iterator()\n\n        while (iterator.hasNext()) {\n            findCatalog(iterator.next().value, article, multipleLines, !iterator.hasNext(), result)\n        }\n        println(result)\n        println()\n        return if (result.isBlank()) \"Nothing\" else result.toString()\n    }\n\n    fun findCatalog(\n        line: String,\n        article: String,\n        multipleLines: Boolean,\n        isLastLine: Boolean,\n        result: StringBuilder\n    ) {\n\n        val nameRegex = Regex(\"<name>(.*)<\/name>\")\n        val priceRegex = Regex(\"<prx>(([0-9]*[.])?[0-9]*)<\/prx>\")\n        val qtyRegex = Regex(\"<qty>([0-9]*)<\/qty>\")\n\n        val name = extractValue(line, nameRegex)\n        val price = extractValue(line, priceRegex)\n        val qty = extractValue(line, qtyRegex)\n\n        if (!multipleLines || isLastLine)\n            result.append(getCatalogLineString(name, price, qty))\n        else\n            result.appendLine(getCatalogLineString(name, price, qty))\n    }\n\n    fun extractValue(line: String, regex: Regex): String {\n        val res = regex.find(line)\n        res?.let {\n            val value = res.groupValues[1]\n            return value\n        }\n        return \"\"\n    }\n\n    fun getCatalogLineString(name: String, price: String, qty: String): String {\n        return \"$name > prx: $$price qty: $qty\"\n    }\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207930,"user_id":932,"body":"fun catalog(src: String, key: String) = Regex(\"\"\"<prod><name>(.+)<\/name><prx>(.+)<\/prx><qty>(.+)<\/qty><\/prod>\"\"\")\n    .findAll(src).filter {it.groupValues[1].contains(key)}\n    .map {\"${it.groupValues[1]} > prx: $${it.groupValues[2]} qty: ${it.groupValues[3]}\"}\n    .joinToString(\"\n\").ifEmpty {\"Nothing\"}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207931,"user_id":null,"body":"fun catalog(s: String, article: String): String {\n    val products = s.split(\"\n\n\").filter { article in it }\n    val output = mutableListOf<String>()\n    if (products.isNullOrEmpty()) output.add(\"Nothing\")\n    else {\n        for (product in products) {\n            val (name, prx, qty) = product.split(\"<prod><name>\", \"<\/name><prx>\", \"<\/prx><qty>\", \"<\/qty><\/prod>\")\n                .filter {it != \"\"}\n            output.add(\"$name > prx: $$prx qty: $qty\")\n            \n        }\n    }\n    return output.joinToString(\"\n\")\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207932,"user_id":1381,"body":"fun catalog(s: String, article: String): String {\n    return s.lines().filter { it.contains(article) }\n        .map { it.replace(Regex(\"<.*?>\"), \"|\").split(\"||\") }\n        .joinToString(\"\n\") { \"${it[1]} > prx: $${it[2]} qty: ${it[3]}\" }\n        .ifEmpty { \"Nothing\" }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207933,"user_id":null,"body":"fun catalog(s: String, article: String): String {\n    val articles = s.split(\"\n\")\n       .filter { line -> line.substringAfter(\"<name>\").substringBefore(\"<\/name>\").contains(article) }\n       .map {\n         val name = it.substringAfter(\"<name>\").substringBefore(\"<\/name>\")\n         val price = it.substringAfter(\"<prx>\").substringBefore(\"<\/prx>\")\n         val qty = it.substringAfter(\"<qty>\").substringBefore(\"<\/qty>\")\n         \"$name > prx: \\$$price qty: $qty\"\n       }\n       .joinToString(\"\n\")\n    return if (articles.isBlank()) \"Nothing\"\n    else articles\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207934,"user_id":null,"body":"val regex = \"\"\"<prod><name>(.*)<\/name><prx>(.*)<\/prx><qty>(.*)<\/qty><\/prod>\"\"\".toRegex()\nfun catalog(s: String, article: String) = regex.findAll(s)\n    .map { it.destructured }\n    .filter { (name) -> name.contains(article) }\n    .joinToString(\"\n\"){ (name, prx, qty) -> \"$name > prx: $$prx qty: $qty\"}\n    .ifBlank{ \"Nothing\" }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207935,"user_id":null,"body":"fun catalog(s: String, article: String): String =\n    Regex(\"\"\"<prod><name>(.+)<\/name><prx>(.+)<\/prx><qty>(.+)<\/qty><\/prod>\"\"\")\n        .findAll(s)\n        .filter { it.groupValues[1].contains(article) }\n        .joinToString(\"\n\") {\n            val (_, name, price, qty) = it.groupValues\n            \"$name > prx: $$price qty: $qty\"\n        }.ifEmpty { \"Nothing\" }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"59de1e2fe50813a046000124":[{"id":207936,"user_id":null,"body":"package solution\n\nobject MatchSubst {\n    private val phoneValidator = \"\"\"^Phone: \\+1-\\d{3}-\\d{3}-\\d{4}$\"\"\".toRegex()\n    private val versionValidator = \"\"\"^Version: \\d+\\.\\d+$\"\"\".toRegex()\n    private val validationErrorMessage = \"ERROR: VERSION or PHONE\"\n\n    fun change(s: String, prog: String, version: String) = s.split(\"\n\")\n        .filterNot { it.startsWith(\"Corporation\") || it.startsWith(\"Level\") }\n        .map { when {\n            it.startsWith(\"Program\")     -> \"Program: $prog\"\n            it.startsWith(\"Auth\")        -> \"Author: g964\"\n            it.startsWith(\"Date\")        -> \"Date: 2019-01-01\"\n            it.equals(\"Version: 2.0\")    -> it\n            it.startsWith(\"Phone:\")      -> if (phoneValidator.matches(it)) \"Phone: +1-503-555-0090\" else return validationErrorMessage\n            it.startsWith(\"Version:\")    -> if (versionValidator.matches(it)) \"Version: $version\" else return validationErrorMessage\n            else                         -> it\n        }}.joinToString(\" \")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207937,"user_id":1381,"body":"package solution\n\nobject MatchSubst {\n\n    fun change(s: String, prog: String, version: String): String {\n        if (phone(s) == null || version(s) == null) {\n            return \"ERROR: VERSION or PHONE\"\n        }\n        return \"Program: $prog Author: g964 Phone: +1-503-555-0090 Date: 2019-01-01 Version: ${if (version(s) == \"2.0\") \"2.0\" else version}\"\n    }\n    \n    private fun phone(s: String) = Regex(\"Phone: (\\\\+1-\\\\d{3}-\\\\d{3}-\\\\d{4})\").find(s)?.groupValues?.get(1)\n\n    private fun version(s: String) = Regex(\"Version: (\\\\d+\\\\.\\\\d+)\n\").find(s)?.groupValues?.get(1)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207938,"user_id":null,"body":"package solution\n\nobject MatchSubst {\n    val versionOrPhoneError = \"ERROR: VERSION or PHONE\"\n    val phoneExtractRegex = \"\"\"Phone:\\s*(\\+1-\\d{3}-\\d{3}-\\d{4})\"\"\".toRegex()\n    val versionExtractRegex = \"\"\"Version:\\s*(\\d+\\.\\d+)\\s\"\"\".toRegex()\n\n    fun change(s: String, prog: String, version: String): String {\n        val phoneResult = phoneExtractRegex.find(s)\n        val versionResult = versionExtractRegex.find(s)\n        if (phoneResult == null || versionResult == null)\n            return versionOrPhoneError\n        val newVersion = versionResult.groupValues[1]\n            .let { if (it == \"2.0\") it else version }\n        return \"Program: $prog Author: g964 Phone: +1-503-555-0090 Date: 2019-01-01 Version: $newVersion\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207939,"user_id":null,"body":"package solution\n\nobject MatchSubst {\n\nfun change(s: String, prog: String, version: String): String {\n    val data = s.lines()\n        .filterNot { it.contains(\"Corporation\", ignoreCase = true) || it.contains(\"Level\", ignoreCase = true) }\n        .toMutableList()\n    \n    if (!data[4].validate(\"\\\\d+\\\\.\\\\d+\") || !data[2].validate(\"\\\\+1-\\\\d{3}-\\\\d{3}-\\\\d{4}\")) {\n        return \"ERROR: VERSION or PHONE\"\n    }\n    return Data(prog, version = if (data[4].split(\": \")[1] == \"2.0\") \"2.0\" else version).toString()\n}\n\nfun String.validate(regex: String): Boolean = split(\": \")[1].matches(Regex(regex))\n\ndata class Data(\n    val program: String,\n    val author: String = \"g964\",\n    val phone: String = \"+1-503-555-0090\",\n    val date: String = \"2019-01-01\",\n    val version: String,\n) {\n    override fun toString(): String {\n        return \"Program: $program Author: $author Phone: $phone Date: $date Version: $version\"\n    }\n}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207940,"user_id":null,"body":"package solution\n\nobject MatchSubst {\n\n    fun change(s: String, prog: String, version: String) = \n    s.split(\"\n\")\n        .map {\n            val arr = it.split(\": \")\n            val el = Pair(arr.first(), arr.last())\n            \n            when (el.first) {\n                \"Program title\" -> \"Program: $prog\"\n                \"Author\"        -> \"Author: g964\"\n                \"Date\"          -> \"Date: 2019-01-01\"\n                \"Phone\"         -> {\n                    if (!el.second.matches(\"\\\\+[1]-\\\\d{3}-\\\\d{3}-\\\\d{4}\".toRegex())) {\n                        return \"ERROR: VERSION or PHONE\"\n                    } else {\n                        \"Phone: +1-503-555-0090\"\n                    }\n                }\n                \"Version\"       -> {\n                    if (!el.second.matches(\"\\\\d+\\\\.\\\\d+\".toRegex())) {\n                        return \"ERROR: VERSION or PHONE\"\n                    } else {\n                        if (el.second != \"2.0\") {\n                            \"Version: $version\"\n                        } else {\n                            \"Version: ${el.second}\"\n                        }\n                    }\n                }\n                else            -> null\n            }\n        }.filterNotNull()\n        .joinToString(\" \")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207941,"user_id":null,"body":"package solution\n\nobject MatchSubst {\n\n    fun change(s: String, prog: String, version: String): String {\n        val vRegex = \"\\\\s\\\\d+[.]\\\\d+\\\n\".toRegex()\n        val tRegex = \"[+][1][-]\\\\d{3}[-]\\\\d{3}[-]\\\\d{4}\\\n\".toRegex()\n        if (!s.contains(tRegex) || !s.contains(vRegex)) return \"ERROR: VERSION or PHONE\"\n        val r = s.replace(\"Program title:\", \"Program:\").split(\"\n\")\n            .filter{!it.contains(\"Corporation: \")}\n            .filter{!it.contains(\"Level: \")}\n            .map{if (it.contains(\"Author: \")) \"Author: g964\" else it}\n            .map{if (it.contains(\"Date: \")) \"Date: 2019-01-01\" else it}\n            .map{if (it.contains(\"Program: \")) \"Program: $prog\" else it}\n            .map{if (it.contains(\"Phone: \")) \"Phone: +1-503-555-0090\" else it}\n            .map{if (it.contains(\"Version: \") && !it.contains(\" 2.0\")) \"Version: $version\" else it}\n        return r.joinToString(\" \")\n        }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207942,"user_id":null,"body":"package solution\n\nobject MatchSubst {\n\n    fun change(s: String, prog: String, version: String): String {\n    val input = s.split(\"\n\")\n    val regexPhoneNumber = Regex(\"^[\\\\+][1][-]?[(]?[0-9]{3}[)]?[-]?[0-9]{3}[-]?[0-9]{4}\\$\")\n    val regexVersion = Regex(\"^\\\\d+\\\\.\\\\d+\\$\")\n    val phone = input.find { it.contains(\"Phone: \")}?.split(\" \")?.toMutableList()?.removeAt(1)\n    var versionNew = input.find { it.contains(\"Version: \")}?.split(\" \")?.toMutableList()?.removeAt(1)\n\n    return if (phone?.matches(regexPhoneNumber) == false || versionNew?.matches(regexVersion) == false) {\n        \"ERROR: VERSION or PHONE\"\n    } else {\n        if (versionNew != \"2.0\") {\n            versionNew = version\n        }\n        \"Program: $prog Author: g964 Phone: +1-503-555-0090 Date: 2019-01-01 Version: $versionNew\"\n    }\n}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207943,"user_id":null,"body":"package solution\n\nobject MatchSubst {\n\n    fun change(s: String, prog: String, version: String): String {\n        val phone = s.split(\"\n\").filter{it.take(5)==\"Phone\"}.first()\n        var version_s = s.split(\"\n\").filter{it.take(7)==\"Version\"}.first().drop(8).trim()\n        return if(phone.filter{it.isDigit()}.length==11 && \"+1-\" in phone \n          && version_s[0].isDigit() && version_s.filter{it=='.'}.length==1) {\n            version_s = if(version_s==\"2.0\") \"2.0\" else version\n            \"Program: $prog Author: g964 Phone: +1-503-555-0090 Date: 2019-01-01 Version: $version_s\"\n        } else {\n            \"ERROR: VERSION or PHONE\"\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207944,"user_id":null,"body":"package solution\n\nobject MatchSubst {\n\n   fun change(s: String, prog: String, version: String): String {\n\tval versionIsValid: (String) -> Boolean = { lineVersion:String -> lineVersion.count { it == '.' } == 1 && lineVersion.contains(Regex(\"[^0,9.]\")) && lineVersion[0].digitToIntOrNull() != null}\n\tval phoneIsValid: (String) -> Boolean = { linePhone: String ->linePhone.mapIndexed { id, c -> if(id < 3 || c == '-') c else if(c.digitToIntOrNull() != null) 'x' else 'z'}.joinToString(\"\") == \"+1-xxx-xxx-xxxx\" }\n\n\tfun lineIsValid(line: String) : Boolean {\n\t\tif(line.startsWith(\"Version\") && (!versionIsValid(line.split(\": \")[1])) ) {\n            println(\"Version non valide ${versionIsValid(line.split(\": \")[1])} ${versionIsValid(version)}\")\n\t\t\treturn false\n\t\t} else if (line.startsWith(\"Corporation\") || line.startsWith(\"Level\")) {\n\t\t\treturn false\n\t\t} else if (line.startsWith(\"Phone\") && !phoneIsValid(line.split(\": \")[1])) {\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t}\n\n\tfun updateLine(line: String, prog: String) : String {\n\t\tif(line.startsWith(\"Program title\")) {\n\t\t\treturn \"Program: $prog\"\n\t\t}\n\t\tif(line.startsWith(\"Author\")) {\n\t\t\treturn \"Author: g964\"\n\t\t}\n\t\tif(line.startsWith(\"Date\")) {\n\t\t\treturn \"Date: 2019-01-01\"\n\t\t}\n\t\tif(line.startsWith(\"Version\") && line.split(\": \")[1] != \"2.0\") {\n\t\t\treturn \"Version: $version\"\n\t\t}\n\t\tif(line.startsWith(\"Phone\")) {\n\t\t\treturn \"Phone: +1-503-555-0090\"\n\t\t}\n\t\treturn line\n\t}\n\n\tval parsed = s.split(\"\n\").filter { lineIsValid(it) }.map { updateLine(it, prog) }.joinToString(\" \")\n    println(\"$s \n versionParam $version \n______ \n-> ${if(!parsed.contains(\"Version\") || !parsed.contains(\"Phone\")) \"ERROR: VERSION or PHONE\" else parsed} \n \")\n\treturn if(!parsed.contains(\"Version\") || !parsed.contains(\"Phone\")) \"ERROR: VERSION or PHONE\" else parsed\n}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207945,"user_id":null,"body":"package solution\n\nimport java.lang.IllegalArgumentException\n\nobject MatchSubst {\n    fun change(s: String, prog: String, version: String): String {\n        return try {\n            s.split(\"\n\")\n                .filter { !it.startsWith(\"Corporation:\") && !it.startsWith(\"Level: \") }\n                .map { it.replace(Regex(\"\"\"^Author:.*\"\"\"), \"Author: g964\") }\n                .map { it.replace(Regex(\"\"\"^Date:.*\"\"\"), \"Date: 2019-01-01\") }\n                .map { it.replace(Regex(\"\"\"\\b[Pp]rogram [Tt]itle:\\s*.*\"\"\"), \"Program: $prog\") }\n                .map { sanitizeVersion(it, version) }\n                .map { sanitizePhone(it) }\n                .joinToString(\" \")\n        } catch (e: IllegalArgumentException) {\n            \"ERROR: VERSION or PHONE\"\n        }\n    }\n\n    fun sanitizeVersion(line: String, version: String): String =\n        when {\n            !line.startsWith(\"Version:\") -> line\n            line.matches(Regex(\"\"\"^Version:\\s+2\\.0\\s*$\"\"\")) -> line\n            line.matches(Regex(\"\"\"^Version:\\s+\\d+\\.\\d+\\s*$\"\"\")) -> line.replace(Regex(\"\"\"\\d+\\.\\d+\"\"\"), version)\n            else -> throw IllegalArgumentException()\n        }\n\n    fun sanitizePhone(line: String): String =\n        when {\n            !line.startsWith(\"Phone:\") -> line\n            line.matches(Regex(\"\"\"^Phone:\\s+\\+1-\\d{3}-\\d{3}-\\d{4}\\s*$\"\"\")) -> \"Phone: +1-503-555-0090\"\n            else -> throw IllegalArgumentException()\n        }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"59df2f8f08c6cec835000012":[{"id":207946,"user_id":null,"body":"fun meeting(s: String) = s.toUpperCase()\n        .split(\";\")\n        .map { it.split(\":\") }\n        .map { \"(${it[1]}, ${it[0]})\" }\n        .sorted()\n        .joinToString(\"\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207947,"user_id":null,"body":"fun meeting(s: String): String {\n    return s.split(';')\n        .map { Person(it) }\n        .map { it.toString() }\n        .sorted()\n        .joinToString(\"\")\n}\n\nclass Person(input: String) {\n    private val firstName: String = input.takeWhile { it != ':' }\n    private val lastName: String = input.takeLastWhile { it != ':' }\n\n    override fun toString(): String {\n        return \"($lastName, $firstName)\".toUpperCase()\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207948,"user_id":null,"body":"fun meeting(s: String) =  s.toUpperCase().splitToSequence(';')\n        .map { it.split(\":\") }\n        .sortedWith(compareBy({it[1]}, {it[0]}))\n        .joinToString(\"\"){ (firstName, lastName) -> \"($lastName, $firstName)\"}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207949,"user_id":null,"body":"fun meeting(s: String) =\n        s.toUpperCase()\n                .split(\";\")\n                .map { it.split(\":\").let { name -> \"(${name.last()}, ${name.first()})\" } }\n                .sorted()\n                .joinToString(\"\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207950,"user_id":492,"body":"fun meeting(s: String) = \"(\" + s.toUpperCase().split(\";\")\n                .map{s -> s.split(\":\").reversed().joinToString(\", \")}\n                .sorted()\n                .joinToString(\")(\") + \")\"","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207951,"user_id":null,"body":"data class Person(val firstName: String, val lastName: String)\n\nfun meeting(s: String): String {\n    return s.toUpperCase().split(\";\")\n        .map { it.split(':') }\n        .map { Person(it[0], it[1]) }\n        .sortedWith(compareBy(Person::lastName).thenBy(Person::firstName))\n        .joinToString(\"\") { \"(${it.lastName}, ${it.firstName})\" }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207952,"user_id":null,"body":"fun meeting(s: String): String {\n            return s.uppercase().split(\";\")\n            .map {\n                val splited = it.split(\":\")\n                Pair(splited[1], splited[0])\n            }\n            .sortedWith(compareBy({it.first}, {it.second}))\n            .joinToString(\"\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207953,"user_id":null,"body":"fun meeting(s: String): String {\n    val t = s.uppercase().split(\";\")\n            .map {\n                val pair = it.split(\":\")\n                Pair(pair[1], pair[0])\n            }\n            .sortedWith(compareBy({ it.first }, { it.second }))\n\n        var str = \"\"\n        t.forEach {\n            str += it\n        }\n\n        return str\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207954,"user_id":null,"body":"fun meeting(s: String): String = s.toUpperCase().split(';').map{ it->\n        \"${it.split(':').reversed().joinToString(\", \")}\" \n    }.sorted().map{\n         \"(${it})\"\n     }.joinToString(\"\")\n    ","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207955,"user_id":null,"body":"fun meeting(s: String): String {\n    return s.split(\";\").map { name -> parseName(name).toUpperCase() }.sorted().joinToString(\"\")\n}\n\nfun parseName(name: String): String {\n    return name.split(\":\").reversed().joinToString(\", \", \"(\", \")\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"59eb80eea95427d81a0000fc":[{"id":207956,"user_id":null,"body":"import java.util.*\n\ntailrec fun loop(random: Random, int: Int): Int {\n\tif (int <= 0) return random.nextInt()\n\telse {\n    random.nextInt()\n\t\treturn loop(random, int - 1)\n\t}\n}\n\/\/ StackOverflow\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207957,"user_id":null,"body":"import java.util.Random\n\ntailrec fun loop(random: Random, int: Int): Int {\n    return if (int <= 0) random.nextInt()\n    else {\n        random.nextInt()\n        loop(random, int - 1)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207958,"user_id":null,"body":"import java.util.*\n\n\/\/ \u9009\u62e9\u5f88\u591a\nfun loop(random: Random, int: Int) = IntArray(int) { random.nextInt() }.let { random.nextInt() }\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207959,"user_id":null,"body":"import java.util.*\n\nfun loop(random: Random, int: Int): Int {\n  repeat(int) {\n    random.nextInt()\n  }\n  return random.nextInt()\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207960,"user_id":null,"body":"import java.util.*\n\nfun loop(random: Random, int: Int): Int {\n\treturn random.ints(int + 1L).skip(int + 0L).sum() ?: 0\n}\n\/\/ StackOverflow\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207961,"user_id":null,"body":"import java.util.*\n\nfun loop(random: Random, int: Int): Int {\n  when {\n\t  int <= 0 -> { \n      return random.nextInt()\n    }\n\t  else -> {\n      random.nextInt()\n\t\t  return IntArray(int, { i -> random.nextInt() }).last()\n\t  }\n  }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207962,"user_id":null,"body":"import java.util.*\n\n\ntailrec fun loop(random: Random, int: Int): Int {\n    val rand = random.nextInt()\n    return if (int <= 0) {\n        rand\n    } else {\n        loop(random, int-1)\n    }\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207963,"user_id":null,"body":"import java.util.*\n\nfun loop(random: Random, int: Int): Int {\n    \n\tval mod: Int = loopPack(random, int, 1000)\n    if (mod <= 0) return random.nextInt()\n    random.nextInt()\n    \n    return loop(random, mod - 1)\n    \n}\n\nfun loopPack(random: Random, int: Int, count: Int): Int {\n    \n    if (int <= 0 || int % count == 0) return int\n    random.nextInt()\n    \n    return loopPack(random, int - 1, count)\n    \n}\n\n\/\/ StackOverflow\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207964,"user_id":1228,"body":"import java.util.*\n\nfun loop(random: Random, int: Int): Int {\n    return random.ints(int + 1L).skip( 0L + int).sum() ?: 0\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207965,"user_id":100,"body":"import java.util.*\n\nfun loop(random: Random, int: Int): Int {\n\tif (int <= 0) return random.nextInt()\n\telse {\n\t\tIntArray(int) { random.nextInt() }\n\t\treturn loop(random, 0)\n\t}\n}\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"59eb8739fc3c49b67a00007d":[{"id":207966,"user_id":null,"body":"operator fun Box.invoke(block : Box.() -> Unit) = block(this)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207967,"user_id":null,"body":"operator fun Box.invoke(a: Box.() -> Unit) = a()\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207968,"user_id":759,"body":"operator fun Box.invoke(f: Box.() -> Unit) = this.f()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207969,"user_id":null,"body":"operator fun Box.invoke(block: Box.() -> Unit) = this.block()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207970,"user_id":null,"body":"\/\/ do anything!\noperator fun Box.invoke(f: Box.() -> Unit) = with(this, f)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207971,"user_id":null,"body":"inline operator fun<R> Box.invoke(body: Box.() -> R): R = with(this, body)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207972,"user_id":null,"body":"operator fun Box.invoke(initalizer: Box.() -> Unit) {\n    this.initalizer()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207973,"user_id":null,"body":"\/\/ do anything!\noperator fun Box.invoke(block: Box.() -> Unit) = block()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207974,"user_id":null,"body":"operator fun Box.invoke(apply: Box.() -> Unit) = apply(this)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207975,"user_id":null,"body":"\/\/ do anything!\n\noperator fun Box.invoke(function: Box.() -> Unit) {\n    function.invoke(this)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"59f11118a5e129e591000134":[{"id":207976,"user_id":null,"body":"fun repeats(arr: IntArray): Int =\n    2 * arr.distinct().sum() - arr.sum()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207977,"user_id":null,"body":"fun repeats(arr: IntArray) = arr.groupBy{ it }.filterValues { it.size < 2 }.keys.sum()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207978,"user_id":null,"body":"fun repeats(arr: IntArray): Int = \n    arr.groupBy { it }.filter { it.value.size == 1 }.keys.sum()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207979,"user_id":null,"body":"fun repeats(arr: IntArray): Int {\n\n    \/\/ How do we do it?\n    \/\/ 1. Iterate array and remove the element from original array\n    \/\/ 2. Check if the array still contains the element\n    \/\/ 3. If it contians then sum it up, otherwise continue\n    \n    var sum = 0\n    arr.forEach { e ->\n        val result = arr.filter { e2 -> e2 == e }\n        if (result.size == 1) {\n            sum += e\n        }\n    }\n    \n    return sum\n}\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207980,"user_id":null,"body":"fun repeats(arr: IntArray) = arr.filter { arr.count {i -> i == it } == 1 }.sum()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207981,"user_id":null,"body":"fun repeats(arr: IntArray): Int {\n   val list = mutableListOf<Int>()\n   for (a in arr){\n       if (list.contains(a)) list.remove(a)\n       else list.add(a)\n   }\n    return list.sum()\n   }   ","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207982,"user_id":null,"body":"fun repeats(arr: IntArray): Int {\n    return arr.fold(0) { acc, n -> if (arr.count {it == n} == 1) acc+n else acc }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207983,"user_id":null,"body":"fun repeats(arr: IntArray): Int {\n        var sum = 0\n        val map = HashMap<Int, Int>()\n        arr.map {\n            if (map.containsKey(it)) {\n                map[it] = map.getValue(it) + 1\n            } else {\n                map[it] = 1\n            }\n        }\n\n        map.map {\n            if (it.value == 1) sum += it.key\n        }\n\n        return sum\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207984,"user_id":null,"body":"fun repeats(arr: IntArray): Int {\n    \n    \/\/ get a number and find how many \n    \/\/ times is repeated.\n    \/\/ if the number does not repeat then\n    var n = mutableMapOf<Int,Int>()\n    var sum = 0\n    arr.forEach {k ->    \n        var times = 0\n        if (n.contains(k)) {\n            times = n.getValue(k)\n        }\n        n.put(k,times + 1)\n    }\n    \n    for((k,v) in n){\n        if(v == 1){\n            sum+=k\n        }\n    }\n    return sum\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207985,"user_id":null,"body":"fun repeats(arr: IntArray): Int {\n    var result = 0\n    for (i in arr.indices) {\n        if (arr.count { it == arr[i] } == 1) {\n            result += arr[i]\n        }\n    }\n    return result\n}\n ","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"59f44c7bd4b36946fd000052":[{"id":207986,"user_id":null,"body":"fun hist(s: String) = s.filter { it in \"uwxz\" }.groupingBy { it }.eachCount()\n        .map { \"${it.key}  %-6s%s\".format(it.value, \"*\".repeat(it.value)) }.sorted().joinToString(\"\\r\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207987,"user_id":null,"body":"\nfun hist(s: String) =\n    arrayOf('u', 'w', 'x', 'z').map { errorCode ->\n        val errorCount = s.count { it == errorCode }\n        if (errorCount < 1) return@map \"\"\n        '\\r' +\n                errorCode.toString().padEnd(2, ' ') + ' ' +\n                errorCount.toString().padEnd(6, ' ') +\n                \"*\".repeat(errorCount)\n\n    }.joinToString(\"\").drop(1)\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207988,"user_id":null,"body":"fun hist(s: String): String = \"uwxz\"\n    .filter { s.contains(it) }\n    .map { errorChar ->\n        val count = s.filter { errorChar == it }.count()\n        val spaces = \"\".padStart(6 - \"$count\".length)\n        val stars = \"*\".repeat(count)\n        \"$errorChar  $count$spaces$stars\"\n    }\n    .joinToString(\"\\r\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207989,"user_id":null,"body":"fun hist(s: String): String = s.toCharArray().sorted()\n    .filter { it in listOf('u', 'w', 'x', 'z') }\n    .groupingBy { it }.eachCount()\n    .map { it.key + \"  \" + it.value + \" \".repeat(6 - it.value.toString().length) + \"*\".repeat(it.value)}\n    .joinToString ( \"\\r\" )","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207990,"user_id":null,"body":"fun hist(s: String): String {\n    return \"uwxz\"\n    \t.toList()\n        .map {c -> c to s.count {c == it}}\n        .filter { (_, incidents) -> incidents != 0}\n        .map { (c, incidents) ->\n            var paddedIncidents = incidents.toString().padEnd(6)\n            var stars = \"*\".repeat(incidents)\n            \"$c  $paddedIncidents$stars\"\n        }\n        .joinToString(\"\\r\")\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207991,"user_id":null,"body":"fun hist(s: String): String = s.filter { it in \"uwxz\" }\n    .groupingBy { it }\n    .eachCount()\n    .toSortedMap()\n    .map { \"${it.key}  ${it.value.toString().padEnd(6, ' ')}${\"*\".repeat(it.value)}\" }\n    .joinToString(\"\\r\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207992,"user_id":null,"body":"fun hist(s: String): String {\n    val errors= arrayListOf('u','w','x','z')\n    val errorHist=s.filter { errors.contains(it) }.groupBy { it }.toSortedMap()\n    var res =\"\"\n    for ((index,value) in errorHist){\n        res+=index+\"  \"+value.size+\" \".repeat(6-value.size.toString().length)+\"*\".repeat(value.size)+\"\\r\"\n    }\n\n    return res.trim()\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207993,"user_id":null,"body":"fun hist(s: String): String {\n    var r = \"uwxz\"\n    var result = \"\"\n    r.forEachIndexed{ index, element ->\n       if (element in s){\n       \t\tresult += element.toString().padEnd(3,' ').plus(s.count{it in r[index].toString()}.toString())\n       \t\t\t        .padEnd(9,' ').padEnd(9 + s.count{it in r[index].toString()},'*').plus(\"\\r\")\n       }\n    }\n    return result.substringBeforeLast(\"\\r\")\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207994,"user_id":null,"body":"fun hist(s: String): String {\n    var result = \"\"\n    var r = \"uwxz\"\n    r.forEachIndexed{index, element ->\n       if (element in s){\n       \t\tresult += element.toString().padEnd(element.toString().count()+2,' ').plus(s.count{it in r[index].toString()}.toString())\n       \t\t\t\t\t.padEnd(element.toString().count()+ 8,' ')\n                        .padEnd(element.toString().count()+ 8 + s.count{it in r[index].toString()},'*').plus(\"\\r\")\n       }\n    }\n    return result.substringBeforeLast(\"\\r\")\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207995,"user_id":null,"body":"fun hist(s: String): String {\n            \n    val count = \"abcdefghijklmnopqrstuvwxyz\".associate { letter -> Pair(letter, 0) }.toMutableMap()\n    for (letter in s)\n        count[letter] = count[letter]!!.plus(1)\n\n    val res = mutableListOf<String>()\n    for (letter in \"uwxz\") {\n        if (count[letter]!! > 0) {\n            val num = \"%-6d\".format(count[letter])\n            val stars = \"*\".repeat(count[letter]!!)\n            res.add(\"$letter  $num$stars\")\n        }\n    }\n\n    return res.joinToString(\"\\r\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"59f4a0acbee84576800000af":[{"id":207996,"user_id":null,"body":"package solution\n\nobject PositionAverage {\n\n    fun posAverage(s: String): Double {\n        val list = s.split(\", \")\n        val size = list.size\n        var sum = 0.0\n        var signs = 0\n        for (i in (0 until size - 1)) {\n            for (j in i + 1 until size) {\n                sum += list[i].mapIndexed { index, c ->\n                    signs++\n                    if (list[j][index] == c) 1 else 0\n                }.sum()\n            }\n        }\n        return sum * 100 \/ signs\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207997,"user_id":null,"body":"package solution\n\nobject PositionAverage {\n    fun posAverage(s: String): Double {\n\n        fun combinations(str: List<String>) = IntRange(1, str.size - 1).sumOf { it * str[0].length }.toDouble()\n\n        val str = s.split(\", \")\n\n        var count = 0.0\n        for (i in str.indices) {\n            val current = str[i]\n            for (j in i + 1..str.indices.last) {\n                val next = str[j]\n                for (k in current.indices) {\n                    if (current[k] == next[k]) count += 1\n                }\n            }\n        }\n\n        return count \/ combinations(str) * 100.0\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207998,"user_id":null,"body":"package solution\n\nobject PositionAverage {\n    \n    fun posAverage(s: String): Double {\n        \/\/ your code\n        val sp = s.split(\", \")\n        val length = sp[0].length\n        var common = 0.0\n        var comps = 0.0\n        \/\/val combis = sp.size * (sp.size-1) \/ 2\n        \/\/compare it two times\n        for (i in sp.indices) {\n            val a = sp[i]\n            for (j in sp.indices) {\n                val b = sp[j]\n                if (i == j)\n                    continue\n                comps ++\n                for ((c1, c2) in a.zip(b)) {\n                    if (c1 == c2)\n                        common ++\n                }\n            }\n        }\n\n        val comps2 = if (comps > 0) comps else 1.0\n        \n        return common * 100 \/ (comps2 * length)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":207999,"user_id":null,"body":"package solution\n\nobject PositionAverage {\n    \n    fun posAverage(s: String): Double {\n        val tokens = s.split(\", \")\n        val combinations = tokens.first().length * tokens.size * (tokens.size - 1) \/ 2\n        return tokens.mapIndexed { i, s1 ->\n            tokens.drop(i + 1).sumBy { s2 -> s1.zip(s2).count { it.first == it.second } }\n        }.sum() * 100.0 \/ combinations\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208000,"user_id":53,"body":"package solution\n\nobject PositionAverage {\n    \n    fun posAverage(s: String): Double {\n        var hit = 0\n        val size = s.length\n        val m = s.indexOf(',')\n        val n = (size + 2) \/ (m + 2)\n        val tot = m * n * (n - 1) \/ 2\n        for (i in 0..(size - m - 2) step (m + 2)) {\n            for (j in (i + m + 2)..size step (m + 2)) {\n                for (k in 0..(m - 1)) {\n                    if (s[i+k] == s[j+k]) {\n                        hit += 1\n                    }\n                }\n            }\n        }\n        return 100.0 * hit.toDouble() \/ tot.toDouble()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208001,"user_id":null,"body":"package solution\n\nobject PositionAverage {\n    fun posAverage(s: String): Double = s.split(\", \").let { list ->\n        list.mapIndexed { index, a ->\n            list.drop(index + 1).sumOf { b ->\n                a.zip(b).count { it.first == it.second }\n            }\n        }.sum().toDouble() \/ (list.first().length * list.size * (list.size - 1) \/ 2) * 100\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208002,"user_id":null,"body":"package solution\n\nobject PositionAverage {\n    fun posAverage(s: String): Double {\n        val list = s.split(\", \")\n        val combinations = list.first().length * list.size * (list.size - 1) \/ 2\n\n        val common = list.mapIndexed { index, a ->\n            list.drop(index + 1).sumOf { b ->\n                a.zip(b).count { it.first == it.second }\n            }\n        }\n        return common.sum().toDouble() \/ combinations * 100\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208003,"user_id":null,"body":"package solution\n\nobject PositionAverage {\n    fun posAverage(s: String): Double {\n        val list = s.split(\", \")\n        var total = list.size * (list.size - 1) \/ 2\n        var common = 0\n\n        for (i in 0 until list.lastIndex)\n            for (j in i + 1..list.lastIndex)\n                common += list[i].zip(list[j]).count { it.first == it.second }\n\n        return common.toDouble() \/ list.first().length \/ total * 100\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208004,"user_id":null,"body":"package solution\n\nobject PositionAverage {\n    fun posAverage(s: String): Double = s.split(\", \").let { tokens ->\n        tokens.cartesianProduct().run{\n            sumOf { it.nIdenticalIndices() }.toDouble() \/ (tokens.first().length * size) * 100\n        }\n    }\n\n    private fun <T> List<T>.cartesianProduct(): List<Pair<T, T>> = mapIndexed { index, t -> slice(index + 1 until size).map { t to it } }.flatten()\n    private fun Pair<String, String>.nIdenticalIndices(): Int = first.zip(second).count { it.first == it.second }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208005,"user_id":null,"body":"package solution\n\nobject PositionAverage {\n    \n    fun posAverage(s: String): Double {\n        val chunks = s.split(\", \")\n        val list = combinationsWithoutRepetitions(chunks)\n        val qty = list.size * chunks[0].length\n        return list.map { countSameDigits(it.first, it.second) }.sumOf { it }.toDouble() \/ qty * 100.0\n    }\n\n\n    private fun countSameDigits(x: String, y: String): Int {\n        var result = 0\n        for (i in x.indices) {\n            if (x[i] == y[i])\n                result++\n        }\n        return result\n    }\n\n    private fun combinationsWithoutRepetitions(list: List<String>): List<Pair<String, String>> {\n        val result = mutableListOf<Pair<String, String>>()\n        for (i in list.indices) {\n            for (j in i + 1 until list.size) {\n                result.add(Pair(list[i], list[j]))\n            }\n        }\n        return result\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5a00e05cc374cb34d100000d":[{"id":208006,"user_id":527,"body":"fun reverse_seq(n: Int) = (n downTo 1).toList()","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208007,"user_id":null,"body":"fun reverse_seq(n: Int) = n.downTo(1).toList()","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208008,"user_id":null,"body":"fun reverse_seq(n: Int) = List(n) { n  - it }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208009,"user_id":null,"body":"fun reverse_seq(n: Int): List<Int> {\n    var listHere: MutableList<Int> = mutableListOf()\n    for (i in n downTo 1){\n        listHere.add(i)\n    }\n    return listHere\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208010,"user_id":527,"body":"fun reverse_seq(n: Int): List<Int> {\n    return (n downTo 1).toList()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208011,"user_id":null,"body":"fun reverse_seq(n: Int): List<Int> = IntRange(1,n).reversed().toList()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208012,"user_id":null,"body":"fun reverse_seq(n: Int): List<Int> {\n    var arr = mutableListOf<Int>()\n    for (x in 1..n) {\n        arr.add(n + 1 - x)\n    }\n  return arr\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208013,"user_id":null,"body":"fun reverse_seq(number: Int) = number.downTo(1).toList()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208014,"user_id":null,"body":"fun reverse_seq(n: Int): List<Int> {\n  val list: MutableList<Int> = mutableListOf();\n    \n  for(num in n downTo 1) {\n      list.add(num)\n  }\n  \n  return list.toList()\n  \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208015,"user_id":null,"body":"fun reverse_seq(n: Int): List<Int> {\n  var listInt = mutableListOf<Int>()\n  for(i in n downTo 1){\n      listInt.add(i)\n  }\n  return listInt\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5a03b3f6a1c9040084001765":[{"id":208016,"user_id":null,"body":"fun angle(n: Int): Int = 180*(n-2)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208017,"user_id":527,"body":"fun angle(n: Int): Int {\n    return 180 * (n - 2)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208018,"user_id":null,"body":"fun angle(n: Int): Int {\n    var wynik = 360\n    if (n == 3) return 180\n    else if (n == 4) return 360 \n    else {\n    for (i in 5..n) {\n        wynik += 180\n    }\n    }\n    return wynik\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208019,"user_id":null,"body":"fun angle(n: Int) = (n - 2) * 180","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208020,"user_id":932,"body":"fun angle(n: Int)=180*n-360","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208021,"user_id":null,"body":"fun angle(n: Int) = n.minus(2) * 180","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208022,"user_id":null,"body":"fun angle(n: Int): Int {\n    println(180 * (n.toDouble()-2)\/n.toDouble())\n    val result = (180 * ((n.toDouble()-2)\/n.toDouble())) * n\n    return Math.round(result).toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208023,"user_id":527,"body":"fun angle(n: Int) = 180 * (n - 2)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208024,"user_id":null,"body":"fun angle(n: Int): Int = (n-2)*180\n    \/\/ your code here","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208025,"user_id":null,"body":"\n\nfun angle(n: Int): Int? {\n    return if (n > 2) {\n        if (n == 3)\n            180\n        else if (n > 3)\n            (360 + (n - 4) * 180)\n        else\n            0\n    } else\n        null\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5a045fee46d843effa000070":[{"id":208026,"user_id":null,"body":"package factDecomp\nimport java.util.*\n\nfun decomp(m:Int):String {\n    val map = TreeMap<Int, Int>()\n    for (i in 2..m) {\n        val decMap = decompSmall(i)\n        decMap.forEach { (key, value) -> map[key] = (map[key] ?: 0) + value}\n    }\n    return map.map { if (it.value > 1) \"${it.key}^${it.value}\" else \"${it.key}\" }.joinToString(\" * \")\n}\n\nfun decompSmall(m: Int): Map<Int, Int> {\n    var div = 2\n    var mm = m\n    val result = TreeMap<Int, Int>()\n    while (mm > 1) {\n        if (mm % div == 0) {\n            result[div] = (result[div] ?: 0) + 1\n            mm \/= div\n        } else {\n            div++\n        }\n    }\n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208027,"user_id":932,"body":"package factDecomp\nimport java.math.BigInteger\n\n\nfun decomp(m:Int):String {\n    var f = BigInteger.ONE\n    val result = ArrayList<String>()\n    (2..m).forEach{f = f * BigInteger.valueOf(it.toLong())}\n    var c = BigInteger.valueOf(2L)\n    var t = 0\n    while(f.compareTo(BigInteger.ONE)==1){\n        while(f.mod(c).equals(BigInteger.ZERO)){\n            t++\n            f \/= c\n        }\n        when{\n            (t==1) -> result.add(\"$c\")\n            (t>1) -> result.add(\"$c^$t\")\n        }\n        t = 0\n        c++\n    }\n    return result.joinToString(\" * \")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208028,"user_id":null,"body":"package factDecomp\n\nfun decomp(m:Int): String {\n    val map = (1..m)\n        .flatMap { it.toPrimeFactors() }\n        .groupBy { it }\n    var res = \"\"\n    for ((k, v) in map) {\n        val base = if (res.isBlank()) k else \" * $k\"\n        val power = if (v.size > 1) \"^${v.size}\" else \"\"\n        res += \"$base$power\"\n    }\n    return res\n}\n\nfun Int.toPrimeFactors() : List<Int> {\n    var number = this.toLong()\n    val setPrimeFactors = mutableListOf<Int>()\n    var i = 2\n    while (i <= number) {\n        if (number % i == 0L) {\n            setPrimeFactors.add(i)               \n            number \/= i\n            i--\n        }\n        i++\n    }\n    return setPrimeFactors\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208029,"user_id":null,"body":"package factDecomp\nimport kotlin.math.sqrt\nimport java.util.*\n\nfun getPrimesTilN(n: Int): List<Int>{\n        var list = (2..n).toList()\n        for (i in 2..sqrt(n.toDouble()).toInt()){\n            list = list.filter { if(it == i) true else it % i != 0 }\n        }\n        return list\n    }\n\n    fun decomp(m:Int):String {\n        val divisors = TreeMap<Int, Int>()\n        val primes = getPrimesTilN(m)\n        for(i in 2..m){\n            if (primes.contains(i)){\n                divisors[i] = 0\n            }\n            var cur = i\n            for(div in divisors){\n                while(cur % div.key == 0){\n                    div.setValue(div.value + 1)\n                    cur \/= div.key\n                }\n            }\n        }\n        return divisors.entries.map { e ->\n            if(e.value > 1) e.key.toString() + \"^\" + e.value\n            else e.key.toString()   }.joinToString(\" * \")\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208030,"user_id":null,"body":"package factDecomp\n\nfun getPrimeFactors (number: Int) : List<Int> {\n    val res = mutableListOf<Int>()\n\n    var i = 2\n    var n = number\n    while (i * i <= n) {\n        while (n % i == 0) {\n            res.add(i)\n            n \/= i\n        }\n        i += 1\n    }\n    if (n > 1) {\n        res.add(n)\n    }\n    return res\n}\n\nfun decomp(m: Int): String {\n    val res = mutableMapOf<Int, Int>()\n\n    for (i in 2..m) {\n        getPrimeFactors(i).map {\n            res[it] = res.getOrDefault(it, 0).inc()\n        }\n    }\n\n    return res.toString()\n        .replace(\"{\", \"\")\n        .replace(\"=1}\", \"\")\n        .replace(\"=1,\", \",\")\n        .replace(\"}\", \"\")\n        .replace(\"=\", \"^\")\n        .replace(\",\", \" *\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208031,"user_id":null,"body":"package factDecomp\n\nfun decomp(m:Int):String {\n    \n    if (m>=5009) return \"Number is too Big!\"\n\n    val primeMap = mutableMapOf<Int,Int>()\n\n    for (i in 2..m) {\n        var n = i\n\n        while (!isPrimeNumber(n)) {\n            for (p in primeNumbers) {\n                if (n % p == 0) {\n                    primeMap[p] = (primeMap[p] ?:0) + 1\n                    n \/= p\n                    break\n                }\n            }\n        }\n\n        primeMap[n] = (primeMap[n] ?:0) + 1\n    }\n\n    val str = StringBuilder()\n    primeMap.forEach { key, value ->\n        if (str.isNotEmpty()) {\n            str.append(\" * \")\n        }\n\n        if (value > 1) {\n            str.append(\"$key^$value\")\n        } else {\n            str.append(\"$key\")\n        }\n    }\n\n    return str.toString()\n}\n\n\nfun isPrimeNumber(n:Int):Boolean = primeNumbers.contains(n)\nval primeNumbers = arrayOf(2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,1621,1627,1637,1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,1933,1949,1951,1973,1979,1987,1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,2621,2633,2647,2657,2659,2663,2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,2749,2753,2767,2777,2789,2791,2797,2801,2803,2819,2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,2909,2917,2927,2939,2953,2957,2963,2969,2971,2999,3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,3083,3089,3109,3119,3121,3137,3163,3167,3169,3181,3187,3191,3203,3209,3217,3221,3229,3251,3253,3257,3259,3271,3299,3301,3307,3313,3319,3323,3329,3331,3343,3347,3359,3361,3371,3373,3389,3391,3407,3413,3433,3449,3457,3461,3463,3467,3469,3491,3499,3511,3517,3527,3529,3533,3539,3541,3547,3557,3559,3571,3581,3583,3593,3607,3613,3617,3623,3631,3637,3643,3659,3671,3673,3677,3691,3697,3701,3709,3719,3727,3733,3739,3761,3767,3769,3779,3793,3797,3803,3821,3823,3833,3847,3851,3853,3863,3877,3881,3889,3907,3911,3917,3919,3923,3929,3931,3943,3947,3967,3989,4001,4003,4007,4013,4019,4021,4027,4049,4051,4057,4073,4079,4091,4093,4099,4111,4127,4129,4133,4139,4153,4157,4159,4177,4201,4211,4217,4219,4229,4231,4241,4243,4253,4259,4261,4271,4273,4283,4289,4297,4327,4337,4339,4349,4357,4363,4373,4391,4397,4409,4421,4423,4441,4447,4451,4457,4463,4481,4483,4493,4507,4513,4517,4519,4523,4547,4549,4561,4567,4583,4591,4597,4603,4621,4637,4639,4643,4649,4651,4657,4663,4673,4679,4691,4703,4721,4723,4729,4733,4751,4759,4783,4787,4789,4793,4799,4801,4813,4817,4831,4861,4871,4877,4889,4903,4909,4919,4931,4933,4937,4943,4951,4957,4967,4969,4973,4987,4993,4999,5003)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208032,"user_id":470,"body":"package factDecomp\n\nfun decomp(n: Int): String {\n\tval primes = intArrayOf(2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,1621,1627,1637,1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,1933,1949,1951,1973,1979,1987,1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,2621,2633,2647,2657,2659,2663,2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,2749,2753,2767,2777,2789,2791,2797,2801,2803,2819,2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,2909,2917,2927,2939,2953,2957,2963,2969,2971,2999,3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,3083,3089,3109,3119,3121,3137,3163,3167,3169,3181,3187,3191,3203,3209,3217,3221,3229,3251,3253,3257,3259,3271,3299,3301,3307,3313,3319,3323,3329,3331,3343,3347,3359,3361,3371,3373,3389,3391,3407,3413,3433,3449,3457,3461,3463,3467,3469,3491,3499,3511,3517,3527,3529,3533,3539,3541,3547,3557,3559,3571,3581,3583,3593,3607,3613,3617,3623,3631,3637,3643,3659,3671,3673,3677,3691,3697,3701,3709,3719,3727,3733,3739,3761,3767,3769,3779,3793,3797,3803,3821,3823,3833,3847,3851,3853,3863,3877,3881,3889,3907,3911,3917,3919,3923,3929,3931,3943,3947,3967,3989)\n\tfun proc(c: Int, m: Int): String {\n\t\tvar ct = 0\n\t\tvar q = 1\n\t\twhile (m >= q * c) {\n\t\t\tq *= c\n\t\t\tct += m \/ q\n\t\t}\n\t\treturn if (ct > 1) \"$c^$ct\" else c.toString()\n\t}\n\treturn primes.filter { n >= it }.map { proc(it,n) }.joinToString(\" * \")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208033,"user_id":null,"body":"package factDecomp\n\nimport kotlin.math.pow\n\nfun Int.isPrime(): Boolean {\n    val limit = this.toDouble().pow(0.5).toInt()\n    for (i in 2..limit) {\n        if (this % i == 0) return false\n    }\n\n    return true\n}\n\nfun decomp(m:Int):String {\n    val primes = mutableListOf<Int>()\n    val result = mutableListOf<String>()\n\n    (2..5000).forEach {\n        if (it.isPrime()) primes += it\n    }\n    \n    primes.forEach { prime ->\n        var d = prime\n        var sum = 0\n\n        while (m \/ d > 0) {\n            sum += m \/ d\n            d *= prime\n        }\n\n        when (sum) {\n            0 -> Unit\n            1 -> result += \"$prime\"\n            else -> result += \"$prime^$sum\"\n        }\n    }\n\n    return result.joinToString(\" * \")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208034,"user_id":null,"body":"package factDecomp\n\nfun isPrime(n: Int):Boolean {\n    \/\/ returns true if n is prime, false if not\n    for (i in 2..n-1) {\n        if (n % i == 0) return false\n    }\n    return true\n} \n\nfun decomp(m:Int):String {\n    var result: String = \"\"\n    var primes = mutableMapOf<Int,Int>()\n    \n    \/\/ My first approach was to caclulate the factorial first, but this\n    \/\/ led to much to high numbers, so I changed to decompose factor by factor\n    \n    for (i in 2..m) {\n        \/\/ if factor is prime by itself, put it into map of primes\n        if(isPrime(i)) {\n            primes.put(i, 1)\n        } \n        \/\/ if factor is not prime, use already identified primes to decomppse\n        else {\n            var decomp = i\n            for ((key,_) in primes) {\n                while (decomp % key == 0) {\n                    decomp = decomp \/ key\n                    \/\/ count number for each prime\n                    primes.put(key, primes.getValue(key) + 1)\n                }\n            }\n        }\n    }\n    \n    \/\/ attach result to output string\n    result = primes.entries.joinToString(\" * \").replace(\"=\",\"^\").replace(\"^1 \",\" \")\n    if (result.takeLast(2) == \"^1\" ) {\n        return result.dropLast(2)\n    } else {\n        return result\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208035,"user_id":null,"body":"package factDecomp\n\n   fun decomp(m: Int): String {\n        var result: String = \"\"\n        var simpleNumbers: MutableMap<Int, Int> = mutableMapOf()\n\n        repeat(1000) {\n            simpleNumbers.addNewSimpleNumber()\n        }\n        for (i in 2..m) {\n            var temp = i\n            for (j in simpleNumbers.keys) {\n                if (temp == 1) break\n                while (true) {\n                    if (temp % j == 0) {\n                        simpleNumbers[j] = simpleNumbers[j]!! + 1\n                        temp \/= j\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n        simpleNumbers = simpleNumbers.filter { it.value != 0 } as MutableMap<Int, Int>\n        for (i in simpleNumbers) {\n            result += if (i.value == 1) {\n                \"${i.key} * \"\n            } else\n                \"${i.key}^${i.value} * \"\n        }\n        result = result.dropLast(3)\n        print(result)\n        return result\n    }\n\n    private fun MutableMap<Int, Int>.addNewSimpleNumber() {\n        if (this.isEmpty()) {\n            this[2] = 0\n            this[3] = 0\n            this[5] = 0\n            this[7] = 0\n        }\n\n        var iterator = this.keys.last()\n\n        while (true) {\n            iterator += 1\n            var numberIsSimple = true\n            for (i in 2..9) {\n                if (iterator % i == 0) numberIsSimple = false\n            }\n            if (numberIsSimple) {\n                this.put(iterator, 0)\n                return\n            }\n        }\n\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5a057ec846d843c81a0000ad":[{"id":208036,"user_id":null,"body":"package cycle\n\nfun cycle(n: Int): Int {\n    if (n % 2 == 0 || n % 5 == 0) return -1\n    return generateSequence(10) { i -> (i % n * 10).takeUnless { it == 10 } }.count()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208037,"user_id":492,"body":"package cycle\n\nfun cycle(n:Int):Int {\n  if (n % 2 == 0 || n % 5 == 0)\n  {\n    return -1\n  }\n  var r = 1\n  for (i in 1..n)\n  {\n    r = r * 10 % n\n    if (r == 1)\n    {\n      return i\n    }\n  }\n  return -1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208038,"user_id":53,"body":"package cycle\n\nfun cycle(n:Int):Int {\n  if (n%2 == 0 || n%5 == 0) return -1\n  var m = 10 % n\n  var cnt = 1\n  while (m != 1) {\n      m = m * 10 % n\n      cnt += 1\n  }\n  return cnt\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208039,"user_id":null,"body":"package cycle\n\nfun cycle(n:Int):Int {\n    if (n % 2 == 0 || n % 5 == 0)\n        return -1\n\n    var c = 0\n    var r = 1\n\n    do {\n        c++\n        r = r * 10 % n\n    } while (r > 1)\n\n    return c\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208040,"user_id":null,"body":"package cycle\n\nfun cycle(n: Int): Int {\n    if ((n % 2) * (n % 5) == 0) return -1\n    var result = 0\n    var remainder = 10\n    do {\n        result++\n        remainder = (remainder % n) * 10\n    } while (remainder != 10)\n    return result\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208041,"user_id":null,"body":"package cycle\nimport java.math.BigInteger\n\nfun cycle(n: Int): Int {\n    if (n % 2 == 0 || n % 5 == 0)\n        return -1\n\n    val power10 = BigInteger.valueOf(10L)\n    val m = BigInteger.valueOf(n.toLong())\n    var exponent = 1L\n\n    while (power10.modPow(BigInteger.valueOf(exponent), m) != BigInteger.ONE)\n        exponent++\n\n    return exponent.toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208042,"user_id":null,"body":"package cycle\nimport java.math.BigInteger\n\nfun cycle(n: Int): Int {\n    if (n % 2 == 0 || n % 5 == 0) return -1\n\n    val mod = 10 % n\n\n    var bufferMod = mod\n    var i = 1\n\n    while(true){\n        if(bufferMod == 1)\n            return i\n        bufferMod = (bufferMod * mod) % n\n        i++\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208043,"user_id":null,"body":"package cycle\n\n\n\n\nfun cycle(n:Int):Int {  \n  if (n % 2 == 0 || n % 5 == 0 ) return -1\n  val remainders = HashMap<Int,Boolean>()\n  \n  var a = 10\n  var b = n  \n  var counter = 0    \n  while (true) {    \n    val fraction = a \/ b\n    a = 10*(a % b)\n    \n    if (remainders.size > 0) {        \n        if (remainders.contains(a)) return counter\n    }\n    remainders[a] = true        \n    \n    counter++    \n  }\n                \n  return -1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208044,"user_id":932,"body":"package cycle\n\nfun cycle(p:Int):Int {\n    if (p%2==0 || p%5==0) return -1\n    var t = 0\n    var r = 1\n    var n = 0\n    do {\n        t++\n        val x = r*10\n        val d = x\/p\n        r = x%p\n        n = n*10+d\n    }while (r != 1)\n    return t\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208045,"user_id":168,"body":"package cycle\n\nfun cycle(n: Int): Int {\n    if (n % 2 == 0 || n % 5 == 0) return -1\n    var i = 0\n    var p = 1\n    do {\n        p = 10 * p % n\n        i++\n    } while (p != 1)\n    return i\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5a1e6323ffe75f71ae000026":[{"id":208046,"user_id":null,"body":"fun isTuringEquation(s: String): Boolean =\n    s.split('+', '=').map { it.reversed().toInt() }.let { it[0] + it[1] == it[2] }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208047,"user_id":null,"body":"fun isTuringEquation(s: String)= s.reversed().run {\n    ( takeWhile { it != '=' }.toLong() == \n      dropWhile { it != '=' }.drop(1).takeWhile { it != '+' }.toLong() +\n      takeLastWhile { it != '+' }.toLong() )\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208048,"user_id":1251,"body":"fun isTuringEquation(s: String) = s.reversed().split(Regex(\"[+=]\")).map { it.toInt() }.let { it[0] == it.drop(1).sum() }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208049,"user_id":null,"body":"fun isTuringEquation(s: String): Boolean {\n  val text = s.split(\"+\",\"=\")\n  return (\n      (text.first().reversed().toInt()) + \n      (text[1].reversed().toInt()) ==\n      (text.last().reversed().toInt())\n)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208050,"user_id":null,"body":"fun isTuringEquation(s: String): Boolean {\n    val sub1 = s.substringBefore(\"+\").reversed().toInt()\n    val sub2 = s.substringAfter(\"+\").substringBefore(\"=\").reversed().toInt()\n    val sub3 = s.substringAfter(\"=\").reversed().toInt()\nif(sub1 + sub2 == sub3) return true\nelse return false\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208051,"user_id":null,"body":"fun isTuringEquation(s: String): Boolean {\n  \/\/coding and coding..\n    val splitted = s.split('+','=').map{it.reversed().toLong()}\n    \n    return splitted[0]+splitted[1] == splitted[2]\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208052,"user_id":null,"body":"fun isTuringEquation(s: String): Boolean {\n    var c = s.split(\"=\")[1]\n    var (a,b) = s.split(\"=\")[0].split(\"+\")\n    println(\"-- > ${a.reversed()} + ${b.reversed()} = ${c.reversed()}\")\n    return a.reversed().toInt() + b.reversed().toInt() == c.reversed().toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208053,"user_id":null,"body":"fun isTuringEquation(s: String): Boolean {\n    println(s)\n   val first = s.substringBefore(\"+\").reversed()\n    val second = s.substringAfter(\"+\").substringBefore(\"=\").reversed()\n    val result = s.substringAfter(\"=\").reversed()\n    return first.toInt() + second.toInt() == result.toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208054,"user_id":null,"body":"fun isTuringEquation(s: String): Boolean {\n    val listOfValues = s.reversed().replace(\"=\", \"+\").split(\"+\")\n    var a = listOfValues[0].toLong()\n    var b = listOfValues[1].toLong()\n    var c = listOfValues[2].toLong()\n    return a == b + c\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208055,"user_id":null,"body":"import java.util.*\nfun isTuringEquation(s: String): Boolean {\n    \n    val n1 = s.split(\"+\").getOrNull(0)?.reversed()?.toBigInteger()\n    val n2 = s.split(\"+\").getOrNull(1)?.split(\"=\")?.getOrNull(0)?.reversed()?.toBigInteger()\n    val res = s.split(\"+\").getOrNull(1)?.split(\"=\")?.getOrNull(1)?.reversed()?.toBigInteger()\n\n    return if (n1 != null) {\n        ((n1+ n2!!)==res)\n    }else\n        false\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5a24a35a837545ab04001614":[{"id":208056,"user_id":null,"body":"package kata\n\nimport kotlin.math.ceil\nimport kotlin.math.sqrt\n\nobject InterlacedSpiralCipher {\n    fun encode(s: String): String {\n        val size = matrixSize(s.length)\n        val builder = StringBuilder(\" \".repeat(size * size))\n        generateIndices(size).forEachIndexed { index, newIndex ->\n            builder[newIndex] = s.getOrNull(index) ?: ' '\n        }\n        return builder.toString()\n    }\n\n    fun decode(s: String): String {\n        return generateIndices(matrixSize(s.length))\n            .map { s.getOrNull(it) ?: ' ' }\n            .joinToString(separator = \"\")\n            .trimEnd()\n    }\n\n    private fun generateIndices(size: Int): List<Int> {\n        val indices = mutableListOf<Int>()\n        val maxDimension = size - 1\n        for (depth in 0..maxDimension \/ 2) {\n            for (i in 0 until (maxDimension - depth * 2)) {\n                indices += depth * size + depth + i\n                indices += (depth + i) * size + maxDimension - depth\n                indices += (maxDimension - depth) * size + maxDimension - depth - i\n                indices += (maxDimension - depth - i) * size + depth\n            }\n        }\n        if (size % 2 != 0) {\n            indices += size * size \/ 2\n        }\n        return indices\n    }\n\n    private fun matrixSize(length: Int) = ceil(sqrt(length.toDouble())).toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208057,"user_id":null,"body":"package kata\n\nobject InterlacedSpiralCipher {\n    fun encode(s: String): String {\n        val len = s.length\n        val mapLen = Math.ceil(Math.sqrt(len.toDouble())).toInt()\n        val map = Array(mapLen) { Array(mapLen) { ' ' } }\n        val s = s.padEnd(mapLen * mapLen, ' ')\n        travers(map.size) { i, j, index ->\n            map[i][j] = s.get(index)\n        }\n        return map.flatten().joinToString(\"\")\n    }\n\n    fun decode(s: String): String {\n        val len = s.length\n        val mapLen = Math.ceil(Math.sqrt(len.toDouble())).toInt()\n        val map = Array(mapLen) { Array(mapLen) { ' ' } }\n        s.forEachIndexed { index, c ->\n            map[index \/ mapLen][index % mapLen] = c\n        }\n        val sb = StringBuilder()\n        travers(map.size) { i, j, index ->\n            sb.append(map[i][j])\n        }\n        return sb.toString().trim()\n    }\n\n    fun travers(len: Int, action: (i: Int, j: Int, index: Int) -> Unit) {\n        var count = 0\n        0.rangeTo(Math.ceil(len \/ 2.0).toInt() - 1).forEach { x ->\n            val w = len - 2 * x - 1\n            if (w != 0)\n                0.rangeTo(w - 1).map { y ->\n                    action(x, x + y, count++)\n                    action(x + y, x + w, count++)\n                    action(x + w, x + w - y, count++)\n                    action(x + w - y, x, count++)\n                }\n            else\n                action(x, x, count++)\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208058,"user_id":null,"body":"package kata\n\nobject InterlacedSpiralCipher {\n    fun encode(s:String): String {\n        val n = s.length.intRoot()\n        val mat = Array(n) {Array(n){' '}}\n        for (i in s.indices) mat.setCoords(spiralCoords(i,n-1), s[i])\n        return mat.flatten().joinToString(\"\")\n    }\n    fun decode(s:String): String {\n        val n = s.length.intRoot()\n        val mat = Array(n) {i->s.substring(i*n, i*n+n)}\n        return String(CharArray(n*n) {i-> mat.getCoords(spiralCoords(i,n-1))}).trim(' ')\n    }\n    fun spiralCoords(i:Int, n:Int, add:Int = 0):Pair<Int,Int> {\n        if (i - 4*n >= 0) {\n            if (n<=0) return add to add\n            return spiralCoords(i - 4*n, n-2, add+1)\n        }\n        return when (i % 4) {\n            0 -> add to add +i \/ 4\n            1 -> add + i\/4 to add + n\n            2 -> add + n to add + n -i\/4 \n            else -> add + n - i\/4 to add\n        }\n    }\n    fun Int.intRoot():Int {\n        for (i in 1..46341) if (i * i >=this) return i\n        return -1   \n    }\n    fun Array<String>.getCoords(pair:Pair<Int,Int>) = this[pair.first][pair.second]\n    fun Array<Array<Char>>.setCoords(pair:Pair<Int,Int>, c:Char) {this[pair.first][pair.second] = c }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208059,"user_id":null,"body":"package kata\nimport kotlin.math.roundToInt\n\n\nobject InterlacedSpiralCipher {\n    \n   \n    fun encode(s : String) : String {\n        \n        val input = s.trim()\n        val side = getSideSize(input)\n        println (\"ENCODE $s --> $side\")\n        if (side == 0) return \"\"\n        \n        val output = CharArray(side*side){' '}\n        input.forEachIndexed { ind,c ->\n            val ptr = placer(side,ind,'E')\n            output[ptr] = c\n         }\n        val ret = output.joinToString(\"\")\n        \n        println (\"ENCODED: [$ret] \n\")\n        return ret\n        \n    }\n    \n            \n    fun decode(s : String): String {\n    \n        val input = s.trim()\n        val side = getSideSize(input)\n        println (\"DECODE $s --> $side\")\n        if (side == 0) return \"\"\n        \n        val output = CharArray(side*side){' '}\n        input.forEachIndexed { ind,c ->\n            val ptr = placer(side,ind,'D')\n            output[ptr] = c\n         }\n        val ret = output.joinToString(\"\").trim()\n    \n        println(\"DECODED: [$ret]\")\n        return ret\n    \n    }\n    \n    fun getSideSize(s : String) : Int {\n        val str_len = s.length\n        if (str_len==0) return 0\n        (1..32768).forEach {\n            if (it*it >= str_len) return it\n         }\n        return 0\n    }\n    \n    \n    fun placer (side: Int, ind : Int, mode : Char) : Int {\n        val place = dicGenerator(side)\n        val to = if (mode=='E') place.indexOf(ind) else place[ind]\n        return to\n    }\n    \n    fun dicGenerator(side : Int) : IntArray {\n        val dic = MutableList(side*side){0}\n        val layer_number = ((side+0.5)\/2.0).roundToInt()\n        var start_number = 0\n        (0..layer_number-1).forEach { layer -> \n            val start_ptr = (side+1)*layer\n            val endln_offset = side-1-layer*2\n            val start_pointers = arrayOf(start_ptr,start_ptr+endln_offset,(start_ptr+endln_offset)+side*endln_offset,start_ptr+side*endln_offset)\n            val jumps = arrayOf(1,side,-1,-side)\n            val phases = if (endln_offset>0) 3 else 0\n            (0..phases).forEach { phase ->\n                dic[start_pointers[phase]] = start_number + phase\n                (1..endln_offset - 1).forEach { cell_offset ->\n                    val ptr = start_pointers[phase] + cell_offset * jumps[phase]\n                    val num = start_number + phase + cell_offset * 4\n                    dic[ptr] = num\n                }\n\n            }\n            start_number += endln_offset*4\n        }\n        return dic.toIntArray()\n    }\n   \n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208060,"user_id":null,"body":"package kata\n\nobject InterlacedSpiralCipher {\n\n    fun createMap(mapSize:Int): Map<Int, Int> {\n        \/\/ given a size, returns the encoding map from position -> position\n        val map = mutableMapOf<Int, Int>()\n        var start: Int\n        var size = mapSize\n        for(row in 0..Math.floor(mapSize\/2.0).toInt()) {\n            start = if (row == 0) {\n                0\n            } else {\n                (map[row - 1 + row * mapSize] ?: 0) + 1 \/\/ row + column = row-1\n            }\n            \/\/ top\n            var p = start\n            for (i in row until size-1) {\n                map[i + row * mapSize] = p\n                p += 4\n            }\n            \/\/ left\n            p = start + 1\n            for (i in row until size-1) {\n                map[size-1 + i * mapSize] = p\n                p += 4\n            }\n            \/\/ bottom\n            p = start + 2\n            for (i in size-1 downTo (row+1)) {\n                map[mapSize * (size - 1) + i] = p\n                p += 4\n            }\n            \/\/ right\n            p = start + 3\n            for (i in size-1 downTo (row+1)) {\n                map[row + i * mapSize] = p\n                p += 4\n            }\n            size -= 1\n        }\n        \/\/ if size is odd, fill middle square\n        if (mapSize % 2 == 1) {\n            val mid = Math.floor(mapSize \/ 2.0).toInt()\n            map[mid + mid * mapSize] = (map[mid-1 + mid*mapSize] ?: 0) + 1\n        }\n        return map\n    }\n\n    fun cypher(s:String, rev:Boolean) : String {\n        val size = Math.ceil(Math.sqrt(s.length.toDouble())).toInt()\n        var map = createMap(size)\n        if (rev) {\n            map = map.entries.associate{(k,v)-> v to k}\n        }\n        val output = CharArray(size*size){' '}\n        s.forEachIndexed { i, c -> output[map[i] ?: 0] = c }\n        return if (rev) String(output) else String(output).trim()\n    }\n\n    fun encode(s:String): String {\n        return cypher(s, true)\n    }\n\n    fun decode(s:String): String {\n        return cypher(s, false)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208061,"user_id":null,"body":"package kata\nimport kotlin.math.*\n\nobject InterlacedSpiralCipher {\n    fun encode(s:String): String {\n        \n        val n = s.count()\n        val size = ceil(sqrt(n.toDouble())).toInt()\n        val str = s.padEnd(2 * n, ' ')\n        var grid = Array(size) { Array(size) { ' ' }}\n        var ind = 0\n        val lim = ceil(size.toDouble() \/ 2.0).toInt()\n        \n        for (i in 0 until lim) {\n            if (2 * i == size - 1) {\n                grid[i][i] = str[ind]\n                ind += 1\n            }\n            \n            for (d in 0 until size - 1 - 2 * i) {\n                \n                grid[i][i + d] = str[ind]\n                grid[i + d][size - 1 - i] = str[ind + 1]\n                grid[size - 1 - i][size - 1 - i - d] = str[ind + 2]\n                grid[size - 1 - i - d][i] = str[ind + 3]\n                \n                ind += 4\n            }        \n        }       \n        return grid.map { row -> row.joinToString(\"\") }.joinToString(\"\")\n    }\n    \n    fun decode(s:String): String {\n        val n = s.count()\n        val size = ceil(sqrt(n.toDouble())).toInt()\n        val grid = s.chunked(size).map { row -> row.toList().toTypedArray() }\n        var res = \"\"\n        val lim = ceil(size.toDouble() \/ 2.0).toInt()\n        \n        for (i in 0 until lim) {\n            for (j in i until max(size - 1 - i, lim)) {\n                \n                res += grid[i][j]\n\n                if (2 * i == size - 1) break\n\n                res += grid[j][size - 1 - i]\n                res += grid[size - 1 - i][size - 1 - j]\n                res += grid[size - 1 - j][i]                \n            }\n        }\n        return res.trim()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208062,"user_id":null,"body":"package kata\n\nobject InterlacedSpiralCipher {\n    fun encode(s:String): String {\n        var squareSize = squareSize(s);\n        var encoded = StringBuilder(\" \".repeat(squareSize*squareSize));\n        var inputWithSpaces = s;\n        \n        for (char in (s.length)..(squareSize*squareSize)) {\n            inputWithSpaces += \" \";\n        }\n        \n        var current = 0;\n        \n        for (level in 1..(squareSize\/2)) {\n            for (shift in 0..(squareSize-2 - (level-1)*2)) {\n                var nextIds = getNextIds(squareSize, level, shift);\n                \n                encoded.setCharAt(nextIds[0], inputWithSpaces[current++]);\n                if (nextIds[0] == nextIds[1]) break;\n                encoded.setCharAt(nextIds[1], inputWithSpaces[current++]);\n                encoded.setCharAt(nextIds[2], inputWithSpaces[current++]);\n                encoded.setCharAt(nextIds[3], inputWithSpaces[current++]);\n            }\n        }\n        \n        if (squareSize % 2 == 1) {\n            encoded.setCharAt(((squareSize * squareSize) \/ 2), inputWithSpaces[current]);\n        }\n        \n        return encoded.toString();\n    }\n    \n    fun decode(s:String): String {\n        var squareSize = squareSize(s);\n        var decoded = \"\";\n        \n        for (level in 1..(squareSize\/2)) {\n            for (shift in 0..(squareSize-2 - (level-1)*2)) {\n                var nextIds = getNextIds(squareSize, level, shift);\n                \n                decoded += s[nextIds[0]];\n                if (nextIds[0] == nextIds[1]) break;\n                decoded += s[nextIds[1]];\n                decoded += s[nextIds[2]];\n                decoded += s[nextIds[3]];\n            }\n        }\n        \n        if (squareSize % 2 == 1) {\n            decoded += s[(squareSize * squareSize) \/ 2];\n        }\n        \n        return decoded.trimEnd();\n    }\n    \n    fun getNextIds(squareSize:Int, level:Int, shift:Int): IntArray {\n        return intArrayOf(\n            (squareSize+1)*(level-1) + shift,\n            (squareSize-1)*(level) + (shift*squareSize),\n            (squareSize+1)*(squareSize-level) - shift,\n            (squareSize-1)*(squareSize-(level-1)) - (shift*squareSize)\n        );\n    }\n    \n    fun squareSize(s:String): Int {\n        var squareRoot = Math.sqrt(s.length.toDouble());\n        return Math.ceil(squareRoot).toInt();\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208063,"user_id":null,"body":"package kata\n\nimport kotlin.math.ceil\nimport kotlin.math.sqrt\n\nobject InterlacedSpiralCipher {\n    fun encode(s: String): String {\n\n        val squareSize = ceil(sqrt(s.length.toDouble())).toInt()\n        val padded = s.padEnd(squareSize * squareSize, ' ')\n\n        val square = charArray2D(squareSize, squareSize)\n        val pattern = getEncodingPattern(squareSize)\n        pattern.forEachIndexed { j, a ->\n            a.forEachIndexed { i, pos -> square[j][i] = padded[pos] }\n        }\n        return square.joinToString(\"\") { it.joinToString(\"\") }\n    }\n\n    fun decode(s: String): String {\n        val squareSize = ceil(sqrt(s.length.toDouble())).toInt()\n        val pattern = getEncodingPattern(squareSize)\n        val builder = StringBuilder(\" \".repeat(s.length))\n        var idx = 0\n        pattern.forEachIndexed { j, a ->\n            a.forEachIndexed { i, pos ->\n                builder.setCharAt(pos, s[idx++])\n             }\n        }\n        return builder.toString().trim()\n    }\n\n    fun getEncodingPattern(dimension: Int): IntArray2D {\n        val ringsNeeded = dimension + 1 \/ 2\n        var cnt = 0\n\n        val pattern = intArray2D(dimension, dimension)\n        (0 until ringsNeeded).forEach { ring ->\n            val top = ring\n            val left = ring\n            val right = dimension - 1 - ring\n            val bottom = dimension - 1 - ring\n            for (x in 0 until (right - ring)) {\n                pattern[top][left + x] = cnt++\n                pattern[top + x][right] = cnt++\n                pattern[bottom][right - x] = cnt++\n                pattern[bottom - x][left] = cnt\n\n                if (cnt == dimension * dimension - 1) break\n                if (cnt == dimension * dimension - 2) {\n                    cnt++\n                    pattern[(dimension + 1) \/ 2 - 1][(dimension + 1) \/ 2 - 1] = cnt\n                    break\n                }\n                cnt++\n            }\n        }\n        return pattern\n    }\n}\n\ntypealias IntArray2D = Array<IntArray>\n\nfun intArray2D(rows: Int, cols: Int, block: (i: Int, j: Int) -> Int = { _, _ -> 0 }): IntArray2D {\n    return Array(rows) { i ->\n        IntArray(cols) { j ->\n            block(i, j)\n        }\n    }\n}\n\ntypealias CharArray2D = Array<CharArray>\n\nfun charArray2D(rows: Int, cols: Int, block: (i: Int, j: Int) -> Char = { _, _ -> ' ' }): CharArray2D {\n    return Array(rows) { i ->\n        CharArray(cols) { j ->\n            block(i, j)\n        }\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208064,"user_id":null,"body":"package kata\nimport kotlin.math.abs\nimport kotlin.math.ceil\nimport kotlin.math.max\nimport kotlin.math.sqrt\n\nobject InterlacedSpiralCipher {\n    fun encode(s: String) =\n        encodingSequence(s.fit())\n            .map { s.getOrElse(it) { ' ' } }\n            .joinToString(\"\")\n\n    fun decode(s: String) =\n        encodingSequence(s.fit())\n            .zip(s.asSequence())\n            .sortedBy { it.first }\n            .map { it.second }\n            .joinToString(\"\")\n            .trimEnd()\n\n    private fun String.fit() = ceil(sqrt(length.toDouble())).toInt()\n\n    private fun encodingSequence(size: Int): Sequence<Int> {\n\n        fun ringSize(ringIdx: Int) = (size - 1 - ringIdx * 2) * 4\n\n        val rings = ceil(size \/ 2.0).toInt()\n        val singleCenter = size % 2 != 0\n        val mid = (size - 1) \/ 2.0\n        return (0 until size).asSequence().map { row ->\n            (0 until size).asSequence().map { col ->\n                val distance = max(abs(row - mid), abs(col - mid)).toInt()\n                val ringIdx = rings - distance - 1\n                val firstOnRing = (0 until ringIdx).sumBy { ringSize(it) }\n\n                val isLeft = mid - col >= distance\n                val isBottom = row - mid >= distance && !isLeft\n                val isRight = col - mid >= distance && !isBottom\n                val isTop = mid - row >= distance && !isRight || (distance == 0 && singleCenter)\n\n                firstOnRing + when {\n                    isTop -> (col - ringIdx) * 4\n                    isRight -> 1 + (row - ringIdx) * 4\n                    isBottom -> 2 + (size - col - 1 - ringIdx) * 4\n                    isLeft -> 3 + (size - row - 1 - ringIdx) * 4\n                    else -> 0\n                }\n            }\n        }.flatten()\n    }\n\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208065,"user_id":470,"body":"package kata\n\nobject InterlacedSpiralCipher {\n\tfun encode(s:String): String {\n\t\tval ln: Int = Math.ceil(Math.sqrt(s.length.toDouble())).toInt()\n\t\tval tome = Array<CharArray>(ln) {CharArray(ln) {' '}}\n\t\tval codex = s.toCharArray()\n\t\treturn convert(s.length,ln,tome,codex,true)\n\t}\n\t\n\tfun decode(s:String): String {\n\t\tval ln: Int = Math.sqrt(s.length.toDouble()).toInt()\n\t\tval tome = Array<CharArray>(ln) {s.substring(ln*it,ln*(it+1)).toCharArray()}\n\t\tval codex = CharArray(s.length){' '}\n\t\treturn convert(s.length,ln,tome,codex,false)\n\t}\n\t\n\tprivate fun convert(n:Int,ln:Int,tome:Array<CharArray>,codex:CharArray,encode:Boolean): String {\n\t\tvar nc = ln - 1\n\t\tvar lc = 0\n\t\tvar bc = 0\n\t\tvar c: Int\n\t\tvar x: Int\n\t\tvar y: Int\n\t\t\n\t\tfor (i in 0 until n){\n\t\t\tvar z = i % 2\n\t\t\tvar q = i % 4\n\t\t\tif (q == 0 && i > 0){bc++}\n\t\t\tif (lc + bc == nc){lc++;nc--;bc = 0}\n\t\t\tif (z == 0){\n\t\t\t\tc = q\/2\n\t\t\t\tx = if (c == 0) lc else nc\n\t\t\t\ty = if (c == 0) lc+bc else nc-bc}\n\t\t\telse {\n\t\t\t\tc = (q-1)\/2\n\t\t\t\tx = if (c == 0) lc+bc else nc-bc\n\t\t\t\ty = if (c == 0) nc else lc}\n\t\t\tif (encode){tome[x][y] = codex[i]}\n\t\t\telse {codex[i] = tome[x][y]}\n\t\t}\n\n\t\treturn if (encode) tome.map {String(it)}.joinToString(separator=\"\") else String(codex).trimEnd(' ')\n\t}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5a2a597a8882f392020005e5":[{"id":208066,"user_id":null,"body":"package kata\n\nobject Blox {\n    fun bloxSolver(puzzle: Array<String>): String {\n        val solver = Solver(puzzle)\n        return solver.solve()\n    }\n\n    class Solver(data: Array<String>) {\n        val board = data.map{ row ->\n            row.map {\n                it != '0'\n            }\n        }\n\n        private val winState: BloxState\n        val paths = HashMap<BloxState, String>()\n        var recentStates = ArrayList<BloxState>()\n\n        init {\n            val winY = data.indexOfFirst { it.contains('X') }\n            val winX = data[winY].indexOf('X')\n            winState = BloxState(winX, winY, Blox.BloxState.BloxDirection.Upright)\n\n            val startY = data.indexOfFirst { it.contains('B') }\n            val startX = data[startY].indexOf('B')\n            val startState = BloxState(startX, startY, Blox.BloxState.BloxDirection.Upright)\n            paths[startState] = \"\"\n            recentStates.add(startState)\n        }\n\n        fun solve(): String {\n            while (paths[winState] == null) {\n                val newStates = ArrayList<BloxState>()\n                recentStates.forEach {\n                    val state = it\n                    val path = paths[it]!!\n\n                    attemptMove(state.up, path, \"U\", newStates)\n                    attemptMove(state.right, path, \"R\", newStates)\n                    attemptMove(state.down, path, \"D\", newStates)\n                    attemptMove(state.left, path, \"L\", newStates)\n                }\n                recentStates = newStates\n            }\n\n            return paths[winState]!!\n        }\n\n        private fun attemptMove(state: BloxState, path: String, char: String, newStates: ArrayList<BloxState>) {\n            if (!isValid(state)) return\n            if (paths[state] != null) return\n            paths[state] = \"$path$char\"\n            newStates.add(state)\n        }\n\n        private fun isValid(state: BloxState): Boolean {\n            fun safeGet(x: Int, y:Int): Boolean {\n                if (x < 0 || y < 0 || y >= board.size || x >= board[y].size) {\n                    return false\n                }\n                return board[y][x]\n            }\n            if (!safeGet(state.x, state.y)) {\n                return false\n            }\n\n            return when (state.direction) {\n                Blox.BloxState.BloxDirection.Upright -> true\n                Blox.BloxState.BloxDirection.Vertical -> safeGet(state.x, state.y+1)\n                Blox.BloxState.BloxDirection.Horizontal -> safeGet(state.x + 1, state.y)\n            }\n        }\n    }\n\n\n    data class BloxState(\n        val x: Int,\n        val y: Int,\n        val direction: BloxDirection\n    ) {\n        enum class BloxDirection {\n            Upright,\n            Vertical,\n            Horizontal\n        }\n\n        val up get() = when(direction) {\n            BloxDirection.Upright -> BloxState(x, y-2, BloxDirection.Vertical)\n            BloxDirection.Vertical -> BloxState(x, y-1, BloxDirection.Upright)\n            BloxDirection.Horizontal -> BloxState(x, y-1, BloxDirection.Horizontal)\n        }\n\n        val down get() = when(direction) {\n            BloxDirection.Upright -> BloxState(x, y+1, BloxDirection.Vertical)\n            BloxDirection.Vertical -> BloxState(x, y+2, BloxDirection.Upright)\n            BloxDirection.Horizontal -> BloxState(x, y+1, BloxDirection.Horizontal)\n        }\n\n        val right get() = when(direction) {\n            BloxDirection.Upright -> BloxState(x+1, y, BloxDirection.Horizontal)\n            BloxDirection.Vertical -> BloxState(x+1, y, BloxDirection.Vertical)\n            BloxDirection.Horizontal -> BloxState(x+2, y, BloxDirection.Upright)\n        }\n\n        val left get() = when(direction) {\n            BloxDirection.Upright -> BloxState(x-2, y, BloxDirection.Horizontal)\n            BloxDirection.Vertical -> BloxState(x-1, y, BloxDirection.Vertical)\n            BloxDirection.Horizontal -> BloxState(x-1, y, BloxDirection.Upright)\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208067,"user_id":null,"body":"package kata\n\nimport kata.BloxMoveDirection.*\nimport kata.BloxOrientation.Z_AXIS\nimport java.awt.Point\nimport java.util.*\n\nconst val BLOX_MAP_KEY_OPEN_AIR = '0'\nconst val BLOX_MAP_KEY_STARTING_POSITION = 'B'\nconst val BLOX_MAP_KEY_DESTINATION = 'X'\n\nenum class BloxMoveDirection(val mapKey: Char) {\n    UP('U'), DOWN('D'), LEFT('L'), RIGHT('R');\n\n    val opposite: BloxMoveDirection\n        get() = when (this) {\n            UP -> DOWN\n            DOWN -> UP\n            LEFT -> RIGHT\n            RIGHT -> LEFT\n        }\n}\n\nenum class BloxOrientation(val dx: Int, val dy: Int) {\n    X_AXIS(1, 0), Y_AXIS(0, 1), Z_AXIS(0, 0);\n\n    fun moveOffsetState(moveDirection: BloxMoveDirection): BloxState = when (this) {\n        X_AXIS -> when (moveDirection) {\n            UP -> BloxState(Point(0, -1), X_AXIS)\n            DOWN -> BloxState(Point(0, 1), X_AXIS)\n            LEFT -> BloxState(Point(-1, 0), Z_AXIS)\n            RIGHT -> BloxState(Point(2, 0), Z_AXIS)\n        }\n        Y_AXIS -> when (moveDirection) {\n            UP -> BloxState(Point(0, -1), Z_AXIS)\n            DOWN -> BloxState(Point(0, 2), Z_AXIS)\n            LEFT -> BloxState(Point(-1, 0), Y_AXIS)\n            RIGHT -> BloxState(Point(1, 0), Y_AXIS)\n        }\n        Z_AXIS -> when (moveDirection) {\n            UP -> BloxState(Point(0, -2), Y_AXIS)\n            DOWN -> BloxState(Point(0, 1), Y_AXIS)\n            LEFT -> BloxState(Point(-2, 0), X_AXIS)\n            RIGHT -> BloxState(Point(1, 0), X_AXIS)\n        }\n    }\n\n    fun secondPoint(point: Point): Point = Point(point.x + this.dx, point.y + this.dy)\n\n}\n\nobject Blox {\n    fun bloxSolver(puzzle: Array<String>): String = BloxSolver(puzzle).solution()\n}\n\ndata class BloxState(val point: Point, val orientation: BloxOrientation) {\n\n    fun minimumMovesBetweenPoints(other: BloxState): Int =\n        (kotlin.math.abs(point.x - other.point.x) * 2 + 1) \/ 3 + (kotlin.math.abs(point.y - other.point.y) * 2 + 1) \/ 3\n\n    fun move(direction: BloxMoveDirection): BloxState = orientation.moveOffsetState(direction).let { offsetState ->\n        BloxState(\n            Point(this.point).apply { translate(offsetState.point.x, offsetState.point.y) }, offsetState.orientation\n        )\n    }\n\n}\n\ndata class BloxSolutionStep(val movesRemaining: Int, val move: BloxMoveDirection?, val nextState: BloxState)\n\nclass BloxSolver(val puzzle: Array<String>) {\n    val startingState = BloxState(getUniquePoint(puzzle, BLOX_MAP_KEY_STARTING_POSITION), Z_AXIS)\n    val destinationState = BloxState(getUniquePoint(puzzle, BLOX_MAP_KEY_DESTINATION), Z_AXIS)\n    val compareByShortestPossiblePath: Comparator<BloxState> =\n        compareBy { it.minimumMovesBetweenPoints(startingState) + pathToDestination[it]!!.movesRemaining }\n    val pathToDestination = mutableMapOf<BloxState, BloxSolutionStep>().apply {\n        this[destinationState] = BloxSolutionStep(0, null, destinationState)\n    }\n    val bloxStatesToProcess = PriorityQueue(compareByShortestPossiblePath).apply {\n        this.offer(destinationState)\n    }\n\n    fun solution(): String {\n        while (startingState !in pathToDestination.keys) processBloxState(bloxStatesToProcess.poll()!!)\n        return sequence {\n            var currentState = startingState\n            while (currentState != destinationState) {\n                pathToDestination[currentState]!!.run {\n                    yield(this.move!!.mapKey)\n                    currentState = this.nextState\n                }\n            }\n        }.joinToString(\"\")\n    }\n\n    private fun getUniquePoint(puzzle: Array<String>, uniqueChar: Char) =\n        puzzle.joinToString(\"\").indexOf(uniqueChar).let { Point(it % puzzle[0].length, it \/ puzzle[0].length) }\n\n    private fun processBloxState(stateToProcess: BloxState) {\n        val movesRemaining = pathToDestination[stateToProcess]!!.movesRemaining + 1\n        BloxMoveDirection.values().associate { it to stateToProcess.move(it) }\n            .filterValues { ((movesRemaining < (pathToDestination[it]?.movesRemaining ?: Int.MAX_VALUE))) }\n            .filterValues(::isValid).forEach { direction, state ->\n                pathToDestination[state] = BloxSolutionStep(movesRemaining, direction.opposite, stateToProcess)\n                bloxStatesToProcess.offer(state)\n            }\n    }\n\n    private fun isValid(state: BloxState): Boolean =\n        isValid(state.point) && isValid(state.orientation.secondPoint(state.point))\n\n    private fun isValid(point: Point): Boolean =\n        (point.x in puzzle[0].indices) && (point.y in puzzle.indices) && (puzzle[point.y][point.x] != BLOX_MAP_KEY_OPEN_AIR)\n\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208068,"user_id":null,"body":"package kata\n\ndata class Position(\n    var path: String? = null, \/\/ how to get to this position from X, or null, if not visited yet\n    var l: Position? = null,\n    var r: Position? = null,\n    var u: Position? = null,\n    var d: Position? = null,\n    val finish: Boolean = false,\n    var solid: Boolean = false,\n) {\n\n    fun next(): List<Pair<String, Position>> =\n        listOf(\"U\" to u, \"D\" to d, \"L\" to l, \"R\" to r)\n            .filter { it.second?.let { it.path == null && it.solid } ?: false }\n            .map { Pair(it.first, it.second!!) }\n\n    override fun toString() = path ?: \"\"\n\n}\n\nobject Blox {\n    \n    val solid = setOf('1', 'B', 'X')\n\n    private fun Array<String>.toMarkedPuzzle(): Position { \/\/ starting position\n        var positionB: Position? = null\n        val shortFaces = this.map { row ->\n            row.map { col ->\n                val position = Position(finish = col == 'X', solid = col in solid, path = if (col == 'B') \"\" else null)\n                if (col == 'B')\n                    positionB = position\n                position\n            }\n        }\n        val horizontalFaces = this.map { it.dropLast(1).map { Position() } }\n        val verticalFaces = this.dropLast(1).map { it.map { Position() } }\n        for (i in this.indices) {\n            for (j in 0 until this[i].length - 2) {\n                shortFaces[i][j].r = horizontalFaces[i][j + 1]\n                horizontalFaces[i][j + 1].l = shortFaces[i][j]\n                shortFaces[i][j + 2].l = horizontalFaces[i][j]\n                horizontalFaces[i][j].r = shortFaces[i][j + 2]\n            }\n            for (j in 0 until this[i].length - 1)\n                horizontalFaces[i][j].solid = this[i][j] in solid && this[i][j + 1] in solid\n        }\n        for (i in 0 until this.size - 2) {\n            for (j in this[i].indices) {\n                shortFaces[i][j].d = verticalFaces[i + 1][j]\n                verticalFaces[i + 1][j].u = shortFaces[i][j]\n                shortFaces[i + 2][j].u = verticalFaces[i][j]\n                verticalFaces[i][j].d = shortFaces[i + 2][j]\n            }\n        }\n        for (i in 0 until this.size - 1) {\n            for (j in this[i].indices)\n                verticalFaces[i][j].solid = this[i][j] in solid && this[i + 1][j] in solid\n            for (j in 0 until this[i].length - 1) {\n                horizontalFaces[i][j].d = horizontalFaces[i + 1][j]\n                horizontalFaces[i + 1][j].u = horizontalFaces[i][j]\n                verticalFaces[i][j].r = verticalFaces[i][j + 1]\n                verticalFaces[i][j + 1].l = verticalFaces[i][j]\n            }\n        }\n        return positionB!!\n    }\n    \n    fun bloxSolver(puzzle:Array<String>): String {\n        val positionB = puzzle.toMarkedPuzzle()\n        val posQueue = mutableListOf(positionB)\n        while (posQueue.isNotEmpty()) {\n            val currPos = posQueue.removeAt(0)\n            val nextOnes = currPos.next()\n            nextOnes.forEach {\n                it.second.path = currPos.path + it.first\n                if (it.second.finish)\n                    return@bloxSolver it.second.path!!\n            }\n            posQueue.addAll(nextOnes.map { it.second })\n        }\n        throw IllegalArgumentException(\"Insolvable puzzle!\")\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208069,"user_id":null,"body":"package kata\n\ndata class Position(var state: String = \"s\", var x1: Int = 0, var y1: Int = 0, var x2: Int = 0, var y2: Int = 0, var from: String = \"R\") {\n    \n    fun nbrsWithinGrid(maxX: Int, maxY: Int): List<Position> {\n        val r = mutableListOf<Position>()\n        when (state) {\n            \"s\" -> {\n                r.add(Position(\"h\", x1+1, y1, x1+2, y1, from+\"R\")) \/\/R\n                r.add(Position(\"h\", x1-2, y1, x1-1, y1, from+\"L\")) \/\/L\n                r.add(Position(\"v\", x1, y1-2, x1, y1-1, from+\"U\")) \/\/U\n                r.add(Position(\"v\", x1, y1+1, x1, y1+2, from+\"D\")) \/\/D                \n            }\n            \"v\" -> {\n                r.add(Position(\"v\", x1+1, y1, x2+1, y2, from+\"R\")) \/\/R\n                r.add(Position(\"v\", x1-1, y1, x2-1, y2, from+\"L\")) \/\/L\n                r.add(Position(\"s\", x1, y1-1, 0, 0, from+\"U\")) \/\/U\n                r.add(Position(\"s\", x2, y2+1, 0, 0, from+\"D\")) \/\/D                \n            }\n            else -> {\n                r.add(Position(\"s\", x1+2, y1, 0, 0, from+\"R\")) \/\/R\n                r.add(Position(\"s\", x1-1, y1, 0, 0, from+\"L\")) \/\/L\n                r.add(Position(\"h\", x1, y1-1, x2, y2-1, from+\"U\")) \/\/U\n                r.add(Position(\"h\", x1, y1+1, x2, y2+1, from+\"D\")) \/\/D\n            }\n        }\n        return r.filter{it.x1 in 0..maxX && it.x2 in 0..maxX && it.y1 in 0..maxY && it.y2 in 0..maxY}\n    }\n    \n    fun isValid(level: Array<String>): Boolean {\n        when (state) {\n            \"s\" -> return if (level[y1][x1] == '0') false else true\n            else -> return if (level[y1][x1] == '0' || level[y2][x2] == '0') false else true\n        }\n    }\n}\n\nobject Blox {\n    fun bloxSolver(puzzle:Array<String>): String {\n        val maxX = puzzle[0].length-1\n        val maxY = puzzle.size-1\n        val start = Position(\"s\", puzzle.find{it.contains('B')}!!.indexOf('B'), puzzle.indexOfFirst{it.contains('B')}, 0, 0, \"\")\n        val finish = Position(\"s\", puzzle.find{it.contains('X')}!!.indexOf('X'), puzzle.indexOfFirst{it.contains('X')}, 0, 0, \"F\")\n        val ways = mutableListOf(Pair(start,0))\n        var i = 0\n        while (!ways.any{it.first.x1 == finish.x1 && it.first.x2 == finish.x2 && it.first.y1 == finish.y1 && it.first.y2 == finish.y2}) {\n            ways.filter{it.second == i}.forEach{\n                for (nbr in it.first.nbrsWithinGrid(maxX, maxY)) {\n                    if (nbr.isValid(puzzle) \n                        && !ways.any{it.first.x1 == nbr.x1 && it.first.x2 == nbr.x2 && it.first.y1 == nbr.y1 && it.first.y2 == nbr.y2})\n                \t\t    ways.add(Pair(nbr, i+1))\n                }\n            }        \n            i++\n        }\n        return ways.find{it.first.x1 == finish.x1 && it.first.x2 == finish.x2 && it.first.y1 == finish.y1 && it.first.y2 == finish.y2}?.first?.from?:\"NO WAY\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208070,"user_id":null,"body":"package kata\n\nvar n = 0\nvar m = 0\nvar start: State? = null\nvar end: State? = null\nvar a: Array<String>? = null\nvar u = mutableSetOf<State>()\n\nfun valid(x: Int, y: Int): Boolean {\n    if (x == -1 && y == -1) {\n        return true\n    }\n    val validCoordinate = x in 0 until n && y in 0 until m\n    return validCoordinate && a?.get(x)?.get(y) in arrayOf('1', 'B', 'X')\n}\n\ndata class State(val x1: Int, val y1: Int, val x2: Int = -1, val y2: Int = -1) {\n    fun next(): List<Pair<Char, State>> {\n        if (x2 == -1 && y2 == -1) {\n            \/\/ single square\n            return arrayListOf(\n                    Pair('L', State(x1, y1-2, x1, y1-1)),\n                    Pair('U', State(x1-2, y1, x1-1, y1)),\n                    Pair('R', State(x1, y1+1, x1, y1+2)),\n                    Pair('D', State(x1+1, y1, x1+2, y1)))\n                    .filter { valid(it.second.x1, it.second.y1)\n                            && valid(it.second.x2, it.second.y2)\n                            && !u.contains(it.second) }\n        } else if (x1 == x2) {\n            \/\/ horizontal\n            return arrayListOf(\n                    Pair('L', State(x1, y1-1)),\n                    Pair('U', State(x1-1, y1, x2-1, y2)),\n                    Pair('R', State(x2, y2+1)),\n                    Pair('D', State(x1+1, y1, x2+1, y2)))\n                    .filter { valid(it.second.x1, it.second.y1)\n                            && valid(it.second.x2, it.second.y2)\n                            && !u.contains(it.second) }\n        } else {\n            \/\/ vertical\n            return arrayListOf(\n                    Pair('L', State(x1, y1-1, x2, y2-1)),\n                    Pair('U', State(x1-1, y1)),\n                    Pair('R', State(x1, y1+1, x2, y2+1)),\n                    Pair('D', State(x2+1, y2)))\n                    .filter { valid(it.second.x1, it.second.y1)\n                            && valid(it.second.x2, it.second.y2)\n                            && !u.contains(it.second) }\n        }\n    }\n}\n\nobject Blox {\n    fun bloxSolver(puzzle:Array<String>): String {\n        a = puzzle\n        n = puzzle.size\n        m = puzzle[0].length\n        a?.forEachIndexed {i, arr ->\n            arr.forEachIndexed {j, char ->\n                when(char) {\n                    'B' -> start = State(i, j)\n                    'X' -> end = State(i, j)\n                }\n            }\n        }\n        u.clear()\n\n        val q = ArrayList<State>()\n        val p = ArrayList<Int>()\n        val d = ArrayList<Char>()\n        q.add(start!!)\n        u.add(start!!)\n        p.add(-1)\n        d.add('0')\n        var pos = 0\n        while (pos < q.size) {\n            val current = q[pos]\n            val next = current.next()\n            for (state in next) {\n                if (state.second == end!!) {\n                    val txt = StringBuilder(state.first.toString())\n                    while (pos != 0) {\n                        txt.append(d[pos])\n                        pos = p[pos]\n                    }\n                    return txt.toString().reversed()\n                }\n                q.add(state.second)\n                u.add(state.second)\n                p.add(pos)\n                d.add(state.first)\n            }\n            pos++\n        }\n        return \"not found\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208071,"user_id":null,"body":"package kata\n\nimport kotlin.math.max\nimport kotlin.math.min\n\nobject Blox {\n    fun bloxSolver(puzzle: Array<String>): String {\n        val board = Board(puzzle)\n        return board.solve()\n    }\n}\n\nclass Board(boardData: Array<String>) {\n\n    private val boardCoordinates = boardData.map { it.toCharArray().toTypedArray() }.toTypedArray()\n    private val startingBlockCoordinates = getCoordinates(boardData, 'B')\n    private val exitCoordinates = getCoordinates(boardData, 'X').first()\n    private val rootNode = PathNode(blockCoordinates = startingBlockCoordinates)\n    private val pathNodes: MutableList<PathNode> = mutableListOf()\n\n    fun solve(): String {\n        pathNodes.add(rootNode)\n        while (endNodeNotFound()) {\n            val nodes = getNodesToExamine()\n            if (nodes.isNotEmpty()) {\n                for (node in nodes) {\n                    val childNodes = findChildNodes(node)\n                    handleChildNodes(node, childNodes)\n                }\n            }\n        }\n        var node = pathNodes.first { isBlockAtExit(exitCoordinates, it.blockCoordinates) }\n        var path = \"\"\n        while (node.parentNode != null) {\n            path += node.direction?.id ?: \"\"\n            node = node.parentNode!!\n        }\n        return path.reversed()\n    }\n\n    private fun handleChildNodes(parentNode: PathNode, childNodes: List<PathNode>){\n        if (childNodes.isEmpty()) {\n            parentNode.deadEnd = true\n        } else {\n            childNodes.forEach { childNode ->\n                if (pathNodes.none { it.blockCoordinates == childNode.blockCoordinates }) {\n                    parentNode.childNodes.add(childNode)\n                    pathNodes.add(childNode)\n                } else {\n                    childNode.deadEnd = true\n                }\n            }\n        }\n    }\n\n    private fun findChildNodes(parent: PathNode): List<PathNode> {\n        val blockOrientation = getBlockOrientation(parent.blockCoordinates)\n        val directions = getPossibleDirections(parent.blockCoordinates, blockOrientation)\n        return directions.filter { it != Direction.opposite[parent.direction] }.map {\n            PathNode(\n                parentNode = parent,\n                direction = it,\n                blockCoordinates = blockOrientation.getBlockCoordsAfterMove(parent.blockCoordinates, it)\n            )\n        }\n    }\n\n    private fun getPossibleDirections(\n        blockCoords: List<Coordinates>,\n        blockOrientation: BlockOrientation\n    ): List<Direction> =\n        blockOrientation.getAllowedDirections(blockCoords, boardCoordinates)\n\n    private fun getNodesToExamine(): List<PathNode> = pathNodes.filter { !it.deadEnd && it.childNodes.isEmpty() }\n\n    private fun endNodeNotFound(): Boolean =\n        !pathNodes.any { exitCoordinates == it.blockCoordinates.first() && it.blockCoordinates.size == 1 }\n\n    private fun getCoordinates(boardArray: Array<String>, c: Char) =\n        boardArray.mapIndexed { i, s -> Coordinates(s.indexOf(c), i) }.filter { it.x >= 0 }\n\n    private fun isBlockAtExit(exitCoordinates: Coordinates, blockCoordinates: List<Coordinates>): Boolean =\n        blockCoordinates.size == 1 && blockCoordinates[0].x == exitCoordinates.x && blockCoordinates[0].y == exitCoordinates.y\n\n    private fun getBlockOrientation(blockCoordinates: List<Coordinates>): BlockOrientation {\n        return if (blockCoordinates.size == 1) {\n            BlockOrientation.VERTICAL\n        } else {\n            if (blockCoordinates.first().x == blockCoordinates.last().x)\n                BlockOrientation.HORIZONTAL_ACROSS\n            else\n                BlockOrientation.HORIZONTAL_ALONG\n        }\n    }\n}\n\ndata class Coordinates(val x: Int, val y: Int)\n\nclass PathNode(\n    val parentNode: PathNode? = null,\n    val childNodes: MutableList<PathNode> = mutableListOf(),\n    val direction: Direction? = null,\n    val blockCoordinates: List<Coordinates>\n) {\n    var deadEnd = false\n}\n\nenum class Direction(val id: Char) {\n    UP('U'),\n    DOWN('D'),\n    LEFT('L'),\n    RIGHT('R');\n\n    companion object {\n        val opposite = mapOf(UP to DOWN, DOWN to UP, RIGHT to LEFT, LEFT to RIGHT)\n    }\n}\n\nprivate fun isTileAt(x: Int, y: Int, boardCoordinates: Array<Array<Char>>): Boolean =\n    boardCoordinates.getOrNull(y)?.getOrNull(x) ?: '0' in \"1XB\"\n\ninterface Movable {\n    fun getAllowedDirections(blockCoords: List<Coordinates>, board: Array<Array<Char>>): List<Direction>\n    fun getBlockCoordsAfterMove(blockCoords: List<Coordinates>, direction: Direction): List<Coordinates>\n}\n\nenum class BlockOrientation : Movable {\n    VERTICAL {\n        override fun getAllowedDirections(\n            blockCoords: List<Coordinates>,\n            board: Array<Array<Char>>\n        ): List<Direction> {\n            val pos = blockCoords.first()\n            val moves = mutableListOf<Direction>()\n            if (isTileAt(pos.x, pos.y - 1, board) && isTileAt(pos.x, pos.y - 2, board))\n                moves.add(Direction.UP)\n            if (isTileAt(pos.x, pos.y + 1, board) && isTileAt(pos.x, pos.y + 2, board))\n                moves.add(Direction.DOWN)\n            if (isTileAt(pos.x - 1, pos.y, board) && isTileAt(pos.x - 2, pos.y, board))\n                moves.add(Direction.LEFT)\n            if (isTileAt(pos.x + 1, pos.y, board) && isTileAt(pos.x + 2, pos.y, board))\n                moves.add(Direction.RIGHT)\n            return moves\n        }\n\n        override fun getBlockCoordsAfterMove(blockCoords: List<Coordinates>, direction: Direction): List<Coordinates> {\n            val pos = blockCoords.first()\n            return when (direction) {\n                Direction.UP -> listOf(Coordinates(pos.x, pos.y - 1), Coordinates(pos.x, pos.y - 2))\n                Direction.DOWN -> listOf(Coordinates(pos.x, pos.y + 1), Coordinates(pos.x, pos.y + 2))\n                Direction.LEFT -> listOf(Coordinates(pos.x - 1, pos.y), Coordinates(pos.x - 2, pos.y))\n                Direction.RIGHT -> listOf(Coordinates(pos.x + 1, pos.y), Coordinates(pos.x + 2, pos.y))\n            }\n        }\n    },\n    HORIZONTAL_ALONG {\n        override fun getAllowedDirections(blockCoords: List<Coordinates>, board: Array<Array<Char>>): List<Direction> =\n            getHorizontalAllowedDirections(blockCoords, board)\n\n        override fun getBlockCoordsAfterMove(blockCoords: List<Coordinates>, direction: Direction): List<Coordinates> {\n            return when (direction) {\n                Direction.UP -> listOf(\n                    Coordinates(blockCoords.first().x, blockCoords.first().y - 1),\n                    Coordinates(blockCoords.last().x, blockCoords.last().y - 1)\n                )\n                Direction.DOWN -> listOf(\n                    Coordinates(blockCoords.first().x, blockCoords.first().y + 1),\n                    Coordinates(blockCoords.last().x, blockCoords.last().y + 1)\n                )\n                Direction.LEFT -> listOf(\n                    Coordinates(min(blockCoords.first().x, blockCoords.last().x) - 1, blockCoords.first().y)\n                )\n                Direction.RIGHT -> listOf(\n                    Coordinates(max(blockCoords.first().x, blockCoords.last().x) + 1, blockCoords.last().y)\n                )\n            }\n        }\n    },\n    HORIZONTAL_ACROSS {\n        override fun getAllowedDirections(blockCoords: List<Coordinates>, board: Array<Array<Char>>): List<Direction> =\n            getHorizontalAllowedDirections(blockCoords, board)\n\n        override fun getBlockCoordsAfterMove(blockCoords: List<Coordinates>, direction: Direction): List<Coordinates> {\n            return when (direction) {\n                Direction.UP -> listOf(\n                    Coordinates(blockCoords.first().x, min(blockCoords.first().y, blockCoords.last().y) - 1)\n                )\n                Direction.DOWN -> listOf(\n                    Coordinates(blockCoords.last().x, max(blockCoords.first().y, blockCoords.last().y) + 1)\n                )\n                Direction.LEFT -> listOf(\n                    Coordinates(blockCoords.first().x - 1, blockCoords.first().y),\n                    Coordinates(blockCoords.last().x - 1, blockCoords.last().y)\n                )\n                Direction.RIGHT -> listOf(\n                    Coordinates(blockCoords.first().x + 1, blockCoords.first().y),\n                    Coordinates(blockCoords.last().x + 1, blockCoords.last().y)\n                )\n            }\n        }\n    };\n\n    fun getHorizontalAllowedDirections(blockCoords: List<Coordinates>, board: Array<Array<Char>>): List<Direction> {\n        val moves = mutableListOf<Direction>()\n        if (isTileAt(blockCoords.first().x, blockCoords.first().y - 1, board) &&\n            isTileAt(blockCoords.last().x, blockCoords.last().y - 1, board)\n        )\n            moves.add(Direction.UP)\n        if (isTileAt(blockCoords.first().x, blockCoords.first().y + 1, board) &&\n            isTileAt(blockCoords.last().x, blockCoords.last().y + 1, board)\n        )\n            moves.add(Direction.DOWN)\n        if (isTileAt(blockCoords.first().x - 1, blockCoords.first().y, board) &&\n            isTileAt(blockCoords.last().x - 1, blockCoords.last().y, board)\n        )\n            moves.add(Direction.LEFT)\n\n        if (isTileAt(blockCoords.first().x + 1, blockCoords.first().y, board) &&\n            isTileAt(blockCoords.last().x + 1, blockCoords.last().y, board)\n        )\n            moves.add(Direction.RIGHT)\n        return moves\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208072,"user_id":null,"body":"package kata\n\nimport java.util.LinkedList\nimport kotlin.collections.HashSet\nimport kotlin.math.max\nimport kotlin.math.min\n\nobject Blox {\n    fun bloxSolver(puzzle: Array<String>): String {\n        val visited = HashSet<Position>()\n        val matrix = Matrix(puzzle)\n\n        val isHanging: Position.() -> Boolean = {\n            when (this) {\n                is Position.Laying -> matrix[cell1] == CellType.AIR || matrix[cell2] == CellType.AIR\n                is Position.Upright -> matrix[cell] == CellType.AIR\n            }\n        }\n\n        val initialPosition = Position.Upright(Cell(matrix.beginning.first, matrix.beginning.second))\n        visited.add(initialPosition)\n        val bfsq = LinkedList<Node>()\n        bfsq.add(Node(initialPosition, CameHere.FromBeginning))\n        while (bfsq.isNotEmpty()) {\n            val node = bfsq.poll()\n            val candidates = Direction.values().map { direction ->\n                Node(node.position.rotate(direction), CameHere.FromNode(node, direction))\n            }\n            val finalNode =\n                candidates.find { it.position is Position.Upright && matrix[it.position.cell] == CellType.DESTINATION }\n            if (finalNode != null) {\n                return traversePath(finalNode)\n            }\n            candidates.filter { !it.position.isHanging() }.filter { visited.add(it.position) }.forEach {\n                println(traversePath(it))\n                bfsq.offer(it)\n            }\n            println()\n        }\n        throw IllegalArgumentException()\n    }\n}\n\nfun traversePath(node: Node): String = when (node.cameHereFrom) {\n    is CameHere.FromBeginning -> \"\"\n    is CameHere.FromNode -> \"${traversePath(node.cameHereFrom.node)}${node.cameHereFrom.direction}\"\n}\n\n\nfun Position.rotate(direction: Direction): Position = when (this) {\n    is Position.Upright -> when (direction) {\n        Direction.U -> Position.Laying(this.cell.up(), this.cell.up().up())\n        Direction.D -> Position.Laying(this.cell.down(), this.cell.down().down())\n        Direction.L -> Position.Laying(this.cell.left(), this.cell.left().left())\n        Direction.R -> Position.Laying(this.cell.right(), this.cell.right().right())\n    }\n    is Position.Laying -> when {\n        this.cell1.x == this.cell2.x -> {\n            when (direction) {\n                Direction.L -> Position.Laying(this.cell1.left(), this.cell2.left())\n                Direction.R -> Position.Laying(this.cell1.right(), this.cell2.right())\n                Direction.U -> Position.Upright(Cell(this.cell1.x, max(this.cell1.y, this.cell2.y)).up())\n                Direction.D -> Position.Upright(Cell(this.cell1.x, min(this.cell1.y, this.cell2.y)).down())\n            }\n        }\n        else ->\n            when (direction) {\n                Direction.U -> Position.Laying(this.cell1.up(), this.cell2.up())\n                Direction.D -> Position.Laying(this.cell1.down(), this.cell2.down())\n                Direction.L -> Position.Upright(Cell(min(this.cell1.x, this.cell2.x), this.cell1.y).left())\n                Direction.R -> Position.Upright(Cell(max(this.cell1.x, this.cell2.x), this.cell1.y).right())\n            }\n    }\n}\n\nclass Node(val position: Position, val cameHereFrom: CameHere)\n\nsealed class Position {\n    data class Upright(val cell: Cell) : Position()\n    data class Laying(val cell1: Cell, val cell2: Cell) : Position()\n}\n\ndata class Cell(val x: Int, val y: Int) {\n    fun up() = Cell(x, y + 1)\n    fun down() = Cell(x, y - 1)\n    fun left() = Cell(x - 1, y)\n    fun right() = Cell(x + 1, y)\n}\n\nenum class CellType {\n    AIR, SOLID, DESTINATION\n}\n\nenum class Direction { U, D, L, R }\nsealed class CameHere {\n    class FromNode(val node: Node, val direction: Direction) : CameHere()\n    object FromBeginning : CameHere()\n}\n\nclass Matrix(puzzle: Array<String>) {\n    private val data: Array<Array<CellType>> = puzzle.reversed().map {\n        it.map { c ->\n            when (c) {\n                '0' -> CellType.AIR\n                '1', 'B' -> CellType.SOLID\n                'X' -> CellType.DESTINATION\n                else -> throw IllegalArgumentException()\n            }\n        }.toTypedArray()\n    }.toTypedArray()\n\n    val beginning: Pair<Int, Int> = Pair(\n        puzzle.find { it.contains(\"B\") }!!.indexOf(\"B\"),\n        puzzle.reversed().indexOfFirst { it.contains(\"B\") }\n    )\n\n    operator fun get(cell: Cell) = if (cell.x < 0 || cell.y < 0 || cell.x >= data[0].size || cell.y >= data.size) {\n        CellType.AIR\n    } else {\n        data[cell.y][cell.x]\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208073,"user_id":null,"body":"@file:Suppress(\"KDocMissingDocumentation\")\n\n\/** https:\/\/www.codewars.com\/kata\/5a2a597a8882f392020005e5 *\/\n\npackage kata\n\nabstract class Block(val position: List<MapGrid.Tile>) {\n    enum class Direction(val movement: (Block) -> Block) {\n        Up(Block::moveUp), Down(Block::moveDown), Left(Block::moveLeft), Right(Block::moveRight)\n    }\n\n    override fun toString(): String {\n        return position.joinToString(separator = \"\")\n    }\n    fun move(): List<Movement> =\n        Direction.values()\n            .map { Movement(from = this, to = it.movement(this), direction = it) }\n\n    fun isInside() =\n        position.all { it.type != MapGrid.Type.Empty }\n\n    fun isGoal() =\n        position.all { it.type == MapGrid.Type.Goal }\n\n    fun isStart() =\n        position.all { it.type == MapGrid.Type.Start }\n\n    override fun equals(other: Any?): Boolean {\n        return this.position.containsAll((other as Block).position) and ((other as Block).position).containsAll(this.position)\n    }\n\n    protected abstract fun moveUp(): Block\n    protected abstract fun moveDown(): Block\n    protected abstract fun moveLeft(): Block\n    protected abstract fun moveRight(): Block\n\n    class Unit(private val pos: MapGrid.Tile) : Block(listOf(pos)) {\n        override fun moveUp() = Block.Vertical(listOf(pos.translate(0, -2),pos.translate(0,-1)))\n        override fun moveDown() = Block.Vertical(listOf(pos.translate(0, +1),pos.translate(0,+2)))\n        override fun moveLeft() = Block.Horizontal(listOf(pos.translate(-2, 0),pos.translate(-1,0)))\n        override fun moveRight() = Block.Horizontal(listOf(pos.translate(+1, 0),pos.translate(+2,0)))\n    }\n\n    class Horizontal(private val pos: List<MapGrid.Tile>) : Block(pos) {\n        override fun moveUp() = Block.Horizontal(position.map { it.translate(0, -1) })\n        override fun moveDown() = Block.Horizontal(position.map { it.translate(0, +1) })\n        override fun moveLeft() = Block.Unit(position.first().translate(-1, 0))\n        override fun moveRight() = Block.Unit(position.last().translate(+1, 0))\n    }\n\n    class Vertical(private val pos: List<MapGrid.Tile>) : Block(pos) {\n        override fun moveUp() = Block.Unit(position.first().translate(0, -1))\n        override fun moveDown() = Block.Unit(position.last().translate(0, +1))\n        override fun moveLeft() = Block.Vertical(position.map { it.translate(-1, 0) })\n        override fun moveRight() = Block.Vertical(position.map { it.translate(+1, 0) })\n    }\n\n}\n\nclass MapGrid(private val scheme: Array<String>) : Iterable<MapGrid.Tile> {\n\n    enum class Type(val symbol: Char) { Void('0'), Empty('1'), Start('B'), Goal('X') }\n    inner class Tile(val x: Int, val y: Int, val type: Type? = null) {\n        fun translate(dx: Int, dy: Int) = get(x + dx, y + dy)\n        override fun equals(other: Any?): Boolean {\n            return ((other as Tile).x == this.x) and ((other as Tile).y == this.y)\n        }\n\n        override fun toString(): String {\n            return \"($x,$y)\"\n        }\n    }\n\n    private val _x = scheme.first().length\n    private val _y = scheme.size\n    private val _size = _x * _y\n    operator fun get(x: Int, y: Int) =\n        Tile(x, y, Type.values().find { it.symbol == scheme.getOrNull(y)?.getOrNull(x) ?: '0' })\n\n    override fun iterator() = object : Iterator<Tile> {\n        private var _position = 0\n        override fun hasNext() = _position < _size\n        override fun next() = get(_position % _x, _position \/ _x)\n            .also { _position++ }\n    }\n}\n\ndata class Movement(val from: Block?, val to: Block, val direction: Block.Direction? = null) {\n    override fun toString(): String {\n        return \"${from}${direction?.name?.first()?:' '}${to}\"\n    }\n}\n\nobject Blox {\n    fun bloxSolver(puzzle: Array<String>): String {\n        val mg = MapGrid(puzzle)\n        var movements = listOf(Movement(from = null,to = Block.Unit(mg.find { it.type == MapGrid.Type.Start }!!)))\n        var lastMovements = movements\n        while (movements.none { it.to.isGoal() }) {\n            lastMovements =\n                lastMovements\n                    .flatMap { it.to.move() }\n                    .filter { it.to.position.none { it.type == MapGrid.Type.Void } }\n                    .filter { it.to !in movements.map { it.to } }\n            movements = movements.plus(lastMovements)\n        }\n        var sol = mutableListOf<Movement>(movements.find { it.to.isGoal() }!!)\n        while (!sol.last().from!!.isStart()) {\n            val l = sol.last()\n            val ps = movements.filter { it.to == l.from }\n            sol.add(movements.find { it.to == sol.last().from } as Movement)\n        }\n        val s = sol.reversed().map { it.direction!!.name.first() }.joinToString(separator = \"\")\n\/\/        val xx = movements.map { it.to.position }\n\/\/        val init = Movement(Block.Unit(mg.find { it.type == MapGrid.Type.Start }!!))\n\/\/        init.next = init.block.move().filter { it.block.isInside()}\n        return s\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208074,"user_id":null,"body":"package kata\n\nimport kotlin.math.max\nimport kotlin.math.min\n\ntypealias P = Pair<Int, Int>\noperator fun Pair<Int, Int>.plus(that: Pair<Int, Int>) = Pair(this.first + that.first, this.second + that.second)\noperator fun Pair<Int, Int>.minus(that: Pair<Int, Int>) = Pair(this.first - that.first, this.second - that.second)\n\nval NILP: P = P(-1, -1)\n\nsealed class Block {\n    abstract fun up(): Block\n    abstract fun down(): Block\n    abstract fun left(): Block\n    abstract fun right(): Block\n}\n\ndata class Standing(val pos: P) : Block() {\n\n    override fun up() = Lying(pos + P(0, -1), pos + P(0, -2))\n    override fun down() = Lying(pos + P(0, 1), pos + P(0, 2))\n    override fun left() = Lying(pos + P(-1, 0), pos + P(-2, 0))\n    override fun right() = Lying(pos + P(1, 0), pos + P(2, 0))\n}\n\nclass Lying(a: P, b: P) : Block() {\n\n    var first :P\n    var second :P\n\n    init {\n        when {\n            a.first< b.first -> {\n                first = a\n                second = b\n            }\n            a.first > b.first -> {\n                first = b\n                second = a\n            }\n            a.second < b.second -> {\n                first = a\n                second = b\n            }\n            else -> {\n                first = b\n                second = a\n            }\n        }\n    }\n\n    override fun up(): Block {\n        return if (first.first == second.first) {\n            Standing(P(first.first, Math.min(first.second, second.second) - 1))\n        } else {\n            Lying(first + P(0, -1), second + P(0, -1))\n        }\n    }\n\n    override fun down(): Block {\n        return if (first.first == second.first) {\n            Standing(P(first.first, max(first.second, second.second) + 1))\n        } else {\n            Lying(first + P(0, 1), second + P(0, 1))\n        }\n    }\n\n    override fun left(): Block {\n        return if (first.second == second.second) {\n            Standing(P(min(first.first, second.first) - 1, first.second))\n        } else {\n            Lying(first + P(-1, 0), second + P(-1, 0))\n        }\n    }\n\n    override fun right(): Block {\n        return if (first.second == second.second) {\n            Standing(P(Math.max(first.first, second.first) + 1, first.second))\n        } else {\n            Lying(first + P(1, 0), second + P(1, 0))\n        }\n    }\n\n    override fun equals(other: Any?): Boolean {\n        if (this === other) return true\n        if (javaClass != other?.javaClass) return false\n\n        other as Lying\n\n        if (first != other.first) return false\n        if (second != other.second) return false\n\n        return true\n    }\n\n    override fun hashCode(): Int {\n        var result = first.hashCode()\n        result = 31 * result + second.hashCode()\n        return result\n    }\n}\n\nenum class Tile { EMPTY, SOLID, GOAL }\n\nobject Blox {\n    fun bloxSolver(puzzle: Array<String>): String {\n        val (block, goal, map) = parseInput(puzzle)\n        val q = mutableListOf<Block>()\n        val shortestPath = mutableMapOf<Block, String>()\n        q.add(block)\n        shortestPath[block] = \"\"\n        while (q.isNotEmpty()) {\n            val curr = q.removeAt(0)\n            val currPath = shortestPath[curr]!!\n            val neighbours = listOf(\n                Pair('U', curr.up()),\n                Pair('D', curr.down()),\n                Pair('L', curr.left()),\n                Pair('R', curr.right())\n            ).filter { isPossible(map, it.second) }\n            for (n in neighbours) {\n                if (n.second is Standing && (n.second as Standing).pos == goal) {\n                    if (!shortestPath.containsKey(n.second) || shortestPath[n.second]!!.length > (currPath + n.first).length) {\n                        shortestPath[n.second] = currPath + n.first\n                    }\n                } else {\n                    if (shortestPath.containsKey(n.second)) {\n                        if (shortestPath[n.second]!!.length > (currPath + n.first).length) {\n                            shortestPath[n.second] = currPath + n.first\n                            q.add(n.second)\n                        }\n                    } else {\n                        shortestPath[n.second] = currPath + n.first\n                        q.add(n.second)\n                    }\n                }\n            }\n        }\n        return shortestPath[Standing(goal)]!!\n    }\n\n    private fun isPossible(map: MutableMap<Pair<Int, Int>, Tile>, block: Block): Boolean {\n        return if (block is Standing) {\n            block.pos.first >= 0 && block.pos.second >= 0 && (map[block.pos] == Tile.SOLID || map[block.pos] == Tile.GOAL)\n        } else {\n            (block as Lying).first.first >= 0 && block.first.second >= 0 &&\n                    block.second.first >= 0 && block.second.second >= 0 &&\n                    map[block.first] == Tile.SOLID && map[block.second] == Tile.SOLID\n        }\n    }\n\n    private fun parseInput(puzzle: Array<String>): Triple<Block, P, MutableMap<P, Tile>> {\n        var block = Standing(NILP)\n        var goal = NILP\n        val map = mutableMapOf<P, Tile>()\n        for (rowN in puzzle.indices) {\n            val row = puzzle[rowN]\n            for (colN in row.indices) {\n                when (row[colN]) {\n                    '0' -> map[Pair(colN, rowN)] = Tile.EMPTY\n                    '1' -> map[Pair(colN, rowN)] = Tile.SOLID\n                    'X' -> {\n                        goal = Pair(colN, rowN)\n                        map[Pair(colN, rowN)] = Tile.SOLID\n                    }\n                    'B' -> {\n                        block = Standing(Pair(colN, rowN))\n                        map[Pair(colN, rowN)] = Tile.SOLID\n                    }\n                }\n\n            }\n        }\n        return Triple(block, goal, map)\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208075,"user_id":null,"body":"package kata\n\n\nimport kotlin.collections.*\n\nobject Blox {\n    val validMoves = listOf('L','R','U','D')\n\n    fun move(bLoc: List<Pair<Int,Int>>, move: Char, board: Array<String>) : List<Pair<Int,Int>>? {\n        if (!validMoves.contains(move)) return null\n\n        val newBloc = if (bLoc.size == 1) {\n            with (bLoc.first()) {\n                when(move) {\n                    'L' -> listOf(Pair(first,second-2),Pair(first,second-1))\n                    'R' -> listOf(Pair(first,second+1),Pair(first,second+2))\n                    'U' -> listOf(Pair(first-2,second),Pair(first-1,second))\n                    'D' -> listOf(Pair(first+1,second),Pair(first+2,second))\n\n                    else -> return null\n                }\n            }\n\n        } else if (bLoc[0].first == bLoc[1].first) {\n            when(move) {\n                'L' -> listOf(Pair(bLoc[0].first,bLoc[0].second-1))\n                'R' -> listOf(Pair(bLoc[0].first,bLoc[1].second+1))\n\n                'U' -> bLoc.map { Pair(it.first-1,it.second) }\n                'D' -> bLoc.map { Pair(it.first+1,it.second) }\n                else -> return null\n            }\n\n        } else {\n            when(move) {\n                'L' -> bLoc.map { Pair(it.first,it.second-1) }\n                'R' -> bLoc.map { Pair(it.first,it.second+1) }\n\n                'U' -> listOf(Pair(bLoc[0].first-1,bLoc[0].second))\n                'D' -> listOf(Pair(bLoc[1].first+1,bLoc[0].second))\n                else -> return null\n            }\n        }\n\n        if (newBloc.any {\n                it.first !in board.indices\n                        || it.second !in board[0].indices\n                        || board[it.first][it.second] == '0'\n            }) return null\n\n        return newBloc\n    }\n\n    fun findLetter(letter: Char, s: Array<String>) =  s.indices.flatMap { m ->\n        s[m].indices.mapNotNull { n-> if(s[m][n] == letter) Pair(m,n) else null }\n    }\n\n\n    fun bloxSolver(puzzle:Array<String>): String {\n        \/\/ your code goes here. you can do it!\n        val xLoc = findLetter('X',puzzle)\n        val initialBLoc = findLetter('B',puzzle)\n\n        if (initialBLoc == xLoc) return \"\"\n\n        val q = mutableListOf<Pair<String,List<Pair<Int,Int>>>>()\n        val used = mutableListOf<List<Pair<Int,Int>>>()\n        q.add(Pair(\"\",initialBLoc))\n        while (q.isNotEmpty()) {\n            val (path, bLoc) = q.removeAt(0)\n            used.add(bLoc)\n\n            val lastDirection = path.lastOrNull()\n            validMoves.filterNot { it == when(lastDirection) {\n                'L' -> 'R'\n                'R' -> 'L'\n                'U' -> 'D'\n                'D' -> 'U'\n                else -> false\n            } }.forEach { direction ->\n                val newbLoc = move(bLoc,direction,puzzle)\n\n                if (null != newbLoc) {\n                    val newPath = path+direction\n                    if (newbLoc == xLoc) return newPath\n\n                    if (!used.contains(newbLoc)) {\n                        q.add(Pair(newPath,newbLoc))\n                        used.add(newbLoc)\n                    }\n                }\n            }\n        }\n        return \"\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5a30e7e9c5e28454790000c1":[{"id":208076,"user_id":null,"body":"fun spiderToFly(spider: String, fly: String): Double {\n    val angle = (spider[0] - fly[0]) * 45.0\n    val a = \"${spider[1]}\".toInt()\n    val b = \"${fly[1]}\".toInt()\n    return Math.sqrt(a * a + b * b - 2 * a * b * Math.cos(Math.toRadians(angle)))\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208077,"user_id":null,"body":"import kotlin.math.*\n\nfun String.c() = this[0]\nfun String.d() = this.substring(1).toDouble()\nfun String.rad() = (2-c().minus('A')).toDouble()\/4.0 * PI\nfun String.x() = d() * cos(rad())\nfun String.y() = d() * sin(rad())\n\nfun spiderToFly(spider: String, fly: String) =\n    sqrt((spider.x()-fly.x()).pow(2) + (spider.y()-fly.y()).pow(2))\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208078,"user_id":null,"body":"import kotlin.math.*\n\nval angles = mapOf('A' to 0.0, \n                       'B' to PI \/ 4.0, \n                       'C' to PI \/ 2.0, \n                       'D' to 3.0 * PI \/ 4.0, \n                       'E' to PI, \n                       'F' to PI + PI \/ 4.0, \n                       'G' to PI + PI \/ 2.0, \n                       'H' to 2.0 * PI - PI \/ 4.0)\nfun spiderToFly(spider: String, fly: String): Double {\n    val rs = spider[1].digitToInt()\n    val rf = fly[1].digitToInt()\n    val ts = angles[spider[0]]?:0.0\n    val tf = angles[fly[0]]?:0.0\n    val d = rs*rs + rf*rf - 2*rs*rf*cos(ts-tf)\n    return sqrt(d) \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208079,"user_id":null,"body":"import kotlin.math.*\n\nfun spiderToFly(spider: String, fly: String): Double {\n    \/\/ get the first letter from both coordinates\n    \/\/ and calculate the angle based on the ASCII distiance between\n    \/\/ the letters\n    var angle = (abs(spider[0].code - fly[0].code) * 45).toDouble();\n    angle = angle * PI \/ 180;\n\n    \/\/ get a\n    var a = spider[1].digitToInt().toDouble()\n    \n    \/\/ get b\n    var b = fly[1].digitToInt().toDouble()\n    \n    \/\/ use formula\n    return sqrt(a.pow(2) + b.pow(2) - 2*a*b*cos(angle))\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208080,"user_id":null,"body":"\/\/ https:\/\/www.mathsisfun.com\/algebra\/trig-cosine-law.html\n\/\/ 9 + 4 - 2*3*2*cos(135)\n\/\/ https:\/\/kotlinlang.org\/docs\/packages.html\n\/\/ https:\/\/kotlinlang.org\/api\/latest\/jvm\/stdlib\/kotlin.math\/\n\nimport kotlin.math.*\n\nfun spiderToFly(spider: String, fly: String): Double {\n    \/\/ get the first letter from both coordinates\n    \/\/ and calculate the angle based on the ASCII distiance between\n    \/\/ the letters\n    var angle = (abs(spider[0].code - fly[0].code) * 45).toDouble();\n    angle = angle * PI \/ 180;\n\n    \/\/ get a\n    var a = spider[1].digitToInt().toDouble()\n    \n    \/\/ get b\n    var b = fly[1].digitToInt().toDouble()\n    \n    \/\/ use formula\n    return sqrt(a.pow(2) + b.pow(2) - 2*a*b*cos(angle))\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208081,"user_id":null,"body":"import java.lang.Math.pow\nimport kotlin.math.sqrt\n\nfun coordXY(coord: String): Pair<Double, Double>{\n    return (when(coord[0]){\n        'A' -> Pair(0.0, coord[1].toString().toDouble())\n        'E' -> Pair(0.0, -coord[1].toString().toDouble())\n        'G' -> Pair(-coord[1].toString().toDouble(), 0.0)\n        'C' -> Pair(coord[1].toString().toDouble(), 0.0)\n        'B' -> Pair(coord[1].toString().toDouble()*0.5*sqrt(2.0), coord[1].toString().toDouble()*0.5*sqrt(2.0))\n        'D' -> Pair(coord[1].toString().toDouble()*0.5*sqrt(2.0), -coord[1].toString().toDouble()*0.5*sqrt(2.0))\n        'F' -> Pair(-coord[1].toString().toDouble()*0.5*sqrt(2.0), -coord[1].toString().toDouble()*0.5*sqrt(2.0))\n        'H' -> Pair(-coord[1].toString().toDouble()*0.5*sqrt(2.0), coord[1].toString().toDouble()*0.5*sqrt(2.0))\n        else -> {Pair(0.0, 0.0)}\n    })\n}\nfun spiderToFly(spider: String, fly: String): Double {\n    val (sx, sy) = coordXY(spider)\n    val (fx, fy) = coordXY(fly)\n\n    return (sqrt(pow((sx-fx), 2.0) + pow(sy-fy, 2.0)))\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208082,"user_id":null,"body":"import kotlin.math.PI\nimport kotlin.math.cos\nimport kotlin.math.sqrt\n\nfun spiderToFly(spider: String, fly: String): Double {\n    val angles = mapOf(\n        'A' to 0.0,\n        'B' to 0.25 * PI,\n        'C' to 0.5 * PI,\n        'D' to 0.75 * PI,\n        'E' to PI,\n        'F' to 1.25 * PI,\n        'G' to 1.5 * PI,\n        'H' to 1.75 * PI\n    )\n\n    val a1 = angles[spider.first()] ?: 0.0\n    val r1 = spider.drop(1).toInt()\n\n    val a2 = angles[fly.first()] ?: 0.0\n    val r2 = fly.drop(1).toInt()\n    \n    return sqrt(r1 * r1 + r2 * r2 - 2 * r1 * r2 * cos(a1 - a2))\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208083,"user_id":null,"body":"import kotlin.math.*\n\nfun spiderToFly(spider: String, fly: String): Double {\n    val radiantSpider = radials.indexOf(spider.first().toString())\n    val radiantFly = radials.indexOf(fly.first().toString())\n    val degrees = calculateDeg(radiantSpider, radiantFly)\n    val ringSpider = Character.getNumericValue(spider[1])\n    val flyRing = Character.getNumericValue(fly[1])\n    return sqrt(\n        ringSpider.toDouble().pow(2) + flyRing.toDouble().pow(2) - 2 * ringSpider * flyRing * cos(\n            degrees * PI.div(180)\n        )\n    )\n}\n\nval radials = \"ABCDEFGH\"\n\nfun calculateDeg(start: Int, end: Int): Double {\n    val variant1 = abs(start.minus(end))\n    val variant2 = radials.length.minus(start).plus(end)\n    val variant3 = radials.length.minus(end).plus(start)\n    val segment = minOf(variant1, variant2, variant3)\n    return (segment.toDouble().div(radials.length)).times(360)\n}\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208084,"user_id":null,"body":"fun spiderToFly(spider: String, fly: String): Double {\n    val spiderCoord = webToCoord(spider)\n    val flyCoord = webToCoord(fly)\n    \/\/ dist = sqrt((x-x)^2 + (y-y)^2)\n    val xdiff = spiderCoord.first - flyCoord.first\n    val ydiff = spiderCoord.second - flyCoord.second\n    return Math.sqrt(xdiff * xdiff + ydiff * ydiff)\n}\n\nfun webToCoord(web: String): Pair<Double, Double> {\n    \/\/ A(0,1); B(r2,r2); C(1,0); D(r2,-r2); E(0,-1); F(-r2,-r2); G(-1,0); H(-r2,r2)\n    val r2 = Math.sqrt(2.0)\/2.0\n    val vector = when (web[0]) {\n        'A' -> Pair(0.0,1.0)\n        'B' -> Pair(r2,r2)\n        'C' -> Pair(1.0,0.0)\n        'D' -> Pair(r2,-r2)\n        'E' -> Pair(0.0,-1.0)\n        'F' -> Pair(-r2,-r2)\n        'G' -> Pair(-1.0,0.0)\n        else -> Pair(-r2,r2)\n    }\n    println(vector)\n    val scale = web.substring(1).toInt()\n    println(scale)\n    return Pair(scale * vector.first, scale * vector.second)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208085,"user_id":null,"body":"import kotlin.math.*\n\nfun spiderToFly(spider: String, fly: String): Double {\n    \n    val spiderRadial = spider[0]\n    val flyRadial = fly[0]\n    val spiderRing = spider.takeLast(1).toDouble()\n    val flyRing = fly.takeLast(1).toDouble()\n    val degrees = Math.abs(flyRadial - spiderRadial) * 45.0\n    \n    val distance = sqrt(\n        spiderRing.pow(2) + flyRing.pow(2)\n        - (2 * spiderRing * flyRing * cos(Math.toRadians(degrees)))\n        )\n    \n    return distance\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5a32526ae1ce0ec0f10000b2":[{"id":208086,"user_id":null,"body":"fun digitsAverage(input: Int): Int {\n    var digits = input.toString().map(Character::getNumericValue)\n    while (digits.size > 1) {\n        digits = digits.zipWithNext { a, b -> (a + b + 1) \/ 2 }\n    }\n    return digits.first()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208087,"user_id":null,"body":"import kotlin.math.*\n\nfun digitsAverage(input: Int): Int = \n    if (input < 10) input else digitsAverage(\n    \"$input\".run{ mapIndexed { i, c ->\n        if (i != lastIndex) \n            \"${ceil((\"$c\".toDouble() + \"${this[i+1]}\".toDouble())\/2.0).toInt()}\"\n        else \"\"\n    }.joinToString(\"\")}.toInt()\n)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208088,"user_id":null,"body":"import kotlin.math.ceil\n\nfun digitsAverage(input: Int): Int = generateSequence(\"$input\") {\n        it.zipWithNext { a, b -> \"${ceil((\"$a\".toInt() + \"$b\".toInt()) \/ 2.0).toInt()}\" }.joinToString(\"\")\n    }.first { it.length == 1 }.toInt()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208089,"user_id":null,"body":"fun digitsAverage(input: Int): Int {\n    var av = mutableListOf<Int>()\n    var avNew = mutableListOf<Int>()\n    input.toString().forEach {\n       av.add(it.toString().toInt())\n    }\n    while(av.size > 1) {\n       for(i in 0..av.size-2) {\n           avNew.add((av[i]+av[i+1])\/2 +(av[i]+av[i+1])%2)\n       }\n       av.clear()\n       av.addAll(avNew)\n       avNew.clear()\n   }\n  return av[0]\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208090,"user_id":null,"body":"fun digitsAverage(input: Int): Int {\n    if (input < 10) return input\n\n    val nextDigits = input.toString().map { it.digitToInt() }\n        .zipWithNext { a, b -> (a + b + 1) \/ 2 }\n        .joinToString(\"\").toInt()\n\n    return digitsAverage(nextDigits)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208091,"user_id":null,"body":"import kotlin.math.ceil\n\ntailrec fun digitsAverage(input: Int): Int =\n    if (input < 10) input else\n        digitsAverage(input.toString()\n            .windowed(2)\n            .map { ceil((it[0].digitToInt() + it[1].digitToInt()) \/ 2.0).toInt()}.joinToString(\"\")\n            .toInt())","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208092,"user_id":null,"body":"import kotlin.math.ceil\n\nfun digitsAverage(input: Int): Int {\n    var digits = input.toString().map{it.digitToInt()}\n    while(digits.count() > 1){\n        digits = digits.windowed(2).map { ceil((it.first() + it.last()) \/ 2.0).toInt() }\n    }\n    return digits[0]\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208093,"user_id":null,"body":"import kotlin.math.ceil\nfun digitsAverage(input: Int): Int {\n  \/\/ code here\n          var list: MutableList<Int> = mutableListOf()\n        var string=\"\"\n        var i=input.toString().map { it }.toList()\n       while (i.size>1){\n           for (j in 1 until i.size){\n               val avg= ceil((((i[j-1].toDouble()-48)+i[j].toDouble()-48)\/2).toDouble())\n               string+=avg.toInt().toString()\n           }\n           i=string.toString().map { it }.toList()\n           string=\"\"\n       }\n            return i[0].code-48\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208094,"user_id":null,"body":"fun digitsAverage(input: Int): Int {\n  var arrayDouble = input.toString().map { Character.getNumericValue(it).toDouble() }\n  \n  while (arrayDouble.size > 1) {\n      arrayDouble = arrayDouble.windowed(2) { Math.ceil((it[0] + it[1]) \/ 2) }\n  }\n  \n  return arrayDouble[0].toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208095,"user_id":null,"body":"fun digitsAverage(input: Int): Int {\n    if (input.toString().length < 2) return input\n\n    val res = input.toString()\n        .toList()\n        .zipWithNext()\n        .map { Math.ceil((it.first.toString().toInt() + it.second.toString().toInt())\/2.0).toInt() }\n        .joinToString(\"\")\n        .toInt()\n\n    return digitsAverage(res)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5a3357ae8058425bde002674":[{"id":208096,"user_id":null,"body":"package kata\n\nobject IterativeRotationCipher {\n        \n    fun decode(s:String): String {\n        val n = s.takeWhile{it.isDigit()}.toIntOrNull()?:0\n        var code = s.drop(\"$n \".length)\n        println(\"DECODE $n $code\")\n        (1..n).forEach {code = decode_once(n,code)}\n        return code\n    }\n    \n    fun decode_once(n: Int, s: String): String {\n        val step3 = s.split(\" \").map {\n            shiftLeft(n,it)\n        }.joinToString(\" \")\n        val spaces = step3.mapIndexedNotNull{ind,c-> if(c==' ') ind else null}\n        var step2 = shiftLeft(n,step3.filter{it!=' '})\n        var ptr = 0\n        return (0..s.lastIndex).map{ind->\n            if(ind in spaces) \" \"\n            else {val c = step2.take(1); step2 = step2.drop(1); c }\n        }.joinToString(\"\")\n    }\n    \n    private fun shiftLeft(n: Int, what: String): String {\n        if(n<=0 || what.length==0) return what\n        val shift = n%what.length\n        return  what.drop(shift) + what.take(shift)\n    }\n    \n    fun encode(n: Int, s: String): String {\n        println(\"ENCODE $n $s\")\n        var code = s\n        (1..n).forEach {code = encode_once(n,code)}\n        return \"$n $code\"\n    }\n    \n    private fun encode_once(n: Int, s: String): String {\n        val spaces = s.mapIndexedNotNull{ind,c-> if(c==' ') ind else null}\n        var step2 = shiftRight(n,s.filter{it!=' '})\n        var ptr = 0\n        val step3 = (0..s.lastIndex).map{ind->\n            if(ind in spaces) \" \"\n            else {val c = step2.take(1); step2 = step2.drop(1); c }\n        }.joinToString(\"\")\n        return step3.split(\" \").map{\n            shiftRight(n,it)\n        }.joinToString(\" \")\n    }\n    \n    private fun shiftRight(n: Int, what: String): String {\n        if(n<=0 || what.length==0) return what\n        val shift = n%what.length\n        return what.takeLast(shift) + what.dropLast(shift)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208097,"user_id":932,"body":"package kata\n\nobject IterativeRotationCipher {\nfun encode(n: Int, str: String)=str.mapIndexed { index, c ->  Pair(index,c)}.filter { it.second==' '}.map {it.first}.let {space->\n    \"$n \"+(1..n).fold(str){s,i->\n        s.replace(\" \",\"\").let {StringBuilder(it.drop(it.length-n)+it.dropLast(n))}\n            .let {s->space.forEach {s.insert(it,' ')};s.toString()}\n            .split(\" \")\n            .map {if (it.length>0)(n%it.length).let { m->it.drop(it.length-m)+it.dropLast(m)} else it}\n            .joinToString(\" \")\n    }\n}\n\nfun decode(str: String): String{\n    val n = str.substringBefore(' ').toInt()\n    var str = str.substringAfter(' ')\n    return str.mapIndexed { index, c ->  Pair(index,c)}.filter { it.second==' '}.map {it.first}.let {space->\n        (1..n).fold(str){s,i->\n            s.split(\" \")\n                .map {if(it.length>0)(n%it.length).let { m->it.drop(m)+it.dropLast(it.length-m)}else it}\n                .joinToString(\"\")\n                .let {StringBuilder(it.drop(n)+it.dropLast(it.length-n))}\n                .let {s->space.forEach{s.insert(it, ' ')};s.toString()}\n        }\n    }\n}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208098,"user_id":null,"body":"package kata\nimport java.util.*\n\nobject IterativeRotationCipher {\n    fun encode(n:Int, s:String): String {\n        return IterativeRotationCypher.encode(s,n)\n    }\n    \n    fun decode(s:String): String {\n        return IterativeRotationCypher.decode(s)\n    }\n}\n\nclass IterativeRotationCypher(_text: String, _separator: Char = ' ') {\n    val chars = _text.toMutableList()\n    private val separator = _separator\n    private val separatorIndexes = chars.withIndex().filter { it.value == _separator }.map { it.index }\n    private val separatorIndexesWithEnds =\n        separatorIndexes.toMutableList().also { it.add(0, -1) }.also { it.add(chars.size) }\n\n\n    companion object {\n        private val componentRegex =\n            Regex(\"\"\"^(\\d+) (.*)$\"\"\", setOf(RegexOption.MULTILINE, RegexOption.DOT_MATCHES_ALL))\n\n        fun encode(value: String, n: Int): String {\n            with(IterativeRotationCypher(value)) {\n                repeat(n) {\n                    rotateIgnoringSeparator(n)\n                    rotateAroundSeparator(n)\n                }\n                return \"$n ${chars.joinToString(\"\")}\"\n            }\n        }\n\n        fun decode(value: String): String {\n            val matchResult = componentRegex.find(value)\n            val n = matchResult!!.groupValues[1].toInt()\n            val encodedText = matchResult.groupValues[2]\n            with(IterativeRotationCypher(encodedText)) {\n                repeat(n) {\n                    rotateAroundSeparator(-n)\n                    rotateIgnoringSeparator(-n)\n                }\n                return chars.joinToString(\"\")\n            }\n        }\n    }\n\n    fun rotateAroundSeparator(distance: Int) = apply {\n        separatorIndexesWithEnds.withIndex().drop(1).forEach {\n            val start = separatorIndexesWithEnds[it.index - 1] + 1\n            val end = it.value\n            Collections.rotate(chars.subList(start, end), distance)\n        }\n    }\n\n    fun rotateIgnoringSeparator(distance: Int) = apply {\n        separatorIndexes.asReversed().forEach { chars.removeAt(it) }\n        Collections.rotate(chars, distance)\n        separatorIndexes.forEach { chars.add(it, separator) }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208099,"user_id":null,"body":"package kata\n\nobject IterativeRotationCipher {\n    fun encode(n: Int, s: String): String {\n        var spaces = mutableListOf<Int>()\n        var resultString = s\n\n        s.forEachIndexed { index, it ->\n            if (it == ' ') {\n                spaces.add(index)\n            }\n        }\n        repeat(n) {\n            var trimmedString = resultString.replace(\" \", \"\")\n\n            repeat(n) {\n                trimmedString = cyclicRightShift(trimmedString)\n            }\n\n            spaces.forEach {\n                trimmedString = StringBuilder(trimmedString).insert(it, \" \").toString()\n            }\n\n            trimmedString = trimmedString.split(\" \").joinToString(\"\") { item ->\n                var newString = item\n                if (item.isNotBlank()) {\n                    repeat(n) {\n                        newString = cyclicRightShift(newString)\n                    }    \n                }\n                newString\n            }\n\n            spaces.forEach {\n                trimmedString = StringBuilder(trimmedString).insert(it, \" \").toString()\n            }\n            resultString = trimmedString\n        }\n        return \"$n $resultString\"\n    }\n\n    fun decode(s: String): String {\n        var spaces = mutableListOf<Int>()\n        println(s)\n        var sumLoop = s.takeWhile {\n            println(it)\n            it != ' '\n        }.toInt()\n        var resultString = s.substring(s.indexOf(' ') + 1)\n        println(resultString)\n\n        resultString.forEachIndexed { index, it ->\n            if (it == ' ') {\n                spaces.add(index)\n            }\n        }\n        println(sumLoop)\n        repeat(sumLoop) {\n            var trimmedString: String\n            trimmedString = resultString.split(\" \").joinToString(\"\") { item ->\n                var newString = item\n                if (item.isNotBlank()) {\n                    repeat(sumLoop) {\n                        newString = cyclicLeftShift(newString)\n                    }\n                }\n                newString\n            }\n            println(trimmedString)\n\n            repeat(sumLoop) {\n                trimmedString = cyclicLeftShift(trimmedString)\n            }\n\n            spaces.forEach {\n                trimmedString = StringBuilder(trimmedString).insert(it, \" \").toString()\n            }\n            resultString = trimmedString\n        }\n        return resultString\n    }\n\n    fun cyclicRightShift(s: String): String {\n        return s.last() + s.dropLast(1)\n    }\n\n    fun cyclicLeftShift(s: String): String {\n        return s.drop(1) + s.take(1)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208100,"user_id":null,"body":"package kata\n\nobject IterativeRotationCipher {\n    fun String.shiftLeft(n: Int): String = this.takeLast(this.length - n%this.length)+this.take(n%this.length)\n    fun String.shiftRight(n: Int): String = this.takeLast(n%this.length) + this.take(this.length - n%this.length)\n    \n    fun encode(n:Int, s:String): String {        \n        var r = s\n        val ws = s.mapIndexed{i, v -> Pair(v, i)}.filter{it.first == ' '}.mapIndexed{j, w -> w.second-j-1}\n        for (i in 1..n) {\n            r = r.filter{it != ' '}.shiftRight(n)\n                .mapIndexed{k, z -> if (k in ws) z.toString()+\" \" else z.toString()}\n                .joinToString(\"\")\n                .split(\" \").filter{it!=\"\"}.map{it.shiftRight(n)}\n                .joinToString(\"\").mapIndexed{k, z -> if (k in ws) z.toString()+\" \".repeat(ws.filter{it == k}.size) else z.toString()}\n                .joinToString(\"\")\n        }\n        return n.toString()+\" \"+r\n    }\n    \n    fun decode(s:String): String {        \n        val n = s.takeWhile{it != ' '}.toInt()\n        var r = s.dropWhile{it != ' '}.drop(1)\n        val ws = r.mapIndexed{i, v -> Pair(v, i)}.filter{it.first == ' '}.mapIndexed{j, w -> w.second-j-1}\n        for (i in 1..n) {\n        \tr = r.split(\" \").filter{it!=\"\"}.map{it.shiftLeft(n)}.joinToString(\"\").shiftLeft(n)\n                .mapIndexed{j, w -> if (j in ws) w.toString()+\" \".repeat(ws.filter{it == j}.size) else w.toString()}\n                .joinToString(\"\")\n        }\n        return r \n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208101,"user_id":null,"body":"package kata\n    \nprivate fun String.rotateWordLeft(n: Int): String {\n    if (length == 0) {\n        return this\n    }\n    val nn = n % length\n    return substring(nn) + substring(0, nn)\n}\n\nprivate fun String.rotateWordRight(n: Int): String {\n    if (length == 0) {\n        return this\n    }\n    return rotateWordLeft(length - n % length)\n}\n\nprivate fun String.rotateSentense(n: Int, wordLengths: List<Int>, rotator: String.(Int) -> String): String {\n    val rotated = replace(\" \", \"\").rotator(n)\n    var idx = 0\n    return wordLengths.joinToString(\" \") {\n        idx += it\n        rotated.substring(idx - it, idx)\n    }\n}\n\nobject IterativeRotationCipher {\n    \n    fun encode(n: Int, s: String): String {\n        val wordLengths = s.split(' ').map { it.length }\n        val res = (0 until n).fold(s) { it, _ -> \n            it.rotateSentense(n, wordLengths, String::rotateWordRight)\n                .split(' ')\n                .joinToString(\" \") { it.rotateWordRight(n) } \n        }\n        return \"$n $res\"\n    }\n    \n    fun decode(es: String): String {\n        val (nStr, s) = es.split(' ', limit = 2)\n        val n = nStr.toInt()\n        val wordLengths = s.split(' ').map { it.length }\n        return (0 until n).fold(s) { it, _ ->\n            it.split(' ')\n                .joinToString(\" \") { it.rotateWordLeft(n) }\n                .rotateSentense(n, wordLengths, String::rotateWordLeft)\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208102,"user_id":null,"body":"package kata\n\nobject IterativeRotationCipher {\n    fun encode(n:Int, s:String): String {\n        var result = s\n        for (i in IntRange(1, n)) {\n            result = singleEncodeStep(n, result)\n        }\n\n        return \"$n $result\"\n    }\n\n    fun decode(s:String): String {\n        val n = s.split(\" \").first().toInt()\n        var result = s.split(\" \").drop(1).joinToString(\" \")\n\n        for (i in IntRange(1, n)) {\n            result = singleDecodeStep(n, result)\n        }\n\n        return result\n    }\n\n    private fun singleEncodeStep(n:Int, s:String) : String {\n        val spacePositions = getSpacePositions(s)\n        val spaceless = removeSpaces(s)\n        val rotated = rotate(spaceless, -n)\n        val withSpacesBack = insertSpaces(rotated, spacePositions)\n        return withSpacesBack.split(\" \").map { rotate(it, -n) }.joinToString(\" \")\n    }\n\n    private fun singleDecodeStep(n:Int, s:String) : String {\n        val partsRotatedBack = s.split(\" \").map { rotate(it, n) }.joinToString(\" \")\n        val spacePositions = getSpacePositions(partsRotatedBack)\n        val spaceless = removeSpaces(partsRotatedBack)\n        val rotatedBack = rotate(spaceless, n)\n        return insertSpaces(rotatedBack, spacePositions)\n    }\n\n    private fun rotate(s:String, n:Int) : String {\n        if (s.isEmpty()) return s\n        val length = s.length\n        val pos = if (n < 0) length + n % length else n % length\n\n        return s.slice(IntRange(pos, length - 1)) + s.slice(IntRange(0, pos - 1))\n    }\n\n    private fun removeSpaces(s:String) : String {\n        return s.split(\" \").joinToString(\"\")\n    }\n\n    private fun insertSpaces(s:String, spacePositions:List<Int>) : String {\n        var withSpacesBack = s\n        for (index in spacePositions) {\n            withSpacesBack = insertSpace(withSpacesBack, index)\n        }\n\n        return withSpacesBack\n    }\n\n    private fun insertSpace(s:String, index:Int) : String {\n        return s.slice(IntRange(0, index - 1)) + \" \" + s.slice(IntRange(index, s.length - 1))\n    }\n\n    private fun getSpacePositions(s:String) : List<Int> {\n        var result = mutableListOf<Int>()\n        s.split(\"\").forEachIndexed { index, v -> if (v == \" \") result.add(index - 1)  }\n\n        return result\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208103,"user_id":null,"body":"package kata\n\nfun shiftString(s: String, n: Int): String {\n    if (s.length < 2) return s\n    val shift = n.rem(s.length)\n    return when {\n        shift > 0 -> s.takeLast(shift) + s.take(s.length - shift)\n        shift < 0 -> s.takeLast(s.length + shift) + s.take(0 - shift)\n        else -> s\n    }\n}\n\nobject IterativeRotationCipher {\n    fun encode(n:Int, s:String): String {\n        var result = s\n        for (iteration in 1..n) {\n            result = result\n                .filter { it != ' ' }\n                .let { shiftString(it, n) }\n                .let {\n                    var i = 0\n                    var acc = \"\"\n                    for (c in s) {\n                        acc += if (c == ' ') c else it[i++]\n                    }\n                    acc\n                }\n                .split(\" \")\n                .map { shiftString(it, n) }\n                .joinToString(\" \")\n        }\n        return n.toString() + \" \" + result\n    }\n    \n    fun decode(s:String): String {\n        val n = s.split(\" \").first().toInt(10)\n        val startStr = s.split(\" \").drop(1).joinToString(\" \")\n        var result = startStr\n        for (iteration in 1..n) {\n            result = result\n                .split(\" \")\n                .map { shiftString(it, -n) }\n                .joinToString(\"\")\n                .let { shiftString(it, -n) }\n                .let {\n                    var i = 0\n                    var acc = \"\"\n                    for (c in startStr) {\n                        acc += if (c == ' ') c else it[i++]\n                    }\n                    acc\n                }\n        }\n        return result\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208104,"user_id":null,"body":"package kata\n\nimport java.util.Collections.rotate\nimport kotlin.math.abs\n\nobject IterativeRotationCipher {\n    fun encode(n: Int, s: String): String {\n        var result = s\n        val spaceIndexes = spaceIndexes(result)\n        for (i in 0 until abs(n)) {\n            result = rotateAll(result, n, spaceIndexes)\n            result = rotateWords(result, n)\n        }\n        return \"$n $result\"\n    }\n\n    fun decode(s: String): String {\n        val split = s.split(\" \")\n        val n = split.first().toInt()\n        var result = split.drop(1).joinToString(\" \")\n        val spaceIndexes = spaceIndexes(result)\n        for (i in 0 until n) {\n            result = rotateWords(result, -n)\n            result = rotateAll(result, -n, spaceIndexes)\n            println(result)\n        }\n        return result\n    }\n    \n    private fun spaceIndexes(s: String): List<Int> = s.mapIndexed { i, c ->\n        if (c == ' ') i else null\n    }.filterNotNull()\n\n    private fun insertSpaces(s: String, spaces: List<Int>): String {\n        val chars = s.toMutableList()\n        spaces.forEach {\n            chars.add(it, ' ')\n        }\n        return chars.joinToString(\"\")\n    }\n\n    private fun rotate(s: String, n: Int): String {\n        val list = s.toMutableList()\n        rotate(list, n)\n        return list.joinToString(\"\")\n    }\n\n    private fun rotateWords(s: String, n: Int): String = s.split(\" \")\n        .joinToString(\" \") { rotate(it, n) }\n\n    private fun rotateAll(s: String, n: Int, spaceIndexes: List<Int>): String {\n        val rotated = s.replace(\" \", \"\")\n        return insertSpaces(rotate(rotated, n), spaceIndexes)\n    }\n}\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208105,"user_id":null,"body":"package kata\n\n\nobject IterativeRotationCipher {\n    fun encode(n: Int, s: String): String {\n      \n        var sentence = s\n\n        val indexesOfSpaces = sentence.withIndex().filter { it.value == ' ' }.map { it.index }\n        for (i in 0 until n) {\n            val withoutSpaces = sentence.replace(\" \", \"\")\n\n            val lastNCharacters = if (withoutSpaces.length < n) withoutSpaces.takeLast(withoutSpaces.length % n) else withoutSpaces.takeLast(n)\n            val firstSLengthMinusNCharacters = if (withoutSpaces.length < n) withoutSpaces.take(withoutSpaces.length - (withoutSpaces.length % n)) else withoutSpaces.take(withoutSpaces.length - n)\n\n            var shiftedString = lastNCharacters + firstSLengthMinusNCharacters\n\n            indexesOfSpaces.forEach {\n                shiftedString = shiftedString.replaceRange(it, it, \" \")\n            }\n\n            var shiftedAllWords = shiftedString.split(\"  *\".toRegex()).map {\n                val startedPosition = shiftCharacterToRight(it, n, 0)\n                shiftWord(it, startedPosition)\n            }.joinToString(\"\")\n\n            indexesOfSpaces.forEach {\n                shiftedAllWords = shiftedAllWords.replaceRange(it, it, \" \")\n            }\n\n            sentence = shiftedAllWords\n        }\n        return \"$n $sentence\"\n    }\n\n\n    fun decode(s: String): String {\n                println(\"s = $s\")\n\n        val n = s.takeWhile { it != ' ' }.toInt()\n\n        val prefixSize = s.takeWhile { it != ' ' }.length.let { it + 1 }\n        var sentence = s.substring(prefixSize, s.length)\n        val indexesOfSpaces = sentence.withIndex().filter { it.value == ' ' }.map { it.index }\n\n        for (i in 0 until n) {\n            var shiftedAllWords = sentence.split(\" \").map {\n                val startedPosition = shiftCharacterToLeft(it, n, 0)\n                shiftWord(it, startedPosition)\n            }.joinToString(\"\")\n\n            val firstNCharacters = if (shiftedAllWords.length < n) shiftedAllWords.take(shiftedAllWords.length % n) else shiftedAllWords.take(n)\n            val lastSLengthMinusNCharacters = if (shiftedAllWords.length < n) shiftedAllWords.takeLast(shiftedAllWords.length - (shiftedAllWords.length % n)) else shiftedAllWords.takeLast(shiftedAllWords.length - n)\n\n            shiftedAllWords = lastSLengthMinusNCharacters + firstNCharacters\n\n            indexesOfSpaces.forEach {\n                shiftedAllWords = shiftedAllWords.replaceRange(it, it, \" \")\n            }\n            sentence = shiftedAllWords\n        }\n        return sentence\n    }\n\n    private fun shiftCharacterToRight(s: String, n: Int, startedPosition: Int): Int { \/\/ return index of new location for s charaster, with this character\n        var newPosition = startedPosition\n        for (i in 0 until n) {\n            if (newPosition == s.length - 1) { \/\/ if we are on the end of string. go to begin of string\n                newPosition = 0\n            } else {\n                newPosition++\n            }\n        }\n        return newPosition\n    }\n\n    private fun shiftCharacterToLeft(s: String, n: Int, startedPosition: Int): Int { \/\/ return index of new location for s charaster, with this character\n        var newPosition = startedPosition\n        for (i in 0 until n) {\n            if (newPosition == 0) { \/\/ if we are on the end of string. go to begin of string\n                newPosition = s.length - 1\n            } else {\n                newPosition--\n            }\n        }\n        return newPosition\n    }\n\n    private fun shiftWord(s: String, startedPosition: Int): String {\n        if (s.isNotEmpty()) {\n            val sufixSize = s.length - startedPosition\n            val sufix = s.take(sufixSize)\n            return s.takeLast(startedPosition) + sufix\n        }\n        else return \"\"\n    }\n\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5a3fe3dde1ce0e8ed6000097":[{"id":208106,"user_id":null,"body":"fun century_from_year(number: Int) = (number +99) \/ 100","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208107,"user_id":null,"body":"import kotlin.math.ceil\n\nfun century_from_year(number: Int) = ceil(number \/ 100.0).toInt()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208108,"user_id":1381,"body":"fun century_from_year(year: Int): Int {\n    return if (year % 100 == 0) year \/ 100 else (year \/ 100) + 1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208109,"user_id":null,"body":"fun century_from_year(number: Int): Int {\n    return ((number - 1) \/ 100).toInt() + 1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208110,"user_id":null,"body":"import kotlin.math.*\n\nfun century_from_year(number: Int): Int {\n    return ceil(number \/ 100.0).toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208111,"user_id":null,"body":"fun century_from_year(number: Int): Int = if(number % 100 > 0) (1+ number\/100) else number\/100 ","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208112,"user_id":null,"body":"fun main () {\n    century_from_year(1900)\n}\n\nfun century_from_year(number: Int):Int {\n   var x = (number+99)\/100\n    \n    return x.toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208113,"user_id":null,"body":"fun century_from_year(n: Int) = if (n % 100 == 0) n \/ 100 else n \/ 100 + 1","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208114,"user_id":null,"body":"fun century_from_year(number: Int): Int = (number-1).div(100)+1","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208115,"user_id":null,"body":"fun century_from_year(number: Int): Int =  (number - 1) \/ 100 + 1","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5a431c0de1ce0ec33a00000c":[{"id":208116,"user_id":1251,"body":"fun evenNumbers(array: List<Int>, number: Int) = array.filter{ it % 2 == 0 }.takeLast(number)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208117,"user_id":null,"body":"fun evenNumbers(array: List<Int>, number: Int): List<Int> {\n        val evenList = mutableListOf<Int>()\n        array.reversed().map {\n            if (it % 2 == 0 && evenList.size < number) evenList.add(it)\n        }\n\n        return evenList.reversed()\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208118,"user_id":1170,"body":"\nfun evenNumbers(array: List<Int>, number: Int) = array.filter { it.rem(2) == 0 }.takeLast(number)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208119,"user_id":null,"body":"fun evenNumbers(array: List<Int>, n: Int) = array.filter { it%2==0 }.takeLast(n)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208120,"user_id":null,"body":"fun evenNumbers(array: List<Int>, number: Int): List<Int> {\n    return array.filter { x -> x % 2 == 0 }.reversed().subList(0, number).reversed()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208121,"user_id":null,"body":"\/\/ Just because the challenge says \"array\" does not mean we should use a Kotlin Array...\nfun evenNumbers(array: List<Int>, number: Int): List<Int> = array.filter { item -> item.rem(2) == 0 }.takeLast(number)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208122,"user_id":null,"body":"fun evenNumbers(array: List<Int>, number: Int): List<Int> {\n  var newList = listOf<Int>()\n    \n  for (number in array) {\n    if ( number % 2 == 0 ) {\n      newList += number\n    }  \n  }\n  return newList.subList(newList.size - number, newList.size)\n} \n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208123,"user_id":null,"body":"\/\/ Just because the challenge says \"array\" does not mean we should use a Kotlin Array...\nfun evenNumbers(array: List<Int>, number: Int): List<Int> {\n    var evenNumbers: MutableList<Int> = mutableListOf()\n    \n    array.forEach { num ->\n        if (num % 2 == 0) {\n            evenNumbers.add(num)\n        }\n    }\n    \n    val lastPosition = evenNumbers.lastIndex + 1\n    val firstPosition = lastPosition - number\n    \n    return evenNumbers.subList(firstPosition, lastPosition)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208124,"user_id":null,"body":"fun evenNumbers(xs: List<Int>, n: Int): List<Int> = xs.partition { it % 2 == 0 }.first.takeLast(n)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208125,"user_id":null,"body":"fun evenNumbers(a: List<Int>, n: Int) = a.filter { it or 1 != it }.takeLast(n)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5a48948e145c46820b00002f":[{"id":208126,"user_id":492,"body":"package kprimessteps\n  \nprivate fun countPrimeDiv(m:Long):Int {\n  var cnt = 0\n  var n = m\n  var i:Long = 2\n  while (i * i <= n)\n  {\n    while (n % i == 0L)\n    {\n      cnt++\n      n \/= i\n    }\n    i++\n  }\n  if (n > 1) cnt++\n  return cnt\n}\nfun kprimesStep(k:Int, step:Int, start:Long, nd:Long):List<LongArray> {\n  val res = ArrayList<LongArray>()\n  var i = start\n  while (i <= nd - step)\n  {\n    if ((countPrimeDiv(i) == k && countPrimeDiv(i + step) == k))\n    res.add(longArrayOf(i, i + step))\n    i++\n  }\n  return res\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208127,"user_id":932,"body":"package kprimessteps\n\nprivate fun Long.factorCount(): Int{\n    var count = 0\n    var f = 2\n    var n = this\n    while (n>1){\n        if (n%f==0L){\n            n\/=f\n            count++\n        }else f++\n    }\n    return count\n}\n\n\nfun kprimesStep(k:Int, step:Int, start:Long, nd:Long)=(start..nd).filter{it.factorCount()==k}.let{kPrimes->kPrimes.filter{it+step in kPrimes}.map{ longArrayOf(it, it+step)}.toList()}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208128,"user_id":null,"body":"package kprimessteps\n\nfun kprimesStep(k: Int, step: Int, start: Long, end: Long): List<LongArray> {\n    return (start..end - step)\n        .filter { countPrimeFactors(it) == k && countPrimeFactors(it + step) == k }\n        .map { longArrayOf(it, it + step) }\n}\n\nfun countPrimeFactors(m: Long): Int {\n    var primeFactors = 0\n    var n = m\n\n    while (n % 2 == 0L && n > 0) {\n        n \/= 2\n        primeFactors++\n    }\n\n    for (i in 3..Math.sqrt(n.toDouble()).toInt() step 2) {\n        while (n % i == 0L) {\n            n \/= i\n            primeFactors++\n        }\n    }\n\n    return if (n == 1L) primeFactors else primeFactors + 1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208129,"user_id":null,"body":"package kprimessteps\n\nimport kotlin.math.sqrt\n\nfun kprimesStep(k: Int, step: Int, start: Long, end: Long): List<LongArray> {\n\n    val x = (start..end).map{Pair(it,decompose(it))}\n        .filter{it.second.count() == k && decompose(it.first + step).count() == k}\n        .map { longArrayOf(it.first, it.first + step) }\n\n    return x\n}\n\nfun decompose(n: Long): LongArray {\n    var temp = n\n    val primes = mutableListOf<Long>()\n\n    while (temp % 2 == 0L) {\n        primes.add(2)\n        temp \/= 2;\n    }\n\n    val s = sqrt(temp.toDouble()).toLong()\n\n    (3L..s step 2).forEach {\n        while (temp % it == 0L) {\n            primes.add(it)\n            temp \/= it\n        }\n    }\n\n    if (temp > 2)\n        primes.add(temp)\n\n    return primes.toLongArray()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208130,"user_id":null,"body":"package kprimessteps\nval primes = mutableListOf(2L)\nfun calcNextPrime() {\n    var current = primes[primes.size - 1] + 1\n    while(true) {\n        for (i in primes.indices) {\n            if (current % primes[i] == 0L) {\n                current++\n                continue\n            }\n        }\n\n        primes += current\n        break\n    }\n}\nfun getPrimeFactors(n: Long, k: Int): List<Long> {\n    if (n in listOf(0L, 1L)) return listOf()\n\n    val factors = mutableListOf<Long>()\n    var current = n\n    var currentPrimeIndex = 0\n    var overhead = 0\n\n    while (current != 1L && k >= factors.size) {\n        if (overhead >= 10000) return listOf()\n        if (current % primes[currentPrimeIndex] == 0L) {\n            current \/= primes[currentPrimeIndex]\n            factors += primes[currentPrimeIndex]\n        } else {\n            currentPrimeIndex++\n            if (currentPrimeIndex == primes.size) calcNextPrime()\n            overhead++\n        }\n    }\n\n    return factors\n}\n\nfun kprimesStep(k: Int, step: Int, start: Long, nd: Long): List<LongArray> {\n    val kPrimes = (start..nd).filter { getPrimeFactors(it, k).size == k }.toList()\n    val pairs = mutableListOf<LongArray>()\n\n    outer@ for (i in kPrimes.indices) {\n        for (j in i + 1 until kPrimes.size) {\n            if (kPrimes[j] - kPrimes[i] == step.toLong()) {\n                pairs += longArrayOf(kPrimes[i], kPrimes[j])\n                continue@outer\n            }\n        }\n    }\n\n    return pairs\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208131,"user_id":1170,"body":"package kprimessteps\n\nimport kotlin.math.pow\nimport kotlin.math.sqrt\n\nval primesList = mutableListOf(2L)\n\nfun kprimesStep(k: Int, step: Int, start: Long, end: Long): List<LongArray> {\n    getPrimesTill(end)\n    val goodNumbers = mutableListOf<Long>()\n    val rStart = if (start < 3) 3 else start\n\n    (rStart..end).forEach { number ->\n        var currentNumber = number\n        var sumOfDividers = 0L\n\n        primesList.forEach { prime ->\n            val pow = getDividerPow(currentNumber, prime)\n            sumOfDividers += pow.toLong()\n            currentNumber \/= prime.toDouble().pow(pow).toLong()\n        }\n\n        if (currentNumber != 1L) sumOfDividers++\n        if (sumOfDividers == k.toLong()) goodNumbers.add(number)\n    }\n\n    return getResultByStep(goodNumbers, step)\n}\n\nfun getPrimesTill(end: Long) {\n    (3L..(sqrt(end.toDouble()).toLong())).forEach lit@{\n        primesList.forEach lit2@{ prime ->\n            if (it % prime == 0L) return@lit\n        }\n        primesList.add(it)\n    }\n}\n\nfun getDividerPow(currentNumber: Long, prime: Long): Double {\n    var pow = 1.0\n    while (currentNumber % (prime.toDouble().pow(pow).toLong()) == 0L) {\n        pow++\n    }\n    return pow - 1\n}\n\nfun getResultByStep(goodNumbers: List<Long>, step: Int): List<LongArray> {\n    val result = mutableListOf<LongArray>()\n    (0 until goodNumbers.size - 1).forEach {\n        if (goodNumbers.contains(goodNumbers[it] + step)) {\n            result.add(longArrayOf(goodNumbers[it], goodNumbers[it] + step))\n        }\n    }\n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208132,"user_id":null,"body":"package kprimessteps\n\nfun kprimesStep(k: Int, step: Int, start: Long, end: Long): List<LongArray> =\n    (start..end).asSequence()\n        .map { isKPrime(it, k) }\n        .windowed(step + 1).withIndex()\n        .filter { (_, p) -> p.first() && p.last() }\n        .map { it.index.toLong() + start }\n        .map { longArrayOf(it, it + step) }\n        .toList()\n\nfun isKPrime(num: Long, k: Int): Boolean {\n    if (num == 1L) return false\n    var (n, counter) = num to 0\n    val inc = arrayOf(4, 2, 4, 2, 4, 6, 2, 6)\n    for (ki in listOf(2, 3, 5)) {\n        while (n % ki == 0L) {\n            n \/= ki\n            if (++counter > k) return false\n        }\n    }\n    var (ki, i) = 7L to 0\n    while (ki * ki <= n) {\n        if (n % ki == 0L) { counter++; n \/= ki }\n        else { ki += inc[i++]; i %= 8 }\n        if (counter > k) return false\n    }\n    if (n > 1) counter++\n    return counter == k\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208133,"user_id":53,"body":"package kprimessteps\n\nfun kprimesStep(k:Int, step:Int, start:Long, nd:Long):List<LongArray> {\n    var arr : List<LongArray> = listOf()\n    var i = start;\n    while (i <= nd - step) {\n        if (primeFactorCount(i) == k.toLong() && primeFactorCount(i + step) == k.toLong()) {\n            arr += (longArrayOf(i, i + step));\n        }\n        i = i + 1;\n    }\n    return arr;\n}\n\nfun primeFactorCount(m:Long): Long {\n    var len = 0.toLong();\n    var n = m;\n    var i = 2.toLong();\n    while (i * i <= n) {\n        while (n % i == 0.toLong()) {\n            len = len + 1;\n            n = n \/ i;\n        }\n        i = i + 1;\n    }\n    if (n > 1) len = len + 1;\n    return len;\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208134,"user_id":null,"body":"package kprimessteps\n\nfun kprimesStep(k: Int, step: Int, start: Long, nd: Long): List<LongArray> {\n\n    val list = arrayListOf<LongArray>()\n    val allList = k.primes(nd, start)\n    allList.map { if (allList.contains(it + step)) list.add(longArrayOf(it.toLong(), (it + step).toLong())) }\n    return list\n}\n\nfun Int.k_prime(x: Int): Boolean {\n    var n = x\n    var f = 0\n    var p = 2\n    while (f < this && p * p <= n) {\n        while (0 == n % p) {\n            n \/= p; f++\n        }\n        p++\n    }\n    return f + (if (n > 1) 1 else 0) == this\n}\n\nfun Int.primes(n: Long, start: Long): List<Int> {\n    var i = start.toInt()\n    val list = mutableListOf<Int>()\n    while (i < n + 1) {\n        if (k_prime(i)) list.add(i)\n        i++\n    }\n    return list\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208135,"user_id":null,"body":"package kprimessteps\n\nfun main() {\n\n    kprimesStep(2, 10, 0, 50).forEach(::print)\n}\n\nfun kprimesStep(k: Int, step: Int, start: Long, nd: Long): List<LongArray> {\n\n    val list = arrayListOf<LongArray>()\n    val allList = k.primes(nd, start)\n    allList.map { if (allList.contains(it + step)) list.add(longArrayOf(it.toLong(), (it + step).toLong())) }\n    return list\n}\n\nfun Int.k_prime(x: Int): Boolean {\n    var n = x\n    var f = 0\n    var p = 2\n    while (f < this && p * p <= n) {\n        while (0 == n % p) {\n            n \/= p; f++\n        }\n        p++\n    }\n    return f + (if (n > 1) 1 else 0) == this\n}\n\nfun Int.primes(n: Long, start: Long): List<Int> {\n    var i = start.toInt()\n    val list = mutableListOf<Int>()\n    while (i < n + 1) {\n        if (k_prime(i)) list.add(i)\n        i++\n    }\n    return list\n}\n\n\/*********************** Best Practice *************************\/\n\nfun getFactors(number: Long): List<Long> {\n    for (i in 2..number) {\n        if (number % i == 0L) {\n            return listOf(i).plus(getFactors(number \/ i))\n        }\n    }\n    return emptyList()\n}\n\nfun kprimesStepp(k: Int, stp: Int, start: Long, end: Long): List<LongArray> {\n    var kFactorNumbers = (start..end)\n        .filter { getFactors(it).size == k }\n\n    val result = mutableListOf<LongArray>()\n    kFactorNumbers.forEach {\n        if (it + stp in kFactorNumbers) result.add(longArrayOf(it, it + stp))\n    }\n\n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5a50a20fd39ec527b2000011":[{"id":208136,"user_id":106,"body":"class TrickyKotlin6<T>{}\ninline fun <reified T, reified U> TrickyKotlin6<T>.classOrSuperClassOf(anyGetter: () -> U) = T::class.java.isAssignableFrom(U::class.java)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208137,"user_id":null,"body":"class TrickyKotlin6<T>\ninline fun <reified T,reified R> TrickyKotlin6<T>.classOrSuperClassOf(anyGetter: () -> R)\n        =T::class.java.isAssignableFrom(R::class.java)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208138,"user_id":null,"body":"import sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl\nimport java.lang.reflect.ParameterizedType\n\n\/**\n * Created by natsuki on 07\/01\/2018.\n *\/\n\nopen class TrickyKotlin6<S : Any> constructor(val name: String) {\n    open fun classOrSuperClassOf(fn: () -> Any) = false\n\n    companion object {\n        operator inline fun <reified S : Any> invoke(): TrickyKotlin6<S> = object : TrickyKotlin6<S>(\"foobar\") {\n            override fun classOrSuperClassOf(fn: () -> Any): Boolean {\n                val (a, b) = arrayOf(\n                        javaClass.genericSuperclass,\n                        fn.javaClass.genericInterfaces[0]\n                ).map {\n                    (it as ParameterizedType).actualTypeArguments[0].run {\n                        (this as? Class<*>) ?: ((this as ParameterizedTypeImpl).rawType as Class<*>)\n                    }\n                }\n                return a.isAssignableFrom(b)\n            }\n        }\n    }\n}\n\n\n\n\n\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208139,"user_id":null,"body":"import kotlin.reflect.KClass\nimport kotlin.reflect.full.isSubtypeOf\nimport kotlin.reflect.full.starProjectedType\nimport kotlin.reflect.jvm.reflect\n\nclass TrickyKotlin6<T : Any> private constructor(private val cl: KClass<*>) {\n    \n    companion object {\n    \n        internal inline operator fun <reified T : Any> invoke(): TrickyKotlin6<T> = TrickyKotlin6(T::class)\n    }\n\n    fun classOrSuperClassOf(anyGetter: () -> Any) = anyGetter.reflect()?.returnType?.isSubtypeOf(cl.starProjectedType) ?: false\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208140,"user_id":null,"body":"import kotlin.reflect.*\nimport kotlin.reflect.full.*\n\nclass TrickyKotlin6<V: Any>(val Tclass: KClass<V>) {\n    companion object {\n        inline operator fun <reified T: Any> invoke(): TrickyKotlin6<T> {\n            return TrickyKotlin6(T::class)\n        }\n    }\n    \n    inline fun <reified U> classOrSuperClassOf(anyGetter: () -> U): Boolean {\n            return Tclass in U::class.allSuperclasses || Tclass == U::class\n        }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208141,"user_id":null,"body":"import kotlin.reflect.KClass\n\nclass TrickyKotlin6<T: Any> constructor(val classOfT: KClass<out T>) {\n    companion object {\n        inline operator fun <reified T: Any> invoke() = TrickyKotlin6(T::class)\n    }\n    inline fun <reified U> classOrSuperClassOf(anyGetter: () -> U) = classOfT.java.isAssignableFrom(U::class.java)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208142,"user_id":null,"body":"import kotlin.reflect.KClass\nimport kotlin.reflect.full.isSubclassOf\nclass TrickyKotlin6<T : Any>(val checker: (retType: KClass<*>) -> Boolean) {\n    inline fun <reified R : Any> classOrSuperClassOf(anyGetter: () -> R) : Boolean {\n        return checker(R::class)\n    }\n\n    companion object {\n        inline operator fun <reified T : Any> invoke() : TrickyKotlin6<T> {\n            return TrickyKotlin6 {\n                it == T::class || it.isSubclassOf(T::class)\n            }\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208143,"user_id":null,"body":"class TrickyKotlin6<T : Any> constructor(val type: Class<T>) {\n    inline fun <reified R: Any> classOrSuperClassOf(anyGetter: () -> R): Boolean = type.isAssignableFrom(R::class.java)\n}\n\ninline fun <reified T : Any> TrickyKotlin6() = TrickyKotlin6(T::class.java)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208144,"user_id":null,"body":"inline fun <reified T> TrickyKotlin6() = TrickyKotlin6<Unit>(T::class.java)\n\nclass TrickyKotlin6 <_T> (c: Class<*>) {\n    val xC = c\n\tinline fun <reified R> classOrSuperClassOf(anyGetter: () -> R) = xC.isAssignableFrom(R::class.java)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208145,"user_id":null,"body":"import kotlin.reflect.full.isSubclassOf\n\nclass TrickyKotlin6<T>()\n\ninline fun <reified T, reified R> TrickyKotlin6<T>.classOrSuperClassOf(anyGetter: () -> R) = R::class.isSubclassOf(T::class)\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5a537ad4145c4615350000ff":[{"id":208146,"user_id":527,"body":"fun f(s:String)=s.map{\"()<>{}\".zip(\")(><}{\").toMap()[it]?:it}.joinToString(\"\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208147,"user_id":null,"body":"fun f(\u51b0:String)=\u51b0.fold(\"\"){\u597d,\u574f->\u597d+\"{)<>(}$\u574f\"[5-\"{)<>(}\".indexOf(\u574f)]}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208148,"user_id":106,"body":"fun f(s:String)=s.replace(Regex(\"[()><{}]\")){\")(<>}{\"[\"()><{}\".indexOf(it.value)]+\"\"}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208149,"user_id":null,"body":"fun f(s:String)=s.fold(\"\"){s,c->s+\"{)<>(}$c\"[5-\"{)<>(}\".indexOf(c)]}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208150,"user_id":527,"body":"fun f(s:String)=s.map{\"$it)(><}{\"[\"()<>{}\".indexOf(it)+1]}.joinToString(\"\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208151,"user_id":571,"body":"fun f(s:String)=s.fold(\"\"){a,b->a+(\"{})(<>\".zip(\"}{()><\").toMap()[b]?:b)}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208152,"user_id":490,"body":"fun f(s:String)=s.replace(Regex(\"[(){}<>]\")){\"${\")(}{><\"[\"(){}<>\".indexOf(it.value[0])]}\"}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208153,"user_id":null,"body":"fun f(s:String):String=s.replace(Regex(\"[{}<>()]\")){\"}{><)(\"[\"{}<>()\".indexOf(it.value)]+\"\"}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208154,"user_id":null,"body":"fun f(s:String)=s.fold(\"\"){a,c->a+\"$c()<>{}\".zip(\"$c)(><}{\").toMap()[c]}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208155,"user_id":null,"body":"fun f(s:String)=s.map{c->val l=\"<({})>\";if(c in l)l[5-l.indexOf(c)]else c}.joinToString(\"\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5a57faad880385f3b60000d0":[{"id":208156,"user_id":null,"body":"package kata\n\nimport java.awt.Point\n\nprivate fun Int.squared(): Int = this * this\n\nconst val TD_GRID_START_OF_PATH = '0'\nconst val TD_GRID_PATH = '1'\nval TD_GRID_TURRETS = 'A'..'Z'\n\nobject TD {\n    fun towerDefense(grid: Array<String>, turrets: Map<Char, Pair<Int, Int>>, aliens: IntArray): Int {\n        return TowerDefense(grid, turrets).attackResults(aliens)\n    }\n}\n\nclass TowerDefense(val turretTargets: Map<Char, List<Int>>, val turretFireRate: Map<Char, Int>) {\n\n    companion object {\n        operator fun invoke(grid: Array<String>, turrets: Map<Char, Pair<Int, Int>>): TowerDefense {\n            val gridJoined = grid.joinToString(separator = \"\")\n            val turretCoordinatesMap = TD_GRID_TURRETS.map { it to gridJoined.indexOf(it) }.filter { it.second >= 0 }\n                .associate { it.first to Point(it.second % grid.size, it.second \/ grid.size) }\n            val pathListOfPoints = mutableListOf<Int>().apply {\n                var pathIndex = gridJoined.indexOf(TD_GRID_START_OF_PATH)\n                while (pathIndex >= 0) {\n                    add(pathIndex)\n                    pathIndex = mutableListOf(pathIndex - grid.size, pathIndex + grid.size).apply {\n                        if (pathIndex % grid.size != 0) add(pathIndex - 1)\n                        if ((pathIndex + 1) % grid.size != 0) add(pathIndex + 1)\n                    }.filter { it in gridJoined.indices }.filter { gridJoined[it] == TD_GRID_PATH }\n                        .firstOrNull { it !in this } ?: -1\n                }\n            }.map { Point(it % grid.size, it \/ grid.size) }\n            return TowerDefense(\n                turretTargets = turretCoordinatesMap.keys.associateWith { mutableListOf<Int>() }.apply {\n                    pathListOfPoints.forEachIndexed { pathIndex, pathPoint ->\n                        turretCoordinatesMap.filter { it.value.distanceSq(pathPoint) <= turrets[it.key]!!.first.squared() }\n                            .forEach { this[it.key]!!.add(pathIndex) }\n                    }\n                },\n                turretFireRate = turrets.mapValues { it.value.second }\n            )\n        }\n    }\n\n    fun attackResults(aliens: IntArray): Int {\n        val pathLength = turretTargets.values.flatten().max()?:0\n        val maxNumberOfShots = turretFireRate.values.max()?:0\n        for (timeTick in 0 until pathLength + aliens.size) {\n            for (shot in 1..maxNumberOfShots) {\n                for (turretFiring in turretFireRate.filterValues { it >= shot }.keys.sorted()) {\n                    turretTargets[turretFiring]!!.map { pathIndex -> timeTick - pathIndex }\n                        .filter { it in aliens.indices }.filter { aliens[it] > 0 }\n                        .run { if (this.isNotEmpty()) --aliens[this.last()] }\n                }\n            }\n        }\n        return aliens.sum()\n    }\n\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208157,"user_id":null,"body":"package kata\n\nimport kotlin.math.ceil\nimport kotlin.math.hypot\n\ndata class Point(val x: Int, val y: Int) {\n    fun distanceTo(other: Point): Int = ceil(hypot(x - other.x.toDouble(), y - other.y.toDouble())).toInt()\n}\n\ndata class Alien(var positionIndex: Int, var health: Int)\n\ndata class Turret(val position: Point, val range: Int, val maxShots: Int, var shotsLeft: Int = maxShots) {\n    fun reset() {\n        shotsLeft = maxShots\n    }\n}\n\nfun findPoint(grid: Array<String>, char: Char): Point {\n    for (y in grid.indices) {\n        val row = grid[y]\n        for (x in row.indices) {\n            if (row[x] == char)\n                return Point(x, y)\n        }\n    }\n\n    error(\"Point not found\")\n}\n\nfun createPath(grid: Array<String>): List<Point> {\n    val path = mutableListOf<Point>()\n    path.add(findPoint(grid, '0'))\n\n\n    fun Point.withOffset(dx: Int, dy: Int): Point? {\n        val newX = x + dx\n        val newY = y + dy\n        return if (newX in 0 until grid[0].length && newY in grid.indices && grid[newY][newX] == '1')\n            Point(x + dx, y + dy)\n        else null\n    }\n\n    val offsets = listOf(1, 0, 0, 1, -1, 0, 0, -1)\n    var previous: Point? = null\n\n    outer@ while (true) {\n        for (i in 0 until 4) {\n            val last = path.last()\n            val candidate = last.withOffset(offsets[i * 2], offsets[i * 2 + 1])\n            if (candidate != null && candidate != previous) {\n                path.add(candidate)\n                previous = last\n                continue@outer\n            }\n        }\n\n        break\n    }\n\n    return path\n}\n\nprivate fun createAliens(alienData: IntArray) = alienData\n    .mapIndexed { index, health -> if (health > 0) Alien(-index - 1, health) else null }\n    .filterNotNull()\n\nfun createTurrets(grid: Array<String>, data: Map<Char, Pair<Int, Int>>): List<Turret> = data\n    .toSortedMap()\n    .map { Turret(findPoint(grid, it.key), it.value.first, it.value.second) }\n\nfun getFurthestAlien(turret: Turret, aliens: Collection<Alien>, path: List<Point>): Alien? {\n    for (alien in aliens) {\n        if (alien.health <= 0)\n            continue\n\n        val alienPos = if (alien.positionIndex in path.indices) path[alien.positionIndex] else continue\n        val distance = turret.position.distanceTo(alienPos)\n\n        if (distance <= turret.range)\n            return alien\n    }\n\n    return null\n}\n\nobject TD {\n    fun towerDefense(grid: Array<String>, turretData: Map<Char, Pair<Int, Int>>, alienData: IntArray): Int {\n        val path = createPath(grid)\n        val aliens = createAliens(alienData)\n        val turrets = createTurrets(grid, turretData)\n        val totalShots = turrets.map { it.maxShots }.sum()\n\n        while (true) {\n            turrets.forEach { it.reset() }\n            aliens.forEach { it.positionIndex++ }\n\n            var nextTurret = 0\n            val shootingTurrets = turrets.toMutableList()\n\n            for (i in 0 until totalShots) {\n                val turret = shootingTurrets[nextTurret]\n\n                if (--turret.shotsLeft == 0)\n                    shootingTurrets.remove(turret)\n                else\n                    nextTurret++\n\n                if (shootingTurrets.isNotEmpty())\n                    nextTurret %= shootingTurrets.size\n\n                val alien = getFurthestAlien(turret, aliens, path) ?: continue\n                alien.health--\n            }\n\n            if (aliens.last().positionIndex >= path.size)\n                break\n        }\n\n        return aliens.map { it.health }.sum()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208158,"user_id":null,"body":"package kata\n\nimport kotlin.math.pow\nimport kotlin.math.sqrt\n\nobject TD {\n\n    fun towerDefense(grid: Array<String>, turrets: Map<Char, Pair<Int, Int>>, aliens: IntArray): Int {\n        val gridMap = gridMap(grid)\n        val keyPoints = gridMap.entries.associateBy({ it.value }) { it.key }.filter { it.key !in listOf('1', ' ') }\n        val sortedTurrets = generateTurrets(keyPoints, turrets)\n        val pathPositions = gridMap.filterValues { it == '1' }.keys\n\n        val entryPoint = keyPoints['0'] ?: error(\"No entry point found for the aliens. It's a trap!!\")\n        val path: List<Point> = calculatePath(entryPoint, pathPositions)\n\n        val alienArmy = aliens.mapIndexed { index, health -> Alien(health, alienTransporter(path, index)) }\n\n        val maxTurretShots = sortedTurrets.map { it.shots }.max() ?: 0\n        val maxTurns = path.size + aliens.size - 2\n        for (turn in 0..maxTurns) {\n            alienArmy.forEach { it.deploy(turn) }\n\n            for (shot in 1..maxTurretShots) {\n                for (turret in sortedTurrets) {\n                    if (turret.shots >= shot) {\n                        val maybeAlien = alienArmy.firstOrNull { it.isAlive() && turret.isInFireRange(it) }\n                        maybeAlien?.damage()\n                    }\n                }\n            }\n        }\n        return alienArmy.map { it.health }.sum()\n    }\n\n    internal fun alienTransporter(path: List<Point>, initialPosition: Int): (Int) -> Point? {\n        return { turn -> path.getOrNull(turn - initialPosition) }\n    }\n\n    private fun generateTurrets(\n        keyPoints: Map<Char, Point>,\n        turrets: Map<Char, Pair<Int, Int>>\n    ): List<Turret> {\n        val turretPositionsByName = keyPoints.filterKeys { it.isLetter() }.toSortedMap()\n        return turretPositionsByName.map { (turretName, turretPosition) ->\n            val (range, frequency) = turrets[turretName] ?: error(\"There's no turret named $turretName\")\n            Turret(turretPosition, range, frequency)\n        }\n    }\n\n    private fun calculatePath(entryPoint: Point, pathPoints: Set<Point>): List<Point> {\n        val path = mutableListOf(entryPoint)\n        val unassignedPathPoints = pathPoints.toMutableSet()\n        while (unassignedPathPoints.isNotEmpty()) {\n            val last = path.last()\n            val next = last.neighbours().first { unassignedPathPoints.remove(it) }\n            path.add(next)\n        }\n        return path\n    }\n\n    private fun gridMap(grid: Array<String>): Map<Point, Char> {\n        val gridMap = mutableMapOf<Point, Char>()\n        for ((y, row) in grid.withIndex()) {\n            for ((x, cellValue) in row.withIndex()) {\n                gridMap[Point(x, y)] = cellValue\n            }\n        }\n        return gridMap\n    }\n\n    private class Alien(\n        var health: Int,\n        private val positionCalculator: (turns: Int) -> Point?\n    ) {\n\n        private var turn: Int = 0\n\n        val position: Point?\n            get() = positionCalculator(turn)\n\n        fun isAlive() = health > 0\n\n        fun damage() {\n            health--\n        }\n\n        fun deploy(turn: Int) {\n            this.turn = turn\n        }\n    }\n\n    private data class Turret(private val position: Point, private val range: Int, val shots: Int) {\n\n        fun isInFireRange(alien: Alien): Boolean {\n            val alienPosition = alien.position ?: return false\n\n            val triangleLeg1 = (alienPosition.x - position.x).toDouble()\n            val triangleLeg2 = (alienPosition.y - position.y).toDouble()\n            val distance = sqrt(triangleLeg1.pow(2) + triangleLeg2.pow(2))\n            return distance <= range\n        }\n    }\n\n    internal data class Point(val x: Int, val y: Int) {\n\n        fun neighbours(): Set<Point> {\n            return setOf(Point(x - 1, y), Point(x + 1, y), Point(x, y - 1), Point(x, y + 1))\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208159,"user_id":null,"body":"package kata\n\nimport java.util.*\nimport kotlin.math.pow\nimport kotlin.test.assertEquals\n\ntypealias Road = LinkedList<Place>\ntypealias RoadNextStep = Map<Place, Place?>\ntypealias AlienLive = Int\n\ndata class Place(var x: Int = 0, var y: Int = 0) {\n    fun distance(place: Place): Double =\n        ((place.x - x).toDouble().pow(2.0) + (place.y - y).toDouble().pow(2.0)).pow(0.5)\n}\n\nclass Alien(var live: AlienLive, var place: Place? = Place()) {\n    private var code = 0\n\n    fun setCodeV(code: Int) {\n        this.code = code\n    }\n}\n\nclass Aliens(private val worldMap: WorldMap) {\n    private var alienCode = 1\n    var items = mutableListOf<Alien>()\n    private var accLives = 0\n    private var aliveDebug = mutableListOf<Alien>()\n\n    fun getAccLives() = accLives\n\n    fun addNew(alien: Alien?) {\n        shift()\n\n        if (items.lastOrNull() !== null && items.lastOrNull()?.place == null) {\n            items.removeAt(items.lastIndex).also { aliveDebug.add(it) }.also { accLives += it.live }\n        }\n\n        alien?.let {\n            items.add(0, it)\n            it.setCodeV(alienCode++)\n        }\n\n        worldMap.guns.addDamage(this)\n\n        items.removeIf { it.live <= 0 }\n    }\n\n    private fun shift() = items.forEach { it.place = worldMap.roadNextStep.getOrDefault(it.place, null) }\n}\n\nclass Game(private val worldMap: WorldMap) {\n    private val aliens = Aliens(worldMap)\n    private fun nextStep(d: AlienLive) {\n        val alien = if (d == 0) null else Alien(d, worldMap.startPlace)\n        aliens.addNew(alien)\n    }\n\n    fun play(aliensAr: IntArray): Int {\n        aliensAr.forEach { nextStep(it) }\n        while (aliens.items.isNotEmpty()) aliens.addNew(null)\n        return aliens.getAccLives()\n    }\n}\n\ndata class Gun(var range: Int, var damage: Int, val place: Place, val code: String)\n\nclass Guns(private val items: List<Gun>) {\n\n    fun addDamage(aliens: Aliens) {\n        val itemsClone = items.map { it.copy() }.toMutableList()\n        itemsClone.sortBy { it.code }\n\n        do {\n            var d = false\n            itemsClone.filter { it.damage > 0 }.forEach { g ->\n                aliens.items.findLast { it.live > 0 && g.place.distance(it.place!!) <= g.range.toDouble() }?.let {\n                    it.live--\n                    g.damage--\n                    d = true\n                }\n            }\n\n        } while (d)\n    }\n}\n\nfun getCharOfWorld(grid: Array<String>, place: Place): Char? = grid.getOrNull(place.y)?.getOrNull(place.x)\n\nclass WorldMap(grid: Array<String>, turrets: Map<Char, Pair<Int, Int>>) {\n\n    val guns: Guns\n    val roadNextStep: RoadNextStep\n    val startPlace: Place\n\n    init {\n        val gunsTemp = mutableListOf<Gun>()\n        var startPlaceTemp = Place()\n        grid.forEachIndexed { y, row ->\n            row.forEachIndexed { x, v ->\n                when (v) {\n                    '0' -> startPlaceTemp = Place(x, y)\n                    in ('A'..'Z') -> gunsTemp.add(\n                        Gun(\n                            turrets[v]!!.first,\n                            turrets[v]!!.second,\n                            Place(x, y),\n                            v.toString()\n                        )\n                    )\n                }\n            }\n        }\n\n        startPlace = startPlaceTemp\n        guns = Guns(gunsTemp.toList())\n\n        val fRoundStep = { place: Place ->\n            listOf<Place>(\n                Place(place.x, place.y - 1),\n                Place(place.x - 1, place.y),\n                Place(place.x + 1, place.y),\n                Place(place.x, place.y + 1)\n            )\n        }\n\n        val fGetNext = { road: Road ->\n            val last = road.getOrNull(road.lastIndex - 1)\n            val current = road.last()\n            var round = fRoundStep(current)\n            if (last != null) round -= last\n            round.map { it to getCharOfWorld(grid, it) }.filter { it.second == '1' }.firstOrNull()?.first\n        }\n\n        val road = Road()\n        var end = false\n        road.add(startPlace)\n        while (!end) {\n            val next = fGetNext(road)\n            if (next is Place) {\n                road.add(next)\n            } else {\n                end = true\n            }\n        }\n\n        roadNextStep = road.windowed(2, 1).map { it.first() to it.last() }.toMap()\n    }\n}\n\nobject TD {\n    fun towerDefense(grid: Array<String>, turrets: Map<Char, Pair<Int, Int>>, aliens: IntArray): Int {\n        return Game(WorldMap(grid, turrets)).play(aliens)\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208160,"user_id":null,"body":"package kata\n\nobject TD {\n    fun towerDefense(grid: Array<String>,\n                     turrets: Map<Char,Pair<Int,Int>>,\n                     aliens: IntArray): Int {\n        val td = TurretDefence(grid, turrets, aliens)\n\n        while (td.takeTurn()) {\n            println(\"Pew Pew\")\n        }\n\n        return td.totalHealth\n    }\n\n    data class Position(val x: Int, val y: Int) {\n        companion object {\n            fun findUnique(grid: List<CharArray>, target: Char): Position {\n                val y = grid.indexOfFirst { it.contains(target) }\n                val x = grid[y].indexOf(target)\n                return Position(x, y)\n            }\n        }\n    }\n\n    class TurretDefence(grid: Array<String>, turretData: Map<Char, Pair<Int, Int>>, alienData: IntArray) {\n        private val turrets: List<Turret>\n        private val path: Path\n        val aliens: List<Alien>\n        private var turn = 0\n\n        val totalHealth get() = aliens.sumBy { it.health }\n\n        init {\n            val split = grid.map{ it.toCharArray() }\n            turrets = generateTurrets(split, turretData)\n            path = Path(split)\n            aliens = alienData.map { Alien(it) }\n        }\n\n        private fun generateTurrets(grid: List<CharArray>, turretData: Map<Char, Pair<Int, Int>>) = turretData.map { entry ->\n            val position = TD.Position.findUnique(grid, entry.key)\n            Turret(entry.key, position, entry.value.first, entry.value.second)\n        }.sortedBy { it.name }\n\n        fun takeTurn(): Boolean {\n            if (turn == path.size + aliens.size) {\n                return false\n            }\n\n            val pathedAliens = ArrayList<Pair<Alien, Position>>()\n            for (i in 0 until turn) {\n                if (turn - i > path.size || i >= aliens.size) {\n                    continue\n                }\n\n                pathedAliens.add(Pair(aliens[i], path[turn - i - 1]))\n            }\n\n            var shotIndex = 0\n            var hasShot = true\n            while (hasShot) {\n                hasShot = false\n\n                turrets.forEach {\n                    hasShot = it.shoot(pathedAliens, shotIndex) || hasShot\n                }\n\n                shotIndex += 1\n            }\n\n            turn += 1\n            return true\n        }\n    }\n\n    class Turret(\n        val name: Char,\n        val position: Position,\n        range: Int,\n        val shots: Int) {\n        private val range = range * range\n        private val canHit = HashMap<Position, Boolean>()\n\n        fun shoot(pathedAliens: List<Pair<Alien, Position>>, shotIndex: Int): Boolean {\n            if (shotIndex >= shots) {\n                return false\n            }\n\n            for (entry in pathedAliens) {\n                val alien = entry.first\n                val position = entry.second\n\n                if (alien.health <= 0) {\n                    continue\n                }\n\n                if (canShoot(position)) {\n                    alien.health -= 1\n                    return true\n                }\n            }\n\n            return false\n        }\n\n        private fun canShoot(other: Position): Boolean {\n            val cached = canHit[other]\n            if (cached != null) {\n                return cached\n            }\n            \n            val xDiff = position.x - other.x\n            val yDiff = position.y - other.y\n            val hit = xDiff * xDiff + yDiff * yDiff <= range\n            canHit[other] = hit\n            return hit\n        }\n    }\n\n    class Alien(var health: Int)\n\n    class Path(grid: List<CharArray>) {\n        private val positions = ArrayList<Position>()\n\n        operator fun get(index: Int) = positions[index]\n        val size get() = positions.size\n\n        init {\n            positions.add(TD.Position.findUnique(grid, '0'))\n\n            var next = findNext(grid)\n            while (next != null) {\n                positions.add(next)\n                next = findNext(grid)\n            }\n        }\n\n        private fun findNext(grid: List<CharArray>): Position? {\n            fun safeGet(x: Int, y: Int) = when {\n                x < 0 || x >= grid[0].size || y < 0 || y >= grid.size -> null\n                grid[y][x] == '1' -> Position(x, y)\n                else -> null\n            }\n\n            val current = positions.last()\n            val possibilities = arrayOf(\n                safeGet(current.x, current.y - 1),\n                safeGet(current.x, current.y + 1),\n                safeGet(current.x + 1, current.y),\n                safeGet(current.x - 1, current.y)\n            )\n\n            return if (positions.size > 1) {\n                val previous = positions[positions.size - 2]\n                possibilities.firstOrNull {\n                    it != null && it != previous\n                }\n            } else {\n                possibilities.firstOrNull { it != null }\n            }\n        }\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208161,"user_id":470,"body":"package kata\n\nobject TD {\n\tfun towerDefense(grid: Array<String>,tmap: Map<Char,Pair<Int,Int>>,aliens: IntArray): Int {\n\t\tval roster = aliens.toMutableList()\n\t\tval pathList = findPath(grid)\n\t\tval pathLen = pathList.size\n\t\tval towerPosList = locateTowers(grid)\n\t\tval towerIDs = ('A'..'Z').filterIndexed { i,_ -> towerPosList[i] != null }\n\t\t\/\/ val maxShots = tmap.values.maxOfOrNull { it.second }\/\/ Kotlin 1.4\n\t\tval maxShots = tmap.values.map { it.second }.max()!!\n\t\tvar sumHP = roster.sum()\n\t\tvar fst = 0\n\t\t\n\t\tval towerPathMap: Map<Char,IntArray> = ('A'..'Z').zip(towerPosList)\n\t\t.filter { it.second != null }\n\t\t.map { it.first to (0..pathLen).zip(pathList).filter { (_,xy) -> inRange(xy,it.second!!,tmap.get(it.first)!!.first) }.map { (i,_) -> i }.asReversed().toIntArray() }\n\t\t.toMap()\n\t\t\n\t\t(0 until roster.size + pathLen).forEach {\n\t\t\twhile (roster[fst] == 0) fst++\n\t\t\tval occupiedCells = (fst..Math.min(it,roster.size-1)).filter { q -> roster[q] > 0 }.map { q -> it - q }\n\t\t\tval towersInRange = towerIDs.filter { ch -> towerPathMap[ch]!!.any { n -> occupiedCells.contains(n) } }\n\t\t\t\n\t\t\tfor (i in 1..maxShots){\n\t\t\t\tfor (tower in towersInRange){\n\t\t\t\t\tif (tmap[tower]!!.second >= i){\n\t\t\t\t\t\tfor (n in towerPathMap[tower]!!){\n\t\t\t\t\t\t\tif (occupiedCells.contains(n) && roster[it-n] > 0){\n\t\t\t\t\t\t\t\troster[it-n]--\n\t\t\t\t\t\t\t\tsumHP--\n\t\t\t\t\t\t\t\tbreak } } } } }\n\t\t\tif (sumHP < 1) return 0\n\t\t}\n\t\t\n\t\treturn sumHP\n\t}\n\t\n\tprivate fun findPath(grid: Array<String>): List<Pair<Int,Int>> {\n\t\tval path = mutableListOf<Pair<Int,Int>>()\n\t\tval steps = mutableSetOf<Pair<Int,Int>>()\n\t\tvar p0: Pair<Int,Int> = -1 to -1\n\t\t\n\t\tgrid.forEachIndexed { i,row ->\n\t\t\trow.forEachIndexed { j,cel ->\n\t\t\t\twhen (cel){\n\t\t\t\t\t'1' -> steps.add(i to j)\n\t\t\t\t\t'0' -> p0 = i to j\n\t\t\t\t\telse -> Unit } } }\n\t\t\n\t\tvar (x,y) = p0\n\t\tpath.add(p0)\n\t\twhile (steps.size > 0){\n\t\t\tfor ((dx,dy) in arrayOf(0 to 1,0 to -1,1 to 0,-1 to 0)){\n\t\t\t\tval nxy = Pair(x+dx,y+dy)\n\t\t\t\tif (steps.contains(nxy)){\n\t\t\t\t\tpath.add(nxy)\n\t\t\t\t\tsteps.remove(nxy)\n\t\t\t\t\tx = nxy.first\n\t\t\t\t\ty = nxy.second\n\t\t\t\t\tbreak } } }\n\t\t\n\t\treturn path.toList()\n\t}\n\t\n\tprivate fun locateTowers(grid: Array<String>): List<Pair<Int,Int>?> = grid.foldIndexed(MutableList<Pair<Int,Int>?>(26,{ null })) { i,ix,row -> row.forEachIndexed { j,cel -> if (cel in 'A'..'Z') ix[cel.toInt()-65] = i to j }; ix }\n\t\n\tprivate fun inRange(p1:Pair<Int,Int>,p2:Pair<Int,Int>,d:Int): Boolean {\n\t\tval x = Math.abs(p1.first - p2.first)\n\t\tval y = Math.abs(p1.second - p2.second)\n\t\treturn if (x == 0 || y == 0) x + y <= d else x*x + y*y <= d*d\n\t}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5a5db0f580eba84589000979":[{"id":208162,"user_id":179,"body":"package kata\n\nobject PNZ {\n\n    fun plantsAndZombies(lawn:Array<String>,zombies:Array<IntArray>): Int? {\n\n        val width = lawn.first().length + 1 \/\/ Add an extra column for zombies which is protected\n        val height = lawn.size\n\n        val field = Field(width, height)\n        (0 until width -1).forEach { x ->\n            (0 until height).forEach { y ->\n                val c = lawn[y][x]\n                when {\n                    c == 'S' -> field.set(x to y, SShooter())\n                    c != ' ' -> field.set(x to y, NShooter(c  - '0'))\n                }\n            }\n        }\n        zombies.forEach {\n            val i = it[0]\n            val row = it[1]\n            val hp = it[2]\n            val pos = (width - 1) to row \/\/ Put zombies in the safe area\n            field.set(pos, Zombie(i, hp))\n        }\n\n        val model = Model(field)\n        while (!model.checkEndCondition()) {\n            model.doMove()\n        }\n        return when {\n            model.zombiesWin() -> model.move\n            model.plantsWin() -> null\n            else -> error(\"Illegal State!\")\n        }\n    }\n\n    class Model(private val field: Field) {\n\n        var move = 0\n\n        fun doMove() {\n            field.mapNotNull { it.instance<Zombie>() }.forEach { it.doAction() }\n            field.mapNotNull { it.instance<NShooter>() }.forEach { it.doAction() }\n            field.mapNotNull { it.instance<SShooter>() }.forEach { it.doAction() }\n            ++move\n        }\n\n        fun checkEndCondition() = plantsWin() || zombiesWin()\n\n        fun plantsWin(): Boolean {\n            field.mapNotNull { it.instance<Zombie>() }.forEach { _ ->\n                return false\n            }\n            return true\n        }\n\n        fun zombiesWin(): Boolean {\n            (0 until field.height).forEach { y ->\n                field.getAll(0 to y).mapNotNull { it.instance<Zombie>() }.forEach { _ ->\n                    return true\n                }\n            }\n            return false\n        }\n    }\n\n    class SShooter(): Plant() {\n\n        private val dirs = listOf(1 to 0, 1 to 1, 1 to -1)\n\n        override fun doAction() {\n            dirs.forEach { shoot(it) }\n        }\n    }\n\n    class NShooter(val n: Int): Plant() {\n\n        override fun doAction() {\n            (0 until n).forEach { _ -> shoot(1 to 0) }\n        }\n    }\n\n    abstract class Plant: Character() {\n\n        fun shoot(dir: Pair<Int, Int>) {\n            val field = field ?: error(\"Illegal State!\")\n            var curr = pos?.move(dir) ?: error(\"Illegal State!\")\n            while (field.inBounds(curr)) {\n                field.getAll(curr).mapNotNull { it.instance<Zombie>() }.firstOrNull()?.let {\n                    it.doDamage()\n                    return\n                }\n                curr = curr.move(dir)\n            }\n        }\n\n        override fun doDamage() {\n            val field = field ?: error(\"Illegal State!\")\n            field.remove(this)\n        }\n    }\n\n    class Zombie(var i: Int, var hp: Int): Character() {\n\n        override fun doAction() {\n            val pos = pos ?: error(\"Illegal State!\")\n            val field = field ?: error(\"Illegal State!\")\n            if (i > 0) {\n                --i\n            }\n            else { \/\/ zombie leaves the safe area when i == 0\n                val newPos = pos.move(-1 to 0)\n                field.getAll(newPos).mapNotNull { it.instance<Plant>() }.forEach{ it.doDamage() }\n                field.set(newPos, this)\n            }\n        }\n\n        override fun doDamage() {\n            val field = field ?: error(\"Illegal State!\")\n            val pos = pos ?: error(\"Illegal State!\")\n            if (pos.first != field.width - 1) --hp \/\/ Zombie can only loose hp when it leaves the safe area\n            if (hp == 0) field.remove(this)\n        }\n    }\n\n    abstract class Character {\n\n        var field: Field? = null\n        var pos: Pair<Int, Int>? = null\n\n        abstract fun doAction()\n        abstract fun doDamage()\n    }\n\n    class Field(val width: Int, val height: Int): Iterable<Character> {\n\n        private val field: Array<Array<MutableList<Character>>> = (0 until width).map { (0 until height).map { mutableListOf<Character>() }.toTypedArray() }.toTypedArray()\n\n        fun inBounds(pos: Pair<Int, Int>) = when {\n            pos.first < 0 -> false\n            pos.first >= width -> false\n            pos.second < 0 -> false\n            pos.second >= height -> false\n            else -> true\n        }\n\n        fun set(pos: Pair<Int, Int>, character: Character) {\n            remove(character)\n            field[pos.first][pos.second].add(character)\n            character.pos = pos\n            character.field = this\n        }\n\n        fun getAll(pos: Pair<Int, Int>) = field[pos.first][pos.second].toList()\n\n        fun remove(character: Character) {\n            character.pos?.let { remove(it, character) }\n        }\n\n        private fun remove(pos: Pair<Int, Int>, character: Character) {\n            field[pos.first][pos.second].remove(character)\n        }\n\n        override fun iterator(): Iterator<Character> {\n            val l = mutableListOf<Character>()\n            (width -1 downTo 0).forEach { x ->\n                (0 until height).forEach { y ->\n                    l.addAll(field[x][y])\n                }\n            }\n            return l.iterator()\n        }\n    }\n\n    inline fun <reified T : Any> Any.instance(): T? = if (this is T) this else  null\n\n    fun Pair<Int, Int>.move(v: Pair<Int, Int>) = (this.first + v.first) to (this.second + v.second)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208163,"user_id":null,"body":"package kata\n\nenum class GameObjectType {\n    ZOMBIE, NUMBER_SHOOTER, S_SHOOTER\n}\n\ndata class GameObject(val x: Int, val y: Int, val type: GameObjectType, var hp: Int)\n\nclass Game(private val lawn: Array<String>, private val zombies: Array<IntArray>) {\n\n    private var curStep = 0\n    private var height = 0\n    private var width = 0\n    private var zombieNum = 0\n    private val shooterMap = mutableMapOf<Pair<Int, Int>, GameObject>()\n    private val zombieMap = mutableMapOf<Pair<Int, Int>, GameObject>()\n\n    init {\n        height = lawn.size\n        width = lawn[0].length\n        zombieNum = zombies.size\n\n        for (i in 0 until height) {\n            for (j in 0 until width) {\n                when (lawn[i][j]) {\n                    'S' -> shooterMap[Pair(i, j)] = GameObject(i, j, GameObjectType.S_SHOOTER, 1)\n                    ' ' -> continue\n                    else -> shooterMap[Pair(i, j)] = GameObject(i, j, GameObjectType.NUMBER_SHOOTER, lawn[i][j].toString().toInt())\n                }\n            }\n        }\n\n    }\n\n\n    private fun shooterGetTargets(shooter: GameObject): List<GameObject> {\n        val targets = mutableListOf<GameObject>()\n        if (shooter.type == GameObjectType.NUMBER_SHOOTER) {\n\n            val targetSameRow =\n                zombieMap.values.filter { it.y > shooter.y && it.x == shooter.x && it.type == GameObjectType.ZOMBIE }\n                    .sortedBy { it.y }.getOrNull(0)\n            if (targetSameRow != null) targets.add(targetSameRow)\n            return targets\n        } else if (shooter.type == GameObjectType.S_SHOOTER) {\n\n            val targetSameRow =\n                zombieMap.values.filter { it.y > shooter.y && it.x == shooter.x && it.type == GameObjectType.ZOMBIE }\n                    .sortedBy { it.y }.getOrNull(0)\n            val targetSameMainDiag =\n                zombieMap.values.filter { it.y > shooter.y && it.x + it.y == shooter.x + shooter.y && it.type == GameObjectType.ZOMBIE }\n                    .sortedBy { it.y }.getOrNull(0)\n            val targetSameSubDiag =\n                zombieMap.values.filter { it.y > shooter.y && it.y - it.x == shooter.y - shooter.x && it.type == GameObjectType.ZOMBIE }\n                    .sortedBy { it.y }.getOrNull(0)\n            if (targetSameRow != null) targets.add(targetSameRow)\n            if (targetSameMainDiag != null) targets.add(targetSameMainDiag)\n            if (targetSameSubDiag != null) targets.add(targetSameSubDiag)\n\n            return targets\n        } else {\n            return listOf()\n        }\n    }\n\n    private fun shooterAttack(shooter: GameObject) {\n        val targets = shooterGetTargets(shooter)\n\n        for (target in targets) {\n            target.hp -= 1\n            if (target.hp <= 0) {\n                zombieMap.remove(Pair(target.x, target.y))\n                zombieNum -= 1\n            }\n        }\n\n    }\n\n    private fun zombieMoveAndAttack(zombie: GameObject): Boolean {\n        val targetY = zombie.y - 1\n        if (targetY < 0) {\n            return true\n        }\n\n        zombieMap[Pair(zombie.x, targetY)] = GameObject(zombie.x, targetY, GameObjectType.ZOMBIE, zombie.hp)\n        shooterMap.remove(Pair(zombie.x, targetY))\n        zombieMap.remove(Pair(zombie.x, zombie.y))\n\n        return false\n    }\n\n    fun step(): Int? {\n\n        while (zombieNum > 0) {\n\n            \/\/ Current zombies move\n            for (zombie in zombieMap.values.filter { it.type == GameObjectType.ZOMBIE }) {\n                if (zombieMoveAndAttack(zombie)) return curStep\n            }\n\n            \/\/ Then new zombies appear\n            for (newZombie in zombies.filter { it[0] == curStep }) {\n                zombieMap[Pair(newZombie[1], width - 1)] =\n                    GameObject(newZombie[1], width - 1, GameObjectType.ZOMBIE, newZombie[2])\n            }\n\n            \/\/ Then numbered shooters attack\n            for (time in 1..9) {\n                for (numberedShooter in shooterMap.values.filter { it.type == GameObjectType.NUMBER_SHOOTER && it.hp >= time }\n                    .sortedByDescending { it.y }) {\n                    shooterAttack(numberedShooter)\n                }\n            }\n\n            \/\/ Then S-shooters attack\n            for (sShooter in shooterMap.values.filter { it.type == GameObjectType.S_SHOOTER }\n                .sortedWith(compareBy({ -it.y }, { it.x }))) {\n                shooterAttack(sShooter)\n            }\n\n            curStep += 1\n\n        }\n        return null\n    }\n}\n\nobject PNZ {\n    fun plantsAndZombies(lawn: Array<String>, zombies: Array<IntArray>): Int? {\n        val game = Game(lawn, zombies)\n        return game.step()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208164,"user_id":null,"body":"package kata\n\nenum class GameObjectType {\n    ZOMBIE, NUMBER_SHOOTER, S_SHOOTER\n}\n\ndata class GameObject(val x: Int, val y: Int, val type: GameObjectType, var hp: Int)\n\nclass Game(private val lawn: Array<String>, private val zombies: Array<IntArray>) {\n\n    private var curStep = 0\n    private var height = 0\n    private var width = 0\n    private var zombieNum = 0\n    private val gameMap = mutableMapOf<Pair<Int, Int>, GameObject>()\n\n    init {\n        height = lawn.size\n        width = lawn[0].length\n        zombieNum = zombies.size\n\n        for (i in 0 until height) {\n            for (j in 0 until width) {\n                when (lawn[i][j]) {\n                    'S' -> gameMap[Pair(i, j)] = GameObject(i, j, GameObjectType.S_SHOOTER, 1)\n                    ' ' -> continue\n                    else -> gameMap[Pair(i, j)] = GameObject(i, j, GameObjectType.NUMBER_SHOOTER, lawn[i][j].toString().toInt())\n                }\n            }\n        }\n\n    }\n\n\n    private fun shooterGetTargets(shooter: GameObject): List<GameObject> {\n        val targets = mutableListOf<GameObject>()\n        if (shooter.type == GameObjectType.NUMBER_SHOOTER) {\n\n            val targetSameRow =\n                gameMap.values.filter { it.y > shooter.y && it.x == shooter.x && it.type == GameObjectType.ZOMBIE }\n                    .sortedBy { it.y }.getOrNull(0)\n            if (targetSameRow != null) targets.add(targetSameRow)\n            return targets\n        } else if (shooter.type == GameObjectType.S_SHOOTER) {\n\n            val targetSameRow =\n                gameMap.values.filter { it.y > shooter.y && it.x == shooter.x && it.type == GameObjectType.ZOMBIE }\n                    .sortedBy { it.y }.getOrNull(0)\n            val targetSameMainDiag =\n                gameMap.values.filter { it.y > shooter.y && it.x + it.y == shooter.x + shooter.y && it.type == GameObjectType.ZOMBIE }\n                    .sortedBy { it.y }.getOrNull(0)\n            val targetSameSubDiag =\n                gameMap.values.filter { it.y > shooter.y && it.y - it.x == shooter.y - shooter.x && it.type == GameObjectType.ZOMBIE }\n                    .sortedBy { it.y }.getOrNull(0)\n            if (targetSameRow != null) targets.add(targetSameRow)\n            if (targetSameMainDiag != null) targets.add(targetSameMainDiag)\n            if (targetSameSubDiag != null) targets.add(targetSameSubDiag)\n\n            return targets\n        } else {\n            return listOf()\n        }\n    }\n\n    private fun shooterAttack(shooter: GameObject) {\n        val targets = shooterGetTargets(shooter)\n\n        for (target in targets) {\n            target.hp -= 1\n            if (target.hp <= 0) {\n                gameMap.remove(Pair(target.x, target.y))\n                zombieNum -= 1\n            }\n        }\n\n    }\n\n    private fun zombieMoveAndAttack(zombie: GameObject): Boolean {\n        val targetY = zombie.y - 1\n        if (targetY < 0) {\n            return true\n        }\n\n        gameMap[Pair(zombie.x, targetY)] = GameObject(zombie.x, targetY, GameObjectType.ZOMBIE, zombie.hp)\n        gameMap.remove(Pair(zombie.x, zombie.y))\n\n        return false\n    }\n\n    fun step(): Int? {\n\n        while (zombieNum > 0) {\n\n            \/\/ Current zombies move\n            for (zombie in gameMap.values.filter { it.type == GameObjectType.ZOMBIE }) {\n                if (zombieMoveAndAttack(zombie)) return curStep\n            }\n\n            \/\/ Then new zombies appear\n            for (newZombie in zombies.filter { it[0] == curStep }) {\n                gameMap[Pair(newZombie[1], width - 1)] =\n                    GameObject(newZombie[1], width - 1, GameObjectType.ZOMBIE, newZombie[2])\n            }\n\n            \/\/ Then numbered shooters attack\n            for (time in 1..9) {\n                for (numberedShooter in gameMap.values.filter { it.type == GameObjectType.NUMBER_SHOOTER && it.hp >= time }\n                    .sortedByDescending { it.y }) {\n                    shooterAttack(numberedShooter)\n                }\n            }\n\n            \/\/ Then S-shooters attack\n            for (sShooter in gameMap.values.filter { it.type == GameObjectType.S_SHOOTER }\n                .sortedWith(compareBy({ -it.y }, { it.x }))) {\n                shooterAttack(sShooter)\n            }\n\n            curStep += 1\n\n        }\n        return null\n    }\n}\n\nobject PNZ {\n    fun plantsAndZombies(lawn: Array<String>, zombies: Array<IntArray>): Int? {\n        val game = Game(lawn, zombies)\n        return game.step()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208165,"user_id":null,"body":"package kata\n\nconst val PNZ_LAWN_EMPTY_SPACE = ' '\nconst val PNZ_S_SHOOTERS_SHOT_TYPE = 0\n\nobject PNZ {\n    fun plantsAndZombies(lawn: Array<String>, zombies: Array<IntArray>): Int? {\n        return PlantsAndZombies(lawn).attackResults(Zombie.horde(zombies))\n    }\n}\n\nclass PlantsAndZombies(lawn: Array<String>) {\n    private val height = lawn.size\n    private val width = lawn[0].length\n    private val plantsByRow = RowOfPlants.gardenStations(lawn)\n\n    fun attackResults(zombiesToBeDeployed: MutableList<Zombie>): Int? {\n        val activeZombiesByRow = Array(height) { RowOfZombies() }\n        val listOfSpreadShooters = plantsByRow.listOfSpreadShooters()\n        val spreadShooterRowProgressionsByRow = (0 until height).map { listOf((it - 1 downTo 0), it + 1 until height) }\n        var timeTick = 0\n        while (true) {\n\n            \/\/ march zombies\n            var checkForVictory = true\n            activeZombiesByRow.forEach { rowOfZombies ->\n                rowOfZombies.forEach { zombie ->\n                    if ((zombie.column--) == 0) return timeTick\n                    checkForVictory = false\n\n                }\n            }\n\n            \/\/ summon zombies\n            zombiesToBeDeployed.iterator().let { iterator ->\n                while (iterator.hasNext()) {\n                    checkForVictory = false\n                    val zombie = iterator.next()\n                    if (zombie.turnOfSummons != timeTick) break\n                    zombie.column = width - 1\n                    activeZombiesByRow[zombie.row].add(zombie)\n                    iterator.remove()\n                }\n            }\n            if (checkForVictory) return null\n\n            \/\/ remove trampled plants\n            activeZombiesByRow.forEachIndexed { row, listOfZombies ->\n                listOfZombies.firstOrNull()?.let { zombie ->\n                    plantsByRow[row].lastOrNull()?.let { plant ->\n                        if (zombie.column == plant.column) {\n                            if (plant.shotType == PNZ_S_SHOOTERS_SHOT_TYPE) {\n                                listOfSpreadShooters.remove(plant)\n                                plantsByRow[row].removeLast()\n                            } else {\n                                plantsByRow[row].pruneLast()\n                            }\n                        }\n                    }\n                }\n            }\n\n            \/\/ shots fired - pea shooters\n            plantsByRow.forEachIndexed { row, rowOfPlants ->\n                activeZombiesByRow[row].applyDamage(rowOfPlants.totalDamage)\n            }\n\n            \/\/ shots fired - s-shooters\n            listOfSpreadShooters.forEach { plant ->\n                activeZombiesByRow[plant.row].applyDamage(1)\n                spreadShooterRowProgressionsByRow[plant.row].forEach { progression ->\n                    activeZombiesByRow.zombieAtAnAngle(plant.column + 1, progression)?.let { zombie ->\n                        if ((--zombie.healthPoints) == 0) activeZombiesByRow[zombie.row].remove(zombie)\n                    }\n                }\n            }\n            ++timeTick\n        }\n    }\n\n}\n\n\ndata class Plant(val row: Int, val column: Int, val shotType: Int)\n\nclass RowOfPlants(list: List<Plant>) : ArrayList<Plant>(list) {\n    var totalDamage = this.sumOf { it.shotType }\n\n    companion object {\n        fun gardenStations(lawn: Array<String>): Array<RowOfPlants> = lawn.indices.map { row ->\n            RowOfPlants(lawn[row].indices.filter { column -> lawn[row][column] != PNZ_LAWN_EMPTY_SPACE }.map { column ->\n                Plant(row, column, (lawn[row][column].digitToIntOrNull() ?: 0))\n            })\n        }.toTypedArray()\n    }\n\n    fun pruneLast() {\n        if (this.isEmpty()) return\n        totalDamage -= this.last().shotType\n        this.removeLast()\n    }\n\n}\n\nprivate fun Array<RowOfPlants>.listOfSpreadShooters() = this.flatMap { rowOfPlants ->\n    rowOfPlants.filter { plant -> plant.shotType == PNZ_S_SHOOTERS_SHOT_TYPE }\n}.sortedWith(compareBy({ -it.column }, { it.row })).toMutableList()\n\ndata class Zombie(val turnOfSummons: Int, val row: Int, var healthPoints: Int) {\n\n    var column = -1\n\n    constructor(arrayOfStats: IntArray) : this(arrayOfStats[0], arrayOfStats[1], arrayOfStats[2])\n\n    companion object {\n        fun horde(zombieStatArray: Array<IntArray>) =\n            zombieStatArray.map(::Zombie).sortedBy { it.turnOfSummons }.toMutableList()\n    }\n\n}\n\nclass RowOfZombies(list: List<Zombie> = mutableListOf()) : ArrayList<Zombie>(list) {\n    fun applyDamage(totalDamage: Int) {\n        var remainingDamage = totalDamage\n        val iterator = this.iterator()\n        while (iterator.hasNext()) {\n            val zombie = iterator.next()\n            if (zombie.healthPoints > remainingDamage) {\n                zombie.healthPoints -= remainingDamage\n                return\n            }\n            remainingDamage -= zombie.healthPoints\n            iterator.remove()\n        }\n    }\n}\n\nprivate fun Array<RowOfZombies>.zombieAtAnAngle(sourceColumnPlusOne: Int, progression: IntProgression): Zombie? {\n    progression.forEachIndexed { index, row ->\n        this[row].firstOrNull { zombie -> zombie.column == sourceColumnPlusOne + index }?.run { return this }\n    }\n    return null\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208166,"user_id":null,"body":"package kata\n\nimport java.lang.IllegalArgumentException\nimport kotlin.reflect.KClass\n\ntypealias Line = MutableList<Cell>\n\nobject PNZ {\n    fun plantsAndZombies(inputLawn: Array<String>, inputZombies: Array<IntArray>): Int? =\n        Game(\n            InputLawnParser(inputLawn).lawn,\n            inputZombies.map { Zombie(it[0], it[1], it[2]) }\n        ).solve()\n}\n\nclass Game(val lawn: Lawn, var zombies: List<Zombie>) {\n    var round = 0\n\n    fun solve(): Int? {\n        while (zombies.isNotEmpty() || lawn.containZombie()) {\n            if (lawn.zombiesMoveToTheLeft()) {\n                return round\n            }\n            spawnZombies()\n            lawn.shootersFire()\n            lawn.s_shootersFire()\n            round++\n        }\n        return null\n    }\n\n    private fun spawnZombies() {\n        val (toSpawn, restOfZombies) = zombies.partition { it.roundAppear == round }\n        this.zombies = restOfZombies\n        toSpawn.forEach(lawn::spawn)\n    }\n}\n\nclass Lawn {\n    data class Coord(val lineIndex: Int, val columnIndex: Int)\n\n    private val lawn: MutableList<Line> = mutableListOf()\n\n    fun newLine() = lawn.add(mutableListOf())\n\n    fun addCell(cell: Cell) = lawn.last().add(cell)\n\n    fun getCell(coord: Coord) = lawn[coord.lineIndex][coord.columnIndex]\n\n    fun setCell(coord: Coord, cell: Cell) {\n        lawn[coord.lineIndex][coord.columnIndex] = cell\n    }\n\n    \/** return true if any zombie reach end of lawn *\/\n    fun zombiesMoveToTheLeft(): Boolean {\n        lawn.forEach { line ->\n            line.forEachIndexed() { i, cell ->\n                if (cell is Zombie) {\n                    if (i == 0) {\n                        return true\n                    }\n                    line[i - 1] = cell \/\/It will destroy shooter, if there was any\n                    line[i] = EmptyCell()\n                }\n            }\n        }\n        return false\n    }\n\n    fun containZombie(): Boolean {\n        lawn.forEach { line ->\n            line.forEach { cell ->\n                if (cell is Zombie) return true\n            }\n        }\n        return false\n    }\n\n    fun spawn(zombie: Zombie) {\n        lawn[zombie.row][lawn.first().lastIndex] = zombie\n    }\n\n    fun shootersFire() {\n        forEachIndexed(Shooter::class) { coord, line, cell ->\n            repeat(cell.power) {\n                shootBullet(coord) { coord ->\n                    Coord(coord.lineIndex, coord.columnIndex + 1)\n                }\n            }\n        }\n    }\n\n    private fun shootBullet(previousCoord: Coord, nextCoord: (Coord) -> Coord) {\n        val actual = nextCoord(previousCoord)\n        if (isInside(actual)) {\n            val zombie = getCell(actual)\n            if (zombie is Zombie) {\n                zombie.health--\n                if (zombie.health <= 0) {\n                    setCell(actual, EmptyCell())\n                }\n            } else {\n                shootBullet(actual, nextCoord)\n            }\n        }\n    }\n\n    fun s_shootersFire() {\n        forEachIndexed(S_Shooter::class) { sCoord, _, _ ->\n            shootBullet(sCoord) { coord -> Coord(coord.lineIndex - 1, coord.columnIndex + 1) }\n            shootBullet(sCoord) { coord -> Coord(coord.lineIndex, coord.columnIndex + 1) }\n            shootBullet(sCoord) { coord -> Coord(coord.lineIndex + 1, coord.columnIndex + 1) }\n        }\n    }\n\n    private fun isInside(coord: Coord) = coord.run {\n        lineIndex >= 0 && columnIndex >= 0 && lineIndex < lawn.size && columnIndex < lawn.first().size\n    }\n\n    private fun <T : Cell> forEachIndexed(\n        cellType: KClass<T>,\n        action: (coord: Coord, line: Line, cell: T) -> Unit\n    ) {\n        for (columnIndex in (lawn.first().lastIndex downTo 0)) {\n            lawn.forEachIndexed { lineIndex, line: Line ->\n                val cell = line[columnIndex]\n                if (cellType.isInstance(cell))\n                    action(Coord(lineIndex, columnIndex), line, cell as T)\n            }\n        }\n    }\n\n}\n\nabstract class Cell\n\nclass EmptyCell : Cell()\n\nclass Shooter(var power: Int) : Cell()\n\nclass S_Shooter : Cell()\n\n\/** roundAppear = 0 based *\/\nclass Zombie(val roundAppear: Int, val row: Int, var health: Int) : Cell()\n\nclass InputLawnParser(private val inputLawn: Array<String>) {\n    val lawn by lazy { parse() }\n\n    private fun parse() = Lawn().apply {\n        inputLawn.forEach { line ->\n            newLine()\n            line.forEach { char ->\n                addCell(charToCell(char))\n            }\n        }\n    }\n\n    private fun charToCell(char: Char): Cell =\n        when (char) {\n            ' ' -> EmptyCell()\n            in '0'..'9' -> Shooter(char.toInt() - '0'.toInt())\n            'S' -> S_Shooter()\n            else -> throw IllegalArgumentException(\"Illegal input '$char'\")\n        }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208167,"user_id":179,"body":"package kata\n\nobject PNZ {\n\n    fun plantsAndZombies(lawn:Array<String>,zombies:Array<IntArray>): Int? {\n\n        val width = lawn.first().length + 1\n        val height = lawn.size\n\n        val field = Field(width, height)\n        (0 until width -1).forEach { x ->\n            (0 until height).forEach { y ->\n                val c = lawn[y][x]\n                when {\n                    c == 'S' -> field.set(x to y, SShooter())\n                    c != ' ' -> field.set(x to y, NShooter(c  - '0'))\n                }\n            }\n        }\n        zombies.forEach {\n            val i = it[0]\n            val row = it[1]\n            val hp = it[2]\n            val pos = (width - 1) to row\n            field.set(pos, Zombie(i, hp))\n        }\n\n        val model = Model(field)\n        while (!model.checkEndCondition()) {\n            model.doMove()\n        }\n        return when {\n            model.zombiesWin() -> model.move\n            model.plantsWin() -> null\n            else -> error(\"Illegal State!\")\n        }\n    }\n\n    class Model(private val field: Field) {\n\n        var move = 0\n\n        fun doMove() {\n            field.mapNotNull { it.instance<Zombie>() }.forEach { it.doAction() }\n            field.mapNotNull { it.instance<NShooter>() }.forEach { it.doAction() }\n            field.mapNotNull { it.instance<SShooter>() }.forEach { it.doAction() }\n            ++move\n        }\n\n        fun checkEndCondition() = plantsWin() || zombiesWin()\n\n        fun plantsWin(): Boolean {\n            field.mapNotNull { it.instance<Zombie>() }.forEach { _ ->\n                return false\n            }\n            return true\n        }\n\n        fun zombiesWin(): Boolean {\n            (0 until field.height).forEach { y ->\n                field.getAll(0 to y).mapNotNull { it.instance<Zombie>() }.forEach { _ ->\n                    return true\n                }\n            }\n            return false\n        }\n    }\n\n    class SShooter(): Plant() {\n\n        private val dirs = listOf(1 to 0, 1 to 1, 1 to -1)\n\n        override fun doAction() {\n            dirs.forEach {\n                shoot(it)\n            }\n        }\n    }\n\n    class NShooter(val n: Int): Plant() {\n\n        override fun doAction() {\n            (0 until n).forEach { _ ->\n                shoot(1 to 0)\n            }\n        }\n    }\n\n    abstract class Plant: Character() {\n\n        fun shoot(dir: Pair<Int, Int>) {\n            val field = field ?: error(\"Illegal State!\")\n            var curr = pos?.move(dir) ?: error(\"Illegal State!\")\n            while (field.inBounds(curr)) {\n                field.getAll(curr).mapNotNull { it.instance<Zombie>() }.firstOrNull()?.let {\n                    it.doDamage()\n                    return\n                }\n                curr = curr.move(dir)\n            }\n        }\n\n        override fun doDamage() {\n            val field = field ?: error(\"Illegal State!\")\n            field.remove(this)\n        }\n    }\n\n    class Zombie(var i: Int, var hp: Int): Character() {\n\n        override fun doAction() {\n            val pos = pos ?: error(\"Illegal State!\")\n            val field = field ?: error(\"Illegal State!\")\n            if (i > 0) {\n                --i\n            }\n            else {\n                val newPos = pos.move(-1 to 0)\n                field.getAll(newPos).mapNotNull { it.instance<Plant>() }.forEach{ it.doDamage() }\n                field.set(newPos, this)\n            }\n        }\n\n        override fun doDamage() {\n            val field = field ?: error(\"Illegal State!\")\n            val pos = pos ?: error(\"Illegal State!\")\n            if (pos.first != field.width - 1) --hp\n            if (hp == 0) field.remove(this)\n        }\n    }\n\n    abstract class Character {\n\n        var field: Field? = null\n        var pos: Pair<Int, Int>? = null\n\n        abstract fun doAction()\n        abstract fun doDamage()\n    }\n\n    class Field(val width: Int, val height: Int): Iterable<Character> {\n\n        private val field: Array<Array<MutableList<Character>>> = (0 until width).map { (0 until height).map { mutableListOf<Character>() }.toTypedArray() }.toTypedArray()\n\n        fun inBounds(pos: Pair<Int, Int>) = when {\n            pos.first < 0 -> false\n            pos.first >= width -> false\n            pos.second < 0 -> false\n            pos.second >= height -> false\n            else -> true\n        }\n\n        fun set(pos: Pair<Int, Int>, character: Character) {\n            remove(character)\n            field[pos.first][pos.second].add(character)\n            character.pos = pos\n            character.field = this\n        }\n\n        fun getAll(pos: Pair<Int, Int>): List<Character> {\n            return field[pos.first][pos.second].toList()\n        }\n\n        fun remove(character: Character): Character {\n            character.pos?.let { remove(it, character) }\n            return character\n        }\n\n        private fun remove(pos: Pair<Int, Int>, character: Character) {\n            field[pos.first][pos.second].remove(character)\n        }\n\n        override fun iterator(): Iterator<Character> {\n            val l = mutableListOf<Character>()\n            (width -1 downTo 0).forEach { x ->\n                (0 until height).forEach { y ->\n                    l.addAll(field[x][y])\n                }\n            }\n            return l.iterator()\n        }\n    }\n\n    inline fun <reified T : Any> Any.instance(): T? = if (this is T) {\n        this\n    } else {\n        null\n    }\n\n    fun Pair<Int, Int>.move(v: Pair<Int, Int>) = (this.first + v.first) to (this.second + v.second)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208168,"user_id":null,"body":"package kata\n\nimport java.util.*\nimport kotlin.Comparator\n\nobject PNZ {\n    private lateinit var lanes: Array<Array<Entity?>>\n    private var breach = false\n    private var zombiesAlive = 0\n\n    fun plantsAndZombies(lawn: Array<String>, zombies: Array<IntArray>): Int? {\n        createLanes(lawn)\n        breach = false\n        zombiesAlive = zombies.size\n\n        var turn = -1\n        var dataIndex = 0\n\n        while (!breach && zombiesAlive > 0) {\n            turn++\n\n            moveExistingZombies()\n\n            while (dataIndex < zombies.size && zombies[dataIndex][0] == turn)\n                spawnNewZombie(zombies[dataIndex++])\n\n            normalPlantsShoot()\n            superPlantsShoot()\n        }\n\n        return if (breach) turn else null\n    }\n\n    private fun createLanes(lawn: Array<String>) {\n        lanes = Array(lawn.size) { Array(lawn.first().length) { null } }\n\n        for (i in lawn.indices) {\n            for (pos in lawn[i].indices) {\n                val symbol = lawn[i][pos]\n\n                val entity = when {\n                    symbol == 'S' -> SuperPlant()\n                    symbol.isDigit() -> Plant(symbol.digitToInt())\n                    else -> null\n                }\n\n                lanes[i][pos] = entity\n            }\n        }\n    }\n\n    private fun moveExistingZombies() {\n        for (lane in lanes) {\n            if (lane[0] is Zombie) {\n                lane[0] = null\n                breach = true\n            }\n\n            for (i in 0 until lane.size - 1) {\n                if (lane[i + 1] !is Zombie)\n                    continue\n\n                lane[i] = lane[i + 1]\n                lane[i + 1] = null\n            }\n        }\n    }\n\n    private fun spawnNewZombie(data: IntArray) {\n        val zombie = Zombie(data[2])\n        val lane = lanes[data[1]]\n        lane[lane.lastIndex] = zombie\n    }\n\n    private fun normalPlantsShoot() {\n        for (laneNo in lanes.indices) {\n            val lane = lanes[laneNo]\n            var firstZombieIndex: Int? = null\n\n            for (pos in lane.indices) {\n                if (lane[pos] !is Plant)\n                    continue\n\n                val shotCount = (lane[pos] as Plant).shots\n                var noZombies = false\n\n                for (s in 0 until shotCount) {\n                    val zombieIndex = findFirstZombie(laneNo, firstZombieIndex ?: 0)\n                    if (zombieIndex == null) {\n                        noZombies = true\n                        break\n                    }\n\n                    shootAtZombie(laneNo, zombieIndex)\n\n                    firstZombieIndex = zombieIndex\n                }\n\n                if (noZombies)\n                    break\n            }\n        }\n    }\n\n    private fun superPlantsShoot() {\n        val candidates = TreeSet(Comparator<Pair<Int, Int>> { o1, o2 ->\n            var order = o2.second.compareTo(o1.second)\n            if (order == 0)\n                order = o1.first.compareTo(o2.first)\n\n            order\n        })\n\n        for (laneNo in lanes.indices) {\n            for (pos in lanes[laneNo].indices.reversed()) {\n                if (lanes[laneNo][pos] !is SuperPlant)\n                    continue\n\n                candidates.add(Pair(laneNo, pos))\n            }\n        }\n\n        for ((laneNo, pos) in candidates) {\n            findFirstZombie(laneNo, pos + 1)?.let { shootAtZombie(laneNo, it) }\n            findFirstZombieDiagonal(laneNo, pos, 1)?.let { shootAtZombie(it.first, it.second) }\n            findFirstZombieDiagonal(laneNo, pos, -1)?.let { shootAtZombie(it.first, it.second) }\n        }\n    }\n\n    private fun findFirstZombie(laneNo: Int, startFrom: Int): Int? {\n        val lane = lanes[laneNo]\n        for (i in startFrom until lane.size) {\n            if (lane[i] is Zombie)\n                return i\n        }\n\n        return null\n    }\n\n    private fun findFirstZombieDiagonal(startLaneNo: Int, startPos: Int, direction: Int): Pair<Int, Int>? {\n        var laneNo = startLaneNo + direction\n        var pos = startPos + 1\n\n        while (laneNo in lanes.indices && pos in lanes[laneNo].indices) {\n            if (lanes[laneNo][pos] is Zombie)\n                return Pair(laneNo, pos)\n\n            laneNo += direction\n            pos++\n        }\n\n        return null\n    }\n\n    private fun shootAtZombie(laneNo: Int, pos: Int) {\n        val zombie = lanes[laneNo][pos] as Zombie\n        zombie.health--\n\n        if (zombie.health == 0) {\n            lanes[laneNo][pos] = null\n            zombiesAlive--\n        }\n    }\n}\n\nprivate abstract class Entity\n\nprivate class Plant(val shots: Int) : Entity()\n\nprivate class SuperPlant : Entity()\n\nprivate class Zombie(var health: Int) : Entity()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208169,"user_id":null,"body":"import kotlin.math.min\n\ndata class Zombie(val index: Int, val startMoveNumberval: Int, val y: Int, var health: Int, var x: Int? = null) {\n    val onLawn get() = x != null\n    override fun toString() = \"Zombie($index $x,$y $health)\"\n}\n\ninterface Shooter {\n    val index: Int\n    val x: Int\n    val y: Int\n    val c: String\n}\n\nval Int.pad3 get(): String = this.toString() + (this.toString().length until 3).joinToString(\" \") { \"\" }\n\ndata class NumberShooter(override val index: Int, override val x: Int, override val y: Int, val shots: Int) : Shooter {\n    override val c = \"N${shots.pad3}\"\n    override fun toString() = \"N($index $x,$y $shots)\"\n}\n\ndata class SShooter(override val index: Int, override val x: Int, override val y: Int) : Shooter {\n    override val c = \"S==\"\n    override fun toString() = \"S($index $x,$y)\"\n}\n\ndata class Position(val x: Int, val y: Int, var shooter: Shooter? = null, var zombie: Zombie? = null) {\n    val c get() = shooter?.let { shooter!!.c } ?: zombie?.let { \"Z${it.health.pad3}\" } ?: \"   \"\n}\n\ndata class Lawn(private val positions: List<List<Position>> = (0..4).map { y -> (0..7).map { x -> Position(x, y) } }) {\n\n    constructor(xSize: Int, ySize: Int) : this((0 until ySize).map { y -> (0 until xSize).map { x -> Position(x, y) } })\n\n    val maxX = positions[0].size - 1\n\n    fun position(x: Int, y: Int): Position? {\n        return positions.getOrNull(y)?.getOrNull(x)\n    }\n\n    fun show() {\n        println(visual())\n    }\n\n    fun visual(): String {\n        val res = StringBuilder()\n        val title = (positions[0].indices).map { \"  $it\" }.joinToString(\"\")\n        res.append(\"$title\n\")\n        for (row in positions.indices) {\n            res.append(\"$row ${positions[row].joinToString(\"\") { it.c }}\n\")\n        }\n        return res.toString()\n    }\n}\n\nclass DefencesPenetrated(val moves: Int) : Throwable()\nclass AllZombiesDead() : Throwable()\n\ndata class World(\n    val lawn: Lawn = Lawn(),\n    val zombies: MutableList<Zombie> = mutableListOf(),\n    val shooters: MutableList<Shooter> = mutableListOf(),\n    var nextMoveCounter: Int = 0\n) {\n    constructor(lawnArray: Array<String>) : this(\n        Lawn(lawnArray[0].length, lawnArray.size)\n    )\n\n    fun populate(lawnArray: Array<String>, zombiesArray: Array<IntArray>) {\n        zombies.addAll(zombiesArray.mapIndexed { index, ints -> Zombie(index, ints[0], ints[1], ints[2]) })\n        var nsCounter = 0\n        var ssCounter = 0\n        for (y in lawnArray.indices) {\n            for (x in lawnArray[y].indices) {\n                val c = lawnArray[y][x]\n                if (c.isDigit()) {\n                    val n = NumberShooter(nsCounter++, x, y, c.toString().toInt())\n                    shooters.add(n)\n                    lawn.position(x, y)!!.shooter = n\n                } else if (c == 'S') {\n                    val s = SShooter(ssCounter++, x, y)\n                    shooters.add(s)\n                    lawn.position(x, y)!!.shooter = s\n                }\n            }\n        }\n    }\n\n    fun tick() {\n        moveZombies()\n        addZombies()\n        fireNumberShooters()\n        fireSShooters()\n        nextMoveCounter++\n    }\n\n    private fun moveZombies() {\n        zombies.filter { it.onLawn }.sortedBy { it.x }.forEach { zombie ->\n            val x = zombie.x!!\n            if (x - 1 < 0) {\n                throw DefencesPenetrated(nextMoveCounter)\n            }\n            zombie.x = x - 1\n            lawn.position(x, zombie.y)!!.zombie = null\n            val position = lawn.position(zombie.x!!, zombie.y)!!\n            position.zombie = zombie\n            position.shooter?.let {\n                \/\/ println(\"Shooter ${position.shooter} died\")\n                shooters.remove(it)\n                position.shooter = null\n            }\n        }\n    }\n\n    private fun addZombies() {\n        zombies.filter { it.startMoveNumberval == nextMoveCounter }.forEach { zombie ->\n            val p = lawn.position(lawn.maxX, zombie.y)!!\n            check(p.zombie == null)\n            p.zombie = zombie\n            zombie.x = lawn.maxX\n            \/\/ println(\"Inserted Zombie $zombie\")\n        }\n    }\n\n    private fun fireNumberShooters() {\n        for (shooter in shooters.filterIsInstance<NumberShooter>()) {\n            var shotsRemaining = shooter.shots\n            for (x in ((shooter.x + 1)..lawn.maxX)) {\n                val position = lawn.position(x, shooter.y)!!\n                if (position.zombie != null) {\n                    val used = min(shotsRemaining, position.zombie!!.health)\n                    \/\/ println(\"Shooter $shooter hits ${position.zombie} $used times\")\n                    shotsRemaining -= used\n                    position.zombie!!.health -= used\n                    if (position.zombie!!.health <= 0) {\n                        \/\/ println(\"Zombie ${position.zombie} died\")\n                        zombies.remove(position.zombie)\n                        position.zombie = null\n                        if (zombies.isEmpty()) {\n                            throw AllZombiesDead()\n                        }\n                    }\n                    if (shotsRemaining == 0) {\n                        break\n                    }\n                }\n            }\n        }\n    }\n\n    private fun fireSShooters() {\n        val shooters = shooters.filterIsInstance<SShooter>().groupBy { it.x }.map { it.value.sortedBy { it.y } } .sortedByDescending { it[0].x }.flatten()\n        for (shooter in shooters) {\n            var yAdjust = 0\n            val directionHit = mutableListOf(false, false, false)\n            for (x in ((shooter.x + 1)..lawn.maxX)) {\n                yAdjust += 1\n                for (p in listOf(\n                    0 to lawn.position(x, shooter.y),\n                    1 to lawn.position(x, shooter.y - yAdjust),\n                    2 to lawn.position(x, shooter.y + yAdjust)\n                ).filter { it.second != null }) {\n                    val index = p.first\n                    if (directionHit[index]) {\n                        continue\n                    }\n                    val position = p.second!!\n                    if (position.zombie != null) {\n                        \/\/ println(\"Shooter $shooter hits ${position.zombie}\")\n                        directionHit[index] = true\n                        position.zombie!!.health -= 1\n                        if (position.zombie!!.health <= 0) {\n                            \/\/ println(\"Zombie ${position.zombie} died\")\n                            zombies.remove(position.zombie)\n                            position.zombie = null\n                            if (zombies.isEmpty()) {\n                                throw AllZombiesDead()\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nobject PNZ {\n    fun plantsAndZombies(lawnArray: Array<String>, zombiesArray: Array<IntArray>): Int? {\n      println(\"arrayOf(${lawnArray.map { \"\\\"$it\\\"\"}.joinToString()})\")\n        println(\"arrayOf(${zombiesArray.map { \"intArrayOf(\" + it.toList().joinToString() + \")\"}})\")\n        val world = World(lawnArray)\n        world.populate(lawnArray, zombiesArray)\n        try {\n            while (true) {\n                \/\/ println(\"${world.nextMoveCounter}\")\n                world.tick()\n                \/\/ world.lawn.show()\n            }\n        } catch (e: DefencesPenetrated) {\n            return e.moves\n        } catch (e: AllZombiesDead) {\n            return null\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208170,"user_id":null,"body":"package kata\nimport java.util.LinkedList\nimport java.util.ArrayList\n\nobject PNZ {\n    fun plantsAndZombies(lawn:Array<String>,zombies:Array<IntArray>): Int? {\n        val cols = lawn[0].length\n        val rows = lawn.size\n        val maxZombiePosition = cols\n        \n        val turetsSorted = lawn.flatMapIndexed{idx, line -> Turet.createFromString(line, idx)}\n                    .sortedWith(compareBy({it.typeOrder()}, {-it.position}, {it.row}))\n                    .toList()\n                    \n        val board = Board(\n            rows = rows,\n            cols = cols,\n            turets = turetsSorted\n        )\n\n        var moveNumber = 0\n        var isGameOver = false\n        \n        val maxActivationLine = zombies.map{z -> z[0]}.maxOrNull() ?: 0\n        while(!isGameOver)\n        {\n            val zombiesToActivate = zombies.filter{arr -> arr[0] == moveNumber}\n                        .map{t -> Zombie.readZombie(maxZombiePosition - 1, t)}\n                        .toList()\n\n            board.moveZombies()\n\n            for(z in zombiesToActivate)\n                board.addZombie(z)\n\n            \/\/shooting\n            board.turets\n                    .filter{t -> t.isAlive}\n                    .forEach{it.shoot(board)}\n\n            val anyAliveZombie = board.zombies.any{z -> z.health > 0}\n            val allWavesDone = moveNumber > maxActivationLine\n            if(!anyAliveZombie && allWavesDone)\n                return null\n\n            isGameOver = board.zombies\n                .any{z -> z.position <= 0}\n            moveNumber += 1\n        }\n\n        return moveNumber\n    }\n}\n\nfun Turet.typeOrder() =\n    when(this) {\n        is ShooterS -> 5\n        is NumberedShooter -> 0\n        else -> -1\n    }\n\nclass Board(\n    val rows: Int,\n    val cols: Int,\n    val zombies: MutableList<Zombie> = LinkedList<Zombie>(),\n    val turets: List<Turet> = ArrayList<Turet>()\n) {\n    \n    private val zombieMatrix = initMatrixZombie(rows, cols)\n    private val turetsMatrix = initMatrixTurets(rows, cols, turets)\n    \n    companion object {\n        private fun initMatrixZombie(rows: Int, cols: Int): Array<Array<List<Zombie>>> {\n            val result = Array<Array<List<Zombie>>>(rows) {_ -> Array<List<Zombie>>(cols){_ -> emptyList()}}\n            return result\n        }\n        private fun initMatrixTurets(rows: Int, cols: Int, turets: List<Turet>): Array<Array<List<Turet>>> {\n            val result = Array<Array<List<Turet>>>(rows) {_ -> Array<List<Turet>>(cols){_ -> emptyList()}}\n            turets.forEach{t -> result[t.row][t.position] = result[t.row][t.position].plus(t)}\n            return result\n        }\n    }\n    \n    fun moveZombies() {\n        for(rowIt in 0..rows-1) {\n            for(colIt in 1..cols-1) {\n                val zz = zombieMatrix[rowIt][colIt];\n                val movedZombies = zz.filter{it.health > 0}\n                val deadZombies = zz.filter{it.health <= 0}\n                val targetCol = colIt - 1\n                movedZombies.forEach{it.position = targetCol}\n                if(!movedZombies.isEmpty()) {\n                    turetsMatrix[rowIt][colIt - 1]\n                        .forEach{it.isAlive = false}\n                }\n                zombieMatrix[rowIt][colIt] = deadZombies;\n                zombieMatrix[rowIt][colIt - 1] = movedZombies;\n            }\n        }\n    }\n\n    fun getZombies(row: Int, position: Int): List<Zombie> {\n        if(row < 0 || position < 0 || row >= rows || position >= cols)\n            return emptyList()\n        return zombieMatrix[row][position]\n    }\n    \n    fun addZombie(zombie: Zombie) {\n        zombies.add(zombie)\n        zombieMatrix[zombie.row][zombie.position] = zombieMatrix[zombie.row][zombie.position].plus(zombie)\n    }\n    \n}\n\nabstract class Turet (\n    val row: Int,\n    val position: Int,\n    var isAlive: Boolean = true\n) {\n\n    abstract fun getStrength(): Int;\n    abstract fun getTargets(board: Board): List<List<Zombie>>;\n    fun shoot(board: Board) {\n        val zombieTargets = this.getTargets(board)\n        for(shoot in 0..this.getStrength()-1) {\n            for(target in zombieTargets) {\n                val zombie = target.filterNotNull().filter{z -> z.health > 0}.firstOrNull()\n                if(zombie != null) {\n                    zombie.health -= 1\n                }\n            }\n        }\n    }\n\n    companion object {\n        fun createShooterS(row: Int, position: Int) =\n            ShooterS(row, position)\n        fun createNumberedShooter(row: Int, position: Int, strength: Int) =\n            NumberedShooter(strength, row, position)\n        fun createFromString(str: String, row: Int): List<Turet> =\n            str.mapIndexed{position, ch -> \n                when(ch)\n                {\n                    ' ' ->  null\n                    'S' ->  createShooterS(row, position)\n                    else ->  createNumberedShooter(row, position, ch.code - '0'.code)\n                }\n            }.filterNotNull().toList()\n    }\n}\n\nclass NumberedShooter (\n    val numbers: Int,\n    row: Int,\n    position: Int,\n    isAlive: Boolean = true\n): Turet(row, position, isAlive) {\n    override fun getStrength(): Int = numbers\n    override fun getTargets(board: Board): List<List<Zombie>> =\n        listOf(\n            getDirectiveTarget(board, this.row)\n        ).filterNotNull().toList()\n}\nclass ShooterS (\n    row: Int,\n    position: Int,\n    isAlive: Boolean = true\n): Turet(row, position, isAlive) {\n    override fun getStrength(): Int = 1\n    override fun getTargets(board: Board): List<List<Zombie>> =\n        listOf(\n            getDirectiveTarget(board, this.row),\n            getDiagonalUpTarget(board, this),\n            getDiagonalDownTarget(board, this)\n        ).filterNotNull().toList()\n}\n\nfun getDiagonalUpTarget(board: Board, turet: Turet): List<Zombie> =\n    (turet.position+1..board.cols-1)\n        .flatMapIndexed{idx, position -> board.getZombies(turet.row + idx + 1, position)}.toList()\nfun getDiagonalDownTarget(board: Board, turet: Turet): List<Zombie> =\n    (turet.position+1..board.cols-1)\n        .flatMapIndexed{idx, position -> board.getZombies(turet.row - idx - 1, position)}.toList()\nfun getDirectiveTarget(board: Board, row: Int): List<Zombie> =\n    (0..board.cols-1).flatMap{position -> board.getZombies(row, position)}.toList()\n\nclass Zombie(\n    var health: Int,\n    val row: Int,\n    var position: Int\n) {\n    \n    fun decrementHealth(amount: Int = 1) {\n        health -= amount\n    }\n    \n    companion object {\n        fun readZombie(position: Int, zombie: IntArray) =\n                Zombie(zombie[2], zombie[1], position)\n        \n    }\n    \n}\n\n\n\n\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208171,"user_id":null,"body":"package kata\n\nimport kotlin.math.min\n\ndata class Shooter(val x:Int, val y:Int, var shooterStrength: Int)\n\ndata class DS(val dx:Int, val dy:Int, val s: Int)\n\nobject PNZ {\n    fun plantsAndZombies(lawn:Array<String>,zombies:Array<IntArray>): Int? {\n        val shooters = mutableListOf<Shooter>()\n        val sx = lawn[0].length\n        val sy = lawn.size\n        for (x in 0 until sx) {\n            for (y in 0 until sy) {\n                lawn[y][x].let { c ->\n                    if (Character.isDigit(c)) {\n                        shooters.add(Shooter(x, y, c - '0'))\n                    }\n                }\n            }\n        }\n        for (x in sx-1 downTo 0) {\n            for (y in 0 until sy) {\n                if (lawn[y][x] == 'S') shooters.add(Shooter(x, y, -1))\n            }\n        }\n\n        val zombieReachPerRow = IntArray(sy) { _ -> sx }\n        var turn = 0\n        while (true) {\n            \/\/ Move Zombies\n            var zombiesInLawn = Array(sy) { IntArray(sx) { -1 } }\n            var someAlive = false\n            zombies.forEachIndexed { ix, z ->\n                if (z[2] > 0) {\n                    someAlive = true\n                    val zx = sx - 1 + z[0] - turn\n                    if (zx < 0) return turn\n                    val zy = z[1]\n                    if (zx < sx) {\n                        zombieReachPerRow[zy] = zombieReachPerRow[zy].coerceAtMost(zx)\n                        zombiesInLawn[zy][zx] = ix\n                    }\n                }\n            }\n            if (!someAlive) return null\n\n            \/\/ Shoot\n            shooters\n                .filter { s -> s.x < zombieReachPerRow[s.y] }\n                .forEach { s ->\n                    val dirStrength = if (s.shooterStrength < 0)\n                        (-1.. 1).map{ DS(1, it, 1) }\n                    else\n                        listOf(DS(1, 0, s.shooterStrength))\n                    dirStrength.forEach { ds ->\n                        var x = s.x\n                        var y = s.y\n                        var str = ds.s\n                        while (str > 0 && x < sx && y >= 0 && y < sy) {\n                            val zIx = zombiesInLawn[y][x]\n                            if (zIx >= 0) {\n                                val dmg = min(zombies[zIx][2], str)\n                                str -= dmg\n                                zombies[zIx][2] -= dmg\n                            }\n                            x += ds.dx\n                            y += ds.dy\n                        }\n                    }\n                }\n\n            turn++\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5a6663e9fd56cb5ab800008b":[{"id":208172,"user_id":null,"body":"package solution\nfun human_years_cat_years_dog_years(years: Int): Array<Int> =\n    when (years) {\n        1 -> arrayOf(1, 15 , 15)\n        2 -> arrayOf(years, 24 , 24)\n        else -> arrayOf(years, 24 + 4 * (years - 2), 24 + 5 * (years - 2))\n    }","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208173,"user_id":null,"body":"package solution\n\nfun catYears(humanYears: Int): Int {\n  when(humanYears) {\n    1 -> return 15\n    2 -> return 15 + 9\n    else -> return 15 + 9 + 4 * (humanYears - 2)\n  }\n}\n\nfun dogYears(humanYears: Int): Int {\n  when(humanYears) {\n    1 -> return 15\n    2 -> return 15 + 9\n    else -> return 15 + 9 + 5 * (humanYears - 2)\n  }\n}\n\nfun human_years_cat_years_dog_years(years: Int): Array<Int> {\n    return arrayOf(years, catYears(years), dogYears(years))\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208174,"user_id":null,"body":"package solution\n\nfun human_years_cat_years_dog_years(years: Int): Array<Int> {\n  \/\/ Your solution is here\n  val catYears = animalCalculator(years,4)\n  val dogYears = animalCalculator(years,5)\n  return arrayOf(years, catYears, dogYears)\n}\n\nfun animalCalculator(x : Int, y: Int) : Int = when(x) {\n    1 -> 15\n    2 -> 24\n    else -> (24 + ((x-2)*y))\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208175,"user_id":null,"body":"package solution\n\nfun human_years_cat_years_dog_years(years: Int): Array<Int> =\n    if (years == 1) arrayOf(1, 15, 15) else arrayOf(years, 16 + 4 * years, 14 + 5 * years)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208176,"user_id":null,"body":"package solution\n\nfun human_years_cat_years_dog_years(years: Int): Array<Int> {\n    var dogYears: Int = 0\n    var catYears: Int = 0\n    for (i in 1..years) {\n        when (i) {\n        1 -> { \n            dogYears += 15\n            catYears += 15 \n            }\n        2 -> {\n            dogYears += 9\n            catYears += 9 \n            }\n        else -> {\n            dogYears += 5\n            catYears += 4 \n            }\n        }\n    }\n    return arrayOf(years, catYears, dogYears);\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208177,"user_id":17,"body":"package solution\n\nfun human_years_cat_years_dog_years(n: Int): Array<Int> {\n  return arrayOf(n, if (n == 1) 15 else 4 * (n + 4), if (n == 1) 15 else 5 * n + 14);\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208178,"user_id":null,"body":"package solution\n\nfun human_years_cat_years_dog_years(years: Int) = arrayOf(years,\n    15 + if(years > 1) 9 + (years - 2) * 4 else 0,\n    15 + if(years > 1) 9 + (years - 2) * 5 else 0)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208179,"user_id":null,"body":"package solution\n\nfun human_years_cat_years_dog_years(years: Int) = arrayOf(years, getYears(years, 4), getYears(years, 5))\n\nprivate fun getYears(years: Int, n: Int) = (1..years).sumOf {\n    when (it) {\n        1 -> 15\n        2 -> 9\n        else -> n\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208180,"user_id":null,"body":"package solution\n\nfun human_years_cat_years_dog_years(years: Int): Array<Int> {\n    \/\/ Your solution is here\n    var humanYears = 0\n    var catYears = 0\n    var dogYears = 0\n    \n    humanYears = years\n    if(humanYears == 1){\n        catYears = catYears + 15\n        dogYears = dogYears + 15\n    }else if(humanYears == 2){\n        catYears = catYears + 15 + 9\n        dogYears = dogYears + 15 + 9\n    }else{\n        catYears = catYears + 15 + 9 + ((humanYears-2)*4)\n        dogYears = dogYears + 15 + 9 + ((humanYears-2)*5)\n    }\n    \n    return arrayOf(humanYears, catYears, dogYears);\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208181,"user_id":null,"body":"package solution\n\nfun human_years_cat_years_dog_years(years: Int) = arrayOf(years, years.fur(15,9,4), years.fur(15,9,5))\n\nfun Int.fur(y1:Int,y2:Int,yall:Int) = \n    (if(this>=1) y1 else 0) +\n    (if(this>=2) y2 else 0) +\n    (if(this>=3) yall*(this-2) else 0)\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5a6f71185084d76d2000001b":[{"id":208182,"user_id":null,"body":"package solution\n\nimport java.util.Optional\n\nfun <T> `for`(lambda: suspend SequenceScope<Optional<T>>.() -> Unit): Optional<T> {\n    return sequence<Optional<T>> { lambda() }.first()\n}\n\nsuspend fun <T> SequenceScope<Optional<T>>.yield(value: T) = yield(Optional.of(value))\n\nsuspend fun <T, U> SequenceScope<Optional<T>>.bind(value: Optional<U>): U {\n    if (!value.isPresent) {\n        yield(Optional.empty())\n    }\n    return value.get()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208183,"user_id":null,"body":"package solution\n\nimport java.util.*\nimport kotlin.coroutines.*\n\nfun <T : Any> `for`(lambda: suspend () -> T): Optional<T> {\n    var optional: Optional<T> = Optional.empty()\n    lambda.startCoroutine(object : Continuation<T> {\n        override val context: CoroutineContext get() = EmptyCoroutineContext\n\n        override fun resumeWith(result: Result<T>) {\n            optional = Optional.of(result.getOrThrow())\n        }\n    })\n    return optional\n}\n\nfun <T> yield(value: T) = value\n\nsuspend fun <T> bind(o: Optional<T>): T =\n    suspendCoroutine { continuation -> o.ifPresent { continuation.resume(it!!) } }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208184,"user_id":null,"body":"package solution\n\nimport java.util.Optional\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED\nimport kotlin.coroutines.intrinsics.suspendCoroutineUninterceptedOrReturn\n\nclass OptionalComputer<T> : Continuation<Unit> {\n    var isFinished = false;\n    var result: Optional<T> = Optional.empty()\n    lateinit var continuation: Continuation<Unit>\n    override val context: CoroutineContext\n        get() = EmptyCoroutineContext\n\n    suspend fun <R> bind(o: Optional<R>): R {\n        if (o.isPresent) return o.get()\n        isFinished = true\n        return suspendCoroutineUninterceptedOrReturn {\n            COROUTINE_SUSPENDED\n        }\n    }\n\n    fun yield(e: T) {\n        result = Optional.of(e)\n    }\n\n    override fun resumeWith(result: Result<Unit>) {\n        result.getOrThrow()\n        isFinished = true\n    }\n}\n\nfun <T> `for`(lambda: suspend OptionalComputer<T>.() -> Unit): Optional<T> {\n    val computer = OptionalComputer<T>()\n    lambda\n        .createCoroutine(computer, computer)\n        .resume(Unit)\n    while (!computer.isFinished);\n    return computer.result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208185,"user_id":null,"body":"package solution\n\nimport java.util.*\nimport kotlin.coroutines.Continuation\nimport kotlin.coroutines.CoroutineContext\nimport kotlin.coroutines.EmptyCoroutineContext\nimport kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED\n\nobject EmptyContinuation:Continuation<Any?> {\n\toverride val context: CoroutineContext\n\t\tget() = EmptyCoroutineContext\n\n\toverride fun resumeWith(result: Result<Any?>) {\n\t\tTODO(\"Implement resumeWith\")\n\t}\n}\n\nfun <T> `for`(lambda: suspend () -> T): Optional<T> {\n\t@Suppress(\"UNCHECKED_CAST\")\n\tlambda as (Continuation<T>) -> Any\n\tval debug = lambda(EmptyContinuation)\n\tif(debug == COROUTINE_SUSPENDED)\n\t\treturn Optional.empty()\n\t@Suppress(\"UNCHECKED_CAST\")\n\treturn Optional.of(debug as T)\n}\n\nfun <T> yield(value: T):T = value\n\n@Suppress(\"RedundantSuspendModifier\", \"UNCHECKED_CAST\")\nsuspend fun <T>bind(optional: Optional<T>) : T = optional.orElse(COROUTINE_SUSPENDED as T)\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208186,"user_id":null,"body":"package solution\n\nimport java.util.*\nimport kotlin.coroutines.Continuation\nimport kotlin.coroutines.CoroutineContext\nimport kotlin.coroutines.EmptyCoroutineContext\nimport kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED\n\nobject EmptyContinuation:Continuation<Any?> {\n\toverride val context: CoroutineContext\n\tget() = EmptyCoroutineContext\n\n\toverride fun resumeWith(result: Result<Any?>) {\n\t\tTODO(\"Implement resumeWith\")\n\t}\n}\n\nclass Ref<T>(var item:T? = null)\n\nfun <T> `for`(lambda: suspend Ref<T>.() -> Unit): Optional<T> {\n\t@Suppress(\"UNCHECKED_CAST\")\n\tval t = lambda as (Ref<T>, Continuation<T>) -> Any\n\tval ref = Ref<T>()\n\tval debug = t(ref, EmptyContinuation)\n\tif(debug == COROUTINE_SUSPENDED)\n\t\treturn Optional.empty()\n\t@Suppress(\"UNCHECKED_CAST\")\n\treturn Optional.of(ref.item!!)\n}\n\nfun <T> Ref<T>.yield(value: T) {\n\titem = value\n}\n\n@Suppress(\"RedundantSuspendModifier\")\nsuspend fun <T>bind(optional: Optional<T>) : T{\n\tif(optional.isPresent)\n\t\treturn optional.get()\n\t@Suppress(\"UNCHECKED_CAST\")\n\treturn COROUTINE_SUSPENDED as T\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208187,"user_id":null,"body":"package solution\n\nimport java.util.Optional\n\nfun <T> `for`(lambda: () -> Optional<T>): Optional<T> {\n    lambda.javaClass.declaredFields.forEach {\n        val optional = when (it.type) {\n            Optional::class.java -> it.get(lambda) as Optional<T>\n            Function0::class.java -> (it.get(lambda) as Function0<Optional<T>>).invoke()\n            else -> null\n        }\n        if (optional != null && !optional.isPresent) return Optional.empty()\n    }\n    return lambda.invoke()\n}\n\n\/\/ you can change this implemention as you wish\nfun <T> yield(value: T): Optional<T> = Optional.of(value)\n\nfun <T> bind(o: Optional<T>) = o.get()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208188,"user_id":100,"body":"package solution\n\nimport java.util.Optional\n\nfun <T> `for`(lambda: suspend SequenceScope<Optional<T>>.() -> Unit): Optional<T> {\n    return sequence<Optional<T>> { lambda() }.first()\n}\n\nsuspend fun <T : Any> SequenceScope<Optional<T>>.yield(value: T) = yield(Optional.of(value))\n\nsuspend fun <T : Any, U> SequenceScope<Optional<T>>.bind(value: Optional<U>): U {\n    if (!value.isPresent) {\n        yield(Optional.empty())\n    }\n    return value.get()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208189,"user_id":null,"body":"@file:Suppress(\"PACKAGE_CANNOT_BE_IMPORTED\")\n\npackage solution\n\nimport java.util.Optional\n\nfun <T> `for`(lambda: suspend SequenceScope<Optional<T>>.() -> Unit): Optional<T> {\n    return sequence { lambda() }.first()\n}\n\n\/\/ you can change this implemention as you wish\nsuspend fun <T> SequenceScope<Optional<T>>.yield(value: T) = yield(Optional.of(value))\n\nsuspend fun <T, U> SequenceScope<Optional<T>>.bind(value: Optional<U>): U {\n    if (!value.isPresent) yield(Optional.empty())\n    return value.get()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208190,"user_id":null,"body":"@file:Suppress(\"PACKAGE_CANNOT_BE_IMPORTED\")\n\npackage solution\nimport java.util.*\nimport kotlin.coroutines.*\n\nobject Failure : Throwable()\n\nfun <T> `for`(lambda: suspend () -> Optional<T>): Optional<T> {\n    var shit: Result<Optional<T>>? = null\n\n    lambda.createCoroutine(Continuation(EmptyCoroutineContext) {\n        shit = it\n    }).resume(Unit)\n\n    val result = shit!!\n\n    return result.getOrElse { if (it === Failure) Optional.empty() else throw it }\n}\n\nfun <T> yield(value: T) = Optional.of(value)\n\nsuspend fun <T> bind(opt: Optional<T>): T {\n    return suspendCoroutine { cont ->\n        if (opt.isPresent) {\n            cont.resume(opt.get())\n        } else {\n            cont.resumeWith(Result.failure(Failure))\n        }\n    }\n}\n\nval result = `for` {\n    val i = bind(Optional.of(1))\n    val j = bind(Optional.empty<Int>())\n\n    yield(i + j)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208191,"user_id":null,"body":"@file:Suppress(\"PACKAGE_CANNOT_BE_IMPORTED\")\n\npackage solution\n\nimport java.util.Optional\nimport kotlin.coroutines\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED\nimport kotlin.coroutines.intrinsics.createCoroutineUnintercepted\nimport kotlin.coroutines.intrinsics.suspendCoroutineUninterceptedOrReturn\n\nsealed interface Result<out T>\nobject Null:Result<Any>\ndata class Ready<T>(val result:T):Result<T>\nenum class ExecState{\n    STOPPED,\n    READY,\n    DONE,\n    FAILED\n}\n\nclass ForComprehension<T>:Iterator<T>,Continuation<Unit>{\n    var state = ExecState.STOPPED\n    var nextStep:Continuation<Unit>? = null\n    var result:T? = null\n    override fun hasNext(): Boolean {\n        while(true){\n            when(state){\n                ExecState.STOPPED -> {}\n                ExecState.READY -> return true\n                ExecState.DONE -> return false\n                else -> TODO()\n            }\n            state = ExecState.FAILED\n            val step = nextStep!!\n            nextStep = null\n            step.resume(Unit)\n        }\n    }\n\n    override fun next(): T =\n        when(state){\n            ExecState.STOPPED -> if(!hasNext()) TODO() else next()\n            ExecState.READY -> {\n                state = ExecState.STOPPED\n                @Suppress(\"UNCHECKED_CAST\")\n                val res = result as T\n                result = null\n                res\n            }\n            else -> TODO()\n        }\n\n\n    override val context: CoroutineContext\n        get() = EmptyCoroutineContext\n\n    override fun resumeWith(result: kotlin.Result<Unit>) {\n        result.getOrThrow()\n        state = ExecState.DONE\n    }\n\n    suspend fun yield(value:T){\n        result = value\n        state = ExecState.READY\n        return suspendCoroutineUninterceptedOrReturn{\n            nextStep = it\n            COROUTINE_SUSPENDED\n        }\n    }\n\n    suspend fun<T> bind(ma:Optional<T>):T = when{\n            ma.isPresent -> {\n                state = ExecState.READY\n                ma.get()\n            }\n            else -> {\n                state = ExecState.DONE\n                nextStep = null\n                result = null\n                suspendCoroutineUninterceptedOrReturn {\n                    COROUTINE_SUSPENDED\n                }\n            }\n        }\n    }\n\n\n\n\n\nfun <T> `for`(lambda: suspend ForComprehension<T>.() -> Unit): Optional<T> {\n    val impl = ForComprehension<T>()\n    impl.nextStep = lambda.createCoroutineUnintercepted(impl,impl)\n    var solution:T? = null\n    for(elem in impl){\n        solution = elem\n    }\n    return when(solution){\n        null -> Optional.empty<T>()\n        else -> Optional.of(solution)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5a726f16373c2ee6c60000db":[{"id":208192,"user_id":null,"body":"object PasswordHider {\n  fun hidePasswordFromConnection(url: String): String {\n    return Regex(\"(?<=password=)[^&]*\").replace(url) { \"*\".repeat(it.value.length) }\n  }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208193,"user_id":null,"body":"object PasswordHider {\n    fun hidePasswordFromConnection(urlString: String): String {\n        val regex = Regex(\"password=([a-zA-Z_0-9'$!]+)\")\n        val find = regex.find(urlString)\n        return urlString.replace(regex, \"password=${\"*\".repeat(find?.groupValues?.get(1)?.count() ?: 0)}\")\n    }\n}\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208194,"user_id":null,"body":"object PasswordHider {\n  fun hidePasswordFromConnection(urlString: String): String {\n      val pwd = \"password=\"\n      var position = urlString.indexOf(pwd) + pwd.length\n      var str = urlString.toCharArray()\n      while (position < str.size) {\n          if (str[position] == '&') break\n          str[position] = '*'\n          position++\n      } \n      var ret = str.joinToString(\"\")\n    return ret\n  }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208195,"user_id":null,"body":"import java.util.regex.*\n\nobject PasswordHider {\n  fun hidePasswordFromConnection(urlString: String) =\n    (Pattern.compile(\"password=([^&]*)|$\").matcher(urlString)).run { find()\n        this.group(1).let{ urlString.replace(it, \"*\".repeat(it.length)) }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208196,"user_id":null,"body":"object PasswordHider {\n\n  fun hidePasswordFromConnection(urlString: String): String {\n  val (url, query) = urlString.split(\"?\")\n  val parsedQuery = hidePasswordFromQuery(query)\n  \n  return \"$url?$parsedQuery\"\n  }\n  \n  private fun hidePasswordFromQuery(query: String): String {\n    val queryParams = query.split(\"&\")\n    \n   return queryParams.map{ queryParam ->\n      if (queryParam.startsWith(\"password=\")) {\n          val password = queryParam.split(\"=\")[1]\n          val protectedPassword =\"*\".repeat(password.length)\n          \"password=$protectedPassword\"      \n      } else {\n        queryParam\n      }\n      \n    }.joinToString(\"&\")\n\n  }\n  \n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208197,"user_id":null,"body":"object PasswordHider {\n    fun hidePasswordFromConnection(urlString: String)=\n        with(urlString.substringAfter(\"password=\").substringBefore(\"&\")) {\n            urlString.replace(this, this.map { '*' }.joinToString(\"\"))\n        }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208198,"user_id":null,"body":"object PasswordHider {\n  fun hidePasswordFromConnection(urlString: String): String {\n      var password = urlString.split(\"password=\")[1]\n      var hiddenUrlString = urlString.split(\"password=\")[0] + \"password=\"\n      if (password.contains(\"&\")) {\n          password = password.split(\"&\")[0] \n           repeat(password.length) {hiddenUrlString += \"*\"} \n           hiddenUrlString += \"&\" + urlString.split(\"password=\")[1].split(\"&\")[1]\n      } else {\n          repeat(password.length) {hiddenUrlString += \"*\"}\n      }\n      return hiddenUrlString\n      \n  }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208199,"user_id":null,"body":"object PasswordHider {\n  fun hidePasswordFromConnection(urlString: String): String {\n     val index = urlString.substringAfter(\"password=\").substringBefore('&')\n    val numberOfStars = index.length\n    val result = urlString.replace(index,\"*\".repeat(numberOfStars))\n    return result\n  }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208200,"user_id":null,"body":"object PasswordHider {\n  fun hidePasswordFromConnection(urlString: String): String {\n    val list = urlString.split(\"password=\",\"&user\")\n    return urlString.replace(list[1],\"*\".repeat(list[1].length))\n  }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208201,"user_id":null,"body":"object PasswordHider {\n  fun hidePasswordFromConnection(urlString: String): String {\n    val password = urlString.substringAfterLast(\"password=\").substringBefore(\"&\")\n    return urlString.replace(password, \"*\".repeat(password.length))\n  }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5a8cacb2d5261f53ec0031f3":[{"id":208202,"user_id":null,"body":"package kata\n\nobject Ziggurat {\n    fun rideOfFortune(artifact: Array<String>, explorers: IntArray): Array<Pair<Int, Int>?> {\n        val newArtifact = mutableListOf<CharArray>()\n        var k = 0\n        for (i in artifact) {\n            newArtifact += i.toCharArray()\n        }\n        var array = Array<Pair<Int, Int>?>(explorers.size) {null}\n        for (i in explorers) {\n            var x = 0\n            var y = i\n            var north = false\n            var east = true\n            var south = false\n            var west = false\n\n            while (true) {\n                if (newArtifact[y][x] == 'A') {\n                    when {\n                        north -> {\n                            west = true\n                            north = false\n                        }\n                        east -> {\n                            south = true\n                            east = false\n                        }\n                        south -> {\n                            east = true\n                            south = false\n                        }\n                        west -> {\n                            north = true\n                            west = false\n                        }\n                    }\n                    newArtifact[y][x] = 'B'\n                } else if (newArtifact[y][x] == 'B') {\n                    when {\n                        north -> {\n                            east = true\n                            north = false\n                        }\n                        east -> {\n                            north = true\n                            east = false\n                        }\n                        south -> {\n                            west = true\n                            south = false\n                        }\n                        west -> {\n                            south = true\n                            west = false\n                        }\n                    }\n                    newArtifact[y][x] = 'A'\n                }\n\n                if (north) y--\n                if (east) x++\n                if (south) y++\n                if (west) x--\n\n                if (x == artifact[0].length) {\n\n                    array[k] = Pair(y, x - 1)\n                    k++\n                    break\n                }\n                if (y < 0) {\n                    array[k] = Pair(y + 1, x)\n                    k++\n                    break\n                }\n                if (y == artifact.size ){\n                    array[k] = Pair(y - 1, x)\n                    k++\n                    break\n                }\n                if (x < 0) {\n                    k++\n                    break\n                }\n            }\n        }\n        return array\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208203,"user_id":null,"body":"package kata\n\nobject Ziggurat {\n\n    fun rideOfFortune(artifact: Array<String>, explorers: IntArray): Array<Pair<Int, Int>?> {\n        val solution = mutableListOf<Pair<Int, Int>?>()\n\n        explorers.forEach { i ->\n            var pos = Position(0, i)\n            var d = Direction.EAST\n            while (true) {\n                d = updateDirection(artifact, pos, d)\n                if (pos.isExit(d)) {\n                    solution.add(null)\n                    break;\n                } else if (pos.isPortal(artifact.size, d)) {\n                    val sol = Pair(pos.y, pos.x)\n                    solution.add(sol)\n                    break;\n                }\n                val newPos = pos.applyMove(d)\n                pos = newPos\n            }\n        }\n        return solution.toTypedArray()\n    }\n\n    fun String.replaceChar(ch: Char, index: Int): String = this.substring(0, index) + ch + this.substring(index + 1)\n\n    enum class Direction { WEST, EAST, NORTH, SOUTH }\n    enum class SwitchState { A, B }\n\n    data class Position(val x: Int = 0, val y: Int = 0) {\n        fun isExit(d: Direction) = (x == 0 && d == Direction.WEST)\n        fun isPortal(size: Int, d: Direction) = when (d) {\n            Direction.EAST -> x == size - 1\n            Direction.NORTH -> y == 0\n            Direction.SOUTH -> y == size - 1\n            else -> false\n        }\n\n        fun applyMove(direction: Direction) = when (direction) {\n            Direction.WEST -> this.copy(x = x - 1)\n            Direction.EAST -> this.copy(x = x + 1)\n            Direction.NORTH -> this.copy(y = y - 1)\n            Direction.SOUTH -> this.copy(y = y + 1)\n        }\n    }\n    \n    private fun updateDirection(artifact: Array<String>, pos: Position, d: Direction): Direction {\n        var newDirection = d\n        if (artifact[pos.y][pos.x] == 'A') {\n            newDirection = applyTurn(SwitchState.A, newDirection)\n            artifact[pos.y] = artifact[pos.y].replaceChar('B', pos.x)\n        } else if (artifact[pos.y][pos.x] == 'B') {\n            newDirection = applyTurn(SwitchState.B, newDirection)\n            artifact[pos.y] = artifact[pos.y].replaceChar('A', pos.x)\n        }\n        return newDirection\n    }\n\n    private fun applyTurn(state: SwitchState, direction: Direction) = when (direction) {\n        Direction.WEST -> if (state == SwitchState.A) Direction.NORTH else Direction.SOUTH\n        Direction.EAST -> if (state == SwitchState.A) Direction.SOUTH else Direction.NORTH\n        Direction.NORTH -> if (state == SwitchState.A) Direction.WEST else Direction.EAST\n        Direction.SOUTH -> if (state == SwitchState.A) Direction.EAST else Direction.WEST\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208204,"user_id":null,"body":"package kata\n\nobject Ziggurat {\n        enum class Direction {\n        NORTH, SOUTH, WEST, EAST\n    }\n\n    fun rideOfFortune(artifact:Array<String>,explorers:IntArray): Array<Pair<Int,Int>?> {\n        var grd= mutableListOf<MutableList<Char>>()\n        var ans = mutableListOf<Pair<Int,Int>?>()\n\n        artifact.forEachIndexed { index, s -> grd.add(index, s.toMutableList() )  }\n\n        explorers.forEach {\n            var row= 0\n            var col=it\n            var dir =Direction.EAST\n\n            do {\n                when (grd[col][row]) {\n                    'A' -> {\n                        dir = when (dir) {\n                            Direction.EAST -> Direction.SOUTH\n                            Direction.WEST -> Direction.NORTH\n                            Direction.SOUTH -> Direction.EAST\n                            Direction.NORTH -> Direction.WEST\n                        }\n                        grd[col][row]='B'\n                    }\n                    'B' -> {\n                        dir = when (dir) {\n                            Direction.EAST -> Direction.NORTH\n                            Direction.WEST -> Direction.SOUTH\n                            Direction.SOUTH -> Direction.WEST\n                            Direction.NORTH -> Direction.EAST\n                        }\n                        grd[col][row]='A'\n                    }\n                }\n\n                when (dir) {\n                    Direction.EAST -> row++\n                    Direction.WEST -> row--\n                    Direction.SOUTH -> col++\n                    Direction.NORTH -> col--\n                }\n\n            } while (!(col>=grd.size||col<0||row>=grd[0].size||row<0))\n            row=row.coerceIn(0,grd.size-1)\n            if(dir==Direction.WEST) ans.add( null )\n            else ans.add(col.coerceIn(0,grd.size-1) to row.coerceIn(0,grd.size-1))\n\n        }\n        return ans.toTypedArray()\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208205,"user_id":null,"body":"import kotlin.math.max\nimport kotlin.math.min\n\nobject Ziggurat {\n    fun rideOfFortune(artifact:Array<String>, explorers:IntArray): Array<Pair<Int,Int>?> {\n        val board = Board(artifact)\n        return explorers.map { board.enter(Explorer(0, it, Direction.East))}.map { when {\n            it.x == -1 -> null\n            else -> Pair(min(max(it.y, 0), board.maxY), min(it.x, board.maxX))\n        }}.toTypedArray()\n    }\n\n    class Board(artifact: Array<String>) {\n        val data = artifact.map { it.map { Pather(it) }}\n        val maxX = data[0].size - 1\n        val maxY = data.size - 1\n\n        fun enter(explorer: Explorer): Explorer {\n            try {\n                while (true) {\n                    data[explorer.y][explorer.x].enter(explorer)\n                }\n            }\n            catch (e: Exception) {\n                return explorer\n            }\n        }\n    }\n\n    class Pather(raw: Char) {\n        enum class State {\n            Blank,\n            A,\n            B\n        }\n\n        var state = when (raw) {\n            ' ' -> State.Blank\n            'A' -> State.A\n            'B' -> State.B\n            else -> throw Exception(\"Invalid artifact!\")\n        }\n\n        fun enter(explorer: Explorer) {\n            explorer.direction = when (state) {\n                State.Blank -> explorer.direction\n                State.A -> when (explorer.direction) {\n                    Direction.North -> Direction.West\n                    Direction.East -> Direction.South\n                    Direction.South -> Direction.East\n                    Direction.West -> Direction.North\n                }\n                State.B -> when (explorer.direction) {\n                    Direction.North -> Direction.East\n                    Direction.West -> Direction.South\n                    Direction.South -> Direction.West\n                    Direction.East -> Direction.North\n                }\n            }\n\n            state = when (state) {\n                State.A -> State.B\n                State.B -> State.A\n                State.Blank -> State.Blank\n            }\n\n            explorer.move()\n        }\n    }\n\n    enum class Direction {\n        North,\n        East,\n        West,\n        South\n    }\n\n    class Explorer(var x: Int, var y: Int, var direction: Direction) {\n        fun move() {\n            when (direction) {\n                Direction.North -> y -= 1\n                Direction.South -> y += 1\n                Direction.West -> x -= 1\n                Direction.East -> x += 1\n            }\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208206,"user_id":null,"body":"package kata\n\nimport kata.Direction.*\nimport kata.SwitchState.*\n\nobject Ziggurat {\n    fun rideOfFortune(artifact: Array<String>, explorers: IntArray): Array<Pair<Int, Int>?> {\n        val field = artifact.map {\n            it.map {\n                when {\n                    it == 'A' -> A\n                    it == 'B' -> B\n                    else -> null\n                }\n            }.toMutableList()\n        }\n        return explorers.map { navigateField(it, field) }.toTypedArray()\n    }\n\n    private fun navigateField(enteringPoint: Int, field: List<MutableList<SwitchState?>>): Pair<Int, Int>? {\n        var x = 0\n        var y = enteringPoint\n        var direction = E\n        var startX = x\n        var startY = y\n        while (x >= 0 && x < field.size && y >= 0 && y < field.size) {\n            startX = x\n            startY = y\n            if (field[y][x] != null) {\n                when (field[y][x]) {\n                    A -> {\n                        direction = when (direction) {\n                            W -> N\n                            E -> S\n                            S -> E\n                            N -> W\n                        }\n                        field[y][x] = B\n                    }\n                    B -> {\n                        direction = when (direction) {\n                            W -> S\n                            S -> W\n                            N -> E\n                            E -> N\n                        }\n                        field[y][x] = A\n                    }\n                }\n            }\n            when (direction) {\n                N -> y--\n                E -> x++\n                S -> y++\n                W -> x--\n            }\n        }\n        return if (x < 0) {\n            null\n        } else {\n            startY to startX\n        }\n    }\n}\n\nenum class SwitchState {\n    A, B\n}\n\nenum class Direction {\n    N, E, S, W\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208207,"user_id":null,"body":"package kata\n\nobject Ziggurat {\n\n    private fun gridImport(artifact:Array<String>): Array<Array<Char>> {\n        val grid = Array(artifact.size) {\n            Array(artifact.size) {'n'}\n        }\n\n        for (row in 0 until artifact.size) {\n            for (cell in 0 until artifact[0].length) {\n                grid[row][cell] = when (artifact[row][cell]) {\n                    ' ' -> 'n'\n                    else -> artifact[row][cell]\n                }\n            }\n        }\n\n        return grid\n    }\n\n    \/\/directions: 0=North; 1=East: 2=South; 3=West\n    val ASwitchDirs = mapOf(0 to 3, 1 to 2, 2 to 1, 3 to 0)\n\n    fun rideOfFortune(artifact:Array<String>,explorers:IntArray): Array<Pair<Int,Int>?> {\n        val grid = gridImport(artifact)\n        val exits = mutableListOf<Pair<Int, Int>?>()\n\n        for (guy in explorers) {\n            var position = Pair(guy, 0)\n            var direction = 1\n\n            do {\n                direction = when (grid[position.first][position.second]) {\n                    'A' -> {\n                        grid[position.first][position.second] = 'B'\n                        ASwitchDirs[direction]!!\n                    }\n                    'B' -> {\n                        grid[position.first][position.second] = 'A'\n                        (ASwitchDirs[direction]!! + 2) % 4\n                    }\n                    else -> direction\n                }\n\n                position = when (direction) {\n                    0 -> (position.first - 1) to position.second\n                    2 -> (position.first + 1) to position.second\n                    1 -> position.first to (position.second + 1)\n                    else -> position.first to (position.second - 1)\n                }\n\n            } while (position.first in grid.indices && position.second in grid[0].indices)\n\n            exits.add(\n                if (position.second < 0)\n                    null\n                else\n                    position.first.coerceIn(grid.indices) to position.second.coerceIn(grid[0].indices)\n            )\n        }\n\n        return exits.toTypedArray()\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208208,"user_id":470,"body":"package kata\n\nobject Ziggurat {\n\tfun rideOfFortune(r:Array<String>,r2:IntArray): Array<Pair<Int,Int>?> {\n\t\tval ln = r.size\n\t\tval codex = arrayOf(\/\/ N:0, E:1, S:2, W:3\n\t\t\tintArrayOf(3,2,1,0),\/\/ A\n\t\t\tintArrayOf(1,0,3,2))\/\/ B\n\t\tval tome = mutableMapOf<Pair<Int,Int>,Int>()\/\/ (x,y): 0 (A) or 1 (B)\n\t\tval ix = mutableMapOf<Pair<Int,Int>,Array<Pair<Int,Int>?>>()\n\t\tval res = arrayOfNulls<Pair<Int,Int>>(r2.size)\n\t\tval vertNodes = arrayOfNulls<Pair<Int,Int>>(ln)\n\t\tval firstSwitch = arrayOfNulls<Pair<Int,Int>>(ln)\n\t\tvar xPrev: Pair<Int,Int>?\n\t\tvar pos: Pair<Int,Int>?\n\t\tvar dpath: Int\n\t\t\n\t\tfor ((i,rr) in r.withIndex()){\n\t\t\txPrev = null\n\t\t\tfor ((j,v) in rr.withIndex()){\n\t\t\t\tif (v in \"AB\"){\n\t\t\t\t\tvar xy = i to j\n\t\t\t\t\ttome.put(xy,if (v == 'A') 0 else 1)\n\t\t\t\t\tix.put(xy,arrayOfNulls<Pair<Int,Int>>(4))\n\t\t\t\t\tif (xPrev != null){\n\t\t\t\t\t\tix[xy]!![3] = xPrev\n\t\t\t\t\t\tix[xPrev]!![1] = xy }\n\t\t\t\t\telse { firstSwitch[i] = xy }\n\t\t\t\t\tif (vertNodes[j] != null){\n\t\t\t\t\t\tix[xy]!![0] = vertNodes[j]\n\t\t\t\t\t\tix[vertNodes[j]]!![2] = xy}\n\t\t\t\t\tvertNodes[j] = xy\n\t\t\t\t\txPrev = xy }}}\n\t\t\n\t\tfor ((i,n) in r2.withIndex()){\n\t\t\tpos = firstSwitch[n]\n\t\t\tdpath = 1\n\t\t\txPrev = Pair(n,0)\n\t\t\twhile (pos != null){\n\t\t\t\tval switchD = tome[pos]!!\n\t\t\t\txPrev = pos\n\t\t\t\ttome[pos] = switchD xor 1\n\t\t\t\tdpath = codex[switchD][dpath]\n\t\t\t\tpos = ix[pos]!![dpath]}\n\t\t\tres[i] = findExit(dpath,ln,xPrev!!)}\n\t\t\n\t\treturn res\n\t}\n\t\n\tprivate fun findExit(dpath:Int,ln:Int,xPrev:Pair<Int,Int>): Pair<Int,Int>? {\n\t\treturn when (dpath) {\n\t\t\t0 -> 0 to xPrev.second\n\t\t\t1 -> xPrev.first to ln-1\n\t\t\t2 -> ln-1 to xPrev.second\n\t\t\t3 -> null\n\t\t\telse -> throw Exception(\"**record scratch**...you're probably wondering how I ended up in this situation\")}\n\t}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5a90c9ecb171012b47000077":[{"id":208209,"user_id":null,"body":"fun testIt(a: Int, b: Int): Int {\n    val sum1 = a.toString().sumBy { Character.getNumericValue(it) }\n    val sum2 = b.toString().sumBy { Character.getNumericValue(it) }\n    return sum1 * sum2\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208210,"user_id":null,"body":"fun testIt(a: Int, b: Int): Int = a.getSumOfDigits() * b.getSumOfDigits()\n\nfun Int.getSumOfDigits() = this.toString().sumBy(Character::getNumericValue)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208211,"user_id":211,"body":"fun digitSum(n: Int): Int {\n  var r = 0\n  var d = n\n  while (d > 0) {\n    r += d % 10\n    d \/= 10\n  }\n  return r\n}\n\nfun testIt(a: Int, b: Int): Int {\n  return digitSum(a) * digitSum(b)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208212,"user_id":null,"body":"fun testIt(a : Int,b : Int) : Int {\n   var numA: Int = 0\n    a.toString().forEach {\n       numA += it.toString().toInt()\n   }\n   var numB: Int = 0\n    b.toString().forEach {\n       numB += it.toString().toInt()\n   }\n\n    return numA * numB \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208213,"user_id":53,"body":"fun testIt(x : Int, y : Int) : Int {\n  var m = 0\n  var n = 0\n  var a = x\n  var b = y\n  while (a > 0) {\n    var i = a % 10\n    m = m + i\n    a = a \/ 10\n  }\n  while (b > 0) {\n    var i = b % 10\n    n = n + i\n    b = b \/ 10\n  }\n  return m * n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208214,"user_id":1170,"body":"fun testIt(a: Int, b: Int) = a.toString().map { it.toString().toInt() }.sum() *\n        b.toString().map { it.toString().toInt() }.sum()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208215,"user_id":null,"body":"fun testIt(a : Int,b : Int) : Int {\n  val arrayA = createArray(a)\n  val arrayB = createArray(b)\n  var sum = 0\n    for (i in arrayA){\n        for (j in arrayB){\n            sum += i * j\n        }\n    }\n    return sum\n}\n\nfun createArray(num: Int) : ArrayList<Int>{\n    val arrayList: ArrayList<Int> = arrayListOf()\n    var numOne = num\n    while (numOne != 0){\n        arrayList.add(numOne % 10)\n        numOne \/= 10\n    }\n    return arrayList\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208216,"user_id":null,"body":"fun testIt(a : Int,b : Int) : Int {\n    var aSum = 0\n    var bSum =0\n    a.toString().forEach{aSum+=it.toString().toInt() }\n    b.toString().forEach{bSum+=it.toString().toInt() }\n    return aSum * bSum\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208217,"user_id":null,"body":"fun testIt(a: Int, b: Int): Int = a.sumDigits() * b.sumDigits()\n\nprivate fun Int.sumDigits(): Int = this.toString().map { it.toString().toInt() }.reduce { s, c -> s + c }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208218,"user_id":null,"body":"fun testIt(a : Int,b : Int) : Int {\n    \n    var numberA = reduceNumber(a)\n\n    var numberB = reduceNumber(b)\n    \n    return numberA*numberB\n}\n\n\nfun reduceNumber(value:Int): Int{\n    var result = 0\n    var originalNum = value\n    \n    while (originalNum > 0){\n        result += originalNum%10\n        originalNum = Math.floor(originalNum.div(10).toDouble()).toInt()\n    }\n    \n    return result\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5aa736a455f906981800360d":[{"id":208219,"user_id":1267,"body":"fun feast(beast: String, dish: String) = beast.first() == dish.first() && beast.last() == dish.last()","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208220,"user_id":null,"body":"fun feast(beast: String, dish: String): Boolean {\n  if( (beast.get(0) == dish.get(0)) && (beast.get(beast.length-1) == dish.get(dish.length-1))){\n    return true;\n  }\n  return false;\n}","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208221,"user_id":null,"body":"fun feast(beast: String, dish: String): Boolean {\n\/\/your function here\n    return if(beast.take(1)==dish.take(1) && beast.get(beast.lastIndex) == dish.get(dish.lastIndex)) true else false\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208222,"user_id":null,"body":"fun feast(beast: String, dish: String) = \"${beast[0]}${beast.last()}\" == \"${dish[0]}${dish.last()}\"","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208223,"user_id":null,"body":"fun feast(beast: String, dish: String) = beast.take(1) + beast.takeLast(1) == dish.take(1) + dish.takeLast(1)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208224,"user_id":null,"body":"fun feast(beast: String, dish: String) = beast.startEnd() == dish.startEnd()\n\nfun String.startEnd(): Pair<Char, Char> {\n    return Pair(this[0], this[lastIndex])\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208225,"user_id":null,"body":"fun feast(beast: String, dish: String): Boolean {\n   for(i in 0..9){\n        if(beast.contains(i.toString())){\n            return false\n        }\n    }\n\n    val beastFirstAndLast=\"${beast[0]}${beast.last()}\"\n    val dishFirstAndLast=\"${dish[0]}${dish.last()}\"\n\n    return beastFirstAndLast==dishFirstAndLast\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208226,"user_id":null,"body":"fun feast(beast: String, dish: String): Boolean {\n\/\/your function here\n      return beast.startsWith(dish.first()) && beast.endsWith(dish.last())\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208227,"user_id":null,"body":"fun feast(beast: String, dish: String): Boolean =\n  beast.first() == dish.first() && beast.last() == dish.last()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208228,"user_id":null,"body":"fun feast(beast: String, dish: String): Boolean {\n    return beast.takeLast(1) == dish.takeLast(1) && beast.take(1) == dish.take(1)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5ab6538b379d20ad880000ab":[{"id":208229,"user_id":null,"body":"fun area_or_perimeter(l: Int, w: Int) = if (l == w) l * w else 2 * (l + w)\n","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208230,"user_id":null,"body":"object Solution {\n  fun area_or_perimeter(l:Int, w:Int): Int {\n      return when {\n          w == l -> w * l\n          else -> (w + l) * 2\n      }\n  }\n\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208231,"user_id":null,"body":"object Solution {\n  fun area_or_perimeter(l:Int, w:Int):Int {\n    return when {\n        l == w -> l * w\n        else -> 2 * (l + w)\n    }\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208232,"user_id":null,"body":"object Solution {\n  fun area_or_perimeter(l: Int, w: Int): Int {\n    return if (l == w) Math.pow(l.toDouble(), 2.0).toInt() else 2*(l+w)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208233,"user_id":null,"body":"object Solution {\n  fun area_or_perimeter(l:Int, w:Int):Int {\n    \/\/ code away...\n      var p = 2*(l+w)\n      var a = l*w\n      \n      if(l==w){\n          return a\n      } else{return p}\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208234,"user_id":null,"body":"object Solution {\n  \n  fun area_or_perimeter(l: Int, w: Int) = if (l == w) l * w else l * 2 + w * 2\n  \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208235,"user_id":null,"body":"object Solution {\n  fun area_or_perimeter(l:Int, w:Int):Int {\n  if(l == w)\n  return l*w\n  \n  else \n  return l+l+w+w\n  \n    \/\/ code away...\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208236,"user_id":null,"body":"object Solution {\n  fun area_or_perimeter(l:Int, w:Int):Int =\n      if( l == w ) l*w else 2*(l+w)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208237,"user_id":null,"body":"object Solution {\n  fun area_or_perimeter(l:Int, w:Int):Int {\n    if (l == w){\n    return l*w\n    }\n    else{\n    return (l+w)*2\n    }\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208238,"user_id":null,"body":"object Solution {\n  fun area_or_perimeter(l:Int, w:Int):Int {\n    if(l == w) {\n        var s_square = Math.pow(l.toDouble(), 2.0)\n        println(\"Square area is S = $s_square\")\n        return s_square.toInt()\n    } else {\n        var p_rect = (l + w) * 2\n        println(\"Rectangle perimeter is P = $p_rect\")\n        return p_rect\n    }\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5aba780a6a176b029800041c":[{"id":208239,"user_id":null,"body":"fun maxMultiple(d: Int, b: Int): Int = (b downTo d).first { it % d == 0 }\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208240,"user_id":null,"body":"fun maxMultiple(d: Int, b: Int) = b \/ d * d","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208241,"user_id":null,"body":"fun maxMultiple(d: Int, b: Int): Int {\n    for (i in b downTo 0) if (i % d == 0) return i\n    return 0\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208242,"user_id":null,"body":"fun maxMultiple(d: Int, b: Int) = b-(b%d)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208243,"user_id":null,"body":"fun maxMultiple(d: Int, b: Int): Int {\nvar i = b\ngenerateSequence{i--}\n    .forEach{\n        if(it%d == 0){\n            return it\n        }\n    }\nreturn 42\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208244,"user_id":null,"body":"fun maxMultiple(divisor: Int, bound: Int): Int = (bound downTo 0).first { it % divisor == 0 }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208245,"user_id":null,"body":"fun maxMultiple(d: Int, b: Int): Int {\n    b.downTo(1).forEach { i -> if (i.rem(d) == 0) return i}\n    return 1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208246,"user_id":null,"body":"fun maxMultiple(d: Int, b: Int): Int {\n     for(elem in b downTo 1){\n         if(elem%d == 0){\n             return elem\n         }\n     }\n     return 0\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208247,"user_id":null,"body":"fun maxMultiple(d: Int, b: Int): Int = b\/d*d","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208248,"user_id":527,"body":"fun maxMultiple(d: Int, b: Int): Int {\n    return b - b % d\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5abab55b20746bc32e000008":[{"id":208249,"user_id":null,"body":"package kata\n\nimport kotlin.math.abs\nimport kotlin.math.max\n\nclass Blobservation(height: Int, width: Int = height) {\n    \/\/ if invalid arguments are given to either `populate` or `move` methods, throw an IllegalArgumentException\n    private val h = height\n    private val w = width\n    private var curBlobs = mutableMapOf<Pair<Int, Int>, Blob>()\n    private val ds = listOf<Pair<Int, Int>>(\n        Pair(-1, 0),\n        Pair(-1, 1),\n        Pair(0, 1), Pair(1, 1),\n        Pair(1, 0), Pair(1, -1),\n        Pair(0, -1), Pair(-1, -1)\n    )\n\n    fun populate(blobs: Array<Blob>) {\n        val copiedBlobs = curBlobs.toMutableMap()\n\n        for (blob in blobs) {\n            if (blob.x < 0 || blob.x >= this.h || blob.y < 0 || blob.y >= this.w || blob.size < 1 || blob.size > 20) {\n                throw IllegalArgumentException()\n            }\n\n            if (copiedBlobs.containsKey(Pair(blob.x, blob.y))){\n                copiedBlobs[Pair(blob.x, blob.y)]!!.size += blob.size\n            }else{\n                copiedBlobs[Pair(blob.x, blob.y)] = Blob(blob.x, blob.y, blob.size)\n            }\n        }\n        this.curBlobs = copiedBlobs\n    }\n\n    fun getTargets(x: Int, y: Int): List<Blob> {\n        return curBlobs.values.filter { it.size < curBlobs[Pair(x, y)]!!.size }\n    }\n\n    fun getDistance(a: Blob, b: Blob): Int {\n        return max(abs(a.x - b.x), abs(a.y - b.y))\n    }\n\n    fun getDirection(a: Blob, b: Blob): Pair<Int, Int> {\n        val f = (if (a.x < b.x) 1 else 0) - (if (a.x > b.x) 1 else 0)\n        val s = (if (a.y < b.y) 1 else 0) - (if (a.y > b.y) 1 else 0)\n\n        return Pair(f, s)\n    }\n\n    fun getHour(a: Blob, b: Blob): Int {\n        return this.ds.indexOf(getDirection(a, b))\n    }\n\n    fun moveOneStep(a: Blob, b: Blob): Pair<Int, Int> {\n        val d = getDirection(a, b)\n\n        return Pair(a.x + d.first, a.y + d.second)\n    }\n\n    fun customComparator(origin: Blob, a: Blob, b: Blob): Int {\n        return if (getDistance(origin, a) != getDistance(origin, b)) {\n            getDistance(origin, a).compareTo(getDistance(origin, b))\n        } else if (a.size != b.size) {\n            b.size.compareTo(a.size)\n        } else {\n            getHour(origin, a).compareTo(getHour(origin, b))\n        }\n    }\n\n    fun move(n: Int = 1) {\n\n\n        if (n < 1) {\n            throw IllegalArgumentException()\n        }\n\n        for (t in 0 until n) {\n            val copiedBlobs = mutableMapOf<Pair<Int, Int>, Blob>()\n\n            for (a in curBlobs.values.sortedWith(compareBy({ it.x }, { it.y }))) {\n                val targets =\n                    getTargets(a.x, a.y).sortedWith(compareBy({ getDistance(a, it) }, { -it.size }, { getHour(a, it) }))\n                val nextPair = if (targets.isNotEmpty()) moveOneStep(a, targets[0]) else Pair(a.x, a.y)\n\n                if (!copiedBlobs.containsKey(nextPair)){\n                    copiedBlobs[nextPair] = Blob(nextPair.first, nextPair.second, a.size)\n                }else{\n                    copiedBlobs[nextPair]!!.size += a.size\n                }\n\n            }\n\n            if (copiedBlobs == curBlobs) {\n                break\n            }\n            curBlobs = copiedBlobs\n        }\n\n\n    }\n\n    fun printState(): List<IntArray> {\n        val res = mutableListOf<IntArray>()\n\n        for (a in curBlobs.values.sortedWith(compareBy({ it.x }, { it.y }))) {\n            res.add(intArrayOf(a.x, a.y, a.size))\n        }\n        return res.toList()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208250,"user_id":null,"body":"package kata\n\nimport kotlin.math.abs\nimport kotlin.math.atan2\nimport kotlin.math.sign\n\nclass Blobservation(val height: Int, val width: Int = height) {\n    var blobList = mutableListOf<Blob>()\n\n    fun populate(blobs: Array<Blob>) {\n        require(blobs.all { (it.x in 0.until(height)) && (it.y in 0.until(width)) && (it.size in 1.rangeTo(20)) })\n        blobList.addAll(blobs)\n        mergeBlobs()\n    }\n\n    fun move(n: Int = 1) {\n        require(n > 0)\n        (1..n).forEach { _ ->\n            blobList.associate { it to getTarget(it).let { Pair(it.x, it.y) } }.forEach { (blob, target) ->\n                blob.x += (target.first - blob.x).sign\n                blob.y += (target.second - blob.y).sign\n            }\n            mergeBlobs()\n        }\n    }\n\n    fun printState(): List<IntArray> = blobList.sortedWith(compareBy({ it.x }, { it.y }, { it.size }))\n        .map { arrayOf(it.x, it.y, it.size).toIntArray() }.toList()\n\n    private fun mergeBlobs() {\n        blobList =\n            blobList.groupBy { Pair(it.x, it.y) }.map { (k, v) -> Blob(k.first, k.second, v.map { it.size }.sum()) }\n                .toMutableList()\n    }\n\n    private fun getTarget(blob: Blob): Blob {\n        return blobList.filter { it.size < blob.size }.sortedWith(\n            compareBy({ maxOf(abs(it.x - blob.x), abs(it.y - blob.y)) }, { -it.size }, {\n                \/\/ adjust so that highest priority position evaluates to -PI instead of PI\n                atan2((blob.y - it.y - 0.0000001), (it.x - blob.x).toDouble())\n            })\n        ).firstOrNull() ?: blob\n    }\n\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208251,"user_id":null,"body":"package kata\n\nimport kotlin.math.absoluteValue\n\nclass Blobservation(val height: Int, val width: Int = height) {\n    private val blobsMapHistory = mutableListOf<Map<Int, Int>>()\n    private var blobsMap: Map<Int, Int>\n        get() = blobsMapHistory.lastOrNull() ?: sortedMapOf()\n        set(value) { blobsMapHistory.add(value) }\n\n    \/\/ if invalid arguments are given to either `populate` or `move` methods, throw an IllegalArgumentException\n\n    fun populate(blobs: Array<Blob>) {\n        require(blobs.all { it.isValid() })\n\n        val newBlobsMap = blobsMap.toSortedMap()\n        for (blob in blobs) {\n            val pos = pos(blob.x, blob.y)\n            val size = newBlobsMap.getOrDefault(pos, 0) + blob.size\n            newBlobsMap[pos] = size\n        }\n        blobsMap = newBlobsMap\n    }\n\n    tailrec fun move(n: Int = 1) {\n        require(n >= 1)\n\n        val newBlobsMap = sortedMapOf<Int, Int>()\n        for ((pos, size) in blobsMap) {\n            val newPos = newPos(pos, size)\n            val newSize = newBlobsMap.getOrDefault(newPos, 0) + size\n            newBlobsMap[newPos] = newSize\n        }\n        blobsMap = newBlobsMap\n\n        if (n > 1) move(n - 1)\n    }\n\n    fun printState(): List<IntArray> =\n        blobsMap.map { (pos, size) -> intArrayOf(x(pos), y(pos), size) }\n\n    private fun Blob.isValid() = when {\n        x !in 0 until height -> false\n        y !in 0 until width -> false\n        size !in 1..20 -> false\n        else -> true\n    }\n\n    private fun newPos(pos: Int, size: Int): Int {\n        var targetDistance = Int.MAX_VALUE\n        var targetSize = 0\n        var targetDirection = Direction.NONE\n\n        for ((curTargetPos, curTargetSize) in blobsMap) {\n            if (curTargetPos == pos) continue\n            if (curTargetSize >= size) continue\n\n            val curTargetDistance = distance(pos, curTargetPos)\n            val curTargetDirection = direction(pos, curTargetPos)\n\n            fun updateTarget() {\n                targetDistance = curTargetDistance\n                targetSize = curTargetSize\n                targetDirection = curTargetDirection\n            }\n\n            if (curTargetDistance < targetDistance) updateTarget()\n\n            if (curTargetDistance == targetDistance) {\n                if (curTargetSize > targetSize) updateTarget()\n                else if (\n                    curTargetSize == targetSize &&\n                    curTargetDirection.ordinal < targetDirection.ordinal\n                ) updateTarget()\n            }\n        }\n        return targetDirection.newPos(pos)\n    }\n\n    private fun distance(posA: Int, posB: Int): Int {\n        val dx = (x(posA) - x(posB)).absoluteValue\n        val dy = (y(posA) - y(posB)).absoluteValue\n        return maxOf(dx, dy)\n    }\n\n    private fun direction(fromPos: Int, toPos: Int): Direction = when {\n        x(toPos) < x(fromPos) && y(toPos) == y(fromPos) -> Direction.N\n        x(toPos) < x(fromPos) && y(toPos) > y(fromPos) -> Direction.NE\n        x(toPos) == x(fromPos) && y(toPos) > y(fromPos) -> Direction.E\n        x(toPos) > x(fromPos) && y(toPos) > y(fromPos) -> Direction.SE\n        x(toPos) > x(fromPos) && y(toPos) == y(fromPos) -> Direction.S\n        x(toPos) > x(fromPos) && y(toPos) < y(fromPos) -> Direction.SW\n        x(toPos) == x(fromPos) && y(toPos) < y(fromPos) -> Direction.W\n        x(toPos) < x(fromPos) && y(toPos) < y(fromPos) -> Direction.NW\n        x(toPos) == x(fromPos) && y(toPos) == y(fromPos) -> Direction.NONE\n        else -> throw IllegalStateException()\n    }\n\n    private fun Direction.newPos(pos: Int) = when(this) {\n        Direction.N -> pos - width\n        Direction.NE -> pos - width + 1\n        Direction.E -> pos + 1\n        Direction.SE -> pos + width + 1\n        Direction.S -> pos + width\n        Direction.SW -> pos + width - 1\n        Direction.W -> pos - 1\n        Direction.NW -> pos - width - 1\n        Direction.NONE -> pos\n    }\n\n    private fun pos(x: Int, y: Int) = x * width + y\n    private fun x(pos: Int) = pos \/ width\n    private fun y(pos: Int) = pos % width\n\n    fun display() {\n        val m = Array(height) { Array(width) { '.' } }\n        for ((pos, size) in blobsMap) {\n            val x = x(pos)\n            val y = y(pos)\n            m[x][y] = 'A' + size - 1\n        }\n        val str = m.joinToString(\"\n\") { it.joinToString(\"\") }\n        println(str)\n        println()\n    }\n}\n\nenum class Direction { N, NE, E, SE, S, SW, W, NW, NONE }\n\n\/\/data class Blob(val x: Int, val y: Int, val size: Int)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208252,"user_id":null,"body":"package kata\n\nimport kotlin.math.*\n\nval Int.unitMove: Int\n  get() {\n      if (this == 0) return 0\n      return this \/ abs(this)\n  }\n\ndata class Point(val x: Int, val y: Int) {\n    fun distanceTo(other: Point) =\n      max(abs(x - other.x), abs(y - other.y))\n      \n    fun angleTo(other: Point): Double {\n        val a = atan2((other.y - y).toDouble(), (x - other.x).toDouble())\n        return if (a < 0) a + 2*PI else a\n    }\n    \n    fun stepTowards(other: Point): Point {\n        assert(this != other, { \"Bad point: ${other}\" })\n        return Point(this.x + (other.x - this.x).unitMove, this.y + (other.y - this.y).unitMove)\n    }\n}\n\nfun Blob.merge(other: Blob?): Blob {\n    other?.let {\n        this.size += it.size\n    }\n    return this\n}\n\nval Blob.pos: Point\n  get() = Point(this.x, this.y)\nfun Blob.distanceTo(other: Blob) = this.pos.distanceTo(other.pos)\nfun Blob.angleTo(other: Blob) = this.pos.angleTo(other.pos)\n\nfun Blob.stepTowards(other: Blob): Blob {\n    val newPos = this.pos.stepTowards(other.pos)\n    return Blob(newPos.x, newPos.y, this.size)\n}\n\nclass Blobservation(val width: Int, val height: Int = width) {\n    val grid: MutableMap<Point, Blob> = mutableMapOf()\n    \n    \/\/ if invalid arguments are given to either `populate` or `move` methods, throw an IllegalArgumentException\n    fun populate(blobs: Array<Blob>) {\n        blobs.forEach { validateBlob(it) } \/\/ Fail without modification if any invalid\n        blobs.forEach { insertBlob(it) }\n    }\n    fun move(n: Int = 1) {\n      if (n < 1) throw IllegalArgumentException(\"Non-positive number of moves!\")\n      \n      (1..n).forEach { singleMove() }\n    }\n    fun printState() =\n      grid\n        .values\n        .sortedWith(compareBy({it.x}, {it.y}))\n        .map { intArrayOf(it.x, it.y, it.size) }\n    \n    private fun validateBlob(blob: Blob) {\n        if (blob.x < 0\n         || blob.x >= width\n         || blob.y < 0\n         || blob.y >= height\n         || blob.size < 1\n         || blob.size > 20)\n            throw IllegalArgumentException(\"Bad blob data! $blob\")\n    }\n    \n    private fun insertBlob(blob: Blob) {\n        val pos = blob.pos\n        grid[pos] = blob.merge(grid[pos])\n    }\n    \n    private fun singleMove() {\n        val oldBlobs = grid.values.sortedBy { it.size }.toList()\n        if (oldBlobs.isEmpty()) return\n        \n        val smallest = oldBlobs.first().size\n        val movers = oldBlobs.dropWhile { it.size == smallest }\n        val newBlobs: List<Blob> =\n          movers.map { curr ->\n            val target =\n              oldBlobs\n                .takeWhile { it.size < curr.size }\n                .sortedWith(compareBy({curr.distanceTo(it)}, {-(it.size)}, {curr.angleTo(it)}))\n                .first()\n            curr.stepTowards(target)\n          }\n        movers.forEach { grid.remove(it.pos) }\n        newBlobs.forEach { insertBlob(it) }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208253,"user_id":null,"body":"package kata\n\nimport kotlin.math.*\n\nfun Blob.toIntArray() = arrayOf(x, y, size).toIntArray()\n\nfun Blob.moveTo(other: Blob) = Blob(this.x-(this.x-other.x).sign,this.y-(this.y-other.y).sign,this.size) \/\/Ok\n\nfun Blob.distTo(other: Blob) = max(abs(this.x - other.x), abs(this.y - other.y))\n\nfun Blob.clockDistFrom(other: Blob): Int {\n    val d = this.distTo(other)\n    val dx = other.x - this.x\n    val dy = other.y - this.y\n    return if (dx > 0 && dy <= 0) return d-dy-dx \n    \telse if (dx <= 0 && dy < 0) return 3*d+dy-dx \n    \t\telse if (dx < 0 && dy >= 0) return 5*d+dx+dy else 7*d+dx-dy\n}\n\nclass Blobservation(val height: Int, val width: Int = height) {\n    private var blobs = arrayOf<Blob>()\n    \/\/ if invalid arguments are given to either `populate` or `move` methods, throw an IllegalArgumentException\n    fun populate(blobs: Array<Blob>) {\n        if (blobs.any{it.x < 0 || it.y < 0 || it.size < 1 || it.x > this.height-1 || it.y > this.width-1}) \n            throw IllegalArgumentException()\n        this.blobs = (this.blobs + blobs).groupingBy{Pair(it.x, it.y)}\n            .reduce{_, s, e -> s.copy(s.x, s.y, s.size+e.size)}.map{it.value}.toTypedArray()\n    }\n    fun move(n: Int = 1) { \n        println(n)        \n        if (n < 1) throw IllegalArgumentException()\n        if (blobs.size <= 1) return\n        var nextgen = mutableListOf<Blob>()\n        for (i in 1..n) {\n            nextgen.clear()\n            \/\/add stationary blobs\n            nextgen.addAll(blobs.filter{it.size == blobs.minBy{it.size}?.size?:0})\n            if (nextgen.size == blobs.size) return \/\/ return if only stationary blobs left\n            blobs.filter{it.size > blobs.minBy{it.size}?.size?:0}.forEach{ current ->\n                nextgen.add(current.moveTo(blobs.filter{it.size < current.size}\n                        .groupBy{it.distTo(current)}.minBy{it.key}!!\n                        .value.groupBy{it.size}.maxBy{it.key}!!\n                        .value.minBy{it.clockDistFrom(current)}?:Blob(0,0,0)))\n            }\n            blobs = arrayOf<Blob>()\n            this.populate(nextgen.toTypedArray()) \n        }\n               \n    }\n    \n    fun printState(): List<IntArray> { \n        return blobs.toList().map{it.toIntArray()}.sortedBy{it[1]}.sortedBy{it[0]}\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208254,"user_id":null,"body":"package kata\n\nimport kotlin.math.abs\nimport kotlin.math.max\nimport kotlin.math.sign\n\n\nenum class Direction() {\n    NW, W, SW, S, SE, E, NE, N;\n\n    companion object {\n        fun getDirectionByBase(x:Int , y: Int): Direction {\n            when {\n                x == -1 && y == 0 -> return Direction.N\n                x == -1 && y == 1 -> return Direction.NE\n                x == 0 && y == 1 -> return Direction.E\n                x == 1 && y == 1 -> return Direction.SE\n                x == 1 && y == 0 -> return Direction.S\n                x == 1 && y == -1 -> return Direction.SW\n                x == 0 && y == -1 -> return Direction.W\n                x == -1 && y == -1 -> return Direction.NW\n            }\n            throw IllegalArgumentException()\n        }\n    }\n}\n\nclass Blobservation(height: Int, width: Int = height) {\n    private val height = height\n    private val width = width\n    private var board = MutableList<MutableList<Blob?>>(height){ MutableList<Blob?>(width){null} }\n    init {\n        println(\"init $height $width\")\n    }\n\n    fun populate(blobs: Array<Blob>) {\n        blobs.forEach {\n            require(it.x in 0 until height)\n            require(it.y in 0 until width)\n            require(it.size in 1..20)\n        }\n        blobs.forEach {\n            updateBoard(it)            \n        }\n    }\n\n    private fun updateBoard(it: Blob) {\n        if (board[it.x][it.y] == null) {\n            board[it.x][it.y] = it\n        } else {\n            board[it.x][it.y]?.size = board[it.x][it.y]?.size?.plus(it.size)!!\n        }\n    }\n\n    fun move(n: Int = 1) {\n        println(\"move $n\")\n        require(n > 0)\n        (1..n).forEach() { _ ->\n            val allBlobs = board.flatten().filterNotNull()\n            if (allBlobs.size > 1) {\n                val minSize: Int = allBlobs.minBy { it.size }?.size ?: 0\n                var newBlobs = allBlobs.filter { it.size > minSize }.map { moveBlob(it, allBlobs) }\n                newBlobs += allBlobs.filter {it.size == minSize}\n                board = MutableList<MutableList<Blob?>>(height){ MutableList<Blob?>(width){null} }\n                newBlobs.forEach { updateBoard(it) }\n            }\n        }\n    }\n\n    private fun moveBlob(blob: Blob, allBlobs: List<Blob>): Blob {\n        val movedBlob = blob.copy()\n        val closestBlobs: Map<Int, List<Blob>> = allBlobs.filter { it.size < blob.size }.groupBy { max(abs(it.x - blob.x), abs(it.y - blob.y)) }.toSortedMap()\n        val targetBlob = closestBlobs.values.first().sortedWith(\n            Comparator { blob1, blob2 ->\n                if (blob1.size == blob2.size) {\n                    val direction1 = Direction.getDirectionByBase((blob1.x - blob.x).sign, (blob1.y - blob.y).sign)\n                    val direction2 = Direction.getDirectionByBase((blob2.x - blob.x).sign, (blob2.y - blob.y).sign)\n                    val comp = compareValues(direction1, direction2)\n                    comp\n                } else {\n                    blob1.size - blob2.size\n                }\n            }\n        ).reversed().first()\n\n        movedBlob.x += (targetBlob.x - blob.x).sign\n        movedBlob.y += (targetBlob.y - blob.y).sign\n\n        return movedBlob\n    }\n\n    fun printState(): List<IntArray> {\n        return board\n            .flatten()\n            .filterNotNull()\n            .sortedWith(compareBy({it.x}, {it.y}))\n            .map { it -> intArrayOf(it.x, it.y, it.size) }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208255,"user_id":null,"body":"package kata\n\nimport kotlin.math.abs\nimport kotlin.math.max\n\ndata class Point(val x: Int, val y: Int)\n\/\/data class Blob(var x: Int, var y: Int, var size: Int)\n\nval DIRS = listOf(\n    Point(0, -1), Point(1, -1),\n    Point(1, 0), Point(1, 1),\n    Point(0, 1), Point(-1, 1),\n    Point(-1, 0), Point(-1, -1)\n)\n\nclass Blobservation(val height: Int, val width: Int) {\n    var currBlobs = mutableMapOf<Point, Int>()\n\n    fun populate(blobs: Array<Blob>) {\n        blobs.forEach {\n            if (!(it.y in 0 until width && it.x in 0 until height && it.size in 1.. 20))\n                throw IllegalArgumentException(\"Illegal blob $it\")\n        }\n\n        \/\/ Add\n        blobs.forEach {\n            val p = Point(it.y, it.x)\n            currBlobs[p] = (currBlobs[p] ?: 0) + it.size\n        }\n    }\n    fun move(n: Int = 1) {\n        if (n <= 0) throw IllegalArgumentException()\n        repeat(n) {\n            if (currBlobs.values.toSet().size <= 1) return \/\/ no more moves\n\n            var move = mutableMapOf<Point, Point>()\n            currBlobs.forEach { (toMovePoint, toMoveSize) ->\n                var bestDist = Int.MAX_VALUE\n                var bestSize = 0\n                var bestDir = -1\n                currBlobs.forEach { (targetPoint, targetSize) ->\n                    if (targetSize < toMoveSize) {\n                        val dx = targetPoint.x - toMovePoint.x\n                        val dy = targetPoint.y - toMovePoint.y\n                        val dist = max(abs(dx), abs(dy))\n                        val dir = DIRS.indexOf(Point(sign(dx), sign(dy)))\n                        \/\/ println(\"$toMovePoint -> $targetPoint \/ $dx, $dy \/ $dist, $dir\")\n                        if (dir > -1 && (dist < bestDist || (dist == bestDist &&\n                                    (targetSize > bestSize || (targetSize == bestSize && dir < bestDir))))) {\n                            bestDist = dist\n                            bestSize = targetSize\n                            bestDir = dir\n                        }\n                    }\n                }\n                \/\/ println(\"$toMovePoint moving in dir: $bestDir\")\n                if (bestDir > -1) {\n                    move[toMovePoint] = DIRS[bestDir]\n                }\n            }\n\n            var newBlobs = mutableMapOf<Point, Int>()\n            currBlobs.forEach { (point, size) ->\n                val toMove = move[point] ?: Point(0, 0)\n                val newPoint = Point(point.x + toMove.x, point.y + toMove.y)\n                newBlobs[newPoint] = (newBlobs[newPoint] ?: 0) + size\n\n            }\n\n            currBlobs = newBlobs\n        }\n    }\n\n    private fun sign(x: Int): Int = when {\n        x<0 -> -1\n        x>0 -> 1\n        else -> 0\n    }\n\n    fun printState(): List<IntArray> = currBlobs.map { me ->\n        intArrayOf(me.key.y, me.key.x, me.value)\n    }.sortedWith (compareBy({ it[0] },{ it[1]}) )\n\n    constructor(s: Int) : this(s, s)\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208256,"user_id":null,"body":"package kata\n\nimport java.util.*\nimport kotlin.Comparator\nimport kotlin.math.PI\nimport kotlin.math.abs\nimport kotlin.math.atan\n\nclass Blobservation(private val width: Int, private val height: Int = width) {\n    private var room: MutableList<IntArray> = MutableList(height) { IntArray(width) { 0 } }\n    private val blobs: MutableList<Blob> = mutableListOf()\n\n    init {\n        if (width !in 8..50 || height !in 8..50) {\n            throw IllegalArgumentException()\n        }\n    }\n\n    private fun getRad(x: Double, y: Double): Double {\n        var a = if (x == .0) {\n            PI \/ 2 + if (y < 0) PI else .0\n        } else {\n            atan(y \/ x)\n        }\n        if (x < 0 && y > 0 || x < 0 && y < 0) {\n            a += PI\n        } else if (x > 0 && y < 0) {\n            a += 2 * PI\n        } else if (y == .0 && x < 0) {\n            a += PI\n        }\n        return a\n    }\n\n    private fun Blob.distance(blob: Blob): Int {\n        val dx = abs(this.x - blob.x)\n        val dy = abs(this.y - blob.y)\n        return kotlin.math.max(dx, dy)\n    }\n\n    private fun Blob.moveToTarget(target: Blob): Blob {\n        val b = this.copy()\n        var dx = target.x - b.x\n        var dy = target.y - b.y\n        if (dx != 0) dx \/= abs(dx)\n        if (dy != 0) dy \/= abs(dy)\n        b.x += dx\n        b.y += dy\n        return b\n    }\n\n    private fun Blob.clockwiseCompare(b1: Blob, b2: Blob): Int {\n        val dx1 = (b1.x - this.x).toDouble()\n        val dy1 = -(b1.y - this.y).toDouble()\n        val dx2 = (b2.x - this.x).toDouble()\n        val dy2 = -(b2.y - this.y).toDouble()\n\n        var a1 = getRad(dx1, dy1) - PI\n        if (a1 < 0) {\n            a1 += PI * 2\n        }\n        var a2 = getRad(dx2, dy2) - PI\n        if (a2 < 0) {\n            a2 += PI * 2\n        }\n\n        return a1.compareTo(a2)\n    }\n\n    private fun Blob.toIntArray() = IntArray(3).also {\n        it[0] = this.x; it[1] = this.y; it[2] = this.size\n    }\n\n    private fun rebuildRoom() {\n        room = MutableList(height) { IntArray(width) { 0 } }\n        blobs.forEach {\n            room[it.y][it.x] += it.size\n            it.size = room[it.y][it.x]\n        }\n    }\n\n    private fun verify(blob: Blob) = blob.x in 0 until width && blob.y in 0 until height && blob.size in 1..20\n\n    fun populate(blobs: Array<Blob>) {\n        if (!blobs.all(this::verify)) {\n            throw IllegalArgumentException()\n        }\n        blobs.forEach {\n            if (room[it.y][it.x] != 0) {\n                it.size += room[it.y][it.x]\n                this.blobs.removeIf { b -> b.x == it.x && b.y == it.y }\n            }\n            room[it.y][it.x] = it.size\n        }\n        this.blobs.addAll(blobs)\n    }\n\n    fun move(n: Int = 1) {\n        if (n < 1) {\n            throw IllegalArgumentException()\n        }\n\n\n        for (i in 1..n) {\n            val smallest = blobs.minBy(Blob::size) ?: return\n            val moving = blobs.filter { it.size > smallest.size }.sortedByDescending { it.size }\n            val newBlobs = MutableList<Blob?>(moving.size) { null }\n\n            moving.forEachIndexed { index, it ->\n                val targets = blobs.filter { target -> it.size > target.size }.sortedWith(Comparator { o1, o2 ->\n                    val d1 = it.distance(o1)\n                    val d2 = it.distance(o2)\n\n                    when {\n                        d1 != d2 -> d1 - d2\n                        o2.size != o1.size -> o2.size - o1.size\n                        else -> it.clockwiseCompare(o1, o2)\n                    }\n                })\n\n                if (targets.isEmpty()) {\n                    return@forEachIndexed\n                }\n                \n                newBlobs[index] = it.moveToTarget(targets[0])\n            }\n\n            moving.forEachIndexed { index, it ->\n                val b = newBlobs[index] ?: return@forEachIndexed\n                it.x = b.x\n                it.y = b.y\n                it.size = b.size\n            }\n\n            rebuildRoom()\n            blobs.removeIf { it.size <= 0 || it.size != room[it.y][it.x] }\n        }\n    }\n\n    fun printState() = blobs.sortedWith (Comparator { o1, o2 ->\n        when {\n            o1.x != o2.x -> o1.x - o2.x\n            o1.y != o2.y -> o1.y - o2.y\n            else -> o1.size - o2.size\n        }\n    }).map { it.toIntArray() }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208257,"user_id":null,"body":"package kata\n\nimport kotlin.math.abs\nimport kotlin.math.atan2\nimport kotlin.math.max\nimport kotlin.math.PI\nimport kotlin.math.sign\n\nclass Blobservation(val height: Int, val width: Int) {\n    \n    constructor(s: Int): this(s,s)\n    \n    private val blobList = mutableListOf<Blob>()\n    \n    private fun Blob.toIntArray() = listOf(x,y,size).toIntArray()\n    private fun Blob.distanceTo(other: Blob) = max(abs(other.x-x),abs(other.y-y))\n    \n    private fun Blob.update(move: Pair<Int,Int>){\n        x += move.first\n        y += move.second\n    }\n    \n    private fun Blob.nextMove(smallestSize: Int): Pair<Int,Int>{\n        if (size == smallestSize) return 0 to 0\n        \n        val target = blobList.filter{ it.size < size }\n            .sortedWith( compareBy<Blob>{ distanceTo(it) }\n                    .thenByDescending{ it.size }\n                    .thenBy{ PI - atan2((it.y-y).toFloat(), (it.x-x).toFloat())})\n            .first()\n        \n        return (target.x - x).sign to (target.y - y).sign\n    }\n    \n    private fun MutableList<Blob>.checkFusions(){\n        groupBy{it.x to it.y}.values.filter{ it.size > 1 }.forEach{\n            val first = it[0]\n            it.drop(1).forEach{\n                first.size += it.size\n                remove(it)\n            }\n        }\n    }\n    \n    fun populate(blobs: Array<Blob>) { \n        require(blobs.map{it.x to it.y}.all{ (x, y) -> x in 0 until height && y in 0 until width })\n        require(blobs.map{it.size}.all{it in 1..20})\n        blobs.forEach{ newBlob ->\n            val fusePartner = blobList.find{ it.x == newBlob.x && it.y == newBlob.y }\n            if (fusePartner == null) blobList.add(newBlob)\n            else fusePartner.size += newBlob.size\n        }\n    }\n    fun move(n: Int = 1) {\n        require(n > 0)\n        if (blobList.isEmpty()) return\n        \n        repeat(n){\n            val smallestSize = blobList.minBy{it.size}!!.size\n            \n            blobList.apply{\n                map{ it to it.nextMove(smallestSize) }\n                    .forEach{ it.first.update(it.second) }\n            }.checkFusions()\n        }\n    }\n    fun printState(): List<IntArray> = \n        blobList.sortedWith( compareBy<Blob>{it.x}.thenBy{it.y} ).map{ it.toIntArray() }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208258,"user_id":null,"body":"\/\/ @docgunthrop's solution\npackage kata\n\nclass Blobservation(h: Int, w: Int = h) {\n\tval h = h\n\tval w = w\n\tvar room = summonGrid(h,w)\n\tvar blobs = mutableListOf<Blob>()\n\t\n\tfun populate(r: Array<Blob>) {\n\t\tif (r.any { blob -> blob.x < 0 || blob.x >= h || blob.y < 0 || blob.y >= w || blob.size < 1 }) throw IllegalArgumentException(\"Invalid populate input\")\n\t\tfor (blob in r) {\n\t\t\tval (x,y,q) = blob\n\t\t\troom[x][y].run {\n\t\t\t\tif (this != null) { this.size += q } else { blobs.add(blob); room[x][y] = blob } } }\n\t}\n\t\n\tfun move(n: Int = 1) {\n\t\tif (n < 1) throw IllegalArgumentException(\"Invalid move input\")\n\t\tvar c = n\n\t\tif (blobs.isEmpty()) return\n\t\tval maxD = Math.max(h,w)\n\t\tvar minSize = sizeList().minBy({ it })\n\t\t\/\/ val minSize = sizeList().minByOrNull({ it })\/\/ Kotlin 1.4\n\t\twhile (c > 0 && blobs.size > 1 && sizeList().size > 1) {\n\t\t\tblobs.sortByDescending { blob -> blob.size }\n\t\t\tval nr = summonGrid(h,w)\n\t\t\tval roster = mutableListOf<Blob>()\n\t\t\tfor ((i,blob1) in blobs.withIndex()) {\n\t\t\t\tval (x1,y1,q1) = blob1\n\t\t\t\tvar md = maxD\n\t\t\t\tvar targ: Blob? = null\n\t\t\t\tif (q1 == minSize) {\n\t\t\t\t\tif (nr[x1][y1] != null) nr[x1][y1]!!.size += q1\n\t\t\t\t\telse { nr[x1][y1] = blob1; roster.add(blob1) }\n\t\t\t\t\tcontinue }\n\t\t\t\tfor (blob2 in blobs.drop(i+1)) {\n\t\t\t\t\tval (x2,y2,q2) = blob2\n\t\t\t\t\tif (q2 >= q1) continue\n\t\t\t\t\tval d = Math.max(Math.abs(x2-x1), Math.abs(y2-y1))\n\t\t\t\t\tif (d <= md) {\n\t\t\t\t\t\tif (d < md || q2 > targ!!.size || q2 == targ.size && dpr(x2-x1, y2-y1, targ.x-x1, targ.y-y1)) {\n\t\t\t\t\t\t\tmd = d\n\t\t\t\t\t\t\ttarg = blob2 } } }\n\t\t\t\tval tx = if (targ != null) (targ.x - x1).sign() + x1 else x1\n\t\t\t\tval ty = if (targ != null) (targ.y - y1).sign() + y1 else y1\n\t\t\t\tif (nr[tx][ty] != null) nr[tx][ty]!!.size += q1\n\t\t\t\telse {\n\t\t\t\t\tblob1.x = tx\n\t\t\t\t\tblob1.y = ty\n\t\t\t\t\tnr[tx][ty] = blob1\n\t\t\t\t\troster.add(blob1) }\n\t\t\t}\n\t\t\tminSize = roster.map { it.size }.min()\n\t\t\tblobs = roster\n\t\t\troom = nr\n\t\t\tc--\n\t\t}\n\t}\n\t\n\tfun printState(): List<IntArray> = blobs.map { (x,y,size) -> intArrayOf(x,y,size) }.sortedWith(compareBy({ it[0] }, { it[1] }))\n\t\n\tprivate fun summonGrid(h: Int, w: Int) = Array(h, { Array<Blob?>(w, { null }) })\n\tprivate fun sizeList(): Set<Int> = blobs.map { it.size }.toSet()\n\t\n\tprivate fun dpr(dx1: Int, dy1: Int, dx2: Int, dy2: Int): Boolean {\n\t\tval sx1 = dx1.sign()\n\t\tval sx2 = dx2.sign()\n\t\tval sy1 = dy1.sign()\n\t\tval sy2 = dy2.sign()\n\t\tif (sx1 != sx2) return sx1 < sx2 && sy1 >= 0 || sx1 > sx2 && sy2 < 0\n\t\telse if (sy1 != sy2) return if (sx1 <= 0) { sy1 >= 0 && sy2 != 0 } else { sy1 > sy2 }\n\t\telse {\n\t\t\treturn if (sx1 <= 0) {\n\t\t\t\tif (sy1 <= 0) { dx1 - dy1 > dx2 - dy2 } else { -dx1 - dy1 > -dx2 - dy2 } }\n\t\t\telse {\n\t\t\t\tif (sy1 <= 0) { dx1 + dy1 > dx2 + dy2 } else { dy1 - dx1 > dy2 - dx2 } }\n\t\t}\n\t}\n}\n\nfun Int.sign() = Math.max(this,-1).let { Math.min(it,1) }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5ae326342f8cbc72220000d2":[{"id":208259,"user_id":null,"body":"package solution\n\nfun stringExpansion(s: String): String = buildString {\n    var numberPrefix = 1\n    s.forEach {\n        if (it in \"0123456789\") {\n            numberPrefix = it.toString().toInt()\n        } else {\n            append(it.toString().repeat(numberPrefix))\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208260,"user_id":null,"body":"package solution\n\nfun stringExpansion(s: String): String {\n  var sb = StringBuilder()\n  var rememberDigit = 1\n    s.forEach { x ->\n        if(x.isDigit())\n            rememberDigit = x.toString().toInt()\n        else\n            sb.append(x.toString().repeat(rememberDigit))\n    }\n    return sb.toString()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208261,"user_id":null,"body":"package solution\n\nfun stringExpansion(s: String): String {\n    var str = \"\"\n    var num = 1\n    for(i in s) {\n        if (i.isDigit()) {\n            num = i.code - 48\n        } else {\n            repeat(num) {\n                str += i\n            }\n        }\n    }\n    return str\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208262,"user_id":null,"body":"package solution\n\nfun stringExpansion(s: String): String = buildString {\n    var num = 1\n    s.forEach{\n        if (it.isDigit()) { num = it.toString().toInt() }\n        else {\n            append(it.toString().repeat(num))\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208263,"user_id":null,"body":"package solution\n\nfun stringExpansion(s: String): String {\n  var result = \"\"\n  if(s == \"\")\n    return \"\"\n  var num = 1;\n  for(c in s) {\n      if(c.isDigit()) {\n          num = c.toString().toInt()\n      }\n      else {\n        for(i in 1..num){\n            result += c.toString()\n        }\n    }\n}\nreturn result\n  \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208264,"user_id":932,"body":"package solution\n\nfun stringExpansion(s: String): String{\n    var times = 1\n    var result = \"\"\n    s.forEach {if (it.isDigit()) times = it-'0' else result += \"$it\".repeat(times)}\n    return result\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208265,"user_id":null,"body":"package solution\n\nfun stringExpansion(s: String): String = s.map { it.toString().toIntOrNull() ?: it }.let { it.mapIndexed { i, k -> if (i<it.size-1 &&  k is Int && it[i + 1] is Int) \"govno\" else k } }.filter { it != \"govno\" }\n            .run {var g = 1;var result = \"\"\n            for (i in this){\n                if (i is Int) g =i\n                else{ for (j in 0 until g) result+=i\n                }\n            }\n            return@run result}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208266,"user_id":null,"body":"package solution\n\nfun stringExpansion(s: String): String {\n    var times = 1\n    var expansion = \"\"\n\n    s.toCharArray().forEach { item ->\n        if (item.isLetter()) {\n            repeat(times) {\n                expansion += item\n            }\n        } else {\n            times = Character.getNumericValue(item)\n        }\n    }\n\n    return expansion\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208267,"user_id":null,"body":"package solution\n\nfun stringExpansion(s: String): String {\n  var result: String = \"\"\n  var rep: Int = 1  \n    s.forEach {\n        var x = it\n        if(x.isDigit()){\n            rep = x.toString().toInt()\n        } else{\n            repeat(rep) {result += x}\n        }\n    }\n   return result \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208268,"user_id":null,"body":"package solution\n\nfun stringExpansion(s: String): String {\n    var n = 1\n    return s\n       .map { it.toString() }\n       .runningFold(\"\") { a, e ->\n         if (e.first().isDigit()) {\n           n = e.toInt()\n           a\n         } else if (e.first().isLetter()) {\n           a + e.repeat(n)\n         } else \"\"\n       }.last()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5ae62fcf252e66d44d00008e":[{"id":208269,"user_id":null,"body":"import java.util.Collections.max\n\nfun expression_matter(a: Int, b: Int, c: Int) =\n max(listOf(a * b * c, a * (b + c), a + b * c, (a + b) * c, a + b + c))","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208270,"user_id":null,"body":"fun expression_matter(a : Int, b : Int, c : Int) : Int {\n return if (a != 1 && b != 1 && c != 1) {\n  a * b * c\n } else if (a == 1 && c == 1) {\n  a + b + c\n } else if (c == 1 && a != 1 || (a > c)) {\n  a * (b + c)\n } else {\n  (a + b) * c\n }         \n}","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208271,"user_id":527,"body":"class Kata {\n    companion object {\n        fun expression_matter(a: Int, b: Int, c: Int): Int {\n            return maxOf(a + b + c, a * (b + c), (a + b) * c, a * b * c)\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208272,"user_id":null,"body":"class Kata {\n    companion object {\n     \n     fun expression_matter(a : Int, b : Int, c : Int) : Int {\n         \/\/ Your Code here... Happy Coding!\n         \n         var max = 0\n         var d = 0\n         \n         d = a + b + c\n         if(d>max) max = d\n         \n         d = a + b * c\n         if(d>max) max = d\n         \n         d = a * b + c\n         if(d>max) max = d\n         \n         d = a * b * c\n         if(d>max) max = d\n         \n         d = (a+b) * c\n         if(d>max) max = d\n         \n         d = a * (b+c)\n         if(d>max) max = d\n         \n         return max\n     }\n     \n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208273,"user_id":null,"body":"class Kata {\n    companion object {\n        fun expression_matter(a: Int, b: Int, c: Int): Int {\n            return maxOf((a * (b + c)), (a * b * c), (a + b * c), ((a + b) * c), (a + b + c))\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208274,"user_id":null,"body":"class Kata {\n        companion object {\n            fun expression_matter(a: Int, b: Int, c: Int): Int {\n                val first = a + b + c\n                val second = a * b * c\n                val third = a + b * c\n                val fourth = (a + b) * c\n                val fifth = a * (b + c)\n                val x = listOf(first,second,third,fourth,fifth)\n                var y = 0\n                for(i in x) {\n                    if(y<i) y= i\n                }\n                return y\n            }\n        }\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208275,"user_id":null,"body":"class Kata {\n    companion object {\n     \n     fun expression_matter(a : Int, b : Int, c : Int) : Int {\n        fun m(a:Int, b:Int) = Math.max(a+b,a*b)\n        return Math.max(m(m(a,b),c),m(a,m(b,c)))\n     }\n     \n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208276,"user_id":null,"body":"import kotlin.math.max\nclass Kata {\n    companion object {\n        fun expression_matter(a: Int, b: Int, c: Int) = max(max(a + b + c, a * (b + c)), max((a + b) * c, a * b * c))\n     \n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208277,"user_id":null,"body":"class Kata {\n    companion object {\n        fun expression_matter(a: Int, b: Int, c: Int) = (if (c < a) listOf(c, b, a) else listOf(a, b, c))\n            .reduce { acc, v -> if (v * acc > v + acc) acc * v else acc + v }\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208278,"user_id":null,"body":"class Kata {\n    companion object {\n        fun expression_matter(a: Int, b: Int, c: Int): Int =\n            listOf(\n                { x:Int , y: Int, z: Int -> x * (y + z) },\n                { x:Int , y: Int, z: Int -> x * y * z   },\n                { x:Int , y: Int, z: Int -> x + y * z   },\n                { x:Int , y: Int, z: Int -> (x + y) * z },\n                { x:Int , y: Int, z: Int -> x + y + z   },\n            ).maxOf { it(a,b,c) }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5af96cea3e9715ec670001dd":[{"id":208279,"user_id":1403,"body":"package projectile\n\nclass Projectile(h:Int, v0:Int, a:Int) {\n  private var startVelocity:Int = 0\n  private var startHeight:Int = 0\n  private var angle:Int = 0\n  private var horizVel:Double = 0.toDouble()\n  private var verticalVel:Double = 0.toDouble()\n  init{\n    startHeight = h\n    startVelocity = v0\n    angle = a\n    horizVel = startVelocity * Math.cos((a * Math.PI) \/ 180.0)\n    verticalVel = startVelocity * Math.sin((a * Math.PI) \/ 180.0)\n  }\n  fun heightEq():String {\n    var vv = Math.round(verticalVel * 1000.0).toDouble() \/ 1000.0\n    var a = \"\"\n    if (startHeight != 0) a = \" + \" + startHeight.toDouble()\n    return \"h(t) = -16.0t^2 + \" + vv + \"t\" + a\n  }\n  fun horizEq():String {\n    return \"x(t) = \" + Math.round(horizVel * 1000.0).toDouble() \/ 1000.0 + \"t\"\n  }\n  fun height(time:Double):Double {\n    var d = (-16 * Math.pow(time, 2.0) + (verticalVel * time) + startHeight)\n    return Math.round(d * 1000.0).toDouble() \/ 1000.0\n  }\n  fun horiz(time:Double):Double {\n    return Math.round((horizVel * time) * 1000.0).toDouble() \/ 1000.0\n  }\n  fun landing():DoubleArray {\n    var t = ((0.0 - verticalVel - Math.sqrt(Math.pow(verticalVel, 2.0) - (4.0 * (-16).toDouble() * startHeight))) \/ -32.0)\n    var x = horiz(t)\n    t = Math.round(t * 1000.0).toDouble() \/ 1000.0\n    x = Math.round(x * 1000.0).toDouble() \/ 1000.0\n    return doubleArrayOf(x, 0.0, t)\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208280,"user_id":null,"body":"package projectile\n\n\nclass Projectile(val h:Int, val v:Int, val a:Int) {\n\n    val r = a * Math.PI \/ 180.0\n\n    fun heightEq(): String {\n        return \"h(t) = -16.0t^2 + \" + String.format(\"%.3f\", v * Math.sin(r)).toDouble() + \"t\" + if (h>0.0) \" + \" + h.toDouble() else \"\"\n    }\n\n    fun horizEq(): String {\n        return \"x(t) = \" + String.format(\"%.3f\", v * Math.cos(r)).toDouble() + \"t\"\n    }\n\n    fun height(t: Double): Double {\n        return String.format(\"%.3f\", -16 * Math.pow(t, 2.0) + (v * Math.sin(r)) * t + h).toDouble()\n    }\n\n    fun horiz(t: Double): Double {\n        return String.format(\"%.3f\", v * Math.cos(r) * t).toDouble()\n    }\n\n    fun landing(): DoubleArray {\n        val t:Double = (-(v * Math.sin(r)) - Math.sqrt(Math.pow( v * Math.sin(r), 2.0) -4 * (-16) * h)) \/ (2 * (-16))\n        return doubleArrayOf(\n                horiz(t),\n                0.0,\n                String.format(\"%.3f\", t).toDouble()\n        )\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208281,"user_id":null,"body":"package projectile\nimport kotlin.math.sin\nimport kotlin.math.cos\nimport kotlin.math.PI\nimport kotlin.math.sqrt\nimport kotlin.math.round\n\nclass Projectile(_h0: Int, _v0: Int, _ang: Int) {\n    val h = _h0.toDouble()\n    val v = _v0.toDouble()\n    val ang = _ang.toDouble()\n    \n    fun heightEq(): String {\n        return if (h !=0.0 ) (\"h(t) = -16.0t^2 + ${Math.round(v*sin(ang*(PI\/180))*1000.0)\/1000.0}t + ${h}\") else (\"h(t) = -16.0t^2 + ${Math.round(v*sin(ang*(PI\/180))*1000.0)\/1000.0}t\")\n    }\n    \n    fun horizEq(): String {\n        return (\"x(t) = ${Math.round(v*cos(ang*(PI\/180))*1000.0)\/1000.0}t\")\n    }\n    \n    fun height(t: Double): Double {\n        return Math.round((-16.0*t*t + v*sin(ang*(PI\/180))*t + h)*1000.0)\/1000.0\n    }\n    \n    fun horiz(t: Double): Double {\n        return Math.round((v*cos(ang*(PI\/180))*t)*1000.0)\/1000.0\n    }\n    \n    fun landing(): DoubleArray {\n        var d: Double = (v*sin(ang*(PI\/180)))*(v*sin(ang*(PI\/180)))-4*(-16.0*h)\n        var a: Double = -16.0\n        var b: Double = v*sin(ang*(PI\/180))\n        var t: Double = if (((-1.0*b)-sqrt(d))\/(2.0*a) > 0) ((-1.0*b)-sqrt(d))\/(2.0*a) else ((-1.0*b)+sqrt(d))\/(2.0*a)\n        var x: Double = v*cos(ang*(PI\/180))*t\n        return doubleArrayOf(Math.round(x*1000.0)\/1000.0, 0.0, Math.round(t*1000.0)\/1000.0)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208282,"user_id":null,"body":"package projectile\n\nimport kotlin.math.*\n\nclass Projectile(private val h: Int, private val v: Int, private val a: Int) {\n\n    private val b = v * sin(a.toRad())\n    private val c = v * cos(a.toRad())\n\n    fun height(t: Double): Double = (-16 * t * t + b * t + h).round(3)\n\n    fun heightEq(): String = \"h(t) = -16.0t^2 + ${b.round(3)}t${if(h!=0) \" + \" + h.toDouble() else \"\"}\"\n\n    fun horiz(t: Double): Double = (c * t).round(3)\n\n    fun horizEq(): String = \"x(t) = ${horiz(1.0)}t\"\n\n    fun landing(): DoubleArray {\n        val d = b.pow(2) - 4 * -16 * h\n        val t1 = (-b - sqrt(d)) \/ -32.0\n        return doubleArrayOf(horiz(t1), 0.0, t1.round(3))\n    }\n\n    private fun Int.toRad() = this * PI \/ 180\n    private fun Double.round(places: Int) = (this * 10.0.pow(places)).roundToInt() \/ 10.0.pow(places)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208283,"user_id":168,"body":"package projectile\n\nfun round(x: Double): Double = Math.round(x * 1000).toDouble() \/ 1000\n\nclass Projectile(val h: Int, v: Int, a: Int) {\n    val x = v * Math.cos(Math.toRadians(a.toDouble()))\n    val y = v * Math.sin(Math.toRadians(a.toDouble()))\n    \n    fun heightEq(): String {\n        var res = \"h(t) = -16.0t^2\"\n        if (y != 0.0) res += \" + ${round(y)}t\"\n        if (h != 0) res += \" + ${h.toDouble()}\"\n        return res\n    }\n    fun horizEq() = \"x(t) = ${round(x)}t\"\n    \n    fun height(t: Double) = round(-16 * t * t + y * t + h)\n    fun horiz(t: Double) = round(x * t)\n    fun landing(): DoubleArray {\n        val t = (y + Math.sqrt(y * y + 64 * h)) \/ 32\n        return doubleArrayOf(round(x * t), 0.0, round(t))\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208284,"user_id":null,"body":"package projectile\n\nimport java.util.*\nimport kotlin.math.cos\nimport kotlin.math.sin\nimport kotlin.math.pow\nimport kotlin.math.sqrt\n\n\nclass Projectile(val height:Int, val velocity:Int, val angle:Int) {\n\n\n    fun heightEq() : String {\n        val eq = StringBuilder()\n        eq.append(\"h(t) = -16.0t^2\")\n\n        val sinAngle = sin(angeToRadians())\n        if(sinAngle != 0.0) {\n            eq.append(\" + ${formatDouble(velocity*sinAngle)}t\")\n        }\n\n        val heightToDouble = height.toDouble()\n        if(heightToDouble != 0.0) {\n            eq.append(\" + $heightToDouble\")\n        }\n\n        return eq.toString()\n    }\n\n\n    fun horizEq() : String {\n        return \"x(t) = ${formatDouble(velocity* cos(angeToRadians()))}t\"\n    }\n\n\n    fun height(time: Double) : Double {\n        val height =  -16.0 * time.pow(2.0) + velocity * sin(angeToRadians()) * time + height.toDouble()\n        return formatDouble(height)\n    }\n\n\n    fun horiz(time: Double) : Double {\n        val horizon = velocity * cos(angeToRadians()) * time\n        return formatDouble(horizon)\n    }\n\n\n    fun landing() : DoubleArray {\n        val (x1, x2) = quadraticEquation()\n        val time  : Double = if (x1 < 0.0) x2 else x1\n\n        val distance = velocity * cos(angeToRadians()) * time\n        return doubleArrayOf(formatDouble(distance), 0.0, formatDouble(time))\n    }\n\n\n    private fun angeToRadians() : Double = Math.toRadians(angle.toDouble())\n\n\n    private fun formatDouble(d : Double) : Double = String.format(Locale.ENGLISH, \"%.3f\", d).toDouble()\n\n\n    private fun quadraticEquation() : Pair<Double, Double> {\n        val a = -16.0\n        val b = velocity * sin(angeToRadians())\n        val c = height\n\n        val delta = b.pow(2) - 4 * a * c\n        val x1 = (-b - sqrt(delta)) \/ (2 * a)\n        val x2 = (-b + sqrt(delta)) \/ (2 * a)\n\n        return Pair(x1, x2)\n    }\n\n\n    override fun toString(): String {\n        return \"Projectile(height=$height, velocity=$velocity, angle=$angle)\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208285,"user_id":null,"body":"package projectile\n\nimport kotlin.math.*\n\nclass Projectile(private val h0: Int, v0: Int, a0: Int) {\n\n    private val vy = v0 * sin(a0 * PI \/ 180)\n    private val vx = v0 * cos(a0 * PI \/ 180)\n    private val time = ((vy + sqrt(vy * vy + 64 * h0)) \/ 32)\n\n    fun height(t: Double) = (-16 * t * t + vy * t + h0).rounded()\n    fun horiz(t: Double) = (vx * t).rounded()\n    fun heightEq(): String = \"h(t) = -16.0t^2 + ${vy.rounded()}t\" + if (h0 > 0.0) \" + $h0.0\" else \"\"\n    fun horizEq(): String = \"x(t) = ${vx.rounded()}t\"\n    fun landing() = doubleArrayOf(horiz(time), 0.0, time.rounded())\n    \n    companion object {\n        fun Double.rounded() = round(this * 1000) \/ 1000\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208286,"user_id":null,"body":"package projectile\n\nimport java.math.RoundingMode\nimport java.text.DecimalFormat\n\nclass Projectile(val height: Int, val v0: Int, val angle: Int) {\n\n    val v = v0 * Math.sin(angle * Math.PI \/ 180)\n    val h = v0 * Math.cos(angle * Math.PI \/ 180)\n    val hString = if (height == 0) \"\" else \" + $height.0\"\n\n    fun heightEq(): String = \"h(t) = -16.0t^2 + ${v.roundOffDecimal()}t$hString\"\n\n    fun horizEq(): String = \"x(t) = ${h.roundOffDecimal()}t\"\n\n    fun height(time: Double): Double = (-16 * Math.pow(time, 2.0) + v * time + height).roundOffDecimal()\n\n    fun horiz(time: Double): Double = (h * time).roundOffDecimal()\n\n    fun landing(): DoubleArray {\n        val t = (-v - Math.sqrt(Math.pow(v, 2.0) - 4 * (-16) * height)) \/ (2 * (-16))\n        return doubleArrayOf(horiz(t).roundOffDecimal(), 0.0, t.roundOffDecimal())\n    }\n\n    fun Double.roundOffDecimal(): Double {\n        val df = DecimalFormat(\"#.###\")\n        df.roundingMode = RoundingMode.HALF_UP\n        return df.format(this).toDouble()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208287,"user_id":null,"body":"package projectile\n\nimport java.lang.Math.*\n\nclass Projectile(height: Int, velocity: Int, angle: Int) {\n    var h = height.toDouble()\n    var v0 = velocity.toDouble()\n    var rad = toRadians(angle.toDouble())\n    var vertical = v0 * sin(rad)\n    var dx = v0 * cos(rad)\n    val f = { v: Double, p: Int -> String.format(\"%.${p}f\", v).toDouble().toString() }\n    \n    fun heightEq(): String {\n        val h0 = if (h == 0.0) \"\" else \" + ${f(h, 3)}\"\n        return \"h(t) = -16.0t^2 + ${f(vertical, 3)}t${h0}\"\n    }\n    \n    fun horizEq(): String {\n        return \"x(t) = ${f(dx, 3)}t\"\n    }\n    \n    fun height(time: Double): Double {\n        return f(-16 * time * time + vertical * time + h, 3).toDouble()\n    }\n    \n    fun horiz(time: Double): Double {\n        return f(dx * time, 3).toDouble()\n    }\n    \n    fun landing(): List<Double> {\n        val timeMaxHeight = vertical \/ 32\n        var time = 2 * timeMaxHeight\n        \n        if (h != 0.0) {\n            val dy = vertical * timeMaxHeight - 16 * timeMaxHeight * timeMaxHeight\n            val maxHeight = dy + h\n            val timeDown = sqrt(maxHeight \/ 16)\n            time = timeMaxHeight + timeDown\n        }\n        \n        return listOf(horiz(time), 0.0, f(time, 3).toDouble())\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208288,"user_id":null,"body":"package projectile\n\nimport kotlin.math.*\n\nclass Projectile(startingHeightAsInt: Int, startingVelocityAsInt: Int, angleInDegrees: Int) {\n    private val angle = angleInDegrees * PI \/ 180\n    private val launchHeight = startingHeightAsInt.toDouble()\n    private val launchVelocity = startingVelocityAsInt.toDouble()\n    private val launchHorizontalVelocity = launchVelocity * cos(angle)\n    private val launchVerticalVelocity = launchVelocity * sin(angle)\n\n    fun heightEq(): String {\n        var result =  \"h(t) = -16.0t^2 + ${launchVerticalVelocity.round(3)}t\"\n        if (launchHeight > 0) {\n            result += \" + $launchHeight\"\n        }\n        return result\n    }\n\n    fun horizEq() = \"x(t) = ${launchHorizontalVelocity.round(3)}t\"\n\n    fun height(time: Double) =\n        (-16 * time.pow(2) + launchVerticalVelocity * time + launchHeight).round(3)\n\n    fun horiz(time: Double) = (launchHorizontalVelocity * time).round(3)\n\n    fun landing(): Array<Double> {\n        val timeToLand = solveQuadraticFormula(-16.0, launchVerticalVelocity, launchHeight)\n        val landingHorizontalPosition = horiz(timeToLand)\n        return arrayOf(landingHorizontalPosition.round(3), 0.0, timeToLand.round(3))\n    }\n\n    private fun solveQuadraticFormula(a: Double, b: Double, c: Double): Double {\n        val part1 = b * -1\n        val part2 = sqrt(b.pow(2) - 4 * a * c)\n        val part3 = 2 * a\n\n        val result: Double = (part1 + part2) \/ part3\n\n        return when {\n            result > 0 -> result\n            else -> (part1 - part2) \/ part3\n        }\n    }\n}\n\nfun Double.round(decimalPlaces: Int) = round(this * 10.0.pow(decimalPlaces)) \/ 10.0.pow(decimalPlaces)\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5aff237c578a14752d0035ae":[{"id":208289,"user_id":null,"body":"fun predictAge(vararg age:Int) = (Math.sqrt((age.map{it*it}.sum().toDouble()))\/2).toInt()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208290,"user_id":null,"body":"import kotlin.math.sqrt\n\nfun predictAge(vararg ages: Int): Int =\n    ages.map { it * it }\n        .sum()\n        .toDouble()\n        .let { sqrt(it) }\n        .div(2)\n        .toInt()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208291,"user_id":571,"body":"import kotlin.math.sqrt\nfun predictAge(vararg ages: Int): Int{\n  return (sqrt(ages.fold(1.0){a,b -> a + b*b })\/2).toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208292,"user_id":null,"body":"fun predictAge(age1: Int, age2: Int, age3: Int, age4: Int, age5: Int, age6: Int, age7: Int, age8: Int) = (Math.sqrt(arrayOf(age1, age2, age3, age4, age5, age6, age7, age8).map { it * it}.sum().toDouble()) \/ 2).toInt()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208293,"user_id":null,"body":"import kotlin.math.sqrt\n\nfun predictAge(vararg ages: Int): Int{\n  return (sqrt(ages.sumBy { it * it }.toDouble()) \/ 2).toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208294,"user_id":null,"body":"import kotlin.math.sqrt\n\nfun predictAge(vararg ages: Int): Int = (sqrt(ages.sumOf { it * it }.toDouble()) \/ 2).toInt()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208295,"user_id":null,"body":"fun predictAge(vararg age: Int): Int = (Math.sqrt(age.sumOf { it * it }.toDouble()).toInt() \/ 2)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208296,"user_id":null,"body":"import kotlin.math.*\n\nfun predictAge(vararg age: Int) = (sqrt(age.sumBy{ it*it}*1.0)\/2).toInt()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208297,"user_id":null,"body":"import kotlin.math.sqrt\n\nfun predictAge(vararg ages: Int): Int =\n        (sqrt(ages.map { it*it }.sum().toDouble())\/2).toInt()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208298,"user_id":null,"body":"import kotlin.math.sqrt\n\nfun predictAge(vararg age: Int) = (sqrt((age.map { it * it }.sum().toDouble())) \/ 2).toInt()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5b06c990908b7eea73000069":[{"id":208299,"user_id":null,"body":"package solv\nimport kotlin.math.*\n\nfun f(x: Double, y: Double, eps: Double) = hypot(x, y).let {\n    if (it < 1) log(eps, it).toInt() else -1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208300,"user_id":492,"body":"package solv\n\nprivate fun modul(x: Double, y: Double): Double {\n    if (x != 0.0 || y != 0.0)\n        return Math.sqrt(x * x + y * y)\n    else\n        return 0.0\n}\nfun f(x: Double, y: Double, eps: Double): Int {\n    if (modul(x, y) >= 1.0)\n        return -1\n    return (Math.log(eps) \/ Math.log(modul(x, y))).toInt()\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208301,"user_id":527,"body":"package solv\n\nimport kotlin.math.*\n\nfun f(x: Double, y: Double, eps: Double): Int {\n    val m = hypot(x, y)\n    return if (m < 1) log(eps, m).toInt() else -1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208302,"user_id":53,"body":"package solv\n\nfun f(x: Double, y: Double, eps: Double): Int {\n    val ans = Math.log(eps) \/ Math.log(Math.hypot(x, y))\n    if (ans < 0) { return -1 }\n    return ans.toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208303,"user_id":168,"body":"package solv\n\nfun f(x: Double, y: Double, eps: Double): Int {\n    val a = Math.hypot(x, y)\n    if (a >= 1) {\n        return -1\n    } else {\n        return (Math.log(eps) \/ Math.log(a)).toInt()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208304,"user_id":null,"body":"package solv\nimport kotlin.math.log\nimport kotlin.math.hypot\nimport kotlin.math.sqrt\n\nfun f(x: Double, y: Double, eps: Double): Int = with(hypot(x, y)) {\n    return if (this >= 1.0)\n        -1\n    else\n        (log(eps, 10.0) \/ log(this, 10.0)).toInt()\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208305,"user_id":null,"body":"package solv\nimport kotlin.math.log\nimport kotlin.math.sqrt\n\nfun f(x: Double, y: Double, eps: Double): Int = with(modulus(x, y)) {\n    return if (this >= 1.0)\n        -1\n    else\n        (log(eps, 10.0) \/ log(this, 10.0)).toInt()\n}\n\nfun modulus(x: Double, y: Double) = if (x == 0.0 || y == 0.0) 0.0 else sqrt(x * x + y * y)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208306,"user_id":null,"body":"package solv\n\nimport kotlin.math.absoluteValue\nimport kotlin.math.pow\n\nfun f(x: Double, y: Double, eps: Double): Int {\n    val d = (x.pow(2)+y.pow(2)).pow(0.5)\n    var n = 0\n    if (d >= 1) return -1\n\n    while (d.pow(n + 1).absoluteValue >= eps) { ++n }\n    return n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208307,"user_id":null,"body":"package solv\n\nimport kotlin.math.ceil\nimport kotlin.math.ln\nimport kotlin.math.max\n\nfun f(x: Double, y: Double, eps: Double): Int {\n    val norm = x*x + y*y\n    if (norm>=1.0) return -1\n\n    return max(0.0, ceil(ln(eps)*2\/ln(norm) - 1)).toInt()\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208308,"user_id":null,"body":"package solv\n\nfun f(x: Double, y: Double, eps: Double): Int {\n    val res = Math.log(eps) \/ Math.log(Math.hypot(x, y))\n    return if (res < 0) -1 else res.toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5b0a80ce84a30f4762000069":[{"id":208309,"user_id":null,"body":"class Dinglemouse {\n    private val info = linkedMapOf(\"hello\" to \"Hello.\")\n\n    fun setAge(age: Int) = apply { info[\"age\"] = \"I am $age.\" }\n    fun setSex(sex: Char) = apply { info[\"sex\"] = \"I am ${if (sex == 'M') \"male\" else \"female\"}.\" }\n    fun setName(name: String) = apply { info[\"name\"] = \"My name is $name.\" }\n\n    fun hello() = info.values.joinToString(\" \")\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208310,"user_id":null,"body":"class Dinglemouse {\n\n    private var name: String = \"\"\n    private var age: Int = 0\n    private var sex: Char = ' '\n    private var order = mutableSetOf<Char>()\n\n    fun setAge(age: Int): Dinglemouse {\n        this.age = age\n        this.order += 'a'\n        return this\n    }\n\n    fun setSex(sex: Char): Dinglemouse {\n        this.sex = sex\n        this.order += 's'\n        return this\n    }\n\n    fun setName(name: String): Dinglemouse {\n        this.name = name\n        this.order += 'n'\n        return this\n    }\n\n    fun hello(): String {\n        val gender = if (sex=='M') \"male\" else \"female\"\n        var ret = \"Hello. \" + order.map {\n            when (it) {\n                'a' -> \"I am $age.\"\n                's' -> \"I am $gender.\"\n                'n' -> \"My name is $name.\"\n                else -> \"\"\n            }\n        }.joinToString(\" \")\n        return ret.trim()\n    }\n\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208311,"user_id":null,"body":"import java.util.*\n\nclass Dinglemouse {\n\n    private val map = LinkedHashMap<String, Any>()\n\n    fun setAge(age: Int) = apply { map[\"age\"] = \"I am $age.\" }\n    fun setSex(sex: Char) = apply { map[\"sex\"] = \"I am ${if (sex == 'M') \"male\" else \"female\"}.\" }\n    fun setName(name: String) = apply { map[\"name\"] = \"My name is $name.\" }\n\n    fun hello() = (listOf(\"Hello.\") + map.values).joinToString(\" \")\n\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208312,"user_id":null,"body":"class Dinglemouse {\n  \n    private var mutableMap :MutableMap<String, String> = mutableMapOf()\n\n    init {\n        mutableMap[\"hello\"] = \"Hello.\"\n    }\n\n    fun setAge(age: Int): Dinglemouse {\n        mutableMap[\"age\"] = \" I am $age.\"\n        return this\n    }\n\n    fun setSex(sex: Char): Dinglemouse {\n        mutableMap[\"sex\"]= \" I am \" + if (sex == 'M') \"male.\" else \"female.\"\n        return this\n    }\n\n    fun setName(name: String): Dinglemouse {\n        mutableMap[\"name\"]= \" My name is $name.\"\n        return this\n    }\n\n    fun hello(): String {\n        var result = \"\"\n        mutableMap.map { result += it.value }\n        return result\n    }\n\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208313,"user_id":null,"body":"import java.util.*\n\nclass Dinglemouse {\n    private val params = LinkedHashMap<String, Any>()\n\n    fun setAge(age: Int): Dinglemouse {\n        params[\"age\"] = age\n        return this\n    }\n\n    fun setSex(sex: Char): Dinglemouse {\n        params[\"sex\"] = sex\n        return this\n    }\n\n    fun setName(name: String): Dinglemouse {\n        params[\"name\"] = name\n        return this\n    }\n\n    fun hello(): String {\n        val resultString = mutableListOf(\"Hello\") + params.toList().map{\n            when(val param = it.second){\n                is Int -> \"I am $param\"\n                is Char -> \"I am \" + if (param == 'M') \"male\" else \"female\"\n                is String -> \"My name is $param\"\n                else -> \"\"\n            }\n        }\n        return resultString.joinToString(separator = \". \", postfix = \".\")\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208314,"user_id":null,"body":"class Dinglemouse {\n    private var linkedHashMap = linkedMapOf(\"greeting\" to \"Hello.\")\n\n    fun setAge(age: Int): Dinglemouse {\n        linkedHashMap[\"age\"] = \"I am $age.\"\n        return this\n    }\n    fun setSex(sex: Char): Dinglemouse {\n        linkedHashMap[\"sex\"] = \"I am %s.\".format(if (sex == 'M') \"male\" else \"female\")\n        return this\n    }\n    fun setName(name: String): Dinglemouse {\n        linkedHashMap[\"name\"] = \"My name is $name.\"\n        return this\n    }\n    fun hello(): String = linkedHashMap.values.reduce { acc, s -> \"$acc $s\" }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208315,"user_id":null,"body":"class Dinglemouse {\n\n    private var name: String = \"\"\n    private var age: Int = 0\n    private var sex: Char = ' '\n    private var schema: String=\"\"\n    fun setAge(age: Int): Dinglemouse {\n        this.age = age\n        this.schema+=\"a\"\n        return this\n    }\n\n    fun setSex(sex: Char): Dinglemouse {\n        this.sex = sex\n        this.schema+=\"s\"\n        return this\n    }\n\n    fun setName(name: String): Dinglemouse {\n        this.name = name\n        this.schema+=\"n\"\n        return this\n    }\n\n    fun hello(): String {\n        println(this.schema)\n        var list:MutableList<String> =mutableListOf(\"Hello.\")\n        var s:String=this.schema\n        var index:Int=0\n        while(index<s.length){\n            val item=s[index]\n            if(item=='a')list.add(\"I am $age.\")\n            if(item=='s')list.add(\"I am \"+(if(this.sex=='M') \"male\" else \"female\")+\".\")\n            if(item=='n')list.add(\"My name is $name.\")\n            s=s.filter{it!=item}\n        }\n        return list.joinToString(\" \")\n    }\n\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208316,"user_id":null,"body":"class Dinglemouse {\n    private val data = mutableMapOf<DataType, String>()\n\n    fun setAge(age: Int): Dinglemouse {\n        data[DataType.AGE] = age.toString()\n        return this\n    }\n\n    fun setSex(sex: Char): Dinglemouse {\n        data[DataType.SEX] =\n            when (sex) {\n                'M' -> \"male\"\n                'F' -> \"female\"\n                else -> \"unrecognized input\"\n            }\n        return this\n    }\n\n    fun setName(name: String): Dinglemouse {\n        data[DataType.NAME] = name\n        return this\n    }\n\n    fun hello(): String {\n        val acc = data.map { (type, value) ->\n            when (type) {\n                DataType.NAME -> \"My name is $value\"\n                DataType.AGE -> \"I am $value\"\n                DataType.SEX -> \"I am $value\"\n            }\n        }\n        return if (acc.isEmpty()) {\n            \"Hello.\"\n        } else {\n            \"Hello. \" + acc.joinToString(\". \") + \".\"\n        }\n    }\n\n    enum class DataType {\n        NAME, AGE, SEX\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208317,"user_id":null,"body":"class Dinglemouse {\n    private val order = mutableListOf<String>()\n    private var resultMap: MutableMap<String, String> = mutableMapOf()\n    private var result: String = \"Hello.\"\n\n    fun setAge(age: Int): Dinglemouse {\n        if (!resultMap.containsKey(\"age\")) order.add(\"age\")\n        resultMap[\"age\"] = \" I am $age.\"\n        return this\n    }\n\n    fun setSex(sex: Char): Dinglemouse {\n        if (!resultMap.containsKey(\"sex\")) order.add(\"sex\")\n        resultMap[\"sex\"] = \" I am ${if (sex == 'M') \"male\" else \"female\"}.\"\n        return this\n    }\n\n    fun setName(name: String): Dinglemouse {\n        if (!resultMap.containsKey(\"name\")) order.add(\"name\")\n        resultMap[\"name\"] = \" My name is $name.\"\n        return this\n    }\n\n    fun hello(): String {\n        for (i in order) {\n            result = \"$result${resultMap[i]}\"\n        }\n        return result\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208318,"user_id":null,"body":"class Dinglemouse {\n\n    private val gender = mapOf('M' to \"male\", 'F' to \"female\")\n    private val parts = mapOf(\"age\" to \"I am $.\", \"name\" to \"My name is $.\", \"sex\" to \"I am $.\")\n    private val map: LinkedHashMap<String, String> = LinkedHashMap()\n\n    fun setAge(age: Int): Dinglemouse {\n        map[\"age\"] = age.toString()\n        return this\n    }\n\n    fun setSex(sex: Char): Dinglemouse {\n        map[\"sex\"] = gender[sex]!!\n        return this\n    }\n\n    fun setName(name: String): Dinglemouse {\n        map[\"name\"] = name\n        return this\n    }\n\n    fun hello(): String = map.entries.joinToString(\" \", prefix = \"Hello. \") { parts[it.key]!!.replace(\"$\", it.value) }.trim()\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5b0c0ec907756ffcff00006e":[{"id":208319,"user_id":527,"body":"package quadratiq\n\nfun quadratic(a: Double, b: Double, c: Double): Double {\n    return -c \/ b\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208320,"user_id":null,"body":"package quadratiq\n\nfun quadratic(a:Double, b:Double, c:Double):Double {\n  val d = (b * b) - (4 * a * c)\n  val x2 = (-b - Math.sqrt(d)) \/ (2 * a)\n  return c \/ (a * x2)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208321,"user_id":492,"body":"package quadratiq\n\nfun quadratic(@Suppress(\"UNUSED_PARAMETER\") a:Double, b:Double, c:Double):Double {\n    return -c \/ b\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208322,"user_id":null,"body":"package quadratiq\nimport kotlin.math.abs\nimport kotlin.math.pow\nimport kotlin.math.sign\nimport kotlin.math.sqrt\n\nfun quadratic(a: Double, b: Double, c: Double): Double {\n\n    val d = b.pow(2) - (4.0 * a * c)\n    val u1 = -b - b.sign * sqrt(d)\n\n    val x1 = u1.div((2.0 * a))\n    val x2 = c.div(a * x1)\n\n    return if (abs(x1) > abs(x2)) x2 else x1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208323,"user_id":null,"body":"package quadratiq\nimport java.math.MathContext\n\nfun quadratic(a:Double, b:Double, c:Double):Double {\n    val a1 = a.toBigDecimal()\n    val b1 = b.toBigDecimal()\n    val c1 = c.toBigDecimal()\n\n    val d = b1.pow(2) - (4.0.toBigDecimal() * a1 * c1)\n    val sqd = d.sqrt(MathContext.DECIMAL128)\n    val u1 = -b1 - b1.signum().toBigDecimal() * sqd\n\n    val x1 = u1.divide((2.0.toBigDecimal() * a1), MathContext.DECIMAL128)\n    val x2 = c1.divide(a1 * x1, MathContext.DECIMAL128)\n\n    return if( x1.abs() > x2.abs())\n        x2.toDouble()\n    else\n        x1.toDouble()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208324,"user_id":null,"body":"package quadratiq\n\nimport kotlin.math.sqrt\n\nfun quadratic(a:Double, b:Double, c:Double):Double {\n    return (2 * c) \/ (- b - sqrt(b * b - 4 * a * c))\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208325,"user_id":null,"body":"package quadratiq\n\nfun quadratic(a:Double, b:Double, c:Double):Double {\n    \/\/ your code\n    return -c \/ b\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208326,"user_id":null,"body":"package quadratiq\nimport kotlin.math.*\n\nfun quadratic(a:Double, b:Double, c:Double):Double = -c\/b","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208327,"user_id":null,"body":"package quadratiq\n\nfun quadratic(a:Double, b:Double, c:Double):Double {\n    return 0 * a - c \/ b\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208328,"user_id":null,"body":"package quadratiq\n\nfun quadratic(a:Double, b:Double, c:Double):Double {\n    val d = (b * b) - (4 * a * c)\n    val x = (-b - Math.sqrt(d))\/(2*a)\n    return c \/ (a * x)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5b180e9fedaa564a7000009a":[{"id":208329,"user_id":2403,"body":"object FixStringCase {\n    fun solve(s: String): String = if (s.count { it.isLowerCase() } >= s.length\/2.0) s.toLowerCase() else s.toUpperCase()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208330,"user_id":null,"body":"object FixStringCase {\n    \n    fun solve(s: String): String{\n        if (s.count { it.isUpperCase() } > s.length \/ 2) return s.toUpperCase() \n        else return s.toLowerCase()\n        \n    }\n\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208331,"user_id":null,"body":"object FixStringCase {\n  fun solve(s: String) = if (s.count(Char::isUpperCase) * 2 > s.length) s.toUpperCase() else s.toLowerCase()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208332,"user_id":null,"body":"object FixStringCase {\n\n    fun solve(inputString: String) = when {\n        hasMoreUppercaseThanLowercase(inputString) -> inputString.toUpperCase()\n        else -> inputString.toLowerCase()\n    }\n\n    private fun hasMoreUppercaseThanLowercase(inputString: String): Boolean {\n        val (upperCases, lowerCases) = inputString.toCharArray().partition { char -> char.isUpperCase() }\n        return upperCases.size > lowerCases.size\n    }\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208333,"user_id":null,"body":"object FixStringCase {\n    \n    fun solve(s: String): String {\n        s.partition { it.toInt() < 96 }.let { \n            return if (it.first.length > it.second.length) s.toUpperCase() \n            else s.toLowerCase() \n        }\n    }\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208334,"user_id":null,"body":"object FixStringCase {\n    \nfun solve(s: String): String = s.count { it.isUpperCase() }.let { u ->\n    if (u > s.count { it.isLowerCase() }) {\n        s.toUpperCase()\n    } else {\n        s.toLowerCase()\n    }\n}\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208335,"user_id":null,"body":"object FixStringCase {\n    \n    fun solve(s: String): String {\n        if(isUpper(s) > isLower(s)){\n            return s.toUpperCase()\n        }else{\n             return s.toLowerCase()\n        }\n    }\n\n    fun isLower(str: String):Int{\n        var count=0;\n        str.map { if(it.isLowerCase()) {\n            count ++;\n    \t    }\n        }\n        return count;\n    }\n    \n    fun isUpper(str: String):Int{\n        var count=0;\n        str.map { if(it.isUpperCase()) {\n            count ++;\n    \t    }\n        }\n    return count;          \n    } \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208336,"user_id":null,"body":"object FixStringCase {\n    \n    fun solve(s: String): String {\n        val p = s.partition { it.isUpperCase() }\n        return if (p.first.count() > p.second.count()) {\n            s.uppercase()\n        } else s.lowercase()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208337,"user_id":null,"body":"object FixStringCase {\n    \n    fun solve(s: String): String {\n        val p = s.partition { it.isUpperCase() }\n        if (p.first.count() > p.second.count())\n        {\n            return s.uppercase()\n        } else return s.lowercase()\n    }\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208338,"user_id":null,"body":"object FixStringCase {\n    \n    fun solve(s: String) = with(s) {\n        if (count { it.isUpperCase() } > count { it.isLowerCase() }) uppercase() else lowercase()\n    }\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5b1cd19fcd206af728000056":[{"id":208339,"user_id":53,"body":"package solv\nimport kotlin.math.sqrt\n\nfun solve(m:Double):Double {\n  return (2 * m + 1 - sqrt(4 * m + 1)) \/ (2 * m)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208340,"user_id":492,"body":"package solv\n\nfun solve(m:Double):Double {\n  val s = Math.sqrt(4 * m + 1)\n  return (2 * m + 1 - s) \/ (2 * m)\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208341,"user_id":null,"body":"package solv\n\nimport kotlin.math.sqrt\n\nfun solve(m: Double): Double = 1 + (0.5 - sqrt(0.25 + m)) \/ m\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208342,"user_id":191,"body":"package solv\n\nval solve = { m: Double -> 1+(.5-Math.sqrt(.25+m))\/m }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208343,"user_id":null,"body":"package solv\n\nimport kotlin.math.sqrt\n\nfun solve(m: Double) = 1 + (1 - sqrt(4 * m + 1)) \/ (2 * m)\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208344,"user_id":null,"body":"package solv\n\nimport kotlin.math.sqrt\n\nfun solve(m: Double): Double = (2 + 1 \/ m).let {\n    (it - sqrt(it * it - 4)) \/ 2\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208345,"user_id":null,"body":"package solv\n\nimport kotlin.math.sqrt\n\nfun solve(m:Double):Double {\n  return (2.0*m+1.0 - sqrt((2.0*m+1.0)*(2.0*m+1.0)-4.0*m*m))\/(2.0*m) \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208346,"user_id":null,"body":"package solv\n\nimport kotlin.math.sqrt\n\nfun solve(m: Double): Double = ((2 * m) + 1 - sqrt(-1 * (-4 * m - 1))) \/ (2 * m)\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208347,"user_id":50,"body":"package solv\nimport kotlin.math.*\n\nfun solve(m:Double):Double {\n    return (2.0*m+1.0-((4.0*m+1.0).pow(0.5)))\/(2.0*m);\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208348,"user_id":null,"body":"package solv\n\nfun solve(s:Double):Double {\n  return (1 - Math.sqrt(4 * s + 1)) \/ (2.0 * s) + 1;\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5b2e60742ae7543f9d00005d":[{"id":208349,"user_id":null,"body":"class CircularList<T>(vararg val elements: T) {\n    var i = -1\n    init {\n        if(elements.size == 0) throw Exception()\n    }\n    fun next(): T {\n        i = (i + 1) % elements.size\n        return elements[i]\n    }\n    fun prev(): T {\n        i = ( if(i < 1) elements.size else i ) - 1\n        return elements[i]\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208350,"user_id":null,"body":"class CircularList<T>(vararg val elements: T) {\n    var i = -1\n    init { if(elements.isEmpty()) throw Exception() }\n    fun next() = elements.getOrNull(++i) ?: run { i = 0; elements.first() }\n    fun prev() = elements.getOrNull(--i) ?: run { i = elements.lastIndex; elements.last() }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208351,"user_id":null,"body":"class CircularList<T>(vararg val elements: T) {\n    private var e = elements\n    private var ptr = -1\n    private var len = elements.count()\n    \n    init {\n        if (elements.count() == 0) throw Exception(\"Oh No!\")\n    }\n    \n    fun next(): T {\n        ptr = (++ptr)%len\n        return e[ptr]\n    }\n\n    fun prev(): T {\n        if (--ptr < 0) ptr = len-1\n        return e[ptr]\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208352,"user_id":168,"body":"class CircularList<T>(vararg val elements: T) {\n    var i = -1\n    \n    init {\n        if (elements.isEmpty()) throw Exception()\n    }\n    \n    fun next(): T {\n        i = (i + 1) % elements.size\n        return elements[i]\n    }\n\n    fun prev(): T {\n        i = if (i <= 0) elements.lastIndex else i - 1\n        return elements[i]\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208353,"user_id":null,"body":"class CircularList<T>(vararg val elements: T) {\n    var i: Int = -1\n\n    init {\n        require(elements.size > 0)\n    }\n\n    fun move(delta: Int): T {\n        i = Math.max(i + delta, -1)\n        i = Math.floorMod(i, elements.size)\n        return elements[i]\n    }\n\n    fun next(): T = move(1)\n    fun prev(): T = move(-1)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208354,"user_id":null,"body":"class CircularList<T>(private vararg val elements: T) {\n    init {\n        if (elements.isEmpty()) {\n            throw IllegalArgumentException(\"Must have at least one element.\")\n        }\n    }\n\n    private var cursor = -1\n\n    fun next(): T {\n        cursor = when (cursor) {\n            -1, elements.lastIndex -> 0\n            else -> cursor + 1\n        }\n        return elements[cursor]\n    }\n\n    fun prev(): T {\n        cursor = when (cursor) {\n            -1, 0 -> elements.lastIndex\n            else -> cursor - 1\n        }\n        return elements[cursor]\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208355,"user_id":null,"body":"class CircularList<T>(vararg val elements: T) {\n    private var currentIndex: Int? = null\n    init {\n        if (elements.isEmpty())\n            throw Exception()\n    }\n\n    fun next(): T = (currentIndex?.plus(1)?.rem(elements.size) ?: 0).let {\n        currentIndex = it\n        elements[it]\n    }\n    fun prev(): T = (currentIndex?.minus(1)?.plus(elements.size)?.rem(elements.size) ?: elements.lastIndex).let {\n        currentIndex = it\n        elements[it]\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208356,"user_id":null,"body":"class CircularList<T>(vararg val elements: T) {\n    \n    init {\n        if (elements.isEmpty()) throw Exception()\n    }\n    \n    var ind: Int = -1\n    \n    fun next(): T {\n        ind ++\n        if (ind > elements.size-1) ind = 0\n        return elements[ind]\n    }\n\n    fun prev(): T {\n        ind --\n        if (ind < 0) ind = elements.size-1\n        return  elements[ind]\n    }\n}\n ","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208357,"user_id":null,"body":"\nclass CircularList<T>(vararg val elements: T) {\n\n    init {\n        if (elements.isNullOrEmpty()) {\n            throw Exception()\n        }\n    }\n\n    private var current = -1\n    fun next(): T {\n        if (elements.isNullOrEmpty()) {\n            throw Exception()\n        }\n        if (current + 1 > elements.size - 1){\n            current = 0\n        } else {\n            current += 1\n        }\n        return elements[current]\n    }\n\n    fun prev(): T {\n        if (elements.isNullOrEmpty()) {\n            throw Exception()\n        }\n        if (current - 1 >= 0 ) {\n            current -= 1\n        } else {\n            current = elements.size - 1\n        }\n        return elements[current]\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208358,"user_id":null,"body":"class CircularList<T>(vararg val elements: T) {\n    private var pos: Int\n\n    fun next(): T {\n        if (pos in 0 until elements.lastIndex) pos++\n        else pos = 0\n\n        return elements[pos]\n    }\n\n    fun prev(): T {\n        if (pos in 1 until elements.size) pos--\n        else pos = elements.lastIndex\n\n        return elements[pos]\n    }\n\n    init {\n        if (elements.isEmpty()) throw Exception(\"input contains no values\")\n        this.pos = -1\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5b40b666dfb4291ad9000049":[{"id":208359,"user_id":53,"body":"package solv\n\nfun solve(a:Int, b:Int, c:Int, alpha:Int, beta:Int, gamma:Int):IntArray {\n  val u = alpha * Math.PI \/ 180\n  val v = beta * Math.PI \/ 180\n  val w = gamma * Math.PI \/ 180\n  val x = a * Math.cos(u) - b * Math.sin(v) - c * Math.cos(w)\n  val y = a * Math.sin(u) + b * Math.cos(v) - c * Math.sin(w)\n  val t = Math.atan2(y, x) * 180 \/ Math.PI\n  val r = Math.hypot(y, x)\n  return intArrayOf(Math.round(r).toInt(), t.toInt(), (t*60).toInt()%60, (t*3600).toInt()%60)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208360,"user_id":492,"body":"package solv\n\nimport java.util.Arrays\n\nfun solve(a:Int, b:Int, c:Int, alpha:Int, beta:Int, gamma:Int):IntArray {\n  val aa = alpha * Math.PI \/ 180\n  val bb = beta * Math.PI \/ 180\n  val cc = gamma * Math.PI \/ 180\n  val x = a * Math.cos(aa) - b * Math.sin(bb) - c * Math.cos(cc)\n  val y = a * Math.sin(aa) + b * Math.cos(bb) - c * Math.sin(cc)\n  val r = Math.sqrt(x * x + y * y)\n  val theta = (Math.acos(x \/ r) * 180.0 * 3600.0 \/ Math.PI).toInt()\n  val d = theta \/ 3600\n  val mm = theta % 3600\n  val m = mm \/ 60\n  val s = mm % 60\n  return intArrayOf(Math.round(r).toInt(), d, m, s)\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208361,"user_id":null,"body":"package solv\n\nimport kotlin.math.atan2\nimport kotlin.math.cos\nimport kotlin.math.PI\nimport kotlin.math.roundToInt\nimport kotlin.math.sin\nimport kotlin.math.sqrt\n\nval deg_to_rad = PI\/180\nval rad_to_deg = 180\/PI\n\nfun sqr(x :Double) = x*x\n\nfun solve(a :Int, b :Int, c :Int, alpha :Int, beta :Int, gamma :Int)   :IntArray {\n  var x = a*cos(alpha*deg_to_rad)\n  var y = a*sin(alpha*deg_to_rad)\n  x -= b*sin(beta*deg_to_rad)\n  y += b*cos(beta*deg_to_rad)\n  x -= c*cos(gamma*deg_to_rad)\n  y -= c*sin(gamma*deg_to_rad)\n  val r = sqrt(sqr(x)+sqr(y))\n  if (r==0.0)\n    return intArrayOf(0, 0, 0, 0)\n  val phi = atan2(y, x)*rad_to_deg\n  val deg = phi.toInt()\n  val min = ((phi-deg.toDouble())*60).toInt()\n  val sec = (((phi-deg.toDouble())*60-min.toDouble())*60).toInt()\n  return intArrayOf(r.roundToInt(), deg, min, sec)\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208362,"user_id":null,"body":"package solv\n\nimport kotlin.math.*\n\nfun solve(a: Int, b: Int, c: Int, alpha: Int, beta: Int, gamma: Int): IntArray {\n    val va = Vector.fromPolar(a.toDouble(), alpha.toDouble().toRadians())\n    val vb = Vector.fromPolar(b.toDouble(), (90.0 + beta).toRadians())\n    val vc = Vector.fromPolar(c.toDouble(), (180.0 + gamma).toRadians())\n    val result = va + vb + vc\n    return (listOf(result.length.roundToInt()) + result.direction.toDegreeMinSec().toList()).toIntArray()\n}\n\ndata class Vector(val a: Double, val b: Double) {\n    val direction: Double\n        get() = atan2(b, a)\n    val length: Double\n        get() = sqrt(a * a + b * b)\n\n    companion object {\n        fun fromPolar(length: Double, direction: Double): Vector =\n            Vector(length * cos(direction), length * sin(direction))\n    }\n\n}\n\noperator fun Vector.plus(other: Vector) = Vector(this.a + other.a, this.b + other.b)\n\nfun Double.toDegrees() = this \/ PI * 180.0\nfun Double.toRadians() = this \/ 360.0 * 2 * PI\n\nfun Double.toDegreeMinSec(): Triple<Int, Int, Int> {\n    val degreesDouble = toDegrees()\n    val degrees = degreesDouble.toInt()\n    val minutes = ((degreesDouble - degrees) * 60.0).toInt()\n    val seconds = ((degreesDouble - degrees - minutes \/ 60.0) * 3600.0).toInt()\n    return Triple(degrees, minutes, seconds)\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208363,"user_id":null,"body":"package solv\n\nimport kotlin.math.*\n\nfun solve(a:Int, b:Int, c:Int, alpha:Int, beta:Int, gamma:Int):IntArray {\n    \n    var rad = PI\/180\n    var a = arrayOf(cos(rad*alpha)*a,sin(rad*alpha)*a)\n    \n\n    var b = arrayOf(-sin(rad*beta)*b+a[0], cos(rad*beta)*b+a[1])\n    \n\n    var c = arrayOf(-cos(rad*gamma)*c+b[0], -sin(rad*gamma)*c+b[1])\n    \n\n    var length =  sqrt(c[0]*c[0]+c[1]*c[1]).roundToInt()\n    var angle = 180+atan(c[1]\/c[0])*180\/PI\n    val degree = angle.toInt()\n    val minutes = ((angle-degree)*60).toInt()\n    val seconds = (((angle-degree)*60 - minutes)*60).toInt()\n\n\n    return arrayOf(length,degree,minutes,seconds).toIntArray()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208364,"user_id":null,"body":"package solv\n\nimport kotlin.math.*\n\nfun solve(a:Int, b:Int, c:Int, alpha:Int, beta:Int, gamma:Int):IntArray {\n\n    val sx = a * cos(alpha.toRad()) + b * cos((beta + 90).toRad()) + c * cos((gamma + 180).toRad())\n    val sy = a * sin(alpha.toRad()) + b * sin((beta + 90).toRad()) + c * sin((gamma + 180).toRad())\n\n    val r = sqrt(sx * sx + sy * sy).roundToInt()\n\n    val d = atan2(sy, sx).toDeg()\n    val h = d.toInt()\n    val m = ((d - h) * 60).toInt()\n    val s = ((d - h - m \/ 60.0) * 3600).toInt()\n\n    return intArrayOf(r, h, m, s)\n}\n\nfun Int.toRad() = this * PI \/ 180\nfun Double.toDeg() = this * 180 \/ PI","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208365,"user_id":null,"body":"package solv\n\nfun solve(a:Int, b:Int, c:Int, alpha:Int, beta:Int, gamma:Int):IntArray {\n  val xc = a * Math.cos(alpha * Math.PI \/ 180) - b * Math.sin(beta * Math.PI \/ 180) - c * Math.cos(gamma * Math.PI \/ 180)\n    val yc = a * Math.sin(alpha * Math.PI \/ 180) + b * Math.cos(beta * Math.PI \/ 180) - c * Math.sin(gamma * Math.PI \/ 180)\n    val oc = Math.round(Math.sqrt(xc*xc + yc * yc))\n    var toc = Math.atan2(yc, xc) * 180 \/ Math.PI\n    val degree = Math.floor(toc)\n    toc = (toc - degree) * 60\n    val minute = Math.floor(toc)\n    val second = Math.floor((toc - minute) * 60)\n    return intArrayOf(oc.toInt(), degree.toInt(), minute.toInt(), second.toInt())\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208366,"user_id":null,"body":"package solv\n\nfun vector(c:Int, alpha:Double) = Pair(Math.cos(Math.toRadians(alpha)) * c, Math.sin(Math.toRadians(alpha)) * c)\nfun solve(a:Int, b:Int, c:Int, alpha:Int, beta:Int, gamma:Int): IntArray{\n    val A = vector(a, alpha.toDouble())\n    var x = A.first\n    var y = A.second\n    val B = vector(b, (beta + 90).toDouble())\n    x = x + B.first\n    y = y + B.second\n    val C = vector(c, (gamma + 180).toDouble())\n    x = x + C.first\n    y = y + C.second\n    val distance = Math.round(Math.sqrt(Math.pow(x, 2.0) + Math.pow(y, 2.0))).toInt()\n    val angle = Math.toDegrees(Math.atan(y \/ x)) + 180.0\n    val degrees = angle.toInt()\n    val minutesDouble = (angle % 1.0) * (3.0\/5.0) * 100.0\n    val minutes = minutesDouble.toInt()\n    val secondsDouble = (minutesDouble % 1.0) * (3.0\/5.0) * 100.0\n    val seconds = secondsDouble.toInt()\n    return intArrayOf(distance, degrees, minutes, seconds)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208367,"user_id":null,"body":"package solv\nimport kotlin.math.*\n\ndata class Point(val x:Double, val y:Double)\n\ndata class Soca(val sin:Double, val cos:Double)\n\nfun mkSoca(angle: Int):Soca = Soca(sin(Math.toRadians(angle.toDouble())), cos(Math.toRadians(angle.toDouble())))\n\nfun solve(a:Int, b:Int, c:Int, alpha:Int, beta:Int, gamma:Int):IntArray {\n    val t = mkSoca(alpha)\n    val A = Point(t.cos * a, t.sin * a)\n\n    val h = mkSoca(beta)\n    val B = Point(A.x - h.sin * b, A.y + h.cos * b)\n\n    val u = mkSoca(gamma)\n    val C = Point(B.x - u.cos * c, B.y - u.sin * c)\n\n    val distance = sqrt(C.x * C.x + C.y * C.y)\n    val cosC = C.x \/ distance\n    val deg = Math.toDegrees(acos(cosC)) * 60 * 60\n\n    val seconds = deg % 60\n    val minutes = (deg \/ 60) % 60\n    val degrees = ((deg \/ 60) \/ 60)\n\n    return intArrayOf(distance.roundToInt(), degrees.toInt(), minutes.toInt(), seconds.toInt())\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208368,"user_id":null,"body":"package solv\n\nimport kotlin.math.*\n\nfun solve(a: Int, b: Int, c: Int, alpha: Int, beta: Int, gamma: Int): IntArray {\n    val va = Vector.fromPolar(a.toDouble(), alpha.toDouble().toRadiant())\n    val vb = Vector.fromPolar(b.toDouble(), (90.0 + beta).toRadiant())\n    val vc = Vector.fromPolar(c.toDouble(), (180.0 + gamma).toRadiant())\n    val result = va + vb + vc\n    return (listOf(result.length.roundToInt()) + result.direction.toDegreeMinSec().toList()).toIntArray()\n}\n\ndata class Vector(val a: Double, val b: Double) {\n    val direction: Double\n        get() = atan2(b, a)\n    val length: Double\n        get() = sqrt(a * a + b * b)\n\n    companion object {\n        fun fromPolar(length: Double, direction: Double): Vector =\n            Vector(length * cos(direction), length * sin(direction))\n    }\n\n}\n\noperator fun Vector.plus(other: Vector) = Vector(this.a + other.a, this.b + other.b)\n\nfun Double.toDegrees() = this \/ PI * 180.0\nfun Double.toRadiant() = this \/ 360.0 * 2 * PI\n\nfun Double.toDegreeMinSec(): Triple<Int, Int, Int> {\n    val degreesDouble = toDegrees()\n    val degrees = degreesDouble.toInt()\n    val minutes = ((degreesDouble - degrees) * 60.0).toInt()\n    val seconds = ((degreesDouble - degrees - minutes \/ 60.0) * 3600.0).toInt()\n    return Triple(degrees, minutes, seconds)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5b5fe164b88263ad3d00250b":[{"id":208369,"user_id":null,"body":"package kata\n\nobject Cryptarithm {\n    private val allDigits = (0..9).toList()\n    \n    fun alphametics(puzzle: String): String {\n        val words = puzzle.split(\" \").filter { it.toCharArray().all { l -> l.isLetter() } }.map { it.toCharArray() }\n        val firstChars = words.map { it.first() }\n        val numLetters = words.flatMap { it.toList() }.distinct().size\n\n        fun isValid(assignment: Map<Char, Int>) =\n            words.dropLast(1).map { transform(it, assignment).toInt() }.sum() == transform(\n                words.last(),\n                assignment\n            ).toInt()\n\n        fun search(idx: Int, assignment: Map<Char, Int>, carry: Int): Map<Char, Int>? {\n            val charsAtIdx = words.filter { it.size > idx }.map { it[it.size - idx - 1] }\n            if (numLetters == assignment.size) return if (isValid(assignment)) assignment else null\n            val candidates = solve(charsAtIdx, assignment, carry).filter { firstChars.none { c -> it.first[c] == 0 } }\n            for (candidate in candidates) {\n                val result = search(idx + 1, assignment + candidate.first, candidate.second)\n                if (result != null) return result\n            }\n            return null\n        }\n        val initialAssignments = mutableMapOf<Char, Int>()\n        val lastChars = words.map { it.last() }.distinct()\n        if (lastChars.size == 1) initialAssignments[lastChars[0]] = 0\n        if (words.size == 2 && words.last().size > words.dropLast(1).map { it.size }.max()!!){\n            initialAssignments[words.last()[0]] = 1\n        }\n        return transform(puzzle.toCharArray(), search(0, initialAssignments, 0)!!)\n    }\n\n    private fun transform(s: CharArray, assignments: Map<Char, Int>) = s.map { assignments[it]?.toString() ?: it }.joinToString(\"\")\n\n    private fun solve(letters: List<Char>, assignment: Map<Char, Int>, carry: Int): List<Pair<Map<Char, Int>, Int>> {\n        val unassignedLetters = letters.distinct().filter { !assignment.keys.contains(it) }\n        if (unassignedLetters.isEmpty()) {\n            val sum = letters.dropLast(1).map { assignment[it]!! }.sum() + carry\n            return if (sum % 10 == assignment[letters.last()]!!) listOf(Pair(assignment, sum \/ 10)) else listOf()\n        }\n        return allDigits\n            .filter { !assignment.values.contains(it) }\n            .combinations(unassignedLetters.size)\n            .map { cand -> letters.map { assignment[it] ?: cand[unassignedLetters.indexOf(it)] } }\n            .filter { (it.dropLast(1).sum() + carry) % 10 == it.last() }\n            .map {\n                Pair(assignment + letters.zip(it).toMap(), (it.dropLast(1).sum() + carry) \/ 10)\n            }\n    }\n}\n\nprivate fun List<Int>.combinations(n: Int): List<IntArray> {\n    if (n == 0) return listOf()\n    fun perm(a: List<Int>, result: IntArray, l: Int): MutableList<IntArray> {\n        if (result.size == l) return mutableListOf(result)\n        val combinations = mutableListOf<IntArray>()\n        for (i in a.indices) {\n            if (result.contains(a[i])) continue\n            val nr = result + a[i]\n            combinations.addAll(perm(a, nr, l))\n        }\n        return combinations\n    }\n    return perm(this, intArrayOf(), n)\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208370,"user_id":null,"body":"package kata\n\nclass Val(var letter:Char) \n{\n\tvar x:Int=-1;\n    var positions = mutableListOf<Pos>();\n    override fun toString():String=\"Val \"+letter+\"=\"+x.toString()+\" positions: \"+positions.map{x -> x.ind.toString()+\" \"+x.summ.letter}.joinToString();\n}\n\nclass Pos (val summands:List<Val>,val summ:Val, val ind:Int, val maxRest:Int){\n    var rest:Int=-1;\n    var nextPos:Pos?=null;\n    fun validate():Boolean\n    {\n        \/\/if (deb!=0)\n        \/\/\tprintln(\"inside before --- \"+toString())        \t\n        val summandCount=summands.count()\n        if (summands.any{it.x==-1})\n        \treturn true;\n        var newSumm=0\n        if (summandCount>0)\n        \tnewSumm+=summands.map{it.x}.sum();\n        if (rest==-1) \/\/Optimization possible\n        {\n            if ((summ.x==-1)||(summandCount==0))\n            \treturn true;\n            newSumm=newSumm%10\n            if (summ.x>newSumm+maxRest)\n            \treturn false;\n            if ((summ.x<newSumm)&&(newSumm+maxRest<10))\n            \treturn false;\n            if ((summ.x<newSumm)&&(newSumm+maxRest>10)&&(newSumm+maxRest-10<summ.x))\n            \treturn false;\n        \treturn true;\n        }\n        \/\/if (deb!=0)\n        \/\/\tprintln(\"inside --- start\")\n        newSumm+=rest;\n        if ((summ.x!=-1)&&(newSumm%10!=summ.x))\n        \treturn false;        \n        \/\/if (deb!=0)\n        \/\/\tprintln(\"inside --- check\")       \n        var newRest=newSumm\/10;\n        if (nextPos==null)\n        {\n        \tif (newRest>0) \n        \t\treturn false;\n            else\n            \treturn true;\n        }\n        else \n        {\n            val np:Pos=nextPos as Pos;\n            \/\/if (deb!=0)\n        \t\/\/\tprintln(\"inside in np --- $newRest $np\")  \n            if (np.rest!=newRest){               \n                np.rest=newRest;\n        \t\treturn np.validate();\n            }\n            else\n\t\t\t\treturn true;                        \n        }\n    }\n    fun undo():Unit {   \n    \tif (nextPos==null)\n        \treturn;   \n        var newRest:Int\n        if ((rest==-1)||(summands.any{it.x==-1}))\n        \tnewRest=-1\n        else{\n        \tvar newSumm=summands.map{it.x}.sum()+rest;\n        \tnewRest=newSumm\/10;\n        }\n        val np:Pos=nextPos as Pos;\n        if (np.rest!=newRest){               \n            np.rest=newRest;\n            np.undo();\n        }        \t\t\n    }\n    \n    override fun toString():String = \"Position \"+ind.toString()+\" \"+summ.letter+\"=\"+summ.x+\". - \"+summands.map{it.letter+\"=\"+it.x+\".\"}.joinToString()+\" NEXT - \"+ \n    (nextPos?.ind ?: \"-|\")+\" rest = \"+rest.toString();\n}\n\n\n\nobject Cryptarithm {\n    var digits:MutableList<Int> = mutableListOf(0,1,2,3,4,5,6,7,8,9)\n    var vals:List<Val> = listOf();\n    var lettersNotNull:List<Char> = listOf();\n    var positions:List<Pos> = listOf();\n    var puz:String=\"\";\n    fun valReplace(s:String):String{        \n      var result:String=s;\n      vals.filter{it.x!=-1}.forEach{result=result.replace(it.letter.toString(),it.x.toString())}\n      return result;\n    }\n    \n    fun testNext(valIndex:Int):Boolean{\n        if (valIndex==vals.count())\n        \treturn true;\n        for (i in 0..digits.count()-1){\n            if ((digits[i]==0) && (vals[valIndex].letter in lettersNotNull))\n            \tcontinue;\n        \tvals[valIndex].x=digits[i]\n        \tdigits.removeAt(i)\n            \/\/if ((vals[00].x==1)&&(vals[1].x==2)&&(vals[2].x==3)&&(vals[3].x==0)&&(vals[4].x==4)){\n        \t\/\/\tprint(\"valindex $valIndex \")\n        \t\/\/\tprintln(valReplace(puz));\n        \t\/\/}\t\n            var res:Boolean=true;\n            val positionInvolved = positions.filter{(it.summands.contains(vals[valIndex]))||(it.summ==vals[valIndex])}.toList();\n        \tfor (j in positionInvolved){\n                \/\/if ((vals[0].x==1)&&(vals[1].x==2)&&(vals[2].x==3)&&(vals[3].x==0)&&(vals[4].x==4))\n                \/\/\tdeb=1\n                \/\/else\n                \/\/\tdeb=0;\n                res=j.validate()\n                \/\/if ((vals[0].x==1)&&(vals[1].x==2)&&(vals[2].x==3)&&(vals[3].x==0)&&(vals[4].x==4)){\n                \/\/if ((vals[0].x==5)&&(vals[1].x==6)&&(vals[2].x==1)&&(vals[3].x==0)&&(vals[4].x==9)){\n                \/\/    print(\"${vals[valIndex].letter} ${vals[valIndex].x} \")\n        \t\t\/\/\tprintln(\"j $j res $res \")\n                \/\/    println(\"0 - ${positions[0]}\")                    \n                \/\/    println(\"1 - ${positions[1]}\")                    \n                \/\/    println(\"2 - ${positions[2]}\")\n                \/\/    println(\"3 - ${positions[3]}\")\n                \/\/    println(\"4 - ${positions[4]}\")\n\t\t\t\t\/\/}\n                if (!res)\n                \tbreak;\n            }\n            if (res){\n                res=testNext(valIndex+1)\n                if (res)\n                \treturn true;\n            }\n            digits.add(i,vals[valIndex].x)\n        \tvals[valIndex].x=-1            \n            for (j in positionInvolved)\n                j.undo()            \n        }\n        return false;\n    }\n    \n    fun alphametics(puzzle: String): String {\n        puz=puzzle;\n        digits = mutableListOf(0,1,2,3,4,5,6,7,8,9)\n        val summands:List<String> = \"\"\"[A-Z]+\"\"\".toRegex().findAll(puzzle).map{it.value}.toList();\n        vals = summands.flatMap{it.toCharArray().toList()}.groupBy{it}.map{Pair(it.key,it.value.count())}.sortedByDescending{it.second}.map{Val(it.first)}        \n        positions = summands\n            \t\t.last()\n            \t\t.toCharArray().toList().asReversed()\n            \t\t.mapIndexed{\n                        i,x -> Pos(\n                            summands.dropLast(1).filter{it.length>i}.map{summand -> vals.first{it.letter==summand.toCharArray().toList().asReversed()[i]}},\n                            vals.first{it.letter==x},\n                            i,\n                            summands.count()-2\n                            )\n                            }.toMutableList();\n        vals.forEach{myVal -> myVal.positions=positions.filter{(it.summ==myVal) or (it.summands.contains(myVal))}.toMutableList()}\n        var nextPos:Pos?=null;\n        positions.asReversed().forEach{it.nextPos=nextPos;nextPos=it}\n        positions[0].rest=0;\n        lettersNotNull = summands.map{it[0]}.distinct()\n        testNext(0)\n        return valReplace(puzzle);\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208371,"user_id":null,"body":"package kata\n\nobject Cryptarithm {\n    fun alphametics(puzzle: String): String {\n        val letters = mutableListOf<Char>()\n        val pos = mutableMapOf<Char, Int>()\n        var leading: BooleanArray\n        val coef = mutableListOf<Int>()\n        val tens = IntArray(10).also {\n            it[0] = 1\n            for (i in 1..9) {\n                it[i] = 10 * it[i-1]\n            }\n        }\n\n        var left: String\n        var right: String\n        puzzle.filter { it != ' ' }.split(\"=\").also {\n            left = it[0]\n            right = it[1]\n\n            left.split(\"+\").forEach {\n                it.forEach {\n                    if (!letters.contains(it)) {\n                        pos[it] = letters.size\n                        letters.add(it)\n                        coef.add(0)\n                    }\n                }\n            }\n            right.forEach {\n                if (!letters.contains(it)) {\n                    pos[it] = letters.size\n                    letters.add(it)\n                    coef.add(0)\n                }\n            }\n\n            leading = BooleanArray(coef.size)\n\n            left.split(\"+\").forEach {\n                leading[pos[it[0]]!!] = true\n                it.reversed().mapIndexed { i, c ->\n                    coef[pos[c]!!] += tens[i]\n                }\n            }\n            leading[pos[right[0]]!!] = true\n            right.reversed().mapIndexed { i, c ->\n                coef[pos[c]!!] -= tens[i]\n            }\n        }\n\n        val n = letters.size\n        val sequence = IntArray(n)\n        val used = BooleanArray(10)\n\n        fun gen(sequence: IntArray, id: Int): String? {\n            if (id >= sequence.size) {\n                var sum = 0\n                coef.forEachIndexed{ i, it -> sum += it * sequence[i] }\n                if (sum == 0) {\n                    var result = puzzle\n                    letters.forEachIndexed { i, c -> result = result.replace(c, sequence[i].toString()[0]) }\n                    return result\n                }\n                return null\n            }\n            for (d in 0..9) {\n                if (!used[d] &&\n                        (d != 0 || (d == 0 && !leading[id]))) {\n                    used[d] = true\n                    sequence[id] = d\n                    val result = gen(sequence, id + 1)\n                    if (result != null) {\n                        return result\n                    }\n                    used[d] = false\n                }\n            }\n            return null\n        }\n\n        return gen(sequence, 0)!!\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208372,"user_id":null,"body":"package kata\n\nobject Cryptarithm {\n\n    var a: Array<Int> = emptyArray()\n    var overallImpact: Int = 0\n    var impacts: Array<Int> = emptyArray()\n\n    \/**\n     * @see @url https:\/\/alistairisrael.wordpress.com\/2009\/09\/22\/simple-efficient-pnk-algorithm\/\n     *\/\n\n    fun onSwap(i: Int, j: Int) {\n        overallImpact -= impacts[i] * a[i]\n        overallImpact += impacts[i] * a[j]\n\n        overallImpact -= impacts[j] * a[j]\n        overallImpact += impacts[j] * a[i]\n    }\n\n    fun Array<Int>.swap(i: Int, j: Int) {\n        onSwap(i, j)\n        val c = this[i]\n        this[i] = this[j]\n        this[j] = c\n    }\n\n    fun Array<Int>.reverse(left: Int, right: Int) {\n        var l = left\n        var r = right\n        while (l < r) {\n            swap(l++, r--)\n        }\n    }\n\n    fun Array<Int>.next(n: Int = 10, k: Int = n): Boolean {\n        val edge = k - 1\n        val r = (k until n).firstOrNull { r -> this[edge] < this[r] }\n        when {\n            r != null -> swap(edge, r)\n            else -> {\n                reverse(k, n - 1)\n                val i = (edge - 1 downTo 0).firstOrNull { i -> this[i] < this[i + 1] }\n                    ?: return false\n\n                val j = (n - 1 downTo i + 1).firstOrNull { j -> this[i] < this[j] }\n                if (j != null) {\n                    swap(i, j)\n                }\n                reverse(i + 1, n - 1)\n            }\n        }\n        return true\n    }\n\n    fun alphametics(puzzle: String): String {\n\n        val words = puzzle.split(\" + \", \" = \")\n        val nonZeroChars = words.filter { it.length > 1 }.mapNotNull { it.firstOrNull() }.toSet()\n        val allChars = puzzle.toCharArray().distinct().filter { it !in setOf('+', '=', ' ') }\n\n        fun tens(n: Int) = (1..n).fold(1) { acc, _ -> acc * 10 }\n\n        val k = allChars.size\n        a = Array(10) { it }\n\n        impacts = allChars.map { char ->\n            var impact = 0\n            words.forEachIndexed { index, word ->\n                word.forEachIndexed { i, c ->\n                    if (c == char) {\n                        impact += tens(word.length - i - 1) * if (index == words.size - 1) -1 else 1\n                    }\n                }\n            }\n            impact\n        }.plus(Array(10) { 0 }).take(10).toTypedArray()\n\n        overallImpact = impacts.mapIndexed { i, impact ->\n            a[i] * impact\n        }.sumBy { it }\n\n        do {\n            do {\n                val hasSolution = overallImpact == 0\n                val hasNext = if (!hasSolution)\n                    a.next(10, k)\n                else\n                    false\n            } while (hasNext)\n            val ok = allChars.getOrNull(a.indexOf(0)) !in nonZeroChars\n            if (!ok) {\n                a.next(10, k)\n            }\n        } while (!ok)\n\n        val ans = allChars.mapIndexed { i, c -> c to \"${a[i]}\"[0] }.toMap()\n\n        return puzzle.toCharArray().joinToString(\"\") {\n            if (it in ans.keys)\n                \"${ans[it]}\"\n            else\n                \"$it\"\n        }\n\n    }\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208373,"user_id":null,"body":"package kata\nimport java.util.*\nobject Cryptarithm {\n    class solution(val puzzle: String) {\n        val assignMap: MutableMap<Char, Int?>\n        private val result: String\n        private val adds: List<String>\n        private val noZero: Set<Char>\n        private val isAssign = BooleanArray(10) { false }\n        private val assignStack = Stack<Pair<Char, Int>>()\n        private val carryStack = Stack<Int>()\n        private val resultLen: Int\n\n        init {\n            val split = puzzle.split(Regex(\" \\\\+ | = \"))\n            result = split[split.lastIndex].reversed()\n            resultLen = result.length\n            \/\/\u8865\u9f50\u957f\u5ea6\n            adds = split.subList(0, split.lastIndex).map { it.reversed() }\n                .map { it.padEnd(resultLen, '0') }\n\n            noZero = split.map { it[0] }.toSet()\n            val removeAll = puzzle.map { it }.toMutableSet()\n            removeAll.removeAll(listOf(' ', '+', '='))\n\/\/        assignMap = removeAll.associate<Char, Char, Int?> { it to null }.toMutableMap()\n            assignMap = mutableMapOf('0' to 0)\n            carryStack.push(0)\n        }\n\n        fun assignChar(char: Char): Int? {\n            for (withIndex in isAssign.withIndex()) {\n                if (withIndex.value == false) {\n                    \/\/\u9996\u5b57\u6bcd\u4e0d\u5206\u914d0\n                    if (withIndex.index == 0 && char in noZero)\n                        continue\n                    \/\/\u518d\u6b21\u5206\u914d\u7684\u60c5\u51b5\n                    if (assignStack.size > 0 && assignStack.peek().first == char && assignStack.peek().second >= withIndex.index)\n                        continue\n                    \/\/\u5206\u914d\u6210\u529f \u8bb0\u5f55\u76f8\u5173\u6570\u636e\n                    if (assignStack.size != 0 && assignStack.peek().first == char) {\n                        val (c, i) = assignStack.pop()\n                        isAssign[i] = false\n                    }\n                    isAssign[withIndex.index] = true\n                    assignMap[char] = withIndex.index\n                    assignStack.push(char to withIndex.index)\n                    return withIndex.index\n                }\n            }\n            \/\/\u6ca1\u6709\u53ef\u80fd\u7684\u60c5\u51b5 \u8fd4\u56de\u4e0a\u4e00\u5c42\n            return null\n        }\n\n        fun reAssign(index: Int): Boolean {\n            while (true) {\n                if (assignStack.size - 1 == index)\n                    return false\n                val (c, i) = assignStack.pop()\n                isAssign[i] = false\n                assignMap.remove(c)\n                if (assignChar(assignStack.peek().first) != null)\n                    return true\n            }\n        }\n\n        fun unAssign(index: Int): Boolean {\n            while (assignStack.size > index) {\n                val (c, i) = assignStack.pop()\n                isAssign[i] = false\n                assignMap.remove(c)\n            }\n            return true\n        }\n\n        fun dfs(index: Int): Boolean {\n            if (index == resultLen)\n                return carryStack.peek() == 0\n\/\/         println(\"$index -----------------------\")\n            val carry = carryStack.peek()\n            val assignSize = assignStack.size\n            checkAssign(index)\n            val checkAssignSize = assignStack.size\n\n            if (assignSize == checkAssignSize) {\n                val i = adds.sumBy { assignMap[it[index]] ?: 0 } + carry\n                val b = i % 10 == assignMap[result[index]]\n                if (b) {\n                    carryStack.push(i \/ 10)\n                    return dfs(index + 1)\n                } else\n                    return false\n            }\n\n            while (true) {\n\/\/             println(assignMap)\n                val i = adds.sumBy { assignMap[it[index]] ?: 0 } + carry\n                val b = i % 10 == assignMap[result[index]]\n                if (b) {\n                    carryStack.push(i \/ 10)\n                    val dfsResult = dfs(index + 1)\n                    if (dfsResult)\n                        return true\n\/\/                 println(\"return $index -----------------------\")\n                    carryStack.pop()\n                    unAssign(checkAssignSize)\n                    if (assignChar(assignStack.peek().first) == null) {\n                        if (!reAssign(assignSize))\n                            return false\n                        checkAssign(index)\n                    }\n                } else if (assignChar(assignStack.peek().first) == null) {\n                    if (!reAssign(assignSize))\n                        return false\n                    checkAssign(index)\n                }\n            }\n        }\n\n        private fun checkAssign(index: Int) {\n            for (add in adds) {\n                if (assignMap[add[index]] == null)\n                    assignChar(add[index])\n            }\n            if (assignMap[result[index]] == null)\n                assignChar(result[index])\n        }\n    }\n    \n    fun alphametics(puzzle: String): String {\n        val solution = solution(puzzle)\n        solution.dfs(0)\n        return puzzle.map { solution.assignMap[it] ?: it }.joinToString(\"\")\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208374,"user_id":null,"body":"package kata\n\n\n\nobject Cryptarithm {\n    \n    fun alphametics(puzzle: String): String {\n        val parts = puzzle.split(\" = \");\n        val summands = parts.first().split(\" + \").map({ s -> s.reversed() });\n        val result = parts.last().reversed();\n        val nonzeroes = (summands.map({ s -> s.last() }) + result.last()).toSet();\n        val tr = bruteforce(summands, \n                            result, \n                            nonzeroes, \n                            setOf(0, 1, 2, 3, 4, 5, 6, 7, 8, 9));\n        \n        if (tr == null) {\n            return \"\";\n        } else {\n            return puzzle.map({ c -> tr[c] ?: c }).joinToString(\"\");\n        }\n    }\n    \n    fun bruteforce(summands: List<String>,\n                   result: String,\n                   nonzeroes: Set<Char>,\n                   digits: Set<Int>,\n                   i: Int = 0, \n                   j: Int = 0,\n                   overflow: Int = 0,\n                   translation: Map<Char, Int> = emptyMap()): Map<Char, Int>? {\n        if (result.length <= i) {\n            if (overflow == 0) {\n                return translation;\n            } else {\n                return null;\n            }\n        }\n        if (summands.size > j) {\n            if (summands[j].length > i) {\n                val c = summands[j][i];\n                if (c in translation) {\n                    return bruteforce(summands, result, nonzeroes, digits, i, j + 1, overflow, translation);\n                } else {\n                    for (d in digits) {\n                        if (d != 0 || c !in nonzeroes) {\n                            val r = bruteforce(summands, result, nonzeroes, digits - d, i, j + 1, overflow, translation + Pair(c, d));\n                            if (r != null) {\n                                return r;\n                            }\n                        }\n                    }\n                    return null;\n                }\n            } else {\n                return bruteforce(summands, result, nonzeroes, digits, i, j + 1, overflow, translation);\n            }\n        } else {\n            val c = result[i];\n            val rds = if (c in translation) { setOf(translation[c]) } else { digits };\n            for (d in rds.filterNotNull()) {\n                if (d != 0 || c !in nonzeroes) {\n                    val nof = checksum(summands, result, i, overflow, translation + Pair(c, d));\n                    if (nof != null) {\n                        return bruteforce(summands, result, nonzeroes, digits - d, i + 1, 0, nof, translation + Pair(c, d));\n                    }\n                }\n            }\n            return null;\n        }\n    }\n \n    fun checksum(summands: List<String>, \n                 result: String,\n                 i: Int, \n                 overflow: Int, \n                 tr: Map<Char, Int>) : Int? {\n        val sumleft = summands.fold(overflow, { acc, s -> if (s.length > i) { acc + (tr[s[i]] ?: 0) } else { acc } });\n        if ((sumleft % 10) == (tr[result[i]] ?: 0)) {\n            return sumleft \/ 10;\n        } else {\n            return null;\n        }\n    }\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208375,"user_id":null,"body":"package kata\n\nimport java.lang.IllegalArgumentException\n\ntypealias Library = Map<Char, Int>\n\nobject Cryptarithm {\n    fun alphametics(puzzle: String): String {\n\n        val start = System.currentTimeMillis()\n\n        \/\/ your code goes here. you can do it!\n        val (possibleVariants, terms, sum) = init(puzzle)\n\n        val optimizedVariants = optimizeVariants(possibleVariants, terms, sum)\n\n        val lettersByPosition =\n            sum.mapIndexed { index, char -> char to terms.mapNotNull { term -> term.getOrNull(index - (sum.length - term.length)) } }.reversed()\n\n        val lib =\n            nonBruteForceDigits(\n                optimizedVariants,\n                lettersByPosition,\n                setOf(),\n                mapOf(),\n                0\n            )\n        println(\"Took ${System.currentTimeMillis() - start} ms for $puzzle\")\n        if (lib != null) {\n            val result = puzzle.map { lib[it]?.plus('0'.toByte())?.toChar() ?: it }.joinToString(\"\")\n            println(result)\n            return result\n        } else {\n            throw IllegalArgumentException(\"No solutions\")\n        }\n    }\n\n    private fun optimizeVariants(\n        possibleVariants: Map<Char, MutableSet<Int>>,\n        terms: List<String>,\n        sum: String\n    ): Map<Char, MutableSet<Int>> {\n        val maxPossibleSum = terms.map { term -> Integer.valueOf(term.map { '9' }.joinToString(\"\")) }.sum()\n        val maxPossibleSumString = maxPossibleSum.toString()\n        if (maxPossibleSumString.length == sum.length) {\n            possibleVariants[sum[0]]!!.removeIf { it > maxPossibleSumString[0] - '0' }\n        }\n\n        if (terms.size % 2 == 0 && terms.map { it.last() }.toSet().size == 1) {\n            possibleVariants[sum.last()]!!.removeIf { it % 2 == 1 }\n        }\n        \n        return possibleVariants\n    }\n\n    private fun nonBruteForceDigits(\n        possibleVariants: Map<Char, MutableSet<Int>>,\n        operands: List<Pair<Char, List<Char>>>,\n        usedDigits: Set<Int>,\n        lib: Library,\n        shift: Int\n    ): Library? {\n        if (operands.isEmpty()) {\n            return if (shift == 0) {\n                lib\n            } else {\n                null\n            }\n        } else {\n            val (sumLetter, termLetters) = operands.first()\n            val lettersInCurrentPosition = termLetters + sumLetter\n            val letterToSubsctitute = lettersInCurrentPosition.firstOrNull { it !in lib }\n            if (letterToSubsctitute != null) {\n                for(digit in possibleVariants[letterToSubsctitute]!! - usedDigits) {\n                    val newLib = lib + (letterToSubsctitute to digit)\n                    val result = nonBruteForceDigits(possibleVariants, operands, usedDigits + digit, newLib, shift)\n                    if (result != null) {\n                        return result\n                    }\n                }\n                return null\n            } else {\n                val sum = termLetters.map { lib[it]!! }.sum()\n                val newShift = (sum + shift) \/ 10\n                return if ((sum + shift) % 10 != lib[sumLetter]!!) {\n                    null\n                } else {\n                    nonBruteForceDigits(possibleVariants, operands.drop(1), usedDigits, lib, newShift)\n                }\n            }\n        }\n    }\n\n    private fun init(puzzle: String): Triple<Map<Char, MutableSet<Int>>,List<String>, String> {\n        val equals = puzzle.replace(\" \", \"\").split(\"=\")\n        val operands = equals[0].split(\"+\")\n        val sum = equals[1]\n        val allLetters = operands.flatMap { it.toSet() }.toSet() + sum.toSet()\n        val firstLetters = operands.map { it[0] }.toSet() + sum[0]\n        val variants =\n            allLetters.map { it to if (it in firstLetters) (1..9).toMutableSet() else (0..9).toMutableSet() }.toMap()\n\n        return Triple(variants, operands, sum)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208376,"user_id":470,"body":"package kata\n\nobject Cryptarithm {\n\tfun alphametics(s:String): String {\n\t\tval words: MutableList<String> = Regex(\"\"\"\\w+\"\"\").findAll(s).map { it.value.reversed() }.toMutableList()\n\t\tval nonzero = words.map { it.last() }.toSet()\n\t\tval fword = words.removeAt(words.size-1)\/\/ Kotlin 1.3\n\t\t\/\/ val fword = words.removeLast() \/\/ Kotlin 1.4\n\t\tval ix: List<Pair<String,Char>> = List(fword.length, { words.map { s -> s.getOrNull(it) }.filterNotNull().joinToString(\"\") to fword[it] })\n\t\t\n\t\tfun forge(z:MutableMap<Char,Int>, ws:List<Char>, cs:Int, n:Int): MutableMap<Char,Int>? {\n\t\t\tif (n == ix.size) return if (cs == 0) z else null\n\t\t\tval (v1:String,v2:Char) = ix[n]\n\t\t\tval addv = v1.filter { !ws.contains(it) }\n\t\t\tval sumv: Int = z.getOrDefault(v2,-1)\n\t\t\tval nums = z.values.toSet()\n\t\t\tval lnv = addv.toSet().size\n\t\t\tval cv = addv.firstOrNull()\n\t\t\tval cc = if (cv != null) addv.count() { it == cv } else null\n\t\t\tval vn = if (cv != null) z.get(cv) else null\n\t\t\t\n\t\t\tif (vn != null) return forge(z,ws.plusElement(cv!!),cs+cc!!*vn,n)\n\t\t\t\n\t\t\tval rm = lnv + (if (sumv == -1) 1 else 0)\n\t\t\tval n1 = if (nonzero.contains(cv)) 1 else 0\n\t\t\tval rang = (n1..9).filter { !nums.contains(it) }\n\t\t\t\n\t\t\tif (rm == 0) return if (cs % 10 == sumv) forge(z,mutableListOf<Char>(),cs\/10,n+1) else null\n\t\t\t\n\t\t\tif (rm == 1){\n\t\t\t\tif (sumv != -1){\n\t\t\t\t\tval ncv = rang.filter { sumv == (it * cc!! + cs) % 10 }\n\t\t\t\t\tif (ncv.size == 0) return null\n\t\t\t\t\tfor (v in ncv){\n\t\t\t\t\t\tval zc = z.toMutableMap()\n\t\t\t\t\t\tzc.put(cv!!,v)\n\t\t\t\t\t\tval ncs = addv.count() * zc.get(cv)!! + cs\n\t\t\t\t\t\tval nz = forge(zc,mutableListOf<Char>(),ncs\/10,n+1)\n\t\t\t\t\t\tif (nz != null) return nz}\n\t\t\t\t\treturn null }\n\t\t\t\telse {\n\t\t\t\t\tval zc = z.toMutableMap()\n\t\t\t\t\tzc.put(v2,cs%10)\n\t\t\t\t\tval q1 = if (nonzero.contains(v2)) 1 else 0\n\t\t\t\t\tval zcv = zc.get(v2)\n\t\t\t\t\tif (!(q1..9).filter { !nums.contains(it) }.contains(zcv)) return null\n\t\t\t\t\treturn forge(zc,mutableListOf<Char>(),cs\/10,n+1) }\n\t\t\t}\n\t\t\t\n\t\t\tfor (i in rang){\n\t\t\t\tval zc = z.toMutableMap()\n\t\t\t\tzc.put(cv!!,i)\n\t\t\t\tval ncs = cc!! * i + cs\n\t\t\t\tval check = forge(zc,ws.plusElement(cv),ncs,n)\n\t\t\t\tif (check != null) return check }\n\t\t\treturn null\n\t\t}\n\t\t\n\t\tval codex = forge(mutableMapOf<Char,Int>(),mutableListOf<Char>(),0,0)!!.toMap()\n\t\treturn \"${words.map { convert(it,codex) }.joinToString(\" + \") } = ${convert(fword,codex)}\"\n\t}\n\t\n\tprivate fun convert(w:String,cdx:Map<Char,Int>) = w.reversed().map { cdx.get(it)!! }.joinToString(\"\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5b6b67a5ecd0979e5b00000e":[{"id":208377,"user_id":null,"body":"package kata\n\nimport kotlin.math.pow\n\nobject KataSolution {\n    fun mysteryRange(s: String,n: Int): Pair<Int,Int> {\n        return MysteryRangeChecker(s, n).solve()\n    }\n    \n    class MysteryRangeChecker(val s: String, val n: Int) {\n\n        fun solve(): Pair<Int, Int> {\n            \/\/println(\"Solving: $s, $n\")\n            return (0..100).asSequence()\n                .map { it until it + n }\n                .first { testRange(it) }\n                .let { it.first to it.last }\n        }\n\n        private fun testRange(\n            range: IntRange,\n            lookingFor: List<Int> = range.sortedBy { allPositionsFor(it).count() },\n            blocked: BooleanArray = BooleanArray(s.length)\n        ): Boolean {\n            val target = lookingFor.first()\n            val lengthOfNumber = target.toString().length\n\n            allPositionsFor(target).asSequence()\n                .filter { blocked.free(it until it + lengthOfNumber) }\n                .forEach { idx ->\n                    (idx until idx + lengthOfNumber).forEach { blocked[it] = true }\n                    if (lookingFor.size == 1)\n                        return blocked.all { it }\n                    if (testRange(range, lookingFor.subList(1, lookingFor.size), blocked))\n                        return true\n                    (idx until idx + lengthOfNumber).forEach { blocked[it] = false }\n                }\n            return false\n        }\n\n        private inline fun BooleanArray.free(range: IntRange) = range.none { this[it] }\n\n        private val cache: MutableMap<Int, Collection<Int>> = mutableMapOf()\n\n        private fun allPositionsFor(n: Int): Collection<Int> = cache.getOrPut(n) {\n            sequence {\n                val target = n.toString()\n                var idx = s.indexOf(target)\n                while (idx >= 0) {\n                    yield(idx)\n                    idx = s.indexOf(target, idx + 1)\n                }\n            }.toList()\n        }\n\n    }\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208378,"user_id":null,"body":"package kata\n\nobject KataSolution {\n    fun mysteryRange(s: String,l: Int): Pair<Int,Int> {\n        val inDigitCounts = s.groupingBy { it }.eachCount()\n        for (n in 1 until 100) {\n            \/\/take a range\n            val range = (n until (l+n)).toList()\n            val digitCounts = range.joinToString(\"\").groupingBy { it }.eachCount()\n            if (inDigitCounts == digitCounts && range.all { n -> s.contains(\"$n\")}) return Pair(range.first(), range.last())\n        }\n        return Pair(0, 0)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208379,"user_id":null,"body":"package kata\n\nobject KataSolution {\n    fun mysteryRange(s: String,n: Int): Pair<Int,Int> {\n        \n        val counter = (0..9).map { c ->\n            s.filter {it == '0'+c}.count()\n        }\n        \/\/ try all the ranges \n        (1..99).forEach { start ->\n            val candidate_vals = (start..start+n-1).map{it}\n            val candidate_s = candidate_vals.joinToString(\"\")\n            val candidate_counter = (0..9).map { c ->\n                candidate_s.filter {it == '0'+c}.count()\n            }\n            \/\/checks\n            val enough = candidate_counter.filterIndexed {i,e -> \n                e > counter[i] \n            }.size == 0\n            val equal_len = candidate_s.length == s.length\n            val all_numbers_exist = candidate_vals.filter{it.toString() !in s}.size == 0\n            \n            if (enough && equal_len && all_numbers_exist ) \n                    return Pair(start,start+n-1) \/\/ ---> we've found it!\n        }\n        return Pair(0,0) \/\/--- no luck\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208380,"user_id":null,"body":"package kata\n\nobject KataSolution {\n    fun mysteryRange(s: String, n: Int): Pair<Int, Int> {\n        val sCount = s.groupingBy { it }.eachCount()\n        for (i in 1 until 100) {\n            val range = i until i + n\n            val count = range.joinToString(\"\").groupingBy { it }.eachCount()\n            if (count == sCount && range.all { \"$it\" in s }) return Pair(i, i + n - 1)\n        }\n        return Pair(0, 0)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208381,"user_id":null,"body":"package kata\n\nobject KataSolution {\n    fun mysteryRange(s: String, l: Int): Pair<Int,Int> {\n        \n        val counts = s.groupingBy { it }.eachCount()\n        \n        for (n in 1 until 100) {\n            val range = IntArray(l).mapIndexed { i, v -> n + i }\n            val rCounts = range.joinToString(\"\").groupingBy { it }.eachCount()\n            if (counts.equals(rCounts) && range.all { n -> s.contains(\"$n\")}) return Pair(range[0], range[l - 1])\n        }\n        \n        return Pair(0, 0)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208382,"user_id":null,"body":"package kata\n\nobject KataSolution {\n    fun mysteryRange(s: String,n: Int): Pair<Int,Int> {\n         val maxOrder: Int = s.length \/ n\n        var range = mutableListOf<Int>()\n        var min:Int = 0\n        var max = 0\n        if (maxOrder * n == s.length ) {\n            range.addAll(s.chunked(2).map { it.toInt() })\n            min = range.min()?:0\n            max = range.max()?:0\n        } else {\n\n            val doubleNumQuantaty = s.length - n * maxOrder\n            val singleNumQuantaty = s.length - (doubleNumQuantaty * (maxOrder + 1))\n\n            min = Math.pow(10.toDouble(), maxOrder.toDouble())\n                .toInt() - (singleNumQuantaty \/ maxOrder)\n            max = min + n - 1\n        }\n        if (!isSequencesEquals(s, n, min)) {\n            min = (110 - n * 3 + s.length) \/ 2\n            max = min + n - 1\n        }\n        return Pair(min, max)\n    }\n\n    fun isSequencesEquals(s: String, n: Int, min: Int): Boolean {\n        return (min until min + n).joinToString(\"\").toCharArray().sorted() == s.toCharArray().sorted()\n    }\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208383,"user_id":null,"body":"package kata\n\nobject KataSolution {\n    fun mysteryRange(s: String, n: Int): Pair<Int, Int> {\n        val l = s.length\n        val p = l\/n\n        var start = if (p*n == l) {\n            s.chunked(p).min()!!.toInt()\n        }\n        else {\n            val a = n*p + n - l\n            10.pow(p) - a\n        }\n\n        if (!check(s, n, start)) {\n            start = (110 - n*3 + l) \/ 2\n        }\n        \n        return Pair(start, start+n-1)\n    }\n}\n\nfun check(s: String, n: Int, start: Int): Boolean {\n    return (start until start + n).joinToString(\"\").toCharArray().sorted() == s.toCharArray().sorted()\n}\n\nfun Int.pow(n: Int): Int {\n    var pow = 1\n    repeat(n) {\n        pow *= this\n    }\n    return pow\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208384,"user_id":470,"body":"package kata\n\nobject KataSolution {\n\tfun mysteryRange(s:String,n:Int): Pair<Int,Int> {\n\t\tvar ni: Int\n\t\tvar ix: Pair<Int,Int>? = null\n\t\tfor (i in 1..3){\n\t\t\tni = s.substring(0,i).toInt()\n\t\t\tix = forge(s.substring(i),ni,ni,n,mutableSetOf(ni))\n\t\t\tif (ix != null){break}\n\t\t}\n\t\treturn ix!!\n\t}\n\t\n\tprivate fun forge(s:String,mn:Int,mx:Int,n:Int,z:MutableSet<Int>): Pair<Int,Int>? {\n\t\tval ln = s.length\n\t\tvar res: Pair<Int,Int>? = null\n\t\tif (ln == 0){\n\t\t\treturn if (z.size == n && z.all {it >= mn && it <= mx}) Pair(mn,mx) else null}\n\t\tif (s[0] == '0'){return null}\n\t\tfor (j in 1..Math.min(3,ln)){\n\t\t\tvar cn = s.substring(0,j).toInt()\n\t\t\tif (cn in z || (cn > mx && cn - mn > n) || cn < mn && mx - cn > n){continue}\n\t\t\tvar z2 = z.toMutableSet()\n\t\t\tz2.add(cn)\n\t\t\tres = forge(s.substring(j),Math.min(mn,cn),Math.max(mx,cn),n,z2)\n\t\t\tif (res != null){break}\n\t\t}\n\t\treturn res\n\t}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5b853229cfde412a470000d0":[{"id":208385,"user_id":null,"body":"fun twice_as_old(dadYearsOld: Int, sonYearsOld: Int): Int = Math.abs(dadYearsOld - (sonYearsOld * 2))","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208386,"user_id":null,"body":"fun twice_as_old(dadYearsOld: Int, sonYearsOld: Int) =\n    if (dadYearsOld >= 2 * sonYearsOld) dadYearsOld - 2 * sonYearsOld else 2 * sonYearsOld - dadYearsOld","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208387,"user_id":null,"body":"    fun twice_as_old(dadYearsOld: Int, sonYearsOld: Int) = when (val result = dadYearsOld - (sonYearsOld * 2)) {\n        in 0..Int.MAX_VALUE -> result\n        else -> (sonYearsOld * 2) - dadYearsOld\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208388,"user_id":null,"body":"fun twice_as_old(dadYearsOld: Int, sonYearsOld: Int): Int {\n      val gapAge = dadYearsOld - sonYearsOld\n      if (gapAge < sonYearsOld) \n          return sonYearsOld - gapAge\n      else \n          return gapAge - sonYearsOld\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208389,"user_id":null,"body":"fun twice_as_old(dadYearsOld: Int, sonYearsOld: Int): Int {\n  var a = dadYearsOld\n  var b = sonYearsOld\n  var count = 0\n  while ( b * 2 < a){\n  a = a + 1\n  b = b + 1\n  count = count + 1 \n  }\n  if ( count == 0 ) {\n  count = 2 * b - a}\n  return count\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208390,"user_id":null,"body":"import kotlin.math.abs\n\nfun twice_as_old(dadYearsOld: Int, sonYearsOld: Int): Int {\n  return abs(dadYearsOld - 2*sonYearsOld)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208391,"user_id":null,"body":"fun twice_as_old(dadYearsOld: Int, sonYearsOld: Int) = Math.abs(sonYearsOld - (dadYearsOld - sonYearsOld))\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208392,"user_id":null,"body":"fun twice_as_old(dadYearsOld: Int, sonYearsOld: Int): Int {\n    var n = dadYearsOld\n    var k = 2*sonYearsOld\n    return Math.abs(n - k) \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208393,"user_id":null,"body":"fun twice_as_old(d: Int, s: Int) = Math.abs(d - 2 * s)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208394,"user_id":null,"body":"fun twice_as_old(dadYearsOld: Int, sonYearsOld: Int): Int = Math.abs(dadYearsOld - ((dadYearsOld-sonYearsOld)*2))","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5bb5e174528b2908930005b5":[{"id":208395,"user_id":null,"body":"fun findLast(n: Int, m: Int): IntArray {\n\n    val p = m - 1\n    var index = getNextIndex(0, p, n)\n    var sum = 0\n    val l = (1..n).toMutableList()\n\n    while (l.size > 1) {\n        sum += if (l.size > m) m + 2 * (l.size - m) else m\n        l.removeAt(index)\n        index = getNextIndex(index, p, l.size)\n    }\n    return intArrayOf(l[0], sum)\n}\n\nfun getNextIndex(i: Int, m: Int, s: Int): Int = if (i + m < s) i + m else (m + i) % s","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208396,"user_id":null,"body":"import kotlin.math.max\nimport kotlin.math.min\n\nfun findLast(n: Int, m: Int) : IntArray {\n    val players = (1..n).toMutableList()\n    var starter = (m - 1) % n\n    while (players.size > 1) {\n        players.removeAt(starter)\n        starter = (starter + m - 1) % players.size\n    }\n    return intArrayOf(players.first(), (n + 1) * (max(n - m, 0)) + m * min(m - 1 , n - 1))\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208397,"user_id":null,"body":"fun findLast(n: Int, m: Int) : IntArray {\n    var result:Int = 0\n    var last:Int = 0\n    \/\/ identifiers of players who have lost\n    var eliminated: Array<Int> = emptyArray()\n\n    for (i in n downTo 2)\n    {\n        \/\/ if number of people left is less than number of 1 coin step - just add number of steps\n        \/\/ else add number of 1 coin step and 2 * number of people left\n        result += if (m > i) { m } else { m + (i-m)*2 }\n        \/\/ find the last player to score 1 coin ignoring the losers\n        last = findNext(eliminated,last,m,n)\n        \/\/ add current player to losers\n        eliminated += last\n    }\n    last = findNext(eliminated,last,m,n)\n    if( last == 0 )\n        last = n\n    var arr: IntArray = intArrayOf(last,result)\n    return arr\n}\n\nfun findNext(eliminated:Array<Int>, last:Int, m:Int, size:Int):Int\n{\n    var temp:Int = last\n    var step:Int = m\n    var result:Int = last\n    while( step > 0 )\n    {\n        temp++\n        if( temp >= size )\n            temp = 0\n\n        if(!eliminated.contains(temp))\n        {\n            result = temp\n            step--\n        }\n    }\n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208398,"user_id":null,"body":"fun findLast(n: Int, m: Int) : IntArray {\n    \/\/ Set up a game, list of Player numbers paired to their coin count\n    var game = (1..n).map { it to 0 }.toMutableList()\n    \n    \/\/ These are players _indexes_ in the game, not their number\n    var startPlayer = 0\n    while (game.size > 1) {\n        \/\/ Work out what the end player will be this round\n        val endPlayer = startPlayer + m\n        \n        \/\/ Wrap around the players, spraeding the m coins over the fisrt m players\n        for(index in startPlayer until endPlayer) {\n            game.giveCoins(index, 1)\n        }\n        \n        \/\/ If we have less coins than the number of players, we need give the rest 2 coins each\n        \/\/ thanks to 'untill' we don't need to check, if 'endPlayer' is larger, we end up with an empty range\n        for(index in endPlayer until (endPlayer + game.size - m)) {\n            game.giveCoins(index, 2)\n        }\n        \n        \/\/ 'endplayer' is the index of the lucky one who gets the coins\n        \/\/ The loser of this round is the one before, but that might wrap to the end\n        val kickedPlayer = ((if (endPlayer == 0) game.size else endPlayer) - 1) % game.size\n        \n        \/\/ give the 'winner' or this round the coins from the kicked player\n        game.giveCoins(endPlayer, game[kickedPlayer].second)\n        \n        \/\/ remove that kicked player\n        game.removeAt(kickedPlayer)\n        \n        \/\/ Ready for the next round\n        startPlayer = kickedPlayer\n    }\n    \n    \/\/ We should now only have one result, but we need to format it for how it expects the results to be\n    return intArrayOf(game[0].first, game[0].second)\n}\n\n\/\/ Extension function that just makes it easier to allocate coins to the players\nprivate fun MutableList<Pair<Int,Int>>.giveCoins(player: Int, coins: Int) {\n    val index = player % this.size\n    this[index] = this[index].copy(second = this[index].second + coins)\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208399,"user_id":null,"body":"fun findLast(n: Int, m: Int) : IntArray {\n  var people = IntArray(n)\n  var last = -1\n  var index: Int = -1\n  \n  fun findNext(): Int {\n      var i = (0..n - 1).find{ it > last && people[it] != -1 }\n      if (i != null) return i\n      i = (0..n - 1).find{ it < last && people[it] != -1 }\n      return i!!\n  }\n  \n  for (present in 0..n - 2) {\n      var ones = mutableListOf<Int>()\n      for (count in 0..m - 1){\n          val nxt = findNext()\n          people[nxt] += 1\n          last = if (nxt == n) -1 else nxt\n          ones.add(nxt)\n      }\n      \n      for (i in 0..n - 1) {\n          if (people[i] != -1 && i !in ones) people[i] += 2\n      }\n      \n      val nxt = findNext()\n      people[nxt] = people[nxt] + people[last]\n      people[last] = -1\n      index = nxt\n  }\n  return intArrayOf(index + 1, people[index])\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208400,"user_id":null,"body":"fun findLast(n: Int, m: Int) : IntArray {\n    val people = MutableList(n) { it }\n    val coins = MutableList(n) { 0 }\n\n    var curIndex = 0\n    while( people.size > 1 )\n    {\n        val curSize = people.size\n        for( i in 0 until m)\n        {\n            coins[(curIndex+i)%curSize]+=1\n        }\n        curIndex+=(m-1)\n        curIndex%=curSize\n\n        if( m < curSize ) {\n            for(i in 1..people.size-m) {\n                coins[(curIndex+i)%people.size]+=2\n            }\n        }\n\n        coins[(curIndex+1)%coins.size]+=coins[(curIndex)%coins.size]\n        people.removeAt(curIndex%coins.size)\n        coins.removeAt(curIndex%coins.size)\n        curIndex %= people.size\n    }\n\n    return intArrayOf(people[0]+1, coins[0])\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208401,"user_id":null,"body":"class Person(val position : Int, var coins : Int = 0){\n    operator fun plusAssign(x : Int) {\n        coins += x\n    }\n    \n    operator fun plus(x : Person) : Person {\n        return Person(position, coins + x.coins)\n    }\n}\n\nfun findLast(n: Int, m: Int) : IntArray {\n  var c = Array(n, { Person(it + 1) }).toList()\n  while (c.size > 1) {\n    if (m < c.size) {\n      (0 until m).forEach { c[it] += 1 }\n      (m until c.size).forEach { c[it] += 2 }\n      c = c.merge(m)\n    } else {\n      val p = m % c.size\n      val x = m \/ c.size\n      (0 until p).forEach { c[it] += x + 1}\n      (p until c.size).forEach { c[it] += x }\n      c = c.merge(p)\n    }\n  }\n  return intArrayOf(c[0].position, c[0].coins)\n}\n\nfun List<Person>.merge (i: Int) : List<Person> {\n    return if (i > 0)\n      listOf(this[i] + this[i - 1]) + subList(i + 1, size) + subList(0, i - 1)\n    else \n    listOf(this[0] + this[size - 1]) + subList(1, size - 1)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208402,"user_id":null,"body":"fun findLast(n: Int, m: Int) : IntArray {\n    val circle: MutableList<Int> = mutableListOf()\n    (1..n).forEach { circle += it }\n    var coins = 0\n    var i = -1\n    while (circle.size > 1) {\n        coins += (m + Math.max(0, circle.size - m) * 2)\n        i = (i + m) % circle.size\n        circle.removeAt(i)\n        i = Math.floorMod(i - 1, circle.size)\n    }\n    return intArrayOf(circle.first(), coins)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208403,"user_id":1267,"body":"fun findLast(n: Int, m: Int) : IntArray {\n  val a = MutableList(n){it}\n  var i = 0\n  var j = n\n  var s = 0\n  while(a.size > 1){\n    s += m + (if (j - m > 0)  j - m else 0) * 2;\n    i = (i + m - 1) % j--;\n    a.removeAt(i);\n  }\n  return intArrayOf(a[0] + 1, s)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5bb904724c47249b10000131":[{"id":208404,"user_id":null,"body":"fun points(games: List<String>) =\n        games.sumBy {\n            val (x, y) = it.split(\":\")\n            when {\n                x > y -> 3\n                x < y -> 0\n                else -> 1\n            }\n        }","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208405,"user_id":null,"body":"fun points(games: List<String>) = games.sumBy {\n    when {\n        it[0] > it[2] -> 3\n        it[0] == it[2] -> 1\n        else -> 0\n    }\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208406,"user_id":null,"body":"fun points(games: List<String>): Int {\n    return games.map { it.split(\":\") }.map { it[0] to it[1] }.map { (x, y) ->\n        if (x > y) 3 else if (x < y) 0 else 1\n    }.sum()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208407,"user_id":null,"body":"fun points(games: List<String>): Int {\n    var points = 0\n    for (game in games) {\n        if (game[0] > game[2]) {\n            points += 3\n        } else if (game[0] == game[2]) {\n            points += 1\n        }\n    }\n    \n    return points\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208408,"user_id":null,"body":"fun points(games: List<String>): Int {\n    val newGames = games.map { it.removeRange(1, 2) }\n    var count = 0\n    for (i in newGames) {\n        val fNum = i.substring(0, 1).toInt()\n        val sNum = i.substring(1, i.length).toInt()\n            if (fNum > sNum) {\n                count += 3\n            } else if (fNum == sNum) {\n                count++\n            }\n        }\n        return count\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208409,"user_id":null,"body":"fun points(games: List<String>) = games.sumBy { \n    it.split(\":\").map(String::toInt).let { it[0].compareTo(it[1]).let { it + if (it > 0) 2 else 1 } }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208410,"user_id":null,"body":"fun points(games: List<String>) =\n     games.map { if (it.first() > it.last()) 3 else if (it.first() == it.last()) 1 else 0 }.sum()\n   ","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208411,"user_id":null,"body":"val points = {games:List<String>-> games.filter{it.length==3}.sumBy {\n    Pair(it.take(1).toIntOrNull()?:0,it.takeLast(1).toIntOrNull()?:0).run {\n        if(first>second) 3 else if(first==second) 1 else 0\n    }\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208412,"user_id":null,"body":"\nfun points(games: List<String>): Int {\n\n    var sum = 0\n\n    games.forEach {\n        if (it.first().digitToInt() > it.last().digitToInt())\n            sum += 3\n        if (it.first().digitToInt() == it.last().digitToInt())\n            sum += 1\n    }\n    return sum\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208413,"user_id":null,"body":"fun points(games: List<String>): Int {\n    var pnt = 0\n    for (it in games) {\n        if (it[0] > it[2]) {\n            pnt += 3\n        }\n        else if (it[0] == it[2]) {\n            pnt += 1\n        }\n        else\n            pnt += 0\n    }\n    return pnt\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5bbb8887484fcd36fb0020ca":[{"id":208414,"user_id":null,"body":"fun catchSignChange(arr: Array<Int>): Int = arr.map { it < 0 }.zipWithNext { a, b -> a != b }.count { it }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208415,"user_id":953,"body":"fun catchSignChange(arr: Array<Int>) = if (arr.isEmpty()) 0 else {\n    var sum = 0\n    for (i in 0..arr.size - 2)\n        if (arr[i] >= 0 && arr[i + 1] < 0 || arr[i] < 0 && arr[i + 1] >= 0) sum += 1\n    sum\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208416,"user_id":527,"body":"fun catchSignChange(arr: Array<Int>): Int =\n  arr.asSequence().windowed(2).count { (x, y) -> (x >= 0) != (y >= 0) }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208417,"user_id":null,"body":"import kotlin.math.sign\n\nfun catchSignChange(arr: Array<Int>): Int = arr.map { it >= 0 }.zipWithNext().count { it.first != it.second }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208418,"user_id":null,"body":"fun catchSignChange(arr: Array<Int>): Int = arr.asSequence().zipWithNext().count{it.first >=0 != it.second >=0}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208419,"user_id":null,"body":"fun catchSignChange(arr: Array<Int>): Int {\n    var changes = 0\n    for (i in 0 until arr.size-1) {\n        if(arr[i]*arr[i+1] < 0 ) changes += 1\n        if(arr[i]*arr[i+1] == 0) {\n            if(arr[i]+arr[i+1] < 0) changes += 1\n        }\n    }\n    return changes\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208420,"user_id":null,"body":"import kotlin.math.abs\nimport kotlin.math.absoluteValue\n\nfun catchSignChange(arr: Array<Int>): Int {\n    return arr.map { if (it == 0) 1 else it }\n        .zipWithNext()\n        .filter { it.first * it.second != it.first.absoluteValue * it.second.absoluteValue }\n        .count()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208421,"user_id":null,"body":"fun catchSignChange(arr: Array<Int>): Int {\n    if(arr.isNullOrEmpty()) return 0\n    var count = 0\n    var pre = arr[0]\n    for(i in 1..arr.size-1){\n        val next = arr[i]\n        if((pre<0&&next>=0)||(pre>=0&&next<0)) count++\n        pre=next\n    }\n    return count\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208422,"user_id":null,"body":"fun catchSignChange(arr: Array<Int>): Int {\n    \n    var counter = 0\n    \n    for (i in 0 until arr.lastIndex) {\n        if ((arr[i] < 0) xor (arr[i+1] < 0)) counter++\n    }\n    \n    return counter\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208423,"user_id":null,"body":"fun catchSignChange(arr: Array<Int>): Int {\n    var a = 0\n    arr.forEachIndexed { i, current ->\n        if(i >0) {\n            val pre = arr[i - 1]\n            if ((current * pre < 0) || ( current * pre == 0 && (pre < 0 || current < 0))) {\n                a += 1\n            }  \n        } else {\n            \n        }\n     \n    }\n    return a\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5bbd279c8f8bbd5ee500000f":[{"id":208424,"user_id":null,"body":"fun findScreenHeight(width: Int, ratio: String): String {\n        val (w,h) = ratio.split(\":\").map { it.toInt() }\n        return \"${width}x${width * h \/ w}\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208425,"user_id":null,"body":"fun findScreenHeight(width: Int, ratio: String) =\n    \"${width}x${ratio.split(\":\").map { it.toDouble() }.let { (width \/ it[0] * it[1]).toInt() }}\"","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208426,"user_id":null,"body":"fun findScreenHeight(width: Int, ratio: String) = \"${width}x${ratio.split(\":\").let { width * it[1].toInt() \/ it[0].toInt() }}\"","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208427,"user_id":null,"body":"fun findScreenHeight (Width: Int, Ratio: String): String {\n    var arr = IntArray(Ratio.length); var AQ : Int = 40;\n    for (i in Ratio.indices) arr[i] = Ratio[i].toInt()\n    var numero : String = \"\";  var bnumero : String = \"\"\n    for (i in arr){\n        if (AQ == 1)bnumero += i.toChar() ; if (AQ == 40 && i != 58) numero += i.toChar()\n        if (i == 58) AQ = 1\n    }\n    var Final = (Width \/ numero.toDouble()) * bnumero.toDouble()\n    return (\"$Width\"+\"x\"+\"${Final.toInt()}\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208428,"user_id":null,"body":"fun findScreenHeight(width: Int, ratio: String): String =\n    \"${width}x${(ratio.split(':')[1].toInt() * width) \/ ratio.split(':')[0].toInt()}\"","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208429,"user_id":null,"body":"fun findScreenHeight(width: Int, ratio: String): String {\n    if (width <=0 || ratio.length < 3 || ratio.indexOf(':') < 1) return \"Wrong input!\"\n    val vals = ratio.split(\":\").map {it.toDouble()}\n    val k: Double = vals[0]\/vals[1]\n    val height: Int = (width\/k).toInt()\n    return \"${width}x${height}\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208430,"user_id":null,"body":"fun findScreenHeight(width: Int, ratio: String): String {\n    var r = ratio.split(':')\n    return width.toString() + \"x\" + (width * r[1].toInt() \/ r[0].toInt())\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208431,"user_id":1251,"body":"fun findScreenHeight(width: Int, ratio: String): String {\n    val r = ratio.split(\":\")\n    val height = width * r[1].toInt() \/ r[0].toInt()\n\treturn \"${width}x${height}\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208432,"user_id":null,"body":"fun findScreenHeight(width: Int, ratio: String): String {\n      var m = ratio.substringBefore(\":\").toInt()\n      var n = ratio.substringAfter(\":\").toInt()\n      var x = (width.toDouble() \/ m * n).toInt()  \n      return (\"${width.toString()}x${x.toString()}\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208433,"user_id":null,"body":"fun findScreenHeight(width: Int, ratio: String): String {\n    val (wRatio, hRatio) = ratio.split(\":\").map { it.toInt() }\n    val height = width * hRatio\/wRatio\n    return \"${width}x${height}\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5bc001de6aab18fba5000066":[{"id":208434,"user_id":null,"body":"fun jumping(arr: IntArray) : Boolean {\n    if(arr.size<2) return true\n    var ptr = arr.size-2\n    var abyss = 0\n    do {\n        val place = arr[ptr]\n        if(place==0 || place<=abyss)  ++abyss \n        if(place>0 && place>abyss) abyss = 0\n    } while(--ptr>=0)\n    return abyss==0\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208435,"user_id":null,"body":"import kotlin.math.max\n\nfun jumping(arr: IntArray) : Boolean {\n    var range = 0\n    arr.forEachIndexed { index, steps ->\n        if (index == arr.size - 1) {\n            return true\n        }\n        range = max(range - 1, steps)\n        if (range <= 0) {\n            return false\n        }\n    }\n    return false\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208436,"user_id":527,"body":"import kotlin.math.max\n\nfun jumping(xs: IntArray) : Boolean =\n    xs.asSequence().take(xs.size - 1).scan(1){ a, x -> max(a - 1, x) }.contains(0).not()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208437,"user_id":1170,"body":"fun jumping(arr: IntArray): Boolean {\n    var min = arr.size - 1\n    for (i in arr.size - 2 downTo 0) {\n        if (i + arr[i] >= min) min = i\n    }\n    return min == 0\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208438,"user_id":null,"body":"\/**\n * \u7b2c\u4e8c\u79cd\u89e3\u6cd5, \u4e0d\u989d\u5916\u521b\u5efa array\n *\/\nfun jumping(arrays: IntArray): Boolean {\n    arrays[arrays.size - 1] = 1\n    var i = arrays.size - 2\n    while (i >= 0) {\n        val step = arrays[i]\n        arrays[i] = 0\n        val valid = arrays.hasAnyIn(range = i + 1..i + step) { it == 1 }\n        if (valid) {\n            arrays[i] = 1\n        }\n        i--\n    }\n    return arrays[0] == 1\n}\n\nprivate inline fun IntArray.hasAnyIn(range: IntRange, crossinline predicate: (Int) -> Boolean): Boolean {\n    val last = Math.min(this.size - 1, range.last)\n    for (step in range.first .. last) {\n        if (predicate(this[step])) {\n            return true\n        }\n    }\n    return false\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208439,"user_id":null,"body":"fun jumping(arrays: IntArray): Boolean {\n    \/\/ >= 1 -> OK\n    \/\/ == 0 -> NO\n    val markTargets = IntArray(arrays.size)\n    markTargets[arrays.size - 1] = 1\n    var i = arrays.size - 2\n    while (i >= 0) {\n        val step = arrays[i]\n        val valid = canJumpToValidTargetInRange(markTargets, i + 1 .. i + step)\n        if (valid) {\n            markTargets[i] = 1\n        }\n        i--\n    }\n    return markTargets[0] == 1\n}\n\nprivate fun canJumpToValidTargetInRange(markTargets: IntArray, stepRange: IntRange): Boolean {\n    val last = Math.min(markTargets.size - 1, stepRange.last)\n    for (step in stepRange.first..last) {\n        if (markTargets[step] == 1) {\n            return true\n        }\n    }\n    return false\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208440,"user_id":53,"body":"fun jumping(arr: IntArray) : Boolean {\n  var m = arr[0];\n  if (m==0) return false;\n  for ((i, v) in arr.withIndex()) {\n    if (i==0 || i==arr.size-1) continue;\n    m = Math.max(m-1, v);\n    if (m<=0) return false;\n  }\n  return true;\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208441,"user_id":null,"body":"fun jumping(arr: IntArray) : Boolean {\n    var jumpPower = 1\n    arr.forEachIndexed { index, value ->\n        jumpPower--\n        jumpPower = if (value > jumpPower) value else jumpPower\n        if (index == arr.size - 1)\n            return true\n        if (jumpPower <= 0)\n            return false\n    }\n    return true\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208442,"user_id":null,"body":"fun jumping(arr: IntArray): Boolean {\n    val path = mutableListOf(0)\n    while (path.isNotEmpty() && path.last() < arr.lastIndex) {\n        val current = path.last()\n        val maxJump = arr[current]\n        if (maxJump == 0)\n            path.removeAt(path.lastIndex)\n        else {\n            path += current + maxJump\n            arr[current]--\n        }\n    }\n    return path.isNotEmpty()\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208443,"user_id":null,"body":"fun jumping(arr: IntArray): Boolean {\n    var exitIndex = arr.size - 1\n    for (i in (0..exitIndex).reversed()) {\n        when {\n            exitIndex - i > 9 -> return false\n            exitIndex <= i + arr[i] -> exitIndex = i\n        }\n    }\n    return exitIndex == 0\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5bc463f7797b00b661000118":[{"id":208444,"user_id":null,"body":"fun getSolution(arr: IntArray, sum: Int): Boolean {\n    if (arr.isNotEmpty()) {\n        if (arr.size == 1) return arr[0] == sum\n        val newArray = arr.copyOfRange(0, arr.size - 1)\n        return getSolution(newArray, sum - arr.last()) or getSolution(newArray, sum + arr.last())\n    }\n    return false\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208445,"user_id":null,"body":"fun getSolution(arr: IntArray, sum: Int): Boolean = if (arr.size == 1) arr.first() == sum else getSolution(arr.drop(1).toIntArray(), sum - arr.first()) || getSolution(arr.drop(1).toIntArray(), arr.first() - sum)\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208446,"user_id":null,"body":"fun getSolution(arr: IntArray, sum: Int): Boolean = arr.drop(1).fold(listOf(arr.first())) { acc, i ->\n    acc.flatMap { listOf(it - i, it + i) }\n}.contains(sum)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208447,"user_id":null,"body":"fun getSolution(arr: IntArray, sum: Int): Boolean {\n    val root: Node = Node(arr.first())\n\n    for (i in 1..arr.indices.last) {\n        root.insert(arr[i])\n    }\n\n    return root.solve(0, sum)\n}\n\nclass Node(private val value: Int, private var minus: Node? = null, private var plus: Node? = null) {\n\n    fun insert(value: Int) {\n        minus?.insert(value) ?: run {\n            minus = Node(-value)\n        }\n        plus?.insert(value) ?: run {\n            plus = Node(value)\n        }\n    }\n\n    fun solve(value: Int, target: Int) : Boolean {\n        return (this.value + value).let {\n            minus?.solve(it, target) ?: run { it == target } || plus?.solve(it, target) ?: run { it == target }\n        }\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208448,"user_id":null,"body":"fun getSolution(arr: IntArray, sum: Int): Boolean {\n\n\n\n\n    \n\n    val ran = 0..(1 shl (arr.size))\n  var runningCount=arr[0]\n  for(i in ran){\n      for(j in 1 until arr.size){\n          runningCount+=if((i shr j )%2==1) arr[j] else -arr[j]\n      }\n      if (runningCount==sum) return true\n      runningCount=arr[0]\n  }\n  return false\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208449,"user_id":null,"body":"fun getSolution(arr: IntArray, sum: Int): Boolean {\n    fun subSum(index: Int, s: Int): Boolean {\n        if (index == arr.size) return s == 0\n        return subSum(index + 1, s + arr[index]) || subSum(index + 1, s - arr[index])\n    }\n    return subSum(1, sum - arr[0])\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208450,"user_id":null,"body":"fun getSolution(arr: IntArray, sum: Int): Boolean {\n    val end = 1 shl arr.size - 1\n    val sArr = arr.drop(1)\n    val sSum = sum - arr[0]\n    return generateSequence(0) {\n        if (it < end) it + 1 else null\n    }.firstOrNull {\n        sArr.mapIndexed { index, i -> i * (if (it and (1 shl index) == 0) -1 else 1) }.sum() == sSum\n    }?.let { println(it); true } ?: false\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208451,"user_id":null,"body":"import kotlin.math.pow\n\nfun getSolution(arr: IntArray, sum: Int): Boolean = with( 2.0.pow(arr.size).toInt()) { \n    (0 until this).any { i -> (0..arr.lastIndex).sumOf { arr[it] * bitMultiplayer(i, it) } == sum }\n}\nfun isBitSet(n: Int, k: Int) = 1 and (n shr k) > 0\nfun bitMultiplayer(n: Int, k: Int) = if (isBitSet(n, k) || k == 0) 1 else -1","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208452,"user_id":1170,"body":"fun getSolution(arr: IntArray, sum: Int): Boolean {\n    val operatorList = IntArray(arr.size) { 1 }\n    return find(1, sum, arr, operatorList)\n}\n\nfun find(index: Int, sum: Int, arr: IntArray, operatorList: IntArray): Boolean {\n    if (index < arr.size) {\n        var x = find(index + 1, sum, arr, operatorList)\n        if (x) return true\n\n        operatorList[index] = -1\n        x = find(index + 1, sum, arr, operatorList)\n        if (x) return true\n\n        operatorList[index] = 1\n        return false\n    }\n    return getSum(arr, operatorList) == sum\n}\n\nfun getSum(arr: IntArray, operatorList: IntArray) =\n    arr.indices.fold(0) { acc, index -> acc + (arr[index] * operatorList[index]) }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208453,"user_id":null,"body":"import kotlin.random.Random\n\nfun getSolution(arr: IntArray, sum: Int): Boolean {\n    \n    for(i in 0..100000) {\n        val first = arr.first()\n        var res = shuffleAndSum(arr.copyOfRange(1, arr.size)) + first\n        if(res == sum)\n            return true\n    }\n    \n    return false\n}\n\n\nfun shuffleAndSum(arr: IntArray): Int {\n    val size = arr.size\n    val r = Random.nextInt(0, size)\n    \n    val list = arr.toMutableList()\n    list.shuffle()\n    \n    val sum1 = list.subList(0, r).sum()\n    val sum2 = list.subList(r, size).sum()\n    \n    return sum1 - sum2\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5bc9951026f1cdc77400011c":[{"id":208454,"user_id":null,"body":"fun babyCount(x: String): Int? {\n    val a = minOf(\n            x.toLowerCase().count { it == 'b' }\/2,\n            x.toLowerCase().count { it == 'a' },\n            x.toLowerCase().count { it == 'y' }\n        )\n    return if(a == 0) null else a\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208455,"user_id":null,"body":"fun babyCount(x: String): Int? {\n    val count = x.toLowerCase().groupingBy { it }.eachCount()\n    return listOf(count['a'] ?: 0, (count['b'] ?: 0) \/ 2, count['y'] ?: 0).min()?.takeIf { it > 0 }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208456,"user_id":null,"body":"fun babyCount(x: String)=\n    x.toLowerCase().replace(\"[^bay]\".toRegex(), \"\")\n        .groupBy { it }.let { \n            listOf((it['b']?.size ?: 0) \/ 2, it['a']?.size ?: 0, it['y']?.size ?: 0)\n                .minBy {it}\n        }.let { if (it == 0) null else it}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208457,"user_id":null,"body":"fun babyCount(x: String): Int? {\n  val countA = x.count { it.toLowerCase() == 'a' }\n  val countB = x.count { it.toLowerCase() == 'b' }\n  val countY = x.count { it.toLowerCase() == 'y' }\n  \n  val result = minOf(countA, countB\/2, countY)\n  return if (result > 0) {\n      result\n  } else {\n      null\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208458,"user_id":null,"body":"fun babyCount(x: String) = minOf(\n    x.lowercase().count { it == 'b' } \/ 2,\n    x.lowercase().count { it == 'a' },\n    x.lowercase().count { it == 'y' }).takeIf { it > 0 }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208459,"user_id":null,"body":"\nfun babyCount(x: String): Int? {\n    val t = x.toLowerCase()\n    val min = listOf(t.filter { it=='b' }.count() \/ 2, t.filter { it=='a' }.count(), t.filter { it=='y' }.count()).min()\n    return if(min!!>0) min else null\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208460,"user_id":1267,"body":"fun babyCount(x: String): Int? {\n  val _x = x.toLowerCase().replace(Regex(\"[^aby]\"), \"\");\n  val b = Regex(\"b\").findAll(_x).toList().size;\n  val a = Regex(\"a\").findAll(_x).toList().size;\n  val y = Regex(\"y\").findAll(_x).toList().size;\n  val count = Math.min(b\/2, Math.min(a, y))\n  return if (count > 0) count else null\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208461,"user_id":null,"body":"fun babyCount(x: String): Int? {\n    val y = x.toUpperCase()\n    var totalB = 0\n    var totalA = 0\n    var totalY = 0\n\n    y.forEach {\n        if (it == 'B'){\n            totalB += 1\n        } else if(it == 'A') {\n            totalA += 1\n        } else if (it == 'Y'){\n            totalY += 1\n        }\n    }\n    totalB \/= 2\n\n    if ((totalB == 0) || (totalA == 0) || (totalY == 0)) {\n        return null\n    } else if ((totalB < totalA) && (totalB < totalY)){\n        return totalB\n    } else if (totalA <= totalY) {\n        return totalA\n    } else  {\n        return totalY\n    }\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208462,"user_id":null,"body":"fun babyCount(x: String): Int? {\n    val countA = x.count { it.lowercaseChar() == 'a' }\n    val countB = x.count { it.lowercaseChar() == 'b' }\n    val countY = x.count { it.lowercaseChar() == 'y' }\n\n    val result = minOf(countA, countB\/2, countY)\n    return if (result > 0) {\n        result\n    } else {\n        null\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208463,"user_id":null,"body":"fun babyCount(x: String): Int? {\n  val b = x.lowercase().count { it == 'b' }\n    val a = x.lowercase().count { it == 'a' }\n    val y = x.lowercase().count { it == 'y' }\n    val min = listOf(a, b, y).minOrNull()\n    return if (min == 0) null\n    else {\n        if (b \/ 2 >= min!!) min else b \/ 2\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5bd00c99dbc73908bb00057a":[{"id":208464,"user_id":null,"body":"fun alphaSeq(str: String) = str.toLowerCase().toCharArray().sorted().joinToString(\",\") { it.toString().repeat(it.toInt() - 96).capitalize() }\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208465,"user_id":null,"body":"fun alphaSeq(str: String) = str.map { it.toLowerCase() }.sorted().joinToString(\",\") { \"$it\".repeat(it - 'a' + 1).capitalize() }\n    ","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208466,"user_id":null,"body":"fun alphaSeq(str: String) =\n    str.toLowerCase()\n        .toCharArray()\n        .sorted()\n        .joinToString(\",\"){ \"$it\".toUpperCase() + \"$it\".repeat(it - 'a')}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208467,"user_id":null,"body":"fun alphaSeq(str: String): String {\n    return str.toLowerCase().toCharArray().sorted()\n        .joinToString(\",\") { it.toUpperCase() + \"$it\".repeat(it.toInt() - 'a'.toInt()) }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208468,"user_id":null,"body":"fun alphaSeq(str: String)= str.toLowerCase().toCharArray().sorted()\n    .joinToString(\",\") { it.toString().repeat(it.toLowerCase().toInt() - 96).capitalize() }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208469,"user_id":null,"body":"fun alphaSeq(str: String): String =str.map { it.toLowerCase() }.sorted().joinToString(\",\") { it.toUpperCase() + it.toString().repeat(it.toInt() - 96-1) }\n    \/\/your code here\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208470,"user_id":null,"body":"fun alphaSeq(str: String): String {\n    return str.toUpperCase()\n                .toCharArray()\n                .sorted()\n                .joinToString(\",\") { char ->\n                    char + char.toLowerCase().toString().repeat(char.toInt() - 65)\n                }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208471,"user_id":null,"body":"fun alphaSeq(str: String) = str.toLowerCase().toList().sorted().joinToString(\",\") { \"$it\".repeat(it - '`').capitalize() }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208472,"user_id":null,"body":"fun alphaSeq(str: String): String {\n    \n    val chars = str.uppercase().toCharArray().sorted()\n    val builder = StringBuilder()\n\n    chars.forEach {\n        builder.append(\"$it${it.lowercase().repeat(it.lowercaseChar().code - 'a'.code)},\")\n    }\n\n    return builder.dropLast(1).toString()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208473,"user_id":null,"body":"fun alphaSeq(str: String) = str.lowercase().toList().sorted().map() {it -> it.toString().repeat(it.toInt()-96).capitalize()}.joinToString(\",\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5be0c8601b109ad2450000a5":[{"id":208474,"user_id":null,"body":"fun romajiToHiragana(romaji: String) = \n    Regex(\"\"\"((?:[kgstdnhfbpmyrwjz]?[aiueo])|(?:(?:ts|ky|sh|ch|ny|hy|my|ry|gy|by|py)[aiueo])|(?:k(?=k))|(?:t(?=t))|n)\"\"\")\n        .findAll(romaji)\n        .map {it.groupValues[0]}\n        .map {when (it) {\n            \"k\", \"t\" -> \"tsuSmall\"\n            else -> it\n        }}\n        .map {HIRAGANA.get(it)}\n        .joinToString(\"\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208475,"user_id":null,"body":"fun romajiToHiragana(romaji: String): String {\n    \n    var hiragana = romaji\n    \n    if(hiragana.contains(\"nn\")) {\n        hiragana = hiragana.replace(\"nn\", HIRAGANA[\"n\"]!! + \"n\")\n    }\n    \n    hiragana = hiragana.replace(\"([kt])\\\\1+\".toRegex()) { \n        HIRAGANA[\"tsuSmall\"]!! + it.value[0].toString()\n    }\n\n    HIRAGANA.keys\n            .sortedBy { it.length }\n            .reversed()\n            .forEach{\n                if(romaji.contains(it)) {\n                    hiragana = hiragana.replace(it, HIRAGANA[it]!!)\n                }\n            }\n\n    return hiragana\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208476,"user_id":null,"body":"fun romajiToHiragana(romaji: String): String {\n    return romaji.split(Regex(\"(?<=[aeiou])\")).toMutableList()\n        .map{        \n            when(true){\n                it == \"\" -> \"\"\n                it.length > 1 && it[0] != 'n' && it[0] == it[1] -> {\n                    HIRAGANA.get(\"tsuSmall\") +  HIRAGANA.get(it.drop(1))    \n                }\n                it.length > 1 && it[0] == 'n' && it[1] !in listOf('a','e','i','o','u','e','y') -> {\n                     HIRAGANA.get(\"n\") + HIRAGANA.get(it.drop(1))    \n                }\n                else -> HIRAGANA.get(it)\n            }\n        }.joinToString(\"\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208477,"user_id":null,"body":"fun romajiToHiragana(romaji: String): String {\n    \/\/ Happy coding, \u304c\u3093\u3070\u3063\u3066 !\n    var i = 0\n    var j = 0\n    var res = \"\"\n    while (j < romaji.length) {\n        j++\n        \n        val s = romaji.substring(i, j)\n        if (s.length == 2 && s[0] == s[1] && s[0] != 'n') {\n            res += HIRAGANA.get(\"tsuSmall\")\n            i++\n        } else if (s.length == 1 && s[0] == 'n' && romaji.length > i + 1 && \"aeiouy\".contains(romaji[i + 1])) {\n            if (romaji[i + 1] == 'y') {\n                res += HIRAGANA.get(romaji.substring(i, i + 3))\n                i += 3\n                j += 2\n            } else {\n                res += HIRAGANA.get(romaji.substring(i, i + 2))\n                i += 2\n                j++\n            }\n        } else if (HIRAGANA.containsKey(s)) {\n            res += HIRAGANA.get(s)\n            i = j\n        }\n    }\n    \n    return res\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208478,"user_id":null,"body":"fun convertFirstSyllable(romaji: String): Pair<String, String> {\n    var result = \"\"\n    var remainder = romaji\n    if(romaji.length>=3 && romaji[0]==romaji[1]) {\n        result+= if('n' == romaji[0]) HIRAGANA[\"n\"] else   HIRAGANA[\"tsuSmall\"]\n        remainder = remainder.substring(1)\n    }\n    else if(remainder.length>=3 && HIRAGANA[remainder.take(3)] != null) {\n        result+= HIRAGANA[remainder.take(3)]\n        remainder = remainder.substring(3)\n    }\n    else if(remainder.length>=2 && HIRAGANA[remainder.take(2)] != null) {\n        result+= HIRAGANA[remainder.take(2)]\n        remainder = remainder.substring(2)\n    }\n    else if(HIRAGANA[remainder.take(1)] != null) {\n        result+= HIRAGANA[remainder.take(1)]\n        remainder = remainder.substring(1)\n    }\n    return result to remainder\n}\n\nfun romajiToHiragana(romaji: String): String {\n    var remainder = romaji\n    var result = \"\"\n    while(remainder.isNotEmpty())\n    {\n        val c = convertFirstSyllable(remainder)\n        result+=c.first\n        remainder = c.second\n    }\n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208479,"user_id":null,"body":"fun romajiToHiragana(romaji: String): String {\n    val syllableRegex = \"[bcdfghjklmnpqrstvwxyz]*([aeiou]|$)\".toRegex()\n    return syllableRegex.findAll(romaji).map { it.value }.mapNotNull {\n        if(it.count() > 2 && it[0] == it[1]) {\n            if(it[0] == 'n') HIRAGANA.get(\"n\") + HIRAGANA.get(it.substring(1))\n            else HIRAGANA.get(\"tsuSmall\") + HIRAGANA.get(it.substring(1))\n        } else if(it.count() > 2 && it[0] == 'n' && it[1] != 'y') {\n            HIRAGANA.get(\"n\") + HIRAGANA.get(it.substring(1))\n        } else {\n             HIRAGANA.get(it)\n        }\n    }.joinToString(\"\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208480,"user_id":null,"body":"fun romajiToHiragana(romaji: String): String {\n    \/\/ Happy coding, \u304c\u3093\u3070\u3063\u3066 !\n    val vowel = \"aiueo\"\n    val spromaji = romaji.trim().split(\"\").filter { it != \"\"}\n    var hiragana = \"\"\n    var word = \"\"\n    var oldC = \"\"\n    var cnt = 0\n\n    for (c in spromaji) {\n        cnt++\n        \n        if (c.isBlank()) {\n            continue\n        }\n        if (cnt == spromaji.size && c == \"n\") {\n            hiragana += \"\u3093\"\n        } else if (vowel.contains(c, true)) {\n            word += c\n            hiragana += HIRAGANA.get(word)\n            word = \"\"\n            oldC = c\n        } else {\n            if (word.isNotEmpty()) {\n                if (c == oldC) {\n                    hiragana += when (word) {\n                        \"n\" -> \"\u3093\"\n                        else -> \"\u3063\"\n                    }\n                } else if (word.startsWith(\"n\") && c != \"y\") {\n                    hiragana += \"\u3093\"\n                    word = word.substring(1)\n                    word += c\n                } else {\n                    word += c\n                }\n            } else {\n                word += c\n            }\n            oldC = c\n\n        }\n    }\n    return hiragana\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208481,"user_id":1228,"body":"fun romajiToHiragana(romaji: String): String {\n    \/\/ Happy coding, \u304c\u3093\u3070\u3063\u3066 !\n    var last = 0\n    var result = \"\"\n    for (i in 0 until romaji.length) {\n      when  (romaji[i]) {\n        'a', 'e', 'i', 'o', 'u' -> {\n              result += HIRAGANA.get(romaji.substring(last, i+1));\n              last = i+1\n          }\n      else -> {\n              if ((i>0 && 'n' == romaji[i-1] && 'y' != romaji[i]) || ('n'== romaji[i] && i== romaji.length - 1)) {\n                result += HIRAGANA.get(\"n\")\n                last ++\n              }\n              else if (i>0 && 'n' != romaji[i-1] && romaji[i-1] == romaji[i]) {\n                result += HIRAGANA.get(\"tsuSmall\")\n                last ++\n              }\n          }\n      }\n  }\n  return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208482,"user_id":1251,"body":"fun romajiToHiragana(romaji: String): String {\n    var hiraganaWord = \"\"\n    var index = 0\n    val len = romaji.length\n    while (index < len) {\n        if (romaji.get(index) == 'a' || romaji.get(index) == 'i' || romaji.get(index) == 'u' || romaji.get(index) == 'e' || romaji.get(index) == 'o')\n            hiraganaWord += HIRAGANA.get(Character.toString(romaji.get(index++)))\n        else if (romaji.get(index) != 'n' && index + 1 < len && romaji.get(index+1) != 'a' && romaji.get(index+1) != 'i' && romaji.get(index+1) != 'u' && romaji.get(index+1) != 'e' && romaji.get(index+1) != 'o' &&\n                 romaji.get(index+1) != 'h' && romaji.get(index+1) != 'y' && !(romaji.get(index) == 't' && romaji.get(index+1) == 's')) {\n                     hiraganaWord += HIRAGANA.get(\"tsuSmall\")\n                     index++\n        }\n        else if (((index + 2 < len) && (romaji.substring(index,index+3).equals(\"shi\") || romaji.substring(index,index+3).equals(\"chi\"))) || (index + 1 < len && romaji.substring(index, index+2).equals(\"ts\"))) {\n            hiraganaWord += HIRAGANA.get(romaji.substring(index, index + 3))\n            index += 3\n        }\n        else if (romaji.get(index) == 'n' && (index + 1 == len ||\n                 romaji.get(index+1) != 'a' && romaji.get(index+1) != 'i' && romaji.get(index+1) != 'u' && romaji.get(index+1) != 'e' && romaji.get(index+1) != 'o' && romaji.get(index+1) != 'y')) {\n            hiraganaWord += HIRAGANA.get(\"n\")\n            index++\n        }\n        else if ((index + 1 < len && (romaji.get(index+1) == 'y' || romaji.get(index+1) == 'h')) || romaji.get(index) == 'j') {\n            if (romaji.get(index) == 'j') {\n                hiraganaWord += HIRAGANA.get(\"ji\")\n                if (romaji.get(index+1) == 'a') hiraganaWord += HIRAGANA.get(\"yaSmall\")\n                else if (romaji.get(index+1) == 'u') hiraganaWord += HIRAGANA.get(\"yuSmall\")\n                else if (romaji.get(index+1) == 'o') hiraganaWord += HIRAGANA.get(\"yoSmall\")\n                index += 2\n            }\n            else {\n                if (romaji.get(index) == 'k') hiraganaWord += HIRAGANA.get(\"ki\")\n                else if (romaji.get(index) == 's') hiraganaWord += HIRAGANA.get(\"shi\")\n                else if (romaji.get(index) == 'c') hiraganaWord += HIRAGANA.get(\"chi\")\n                else if (romaji.get(index) == 'n') hiraganaWord += HIRAGANA.get(\"ni\")\n                else if (romaji.get(index) == 'h') hiraganaWord += HIRAGANA.get(\"hi\")\n                else if (romaji.get(index) == 'm') hiraganaWord += HIRAGANA.get(\"mi\")\n                else if (romaji.get(index) == 'r') hiraganaWord += HIRAGANA.get(\"ri\")\n                else if (romaji.get(index) == 'g') hiraganaWord += HIRAGANA.get(\"gi\")\n                else if (romaji.get(index) == 'b') hiraganaWord += HIRAGANA.get(\"bi\")\n                else if (romaji.get(index) == 'p') hiraganaWord += HIRAGANA.get(\"pi\")\n                if (romaji.get(index+2) == 'a') hiraganaWord += HIRAGANA.get(\"yaSmall\")\n                if (romaji.get(index+2) == 'u') hiraganaWord += HIRAGANA.get(\"yuSmall\")\n                if (romaji.get(index+2) == 'o') hiraganaWord += HIRAGANA.get(\"yoSmall\")\n                index += 3\n            }\n        }\n        else if (romaji.get(index) == 'g' || romaji.get(index) == 'd' || romaji.get(index) == 'z' || romaji.get(index) == 'b' || romaji.get(index) == 'p' ||\n            romaji.get(index) == 'j' && romaji.get(index+1) == 'i') {\n            hiraganaWord += HIRAGANA.get(romaji.substring(index, index + 2))\n            index += 2\n        }\n        else {\n            hiraganaWord += HIRAGANA.get(romaji.substring(index, index + 2))\n            index += 2\n        }\n    }\n    return hiraganaWord\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5be350bcce5afad8020000d6":[{"id":208483,"user_id":null,"body":"val words = VALID_WORDS.sortedByDescending { it.length }\n\nprivate fun getWord(str: String) = words.find { str.startsWith(it) } ?: str.take(1)\n\nfun maxMatch(sentence: String) = generateSequence(sentence to listOf<String>()) {\n    if (it.first.isEmpty()) null else getWord(it.first).run { it.first.drop(length) to it.second + this }\n}.last().second","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208484,"user_id":1251,"body":"fun maxMatch(sentence: String): List<String> {\n    val len = sentence.length\n    if (len == 0) return emptyList()\n    for (i in len downTo 2) {\n        if (VALID_WORDS.contains(sentence.substring(0,i))) {\n            var words = mutableListOf(sentence.substring(0,i))\n            words.addAll(maxMatch(sentence.substring(i)))\n            return words\n        }\n    }\n    var words = mutableListOf(sentence.substring(0,1))\n    words.addAll(maxMatch(sentence.substring(1)))\n    return words\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208485,"user_id":1228,"body":"   fun maxMatch(sentence: String): List<String> {\n    val ans = mutableListOf<String>()\n    for (index in sentence.length downTo 0) {   \n      if (index == 1 || VALID_WORDS.contains(sentence.substring(0, index))) {\n        ans.add(sentence.substring(0, index))\n        ans.addAll(maxMatch(sentence.substring(index)))\n        break;\n      }\n    }\n    return ans\n  }\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208486,"user_id":932,"body":"val MAX_LENGTH = VALID_WORDS.map{it.length}.max()?:1\n\nfun maxMatch(sentence: String)=ArrayList<String>().apply{\n        var s = sentence\n        while (s.isNotEmpty()) {\n            var mL = MAX_LENGTH\n            while (mL > 1 && !VALID_WORDS.contains(s.take(mL))) mL--\n            add(s.take(mL))\n            s = s.drop(mL)\n        }\n    }.toList()\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208487,"user_id":null,"body":"fun maxMatch(sentence: String): List<String> {\n    \n    var result = mutableListOf<String>()\n    var redSentence = sentence\n    \n    while (!redSentence.isEmpty())  {\n        var wordFound = false\n        VALID_WORDS.sortedByDescending() {it.length}.forEach{\n            if (!wordFound && redSentence.take(it.length) == it) {\n                result.add(it)\n                redSentence = redSentence.drop(it.length)\n                wordFound = true\n            }\n        }\n        if (!wordFound) {\n            result.add(redSentence.take(1))\n            redSentence = redSentence.drop(1)\n        }\n    }\n   \n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208488,"user_id":null,"body":"\nfun maxMatch(sentence: String): List<String> {\n    val ret = mutableListOf<String>()\n    var words = sentence\n    fun rec(k:String) {\n        if(words.isNotEmpty()){\n        if(VALID_WORDS.contains(k)|| k.length==1){\n            ret+=k\n            words = words.drop(k.length)\n            rec(words)\n        }else rec(k.dropLast(1))\n    }}\n    rec(sentence)\n    return ret.toList()\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208489,"user_id":null,"body":"fun maxMatch(sentence: String): List<String> {\n    val words = mutableListOf<String>()\n    var i = sentence.length\n\n    while (i > 0) {\n        val word = sentence.substring(0, i)\n\n        if (i == 1 || VALID_WORDS.contains(word)) {\n            words.add(word)\n            words.addAll(maxMatch(sentence.substring(i)))\n            break\n        }\n        i--\n    }\n    return words\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208490,"user_id":null,"body":"fun maxMatch(sentence: String): List<String> {\n    val words = mutableListOf<String>()\n    var buffer = sentence\n    var lastMatch = \"\"\n    while (buffer.isNotEmpty()) {\n\n        for (i in 1..buffer.length) {\n            val s = buffer.substring(0, i)\n            if (VALID_WORDS.any { it.startsWith(s) }) {\n                if (VALID_WORDS.contains(s)) {\n                    lastMatch = s\n                }\n            } else break\n        }\n\n        if (lastMatch.isNotEmpty()) {\n            words.add(lastMatch)\n            buffer = buffer.substringAfter(lastMatch)\n            lastMatch = \"\"\n        } else {\n            words.add(buffer.take(1))\n            buffer = buffer.drop(1)\n        }\n    }\n    return words\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208491,"user_id":1170,"body":"fun maxMatch(sentence: String): List<String> {\n    val result = mutableListOf<String>()\n    search(sentence, result)\n    return result\n}\n\nfun search(sentence: String, result: MutableList<String>) {\n    if (sentence == \"\") return\n\n    val subset = VALID_WORDS.filter { it.startsWith(sentence[0]) }\n    var longest = \"\"\n    subset.forEach {\n        if (sentence.startsWith(it) && it.length > longest.length) {\n            longest = it\n        }\n    }\n    if (longest.isEmpty()) {\n        result.add(sentence[0].toString())\n        search(sentence.drop(1), result)\n    } else {\n        result.add(longest)\n        search(sentence.drop(longest.length), result)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208492,"user_id":null,"body":"fun maxMatch(sentence: String): List<String> {\n    var str = sentence\n    val ret_list = mutableListOf<String>()\n    while (str.length>0) {\n        var take = 1\n        for (srch in VALID_WORDS.sortedBy{it.length}.reversed()) {\n            val ind = str.indexOf(srch)\n            if (ind==0) {\n                take = srch.length\n                break\n            }\n        }\n        val word = str.take(take)\n        str = str.drop(take)\n        ret_list.add(word)\n    }\n    \n    return ret_list\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5c3433a4d828182e420f4197":[{"id":208493,"user_id":null,"body":"\/\/ No Kotlin coder would ever use Arrays if they could avoid it,\n\/\/ even in a challenge called \"Ultimate Array Reverser.\"\n\/\/ To paraphrase a man in a cave,\n\/\/ \"It's dangerous to go alone, take this [List]\"\nfun reverse(a: List<String>): List<String> {\n    var contentsReversed = a.joinToString(\"\").reversed()\n    val output = mutableListOf<String>()\n    for (word in a) {\n        val newWord = contentsReversed.take(word.length)\n        contentsReversed = contentsReversed.drop(word.length)\n        output.add(newWord)\n    }\n    return output\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208494,"user_id":null,"body":"fun reverse(a: List<String>): List<String> {\n    val str = a.joinToString(\"\").reversed().iterator()\n    return a.map { Array(it.length) { str.nextChar() }.joinToString(\"\") }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208495,"user_id":null,"body":"\/\/ No Kotlin coder would ever use Arrays if they could avoid it,\n\/\/ even in a challenge called \"Ultimate Array Reverser.\"\n\/\/ To paraphrase a man in a cave,\n\/\/ \"It's dangerous to go alone, take this [List]\"\nfun reverse(a: List<String>): List<String> {\n    var string = a.joinToString(\"\").reversed()\n    val list = mutableListOf<String>()\n    for (str in a){\n        list.add(string.take(str.length))\n        string = string.drop(str.length)\n    }\n    return list\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208496,"user_id":null,"body":"fun reverse(a: List<String>): List<String> {\n        val word = a.joinToString(\"\").reversed()\n        val list = mutableListOf<String>()\n        var counter = 0\n        a.map {\n            val builder = StringBuilder()\n            (it.indices).map {\n                builder.append(word[counter])\n                counter++\n            }\n            list.add(builder.toString())\n            builder.clear()\n        }\n\n        return list\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208497,"user_id":null,"body":"fun reverse(a: List<String>): List<String> {\n    var str = a.joinToString(\"\").reversed()\n    return a.map{val s = str.take(it.length);str = str.drop(it.length);s}\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208498,"user_id":null,"body":"fun reverse(a: List<String>) = a.map { it.length }.fold(listOf(a.joinToString(\"\").reversed()))\n{ c, l: Int -> c.dropLast(1) + c.last().run { listOf(take(l), drop(l)) } }.dropLast(1)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208499,"user_id":null,"body":"fun reverse(a: List<String>): List<String> {\n    \n    val lengths = a.map { it.length }\n    var reversedStringifiedList = a.joinToString(\"\").reversed()\n    val result = mutableListOf<String>()\n\n    for (i in lengths) {\n        result.add(reversedStringifiedList.take(i))\n        reversedStringifiedList = reversedStringifiedList.substring(i)\n    }\n\n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208500,"user_id":null,"body":"\/\/ No Kotlin coder would ever use Arrays if they could avoid it,\n\/\/ even in a challenge called \"Ultimate Array Reverser.\"\n\/\/ To paraphrase a man in a cave,\n\/\/ \"It's dangerous to go alone, take this [List]\"\n    fun reverse(a: List<String>): List<String> {\n\n        val s = a.joinToString(\"\").reversed()\n\n        val o = arrayListOf<String>()\n\n        var offset = 0\n\n        for (i in a) {\n            o.add(s.slice(offset..offset + i.length-1))\n            offset += i.length\n        }\n\n        return o\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208501,"user_id":null,"body":"\/\/ No Kotlin coder would ever use Arrays if they could avoid it,\n\/\/ even in a challenge called \"Ultimate Array Reverser.\"\n\/\/ To paraphrase a man in a cave,\n\/\/ \"It's dangerous to go alone, take this [List]\"\nfun reverse(a: List<String>): List<String> {\n    var inputToString = a.joinToString(\"\").reversed()\n    var output = mutableListOf<String>()\n    a.forEach{\n        output.add(inputToString.take(it.length))\n        inputToString = inputToString.drop(it.length)\n    }\n    return output\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208502,"user_id":null,"body":"fun reverse(a: List<String>): List<String> {\n    var allLatters = a.flatMap { it.toList() }.reversed()\n    var result = mutableListOf<String>()\n    a.forEach {\n        result.add(allLatters.take(it.length).joinToString(\"\"))\n        allLatters = allLatters.drop(it.length)\n    }\n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5c374b346a5d0f77af500a5a":[{"id":208503,"user_id":null,"body":"import kotlin.math.abs\nfun elevator(left: Int, right: Int, call: Int) = if (abs(call - left) < abs(call - right)) \"left\" else \"right\"","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208504,"user_id":null,"body":"fun elevator(left: Int, right: Int, call: Int) = if (Math.abs(left-call) < Math.abs(right-call)) \"left\" else \"right\"\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208505,"user_id":null,"body":"import kotlin.math.abs \n\nfun elevator(left: Int, right: Int, call: Int): String {\n  val distanceLeft = abs(call - left)\n  val distanceRight = abs(call - right)\n  return if(distanceLeft < distanceRight) \"left\" else \"right\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208506,"user_id":null,"body":"fun elevator(left: Int, right: Int, call: Int): String {\n  val leftDis = Math.abs(left - call)\n  val rightDis = Math.abs(right - call)\n  val minDis = minOf(leftDis, rightDis)\n \n  return when (minDis){\n      rightDis -> \"right\"\n      else -> \"left\"\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208507,"user_id":null,"body":"fun elevator(left: Int, right: Int, call: Int) = \n    mapOf(left to \"left\", right to \"right\").filter {\n        when (it.key == call) {\n            true -> it.key == call\n            false -> {\n                when (Math.abs(call - right) <= Math.abs(call - left)) {\n                    true -> it.key == right\n                    false -> it.key == left\n                }\n            }\n        }\n    }.values.first()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208508,"user_id":null,"body":"fun elevator(left: Int, right: Int, call: Int): String {\n  if(Math.abs(left - call) >= Math.abs(right - call)) return \"right\"\n  else return \"left\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208509,"user_id":null,"body":"fun main() {\n    elevator(0, 1, 0) \/\/ => \"left\"\n    elevator(0, 1, 1) \/\/ => \"right\"\n    elevator(0, 1, 2) \/\/ => \"right\"\n    elevator(0, 0, 0) \/\/ => \"right\"\n    elevator(0, 2, 1) \/\/ => \"right\"\n}\n\nfun elevator(left: Int, right: Int, call: Int):String {\n    lateinit var elevatorToTake:String\n    if (call in 0..2) {\n        \/\/The difference between the call floor and the floor where the left elevator is\n        val difLeft = kotlin.math.abs(call-left)\n\n        \/\/The difference between the call floor and the floor where the right elevator is\n        val difRight = kotlin.math.abs(call-right)\n        when {\n            difLeft == difRight ->  elevatorToTake =\"right\"\n            difLeft < difRight ->  elevatorToTake =\"left\"\n            difLeft > difRight ->  elevatorToTake =\"right\"\n        }\n    }\n    \/\/println(elevatorToTake)\n    return elevatorToTake\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208510,"user_id":null,"body":"fun elevator(left: Int, right: Int, call: Int): String {\n\n    var elevatorToMove = \"\"\n    var distanceFromLeftElevator = kotlin.math.abs(call - left)\n    var distanceFromRightElevator = kotlin.math.abs(call - right)\n\n    println(\"Distance from left elevator = \" + distanceFromLeftElevator)\n    println(\"Distance from right elevator = \" + distanceFromRightElevator)\n\n    if(right == call){\n        elevatorToMove = \"right\"\n        println(\"right\")\n    }else  if(left == call){\n        elevatorToMove = \"left\"\n        println(\"left\")\n    }else if (distanceFromLeftElevator == distanceFromRightElevator) {\n        elevatorToMove = \"right\"\n        println(\"right\")\n    }else if (distanceFromLeftElevator < distanceFromRightElevator) {\n        elevatorToMove = \"left\"\n        println(\"left\")\n    } else {\n        elevatorToMove = \"right\"\n        println(\"right\")\n    }\n\n    println(elevatorToMove)\n    return elevatorToMove\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208511,"user_id":null,"body":"fun elevator(left: Int, right: Int, call: Int): String {\n   var l: String? = null\n\n    if ((left == call && left != right) || (left < call && right < left)||(left > call && right > left)) {\n        l = \"left\"\n    } else {\n        l = \"right\"\n    }\n    return l\n}\n\/\/fun elevator(left: Int, right: Int, call: Int)= if (abs(call - left) < abs(call - right)) \"left\" else \"right\"\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208512,"user_id":null,"body":"fun elevator(left: Int, right: Int, call: Int): String {\n  \/\/ code here\n    \n   return if(Math.abs(right-call)<=Math.abs(left-call)) \"right\" else \"left\"  \n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5c44b0b200ce187106452139":[{"id":208513,"user_id":null,"body":"fun argsCount(vararg args: Any): Int = args.size\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208514,"user_id":1251,"body":"fun argsCount(vararg args: Any) = args.size","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208515,"user_id":null,"body":"fun argsCount(vararg args: Any): Int {\n    return (args as Array<Any>).count()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208516,"user_id":null,"body":"fun argsCount(vararg args: Any): Int {\n    return args.size;\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208517,"user_id":null,"body":"fun argsCount(vararg args: Any): Int {\n    var d = 0\n    for(i in args){\n        d++\n    } \n    return d  \n} \/\/args.contains()\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208518,"user_id":null,"body":"fun argsCount(vararg args: Any): Int = args.lastIndex + 1","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208519,"user_id":null,"body":"fun argsCount(vararg args: Any): Int {\n    var c = 0\n    for (item in args) {\n        c += 1\n    }\n    return c\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208520,"user_id":null,"body":"fun argsCount(vararg args: Any):Int{\n    var v = 0\n    for(t in args){\n           v++\n    }\n    return v\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208521,"user_id":null,"body":"fun argsCount(vararg args: Any): Int {\n    val result = ArrayList<Any>()\n    for (arg in args) result.add(arg)\n    return result.size\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208522,"user_id":null,"body":"fun argsCount(vararg args: Any): Int {\n    var k = 0\n    for(i in args){\n        k++\n    }\n    return k\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5c55ad8c9d76d41a62b4ede3":[{"id":208523,"user_id":null,"body":"fun duplicates(array: IntArray) = array.groupBy { it }.map { it.value.size \/ 2 }.sum()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208524,"user_id":null,"body":"fun duplicates(array: IntArray) = array.toSet().sumBy { x -> array.count { it == x } \/ 2 }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208525,"user_id":null,"body":"fun duplicates(array: IntArray) = array.groupBy { it }.values.sumBy { it.count() \/ 2 }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208526,"user_id":null,"body":"fun duplicates(array: IntArray): Int {\n    var registry: ArrayList<Int> = ArrayList(array.size)\n    var duplicates: Int = 0\n    for (item in array) {\n        if (registry.contains(item)) {\n            duplicates += 1\n            registry.remove(item)\n        } else {\n            registry.add(item)\n        }\n    }\n    return duplicates\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208527,"user_id":null,"body":"fun duplicates(array: IntArray): Int {\n    return array.groupBy { it }.map { it.value.size \/ 2 }.sum()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208528,"user_id":null,"body":"fun duplicates(array: IntArray) = array.toSet().map { number ->\n    array.count { it == number } \/ 2\n}.sum()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208529,"user_id":null,"body":"fun duplicates(array: IntArray): Int {\n      \n      var hashMap = LinkedHashMap<Int, Int>(array.size)\n      var totalCount = 0\n\n     for (values in array) {\n      if (hashMap.containsKey(values))\n          { hashMap.remove(values)\n            totalCount+=1 \n          } else hashMap.put(values, values)\n      }\n\n     return totalCount\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208530,"user_id":null,"body":"fun duplicates(array: IntArray) = array.toList().groupingBy { it }.eachCount().map { it.value \/ 2 }.sum()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208531,"user_id":null,"body":"fun duplicates(array: IntArray): Int {\n     array.sort()\n     var watching = -1\n     var total = 0\n     for (i in array){\n         if(i == watching){\n             total++\n             watching = -1\n         } else {\n             watching = i\n         }\n     }\n     return total\n }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208532,"user_id":null,"body":"    fun duplicates(array: IntArray): Int {\n        var result = 0\n        val eachCount = array.toList().groupingBy { it }.eachCount()\n        for (item in eachCount) {\n            result += item.value \/ 2 \n        }\n        return result\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5c80b55e95eba7650dc671ea":[{"id":208533,"user_id":193,"body":"fun completeBinaryTree(input: IntArray):IntArray {\n    val output = IntArray(input.size)\n    var k = 0\n    fun h(i: Int): Unit {\n        if (i >= input.size) return\n        h(2 * i + 1)\n        output[i] = input[k++]\n        h(2 * i + 2)\n    }\n    h(0)\n    return output\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208534,"user_id":null,"body":"import kotlin.math.*\n\nfun completeBinaryTree(input: IntArray):IntArray {\n    if (input.size <= 1)\n        return input\n    \n    val depth = ceil(log(input.size.toDouble() + 1, 2.0)).toInt()\n    val min = 2.toDouble().pow(depth - 2).toInt() - 1\n    val max = 2.toDouble().pow(depth - 1).toInt() - 1\n    \n    val left = min(max, input.size - 1 - min)\n    \n    val pivot = input[left]\n    val leftTree = input.sliceArray(0..left-1)\n    val rightTree = input.sliceArray(left+1..input.size-1)\n\n    val result = intArrayOf(pivot) + merge(completeBinaryTree(leftTree), completeBinaryTree(rightTree), 1)\n    return result\n}\n\nprivate fun merge(left: IntArray, right: IntArray, num: Int) : IntArray {\n    return if (left.size <= num && right.size <= num)\n        left + right\n    else if (left.size > num && right.size <= num)\n        left.sliceArray(0..num-1) + right + left.sliceArray(num..left.size-1)\n    else \n        left.sliceArray(0..num-1) + right.sliceArray(0..num-1) + merge(\n            left.sliceArray(num..left.size-1), right.sliceArray(num..right.size-1), num*2)\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208535,"user_id":null,"body":"import java.util.*\n\nfun completeBinaryTree(input: IntArray):IntArray {\n    val data = input.toMutableList()\n    val leavesCount = countLeaves(input.size)\n    val list = mutableListOf<Int>()\n    for (i in (leavesCount-1)*2 downTo 0 step 2){\n        list.add(data[i])\n        data.removeAt(i)\n    }\n    while (data.size > 0){\n        for (i in data.size - 1 downTo 0 step 2){\n            if (i < 0) break\n            list.add(data[i])\n            data.removeAt(i)\n        }\n    }\n    return list.reversed().toIntArray()\n}\n\nfun countLeaves(size: Int): Int {\n    var n = 1\n    var nonLeafNodes = 0\n    while (n+nonLeafNodes < size){\n        nonLeafNodes += n\n        n*=2\n    }\n    return size - nonLeafNodes\n}\n\nfun completeBinaryTreeInv(input : IntArray) : IntArray{\n    return input \/\/ ..!.,\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208536,"user_id":null,"body":"import kotlin.math.pow\n\nfun completeBinaryTree(input: IntArray):IntArray {\n    val treeLevels = calculateTreeLevels(input)\n    val elementsInLastLevel = (input.size - (2.0.pow(treeLevels-1)-1)).toInt()\n\n    \/\/ add level within tree to each input value\n    val data = mutableListOf<Pair<Int, Int>>()\n    input.forEach { data.add(Pair(it, -1)) }\n    addLevelData(data, treeLevels, elementsInLastLevel)\n    for(i in treeLevels-1 downTo 1) {\n        addLevelData(data, i, -1)\n    }\n\n    \/\/ build result\n    val result = mutableListOf<Int>()\n    for (level in 1..treeLevels) {\n        for (dataIndex in data.indices) {\n            if (data[dataIndex].second == level) result.add(data[dataIndex].first)\n        }\n    }\n\n    return result.toIntArray()\n}\n\nfun addLevelData(data: MutableList<Pair<Int, Int>>, level: Int, maxCount: Int) {\n    var skipNext = false\n    var count = 0\n\n    for(i in data.indices) {\n        if( (maxCount != -1) && (count >= maxCount)) break \/\/ max. number of elements marked\n        if(data[i].second != -1) continue \/\/ already has level set\n        if(skipNext) {\n            skipNext = false\n            continue\n        }\n        data[i] = Pair(data[i].first, level)\n        skipNext = true\n        count++\n    }\n\n}\n\nfun calculateTreeLevels(arr: IntArray): Int {\n    var treeLevels = 0\n    while (arr.size > 2.0.pow(treeLevels) - 1) treeLevels++\n    return treeLevels\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208537,"user_id":null,"body":"class Node(p: Int = -1, l: Int = -1, r: Int = -1, v: Int = 0){\n    var parent = p\n    var left = l\n    var right = r\n    var value = v\n}\n\nclass Tree {\n    var nodes = ArrayList<Node>()\n    var arrIdx = 0\n    var lastLevelNodes = 0\n    var numLevels = 0\n\n    fun buildCompleteTree(arr: IntArray) {\n        while(arr.size >= 1 shl(numLevels)) numLevels++\n        lastLevelNodes = arr.size - ((1 shl(numLevels-1)) - 1)\n        nodes.add(Node())\n        buildTree(1, arr)\n    }\n\n    fun buildTree(depth: Int, arr: IntArray) :Int {\n        val nodeIdx = nodes.size - 1\n        if(depth < numLevels - 1 || (depth == numLevels -1 && lastLevelNodes > 0)){\n            if(depth == numLevels -1) lastLevelNodes--\n            nodes.add(Node(nodeIdx))\n            nodes[nodeIdx].left = buildTree(depth + 1, arr)\n        }\n        nodes[nodeIdx].value = arr[arrIdx++]\n        if(depth < numLevels - 1 || (depth == numLevels -1 && lastLevelNodes > 0)){\n            if(depth == numLevels -1) lastLevelNodes--\n            nodes.add(Node(nodeIdx))\n            nodes[nodeIdx].right = buildTree(depth + 1, arr)\n        }\n        return nodeIdx\n    }\n\n    fun bfs(root: Int) :IntArray {\n        var nodeIdx = 0\n        var discoveredNodes = ArrayList<Int>()\n        discoveredNodes.add(root)\n        var resultArray = ArrayList<Int>()\n        while(nodeIdx != discoveredNodes.size){\n            val current = discoveredNodes[nodeIdx]\n            resultArray.add(nodes[current].value)\n            if(nodes[current].left >= 0) discoveredNodes.add(nodes[current].left)\n            if(nodes[current].right >= 0) discoveredNodes.add(nodes[current].right)\n            nodeIdx++\n        }\n        return resultArray.toIntArray()\n    }\n}\n\nfun completeBinaryTree(input: IntArray):IntArray {\n    var tree = Tree()\n    tree.buildCompleteTree(input)\n    return tree.bfs(0)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208538,"user_id":null,"body":"private fun top2Power(n: Int): Int {\n    \/\/ Return: 1 -> 0, 2..3 -> 1, 4..7 -> 2, 8..15 -> 3 ...\n    var mask = n\n    var count = 0\n    while (mask > 1) {\n        mask = mask ushr 1\n        ++count\n    }\n    return count\n}\n\nfun footTreeSize(arrLength: Int): Int {\n    val power = top2Power(arrLength)\n    var mask = 1\n    var count = power\n    while (count-- > 0)\n        mask = mask shl 1\n    return mask\n}\n\nfun fullTreeSize(arrLength: Int): Int {\n    val power = top2Power(arrLength)\n    var mask = 1\n    var count = power\n    while (count-- > 0)\n        mask = mask or (mask shl 1)\n    return mask\n}\n\nfun rootIndex(strokeLen: Int): Int {\n    if (strokeLen == 1)\n        return 0\n    val full = fullTreeSize(strokeLen)\n    val fullHalf = full \/ 2\n    val foot = footTreeSize(strokeLen)\n    val ftHalf = foot \/ 2\n    val delta = full - strokeLen\n    val deltaL = if (delta > ftHalf) delta - ftHalf else 0\n    return fullHalf - deltaL\n}\n\nfun completeBinaryTree(input: IntArray): IntArray {\n    val arrLen = input.size\n    val heap = IntArray(arrLen)\n    fun fromInOrderArray(index: Int, begin: Int, end: Int) {\n        if (begin >= end)\n            return\n        val rootPos = rootIndex(end - begin) + begin\n        val leftChild = 2 * index + 1\n        val rightChild = leftChild + 1\n        heap[index] = input[rootPos]\n        fromInOrderArray(leftChild, begin, rootPos)\n        fromInOrderArray(rightChild, rootPos + 1, end)\n    }\n    fromInOrderArray(0, 0, arrLen)\n    return heap\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208539,"user_id":null,"body":"import kotlin.math.pow\n\nfun completeBinaryTree(input: IntArray): IntArray {\n    return getBinaryTreeValue(1, input).groupBy { it.first }.flatMap { it.value }.map { it.second }.toIntArray()\n}\n\nfun getBinaryTreeValue(currentDepth:Int, input:IntArray) : ArrayList<Pair<Int, Int>> {\n    val arrayList:ArrayList<Pair<Int, Int>> = arrayListOf()\n    var depth = 1\n    while (2.0.pow(depth.toDouble()) < input.size) {\n        depth++\n    }\n    if (2.0.pow(depth.toDouble()).toInt() == input.size) depth++\n    val remainder: Int = (input.size - 2.0.pow(depth.toDouble() - 2) * 2 + 1).toInt()\n    val lastDepthSize = 2.0.pow(depth - 1).toInt()\n    val rightSize: Int =\n        (2.0.pow(depth.toDouble() - 2) - 1 + if (remainder - (lastDepthSize \/ 2) > 0)\n            remainder - (lastDepthSize \/ 2)\n        else\n            0).toInt()\n    val centerIndex = input.size - (rightSize + 1)\n    val left = input.slice(0 until centerIndex).toIntArray()\n    val right = input.slice(centerIndex+1..input.lastIndex).toIntArray()\n\n\n    arrayList.add(currentDepth to input[centerIndex])\n\n    if (left.isNotEmpty()){\n       arrayList += getBinaryTreeValue(currentDepth + 1, left)\n    }\n    if (right.isNotEmpty()){\n        arrayList += getBinaryTreeValue(currentDepth + 1 ,right)\n    }\n    return arrayList\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5ca3ae9bb7de3a0025c5c740":[{"id":208540,"user_id":null,"body":"package solution\n\nobject PointView {\n    data class Point(val x: Int, val y: Int)\n\n    fun point(a: Int, b: Int): () -> Point = fun() = Point(a, b)\n\n    fun fst(pt: () -> Point): Int = pt().x\n\n    fun snd(pt: () -> Point): Int = pt().y\n\n    fun sqrDist(\n        pt1: () -> Point,\n        pt2: () -> Point\n    ): Int {\n        val p1 = pt1()\n        val p2 = pt2()\n        val x = p1.x - p2.x\n        val y = p1.y - p2.y\n        return x * x + y * y\n    }\n\n    fun line(\n        pt1: () -> Point,\n        pt2: () -> Point\n    ): IntArray {\n        val p1 = pt1()\n        val p2 = pt2()\n\n        val a = p1.y - p2.y\n        val b = p2.x - p1.x\n        val l = p1.x * p2.y - p2.x * p1.y\n        return intArrayOf(a, b, l)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208541,"user_id":null,"body":"package solution\n\nobject PointView {\n    \n    data class Point(val x: Int, val y: Int)\n    \n    fun point(a: Int, b: Int): () -> Point = { Point(a, b) }\n    \n    fun fst(pt: () -> Point): Int = pt().x\n    \n    fun snd(pt: () -> Point): Int = pt().y\n    \n    fun sqrDist(pt1: () -> Point, pt2: () -> Point): Int {\n        val dx = pt1().x - pt2().x;\n        val dy = pt1().y - pt2().y;\n        \n        return dx * dx + dy * dy;\n    }\n    \n    fun line(pt1: () -> Point, pt2: () -> Point): IntArray {\n        val a = pt1().y - pt2().y;\n        val b = pt2().x - pt1().x;\n        \n        return intArrayOf(a, b, -(a * pt1().x + b * pt1().y));\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208542,"user_id":null,"body":"package solution\n\nimport kotlin.math.pow\n\n\ndata class Point(val x: Int, val y: Int) {\n    fun sqrDist(that: Point): Int {\n        val dx = (this.x - that.x).toDouble()\n        val dy = (this.y - that.y).toDouble()\n\n        return (dx.pow(2) + dy.pow(2)).toInt()\n    }\n\n    fun line(that: Point): IntArray = intArrayOf(\n        this.y - that.y,\n        that.x - this.x,\n        this.x * that.y - that.x * this.y\n    )\n}\n\ntypealias PointCreator = () -> Point\n\nobject PointView {\n    fun point(a: Int, b: Int): PointCreator = { Point(a, b) }\n    fun fst(pt: PointCreator): Int = pt().x\n    fun snd(pt: PointCreator): Int = pt().y\n    fun sqrDist(pt1: PointCreator, pt2: PointCreator): Int = pt1().sqrDist(pt2())\n    fun line(pt1: PointCreator, pt2: PointCreator): IntArray = pt1().line(pt2())\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208543,"user_id":1381,"body":"package solution\n\nimport kotlin.math.max\nimport kotlin.math.min\n\nobject PointView {\n    fun point(a: Int, b: Int): PtFn {\n        return { a to b }\n    }\n\n    fun fst(pt: PtFn): Int {\n        return pt().first\n    }\n\n    fun snd(pt: PtFn): Int {\n        return pt().second\n    }\n\n    fun sqrDist(pt1: PtFn, pt2: PtFn): Int {\n        val (p1, p2) = pt1() to pt2()\n        return squared(max(p1.first, p2.first) - min(p1.first, p2.first)) + squared(max(p1.second, p2.second) - min(p1.second, p2.second))\n    }\n\n    fun line(pt1: PtFn, pt2: PtFn): IntArray {\n        val (p1, p2) = pt1() to pt2()\n        val l = p2.second - p1.second\n        val m = p1.first - p2.first\n        val n = l * p1.first + m * p1.second\n        val gcd = gcd(listOf(l, m, n))\n        return intArrayOf(l \/ gcd, m \/ gcd, -(n \/ gcd))\n    }\n}\n\nprivate fun squared(n: Int) = n * n\n\nprivate fun gcd(a: Int, b: Int): Int {\n    if (b == 0) return a\n    return gcd(b, a % b)\n}\n\nprivate fun gcd(ns: List<Int>): Int {\n    return ns.fold(ns.first()) { acc, elem -> gcd(acc, elem) }\n}\n    \ntypealias PtFn = () -> Pair<Int, Int>","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208544,"user_id":null,"body":"package solution\n\nobject PointView {\n    fun point(a: Int, b: Int) =  { a to b }\n    fun fst(pt: () -> Pair<Int, Int>) = pt.invoke().first\n    fun snd(pt: () -> Pair<Int, Int>) = pt.invoke().second\n    fun sqrDist(pt1: () -> Pair<Int, Int>, pt2: () -> Pair<Int, Int>): Int {\n        return (pt2.invoke().first - pt1.invoke().first) * (pt2.invoke().first - pt1.invoke().first) + \n              (pt2.invoke().second - pt1.invoke().second) * (pt2.invoke().second - pt1.invoke().second)\n    }\n    fun line(pt1: () -> Pair<Int, Int>, pt2: () -> Pair<Int, Int>): IntArray {\n        return intArrayOf(\n            pt1.invoke().second - pt2.invoke().second,\n            pt2.invoke().first - pt1.invoke().first,\n            pt1.invoke().first * pt2.invoke().second - pt2.invoke().first * pt1.invoke().second\n        )\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208545,"user_id":null,"body":"package solution\n\n\/\/ object PointView {\n\/\/     \/\/ point should return a function\n\/\/     fun point(a: Int, b: Int) = {a to b}\n\/\/     fun fst(pt: ()->Pair<Int,Int>) = pt().first\n\/\/     fun snd(pt: ()->Pair<Int,Int>) = pt().second\n\/\/     fun sqrDist(pt1: ()->Pair<Int,Int>, \n\/\/                 pt2: ()->Pair<Int,Int>) = poin\n\/\/     fun line(pt1: ()->Pair<Int,Int>, \n\/\/             pt2: ()->Pair<Int,Int>): IntArray {\n\/\/         val l = (pt2.second - pt1.second)\n\/\/         val m = -(pt2.first - pt1.first)\n\/\/         val n = -(l*pt1.first + m*pt1.second)\n\/\/         return arrayOf(l,m,n).toIntArray()\n\/\/     }\n\/\/ }\ntypealias Point = ()->Pair<Int,Int>\nobject PointView {\n    \/\/ point should return a function\n    fun point(a: Int, b: Int) = {a to b}\n    fun fst(pt: Point) = pt().first\n    fun snd(pt: Point) = pt().second\n    fun sqrDist(pt1: Point, pt2: Point) = (fst(pt2)-fst(pt1)).let {it*it + (snd(pt2)-snd(pt1)).let{it*it}}\n    fun line(pt1: Point, pt2: Point): IntArray {\n        val l = snd(pt2) - snd(pt1)\n        val m = -(fst(pt2) - fst(pt1))\n        val n = -(l*fst(pt1) + m*snd(pt1))\n        return arrayOf(l,m,n).toIntArray()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208546,"user_id":492,"body":"package solution\n\nobject PointView {\n    fun point(a: Int, b: Int): (Boolean) -> Int {\n        return { x -> if (x) a else b}\n    }\n    fun fst(pt: (Boolean) -> Int): Int {\n        return pt(true)\n    }\n    fun snd(pt: (Boolean) -> Int): Int {\n        return pt(false)\n    }\n    fun sqrDist(pt1: (Boolean) -> Int, pt2: (Boolean) -> Int): Int {\n        val d1 = fst(pt1) - fst(pt2)\n        val d2 = snd(pt1) - snd(pt2)\n        return d1 * d1 + d2 * d2\n    }\n    fun line(pt1: (Boolean) -> Int, pt2: (Boolean) -> Int): IntArray {\n        val x1 = fst(pt1)\n        val y1 = snd(pt1)\n        val x2 = fst(pt2)\n        val y2 = snd(pt2)\n        val dx = x2 - x1\n        val dy = y2 - y1\n        return intArrayOf(-dy, dx, dy * x1 - dx * y1)\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5cd12646cf44af0020c727dd":[{"id":208547,"user_id":null,"body":"package algos\nimport kotlin.math.*\n\nfun squarePi(digits: Int): Int {\n    val PI = \"31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679\"\n    val sum = PI.take(digits).sumByDouble { (it-'0').toDouble().pow(2) }\n    return ceil(sqrt(sum)).toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208548,"user_id":932,"body":"package algos\nfun squarePi(n: Int)=\"31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679\"\n    .take(n).map{\"$it\".toDouble()}.map{it*it}.sum().let{Math.ceil(Math.sqrt(it)).toInt()}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208549,"user_id":null,"body":"package algos\nimport kotlin.math.*\n\nfun squarePi(digits: Int)=\n    with(\"31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679\"){\n        ceil(sqrt(take(digits).map{ \"$it\".toDouble().pow(2.0)}.sum()))\n    }.toInt()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208550,"user_id":null,"body":"package algos\nimport kotlin.math.sqrt\nimport kotlin.math.ceil\n\nval pi = \"31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679\"\n\nfun squarePi(digits: Int): Int {\n  val n = pi.take(digits).map(Character::getNumericValue).map{it*it}.sum().toDouble()\n  return ceil(sqrt(n)).toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208551,"user_id":null,"body":"package algos\nfun squarePi(digits: Int): Int {\n  var pi: String = \"31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679\"\n  var pot: Double = 0.0\n    pi.take(digits).forEach {\n      pot += it.toString().toDouble() * it.toString().toDouble()\n  }  \n  return Math.ceil(Math.sqrt(pot)).toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208552,"user_id":null,"body":"package algos\nfun squarePi(digits: Int): Int {\n    val str = \"31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679\"\n    return  str.substring(0, digits)\n        .toCharArray()\n        .map { it.toString().toInt() }\n        .sumOf { it * it }\n        .let{ Math.ceil(Math.sqrt(it.toDouble())) }\n        .toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208553,"user_id":null,"body":"package algos\n\nimport kotlin.math.ceil\nimport kotlin.math.sqrt\n\nprivate val PI = \"31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679\".toCharArray()\n\nfun squarePi(digits: Int): Int {\n    if (digits == 0) return 0\n    return ceil(sqrt(PI.take(digits).map { (\"$it\".toDouble()).let { n -> n * n } }.reduce { acc, n -> acc + n })).toInt()\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208554,"user_id":null,"body":"package algos\n\nimport kotlin.math.ceil\nimport kotlin.math.pow\nimport kotlin.math.sqrt\n\nfun squarePi(digits: Int): Int {\n    val pi = \"31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679\"\n    return ceil(sqrt(pi.take(digits).sumOf { it.digitToInt().toDouble().pow(2.0) })).toInt()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208555,"user_id":null,"body":"package algos\nfun squarePi(digits: Int): Int \n    = Math.ceil(Math.sqrt(\"31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679\".take(digits)\n    .split(\"\").filter { it.length != 0 }.map { it.toInt()*it.toInt() }.sum().toDouble())).toInt()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208556,"user_id":null,"body":"package algos\n\nimport kotlin.math.*\n\nconst val stringPI = \"31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679\"\n\nfun squarePi(digits: Int): Int = stringPI.take(digits).sumByDouble { Character.getNumericValue(it).toDouble().pow(2) }\n    .let { ceil(sqrt(it)).toInt() }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5ce399e0047a45001c853c2b":[{"id":208557,"user_id":492,"body":"package sumofparts\n\nfun parts_sums(ls: IntArray): IntArray {\n    val result = IntArray(ls.size + 1)\n    for (i in ls.indices.reversed())\n    {\n        result[i] = result[i + 1] + ls[i]\n    }\n    return result\n}","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208558,"user_id":null,"body":"package sumofparts\n\nfun parts_sums(ls: IntArray) = ls.foldRightIndexed(IntArray(ls.size + 1)) { i, n, acc  -> acc[i] = acc[i + 1] + n; acc }\n","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208559,"user_id":null,"body":"package sumofparts\n\nfun parts_sums(ls: IntArray): IntArray {   \n    val res = mutableListOf(ls.sum())\n    ls.forEach {\n        res.add(res.last() - it)\n    }\n    return res.toIntArray()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208560,"user_id":null,"body":"package sumofparts\n\nfun parts_sums(ls: IntArray): IntArray {\n    var hej = mutableListOf<Int>()\n    var net = ls.sum()\n    for (i in 0 until ls.size) {\n      hej.add(net)\n      net -= ls[i]\n    }\n  hej.add(0)\n  return hej.toIntArray()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208561,"user_id":null,"body":"package sumofparts\n\nfun parts_sums(ls: IntArray) = IntArray(ls.size + 1)\n        .apply { ls.foldRightIndexed(0) { idx, item, acc -> (acc + item).also { this[idx] = it } } }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208562,"user_id":null,"body":"package sumofparts\n\nfun parts_sums(ls: IntArray): IntArray {\n    val sum = IntArray(ls.size + 1) \n    sum[0] = ls.sum()\n\n    for (i in ls.indices) {\n        sum[i+1] = (sum[i] - ls[i])\n    }\n\n    return sum\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208563,"user_id":null,"body":"package sumofparts\n\nfun parts_sums(ls: IntArray): IntArray {\n    \/\/ your code\n    val result = IntArray(ls.size + 1) {0}\n    ls.reverse()\n    for (i in 1..ls.size) {\n        result[i] = result[i - 1] + ls[i - 1]\n    }\n    result.reverse()\n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208564,"user_id":null,"body":"package sumofparts\nimport java.util.*\n\nfun parts_sums(ls: IntArray): IntArray {\n    val totalSum = ls.sum()\n    var currentSum = totalSum\n    val link = LinkedList<Int>()\n    ls.forEach {\n        link.add(currentSum)\n        currentSum -= it\n    }\n    link.addLast(0)\n    return link.toIntArray()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208565,"user_id":null,"body":"package sumofparts\n\nfun parts_sums(ls: IntArray) = IntArray(ls.size + 1).run {\n    ls.reversedArray().foldIndexed(0) { i, a, v -> (a + v).also { set(i + 1, it) } }\n    reversedArray()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208566,"user_id":null,"body":"package sumofparts\n\nfun parts_sums(ls: IntArray):  IntArray {\n    val res = ArrayList<Int>()\n    var sum = 0\n    var d = 0\n    for (i in ls.indices) {\n        sum += ls[i]\n    }\n    while (sum > 0) {\n        res.add(sum)\n        sum -= ls[d]\n        d++\n    }\n    res.add(0)\n    return res.toIntArray()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5cfe4465ac68b86026b09c77":[{"id":208567,"user_id":null,"body":"package solution\n\nimport kotlin.math.sqrt\nimport kotlin.math.pow\nimport java.math.BigInteger\n\nfun solve(n: Long): String {\n   getFactors(n - 1).forEach {\n       val mod = powMod(10L, it, n)\n       if (mod == 1L) return \"$it-sum\"\n       if (mod == n - 1) return \"$it-altsum\"\n   }   \n   return \"\"\n}\n\nfun getFactors(n: Long): List<Long> {\n    val factors = mutableSetOf(1L, n)\n    for (i in 2L until sqrt(n.toDouble()).toLong() + 1) {\n        if (n % i == 0L) {\n            factors.add(i)\n            factors.add(n \/ i)\n        }\n    }\n    return factors.sorted()\n}\n\nfun powMod(base: Long, exp: Long, mod: Long): Long {\n    val b = BigInteger(base.toString())\n    val e = BigInteger(exp.toString())\n    val m = BigInteger(mod.toString())\n    val res = b.modPow(e, m)\n    return res.toLong()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208568,"user_id":null,"body":"package solution\n\nimport java.math.BigInteger\nimport kotlin.math.sqrt\n\nfun solve(prime: Long): String {\n    val p = prime - 1\n    var res = 1L to 1L\n    (1..sqrt(prime.toDouble()).toLong())\n        .filter { p % it == 0L }\n        .forEach {\n            var div = it\n            var rem = 10L.modPow(div, prime)\n            if (rem == 1L)\n                return \"$div-sum\"\n            else if (rem == p)\n                return \"$div-altsum\"\n            div = p \/ div\n            rem = 10L.modPow(div, prime)\n            if (rem == 1L)\n                res = div to rem\n            else if (rem == p)\n                res = div to p\n        }\n    return if (res.second == 1L) \"${res.first}-sum\" else \"${res.first}-altsum\"\n}\n\nprivate fun Long.modPow(exp: Long, mod: Long) = this.toBigInteger().modPow(exp.toBigInteger(), mod.toBigInteger()).toLong()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208569,"user_id":193,"body":"package solution\n\nfun solve(p: Long): String {\n    var n = p - 1\n    for (f in factors(p - 1)) {\n        val m = n \/ f\n        if (10L.pow(m, p) == 1L) n = m\n    }\n    return if (n % 2L == 1L) \"$n-sum\" else \"${n \/ 2}-altsum\"\n}\n\nprivate fun factors(n: Long): Sequence<Long> = sequence {\n    var m = n\n    var d = 2L\n    while (d * d <= n) {\n        while (m % d == 0L) {\n            yield(d)\n            m \/= d\n        }\n        d += if (d == 2L) 1L else 2L\n    }\n    if (m > 1) yield(m)\n}\n\nprivate fun Long.pow(exp: Long, mod: Long): Long {\n    var a = exp\n    var b = 1L\n    var res = 1L\n    while (b <= exp) b = b shl 1\n    while (b > 1L) {\n        b = b shr 1\n        res = res * res % mod\n        if (b <= a) {\n            a -= b\n            res = res * this % mod\n        }\n    }\n    return res\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5d2659626c7aec0022cb8006":[{"id":208570,"user_id":null,"body":"fun baumSweet(): Iterator<Int> = iterator {\n    yield(1)\n    yieldAll(generateSequence(1) { it + 1 }.map { it.toString(2).split(\"1\").none { it.length % 2 != 0 }.compareTo(false) })\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208571,"user_id":null,"body":"fun baumSweet(limit: Int = 1000000): Iterator<Int> = iterator {\n  \/\/ Special case for 0 as outlined in the instructions.\n  yield(1)\n\n  var number = 0\n\n  while (++number < limit) {\n    val bits = Integer.toBinaryString(number)\n\n    \/\/ Tracks the number of consecutive 0's.\n    var consecutiveZeros = 0\n\n    \/\/ Loop over the digits to find the first block that\n    \/\/ contains an odd number of consecutive 0's.\n    for (index in bits.indices) {\n      when {\n        \/\/ Increase the number of consecutive 0's found.\n        '0' == bits[index] -> consecutiveZeros++\n\n        \/\/ We found '1' at this position, so we can safely break the loop\n        \/\/ if we've found an odd number of 0's in the previous block.\n        1 == consecutiveZeros % 2 -> break\n\n        \/\/ Take on the next block of consecutive 0's.\n        else -> consecutiveZeros = 0\n      }\n    }\n\n    yield(1 - consecutiveZeros % 2)\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208572,"user_id":null,"body":"fun baumSweet(): Iterator<Int> = iterator {\n    yield(1)\n    var n = 1\n    while (true) {\n        yield(if (n.toString(2).split(\"1\").any { it.length % 2 == 1 }) 0 else 1)\n        n++\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208573,"user_id":null,"body":"fun baumSweet(): Iterator<Int> = iterator {\n    yieldAll(generateSequence(0, Int::inc).map { if (\"10(00)*(1|\\$)\".toRegex().containsMatchIn(it.toString(2))) 0 else 1 })\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208574,"user_id":645,"body":"fun baumSweet(): Iterator<Int> = iterator {\n    yieldAll(listOf(1, 1, 0, 1))\n    val gen = baumSweet()\n    gen.next()\n    gen.next()\n    var a: Int\n    var b: Int\n    while (true) {\n        a = gen.next()\n        b = gen.next()\n        yieldAll(listOf(b, a, 0, b))\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208575,"user_id":null,"body":"fun baumSweet(): Iterator<Int> = iterator {\n        var counter = 0UL\n        while(true) {\n            val bina = counter.toString(2)\n            val zero = if(bina.replace(\"00\",\"X\").indexOf(\"0\")>0 && counter!=0UL) 0 else 1\n            ++counter\n            yield(zero) \n        }\n    }\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208576,"user_id":null,"body":"fun baumSweet() = generateSequence(0, Int::inc).map{ \n    if (Regex(\"10(00)*(1|\\$)\").find(it.toString(2)) == null) 1 else 0\n}.iterator()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208577,"user_id":null,"body":"fun baumSweet(): Iterator<Int> = iterator {\n    var a = 1;\n    yield(1);\n    while(true) {\n        yield(if (a.toString(2).split(\"1\").any { it.length % 2 != 0 }) 0 else 1)\n        a++;\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208578,"user_id":null,"body":"fun baumSweet(): Iterator<Int>{\n    val retList = mutableListOf(1)\n    \n    (1..1000000).forEach { i ->\n        retList.add(if (Integer.toBinaryString(i).split(\"1\").any{ it.length % 2 == 1 }) 0 else 1)\n    }\n    \n    return retList.iterator()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208579,"user_id":null,"body":"fun baumSweet(): Iterator<Int>{\n    val retList = mutableListOf(1)\n    \n    (1..1000000).forEach { i ->\n\/\/         println(Integer.toBinaryString(i))\n\/\/         println(if (Integer.toBinaryString(i).split(\"1\").any{ it.length % 2 == 1 }) 0 else 1)\n        retList.add(if (Integer.toBinaryString(i).split(\"1\").any{ it.length % 2 == 1 }) 0 else 1)\n    }\n    \n\/\/     retList.forEach{i -> print(i)}\n    var numbersIterator = retList.iterator()\n\/\/     while (numbersIterator.hasNext()) {\n\/\/       print(numbersIterator.next())\n\/\/     }\n    return retList.iterator()\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5d26721d48430e0016914faa":[{"id":208580,"user_id":527,"body":"fun paperFold() =\n    generateSequence(1, Int::inc)\n        .map{ i -> if (i and (Integer.lowestOneBit(i) shl 1) == 0) 1 else 0 }\n        .iterator()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208581,"user_id":null,"body":"fun paperFold(): Iterator<Int> {\n    return iterator {\n        yieldAll(listOf(1,1,0,1))\n        val gen = paperFold(); gen.next(); gen.next()\n        while (true) yieldAll(listOf(1, gen.next(), 0, gen.next()))\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208582,"user_id":null,"body":"fun paperFold(): Iterator<Int> {\n    var index = 0\n    val y = (1..(1 shl 20)).map { (it shr Integer.numberOfTrailingZeros(it) + 1).inv() and 1 }\n\n    return iterator {\n        while (index < y.lastIndex) {\n            yield(y[index++])\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208583,"user_id":null,"body":"fun paperFold(): Iterator<Int> = iterator {\n    for (k in 1..1_000_000) {\n        yield(if (k and ((k and -k) shl 1) == 0) 1 else 0)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208584,"user_id":null,"body":"import java.util.*\n\nfun paperFold() = object : Iterator<Int> {\n    val data: LinkedList<Pair<Int, Int>> = LinkedList(listOf(0 to 1))\n    var isFirst = true\n    var count = 0\n\n    override fun hasNext() = true\n\n    override fun next(): Int {\n        if (count < 2) {\n            count++\n            return 1\n        }\n        if (isFirst) {\n            isFirst = false\n            return data[0].first\n        }\n        val pop = data.pop()\n        when (pop) {\n            0 to 0 -> data.let { it.add(1 to 0);it.add(0 to 0) }\n            0 to 1 -> data.let { it.add(1 to 0);it.add(0 to 1) }\n            1 to 0 -> data.let { it.add(1 to 1);it.add(0 to 0) }\n            1 to 1 -> data.let { it.add(1 to 1);it.add(0 to 1) }\n        }\n        isFirst = true\n        return pop.second\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208585,"user_id":null,"body":"fun paperFold(): Iterator<Int> {\n    fun alternatingSequence() = generateSequence(true) { !it }\n\n    val firstElement = sequenceOf(true)\n\n    val nextElements =\n            generateSequence(sequenceOf(true, false)) {\n                it.zip(alternatingSequence()) { a, b -> sequenceOf(a, b) }.flatten()\n            }.flatten()\n    \n    return firstElement\n            .plus(nextElements)\n            .map { if (it) 1 else 0 }\n            .iterator()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208586,"user_id":53,"body":"fun paperFold(): Iterator<Int> {\n    return iterator {\n        var i = 1;\n        while (true) {\n            var n = i;\n            while (n % 2 == 0) n \/= 2;\n            if (n % 4 == 1) yield(1);\n            else if (n % 4 == 3) yield(0);\n            i++;\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208587,"user_id":null,"body":"fun List<Int>.reverseWithInverted(): List<Int> {\n    return this.reversed().map { if (it == 0) 1 else 0 }\n}\n\nfun paperFold(): Iterator<Int> {\n    val list = mutableListOf(1)\n    while (true) {\n        val l = list.reverseWithInverted()\n        list.add(1)\n        list.addAll(l)\n        if (list.size > 1_000_000)\n            break\n    }\n    return list.iterator()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208588,"user_id":2403,"body":"import kotlin.math.log2\nimport kotlin.math.pow\n\nfun paperFold(): Iterator<Int> = iterator {\n  var n = 1\n  val previouslySeen = mutableListOf<Int>()\n  while (true) {\n    val isPow2 = n and n - 1 == 0\n    val nextValue = if (isPow2) 1 else {\n      val k = log2(n.toDouble()).toInt() + 1\n      1 - previouslySeen[2.toDouble().pow(k).toInt() - n - 1]\n    }\n    previouslySeen.add(nextValue)\n    n++\n    yield(nextValue)\n  }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208589,"user_id":null,"body":"fun paperFold(): Iterator<Int> {\n\n    val sequence = mutableListOf<Int>(1)\n\n    return iterator {\n\n        var pointerIterator = 0\n        while(true) {\n            if(pointerIterator >= sequence.size){\n                val reverseSequence = sequence.reversed()\n                    .map { e -> (e + 1)%2 }\n                    .toList()\n                sequence.add(1)\n                sequence.addAll(reverseSequence)\n            }\n            yield(sequence[pointerIterator])\n            pointerIterator++\n        }\n    }\n}\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5d50e3914861a500121e1958":[{"id":208590,"user_id":null,"body":"fun add_letters(arr: List<Char>) = arr.sumBy { it.toInt() - 96 }.plus(25).rem(26).plus(97).toChar()","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208591,"user_id":null,"body":"fun add_letters(arr: List<Char>) = 'z' - arr.sumBy { 'z' - it } % 26","lang_id":29,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208592,"user_id":645,"body":"fun add_letters(arr: List<Char>): Char = \"zabcdefghijklmnopqrstuvwxy\"[arr.fold(0) { acc, x -> acc + x.toInt() - 96 } % 26]","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208593,"user_id":null,"body":"fun add_letters(arr: List<Char>): Char {\n\n        val alphabet = \"zabcdefghijklmnopqrstuvwxy\"\n        var sum = 0\n        for (str in arr) sum += str - 'a' + 1\n        return alphabet[sum % 26]\n        \n   \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208594,"user_id":null,"body":"    fun add_letters(arr: List<Char>): Char {\n        if (arr.isEmpty()) return 'z'\n\n        val map: MutableMap<Char, Int> = HashMap()\n        map['a'] = 1\n        map['b'] = 2\n        map['c'] = 3\n        map['d'] = 4\n        map['e'] = 5\n        map['f'] = 6\n        map['g'] = 7\n        map['h'] = 8\n        map['i'] = 9\n        map['j'] = 10\n        map['k'] = 11\n        map['l'] = 12\n        map['m'] = 13\n        map['n'] = 14\n        map['o'] = 15\n        map['p'] = 16\n        map['q'] = 17\n        map['r'] = 18\n        map['s'] = 19\n        map['t'] = 20\n        map['u'] = 21\n        map['v'] = 22\n        map['w'] = 23\n        map['x'] = 24\n        map['y'] = 25\n        map['z'] = 26\n\n        var result = 0\n        arr.map {\n            print(it)\n            result += map[it] ?: 0\n        }\n\n        while (result > 26){\n            result -= 26\n        }\n\n        val d = map.filterValues { it == result }.keys\n\n        return if (d.isNotEmpty()) d.first() else arr[0]\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208595,"user_id":null,"body":"fun add_letters(arr: List<Char>): Char =\n    arr.fold('z') { acc, c ->\n        val sum = acc + (c - '`')\n\n        if (sum > 'z') 'a' + (sum - '{')\n        else sum\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208596,"user_id":null,"body":"fun add_letters(arr: List<Char>): Char = \nrun {\n        var result = 'z'\n        arr.forEach {\n            result += (it - '`')\n            if (result > 'z') {\n                result = 'a' + (result - '{')\n            }\n        }\n        result\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208597,"user_id":null,"body":"fun add_letters(arr: List<Char>): Char {\nif(arr.size==0)  return 'z';\nvar s=0;\nfor(i in arr)  s+=i-'`';\nif(s%26==0)  return 'z';\nreturn (96+(s%26)).toChar();\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208598,"user_id":null,"body":"fun add_letters(arr: List<Char>): Char {\n    return arr.apply {\n       if (this.size == 0) return 'z'\n    }.map {\n       it.toInt() - 96\n    }.reduce { acc, value ->\n        acc + value\n    }.let {\n        ((it - 1) % 26 + 97).toChar()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208599,"user_id":null,"body":"fun add_letters(arr: List<Char>): Char {\n    \/\/ your code here\n    return (((arr.map {it->it.toInt()-'a'.toInt()+1}.sum()+25)%26)+'a'.toInt()).toChar()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5d617c2fa5e6a2001a369da2":[{"id":208600,"user_id":null,"body":"package kata\n\nimport java.util.*\nimport kotlin.math.ceil\n\nobject PyrrhicVictor {\n    fun queueBattle(dist: Int, vararg armies: IntArray): Pair<Int, IntArray> {\n        val armies = armies.mapIndexed { index, army -> Army(index, army, dist) }.toMutableList()\n\n        var time = 0\n        while (armies.size > 1) {\n            time++\n\n            armies.forEachIndexed { index, army ->\n                val targetArmy = armies[(index + 1) % armies.size]\n                army.turn(targetArmy, time)\n            }\n\n            val oldArmyCount = armies.size\n            armies.removeIf { !it.isAlive }\n            if (armies.size != oldArmyCount) {\n                armies.forEach {\n                    it.removeBullets()\n                }\n            }\n        }\n\n        return if (armies.size == 1) {\n            val army = armies.first()\n            army.num to army.getQueue()\n        } else {\n            -1 to IntArray(0)\n        }\n    }\n\n    class Army(\n        val num: Int,\n        private val soldiers: IntArray,\n        private val dist: Int\n    ) {\n        private val queue = LinkedList(soldiers.indices.toMutableList())\n        private val bullets = PriorityQueue<Int>(compareBy { it }) \/\/flying towards this army\n        val isAlive: Boolean\n            get() = queue.isNotEmpty()\n\n        fun turn(target: Army, time: Int) {\n            var hit = false\n            while (bullets.isNotEmpty() && bullets.peek() <= time) {\n                bullets.poll()\n                hit = true\n            }\n\n            if (!hit) {\n                shoot(target, time)\n            }\n            val head = queue.poll()\n            if (!hit) {\n                queue.offer(head)\n            }\n        }\n\n        fun removeBullets() {\n            bullets.clear()\n        }\n\n        fun getQueue() = queue.toIntArray()\n\n        private fun shoot(target: Army, time: Int) {\n            val bulletSpeed = soldiers[queue.first()]\n            val hitTime = time + ceil(dist \/ bulletSpeed.toDouble()).toInt()\n            target.bullets += hitTime\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208601,"user_id":null,"body":"package kata\n\nobject PyrrhicVictor {\n    \n    private val ALL_DEAD = Pair(-1, IntArray(0))\n    \n    fun queueBattle(dist:Int,vararg armies:IntArray): Pair<Int,IntArray> {\n        return battle(\n            armies.mapIndexed { n, x -> \n                Army(n, x, turnsToImpact(dist)) \n            }\n        )\n    }\n    \n    \n    fun battle(armyList: List<Army>): Pair<Int, IntArray> {\n        var turn = 0\n        val bullets = mutableSetOf<Pair<Int, Int>>()\n        while(armyList.count { x -> x.troops.any() } > 1) {\n            val liveArmies = armyList\n                .filter { x -> x.troops.any() }\n            liveArmies.forEachIndexed { i, x -> \n                    x.takeTurn(turn, liveArmies[(i + 1) % liveArmies.size], bullets)\n                }\n            if (liveArmies.any { x -> !x.troops.any() }) bullets.clear()\n            turn++\n        }\n        return (armyList\n            .firstOrNull { x -> x.troops.any() }?.let { x -> \n                Pair(x.n, x.troops.map { t -> t.first }.toIntArray()) \n            } ?: ALL_DEAD)\n    }\n    \n    data class Army(val n: Int, val t: IntArray, val tti: (Int) -> Int) {\n        val troops = t.mapIndexed { i, x -> Pair(i, x) }.toMutableList()\n        \n        fun takeTurn(turn: Int, target: Army, bullets: MutableSet<Pair<Int, Int>>) {\n            if (Pair(n, turn) !in bullets) {\n                troops += troops[0]\n                bullets.add(Pair(target.n, turn + tti(troops[0].second)))\n            }\n            troops -= troops[0]\n        }\n    }\n    \n    fun turnsToImpact(dist: Int): (Int) -> Int = { speed -> \n        (dist - 1) \/ speed + 1\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208602,"user_id":null,"body":"package kata\n\nimport java.util.*\n\ndata class Bullet(val speed: Int, var distance: Int) {\n    fun hasHit(): Boolean = distance <= 0\n    fun letFly() { distance -= speed }\n    override fun toString(): String {\n        return \"B(%d,%d)\".format(speed, distance)\n    }\n}\ndata class Soldier(val position: Int, val shootingSpeed: Int) {\n    fun fire(distance: Int) = Bullet(shootingSpeed, distance)\n    override fun toString(): String {\n        return \"S(%d,%d)\".format(position, shootingSpeed)\n    }\n}\ndata class Army(val position: Int, val soldiers: MutableList<Soldier>, val incoming: MutableList<Bullet>){\n    constructor(position: Int, speeds: IntArray) :\n            this(position, speeds.mapIndexed(::Soldier).toMutableList(), mutableListOf())\n    fun anyBulletHit() = incoming.any(Bullet::hasHit)\n    fun removeHead() = soldiers.removeAt(0)\n    fun removeBulletsThatHaveHit() = incoming.removeIf(Bullet::hasHit)\n    fun rotate() = Collections.rotate(soldiers, -1)\n    fun isEmpty() = soldiers.isEmpty()\n    fun clearIncoming() = incoming.clear()\n    fun letTimePassAndBulletsFly() = incoming.forEach(Bullet::letFly)\n}\n\nobject PyrrhicVictor {\n    private var distance = -1\n    private var armies = mutableListOf<Army>()\n\n    fun queueBattle(dist: Int, vararg armies: IntArray): Pair<Int, IntArray> {\n        this.armies = armies.mapIndexed(::Army).toMutableList()\n        this.distance = dist\n        val (winner, soldiers) = queueBattle()\n        val winningPositions = soldiers.map(Soldier::position).toIntArray()\n        return winner to winningPositions\n    }\n\n    tailrec fun queueBattle(): Army {\n        if (armies.isEmpty() || (armies.size == 1 && armies[0].isEmpty()))\n            return Army(-1, intArrayOf())\n        if (armies.size == 1)\n            return armies[0]\n\n        letTimePassAndBulletsFly()\n        killHeadsOrLetThemFire()\n        removeEmptyArmiesAndBullets()\n        return queueBattle()\n    }\n\n    fun letTimePassAndBulletsFly() { armies.forEach(Army::letTimePassAndBulletsFly) }\n\n    fun killHeadsOrLetThemFire() {\n        armies.forEachIndexed { index, army ->\n            if (army.anyBulletHit()) {\n                army.removeHead()\n                army.removeBulletsThatHaveHit()\n            }else {\n                fire(army, armies[(index+1)%armies.size])\n                army.rotate()\n            }\n        }\n    }\n\n    private fun fire(shooting: Army, shotAt:Army) {\n        val shootingSoldier = shooting.soldiers.first()\n        val bullet = shootingSoldier.fire(distance)\n        shotAt.incoming.add(bullet)\n    }\n\n    fun removeEmptyArmiesAndBullets() {\n        val hadEmptyArmies = armies.removeIf { it.isEmpty() }\n        if (hadEmptyArmies) {\n            armies.forEach { it.clearIncoming() }\n        }\n    }\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208603,"user_id":null,"body":"package kata\n\nimport java.util.*\n\ndata class Bullet(val speed:Int, var distance:Int)\ndata class Soldier(val position: Int, val shootingSpeed: Int)\n\ndata class Parameters(\n    val armyIdentifiers: MutableList<Int>,\n    val bullets: MutableList<MutableList<Bullet>>, \/\/ speed + distance to target\n    val dist: Int,\n    val soldiers: MutableList<MutableList<Soldier>>\n) {\n    fun letTimePassAndBulletsFly() {\n        bullets.forEach { it.forEach{it.distance-= it.speed} }\n    }\n\n    fun killHeadsOrLetThemFire() {\n        val groupsThatHit = bullets\n            .mapIndexed { index, bulletGroup -> if (bulletGroup.any {hasHitTheEnemy(it)}) index else -1 }\n            .filter { it != -1 }\n        val groupsThatAreHit = groupsThatHit.map { (it + 1) % bullets.size }\n\n        soldiers.mapIndexed { index, weapons ->\n            if (!groupsThatAreHit.contains(index)) {\n                \/\/ fire\n                fire(index)\n                rotate(weapons)\n            }\n        }\n\n        removeHeads(groupsThatAreHit)\n        removeBulletsThatHaveHit()\n    }\n\n    private fun fire(index: Int) {\n        val soldier = soldiers[index][0]\n        bullets[index].add(Bullet(speed=soldier.shootingSpeed, distance=dist))\n    }\n\n    private fun rotate(soldiers: MutableList<Soldier>) {\n        Collections.rotate(soldiers, -1);\n    }\n\n    private fun removeBulletsThatHaveHit() {\n        bullets.forEach { it.removeIf(this::hasHitTheEnemy) }\n    }\n\n    private fun hasHitTheEnemy(bullet:Bullet): Boolean = bullet.distance <= 0\n\n    private fun removeHeads(groupsThatAreHit: List<Int>) {\n        soldiers.forEachIndexed { index, army -> dropHeadIfHit(index, army, groupsThatAreHit) }\n    }\n\n    private fun dropHeadIfHit(index: Int, army: MutableList<Soldier>, groupsThatAreHit: List<Int>) {\n        if (groupsThatAreHit.contains(index)) army.removeAt(0)\n    }\n\n\n    fun removeEmptyArmies() {\n        val emptyArmies = soldiers\n            .mapIndexed { index, soldiers -> if (soldiers.isEmpty()) index else -1 }\n            .filter { it != -1 }\n\n        if (emptyArmies.isNotEmpty()) {\n            removeAll(emptyArmies)\n            bullets.forEach { it.clear() }\n        }\n    }\n\n    private fun removeAll(armyIndices: List<Int>) {\n        armyIndices.sortedDescending().forEach { remove(it) }\n    }\n\n    private fun remove(removedArmy: Int) {\n        armyIdentifiers.removeAt(removedArmy)\n        bullets.removeAt(removedArmy)\n        soldiers.removeAt(removedArmy)\n    }\n}\n\nobject PyrrhicVictor {\n    fun queueBattle(dist: Int, vararg armies: IntArray): Pair<Int, IntArray> {\n        val (winner, winningSoldiers) = indexedQueueBattle(\n            Parameters(\n                MutableList(armies.size) { it },\n                MutableList(armies.size) { MutableList(0) { Bullet(0, 0) } },\n                dist,\n                MutableList(armies.size) { armies[it].mapIndexed{index, speed -> Soldier(index, speed)}.toMutableList() }\n            )\n        )\n        val winningPositions = winningSoldiers.map { it.position }.toIntArray()\n        return winner to winningPositions\n    }\n\n    tailrec fun indexedQueueBattle(p: Parameters): Pair<Int, List<Soldier>> {\n        if (p.soldiers.isEmpty() || (p.soldiers.size == 1 && p.soldiers[0].isEmpty()))\n            return -1 to emptyList()\n        if (p.soldiers.size == 1)\n            return p.armyIdentifiers[0] to p.soldiers[0]\n\n        p.letTimePassAndBulletsFly()\n        p.killHeadsOrLetThemFire()\n        p.removeEmptyArmies()\n        return indexedQueueBattle(p)\n    }\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208604,"user_id":470,"body":"package kata\n\nobject PyrrhicVictor {\n\tfun queueBattle(dst:Int,vararg arms:IntArray): Pair<Int,IntArray> {\n\t\tval tome = arms.map { linkedLoop(it.toTypedArray()) }\n\t\tvar ct = arms.size\n\t\tvar curQ = linkedLoop(tome.toTypedArray())\n\t\tvar slugTrack = linkedLoop(Array<MutableList<Pair<Int,Int>>>(ct){ mutableListOf<Pair<Int,Int>>() })\n\t\t\n\t\twhile (ct > 1){\n\t\t\tvar elimination = false\n\t\t\twhile (!elimination){\n\t\t\t\tvar hitList = mutableListOf<Boolean>()\n\t\t\t\tfor (_i in 1..ct){\n\t\t\t\t\tval slugUpdated = mutableListOf<Pair<Int,Int>>()\n\t\t\t\t\tvar headshot = false\n\t\t\t\t\tfor ((speed,pos) in slugTrack.v){\n\t\t\t\t\t\tPair(speed,speed + pos).let { if(it.second >= dst){ headshot = true } else slugUpdated.add(it) }}\n\t\t\t\t\tslugTrack.v = slugUpdated\n\t\t\t\t\thitList.add(headshot)\n\t\t\t\t\tslugTrack = slugTrack.nxt!!}\n\t\t\t\tfor (slain in hitList){\n\t\t\t\t\tval xc = curQ.v\n\t\t\t\t\tif (slain){\n\t\t\t\t\t\tif (xc === xc.nxt){\n\t\t\t\t\t\t\tcurQ.pre?.nxt = curQ.nxt!!\n\t\t\t\t\t\t\tcurQ.nxt?.pre = curQ.pre!!\n\t\t\t\t\t\t\telimination = true\n\t\t\t\t\t\t\tif (--ct == 0){ return Pair(-1,intArrayOf()) }}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\txc.pre?.nxt = xc.nxt!!\n\t\t\t\t\t\t\txc.nxt?.pre = xc.pre!!}}\n\t\t\t\t\telse { slugTrack.nxt?.v?.add(xc.v to 0) }\n\t\t\t\t\tcurQ.v = xc.nxt!!\n\t\t\t\t\tcurQ = curQ.nxt!!\n\t\t\t\t\tslugTrack = slugTrack.nxt!!}}\n\t\t\tslugClear(slugTrack,ct)}\n\t\treturn Pair(curQ.n,unloop(curQ.v))\n\t}\n\t\n\tprivate fun slugClear(_cv:LL<MutableList<Pair<Int,Int>>>?,ct:Int) {\n\t\tvar cv = _cv\n\t\t(1 until ct).forEach { cv?.v?.clear(); cv = cv?.nxt!! }\n\t\tcv?.v?.clear()\n\t\tcv?.nxt = _cv\n\t\t_cv?.pre = cv\n\t}\n\t\n\tprivate fun unloop(q:LL<Int>): IntArray {\n\t\tval ix = mutableListOf<Int>()\n\t\tvar cq = q\n\t\tdo { ix.add(cq.n); cq = cq.nxt!! } while (cq !== q)\n\t\treturn ix.toIntArray()\n\t}\n\t\n\tprivate fun <T>linkedLoop(r:Array<T>): LL<T> {\n\t\tval fst = LL(r[0],0)\n\t\tvar pre = fst\n\t\tvar cur = fst\n\t\tfor ((i,v) in r.withIndex().drop(1)){\n\t\t\tcur = LL(v,i,pre)\n\t\t\tpre.nxt = cur\n\t\t\tpre = cur}\n\t\tfst.pre = cur\n\t\tcur.nxt = fst\n\t\treturn fst\n\t}\n\t\n\tdata class LL<T>(var v:T,var n:Int,var pre:LL<T>?=null,var nxt:LL<T>?=null)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5d81d8571c6411001a40ba66":[{"id":208605,"user_id":null,"body":"package kata\n\nobject DnB {\n    fun dotsAndBoxes(r:Array<Pair<Int,Int>>): Pair<Int,Int> {\n        \/\/ scan all the values to see if it's between (or equal) perfect square to next\n        \/\/ ex: between 9 and 15 inclusive means n=4; between 16 and 24 inclusive means n=5, etc.\n        var max = 0\n        r.forEach { p -> if (p.first > max) max = p.first; if (p.second > max) max = p.second }\n        var n = 0\n        (3..20).forEach{\n            if (max >= (it-1)*(it-1) && max < it*it) n = it;\n        }\n        val board = mutableListOf<Pair<Int,Int>>()\n        var score = arrayListOf<Int>(0 ,0)\n        var turn = 0\n        r.forEach{ p ->\n            \/\/ first make it well-ordered\n            val newp = Pair(Math.min(p.first, p.second), Math.max(p.first, p.second))\n            \/\/ add p to board - if it made a square, add one to player's score, else alt turn\n            board.add(newp)\n            var tempScore = 0\n            \/\/ if one apart, it's a horiz line, check above and below\n            \/\/ if n apart, it's a vert line, check left and right\n            if (newp.second - newp.first == 1) {\n                \/\/ did you make the top?\n                val topBottom = Pair(newp.first + n, newp.second + n)\n                val topLeft = Pair(newp.first, newp.first + n)\n                val topRight = Pair(newp.second, newp.second + n)\n                if (board.containsAll(listOf(topBottom,topLeft,topRight))) tempScore++\n                \/\/ did you make the bottom?\n                val bottomTop = Pair(newp.first - n, newp.second - n)\n                val bottomLeft = Pair(newp.first - n, newp.first)\n                val bottomRight = Pair(newp.second - n, newp.second)\n                if (board.containsAll(listOf(bottomTop,bottomLeft,bottomRight))) tempScore++\n            } else {\n                \/\/ did you make the left?\n                val leftRight = Pair(newp.first + 1, newp.second + 1)\n                val leftTop = Pair(newp.first, newp.first + 1)\n                val leftBottom = Pair(newp.second, newp.second+1)\n                if (board.containsAll(listOf(leftRight,leftTop,leftBottom))) tempScore++\n                \/\/ did you make the right?\n                val rightLeft = Pair(newp.first - 1, newp.second - 1)\n                val rightTop = Pair(newp.first - 1, newp.first)\n                val rightBottom = Pair(newp.second - 1, newp.second)\n                if (board.containsAll(listOf(rightLeft,rightTop,rightBottom))) tempScore++\n            }\n            if (tempScore > 0) {\n                score[turn] += tempScore\n            } else {\n                turn = (turn + 1) % 2\n            }\n        }\n        return Pair(score[0], score[1])   \n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208606,"user_id":null,"body":"package kata\n\nimport kotlin.math.sqrt\n\n\nobject DnB {\n    fun dotsAndBoxes(lines: Array<Pair<Int, Int>>): Pair<Int, Int> {\n        val r = lines.map { if (it.first > it.second) it.second to it.first else it }\n        val width = sqrt(r.maxOf { maxOf(it.first, it.second) } + 1.0).toInt()\n        var p1 = 0\n        var p2 = 0\n        var p1Turn = true\n        for (i in r.indices) {\n            var completed = 0\n            when (r[i].second - r[i].first) {\n                width -> { \/\/ vertical line\n                    var rightBoxLines = 0\n                    var leftBoxLines = 0\n                    for (j in 0 until i) {\n                        val deltaF = r[j].first - r[i].first\n                        val deltaS = r[j].second - r[i].second\n                        when (deltaF to deltaS) {\n                            1 to 1, 0 to 1 - width, width to 1 -> rightBoxLines++\n                             -1 to -1, width - 1 to 0, -1 to -width -> leftBoxLines++\n                        }\n                    }\n                    completed = rightBoxLines \/ 3 + leftBoxLines \/ 3\n                }\n                1 -> { \/\/ horizontal line\n                    var lowerBoxLines = 0\n                    var upperBoxLines = 0\n                    for (j in 0 until i) {\n                        val deltaF = r[j].first - r[i].first\n                        val deltaS = r[j].second - r[i].second\n                        when (deltaF to deltaS) {\n                            width to width, 1 to width, 0 to width - 1 -> lowerBoxLines++\n                            -width to -width, -width to -1, 1 - width to 0 -> upperBoxLines++\n                        }\n                    }\n                    completed = lowerBoxLines \/ 3 + upperBoxLines \/ 3\n                }\n            }\n            if (completed > 0) {\n                if (p1Turn) p1 += completed\n                else p2 += completed\n            } else p1Turn = !p1Turn\n        }\n        return p1 to p2\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208607,"user_id":null,"body":"package kata\n\nimport kotlin.math.min\nimport kotlin.math.max\nimport kotlin.math.sqrt\n\nobject DnB {\n    class Board(size: Int) {\n        val boxes = (0 until (size * size)).map {\n            val lines = mutableListOf<Pair<Int, Int>>()\n            val n = it + (it \/ size)\n            lines += Pair(n, n + 1)\n            lines += Pair(n, n + size + 1)\n            lines += Pair(n + 1, n + size + 2)\n            lines += Pair(n + size + 1, n + size + 2)\n            Box(it, lines)\n        }\n        var score = Pair(0, 0)\n        var isFirstPlayer = true\n\n        fun addLine(line: Pair<Int, Int>) {\n            var toggle = true\n            boxes.forEach {\n                if (it.lines.isNotEmpty()) {\n                    it.lines -= line\n                    if (it.lines.isEmpty()) {\n                        score = if (isFirstPlayer) Pair(score.first + 1, score.second) else Pair(score.first, score.second + 1)\n                        toggle = false\n                    }\n                }\n            }\n            if (toggle) isFirstPlayer = !isFirstPlayer\n        }\n    }\n    data class Box(val n: Int, val lines: MutableList<Pair<Int, Int>>) {}\n\n    fun dotsAndBoxes(r:Array<Pair<Int,Int>>): Pair<Int,Int> {\n        val sortedLines = r.map { Pair(min(it.first, it.second), max(it.first, it.second)) }\n        val board = Board(sqrt((sortedLines.map { it.second }.max()?.plus(1) ?: 0).toDouble()).toInt() - 1)\n        sortedLines.forEach { board.addLine(it) }\n        return board.score\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208608,"user_id":null,"body":"package kata\n\nobject DnB {\n    fun dotsAndBoxes(r:Array<Pair<Int,Int>>): Pair<Int,Int> {\n        val n = getSize(r.size)\n        val boxes = (n - 1)*(n - 1)\n        var map = (1..boxes).associate { it to 0 }.toMutableMap()\n        \n        var xScore = 0\n        var yScore = 0\n        \n        var xPlays = true\n        \n        for(pair in r) {\n            var pass = true\n            val boxesSelected = getBoxesSelected(n, pair)\n            for(box in boxesSelected) {\n                val selected = map.computeIfPresent(box) { _, v -> v + 1 }\n                if (selected == 4) {\n                    if(xPlays) {\n                        xScore++\n                    } else {\n                        yScore++\n                    }\n                    pass = false\n                }\n            }\n            xPlays = xPlays && !pass || !xPlays && pass\n        }\n        return Pair(xScore, yScore)\n    }\n    \n    fun getSize(lines: Int): Int {\n        var acc = 0\n        for(i in 1..14) {\n            acc += ((i - 1) * 4)\n            if(acc == lines) return i\n        }\n        return 0\n    }\n    \n    fun getBoxesSelected(size: Int, pair: Pair<Int, Int>): IntArray {\n        val a = pair.first.coerceAtMost(pair.second)\n        val b = pair.first.coerceAtLeast(pair.second)\n        val isHorizontal = (b - a == 1)\n        val x = a % size + 1\n        val y = a \/ size + 1\n        if (isHorizontal) {\n            return when (y) {\n                1 -> {\n                    intArrayOf(x)\n                }\n                size -> {\n                    intArrayOf((size - 1) * (y - 2) + x)\n                }\n                else -> {\n                    intArrayOf((size - 1) * (y - 2) + x, (size - 1) * (y - 1) + x)\n                }\n            }\n        } else {\n            return when (x) {\n                1 -> {\n                    intArrayOf((size - 1) * (y - 1) + x)\n                }\n                size -> {\n                    intArrayOf((size - 1) * (y - 1) + x - 1)\n                }\n                else -> {\n                    intArrayOf((size - 1) * (y - 1) + x - 1, (size - 1) * (y - 1) + x)\n                }\n            }\n        }\n    }\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208609,"user_id":null,"body":"package kata\n\nobject DnB {\n    fun dotsAndBoxes(r: Array<Pair<Int, Int>>): Pair<Int, Int> {\n        val c = r.size \/ 2\n        var s = (Math.sqrt(4 * c + 1.0).toInt() - 1) \/ 2\n        val record = Array(s) { Array(s) { 0 } }\n        s++\n        var scoreA = 0\n        var scoreB = 0\n        var isComplete = false\n        var turn = 1\n\n        val scoring = fun(count: Int) {\n            if (count == 4) {\n                isComplete = true\n                if (turn > 0) {\n                    scoreA++\n                } else {\n                    scoreB++\n                }\n            }\n        }\n        r.forEach {\n            isComplete = false\n            if (Math.abs(it.first - it.second) == 1) {\n                val v = Math.min(it.first, it.second)\n                if (v \/ s < s - 1) {\n                    record[v \/ s][v % s]++\n                    scoring(record[v \/ s][v % s])\n                }\n                if (v \/ s >= 1) {\n                    record[v \/ s - 1][v % s]++\n                    scoring(record[v \/ s - 1][v % s])\n                }\n            } else {\n                val v = Math.min(it.first, it.second)\n                if (v % s < s - 1) {\n                    record[v \/ s][v % s]++\n                    scoring(record[v \/ s][v % s])\n                }\n                if (v % s >= 1) {\n                    record[v \/ s][v % s - 1]++\n                    scoring(record[v \/ s][v % s - 1])\n                }\n            }\n            if(!isComplete) turn *= -1\n        }\n\n        return scoreA to scoreB\n    }\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208610,"user_id":null,"body":"package kata\n\nobject DnB {\n    fun dotsAndBoxes(r:Array<Pair<Int,Int>>): Pair<Int,Int> {\n        val nBoard = findBoard(r)\n        if (nBoard < 3) return Pair(0, 0)\n        \n    \tval board = genBoard(nBoard)\n    \tval boxes = genBoxes(nBoard)\n    \tval winnerMap: MutableMap<Int, Int> = mutableMapOf()\n    \n    \tvar index = 0\n    \tr.forEach { p ->\n    \t\tindex += 1\n    \n    \t\t\/\/Check in board then mark true\n    \t\tval line = getMinPair(p)\n    \t\tboard[line] = true\n    \n    \t\t\/\/Find related box\n    \t\tvar boxFlag = false\n    \t\tboxes.forEach { box ->\n    \t\t\tif (box.contains(line)) {\n    \t\t\t\t\/\/Compare list of pair from related box and Board that mark true\n    \t\t\t\tval remBox = box.filter { q ->\n    \t\t\t\t\t(board[q] == false)\n    \t\t\t\t}\n    \n    \t\t\t\tif (remBox.isEmpty()) {\n    \t\t\t\t\tval winTimes = winnerMap[index % 2] ?: 0\n    \t\t\t\t\twinnerMap[index % 2] = winTimes + 1\n    \t\t\t\t\tboxFlag = true\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \n    \t\tif (boxFlag) index -= 1\n    \t}\n        \n    \treturn Pair(winnerMap[1] ?: 0, winnerMap[0] ?: 0)\n    }\n    \n    fun findBoard(r:Array<Pair<Int,Int>>): Int {\n\t    var max = 0\n    \tr.forEach { p ->\n    \t\tif (max < p.first) max = p.first\n    \t}\n    \tvar nBoard = 1\n    \tfor (x in 3..20) {\n    \t\tif (x * x >= max) {\n    \t\t\tnBoard = x\n    \t\t\tbreak\n    \t\t}\n    \t}\n    \n    \treturn nBoard\n    }\n    \n    fun genBoard(nBoard: Int): MutableMap<Pair<Int, Int>, Boolean> {\n    \tvar board: MutableMap<Pair<Int, Int>, Boolean> = mutableMapOf()\n    \tvar xxx: MutableMap<String, Boolean> = mutableMapOf()\n    \t(0 until nBoard).forEach { j ->\n    \t\t(0 until nBoard).forEach { i ->\n    \t\t\tval position = (j * nBoard) + i\n    \t\t\tval rightPosition = position + 1\n    \t\t\tval topPosition = position - nBoard\n    \t\t\tif (j == 0) {\n    \t\t\t\t\/\/Not the rightest\n    \t\t\t\txxx[\"a\"] = false\n    \t\t\t\tif (i != nBoard - 1) {\n    \t\t\t\t\tboard[Pair(position, rightPosition)] = false\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\telse {\n    \t\t\t\t\/\/Rightest\n    \t\t\t\tif (i == nBoard - 1) {\n    \t\t\t\t\tboard[Pair(topPosition, position)] = false\n    \t\t\t\t}\n    \t\t\t\t\/\/Not the rightest\n    \t\t\t\telse {\n    \t\t\t\t\tboard[Pair(position, rightPosition)] = false\n    \t\t\t\t\tboard[Pair(topPosition, position)] = false\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n    \n    \treturn board\n    }\n    \n    fun genBoxes(nBoard: Int): MutableList<MutableList<Pair<Int, Int>>> {\n    \tval boxes: MutableList<MutableList<Pair<Int, Int>>> = mutableListOf()\n    \t(0 until nBoard).forEach { j ->\n    \t\t(0 until nBoard).forEach { i ->\n    \t\t\tval position = (j * nBoard) + i\n    \t\t\tval rightPosition = position + 1\n    \t\t\tval rightBottomPosition = rightPosition + nBoard\n    \t\t\tval bottomPosition = position + nBoard\n    \t\t\tval box: MutableList<Pair<Int, Int>> = mutableListOf()\n    \t\t\tif (j != nBoard - 1 && i != nBoard - 1) {\n    \t\t\t\tbox.add(Pair(position, rightPosition))\n    \t\t\t\tbox.add(Pair(rightPosition, rightBottomPosition))\n    \t\t\t\tbox.add(Pair(position, bottomPosition))\n    \t\t\t\tbox.add(Pair(bottomPosition, rightBottomPosition))\n    \t\t\t\tboxes.add(box)\n    \t\t\t}\n    \t\t}\n    \t}\n    \n    \treturn boxes\n    }\n    \n    fun getMinPair(p: Pair<Int, Int>): Pair<Int, Int> {\n    \treturn if (p.first > p.second) Pair(p.second, p.first) else p\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208611,"user_id":null,"body":"package kata\n\nobject DnB {\n    fun dotsAndBoxes(r:Array<Pair<Int,Int>>): Pair<Int,Int> {\n        var len=calculate_len(r.size);\n        var m = Array( len*2-1,{ i->Array(len*2-1,{j->if(i%2==0&&j%2==0||i%2==1&&j%2==1)9;else 0;}) } );\n        var score=0;\n        var player=true;\n        var score1=0;\n        var score2=0;\n        for((j,k) in r){\n            var row1=j\/len*2;\n            var col1=j%len*2;\n            var row2=k\/len*2;\n            var col2=k%len*2;\n            if(row1==row2)\n                m[row1][(col1+col2)\/2]=1;\n            else if(col1==col2)\n                m[(row1+row2)\/2][col1]=1;\n            var s=score_(m);\n            if(s>score){\n                if(player)\n                    score1+=s-score;\n                else\n                    score2+=s-score;\n                player=!player;\n                score=s;\n            }\n            player=!player;\n        }\n        return Pair(score1,score2);\n    }\n    fun calculate_len(n:Int):Int{\n        var scope=4;\n        var inside=0;\n        var len=0;\n        var res=1;\n        while(len<n){\n            len+=scope;\n            len+=inside;\n            inside+=scope;\n            res++;\n        }\n        return res;\n    }\n    fun score_(m:Array<Array<Int>>):Int{\n        var res:Int=0;\n        var i=0;\n        var r=0;\n        while(i<m.size-2){\n            r=1;\n            while(r<m.size-1){\n                if(m[i][r]==1&&m[i+1][r-1]==1&&m[i+1][r+1]==1&&m[i+2][r]==1)\n                    res++;\n                r+=2;\n            }\n            i+=2;\n        }\n        return res;\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208612,"user_id":null,"body":"import kotlin.math.abs\nimport kotlin.math.max\nimport kotlin.math.sqrt\n\nobject DnB {\n    fun dotsAndBoxes(r: Array<Pair<Int, Int>>): Pair<Int, Int> {\n\n        var firstPlayer = true\n        var result = Pair(0, 0)\n        val boardSize = calculateSizeBoard(r)\n        println(\"BoardSize: $boardSize\")\n\n        r.forEach {\n            val orientation = if (isVertical(it, boardSize)) \"vertical\" else \"horizontal\"\n            \/\/ println(\"Orientation: $it $orientation\")\n        }\n\n        val boxes = generateBox(boardSize).toMutableList().also {\n            \/* it.forEach {\n                 println(\n                     \"Box: $it\"\n                 )\n             }*\/\n        }\n\n\n        r.forEach {\n            var completeBoxByStep = 0\n            val box: Box\n            boxes.forEach { box ->\n                run {\n                    box.isComplete(it, boardSize).let { complete ->\n                        if (complete) {\n                            println(\"Step: $it\")\n                            println(\"Result: $result\")\n                            completeBoxByStep += 1\n                        }\n                    }\n                }\n            }\n            result = result.incremental(firstPlayer, completeBoxByStep)\n            if (completeBoxByStep == 0) {\n                firstPlayer = !firstPlayer\n            } else {\n                println(\"CountCompleteBox: $completeBoxByStep\")\n                println(\"Gain Score: onStep: [$it] firstPlayer: [$firstPlayer] Result: $result\")\n            }\n        }\n        return result\n    }\n\n    fun isVertical(pair: Pair<Int, Int>, sizeBoard: Int): Boolean = abs(pair.first - pair.second) == sizeBoard - 1\n\n    fun calculateSizeBoard(r: Array<Pair<Int, Int>>): Int {\n        val max1 = r.map { it.first }.max()!!\n        val max2 = r.map { it.second }.max()!!\n        max(max1, max2).let {\n            return sqrt((it + 1).toFloat()).toInt() - 1\n        }\n    }\n\n    fun generateBox(sizeBoard: Int): List<Box> {\n        val countBoxes = (sizeBoard + 1) * (sizeBoard + 1)\n\n        val arrayBoxes = arrayListOf<Box>()\n\n        for (point in 0..countBoxes) {\n            run {\n                val verticalStep = sizeBoard + 1\n                if (sizeBoard - point != 0) {\n                    Box(\n                        sideTop = Pair(point, point + 1),\n                        sideBottom = Pair(point + verticalStep, point + verticalStep + 1),\n                        sideLeft = Pair(point, point + verticalStep),\n                        sideRight = Pair(point + 1, point + 1 + verticalStep)\n                    ).also {\n                        arrayBoxes.add(it)\n                    }\n                }\n\n            }\n        }\n        return arrayBoxes\n    }\n\n    data class Box(\n        val sideTop: Pair<Int, Int>,\n        val sideBottom: Pair<Int, Int>,\n        val sideLeft: Pair<Int, Int>,\n        val sideRight: Pair<Int, Int>,\n        private var fillTop: Boolean = false,\n        private var fillLeft: Boolean = false,\n        private var fillBottom: Boolean = false,\n        private var fillRight: Boolean = false,\n        private var reported: Boolean = false\n    ) {\n        fun isComplete(pair: Pair<Int, Int>, boardSize: Int): Boolean {\n            if (reported) {\n                return false\n            }\n            if (sideLeft.isEquals(pair)) {\n                fillLeft = true\n            }\n            if (sideBottom.isEquals(pair)) {\n                fillBottom = true\n            }\n            if (sideRight.isEquals(pair)) {\n                fillRight = true\n            }\n            if (sideTop.isEquals(pair)) {\n                fillTop = true\n            }\n            reported = fillBottom && fillLeft && fillRight && fillTop\n            return reported\n        }\n    }\n\n    fun Pair<Int, Int>.isEquals(pair: Pair<Int, Int>): Boolean {\n        return (first == pair.first && second == pair.second) || second == pair.first && first == pair.second\n    }\n\n    fun Pair<Int, Int>.incremental(first: Boolean, times: Int = 1): Pair<Int, Int> {\n        return if (first) {\n            Pair(this.first + times, this.second)\n        } else {\n            Pair(this.first, this.second + times)\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208613,"user_id":null,"body":"import kotlin.math.max\nimport kotlin.math.sqrt\n\nobject DnB {\n    fun dotsAndBoxes(r:Array<Pair<Int,Int>>): Pair<Int,Int> {\n        val size = sqrt(r.maxBy { it.max }!!.max + 1f).toInt()\n        var player = 0\n        val board = Board(size)\n        val scores = Array(2){0}\n\n        r.forEach {\n            val squares = board.draw(it.sorted)\n            if (squares == 0) {\n                player = 1 - player\n            }\n            else {\n                scores[player] += squares\n            }\n        }\n\n        return Pair(scores[0], scores[1])\n    }\n\n    class Board(size: Int) {\n        class Square(sides: Array<Pair<Int, Int>>) {\n            val sides = HashMap<Pair<Int, Int>, Boolean>().apply {\n                sides.forEach {\n                    put(it, false)\n                }\n            }\n\n            fun draw(pair: Pair<Int, Int>): Boolean {\n                sides[pair] ?: return false\n                sides[pair] = true\n                for (value in sides.values) {\n                    if (!value) return false\n                }\n                return true\n            }\n        }\n\n        val squares: Array<Square>\n\n        init {\n            val squares = ArrayList<Square>()\n            (0 until size - 1).forEach { x ->\n                (0 until size - 1).forEach { y ->\n                    squares.add(\n                        Square(\n                            arrayOf(\n                                Pair(y*size + x, y*size + x + 1),\n                                Pair(y*size + x + 1, (y+1)*size + x + 1),\n                                Pair((y+1)*size + x, (y+1)*size + x + 1),\n                                Pair(y*size + x, (y+1)*size + x)\n                            )\n                        )\n                    )\n                }\n            }\n\n            this.squares = squares.toTypedArray()\n        }\n\n        fun draw(pair: Pair<Int, Int>) = squares.count { it.draw(pair) }\n    }\n}\n\nval Pair<Int, Int>.max get() = max(first, second)\nval Pair<Int, Int>.sorted get() = if (first > second) Pair(second, first) else Pair(first, second)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208614,"user_id":null,"body":"package kata\nimport kotlin.math.sqrt\n\nobject DnB {\n    fun dotsAndBoxes(r: Array<Pair<Int, Int>>): Pair<Int, Int> {\n        var firstPlayerMove = true\n        var firstPlayerResult = 0\n        var secondPlayerResult = 0\n        val squares = r.asSequence()\n            .flatMap { sequenceOf(it.first, it.second) }.max()!!\n            .let { maxCoordinate ->\n                createSquares(sqrt((maxCoordinate + 1).toDouble()).toInt())\n            }\n        r.forEach { coordinates ->\n            var movePoints = 0\n            squares.forEach {square ->\n                if (square.fill(coordinates))\n                    movePoints++\n            }\n            if(movePoints == 0 ){\n                firstPlayerMove = !firstPlayerMove\n            } else {\n                if(firstPlayerMove) {\n                    firstPlayerResult += movePoints\n                } else {\n                    secondPlayerResult += movePoints\n                }\n            }\n        }\n        return Pair(firstPlayerResult, secondPlayerResult)\n    }\n\n    private fun createSquares(dimension: Int): List<Square> {\n        val squares = mutableListOf<Square>()\n        for (x in 0 until dimension){\n            for (y in 0 until dimension) {\n                val a = x * dimension + y\n                val b = a + 1\n                val d = (x + 1) * dimension + y\n                val c = d + 1\n                squares.add(Square(a, b, c, d))\n            }\n        }\n        return squares\n    }\n\n    private class Square(private val a: Int, private val b: Int, private val c: Int, private val d: Int) {\n        private var abEdgeFilled = false\n        private var bcEdgeFilled = false\n        private var cdEdgeFilled = false\n        private var daEdgeFilled = false\n        fun fill(coordinates: Pair<Int, Int>): Boolean {\n            if(isFilled()) {\n                return false\n            }\n            when {\n                isEdgeCoordinates(coordinates, a, b) -> {\n                    abEdgeFilled = true\n                }\n                isEdgeCoordinates(coordinates, b, c) -> {\n                    bcEdgeFilled = true\n                }\n                isEdgeCoordinates(coordinates, c, d) -> {\n                    cdEdgeFilled = true\n                }\n                isEdgeCoordinates(coordinates, d, a) -> {\n                    daEdgeFilled = true\n                }\n            }\n            return isFilled()\n        }\n        private fun isFilled() = abEdgeFilled && bcEdgeFilled && cdEdgeFilled && daEdgeFilled\n        private fun isEdgeCoordinates(coordinates: Pair<Int, Int>, x: Int, y: Int) =\n            (coordinates.first == x && coordinates.second == y) || (coordinates.first == y && coordinates.second == x)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5d98b6b38b0f6c001a461198":[{"id":208615,"user_id":932,"body":"package binary\nprivate val code = arrayOf(\"10\", \"11\", \"0110\", \"0111\", \"001100\", \"001101\", \"001110\", \"001111\", \"00011000\", \"00011001\")\n\nfun code(s: String)=s.map{code[it-'0']}.joinToString(\"\")\nfun decode(s: String): String{\n    var src = s\n    var r = \"\"\n    while (src.length>0)\n        code.forEachIndexed { i, it ->\n            if (src.take(it.length)==it){\n                r += \"$i\"\n                src = src.drop(it.length)\n            }\n        }\n    return r\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208616,"user_id":null,"body":"package binary\n\nfun code(str: String) = str.map {\n    \"$it\".toInt().toString(2).run {\n        \"0\".repeat(length - 1) + \"1\" + this\n    }\n}.joinToString(\"\")\n\n\nfun decode(str: String): String {\n    var bits = 0\n    var tempStr = \"\"\n    var counter = -1\n    while( ++counter < str.length){\n        if(str[counter] == '1'){\n            tempStr += \"${str.substring(counter + 1, counter + ++bits + 1).toInt(2)}\"\n            counter += bits\n            bits = 0\n        }else bits++\n    }\n    return tempStr\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208617,"user_id":492,"body":"package binary\n\nfun code(str: String): String {\n    val res = StringBuilder()\n    for (c in str.toCharArray()) {\n        val b = Integer.toBinaryString(Character.getNumericValue(c))\n        res.append(\"0\".repeat(b.length - 1) + \"1\" + b)\n    }\n    return res.toString()\n}\nfun decode(str: String): String {\n    val res = StringBuilder()\n    var i = 0; var k = 1\n    while (i < str.length) {\n        if (str[i] == '1') {\n            res.append(str.substring(i + 1, i + 1 + k).toInt(2))\n            i += k; k = 0\n        }\n        i++; k++\n    }\n    return res.toString()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208618,"user_id":null,"body":"package binary\n\nfun code(str: String): String {\n    var result: String = \"\"\n    str.forEach {\n        if (it.toString().toInt().toString(2).length == 1) {\n            result += \"1\" + it.toString().toInt().toString(2)\n        } else if (it.toString().toInt().toString(2).length == 2) {\n            result += \"01\" + it.toString().toInt().toString(2)\n        } else if (it.toString().toInt().toString(2).length == 3) {\n            result += \"001\" + it.toString().toInt().toString(2)\n        } else if (it.toString().toInt().toString(2).length == 4) {\n            result += \"0001\" + it.toString().toInt().toString(2)\n        }\n    }\n    return result\n}\nfun decode(str: String): String {\n    var decompStr = str\n    var result: String = \"\"\n    while (decompStr.length > 0) {\n        if (decompStr.take(1) == \"1\") {\n            decompStr = decompStr.drop(1)\n            result += decompStr.take(1).toInt(2).toString()\n            decompStr = decompStr.drop(1)\n        } else if (decompStr.take(2) == \"01\") {\n            decompStr = decompStr.drop(2)\n            result += decompStr.take(2).toInt(2).toString()\n            decompStr = decompStr.drop(2)  \n        } else if (decompStr.take(3) == \"001\") {\n            decompStr = decompStr.drop(3)\n            result += decompStr.take(3).toInt(2).toString()\n            decompStr = decompStr.drop(3)  \n        } else if (decompStr.take(4) == \"0001\") {\n            decompStr = decompStr.drop(4)\n            result += decompStr.take(4).toInt(2).toString()\n            decompStr = decompStr.drop(4)  \n        } else {\n            return \"error\"\n        }\n    }\n   return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208619,"user_id":null,"body":"package binary\n\nfun bitsMinusOne(d: Int) = when {\n    d < 2 -> 0\n    d < 4 -> 1\n    d < 8 -> 2\n    else -> 3   \n}\n\nfun code(str: String): String {\n    return str.map{\"0\".repeat(bitsMinusOne(it.digitToInt()))+\"1\"+it.digitToInt().toString(2)}.joinToString(\"\")        \n}\n\nfun decode(str: String): String {\n    if (str.isEmpty()) return \"\"\n    val currentSize = str.takeWhile{it == '0'}.length+1\n    val currentNumber = str.drop(currentSize).take(currentSize).toInt(2).toString()\n    return currentNumber + decode(str.drop(currentSize*2))\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208620,"user_id":null,"body":"package binary\n\nfun code(str: String): String {\n    val binaryStrMap = mapOf(\n        '0' to \"0\",\n        '1' to \"1\",\n        '2' to \"10\",\n        '3' to \"11\",\n        '4' to \"100\",\n        '5' to \"101\",\n        '6' to \"110\",\n        '7' to \"111\",\n        '8' to \"1000\",\n        '9' to \"1001\",\n    )\n    \n    return str.mapNotNull {\n        binaryStrMap[it]\n    }.map {\n        \"0\".repeat(it.length - 1) + \"1\" + it\n    }.joinToString(separator = \"\")\n}\n\nfun decode(str: String): String {\n    var prefixLength = 0\n    var result = \"\"\n    \n    var index = 0\n    while (index < str.length) {\n        prefixLength++\n        \n        if (str[index] == '1') {\n            val start = index + 1\n            val end = start + prefixLength\n            result += str.substring(start, end).toInt(2).toString()\n            \n            index += prefixLength\n            prefixLength = 0\n        }\n        index++\n    }\n    \n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208621,"user_id":null,"body":"package binary\n\nfun code(str: String): String {\n    val nums = hashMapOf<Int, String>(\n        Pair(1, \"1\"),\n        Pair(2, \"01\"),\n        Pair(3, \"001\"),\n        Pair(4, \"0001\")\n    )\n    var resultString = \"\"\n    var tmpString = \"\"\n    str.forEach {\n        tmpString = it.digitToInt().toString(2)\n        resultString = resultString + nums[tmpString.length] + tmpString\n        tmpString = \"\"\n    }\n    return resultString\n}\n\nfun decode(str: String): String {\n    var stringgg = str\n    var bits = 0\n    var result = \"\"\n\n    while (stringgg.isNotEmpty()) {\n        if(stringgg[0] == '0'){\n            bits++\n            stringgg = stringgg.takeLast(stringgg.length - 1)\n        } else {\n            bits++\n            stringgg = stringgg.takeLast(stringgg.length - 1)\n            result += stringgg.take(bits).toInt(2).toString(10)\n            stringgg = stringgg.takeLast(stringgg.length - bits)\n            bits = 0\n        }\n    }\n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208622,"user_id":null,"body":"package binary\n\nfun code(str: String): String {\n    var output = \"\"\n    for(char in str){\n        val num = char.code- '0'.code\n        val binary = num.toString(2)\n        val zeroPadding = \"0\".repeat(binary.length-1) \n        output += \"${zeroPadding}1$binary\"\n    }\n    return output\n}\nfun decode(str: String): String {\n    var start = true\n    var nZeroes = 0\n    var output = \"\"\n    var convert = \"\"\n    for(char in str){\n        when(start){\n            true -> when(char){\n                '0' -> nZeroes++\n                '1' -> {\n                    nZeroes++\n                    start = false\n                }\n            }\n            false ->{\n                convert += char\n                nZeroes--\n                if(nZeroes == 0){\n                    output += convert.toInt(2)\n                    start = true\n                    convert = \"\"\n                }\n            }\n        }        \n    }\n    return output\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208623,"user_id":null,"body":"package binary\n\nfun code(str: String): String =\n    str.map { it.digitToInt().toString(2) }\n        .joinToString(\"\") {\n            \"1\".padStart(it.length, '0') + it\n        }\n\nfun decode(str: String): String =\n    (str.indexOf('1') + 1)\n        .let { i ->\n            if (i == 0) \"\"\n            else str.substring(i, i + i).toInt(2).toString() + decode(str.substring(i + i))\n        }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208624,"user_id":null,"body":"package binary\n\nprivate val binCodes = arrayOf(\"10\", \"11\", \"0110\", \"0111\", \"001100\", \"001101\", \"001110\", \"001111\", \"00011000\", \"00011001\")\n\nfun code(str: String): String = str.map { binCodes[it.digitToInt()] }.joinToString(\"\")\n\nfun decode(str: String): String {\n    var i = 0\n    val bldr = StringBuilder()\n\n    while (i < str.length) {\n        var x = 0\n\n        while (str[i + x] == '0') x++\n\n        val sub = str.substring(i, i + 2 * (x + 1))\n        bldr.append(binCodes.indexOf(sub))\n        i += 2 * (x + 1)\n    }\n    return bldr.toString()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5da1df6d8b0f6c0026e6d58d":[{"id":208625,"user_id":492,"body":"package section\n\nprivate fun divNb(n:Long):Int {\n    var nn = n\n    var i = 2\n    var p = 1\n    while (nn > 1)\n    {\n        var kt = 0\n        while (nn % i == 0L)\n        {\n            nn = nn \/ i\n            kt += 1\n        }\n        if (kt != 0)\n            p *= (kt + 1)\n        i += 1\n    }\n    return p\n}\nfun c(k:Long):Int {\n    val r = (Math.sqrt(k.toDouble())).toLong()\n    if (r * r == k)\n        return divNb(k * r)\n    return 0\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208626,"user_id":null,"body":"package section\n\nfun c(k: Long):Int {\n   val xy = Math.sqrt(k.toDouble())\n   return if (xy % 1 != 0.0) 0 else countPrimeFactors(xy.toLong() * k)   \n}\n\nfun countPrimeFactors(num: Long): Int {\n    var i: Long = 2\n    var count = 1\n    var n = num\n    \n    while (n > 1) {\n        var exp = 1\n        while (n % i == 0L) {\n            n \/= i\n            exp += 1\n        }\n        count *= exp\n        i += 1\n    }\n    return count\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208627,"user_id":null,"body":"package section\n\nimport kotlin.math.*\n\nfun Long.sqrt(): Long? {\n    val root = sqrt(toDouble()).toLong()\n    return if (root * root == this) root else null\n}\n\nfun primeFactors(n: Long): Map<Long, Int> {\n    val res = mutableMapOf<Long, Int>()\n    fun exec(n: Long, s: Long) {\n        val d = (s..n).firstOrNull { n % it == 0L }\n        if (d != null) {\n            res[d] = res.getOrDefault(d, 0) + 1\n            exec(n \/ d, d)\n        }\n    }\n    exec(n, 2)\n    return res\n}\n\nfun c(k: Long): Int {\n    val root = k.sqrt() ?: return 0\n    return primeFactors(root).values\n        .fold(1) { acc, it -> acc * (it * 3 + 1) }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208628,"user_id":null,"body":"package section\n\nfun c(k:Long):Int {\n    if(k.toBigInteger().pow(3).sqrtAndRemainder()[1]!=0.toBigInteger()) return 0\n    val seq = generateSequence(3L) {\n        var next = it+2L\n        while((2L..Math.sqrt(next.toDouble()).toLong()).any{next%it==0L}) next++\n        next}.iterator()\n    var z = k.toBigInteger().pow(3).sqrt().toLong()\n    val primeCount = mutableListOf<Int>(0)\n    while(z%2L==0L){\n        z\/=2L\n        primeCount[0]++\n    }\n    for(el in seq){\n        if(el*el>z) break\n        primeCount.add(0)\n        while(z%el==0L){\n            z\/=el\n            primeCount[primeCount.lastIndex]++\n        }\n    }\n    return primeCount.fold(1){prod,it->prod*(it+1)}\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208629,"user_id":null,"body":"package section\nimport kotlin.math.ceil\nimport kotlin.math.pow\nimport kotlin.math.floor\nimport kotlin.math.sqrt\n\n\/*\n*\n*  z^3     = x^2 * y^2\n*\n*  (r^2)^3 = x^2 * y^2   \/\/ z = r^2\n*  r^6     = x^2 * y^2\n*  r^6     = (x*y)^2     \/\/sqrt\n*  r^3     = x*y\n*\/\nfun c(`r^2`: Long): Int {\n    if (isSquareRoot(`r^2`).not()) return 0\n\n    val `r^3` = promoteToCubicRoot(`r^2`)\n    val xy = `r^3`\n    return countPrimeFactors(xy).toInt()\n}\n\nfun countPrimeFactors(value: Long): Long {\n    var primeFactors = 1L\n    var number = value\n    (2L..value).forEach { divider ->\n        val (divisions, rest) = integerDivisionCount(number, divider)\n        number = rest\n        primeFactors *= (divisions + 1)\n        if (number == 1L) return primeFactors\n    }\n\n    return primeFactors\n}\n\nfun promoteToCubicRoot(value: Long): Long {\n    val valueSquare = value.toDouble().run(::sqrt).toInt()\n    return valueSquare * value\n}\n\nfun isSquareRoot(value: Long): Boolean {\n    val valueSquare = value.toDouble().run(::sqrt)\n    return valueSquare.run(::isInteger)\n}\n\nfun isInteger(value: Double): Boolean = floor(value) == value\n\ninfix fun Long.divisible(other: Long): Boolean = this % other == 0L\n\ndata class IntegerDivisionResult(\n    val divisions: Long,\n    val rest: Long\n)\n\nfun integerDivisionCount(startingBase: Long, value: Long): IntegerDivisionResult {\n    var divisions = 0L\n    var base = startingBase\n    while (base divisible value) {\n        base \/= value\n        divisions++\n    }\n    return IntegerDivisionResult(divisions, base)\n}\n\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208630,"user_id":null,"body":"package section\nimport kotlin.math.ceil\nimport kotlin.math.pow\nimport kotlin.math.floor\n\nfun c(k: Long): Int {\n    var result = 1\n    val kSqrt = k.toDouble().pow(0.5)\n    if (isInteger(kSqrt).not()) return 0\n    var kPart = kSqrt.toInt()\n    (2..kPart).forEach {\n        if (kPart % it == 0) {\n            var count = 0\n            while (kPart % it == 0) {\n                kPart \/= it\n                count++\n            }\n            result = result * (((count - 1) * 3) + 4)\n        }\n    }\n\n    return result\n}\n\nfun isInteger(value: Double): Boolean = floor(value) == value","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208631,"user_id":null,"body":"package section\n\nimport kotlin.math.sqrt\n\nfun c(k:Long):Int {\n    \n    if (sqrt(k.toDouble()).toLong() * sqrt(k.toDouble()).toLong() != k) return 0\n    if (k == 1L) return 1\n    return (k * sqrt(k.toDouble()).toLong()).factorsCount()\n}\n\nfun Long.factorsCount(): Int {\n    var r = 1\n    if (this <= 3L) return 2\n    var f = 2L\n    var t = this    \n    while (t > 1L) {\n        var i = 0\n        while (t % f == 0L) {\n            i++\n            t = t \/ f\n        }\n        r = r * (i+1)\n        f++\n    }\n    return r\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208632,"user_id":168,"body":"package section\n\nfun c(k: Long) : Int {\n    var n = Math.sqrt(k.toDouble()).toLong()\n    if (n * n != k) return 0\n    var d = 2L\n    var r = 1\n    while (d * d <= n) {\n        var e = 0\n        while (n % d == 0L) {\n            n \/= d\n            e++\n        }\n        r *= 3 * e + 1\n        d++\n    }\n    return if (n > 1) r * 4 else r\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208633,"user_id":53,"body":"package section\nimport kotlin.math.sqrt\nimport kotlin.math.floor\n\nfun c(k:Long):Int {\n    var sq = floor(sqrt(k.toDouble())).toLong()\n    if (sq * sq != k) return 0\n    var i = 2\n    var num = k * sq\n    var ans = 1\n    while (num > 1) {\n        var cnt = 0\n        while (num % i == 0.toLong()) {\n            num \/= i\n            cnt++\n        }\n        ans *= (cnt + 1)\n        i++\n    }\n    return ans\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208634,"user_id":null,"body":"package section\n\nimport kotlin.math.sqrt\n\nfun factorize(k: Long): List<Long> {\n    val fac = mutableListOf<Long>()\n    var n = k\n    while (n % 2 == 0L) { fac += 2; n \/= 2 }\n    for (i in 3..sqrt(n.toDouble()).toLong() step 2) {\n        while (n % i == 0L) { fac += i; n \/= i }\n    }\n    if (n > 1) fac += n\n    return fac\n}\n\nfun c(k: Long): Int = when (k) {\n    1L -> 1\n    else -> with(factorize(k).groupingBy { it }.eachCount()) {\n        if (any { it.value % 2 == 1 }) 0\n        else values.map { it * 3 \/ 2 + 1 }.reduce(Int::times)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5dad6e5264e25a001918a1fc":[{"id":208635,"user_id":null,"body":"package decod\n\nfun decode(r: String): String {\n    val x = r.filter { it.isDigit() }.toInt() % 26\n    if (x % 2 == 0 || x == 13) return \"Impossible to decode\"\n    val dict = ('a'..'z').associateBy { ((it - 'a') * x % 26 + 97).toChar() }\n    return r.filter { it.isLowerCase() }.map { dict.getValue(it) }.joinToString(\"\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208636,"user_id":null,"body":"package decod\n\nfun decode(r: String)= r.takeWhile { it.isDigit() }.toInt().run {\n    r.substring(\"$this\".length, r.length).map { c ->\n        (0..25).filter { n ->\n            (n * this  % 26) == (c.toInt() - 97)\n        }\n    }.run {\n        if (any{ it.size > 1 || it.isEmpty() }) \"Impossible to decode\"\n        else map{ (it[0] + 97).toChar() }.joinToString(\"\")\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208637,"user_id":492,"body":"package decod\n\nimport java.util.regex.Pattern\n\nfun decode(r: String): String {\n    val dict = mapOf(3 to 9, 9 to 3, 21 to 5, 5 to 21, 7 to 15, 15 to 7, 11 to 19, 19 to 11, 17 to 23, 23 to 17, 25 to 25, 1 to 1)\n    val p = Pattern.compile(\"([0-9]+)([a-z]+)\")\n    var num = 0\n    var s = \"\"\n    val m = p.matcher(r)\n    if (m.find())\n    {\n        num = Integer.parseInt(m.group(1)) % 26\n        s = m.group(2)\n    }\n    val n = dict[num]\n    if (n == null)\n        return \"Impossible to decode\"\n    val alpha = \"abcdefghijklmnopqrstuvwxyz\"\n    var res = \"\"\n    for (i in 0 until s.length)\n    {\n        val j = (alpha.indexOf(s[i]) * n) % 26\n        res += alpha.get(j)\n    }\n    return res\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208638,"user_id":null,"body":"package decod\n\nfun decode(r: String): String {\n\n    val idx = r.indexOfFirst { !it.isDigit() }\n    val num = r.substring(0, idx).toInt()\n    val s = r.substring(idx)\n\n    val map = createReverseLookupMap(num)\n    if (map.size != 26) return \"Impossible to decode\"\n\n    val result = StringBuilder()\n    for (ch in s.chars()) {\n        val chr = map[ch - 97] ?: return \"Impossible to decode\"\n        result.append(chr);\n    }\n\n    return result.toString()\n}\n\nprivate fun createReverseLookupMap(num: Int): Map<Int, Char> {\n    val map = mutableMapOf<Int, Char>()\n    for (ch in 'a'..'z') {\n        map[(ch.code - 97) * num % 26] = ch\n    }\n    return map\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208639,"user_id":null,"body":"package decod\n\nfun decode(r: String): String {\n    var pattern = \"[^\\\\d+]\".toRegex()\n    var key = pattern.replace(r,\"\").toString().toInt()\n    var code = r.replace(key.toString(),\"\")\n    var result: String = \"\"\n\n    code.forEach {\n        var decodePos: Int = 0    \n        for (i in 0..25) {\n            if (i * key % 26 == (it - 'a').toInt()) {\n                result += (i+97).toChar()\n                decodePos += 1\n            } \n        }\n        if (decodePos != 1) return \"Impossible to decode\"\n    }\n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208640,"user_id":null,"body":"package decod\n\nfun decode(r: String): String {\n    val (digits, encoded) = r.partition { it.isDigit() }\n    val num = digits.toInt() % 26\n\n    for (i in 1..25)\n        if (i * num % 26 == 1)\n            return encoded.map { 'a' + i * (it - 'a') % 26 }.joinToString(\"\")\n\n    return \"Impossible to decode\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208641,"user_id":null,"body":"package decod\n\nfun decode(r: String): String = r.partition { it.isDigit() }\n    .let { parts ->\n        parts.second\n            .map { c ->\n                (0..25).first { i -> c - 'a' == i }\n            }.flatMap { y ->\n                (0..25).filter { x -> x * parts.first.toInt() % 26 == y }\n            }.map { i -> 'a' + i }\n            .joinToString(\"\")\n            .let { plainText ->\n                if (plainText.length == parts.second.length) plainText\n                else \"Impossible to decode\"\n            }\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208642,"user_id":null,"body":"package decod\n\nfun decode(r: String): String {\n    val alphabet = \"abcdefghijklmnopqrstuvwxyz\".toList()\n\n    val encodingNumber = r.filter { it.isDigit() }.toInt()\n    val encodedString = r.filter { !it.isDigit() }\n\n    val hasRepeatedNumbers =\n        alphabet.map { alphabet.indexOf(it) * encodingNumber % 26 }.distinct().size != alphabet.size\n\n    if (hasRepeatedNumbers) {\n        return \"Impossible to decode\"\n    }\n\n    \n    fun makeEncodedAlphabet(): List<Char> {\n        return alphabet.toMutableList().map { letter ->\n            alphabet[alphabet.indexOf(letter) * encodingNumber % 26]\n        }\n    }\n\n    val encodedAlphabet = makeEncodedAlphabet()\n\n    val decodedString = encodedString.map {\n        alphabet[encodedAlphabet.indexOf(it)]\n    }.joinToString(\"\")\n\n    return decodedString\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208643,"user_id":null,"body":"package decod\n\nval ALPHABET = 'a'..'z'\n\nfun decode(r: String): String {\n    val (numStr, str) = r.split(\"\"\"(?!\\d)\"\"\".toRegex(), 2)\n    val num = numStr.toInt()\n    val newAlphabet = ALPHABET.associateBy { ALPHABET.indexOf(it) * num % 26 }\n\n    if (newAlphabet.size != 26) {\n        return \"Impossible to decode\"\n    }\n\n    return str\n        .map { newAlphabet[ALPHABET.indexOf(it)]!! }\n        .joinToString(\"\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208644,"user_id":168,"body":"package decod\n\nfun decode(r: String): String {\n    val (k, s) = Regex(\"(\\\\d+)(.*)\").matchEntire(r)!!.destructured\n    val n = k.toInt() % 26\n    for (i in 1..25) {\n        if (i * n % 26 == 1) {\n            return s.map { ((it.code - 97) * i % 26 + 97).toChar() }.joinToString(\"\")\n        }\n    }\n    return \"Impossible to decode\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5df754981f177f0032259090":[{"id":208645,"user_id":527,"body":"package floatrepresent\n\nimport java.math.BigDecimal\nimport java.math.RoundingMode\n\nfun mantExp(number: BigDecimal, nDigits: Int): String {\n    val n = number.setScale(nDigits + number.scale() - number.precision(), RoundingMode.DOWN)\n    return \"${n.unscaledValue()}P${-n.scale()}\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208646,"user_id":492,"body":"package floatrepresent\n\nimport java.math.BigDecimal\nimport java.math.RoundingMode\n\nfun mantExp(aNumber: BigDecimal, digitsNumber: Int): String {\n    val s = String.format(\"%.15e\", aNumber)\n    val a = s.split(\"e\".toRegex(), 2).toTypedArray()\n    val exp = digitsNumber - Integer.valueOf(a[1]) - 1\n    val man = aNumber.multiply(BigDecimal(Math.pow(10.0, exp.toDouble()))).setScale(0, RoundingMode.FLOOR)\n    return man.toString() + \"P\" + (-exp).toString()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208647,"user_id":null,"body":"package floatrepresent\n\nimport java.math.BigDecimal\n\nfun mantExp(a: BigDecimal, n: Int): String {\n    var x = 1\n    val target = BigDecimal.TEN.pow(n)\n    while (a.scaleByPowerOfTen(x) <= target) x++\n    while (a.scaleByPowerOfTen(x) >= target) x--\n    return \"${a.scaleByPowerOfTen(x).toLong()}P${-x}\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208648,"user_id":null,"body":"package floatrepresent\n\nimport java.math.BigDecimal\nimport java.math.RoundingMode\n\nfun mantExp(aNumber: BigDecimal, digitsNumber: Int): String {\n\n    var num = aNumber.stripTrailingZeros()\n    var count = 0\n\n    while(num.toBigInteger().toBigDecimal().precision() < digitsNumber){\n        num *= BigDecimal.TEN\n        count--\n    }\n\n    while(num.toBigInteger().toBigDecimal().precision() > digitsNumber){\n        num = num.divide(BigDecimal.TEN, digitsNumber, RoundingMode.DOWN)\n        count++\n    }\n\n    return \"${num.toBigInteger()}P${count}\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208649,"user_id":null,"body":"package floatrepresent\n\nimport java.math.BigDecimal\nimport kotlin.math.log10\nimport kotlin.math.floor\nimport java.math.RoundingMode\n\nfun mantExp(aNumber: BigDecimal, digitsNumber: Int): String {\n    val newValue = aNumber.toString()\n        .trimEnd('0')\n        .replace(\".\", \"\")\n        .trimStart('0')\n        .take(digitsNumber)\n        .padEnd(digitsNumber, '0')\n\n    val exp = log10(newValue.toBigDecimal().divide(aNumber, 100, RoundingMode.CEILING).toDouble()) * -1\n    \n    return newValue.replace(\".\", \"\")\n        .trimStart('0')\n        .take(digitsNumber)\n        .padEnd(digitsNumber, '0')\n        .plus('P')\n        .plus(floor(exp))\n        .replace(\".0\", \"\")\n        .replace(\"-0\", \"0\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208650,"user_id":null,"body":"package floatrepresent\n\nimport java.math.BigDecimal\nimport java.math.BigInteger\n\nfun mantExp(aNumber: BigDecimal, digitsNumber: Int): String {\n    var base = aNumber.unscaledValue()\n    if (digitsNumber - aNumber.precision() > 0)\n        base = base.multiply(BigInteger.TEN.pow(digitsNumber - aNumber.precision()))\n    else\n        base = base.div(BigInteger.TEN.pow(aNumber.precision() - digitsNumber))\n    val e = aNumber.precision() - aNumber.scale() - digitsNumber\n    return \"${base}P$e\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208651,"user_id":null,"body":"package floatrepresent\n\nimport java.math.BigDecimal\n\nfun mantExp(aNumber: BigDecimal, digitsNumber: Int): String {\n   var num = aNumber\n   var exp = 1\n   \n   val ten = 10.toBigDecimal()\n   val limit = ten.pow(digitsNumber)\n   \n   if (num.compareTo(limit) > 0) {\n       while (num.compareTo(limit) > 0) {\n           val s = num.toString()\n           num = s.take(s.length - 1).toBigDecimal()\n           exp += 1           \n       }       \n       exp -= 1\n   } else {\n       while (num.compareTo(limit) < 0) {\n           num = num.times(ten)\n           exp -= 1           \n       }\n       num = num.div(ten).toBigInteger().toBigDecimal()\n   }\n   return \"${num}P${exp}\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208652,"user_id":null,"body":"package floatrepresent\n\nimport java.math.BigDecimal\n\nfun mantExp(aNumber: BigDecimal, digitsNumber: Int): String {\n    val scale = aNumber.scale()\n    val unscaled = if (scale == 0) aNumber.toString()\n        else aNumber.unscaledValue().toString()\n    val precision = aNumber.precision()\n    \n    var newExponent = precision - scale - digitsNumber\n    val mantissa = processMantissa(digitsNumber, precision, unscaled)\n    \n    return format(mantissa, newExponent)\n}\n\nfun processMantissa(digitsNumber: Int, precision: Int, unscaled: String): String {\n    return if (digitsNumber == precision) {\n        unscaled\n    } else if (digitsNumber > precision) {\n        unscaled.padEnd(digitsNumber, '0')\n    } else {\n        unscaled.take(digitsNumber)\n    }\n}\n\nfun format(mantissa: String, exponent: Int): String{\n    return \"%sP%d\".format(mantissa, exponent)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208653,"user_id":null,"body":"package floatrepresent\n\nimport java.math.BigDecimal\n\nfun mantExp(aNumber: BigDecimal, digitsNumber: Int): String =\n    aNumber.toString().substringAfter('.').let {\n        var shift = 0\n\n        val afterComma = it.length\n        var num = aNumber.movePointRight(afterComma)\n        shift -= afterComma\n\n        val numLength = num.toString().length\n        val numMultiplier = digitsNumber - numLength\n        num = num.movePointRight(numMultiplier)\n        shift -= numMultiplier\n\n        \"${num.toBigInteger()}P$shift\"\n    }\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208654,"user_id":null,"body":"package floatrepresent\n\nimport java.math.BigDecimal\nimport kotlin.math.pow\n\nfun mantExp(aNumber: BigDecimal, digitsNumber: Int): String = if (aNumber.toString().split(\".\")[0].length < digitsNumber) {\n        var number = aNumber\n        var radix = 0\n\n\n        while (10.toDouble().pow(digitsNumber.toDouble() - 1) > number.toDouble()) {\n            number = number.multiply(BigDecimal.TEN)\n            radix += 1\n        }\n\n        String.format(\"%sP-%d\", number.toString().split(\".\")[0],radix)\n    } else {\n        var number = aNumber\n        var radix = 0\n\n        while (10.toDouble().pow(digitsNumber.toDouble()) <= number.toDouble()) {\n            number = number.divide(BigDecimal.TEN)\n            radix += 1\n        }\n\n        String.format(\"%sP%d\", number.toString().split(\".\")[0], radix)\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5e1ab1b9fe268c0033680e5f":[{"id":208655,"user_id":470,"body":"package kata\n\nobject KataSolution {\n\tfun solve(n:Long): Int = forge(n,9L,1L,0L,0L)\n\t\n\t\/\/ count digits in a range\n\t\/\/ q: initial digit count, d: exponent of 10, ct: range size\n\tprivate val proc = { q:Long,d:Long,ct:Long -> (q + d + q + d * ct) * ct \/ 2L }\n\t\n\t\/\/ STEP 1: check each succeeding order of magnitude (x10) as its own group and find total number of digits in the group (e.g. 45 digits in range 1..9)\n\tprivate tailrec fun forge(n:Long,ct:Long,d:Long,q:Long,c:Long): Int {\n\t\tval m = proc(q,d,ct)\n\t\treturn if (c + m >= n) binseek(n-c,d,q,p10(d-1L),p10(d)-1L) else forge(n,ct*10L,d+1L,q+d*ct,c+m)\n\t}\n\t\n\t\/\/ STEP 2: use binary search to narrow down to iteration\n\tprivate tailrec fun binseek(n:Long,d:Long,q:Long,q0:Long,q1:Long): Int {\n\t\tval mp = (q1-q0+1L)\/2L\n\t\tif (mp < 1L) return digitseek(n-1L,1L,9L)\n\t\tval dc = proc(q,d,mp)\n\t\tval args = if (dc >= n) arrayOf(n,q,q0,q0+mp-1L) else arrayOf(n-dc,q+d*mp,q0+mp,q1)\n\t\treturn binseek(args[0],d,args[1],args[2],args[3])\n\t}\n\t\n\t\/\/ STEP 3: iterate through each exponent of 10 group until nth value is reached\n\tprivate tailrec fun digitseek(n:Long,d:Long,z:Long): Int {\n\t\tif (n <= 0L) return 1\n\t\tval v = d * z\n\t\treturn if (n <= v) (n\/d+p10(d-1L)).toString()[(n%d).toInt()].toInt()-48 else digitseek(n-v,d+1L,z*10L)\n\t}\n\t\n\tprivate tailrec fun p10(n:Long,v:Long=1L):Long = if (n < 1L) v else p10(n-1L,v*10L)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208656,"user_id":null,"body":"package kata\nimport kotlin.math.*\n\nobject KataSolution {\n    fun solve(n: Long): Int {\n        var guess = floor(n.toDouble().pow(.48)).toLong()\n        var stepSize = 2.0.pow(order(guess, 2.0)).toLong()\n        var lastTri = triLength(guess)\n        while (stepSize>0) {\n            val new = guess + stepSize\n            val newTri = triLAssisted(new, guess, lastTri)\n            if(newTri > n) stepSize \/=2 else {\n                guess = new\n                lastTri = newTri\n            }\n        }\n        var remaining = n - lastTri\n        if (remaining == 0L) return (guess % 10).toInt()\n        var order = 1 \n        var bracket = 9L\n        guess=0\n        while(remaining > order*bracket) {\n            remaining -= order* bracket\n            guess+=bracket\n            order++\n            bracket*=10\n        }\n        val last = (remaining-1)\/order\n        remaining -= last*order\n        guess += last+1\n        for (i in remaining until order) guess\/=10\n        return (guess%10).toInt()\n         \n    }\n    fun triLAssisted(n:Long, lastN: Long, LastTri:Long):Long {\n        val order = order(n)+1\n        if(order >= order(lastN)) return triLength(n)\n        val dif = n-lastN\n        return LastTri +(dif)*(lastN*order - excessDigits(order)) + triSimple(dif) *order\n    }\n    fun triLength(n:Long): Long {\n        val order = order(n)+1\n        var ans = triSimple(n)*order\n        var max = 0L\n        for (i in 1 until order) {\n            max = 10 * max +9\n            ans -= triSimple(max) + max*(n-max)\n        }\n        return ans\n    }\n    fun order(n:Long, base:Double = 10.0):Int {\n        return floor(log(n.toDouble(), base)).toInt()\n    }\n    fun excessDigits(order: Int) = (10.0.pow(order).toLong() -1)*10\/9 - order\n    fun triSimple(n: Long) = n*(n+1)\/2\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208657,"user_id":null,"body":"package kata\n\nimport kotlin.math.pow\n\nobject KataSolution {\n    fun solve(n: Long): Int = digitInSegment(n - lengthOfCompleteSequence(previousCompleteSequence(n)))\n\n    private fun previousCompleteSequence(n: Long): Int {\n        return tuneInFromEstimate(\n            n,\n            ((kotlin.math.sqrt(8.0 * n + 1) - 1) \/ 2).toInt().let { it \/ it.digitCount() },\n            ::lengthOfCompleteSequence,\n            ::lengthOfSequenceSegment\n        )\n    }\n\n    private fun lengthOfCompleteSequence(i: Int): Long =\n        (1..i.digitCount()).map { i - 10.0.pow(it - 1).toLong() + 1 }.map { it * (it + 1) \/ 2 }.sum()\n\n    private fun lengthOfSequenceSegment(i: Int): Long =\n        (1..i.digitCount()).map { i - 10.0.pow(it - 1).toLong() + 1 }.sum()\n\n    private fun previousCompleteSubsegment(n: Long): Int {\n        return tuneInFromEstimate(\n            n, (n \/ n.digitCount()).toInt(), ::lengthOfSequenceSegment\n        ) { num: Number -> num.digitCount().toLong() }\n\n    }\n\n    private fun digitInSegment(digitPlace: Long): Int =\n        previousCompleteSubsegment(digitPlace).let { (it + 1).toString()[(digitPlace - lengthOfSequenceSegment(it) - 1).toInt()].digitToInt() }\n\n    private fun tuneInFromEstimate(\n        n: Long, estimate: Int, getLengthOfEstimate: (Int) -> Long, getLengthOfNextSegment: (Int) -> Long\n    ): Int {\n        var approximate = estimate\n        do {\n            val lengthOfEstimate = getLengthOfEstimate(approximate)\n            val lengthOfNextNumber = getLengthOfNextSegment(approximate + 1)\n            when {\n                n <= lengthOfEstimate -> approximate -= 1 + ((lengthOfEstimate - n) \/ lengthOfNextNumber).toInt()\n                n > lengthOfEstimate + lengthOfNextNumber -> approximate += ((n - lengthOfEstimate) \/ lengthOfNextNumber).toInt()\n                else -> return approximate\n            }\n        } while (true)\n    }\n\n    private fun Number.digitCount(): Int = this.toString().length\n\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208658,"user_id":149,"body":"package kata\n\nimport kotlin.math.sqrt\n\nobject KataSolution {\n    fun solve(N: Long): Int {\n        var n = N - 1\n\n        var a1: Long\n        var an = 0L\n        var total = 0L\n        var d = 1L\n        while (true) {\n            a1 = an + d\n            an += 9 * d * f(10, d - 1)\n            var nextTotal = total + (a1 + an) * 9 * f(10, d - 1) \/ 2\n            if (nextTotal > n) {\n                n -= total\n                break\n            }\n            total = nextTotal\n            d++\n        }\n\n        var b = a1 * 2 - d\n        var x = ((sqrt(8.0 * d * n + b * b) - b) \/ (d * 2)).toLong()\n        n -= (a1 + a1 + d * (x - 1)) * x \/ 2\n\n        d = 1\n        while (true) {\n            total = 9 * d * f(10, d - 1)\n            if (n < total) break\n            n -= total\n            d++\n        }\n        \n        return (f(10, d - 1) + n \/ d).toString()[(n%d).toInt()].code - 48\n    }\n    \n    fun f(a: Long, B: Long): Long {\n        var r = 1L\n        var b = B\n        while (b-- > 0) r *= a\n        return r\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208659,"user_id":53,"body":"package kata\n\nobject KataSolution {\n    fun solve(m: Long): Int {\n        var n = m - 1\n        var lb = 0L\n        var rb = 1000000000L\n        while (lb < rb) {\n            val mb = (lb + rb + 1) \/ 2\n            if (bSearch(mb) > n) {\n                rb = mb - 1\n            } else {\n                lb = mb\n            }\n        }\n        n = n - bSearch(lb)\n        var cnt = 9L\n        var len = 1L\n        while (n >= cnt * len) {\n            n = n - cnt * len\n            cnt = cnt * 10\n            len = len + 1\n        }\n        val x = (cnt \/ 9 + n \/ len).toString()\n        val y = (n % len).toInt()\n        return x.get(y).digitToInt()\n    }\n    fun bSearch(n: Long): Long {\n        var res = 0L\n        var i = 1L\n        var k = 9L\n        var j = 9L\n        while (j < n) {\n            res = res + (i * k * (k + 1) \/ 2)\n            res = res + (i * k * (n - j))\n            i = i + 1\n            k = k * 10\n            j = j + k\n        }\n        k = n - j \/ 10\n        res = res + (i * k * (k + 1) \/ 2)\n        return res\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208660,"user_id":null,"body":"package kata\n\nobject KataSolution {\n    fun acc(m: Long, cutLevel: Long = 9): Long =\n        if (m <= 0L)\n            0L\n        else\n            m * (m + 1) \/ 2 + acc(m - cutLevel, cutLevel = cutLevel * 10)\n\n    fun lastAcc(n: Long, m: Long = 1L, step: Long = 1L): Long? =\n        acc(m).let { currLast ->\n            if (currLast >= n)\n                null\n            else\n                lastAcc(n = n, m = m + step, step = step * 2)\n                    ?: lastAcc(n = n, m = m + 1, step = 2)\n                    ?: currLast\n        }\n    \n    fun solve(n: Long): Int {\n        var n0 = n - (lastAcc(n) ?: 0L)\n        var digs = 1L\n        var lastNo = 9L\n        while (n0 > lastNo * digs) {\n            n0 -= lastNo * digs\n            digs++\n            lastNo *= 10L\n        }\n        val no = ((n0 - 1) \/ digs) + (lastNo \/ 9L)\n        return \"$no\"[((n0 - 1) % digs).toInt()] - '0'\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208661,"user_id":null,"body":"package kata\n\nobject KataSolution {\n    \n    val list10:List<Long> = List(18, {1L}).runningFold(1) { acc, _ -> acc*10L }   \n\n    fun solve(n: Long): Int {\n        var startDigitLength:Long=1L\n        var start:Long\n        var next:Long=1L\n        var power:Long=0L\n        var oldStartDigitLength:Long\n        do {\n            start=next\n            val lastDigitLength:Long=(startDigitLength+9L*(power+1)*list10[power.toInt()]-(power+1)).toLong()\n            val amount:Long=(9L*list10[power.toInt()]).toLong()\n            val sumDigit:Long=(startDigitLength+lastDigitLength)*amount\/2\n            power+=1\n            oldStartDigitLength=startDigitLength\n            startDigitLength=(lastDigitLength+(power+1)).toLong()            \n            next=start+sumDigit        \n        } while (next<n)        \n        var n1=n-start+1\n        start=oldStartDigitLength        \n        var counter=0\n        var resN1:Long=(((power-2*start)+kotlin.math.sqrt(((2.0*start-power)*(2.0*start-power)+8.0*power*n1).toDouble()))\/(2L*power)).toLong()        \n        val sumN1:Long=(2*start+(resN1.toLong()-1)*power)*resN1.toLong()\/2        \n        if (sumN1!=n1)\n        \tn1=n1-sumN1\n        else{\n            val sumN1m:Long=(2*start+(resN1.toLong()-2)*power)*(resN1.toLong()-1)\/2\n            n1=n1-sumN1m\n        }\n        start=9\n        var places:Long=1L\n        counter=0\n        while (n1-start>0){\n        \tn1=n1-start\n            start=(9*list10[places.toInt()]*(places+1)).toLong()\n            places+=1            \n            counter++            \n        }\n        var resultNumber:Long=n1\/places\n        var resultDigit:Long=n1%places\n        if (resultDigit==0L){        \n        \tresultDigit=places\n            resultNumber=resultNumber-1\n        }\n        val resultValue:Long=list10[places.toInt()-1].toLong()+resultNumber\n        val result:Long = resultValue\/(list10[resultValue.toString().length-resultDigit.toInt()]).toLong()%10\n        return result.toInt()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208662,"user_id":null,"body":"package kata\n\nobject KataSolution {\n    private fun segment(n: Long): Long {\n        var result: Long = 0\n        var segment: Long = 1\n        var order: Long = 9\n        var length: Long = 9\n        while (length < n) {\n            val l = segment * order\n            result += l * (order + 1) \/ 2 + l * (n - length)\n            ++segment\n            order *= 10\n            length += order\n        }\n        order = n - length \/ 10\n        result += segment * order * (order + 1) \/ 2\n        return result\n    }\n\n    fun solve(n: Long): Int {\n        var cn = n\n        cn--\n        var lb: Long = 0\n        var rb = 1e9.toLong()\n        while (lb < rb) {\n            val mb = (lb + rb + 1) \/ 2\n            if (segment(mb) > cn) rb = mb - 1 else lb = mb\n        }\n        cn -= segment(lb)\n        var cnt: Long = 9\n        var len: Long = 1\n        while (cn >= cnt * len) {\n            cn -= cnt * len\n            cnt *= 10\n            ++len\n        }\n        val x = (cnt \/ 9 + cn \/ len).toString()\n        val y = (cn % len).toInt()\n        return x[y] - '0'\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208663,"user_id":null,"body":"package kata\nimport kotlin.math.pow\nobject KataSolution {\n    fun solve(n: Long): Int {\n        var n = n - 1\n        var a = 0L\n\n        for (i in 1..9) {\n            val c = 9 * 10.0.pow(i - 1).toLong()\n            val sum = (2 * a + i + i * c) * c \/ 2\n            if (n > sum)\n                n -= sum\n            else {\n                val b = 2 * a + i\n                val c = ((Math.sqrt(b * b + 8.0 * i * n) - b) \/ (2 * i)).toLong()\n                val sum = (2 * a + i + i * c) * c \/ 2\n                n -= sum\n                break\n            }\n            a = a + c * i\n        }\n\n        for (i in 1..9) {\n            if (n < i * 9 * 10.0.pow(i - 1)) {\n                return (n \/ i + 10.0.pow(i - 1).toLong()).toString()[(n % i).toInt()].toInt() - '0'.toInt()\n            } else {\n                n -= (i) * 9 * 10.0.pow(i - 1).toLong()\n            }\n        }\n        return 0\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208664,"user_id":null,"body":"package kata\n\nimport kotlin.math.ceil\nimport kotlin.math.min\n\nobject KataSolution {\n    fun solve(n: Long): Int {\n        var position = position(n)\n        var current = 0L\n        var length = 1L\n        var limit = 9L\n    \n        while (position > 0) {\n            val min = min(ceil(position \/ length.toDouble()).toLong(), limit)\n            current += min\n            position -= min*length\n    \n            limit *= 10\n            length += 1\n        }\n    \n        val str = current.toString()\n        return str[str.length+position.toInt()-1].toString().toInt()\n    }\n    \n    \/\/ find needed number in the array, and return position inside that number\n    fun position(upTo: Long): Long {\n        var position = upTo\n        var length = 1L\n        var limit = 9L\n        var sum: Long\n        var first = 1L\n        var last: Long\n    \n        \/\/ skip first 10^n numbers that are before needed position\n        while (true) {\n            last = first + length * (limit - 1)\n            sum = progSum(first, last, limit)\n    \n            if (position <= sum) break\n    \n            position -= sum\n            length++\n            first = last + length\n            limit *= 10\n        }\n    \n        \/\/ binary search of needed number between \"first\" and \"last\"\n        var firstIndex = 0L\n        var lastIndex = limit\n        var middle: Long\n    \n        while (lastIndex != firstIndex+1) {\n            middle = (lastIndex+firstIndex) shr 1\n            last = first + length * (middle - 1)\n            sum = progSum(first, last, middle)\n    \n            if (sum >= position)\n                lastIndex = middle\n            else\n                firstIndex = middle\n        }\n    \n        return position - progSum(first, first + length * (firstIndex - 1), firstIndex)\n    }\n    \n    \/\/ Sum of arithmetic progression\n    fun progSum(a1: Long, aN: Long, n: Long) = (n.toULong() * (a1 + aN).toULong() shr 1).toLong()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5e2596a9ad937f002e510435":[{"id":208665,"user_id":932,"body":"fun infected(s: String): Double{\n    var infectedPerson = 0.0\n    var total = 0.0\n    s.split(\"X\").forEach{\n        if(it.contains(\"1\")) infectedPerson += it.length\n        total += it.length\n    }\n    return if (total==0.0) 0.0 else 100*infectedPerson\/total\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208666,"user_id":null,"body":"fun infected(s: String): Double {\n    val allPopulation = s.filter { it != 'X' }.length\n    \n    if(allPopulation == 0) {\n        return 0.0\n    }\n\n    val infectedPopulation = s.split('X')\n        .filter { it.contains('1') }\n        .map { it.length }\n        .sum()\n\n    return infectedPopulation \/ allPopulation.toDouble() * 100\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208667,"user_id":null,"body":"fun infected(s: String) = s.split(\"X\").filter { \"1\" in it }.sumOf { it.count() } * 100.0 \/ (s.replace(\"X\", \"\").count().takeIf { it > 0 } ?: 1)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208668,"user_id":null,"body":"fun infected(s: String): Double {\n    val continents = s.split('X')\n    var population: Double = 0.0\n    var infected: Double = 0.0\n    for (c: String in continents) {\n        if (c.filter{it=='1'}.count() > 0) infected += c.length\n        population += c.length\n    }\n    if (population == 0.0 || infected == 0.0) return 0.0\n    return infected\/population*100\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208669,"user_id":null,"body":"fun infected(s: String): Double {\n    val total = s.count { ch -> ch != 'X' }\n    if (total == 0) {\n        return 0.0\n    }\n\n    val infectees = s.split(\"X\")\n        .sumOf { substr -> if (substr.contains('1')) substr.length else 0 }\n\n    return infectees.toDouble() \/ total.toDouble() * 100.0\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208670,"user_id":null,"body":"fun infected(s: String): Double{\n    val infected = s.split(\"X\").filter { it.contains(\"1\") }.sumOf { it.length }\n    val all = s.split(\"X\").sumOf { it.length }\n    return if (all == 0) 0.0 else 100.0 * infected \/ all\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208671,"user_id":null,"body":"fun infected(s: String): Double{\n    \n    var all = s.replace(\"X\",\"\").length\n    if (all == 0) return 0.0\n    \n    var inf: Int = 0\n    s.split(\"X\").forEach {\n\n        if (it.contains('1')) {\n            inf += it.length\n        }\n    }\n    return 100.0 * inf.toDouble()\/all.toDouble()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208672,"user_id":null,"body":"fun infected(s: String): Double {\n    val sList = s.split(\"X\")\n    var result = 0\n    var total = 0\n\n    for (i in sList) {\n        total += i.length\n        println(\"i = '$i'\")\n        if (i.contains(\"1\")) {\n            result += i.length\n        }\n    }\n    if (result == 0) {\n        return 0.0\n    } else {\n        return (result \/ total.toDouble()) * 100.0\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208673,"user_id":null,"body":"fun infected(s: String): Double {\n    \/\/ have fun :)\n    println(\"s = '$s'\")\n    val sList = s.split(\"X\")\n    println(\"s.split() = '$sList'\")\n    var result = 0\n    var total = 0\n\n    for (i in sList) {\n        total += i.length\n        println(\"i = '$i'\")\n        if (i.contains(\"1\")) {\n            result += i.length\n        }\n    }\n    println(\"result = $result\")\n    println(\"total = $total\")\n    println(\"result\/total = ${(result \/ total.toDouble()) * 100.0}\")\n    if (result == 0) return 0.0 else return (result \/ total.toDouble()) * 100.0 \n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208674,"user_id":null,"body":"fun infected(s: String): Double{\n  if (!s.contains('1')&& !s.contains('0')) return 0.0\n\n    var save = \"\"\n    var infected = \"\"\n    val territory = s.split('X')\n    territory.forEach {\n            if ( it.contains('1')) {\n                infected += it\n            } else {\n                save += it\n            }\n    }\n    return (infected.length.toDouble()\/(infected.length.toDouble()+save.length.toDouble()))*100\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5e320fe3358578001e04ad55":[{"id":208675,"user_id":571,"body":"fun isCheck(n:Array<Array<String>>,s:Any=\"(.{7}|.{11}|.{18}|.{20})\",q:Any=\"(.{9} )*.{9}\",c:Any=\"((.{8} )*(.{8})|(.{10} )*(.{10}))\",j:Any=\"[\u265b\u265c]|[\u265b\")=n.fold(\"\"){a,b->a+b.reduce{c,v->c+v}+\"--\"}.matches(Regex(\".*(\u2654$s\u265e|\u265e$s\u2654|\u265f(.{8}|.{10})\u2654|\u2654$q$j\u265c]$q\u2654|[\u265b\u265c] *\u2654|\u2654 *$j\u265d]$c\u2654|\u2654$c[\u265b\u265d]).*\"))","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5e388662a9ca160021b7a7c1":[{"id":208676,"user_id":490,"body":"class LiveData<T>(private val initial: T? = null) {\n  var defaultProvider: () -> T? = { null }\n  private var observers = mutableListOf<(T?) -> Unit>()\n  var value: T? = null\n    get() = field ?: initial ?: defaultProvider()\n    set(value) { field = value; observers.forEach { it(value) } }\n  fun observe(lambda: (T?) -> Unit) { observers.add(lambda) }\n}\n\nfun <T> combineLatest(vararg sources: LiveData<out Any>, combiner: (Array<Any?>) -> T) =\n  LiveData<T>().apply {\n    sources.forEach { it.observe { value = defaultProvider() } }\n    defaultProvider = { sources.map(LiveData<out Any>::value).takeIf { it.all { it != null } }?.toTypedArray()?.let(combiner) }\n  }\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208677,"user_id":null,"body":"class LiveData<T>(initial: T? = null) {\n\n    private val observers = mutableListOf<(T) -> Unit>()\n\n    var value: T? = initial\n        set(value) {\n            field = value\n            if (value != null) {\n                observers.forEach { it.invoke(value) }\n            }\n        }\n\n    fun observe(lambda: (newValue: T) -> Unit) {\n        observers.add(lambda)\n    }\n}\n\nfun <T>combineLatest(\n    vararg sources: LiveData<out Any>,\n    combiner: (Array<Any?>) -> T\n): LiveData<T> {\n    val generator = {\n        if (sources.all { it.value != null })\n            combiner(sources.map { it.value }.toTypedArray())\n        else null\n    }\n    val result = LiveData(generator.invoke())\n    for (s in sources) {\n        s.observe { \n            result.value = generator.invoke()\n        }\n    }\n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208678,"user_id":null,"body":"class LiveData<T>(initial: T? = null) {\n    var value: T? = initial\n        set(value) {\n            field = value\n            for (lambda in observedList) {\n                field?.apply { lambda(this) }\n            }\n            for (combined in combinedList) {\n                field?.apply {\n                    combined.combine()\n                }\n            }\n        }\n    var observedList = mutableListOf<(T) -> Unit>()\n    var combiner: (LiveData<T>) -> Unit = {}\n    fun combine() {\n        combiner(this)\n    }\n    var combinedList = mutableListOf<LiveData<out Any?>>()\n    fun observe(lambda: (newValue: T) -> Unit) {\n        observedList.add(lambda)\n        value?.apply { lambda(this) }\n    }\n}\n\nfun <T>combineLatest(vararg sources: LiveData<out Any>, combiner: (Array<out Any?>) -> T): LiveData<T>{\n    var newLd = LiveData<T>()\n    newLd.combiner = { \n        val srcs = sources.map { it.value } .toTypedArray()\n        if (!srcs.contains(null)) {\n            it.value = combiner(srcs)\n        }\n    }\n    for (ld in sources) {\n        ld.combinedList.add(newLd)\n    }\n    newLd.combine()\n    return newLd;\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208679,"user_id":null,"body":"class LiveData<T>(initial: T? = null) {\n    var value = initial\n        set(value) {\n            field = value\n            callbacks.forEach { it(field!!) }\n        }\n    private val callbacks = mutableListOf<(T) -> Unit>()\n    fun observe(lambda: (newValue: T) -> Unit) { callbacks.add(lambda)}\n}\n\nfun <T>combineLatest(\n    vararg sources: LiveData<out Any>,\n    combiner: (Array<Any?>) -> T\n) = LiveData<T>().apply {\n    fun update() { value = combiner(sources.map { it.value ?: return }.toTypedArray()) }\n    sources.forEach { it.observe { update() } }\n    update()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208680,"user_id":null,"body":"class LiveData<T>(\n    initial: T? = null,\n    private var parentData: List<LiveData<out Any>> = mutableListOf(),\n    private var combiner: ((Array<Any?>) -> T)? = null,\n    private var childrenData: MutableList<LiveData<out Any>> = mutableListOf()) {\n\n    private var observerLambdas: MutableList<(newValue: Any) -> Unit> = mutableListOf()\n\n    var value: T? = initial\n    set(value) {\n        if (value != null) {\n            field = value\n            observerLambdas.forEach { it.invoke(value) }\n            childrenData.forEach { it.invokeObservers() }\n        }\n    }\n    get() {\n        return if (parentData.isNotEmpty() && combiner != null) {\n            val hasNullData = parentData.any { it.value == null }\n            if (hasNullData) return null\n            val value = parentData.map { it.value }\n            combiner!!.invoke(value.toTypedArray())\n        } else field\n    }\n\n    fun observe(lambda: (newValue: T) -> Unit) {\n        observerLambdas.add(lambda as (newValue: Any) -> Unit)\n    }\n\n    fun addChildren(children: LiveData<out Any>) {\n        childrenData.add(children)\n    }\n\n    fun invokeObservers() {\n        observerLambdas.forEach { it.invoke(value as Any) }\n        childrenData.forEach { it.invokeObservers() }\n    }\n}\n\nfun <T> combineLatest(vararg sources: LiveData<out Any>, combiner: (Array<Any?>) -> T) : LiveData<T> {\n    val data = LiveData(parentData = sources.asList(), combiner = combiner)\n    sources.forEach { it.addChildren(data as LiveData<out Any>) }\n    return data\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208681,"user_id":null,"body":"class LiveData<T>(initial: T? = null) {\n    var value: T?\n        get() = _value\n        set(newValue: T?){\n            _value = newValue\n            observers.forEach{ observer ->\n                newValue?.let{ observer(it)}\n            }\n        }\n    \n    private var _value: T? = initial\n    \n    private var observers = mutableListOf<((newValue: T) -> Unit)>()\n    \n    fun observe(lambda: (newValue: T) -> Unit) {\n        value?.let{ lambda(it) }\n        observers.add(lambda)\n    }\n}\n\nfun <T>combineLatest(vararg sources: LiveData<out Any>, combiner: (Array<Any?>) -> T): LiveData<T>{\n    val liveData = LiveData<T>()\n    if(sources.all{it.value != null}){\n        liveData.value = combiner(sources.map{it.value}.toTypedArray<Any?>())\n    }\n    \n    sources.forEach{ source ->\n        source.observe{ observeValue ->\n            if(sources.all{it.value != null}){\n                liveData.value = combiner(sources.map{it.value}.toTypedArray<Any?>())\n            }\n        }\n    }\n    return liveData\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208682,"user_id":null,"body":"class LiveData<T>(initial: T? = null) {\n    var _value: T? = initial\n    var value: T?\n        get() = this._value\n        set(value) {\n            this._value = value;\n            observations.forEach{it(value)}\n        }\n    var observations = mutableListOf<(T?) -> Unit>()\n    fun observe(lambda: (T?) -> Unit) {\n        this.observations.add(lambda)\n    }\n}\n\nfun <T>combineLatest(vararg sources: LiveData<out Any>, combiner: (Array<Any?>) -> T): LiveData<T>{\n    val data = LiveData<T>()\n    val onUpdate = {\n        if (sources.none{it.value == null}) {\n            data.value = combiner(sources.map{it.value}.toTypedArray())\n        }\n    }\n    sources.forEach{it.observe{onUpdate()}}\n    onUpdate()\n    return data\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208683,"user_id":null,"body":"class LiveData<T>(initial: T? = null) {\n    private val onChange:MutableList<(T?)->Unit> = mutableListOf()\n    var value: T? = null\n        set(newValue: T?){\n            field =newValue\n            onChange.forEach{it(newValue)}\n        }\n    init{\n        value=initial\n    }\n    fun observe(lambda: (newValue: T?) -> Unit)=onChange.add(lambda)\n}\n\nfun <T>combineLatest(vararg sources: LiveData<out Any>, combiner: (Array<Any?>) -> T): LiveData<T>{\n    val data=LiveData<T>()\n    fun update(){\n        if(sources.map{it.value}.all{it!=null})\n        data.value=combiner(sources.map { it.value }.toTypedArray())\n    }\n    update()\n    sources.forEach { it.observe { update() } }\n    return data\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208684,"user_id":null,"body":"class LiveData<T>(initial: T? = null) {\n    private var _observers = mutableListOf<(newValue: T) -> Unit>()\n    \n    private fun _informObservers() = value?.let { unwrappedValue -> _observers.forEach { it(unwrappedValue) } }\n    \n    var value: T? = initial\n        set(value) {\n            if (field != value) {\n                field = value\n                _informObservers()\n            }\n        } \n        \n    fun observe(lambda: (newValue: T) -> Unit) = _observers.add(lambda)\n}\n\nfun <T>combineLatest(vararg sources: LiveData<out Any>, combiner: (Array<Any?>) -> T) = LiveData<T>().apply {\n    val _func: () -> Unit = {\n        if (sources.all { it.value != null }) {\n            value = combiner(sources.map { it.value }.toTypedArray())\n        }\n    }\n    \n    sources.forEach { \n        it.observe { _func() }\n    }\n    \n    _func()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208685,"user_id":null,"body":"class LiveData<T>(initial: T? = null) {\n\n    private var _observers = mutableListOf<(newValue: T?) -> Unit>()\n    var value: T? = null\n        set(newValue: T?) {\n            if(value != newValue) {\n                field = newValue\n                _observers.forEach { observer->\n                    observer(newValue)\n                }\n            } \n        }\n    \n    init {\n        value = initial\n    }\n    \n    fun observe(lambda: (newValue: T?) -> Unit) {\n        _observers.add(lambda)\n    }\n}\n\nfun <T>combineLatest(vararg sources: LiveData<out Any>, combiner: (Array<Any?>) -> T): LiveData<T> {\n    val result = LiveData<T>(null)\n    sources.forEach {\n        it.observe {\n            it?.let {\n                if(sources.all { it.value != null }) {\n                   result.value = combiner(sources.map { it.value }.toTypedArray())\n                }  \n            }\n        }\n    }\n    return result.apply {\n        if(sources.all { it.value != null }) {\n           value = combiner(sources.map { it.value }.toTypedArray())\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5e4e8f5a72d9550032953717":[{"id":208686,"user_id":527,"body":"fun allRationals(): Iterator<Pair<Int, Int>> = iterator {\n    yield(Pair(1, 1))\n    for ((a, b) in allRationals()) {\n        yield(Pair(a, a + b))\n        yield(Pair(a + b, b))\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208687,"user_id":null,"body":"fun allRationals(): Iterator<Pair<Int, Int>> = iterator {\n    val res = mutableListOf<Pair<Int, Int>>()\n    res.add(Pair(1,1))\n\n    while (true){\n        val (a,b) = res.removeAt(0)\n        res.add(Pair(a, a + b))\n        res.add(Pair(a + b, b))\n        yield(Pair(a, b))\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208688,"user_id":645,"body":"fun allRationals(): Iterator<Pair<Int, Int>> = iterator {\n    yield(Pair(1, 1))\n    allRationals().forEach { (a, b) -> yieldAll(listOf(Pair(a, a + b), Pair(a + b, b))) }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208689,"user_id":null,"body":"fun allRationals(): Iterator<Pair<Int, Int>> = iterator {\n    fun nextTier(t: List<Pair<Int, Int>>): List<Pair<Int, Int>> =\n        t.flatMap { (a, b) -> listOf(Pair(a, a + b), Pair(a + b, b)) }\n\n    var tier = listOf(Pair(1, 1))\n    while (true) {\n        yieldAll(tier)\n        nextTier(tier).also { tier = it }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208690,"user_id":null,"body":"fun allRationals(): Iterator<Pair<Int, Int>> = iterator {\n    fun nextTier(t: List<Pair<Int, Int>>): List<Pair<Int, Int>> =\n        t.fold(listOf()) { acc, cur -> val (a, b) = cur; acc + listOf(Pair(a, a + b), Pair(a + b, b)) }\n\n    var tier = listOf(Pair(1, 1))\n    while (true) {\n        yieldAll(tier)\n        nextTier(tier).also { tier = it }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208691,"user_id":null,"body":"fun allRationals(): Iterator<Pair<Int, Int>> = sequence {\n    val start = Pair(1, 1)\n    yield(start)\n    var que = listOf(start)\n    fun derive(p: List<Pair<Int, Int>>): List<Pair<Int, Int>> {\n        return p.fold(listOf()) { acc, cur ->\n            acc + List(2) { val (a, b) = cur; if (it == 0) Pair(a, a + b) else Pair(a + b, b) }\n        }\n    }\n    while (true) {\n        que = derive(que)\n        for (j in que) {\n            yield(j)\n        }\n    }\n}.iterator()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208692,"user_id":50,"body":"fun allRationals(): Iterator<Pair<Int, Int>> = iterator {\n    yield(Pair(1, 1))\n    for (x in allRationals()){\n        var a=x.first\n        var b=x.second\n        yield(Pair(a,a+b))\n        yield(Pair(a+b,b))\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208693,"user_id":null,"body":"fun allRationals(): Iterator<Pair<Int, Int>> = iterator {\n    fun allRationals(p: List<Pair<Int, Int>>): Iterator<Pair<Int, Int>>  = iterator {\n            val rationals = mutableListOf<Pair<Int, Int>>()\n            for (x in p) {\n                yield(x)\n                rationals.add(Pair(x.first, x.first + x.second))\n                rationals.add(Pair(x.first + x.second, x.second))\n            }\n            yieldAll(allRationals(rationals))\n    }\n\n    yieldAll(allRationals(listOf(Pair(1,1))))\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208694,"user_id":null,"body":"import java.util.ArrayDeque\n\n\n\nfun allRationals(): Iterator<Pair<Int, Int>> = iterator {\n    var current = ArrayList<Pair<Int,Int>>()\n    var next = ArrayList<Pair<Int,Int>>()\n    current.add(Pair(1,1))\n    while (true) {\n        \n        for((a,b) in current) {\n            next.add(Pair(a,a+b))\n            next.add(Pair(a+b,b))\n            \/\/print(Pair(a,b))\n            yield(Pair(a,b))\n        }\n        current = next\n        next = ArrayList<Pair<Int,Int>>()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208695,"user_id":null,"body":"fun allRationals(): Iterator<Pair<Int, Int>> = iterator {\n    yield(Pair(1, 1))\n    var nodes:MutableList<Pair<Int,Int>> = mutableListOf(Pair(1,1))\n    var nodesAux:MutableList<Pair<Int,Int>> = mutableListOf()\n    while (true){\n        for (node in nodes){\n            yield(Pair(node.first, node.first + node.second))\n            nodesAux.add(Pair(node.first, node.first + node.second))\n            yield(Pair(node.first + node.second, node.second))\n            nodesAux.add(Pair(node.first + node.second, node.second))\n        }\n        nodes = nodesAux.toMutableList()\n        nodesAux.clear()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5ecc1d68c6029000017d8aaf":[{"id":208696,"user_id":470,"body":"package kata\n\nobject KataSolution {\n\tfun maxHexagonBeam(n:Int,seq:Array<Int>): Int {\n\t\tval cyc = cycle(seq)\n\t\tval lens = Array<Int>(n*2-1, {i -> if (i >= n) n+(n-i%n-2) else i+n})\n\t\tval tome = Array<Array<Int>>(lens.size) {i -> Array<Int>(lens[i], {cyc()})}\n\t\tval codex = Array<Int>(lens.size) {0}\n\t\tvar n1: Int\n\t\tvar n2: Int\n\t\tvar n3: Int\n\t\t\n\t\tfor ((q,ln) in lens.withIndex()){\n\t\t\tn1 = 0; n2 = 0; n3 = 0\n\t\t\tfor (w in 0 until ln){\n\t\t\t\tn1 += tome[q][w]\n\t\t\t\tn2 += tome[Math.max(0,q-n+1)+w][Math.min(q,ln-w-1+Math.max(0,q-n+1))]\n\t\t\t\tn3 += tome[Math.max(0,n-q-1)+w][Math.max(0,q-n+1)+Math.min(w,Math.min(q,n-1))]\n\t\t\t}\n\t\t\tcodex[q] = Math.max(n1,Math.max(n2,n3))\n\t\t}\n\t\t\n\t\treturn codex.reduce {a,e -> Math.max(a,e)}\n\t}\n\t\n\t\/\/ mimic Python itertools.cycle\n\tprivate fun cycle(r:Array<Int>): () -> Int {\n\t\tvar i = -1\n\t\tvar fn: () -> Int = {\n\t\t\tif (++i == r.size){i = 0}\n\t\t\tr[i]\n\t\t}\n\t\treturn fn\n\t}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208697,"user_id":null,"body":"package kata\n\nobject KataSolution {\n    fun maxHexagonBeam(n: Int, seq: Array<Int>): Int {\n        return with(buildHexagon(n, seq)) {\n            listOf(\n                sumHorizontal(this).maxOf { it },\n                sumTopRightBottomLeft(this).maxOf { it },\n                sumTopLeftBottomRight(this).maxOf { it }\n            ).maxOf { it }\n        }\n    }\n\n    private fun buildHexagon(n: Int, seq: Array<Int>): List<List<Int>> {\n        var i = 0\n        return List<List<Int>>(n * 2 - 1) {\n            List<Int>(if (it < n) n + it else n + it - (it - (n - 1)) * 2) {\n                seq[i++ % seq.size]\n            }\n        }\n    }\n\n    private fun sumHorizontal(hexagon: List<List<Int>>): List<Int> = hexagon.map { it.sum() }\n\n    private fun sumTopRightBottomLeft(hexagon: List<List<Int>>): List<Int> {\n        val size = hexagon.first().size\n        return List<Int>(size - 1) { x ->\n            var sum = 0\n            repeat (size + x) { y ->\n                sum += hexagon[y][if (y < size) x else x - (y + 1 - size)]\n            }\n            sum\n        }.append {\n            List<Int>(size) { x ->\n                var sum = 0\n                repeat (size * 2 - 1 - x) { y ->\n                    sum += hexagon[y + x][if (y + x < size) size - 1 + x else size * 2 - 2 - (y + x) + x]\n                }\n                sum\n            }\n        }\n    }\n\n    private fun sumTopLeftBottomRight(hexagon: List<List<Int>>): List<Int> {\n        val size = hexagon.first().size\n        return List<Int>(size - 1) { x ->\n            var sum = 0\n            repeat (size + x) { y ->\n                sum += hexagon[(size * 2 - 2) - y][if ((size * 2 - 2) - y < size - 1) x - (size - 1 - ((size * 2 - 2) - y))  else x]\n            }\n            sum\n        }.append {\n            List<Int>(size) { x ->\n                var sum = 0\n                repeat(size * 2 - 1 - x) { y ->\n                    sum += hexagon[y][if (y < size) y + x else size - 1 + x]\n                }\n                sum\n            }\n        }\n    }\n\n    private fun List<Int>.append(block: () -> List<Int>): List<Int> {\n        return listOf(this, block()).flatten()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208698,"user_id":null,"body":"package kata\n\nobject KataSolution {\n    fun maxHexagonBeam(n: Int, seq: Array<Int>): Int {\n\n        val i = iterator { yieldAll(generateSequence(0, Int::inc).map { seq[it % seq.size] }) }\n        val q = n - 1\n        val hexes = mutableListOf<Pair<Array<Int>, Int>>()\n\n        for (x in -q..q) {\n            for (y in -q..q) {\n                for (z in -q..q) {\n                    if (x + y + z == 0) {\n                        hexes.add(\n                            Pair(\n                                arrayOf(x, y, z),\n                                i.next()\n                            )\n                        )\n                    }\n                }\n            }\n        }\n\n        var max = Int.MIN_VALUE\n        for (k in -q..q) {\n            for (j in 0..2) {\n                val m = hexes.filter { it.first[j] == k }.sumOf { it.second }\n                if (max < m)\n                    max = m\n            }\n        }\n        return max\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208699,"user_id":53,"body":"package kata\nimport kotlin.math.min\nimport kotlin.math.max\n\nobject KataSolution {\n    fun maxHexagonBeam(n: Int, seq: Array<Int>): Int {\n        val ans = IntArray(6 * n - 3) { 0 }\n        var i = -1\n        var q = 1 - n\n        while (q <= n - 1) {\n            var r = max(-n, -q - n) + 1\n            while (r <= min(n, n - q) - 1) {\n                i = (i + 1) % seq.size\n                val s = -q - r\n                val v = seq[i]\n                ans[q + n - 1] += v\n                ans[r + 3 * n - 2] += v\n                ans[s + 5 * n - 3] += v\n                r += 1\n            }\n            q += 1\n        }\n        return ans.fold(ans[0]) { acc, x -> maxOf(acc, x) }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208700,"user_id":null,"body":"package kata\n\nobject KataSolution {\n    fun maxHexagonBeam(n: Int,seq: Array<Int>): Int {\n        var k = 0\n        val s = 2*n-1\n        var summs = IntArray(3*s){0}        \n        var i = 0\n        var j = 0\n        var e = 0        \n        while (i < s) {\n            while (j < s) {\n                if (i+j <= n-2 || i+j > 3*n-3) j++ else {\n                    e = seq[if (k > seq.size-1) 0.also{k=1} else k++]                    \n                    summs[j] = summs[j] + e\n                    summs[s+i] = summs[s+i] + e\n                    summs[2*s+i+j+1-n] = summs[2*s+i+j+1-n] + e                    \n                    j++\n                }                \n            }\n            j=0\n            i++\n        }        \n        return summs.max()?:0\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208701,"user_id":null,"body":"package kata\n\nobject KataSolution {\n    fun maxHexagonBeam(n: Int, seq: Array<Int>): Int {\n        val count = 3 * n * n - 3 * n + 1\n        val seqList = seq.toList()\n        var toList = (1..count \/ seq.size + 1)\n            .fold(mutableListOf<Int>()) { acc, ints -> acc.addAll(seqList);acc }\n            .toList().take(count)\n\n        var index = 0\n        val resultLL1 = mutableListOf<List<Int>>()\n        val resultLL2 = mutableListOf<List<Int>>()\n        val n = n - 1\n        for (i in 0..n) {\n            resultLL1.add(toList.slice(index..index + n + i) + IntArray(n - i).toList())\n            resultLL2.add(IntArray(n - i).toList() + toList.slice(index..index + n + i))\n            index += i + n + 1\n\n        }\n        for (i in n - 1 downTo 0) {\n            resultLL1.add(IntArray(n - i).toList() + toList.slice(index..index + n + i))\n            resultLL2.add(toList.slice(index..index + n + i) + IntArray(n - i).toList())\n            index += i + n + 1\n\n        }\n\n        val result = mutableListOf<Int>()\n        for (i in 0..2 * n) {\n            val sum1 = resultLL1.sumBy { it[i] }\n            val sum2 = resultLL2.sumBy { it[i] }\n            result.add(sum1)\n            result.add(sum2)\n        }\n        val final = resultLL1.map { it.sum() } + result\n\n        return final.reduce { acc, i -> if (acc > i) acc else i }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208702,"user_id":null,"body":"package kata\n\nobject KataSolution {\n    fun maxHexagonBeam(n: Int,seq: Array<Int>): Int {\n    var result = mutableListOf<MutableList<Int>>()\n    var currentIndex = 0\n\n    fun returnLine(k:Int): MutableList<Int>{\n        var resultArray = mutableListOf<Int>()\n\n        for (i in 0 until k){\n            resultArray.add(seq[currentIndex]);currentIndex++\n            if (currentIndex==seq.size) currentIndex=0\n        }\n        return resultArray\n    }\n\n    var index = n\n    for (i in 1 until n*2){\n        result.add(returnLine(index));\n        when {\n            i<n -> index++\n            else-> index--\n        }\n    }\n\n    var indexj = 0\n    var indexj2 = n-1\n    for (i in 0 until 2*n-1){\n        var indexI = i\n        var listnd = mutableListOf<Int>()\n\n        for (j in indexj..indexj2){\n            listnd.add(result[j][indexI])\n            if (j >=n-1) indexI--\n        }\n        result.add(listnd)\n\n        when {\n            i <n-1 -> indexj2++\n            else-> indexj++\n        }\n    }\n    \n    indexj = n-1\n    indexj2 = 2*n-2\n    for (i in 0 until 2*n-1){\n        var indexI = when {\n           i in 0..n-1->0\n            else -> i-(n-1)\n        }\n        var listrd = mutableListOf<Int>()\n\n        for (j in indexj..indexj2){\n            listrd.add(result[j][indexI])\n            if (j < n-1) indexI++\n        }\n        result.add(listrd)\n        when {\n            indexj >0 -> indexj--\n            else-> indexj2--\n        }\n    }\n\n    return result.sortedBy { it.sum() }.last().sum()\n}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208703,"user_id":null,"body":"package kata\n\nobject KataSolution {\n    \n    private lateinit var hexagon: ArrayList<ArrayList<Int>>\n    \n    fun maxHexagonBeam(n: Int,seq: Array<Int>): Int {\n        \n        createHexagon(n, seq)\n        \n        val maxRowSum = hexagon.map { it.sum() }.max() ?: 0\n        val maxDiagSum = getMaxDiagonalSum()\n        \n        return maxOf(maxRowSum, maxDiagSum)\n    }\n    \n    private fun createHexagon(n: Int, seq: Array<Int>) {\n        var k = 0\n        val length = seq.size\n        var rowLength = n\n        \n        hexagon = arrayListOf<ArrayList<Int>>()\n        \n        for (i in 0 until 2 * n - 1) {\n            val row = arrayListOf<Int>()\n            for (j in 0 until rowLength) {\n                row.add(seq[k])\n                k = (k + 1) % length\n            }\n            hexagon.add(row)\n            rowLength += if (i < n - 1) 1 else -1\n        }              \n    }\n    \n    private fun getMaxDiagonalSum(): Int {\n        val height = hexagon.size\n        var up = arrayListOf<ArrayList<Int>>()\n        var down = arrayListOf<ArrayList<Int>>()\n        \n        hexagon.forEachIndexed { i, row ->\n            val pad = (0 until height - row.size).map { 0 }\n            if (i < height \/ 2) {\n                up.add(ArrayList(row + pad))\n                down.add(ArrayList(pad + row))\n            } else {\n                up.add(ArrayList(pad + row))\n                down.add(ArrayList(row + pad))\n            }\n        }\n        \n        val upSumsMax = (up.first().indices).map { i -> up.map { it[i] }.sum() }.max() ?: 0\n        val downSumsMax = (down.first().indices).map { i -> down.map { it[i]}.sum() }.max() ?: 0\n        \n        return maxOf(upSumsMax, downSumsMax)\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208704,"user_id":null,"body":"package kata\n\nobject KataSolution {\n    fun maxHexagonBeam(n: Int,seq: Array<Int>): Int {\n        val lines = getLines(n, seq)\n        val diagonalsLeftToRight = getDiagonalsLeftToRight(lines)\n        val diagonalsRightToLeft = getDiagonals(lines)\n\n        return listOf<Int>(\n            lines.map(List<Int>::sum).max()?:0,\n            diagonalsLeftToRight.map(List<Int>::sum).max()?:0,\n            diagonalsRightToLeft.map(List<Int>::sum).max()?:0\n        ).max()?:0\n    }\n\n    fun getLines(n: Int, seq: Array<Int>): List<List<Int>> {\n        val numberOfLines = n + n - 1\n        val lines = mutableListOf<List<Int>>()\n        var currentSizeOfLine = n\n        var currentIndexInSequence = 0\n        for (i in 0 until numberOfLines) {\n            val line = arrayListOf<Int>()\n\n            if (i <= numberOfLines \/ 2) {\n                currentSizeOfLine++\n            } else {\n                currentSizeOfLine--\n            }\n            for (j in 0 until currentSizeOfLine - 1) {\n                line.add(seq[currentIndexInSequence % seq.size])\n                currentIndexInSequence++\n            }\n            lines.add(line)\n\n        }\n        return lines\n    }\n\n    fun getDiagonals(lines: List<List<Int>>): List<List<Int>> {\n        val diagonals = mutableListOf<List<Int>>()\n        val middleLineIndex = lines.size \/ 2\n        for (i in lines.indices) {\n            val diagonal = arrayListOf<Int>()\n            for (j in lines.indices) {\n                val lineIndex: Int = if (j <= middleLineIndex) i else i - (j - middleLineIndex)\n                lines[j].getOrNull(lineIndex)?.let { diagonal.add(it) }\n            }\n            diagonals.add(diagonal)\n        }\n        return diagonals\n    }\n\n    fun getDiagonalsLeftToRight(lines: List<List<Int>>): List<List<Int>> {\n        val diagonals = mutableListOf<List<Int>>()\n        val middleLineIndex = lines.size \/ 2\n        for (i in lines.indices) {\n            val diagonal = arrayListOf<Int>()\n            for (j in lines.indices) {\n                val lineIndex: Int = if (j > middleLineIndex) i else i + j - middleLineIndex\n                lines[j].getOrNull(lineIndex)?.let { diagonal.add(it) }\n            }\n            diagonals.add(diagonal)\n        }\n        return diagonals\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208705,"user_id":null,"body":"package kata\nimport kotlin.math.abs\n\nobject KataSolution {\n\n    data class Hex(val r: Int, val q: Int)\n    data class Cube(val x: Int, val y: Int, val z: Int)\n\n    fun Cube.rotate() = Cube(-z, -x, -y)\n\n    fun Hex.toCube() = Cube(q, r, -q - r)\n    fun Cube.toHex() = Hex(x, z)\n\n    interface CubeHexagon {\n        val size: Int\n        val rRange: IntRange\n        fun qRange(r: Int): IntRange\n        operator fun get(h: Hex): Int\n        operator fun get(c: Cube): Int = get(c.toHex())\n    }\n\n    fun CubeHexagon.beamValue(r: Int) = qRange(r).sumBy { this[Hex(r, it)] }\n\n    fun CubeHexagon.maxBeamValue() = rRange.map { beamValue(it) }.max()!!\n\n    fun CubeHexagon.maxOverallBeamValue() =\n            sequenceOf(maxBeamValue(), rotated().maxBeamValue(), rotated().rotated().maxBeamValue()).max()!!\n\n    fun CubeHexagon.rotated() = object : CubeHexagon {\n        val original = this@rotated\n        override val size: Int\n            get() = original.size\n        override val rRange: IntRange\n            get() = original.rRange\n\n        override fun qRange(r: Int): IntRange = original.qRange(r)\n\n        override fun get(h: Hex): Int =\n                original[h.toCube().rotate().toHex()]\n\n        override fun get(c: Cube): Int =\n                original[c.rotate()]\n    }\n\n    fun CubeHexagon.print() {\n        for (r in rRange) {\n            print(r.toString().padStart(2, ' '))\n            print(\" \" + \" \".repeat(abs(r)))\n            for (q in qRange(r)) {\n                print(this[Hex(r, q)])\n                print(\" \")\n            }\n            print(\" \".repeat(abs(r)))\n            println(beamValue(r))\n        }\n        println(maxBeamValue())\n    }\n\n    fun maxHexagonBeam(n: Int, seq: Array<Int>): Int =\n        SeqCubeHexagon(n, seq).maxOverallBeamValue()\n\n    class SeqCubeHexagon(override val size: Int, private val seq: Array<Int>) : CubeHexagon {\n\n        private val maxDistance = size - 1\n\n        override val rRange = -maxDistance..maxDistance\n\n        override fun qRange(r: Int) = if (r <= 0)\n            (-maxDistance - r..maxDistance)\n        else\n            (-maxDistance..maxDistance - r)\n\n        override operator fun get(h: Hex): Int {\n            val offset =\n                    rRange.filter { it < h.r }.sumBy { qRange(it).let { it.last - it.first + 1 } } +\n                            h.q - qRange(h.r).first\n            return seq[offset % seq.size]\n        }\n\n    }\n\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5ef9ca8b76be6d001d5e1c3e":[{"id":208706,"user_id":null,"body":"package algos\n\nfun encode(s: String) = s\n    .map { it.toInt().toString(2).padStart(8,'0')\n        .fold(\"\") {acc, c -> acc + c.toString().repeat(3) } }\n    .joinToString(\"\")\n\nfun decode(input: String): String {\n    return input.chunked(3)\n        .map { bitsToCorrect -> if (bitsToCorrect.count {it == '0'} > 1) '0' else '1' }\n        .joinToString(\"\")\n        .chunked(8)\n        .map { Integer.parseInt(it, 2).toChar() }\n        .joinToString(\"\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208707,"user_id":null,"body":"package algos\n\nfun encode(text: String): String = text\n    .map(Char::toInt)\n    .map(Integer::toBinaryString)\n    .map { it.padStart(8, '0') }\n    .flatMap { it.map { \"$it$it$it\" } }\n    .joinToString(\"\")\n\nfun decode(bits: String): String = bits\n    .withIndex().groupBy { it.index \/ 3 }\n    .values.map { if (it.count { it.value == '0' } > 1) '0' else '1' }\n    .withIndex().groupBy { it.index \/ 8 }\n    .map { it.value.fold(\"\") { acc, indexedValue -> acc.plus(indexedValue.value) } }\n    .map { Integer.parseInt(it, 2) }\n    .map { it.toChar() }\n    .joinToString(\"\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208708,"user_id":null,"body":"package algos\n\nfun encode(text: String): String {\n    return text\n        .toByteArray(Charsets.US_ASCII)\n        .flatMap {\n            it\n                .toString(2)\n                .padStart(8, '0')\n                .map { c -> c.toString().repeat(3) }\n        }\n        .joinToString(separator = \"\")\n}\n\nfun decode(bits: String): String {\n    return bits\n        .chunked(3) { if (it.count { c -> c == '1' } > 1) '1' else '0' }\n        .chunked(8) { String(it.toCharArray()).toByte(2) }\n        .let { String(it.toByteArray(), Charsets.US_ASCII) }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208709,"user_id":null,"body":"package algos\n\nfun encode(text: String): String {\n    var result = \"\"\n    for (symbol in text) {\n        for (bit in symbol.toBinary()) {\n            result += bit.repeat(3)\n        }\n    }\n    return result;\n}\n\nfun decode(bits: String): String {\n    var auxiliaryString = StringBuilder()\n    var resultString = StringBuilder()\n    for (str in bits.chunked(3)) {\n        val count = str.chars().filter{char -> char == 48}.count()\n        if (count >=2) auxiliaryString.append(\"0\") else auxiliaryString.append(\"1\")\n    }\n    for (str in auxiliaryString.toString().chunked(8)) {\n        resultString.append(str.toLong().convertBinaryToDecimal().toChar())\n    }\n    return resultString.toString()\n}\n\n\nfun Char.toBinary(): String {\n    var binaryStr = this.toInt().toString(2)\n    while (binaryStr.length <8) {\n        binaryStr = \"0\" + binaryStr\n    }\n    return binaryStr\n}\n\nfun Char.repeat(n: Int) : String {\n    val sb = StringBuilder()\n    for (i in 1..n) {\n        sb.append(this)\n    }\n    return sb.toString()\n}\n\nfun Long.convertBinaryToDecimal(): Int {\n    var num = this\n    var decimalNumber = 0\n    var i = 0\n    var remainder: Long\n\n    while (num.toInt() != 0) {\n        remainder = num % 10\n        num \/= 10\n        decimalNumber += (remainder * Math.pow(2.0, i.toDouble())).toInt()\n        ++i\n    }\n    return decimalNumber\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208710,"user_id":null,"body":"package algos\n\nfun encode(text: String): String {\n    return text.map {\n        Integer.toBinaryString(it.toInt()).run {\n            \"0\".repeat(8 - count()) + this\n        }.map { c -> \"$c\".repeat(3)}.joinToString(\"\")\n    }.joinToString(\"\")\n}\n\nfun decode(bits: String): String {\n    return bits.windowed(size = 3, step = 3).joinToString(\"\") {\n        if (it.count { c-> c == '1' } > 1) \"1\" else \"0\"\n    }.windowed(size = 8, step = 8).map {\n        Integer.parseInt(it, 2).toChar()\n    }.joinToString(\"\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208711,"user_id":null,"body":"package algos\n\nfun encode(text: String): String {\n    val bits = text.flatMap{it.toInt()\n            .toString(2)\n            .padStart(8, '0')\n            .map{\"$it$it$it\"}}\n            .joinToString(separator=\"\")\n    return bits;\n}\n\nfun decode(bits: String): String {\n    val getCorrectedBit: (String) -> String = {bitsToCorrect: String -> if (bitsToCorrect.count{it == '0'} > 1) \"0\" else \"1\"};\n    val text = bits.chunked(3)\n            .map{getCorrectedBit(it)}\n            .joinToString(separator=\"\")\n            .chunked(8)\n            .map{it.toInt(2)}\n            .map{it.toChar()}\n            .joinToString(separator=\"\");\n    return text;\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208712,"user_id":null,"body":"package algos\n\nfun encode(text: String) = text.map {it -> it.toInt().toString(2).padStart(8,'0').replace(\"0\",\"000\").replace(\"1\",\"111\")}.joinToString(\"\")\n    \n \n\nfun decode(bits: String): String {\n    var text: String = \"\"\n    \n    bits.chunked(3).forEach {\n        if (it == \"110\" || it == \"101\" || it == \"011\" || it == \"111\") {\n            text = text + \"1\"\n        } else {\n            text = text + \"0\"\n        }\n    }\n    \n    return text.chunked(8).map {it -> it.toInt(2).toChar()}.joinToString(\"\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208713,"user_id":null,"body":"package algos\n\nfun encode(bits: String)=bits.map{it.code.toString(2)}.map { \"0\".repeat(8-it.length)+it}.joinToString(\"\") {it.map{ch->ch.toString().repeat(3)}.joinToString(\"\")}\n\nfun decode(bits: String) =   bits.chunked(3).joinToString(\"\"){if(it.count{ inner->inner=='0'}>1) \"0\" else \"1\" }.chunked(8).map{ it.toCharArray().joinToString(\"\") { ch->ch.toString() }.toInt(2).toChar() }.joinToString (\"\")\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208714,"user_id":null,"body":"package algos\n\nfun encode(text: String) = text.map{ ch ->\n    ch.code.toString(2).padStart(8, '0').map{\n        it.toString().repeat(3)\n    }.joinToString(\"\")\n}.joinToString(\"\")\n    \nfun decode(bits: String) = bits.chunked(3).map{\n    it.groupBy{ it }.maxByOrNull{ it.value.size}?.key ?: '0' \n}.joinToString(\"\").chunked(8).map{ it.toInt(2).toChar() }.joinToString(\"\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208715,"user_id":null,"body":"package algos\n\nfun encode(text: String): String = text.flatMap { c ->\n    c.code.toString(2)\n        .padStart(8, '0')\n        .map { \"$it\".repeat(3) }\n    }.joinToString(\"\")\n\nfun decode(bits: String): String = bits.chunked(3)\n    .map { bit -> if (bit.count { it == '1' } > 1) '1' else '0' }\n    .chunked(8)\n    .map { Integer.parseInt(it.joinToString(\"\"), 2).toChar() }\n    .joinToString(\"\")","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5efae11e2d12df00331f91a6":[{"id":208716,"user_id":null,"body":"package algos\nimport java.math.BigInteger\nimport java.security.MessageDigest\n\nfun crack(hash: String): String {\n    return (0..99999).map { it.toString().padStart(5, '0') }.first {\n        BigInteger(1, MessageDigest.getInstance(\"MD5\").digest(it.toByteArray())).toString(16).padStart(32, '0') == hash\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208717,"user_id":null,"body":"package algos\n\nimport java.math.BigInteger\nimport java.security.MessageDigest\n\nfun String.md5(): String {\n    val md = MessageDigest.getInstance(\"MD5\")\n    return BigInteger(1, md.digest(toByteArray())).toString(16).padStart(32, '0')\n}\n\nfun crack(hash: String): String = (0..99999).asSequence()\n    .map{it.toString().padStart(5, '0')}\n    .filter{it.md5() == hash}\n    .first()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208718,"user_id":null,"body":"package algos\n\nimport java.lang.Exception\nimport java.math.BigInteger\nimport java.security.MessageDigest\n\nval md: MessageDigest = MessageDigest.getInstance(\"MD5\")\n\nfun md5(s: String): String {\n    return BigInteger(1, md.digest(s.toByteArray())).toString(16).padStart(32, '0')\n}\n\nfun crack(hash: String): String {\n    for (pin in 0..99999) {\n        val pinS = String.format(\"%05d\", pin)\n        if (md5(pinS) == hash) {\n            return pinS\n        }\n    }\n    throw Exception(\"The hash it not of a pin between 0 and 99999\")\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208719,"user_id":null,"body":"package algos\n\nimport java.math.BigInteger\nimport java.security.MessageDigest\n\nfun md5(input:String): String {\n    val md = MessageDigest.getInstance(\"MD5\")\n    return BigInteger(1, md.digest(input.toByteArray())).toString(16).padStart(32, '0')\n}\n\nfun crack(hash: String): String {\n    for (i in 0..99999) {\n        if(md5(i.toString().padStart(5, '0')) == hash) return i.toString().padStart(5, '0')\n    }\n    return \"\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208720,"user_id":null,"body":"package algos\n\nimport java.math.BigInteger\nimport java.security.MessageDigest\n\nfun crack(hash: String): String {\n    for (i in 0..100000) {\n        val sus = i.toString().padStart(5, '0')\n        if (md5(sus) == hash) return sus\n    }\n    return \"\"\n}\n\nfun md5(input:String): String {\n    val md = MessageDigest.getInstance(\"MD5\")\n    return BigInteger(1, md.digest(input.toByteArray())).toString(16).padStart(32, '0')\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208721,"user_id":null,"body":"package algos\nimport java.math.BigInteger\nimport java.security.MessageDigest\n\nfun crack(hash: String): String {\n    val md = MessageDigest.getInstance(\"MD5\")\n    val result = (0..99999).map { it.toString().padStart(5, '0')}.first{\n        hash == String.format(\"%032x\", BigInteger(1, md.digest(it.toByteArray(Charsets.UTF_8))))\n    }\n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208722,"user_id":null,"body":"package algos\nimport java.math.BigInteger\nimport java.security.MessageDigest\nfun md5Hash(str: String): String {\n    val md = MessageDigest.getInstance(\"MD5\")\n    val bigInt = BigInteger(1, md.digest(str.toByteArray(Charsets.UTF_8)))\n    return String.format(\"%032x\", bigInt)\n}\nfun crack(hash: String): String {\n    for(i in 0..99999){\n        val test = \"0\".repeat(5-i.toString().length)+i.toString()\n        if(md5Hash(test)==hash)\n            return test\n    }\n    return \"\"\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208723,"user_id":null,"body":"package algos\n\nimport java.math.BigInteger\nimport java.security.MessageDigest\n\nfun crack(hash: String): String {\n    var result = \"\"\n    \n    for (i in 0..99999) {\n        var pin = if (i < 10) \"0000$i\"\n        else if (i < 100) \"000$i\"\n        else if (i < 1000) \"00$i\"\n        else if (i < 10000) \"0$i\"\n        else i.toString()\n        \n        if (md5(pin) == hash) {\n            result = pin\n            break\n        }\n    }\n    return result\n}\n\nfun md5(input:String): String {\n    val md = MessageDigest.getInstance(\"MD5\")\n    return BigInteger(1, md.digest(input.toByteArray())).toString(16).padStart(32, '0')\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208724,"user_id":null,"body":"package algos\n\nimport java.nio.charset.StandardCharsets.UTF_8\nimport java.security.MessageDigest\n\nfun crack(hash: String) : String {\n    for (i in 0 .. 99999) {\n        val pin = i.toString().padStart(5, '0')\n        if (md5(pin) == hash) {\n            return pin\n        }\n    }\n\n    return \"\"\n}\n\nfun md5(str: String) = MessageDigest\n    .getInstance(\"MD5\")\n    .digest(str.toByteArray(UTF_8))\n    .joinToString(separator = \"\") { \n        byte -> \"%02x\".format(byte)\n    }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208725,"user_id":null,"body":"package algos\nimport java.nio.charset.StandardCharsets.UTF_8\nimport java.security.MessageDigest\n\nfun crack(hash: String) : String {\n    for (i in 0 .. 99999) {\n        val pin = i.toString().padStart(5, '0')\n        if (md5(pin).toHex() == hash) {\n            return pin\n        }\n    }\n\n    return \"\"\n}\n\nfun md5(str: String): ByteArray = MessageDigest.getInstance(\"MD5\").digest(str.toByteArray(UTF_8))\nfun ByteArray.toHex() = joinToString(separator = \"\") { byte -> \"%02x\".format(byte) }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5f0ed36164f2bc00283aed07":[{"id":208726,"user_id":null,"body":"fun overTheRoad(address: Int, n: Int): Int = n * 2 + 1 - address\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208727,"user_id":null,"body":"fun overTheRoad(address: Int, n: Int) = n*2-address+1","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208728,"user_id":527,"body":"fun overTheRoad(address: Int, n: Int) = 2 * n + 1 - address","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208729,"user_id":null,"body":"fun overTheRoad(address: Int, n: Int): Int {\n  \/\/code here\n    return (n*2)+1-address;\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208730,"user_id":null,"body":"fun overTheRoad(address: Int, n: Int): Int {\n    return n*2 - address + 1\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208731,"user_id":null,"body":"val overTheRoad : (Int, Int) -> Int = { a, b -> b*2 - (a-1)}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208732,"user_id":null,"body":"val overTheRoad: (Int,Int)->Int = {a,n -> n*2-a+1}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208733,"user_id":null,"body":"fun overTheRoad(address: Int, n: Int): Int {\n  \n    var result = (n*2)-address+1\n    return result\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208734,"user_id":null,"body":"fun overTheRoad(address: Int, n: Int): Int {\n    val positionOdd : Int\n    val positionEven : Int\n    return when {\n        address % 2 != 0 -> {\n            positionOdd = (address + 1) \/ 2\n            positionEven = n - positionOdd + 1\n            positionEven * 2\n        }\n        else -> {\n            positionEven = address \/ 2\n            positionOdd = n - positionEven + 1\n            (positionOdd * 2) - 1\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208735,"user_id":null,"body":"fun overTheRoad(address: Int, n: Int) = 2 * n - address + 1\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5f8fb3c06c8f520032c1e091":[{"id":208736,"user_id":null,"body":"package kata\n\nclass Blobservation(private var matrix: Array<IntArray>) {\n  fun read(instructions: String) =\n    instructions.forEach { instruction ->\n      when (instruction) {\n        'W' -> matrix = merge(matrix) { it }\n        'E' -> matrix = merge(matrix) { it.reversed().toIntArray() }.map { it.reversed().toIntArray() }.toTypedArray()\n        'N' -> matrix = merge(matrix.transpose()) { it }.transpose()\n        'S' -> matrix = merge(matrix.transpose()) { it.reversed().toIntArray() }.map { it.reversed().toIntArray() }.toTypedArray().transpose()\n      }\n    }\n\n  private fun merge(matrix: Array<IntArray>, transformer: (IntArray) -> IntArray): Array<IntArray> {\n    val merged = matrix.map {\n      val filtered = transformer(it)\n        .toList()\n        .filter { v -> v != 0 }\n\n      filtered\n        .zipWithNext()\n        .fold(listOf(filtered.first())) { acc, pair ->\n          if (pair.first > pair.second) acc.dropLast(1) + listOf(acc.last() + pair.second)\n          else acc + listOf(pair.second)\n        }\n    }\n\n    return merged.map { padRight((merged.maxBy { v -> v.size } ?: listOf()).size, it.toIntArray()) }.toTypedArray()\n  }\n\n  private fun padRight(toSize: Int, array: IntArray): IntArray = array + (1..toSize - array.size).map { 0 }\n\n  fun state(): Array<IntArray> {\n    return matrix\n  }\n}\n\nfun Array<IntArray>.transpose(): Array<IntArray> {\n  val rowSize = this.size\n  val columnSize = this.first().size\n\n  val transpose = Array(columnSize) { IntArray(rowSize) }\n  (0 until rowSize).forEach { i ->\n    (0 until columnSize).forEach { j ->\n      transpose[j][i] = this[i][j]\n    }\n  }\n\n  return transpose\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208737,"user_id":null,"body":"package kata\n\nclass Blobservation(private var matrix: Array<IntArray>) {\n    \n    private var grid = matrix.map { it.toList() }\n    \n    fun read(instructions: String) { \n        \n        for (d in instructions) {\n            grid = cleanMatrix(when (d) {                \n                'E' -> grid.map { tilt(it) }\n                'W' -> grid.map { tilt(it.reversed()).reversed() }\n                else -> handleVerticalTilt(grid, d)\n            })            \n        }                \n    }\n    \n    fun state(): Array<IntArray> = grid.map { it.toIntArray() }.toTypedArray()\n    \n}\n\nfun tilt(list: List<Int>): List<Int>{\n    val arr = moveZeros(list)\n    \n    var sums = mutableListOf<Int>()\n    var tempSum = 0\n    var current = 0\n    \n    for (item in arr) {\n    \n        if (item == 0) continue\n        \n        if (item > current) {\n            tempSum += item                        \n        } else {\n            sums.add(tempSum)\n            tempSum = item                        \n        }\n        current = item\n    }\n    sums.add(tempSum)\n    \n    while (sums.size < arr.size) {\n        sums.add(0, 0)\n    }\n    return moveZeros(sums)\n}\n\nfun handleVerticalTilt(grid: List<List<Int>>, direction: Char): List<List<Int>> {\n    val rows = grid.size\n    val columns = grid[0].size\n            \n    var res = List(rows, { MutableList(columns, {0})})\n    for (j in 0 until columns) {\n        val col = if (direction == 'S') tilt(grid.map { it[j] }) else tilt(grid.map { it[j] }.reversed()).reversed()\n        res = res.mapIndexed { i, row -> \n            row[j] = col[i] \n            row\n        } \n    }\n    return res\n}\n\nfun moveZeros(list: List<Int>): List<Int> {\n    val nonZeros = list.filter { it != 0 }\n    return List(list.size - nonZeros.size, { 0 }).plus(nonZeros)\n}\n\nfun cleanMatrix(list: List<List<Int>>): List<List<Int>> {\n    var res = list.map { it.toMutableList()}.toMutableList()\n    while (true) {\n        val i = res.indexOfFirst { row -> row.all { it == 0} }\n        if (i < 0) break\n        res.removeAt(i)\n    }\n    \n    while (true) {\n        lateinit var temp : MutableList<MutableList<Int>>\n        var deleted = false\n        \n        for (j in 0 until res[0].size) {\n            val col = res.map { it[j] }\n            if (col.any { it != 0 }) continue\n            deleted = true\n            temp = res.map { row ->\n                row.filterIndexed { col, _ -> col != j}.toMutableList()\n            }.toMutableList()                        \n        }\n        if (!deleted) break\n        res = temp        \n    }\n    return res\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208738,"user_id":470,"body":"package kata\n\nclass Blobservation(_r: Array<IntArray>) {\n\tvar west = 0\n\tvar nort = 1\n\tvar tiltDir = 0\n\tvar tiltDup = false\n\tvar grid = _r.map { it.toMutableList() }.toMutableList()\n\t\n\tfun read(s: String) {\n\t\tfor (d in s) {\n\t\t\tif (grid.size == 1 && grid[0].size == 1) break\n\t\t\tproc(d)\n\t\t\ttiltDir = dnum.get(d)!!\n\t\t\tif (tilt()) tiltDup = false\n\t\t}\n\t}\n\t\n\tfun state(): Array<IntArray> {\n\t\tval maxLn = grid.map { it.size }.max()!!\/\/ max deprecated and replaced by maxOrNull in Kotlin 1.4\n\t\tvar r = grid.map { (it + List(maxLn-it.size) { 0 }).toMutableList() }.toMutableList()\n\t\tif (west and 1 == 1) {\n\t\t\tif (west == 1) {\n\t\t\t\tif (west shr 1 == nort shr 1) r = transpose(r)\n\t\t\t\telse  r = transpose(r).let { flip(it) } }\n\t\t\telse if (nort > 0) r = flip(r).let { transpose(it) }.let { flip(it) }\n\t\t\telse r = flip(r).let { transpose(it) } }\n\t\telse {\n\t\t\tif (west > 0) r = flip(r)\n\t\t\tif (nort shr 1 == 1) r.reverse() }\n\t\treturn r.map { it.toIntArray() }.toTypedArray()\n\t}\n\t\n\tprivate fun proc(d: Char) {\n\t\tval v = dnum.get(d)!!\n\t\tif (v == tiltDir && tiltDup) return\n\t\twhen {\n\t\t\tv == west -> Unit\n\t\t\tv and 1 == west and 1 -> flip()\n\t\t\tv == nort -> transpose()\n\t\t\telse -> { transpose(); flip() }\n\t\t}\n\t}\n\t\n\tprivate fun tilt(): Boolean {\n\t\tval nr = mutableListOf<MutableList<Int>>()\n\t\tvar action = false\n\t\tfor (row in grid) {\n\t\t\tvar cv = row.first()\n\t\t\tval cr = mutableListOf(cv)\n\t\t\tfor (nv in row.drop(1)) {\n\t\t\t\tif (cv > nv) {\n\t\t\t\t\taction = true\n\t\t\t\t\tcr[cr.size-1] += nv }\n\t\t\t\telse cr.add(nv)\n\t\t\t\tcv = nv }\n\t\t\tnr.add(cr)\n\t\t}\n\t\tif (action) grid = nr\n\t\treturn action\n\t}\n\t\n\tprivate fun flip(r: MutableList<MutableList<Int>> = grid): MutableList<MutableList<Int>> {\n\t\tr.forEach { it.reverse() }\n\t\tif (r === grid) west = (west + 2) % 4\n\t\treturn r\n\t}\n\t\n\tprivate fun transpose(r: MutableList<MutableList<Int>> = grid): MutableList<MutableList<Int>> {\n\t\tval nr = MutableList(grid.map { it.size }.max()!!, { mutableListOf<Int>() })\n\t\tr.forEach { it.forEachIndexed { c,v -> nr[c].add(v) } }\n\t\tif (r === grid) {\n\t\t\tgrid = nr\n\t\t\twest = nort.also { nort = west } }\n\t\treturn nr\n\t}\n\t\n\tprivate val dnum = mapOf('N' to 1,'S' to 3,'E' to 2,'W' to 0)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"60a94f1443f8730025d1744b":[{"id":208739,"user_id":null,"body":"package kata\n\nobject Kata {\n    fun grid(n: Int) = if (n < 0) null\n    else (0 until n).joinToString(\"\n\") { generateSequence('a') { it.inc().takeIf { it <= 'z' } ?: 'a' }.drop(it).take(n).joinToString(\" \") }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208740,"user_id":null,"body":"package kata\n\nobject Kata {\n    fun grid(n: Int): String? = if (n < 0) null else (0 until n)\n        .joinToString(\"\n\") {\n            generateSequence(\n                (it % 26 + 'a'.code).toChar()\n            ) { c ->\n                ((c.code - 'a'.code + 1) % 26 + 'a'.code).toChar()\n            }.take(n).joinToString(\" \")\n        }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208741,"user_id":null,"body":"package kata\n\nobject Kata {\n\n    private const val ALPHABET = \"abcdefghijklmnopqrstuvwxyz\"\n\n    fun grid(n: Int): String? {\n        if (n < 0) return null\n\n        val str = java.lang.StringBuilder()\n        for (row in 0 until n) {\n            for (col in 0 until n) {\n                str.append(ALPHABET[(row + col) % ALPHABET.length])\n                if (col < n - 1) str.append(\" \")\n            }\n            if (row < n - 1) str.append(\"\n\")\n        }\n\n        return str.toString()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208742,"user_id":null,"body":"package kata\n\nobject Kata {\n    val alphabet = ('a'..'z').toList()\n    fun grid(n: Int): String? = when{\n        n >= 0 ->\n            (0 until n)\n                .map { oIt -> (oIt until oIt + n).map{ alphabet[it % alphabet.size]}.joinToString(\" \")}\n                .joinToString(\"\n\")\n        else -> null\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208743,"user_id":470,"body":"package kata\n\nobject Kata {\n\tfun grid(n: Int): String? = if (n < 0) null else (0 until n).map { i -> (0 until n).map { j -> abc[(i+j)%26] }.joinToString(\" \") }.joinToString(\"\n\")\n\tprivate val abc: String = \"abcdefghijklmnopqrstuvwxyz\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208744,"user_id":null,"body":"package kata\n\nobject Kata {\nfun grid(n: Int): String? {\n    if (n < 0) return null\n    val abc = \"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\"\n    val a = Array(n) { Array(n) { \"\" } }\n    for (i in 0 until n) {\n        for (j in 0 until n) {\n            a[i][j] = if (i != 0 && j == 0) \"\n${abc[j + i]}\" else abc[j + i].toString()\n        }\n    }\n    return a.joinToString(\"\") { it.joinToString(\" \") }\n}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208745,"user_id":null,"body":"package kata\n\nobject Kata {\n    fun grid(n: Int): String? = when {\n        n < 0 -> null\n        n == 0 -> \"\"\n        else -> (0 until n * 2 - 1).map { (it % 26 + 97).toChar() }\n        .windowed(size = n, step = 1).joinToString(separator = \"\n\") { it.joinToString(separator = \" \") }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208746,"user_id":null,"body":"package kata\n\nobject Kata {\n\tfun grid(n: Int): String? {\n\t\tval a = \"abcdefghijklmnopqrstuvwxyz\"\n    var str: String? = if (n >= 0) \"\" else null\n    var diff: Int\n    for (i in 0 until n) {\n        for (j in 0 until n) {\n            diff = i + j\n            while (diff > 25) {\n                diff -= 26\n            }\n            str += a[diff] + \" \"\n        }\n        str = str?.dropLast(1)\n        if (i != n - 1) {\n            str += \"\n\"\n        }\n    }\n    return str\n\t}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208747,"user_id":null,"body":"package kata\n\nobject Kata {\n    fun grid(n: Int): String? {\n        if (n < 0) return null\n\t\tvar result: String = \"\"\n        for (i in 0..n-1) {\n            for (j in 0..n-1) {\n               result += (97+(j+i)%26).toChar() + \" \" \n            }\n            result = result.dropLast(1) + \"\n\"\n        }\n        return result.dropLast(1)\n\t} \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208748,"user_id":null,"body":"object Kata {\n    fun grid(n: Int): String? = when {\n        n<0 -> null\n        n==0 -> \"\"\n        else -> Array(n) { i ->\n                Array(n) { j->\n                    'a'.plus((i+j).mod(26))\n                }.joinToString (separator = \" \")\n            }.joinToString (separator = \"\n\")\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"61123a6f2446320021db987d":[{"id":208749,"user_id":531,"body":"fun prevMultOfThree(n: Int): Int? = when{\n    n == 0 -> null\n    n % 3 == 0 -> n\n    else -> prevMultOfThree(n \/ 10)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208750,"user_id":null,"body":"fun prevMultOfThree(n: Int): Int? = if (n % 3 == 0) n else \"$n\".dropLast(1).takeIf { it.isNotEmpty() }?.let { prevMultOfThree(it.toInt()) }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208751,"user_id":null,"body":"fun prevMultOfThree(n: Int): Int? = n.toString().run {\n    for (i in indices) dropLast(i).toInt().run { if (this % 3 == 0) return this }\n    null\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208752,"user_id":null,"body":"fun prevMultOfThree(n: Int): Int? {\n    var multi3Dig = n\n    while (multi3Dig % 3 != 0) {\n        multi3Dig \/= 10\n        println(multi3Dig)\n    }\n    if (multi3Dig > 0) return multi3Dig\n    return null\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208753,"user_id":null,"body":"fun prevMultOfThree(n: Int): Int? {\n    var str: String = n.toString()\n    while(str.length > 0) {\n        if((str.toInt() % 3) == 0){\n            return str.toInt()\n        }\n        str = str.dropLast(1)\n    }\n    return null\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208754,"user_id":null,"body":"fun prevMultOfThree(n: Int): Int? {\n    val s = n.toString()\n    for (i in s.indices) {\n        val num = s.dropLast(i).toInt()\n        if (num % 3 == 0) return num\n    }\n\n    return null\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208755,"user_id":null,"body":"\nfun prevMultOfThree(n: Int): Int? = when {\n       n % 3 == 0 -> n\n       n < 10 -> null\n       else -> prevMultOfThree(n\/10)\n   }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208756,"user_id":527,"body":"fun prevMultOfThree(n: Int): Int? =\n    generateSequence(n) { it \/ 10 }\n        .find { it % 3 == 0 }\n        .let { if (it == 0) null else it }\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208757,"user_id":null,"body":"fun prevMultOfThree(n: Int): Int? {\n    var number = n\n    for (i in n.toString().indices) {\n        if (number % 3 == 0) {\n            return number\n        } else {\n            number = n.toString().dropLast(i).toInt()\n        }\n    }\n    return if (number % 3 != 0 && n % 3 != 0) null else number\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208758,"user_id":null,"body":"fun prevMultOfThree(n: Int): Int? {\n    var result = n\n    while (result != 0) {\n        if (result % 3 == 0) return result\n        else {\n            result \/= 10\n        }\n    }\n    return null\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5470c635304c127cad000f0d":[{"id":208759,"user_id":null,"body":"import org.junit.Test\n\nimport java.*\nimport java.util.stream.Collectors\nimport java.util.stream.IntStream\n\ndata class ParseError(override val message: String) : Throwable()\n\nfun matchBrackets(input: String): Map<Int, Int> {\n    val res = mutableMapOf<Int, Int>()\n    val seen = mutableListOf<Int>()\n    for (i in input.indices) {\n        if (input[i] == '(') {\n            seen += i\n        }\n        if (input[i] == ')') {\n            if (seen.isEmpty()) {\n                throw ParseError(\") with no corresponding (\")\n            }\n            val p = seen.removeLast()\n            res[p] = i\n        }\n    }\n    return res\n}\n\nfun parseRegExp(input: String): RegExp {\n    if (input.isEmpty()) {\n        return Void()\n    }\n    val mb = matchBrackets(input)\n    if (input[0] in \"*\") {\n        throw ParseError(\"invalid input ${input[0]}\")\n    }\n    val subs = mutableListOf<RegExp?>()\n    var i = 0\n    while (i < input.length) {\n        val c = input[i]\n        if (c == '(') {\n            val j = mb[i] ?: throw ParseError(\"error matching (\")\n            subs.add(parseRegExp(input.substring(i + 1, j)))\n            i = j\n        } else if (c == '.') {\n            subs.add(Any())\n        } else if (c == '*') {\n            if (subs.isEmpty()) {\n                throw ParseError(\"expecting element before * $input:$i\")\n            }\n            val e = subs.removeLast()\n            if (e is ZeroOrMore) {\n                throw ParseError(\"** found\")\n            }\n            subs.add(ZeroOrMore(e!!))\n        } else if (c == '|') {\n            if (subs.isEmpty()) {\n                throw ParseError(\"expecting element before | $input:$i\")\n            }\n            subs.add(null)\n        } else {\n            var next: RegExp = Normal(c)\n            if (i < input.length - 1) {\n                if (input[i + 1] == '*') {\n                    next = ZeroOrMore(next)\n                    i++\n                }\n            }\n            subs.add(next)\n        }\n        ++i\n    }\n    if (subs.size == 1) {\n        return subs[0]!!\n    }\n    if (subs.count { it == null } > 1) {\n        throw ParseError(\"More then 1 |\")\n    }\n    val o = subs.indexOf(null)\n    if (o != -1) {\n        val s1 = subs.subList(0, o).filterNotNull()\n        val s2 = subs.subList(o + 1, subs.size).filterNotNull()\n        if (s2.isEmpty()) {\n            throw ParseError(\"Expecting expression after |\")\n        }\n        val s1a = if (s1.size == 1) {\n            s1[0]\n        } else {\n            Str(s1)\n        }\n        val s2a = if (s2.size == 1) {\n            s2[0]\n        } else {\n            Str(s2)\n        }\n        return Or(s1a, s2a)\n    }\n    return Str(subs.filterNotNull())\n}\n\nclass RegExpParser(private val input: String) {\n\n    fun parse(): RegExp {\n        try {\n            return parseRegExp(input)\n        } catch (e: ParseError) {\n            println(e.message)\n            return Void()\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208760,"user_id":null,"body":"class RegExpParser(input: String) {\n    private var element: Sub = Sub(null)\n    private var isValidator: Boolean = true\n\n    init {\n        var currentElement = element\n        loop@ for (c in input) {\n            when (c) {\n                '(' -> {\n                    val child = Sub(currentElement)\n                    currentElement.subEle.add(child)\n                    currentElement = child\n                }\n                ')' -> {\n                    val parent = currentElement.parent\n\n                    if (parent != null) {\n                        if (parent.type == Sub.subType.Or) {\n                            if (parent.parent == null) {\n                                isValidator = false\n                                break@loop\n                            } else {\n                                currentElement = parent.parent!!\n                            }\n                        } else {\n                            currentElement = parent\n                        }\n                    } else {\n                        isValidator = false\n                        break@loop\n                    }\n                }\n                '|' -> {\n                    val newRoot = Sub(currentElement.parent, Sub.subType.Or)\n                    val nextElement = Sub(newRoot, Sub.subType.Str)\n                    val oldParent = currentElement.parent\n                    currentElement.parent = newRoot\n                    newRoot.subEle.add(currentElement)\n                    newRoot.subEle.add(nextElement)\n\n                    if (oldParent == null)\n                        element = newRoot\n                    else {\n                        if (oldParent.type == Sub.subType.Or) {\n                            isValidator = false\n                            break@loop\n                        }\n                        for ((index, value) in oldParent.subEle.withIndex()) {\n                            if (value == currentElement) {\n                                oldParent.subEle[index] = newRoot\n                                break\n                            }\n                        }\n                    }\n                    currentElement = nextElement\n                }\n                '.' -> currentElement.subEle.add(Sub(currentElement, Sub.subType.Any))\n                '*' -> {\n                    if (currentElement.type == Sub.subType.Normal) {\n                        if (currentElement.type == Sub.subType.ZeroOrMore) {\n                            isValidator = false\n                            break@loop\n                        }\n                        currentElement.type = Sub.subType.ZeroOrMore\n                    } else {\n                        if (currentElement.subEle.lastIndex == -1) {\n                            isValidator = false\n                            break@loop\n                        }\n                        val sub = currentElement.subEle[currentElement.subEle.lastIndex]\n                        val startSub = Sub(sub.parent, Sub.subType.ZeroOrMore)\n                        startSub.subEle.add(sub)\n                        sub.parent = startSub\n                        currentElement.subEle[currentElement.subEle.lastIndex] = startSub\n                    }\n                }\n                else -> currentElement.subEle.add(\n                    Sub(\n                        currentElement,\n                        Sub.subType.Normal,\n                        c\n                    )\n                )\n            }\n        }\n        if (currentElement.parent != null && (currentElement.parent!!.type != Sub.subType.Or || currentElement.parent!!.parent != null))\n            isValidator = false\n        if (isVal(input) == false) {\n            isValidator = false\n        }\n        print(\"\")\n    }\n\n    class Sub(var parent: Sub?, var type: subType = subType.Str, var data: Char? = null) {\n        enum class subType {\n            Normal, ZeroOrMore, Or, Str, Any\n        }\n\n        val subEle: MutableList<Sub> = mutableListOf()\n\n        override fun toString(): String {\n            if (data != null)\n                return if (type == subType.ZeroOrMore) \"$data*\" else data.toString()\n\n            if (subEle.size == 1)\n                return if (type == subType.ZeroOrMore) \"${subEle[0]}*\" else subEle[0].toString()\n\n            return when (type) {\n                subType.Or -> subEle.joinToString(\"|\", \"(\", \")\")\n                subType.ZeroOrMore -> subEle.joinToString(\"\", \"(\", \")\") + \"*\"\n                subType.Str -> subEle.joinToString(\"\", \"(\", \")\")\n                subType.Any -> \".\"\n                else -> \"\"\n            }\n        }\n    }\n\n    fun isVal(string: String): Boolean {\n        if (string.contains(\"**\")) return false\n        if (string.matches(Regex(\"^\\\\|.*|.*\\\\|$\"))) return false\n        return true\n    }\n\n    fun parse(): RegExp {\n        return if (isValidator) toRegExp(element) else Void()\n    }\n\n    fun toRegExp(element: Sub): RegExp {\n        return when (element.type) {\n            Sub.subType.Normal -> Normal(element.data ?: ' ')\n            Sub.subType.Or -> Or(toRegExp(element.subEle[0]), toRegExp(element.subEle[1]))\n            Sub.subType.ZeroOrMore -> ZeroOrMore(toRegExp(element.subEle[0]))\n            Sub.subType.Str -> if (element.subEle.size == 1) toRegExp(element.subEle[0]) else\n                Str(element.subEle.map { toRegExp(it) }.toList())\n            Sub.subType.Any -> Any()\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208761,"user_id":null,"body":"import kotlin.collections.ArrayList\n\nfun ArrayList<RegExp>.removeLast(): RegExp {\n    val e = this.get(this.size-1)\n    this.removeAt(this.size-1)\n    return e\n}\n\nclass RegExpParser(expression: String) {\n    val symbols: CharArray = expression.toCharArray()\n    fun parse(): RegExp {\n        try {\n            return this.__parse__(0, symbols.size)\n        } catch (e: Exception) {\n            return Void()\n        }\n    }\n\tfun __parse__(start: Int, end: Int): RegExp {\n        val stack: ArrayList<RegExp> = ArrayList()\n        var idx = start\n        var operand: RegExp? = null\n        fun makeStr(): RegExp {\n            val token = Str(ArrayList(stack))\n            stack.clear()\n            return token\n        }\n        while (idx < end) {\n            when (symbols[idx]) {\n                '(' -> {\n                    val startIdx = ++idx\n                    var cnt = 1\n                    while(idx < end) {\n                        when (symbols[idx]) {\n                            '(' -> cnt++\n                            ')' -> cnt--\n                        }\n                        if (cnt == 0) break\n                        idx++\n                    }\n                    if (cnt > 0) throw IllegalArgumentException()\n                    stack.add(this.__parse__(startIdx, idx))\n                }\n                ')' -> throw IllegalArgumentException()\n                '*' -> {\n                    if (stack.last() is ZeroOrMore) throw IllegalArgumentException()\n                    stack.add(ZeroOrMore(stack.removeLast()))\n                }\n                '|' -> {\n                    if (operand != null || idx == 0) throw IllegalArgumentException()\n                    operand = if (stack.size > 1) makeStr() else stack.removeLast()\n                }\n                '.' -> stack.add(Any())\n                else -> stack.add(Normal(symbols[idx]))\n            }\n            idx++\n        }\n        if (operand != null)\n            stack.add(Or(operand, if (stack.size > 1) makeStr() else stack.removeLast()))\n        if (stack.size > 1) stack.add(makeStr())\n        return stack.removeLast()\n\t}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208762,"user_id":null,"body":"import org.junit.Test\n\nimport java.*\nimport java.util.stream.Collectors\nimport java.util.stream.IntStream\nimport java.io.StringReader\n\nclass RegExpParser(input: String) {\n    val chars = Lex(input)\n\n    \/\/ Start -> OrExpr\n\tfun parse(): RegExp {\n        try {\n    \t\tval result = parseOr()\n            if (chars.next() != null) return Void()\n            return result\n        } catch (e: InvalidInput) {\n            return Void()\n        }\n\t}\n    \n    \/\/ OrExpr -> ConcatExpr\n    \/\/ OrExpr -> ConcatExpr '|' ConcatExpr\n    fun parseOr(): RegExp {\n        val left = parseConcat()\n        return when (chars.match<Bar>()) {\n            null -> left\n            else -> Or(left, parseConcat())\n        }\n    }\n    \n    \/\/ ConcatExpr -> PostfixExpr+\n    fun parseConcat(): RegExp {\n        val left = parsePostfix() ?: throw InvalidInput\n        val list = arrayListOf(left, parsePostfix() ?: return left)\n        while (true) {\n            when (val next = parsePostfix()) {\n                null -> return Str(list)\n                else -> list += next\n            }\n        }\n    }\n    \n    \/\/ PostfixExpr -> Atom\n    \/\/ PostfixExpr -> Atom '*'\n    fun parsePostfix(): RegExp? {\n        val inside = parseAtom() ?: return null\n        return when (chars.match<Star>()) {\n            Star -> ZeroOrMore(inside)\n            else -> inside\n        }\n    }\n    \n    \/\/ Atom -> '.'\n    \/\/ Atom -> letter\n    \/\/ Atom -> '(' OrExpr ')'\n    fun parseAtom() = when (val c = chars.peek()) {\n        LeftParen -> {\n            chars.next()\n            val inside = parseOr()\n            when (chars.match<RightParen>()) {\n                null -> throw InvalidInput\n                else -> inside\n            }\n        }\n        Dot -> {\n            chars.next()\n            Any()\n        }\n        is Letter -> {\n            chars.next()\n            Normal(c.c)\n        }\n        else -> null\n    }\n}\n\nclass Lex(input: String) {\n    private val chars = StringReader(input)\n    private var next: Token? = null\n    \n    fun peek(): Token? {\n        if (next != null)\n            return next\n        val c = chars.read()\n        if (c == -1)\n            return null\n        next = when (c.toChar()) {\n            '*' -> Star\n            '.' -> Dot\n            '(' -> LeftParen\n            ')' -> RightParen\n            '|' -> Bar\n            else -> Letter(c.toChar())\n        }\n        return next\n    }\n    \n    fun next(): Token? {\n        val n = peek()\n        next = null\n        return n\n    }\n    \n    inline fun <reified T> match(): T? {\n        val n = peek()\n        if (n is T) {\n            next()\n            return n\n        }\n        return null\n    }\n}\n\nsealed class Token\nobject Star : Token()\nobject LeftParen : Token()\nobject RightParen : Token()\nobject Dot : Token()\nobject Bar : Token()\nclass Letter(val c: Char) : Token()\n\nobject InvalidInput : RuntimeException()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208763,"user_id":null,"body":"import org.junit.Test\n\nimport java.*\nimport java.util.stream.Collectors\nimport java.util.stream.IntStream\n\nclass RegExpParser(var input: String) {\n\n   fun parse(): RegExp {\n        try {\n            return p(input, false)\n        } catch (e: IllegalArgumentException) {\n            return Void()\n        }\n\n    }\n\n    fun p(s: String, fromOr: Boolean): RegExp {\n        val exprs  = ArrayList<RegExp>()\n        var str = s\n        while (str != \"\") {\n            if(str.startsWith(\"(\")) {\n                val cl = findClosingBracket(str, 0)\n                if (cl != -1) {\n                    exprs.add(p(str.substring(1, cl), false))\n                    str = if (cl != str.lastIndex) str.substring(cl + 1) else \"\"\n                } else {\n                    throw IllegalArgumentException()\n                }\n            } else\n            if ( str.first() == '.') {\n                exprs.add(Any())\n                str = str.drop(1)\n            } else\n            if (str.startsWith(\"|\")) {\n                val left = if (exprs.size > 1) Str(exprs) else if (exprs.size == 0) Void() else exprs.first()\n                exprs.clear()\n                val right = p(str.drop(1), true)\n                exprs.add(Or(left, right))\n                str = \"\"\n            } else\n            if (str.startsWith(\"*\")) {\n                if (exprs.isEmpty()) throw IllegalArgumentException()\n                val exp = exprs.removeAt(exprs.size - 1)\n                if (exp is ZeroOrMore) throw IllegalArgumentException()\n                exprs.add(ZeroOrMore(exp))\n                str = str.drop(1)\n            } else\n            if (str.startsWith(\")\")) {\n                throw IllegalArgumentException()\n            } else\n            {\n                exprs.add(Normal(str.first()))\n                str = str.drop(1)\n            }\n        }\n        if (fromOr && exprs.size == 1 && exprs.first() is Or) {\n            throw IllegalArgumentException()\n        }\n        if (exprs.isEmpty()) {\n            return Void()\n        } else {\n            if (exprs.size > 1) return Str(exprs)\n            return exprs.first()\n        }\n    }\n    \n    fun findClosingBracket(s: String, i: Int) : Int {\n        var openCounter = 1\n        var closingCounter = 0\n        for (k in i + 1 until s.length) {\n            if (s[k] == '(') {\n                openCounter++\n            }\n            if (s[k] == ')') {\n                closingCounter++\n            }\n            if (closingCounter == openCounter) {\n                return k;\n            }\n        }\n        return -1;\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208764,"user_id":null,"body":"class RegExpParser(val input: String) {\n    fun parse(): RegExp = parse(input)\n}\n\nprivate fun parse(text: String): RegExp {\n    val parts = mutableListOf<RegExp>()\n\n    fun group(): RegExp = when (parts.size) {\n        0 -> Void()\n        1 -> parts.single()\n        else -> Str(parts.toList())\n    }\n\n    var i = 0\n    while (i < text.length) {\n        var exp: RegExp = when (val c = text[i]) {\n            '*', ')' -> Void()\n            '.' -> Any()\n            '(' -> {\n                i++\n                var depth = 1\n                var j = i\n                while (j < text.length) {\n                    when (text[j]) {\n                        '(' -> depth++\n                        ')' -> depth--\n                    }\n                    if (depth == 0) break\n                    j++\n                }\n                if (depth == 0) {\n                    val p = parse(text.substring(i, j))\n                    i = j\n                    p\n                } else Void()\n            }\n            '|' -> {\n                val before = group()\n                parts.clear()\n                val after = parse(text.substring(i + 1))\n                if (after !is Void && after !is Or) {\n                    i = text.length - 1\n                    Or(before, after)\n                } else Void()\n            }\n            else -> Normal(c)\n        }\n\n        if (exp is Void) return exp\n\n        if (text.getOrNull(i + 1) == '*') {\n            exp = ZeroOrMore(exp)\n            i++\n        }\n\n        parts.add(exp)\n        i++\n    }\n\n    return group()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208765,"user_id":null,"body":"import org.junit.Test\n\nimport java.*\nimport java.util.stream.Collectors\nimport java.util.stream.IntStream\n\nclass RegExpParser(val input: String) {\n\n    fun maybeStr(r: List<RegExp>) : RegExp = r.singleOrNull() ?: Str(r)\n    \n    fun parse(s:Iterator<Char>, topLevel:Boolean = true) : RegExp {\n        var l = mutableListOf<RegExp>()\n        var po : MutableList<RegExp>? = null\n        var pend = false\n        \n        loop@ while (s.hasNext()) {\n            when (val c = s.next()) {\n                '(' -> {\n                    val r = parse(s, false)\n                    if (r == Void()) return Void()\n                    l.add(r)\n                }\n                '|' -> {\n                    if (po != null) return Void()\n                    po = l\n                    l = mutableListOf<RegExp>()\n                }\n                '*' -> {\n                    if (l.isEmpty() || l.last() is ZeroOrMore) return Void()\n                    l[l.size-1] = ZeroOrMore(l.last())\n                }\n                ')' -> {\n                    pend = true\n                    break@loop\n                }\n                else -> l.add(Normal(c))\n            }\n        }\n    \n        return when {\n            l.isEmpty() -> Void ()\n            topLevel == pend -> Void()\n            po == null -> maybeStr (l)\n            else -> Or(maybeStr(po), maybeStr(l))\n        }\n    }\n    \n\tfun parse(): RegExp = parse(input.iterator())\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208766,"user_id":null,"body":"const val SPECIAL_CHARS = \"|*()\"\n\nfun char(c: Char) = if (SPECIAL_CHARS.contains(c)) Void() else Normal(c)\nfun or(left: RegExp, right: RegExp) = when {\n    left is Void || right is Void -> Void()\n    else -> Or(left, right)\n}\n\nfun star(inner: RegExp) = if (inner is Void) Void() else ZeroOrMore(inner)\nfun seq(exps: List<RegExp>) = if (exps.any { it is Void }) Void() else if (exps.size == 1) exps[0] else Str(exps)\n\nclass RegExpParser(val input: String) {\n    var index = 0\n\n    private fun peek(): Char = input[index]\n    private fun next(): Char = input[index++]\n    private fun hasMore(): Boolean = index < input.length\n\n    private fun parseAtom(): RegExp {\n        if (!hasMore()) {\n            return Void()\n        }\n        return when (val c = next()) {\n            '(' -> {\n                val res = parseExp()\n                if (hasMore() && next() == ')') res else Void()\n            }\n            '.' -> Any()\n            else -> char(c)\n        }\n    }\n\n    private fun parseStar(): RegExp {\n        val inner = parseAtom()\n        return if (hasMore() && peek() == '*') {\n            next()\n            star(inner)\n        } else inner\n    }\n\n    private fun parseSeq(): RegExp {\n        val exps = mutableListOf<RegExp>()\n        exps.add(parseStar())\n        loop@ while (hasMore()) {\n            when (peek()) {\n                '|', ')' -> break@loop\n            }\n            exps.add(parseStar())\n        }\n        return seq(exps)\n    }\n\n    private fun parseExp(): RegExp {\n        if (hasMore() && peek() == '|') {\n            next()\n            return parseSeq()\n        } else {\n            val lhs = parseSeq()\n            if (!hasMore()) {\n                return lhs\n            }\n            val c = peek()\n            return if (c == '|') {\n                next()\n                if (hasMore() && peek() != ')') {\n                    val rhs = parseSeq()\n                    or(lhs, rhs)\n                } else {\n                    lhs\n                }\n            } else {\n                lhs\n            }\n        }\n    }\n\n    fun parse(): RegExp {\n        val exp = parseExp()\n        return if (hasMore()) Void() else exp\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208767,"user_id":null,"body":"class RegExpParser(private val input: String) {\n    private fun parseOr(i: Int): Pair<RegExp, Int> {\n        val (left, i2) = parseStr(i)\n        return if (i2 < input.length && input[i2] == '|') {\n            val (right, i3) = parseStr(i2 + 1)\n            if (right is Void) (right to i2) else (Or(left, right) to i3)\n        } else {\n            (left to i2)\n        }\n    }\n\n    private fun parseStr(i: Int): Pair<RegExp, Int> {\n        val (re, i2) = parseStar(i)\n        if (re is Void) return (re to i)\n        val res = mutableListOf(re)\n        var ii = i2\n        loop@ while (ii < input.length) {\n            when (input[ii]) {\n                ')', '*', '|' -> break@loop\n                else -> {\n                    val (rr, i3) = parseStar(ii)\n                    if (rr is Void) {\n                        break@loop\n                    } else {\n                        ii = i3\n                        res.add(rr)\n                    }\n                }\n            }\n        }\n        return if (res.size == 1) (res[0] to ii) else (Str(res) to ii)\n    }\n\n    private fun parseStar(i: Int): Pair<RegExp, Int> {\n        val (re, i2) = parseGroup(i)\n        if (re is Void) return (re to i)\n        return if (i2 < input.length && input[i2] == '*') {\n            (ZeroOrMore(re) to i2 + 1)\n        } else {\n            (re to i2)\n        }\n    }\n\n    private fun parseGroup(i: Int): Pair<RegExp, Int> {\n        if (i < input.length) {\n            return when (input[i]) {\n                '(' -> {\n                    val (re, i2) = parseOr(i + 1)\n                    if (re is Void) {\n                        (re to i)\n                    } else if (i2 < input.length && input[i2] == ')') {\n                        (re to i2 + 1)\n                    } else {\n                        (Void() to i)\n                    }\n                }\n                ')', '*', '|' -> (Void() to i)\n                '.' -> {\n                    (Any() to i + 1)\n                }\n                else -> {\n                    (Normal(input[i]) to i + 1)\n                }\n            }\n        } else {\n            return (Void() to i)\n        }\n    }\n\n    fun parse(): RegExp {\n        val (re, i) = parseOr(0)\n        return if (i < input.length) {\n            Void()\n        } else {\n            re\n        }\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208768,"user_id":490,"body":"import java.util.*\nimport java.util.stream.Collectors\n\nclass RegExpParser(input: String) {\n\tprivate val tokens: LinkedList<Char> = LinkedList(input.chars()\n\t\t\t.mapToObj(Int::toChar)\n\t\t\t.collect(Collectors.toList()))\n\n\tinternal class InvalidRegex : RuntimeException()\n\n\tfun parse(): RegExp {\n\t\tval ans = try {\n\t\t\tparse_Or()\n\t\t} catch (e: InvalidRegex) {\n\t\t\tVoid()\n\t\t}\n\t\treturn if (hasChar()) Void() else ans\n\t}\n\n\tprivate fun popChar() = tokens.remove()\n\tprivate fun peekChar() = tokens.peek()\n\tprivate fun hasChar() = tokens.isNotEmpty()\n\n\tprivate fun parse_Or(): RegExp {\n\t\tvar or_ = parse_Str()\n\t\tif (hasChar() && peekChar() == '|') {\n\t\t\tpopChar()\n\t\t\tor_ = Or(or_, parse_Str())\n\t\t}\n\t\treturn or_\n\t}\n\n\tprivate fun parse_Str(): RegExp {\n\t\tval str_ = ArrayList<RegExp>()\n\t\twhile (hasChar() && peekChar() !in \"*)|\")\n\t\t\tstr_.add(parse_ZeroMul())\n\t\treturn when {\n\t\t\tstr_.isEmpty() -> Void()\n\t\t\tstr_.size > 1 -> Str(str_)\n\t\t\telse -> str_[0]\n\t\t}\n\t}\n\n\tprivate fun parse_ZeroMul(): RegExp {\n\t\tvar zm = parse_Term()\n\t\tif (zm !is Void && hasChar() && peekChar() == '*') {\n\t\t\tpopChar()\n\t\t\tzm = ZeroOrMore(zm)\n\t\t}\n\t\treturn zm\n\t}\n\n\tprivate fun parse_Term(): RegExp {\n\t\tif (!hasChar()) throw InvalidRegex()\n\t\tval was = popChar()\n\t\tval expr: RegExp\n\t\tif (was == '(') {\n\t\t\tif (!hasChar() || peekChar() == ')') throw InvalidRegex()\n\t\t\texpr = parse_Or()\n\t\t\tif (!hasChar() || peekChar() != ')') throw InvalidRegex()\n\t\t\tpopChar()\n\n\t\t} else if (was == '.')\n\t\t\texpr = Any()\n\t\telse if (was !in \"()*|\")\n\t\t\texpr = Normal(was)\n\t\telse\n\t\t\tthrow RuntimeException(\"Wrong code: You should never get there...\")\n\n\t\treturn expr\n\t}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"56a73d2194505c29f600002d":[{"id":208769,"user_id":100,"body":"const val multipleOf7 = \"^(0|(10((0|11)(1|00))*(10|(0|11)01)|11)(01*0(0|101|1(1|00)((0|11)(1|00))*(10|(0|11)01)))*1)+$\"","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208770,"user_id":null,"body":"const val multipleOf7 = \"(((((((0+)?1)1)((10*1)1)*(((10*1)0)0)|((((0+)?1)0)0))((01)((10*1)1)*(((10*1)0)0)|((00|1)0))*((01)((10*1)1)*(((10*1)0)1)|((00|1)1))|((((0+)?1)1)((10*1)1)*(((10*1)0)1)|((((0+)?1)0)1)))((0((10*1)1)*(((10*1)0)0)|1)((01)((10*1)1)*(((10*1)0)0)|((00|1)0))*((01)((10*1)1)*(((10*1)0)1)|((00|1)1))|(0((10*1)1)*(((10*1)0)1)))*((0((10*1)1)*(((10*1)0)0)|1)((01)((10*1)1)*(((10*1)0)0)|((00|1)0))*((01)((10*1)1)*0)|(0((10*1)1)*0))|(((((0+)?1)1)((10*1)1)*(((10*1)0)0)|((((0+)?1)0)0))((01)((10*1)1)*(((10*1)0)0)|((00|1)0))*((01)((10*1)1)*0)|((((0+)?1)1)((10*1)1)*0)))(0((0((10*1)1)*(((10*1)0)0)|1)((01)((10*1)1)*(((10*1)0)0)|((00|1)0))*((01)((10*1)1)*(((10*1)0)1)|((00|1)1))|(0((10*1)1)*(((10*1)0)1)))*((0((10*1)1)*(((10*1)0)0)|1)((01)((10*1)1)*(((10*1)0)0)|((00|1)0))*((01)((10*1)1)*0)|(0((10*1)1)*0))|1)*(0((0((10*1)1)*(((10*1)0)0)|1)((01)((10*1)1)*(((10*1)0)0)|((00|1)0))*((01)((10*1)1)*(((10*1)0)1)|((00|1)1))|(0((10*1)1)*(((10*1)0)1)))*((0((10*1)1)*(((10*1)0)0)|1)((01)((10*1)1)*(((10*1)0)0)|((00|1)0))*((01)((10*1)1)*(1(0+)?))|(0((10*1)1)*(1(0+)?))))|((((((0+)?1)1)((10*1)1)*(((10*1)0)0)|((((0+)?1)0)0))((01)((10*1)1)*(((10*1)0)0)|((00|1)0))*((01)((10*1)1)*(((10*1)0)1)|((00|1)1))|((((0+)?1)1)((10*1)1)*(((10*1)0)1)|((((0+)?1)0)1)))((0((10*1)1)*(((10*1)0)0)|1)((01)((10*1)1)*(((10*1)0)0)|((00|1)0))*((01)((10*1)1)*(((10*1)0)1)|((00|1)1))|(0((10*1)1)*(((10*1)0)1)))*((0((10*1)1)*(((10*1)0)0)|1)((01)((10*1)1)*(((10*1)0)0)|((00|1)0))*((01)((10*1)1)*(1(0+)?))|(0((10*1)1)*(1(0+)?)))|(((((0+)?1)1)((10*1)1)*(((10*1)0)0)|((((0+)?1)0)0))((01)((10*1)1)*(((10*1)0)0)|((00|1)0))*((01)((10*1)1)*(1(0+)?))|((((0+)?1)1)((10*1)1)*(1(0+)?)|(0(0+)?)))))$\"","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208771,"user_id":null,"body":"const val multipleOf7 = \"^(?:0|1(?:(?:1(?:01*00)*01*010|(?:0|1(?:01*00)*01*011)(?:(?:(?:0|11)1|10(?:01*00)*01*011))*(?:(?:0|11)0|10(?:01*00)*01*010)))*(?:1(?:01*00)*1|(?:0|1(?:01*00)*01*011)(?:(?:(?:0|11)1|10(?:01*00)*01*011))*10(?:01*00)*1))+$\"","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208772,"user_id":null,"body":"const val multipleOf7 =\n    \"^((?:0)|(?:(?:1)(?:(?:(?:1)(?:(?:(?:0)(?:1)*(?:0))(?:0))*(?:(?:(?:(?:0)(?:1)*(?:0))(?:1))(?:0)))|(?:(?:(?:0)|(?:(?:1)(?:(?:(?:0)(?:1)*(?:0))(?:0))*(?:(?:(?:(?:0)(?:1)*(?:0))(?:1))(?:1))))(?:(?:(?:(?:0)|(?:1)(?:1))(?:1))|(?:(?:(?:1)(?:0))(?:(?:(?:0)(?:1)*(?:0))(?:0))*(?:(?:(?:(?:0)(?:1)*(?:0))(?:1))(?:1))))*(?:(?:(?:(?:0)|(?:1)(?:1))(?:0))|(?:(?:(?:1)(?:0))(?:(?:(?:0)(?:1)*(?:0))(?:0))*(?:(?:(?:(?:0)(?:1)*(?:0))(?:1))(?:0))))))*(?:(?:(?:1)(?:(?:(?:0)(?:1)*(?:0))(?:0))*(?:1))|(?:(?:(?:0)|(?:(?:1)(?:(?:(?:0)(?:1)*(?:0))(?:0))*(?:(?:(?:(?:0)(?:1)*(?:0))(?:1))(?:1))))(?:(?:(?:(?:0)|(?:1)(?:1))(?:1))|(?:(?:(?:1)(?:0))(?:(?:(?:0)(?:1)*(?:0))(?:0))*(?:(?:(?:(?:0)(?:1)*(?:0))(?:1))(?:1))))*(?:(?:(?:1)(?:0))(?:(?:(?:0)(?:1)*(?:0))(?:0))*(?:1))))))+$\"","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208773,"user_id":null,"body":"const val multipleOf7 = \"^(?:0|1(?:1(?:0(?:1)*00)*0(?:1)*010|(?:0|1(?:0(?:1)*00)*0(?:1)*011)(?:(?:0|11)1|10(?:0(?:1)*00)*0(?:1)*011)*(?:(?:0|11)0|10(?:0(?:1)*00)*0(?:1)*010))*(?:1(?:0(?:1)*00)*1|(?:0|1(?:0(?:1)*00)*0(?:1)*011)(?:(?:0|11)1|10(?:0(?:1)*00)*0(?:1)*011)*10(?:0(?:1)*00)*1))+$\";","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208774,"user_id":179,"body":"const val multipleOf7 = \"0|(1(0(0|11)(1(0|11))*0|(1|0(1|(0|11)(1(0|11))*11)0)(01*0(0|1(1(0|11))*110))*(01*01(1(0|11))*0|10*1))*(1|0(1|(0|11)(1(0|11))*11)0)(01*0(0|1(1(0|11))*110))*(1|10*))\"","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208775,"user_id":null,"body":"const val multipleOf7 = \"\"\"(0|1(((0|1(01*00)*01*011)((0|11|10(01*00)*01*01)1)*(0|11|10(01*00)*01*01)|1(01*00)*01*01)0)*(1(01*00)*|(0|1(01*00)*01*011)((0|11|10(01*00)*01*01)1)*10(01*00)*)1)+\"\"\"","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208776,"user_id":19,"body":"const val multipleOf7 = \"^(0|1(((0|1(01*00)*01*011)(((0|11)|10(01*00)*01*01)1)*((0|11)|10(01*00)*01*01)|1(01*00)*01*01)0)*((0|1(01*00)*01*011)(((0|11)|10(01*00)*01*01)1)*10|1)(01*00)*1)+$\"","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208777,"user_id":null,"body":"const val multipleOf7 = \"(((((((0+)?1)1)((10*1)1)*(((10*1)0)0)|((((0+)?1)0)0))((01)((10*1)1)*(((10*1)0)0)|((00|1)0))*((01)((10*1)1)*(((10*1)0)1)|((00|1)1))|((((0+)?1)1)((10*1)1)*(((10*1)0)1)|((((0+)?1)0)1)))((0((10*1)1)*(((10*1)0)0)|1)((01)((10*1)1)*(((10*1)0)0)|((00|1)0))*((01)((10*1)1)*(((10*1)0)1)|((00|1)1))|(0((10*1)1)*(((10*1)0)1)))*((0((10*1)1)*(((10*1)0)0)|1)((01)((10*1)1)*(((10*1)0)0)|((00|1)0))*((01)((10*1)1)*0)|(0((10*1)1)*0))|(((((0+)?1)1)((10*1)1)*(((10*1)0)0)|((((0+)?1)0)0))((01)((10*1)1)*(((10*1)0)0)|((00|1)0))*((01)((10*1)1)*0)|((((0+)?1)1)((10*1)1)*0)))(0((0((10*1)1)*(((10*1)0)0)|1)((01)((10*1)1)*(((10*1)0)0)|((00|1)0))*((01)((10*1)1)*(((10*1)0)1)|((00|1)1))|(0((10*1)1)*(((10*1)0)1)))*((0((10*1)1)*(((10*1)0)0)|1)((01)((10*1)1)*(((10*1)0)0)|((00|1)0))*((01)((10*1)1)*0)|(0((10*1)1)*0))|1)*(0((0((10*1)1)*(((10*1)0)0)|1)((01)((10*1)1)*(((10*1)0)0)|((00|1)0))*((01)((10*1)1)*(((10*1)0)1)|((00|1)1))|(0((10*1)1)*(((10*1)0)1)))*((0((10*1)1)*(((10*1)0)0)|1)((01)((10*1)1)*(((10*1)0)0)|((00|1)0))*((01)((10*1)1)*(1(0+)?))|(0((10*1)1)*(1(0+)?))))|((((((0+)?1)1)((10*1)1)*(((10*1)0)0)|((((0+)?1)0)0))((01)((10*1)1)*(((10*1)0)0)|((00|1)0))*((01)((10*1)1)*(((10*1)0)1)|((00|1)1))|((((0+)?1)1)((10*1)1)*(((10*1)0)1)|((((0+)?1)0)1)))((0((10*1)1)*(((10*1)0)0)|1)((01)((10*1)1)*(((10*1)0)0)|((00|1)0))*((01)((10*1)1)*(((10*1)0)1)|((00|1)1))|(0((10*1)1)*(((10*1)0)1)))*((0((10*1)1)*(((10*1)0)0)|1)((01)((10*1)1)*(((10*1)0)0)|((00|1)0))*((01)((10*1)1)*(1(0+)?))|(0((10*1)1)*(1(0+)?)))|(((((0+)?1)1)((10*1)1)*(((10*1)0)0)|((((0+)?1)0)0))((01)((10*1)1)*(((10*1)0)0)|((00|1)0))*((01)((10*1)1)*(1(0+)?))|((((0+)?1)1)((10*1)1)*(1(0+)?)|(0(0+)?)))))\"","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208778,"user_id":null,"body":"const val multipleOf7 = \"^(0|(10((0|11)(1|00))*(10|(0|11)01)|11)(01*0(0|101|1(1|00)((0|11)(1|00))*(10|001|1101)))*1)+$\"\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"57ff9d3b8f7dda23130015fa":[{"id":208779,"user_id":null,"body":"import kotlin.math.min\n\nclass MineSweeper(board: String, val nMines: Int) {\n    \n    private var nFlagged: Int = 0\n    \n    private val columns = (board.takeWhile { it != '\n' }.length + 1) \/ 2 \/\/ x\n    private val rows = board.count { it == '\n' } + 1 \/\/ y\n    \n    private val cells: List<List<Cell>> = mutableListOf<List<Cell>>().apply {\n        repeat(rows) { i ->\n            add(board\n                .drop(i * columns * 2)\n                .take(columns * 2 - 1)\n                .split(' ')\n                .mapIndexed { ii, v -> Cell(v[0], i, ii) }\n            )\n        }\n    }\n    private val flatCells = cells.flatten()\n    \n    private val allFlagged: Boolean get() = nFlagged == nMines\n    \n    fun solve(): String {\n        if (allFlagged && !toString().contains(\"?\")) return toString()\n        \/\/ Fast approach\n        if (independentReduction()) {\n            return solve()\n        }\n        \/\/ Extensive approach\n        if (groupedReduction()) {\n            return solve()\n        }\n        \n        \/\/ Final approach\n        if (remainingFlagReduction()) {\n            return solve()\n        }\n        \n        println(\"FAILED TO SOLVE:\")\n        println(toString())\n        return \"?\"\n    }\n    \n    private fun independentReduction(): Boolean {\n        var changed = false\n        flatCells.forEach { cell ->\n            if (!cell.isOpened) return@forEach\n            val unknownNeighbors = cell.neighbors().filter { it.isUnknown }\n            val nFlaggedNeighbors = cell.flaggedNeighborCount()\n            \/\/ If all flags are satisfied.\n            if (nFlaggedNeighbors == cell.numeral) {\n                unknownNeighbors.forEach {\n                    it.open()\n                    changed = true\n                }\n            }\n            \/\/ If only n (numeral - flagged) cells nearby are unknown.\n            if (unknownNeighbors.size == cell.numeral - nFlaggedNeighbors) {\n                unknownNeighbors.forEach {\n                    it.flag()\n                    changed = true\n                }\n            }\n        }\n        return changed\n    }\n    \n    private fun groupedReduction(): Boolean {\n        var changed = false\n        val groups = mutableListOf<List<Cell>>()\n        flatCells\n            .filter { it.isUnknown }\n            .filter { it.neighbors().any { it.isOpened } }\n            .forEach { cell ->\n                if (groups.any { it.contains(cell) }) return@forEach\n                groups.add(cell.findGroupedNeighbors())\n            }\n        \/\/ Put constraints on the number of flags the group can used based on\n        \/\/ the number of other remaining groups to solve.\n        nFlagged += groups.size - 1\n        groups.forEach { group ->\n            val solutions = group.first().tryCombinations(group, group.drop(1))\n            nFlagged--\n            println(solutions)\n            \/\/ Find all spaces that cannot possibly be flags            \n            (0 until group.size).map { index ->\n                solutions.map { it[index] }.any { it }\n            }.forEachIndexed { index, isFlag ->\n                if (!isFlag) { \n                    \/\/ Open\n                    group[index].open()\n                    changed = true\n                }\n            }\n        }\n        nFlagged++\n        return changed\n    }\n    \n    \/\/ Solves based on remaining flag count\n    private fun remainingFlagReduction(): Boolean {\n        val unknowns = flatCells.filter { it.isUnknown }\n        if (allFlagged) {\n            unknowns.forEach { it.open() }\n            return true\n        } else {\n            if (unknowns.size == nMines - nFlagged) {\n                unknowns.forEach { it.flag() }\n                return true\n            }\n        }\n        return false\n    }\n    \n    private fun Cell.tryCombinations(group: List<Cell>, siblings: List<Cell>): List<List<Boolean>> {\n        val solutions = mutableListOf<List<Boolean>>()\n        if (!allFlagged) flag()\n        if (allFlagged || siblings.isEmpty()) {\n            if (testSolution(group)) solutions.add(listOf(isFlagged) + List(siblings.size) { false })\n        }\n        else {\n            siblings\n                .first()\n                .tryCombinations(group, siblings.drop(1))\n                .map { listOf(true) + it }\n                .let { solutions.addAll(it) }\n        }\n        unflag()\n        if (siblings.isEmpty()) {\n            if (testSolution(group)) solutions.add(listOf(isFlagged))\n        }\n        else {\n            siblings\n                .first()\n                .tryCombinations(group, siblings.drop(1))\n                .map { listOf(false) + it }\n                .let { solutions.addAll(it) }\n        }\n        return solutions\n    }\n    \n    private fun testSolution(group: List<Cell>): Boolean {\n        if (flatCells.filter {it.isUnknown}.all { group.contains(it) }) {\n            if (!allFlagged) return false\n        }\n        return group\n            .all { cell ->\n                cell.neighbors()\n                    .filter { it.isOpened }\n                    .all { it.flaggedNeighborCount() == it.numeral }\n            }\n    }\n    \n    private fun Cell.flaggedNeighborCount(): Int {\n        return neighbors().count { it.isFlagged }\n    }\n    \n    private fun Cell.findGroupedNeighbors(\n        set: MutableSet<Cell> = mutableSetOf()\n    ): List<Cell> {\n        set.add(this)\n        neighbors().let { cell ->\n            cell.filter { it.isUnknown }\n                .filter { it.neighbors().any { it.isOpened } }\n                .filterNot { set.contains(it) }\n                .forEach { it.findGroupedNeighbors(set) }\n            cell.filter { it.isOpened }\n                .forEach {\n                    it.neighbors()\n                        .filter { it.isUnknown }\n                        .filterNot { set.contains(it) }\n                        .forEach { it.findGroupedNeighbors(set) }\n                }\n        }\n        return set.toList()\n    }\n    \n    inner class Cell(var value: Char, private val row: Int, private val column: Int) {\n        \n        val isUnknown: Boolean get() = value == '?'\n        val isOpened: Boolean get() = !isUnknown && !isFlagged\n        val isFlagged: Boolean get() = value == 'x'\n        \n        val numeral: Int get() = value.toString().toInt()\n        \n        fun open() {\n            value = '0' + Game.open(row, column)\n        }\n        \n        fun flag() {\n            if (value != 'x') nFlagged++\n            value = 'x'\n        }\n        \n        fun unflag() {\n            if (value == 'x') nFlagged--\n            value = '?'\n        }\n        \n        fun neighbors(): List<Cell> {\n            val list = mutableListOf<Cell>()\n            if (column != 0) {\n                list.add(cells[row][column - 1])\n                if (row != 0) list.add(cells[row - 1][column - 1])\n                if (row != rows - 1) list.add(cells[row + 1][column - 1])\n            }\n            if (column != columns - 1) {\n                list.add(cells[row][column + 1])\n                if (row != 0) list.add(cells[row - 1][column + 1])\n                if (row != rows - 1) list.add(cells[row + 1][column + 1])\n            }\n            if (row != 0) list.add(cells[row - 1][column])\n            if (row != rows - 1) list.add(cells[row + 1][column])\n            return list\n        }\n        \n        override fun toString(): String = \"$value\"\n        \n    }\n    \n    override fun toString(): String {\n        val sb = StringBuilder()\n        repeat(rows) {\n            sb.append(cells.flatten().drop(it * columns).take(columns).joinToString(\" \")).append(\"\n\")\n        }\n        sb.deleteCharAt(sb.length - 1)\n        return sb.toString()\n    }\n    \n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208780,"user_id":null,"body":"import java.lang.RuntimeException\nimport java.lang.StringBuilder\n\nclass MineSweeper(board: String, nMines: Int) {\n    val log = true\n    val primaryGrid = Grid(board, nMines)\n\n    fun solve(): String {\n        log(\"\n\nInitial State:\n${primaryGrid.gridToString()}\")\n        primaryGrid.populateNeighbors()\n        var solved = primaryGrid.solveLoop()\n        if(solved){\n            return primaryGrid.gridToStringFinalOutput()\n        }\n        else{\n            return \"?\"\n        }\n    }\n    fun log(output: String){\n        if(log){\n            print(output)\n        }\n    }\n\n\n\n}\nclass Cell constructor(currentValue: String, rowIdx: Int, colIdx: Int){\n    companion object{\n        const val SYMBOL_UNKNOWN = \"?\"\n        const val SYMBOL_MINE = \"x\"\n        const val SYMBOL_SIM_MINE = \"S\"\n    }\n    val perimeterCellList: MutableList<Cell>\n    val rowIdx: Int\n    val colIdx: Int\n    private var symbol = \"\"\n    init{\n        perimeterCellList = ArrayList<Cell>()\n        this.rowIdx = rowIdx\n        this.colIdx = colIdx\n        symbol = currentValue\n    }\n    fun openCell(){\n        val newSymbol = Game.open(rowIdx, colIdx).toString()\n        symbol = newSymbol;\n    }\n    fun markMine(){\n        symbol = SYMBOL_MINE;\n    }\n    fun markUnknown(){\n        symbol = SYMBOL_UNKNOWN;\n    }\n    fun getCoordinateString(): String{\n        return \"[$rowIdx,$colIdx]\"\n    }\n\n    override fun toString(): String {\n        return symbol;\n    }\n    fun getSymbolAsInt(): Int{\n        if(!this.isNumber()){\n            throw RuntimeException(\"Integer value not available for symbol $symbol\")\n        }\n        else{\n            return symbol.toInt()\n        }\n    }\n    fun addNeighbor(neighbor: Cell){\n        perimeterCellList.add(neighbor)\n    }\n    fun isNumber(): Boolean{\n        if(symbol.toIntOrNull() == null){\n            return false\n        }\n        return true\n    }\n    fun isZero(): Boolean{\n        if(symbol == \"0\"){\n            return true\n        }\n        return false\n    }\n    fun isUnknown(): Boolean{\n        if(symbol == SYMBOL_UNKNOWN){\n            return true\n        }\n        return false\n    }\n    fun isMine(): Boolean{\n        if(symbol == SYMBOL_MINE){\n            return true\n        }\n        return false\n    }\n\n}\nclass Scenario constructor(){\n    val simulatedMineCells: MutableSet<Cell>\n    init{\n        simulatedMineCells = HashSet<Cell>()\n    }\n    fun addSimMine(cell: Cell){\n        simulatedMineCells.add(cell)\n    }\n    fun addAllSimMines(mineCellSet: Set<Cell>){\n        simulatedMineCells.addAll(mineCellSet)\n    }\n    fun createNewScenarioOnMerge(subScenario: Scenario): Scenario{\n        val newScenario = Scenario()\n        newScenario.addAllSimMines(simulatedMineCells)\n        newScenario.addAllSimMines(subScenario.simulatedMineCells)\n        return newScenario\n    }\n    fun hasMines(): Boolean{\n        return simulatedMineCells.isNotEmpty()\n    }\n    override fun toString(): String{\n        val sb = StringBuilder(\"Simulated mines at: \")\n        for(simMine in simulatedMineCells){\n            sb.append(simMine.getCoordinateString())\n        }\n        return sb.toString()\n    }\n    fun findScenarioCommonalityForMines(comparisonScenarioList: List<Scenario>): Scenario{\n        val agreedSubScenario = Scenario()\n        val comparisonScenarioString = StringBuilder()\n        for(comparisonScenario in comparisonScenarioList){\n            comparisonScenarioString.append(\"$comparisonScenario\n\")\n        }\n        log(\"Testing for commonality of scenario mine cells between this scenario: ${this} and \n${comparisonScenarioString.toString()}\")\n        for(simulatedMineCell in this.simulatedMineCells){\n            var agreed = true\n            for(comparisonScenario in comparisonScenarioList){\n                if(comparisonScenario.simulatedMineCells.contains(simulatedMineCell)){\n                    continue\n                }\n                else{\n                    agreed = false\n                    break\n                }\n            }\n            if(agreed){\n                log(\"Agreed on mine at [${simulatedMineCell.rowIdx},${simulatedMineCell.colIdx}]\")\n                agreedSubScenario.addSimMine(simulatedMineCell)\n            }\n        }\n        return agreedSubScenario\n    }\n\n    private fun log(output: String){\n        println(output)\n    }\n\n}\n\nclass Grid constructor (board: String, numMines: Int){\n    private val grid: MutableList<MutableList<Cell>>\n    private val activeNumberedCellList: MutableList<Cell>\n    private val activeUnknownCellList: MutableList<Cell>\n    private val activeZeroCellList: MutableList<Cell>\n    private val unknownCellSet: MutableSet<Cell>\n    private val knownMineCellSet: MutableSet<Cell>\n    private val rowMaxIdx: Int\n    private val colMaxIdx: Int\n    private val MAX_NUM_NO_INFO_CELLS_TO_RECURSIVE_EVALUATE = 3\n\n    var numMines = 0\n    var numMinesFound = 0\n\n\n    init {\n        this.numMines = numMines\n        log(\"Input board: \n\" + board)\n        val rows = board.split(\"\n\")\n        val rowNum = rows.count()\n        rowMaxIdx = rowNum - 1\n        grid = ArrayList<MutableList<Cell>>(rowNum)\n        activeNumberedCellList = ArrayList<Cell>()\n        activeUnknownCellList = ArrayList<Cell>()\n        activeZeroCellList = ArrayList<Cell>()\n        knownMineCellSet = HashSet<Cell>()\n        unknownCellSet = HashSet<Cell>()\n        for ((rowIdx, rowValue) in rows.withIndex()){\n            \/\/log(\"Importing row index $rowIdx with value: $rowValue\")\n            val values = rowValue.split(\" \")\n            val gridRow = ArrayList<Cell>(values.size)\n            grid.add(gridRow)\n            for((colIdx, entry) in values.withIndex()){\n                val gridLocation = Cell(entry, rowIdx, colIdx)\n                gridRow.add(gridLocation)\n                handleUpdatedCellInfo(gridLocation)\n            }\n        }\n        colMaxIdx = grid[0].count() - 1\n    }\n    \/\/ Updates the active lists and sets of the grid based on new info\n    private fun handleUpdatedCellInfo(cell: Cell){\n        if(cell.isNumber()){\n            activeNumberedCellList.add(cell)\n            if(cell.isZero()){\n                activeZeroCellList.add(cell)\n            }\n        }\n        else if(cell.isMine()){\n            knownMineCellSet.add(cell)\n        }\n        else if(cell.isUnknown()) {\n            unknownCellSet.add(cell)\n        }\n        else{\n            throw RuntimeException(\"Unclear what this cell is: $cell\")\n        }\n    }\n    fun getGridLocation(rowIdx: Int, colIdx: Int): Cell{\n        return grid[rowIdx][colIdx]\n    }\n    fun gridToString(): String{\n        val gridAsString = StringBuilder()\n        for(row in grid){\n            for(value in row){\n                gridAsString.append(value.toString())\n                gridAsString.append(\" \")\n            }\n            gridAsString.append(\"\n\")\n        }\n        return gridAsString.toString()\n    }\n    fun gridToStringFinalOutput(): String{\n        val gridAsString = StringBuilder()\n        for((rowIdx, row) in grid.withIndex()){\n            for((colIdx, value) in row.withIndex()){\n                gridAsString.append(value.toString())\n                if(colIdx != colMaxIdx){\n                    gridAsString.append(\" \")\n                }\n            }\n            if(rowIdx != rowMaxIdx) {\n                gridAsString.append(\"\n\")\n            }\n        }\n        return gridAsString.toString()\n    }\n    fun populateNeighbors() {\n        for((rowIdx, rowValue) in grid.withIndex()){\n            for((colIdx, activeGridLocation) in rowValue.withIndex()){\/\/ Go to all grid locations, find neighbors, then add yourself to them as a neighbor\n                for(rowOffset in -1..1){\n                    val neighborRow = rowIdx + rowOffset\n                    if((neighborRow < 0) || (neighborRow > rowMaxIdx)){ \/\/If the index is outside of the bounds on the row\n                        \/\/log(\"Neighbor Row of $neighborRow is out of the range, skipping.\")\n                        continue\n                    }\n                    for(colOffset in -1..1){\n                        val neighborCol = colIdx + colOffset\n                        if((neighborCol < 0) || (neighborCol > colMaxIdx)){ \/\/If the index is outside of the bounds on the col\n                            \/\/log(\"Neighbor Column of $neighborCol is out of the range, skipping.\")\n                            continue\n                        }\n                        else if((rowOffset == 0) && (colOffset ==0)){\n                            \/\/log(\"Offsets are both zero, skipping.\")\n                            continue\n                        }\n                        else {\n                            grid[neighborRow][neighborCol].addNeighbor(activeGridLocation)\n                            \/\/log(\"Adding neighbor: [$neighborRow,$neighborCol] to active gridlocation: [$rowIdx,$colIdx]\")\n                        }\n                    }\n                }\n            }\n        }\n    }\n    private fun log(output: String){\n        println(output)\n    }\n    private fun logIntentionsAndMarkMine(justification: String, cell: Cell, log: Boolean){\n        if(log) {\n            log(\"Marking mine at cell [${cell.rowIdx},${cell.colIdx}] with justification of:\n$justification\")\n        }\n        cell.markMine()\n        if(log) {\n            log(\"After:\n ${gridToString()}\")\n        }\n        knownMineCellSet.add(cell)\n        unknownCellSet.remove(cell)\n    }\n    private fun logIntentionsAndOpenCell(justification: String, cell: Cell, log: Boolean, updateActiveNumberCellList: Boolean){\n        if(log) {\n            log(\"Opening cell [${cell.rowIdx},${cell.colIdx}] with justification of:\n$justification\")\n        }\n        cell.openCell()\n        if(log){\n            log(\"After: ${gridToString()}\")\n        }\n        unknownCellSet.remove(cell)\n        if(updateActiveNumberCellList){ \/\/ Sometimes this can't be allowed as we may be looping over it and it'll cause a concurrent modification exception\n            activeNumberedCellList.add(cell)\n        }\n    }\n    private fun zeroSweep(): Boolean{\n        var progressMade = false\n        val deferredRemovalList = ArrayList<Cell>()\n        for(zeroCell in activeZeroCellList){\n            for(neighborCell in zeroCell.perimeterCellList){\n                if(unknownCellSet.contains(neighborCell)){\n                    neighborCell.openCell()\n                    unknownCellSet.remove(neighborCell) \/\/ It can't be unknown any more\n                    activeNumberedCellList.add(neighborCell)\n                    progressMade = true\n                }\n            }\n            deferredRemovalList.add(zeroCell) \/\/ It can't be active anymore, as it's surrounded by definition\n        }\n        activeZeroCellList.removeAll(deferredRemovalList)\n        activeNumberedCellList.removeAll(deferredRemovalList)\n        return progressMade\n    }\n    private fun possibilityEliminationSweep(): Boolean{\n        var progressMade = false\n        val deferredRemovalFromActiveNumberList = ArrayList<Cell>()\n        val deferredAdditionToActiveNumberList = ArrayList<Cell>()\n        for(cell in activeNumberedCellList){\n            val numExpectedMines = cell.getSymbolAsInt()\n            var numUnknownNeighboringCells = 0\n            var numMineNeighboringCells = 0\n            val potentialMarkingCellList = ArrayList<Cell>()\n            for(neighborCell in cell.perimeterCellList){\n                if(knownMineCellSet.contains(neighborCell)){\n                    numMineNeighboringCells++\n                }\n                else if(unknownCellSet.contains(neighborCell)){\n                    potentialMarkingCellList.add(neighborCell)\n                    numUnknownNeighboringCells++\n                }\n            }\n            \/\/ If there are no unknowns in the perimeter, it's surrounded and should no longer be active.\n            if(numUnknownNeighboringCells == 0){\n                deferredRemovalFromActiveNumberList.add(cell)\n            }\n            \/\/ If all mines are accounted for, but there are still unknowns in the perimeter, then those are safe!\n            else if((numExpectedMines == numMineNeighboringCells) && (numUnknownNeighboringCells > 0)){\n                for(identifiedSafe in potentialMarkingCellList){\n                    logIntentionsAndOpenCell(\"If all mines are accounted for around a cell ([${cell.rowIdx},${cell.colIdx}]), but there are unknowns in the perimeter, then those are safe.\", identifiedSafe, false, false)\n                    deferredAdditionToActiveNumberList.add(identifiedSafe)\n                    progressMade = true\n                }\n            }\n            \/\/ If there are an equal number of unknown neighbors to the number of unaccounted for mines, they are mines.\n            else if((numExpectedMines - numMineNeighboringCells) == numUnknownNeighboringCells){\n                for(identifiedMine in potentialMarkingCellList){\n                    logIntentionsAndMarkMine(\"If there are an equal number of unknown neighbors to the number of unaccounted for mines, they are mines.\" +\n                            \"\nThis was found to be the case while evaluating the neighbors of cell [${cell.rowIdx},${cell.colIdx}]\", identifiedMine, false)\n                    deferredRemovalFromActiveNumberList.add(identifiedMine)\n                    progressMade = true\n                }\n            }\n        }\n        activeNumberedCellList.addAll(deferredAdditionToActiveNumberList)\n        activeNumberedCellList.removeAll(deferredRemovalFromActiveNumberList)\n        return progressMade\n    }\n    private fun dump(): String{\n        val objectString = StringBuilder(\"\n\n\")\n        objectString.append(\"\nactiveNumberedCellList:\n\")\n        for(cell in activeNumberedCellList){\n            objectString.append(\"\\t${cell.getCoordinateString()}\")\n        }\n        objectString.append(\"\nactiveUnknownCellList:\n\")\n        for(cell in activeUnknownCellList){\n            objectString.append(\"\\t${cell.getCoordinateString()}\")\n        }\n        objectString.append(\"\nactiveZeroCellList:\n\")\n        for(cell in activeZeroCellList){\n            objectString.append(\"\\t${cell.getCoordinateString()}\")\n        }\n        objectString.append(\"\nunknownCellSet:\n\")\n        for(cell in unknownCellSet){\n            objectString.append(\"\\t${cell.getCoordinateString()}\")\n        }\n        objectString.append(\"\nknownMineCellSet:\n\")\n        for(cell in knownMineCellSet){\n            objectString.append(\"\\t${cell.getCoordinateString()}\")\n        }\n        return objectString.toString()\n    }\n\n    private fun scenarioRunner(): Boolean{\n\n        val unaccountedForMines = numMines - knownMineCellSet.size\n        var guessableCellSet = getGuessableCellSet()  \/\/ These are the cells that are adjacent to a number cell.\n        log(\"$unaccountedForMines unaccounted for mines exist in the field.  \" +\n                \"${guessableCellSet.size} cells are guessable that may have them.  \" +\n                \"There are ${unknownCellSet.size} total unknown cells.\n\" +\n                \"${gridToString()}\")\n        if(guessableCellSet.size == unknownCellSet.size){\n            log(\"All unknown cells are in the guessable set.  So long as there is no ambiguity, we can solve this.\")\n        }\n        else if(guessableCellSet.size < unknownCellSet.size){\n            log(\"Very ambiguous.  We don't know how many mines are in the guessable cells and how many are not.  We must try all number of mines from max to min.\")\n        }\n        val numNoInfoCells = unknownCellSet.size - guessableCellSet.size\n        val maxNumberMinesInGuessableSet =\n            determineMaxNumOfMinesInGuessableSet(guessableCellSet, unaccountedForMines)\n        val minNumberMinesInGuessableSet =\n            determineMinNumOfMinesInGuessableSet(guessableCellSet, unaccountedForMines, numNoInfoCells)\n\n        val validScenarioList = ArrayList<Scenario>()\n\n        for (numMinesAssumedInGuessableSet in minNumberMinesInGuessableSet..maxNumberMinesInGuessableSet) {\n\/\/            if(numMinesAssumedInGuessableSet != unaccountedForMines){\n\/\/                log(\"Temporary bypass of allowing for fewer mines than can be in the set\")\n\/\/                continue\n\/\/            }\n            val scenariosAsIntLists = generateCombinations(\n                guessableCellSet.size,\n                numMinesAssumedInGuessableSet - 1\n            )  \/\/ Why one less than unaccounted for mines?\n            val scenarioList = ArrayList<Scenario>()\n            val guessableCellList = guessableCellSet.toList()\n            for (scenarioAsInts in scenariosAsIntLists) {\n                scenarioList.add(scenarioFromIntList(scenarioAsInts, guessableCellList))\n            }\n            for (scenario in scenarioList) {\n                engageScenario(scenario, true)\n                val valid = validateScenario()\n                if (valid) {\n                    log(\"Valid scenario: $scenario\")\n                    validScenarioList.add(scenario)\n\n                }\n                disengageScenario(scenario)\n            }\n        }\n        if(validScenarioList.size == 1){\n            engageScenario(validScenarioList[0], false)\n            return true\n        }\n        else if(validScenarioList.size > 1){\n            val agreedSubScenario = validScenarioList[0].findScenarioCommonalityForMines(validScenarioList.subList(1, (validScenarioList.size))) \/\/Compare the first to all the others, finding anything that's common to all\n            if(agreedSubScenario.hasMines()){\n                engageScenario(agreedSubScenario, false)\n                return true\n            }\n            else{\n                log(\"No commonality found on mines.  Trying for safe cells\")\n                val agreedSafeCells = findScenarioCommonalityForSafe(guessableCellSet, validScenarioList)\n                if(agreedSafeCells.isNotEmpty()){\n                    for(agreedSafeCell in agreedSafeCells){\n                        logIntentionsAndOpenCell(\"Scenarios have agreed that this is a safe cell\", agreedSafeCell, true, true)\n                    }\n                    return true\n                }\n\/\/                else{\n\/\/                    log(\"No commonality found for safe cells.\")\n\/\/                    val provisionalSafeCells = findScenarioCommonalityForSafe(unknownCellSet, validScenarioList)\n\/\/                    if(provisionalSafeCells.isNotEmpty()){\n\/\/                        for(provisionalSafeCell in provisionalSafeCells){\n\/\/                            logIntentionsAndOpenCell(\"Scenarios have agreed that this is a safe cell\", provisionalSafeCell, true)\n\/\/                        }\n\/\/                        return true\n\/\/                    }\n\/\/                }\n            }\n        }\n        return false\n    }\n    private fun findScenarioCommonalityForSafe(possibleCellSet: Set<Cell>, comparisonScenarioList: List<Scenario>): List<Cell>{\n        val agreedSafeCellList = ArrayList<Cell>()\n        for(possibleSafeCell in possibleCellSet){\n            log(\"\\\"Testing possible cell [${possibleSafeCell.rowIdx},${possibleSafeCell.colIdx}].\")\n            var agreedSafe = true\n            for(comparisonScenario in comparisonScenarioList){\n                if(comparisonScenario.simulatedMineCells.contains(possibleSafeCell)){\n                    log(\"\\\"Cannot agree on safe at [${possibleSafeCell.rowIdx},${possibleSafeCell.colIdx}] as scenario $comparisonScenario has that cell as a mine.\")\n                    agreedSafe = false\n                    break\n                }\n            }\n            if(agreedSafe){\n                log(\"Agreed on safe at [${possibleSafeCell.rowIdx},${possibleSafeCell.colIdx}]\")\n                agreedSafeCellList.add(possibleSafeCell)\n            }\n        }\n        return agreedSafeCellList\n    }\n\n    \/*\n    If the guessableset size is equal to the number of unknown cells, it should be solvable unless there is ambiguity\n    Determine minimum and maximum number of mines that can be in the guessableSet\n    Start from minimum, run scenario, if valid, recur.\n     *\/\n    private fun generationalRecursiveScenarioRunner(): ArrayList<Scenario>{\n        val unaccountedForMines = numMines - knownMineCellSet.size\n        var guessableCellSet = getGuessableCellSet()  \/\/ These are the cells that are adjacent to a number cell.\n        log(\"$unaccountedForMines unaccounted for mines exist in the field.  \" +\n                \"${guessableCellSet.size} cells are guessable that may have them.  \" +\n                \"There are ${unknownCellSet.size} total unknown cells.\")\n        val numNoInfoCells = unknownCellSet.size - guessableCellSet.size\n        if(guessableCellSet.size == unknownCellSet.size){   \/\/ Base Case!\n            log(\"All unknown cells are in the guessable set.  So long as there is no ambiguity, we can solve this.\")\n\n        }\n        else if(guessableCellSet.size < unknownCellSet.size) {\n            log(\"Very ambiguous.  We don't know how many mines are in the guessable cells and how many are not.\")\n        }\n\n        val maxNumberMinesInGuessableSet =\n            determineMaxNumOfMinesInGuessableSet(guessableCellSet, unaccountedForMines)\n        val minNumberMinesInGuessableSet =\n            determineMinNumOfMinesInGuessableSet(guessableCellSet, unaccountedForMines, numNoInfoCells)\n\n        val validScenarioList = ArrayList<Scenario>()\n        for (numMinesAssumedInGuessableSet in minNumberMinesInGuessableSet..maxNumberMinesInGuessableSet) {\n            val scenariosAsIntLists = generateCombinations(\n                guessableCellSet.size,\n                unaccountedForMines - 1\n            )  \/\/ Why one less than unaccounted for mines?\n            val scenarioList = ArrayList<Scenario>()\n            val guessableCellList = guessableCellSet.toList()\n            for (scenarioAsInts in scenariosAsIntLists) {\n                scenarioList.add(scenarioFromIntList(scenarioAsInts, guessableCellList))\n            }\n\n            \/\/ Now we have the scenario combinations as Scenarios.  Time to test them out.\n\n            for (scenario in scenarioList) {\n                engageScenario(scenario, true)\n                val valid = validateScenario()\n                if (valid) {\n                    log(\"Valid scenario at this point. Recursively calling generationalRecursiveScenarioRunner\\\"): ${scenario.toString()}\")\n                    log(\"Recursively calling generationalRecursiveScenarioRunner\")\n                    val validSubScenarios = generationalRecursiveScenarioRunner()\n                    if (validSubScenarios.size == 0) {   \/\/ There are no valid subscenarios.  That means this scenario is no good.\n                        continue\n                    } else if (validSubScenarios.size == 1) {  \/\/ There is one valid subscenario.  This means no ambiguity and that we can use this scenario\n                        validScenarioList.add(scenario.createNewScenarioOnMerge(validSubScenarios[0]))\n                    } else { \/\/ Ambiguity!\n                        \/\/throw AmbiguityException(\"More than one possible solution.\")\n                    }\n                }\n                disengageScenario(scenario)\n            }\n        }\n        return validScenarioList  \/\/ We can never know if we're the first called.  The parent of this will have to handle that.\n    }\n    private fun determineMinNumOfMinesInGuessableSet(guessableCellSet: Set<Cell>, numUnaccountedForMines: Int, numNoInfoCells: Int): Int{\n        if(numNoInfoCells > numUnaccountedForMines){\n            return 0\n        }\n        else{\n            return numUnaccountedForMines - numNoInfoCells\n        }\n         \/\/ TODO\n    }\n    private fun determineMaxNumOfMinesInGuessableSet(guessableCellSet: Set<Cell>, numUnaccountedForMines: Int): Int{\n        return guessableCellSet.size.coerceAtMost(numUnaccountedForMines) \/\/ TODO\n    }\n    private fun scenarioFromIntList(scenarioIndexes: ArrayList<Int>, guessableCellList: List<Cell>): Scenario{\n        val scenario = Scenario()\n        for(simMineIndex in scenarioIndexes){\n            scenario.addSimMine(guessableCellList[simMineIndex])\n        }\n        return scenario\n    }\n    private fun validateScenario(): Boolean{\n        for(cell in activeNumberedCellList){\n            val numExpectedMines = cell.getSymbolAsInt()\n            var numMineNeighboringCells = 0\n            for(neighborCell in cell.perimeterCellList){\n                if(knownMineCellSet.contains(neighborCell)){\n                    numMineNeighboringCells++\n                }\n            }\n            if(numExpectedMines != numMineNeighboringCells){\n                return false\n            }\n        }\n        return true\n\n    }\n    private fun engageScenario(scenario: Scenario, simulationInd: Boolean){\n        for(simMine in scenario.simulatedMineCells){\n            if(simulationInd){\n                logIntentionsAndMarkMine(\"Simulation\", simMine, false)\n            }\n            else{\n                logIntentionsAndMarkMine(\"Validated Simulation for application\", simMine, true)\n            }\n        }\n    }\n    private fun disengageScenario(scenario: Scenario){\n        for(simMine in scenario.simulatedMineCells){\n            simMine.markUnknown()\n            knownMineCellSet.remove(simMine)\n            unknownCellSet.add(simMine)\n        }\n    }\n    private fun generateCombinations(spots: Int, mines: Int): ArrayList<ArrayList<Int>>{\n        val combinations = ArrayList<ArrayList<Int>>()\n        val combinationData = ArrayList<Int>()\n        for(i in 0..mines){\n            combinationData.add(-1)\n        }\n        combinationHelper(combinations, combinationData, 0, spots - 1, 0)\n        return combinations\n\n    }\n    private fun combinationHelper(combinations: ArrayList<ArrayList<Int>>, data: ArrayList<Int>, start: Int, end: Int, index: Int){\n        if (index == data.size) {\n            val combination = data.clone() as (ArrayList<Int>)\n            combinations.add(combination)\n        } else if (start <= end) {\n            data[index] = start\n            combinationHelper(combinations, data, start + 1, end, index + 1)\n            combinationHelper(combinations, data, start + 1, end, index)\n        }\n    }\n    private fun getGuessableCellSet(): MutableSet<Cell>{\n        val guessableCellSet = HashSet<Cell>()\n        for(numberCell in activeNumberedCellList){\n            for(neighborCell in numberCell.perimeterCellList){\n                if(unknownCellSet.contains(neighborCell)){\n                    guessableCellSet.add(neighborCell);\n                }\n            }\n        }\n        return guessableCellSet\n    }\n    fun solveLoop(): Boolean{\n        var progressMade = true\n        while(progressMade){\n            if((knownMineCellSet.size == numMines) && (unknownCellSet.size == 0)){\n                log(\"\n\nThere are no more unknown cells and we have found all the mines.  This is successful.\n\" +\n                        \"${gridToString()}\")\n                return true\n            }\n            else if((numMines - knownMineCellSet.size) == 0){ \/\/ Are there no more mines, but there are unknown cells?  They're safe!\n                 val safeCellList = unknownCellSet.toList()\n                 for(safeCell in safeCellList){\n                     logIntentionsAndOpenCell(\"No more mines exist\", safeCell, true, true)\n                 }\n                return true\n            }\n            else if((numMines - knownMineCellSet.size) == unknownCellSet.size) { \/\/ Are there an equal number of unknown cells and mines? They're mines!\n                val mineCellList = unknownCellSet.toList()\n                for(mineCell in mineCellList){\n                    logIntentionsAndMarkMine(\"No more safe cells exist\", mineCell, true)\n                }\n                return true\n            }\n            else if(activeNumberedCellList.size == 0){ \/\/ Are there no active number cells, and the above solvings won't work?  We can't do anything.\n                log(\"There no active number cells, and we can't make any sweeping solutions?  We can't do anything.\")\n                return false\n            }\n            progressMade = zeroSweep()\n            if(progressMade){\n                \/\/log(\"\n\nProgress was made in zeroSweep.  Continuing. \n${gridToString()}\")\n                continue\n            }\n            else {\n                \/\/log(\"\n\nProgress was not made in zeroSweep.  Escalating. \n${gridToString()}\")\n                progressMade = possibilityEliminationSweep()\n                if (progressMade) {\n                    \/\/log(\"\n\nProgress was made in possibilityEliminationSweep.  Continuing. \n${gridToString()}\")\n                    continue\n                }\n                else {\n                    \/\/log(\"\n\nProgress was not made in possibilityEliminationSweep. Escalating. \n${gridToString()}\")\n                    progressMade = scenarioRunner()\n                    if(progressMade){\n                        \/\/log(\"\n\nProgress was made in scenarioRunner.  Continuing. \n${gridToString()}\")\n                        continue\n                }\n                    else {\n                        \/\/log(\"\n\nProgress was not made in scenarioRunner. Escalating. \n${gridToString()}\")\n                    }\n                }\n            }\n        }\n        log(\"Unable to make progress for a full loop. \n${gridToString()} ${dump()}\")\n        return false\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208781,"user_id":null,"body":"import java.util.LinkedList\nimport java.util.Queue\n\nclass MineSweeper(board: String, nMines: Int) {\n\n    init {\n        println(\"\nboard:\n$board\n\nn = $nMines\n\n\")\n    }\n    \n    private val mineField = board.split(\"\n\")\n        .map { it.split(\" \")\n            .map { it[0].let { when (it) {\n                'x' -> -1;\n                '?' -> null;\n                else -> \"$it\".toInt() } }\n            }.toMutableList()\n        }\n    private var minesLeft = nMines\n\n    fun solve(): String {\n        do {\n            do {\n                while (potentialCellGroups.isNotEmpty()) {\n                    trySolvingCells(potentialCellGroups.poll())\n                }\n            } while (regroupUnresolved())\n            bruteForce()\n        } while (potentialCellGroups.isNotEmpty()) \/\/ brute force can set up this queue again\n        return solution()\n    }\n\n    private fun solution() =\n        if (mineField.any { it.any { it == null } })\n            \"?\"\n        else\n            mineField.map { it.joinToString(separator = \" \") { if (it == -1) \"x\" else \"$it\" } }.joinToString(separator = \"\n\")\n\n    private fun withinBound(row: Int, column: Int) = row in mineField.indices && column in mineField[row].indices\n\n    private fun Pair<Int, Int>.field() = mineField[this.first][this.second]\n\n    private fun Pair<Int, Int>.isMarkedCell(): Boolean =\n        isMarkedCell(row = this.first, column = this.second)\n\n    private fun Pair<Int, Int>.isHiddenCell(): Boolean =\n        isHiddenCell(row = this.first, column = this.second)\n\n    private fun Pair<Int, Int>.isNumberedCell(): Boolean =\n        isNumberedCell(row = this.first, column = this.second)\n\n    private fun Pair<Int, Int>.isResolvedCell(): Boolean =\n        isResolvedCell(row = this.first, column = this.second)\n\n    private fun Pair<Int, Int>.neighbours(): Set<Pair<Int, Int>> =\n        neighbours(row = this.first, column = this.second)\n\n    private fun isHiddenCell(row: Int, column: Int): Boolean =\n        mineField[row][column] == null\n\n    private fun isMarkedCell(row: Int, column: Int): Boolean =\n        mineField[row][column] == -1\n\n    private fun isNumberedCell(row: Int, column: Int): Boolean =\n        mineField[row][column].let { it != null && it >= 0 }\n\n    private fun isResolvedCell(row: Int, column: Int): Boolean =\n        isNumberedCell(row = row, column = column) && this.neighbours(row = row, column = column).all { !it.isHiddenCell() }\n\n    private fun neighbours(row: Int, column: Int): Set<Pair<Int, Int>> =\n        ((row - 1)..(row + 1)).flatMap { r -> ((column - 1)..(column + 1)).map { c -> Pair(r, c) } }\n            .filterNot { it == Pair(row, column) }\n            .filter { withinBound(it.first, it.second) }\n            .toSet()\n\n    private fun selectedCells(predicate: (Int, Int) -> Boolean): Set<Pair<Int, Int>> =\n        mineField.withIndex()\n            .flatMap { irow ->\n                irow.value.withIndex()\n                    .map { icol ->\n                        irow.index to icol.index\n                    }.filter { predicate(it.first, it.second) }\n            }.toSet()\n\n    private var potentialCellGroups: Queue<List<Pair<Int, Int>>> =\n        LinkedList(selectedCells { row, column -> isNumberedCell(row = row, column = column) && !isResolvedCell(row = row, column = column) }.map { listOf(it) })\n\n    private var unresolvedCellGroups: MutableList<MutableList<Pair<Int, Int>>> = mutableListOf()\n\n    private val singleUnresolvedGroupsHistory: MutableSet<Set<Pair<Int, Int>>> = mutableSetOf()\n\n    private fun MutableList<MutableList<Pair<Int, Int>>>.removeFromGroups(cells: Set<Pair<Int, Int>>) {\n        var groupIdx = this.indexOfFirst { group -> cells.any { it in group } }\n        while (groupIdx >= 0) {\n            this[groupIdx].removeAll(cells)\n            if (this[groupIdx].isEmpty())\n                this.removeAt(groupIdx)\n            groupIdx = this.indexOfFirst { group -> cells.any { it in group } }\n        }\n    }\n\n    private fun changed() {\n        singleUnresolvedGroupsHistory.clear()\n    }\n\n    private fun deduce(numberedCells: List<Pair<Int, Int>>, hiddenCells: List<Pair<Int, Int>>, minMines: Int = 0, maxMines: Int = minesLeft): Pair<List<Pair<Pair<Int, Int>, Boolean>>, Int?> {\n        val assumptions = MutableList(hiddenCells.size) { false }\n\n        fun nextAssumption(): Boolean {\n            var idx = 0\n            while (idx < assumptions.size && assumptions[idx])\n                assumptions[idx++] = false\n            if (idx < assumptions.size)\n                assumptions[idx] = true\n            else\n                return true \/\/ overflow\n            return false\n        }\n\n        var uniqueAssumedMinesCount: Int? = null\n        var isAssumedMinesCountUnique: Boolean? = null\n\n        fun isAssumptionFeasible(): Boolean {\n            val assumedMines = hiddenCells.zip(assumptions).filter { it.second }.map { it.first }\n            val assumedMinesCount = assumedMines.count()\n            val test = (assumedMinesCount in minMines.. maxMines) && numberedCells.all {\n                val neighbours = it.neighbours()\n                val neighbourMines = neighbours.count { it.isMarkedCell() }\n                val neighbourAssumptions = neighbours.count { it in assumedMines }\n                (it.field()!! == neighbourMines + neighbourAssumptions)\n            }\n            if (test) {\n                when {\n                    (isAssumedMinesCountUnique == null) -> {\n                        uniqueAssumedMinesCount = assumedMinesCount\n                        isAssumedMinesCountUnique = true\n                    }\n                    isAssumedMinesCountUnique!! -> {\n                        if (uniqueAssumedMinesCount != assumedMinesCount) {\n                            uniqueAssumedMinesCount = null\n                            isAssumedMinesCountUnique = false\n                        }\n                    }\n                }\n            }\n            return test\n        }\n\n        val feasibleScenarios = mutableListOf<List<Boolean?>>()\n        do {\n            if (isAssumptionFeasible())\n                feasibleScenarios.add(assumptions.toList())\n        } while (!nextAssumption())\n        if (feasibleScenarios.isEmpty()) {\n            return Pair(listOf(), uniqueAssumedMinesCount)\n        }\n        val deducedScenario = feasibleScenarios.drop(1).fold(feasibleScenarios[0]) { acc, nextScenario ->\n            acc.zip(nextScenario).map { if (it.first == it.second) it.first else null }\n        }\n        val deduced = hiddenCells.zip(deducedScenario).filter { it.second != null }.map { Pair(it.first, it.second!!) }\n        return Pair(deduced, uniqueAssumedMinesCount)\n    }\n\n    private fun bruteForce() {\n        val hiddenCells = selectedCells(::isHiddenCell)\n        if (hiddenCells.isEmpty())\n            return\n        val hiddenFrontCells = hiddenCells.filter { it.neighbours().any { it.isNumberedCell() } }\n        val hiddenBackCells = hiddenCells - hiddenFrontCells.toSet()\n        val hiddenBackCellsCount = hiddenBackCells.count()\n\n        val numberedFrontCells = hiddenFrontCells.flatMap { it.neighbours() }.filter { it.isNumberedCell() && !it.isResolvedCell() }.distinct()\n        val deduced = deduce(numberedCells = numberedFrontCells, hiddenCells = hiddenFrontCells, minMines = maxOf(0, minesLeft - hiddenBackCellsCount))\n        val deducedFront = deduced.first\n        val deducedFrontMines = deducedFront.filter { it.second }.map { it.first }\n        val deducedFrontNumbered = deducedFront.filterNot { it.second }.map { it.first }\n        val uniqueAssumedFrontMinesCount = deduced.second\n        val uniqueAssumedBackMinesCount = uniqueAssumedFrontMinesCount?.let { minesLeft - it }\n        val deducedBackMines: Set<Pair<Int, Int>> =\n            if (uniqueAssumedBackMinesCount == hiddenBackCellsCount)\n                hiddenBackCells\n            else\n                setOf()\n        val deducedBackNumbered: Set<Pair<Int, Int>> =\n            if (uniqueAssumedBackMinesCount == 0)\n                hiddenBackCells\n            else\n                setOf()\n        (deducedFrontMines + deducedBackMines).forEach {\n            mineField[it.first][it.second] = -1\n            minesLeft--\n        }\n        (deducedFrontNumbered + deducedBackNumbered).forEach {\n            mineField[it.first][it.second] = Game.open(it.first, it.second)\n            potentialCellGroups.add(listOf(it))\n        }\n    }\n\n    private fun trySolvingCells(cells: List<Pair<Int, Int>>) {\n        val allNeighbours = cells.flatMap { it.neighbours() }.distinct()\n        val hiddenNeighbours = allNeighbours.filter { it.isHiddenCell() }\n\n        val deduced = deduce(numberedCells = cells, hiddenCells = hiddenNeighbours).first\n        if (deduced.isEmpty()) {\n            unresolvedCellGroups.add(cells.toMutableList())\n            return\n        }\n        val deducedMines = deduced.filter { it.second }.map { it.first }\n        val deducedNumbered = deduced.filterNot { it.second }.map { it.first }\n        deducedMines.forEach {\n            mineField[it.first][it.second] = -1\n            minesLeft--\n        }\n        deducedNumbered.forEach {\n            mineField[it.first][it.second] = Game.open(it.first, it.second)\n        }\n        val newPotentialCells =\n            ((deducedMines + deducedNumbered)\n                .flatMap { it.neighbours() }\n                .filter { it.isNumberedCell() && !it.isResolvedCell() }\n                .toSet()\n                    + deducedNumbered.filterNot { it.isResolvedCell() }.toSet()\n                    - potentialCellGroups.flatten().toSet())\n                        .filterNot { it.isResolvedCell() }.toSet()\n        val newUnresolvedCells = (cells - newPotentialCells).filterNot { it.isResolvedCell() }.toMutableList()\n\n        potentialCellGroups.addAll(newPotentialCells.map { listOf(it) })\n        unresolvedCellGroups.removeFromGroups(newPotentialCells)\n        if (newUnresolvedCells.isNotEmpty())\n            unresolvedCellGroups.add(newUnresolvedCells)\n        if (deduced.isNotEmpty())\n            changed()\n    }\n\n    private fun Collection<Pair<Int, Int>>.neighbourhood2(): Set<Pair<Int, Int>> =\n        this.flatMap { it.neighbours().flatMap { it.neighbours() }.distinct() }.distinct().toSet() - this.toSet()\n\n    private fun regroupUnresolved(): Boolean {\n        if (unresolvedCellGroups.size == 0)\n            return false \/\/ nothing to regroup anymore\n        if (unresolvedCellGroups.size == 1 && unresolvedCellGroups.single().toMutableSet() in singleUnresolvedGroupsHistory) {\n            unresolvedCellGroups.clear()\n            singleUnresolvedGroupsHistory.clear()\n            return false \/\/ we've fall into an infinite loop\n        }\n        var joined = false\n        while (unresolvedCellGroups.isNotEmpty()) {\n            val group1 = unresolvedCellGroups.removeAt(0).toSet()\n            val neighbourhood = group1.neighbourhood2()\n            val group2 = unresolvedCellGroups.firstOrNull { it.any { it in neighbourhood } }\n            if (group2 != null) {\n                unresolvedCellGroups.remove(group2)\n                potentialCellGroups.add((group1 + group2.toSet()).toList())\n                joined = true\n            } else {\n                potentialCellGroups.add(group1.toList())\n            }\n        }\n        if (!joined && potentialCellGroups.size > 1) {\n            val allAtOnceGroup = potentialCellGroups.flatten()\n            potentialCellGroups.clear()\n            potentialCellGroups.add(allAtOnceGroup) \/\/ last chance - all these cells at once\n        }\n        if (potentialCellGroups.size == 1)\n            singleUnresolvedGroupsHistory.add(potentialCellGroups.single().toSet())\n        return true\n    }\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208782,"user_id":null,"body":"import java.util.*\n\nclass MineSweeper(board: String, private val totalMines: Int) {\n    private val field: MutableList<List<Cell>> = mutableListOf()\n    \/\/ Lists with only cells of one kind for tuning reasons.\n    private val closedCells: MutableList<Cell> = mutableListOf()\n    private val minedCells: MutableList<Cell> = mutableListOf()\n\n    fun solve(): String {\n        var beforeClosedCount: Int\n        while (closedCells.size.also { beforeClosedCount = it } > 0) {\n            if (handleSimpleCases() == beforeClosedCount\n                    && handleComplexCasesWithNeighbours() == beforeClosedCount\n                    && backtracking(beforeClosedCount) == beforeClosedCount)\n                \/\/ No solution without guessing.\n                return CLOSED_CELL\n        }\n        return this.toString()\n    }\n\n    private fun handleSimpleCases(): Int {\n        openSafeNeighbours(closedCells)\n        mutableListOf<Cell>().also { it.addAll(closedCells) }.forEach { handleClosedCell(it) }\n        return closedCells.size\n    }\n\n    private fun openSafeNeighbours(cells: List<Cell>) {\n        for (cell in cells) if (hasSafeNeighbours(cell)) openSafeNeighbours(openNeighboursOf(cell))\n    }\n\n    private fun handleClosedCell(cell: Cell) {\n        for (nc in getNeighbourCells(cell, Cell::hasScore)) {\n            val score = nc.score()\n            val detectedMines = countDetectedMinesInNeighbourCells(nc)\n            if (score <= detectedMines) {\n                open(cell)\n                return\n            }\n            if (getNeighbourCells(nc, Cell::isClosed).size + detectedMines == score) {\n                markMine(cell)\n                return\n            }\n        }\n    }\n\n    private fun backtracking(beforeClosedCount: Int): Int {\n        var result = beforeClosedCount\n        val closedWithScoredNeighbours = closedCells.filter { cc -> getNeighbourCells(cc, Cell::hasScore).isNotEmpty() }.toList()\n        if (closedWithScoredNeighbours.size != closedCells.size)\n            result = handleBacktrackingSolutions(closedWithScoredNeighbours)\n        return if (result == beforeClosedCount\n                && closedCells.size - closedWithScoredNeighbours.size < field.size + field[0].size)\n            handleBacktrackingSolutions(closedCells.toList()) else result\n    }\n\n    private fun handleBacktrackingSolutions(btCells: List<Cell>): Int {\n        val solutions = mutableListOf<List<Cell>>()\n        backtracking(btCells, 0, solutions, closedCells.size == btCells.size)\n        if (solutions.isNotEmpty()) {\n            btCells.filter { c -> solutions.all { it.contains(c) } }\n                .forEach { markMine(it) }\n            btCells.filter { c -> solutions.none { it.contains(c) } }\n                .forEach { open(it) }\n        }\n        return closedCells.size\n    }\n\n    private fun backtracking(btCells: List<Cell>, index: Int, solutions: MutableList<List<Cell>>, fullBt: Boolean) {\n        if (fullBt && allCellsValid() || !fullBt && partSolutionValid()) {\n            solutions.add(btCells.filter { it.isMine() }\n                .map { Cell(it.row, it.col, MINE_CELL) }.toList())\n            return\n        }\n        for (i in index until btCells.size) {\n            if (totalMines <= minedCells.size) return\n            val cell = btCells[i]\n            markMine(cell)\n            if (isMinePossible(cell)) backtracking(btCells, i + 1, solutions, fullBt)\n            close(cell)\n        }\n    }\n\n    private fun allCellsValid(): Boolean {\n        return totalMines == minedCells.size && field.flatMap { it.toList() }.all { isCellValid(it) }\n    }\n\n    private fun partSolutionValid(): Boolean {\n        return totalMines >= minedCells.size && field.flatMap { it.toList() }.all { isCellValid(it) }\n    }\n\n    private fun isCellValid(cell: Cell): Boolean {\n        val mineNeighbours = countDetectedMinesInNeighbourCells(cell)\n        return !cell.hasScore() || cell.score() == mineNeighbours\n    }\n\n    private fun isMinePossible(mine: Cell): Boolean {\n        for (cell in getNeighbourCells(mine, Cell::hasScore)) {\n            if (cell.score() < countDetectedMinesInNeighbourCells(cell)) return false\n        }\n        return true\n    }\n\n    private fun hasSafeNeighbours(cell: Cell): Boolean {\n        return cell.hasScore() && cell.score() <= countDetectedMinesInNeighbourCells(cell)\n    }\n\n    private fun handleComplexCasesWithNeighbours(): Int {\n        val cells = field.flatMap { it.toList() }.filter { it.hasScore() }\n            .filter { sc -> getNeighbourCells(sc, Cell::isClosed).isNotEmpty() }\n            .toList()\n        for (cell in cells) {\n            val scoredNeighbours =\n                getNeighbourCells(cell, Cell::hasScore).flatMap { nc ->\n                    val ncList = ArrayList(getNeighbourCells(nc, Cell::hasScore))\n                    ncList.add(0, nc)\n                    ncList\n                }.distinct().filter { it != cell }.toList()\n            for (other in scoredNeighbours) {\n                val disjointOthers = getDisjointNeighbours(other, scoredNeighbours)\n                handleUniqueNeighbours(cell, disjointOthers)\n            }\n        }\n        return closedCells.size\n    }\n\n    private fun getDisjointNeighbours(neighbour: Cell, neighbours: List<Cell>): List<Cell> {\n        val result = mutableListOf<Cell>()\n        result.add(neighbour)\n        neighbours.filter { it.hasPosition(neighbour.row, neighbour.col) }\n            .filter { Collections.disjoint(getNeighbourCells(it, Cell::isClosed), getNeighbourCells(neighbour, Cell::isClosed)) }\n            .firstOrNull()?.let { result.add(it) }\n        return result\n    }\n\n    private fun handleUniqueNeighbours(cell: Cell, disjointOthers: List<Cell>): Boolean {\n        val cellClosedNeighbours = getNeighbourCells(cell, Cell::isClosed)\n        val disjointOthersClosedNeighbours = disjointOthers\n            .flatMap { getNeighbourCells(cell, Cell::isClosed) }\n            .toList().toSet()\n        if (disjointOthers.size == 1 && cellClosedNeighbours\n                .any { disjointOthersClosedNeighbours.contains(it) }) {\n            val uniqueCellNeighbours = cellClosedNeighbours\n                .filter { !disjointOthersClosedNeighbours.contains(it) }.toList()\n            val uniqueOtherCellNeighbours = disjointOthersClosedNeighbours\n                .filter { !cellClosedNeighbours.contains(it) }.toList()\n            if (uniqueCellNeighbours.isNotEmpty() && uniqueOtherCellNeighbours.isNotEmpty()) {\n                val other = disjointOthers[0]\n                val minSharedCellHiddenMines =\n                    cell.score() - countDetectedMinesInNeighbourCells(cell) - uniqueCellNeighbours.size\n                if (minSharedCellHiddenMines > 0 && other.score() - minSharedCellHiddenMines - countDetectedMinesInNeighbourCells(other) == 0) {\n                    uniqueOtherCellNeighbours.forEach{ open(it) }\n                    return true\n                }\n            }\n        }\n        if (disjointOthersClosedNeighbours.isNotEmpty() && cellClosedNeighbours.containsAll(disjointOthersClosedNeighbours)) {\n            val uniqueCellNeighbours = cellClosedNeighbours\n                .filter { !disjointOthersClosedNeighbours.contains(it) }.toList()\n            if (uniqueCellNeighbours.isNotEmpty()) {\n                val cellHiddenMines = countHiddenMines(cell, disjointOthers)\n                if (cellHiddenMines <= 0) {\n                    uniqueCellNeighbours.forEach{ open(it) }\n                    return true\n                }\n                if (cellHiddenMines >= uniqueCellNeighbours.size) {\n                    uniqueCellNeighbours.forEach{ markMine(it) }\n                    return true\n                }\n            }\n        }\n        return if (disjointOthers.size > 1) handleUniqueNeighbours(cell, listOf(disjointOthers[0])) else false\n    }\n\n    private fun countHiddenMines(cell: Cell, disjointNeighbours: List<Cell>): Int {\n        var result = cell.score() - countDetectedMinesInNeighbourCells(cell)\n        for (neighbour in disjointNeighbours) result -= neighbour.score() - countDetectedMinesInNeighbourCells(neighbour)\n        return result\n    }\n\n    private fun openNeighboursOf(safeCell: Cell): List<Cell> {\n        val opened = getNeighbourCells(safeCell, Cell::isClosed)\n        opened.forEach{ open(it) }\n        return opened\n    }\n\n    private fun open(cell: Cell) {\n        closedCells.remove(cell)\n        val score = Game.open(cell.row, cell.col)\n        cell.value = \"\" + score\n    }\n\n    private fun markMine(cell: Cell) {\n        if (cell.isClosed()) closedCells.remove(cell)\n        cell.value = MINE_CELL\n        minedCells.add(cell)\n    }\n\n    private fun close(cell: Cell) {\n        if (cell.isMine()) minedCells.remove(cell)\n        cell.value = CLOSED_CELL\n        closedCells.add(cell)\n    }\n\n    private fun countDetectedMinesInNeighbourCells(cell: Cell) = getNeighbourCells(cell, Cell::isMine).size\n\n    private fun getNeighbourCells(cell: Cell, filter: (input: Cell) -> Boolean): List<Cell> {\n        val result = mutableListOf<Cell>()\n        findCellBy(cell.row - 1, cell.col - 1)?.let { if (filter(it)) result.add(it) }\n        findCellBy(cell.row - 1, cell.col)?.let { if (filter(it)) result.add(it) }\n        findCellBy(cell.row - 1, cell.col + 1)?.let { if (filter(it)) result.add(it) }\n        findCellBy(cell.row, cell.col - 1)?.let { if (filter(it)) result.add(it) }\n        findCellBy(cell.row, cell.col + 1)?.let { if (filter(it)) result.add(it) }\n        findCellBy(cell.row + 1, cell.col - 1)?.let { if (filter(it)) result.add(it) }\n        findCellBy(cell.row + 1, cell.col)?.let { if (filter(it)) result.add(it) }\n        findCellBy(cell.row + 1, cell.col + 1)?.let { if (filter(it)) result.add(it) }\n        return result\n    }\n\n    fun findCellBy(row: Int, col: Int): Cell? {\n        return if (row >= 0 && col >= 0 && row < field.size && col < field[row].size) {\n            field[row][col]\n        } else null\n    }\n\n    override fun toString(): String {\n        val builder = StringBuilder()\n        val lastCell = field[field.size - 1][field[field.size - 1].size - 1]\n        for (row in 0..lastCell.row) {\n            for (col in 0..lastCell.col) {\n                val cell = findCellBy(row, col)\n                builder.append(cell!!.value).append(\" \")\n            }\n            builder.replace(builder.length - 1, builder.length, \"\n\")\n        }\n        return builder.toString().trim { it <= ' ' }\n    }\n\n    data class Cell(val row: Int, val col: Int, var value: String) {\n        fun score() = value.toInt()\n        fun hasScore() = !(isMine() || isClosed())\n\n        fun isClosed() = CLOSED_CELL == value\n        fun isMine() = MINE_CELL == value\n\n        fun hasPosition(row: Int, col: Int) = this.row == row && this.col == col\n\n        override fun equals(other: Any?): Boolean {\n            if (this === other) return true\n            if (other == null || javaClass != other.javaClass) return false\n            val cell = other as Cell\n            return row == cell.row && col == cell.col\n        }\n\n        override fun hashCode(): Int {\n            var result = row\n            result = 31 * result + col\n            return result\n        }\n    }\n\n    companion object {\n        private const val CLOSED_CELL = \"?\"\n        private const val MINE_CELL = \"x\"\n    }\n\n    init {\n        val rows = board.split(\"\n\".toRegex())\n        for (rowNr in rows.indices) {\n            val cols = rows[rowNr].split(\" \".toRegex()).toTypedArray()\n            val newRow = mutableListOf<Cell>()\n            field.add(newRow)\n            for (colNr in cols.indices) {\n                val cell = Cell(rowNr, colNr, cols[colNr])\n                newRow.add(cell)\n                if (cell.isClosed()) closedCells.add(cell)\n            }\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208783,"user_id":null,"body":"typealias PartialSolutions<T> = List<Map<T, Char>>\n\nclass MineSweeper(board: String, nMines: Int) {\n    val nMines = nMines\n    val tiles = build(board)\n    val unsolveable = listOf<Map<Tile, Char>>()\n\n    fun solve(): String {\n        tiles\n            .filter { x -> x.status == Status.Clear }\n            .forEach { t -> t.openRecursive(force = true) }\n            \n        while (true) {\n            val nextMove = step(tiles, nMines)\n            if (nextMove.isEmpty()) return \"?\"\n            nextMove.forEach { m -> \n                m.forEach { (t, isMine) -> \n                    if (isMine == '1') t.markMine() else t.openRecursive()\n                }\n            }\n            if (tiles.count { x -> x.status == Status.Unknown } == 0) {\n                return output(tiles)\n            }\n        }\n    }\n    \n    fun step(tiles: List<Tile>, nMines: Int): List<Map<Tile, Char>> {\n        \/\/ Look at each numbered tile adjacent to an unknown\n        \/\/ Generate a set of all possible placements satisfying the number of adjacent mines\n        val placements = tiles\n            .filter { t -> t.status == Status.Danger }\n            .filter { t -> t.adjacent.any { a -> a.status == Status.Unknown }}\n            .map(::partials)\n        \n        \/\/ No numbered squares next to unknowns: use the total number of mines to deduce \n        \/\/ whether all the remaining squares are empty or mines, or the map is unsolveable\n        if (placements.size == 0) {\n            val knownMines = tiles.knownMines()\n            val unknown = tiles.unknown()\n            return when {\n               nMines == knownMines -> completeRemaining(tiles, '0')\n               nMines == unknown + knownMines -> completeRemaining(tiles, '1')\n               else -> unsolveable\n            }\n        }\n        \n        \/\/ Any placements that only have a single valid configuration can be applied immediately\n        val certain = placements.filter { m -> m.size == 1 }\n        if (certain.any()) { return certain.flatten() }\n        \n        \/\/ All overlapping placements must be consistent with each other\n        val distinct = mergeConnected(placements)\n        if (distinct.size == 0) {\n            return unsolveable\n        }\n        \n        \/\/ Merged groups that only have a single consistent result can be applied immediately\n        if (distinct.any { x -> x.size == 1 }) {\n            return distinct\n                .filter { x -> x.size == 1 }\n                .flatten()\n        }\n        \n        \/\/ The overall next move must not introduce too many mines or not leave enough space for remaining mines\n        \/\/ Cross-join the distinct areas to get all possible sets of next moves\n        val knownMines = tiles.knownMines()\n        val unknown = tiles.unknown()\n        val combined = expandNextMoves<Tile>(distinct)\n            .filter { x -> \n                x.values.count { it == '1' } <= nMines - knownMines \n                &&\n                x.values.count { it == '1' } + (unknown - x.values.size) >= (nMines - knownMines)\n            }\n        \n        \/\/ All tiles for which all scenarios agree can be applied\n        \/\/ If none agree, the map cannot be solved\n        val commonBits = extractCommonTiles<Tile>(combined)\n        return if (commonBits.size > 0) {\n            listOf(commonBits)\n        } else { \n            unsolveable \n        }\n    }\n    \n    fun partials(tile: Tile): PartialSolutions<Tile> {\n        if (tile.status != Status.Danger) error(\"Only use for mine-adjacent tiles\")\n        val u = tile.adjacent.filter { x -> x.status == Status.Unknown }\n        val m = tile.adjacent.count { x -> x.status == Status.Mine }\n        return combinations(u.size, tile.n - m).map { com -> u.zip(com.toList()).toMap() }\n    }\n\n    fun <T> mergeConnected(partials: List<PartialSolutions<T>>): List<PartialSolutions<T>> {\n        val merged = mutableSetOf<Int>()\n        val nextSet = partials.mapIndexedNotNull { i, p1 ->\n            \/\/ If a partial is merged, it is removed from the pool\n            if (i in merged) {\n                return@mapIndexedNotNull null\n            }\n            \/\/ Check every other non-merged partial and merge if they overlap\n            partials.forEachIndexed { j, p2 ->\n                if (j in (merged + i)) return@forEachIndexed\n                val overlap = p1[0].keys.intersect(p2[0].keys)\n                if (overlap.any()) {\n                    merged.add(i)\n                    merged.add(j)\n                    \/\/ The merged partial should contain only the set of potential solutions \n                    \/\/ that are consistent with each other\n                    return@mapIndexedNotNull p1.flatMap { group ->\n                        p2.mapNotNull { nextGroup ->\n                            if (overlap.all { t -> group[t] == nextGroup[t] }) {\n                                group + nextGroup\n                            } else {\n                                null\n                            }\n                        }\n                    }\n                }\n            }\n            \/\/ No overlaps, it's an island\n            return@mapIndexedNotNull p1\n        }\n        if (nextSet.size < partials.size) return mergeConnected(nextSet)\n        return nextSet\n    }\n    \n    fun <T> expandNextMoves(partials: List<PartialSolutions<T>>): PartialSolutions<T> {\n        return partials.reduce { acc, next -> \n            acc.flatMap { s -> \n                next.map { n -> n + s }\n            }\n        }\n    }\n    \n    fun <T> extractCommonTiles(partials: PartialSolutions<T>): Map<T, Char> =\n        partials[0].mapNotNull { (k, v) ->\n            if (partials.all { p -> p[k] == v }) { Pair(k, v) } else { null }\n        }.toMap()\n        \n    fun <T> trimSolutionWithTooManyMines(partial: PartialSolutions<T>, mLimit: Int) =\n        partial.filter { x -> x.values.count { it == '1' } <= mLimit }\n        \n    fun completeRemaining(tiles: List<Tile>, isMine: Char) = listOf(\n        tiles\n            .filter { x -> x.status == Status.Unknown }\n            .associateWith { isMine }\n    )\n    \n    fun build(board: String): List<Tile> {\n        val tiles = board\n            .split(\"\n\")\n            .mapIndexed { y, row -> \n                row.split(\" \").mapIndexed { x, c -> \n                    Tile(x, y, if (c == \"?\") Status.Unknown else Status.Clear)\n                }\n            }\n        val offsets = listOf(\n            Pair(-1, -1), Pair(0, -1), Pair(1, -1), \n            Pair(-1, 0),               Pair(1, 0), \n            Pair(-1, 1),  Pair(0, 1),  Pair(1, 1)\n        )\n        return tiles.also {\n            val maxX = it[0].size - 1\n            val maxY = it.size - 1\n            it.forEachIndexed { y, row ->\n                row.forEachIndexed { x, t ->\n                    t.adjacent = offsets.mapNotNull { o -> \n                        if (x + o.first in 0..maxX && y + o.second in 0..maxY) {\n                            tiles[y + o.second][x + o.first]\n                        } else {\n                            null\n                        }\n                    }\n                }\n            }\n        }.flatten()\n    }\n    \n    data class Tile(val x: Int, val y: Int, var status: Status) {\n        lateinit var adjacent: List<Tile>\n        var n = 0\n        fun openRecursive(force: Boolean = false) {\n            if (!force && status != Status.Unknown) return\n            n = Game.open(y, x)\n            status = if (n > 0) Status.Danger else Status.Clear\n            if (status == Status.Clear) adjacent.forEach { t ->\n                t.openRecursive()\n            }\n        }\n        fun markMine() {\n            status = Status.Mine\n        }\n        fun toMapString() = when (status) {\n            Status.Unknown -> \"?\"\n            Status.Clear -> \"0\"\n            Status.Danger -> \"$n\"\n            Status.Mine -> \"x\"\n        }\n        override fun toString() = \"($x, $y)\"\n    }\n    \n    fun List<Tile>.knownMines() = this.count { x -> x.status == Status.Mine }\n    \n    fun List<Tile>.unknown() = this.count { x -> x.status == Status.Unknown }\n    \n    fun output(tiles: List<Tile>) = tiles\n        .groupBy { t -> t.y }\n        .toList()\n        .joinToString(\"\n\") { row -> row.second.joinToString(\" \") { t -> t.toMapString() } }\n    \n    enum class Status { Unknown, Clear, Danger, Mine }\n    \n    \/\/ Generate all valid combinations of n mines in m places: [\"011\", \"101\", \"110\"]\n    companion object Helper {\n        val memo = mutableMapOf<Pair<Int, Int>, List<String>>()\n        fun combinations(places: Int, mines: Int): List<String> {\n            return memo.getOrPut(Pair(places, mines)) {\n                (0..(255 shr (8 - places)))\n                .map { x -> x.toString(2) }\n                .filter { x -> x.count { l -> l == '1' } == mines }\n                .map { x -> x.padStart(places, '0') }\n            }\n        }\n    }\n}\n    ","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208784,"user_id":null,"body":"class MineSweeper(board: String, targetMines: Int) {\n    val board = Board(board, targetMines)\n\n    fun solve(): String {\n        while (true) {\n            board.simplify()\n            if (board.complete) {\n                return board.desc\n            }\n            if (!board.hypothesise()) {\n                return \"?\"\n            }\n        }\n    }\n\n    class BoardSlot(data: String) {\n        var contents = when(data) {\n            \"x\" -> Mine()\n            \"?\" -> Unknown()\n            else -> Clue(data.toInt())\n        }\n        var x = -1\n        var y = -1\n        lateinit var links: Array<BoardSlot>\n\n        private val surrounding get() = links.map { it.contents }\n\n        val shouldOpen get(): List<BoardSlot>? {\n            val clue = contents as? Clue ?: return null\n            if (!clue.isSatisfied(surrounding)) return null\n            return links.filter { it.contents is Unknown }\n        }\n\n        val shouldMarkMine get(): List<BoardSlot>? {\n            val clue = contents as? Clue ?: return null\n            if (!clue.allElseBombs(surrounding)) return null\n            return links.filter { it.contents is Unknown }\n        }\n\n        fun isContradiction(remainingMines: Int): Boolean {\n            val clue = contents as? Clue ?: return false\n            return clue.isContradicted(surrounding, remainingMines)\n        }\n    }\n\n    abstract class GameObject(val confirmed: Boolean, val finalAnswer: Boolean, val desc: String)\n    \n    class Clue(val value: Int): GameObject(true, true, value.toString()) {\n        fun isSatisfied(surrounding: List<GameObject>) = surrounding.mines == value\n        fun allElseBombs(surrounding: List<GameObject>) = surrounding.clear == surrounding.size - value\n        fun isContradicted(surrounding: List<GameObject>, remainingMines: Int) = \n            surrounding.mines > value \n                || surrounding.clear > surrounding.size - value \n                || surrounding.mines + remainingMines < value\n        \n    }\n    class Unknown: GameObject(true, false, \"?\")\n    class Mine: GameObject(true, true, \"x\")\n    class HypotheticalClear: GameObject(false, false, \" \")\n    class HypotheticalMine: GameObject(false, false, \"!\")\n\n    class Board(raw: String, private val targetMines: Int) {\n        val data = raw.split(\"\n\").map { row ->\n            row.split(\" \").map {\n                BoardSlot(it)\n            }\n        }\n\n        val mines get() = data.sumBy{row -> row.count { it.contents is Mine || it.contents is HypotheticalMine}}\n        val height = data.size\n        val width = data[0].size\n        val complete get(): Boolean {\n            var complete = true\n            forEach { x, y ->\n                if (!this[x, y].contents.finalAnswer) {\n                    complete = false\n                }\n            }\n            return complete\n        }\n\n        operator fun get(x: Int, y: Int) = data[y][x]\n\n        init {\n            \/\/Link slots\n            forEach { x, y ->\n                val links = ArrayList<BoardSlot>()\n                val sX = if (x == 0) x else x - 1\n                val eX = if (x == width - 1) x else x + 1\n                val sY = if (y == 0) y else y - 1\n                val eY = if (y == height - 1) y else y + 1\n                for (i in sX..eX) {\n                    for (j in sY..eY) {\n                        if (i == x && j == y) continue\n                        links.add(this[i,j])\n                    }\n                }\n                this[x,y].links = links.toTypedArray()\n                this[x,y].x = x\n                this[x,y].y = y\n            }\n        }\n\n        val desc get() = data.joinToString(\"\n\") {\n            it.joinToString(\" \") { space -> space.contents.desc }\n        }\n\n        fun simplify() {\n            clearHypotheticals()\n            performSimpleLogic(\n                { reveal(it) },\n                { Mine() }\n            )\n\n            if (data.sumBy { row -> row.count { it.contents is Unknown }} + mines == targetMines) {\n                forEach { x, y ->\n                    if (this[x,y].contents is Unknown) {\n                        this[x,y].contents = Mine()\n                    }\n                }\n            }\n        }\n\n        fun hypothesise(): Boolean {\n            val unknowns = ArrayList<BoardSlot>()\n            forEach { x, y ->\n                if (this[x, y].contents is Unknown) {\n                    unknowns.add(this[x,y])\n                }\n            }\n\n            for (unknown in unknowns) {\n                if (hypothesise(unknown)) {\n                    return true\n                }\n            }\n\n            return false\n        }\n\n        private fun hypothesise(slot: BoardSlot): Boolean {\n            val canBeMine = !causesContradiction(slot, HypotheticalMine())\n            val canBeClear = !causesContradiction(slot, HypotheticalClear())\n\n            if (canBeMine && !canBeClear) {\n                slot.contents = Mine()\n                return true\n            }\n            else if (canBeClear && !canBeMine) {\n                slot.contents = reveal(slot)\n                return true\n            }\n\n            return false\n        }\n\n        private fun causesContradiction(b: BoardSlot, state: GameObject): Boolean {\n            clearHypotheticals()\n            b.contents = state\n            performSimpleLogic(\n                { HypotheticalClear() },\n                { HypotheticalMine() }\n            )\n            \n            return isContradiction()\n        }\n        \n        private fun performSimpleLogic(clear: (BoardSlot) -> GameObject, mine: () -> GameObject) {\n            var updated = true\n            while (updated) {\n                updated = false\n                forEach { x, y ->\n                    val slot = this[x, y]\n                    val shouldOpen = slot.shouldOpen\n                    if (shouldOpen != null && shouldOpen.isNotEmpty()) {\n                        updated = true\n                        shouldOpen.forEach {\n                            it.contents = clear(it)\n                        }\n                    }\n\n                    val shouldMarkMine = slot.shouldMarkMine\n                    if (shouldMarkMine != null && shouldMarkMine.isNotEmpty()) {\n                        updated = true\n                        shouldMarkMine.forEach {\n                            it.contents = mine()\n                        }\n                    }\n                }\n            }\n        }\n\n        private fun isContradiction(): Boolean {\n            val remainingMines = targetMines - mines\n            if (remainingMines < 0) {\n                return true\n            }\n\n            var contradiction = false\n            var allComplete = true\n            forEach { x, y ->\n                if (this[x,y].isContradiction(remainingMines)) {\n                    contradiction = true\n                }\n\n                if (this[x,y].contents is Unknown) {\n                    allComplete = false\n                }\n            }\n\n            return contradiction || (allComplete && mines < targetMines)\n        }\n\n        fun clearHypotheticals() {\n            forEach { x, y ->\n                if (!this[x,y].contents.confirmed) {\n                    this[x,y].contents = Unknown()\n                }\n            }\n        }\n\n        fun reveal(slot: BoardSlot) = reveal(slot.x, slot.y)\n        fun reveal(x: Int, y: Int) = Clue(Game.open(y, x))\n\n        private fun forEach(action: (Int, Int) -> Unit) {\n            (0 until width).forEach { x ->\n                (0 until height).forEach { y ->\n                    action(x, y)\n                }\n            }\n        }\n    }\n}\n\nval List<MineSweeper.GameObject>.mines get() = count { it is MineSweeper.Mine || it is MineSweeper.HypotheticalMine }\nval List<MineSweeper.GameObject>.clear get() = count { it is MineSweeper.Clue || it is MineSweeper.HypotheticalClear }","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208785,"user_id":null,"body":"\/**\n * Grid\n *\/\ntypealias Grid = List<List<Cell>>\n\n\/**\n * Get and cache the neighbours of a cell, on the cell.\n *\/\nfun Grid.getNeighbours(cell: Cell): Sequence<Cell> {\n\n    if (cell.neighbours.isEmpty()) {\n\n        val neighbours = mutableSetOf<Cell>()\n        for (i in cell.row - 1..cell.row + 1) {\n            for (j in cell.col - 1..cell.col + 1) {\n                try {\n                    neighbours.add(this[i][j])\n                } catch (e: IndexOutOfBoundsException) {}\n            }\n        }\n\n        cell.neighbours = neighbours\n    }\n\n    return cell.neighbours.asSequence()\n}\n\nfun Grid.getNeighbourMines(cell: Cell) = getNeighbours(cell).filter(Cell::isMine)\nfun Grid.getUnknownNeighbours(cell: Cell) = getNeighbours(cell).filter(Cell::isUnknown)\nfun Grid.getAllCells() = flatten().asSequence()\nfun Grid.nMarkedMines() = getAllCells().count { it.indicator == CellIndicator.MINE }\nfun Grid.getUnknownCells() = getAllCells().filter(Cell::isUnknown)\nfun Grid.getRevealedCells() = getAllCells().filter(Cell::isRevealed)\n\nfun Grid.toStringSolution(): String {\n    return map { row ->\n        row.map { cell ->\n            cell.indicator.str\n        }.reduce { str, s -> \"$str $s\" }\n    }.reduce { str, s -> \"$str\n$s\" }\n}\n\n\/**\n * A grid is valid if the indicated number of mines on each revealed cell:\n *      - Is >= the number of marked mines around it.\n *      - Is <= the max number of possible mines around it.\n *\/\nfun Grid.isValid(): Boolean {\n    return getRevealedCells()\n            .all {\n                val nMarkedMines = getNeighbourMines(it).count()\n                val nUnknownMines = getUnknownNeighbours(it).count()\n                nMarkedMines <= it.indicator.nMines()\n                        && it.indicator.nMines() <= nMarkedMines + nUnknownMines\n            }\n}\n\n\n\/**\n * Cell\n *\/\ndata class Cell(val row: Int, val col: Int, var indicator: CellIndicator) {\n    var neighbours: Set<Cell> = setOf()\n\n    fun isRevealed() = indicator.isRevealed\n    fun isUnknown() = indicator == CellIndicator.UNKNOWN\n    fun isMine() = indicator == CellIndicator.MINE\n    fun markAsMine() {\n        indicator = CellIndicator.MINE\n    }\n}\n\n\/**\n * Cell status\n *\/\nenum class CellIndicator(val str: String, val isRevealed: Boolean = true) {\n    MINE(\"x\", false),\n    CLEAR(\"c\", false), \/\/The cell has been pencilled as clear\n    UNKNOWN(\"?\", false),\n    ZERO(\"0\"),\n    ONE(\"1\"),\n    TWO(\"2\"),\n    THREE(\"3\"),\n    FOUR(\"4\"),\n    FIVE(\"5\"),\n    SIX(\"6\"),\n    SEVEN(\"7\"),\n    EIGHT(\"8\");\n\n    fun nMines() = str.toInt()\n\n    companion object {\n        fun factoryFrom(str: String): CellIndicator {\n            return values().find { it.str == str } ?: throw IllegalArgumentException(\"Invalid CellIndicator: $str\")\n        }\n    }\n}\n\n\/**\n * String\n *\/\nfun String.toGrid(): Grid {\n    val boardArray = split(\"\n\").map { it.split(\" \") }\n    val grid: List<MutableList<Cell>> = List(boardArray.size) { MutableList(boardArray[0].size) { Cell(-1, -1, CellIndicator.UNKNOWN)} }\n\n    for (i in boardArray.indices) {\n        for (j in boardArray[i].indices) {\n            val cellStr = boardArray[i][j]\n            grid[i][j] = Cell(i, j, CellIndicator.factoryFrom(cellStr))\n        }\n    }\n    return grid\n}\n\n\/**\n * Exceptions\n *\/\nclass InvalidGameException : Exception()\n\n\/**\n * MineSweeper - The main entry point.\n * MineSweeperPencilled - A version of MineSweeper that marks cells as CellIndicator.CLEAR once it has determined they\n *  are safe rather than opening them.\n *\/\nclass MineSweeperPencilled(board: String, nMines: Int) : MineSweeper(board, nMines) {\n    override fun reveal(cell: Cell) {\n        cell.indicator = CellIndicator.CLEAR\n    }\n}\nopen class MineSweeper(board: String, private val nMines: Int) {\n    private val grid: Grid = board.toGrid()\n\n    fun solve(): String {\n        var gridChanged = true\n        while (gridChanged) {\n\n            performAllSimpleRevealsPossible()\n\n            \/\/Check we are valid before delving into expensive pencilling.\n            checkValidity()\n\n            \/\/This can be expensive so only try to reveal one then try a simple search again.\n            gridChanged = revealOneByPencilling()\n        }\n\n        revealAndMarkUsingNMines()\n\n        checkValidity()\n\n        return if (grid.nMarkedMines() == nMines) grid.toStringSolution() else \"?\"\n    }\n\n    \/**\n     * Using nMines can we deduce anything about the remaining unknown tiles?\n     *\/\n    private fun revealAndMarkUsingNMines() {\n        if (grid.nMarkedMines() == nMines) {\n            grid.getUnknownCells().forEach { reveal(it) }\n        }\n\n        if (grid.getUnknownCells().count() + grid.nMarkedMines() == nMines) {\n            grid.getUnknownCells().forEach(Cell::markAsMine)\n        }\n    }\n\n    \/**\n     * If the game is not valid throw an exception.\n     *\/\n    private fun checkValidity() {\n        if (!isValid()) throw InvalidGameException()\n    }\n\n    \/**\n     * A game is valid if:\n     *      - The indicated mine number of each cell is valid based on it neighbours.\n     *      - We haven't marked more than nMines.\n     *      - There are enough unknown cells on the board for it to be possible to mark nMines.\n     *\/\n    private fun isValid(): Boolean {\n        return grid.isValid()\n                && grid.nMarkedMines() <= nMines\n                && grid.nMarkedMines() + grid.getUnknownCells().count() >= nMines\n    }\n\n    \/**\n     * Reveal a cell, if this is a pencilled game, mark it as clear.\n     *\/\n    open fun reveal(cell: Cell) {\n        cell.indicator = CellIndicator.factoryFrom(Game.open(cell.row, cell.col).toString())\n    }\n\n    \/**\n     * Can be expensive as uses recursion.\n     *\/\n    private fun revealOneByPencilling(): Boolean {\n        \/\/Only want to try unknown cells we know something about, i.e. they have a revealed neighbour.\n        val toTryCells = grid\n                .getRevealedCells()\n                .flatMap { grid.getUnknownNeighbours(it) }\n                .toSet()\n\n        for (cellToTry in toTryCells) {\n            cellToTry.markAsMine()\n            val gridWithGuess = grid.toStringSolution()\n            cellToTry.indicator = CellIndicator.UNKNOWN\n            try {\n                MineSweeperPencilled(gridWithGuess, nMines).solve()\n            } catch (e: InvalidGameException) {\n                reveal(cellToTry)\n                return true\n            }\n        }\n\n        return false\n    }\n\n    \/**\n     * For each revealed cell, attempts to reveal neighbouring cells using the following logic:\n     *      - #indicated = #surroundingMarked => all surroundingUnknown are safe\n     *      - #indicated = #surroundingMarked + #surroundingUnknown => all surroundingUnknown are mines\n     *\n     * Guarantees no more reveals can be performed using this logic once returned.\n     *\/\n    private fun performAllSimpleRevealsPossible() {\n\n        var gridChanged = true\n        while (gridChanged) {\n            gridChanged = performSimpleReveals()\n        }\n    }\n\n    private fun performSimpleReveals(): Boolean {\n        var gridChanged = false\n\n        grid.getRevealedCells()\n                .filter { grid.getUnknownNeighbours(it).count() > 0 }\n                .forEach {\n                    val nIndicatedMines = it.indicator.nMines()\n                    val neighbourMines = grid.getNeighbourMines(it)\n                    val unknownNeighbours = grid.getUnknownNeighbours(it)\n\n                    if (nIndicatedMines == neighbourMines.count()) {\n                        unknownNeighbours.forEach {\n                            reveal(it)\n                            gridChanged = true\n                        }\n                    }\n\n                    if (nIndicatedMines == neighbourMines.count() + unknownNeighbours.count()) {\n                        unknownNeighbours.forEach {\n                            it.markAsMine()\n                            gridChanged = true\n                        }\n\n                    }\n                }\n\n        return gridChanged\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208786,"user_id":null,"body":"import kotlin.coroutines.experimental.buildSequence\n\ntypealias Coord = Pair<Int, Int>\ntypealias Board = Array<CharArray>\n\ninline val Board.rows: Int get () = this.size\ninline val Board.columns: Int get () = this[0].size\ninline operator fun Board.get(xy: Coord): Char = this[xy.first][xy.second]\ninline operator fun Board.set(xy: Coord, c: Char) { this[xy.first][xy.second] = c }\ninline fun Board.copy(): Board = this.map { it.clone() }.toTypedArray()\ninline fun Board.coords(): Sequence<Pair<Coord, Char>> {\n    val board = this\n    return buildSequence {\n        for (x in 0 until board.rows) {\n            for (y in 0 until board.columns) {\n                yield(Pair(Coord(x, y), board[x][y]))\n            }\n        }\n    }\n}\ninline fun Board.neighbors(xy: Coord): Sequence<Coord> {\n    val board = this\n    val (x, y) = xy\n    return buildSequence {\n        for (dx in -1..1) {\n            for (dy in -1..1) {\n                if (dx == 0 && dy == 0) {\n                    continue\n                }\n                val nx = x + dx\n                val ny = y + dy\n                if (nx < 0 || nx >= board.rows || ny < 0 || ny >= board.columns) {\n                    continue\n                }\n                yield(Coord(nx, ny))\n            }\n        }\n    }\n}\ninline fun Board.prettyPrint(): String =\n        this.joinToString(\"\n\") { it.joinToString(\" \") }\n\ninline fun parseBoard(s: String): Board =\n        s.split(\"\n\").map { it.split(\" \").map { s -> s[0] }.toCharArray() }.toTypedArray()\n\nfun binaryComb(n: Int, k: Int): Int {\n    var res = 1\n    for (i in 1..k) {\n        res = res * (n - k + i) \/ i\n    }\n    return res\n}\n\nclass MineSweeper(val board: Board, private var nMines: Int, private val depth: Int) {\n    val stats = hashMapOf<Coord, Stat>()\n\n    constructor(boardStr: String, nMines: Int): this(parseBoard(boardStr), nMines, 0)\n\n    data class Stat(val totalMines: Int, val knownMines: Int, val unknownNeighbors: Int) {\n        val remainMines = totalMines - knownMines\n        val possibilities: Int by lazy {\n            when {\n                remainMines > unknownNeighbors || remainMines < 0 -> 0\n                remainMines == 0 -> 1\n                remainMines == unknownNeighbors -> 1\n                remainMines < unknownNeighbors -> binaryComb(unknownNeighbors, remainMines)\n                else -> -1\n            }\n        }\n    }\n\n    fun getStat(xy: Coord): Stat {\n        val totalMines = board[xy] - '0'\n        var unknownNeighbors = 0\n        var knownMines = 0\n        for (n in board.neighbors(xy)) {\n            when (board[n]) {\n                'x', 'f' -> knownMines += 1\n                '?' -> unknownNeighbors += 1\n            }\n        }\n\n        return Stat(totalMines, knownMines, unknownNeighbors)\n    }\n\n    fun search(): List<Board> {\n        \/\/ ;)\n        if (depth > 10) {\n            return listOf()\n        }\n\n        var totalUnknown = 0\n        for ((xy, c) in board.coords()) {\n            if (c.isDigit()) {\n                stats[xy] = getStat(xy)\n            } else if (c == '?') {\n                totalUnknown += 1\n            }\n        }\n\n        \/\/ Perform inference on digit coordinates with only one possibility\n        val targets = mutableListOf<Pair<Coord, Stat>>()\n        do {\n            targets.clear()\n            for ((xy, stat) in stats) {\n                if (stat.possibilities == 0) {\n                    return listOf()\n                }\n                if (stat.unknownNeighbors > 0) {\n                    targets.add(Pair(xy, stat))\n                }\n            }\n            targets.sortBy { (_, stat) -> stat.possibilities }\n\n            val touched = mutableSetOf<Coord>()\n            for ((xy, stat) in targets) {\n                if (stat.possibilities == 1) {\n                    for (n in board.neighbors(xy)) {\n                        if (board[n] == '?') {\n                            totalUnknown -= 1\n                            touched.add(n)\n                            if (stat.remainMines == 0) {\n                                if (depth > 0) {\n                                    board[n] = 'o'\n                                } else {\n                                    val total = Game.open(n.first, n.second)\n                                    board[n] = '0' + total\n                                }\n                            } else {\n                                assert(stat.unknownNeighbors == stat.remainMines)\n                                board[n] = if (depth > 0) 'f' else 'x'\n                                nMines -= 1\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (!touched.isEmpty()) {\n                for (xy in touched) {\n                    if (board[xy].isDigit()) {\n                        stats[xy] = getStat(xy)\n                    }\n                    for (n in board.neighbors(xy)) {\n                        if (board[n].isDigit()) {\n                            stats[n] = getStat(n)\n                        }\n                    }\n                }\n                continue\n            }\n        } while (!touched.isEmpty())\n\n        \/\/ Fill and exit when possible\n        if (nMines == 0 || nMines == totalUnknown) {\n            for ((xy, c) in board.coords()) {\n                if (c == '?') {\n                    board[xy] = if (nMines == 0) 'o' else 'f'\n                }\n            }\n            return listOf(board)\n        }\n\n        var result = mutableListOf<Board>()\n\n        \/\/ Search by the digit grid with the minimal # of possibilities\n        val firstByDigit = targets.firstOrNull { p -> p.second.possibilities > 1 }\n        if (firstByDigit != null) {\n            val (xy, stat) = firstByDigit\n            for (mask in 0 until 1.shl(stat.unknownNeighbors)) {\n                if (Integer.bitCount(mask) == stat.remainMines) {\n                    val newBoard = board.copy()\n                    var bit = 0\n                    for (n in board.neighbors(xy)) {\n                        if (board[n] == '?') {\n                            if (mask.and(1.shl(bit)) > 0) {\n                                newBoard[n] = 'f'\n                            } else {\n                                newBoard[n] = 'o'\n                            }\n                            bit += 1\n                        }\n                    }\n                    val subSolver = MineSweeper(newBoard, nMines - stat.remainMines, depth + 1)\n                    val rec = subSolver.search()\n                    result.addAll(rec)\n                }\n            }\n        } else {\n            \/\/ Search desperately since no digit can provide us anything\n            var firstRawSearch = null as Coord?\n            for ((xy, c) in board.coords()) {\n                if (c == '?') {\n                    firstRawSearch = xy\n                    break\n                }\n            }\n\n            firstRawSearch?.let { xy ->\n                for (value in listOf('o', 'f')) {\n                    val newBoard = board.copy()\n                    newBoard[xy] = value\n                    val subSolver = MineSweeper(newBoard, nMines - if (value == 'f') 1 else 0, depth + 1)\n                    val rec = subSolver.search()\n                    result.addAll(rec)\n                }\n            }\n        }\n\n        \/\/ Find the intersection of all possible results and decide on the common ones\n        if (depth == 0 && result.size > 1) {\n            var changed = false\n            for ((xy, c) in board.coords()) {\n                if (c == '?') {\n                    var allMines = true\n                    var allOk = true\n                    for (res in result) {\n                        allMines = allMines && (res[xy] == 'x' || res[xy] == 'f')\n                        allOk = allOk && (res[xy] == 'o' || res[xy].isDigit())\n                    }\n                    if (allMines) {\n                        changed = true\n                        board[xy] = 'x'\n                        nMines -= 1\n                    } else if (allOk) {\n                        changed = true\n                        board[xy] = '0' + Game.open(xy.first, xy.second)\n                    }\n                }\n            }\n            if (changed) {\n                return MineSweeper(board, nMines, 0).search()\n            }\n        }\n\n        return result\n    }\n\n    fun solve(): String = search().let { results ->\n        if (results.size != 1) {\n            return \"?\"\n        }\n        val board = results[0]\n        for ((xy, c) in board.coords()) {\n            when (c) {\n                'f' -> board[xy] = 'x'\n                'o' -> board[xy] = '0' + Game.open(xy.first, xy.second)\n            }\n        }\n        board.prettyPrint()\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208787,"user_id":222,"body":"import com.google.common.collect.*\nimport java.util.*\nimport java.lang.Math.*\n\nclass MineSweeper(board: String, private var nMines: Int) {\n    private val map = StringBuilder(board)\n    private val width: Int\n    private val height: Int\n    private var cells = 0\n\n    init {\n        val ws = board.split(\"\n\")\n        height = ws.size\n        width = ws[0].length \/ 2 + 1\n    }\n\n    private fun get(x: Int, y: Int) =\n        map[(y * width + x) * 2].let {\n            if (it == '?') -1 else it.toInt() - 48\n        }\n\n    private fun set(x: Int, y: Int, c: Char): Int {\n        map[(y * width + x) * 2] = c\n        return get(x, y)\n    }\n\n    private fun open(x: Int, y: Int) =\n        set(x, y, (Game.open(y, x) + 48).toChar())\n\n    private inline fun Cell.allNeighbors(block: (Int, Int, Int) -> Unit) {\n        for (y in max(y - 1, 0)..min(y + 1, height - 1)) {\n            for (x in max(x - 1, 0)..min(x + 1, width - 1)) {\n                block(get(x, y), x, y)\n            }\n        }\n    }\n\n    fun solve(): String {\n        val borders = HashSet<CellNum>()\n\n        for (y in 0 until height) {\n            for (x in 0 until width) {\n                val t = get(x, y)\n                if (t >= 0)\n                    borders.add(CellNum(x, y, t))\n            }\n        }\n        cells = width * height - borders.size\n\n        if (borders.isEmpty()) {\n            return when (nMines) {\n                0 -> map.toString().replace('?', '0')\n                cells -> map.toString().replace('?', 'x')\n                else -> \"?\"\n            }\n        }\n\n        while (true) {\n            borders.removeIf { c ->\n                c.allNeighbors { t, x, y ->\n                    if (t < 0)\n                        return@removeIf false\n                }\n                true\n            }\n\n            val moreBorders = ArrayList<CellNum>()\n            val remBorders = ArrayList<CellNum>()\n\n            for (c in borders) {\n                val qs = ArrayList<Cell>()\n                var m = c.n\n                c.allNeighbors { t, x, y ->\n                    if (t > 9)\n                        --m\n                    else if (t < 0)\n                        qs.add(Cell(x, y))\n                }\n                if (qs.size > 0) {\n                    if (m == 0) {\n                        for (d in qs)\n                            moreBorders.add(CellNum(d.x, d.y, open(d.x, d.y)))\n                        remBorders.add(c)\n                        cells -= qs.size\n                    } else if (m == qs.size) {\n                        for (d in qs)\n                            set(d.x, d.y, 'x')\n                        nMines -= m\n                        remBorders.add(c)\n                        cells -= qs.size\n                    }\n                }\n            }\n\n            if (!remBorders.isEmpty()) {\n                borders.removeAll(remBorders)\n                borders.addAll(moreBorders)\n                continue\n            }\n\n            if (nMines < cells && !borders.isEmpty()) {\n                val shores = LinkedHashMultimap.create<Cell, CellNum>()\n\n                for (c in borders) {\n                    c.allNeighbors { t, x, y ->\n                        if (t < 0)\n                            shores.put(Cell(x, y), c)\n                        else if (t > 9)\n                            --c.n\n                    }\n                }\n\n                val shoreList = ArrayList(shores.keySet())\n                val stack = BooleanArray(shoreList.size)\n                var i = 0\n                var numPossb = 0\n                val safeSet = BitSet(stack.size).apply { set(0, stack.size) }\n                val mineSet = BitSet(stack.size).apply { set(0, stack.size) }\n\n                dfs@while (true) {\n                    if (i == stack.size) {\n                        if (cells > stack.size || nMines == 0) {\n                            var valid = true\n                            for (c in borders) {\n                                if (c.n > 0) {\n                                    valid = false\n                                    break\n                                }\n                            }\n                            if (valid) {\n                                ++numPossb\n                                for (j in 0 until stack.size) {\n                                    safeSet.set(j, safeSet.get(j) and !stack[j])\n                                    mineSet.set(j, mineSet.get(j) and stack[j])\n                                }\n                                if (safeSet.isEmpty && mineSet.isEmpty)\n                                    return \"?\"\n                            }\n                        }\n                    } else {\n                        val c0 = shoreList[i]\n                        for (c in shores.get(c0)) {\n                            if (c.n < 1) {\n                                stack[i++] = false\n                                continue@dfs\n                            }\n                        }\n\n                        if (nMines > 0) {\n                            shores.get(c0).forEach { c -> --c.n }\n                            stack[i++] = true\n                            --nMines\n                            continue\n                        }\n                    }\n\n                    while (--i >= 0 && !stack[i])\n                        ;\n\n                    if (i < 0) {\n                        if (numPossb > 0) {\n                            borders.forEach { c -> c.n = get(c.x, c.y) }\n                            safeSet.stream().forEach { j ->\n                                shoreList[j].apply {\n                                    borders.add(CellNum(x, y, open(x, y)))\n                                }\n                                --cells\n                            }\n                            mineSet.stream().forEach { j ->\n                                shoreList[j].apply {\n                                    set(x, y, 'x')\n                                }\n                                --cells\n                                --nMines\n                            }\n                        } else\n                            return \"?\"\n                        break\n                    }\n\n                    ++nMines\n                    shores.get(shoreList[i]).forEach { c -> ++c.n }\n                    stack[i++] = false\n                }\n            }\n\n            if (nMines == 0) {\n                for (y in 0 until height) {\n                    for (x in 0 until width) {\n                        if (get(x, y) < 0)\n                            open(x, y)\n                    }\n                }\n                return map.toString()\n            } else if (nMines == cells) {\n                return map.toString().replace('?', 'x')\n            }\n        }\n    }\n}\n\nopen class Cell(val x: Int, val y: Int) {\n    override fun equals(o: Any?): Boolean {\n        if (o !is Cell)\n            return false\n        return x == o.x && y == o.y\n    }\n\n    override fun hashCode(): Int = y shl 16 or x\n}\n\nclass CellNum(x: Int, y: Int, var n: Int) : Cell(x, y)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5917a2205ffc30ec3a0000a8":[{"id":208788,"user_id":null,"body":"\nimport java.util.*\nimport java.util.stream.IntStream\n\n\/*  7 By 7 Skyscrapers\n *\n *  Given the large number of permutations of the grid, I went with a bit manipulation approach.\n    Something less data-compact would probably be a lot more readable, and perhaps still would have been fast enough.\n\n    Anyway, to describe what I did.  The grid is represented by an array of 7 (GRID_SIZE) longs.  Each long represents\n    all possible combinations that are valid for that row.  This is done by using a bit flag for each possible value.\n    Each grid space for a 7x7 grid uses 7 bits.  They start will all bits set.  Clues are used to reduce those bits.\n    This was done by generating all possible combinations for a single row (7!, 5040 combinations) and grouping them in\n    2D arrays by their resulting clue value.  Then, for each position with a clue, each possible permutation is tested\n    against that row and a new bit mask is made that consist of all possible remaining combinations for that row.\n\n    In order to quickly process the columns, the grid is flipped, changing the columns into rows so that their\n    permutations can be compared to the possible combinations for their clues.  Once processing the clues doesn't result\n    in reducing the number of possible board configurations, the rows without clues are checked against all possible\n    permutations.  When neither clue processing nor clueless processing further refines the possibilities, the final\n    zed.d0c.solution is reached dynamically by finding the row with the least number of permutations and iterating through them,\n    attempting to solve the puzzle with that iteration added as a constraint on the possible board configurations.  This\n    continues until a zed.d0c.solution is found or all possible solutions have been determined invalid, at which point the\n    zed.d0c.solution returned would be null.\n*\/\nobject Skyscrapers {\n    \/* Program will accommodate grid sizes up to 8.  The limit of 8 is due to data types, specifically the limit of the\n     * long used to store bit values.\n     *\/\n    private const val GRID_SIZE: Int = 7\n\n    \/\/ pre-built permutations\n    private val permutations = Permutations(GRID_SIZE)\n    val PERMUTATIONS_FOR_CLUE: Array<LongArray> = permutations.permutations\n    val PERMUTATIONS_FOR_REVERSE_CLUE: Array<LongArray> = permutations.reversePermutations\n    val PERMUTATIONS_FOR_COMBINATIONS: MutableMap<Int, LongArray> = HashMap()\n\n    fun solve_puzzle(clues: IntArray): Array<IntArray> {\n        if (((GRID_SIZE * 4 != clues.size) \/\/ clues don't wrap grid\n                    || (GRID_SIZE > 8)) \/\/ grid row permutations won't fit in a long\n        ) throw IllegalArgumentException()\n        val gridPuzzle = GridPuzzle(GRID_SIZE, clues)\n        return gridPuzzle.solution().orElseThrow()\n    }\n}\n\ninternal class GridStats {\n    var grid: LongArray\n    var flipped: Boolean\n    var permutationCount: IntArray\n\n    constructor(size: Int) {\n        val fullGridLine = (if (size == 8) -1L else ((1L shl (size * size)) - 1))\n        grid = LongArray(size) { fullGridLine }\n        flipped = false\n        permutationCount = IntArray(2 * size)\n    }\n\n    constructor(grid: LongArray, flipped: Boolean, permutationCount: IntArray) {\n        this.grid = grid\n        this.flipped = flipped\n        this.permutationCount = permutationCount\n    }\n\n    fun with(index: Int, l: Long): GridStats {\n        val newGrid: LongArray = grid.copyOf(grid.size)\n        newGrid[index] = l\n        return GridStats(newGrid, flipped, permutationCount.copyOf(permutationCount.size))\n    }\n}\n\ninternal class GridPuzzle {\n    private var size: Int\n    private var clues: IntArray\n    private var gridStats: GridStats\n\n    constructor(gridSize: Int, clues: IntArray) {\n        size = gridSize\n        this.clues = clues\n        gridStats = GridStats(size)\n    }\n\n    constructor(gridSize: Int, clues: IntArray, stats: GridStats) {\n        size = gridSize\n        this.clues = clues\n        gridStats = stats\n    }\n\n    fun solution(): Optional<Array<IntArray>> {\n        do {\n            while (processClues()) flipTheGrid()\n        } while (processAllClueless())\n        return finalSolution()\n    }\n\n    private fun finalSolution(): Optional<Array<IntArray>> {\n        \/\/ get the index of permutationCount that has the least options, excluding those that have only one option.\n        \/\/ those with a count of one are solved rows and there would be noting to iterate through.\n        val optIndexOfMin: OptionalInt =\n            IntStream.range(0, 2 * size).filter { i -> gridStats.permutationCount[i] != 1 }.reduce { a, b ->\n                if ((gridStats.permutationCount[a] < gridStats.permutationCount[b])) a else b\n            }\n        if (optIndexOfMin.isPresent) {\n            var indexOfMin: Int = optIndexOfMin.asInt\n            if (gridStats.permutationCount[indexOfMin] == 0) return Optional.empty()\n            \/\/ might need to flip the grid to properly interact with the indexOfMin, so XOR\n            if ((indexOfMin < size) xor (!gridStats.flipped)) {\n                flipTheGrid()\n            }\n            if (indexOfMin >= size) indexOfMin -= size\n            for (l: Long in getReducedPermutations(indexOfMin)) {\n                val solution: Optional<Array<IntArray>> =\n                    GridPuzzle(size, clues, gridStats.with(indexOfMin, l)).solution()\n                if (solution.isPresent) return solution\n            }\n            return Optional.empty()\n        }\n        if (gridStats.flipped) flipTheGrid()\n        val solution: Array<IntArray> = Array(size) { IntArray(size) }\n        val mask: Long = (1L shl size) - 1\n        for (i in 0 until size) {\n            var gridLine: Long = gridStats.grid[i]\n            for (j in size - 1 downTo 0) {\n                var bit: Int = (gridLine and mask).toInt()\n                var value = 1\n                while ((bit and 1) == 0) {\n                    bit = bit ushr 1\n                    value++\n                }\n                if (bit > 1) { \/\/ there was more than one possible value, yet here we are returning a solution.\n                    return Optional.empty()\n                }\n                solution[i][j] = value\n                gridLine = gridLine ushr size\n            }\n        }\n        return Optional.of(solution)\n    }\n\n    private fun flipTheGrid() {\n        val newGrid = LongArray(size)\n        val mask: Int = (1 shl size) - 1\n        for (i in 0 until size) {\n            for (j in size - 1 downTo 0) {\n                newGrid[j] = (newGrid[j] shl size) or (gridStats.grid[i] and mask.toLong())\n                gridStats.grid[i] = gridStats.grid[i] ushr size\n            }\n        }\n        gridStats.grid = newGrid\n        gridStats.flipped = !gridStats.flipped\n    }\n\n    private fun processClues(): Boolean {\n        var result = false\n        for (i in 0 until size) {\n            val leftClue = getLeftClue(i)\n            val rightClue = getRightClue(i)\n            if ((leftClue > 0) && (rightClue > 0)) {\n                result = result.or(processCombinedClue(i, leftClue - 1, rightClue - 1))\n            } else {\n                if (leftClue > 0) result = result.or(\n                    processClue(\n                        i, Skyscrapers.PERMUTATIONS_FOR_CLUE[leftClue - 1]\n                    )\n                ) else if (rightClue > 0) result = result.or(\n                    processClue(\n                        i, Skyscrapers.PERMUTATIONS_FOR_REVERSE_CLUE[rightClue - 1]\n                    )\n                )\n            }\n        }\n        return result\n    }\n\n    private fun processClue(index: Int, longs: LongArray): Boolean {\n        var newLong = 0L\n        var matches = 0\n        for (bitFlag in longs) {\n            if (bitFlag in gridStats.grid[index]) {\n                newLong = newLong or bitFlag\n                ++matches\n            }\n        }\n        gridStats.permutationCount[index + (if (gridStats.flipped) size else 0)] = matches\n        if (gridStats.grid[index] == newLong) return false\n        gridStats.grid[index] = newLong\n        return true\n    }\n\n    private fun processCombinedClue(i: Int, indexOfLeftClue: Int, indexOfRightClue: Int): Boolean {\n        return processClue(i, getCombinedClue(indexOfLeftClue, indexOfRightClue))\n    }\n\n    private fun getCombinedClue(indexOfLeftClue: Int, indexOfRightClue: Int): LongArray {\n        val key: Int = (indexOfLeftClue shl size) or indexOfRightClue\n        if (!Skyscrapers.PERMUTATIONS_FOR_COMBINATIONS.containsKey(key)) {\n            val leftSet: MutableSet<Long> = HashSet()\n            Arrays.stream(Skyscrapers.PERMUTATIONS_FOR_CLUE[indexOfLeftClue]).forEach(leftSet::add)\n            Skyscrapers.PERMUTATIONS_FOR_COMBINATIONS[key] =\n                Arrays.stream(Skyscrapers.PERMUTATIONS_FOR_REVERSE_CLUE[indexOfRightClue]).filter(leftSet::contains)\n                    .toArray()\n        }\n        return Skyscrapers.PERMUTATIONS_FOR_COMBINATIONS[key]!!\n    }\n\n    private fun processAllClueless(): Boolean {\n        val result: Boolean = processTheCluelessForTheCurrentFlipState()\n        flipTheGrid()\n        return result or processTheCluelessForTheCurrentFlipState()\n    }\n\n    \/\/ the rows that don't have clues can still have their permutations reduced by evaluating them against all possible\n    \/\/ permutations.  For example, if one digit as been reduced to a single digit, then the other digits can't be that\n    \/\/ digit.  It's just a bit slower and less fruitful, so do it last.\n    private fun processTheCluelessForTheCurrentFlipState(): Boolean {\n        var result = false\n        for (i in 0 until size) {\n            \/\/ only process the clueless.  The rows with clues are already processed.\n            if ((getLeftClue(i) == 0) && (getRightClue(i) == 0)) {\n                val matches: IntArray = intArrayOf(0)\n                val newLong: LongArray = longArrayOf(0L)\n                val finalI: Int = i\n                \/\/ this streams every possible permutation of the 7 possible values (7! = 5040).\n                Arrays.stream(Skyscrapers.PERMUTATIONS_FOR_CLUE).flatMapToLong(Arrays::stream).forEach { bitFlag ->\n                    if (bitFlag in gridStats.grid[finalI]) {\n                        newLong[0] = newLong[0] or bitFlag\n                        ++matches[0]\n                    }\n                }\n                gridStats.permutationCount[i + (if (gridStats.flipped) size else 0)] = matches[0]\n                if (gridStats.grid[finalI] != newLong[0]) {\n                    gridStats.grid[finalI] = newLong[0]\n                    result = true\n                }\n            }\n        }\n        return result\n    }\n\n    \/\/ reduces the permutations based on the results of processing\n    private fun getReducedPermutations(index: Int): LongArray {\n        return Arrays.stream(getAllPermutations(index)).filter { bitFlag -> bitFlag in gridStats.grid[index] }.toArray()\n    }\n\n    \/\/ get permutations based on clue, if any.  Doesn't account for reduction of permutations through processing\n    private fun getAllPermutations(index: Int): LongArray {\n        val leftClue: Int = getLeftClue(index)\n        val rightClue: Int = getRightClue(index)\n        if ((leftClue > 0) && (rightClue > 0)) {\n            return getCombinedClue(leftClue - 1, rightClue - 1)\n        }\n        if (leftClue > 0) return Skyscrapers.PERMUTATIONS_FOR_CLUE[leftClue - 1]\n        if (rightClue > 0) return Skyscrapers.PERMUTATIONS_FOR_REVERSE_CLUE[rightClue - 1]\n        return Arrays.stream(Skyscrapers.PERMUTATIONS_FOR_CLUE).flatMapToLong(Arrays::stream).toArray()\n    }\n\n    private fun getLeftClue(index: Int): Int {\n        return (if (gridStats.flipped) clues[index] else clues[(4 * size) - 1 - index])\n    }\n\n    private fun getRightClue(index: Int): Int {\n        return (if (gridStats.flipped) clues[(3 * size) - 1 - index] else clues[size + index])\n    }\n}\n\nprivate operator fun Long.contains(l: Long): Boolean = (l and this) == l\n\ninternal class HeightData {\n    var count: Int = 0\n    var max: Int = 0\n    var reverseCount: Int = 0\n    private var reverseMask: Int\n\n    constructor(mask: Int) {\n        reverseMask = mask\n    }\n\n    constructor(heightData: HeightData) {\n        count = heightData.count\n        max = heightData.max\n        reverseCount = heightData.reverseCount\n        reverseMask = heightData.reverseMask\n    }\n\n    fun add(bit: Int): HeightData {\n        val newData = HeightData(this)\n        \/\/ each building taller than previous max is another one seen\n        if (bit > newData.max) {\n            ++newData.count\n            newData.max = bit\n        }\n        \/\/ can't see anything added until the tallest building remaining is seen\n        \/\/ reverseMask are the remaining buildings\n        if ((bit shl 1) > newData.reverseMask) {\n            ++newData.reverseCount\n        }\n        newData.reverseMask = newData.reverseMask xor bit\n        return newData\n    }\n}\n\ninternal class Permutations(val size: Int) {\n    private var permsArray: ArrayList<ArrayList<Long>> = ArrayList(size)\n    private var reversePermsArray: ArrayList<ArrayList<Long>> = ArrayList(size)\n\n    init {\n        repeat(size) {\n            permsArray.add(ArrayList())\n            reversePermsArray.add(ArrayList())\n        }\n        val mask: Int = (1 shl size) - 1\n        buildPermutations(permsArray, reversePermsArray, size, mask, 0L, size, HeightData(mask))\n    }\n\n    val permutations: Array<LongArray>\n        get() {\n            return getPermutations(permsArray)\n        }\n    val reversePermutations: Array<LongArray>\n        get() {\n            return getPermutations(reversePermsArray)\n        }\n\n    private fun getPermutations(permsList: ArrayList<ArrayList<Long>>): Array<LongArray> =\n        Array(size) { i -> permsList[i].stream().mapToLong(Long::toLong).toArray() }\n\n    companion object {\n        private fun buildPermutations(\n            perms: ArrayList<ArrayList<Long>>,\n            reversePerms: ArrayList<ArrayList<Long>>,\n            size: Int,\n            mask: Int,\n            value: Long,\n            depth: Int,\n            heightData: HeightData\n        ) {\n            if (depth == 0) {\n                perms[heightData.count - 1].add(value)\n                reversePerms[heightData.reverseCount - 1].add(value)\n                return\n            }\n            var iterMask: Int = mask\n            val valueShifted = value shl size\n            while (iterMask != 0) {\n                val bit: Int = iterMask and -iterMask\n                buildPermutations(\n                    perms,\n                    reversePerms,\n                    size,\n                    mask xor bit,\n                    valueShifted or bit.toLong(),\n                    depth - 1,\n                    heightData.add(bit)\n                )\n                iterMask = iterMask xor bit\n            }\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208789,"user_id":null,"body":"import java.util.LinkedList\nimport java.util.Queue\n\nobject Skyscrapers {\n\n    const val dim = 7\n\n    private val templates: List<List<Int>>\n    private val cluesToTemplates: Map<Pair<Int, Int>, Set<Int>> \/\/ maps each pair of clue and anticlue to a set of template numbers\n\n    init {\n        templates = initTemplate(length = this.dim)\n        cluesToTemplates = initClues(templates = this.templates)\n    }\n\n    fun solve_puzzle(clues: IntArray): Array<IntArray> {\n        val puzzle = clues.initialPuzzle()\n        return puzzle.reduceBySplit().toSingleSolution()\n    }\n\n    private fun IntArray.initialPuzzle(): Puzzle =\n        Puzzle(\n            rowTemplates = this.rowClues().map { cluesToTemplates[it]?.toMutableSet() ?: throw UnresolvableException(\"No solution for clue-anticlue pair ${it.first},${it.second}.\") },\n            colTemplates = this.colClues().map { cluesToTemplates[it]?.toMutableSet() ?: throw UnresolvableException(\"No solution for clue-anticlue pair ${it.first},${it.second}.\") },\n        )\n\n    private fun IntArray.colClues() =\n        (0 until dim).map { this[it] to this[3 * dim - 1 - it] }\n\n    private fun IntArray.rowClues() =\n        (0 until dim).map { this[4 * dim - it - 1] to this[dim + it] }\n\n    private fun initTemplate(length: Int): List<List<Int>> =\n        if (length == 1)\n            listOf(listOf(1))\n        else\n            initTemplate(length = length - 1).flatMap { prevTpl ->\n                (0 until length).map { idx -> prevTpl.take(idx) + length + prevTpl.drop(idx) }\n            }\n\n    private fun List<Int>.clue(): Int {\n        var hwm = 0\n        var clue = 0\n        this.forEach {\n            if (it > hwm) {\n                hwm = it\n                clue++\n            }\n        }\n        return clue\n    }\n\n    private fun initClues(templates: List<List<Int>>): Map<Pair<Int, Int>, Set<Int>> {\n        val map = mutableMapOf<Pair<Int, Int>, MutableSet<Int>>((0 to 0) to (templates.indices).toMutableSet())\n        templates.withIndex().forEach {\n            val clue = it.value.clue()\n            val anticlue = it.value.reversed().clue()\n            if (clue to anticlue !in map.keys)\n                map[clue to anticlue] = mutableSetOf()\n            map[clue to anticlue]!!.add(it.index)\n            if (clue to 0 !in map.keys)\n                map[clue to 0] = mutableSetOf()\n            map[clue to 0]!!.add(it.index)\n            if (0 to anticlue !in map.keys)\n                map[0 to anticlue] = mutableSetOf()\n            map[0 to anticlue]!!.add(it.index)\n        }\n        return map\n    }\n\n    private fun List<List<Int>>.merged() = this.drop(1).fold(this[0].map { setOf(it) }) { acc, lst ->\n        acc.zip(lst).map { it.first + it.second }\n    }\n\n    private fun Puzzle.reduceSimple() {\n        val reducer = SimpleReducer(puzzle = this, dim = this@Skyscrapers.dim)\n        reducer.reduce()\n    }\n\n    class UnresolvableException(msg: String = \"Unresolvable puzzle\") : IllegalArgumentException(msg)\n\n    class Puzzle(\n        val rowTemplates: List<MutableSet<Int>>, \/\/ potential row templates\n        val colTemplates: List<MutableSet<Int>>, \/\/ potential col templates\n    ) {\n\n        fun isSolved() = rowTemplates.all { it.size == 1 }\n\n        fun toSingleSolution(): Array<IntArray> =\n            rowTemplates.map { templates[it.single()].toIntArray() }.toTypedArray()\n\n        fun clone(): Puzzle =\n            Puzzle(\n                rowTemplates = rowTemplates.map { it.toMutableSet() },\n                colTemplates = colTemplates.map { it.toMutableSet() },\n            )\n\n    }\n\n    private fun Puzzle.reduceBySplit(): Puzzle =\n        SplitReducer(this).reduce()\n\n    class SplitReducer(\n        val puzzle: Puzzle\n    ) {\n\n        fun reduce(): Puzzle {\n            val puzzles: Queue<Puzzle> = LinkedList(listOf(puzzle))\n            while (puzzles.isNotEmpty()) {\n                try {\n                    val nextPuzzle = puzzles.poll()\n                    nextPuzzle.reduceSimple()\n                    if (nextPuzzle.isSolved())\n                        return nextPuzzle\n                    puzzles.addAll(nextPuzzle.split())\n                } catch (ex: UnresolvableException) { }\n            }\n            throw UnresolvableException()\n        }\n\n        private fun Puzzle.splitPoint(): Pair<Int, Boolean> =\n            (this.rowTemplates.withIndex().filter { it.value.size > 1 }.map { Triple(it.value.size, it.index, true) } +\n                    this.colTemplates.withIndex().filter { it.value.size > 1 }.map { Triple(it.value.size, it.index, false) })\n                .minByOrNull { it.first }!!\n                .let { it.second to it.third }\n\n        private fun Puzzle.split(): List<Puzzle> =\n            this.splitPoint().let { this@split.split(idx = it.first, isRowIdx = it.second) }\n\n        private fun Puzzle.split(idx: Int, isRowIdx: Boolean): List<Puzzle> {\n            val puzzle1 = this.clone()\n            val puzzle2 = this.clone()\n            val puzzleTemplates =\n                if (isRowIdx)\n                    Pair(puzzle1.rowTemplates[idx], puzzle2.rowTemplates[idx])\n                else\n                    Pair(puzzle1.colTemplates[idx], puzzle2.colTemplates[idx])\n\n            puzzleTemplates.first.removeAll(puzzleTemplates.first.sorted().take(puzzleTemplates.first.size \/ 2).toSet())\n            puzzleTemplates.second.removeAll(puzzleTemplates.first)\n            return listOf(puzzle1, puzzle2)\n        }\n\n    }\n\n    class SimpleReducer(\n        val puzzle: Puzzle,\n        val rowMarker: MutableList<Boolean>,\n        val colMarker: MutableList<Boolean>,\n    ) {\n\n        constructor(puzzle: Puzzle, dim: Int) : this(\n            puzzle = puzzle,\n            rowMarker = MutableList(dim) { true },\n            colMarker = MutableList(dim) { true },\n        )\n\n        fun reduce() {\n            while (hasNext())\n                next().let {\n                    reduce(idx = it.first, isRowIdx = it.second)\n                }\n        }\n\n        private fun hasNext(): Boolean = rowMarker.any { it } || colMarker.any { it }\n\n        private fun next(): Pair<Int, Boolean> { \/\/ heuristically pick up next item to induce reduction\n            val rows = puzzle.rowTemplates.map { it.size }.zip(rowMarker).withIndex().filter { it.value.second }.map { Triple(true, it.index, it.value.first) }\n            val cols = puzzle.colTemplates.map { it.size }.zip(colMarker).withIndex().filter { it.value.second }.map { Triple(false, it.index, it.value.first) }\n            return (rows + cols).minByOrNull { it.third }!!.let { it.second to it.first }\n        }\n\n        private fun reduce(idx: Int, isRowIdx: Boolean) {\n            (if (isRowIdx) rowMarker else colMarker)[idx] = false\n            val primaryTemplatesList = if (isRowIdx) puzzle.colTemplates else puzzle.rowTemplates\n            val perpendicularTemplates = if (isRowIdx) puzzle.rowTemplates[idx] else puzzle.colTemplates[idx]\n            val reduced = primaryTemplatesList.reduceTemplatesBy(perpendicularIdx = idx, perpendicularTemplates = perpendicularTemplates)\n            val marker = if (isRowIdx) colMarker else rowMarker\n            reduced.withIndex().forEach {\n                marker[it.index] = marker[it.index] || it.value\n            }\n        }\n\n        private fun List<MutableSet<Int>>.reduceTemplatesBy(perpendicularIdx: Int, perpendicularTemplates: Set<Int>): List<Boolean> =\n            perpendicularTemplates.map { i -> templates[i] }.merged().let { allowedLst ->\n                (this.zip(allowedLst)).map {\n                    val preSize = it.first.size\n                    val allowed = it.second\n                    it.first.removeIf { templates[it][perpendicularIdx] !in allowed }\n                    if (it.first.size == 0)\n                        throw UnresolvableException() \/\/ stop resolving this puzzle immediately\n                    it.first.size < preSize\n                }\n            }\n\n    }\n\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208790,"user_id":null,"body":"object Skyscrapers {\n    fun solve_puzzle(clues: IntArray): Array<IntArray> = Board(clues).solve()\n\n    class Board(\n        private val clueData: IntArray,\n        cellData: Array<Array<List<Int>>>? = null\n    ) {\n        private val size = clueData.size \/ 4\n        private val cells = if (cellData == null) {\n            Array(size) { Array(size) { Cell(size) } }\n        }\n        else {\n            Array(size) { y ->\n                Array(size) { x ->\n                    Cell(cellData[y][x])\n                }\n            }\n        }\n        private val clues: Array<ClueRow>\n        private var firstTime = cellData == null\n\n        init {\n            \/\/Link up cells and clues\n            val clues = ArrayList<ClueRow>()\n            for (i in 0 until size) {\n                val cells0 = ArrayList<Cell>()\n                val cells1 = ArrayList<Cell>()\n                for (j in 0 until size) {\n                    cells0.add(cells[i][j])\n                    cells1.add(cells[j][i])\n                }\n\n                clues.add(\n                    ClueRow(\n                        clueData[4 * size - i - 1],\n                        clueData[size + i],\n                        cells0.toTypedArray()\n                    )\n                )\n\n                clues.add(\n                    ClueRow(\n                        clueData[i],\n                        clueData[3 * size - i - 1],\n                        cells1.toTypedArray()\n                    )\n                )\n            }\n\n            this.clues = clues.toTypedArray()\n        }\n        \n        val output get() = cells.map { it.map { cell -> cell.possible[0] + 1 }.toIntArray() }.toTypedArray()\n\n        fun solve(): Array<IntArray> {\n            while (cells.any { it.any {cell -> !cell.solved }}) {\n                for (clue in clues) {\n                    clue.deduce(firstTime)\n                }\n\n                firstTime = false\n\n                \/\/Prioritise doing this as it is far quicker than deducing!\n                while (clues.any { it.shouldFindNakedSingles} ) {\n                    for (clue in clues) {\n                        clue.findNakedSingles()\n                    }\n                }\n\n                if (!clues.any { it.shouldFindNakedSingles || it.shouldDeduce }) {\n                    \/\/This is really expensive so only do it if we get stuck\n                    \/\/Damn you MedVed!\n                    return bifurcate()\n                }\n            }\n\n            return output\n        }\n\n        private fun bifurcate(): Array<IntArray> {\n            \/\/Find a cell with the fewest possibilities on which to bifurcate\n            var minimum = size\n            var cellToBifurcate: Cell? = null\n            cells.forEach {\n                it.forEach { cell ->\n                    val size = cell.possible.size\n                    if (size in 2 until minimum) {\n                        cellToBifurcate = cell\n                        minimum = size\n                    }\n                }\n            }\n\n            \/\/Check all of the options for the bifurcated cell and hopefully only one will not cause a contradiction!\n            val solutions = ArrayList<Array<IntArray>>()\n            for (i in 0 until minimum) {\n                val bifurcatedData = cells.map {\n                    it.map { cell ->\n                        if (cell != cellToBifurcate) {\n                            cell.possible\n                        } else {\n                            listOf(cell.possible[i])\n                        }\n                    }.toTypedArray()\n                }.toTypedArray()\n                val bifurcatedBoard = Board(clueData, bifurcatedData)\n                bifurcatedBoard.firstTime = false\n                try {\n                    solutions.add(bifurcatedBoard.solve())\n                }\n                catch (e: Exception) {\n                    \/\/We found a contradiction!\n                }\n            }\n\n            if (solutions.size != 1) {\n                \/\/Both options are valid?!\n                throw Exception(\"Fuck. Back to the drawing board!\")\n            }\n\n            return solutions[0]\n        }\n    }\n\n    class Cell(var possible: List<Int>) {\n        constructor(size: Int): this((0 until size).toList())\n\n        val solved get() = possible.size == 1\n        val size get() = possible.size\n\n        val clues = ArrayList<ClueRow>()\n\n        operator fun get(n: Int) = possible[n]\n\n        fun prune(possibilities: Array<Boolean>, source: ClueRow) {\n            val new = possible.filter { possibilities[it] }\n\n            if (new.size != possible.size) {\n                clues.forEach {\n                    it.shouldFindNakedSingles = true\n                    if (it != source) {\n                        it.shouldDeduce = true\n                    }\n                }\n            }\n\n            possible = new\n        }\n\n        fun set(n: Int, source: ClueRow): Boolean {\n            if (solved) return false\n            possible = arrayListOf(n)\n            clues.forEach {\n                it.shouldDeduce = true\n                if (it != source) {\n                    it.shouldFindNakedSingles = true\n                }\n            }\n            return true\n        }\n\n        fun remove(i: Int, source: ClueRow) {\n            if (possible.contains(i)) {\n                possible = possible.filter { it != i }\n                clues.forEach {\n                    it.shouldDeduce = true\n                    if (it != source) {\n                        it.shouldFindNakedSingles = true\n                    }\n                }\n            }\n        }\n\n        fun contains(n: Int) = possible.contains(n)\n    }\n\n    class ClueRow(\n        private val startClue: Int,\n        private val endClue: Int,\n        private val cells: Array<Cell>\n    ) {\n        private val size = cells.size\n\n        var shouldDeduce = true\n        var shouldFindNakedSingles = true\n\n        val consider = IntArray(size)\n        private val indices = IntArray(size)\n        private val possibilities = Array(size) { Array(size) { false } }\n\n        init {\n            cells.forEach {\n                it.clues.add(this)\n            }\n        }\n\n        fun deduce(firstTime: Boolean) {\n            if (!shouldDeduce) return\n            if (firstTime && startClue == 0 && endClue == 0) return\n            reset()\n            var i = 0\n            while (i < size) {\n                check()\n                i = 0\n                indices[i] += 1\n                while (indices[i] == cells[i].size) {\n                    for (j in 0..i) {\n                        indices[j] = 0\n                    }\n                    i += 1\n                    if (i == size) break\n                    indices[i] += 1\n                }\n            }\n\n            prune()\n            shouldDeduce = false\n        }\n\n        private fun check() {\n            for (i in 0 until size) {\n                consider[i] = cells[i][indices[i]]\n            }\n\n            for (i in 0 until size) {\n                for (j in i+1 until size) {\n                    if (consider[i] == consider[j]) return\n                }\n            }\n\n            if (startClue != 0) {\n                var count = 1\n                var highest = consider[0]\n                for (i in 1 until size) {\n                    if (consider[i] > highest) {\n                        highest = consider[i]\n                        count += 1\n                    }\n                }\n                if (count != startClue) return\n            }\n\n            if (endClue != 0) {\n                var count = 1\n                var highest = consider[size - 1]\n                for (i in size - 2 downTo 0) {\n                    if (consider[i] > highest) {\n                        highest = consider[i]\n                        count += 1\n                    }\n                }\n                if (count != endClue) return\n            }\n\n            for (i in 0 until size) {\n                possibilities[i][consider[i]] = true\n            }\n        }\n\n        private fun reset() {\n            for (i in 0 until size) {\n                indices[i] = 0\n                for (j in 0 until size ) {\n                    possibilities[i][j] = false\n                }\n            }\n        }\n\n        private fun prune() {\n            for (i in 0 until size) {\n                cells[i].prune(possibilities[i], this)\n            }\n        }\n\n        fun findNakedSingles() {\n            if (!shouldFindNakedSingles) return\n            shouldFindNakedSingles = false\n\n            for (i in 0 until size) {\n                val cells = cells.filter{ it.contains(i) }\n                if (cells.size != 1) continue\n                if (cells[0].set(i, this)) {\n                    cells.forEach {\n                        if (it != cells[0]) {\n                            it.remove(i, this)\n                        }\n                    }\n                }\n            }\n        }\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208791,"user_id":null,"body":"object Skyscrapers {\n    fun solve_puzzle(clues: IntArray): Array<IntArray> {\n        return SkyscrapersSolver.solve_puzzle(clues)\n    }\n}\n\nconst val N = 7\n\/\/const val N = 4\n\/\/const val N = 3\n\ntypealias List2D<T> = List<List<T>>\n\nfun <T> createList2D(rows: Int, columns: Int, fieldInit: (Int, Int) -> T): List2D<T> =\n        List(rows) {row ->\n            List(columns) {column ->\n                fieldInit(row, column)\n            }\n        }\n\nfun <T> MutableSet<T>.clone(): MutableSet<T> {\n    val original = this\n    return mutableSetOf<T>().apply { addAll(original) }\n}\n\nfun List<MutableSet<Int>>.clone(): List<MutableSet<Int>> =\n        List(this.size){this[it]}.map { it.clone() }\n\n\/\/ r and c can be 0..N-1\nclass SkyscraperField(private val rowPermutationNums: MutableList<Int>,\n                      private val columnPermutationNums: MutableList<Int>) {\n\n    constructor(n: Int):\n            this(MutableList<Int>(n){factorial(n-1)},\n                    MutableList<Int>(n){factorial(n-1)})\n\n    fun removeRow(height: Int): Int {\n        val ix = height-1\n        return --rowPermutationNums[ix]\n    }\n\n    fun removeColumn(height: Int): Int {\n        val ix = height-1\n        return --columnPermutationNums[ix]\n    }\n\n    fun clone(): SkyscraperField {\n        return SkyscraperField(rowPermutationNums, columnPermutationNums)\n    }\n}\n\nenum class Status {\n    SOLVED, SOLVING, UNSOLVABLE\n}\n\nclass Skyscrapers2(private val fields: List2D<SkyscraperField>,\n                   private val rowPermutations: List<MutableSet<Int>>,\n                   private val columnPermutations: List<MutableSet<Int>>) {\n\n    enum class Alignment {\n        ROW, COLUMN\n    }\n\n    private val toRemove = mutableSetOf<Triple<Alignment, Int, Int>>()\n\n    constructor(n: Int):\n            this(createList2D(n, n) {_, _ -> SkyscraperField(n)},\n                    MutableList<MutableSet<Int>>(n) {Permutations.all.clone()},\n                    MutableList<MutableSet<Int>>(n) {Permutations.all.clone()})\n\n    fun clone(): Skyscrapers2 {\n        return Skyscrapers2(\n                createList2D(fields.size, fields.size){i: Int, j: Int -> fields[i][j].clone()},\n                rowPermutations.clone(),\n                columnPermutations.clone())\n    }\n\n    fun removeRow(field: Int, pix: Int) {\n        scheduleRemoveRow(field, pix)\n        remove()\n    }\n\n    fun removeColumn(field: Int, pix: Int) {\n        scheduleRemoveColumn(field, pix)\n        remove()\n    }\n\n    private fun scheduleRemoveRow(field: Int, pix: Int) {\n        toRemove.add(Triple(Alignment.ROW, field, pix))\n    }\n\n    private fun scheduleRemoveColumn(field: Int, pix: Int) {\n        toRemove.add(Triple(Alignment.COLUMN, field, pix))\n    }\n\n    private fun remove() {\n        while (toRemove.isNotEmpty()) {\n            val next = toRemove.first()\n            when (next.first) {\n                Alignment.ROW -> doRemoveRow(next.second, next.third)\n                Alignment.COLUMN -> doRemoveColumn(next.second, next.third)\n            }\n            toRemove.remove(next)\n        }\n    }\n\n    private fun doRemoveRow(rowIx: Int, pix: Int) {\n        if (pix in rowPermutations[rowIx]) {\n            rowPermutations[rowIx].remove(pix)\n            for (columnIx in columnPermutations.indices) {\n                val h = Permutations.index[pix]!![columnIx]\n                if (fields[rowIx][columnIx].removeRow(h)<=0) {\n                    val columnPermutationsToRemove =\n                            columnPermutations[columnIx].intersect(\n                                    Permutations.nx[Pair(rowIx, h)]?:listOf())\n                    for (p in columnPermutationsToRemove) {\n                        scheduleRemoveColumn(columnIx, p)\n                    }\n                }\n            }\n        }\n    }\n\n    private fun doRemoveColumn(columnIx: Int, pix: Int) {\n        if (pix in columnPermutations[columnIx]) {\n            columnPermutations[columnIx].remove(pix)\n            for (rowIx in rowPermutations.indices) {\n                val h = Permutations.index[pix]!![rowIx]\n                if (fields[columnIx][rowIx].removeColumn(h)<=0) {\n                    val rowPermutationsToRemove =\n                            rowPermutations[rowIx].intersect(\n                                    Permutations.nx[Pair(columnIx, h)]?:listOf())\n                    for (p in rowPermutationsToRemove) {\n                        scheduleRemoveRow(rowIx, p)\n                    }\n                }\n            }\n        }\n    }\n\n    fun status(): Status {\n        if (rowPermutations.any{ it.size == 0 } or columnPermutations.any{it.size == 0}) {\n            return Status.UNSOLVABLE\n        }\n        if (rowPermutations.all{ it.size == 1 }) {\n            return Status.SOLVED\n        }\n        return  Status.SOLVING\n    }\n\n    fun split(): Pair<Int,MutableSet<Int>> {\n        val splitRowIx = rowPermutations.indexOfFirst { it.size>1 }\n        return Pair(splitRowIx, rowPermutations[splitRowIx].clone())\n    }\n\n    fun result(): Array<IntArray> {\n        val r = Array(fields.size) { intArrayOf() }\n        for (i in fields[0].indices) {\n            r[i] = (Permutations.index[rowPermutations[i].first()]\n                    ?: listOf()).toIntArray()\n        }\n        return r\n    }\n}\n\nobject SkyscrapersSolver {\n\n    fun solve_puzzle(clues: IntArray): Array<IntArray> {\n        val s = Skyscrapers2(N)\n        applyClues(s, clues)\n        val s1 = reduce(s)\n        return s1.result()\n    }\n\n    private fun applyClues(s: Skyscrapers2, clues: IntArray) {\n        for (i in 0 until 4 * N) {\n            if (clues[i] == 0) {\n                continue\n            }\n            when (i \/ N) {\n                0 ->\n                    for (pix in Permutations.leftNot[clues[i]]!!) {\n                        s.removeColumn(i % N, pix)\n                    }\n                1 ->\n                    for (pix in Permutations.rightNot[clues[i]]!!) {\n                        s.removeRow(i % N, pix)\n                    }\n                2 ->\n                    for (pix in Permutations.rightNot[clues[i]]!!) {\n                        s.removeColumn(N - i % N - 1, pix)\n                    }\n                3 ->\n                    for (pix in Permutations.leftNot[clues[i]]!!) {\n                        s.removeRow(N - i % N - 1, pix)\n                    }\n            }\n        }\n    }\n\n    private fun reduce(s: Skyscrapers2): Skyscrapers2 {\n        if (s.status() == Status.SOLVING) {\n            val (rowIx, pixs) = s.split()\n            for (pix in pixs) {\n                var s1 = s.clone()\n                s1.removeRow(rowIx, pix)\n                s1 = reduce(s1)\n                if (s1.status() == Status.SOLVED) {\n                    return s1\n                }\n            }\n        }\n        return s\n    }\n}\n\n\nobject Permutations {\n    val index = HashMap<Int,List<Int>>()\n    val all = (1..factorial(N)).toMutableSet()\n    val leftNot = HashMap<Int,MutableSet<Int>>()\n    val rightNot = HashMap<Int,MutableSet<Int>>()\n    \/\/ (n, x) -> the permutations whose nth element is x\n    \/\/ n in 0..N-1, x in 1..N\n    val nx = HashMap<Pair<Int, Int>,MutableSet<Int>>()\n\n    init {\n        initPermutations()\n        initViews()\n    }\n\n    private fun initPermutations() {\n        var ix = 0\n        for (p in permutation((1..N).toSet())) {\n            index[++ix] = p\n        }\n    }\n\n    private fun initViews() {\n        val noPermutations = mutableSetOf<Int>()\n        for (i in 1..N) {\n            leftNot[i] = all.clone()\n            rightNot[i] = all.clone()\n            for (j in 1..N) {\n                nx[Pair(i-1, j)] = noPermutations.clone()\n            }\n        }\n        for ((pix, p) in index) {\n            val leftCount = count(p)\n            val rightCount = count(p.reversed())\n            leftNot[leftCount]?.remove(pix)\n            rightNot[rightCount]?.remove(pix)\n            for (i in 0 until N) {\n                nx[Pair(i, p[i])]?.add(pix)\n            }\n        }\n    }\n}\n\nfun factorial(n: Int): Int {\n    var p = 1\n    for (i in 1..n) {\n        p*=i\n    }\n    return p\n}\n\n\/\/ count the visible towers\nfun count(towers: List<Int>) =\n        towers.fold(Pair(0,0)){\n            (max, n), k ->\n            if (k>max) {\n                Pair(k, n+1)\n            } else {\n                Pair(max, n)\n            }\n        }.second\n\nfun <T> permutation(elements: Set<T>): Sequence<MutableList<T>> =\n        sequence {\n            if (elements.isNotEmpty()) {\n                for (e in elements) {\n                    val elements1 = HashSet<T>().apply{addAll(elements)}\n                    elements1.remove(e)\n                    val p1 = permutation(elements1)\n                    for (p in p1) {\n                        p.add(e)\n                        yield(p)\n                    }\n                }\n            } else {\n                yield(mutableListOf())\n            }\n        }\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208792,"user_id":null,"body":"@file:Suppress(\"NOTHING_TO_INLINE\")\n\nconst val SIZE = 7\nconst val FULL_CELL = (1L shl SIZE) - 1\nconst val FULL_ROW = (1L shl (SIZE * SIZE)) - 1\n\n\/\/ This should really be inline class with Kotlin 1.3\ndata class Mask(val value: Long) {\n    inline val isEmpty: Boolean get() = value == 0L\n\n    inline infix fun intersect(other: Mask): Mask {\n        return Mask(this.value and other.value)\n    }\n\n    inline infix fun union(other: Mask): Mask {\n        return Mask(this.value or other.value)\n    }\n\n    inline infix fun diff(other: Mask): Mask {\n        return Mask(this.value and other.value.inv())\n    }\n\n    inline fun getCell(index: Int): Long {\n        val right = (SIZE - index - 1) * SIZE\n        return value shr right and FULL_CELL\n    }\n\n    inline fun getPerm(): IntArray {\n        val nums = IntArray(SIZE)\n        for (i in 0 until SIZE) {\n            val cellMask = this.getCell(i)\n            nums[i] = if (cellMask == 0L) {\n                0\n            } else {\n                java.lang.Long.numberOfTrailingZeros(cellMask) + 1\n            }\n        }\n        return nums\n    }\n\n    companion object {\n        val EMPTY = Mask(0L)\n        val FULL = Mask(FULL_ROW)\n\n        inline fun from(f: (Int) -> Long): Mask {\n            var mask: Long = 0\n            for (j in 0 until SIZE) {\n                mask = (mask shl SIZE) + f(j)\n            }\n            return Mask(mask)\n        }\n    }\n}\n\ninternal inline fun Array<Mask>.transpose(): Array<Mask> {\n    return Array(SIZE) { i -> Mask.from { j -> this[j].getCell(i) } }\n}\n\ninternal class Permutation(val nums: IntArray) {\n    val leftClue: Int\n    val rightClue: Int\n    val mask: Mask\n\n    init {\n        this.leftClue = calcClue(nums, 1)\n        this.rightClue = calcClue(nums, -1)\n        this.mask = calcMask(nums)\n    }\n\n    override fun toString(): String {\n        val ns = StringBuilder()\n        for (n in nums) {\n            ns.append(n)\n        }\n        return \"Permutation{\" +\n                \"nums=\" + ns.toString() +\n                \", leftClue=\" + leftClue +\n                \", rightClue=\" + rightClue +\n                \", value=\" + mask +\n                '}'.toString()\n    }\n\n    companion object {\n        fun calcClue(nums: IntArray, dir: Int): Int {\n            var last = 0\n            val end = if (dir == 1) nums.size else -1\n            val start = if (dir == 1) 0 else nums.size - 1\n            var clue = 0\n            var i = start\n            while (i != end) {\n                if (nums[i] > last) {\n                    last = nums[i]\n                    clue++\n                }\n                i += dir\n            }\n            return clue\n        }\n\n        fun calcMask(nums: IntArray): Mask {\n            var mask: Long = 0\n            for (i in nums.indices) {\n                val bit = nums[i] - 1\n                mask = mask shl nums.size or (1L shl bit)\n            }\n            return Mask(mask)\n        }\n\n        fun genAll(size: Int): Array<Permutation> {\n            val all = arrayListOf<Permutation>()\n            val nums = IntArray(size)\n            val used = BooleanArray(size)\n            fun search(depth: Int) {\n                if (depth == size) {\n                    all.add(Permutation(nums.clone()))\n                    return\n                }\n                for (i in 0 until size) {\n                    if (!used[i]) {\n                        used[i] = true\n                        nums[depth] = i + 1\n                        search(depth + 1)\n                        used[i] = false\n                    }\n                }\n            }\n            search(0)\n            return all.toTypedArray()\n        }\n    }\n}\n\ninternal class PermutationClues(all: Array<Permutation>) {\n    val byClue = run {\n        val index = hashMapOf<Pair<Int, Int>, Pair<Mask, ArrayList<Mask>>>()\n        for (perm in all) {\n            for (key in arrayOf(\n                    Pair(perm.leftClue, perm.rightClue),\n                    Pair(0, perm.rightClue),\n                    Pair(perm.leftClue, 0),\n                    Pair(0, 0)\n            )) {\n                val (bound, list) = index.getOrPut(key) { Pair(Mask.EMPTY, arrayListOf()) }\n                list.add(perm.mask)\n                index[key] = Pair(bound union perm.mask, list)\n            }\n        }\n        index\n    }\n\n    inline fun getBound(leftClue: Int, rightClue: Int): Mask =\n            byClue[Pair(leftClue, rightClue)]?.first ?: Mask.EMPTY\n\n    inline fun getChoices(leftClue: Int, rightClue: Int): List<Mask>? =\n            byClue[Pair(leftClue, rightClue)]?.second\n}\n\nobject Skyscrapers {\n    private var permutations = Permutation.genAll(SIZE)\n    private var permByClues = PermutationClues(permutations)\n\n    private fun search(\n            depth: Int,\n            rows: Array<Mask>, cols: Array<Mask>,\n            rowBounds: Array<Mask>, colBounds: Array<Mask>,\n            clues: IntArray\n    ): Boolean {\n        if (depth == 2 * SIZE) {\n            return true\n        }\n\n        var rb = rowBounds.clone()\n        var cb = colBounds.clone()\n\n        do {\n            var changed = false\n            for (i in 0 until SIZE) {\n                val leftClue = clues[4 * SIZE - i - 1]\n                val rightClue = clues[SIZE + i]\n                (rb[i] intersect permByClues.getBound(leftClue, rightClue)).let {\n                    if (it != rb[i]) {\n                        changed = true\n                    }\n                    rb[i] = it\n                }\n\n                val upClue = clues[i]\n                val downClue = clues[3 * SIZE - i - 1]\n                (cb[i] intersect permByClues.getBound(upClue, downClue)).let {\n                    if (it != cb[i]) {\n                        changed = true\n                    }\n                    cb[i] = it\n                }\n            }\n\n            rb = cb.transpose().run { Array(SIZE) { i -> rb[i] intersect this[i] } }\n            cb = rb.transpose()\n        } while (changed)\n\n        var bestRow = -1\n        var bestCol = -1\n        var bestChoices: List<Mask>? = null\n        for (i in 0 until SIZE) {\n            if (rows[i].isEmpty) {\n                val leftClue = clues[4 * SIZE - i - 1]\n                val rightClue = clues[SIZE + i]\n                val choices = permByClues.getChoices(leftClue, rightClue)?.filter { it union rb[i] == rb[i] }\n                if (bestChoices == null || choices != null && choices.size < bestChoices.size) {\n                    bestRow = i\n                    bestCol = -1\n                    bestChoices = choices\n                }\n            }\n            if (cols[i].isEmpty) {\n                val upClue = clues[i]\n                val downClue = clues[3 * SIZE - i - 1]\n                val choices = permByClues.getChoices(upClue, downClue)?.filter { it union cb[i] == cb[i] }\n                if (bestChoices == null || choices != null && choices.size < bestChoices.size) {\n                    bestRow = -1\n                    bestCol = i\n                    bestChoices = choices\n                }\n            }\n        }\n\n        if (bestChoices == null) {\n            return false\n        }\n\n        if (bestRow != -1) {\n            for (mask in bestChoices) {\n                rows[bestRow] = mask\n                val newRowBounds = Array(SIZE) { i -> if (i == bestRow) mask else rb[i] diff mask }\n                if (search(depth + 1, rows, cols, newRowBounds, cb, clues)) {\n                    return true\n                }\n                rows[bestRow] = Mask.EMPTY\n            }\n        } else {\n            for (mask in bestChoices) {\n                cols[bestCol] = mask\n                val newColBounds = Array(SIZE) { i -> if (i == bestCol) mask else cb[i] diff mask }\n                if (search(depth + 1, rows, cols, rb, newColBounds, clues)) {\n                    return true\n                }\n                cols[bestCol] = Mask.EMPTY\n            }\n        }\n        return false\n    }\n\n    fun solve_puzzle(clues: IntArray): Array<IntArray> {\n        val rows = Array(SIZE) { Mask.EMPTY }\n        val cols = Array(SIZE) { Mask.EMPTY }\n        assert(search(\n                0,\n                rows = rows,\n                cols = cols,\n                rowBounds = Array(SIZE) { Mask.FULL },\n                colBounds = Array(SIZE) { Mask.FULL },\n                clues = clues\n        ))\n\n        return Array(SIZE) { i -> rows[i].getPerm() }\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"59568be9cc15b57637000054":[{"id":208793,"user_id":null,"body":"import java.math.BigInteger\n\/**\n * set true to enable debug\n *\/\ninternal var debug = false\n\ninternal fun elder_age(n: Long, m: Long, k: Long, newp: Long): Long {\n    fun calculate(n: Long, m: Long, k: Long, delta: Long): BigInteger {\n        fun intervalSum(a: Long, b: Long): BigInteger {\n            if (b < a) return BigInteger.ZERO\n            val bigA = BigInteger.valueOf(a)\n            val bigB = BigInteger.valueOf(b)\n            return ((bigA+bigB)*(bigB-bigA+BigInteger.ONE)).shiftRight(1)\n        }\n        if (m > n) return calculate(m, n, k, delta)\n        val nH = java.lang.Long.highestOneBit(n)\n        val mH = if (m < nH) m else nH\n        var result = intervalSum(Math.max(0, delta - k), delta + nH - k - 1) * BigInteger.valueOf(mH)\n        if (n > nH) result = (result + calculate(n - nH, mH, k, delta + nH))\n        if (m > mH) result = (result + calculate(nH, m - mH, k, delta + mH))\n        if (n > nH && m > mH) result = (result + calculate(n - nH, m - mH, k, delta + (mH xor nH)))\n        return result\n    }\n    return calculate(n, m, k, 0).mod(BigInteger.valueOf(newp)).toLong()\n}","lang_id":29,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208794,"user_id":null,"body":"\/**\n * set true to enable debug\n *\/\ninternal var debug = false\n\ninternal fun elder_age(m: Long, n: Long, l: Long, t: Long): Long {\n  val base: Double = 2.toDouble()\n  val small: Long = Math.min(m, n)\n  val big: Long = Math.max(m, n)\n  val power: Long = Math.pow(base, Math.floor(Math.log(big.toDouble()) \/ Math.log(base)).toDouble()).toLong()\n  val rows: Long = Math.min(power, small)\n  val first: Long = Math.max(0, -l)\n  val terms: Long = Math.max(0, power - l - 1)\n  var x = terms - first + 1\n  var y = first + terms\n\n  if (x % 2 > 0) y = Math.floor((y \/ 2).toDouble()).toLong()\n  else if (y % 2 > 0) x = Math.floor((x \/ 2).toDouble()).toLong()\n\n  val series: Long = if (y <= 0) 0 else ((y % t) * (x % t)) % t\n\n  var sum = ((series % t) * (rows % t)) % t\n  if (big > power) sum += elder_age(big - power, rows, l - power, t)\n  if (small > rows) sum += elder_age(power, small - rows, l - rows, t)\n  if (small > rows && big > power) sum += elder_age(big - power, small - rows, l, t)\n\n  return sum % t\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208795,"user_id":53,"body":"import kotlin.math.min\nimport kotlin.math.max\nimport kotlin.math.floor\nimport kotlin.math.log2\nimport kotlin.math.pow\n\ninternal var debug = false\n\ninternal fun elder_age(m: Long, n: Long, l: Long, t: Long): Long {\n  val a = min(m, n)\n  val b = max(m, n)\n  val k = 2.0.pow(floor(log2(b.toDouble()))).toLong()\n  val r = min(k, a)\n  val p = max(0, -l)\n  val q = max(0, k - l - 1)\n  var x = q - p + 1\n  var y = p + q\n  if (x % 2 > 0) y = y \/ 2 else if (y % 2 > 0) x = x \/ 2\n  val w = if (y <= 0) 0 else ((y % t) * (x % t)) % t\n  var s = ((w % t) * (r % t)) % t\n  s += if (b > k) elder_age(b - k, r, l - k, t) else 0\n  s += if (a > r) elder_age(k, a - r, l - r, t) else 0\n  s += if (a > r && b > k) elder_age(b - k, a - r, l, t) else 0\n  return s % t\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208796,"user_id":168,"body":"\/**\n * set true to enable debug\n *\/\ninternal var debug = false\n\ninternal fun mmul(x: Long, y: Long, m: Long) : Long = (x % m) * (y % m) % m\n\ninternal fun elder_age(m: Long, n: Long, l: Long, t: Long): Long {\n    if (m < n) return elder_age(n, m, l, t)\n    val k1 = 2 * m.takeHighestOneBit()\n    if (m <= 0 || n <= 0 || l >= k1) return 0\n    val k = if (n > 1) k1 \/ 2 else m\n    val r = Math.min(n, k)\n    var s = 0L\n    if (k > l) {\n        if (l >= 0) {\n            var x = k - l\n            var y = x - 1\n            if (x % 2 == 0L) x \/= 2 else y \/= 2\n            s = mmul(mmul(x, y, t), r, t)\n        } else {\n            var x = k\n            var y = k - 1\n            if (x % 2 == 0L) x \/= 2 else y \/= 2\n            s = mmul(mmul(x, y, t) - mmul(l, k, t), r, t)\n        }\n    }\n    s += elder_age(m - k, r, l - k, t)\n    s += elder_age(k, n - r, l - k, t)\n    s += elder_age(m - k, n - r, l, t)\n    return s % t\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208797,"user_id":null,"body":"import java.math.BigInteger\n\/\/ import kotlin.math.*\n\nfun min(a: BigInteger, b: BigInteger) = if (a<b) {a} else {b}\nfun max(a: BigInteger, b: BigInteger) = if (a>b) {a} else {b}\n\n\/**\n * set true to enable debug\n *\/\ninternal var debug = false\n\nfun recursive_matrix_calc(sx: BigInteger, sy: BigInteger, ex: BigInteger, ey: BigInteger, l: BigInteger): BigInteger {\n    if (sx == ex || sy == ey){\n        return BigInteger.valueOf(0)\n    }\n    \n    val w = ex-sx\n    val h = ey-sy\n    \n    var w2 = BigInteger.valueOf(2).pow(w.bitLength() - 1)\n    var h2 = BigInteger.valueOf(2).pow(h.bitLength() - 1)\n    \n    var tw2 = BigInteger.valueOf(0)\n    var th2 = BigInteger.valueOf(0)\n    \n    if (h2 > w2) {\n        w2 = min(w, h2)\n        th2 = w2\n        tw2 = h2\n    } else {\n        h2 = min(h, w2)\n        tw2 = w2\n        th2 = h2\n    }\n\n    val mn = sx xor sy\n    val mx = mn+tw2-BigInteger.valueOf(1)\n    var row1 = (mx*(mx+BigInteger.valueOf(1)) - mn*(mn-BigInteger.valueOf(1))) \/ BigInteger.valueOf(2)\n    val zeroed = min(max(l - mn, BigInteger.valueOf(0)), tw2)\n\n    if (zeroed > BigInteger.valueOf(0)) {\n        val mnz = zeroed+mn\n        row1 -= ((mnz*(mnz-BigInteger.valueOf(1))) - mn*(mn-BigInteger.valueOf(1))) \/ BigInteger.valueOf(2)\n    }\n    row1 -= l * (tw2-zeroed)\n\n    var total_sum = row1 * th2\n    total_sum += recursive_matrix_calc(sx + w2, sy, ex, sy+h2, l)\n    total_sum += recursive_matrix_calc(sx, sy + h2, sx+w2, ey, l)\n    total_sum += recursive_matrix_calc(sx+w2, sy+h2, ex, ey, l)\n\n    return total_sum\n}\n\n\ninternal fun elder_age(n: Long, m: Long, k: Long, newp: Long): Long {\n  return (recursive_matrix_calc(BigInteger.valueOf(0), BigInteger.valueOf(0), BigInteger.valueOf(m), BigInteger.valueOf(n), BigInteger.valueOf(k)) % BigInteger.valueOf(newp)).toLong()\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208798,"user_id":null,"body":"import java.math.BigInteger\nimport java.math.BigInteger.*\n\/**\n * set true to enable debug\n *\/\ninternal var debug = true\n\n\ninternal fun elder_age(n: Long, m: Long, l: Long, t: Long): Long {\n    val max = n.coerceAtLeast(m)\n    val min = n + m - max\n    val order = max.takeHighestOneBit()\n    fun triMult(num:Long, b:Long):Long {\n        if(num <= 1L) return 0L\n        return if(num%2 ==0L) {\n            ((num\/2 % t)*((num-1) % t) %t)*(b%t)%t\n        } else ((num % t)*((num-1)\/2 % t) %t)*(b%t)%t\n    }\n    fun extra(a:Long, b:Long, c:Long)= ((a%t)*(b%t) % t)*(c % t) % t\n    \n    val (tri, extra, last) = when {\n        min == 0L -> Triple(0L, 0L, 0L)\n        min == 1L -> Triple(triMult(max - l, 1L),0L, 0L)\n        order >= min && l == 0L -> Triple(triMult(order, min), extra(min, max-order, order),elder_age(min, max- order, 0L, t))\n        l==0L -> Triple(triMult(order,min+ max - order),extra(order, order, min+max - 2*order),elder_age(max - order, min - order, 0L, t))\n        order >= min && order <= l -> Triple(0L, 0L,elder_age(min, max - order, l - order,t))\n        order >= min && order == l+1 -> Triple(0L,extra(min, max-order, 1L),elder_age(min, max-order, 0, t))\n        order <= l+1 -> Triple(triMult(2*order - l, max+min - 2*order), 0L, 0L)\n        order >= min -> Triple(triMult(order - l, min),extra(min, max-order, order - l),elder_age(min, max - order, 0L, t)) \n        else -> Triple((triMult(order - l,order) + triMult(order, min + max - 2 * order))%t ,extra(order - l,order, min + max - 2* order),\n                       elder_age(max - order, min - order, l , t))\n    }\n    val ans = (tri + extra+ last)%t\n    println(listOf(ans, tri, extra, last))\n    return ans\n}\n\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208799,"user_id":null,"body":"import java.math.BigInteger\n\n\/**\n * set true to enable debug\n *\/\ninternal var debug = true\n\ninternal inline fun bInt(l: Long) = BigInteger.valueOf(l)\n\ninternal fun elder_age(n: Long, m: Long, k: Long, newp: Long): Long {\n    if (n <= 0 || m <= 0)\n        return 0\n    if (n < m)\n        return elder_age(n = m, m = n, k = k, newp = newp)\n    var N = 1L\n    while (N <= n \/ 2)\n        N = N.shl(1)\n    val N1 = n - N\n    val M = minOf(m, N)\n    val M1 = maxOf(0L, m - N)\n    val S_ = if (k <= N) (bInt(N - k) * bInt(N - k - 1L) \/ bInt(2L)).mod(bInt(newp)).toLong()\n             else 0L\n    val res = (bInt(S_) * bInt(M)).mod(bInt(newp)) +\n            if (m > N) {\n                val S1_ = when {\n                    (k <= N) -> ((bInt(N) * bInt(N * 3L - k * 2L - 1L)) \/ bInt(2L)).mod(bInt(newp)).toLong()\n                    (k <= N * 2L) -> (bInt(N * 2L - k) * bInt(N * 2L - k - 1) \/ bInt(2L)).mod(bInt(newp)).toLong()\n                    else -> 0L\n                }\n                (bInt(S1_) * bInt(M1 + N1)).mod(bInt(newp)) +\n                        bInt(elder_age(n = N1, m = M1, k = k, newp = newp))\n            } else\n                (bInt(maxOf(N - k, 0L)) * bInt(M) * bInt(N1)).mod(bInt(newp)) +\n                        bInt(elder_age(n = N1, m = M, k = maxOf(0L, k - N), newp = newp))\n    return res.mod(bInt(newp)).toLong()\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208800,"user_id":null,"body":"import kotlin.math.*\n\nval debug = true\n\nfun elder_age(row: Long, col: Long, loss: Long, newp: Long): Long {\n    val biggerDim = max(row, col)\n    val smallerDim = min(row, col)\n    return elder_age(0, biggerDim, smallerDim, loss, newp)\n}\n\n\nprivate fun elder_age(\n    offset: Long,\n    biggerDim: Long,\n    smallerDim: Long,\n    loss: Long,\n    mod: Long\n): Long {\n    val smallerPow2 = highestPowerOf2(smallerDim)\n    val biggerPow2 = highestPowerOf2(biggerDim)\n\n    val mainPart = modulatedSeqSum(\n        start = max(0, offset - loss),\n        end = max(0, offset + biggerPow2 - 1 - loss),\n        length = max(1, biggerPow2 + min(0, offset - loss)),\n        times = smallerPow2,\n        mod = mod\n    )\n\n    val smallerSidePart = modulatedSeqSum(\n        start = max(0, offset + smallerPow2 - loss),\n        end = max(0, offset + (smallerPow2 * 2) - 1 - loss),\n        length = max(1, smallerPow2 + min(0, offset + smallerPow2 - loss)),\n        times = max(0, smallerDim - smallerPow2),\n        mod = mod\n    )\n\n    var biggerSidePart = 0L\n    if (biggerDim > biggerPow2 && biggerPow2 < 2 * smallerPow2) {\n        biggerSidePart = modulatedSeqSum(\n            start = max(0, offset + smallerPow2 - loss),\n            end = max(0, offset + (smallerPow2 * 2) - 1 - loss),\n            length = max(1, smallerPow2 + min(0, offset + smallerPow2 - loss)),\n            times = max(0, min(biggerDim - smallerPow2, smallerPow2)),\n            mod = mod\n        )\n    }\n\n    var bottomReminderPart = 0L\n    if (smallerDim > smallerPow2 && biggerPow2 > smallerPow2 * 2) {\n        bottomReminderPart = modulatedSeqSum(\n            start = max(0, offset + 2 * smallerPow2 - loss),\n            end = max(0, offset + biggerPow2 - 1 - loss),\n            length = max(0, biggerPow2 - 2 * smallerPow2 + min(0, offset + 2 * smallerPow2 - loss)),\n            times = max(0, smallerDim - smallerPow2),\n            mod = mod\n        )\n    }\n\n    var mirroredPart = 0L\n    if (smallerDim > smallerPow2 && biggerDim > smallerPow2) {\n        mirroredPart = elder_age(\n            offset = offset,\n            biggerDim = max(0, min(biggerDim - smallerPow2, smallerPow2)),\n            smallerDim = max(0, smallerDim - smallerPow2), \/\/ negative numbers here should never happen\n            loss = loss,\n            mod = mod\n        )\n    }\n\n\n    var remainderPart = 0L\n    if (biggerDim > biggerPow2 && biggerPow2 >= 2 * smallerPow2) {\n        remainderPart = elder_age(\n            offset = offset + biggerPow2,\n            biggerDim = max(biggerDim - biggerPow2, smallerDim),\n            smallerDim = min(biggerDim - biggerPow2, smallerDim),\n            loss = loss,\n            mod = mod\n        )\n    }\n    return (mainPart + smallerSidePart + biggerSidePart + mirroredPart + remainderPart + bottomReminderPart) % mod\n}\n\n\/\/ if is needed because division modulo (by 0.5) is not always defined\nfun modulatedSeqSum(start: Long, end: Long, length: Long, times: Long, mod: Long): Long =\n    if ((start + end) % 2 == 0L) {\n        (((0.5 * start % mod + 0.5 * end % mod) % mod) * (((length % mod) * (times % mod)) % mod) % mod).toLong()\n    } else {\n        ((((0.5 * length) % mod * (times % mod)) % mod * (start % mod + end % mod) % mod) % mod).toLong()\n    }\n\nfun highestPowerOf2(n: Long): Long {\n    val p = (ln(n.toDouble()) \/ ln(2.0)).toLong()\n    return 2.0.pow(p.toDouble()).toLong()\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208801,"user_id":null,"body":"import java.math.BigInteger\n\n\/\/Declaring these here because CodeWars sometimes can't get the standard constants \u00af\\_(\u30c4)_\/\u00af\nval ZERO = 0.toBigInteger()\nval ONE = 1.toBigInteger()\nval TWO = 2.toBigInteger()\nval FOUR = 4.toBigInteger()\n\nval debug = false\n\ninternal fun elder_age(N: Long, M: Long, l: Long, t: Long) = getAge(\n    N.toBigInteger(),\n    M.toBigInteger(),\n    l.toBigInteger(),\n    t.toBigInteger(),\n    ZERO\n).toLong()\n\nprivate fun getAge(N: BigInteger, M: BigInteger, l: BigInteger, t: BigInteger, o: BigInteger): BigInteger {\n    if (N == ZERO || M == ZERO) return ZERO\n    if (M > N) return getAge(M, N, l, t, o)\n\n    val n = N.log2\n    val pow = n.pow2\n    \n    return if (pow == N) {\n        val r = getRowCol(N, o, l, t)\n        (r * M).modulus(t)\n    }\n    else if (N > pow && M > pow) {\n        val squareSize = (n + 1).pow2\n        val r = getRowCol(squareSize, o, l, t)\n        ((N + M - squareSize) * r + getAge(squareSize - N, squareSize - M, l, t, o)).modulus(t)\n    }\n    else {\n        (getAge(pow, M, l, t, o) + getAge(N - pow, M, l, t, o + pow)).modulus(t)\n    }\n}\n\nprivate fun getRowCol(squareSize: BigInteger, offset: BigInteger, l: BigInteger, t: BigInteger): BigInteger {\n    return if (l < squareSize + offset) {\n        (tri(squareSize + offset - ONE, t) - tri(offset-ONE, t) - squareSize * l + if (l > offset) { tri(l - offset, t) } else { ZERO }).modulus(t)\n    }\n    else {\n        ZERO\n    }\n}\n\nprivate fun tri(n: BigInteger, t: BigInteger) = ((n * (n+ONE)) \/ TWO).modulus(t)\n\nprivate fun BigInteger.modulus(t: BigInteger): BigInteger {\n    if (this >= ZERO) return this % t\n    return this - t * ((this \/ t) - ONE)\n}\n\nprivate val Int.pow2 get(): BigInteger {\n    var p = ONE\n    repeat(this) { p *= TWO }\n    return p\n}\n\nprivate val BigInteger.log2 get(): Int {\n    var log = 0\n    var p = ONE\n    while (p <= this) {\n        p *= TWO\n        log += 1\n    }\n    return log - 1\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208802,"user_id":null,"body":"import kotlin.math.*\n\ninternal var debug = false\n\nfun elder_age(n: Long, m: Long, k: Long, newp: Long): Long {\n\n    val findMax = max(n, m)\n    val findMin = min(n, m)\n    \n    val sq = 2.0.pow(floor(log2(findMax.toDouble()))).toLong()\n    \n    val sMin = min(sq, findMin)\n    val kInv = max(0, -k)\n    val maxMod = max(0, sq - k - 1)\n    \n    var dCase = maxMod - kInv + 1\n    var sCase = maxMod + kInv\n    if (dCase % 2 > 0L) {\n        sCase = floor((sCase \/ 2L).toDouble()).toLong()\n    } else if (sCase % 2 > 0) {\n        dCase = floor((dCase \/ 2).toDouble()).toLong()\n    }\n    val diff: Long = if (sCase <= 0) 0 else ((sCase % newp) * (dCase % newp)) % newp\n    \n    var acc = ((diff % newp) * (sMin % newp)) % newp\n    if (findMax > sq) {\n        acc += elder_age(findMax - sq, sMin, k - sq, newp)\n    }\n    if (findMin > sMin) {\n        acc += elder_age(sq, findMin - sMin, k - sMin, newp)\n    }\n    if ((findMin > sMin) and (findMax > sq)) {\n        acc += elder_age(findMax - sq, findMin - sMin, k, newp)\n    }\n    return acc % newp\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5976c5a5cd933a7bbd000029":[{"id":208803,"user_id":168,"body":"import java.math.BigInteger\n\nobject Faberge {\n    val mod = 998244353.toBigInteger()\n\n    fun height(n: BigInteger, m: BigInteger): BigInteger {\n        if (n >= m) return (BigInteger.TWO.modPow(m, mod) - BigInteger.ONE) % mod\n        var c = BigInteger.ONE\n        var s = BigInteger.ZERO\n        var i = BigInteger.ZERO\n        while (i < n) {\n            c = c * (m - i) * (i + BigInteger.ONE).modInverse(mod) % mod\n            s += c\n            ++i\n        }\n        return s % mod\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208804,"user_id":null,"body":"import java.math.BigDecimal\nimport java.math.BigInteger\nimport java.math.RoundingMode\n\nobject Faberge {\nval mod = 998244353.toBigInteger()\n    val preAllocate = mutableListOf(BigInteger.ZERO, BigInteger.ONE)\n\n    init {\n        for (haha_i in 2L until (80000L + 1L)) {\n            preAllocate.add(\n                mod - mod.toBigDecimal().divide(BigDecimal.valueOf(haha_i), RoundingMode.FLOOR)\n                    .toBigInteger() * preAllocate[(mod % BigInteger.valueOf(haha_i)).toInt()] % mod\n            )\n        }\n    }\n\n\n    fun height(n: BigInteger, m: BigInteger): BigInteger {\n        var h = BigInteger.ZERO\n        var t = BigInteger.ONE\n        val m1 = m % mod\n\n        for (i in 1 until (n.toInt() + 1)) {\n            t = t * (m1 - BigInteger.valueOf(i.toLong()) + BigInteger.ONE) * preAllocate[i] % mod\n            h = (h + t) % mod\n        }\n        return h % mod\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208805,"user_id":492,"body":"import java.math.BigInteger\n\nobject Faberge {\n    val MOD = 998244353.toBigInteger()\n\n    fun height(n: BigInteger, m: BigInteger): BigInteger {\n        var h = BigInteger.ZERO;\n        var a = BigInteger.ONE;\n        for (i in 1..n.intValueExact())\n        {\n            var inv = (i).toBigInteger().modInverse(MOD);\n            a = a.multiply(m.add((1 - i).toBigInteger())).multiply(inv).mod(MOD)\n            h = h.add(a).mod(MOD);\n        }\n        return h;\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208806,"user_id":53,"body":"import java.math.BigInteger\nimport java.math.BigInteger.*\n\nobject Faberge {\n    val mo = 998244353.toBigInteger()\n\n    fun height(n: BigInteger, m: BigInteger): BigInteger {\n        var h = ZERO\n        var t = ONE\n        var i = ONE\n        while (i <= n) {\n            t = t * (m - i + ONE) * i.modInverse(mo) % mo\n            h += t\n            i += ONE\n        }\n        return h % mo\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208807,"user_id":null,"body":"import java.math.BigInteger\nimport java.math.BigInteger.ONE\nimport java.math.BigInteger.valueOf\n\nobject Faberge {\n    private val mod = 998244353.toBigInteger()\n    private val hahaInv: List<BigInteger> by lazy {\n        val value = mutableListOf(0.toBigInteger(), 1.toBigInteger())\n        for (i in (2..80000).map { it.toBigInteger() }) {\n            value.add((mod.minus(mod.divide(i)).multiply(value[mod.mod(i).toInt()]).mod(mod)))\n        }\n        value\n    }\n    fun height(n: BigInteger, m: BigInteger): BigInteger {\n        val m = m.mod(mod)\n        var h = valueOf(0)\n        var t = valueOf(1)\n        for (i in (1..n.toLong()).map { valueOf(it) }) {\n            t = t.multiply(m.minus(i).plus(ONE)).multiply(hahaInv[i.toInt()]).mod(mod);\n            h = h.plus(t).mod(mod);\n        }\n        return h;\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208808,"user_id":null,"body":"import java.math.BigInteger\n\nobject Faberge {\n    private const val m = 998244353L\n    private val mod = m.toBigInteger()\n\n    private val ZERO = 0.toBigInteger()\n    private val ONE = 1.toBigInteger()\n    private val TWO = 2.toBigInteger()\n\n    fun height(e: BigInteger, t: BigInteger): BigInteger {\n        if (e >= t) return (TWO.modPow(t, mod) + mod - ONE) % mod    \/\/Simple case where we have spare eggs\n        \n        val f = ((t - e) % mod).toLong()\n        var c = ZERO                                                 \/\/Use this as a counter. Needs to be bigint to compare with t\n        var q = 1L                                                   \/\/Represents the relevant nth dimensional triangle number\n        var p = TWO.modPow(e, mod).toLong()                          \/\/Power of two from which we will count back. Potentially we will cycle through all powers up to m so we can't cache them all :')\n        var s = 0L\n        var it = 0L                                                  \/\/This is our counter mod m\n        \n        while (c < e) {\n            s = plus(s, times(q, p - 1))\n            q = times(q, f + it)\n            c += ONE\n            it = plus(it, 1L)\n            q = divide(q, it)\n            p = divide(p, 2L)\n        }\n\n        q = times(q, (t % mod).toLong())\n        q = divide(q, f)\n        s = plus(s, q)\n        s = decrement(s)\n\n        return s.toBigInteger()\n    }\n\n    private fun inverse(n: Long): Long {\n        x[0] = 1L\n        y[0] = 1L\n        gcdExtended(n % m, m, 0)\n        return x[0] + m\n    }\n\n    private fun divide(a: Long, b: Long) = if (a % b == 0L) a \/ b else (inverse(b) * a) % m\n    private fun times(a: Long, b: Long) = (a * b) % m\n    private fun plus(a: Long, b: Long) = (a + b) % m\n    private fun decrement(a: Long) = if (a == 0L) m - 1 else a - 1\n\n    \/\/Kotlin doesn't let you pass memory references so we can use the\n    \/\/depth of the algorithm as the reference for accessing a static array\n    val x = Array(99){0L}\n    val y = Array(99){0L}\n    private fun gcdExtended(a: Long, b: Long, d: Int) {\n        if (a == 0L) {\n            x[d] = 0L\n            y[d] = 1L\n            return\n        }\n\n        x[d+1] = 1L\n        y[d+1] = 1L\n        gcdExtended(b % a, a, d+1)\n        x[d] = y[d+1] - x[d+1] * (b \/ a)\n        y[d] = x[d+1]\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208809,"user_id":null,"body":"import java.math.BigInteger\n\nobject Faberge {\n    val mod = 998244353.toBigInteger()\n\n    fun height(n: BigInteger, m: BigInteger): BigInteger {\n\n        var arr = arrayListOf<BigInteger>(BigInteger.ZERO, BigInteger.ONE)\n\n        var i = 2.toBigInteger()\n        while (i < 80000.toBigInteger() + BigInteger.ONE) {\n            arr.add((mod - (mod \/ i)) * arr[mod.intValueExact() % i.intValueExact()] % mod)\n            i++\n        }\n\n        var h = BigInteger.ZERO\n        var c = BigInteger.ONE\n        var j = BigInteger.ONE\n\n        val tempM = m % mod\n\n        while (j < n + BigInteger.ONE) {\n            c = c * (tempM - j + 1.toBigInteger()) * arr[j.intValueExact()] % mod\n            h = (h + c) % mod\n            j++\n        }\n        return h % mod\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208810,"user_id":null,"body":"import java.math.BigInteger\nimport java.math.BigInteger.ZERO\nimport java.math.BigInteger.ONE\n\nobject Faberge {\n\n    private val MOD = 998244353.toBigInteger()\n\n    private val TWO = 2.toBigInteger()\n\n    private fun BigInteger.modular() = rem(MOD).let { if (it < ZERO) it + MOD else it }\n\n    private fun powerOfTwo(exp: BigInteger) = TWO.pow((exp % (MOD - ONE)).toInt())\n\n    private fun computeInverse(a: BigInteger): BigInteger {\n        var u = a\n        var v = MOD\n        var x1 = ONE\n        var x2 = ZERO\n        while (u != ONE) {\n            val q = v \/ u\n            val r = v - q * u\n            val x = x2 - q * x1\n            v = u\n            u = r\n            x2 = x1\n            x1 = x\n        }\n        return x1.modular()\n    }\n\n    private fun generateBinomialCoefficients(n: BigInteger): Sequence<BigInteger> {\n        val modularN = n.modular()\n        return generateSequence({ ONE to ZERO }) { (c, k) ->\n            val nextK = k + ONE\n            (c * (modularN - k) * computeInverse(nextK.modular())).modular() to nextK\n        }.map { it.first }\n    }\n\n    private fun Sequence<BigInteger>.computeSum(maxIndex: Int) = take(maxIndex + 1)\n        .mapIndexed { index, value -> if (index < maxIndex) TWO * value else value }\n        .reduce { acc, value -> (acc + value).modular() }\n\n    fun height(n: BigInteger, m: BigInteger) = if (n >= m) {\n        powerOfTwo(m) - ONE\n    } else {\n        val diff = TWO * n - m + ONE\n        val coefficients = generateBinomialCoefficients(m - ONE)\n        if (diff >= ZERO) {\n            powerOfTwo(m) - coefficients.computeSum(m.toInt() - n.toInt() - 1) - ONE\n        } else {\n            coefficients.computeSum(n.toInt()) - ONE\n        }\n    }.modular()\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208811,"user_id":null,"body":"import java.math.BigInteger\n\nobject Faberge {\n    val mod = 998244353.toBigInteger()\n    val zero = BigInteger.ZERO\n    val one = BigInteger.ONE\n\n    val memo = initialise()\n    \n    \n    fun height(n: BigInteger, m: BigInteger): BigInteger {\n        if (m == zero || n == zero) return zero\n        if (m == one) return one\n        \n        var nn = n % mod\n        var mm = m % mod\n        \n        var floor = zero\n        var k = one\n        var i = one \n        \n        while (i <= nn) {\n            k = k * (mm.plus(one) - i) * memo.get(i)!! % mod\n            floor = (floor + k) % mod\n            i++\n        }\n        \n        return floor % mod\n    }\n    \n    fun gcd(a: BigInteger, b: BigInteger): BigInteger {\n        return if (b == zero) a else gcd(b, a.rem(b))\n    }\n    \n    fun inverseMod(ai: BigInteger, mi: BigInteger): BigInteger {\n        if (gcd(ai, mi) != one) return zero\n        \n        var a = ai\n        var m = mi\n        var x = zero\n        var y = one\n        var lx = one\n        var ly = zero\n        var mx = m\n        \n        while (m != zero) {\n            val q = a \/ m\n            val t = a\n            a = m\n            m = t.rem(m)\n            val xx = lx - q * x\n            val yy = ly - q * y\n            val lxx = x\n            val lyy = y\n            x = xx\n            y = yy\n            lx = lxx\n            ly = lyy            \n        }\n        return (lx + mx).rem(mx)\n    }\n    fun initialise(): Map<BigInteger, BigInteger> {\n        var memo = mutableMapOf(zero to zero)\n        var i = one\n        \n        while (i <= 80000.toBigInteger()) {\n            memo.set(i, inverseMod(i, mod))\n            i++\n        }\n        return memo\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208812,"user_id":1228,"body":"import java.math.BigInteger;\n\nobject Faberge {\n    val MOD = 998244353 \n    \n    fun height(n: BigInteger, m: BigInteger): BigInteger {\n        var nn = n\n        if (nn.equals(BigInteger.ZERO) || m.equals(BigInteger.ZERO)) {\n            return BigInteger.ZERO\n        }\n        if (nn.compareTo(m) > 0) nn = m\n        val eggs = nn.toInt()\n        val tries = m.mod( MOD.toBigInteger() ).toInt()\n        \n        var nck_prev: Long = tries.toLong()\n        var res: Long = nck_prev.toLong()\n        \n        for (i in 2..eggs) {\n            nck_prev = (nck_prev * (MOD + tries + 1 - i)) % MOD\n            nck_prev = (nck_prev * Faberge.inv(i)) % MOD\n            res = (res + nck_prev) % MOD\n        }\n        return res.toBigInteger()\n    }\n    \n    fun inv(n: Int): Int {\n        var t = 1; var old_t = 0\n        var r = n; var old_r = MOD\n        while (r != 0) {\n            val q = old_r \/ r\n            var x = old_r - q * r\n            old_r = r\n            r = x\n            \n            x = old_t - q * t\n            old_t = t\n            t = x\n        }\n        if (old_t < 0) old_t += MOD\n        return old_t\n    }\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"597ccf7613d879c4cb00000f":[{"id":208813,"user_id":null,"body":"import java.math.BigInteger\n\ninterface Statement\ninterface Expression : Statement\ninterface NameOrNumber\ndata class Name(val n: String) : Expression, NameOrNumber\ndata class Number(val n: BigInteger) : Expression, NameOrNumber\ndata class Lambda(val parameters: List<NameOrNumber>, val statement: List<NameOrNumber>) : Expression\ndata class FunctionCall(val expression: Expression, val parameters: List<Expression>, val lambda: Lambda?) : Statement\n\ndata class ParseException(override val message: String) : Throwable()\n\nfun parseKotlinNumber(n: String, p: Int): Pair<Number, Int> {\n    var i = p\n    while (i < n.length && n[i].isDigit()) {\n        i++\n    }\n    if (i < n.length && n[i] !in \"\n {},;()-\") {\n        throw ParseException(\"invalid trailing char on number: ${n.substring(i)}\")\n    }\n    return Number(n.substring(p, i).toBigInteger()) to i\n}\n\nfun parseKotlinName(n: String, p: Int): Pair<Name, Int> {\n    var i = p\n    while (i < n.length && (n[i].isDigit() || n[i] in 'a'..'z' || n[i] in 'A'..'Z' || n[i] == '_')) {\n        i++\n    }\n    return Name(n.substring(p, i)) to i\n}\n\nfun parseKotlinParameters(expression: String, p: Int, parameters: MutableList<Expression>): Int {\n    var i = p\n    check(expression[i] == '(')\n    i++\n    if (expression[i] == ')') {\n        i++\n        return i\n    }\n    while (true) {\n        if (expression[i] == ')') {\n             if (expression[i-1] == ',') {\n                throw ParseException(\"trailing ,\")\n            }\n            i++\n            return i\n        }\n        parseKotlinExpression(expression, i).let {\n            parameters.add(it.first)\n            i = it.second\n            if (expression[i] == ')') {\n                i++\n                return i\n            } else if (expression[i] == ',') {\n                i++\n            } else {\n                throw ParseException(\"expecting , or ) during parsing of parameters\")\n            }\n        }\n    }\n}\n\nfun parseKotlinLambda(l: String, p: Int): Pair<Lambda, Int> {\n    var i = p\n    if (l[i] != '{') { throw ParseException(\"{ exepected for lambda\") }\n    i++\n    if (l[i] == '}') {\n        i++\n        return Lambda(emptyList(), emptyList()) to i\n    }\n    val endB = l.substring(i, l.length).indexOfFirst { it == '}' }\n    if (endB == -1) {\n        throw ParseException(\"missing } in lambda\")\n    }\n    val sub = l.substring(i, i + endB)\n    val hasArrow = \"->\" in sub\n    val parameters = mutableListOf<NameOrNumber>()\n    while (true) {\n        if (l[i] == '}') {\n            i++\n            return Lambda(parameters, emptyList()) to i\n        }\n        if (l[i] == ' ') {\n            i++\n        }\n        parseKotlinNameOrNumber(l, i).let { pair -> parameters.add(pair.first); i = pair.second }\n        if (l[i] == '-') {\n            i++\n            if (l[i] != '>') {\n                throw ParseException(\"expecting -> in lambda\")\n            }\n            i++\n            if (l[i] == '}') {\n                i++\n                return Lambda(parameters, emptyList()) to i\n            }\n            val statements = mutableListOf<NameOrNumber>()\n            while (true) {\n                if (l[i] == '}') {\n                    i++\n                    return Lambda(parameters, statements) to i\n                }\n                if (l[i] == ' ') {\n                    i++\n                }\n                parseKotlinNameOrNumber(l, i).let { pair -> statements.add(pair.first); i = pair.second }\n                if (l[i] == '}') {\n                    i++\n                    return Lambda(parameters, statements) to i\n                } else if (l[i] == ';') {\n                    i++\n                }\n            }\n        } else if (l[i] == ',') {\n            if (!hasArrow) {\n                throw ParseException(\"illegal part of lambda ${l.substring(i)}\")\n            }\n            i++\n        } else if (l[i] == '}') {\n            i++\n            return Lambda(emptyList(), parameters) to i\n        } else if (l[i] == ' ') {\n            if (hasArrow) {\n                throw ParseException(\"illegal part of lambda: ${l.substring(i)}\")\n            }\n        } else {\n            throw ParseException(\"illegal part of lambda: ${l.substring(i)}\")\n        }\n    }\n}\n\nfun parseKotlinExpression(expression: String, p: Int): Pair<Expression, Int> {\n    var e: Expression? = null\n    var i = p\n    if (expression[i].isDigit()) {\n        parseKotlinNumber(expression, i).let { pair -> e = pair.first; i = pair.second }\n    } else if (expression[i] in 'a'..'z' || expression[i] in 'A'..'Z' || expression[i] == '_') {\n        parseKotlinName(expression, i).let { pair -> e = pair.first; i = pair.second }\n    } else if (expression[i] == '{') {\n        parseKotlinLambda(expression, i).let { pair -> e = pair.first; i = pair.second }\n    } else {\n        throw ParseException(\"expecting name, number or lambda\")\n    }\n    return e!! to i\n}\n\nfun parseKotlinNameOrNumber(expression: String, p: Int): Pair<NameOrNumber, Int> {\n    val (e, i) = parseKotlinExpression(expression, p)\n    if (e is Lambda) {\n        throw ParseException(\"unexpected lambba\")\n    }\n    return e as NameOrNumber to i\n}\n\nfun parseKotlinStatement(expression: String, p: Int = 0): Statement {\n    println(\"kotlin statement: $expression\")\n    var e: Expression? = null\n    var i = p\n    parseKotlinExpression(expression, i).let { e = it.first; i = it.second }\n    if (expression[i] == '(') {\n        val parameters = mutableListOf<Expression>()\n        parseKotlinParameters(expression, i, parameters).let { i = it }\n        var lambda: Lambda? = null\n        if (i < expression.length) {\n            parseKotlinLambda(expression, i).let {\n                lambda = it.first\n                i = it.second\n            }\n        }\n        \/\/  check for excess non-white-space\n        if (i != expression.length) {\n            throw ParseException(\"excess characters ${expression.substring(i)}\")\n        }\n        return FunctionCall(e!!, parameters, lambda)\n    } else if (expression[i] == '{') {\n        parseKotlinLambda(expression, i).let {\n            val lambda = it.first\n            i = it.second\n            if (i != expression.length) {\n                throw ParseException(\"excess characters ${expression.substring(i)}\")\n            }\n            return FunctionCall(e!!, mutableListOf(), lambda)\n        }\n    } else {\n        throw ParseException(\"expecting arguments or lamba after expression, not ${expression.substring(i)}\")\n    }\n}\n\nfun makeDartLambda(l: Lambda): String {\n    val parameters = l.parameters.joinToString(\",\") { makeDartExpression(it as Expression) }\n    val statements = l.statement.joinToString(\"\") { makeDartExpression(it as Expression) + \";\" }\n    return \"($parameters){$statements}\"\n}\n\nfun makeDartExpression(e: Expression): String {\n    if (e is Name) {\n        return e.n\n    }\n    if (e is Number) {\n        return e.n.toString()\n    }\n    if (e is Lambda) {\n        return makeDartLambda(e)\n    }\n    throw IllegalStateException()\n}\n\nfun makeDartFunctionCall(f: FunctionCall): String {\n    val e = makeDartExpression(f.expression)\n    val parameters = (f.parameters + listOfNotNull(f.lambda)).joinToString(\",\") { makeDartExpression(it) }\n    return \"$e($parameters)\"\n}\n\nfun makeDartStatement(statement: Statement): String {\n    return if (statement is Expression) {\n        makeDartExpression(statement)\n    } else {\n        makeDartFunctionCall(statement as FunctionCall)\n    }\n}\n\nfun stripKotlinExpression(expression: String): String {\n    val e = expression.strip().lines().joinToString(\"\")\n    val res = StringBuilder()\n    for (i in e.indices) {\n        if (e[i].isWhitespace() && res.last() in \",;+-(){}>\") {\n            continue\n        }\n        if (e[i].isWhitespace() && i < e.length - 1 && (e[i + 1] in \",;+-(){}>\" || e[i + 1].isWhitespace())) {\n            continue\n        }\n        res.append(e[i])\n    }\n    return res.toString()\n}\n\nfun transpile(expression: String): String {\n    try {\n        val x = stripKotlinExpression(expression)\n        println(\"$expression $x\")\n        val s = parseKotlinStatement(x)\n        println(s)\n        return makeDartStatement(s)\n    } catch (e: ParseException) {\n        println(e.message)\n        return \"\"\n    } catch (e: StringIndexOutOfBoundsException) {\n        return \"\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208814,"user_id":null,"body":"fun transpile(expression: String): String {\n    try {\n        val scanner = Scanner(expression.replace('\n', ' ').trim())\n        val result = scanner.func().toString()\n        if (!scanner.finished()) {\n            throw java.lang.IllegalArgumentException(\"Scanner has extra characters\")\n        }\n        return result\n    } catch (e: Exception) {\n        println(e)\n    }\n    return \"\"\n}\n\nsealed class Expr\n\ndata class NameOrNumber(private val value: String) : Expr() {\n    override fun toString() = value\n}\n\ndata class Func(\n    private val expr: Expr,\n    private val params: List<Expr>\n) {\n    override fun toString() = \"$expr(\" + params.joinToString(\",\") + \")\"\n}\n\ndata class Lambda(\n    internal val params: List<Expr>,\n    private val statements: List<Expr>\n) : Expr() {\n    override fun toString() = \"(${params.joinToString(\",\")}){${statements.joinToString(\"\") { \"$it;\" }}}\"\n}\n\nclass Scanner(source: String) {\n    private var tokens = source.dropWhile { it.isWhitespace() }\n        set(value) {\n            field = value.dropWhile { it.isWhitespace() }\n        }\n\n    private fun head() = tokens.firstOrNull() ?: '~'\n    private fun dropTokens(n: Int) {\n        tokens = tokens.drop(n)\n    }\n\n    fun expr(allowLambda: Boolean = false): Expr? {\n\n        val name = name()\n        if (name != null)\n            return name\n\n        val number = number()\n        if (number != null)\n            return number\n\n        if (allowLambda) {\n            val lambda = lambda()\n            if (lambda != null)\n                return lambda\n        }\n\n        return null\n    }\n\n    fun number(): NameOrNumber? = tokens\n        .takeIf { head().isDigit() }\n        ?.takeWhile { it.isDigit() }\n        ?.also { dropTokens(it.length) }\n        ?.let(::NameOrNumber)\n\n    fun name(): NameOrNumber? = tokens\n        .takeIf { head().isLetter() || head() == '_' }\n        ?.takeWhile { it.isLetter() || it == '_' || it.isDigit() }\n        ?.also { dropTokens(it.length) }\n        ?.let(::NameOrNumber)\n\n    fun separator(char: Char): Char? = tokens\n        .takeIf { head() == char }\n        ?.let { head() }\n        ?.also { dropTokens(1) }\n\n    fun lambda(): Lambda? = tokens\n        .takeIf { head() == '{' && '}' in tokens }\n        ?.takeWhile { it != '}' }\n        ?.drop(1)\n        ?.also { dropTokens(it.length + 2) }\n        ?.let { body ->\n            val parts = body.split(\"->\")\n            when (parts.size) {\n                1 -> Lambda(\n                    emptyList(),\n                    Scanner(parts[0]).args(false, ' ')\n                )\n                2 -> Lambda(\n                    Scanner(parts[0]).args(false, ','),\n                    Scanner(parts[1]).args(false, ' ')\n                ).also {\n                    if (it.params.isEmpty())\n                        throw java.lang.IllegalArgumentException(\"Empty params\")\n                }\n                else -> throw IllegalArgumentException(\"Wrong number of lambda parts\")\n            }\n        }\n\n    fun params(): List<Expr>? = tokens\n        .takeIf { head() == '(' && ')' in tokens }\n        ?.takeWhile { it != ')' }\n        ?.drop(1)\n        ?.also { dropTokens(it.length + 2) }\n        ?.let { body ->\n            Scanner(body).args(true, ',')\n        }\n\n    fun func(): Func {\n        val expr = requireNotNull(expr(true)) { \"Expression expected\" }\n        val params = params()\n        return if (params == null) {\n            val lambda = requireNotNull(lambda()) { \"Lambda expected\" }\n            Func(\n                expr = expr,\n                params = listOf(lambda)\n            )\n        } else {\n            val lambda = lambda()\n            Func(\n                expr = expr,\n                params = params + if (lambda != null) listOf(lambda) else emptyList()\n            )\n        }\n    }\n\n    fun args(allowLambda: Boolean, separator: Char): List<Expr> {\n        val expressions = mutableListOf<Expr>()\n        var hasSep = false\n        while (true) {\n            val expr = expr(allowLambda)\n            if (expr != null) {\n                expressions.add(expr)\n                if (separator == ' ')\n                    continue\n                if (separator(separator) != null) {\n                    hasSep = true\n                    continue\n                } else {\n                    hasSep = false\n                }\n            }\n            break\n        }\n        if (hasSep || !finished()) {\n            throw java.lang.IllegalArgumentException(\"Scanner has extra characters\")\n        }\n        return expressions\n    }\n\n    fun finished(): Boolean = head() == '~'\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208815,"user_id":null,"body":"fun transpile(expression: String): String {\n    return Parse(expression).expFunction()\n}\n\nclass Parse(expression: String) {\n\n    enum class lexType {\n        nameOrNum, LP, RP, LL, RL, LAM, PP, none\n    }\n\n    companion object {\n        fun getType(string: String): lexType {\n            return when (string) {\n                \"(\" -> lexType.LP\n                \")\" -> lexType.RP\n                \"{\" -> lexType.LL\n                \"}\" -> lexType.RL\n                \"->\" -> lexType.LAM\n                \",\" -> lexType.PP\n                else -> lexType.nameOrNum\n            }\n        }\n    }\n\n    private val lex: List<Pair<String, lexType>>\n    private var position = 0\n    private var isCompiler = true\n\n    init {\n        lex = Regex(\"[_a-zA-Z][a-zA-Z0-9_]*|[0-9]+|[(){},]|->\")\n            .findAll(expression).map { it.value to getType(it.value) }.toMutableList()\n        isCompiler = Regex(\"([a-zA-Z0-9_(){},\\\n\\\\t\\\\r ]|->)*\").matches(expression)\n        lex.add(\"\" to lexType.none)\n        lex.add(\"\" to lexType.none)\n    }\n\n    \/\/function ::= expression \"(\" [parameters] \")\" [lambda]\n    \/\/    | expression lambda\n\n    \/\/function ::= expression \"(\" [parameters] \")\"\n    fun expFunction(): String {\n        println(\"function\")\n        val expression = expExp()\n        var params = \"\"\n        if (lex[position].second == lexType.LP) {\n            if (lex[position + 1].second != lexType.RP) {\n                position++\n                params += expParameter() + \",\"\n                position++\n            } else\n                position += 2\n            if (lex[position].second == lexType.LL)\n                params += expLambda() + \",\"\n        }\n        if (lex[position].second == lexType.LL) {\n            params += expLambda() + \",\"\n        }\n        if (params.length > 1)\n            params = params.substring(0, params.lastIndex)\n        if(position != lex.size-2)\n            return \"\"\n        if (!isCompiler)\n            return \"\"\n        return \"$expression($params)\"\n    }\n\n    fun err() {\n        println(\"err\")\n        isCompiler = false\n    }\n\n    \/\/expression ::= nameOrNumber\n    \/\/    | lambda\n    fun expExp(): String {\n        println(\"expression\")\n        if (lex[position].second == lexType.nameOrNum) {\n            position++\n            return lex[position - 1].first\n        } else if (lex[position].second == lexType.LL)\n            return expLambda()\n        err()\n        return \"\"\n    }\n\n    \/\/parameters ::= expression [\",\" parameters]\n    fun expParameter(): String {\n        println(\"parameters\")\n        var result = expExp()\n        if (lex[position].second == lexType.PP) {\n            position++\n            result += \",\" + expParameter()\n        }\n        return result\n    }\n\n    \/\/lambdaparam ::= nameOrNumber [\",\" lambdaparam]\n    fun expLambdaParam(): String {\n        println(\"lambda-param\")\n        var result = lex[position].first\n        position++\n        if (lex[position].second == lexType.PP) {\n            position++\n            result += \",\" + expLambdaParam()\n        }\n        return result\n    }\n\n    \/\/lambdastmt  ::= nameOrNumber [lambdastmt]\n\n    \/\/lambdastmt  ::= nameOrNumber \";\" [lambdastmt]\n    fun expLambdaStmt(): String {\n        println(\"lambda-stmt\")\n        var result = lex[position].first + \";\"\n        position++\n        if (lex[position].second == lexType.nameOrNum)\n            result += expLambdaStmt()\n        return result\n    }\n\n    \/\/lambda ::= \"{\" [lambdaparam \"->\"] [lambdastmt] \"}\"\n\n    \/\/lambda ::= \"(\" [lambdaparam] \"){\" [lambdastmt] \"}\"\n    fun expLambda(): String {\n        var params = \"\"\n        var stmt = \"\"\n        println(\"lambda\")\n        if (lex[position].second == lexType.LL)\n            position++\n        else {\n            err()\n            return \"\"\n        }\n        if (lex[position].second == lexType.nameOrNum &&\n            (lex[position + 1].second == lexType.PP || lex[position + 1].second == lexType.LAM)\n        ) {\n            params = expLambdaParam()\n            if (lex[position].second == lexType.LAM)\n                position++\n            else {\n                err()\n                return \"\"\n            }\n        }\n        if (lex[position].second == lexType.nameOrNum)\n            stmt = expLambdaStmt()\n        if (lex[position].second == lexType.RL)\n            position++\n        else {\n            err()\n            return \"\"\n        }\n        return \"($params){$stmt}\"\n    }\n\n}\n","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208816,"user_id":null,"body":"class Peekable<T>(sequence: Sequence<T>) {\n    private val iterator = sequence.iterator()\n    var lookahead: T? = null\n    fun next(): T? = when {\n        lookahead != null -> lookahead.also { lookahead = null }\n        iterator.hasNext() -> iterator.next()\n        else -> null\n    }\n    fun peek(): T? = next().also { lookahead = it }\n}\n\nsealed class Token {\n    override fun toString(): String = javaClass.simpleName\n\n    object LEFT_PARENT: Token()\n    object RIGHT_PARENT: Token()\n    object LEFT_BRACE: Token()\n    object RIGHT_BRACE: Token()\n    object COMMA: Token()\n    object ARROW: Token()\n    object EOF: Token()\n    data class NAME_OR_NUMBER(val string: String): Token()\n}\n\nfun tokenize(expression: String) = sequence<Token> {\n    val chars = Peekable(expression.asSequence())\n    while (chars.peek() != null) {\n        while (chars.peek()?.isWhitespace() == true) {\n            chars.next()\n        }\n        val char = chars.next() ?: break\n        val nextToken = when (char) {\n            '(' -> Token.LEFT_PARENT\n            ')' -> Token.RIGHT_PARENT\n            '{' -> Token.LEFT_BRACE\n            '}' -> Token.RIGHT_BRACE\n            ',' -> Token.COMMA\n            '-' -> if (chars.next() == '>') Token.ARROW else throw Exception(\"unclosed arrow\")\n            else -> {\n                when {\n                    char.isJavaIdentifierStart() -> {\n                        var name = char.toString()\n                        while (chars.peek()?.isJavaIdentifierPart() == true) {\n                            name += chars.next()!!\n                        }\n                        Token.NAME_OR_NUMBER(name)\n                    }\n                    char.isDigit() -> {\n                        var number = char.toString()\n                        while (chars.peek()?.isDigit() == true) {\n                            number += chars.next()!!\n                        }\n                        Token.NAME_OR_NUMBER(number)\n                    }\n                    else -> throw Exception(\"Unexspected $char\")\n                }\n            }\n        }\n        yield(nextToken)\n    }\n    while (true) {\n        yield(Token.EOF)\n    }\n}\n\nclass FunctionCall(val name: Expr, val params: List<Expr>)\n\nsealed class Expr {\n    data class NameOrNumber(val string: String): Expr()\n    data class Lambda(val params: List<String>, val statement: List<String>): Expr()\n}\n\ninline fun<reified T> expect(tokens: Peekable<Token>, msg: String = \"something\") : T  {\n    val next = tokens.next()\n    if (next is T) {\n        return next\n    } else {\n        throw Exception(\"Expected $msg but saw $next\")\n    }\n}\n\ninline fun<reified T> parseList(tokens: Peekable<Token>, endTokens: List<Token>, commaSeparated: Boolean, parseItem: () -> T) : MutableList<T>  {\n    val list = mutableListOf<T>()\n    if (!endTokens.contains(tokens.peek())) {\n        list.add(parseItem())\n    }\n    while (!endTokens.contains(tokens.peek()!!)) {\n        if (commaSeparated) {\n            if (tokens.peek() is Token.COMMA) {\n                expect<Token.COMMA>(tokens, \",\")\n            } else {\n                break\n            }\n        }\n        list += parseItem()\n        if (tokens.peek() is Token.EOF) {\n            throw Exception(\"Unclosed list\")\n        }\n    }\n    return list\n}\n\nfun parse(expression: String): FunctionCall  {\n    \n    val tokens = Peekable(tokenize(expression))\n\n    fun lambda(): Expr.Lambda {\n        expect<Token.LEFT_BRACE>(tokens, \"{\")\n        val content = parseList(tokens, listOf(Token.ARROW, Token.RIGHT_BRACE), true) {\n            expect<Token.NAME_OR_NUMBER>(tokens, \"name or number\").string\n        }\n        var params = emptyList<String>()\n        var stmts = emptyList<String>()\n        if (content.size > 0 && tokens.peek() is Token.ARROW) {\n            params = content\n            expect<Token.ARROW>(tokens, \"->\")\n        } else if (content.size == 1) {\n            stmts = content\n        } else if(content.isNotEmpty()) {\n            throw Exception(\"expected ->\")\n        }\n        stmts += parseList(tokens, listOf(Token.RIGHT_BRACE), false) {\n            expect<Token.NAME_OR_NUMBER>(tokens, \"name or number\").string\n        }\n        expect<Token.RIGHT_BRACE>(tokens, \"}\")\n\n        return Expr.Lambda(params, stmts)\n    }\n\n    fun expr(): Expr {\n        return when (tokens.peek()) {\n            is Token.NAME_OR_NUMBER -> Expr.NameOrNumber(expect<Token.NAME_OR_NUMBER>(tokens, \"name or number\").string)\n            else -> lambda()\n        }\n    }\n\n    fun functionCall(): FunctionCall {\n        val name = expr()\n        var params = mutableListOf<Expr>()\n        if (tokens.peek() is Token.LEFT_PARENT) {\n            expect<Token.LEFT_PARENT>(tokens, \"(\")\n            params = parseList(tokens, listOf(Token.RIGHT_PARENT), true, ::expr)\n            expect<Token.RIGHT_PARENT>(tokens, \")\")\n        } else if (tokens.peek() !is Token.LEFT_BRACE) {\n            throw Exception(\"expected lambda, but got ${tokens.peek()}\")\n        }\n        if (tokens.peek() is Token.LEFT_BRACE) {\n            params.add(lambda())\n        }\n        return FunctionCall(name, params)\n    }\n    return functionCall().also { expect<Token.EOF>(tokens, \"EOF\") }\n}\n\nfun transpile(expression: String): String {\n    \n    fun lambda(lambda: Expr.Lambda) =\n            \"(${lambda.params.joinToString(\",\")})\" +\n            \"{${lambda.statement.joinToString(\";\")}\" +\n            \"${if (lambda.statement.isNotEmpty()) \";\" else \"\"}}\"\n\n    fun expr(expr: Expr) =\n        when (expr) {\n            is Expr.NameOrNumber -> expr.string\n            is Expr.Lambda -> lambda(expr)\n        }\n\n    fun functionCall(call: FunctionCall) =\n            \"${expr(call.name)}\" +\n            \"(${call.params.joinToString(\",\"){expr(it)}})\"\n\n    return try {\n        functionCall(parse(expression))\n    } catch(exception: Exception) {\n        \"\"\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208817,"user_id":null,"body":"fun transpile(expression: String): String {\n    return compileFunction(simplify(expression))\n}\n\nfun compileFunction(functionIn: String): String {\n    if(badName.find(functionIn)?.groupValues != null)\n        return \"\"\n\n    var function  = functionIn\n    if(lambdaParamFunct.matches(function)){\n        var (_, lambd1, param) = lambdaParamFunct.matchEntire(function)!!.groupValues\n        if(!lambdaPattern.matches(lambd1)) return \"\" else lambd1 = convertLambda(lambd1)\n        if(!paramPattern.matches(param)) return \"\"\n        param = params.findAll(param)\n            .map { it.value }.toList()\n            .map { if(lambdaPattern.matches(it)) convertLambda(it) else it }\n            .joinToString(\",\")\n\n        return \"$lambd1($param)\"\n    }\n    else if(exprParamFunct.matches(function)){\n        var (_, expr, param) = exprParamFunct.matchEntire(function)!!.groupValues\n        expr = expr.trim()\n        if(!nameOrNumber.toRegex().matches(expr)) return \"\"\n        if(!paramPattern.matches(param)) return \"\"\n        param = params.findAll(param)\n            .map { it.value }.toList()\n            .map { if(lambdaPattern.matches(it)) convertLambda(it) else it }\n            .joinToString(\",\")\n        return \"$expr($param)\"\n    }\n\n    return \"\"\n}\n\nfun simplify(functionIn : String): String{\n    var function  = functionIn\n\n    if(lambdaParamFunct.matches(function)){\n        \/\/ simplifies a lambdaParam function\n        val (_, lambd1, param, lambd2) = lambdaParamFunct.matchEntire(function)!!.groupValues\n        function = when {\n            (lambd2.isNotBlank() && param.isNotBlank()) -> \"$lambd1($param,$lambd2)\"\n            lambd2.isNotBlank()                         -> \"$lambd1($lambd2)\"\n            else                                        -> \"$lambd1($param)\"\n        }\n    }\n    else if(exprParamFunct.matches(function)){\n        \/\/ simplifies an exprParam function\n        val (_, expr, param, lambd) = exprParamFunct.matchEntire(function)!!.groupValues\n        if(!paramPattern.matches(param)) return \"\"\n        function = when {\n            (lambd.isNotBlank() && param.isNotBlank()) -> \"$expr($param,$lambd)\"\n            lambd.isNotBlank()                         -> \"$expr($lambd)\"\n            else                                       -> \"$expr($param)\"\n        }\n    }\n    else if(lambdaLambdaFunct.matches(function)){\n        \/\/ converts a lambdaLambda function to a lambdaParam function\n        val (_, lambd1, lambd2) = lambdaLambdaFunct.matchEntire(function)!!.groupValues\n        function = \"$lambd1($lambd2)\"\n    }\n    else if(exprLambdaFunct.matches(function)){\n        \/\/ converts a exprLambda function to an exprParam function\n        val (_, expr, lambd) = exprLambdaFunct.matchEntire(function)!!.groupValues\n        if(!lambdaPattern.matches(lambd)) return \"\"\n        function = \"$expr($lambd)\"\n    }\n    return function\n}\n\nfun convertLambda(lamd: String):String{\n    var (_, param, stmt) = lambdaPattern.matchEntire(lamd)!!.groupValues\n    param = \"\\\\s+\".toRegex().replace(param, \"\")\n    stmt = stmt.trim().split(\"\\\\s+\".toRegex()).joinToString(\";\", \"\", \";\")\n        .let {\n            when{\n                it == \";\" -> \"\"\n                else -> it\n            }\n        }\n    return \"(${param}){${stmt}}\"\n}\n\nval lambdaLambdaFunct = \"\\\\s*(\\\\{.*\\\\})\\\\s*(\\\\{.*\\\\})\\\\s*\".toRegex(RegexOption.DOT_MATCHES_ALL)\nval lambdaParamFunct = \"\\\\s*(\\\\{.*\\\\})\\\\s*\\\\((.*)\\\\)\\\\s*(\\\\{.*\\\\})?\\\\s*\".toRegex(RegexOption.DOT_MATCHES_ALL)\nval exprLambdaFunct = \"(.*)(\\\\{.*\\\\})\\\\s*\".toRegex(RegexOption.DOT_MATCHES_ALL)\nval exprParamFunct = \"(.*)\\\\((.*)\\\\)\\\\s*(\\\\{.*\\\\})?\\\\s*\".toRegex(RegexOption.DOT_MATCHES_ALL)\nval nameOrNumber = \"\\\\d+|(?:[a-zA-Z_]\\\\w*)\".toPattern()\nval lambdaParamPattern = \"\\\\s*(?:${nameOrNumber})\\\\s*(?:,\\\\s*(?:${nameOrNumber})\\\\s*)*\".toPattern()\nval lambdaStmtPattern = \"(?:\\\\s*(?:${nameOrNumber})\\\\s*)+\".toPattern()\nval lambdaPattern = \"\\\\{\\\\s*(?:((?:$nameOrNumber)\\\\s*(?:,\\\\s*(?:$nameOrNumber)\\\\s*)*\\\\s*)->\\\\s*)?\\\\s*((?:$nameOrNumber)\\\\s*(?:\\\\s+(?:$nameOrNumber))*)?\\\\s*\\\\}\".toRegex() \/\/val lambdaPattern = \"\\\\{(?:(${lambdaParamPattern})->)?\\\\s*(${lambdaStmtPattern})?\\\\s*\\\\}\".toRegex()\nval exprPattern = \"\\\\s*(?:${nameOrNumber}|${lambdaPattern})\\\\s*\".toPattern()\nval paramPattern = \"\\\\s*((${exprPattern})(,${exprPattern})*)?\\\\s*\".toRegex()\nval params = \"($lambdaPattern)|($nameOrNumber)\".toRegex()\nval badName = \"[(){}, ]\\\\\\\\d+[a-zA-Z_]+\".toRegex()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208818,"user_id":null,"body":"fun transpile(expression: String): String {\n    return try {\n        Fun(expression).toString()\n    } catch (ex: IllegalArgumentException) {\n        \"\"\n    }\n}\n\nprivate data class Fun(val expression: Expression, val params: List<Expression>) {\n    override fun toString(): String = expression.toString() + params.joinToString(\",\", \"(\", \")\")\n}\n\nprivate fun Fun(text: String): Fun {\n    Regex(\"(?s)([^()]*)(?:\\\\((.*)\\\\)(.*)|(\\\\{.*}))\").matchEntire(text.trim())?.let { result ->\n        val expression = Expression(result.groupValues[1])\n        val params = result.groupValues[2].split().map { Expression(it) } +\n                result.groupValues.slice(3..4).filter { it.isNotBlank() }.map { Lambda(it) }\n        return Fun(expression, params)\n    } ?: throw IllegalArgumentException(\"Invalid Fun: '$text'\")\n}\n\nprivate interface Expression\n\nprivate fun Expression(text: String): Expression {\n    return if (text.trim() matches Regex(\"(?s)\\\\{.*}\")) Lambda(text) else parseNameNum(text)\n}\n\nprivate data class Lambda(val params: List<NameNum>, val statements: List<NameNum>) : Expression {\n    override fun toString(): String {\n        return params.joinToString(\",\", \"(\", \")\") +\n                statements.joinToString(\"\", \"{\", \"}\") { \"$it;\" }\n    }\n}\n\nprivate fun Lambda(text: String): Lambda {\n    Regex(\"(?s)\\\\{(?:(.*)->)?(.*)}\").matchEntire(text.trim())?.let { result ->\n        val params = result.groupValues[1].split().map { parseNameNum(it) }\n        require((result.groups[1] == null) == params.isEmpty()) { \"Empty Lambda params: '$text'\" }\n        val statements = result.groupValues[2].trim().takeIf { it.isNotBlank() }\n                ?.split(Regex(\"\\\\s+\"))?.map { parseNameNum(it) } ?: emptyList()\n        return Lambda(params, statements)\n    } ?: throw IllegalArgumentException(\"Invalid Lambda: '$text'\")\n}\n\nprivate data class NameNum(val nameNum: String) : Expression {\n    override fun toString(): String = nameNum\n}\n\nprivate fun parseNameNum(text: String): NameNum {\n    require(text.trim() matches Regex(\"(?i)[_a-z][_a-z\\\\d]*|\\\\d+\")) { \"Invalid Name\/Number: '$text'\" }\n    return NameNum(text.trim())\n}\n\nprivate fun String.split(): List<String> {\n    return if (isNotBlank()) {\n        val list = mutableListOf<String>()\n        var depth = 0\n        val buf = StringBuilder()\n        outer@ for (c in trim()) {\n            when (c) {\n                ',' -> if (depth == 0) {\n                    list += buf.toString()\n                    buf.clear()\n                    continue@outer\n                }\n                '{' -> depth++\n                '}' -> {\n                    depth--\n                    if (depth < 0) throw IllegalArgumentException(\"Unmatched braces: $this\")\n                }\n            }\n            buf.append(c)\n        }\n        if (depth != 0) throw IllegalArgumentException(\"Unmatched braces: $this\")\n        list += buf.toString()\n        list\n    } else emptyList()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5993c1d917bc97d05d000068":[{"id":208819,"user_id":490,"body":"import java.util.HashMap\nimport java.util.HashSet\n\nprivate fun generateRegex(n: Int): String {\n\tif (n == 1) return \"1[01]*\"\n\tval states = HashSet<Int>()\n\tstates += 0 until n\n\tval dfa = DFA(states, 0, arrayOf(0))\n\tfor (i in 0 until n) {\n\t\tdfa.addTransition(i, i * 2 % n, \"0\")\n\t\tdfa.addTransition(i, (i * 2 + 1) % n, \"1\")\n\t}\n\treturn dfa.reduce()\n}\n\nfun regex_divisible_by(n: Int): String {\n\tvar n = n\n\tval start = \"^(0|\"\n\tvar end = \")$\"\n\twhile (n % 2 == 0) {\n\t\tend = \"0\" + end\n\t\tn \/= 2\n\t}\n\treturn String.format(\"%s%s%s\", start, generateRegex(n), end)\n}\n\ninternal class Transition(var from: Int, var to: Int) : Comparable<Transition> {\n\toverride fun equals(other: Any?): Boolean {\n\t\tif (other is Transition) {\n\t\t\tval otherTrans = other as Transition?\n\t\t\treturn this.from == otherTrans!!.from && this.to == otherTrans.to\n\t\t}\n\t\treturn false\n\t}\n\n\toverride operator fun compareTo(other: Transition): Int {\n\t\tval compare = this.from.compareTo(other.from)\n\t\treturn if (compare == 0) this.to.compareTo(other.to) else compare\n\t}\n\n\toverride fun toString(): String {\n\t\treturn String.format(\"(from: %d, to: %d)\", this.from, this.to)\n\t}\n}\n\ninternal class DFA(private val states: HashSet<Int>, startState: Int, acceptedStates: Array<Int>) {\n\tprivate val START_STATE = -1\n\tprivate val END_STATE = -2\n\tprivate val transitions: HashMap<Transition, String> = hashMapOf()\n\n\tinit {\n\t\tthis.addTransition(START_STATE, startState, \"\")\n\t\tfor (acceptedState in acceptedStates) {\n\t\t\tthis.addTransition(acceptedState, END_STATE, \"\")\n\t\t}\n\t}\n\n\tfun addTransition(from: Int, to: Int, transition: String) {\n\t\tthis.transitions.put(Transition(from, to), transition)\n\t}\n\n\tprivate fun selectState(): Int {\n\t\tval fromCount = HashMap<Int, Int>()\n\t\tval toCount = HashMap<Int, Int>()\n\t\tfor (transition in this.transitions.keys) {\n\t\t\tif (transition.from != transition.to) {\n\t\t\t\tvar currentCount = (fromCount as MutableMap<Int, Int>).getOrDefault(transition.from, 0)\n\t\t\t\tfromCount.put(transition.from, currentCount + 1)\n\t\t\t\tcurrentCount = (toCount as MutableMap<Int, Int>).getOrDefault(transition.to, 0)\n\t\t\t\ttoCount.put(transition.to, currentCount + 1)\n\t\t\t}\n\t\t}\n\t\tvar minState = 0\n\t\tvar minBranches = 999\n\t\tfor (state in this.states) {\n\t\t\tval from = (fromCount as MutableMap<Int, Int>).getOrDefault(state, 0)\n\t\t\tval to = (toCount as MutableMap<Int, Int>).getOrDefault(state, 0)\n\t\t\tval branches = from * to\n\t\t\tif (branches < minBranches) {\n\t\t\t\tminState = state\n\t\t\t\tminBranches = branches\n\t\t\t}\n\t\t}\n\t\treturn minState\n\t}\n\n\tprivate fun removeState(state: Int?) {\n\t\tval enteringTrans = HashMap<Int, String>()\n\t\tval exitingTrans = HashMap<Int, String>()\n\t\tvar loop = \"\"\n\t\tvar hasLoop = false\n\t\tvar keys = HashSet(this.transitions.keys)\n\t\tfor (trans in keys) {\n\t\t\tif (trans.from == trans.to && trans.from == state) {\n\t\t\t\tloop = this.transitions[trans]!!\n\t\t\t\thasLoop = true\n\t\t\t} else if (trans.from == state) {\n\t\t\t\texitingTrans.put(trans.to, this.transitions[trans]!!)\n\t\t\t} else if (trans.to == state) {\n\t\t\t\tenteringTrans.put(trans.from, this.transitions[trans]!!)\n\t\t\t}\n\t\t\tif (trans.from == state || trans.to == state) {\n\t\t\t\tthis.transitions.remove(trans)\n\t\t\t}\n\t\t}\n\t\tif (hasLoop) {\n\t\t\tloop = String.format(\"(%s)*\", loop)\n\t\t}\n\t\tfor (enterState in enteringTrans.keys) {\n\t\t\tval enteringString = enteringTrans[enterState]\n\t\t\tfor (exitState in exitingTrans.keys) {\n\t\t\t\tval exitingString = exitingTrans[exitState]\n\n\t\t\t\tvar existingTrans: String? = null\n\t\t\t\tvar hasExistingTrans = false\n\t\t\t\tkeys = HashSet(this.transitions.keys)\n\t\t\t\tfor (trans in keys) {\n\t\t\t\t\tif (trans.from == enterState && trans.to == exitState) {\n\t\t\t\t\t\texistingTrans = this.transitions[trans]\n\t\t\t\t\t\thasExistingTrans = true\n\t\t\t\t\t\tthis.transitions.remove(trans)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar newTrans = String.format(\"%s%s%s\", enteringString, loop, exitingString)\n\t\t\t\tif (hasExistingTrans) {\n\t\t\t\t\tnewTrans = String.format(\"(%s|%s)\", existingTrans, newTrans)\n\t\t\t\t}\n\t\t\t\tthis.addTransition(enterState, exitState, newTrans)\n\t\t\t}\n\t\t}\n\t\tthis.states.remove(state)\n\t}\n\n\tfun reduce(): String {\n\t\twhile (this.states.size > 0) {\n\t\t\tval state = this.selectState()\n\t\t\tthis.removeState(state)\n\t\t}\n\t\tvar result = \"\"\n\t\tfor (trans in this.transitions.keys) {\n\t\t\tresult = this.transitions[trans]!!\n\t\t}\n\t\treturn result\n\t}\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208820,"user_id":null,"body":"fun String?.star() = if (this === null) \"\" else \"($this)*\"\ninfix fun String?.and(x: String?) = this ?.let { a -> x?.let { \"($a)($it)\" }}\ninfix fun String?.or(x: String?) =\n    when {\n        this === null -> x\n        x === null -> this\n        else -> \"($this)|($x)\"\n    }\n\nfun regex_divisible_by(m: Int): String {\n    if (m == 1) return \"[01]*\"\n    val b = Array<String?>(m) { null }\n    val a = Array<String?>(m * m) { null }\n\n    operator fun Array<String?>.get(a: Int, b: Int) = this[a * m + b]\n    operator fun Array<String?>.set(a: Int, b: Int, s: String?) { this[a * m + b] = s }\n\n    b[0] = \"\"\n\n    for (i in 0..(m-1)) {\n        a[i, i * 2 % m] = \"0\"\n        a[i, (i * 2 + 1) % m] = \"1\"\n    }\n\n    for (n in (m - 1) downTo 0) {\n        b[n] = a[n, n].star() and b[n]\n        for (j in 0..n) {\n            a[n, j] = a[n, n].star() and a[n, j]\n        }\n        for (i in 0..n) {\n            b[i] = b[i] or (a[i, n] and b[n])\n            for (j in 0..n) {\n                a[i, j] = a[i, j] or (a[i, n] and a[n, j])\n            }\n        }\n    }\n\n    return b[0]!!\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208821,"user_id":null,"body":"fun regex_divisible_by(m: Int): String {\n    var n = m\n    if (n == 1)\n        return \"^(0|1)+$\"\n\n    val result = MutableList(n) { MutableList(n) { \"\" } }\n\n    for (i in 0 until n) {\n        result[i][(i * 2) % n] = \"0\"\n        result[i][(i * 2 + 1) % n] = \"1\"\n    }\n\n    for (k in 0 until result.size - 1) {\n        n = result.size\n        for (i in 0 until n) {\n            if (result[i][n - 1] == \"\") continue\n            for (j in 0 until n) {\n                if (result[n - 1][j] == \"\") continue\n                result[i][j] = when {\n                    result[i][j] == \"\" && result[n - 1][n - 1] == \"\" ->\n                        \"(${result[i][n - 1]})(${result[n - 1][j]})\"\n                    result[i][j] == \"\" ->\n                        \"(${result[i][n - 1]})(${result[n - 1][n - 1]})*(${result[n - 1][j]})\"\n                    result[n - 1][n - 1] == \"\" ->\n                        \"(${result[i][j]})|(${result[i][n - 1]})(${result[n - 1][j]})\"\n                    else ->\n                        \"(${result[i][j]})|((${result[i][n - 1]})(${result[n - 1][n - 1]})*(${result[n - 1][j]}))\"\n                }\n            }\n        }\n        result.removeAt(n - 1)\n    }\n\n\n    return \"^(${result[0][0]})+$\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208822,"user_id":null,"body":"fun regex_divisible_by(n: Int): String = if (n == 1) \"^(?:0|1)*$\" else dfaFor(n).toRegex()\nfun dfaFor(n: Int): List<State> = (0 until n).map { State(it, (2 * it) % n, (2 * it + 1) % n) }\nfun List<State>.toRegex(): String {\n    val nodes = map { mutableMapOf(it.delta0 to \"0\", it.delta1 to \"1\") }.toMutableList()\n    while (nodes.size > 1) {\n        var last = nodes.removeLast()\n        last.remove(nodes.size)?.run { last = last.mapValues { (if (length == 1) \"$this*\" else \"(?:$this)*\") + it.value }.toMutableMap() }\n        nodes.forEach { node -> node.remove(nodes.size)?.let { last.forEach { n -> node[n.key]?.run { node[n.key] = \"(?:$this|${it + n.value})\" } ?: run { node[n.key] = it + n.value } } } }\n    }\n    return \"^${nodes[0].values.single()}*$\"\n}\nclass State(val index: Int, val delta0: Int, var delta1: Int)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208823,"user_id":null,"body":"fun regex_divisible_by(m: Int): String {\n    var n = m\n    if (n == 1)\n        return \"^(0|1)+$\"\n\n    val result = MutableList(n) { MutableList(n) { \"\" } }\n\n    for (i in 0 until n) {\n        result[i][(i * 2) % n] = \"0\"\n        result[i][(i * 2 + 1) % n] = \"1\"\n    }\n\n    for (k in 0 until result.size - 1) {\n        n = result.size\n        for (i in 0 until n) {\n            if (result[i][n - 1] == \"\") continue\n            for (j in 0 until n) {\n                if (result[n - 1][j] == \"\") continue\n                result[i][j] = when {\n                    result[i][j] == \"\" && result[n - 1][n - 1] == \"\" ->\n                        \"(?:${result[i][n - 1]})(?:${result[n - 1][j]})\"\n                    result[i][j] == \"\" ->\n                        \"(?:${result[i][n - 1]})(?:${result[n - 1][n - 1]})*(?:${result[n - 1][j]})\"\n                    result[n - 1][n - 1] == \"\" ->\n                        \"(?:${result[i][j]})|(?:${result[i][n - 1]})(?:${result[n - 1][j]})\"\n                    else ->\n                        \"(?:${result[i][j]})|(?:(?:${result[i][n - 1]})(?:${result[n - 1][n - 1]})*(?:${result[n - 1][j]}))\"\n                }\n            }\n        }\n        result.removeAt(n - 1)\n    }\n\n\n    return \"^(${result[0][0]})+$\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208824,"user_id":53,"body":"fun regex_divisible_by(n: Int): String \n{\n    if (n == 1) return \"^[01]*$\";\n    var graphs = Array(n, {i -> Array(n, {j -> \"-1\"})});\n    for (i in 0..(n - 1))\n    {\n        graphs[i][(2 * i) % n] = \"0\";\n        graphs[i][(2 * i + 1) % n] = \"1\";\n    }\n    for (k in (n - 1) downTo 0)\n    {\n        val loop = if (graphs[k][k] == \"-1\" ) \"\" else (graphs[k][k] + \"*\");\n        for (i in 0..(k - 1))\n        {\n            if (graphs[i][k] == \"-1\") continue;\n            for (j in 0..(k - 1))\n            {\n                if (graphs[k][j] == \"-1\") continue;\n                val s = if (graphs[i][j] == \"-1\" ) \"\" else (graphs[i][j] + \"|\");\n                graphs[i][j] = \"(?:\" + s + graphs[i][k] + loop + graphs[k][j] + \")\";\n            }\n        }\n    }\n    return \"^\" + graphs[0][0] + \"*$\";\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208825,"user_id":null,"body":"sealed class RE\ndata class Lit(var lit: Any): RE() { override fun toString() = \"$lit\" }\ndata class Alter(var res: MutableSet<RE> = mutableSetOf()): RE() {\n    override fun toString() = res.joinToString(\"|\", \"(\", \")\")\n    fun add(re: RE) { if (re is Alter) res.addAll(re.res) else res.add(re) }\n}\ndata class Concat(var res: MutableList<RE> = mutableListOf()): RE() {\n    override fun toString() = res.joinToString(\"\", \"(\", \")\")\n    fun add(re: RE) {\n        when (re) {\n            is Concat -> res.addAll(re.res)\n            is Epsilon -> {}\n            else -> res.add(re)\n        }\n    }\n}\ndata class Star(var re: RE): RE() { override fun toString() = \"$re*\" }\nobject Epsilon : RE() { override fun toString() = \"\" }  \/\/ a.k.a OneRE\nfun makeConcat(vararg res: RE): Concat = Concat().apply { res.forEach { add(it) } }\nfun makeAlter(vararg res: RE): Alter = Alter().apply { res.forEach { add(it) } }\nfun makeStar(re: RE): RE = if (re is Epsilon || re is Star) re else Star(re)\n\nclass GeneralizedNFA(val nState: Int, val starts: Collection<Int>, val accepts: Collection<Int>) {\n    private var matrix = MutableList(nState + 1) { MutableList<RE?>(nState + 1) { null } }\n    init { \/\/ Rows: [0 1 2 .. n_state-1 START], Cols: [0 1 2 .. n_state-1 END]\n        starts.forEach  { addTrans(nState, it, Epsilon) }\n        accepts.forEach { addTrans(it, nState, Epsilon) }\n    }\n\n    fun addTrans(src: Int, dst: Int, re: RE) {\n        when (val oldR = matrix[src][dst]) {\n            null -> matrix[src][dst] = re\n            is Alter -> oldR.add(re)\n            else -> matrix[src][dst] = makeAlter(oldR, re)\n        }\n    }\n\n    fun toRe(): RE {\n        for (state in 0 until nState) { \/* We want to delete the state `state` here *\/\n            val loopRe = makeStar(matrix[state][state] ?: Epsilon)\n            for (src in state+1 .. nState) {\n                val srcRe = matrix[src][state] ?: continue\n                for (dst in state+1 .. nState) {\n                    val dstRe = matrix[state][dst] ?: continue\n                    addTrans(src, dst, makeConcat(srcRe, loopRe, dstRe))\n                }\n            }\n        }\n        return matrix[nState][nState]!!\n    }\n}\n\nfun regex_divisible_by(n: Int): String {\n    val m = GeneralizedNFA(n, starts = listOf(0), accepts = listOf(0))\n    for (src in 0 until n)\n        (0..1).forEach { m.addTrans(src, (src*2 + it) % n, Lit(it.toString(2))) }\n    return m.toRe().toString()\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208826,"user_id":null,"body":"fun regex_divisible_by(n: Int): String {\n  val result = regDivisibleByBasic(n)\n  println(result)\n  return \"^0+|$result$\"\n}\n\nfun regDivisibleByBasic(n: Int): String {\n    \/\/ Obvious base case\n    if (n == 1) return \"[01]*\"\n    \/\/ Obvious recursive case\n    if (n % 2 == 0) return \"${regDivisibleByBasic(n\/2)}0\"\n    \/\/ Non-trivial base case.\n    \/\/ We construct a Finite State Machine to match binary numbers divisible by n, then convert it to a regular expression.\n    \/\/ If the FSM is in state S, then that means value of the input so far is equivalent to S mod n.\n    \/\/ When we munch a new bit, the value of the input so far doubles and increases by the value of the bit.\n    \/\/ The FSM starts in state 0, and accepts the input if it is in state 0 when the input ends.\n    val trans = Array(n) {\n        arrayListOf(\n            Pair(\"0\", (2*it) % n),\n            Pair(\"1\", (2*it+1) % n)\n        )\n    }\n    while (trans[0].size > 1 || trans[0][0].second != 0) {\n        if (tryAlternationReduction(trans)) continue\n        if (tryLoopReduction(trans)) continue\n        removeLastStateConnection(trans)\n    }\n    return \"(${trans[0][0].first})*\"\n}\n\n\/\/ Reduce a pair of transition rules x => s, y => s to a single rule x|y => s\nfun tryAlternationReduction(trans: Array<ArrayList<Pair<String, Int>>>): Boolean {\n    for (i in 0 until trans.size) {\n        val list = trans[i]\n        for (j in 0 until list.size) {\n            for (k in 0 until list.size) {\n                if (j != k && list[j].second == list[k].second) {\n                    val (a, to) = list[j]\n                    val b = list[k].first\n                    list.removeAt(k)\n                    list[j] = Pair(\"($a|$b)\", to)\n                    return true\n                }\n            }\n        }\n    }\n    return false\n}\n\n\/\/ In state s, remove a rule x => s by altering all other rules y => s' to x*y => s'\nfun tryLoopReduction(trans: Array<ArrayList<Pair<String, Int>>>): Boolean {\n    \/\/ skip 0 since that one has the loop we want\n    for (i in 1 until trans.size) {\n        val list = trans[i]\n        for (j in 0 until list.size) {\n            val (reg, to) = list[j]\n            if (to == i) {\n                val reg = if (reg.length == 1) reg else \"($reg)\"\n                list.removeAt(j)\n                for (j in 0 until list.size) {\n                    val (a, b) = list[j]\n                    list[j] = Pair(\"$reg*$a\", b)\n                }\n                return true\n            }\n        }\n    }\n    return false\n}\n\n\/\/ Removes a transition to the last state somewhere in the FSM.\n\/\/ Also clears the transitions from unreachable states to avoid unneccessary work\nfun removeLastStateConnection(trans: Array<ArrayList<Pair<String, Int>>>) {\n    var lastFrom = 0\n    var lastIndex= 0\n    var lastTo = 0\n    for (i in 0 until trans.size) {\n        for (j in 0 until trans[i].size) {\n            if (trans[i][j].second > lastTo) {\n                lastTo = trans[i][j].second\n                lastFrom = i\n                lastIndex = j\n            }\n        }\n    }\n    for (i in lastTo+1 until trans.size)\n        trans[i].clear()\n    val new = ArrayList<Pair<String, Int>>()\n    val reg = trans[lastFrom][lastIndex].first\n    for ((a, b) in trans[lastTo]) {\n        new.add(Pair(\"$reg$a\", b))\n    }\n    trans[lastFrom].removeAt(lastIndex)\n    trans[lastFrom].addAll(new)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208827,"user_id":null,"body":"class Helper (val N : Int){\n    val conn = Array<Array<String>> (N) { Array<String> (N) { \"\" } }\n\n    \/\/ Generate a state machine that has n states (0..N-1), keeping track\n    \/\/ of the remainder of a number divided by N\n    init {\n        for (i in 0 until N) for (j in 0..1) conn[i][(i * 2 + j) % N] = j.toString()\n    }\n\n    \/\/ Remove a node from the state machine, we check all connection into and ouy of the node and add them as new edges or another \n    \/\/ condition on existing edges\n    fun remove(node:Int) {\n        val loop = conn[node][node].let { if (it == \"\") \"\" else doPar(it) + \"*\" }\n\n        for (i in 0 until N) for (j in 0 until N) if (i != node && j != node && conn[i][node] != \"\" && conn[node][j] != \"\"){\n           conn[i][j] = doOr(conn[i][j], doParC(conn[i][node])+loop+doParC(conn[node][j]))\n        }\n        for (i in 0 until N) {\n            conn[i][node]=\"\"\n            conn[node][i]=\"\"\n        }\n    }\n    \n    \/\/ Try to avoid extra parentheses if they are not needed.\n    private fun doParC(a:String) = if (a.contains('|')) \"($a)\" else a\n    private fun doPar(a:String) = if (a.length <= 1) a else \"($a)\"\n    private fun doOr(a: String, b: String) = if (a == \"\") b else if (b==\"\") a else doParC(a) + \"|\" + doParC(b)\n}\n\nfun regex_divisible_by(n: Int): String {\n  if (n == 1) return \"[01]*\"\n  var h = Helper(n)\n  for (i in 1 until n) h.remove(i)\n  return \"(${h.conn[0][0]})*\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208828,"user_id":null,"body":"var states : ArrayList<State> = ArrayList()\n\nclass Connection(var src: State, var dst: State, var link: String)\n\nclass State(mod: Int, var n: Int) {\n    var m: Int = mod\n    var links : ArrayList<Connection> = ArrayList ()\n\n    fun makeConnections(){\n        \/\/ bit 1:\n        val b1 = Connection(this, states[(m * 2 + 1)%n], \"1\")\n        this.addConnection(b1)\n        if ((m * 2 + 1)%n != m)\n            states[(m * 2 + 1)%n].addConnection(b1)\n        \/\/ bit 0:\n        val b0 = Connection(this, states[(m * 2)%n], \"0\")\n        this.addConnection(b0)\n        if ((m * 2)%n != m)\n            states[(m * 2)%n].addConnection(b0)\n    }\n    fun getConnection(src: Int, dst : Int) : Connection?{\n        return links.find { c -> c.src.m == src && c.dst.m == dst }\n    }\n    fun addConnection(con: Connection){\n        val prevCon = getConnection(con.src.m, con.dst.m)\n        if (prevCon != null){\n\n            links.remove(prevCon)\n            links.add(Connection(prevCon.src, prevCon.dst, \"(\" + prevCon.link + \")\" + \"|\" + \"(\" + con.link + \")\"))\n        }\n        else\n            links.add(con)\n    }\n    fun removeConnection(con : Connection){\n        val conn = links.find { c -> c.src.m == con.src.m && c.dst.m == con.dst.m }\n        if (conn != null) links.remove(conn)\n    }\n}\n\nclass FSA(n: Int) {\n    init {\n        for (m in 0..(n-1))\n            states.add(State(m, n))\n        for (m in 0..(n-1))\n            states[m].makeConnections()\n\n    }\n}\n\nfun removeState(index: Int){\n    val state = states[index]\n    val outLinks = state.links.filter { c -> c.src.m == state.m && c.dst.m != state.m}\n    val inLinks = state.links.filter { c -> c.dst.m == state.m && c.src.m != state.m}\n    val autoLink = state.getConnection(state.m, state.m)\n    \/\/Link inStates with outStates\n    for (inp in inLinks){\n        var newLink = \"(\" + inp.link + \")\"\n        if (autoLink!= null) newLink += \"(\" + autoLink.link + \")*\"\n        for (out in outLinks){\n            val newCon = Connection (inp.src, out.dst, newLink + \"(\" + out.link + \")\")\n            out.dst.addConnection(newCon)\n            if (out.dst.m != inp.src.m)\n                inp.src.addConnection(newCon)\n        }\n    }\n    \/\/Remove previous connections\n    for (inp in inLinks) inp.src.removeConnection(inp)\n    for (out in outLinks) out.dst.removeConnection(out)\n    states.remove(state)\n}\n\nfun regex_divisible_by(n: Int): String {\n    states.clear()\n    FSA(n)\n    while (states.size > 1){\n        removeState(states.size - 1)\n    }\n\n    return \"^(\" + states[0].links[0].link + \")*$\"\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"59f9cad032b8b91e12000035":[{"id":208829,"user_id":503,"body":"@Suppress(\"UNCHECKED_CAST\",\"IMPLICIT_CAST_TO_ANY\",\"NAME_SHADOWING\")\nfun kcuf(RawCode : String,Origin : Boolean = false,Indent : String = \"\\t\") : String\n{\n\tvar Code = \"\"\n\tvar CodeAt = 0\n\tvar Output = \"\"\n\tvar Preserve = 9\n\tvar PreserveMax = -1\n\tval Stack = Array(Preserve,{0})\n\tvar StackAt = 0\n\tvar VarAt = Preserve--\n\tval Var = mutableMapOf<String,Any>()\n\tval AST = mutableListOf<Array<Any>>()\n\tval ASTStack = java.util.Stack<Int>()\n\tvar CurrentAST = AST\n\tval Proc = mutableMapOf<String,Array<Any>>()\n\tvar ProcSig : String? = null\n\tvar ProcVar : MutableList<String>? = null\n\tvar ProcVarType : MutableList<Array<Any>?>? = null\n\n\tvar Line = 0\n\tvar LastCol = 0\n\tval CaseSensetive = {Q : String -> Q.toUpperCase()}\n\tval Clamp = {Q : Int ->\n\t\tval R = Q % 256\n\t\tif (R < 0) 256 + R else R}\n\n\tfun Bad(Q : String,J : Boolean = false) = fun(A : Any?)\n\t{\n\t\tthrow Error((if (null == A) Q else if (A is Array<*>) String.format(Q,*A) else String.format(Q,A)) +\n\t\t\t\"\n\\tat $Line:${if (J) 1 + LastCol else 1 + CodeAt} '$Code'\")\n\t}\n\t\/\/\tParse Error\n\tval ErrorNumberExpected = Bad(\"A number is expected but got %s\")\n\tval ErrorNameExpected = Bad(\"A variable name \/ command is expected but got %s\")\n\tval ErrorCommand = Bad(\"Unexpected command %s\",true)\n\tval ErrorCommandEnd = Bad(\"Expected end of line but got %s\")\n\tval ErrorDefineInProc = Bad(\"Cannot define variables in procedures\")\n\tval ErrorVarUndefined = Bad(\"Undefined variable %s\",true)\n\tval ErrorVarRedeclare = Bad(\"Re-defined variable %s\",true)\n\tval ErrorVarButList = Bad(\"Expected a variable but %s is a list\",true)\n\tval ErrorListButVar = Bad(\"Expected a list but %s is a variable\",true)\n\tval ErrorVarTypeMismatch = Bad(\"Type mismatch\n\" +\n\t\t\"\\tin `%s`\n\" +\n\t\t\"\\t%s was used as a %s at %s:%s `%s`\n\" +\n\t\t\"\\tas well being used as a %s\",true)\n\tval ErrorUnEOL = Bad(\"Unexpected end of line\")\n\tval ErrorUnclosed = Bad(\"Unclosed %s, expected %s but got %s\")\n\tval ErrorBadEscape = Bad(\"Unexpected char escape \\\\%s\")\n\tval ErrorStringExpect = Bad(\"A string is expected but got %s\")\n\tval ErrorStringUnclose = Bad(\"String is not closed\")\n\tval ErrorProcNested = Bad(\"Procedures should not be nested\",true)\n\tval ErrorProcUsed = Bad(\"Procedure re-defined %s\")\n\tval ErrorDupParam = Bad(\"Duplicate parameter name %s\",true)\n\tval ErrorEndNothing = Bad(\"Nothing to end\")\n\tval ErrorEndUnclose = Bad(\"Unclosed block (ifeq \/ ifneq \/ ueq \/ proc)\")\n\t\/\/\tTransform Error\n\tval ErrorNoProc = Bad(\"Undefined procedure %s%s\")\n\tval ErrorProcLength = Bad(\"Procedure %s expects %s argument(s) but got %s%s\")\n\tval ErrorRecursive = Bad(\"Recursive call %s\")\n\tval ErrorArgTypeMismatch = Bad(\"Type mismatch\n\" +\n\t\t\"\\ta %s is expected for parameter %s in `%s`\n\" +\n\t\t\"\\tbut argument %s is a %s\")\n\n\tfun _Taste(Q : Int = 0) = Code.getOrNull(CodeAt + Q) ?: '\\u0000'\n\tfun Taste(Q : Int = 0) = Code.getOrNull(CodeAt + Q)?.toString() ?: \"\"\n\tval TasteEOL =\n\t{\n\t\tval R = _Taste()\n\t\tif (0 < R.toInt()) R.toString() else \"EOL\"\n\t}\n\tval Eat = {++CodeAt}\n\tval Save = {LastCol = CodeAt}\n\tval Walk = {Q : Regex -> while (Q.matches(Taste())) Eat()}\n\tval Discard = {CodeAt = Code.length}\n\tval White =\n\t{\n\t\tWalk(Regex(\"\\\\s\"))\n\t\tif ('\/' == _Taste() && '\/' == _Taste(1) ||\n\t\t\t'-' == _Taste() && '-' == _Taste(1) ||\n\t\t\t'#' == _Taste()) Discard()\n\t}\n\tval Word =\n\t{\n\t\tval S = CodeAt\n\t\tSave()\n\t\tif (Regex(\"[^_A-Za-z$]\").matches(Taste())) ErrorNameExpected(TasteEOL())\n\t\tEat()\n\t\tWalk(Regex(\"[\\\\w$]\"))\n\t\tval R = if (S < Code.length) CaseSensetive(Code.substring(S,CodeAt)) else \"\"\n\t\tWhite()\n\t\tR\n\t}\n\tval MakeName = {H : Boolean ->\n\t{\n\t\tval R = Word()\n\t\tif (R.isEmpty()) ErrorNameExpected(TasteEOL())\n\t\tval T = ProcVar?.indexOf(R) ?: -1\n\t\tif (T < 0)\n\t\t{\n\t\t\tif (!Var.containsKey(R)) ErrorVarUndefined(R)\n\t\t\tif (H != Var[R] is Number) if (H) ErrorVarButList(R) else ErrorListButVar(R)\n\t\t}\n\t\telse if (null == ProcVarType!![T]) ProcVarType!![T] = arrayOf(H,Line,1 + LastCol,Code)\n\t\telse if (H != ProcVarType!![T]!![0]) ErrorVarTypeMismatch(arrayOf\n\t\t(\n\t\t\tProcSig,R,\n\t\t\tif (H) \"list\" else \"variable\",\n\t\t\tProcVarType!![T]!![1],\n\t\t\tProcVarType!![T]!![2],\n\t\t\t(ProcVarType!![T]!![3] as String).trim(),\n\t\t\tif (H) \"variable\" else \"list\"\n\t\t))\n\t\tR\n\t}}\n\tval VarName = MakeName(true)\n\tval ListName = MakeName(false)\n\tval RawNumber =\n\t{\n\t\tval S = CodeAt\n\t\tif ('-' == _Taste()) Eat()\n\t\tWalk(Regex(\"\\\\d\"))\n\t\tval R = Code.substring(S,CodeAt)\n\t\tif (R.isEmpty() || \"-\" == R) ErrorNumberExpected(TasteEOL())\n\t\tWhite()\n\t\tR.toInt()\n\t}\n\tval Number = {Clamp(RawNumber())}\n\tval CharEscape = mapOf(\n\t\t'\\\\' to '\\\\',\n\t\t'\"' to '\"',\n\t\t'\\'' to '\\'',\n\t\t'\"' to '\"',\n\t\t'n' to '\n',\n\t\t'r' to '\\r',\n\t\t't' to '\\t')\n\tval Char =\n\t{\n\t\tvar R = _Taste()\n\t\tEat()\n\t\tif ('\\\\' == R)\n\t\t{\n\t\t\tR = _Taste()\n\t\t\tif (!CharEscape.containsKey(R)) ErrorBadEscape(TasteEOL())\n\t\t\tR = CharEscape.getValue(R)\n\t\t\tEat()\n\t\t}\n\t\tR\n\t}\n\tval NumberOrChar =\n\t{\n\t\tif ('\\'' == _Taste())\n\t\t{\n\t\t\tEat()\n\t\t\tval R = Char()\n\t\t\tif ('\\'' != _Taste()) ErrorUnclosed(arrayOf(\"'\",\"'\",TasteEOL()))\n\t\t\tEat()\n\t\t\tWhite()\n\t\t\tR.toInt()\n\t\t}\n\t\telse Number()\n\t}\n\tval VarNameOrNumber = {if (Regex(\"[-\\\\d']\").matches(Taste())) NumberOrChar() else VarName()}\n\tval String =\n\t{\n\t\tvar R = \"\"\n\t\tif ('\"' != _Taste()) ErrorStringExpect(TasteEOL())\n\t\tEat()\n\t\twhile (!Taste().isEmpty() && '\"' != _Taste()) R += Char()\n\t\tif ('\"' != _Taste()) ErrorStringUnclose(null)\n\t\tEat()\n\t\tWhite()\n\t\tR\n\t}\n\tval VarNameOrString = {if ('\"' == _Taste()) 0 to String() else 1 to VarName()}\n\n\tval MsgList = arrayOf(\n\t{\n\t\tval R = mutableListOf<Pair<Int,String>>()\n\t\twhile (!Taste().isEmpty()) R.add(VarNameOrString())\n\t\tR\n\t})\n\n\tval Begin = {ASTStack.add(CurrentAST.size)}\n\tval Machine = mapOf(\n\t\t\"VAR\" to\n\t\t{\n\t\t\tif (null != ProcSig) ErrorDefineInProc(null)\n\t\t\tif (Taste().isEmpty()) ErrorUnEOL(null)\n\t\t\tvar V = Word()\n\t\t\twhile (!V.isEmpty())\n\t\t\t{\n\t\t\t\tif (Var.containsKey(V)) ErrorVarRedeclare(V)\n\t\t\t\tif ('[' == _Taste())\n\t\t\t\t{\n\t\t\t\t\tEat()\n\t\t\t\t\tWhite()\n\t\t\t\t\tval N = RawNumber()\n\t\t\t\t\tif (']' != _Taste()) ErrorUnclosed(arrayOf(\"[\",\"]\",TasteEOL()))\n\t\t\t\t\tEat()\n\t\t\t\t\tWhite()\n\t\t\t\t\tVar[V] = arrayOf(VarAt,N)\n\t\t\t\t\tVarAt += 4 + N\n\t\t\t\t}\n\t\t\t\telse Var[V] = VarAt++\n\t\t\t\tV = Word()\n\t\t\t}\n\t\t},\n\t\t\"SET\" to arrayOf(VarName,VarNameOrNumber),\n\t\t\"INC\" to arrayOf(VarName,VarNameOrNumber),\n\t\t\"DEC\" to arrayOf(VarName,VarNameOrNumber),\n\t\t\"ADD\" to arrayOf(VarNameOrNumber,VarNameOrNumber,VarName),\n\t\t\"SUB\" to arrayOf(VarNameOrNumber,VarNameOrNumber,VarName),\n\t\t\"MUL\" to arrayOf(VarNameOrNumber,VarNameOrNumber,VarName),\n\t\t\"DIVMOD\" to arrayOf(VarNameOrNumber,VarNameOrNumber,VarName,VarName),\n\t\t\"DIV\" to arrayOf(VarNameOrNumber,VarNameOrNumber,VarName),\n\t\t\"MOD\" to arrayOf(VarNameOrNumber,VarNameOrNumber,VarName),\n\n\t\t\"CMP\" to arrayOf(VarNameOrNumber,VarNameOrNumber,VarName),\n\n\t\t\"A2B\" to arrayOf(VarNameOrNumber,VarNameOrNumber,VarNameOrNumber,VarName),\n\t\t\"B2A\" to arrayOf(VarNameOrNumber,VarName,VarName,VarName),\n\n\t\t\"LSET\" to arrayOf(ListName,VarNameOrNumber,VarNameOrNumber),\n\t\t\"LGET\" to arrayOf(ListName,VarNameOrNumber,VarName),\n\n\t\t\"IFEQ\" to arrayOf(VarName,VarNameOrNumber,Begin),\n\t\t\"IFNEQ\" to arrayOf(VarName,VarNameOrNumber,Begin),\n\t\t\"WEQ\" to arrayOf(VarName,VarNameOrNumber,Begin),\n\t\t\"WNEQ\" to arrayOf(VarName,VarNameOrNumber,Begin),\n\t\t\"PROC\" to\n\t\t{\n\t\t\tif (null != ProcSig) ErrorProcNested(null)\n\t\t\tval N = Word()\n\t\t\tif (Proc.containsKey(N)) ErrorProcUsed(N)\n\t\t\tCurrentAST = mutableListOf()\n\t\t\tProcVar = mutableListOf()\n\t\t\tProcVarType = mutableListOf()\n\t\t\tProcSig = Code\n\t\t\tProc[N] = arrayOf(CurrentAST,ProcVar!!,ProcVarType!!,ProcSig!!)\n\t\t\twhile (!Taste().isEmpty())\n\t\t\t{\n\t\t\t\tval T = Word()\n\t\t\t\tif (ProcVar!!.contains(T)) ErrorDupParam(T)\n\t\t\t\tProcVar!!.add(T)\n\t\t\t\tProcVarType!!.add(null)\n\t\t\t}\n\t\t},\n\t\t\"END\" to arrayOf(\n\t\t{\n\t\t\tif (!ASTStack.isEmpty()) ASTStack.pop()\n\t\t\telse if (null == ProcSig) ErrorEndNothing(null)\n\t\t\telse\n\t\t\t{\n\t\t\t\tCurrentAST = AST\n\t\t\t\tProcSig = null\n\t\t\t\tnull\n\t\t\t}\n\t\t}),\n\t\t\"CALL\" to arrayOf(\n\t\t{\n\t\t\tval N = Word()\n\t\t\tval A = mutableListOf<String>()\n\t\t\twhile (!Taste().isEmpty()) A.add(Word())\n\t\t\tlistOf(N,A)\n\t\t}),\n\n\t\t\"READ\" to arrayOf(VarName),\n\t\t\"MSG\" to MsgList,\n\t\t\"LN\" to MsgList,\n\n\t\t\"REM\" to Discard,\n\n\t\t\"DEBUG\" to arrayOf(Discard),\n\t\t\"STOP\" to arrayOf(Discard))\n\n\tval EscapeMap = mapOf(\n\t\t'&' to \"&amp;\",\n\t\t'+' to \"&plus;\",\n\t\t'-' to \"&minus;\",\n\t\t'<' to \"&lt;\",\n\t\t'>' to \"&gt;\",\n\t\t',' to \"&comma;\",\n\t\t'.' to \"&stop;\",\n\t\t'[' to \"&leftsquare;\",\n\t\t']' to \"&rightsquare;\")\n\tval Escape = {Q : String -> Q.replace(Regex(\"[&+\\\\-<>,.\\\\[\\\\]]\")){EscapeMap.getValue(it.value[0])}}\n\n\tval OpGotoCell = {Q : Int ->\n\t\tOutput += if (Q < StackAt) \"<\".repeat(StackAt - Q)\n\t\t\telse \">\".repeat(Q - StackAt)\n\t\tStackAt = Q\n\t}\n\tval OpAdd = {Q : Int ->\n\t\tval S = Clamp(Q)\n\t\tOutput += if (128 < S) \"-\".repeat(256 - S) else \"+\".repeat(S)\n\t}\n\tval OpSolvePreserve = {Q : Int ->\n\t\tif (PreserveMax < Q) PreserveMax = Q\n\t\tPreserve - Q\n\t}\n\tval OpFly = {Q : Int -> StackAt = OpSolvePreserve(Q)}\n\tval OpGotoPreserve = {Q : Int -> OpGotoCell(OpSolvePreserve(Q))}\n\tval OpGetPreserve = {Q : Int -> Stack[OpSolvePreserve(Q)]}\n\tval OpSetPreserve = {Q : Int,S : Int -> Stack[OpSolvePreserve(Q)] = S}\n\tval OpModifyPreserve = {Q : Int,S : Int ->\n\t\tOpGotoPreserve(Q)\n\t\tOpAdd(S - OpGetPreserve(Q))\n\t\tOpSetPreserve(Q,S)\n\t}\n\tfun OpClearPreserve(Q : Int,J : Boolean = false)\n\t{\n\t\tif (J || 0 != OpGetPreserve(Q))\n\t\t{\n\t\t\tOpGotoPreserve(Q)\n\t\t\tOutput += \"[-]\"\n\t\t\tOpSetPreserve(Q,0)\n\t\t}\n\t}\n\tval OpMsgList = {Q : String ->\n\t\tfor (T in Q)\n\t\t{\n\t\t\tOpModifyPreserve(0,T.toInt())\n\t\t\tOutput += '.'\n\t\t}\n\t}\n\n\tfun Generate\n\t(\n\t\tAST : MutableList<Array<Any>>,\n\t\tCallArg : MutableMap<String,String> = mutableMapOf(),\n\t\tCallStack : java.util.Stack<String> = java.util.Stack(),\n\t\tCallStackMessage : String = \"\",\n\t\t_CurrentIndent : String = \"\"\n\t){\n\t\tvar CurrentIndent = _CurrentIndent\n\n\t\tval OpSolveVar = {Q : String -> CallArg[Q] ?: Q}\n\t\tfun OpGoto(Q : Any,S : Int = 0)\n\t\t{\n\t\t\tif (Q is Int)\n\t\t\t{\n\t\t\t\tif (Q < 0) OpGotoCell(-Q)\n\t\t\t\telse OpGotoPreserve(Q)\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tval T = Var[OpSolveVar(Q as String)]\n\t\t\t\tif (T is Int) OpGotoCell(T)\n\t\t\t\telse OpGotoCell(S + (T as Array<Int>)[0])\n\t\t\t}\n\t\t}\n\t\tfun OpClear(Q : Any,J : Boolean = false)\n\t\t{\n\t\t\twhen (Q)\n\t\t\t{\n\t\t\t\tis Int -> OpClearPreserve(Q,J)\n\t\t\t\tis Array<*> -> Q.forEach{OpClear(it!!,J)}\n\t\t\t\telse ->\n\t\t\t\t{\n\t\t\t\t\tOpGoto(Q)\n\t\t\t\t\tOutput += \"[-]\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfun OpBegin(Q : Any,S : Int = 0)\n\t\t{\n\t\t\tOpGoto(Q,S)\n\t\t\tOutput += \"[-\"\n\t\t}\n\t\tfun OpEnd(Q : Any,S : Int = 0)\n\t\t{\n\t\t\tOpGoto(Q,S)\n\t\t\tOutput += \"]\"\n\t\t}\n\t\tfun OpMove(Q : Any,S : Any,I : Int = 0)\n\t\t{\n\t\t\tOpBegin(Q,I)\n\t\t\tif (S is Array<*>) S.forEach{\n\t\t\t\tOpGoto(it!!)\n\t\t\t\tOutput += '+'\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tOpGoto(S)\n\t\t\t\tOutput += '+'\n\t\t\t}\n\t\t\tOpEnd(Q,I)\n\t\t}\n\t\tfun OpMoveReverse(Q : Any,S : Any,I : Int = 0)\n\t\t{\n\t\t\tOpBegin(Q,I)\n\t\t\tif (S is Array<*>) S.forEach{\n\t\t\t\tOpGoto(it!!)\n\t\t\t\tOutput += '-'\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tOpGoto(S)\n\t\t\t\tOutput += '-'\n\t\t\t}\n\t\t\tOpEnd(Q,I)\n\t\t}\n\t\tfun OpCopy(Q : Any,S : Any,T : Any,J : Boolean = true)\n\t\t{\n\t\t\tif (J) OpClear(T)\n\t\t\tOpMove(Q,if (S is Array<*>) arrayOf(*S,T) else arrayOf(S,T))\n\t\t\tOpMove(T,Q)\n\t\t}\n\t\tval OpPrepare = {Q : Any,S : Any,T : Any ->\n\t\t\tOpClear(S)\n\t\t\tif (Q is Int)\n\t\t\t{\n\t\t\t\tif (S is Array<*>)\n\t\t\t\t{\n\t\t\t\t\tOpGoto(T)\n\t\t\t\t\tOpAdd(Q)\n\t\t\t\t\tOpMove(T,S)\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tOpGoto(S)\n\t\t\t\t\tOpAdd(Q)\n\t\t\t\t}\n\t\t\t}\n\t\t\telse OpCopy(Q,S,T)\n\t\t}\n\t\tfun OpPrepare01(Q : List<*>,W : Any = 0,A : Any = 1,T : Int = 2)\n\t\t{\n\t\t\tOpPrepare(Q[0]!!,W,T)\n\t\t\tOpPrepare(Q[1]!!,A,T)\n\t\t}\n\t\tval OpSet = {Q : Any,S : Any ->\n\t\t\tOpClear(Q)\n\t\t\tOpMove(S,Q)\n\t\t}\n\t\tval OpDivMod = {Arg : List<*> ->\n\t\t\tOpPrepare01(Arg,5,4,0)\n\t\t\tOpCopy(4,8,7)\n\t\t\tOpGoto(7)\n\t\t\tOutput += \"+<-\" +\n\t\t\t\t\"[>>>[->-[>+>>]>[+[-<+>]>+>>]<<<<<]<<-]>\" +\n\t\t\t\t\"[->>[->>>+<<<]<]\"\n\t\t\tOpFly(6)\n\t\t\tOpClear(8,true)\n\t\t\tOpClear(4,true)\n\t\t\tif (null != Arg[2]) OpSet(Arg[2]!!,2) else OpClear(2,true)\n\t\t\tif (3 < Arg.size) OpSet(Arg[3]!!,3) else OpClear(3,true)\n\t\t}\n\t\tfun OpIFWhile(Arg : List<*>,Not : Boolean = false)\n\t\t{\n\t\t\tif (Arg[1] is Int)\n\t\t\t{\n\t\t\t\tOpClear(0)\n\t\t\t\tOpCopy(Arg[0]!!,0,1)\n\t\t\t\tOpGoto(0)\n\t\t\t\tOpAdd(-(Arg[1] as Int))\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tOpPrepare01(Arg)\n\t\t\t\tOpMoveReverse(1,0)\n\t\t\t}\n\t\t\tif (Not)\n\t\t\t{\n\t\t\t\tOpGoto(1)\n\t\t\t\tOutput += \"+>[[-]<-]<[>+<-<]\"\n\t\t\t\tOpFly(2)\n\t\t\t}\n\t\t\tOpGoto(0)\n\t\t}\n\n\t\tAST.forEach{\n\t\t\tvar Command = it[0] as String\n\t\t\tvar Arg = it[1] as List<*>\n\t\t\tval Line = it[2]\n\t\t\tval CurrentCode = it[3] as String\n\t\t\tvar NeedNewLine = true\n\t\t\tvar NeedIndent = false\n\t\t\tCode = CurrentCode\n\t\t\tif (Origin)\n\t\t\t{\n\t\t\t\tif (\"END\" == Command) CurrentIndent = CurrentIndent.substring(Indent.length)\n\t\t\t\tOutput += CurrentIndent + Escape(Code) + '\n'\n\t\t\t\tif (\"END\" != Command || null != Arg[0]) Output += CurrentIndent\n\t\t\t}\n\t\t\twhen (Command)\n\t\t\t{\n\t\t\t\t\"SET\" ->\n\t\t\t\t{\n\t\t\t\t\tOpGoto(Arg[0]!!)\n\t\t\t\t\tOutput += \"[-]\"\n\t\t\t\t\tif (Arg[1] is Int)\n\t\t\t\t\t\tOpAdd(Arg[1] as Int)\n\t\t\t\t\telse\n\t\t\t\t\t\tOpCopy(Arg[1]!!,Arg[0]!!,0)\n\t\t\t\t}\n\t\t\t\t\"INC\" ->\n\t\t\t\t{\n\t\t\t\t\twhen\n\t\t\t\t\t{\n\t\t\t\t\t\tArg[1] is Int ->\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tOpGoto(Arg[0]!!)\n\t\t\t\t\t\t\tOpAdd(Arg[1] as Int)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tOpSolveVar(Arg[0] as String) == OpSolveVar(Arg[1] as String) ->\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tOpClear(0)\n\t\t\t\t\t\t\tOpMove(Arg[0]!!,0)\n\t\t\t\t\t\t\tOpBegin(0)\n\t\t\t\t\t\t\tOpGoto(Arg[0]!!)\n\t\t\t\t\t\t\tOutput += \"++\"\n\t\t\t\t\t\t\tOpEnd(0)\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse -> OpCopy(Arg[1]!!,Arg[0]!!,0)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\"DEC\" ->\n\t\t\t\t{\n\t\t\t\t\tif (Arg[1] is Int)\n\t\t\t\t\t{\n\t\t\t\t\t\tOpGoto(Arg[0]!!)\n\t\t\t\t\t\tOpAdd(-(Arg[1] as Int))\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tOpCopy(Arg[1]!!,0,1)\n\t\t\t\t\t\tOpMoveReverse(0,Arg[0]!!)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\"ADD\" ->\n\t\t\t\t{\n\t\t\t\t\tOpPrepare01(Arg)\n\t\t\t\t\tOpMove(1,0)\n\t\t\t\t\tOpSet(Arg[2]!!,0)\n\t\t\t\t}\n\t\t\t\t\"SUB\" ->\n\t\t\t\t{\n\t\t\t\t\tOpPrepare01(Arg)\n\t\t\t\t\tOpMoveReverse(1,0)\n\t\t\t\t\tOpSet(Arg[2]!!,0)\n\t\t\t\t}\n\t\t\t\t\"MUL\" ->\n\t\t\t\t{\n\t\t\t\t\tOpPrepare01(Arg)\n\t\t\t\t\tOpBegin(0)\n\t\t\t\t\tOpCopy(1,2,3)\n\t\t\t\t\tOpEnd(0)\n\t\t\t\t\tOpClear(1,true)\n\t\t\t\t\tOpSet(Arg[2]!!,2)\n\t\t\t\t}\n\t\t\t\t\"DIVMOD\",\"DIV\" -> OpDivMod(Arg)\n\t\t\t\t\"MOD\" -> OpDivMod(listOf(Arg[0],Arg[1],null,Arg[2]))\n\t\t\t\t\"CMP\" ->\n\t\t\t\t{\n\t\t\t\t\tval X = 4\n\t\t\t\t\tval T0 = 3\n\t\t\t\t\tval T1 = 2\n\t\t\t\t\tOpPrepare01(Arg,arrayOf(T0,X),arrayOf(T1,1 + X),0)\n\t\t\t\t\tOpMoveReverse(1 + X,X)\n\n\t\t\t\t\tOpGoto(1 + X)\n\t\t\t\t\tOutput += \"+>[[-]\"\n\t\t\t\t\tOpFly(X)\n\n\t\t\t\t\tOpGoto(T1 - 1)\n\t\t\t\t\tOutput += \"+<[>-]>[\"\n\t\t\t\t\tOpFly(T1 - 1)\n\t\t\t\t\tOpGoto(X)\n\t\t\t\t\tOutput += '+'\n\t\t\t\t\tOpGoto(T0)\n\t\t\t\t\tOutput += \"[-]\"\n\t\t\t\t\tOpGoto(T1 - 1)\n\t\t\t\t\tOutput += \"->]<+\"\n\t\t\t\t\tOpGoto(T0)\n\t\t\t\t\tOutput += '['\n\t\t\t\t\tOpGoto(T1)\n\t\t\t\t\tOutput += \"-[>-]>[\"\n\t\t\t\t\tOpFly(T1 - 1)\n\t\t\t\t\tOpGoto(X)\n\t\t\t\t\tOutput += '+'\n\t\t\t\t\tOpGoto(T0)\n\t\t\t\t\tOutput += \"[-]+\"\n\t\t\t\t\tOpGoto(T1 - 1)\n\t\t\t\t\tOutput += \"->]<+\"\n\t\t\t\t\tOpGoto(T0)\n\t\t\t\t\tOutput += \"-]\"\n\n\t\t\t\t\tOpGoto(X)\n\t\t\t\t\tOutput += \"[<-]<[>-<-<]\"\n\t\t\t\t\tOpFly(2 + X)\n\n\t\t\t\t\tOpGoto(1 + X)\n\t\t\t\t\tOutput += \"]<[-<]>\"\n\n\t\t\t\t\tOpClear(3,true)\n\t\t\t\t\tOpClear(2,true)\n\t\t\t\t\tOpClear(1,true)\n\n\t\t\t\t\tOpSet(Arg[2]!!,X)\n\t\t\t\t}\n\t\t\t\t\"A2B\" ->\n\t\t\t\t{\n\t\t\t\t\tval (A,B,C,R) = Arg\n\t\t\t\t\tif (A is Int)\n\t\t\t\t\t{\n\t\t\t\t\t\tval a = Clamp(10 * (A - 48))\n\t\t\t\t\t\tif (0 < a)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tOpGoto(1)\n\t\t\t\t\t\t\tOpAdd(a)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tOpCopy(A!!,2,0)\n\t\t\t\t\t\tOpGoto(2)\n\t\t\t\t\t\tOpAdd(-48)\n\t\t\t\t\t\tOpBegin(2)\n\t\t\t\t\t\tOpGoto(1)\n\t\t\t\t\t\tOpAdd(10)\n\t\t\t\t\t\tOpEnd(2)\n\t\t\t\t\t}\n\t\t\t\t\tif (B is Int)\n\t\t\t\t\t{\n\t\t\t\t\t\tOpGoto(1)\n\t\t\t\t\t\tOpAdd(B - 48)\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tOpCopy(B!!,1,0)\n\t\t\t\t\t\tOpGoto(1)\n\t\t\t\t\t\tOpAdd(-48)\n\t\t\t\t\t}\n\t\t\t\t\tOpBegin(1)\n\t\t\t\t\tOpGoto(0)\n\t\t\t\t\tOpAdd(10)\n\t\t\t\t\tOpEnd(1)\n\t\t\t\t\tif (C is Int)\n\t\t\t\t\t{\n\t\t\t\t\t\tOpGoto(0)\n\t\t\t\t\t\tOpAdd(C - 48)\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tOpCopy(C!!,0,1)\n\t\t\t\t\t\tOpGoto(0)\n\t\t\t\t\t\tOpAdd(-48)\n\t\t\t\t\t}\n\t\t\t\t\tOpSet(R!!,0)\n\t\t\t\t}\n\t\t\t\t\"B2A\" ->\n\t\t\t\t{\n\t\t\t\t\tval (R,A,B,C) = Arg\n\t\t\t\t\tif (R is Int)\n\t\t\t\t\t{\n\t\t\t\t\t\tOpClear(A!!)\n\t\t\t\t\t\tOpAdd(R \/ 100)\n\t\t\t\t\t\tOpClear(B!!)\n\t\t\t\t\t\tOpAdd(R \/ 10 % 10)\n\t\t\t\t\t\tOpClear(C!!)\n\t\t\t\t\t\tOpAdd(R % 10)\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tOpDivMod(listOf(R,10,B,C))\n\t\t\t\t\t\tOpDivMod(listOf(B,10,A,B))\n\t\t\t\t\t}\n\t\t\t\t\tOpGoto(0)\n\t\t\t\t\tOpAdd(48)\n\t\t\t\t\tOpMove(0,arrayOf(Arg[1],Arg[2],Arg[3]))\n\t\t\t\t}\n\t\t\t\t\"LSET\" ->\n\t\t\t\t{\n\t\t\t\t\tif (Arg[1] is Int)\n\t\t\t\t\t{\n\t\t\t\t\t\tOpGoto(Arg[0]!!)\n\t\t\t\t\t\tOpAdd(Arg[1] as Int)\n\t\t\t\t\t\tOutput += \"[->+>+<<]\"\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tOpCopy(Arg[1]!!,arrayOf(-1 - (Var[OpSolveVar(Arg[0] as String)] as Array<Int>)[0],\n\t\t\t\t\t\t\t-2 - (Var[OpSolveVar(Arg[0] as String)] as Array<Int>)[0]),Arg[0]!!,false)\n\t\t\t\t\tif (Arg[2] is Int)\n\t\t\t\t\t{\n\t\t\t\t\t\tOpGoto(Arg[0]!!,3)\n\t\t\t\t\t\tOpAdd(Arg[2] as Int)\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tOpCopy(Arg[2]!!,-3 - (Var[OpSolveVar(Arg[0] as String)] as Array<Int>)[0],Arg[0]!!,false)\n\t\t\t\t\tOpGoto(Arg[0]!!)\n\t\t\t\t\tOutput += \">[>>>[-<<<<+>>>>]<[->+<]<[->+<]<[->+<]>-]\" +\n\t\t\t\t\t\t\">>>[-]<[->+<]<\" +\n\t\t\t\t\t\t\"[[-<+>]<<<[->>>>+<<<<]>>-]<<\"\n\t\t\t\t}\n\t\t\t\t\"LGET\" ->\n\t\t\t\t{\n\t\t\t\t\tif (Arg[1] is Int)\n\t\t\t\t\t{\n\t\t\t\t\t\tOpGoto(Arg[0]!!)\n\t\t\t\t\t\tOpAdd(Arg[1] as Int)\n\t\t\t\t\t\tOutput += \"[->+>+<<]\"\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tOpCopy(Arg[1]!!,arrayOf(-1 - (Var[OpSolveVar(Arg[0] as String)] as Array<Int>)[0],\n\t\t\t\t\t\t\t-2 - (Var[OpSolveVar(Arg[0] as String)] as Array<Int>)[0]),Arg[0]!!,false)\n\t\t\t\t\tOpGoto(Arg[0]!!)\n\t\t\t\t\tOutput += \">[>>>[-<<<<+>>>>]<<[->+<]<[->+<]>-]\" +\n\t\t\t\t\t\t\">>>[-<+<<+>>>]<<<[->>>+<<<]>\" +\n\t\t\t\t\t\t\"[[-<+>]>[-<+>]<<<<[->>>>+<<<<]>>-]<<\"\n\t\t\t\t\tOpClear(Arg[2]!!)\n\t\t\t\t\tOpMove(Arg[0]!!,Arg[2]!!,3)\n\t\t\t\t}\n\t\t\t\t\"IFEQ\",\"WEQ\" ->\n\t\t\t\t{\n\t\t\t\t\tOpIFWhile(Arg,true)\n\t\t\t\t\tOutput += '['\n\t\t\t\t\tOpClear(0,true)\n\t\t\t\t\tNeedIndent = true\n\t\t\t\t}\n\t\t\t\t\"IFNEQ\" ->\n\t\t\t\t{\n\t\t\t\t\tOpIFWhile(Arg)\n\t\t\t\t\tOutput += '['\n\t\t\t\t\tOpClear(0,true)\n\t\t\t\t\tNeedIndent = true\n\t\t\t\t}\n\t\t\t\t\"WNEQ\" ->\n\t\t\t\t{\n\t\t\t\t\tif (0 != Arg[1])\n\t\t\t\t\t{\n\t\t\t\t\t\tOpIFWhile(Arg)\n\t\t\t\t\t\tOutput += '['\n\t\t\t\t\t\tOpClear(0,true)\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tOpGoto(Arg[0]!!)\n\t\t\t\t\t\tOutput += '['\n\t\t\t\t\t}\n\t\t\t\t\tNeedIndent = true\n\t\t\t\t}\n\t\t\t\t\"END\" ->\n\t\t\t\t{\n\t\t\t\t\tif (null != Arg[0])\n\t\t\t\t\t{\n\t\t\t\t\t\tCommand = AST[Arg[0] as Int][0] as String\n\t\t\t\t\t\tArg = AST[Arg[0] as Int][1] as List<*>\n\t\t\t\t\t\tif (\"WEQ\" == Command)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tOpIFWhile(Arg,true)\n\t\t\t\t\t\t\tOpGoto(0)\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (\"WNEQ\" == Command)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (0 != Arg[1])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tOpIFWhile(Arg)\n\t\t\t\t\t\t\t\tOpGoto(0)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse OpGoto(Arg[0]!!)\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tOpClear(0)\n\t\t\t\t\t\t\tOpGoto(0)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tOutput += ']'\n\t\t\t\t\t}\n\t\t\t\t\telse NeedNewLine = false\n\t\t\t\t}\n\t\t\t\t\"CALL\" ->\n\t\t\t\t{\n\t\t\t\t\tArg = Arg[0] as List<*>\n\t\t\t\t\tval Arg0 = Arg[0] as String\n\t\t\t\t\tval Arg1 = Arg[1] as MutableList<String>\n\t\t\t\t\tval NextMessage = \"$CallStackMessage\n\\tat line $Line, procedure $Arg0\"\n\t\t\t\t\tif (!Proc.containsKey(Arg0)) ErrorNoProc(arrayOf(Arg0,NextMessage))\n\t\t\t\t\tval T = Proc[Arg0]!!\n\t\t\t\t\tProcVar = T[1] as MutableList<String>\n\t\t\t\t\tProcVarType = T[2] as MutableList<Array<Any>?>\n\t\t\t\t\tProcSig = T[3] as String\n\t\t\t\t\tif (ProcVar!!.size != Arg1.size)\n\t\t\t\t\t\tErrorProcLength(arrayOf(Arg0,ProcVar!![0].length,Arg1.size,NextMessage))\n\t\t\t\t\tif (CallStack.contains(Arg0)) ErrorRecursive(NextMessage)\n\t\t\t\t\tCallStack.add(Arg0)\n\t\t\t\t\tif (Origin) Output += Escape(ProcSig!!) + '\n'\n\t\t\t\t\tval D = mutableMapOf<String,String>()\n\t\t\t\t\tProcVar!!.forEachIndexed{F,V ->\n\t\t\t\t\t\tD[V] = OpSolveVar(Arg1[F])\n\t\t\t\t\t\tif (null != ProcVarType!![F])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tval T = ProcVarType!![F]!![0] as Boolean\n\t\t\t\t\t\t\tif (T != (Var[D[V]] is Int))\n\t\t\t\t\t\t\tErrorArgTypeMismatch(arrayOf\n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\tif (T) \"variable\" else \"list\",\n\t\t\t\t\t\t\t\tV,\n\t\t\t\t\t\t\t\tProcSig,\n\t\t\t\t\t\t\t\tArg1[F],\n\t\t\t\t\t\t\t\tif (T) \"list\" else \"variable\"\n\t\t\t\t\t\t\t))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tGenerate(Proc[Arg0]!![0] as MutableList<Array<Any>>,D,CallStack,NextMessage,CurrentIndent + Indent)\n\t\t\t\t\tNeedNewLine = false\n\t\t\t\t\tCallStack.pop()\n\t\t\t\t}\n\t\t\t\t\"READ\" ->\n\t\t\t\t{\n\t\t\t\t\tOpGoto(Arg[0]!!)\n\t\t\t\t\tOutput += ','\n\t\t\t\t}\n\t\t\t\t\"MSG\",\"LN\" ->\n\t\t\t\t{\n\t\t\t\t\t(Arg[0] as MutableList<Pair<Int,String>>).forEach{(Type,Value) ->\n\t\t\t\t\t\tif (0 == Type) OpMsgList(Value)\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tOpGoto(Value)\n\t\t\t\t\t\t\tOutput += '.'\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (\"LN\" == Command) OpMsgList(\"\n\")\n\t\t\t\t}\n\t\t\t\t\"DEBUG\" -> Output += '_'\n\t\t\t\t\"STOP\" -> Output += '!'\n\t\t\t}\n\t\t\tif (Origin)\n\t\t\t{\n\t\t\t\tif (NeedNewLine) Output += '\n'\n\t\t\t\tif (NeedIndent) CurrentIndent += Indent\n\t\t\t}\n\t\t}\n\t}\n\n\tRawCode.split('\n').forEach{V ->\n\t\t++Line\n\t\tCode = V\n\t\tCodeAt = 0\n\t\tWhite()\n\t\tif (!Taste().isEmpty())\n\t\t{\n\t\t\tval W = Word()\n\t\t\tif (!Machine.containsKey(W)) ErrorCommand(W)\n\t\t\tif (Machine[W] is Array<*>)\n\t\t\t\tCurrentAST.add(arrayOf(W,(Machine[W] as Array<() -> Any>).map{it()},Line,Code.trim()))\n\t\t\telse (Machine[W] as () -> Any)()\n\t\t\tif (!Taste().isEmpty()) ErrorCommandEnd(Taste())\n\t\t\tif (Origin && \"VAR\" == W) Output += Code.trim() + '\n'\n\t\t}\n\t}\n\tif (0 < ASTStack.size) ErrorEndUnclose(null)\n\n\tGenerate(AST)\n\treturn if (Origin) \"Preserved $PreserveMax\n$Output\" else Output.substring(Preserve - PreserveMax)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208830,"user_id":1246,"body":"import java.lang.AssertionError\nimport java.lang.Exception\nimport kotlin.math.sign\nimport kotlin.system.measureTimeMillis\n\ntypealias Generator = (Int) -> String\n\ninline fun bfAssert(test: Boolean, lazyMessage: () -> Any) {\n    if(!test) throw AssertionError(lazyMessage())\n}\n\nfun bfAssert(test: Boolean) {\n    bfAssert(test) { \"Assertion failed\"}\n}\n\nenum class Token(val symbol: String){\n    VAR(\"var\"), SET(\"set\"), INC(\"inc\"), DEC(\"dec\"), ADD(\"add\"),\n    SUB(\"sub\"), MUL(\"mul\"), DIVMOD(\"divmod\"), DIV(\"div\"),\n    MOD(\"mod\"), CMP(\"cmp\"), A2B(\"a2b\"), B2A(\"b2a\"), LSET(\"lset\"),\n    LGET(\"lget\"), IFEQ(\"ifeq\"), IFNEQ(\"ifneq\"), WNEQ(\"wneq\"),\n    PROC(\"proc\"), END(\"end\"), CALL(\"call\"),\n    READ(\"read\"), MSG(\"msg\")\n}\n\nopen class Operand()\nopen class VarOperand(_name : String) : Operand() {\n    val varName = _name.toUpperCase()\n    override fun equals(other: Any?): Boolean =\n        other is VarOperand && other.varName == varName\n    override fun toString(): String = varName\n    override fun hashCode() = varName.hashCode()\n}\n\nclass ListOperand(varName: String, val size: Int) : VarOperand(varName) {}\nclass StringOperand(private val strValue : String) : Operand() {\n    override fun toString()= \"\\\"$strValue\\\"\"\n\n    fun content() = strValue.drop(1).dropLast(1)\n}\nclass ConstOperand(private val intValue : Int) : Operand() {\n    fun content() : Int {\n        if(intValue in 0..255) return intValue\n        if(intValue < 0) return (intValue % 256) + 256\n        return intValue % 256\n    }\n}\nclass Statement(val name: Token, val operands : Array<Operand>)\n\nclass Parser(private val tokens : MutableList<String>) {\n\n    fun getStatements(): Array<Statement>{\n        val result = mutableListOf<Statement>()\n        while(tokens.isNotEmpty()){\n            result.add(parseStatement())\n        }\n        return result.toTypedArray()\n    }\n\n    private fun parseStatement(): Statement = when(current().toLowerCase()) {\n        \"var\" -> parseVarCreation()\n        \"set\" -> parseSet()\n        \"inc\" -> parseInc()\n        \"dec\" -> parseDec()\n        \"add\" -> parseAdd()\n        \"sub\" -> parseSub()\n        \"mul\" -> parseMul()\n        \"divmod\" -> parseDivMod()\n        \"div\" -> parseDiv()\n        \"mod\" -> parseMod()\n        \"cmp\" -> parseCmp()\n        \"a2b\"-> parseA2B()\n        \"b2a\" -> parseB2A()\n        \"lset\" -> parseLSet()\n        \"lget\" -> parseLGet()\n        \"ifeq\" -> parseIfEq()\n        \"ifneq\" -> parseIfNEq()\n        \"wneq\" -> parseWneq()\n        \"proc\" -> parseProc()\n        \"end\" -> parseEnd()\n        \"call\" -> parseCall()\n        \"read\" -> parseRead()\n        \"msg\" -> parseMsg()\n        else -> throw Exception(\"Unknown command '${current()}'\")\n    }\n\n    private fun skip() = when(tokens.size){\n        0 -> throw  Exception()\n        else -> tokens.removeAt(0)\n    }\n\n    private fun current() = when(tokens.size){\n        0 -> throw Exception(\"No more tokens\")\n        else -> tokens[0]\n    }\n\n    private fun currentIs(tk: String) = tokens.size > 0 && current() == tk\n\n    private fun currentMatch(tx: Regex) = current().matches(tx)\n\n    private fun isEnd() = tokens.isEmpty() || currentIs(\"\n\")\n\n    private fun mustEnd() = when{\n        tokens.isEmpty() -> \"\"\n        currentIs(\"\n\") -> skip()\n        else -> throw  Exception(\"Expected EOL\/EOF, found '${current()}'\")\n    }\n\n    private fun mustBe(str: String) = when(current().toLowerCase()) {\n        str.toLowerCase() -> skip()\n        else -> throw Exception(\"Expected '$str' instead go '${tokens[0]}'\")\n    }\n\n    private fun mustBe(tk : Token) =  mustBe(tk.symbol)\n\n    private fun parseVarDeclaration(): VarOperand {\n        val name = parseVarName().varName\n        if(currentIs(\"[\")){\n            skip()\n            bfAssert(currentMatch(\"\"\"^\\d+$\"\"\".toRegex())) {\"Expected number, got '${current()}'\"}\n            val size = skip().toInt()\n            mustBe(\"]\")\n            return ListOperand(name, size)\n        }\n        return VarOperand(name)\n    }\n\n    private fun parseVarName() = when(currentMatch(\"\"\"^[a-zA-Z_$]+(\\w|\\$)*$\"\"\".toRegex())){\n        true -> VarOperand(skip())\n        else -> throw  Exception(\"Invalid var name '${current()}'\")\n    }\n\n    private fun parseVarOrString() = when {\n        current().startsWith(\"\\\"\") && current().endsWith(\"\\\"\") -> StringOperand(skip())\n        else -> parseVarName()\n    }\n\n    private fun parseVarOrNumber() = when{\n        currentMatch(\"^'.'$\".toRegex()) -> ConstOperand(skip()[1].toInt())\n        currentMatch(\"^-?\\\\d+$\".toRegex()) -> ConstOperand(skip().toInt())\n        else -> parseVarName()\n    }\n\n    private fun valNumberStatement(prefix: Token) : Statement {\n        mustBe(prefix)\n        val target = parseVarName()\n        val apply = parseVarOrNumber()\n        mustEnd()\n        return Statement(prefix, arrayOf(target, apply))\n    }\n\n    private fun doubleValStatement(prefix: Token) : Statement {\n        mustBe(prefix)\n        val firstOp = parseVarOrNumber()\n        val secondOp = parseVarOrNumber()\n        val targetVar = parseVarName()\n        mustEnd()\n        return Statement(prefix, arrayOf(firstOp, secondOp, targetVar))\n    }\n\n    private fun parseSet() = valNumberStatement(Token.SET)\n    private fun parseInc() = valNumberStatement(Token.INC)\n    private fun parseDec() = valNumberStatement( Token.DEC)\n    private fun parseIfEq() = valNumberStatement(Token.IFEQ)\n    private fun parseIfNEq() = valNumberStatement(Token.IFNEQ)\n    private fun parseWneq() = valNumberStatement(Token.WNEQ)\n    private fun parseAdd() = doubleValStatement(Token.ADD)\n    private fun parseSub() = doubleValStatement(Token.SUB)\n    private fun parseMul() = doubleValStatement(Token.MUL)\n    private fun parseDiv() = doubleValStatement(Token.DIV)\n    private fun parseMod() = doubleValStatement(Token.MOD)\n    private fun parseCmp() = doubleValStatement(Token.CMP)\n\n    private fun parseDivMod(): Statement {\n        mustBe(Token.DIVMOD)\n        val firstOp = parseVarOrNumber()\n        val secondOd = parseVarOrNumber()\n        val firstVar = parseVarName()\n        val sndVar = parseVarName()\n        mustEnd()\n        return Statement(Token.DIVMOD, arrayOf(firstOp, secondOd, firstVar, sndVar))\n    }\n\n    private fun parseVarCreation(): Statement{\n        mustBe(Token.VAR)\n        val operands = mutableListOf<VarOperand>()\n        while(!isEnd()){\n            operands.add(parseVarDeclaration())\n        }\n        mustEnd()\n        return Statement(Token.VAR, operands.toTypedArray())\n    }\n\n    private fun parseA2B(): Statement {\n        mustBe(Token.A2B)\n        val toDec = 1.rangeTo(3).map { parseVarOrNumber() }.toTypedArray()\n        val target = parseVarName()\n        mustEnd()\n        return Statement(Token.A2B, arrayOf(*toDec, target))\n    }\n\n    private fun parseB2A(): Statement {\n        mustBe(Token.B2A)\n        val toDec = parseVarOrNumber()\n        val targets = 1.rangeTo(3).map { parseVarName() }.toTypedArray()\n        mustEnd()\n        return Statement(Token.B2A, arrayOf(toDec, *targets))\n    }\n\n    private fun parseLSet(): Statement {\n        mustBe(Token.LSET)\n        val listName = parseVarName()\n        val index = parseVarOrNumber()\n        val value = parseVarOrNumber()\n        mustEnd()\n        return Statement(Token.LSET, arrayOf(listName, index, value))\n    }\n\n    private fun parseLGet(): Statement {\n        mustBe(Token.LGET)\n        val listName = parseVarName()\n        val index = parseVarOrNumber()\n        val target = parseVarName()\n        mustEnd()\n        return Statement(Token.LGET, arrayOf(listName, index, target))\n    }\n\n    private fun parseArgs(prefix: Token): Statement {\n        mustBe(prefix)\n        val varName = mutableListOf<Operand>()\n        while(!isEnd()){\n            varName.add(parseVarName())\n        }\n        mustEnd()\n        return Statement(prefix, varName.toTypedArray())\n    }\n\n    private fun parseProc() = parseArgs(Token.PROC)\n    private fun parseCall() = parseArgs(Token.CALL)\n\n    private fun parseEnd(): Statement {\n        mustBe(\"end\")\n        mustEnd()\n        return Statement(Token.END, arrayOf())\n    }\n\n    private fun parseRead(): Statement {\n        mustBe(\"read\")\n        val target = parseVarName()\n        mustEnd()\n        return Statement(Token.READ, arrayOf(target))\n    }\n\n    private fun parseMsg(): Statement{\n        mustBe(\"msg\")\n        val target = mutableListOf<Operand>()\n        while(!isEnd()){\n            target.add(parseVarOrString())\n        }\n        mustEnd()\n        return Statement(Token.MSG, target.toTypedArray())\n    }\n}\n\nclass Procedure(_name: String, val variables : Array<String>, val code : Array<Instruction>) {\n    val name = _name.toUpperCase()\n    override fun equals(other: Any?) =\n        other is Procedure && other.name == name\n    override fun hashCode() = name.hashCode()\n}\n\nopen class Instruction(val type: Token, val operands : Array<Operand>)\n\nclass CondInstruction(type: Token,\n                      operands: Array<Operand>,\n                      val instrs : Array<Instruction>) : Instruction(type, operands)\n\n\nclass StackCount {\n    private var index = 0\n\n    fun get() = index\n\n    fun push(incr : Int = 1) : Int{\n        val res = index\n        index += incr\n        return res\n    }\n\n    fun pop(decr : Int = 1) : String {\n        index -= decr\n        return \"\"\n    }\n}\n\nclass CallStack {\n    private var stack = mutableListOf<Procedure>()\n    private val variablesIndex = mutableListOf<MutableMap<String, Pair<VarOperand, Int>>>(mutableMapOf())\n\n    private fun varNames() = variablesIndex.last()\n\n    fun varIdx(varName : VarOperand) = varNames()[varName.varName]!!.second\n\n    fun varNameExists(varname: VarOperand) = varNames().containsKey(varname.varName)\n\n    fun isListVar(op: Operand) : Boolean {\n        if(op is ConstOperand) return false\n        val varName = op as VarOperand\n        bfAssert(varNameExists(varName))\n        val operand = varNames()[op.varName]!!.first\n        return (operand is ListOperand)\n    }\n\n    fun setVarIdx(varName : VarOperand, index : Int) {\n        bfAssert(isRoot()) { \"Can only declare variables at the root\" }\n        varNames()[varName.varName] = Pair(varName, index)\n    }\n\n    fun push(proc : Procedure, varName : List<VarOperand>) {\n        if(stack.contains(proc)) throw  Exception(\"Cannot call recursively method\")\n        stack.add(proc)\n        val top = varNames()\n        val nwVars = mutableMapOf<String, Pair<VarOperand, Int>>()\n        val procVars = proc.variables\n        for((index, value) in varName.withIndex()) {\n            val nwIndex = top[value.varName]!!.second\n            if(value is ListOperand){\n                nwVars[procVars[index]] = Pair(ListOperand(procVars[index], value.size), nwIndex)\n            } else {\n                nwVars[procVars[index]] = Pair( VarOperand(procVars[index]), nwIndex)\n            }\n        }\n        top.forEach{ nwVars.putIfAbsent(it.key, it.value)}\n        variablesIndex.add(nwVars)\n    }\n\n    fun pop()  {\n        if(stack.isEmpty()) throw Exception(\"Cannot pop empty stack\")\n        stack.removeAt(stack.size - 1)\n        variablesIndex.removeAt(variablesIndex.size - 1)\n    }\n\n    fun isRoot()  = stack.isEmpty()\n\n}\n\nclass Transpiler(var statement: MutableList<Statement>) {\n\n    private val sc = StackCount()\n    private val cs = CallStack()\n    private var cursor = 0\n    private val procedures = mutableMapOf<String, Procedure>()\n    private val instructions = mutableListOf<Instruction>()\n\n    private fun push(i : Int = 1) = sc.push(i)\n    private fun pop(i : Int = 1) = sc.pop(i)\n\n    private fun varIdx(varName : VarOperand) = cs.varIdx(varName)\n\n    private fun goto(idx: Int) : String{\n        if(cursor == idx) return \"\"\n        val res = when(cursor){\n            in 0..idx -> \">\".repeat(idx - cursor)\n            else -> \"<\".repeat(cursor - idx)\n        }\n        cursor = idx\n        return res\n    }\n\n    private fun forceCursor(idx : Int) : String {\n        cursor = idx\n        return \"\"\n    }\n\n    private fun toInstruction(st: Statement) : Instruction  = when(st.name){\n        Token.IFNEQ, Token.IFEQ, Token.WNEQ -> condBody(st)\n        Token.PROC -> throw Exception(\"Expected instruction, got procedure\")\n        else -> Instruction(st.name, st.operands)\n    }\n\n\n    private fun condBody(declaration: Statement): Instruction {\n        val instrs = mutableListOf<Instruction>()\n        while(!endBlock()){\n            val nxt = next()\n            instrs.add(toInstruction(nxt))\n        }\n        mustBe(Token.END)\n        return CondInstruction(declaration.name, declaration.operands, instrs.toTypedArray())\n    }\n\n    private fun parseProc(declaration: Statement) : Procedure{\n        if(declaration.operands.isEmpty()) throw Exception(\"Missing name of procedure\")\n        val procName = (declaration.operands[0] as VarOperand).varName\n        val instrs = mutableListOf<Instruction>()\n        while(!endBlock()){\n            val nxt = next()\n            val inst = toInstruction(nxt)\n            bfAssert(inst.type != Token.VAR && inst.type != Token.PROC) { \"Can't define var inside procedure, nor procedure\"}\n            instrs.add(inst)\n        }\n        mustBe(Token.END)\n        val parameters = declaration.operands.drop(1).map { (it as VarOperand).varName }.toTypedArray()\n        bfAssert(parameters.distinct().size == parameters.size) { \"Avoid duplicate parameters name\" }\n        return Procedure(procName, parameters, instrs.toTypedArray())\n    }\n\n    fun rootParsing() {\n        while(statement.isNotEmpty()){\n            val next = statement.removeAt(0)\n            when (next.name) {\n                Token.VAR -> storeVariables(next)\n                Token.END -> throw Exception(\"Unexpected 'end' token\")\n                Token.PROC -> {\n                    val proc = parseProc(next)\n                    bfAssert(!procedures.containsKey(proc.name)) {\"Procedure ${proc.name} declared twice\"}\n                    procedures[proc.name] = proc\n                }\n                else -> instructions.add(toInstruction(next))\n            }\n        }\n    }\n\n    private fun storeVariables(vars: Statement) {\n        for(o in vars.operands) {\n            val oVar = o as VarOperand\n            bfAssert(!cs.varNameExists(oVar)) {\"Can't have twice the save var\"}\n            cs.setVarIdx(oVar, sc.get())\n            sc.push((oVar as? ListOperand)?.size?.plus(4) ?: 1)\n        }\n    }\n\n    private fun endBlock() = statement.isNotEmpty() && statement[0].name == Token.END\n\n    private fun next() = statement.removeAt(0)\n\n    private fun mustBe(tk: Token) = when{\n        statement.isEmpty() || statement[0].name != tk -> throw Exception(\"Unexpected token\")\n        else -> statement.removeAt(0)\n    }\n\n    private fun inc(increment: Int = 1) = \"+\".repeat(increment)\n    private fun dec(decrement: Int = 1) = \"-\".repeat(decrement)\n    private fun goInc(idx : Int, increment : Int = 1) = \"${goto(idx)}${inc(increment)}\"\n    private fun goDec(idx : Int, decrement : Int = 1) = \"${goto(idx)}${dec(decrement)}\"\n    private fun loop(test: Int, block : () -> String) =  \"${goto(test)}[${block()}${goto(test)}]\"\n\n    private fun cp(from: Int, vararg to: Int) : String {\n        val tmp = push()\n        return \"\"\"\n        ${loop(from) {\n            to.joinToString(\"\", prefix = \"-\") { \"${goto(it)}+\" } + \"${goto(tmp)}+\"\n        }}\n        ${loop(tmp) {  \"-${goto(from)}+\"  }}\n        ${pop()}\n        \"\"\"\n    }\n\n    private fun mv(from: Int, vararg to: Int) = \"\"\"\n        ${loop(from) {  to.joinToString(\"\", prefix = \"-\") { \"${goto(it)}+\" } }}\n    \"\"\"\n\n    private fun reset(idx: Int) = loop(idx) { \"-\" }\n\n    private fun assertVarOrNumber(op : Operand){\n        bfAssert(op is VarOperand && !cs.isListVar(op) || op is ConstOperand)\n    }\n\n    private fun assertNotList(op : Operand) {\n        bfAssert(!cs.isListVar(op)) { \"Can't process a list in this context\"}\n    }\n\n    private fun createSetter(op : Operand, canMv : Boolean = false) : Generator = when(op) {\n            is ConstOperand -> ({ inc(op.content()) })\n            is VarOperand -> ({ if(canMv) mv(varIdx(op), it) else cp(varIdx(op), it)})\n            else -> throw Exception(\"Cannot make generator from $op\")\n    }\n\n    private fun createGetter(op : VarOperand) : Generator {\n        val idx = varIdx(op)\n        return ({ \"${reset(idx)}${mv(it, idx)}\" })\n    }\n\n    private fun createIncrGetter(op : VarOperand, postInc : Int) : Generator {\n        val idx = varIdx(op)\n        return {\"${reset(idx)}${mv(it, idx)}${goInc(idx, postInc)}\"}\n    }\n\n    private fun doSet(from : Operand, to : VarOperand): String {\n        assertNotList(from)\n        assertNotList(to)\n        bfAssert(from is VarOperand || from is ConstOperand) { \"From must be var or const\"}\n        val toIdx = varIdx(to)\n        if(from is ConstOperand) {\n            return \"${goto(toIdx)}${reset(toIdx)}${inc(from.content())}\"\n        }\n        val next1 = push()\n        val fromIdx = varIdx(from as VarOperand)\n        return \"${reset(toIdx)}${mv(fromIdx, next1)}${mv(next1, fromIdx, toIdx)}${pop()}\"\n    }\n\n    private fun doRead(target: VarOperand) = \"${goto(varIdx(target))},\"\n\n    \/\/ Possible improvement : do not reset and incr\/decr only the necessary\n    private fun outChar(chr: Char) = \"${inc(chr.toInt())}.[-]\"\n\n    private fun output(op : Operand) = when(op){\n        is ListOperand -> throw Exception(\"Cannot output value of list $op\")\n        is VarOperand -> \"${goto(varIdx(op))}.\"\n        is ConstOperand -> \"${goto(push())}${inc(op.content())}.${pop()}\"\n        is StringOperand ->\n            \"\"\"${goto(push())}${op.content().replace(\"\\\n\",\"\n\").map(::outChar).joinToString(\"\")}${pop()}\"\"\"\n        else -> throw Exception(\"Unknown operand $op\")\n    }\n\n    private fun doMsg(values: Array<Operand>) : String {\n        return values.joinToString(\"\") { output(it) }\n    }\n\n    private fun doInc(target: VarOperand, incrementOf : Operand) : String {\n        assertNotList(target)\n        assertNotList(incrementOf)\n        val tIdx = varIdx(target)\n        if(incrementOf is ConstOperand) {\n            return \"${goto(tIdx)}${inc(incrementOf.content())}\"\n        }\n        val incIdx = varIdx(incrementOf as VarOperand)\n        val ne1 = push()\n        return \"${mv(incIdx, ne1)}${mv(ne1, tIdx, incIdx)}${pop()}\"\n    }\n\n    private fun doDec(target : VarOperand, decrementOf : Operand) : String {\n        assertNotList(target)\n        assertNotList(decrementOf)\n        val tIdx = varIdx(target)\n        if(decrementOf is ConstOperand){\n            return \"${goto(tIdx)}${dec(decrementOf.content())}\"\n        }\n        val decIdx = varIdx(decrementOf as VarOperand)\n        val ne1 = push()\n        return \"${mv(decIdx, ne1)}${loop(ne1) {\"-${goto(tIdx)}-${goto(decIdx)}+\"} }${pop()}\"\n    }\n\n    private inline fun sum(xSetter : Generator, ySetter : Generator, xGetter : Generator, chr: Char) : String {\n        val x = push()\n        val y = push()\n        return \"\"\"\n            ${reset(x)}${xSetter(x)}\n            ${reset(y)}${ySetter(y)}\n            ${goto(y)}[${goto(x)}$chr${goDec(y)}]\n            ${xGetter(x)}\n        ${pop(2)}\n        \"\"\"\n    }\n\n    private fun doAdd(op1 : Operand, op2: Operand, target: VarOperand) : String{\n        assertVarOrNumber(op1)\n        assertVarOrNumber(op2)\n        assertNotList(target)\n        if(op1 is ConstOperand && op2 is ConstOperand){\n            return \"${goto(varIdx(target))}${inc(op1.content() + op2.content())}\"\n        }\n        return sum(\n                createSetter(op1, target == op1),\n                createSetter(op2, target == op2),\n                createGetter(target),\n                '+'\n        )\n    }\n\n    private fun doSub(op1 : Operand, op2 : Operand, target: VarOperand) : String {\n        assertVarOrNumber(op1)\n        assertVarOrNumber(op2)\n        assertNotList(target)\n        if(op1 is ConstOperand && op2 is ConstOperand){\n            return \"${goto(varIdx(target))}${inc(op1.content() - op2.content())}\"\n        }\n        return sum(\n                createSetter(op1, target == op1),\n                createSetter(op2, target == op2),\n                createGetter(target),\n                '-'\n        )\n    }\n\n    private inline fun mul(xSetter: Generator, ySetter : Generator, xGetter : Generator) : String {\n        val x = push()\n        val y = push()\n        val temp0 = push()\n        val temp1 = push()\n        return \"\"\"\n        ${reset(x)}${xSetter(x)}\n        ${reset(y)}${ySetter(y)}\n        ${reset(temp0)}${reset(temp1)}\n        ${goto(x)}[${goInc(temp1)}${goDec(x)}]\n        ${goto(temp1)}[\n            ${goto(y)}[${goInc(x)}${goInc(temp0)}${goDec(y)}]\n            ${goto(temp0)}[${goInc(y)}${goDec(temp0)}]\n            ${goDec(temp1)}\n        ]\n        ${xGetter(x)}\n        ${pop(4)}\n        \"\"\"\n    }\n\n    private fun doMul(op1 : Operand, op2: Operand, target: VarOperand) : String {\n        assertVarOrNumber(op1)\n        assertVarOrNumber(op2)\n        assertNotList(target)\n        val tIdx = varIdx(target)\n        if(op1 is ConstOperand && op2 is ConstOperand)  return \"${goto(tIdx)}${inc(op1.content()*op2.content())}\"\n        return mul(createSetter(op1, target == op1), createSetter(op2, target == op2), createGetter(target))\n    }\n\n    private inline fun divMod(aSetter : Generator, bSetter : Generator, cGetter: Generator, dGetter : Generator) : String {\n        val n = push()\n        val d = push()\n        val mod = push()\n        val div = push()\n        return \"\"\"\n        ${reset(n)}${aSetter(n)}\n        ${reset(d)}${bSetter(d)}\n        ${reset(mod)}\n        ${reset(div)}\n        ${goto(n)}\n        [->[->+>>]>[<<+>>[-<+>]>+>>]<<<<<]>[>>>]>[[-<+>]>+>>]<<<<<\n        ${forceCursor(n)\/* Cursor is at n now *\/}\n        ${cGetter(div)}\n        ${dGetter(mod)}\n        ${pop(4)}\n        \"\"\"\n    }\n\n    private fun doDiv(op1: Operand, op2 : Operand, target: VarOperand) : String {\n        assertVarOrNumber(op1)\n        assertVarOrNumber(op2)\n        assertNotList(target)\n\n        if(op1 is ConstOperand && op2 is ConstOperand){\n            val div = op1.content() \/ op2.content()\n            return \"${goto(varIdx(target))}${inc(div)}\"\n        }\n        return divMod(createSetter(op1, target == op1 ), createSetter(op2, target == op2), createGetter(target), {\"\"})\n    }\n\n    private fun doDivMod(op1 : Operand,\n                         op2 : Operand,\n                         target1 : VarOperand,\n                         target2 : VarOperand) : String {\n        assertVarOrNumber(op1)\n        assertVarOrNumber(op2)\n        assertNotList(target1)\n        assertNotList(target2)\n        if(op1 is ConstOperand && op2 is ConstOperand) {\n            val quotient = op1.content() \/ op2.content()\n            val remainder = op1.content() % op2.content()\n            return \"${reset(varIdx(target1))}${inc(quotient)}${reset(varIdx(target2))}${inc(remainder)}\"\n        }\n\n        return divMod(\n                createSetter(op1, op1 == target1 || op1 == target2),\n                createSetter(op2, op2 == target2 || op2 == target1),\n                createGetter(target1),\n                createGetter(target2)\n        )\n    }\n\n    private fun doMod(op1 : Operand, op2 : Operand, target : VarOperand) : String {\n        assertVarOrNumber(op1)\n        assertVarOrNumber(op2)\n        assertNotList(target)\n        if(op1 is ConstOperand && op2 is ConstOperand) {\n            val remainder = op1.content() % op2.content()\n            return \"${reset(varIdx(target))}${inc(remainder)}\"\n        }\n        return divMod(createSetter(op1, target == op1), createSetter(op2, target == op2), {\"\"}, createGetter(target))\n    }\n\n    private inline fun compare(aSetter : Generator, bSetter : Generator, cGetter: Generator  ) : String {\n        val result = push()\n        val a = push()\n        val b = push()\n        val flag1 = push()\n        val end = push()\n        return \"\"\"\n            ${reset(result)}\n            ${reset(a)}${aSetter(a)}\n            ${reset(b)}${bSetter(b)}\n            ${reset(flag1)}\n            ${reset(end)}\n            ${goto(a)}\n            [\n                ${dec()}\n                ${goInc(flag1)}\n                ${goto(b)}\n                [->-]>\n                [<<+[[-]<+>]>>->]\n                <<<\n            ]\n            >[[-]<<->>]<<\n            ${forceCursor(result)}\n            ${cGetter(result)}\n            ${pop(5)}\n        \"\"\"\n    }\n\n    private fun doCmp(op1 : Operand, op2 : Operand, target : VarOperand) : String{\n        assertVarOrNumber(op1)\n        assertVarOrNumber(op2)\n        assertNotList(target)\n\n        val targetIdx = varIdx(target)\n        if(op1 is ConstOperand && op2 is ConstOperand){\n            val result = (op1.content()   - op2.content()).sign\n            return \"${reset(targetIdx)}${if(result < 0) dec(1) else inc(result)}\"\n        }\n\n        return compare(\n                createSetter(op1, target == op1),\n                createSetter(op2, target == op2),\n                { \"${reset(targetIdx)}${mv(it, targetIdx)}\"}\n        )\n    }\n\n    private inline fun a2B(aSetter : Generator, bSetter : Generator, cSetter : Generator, dGetter : Generator) : String {\n        val buff = push()\n        val buff2 = push()\n        val result = push()\n        val buff3 = push()\n        val a = push()\n        val b = push()\n        val c = push()\n        val limit = push()\n        return \"\"\"\n            ${reset(buff)}\n            ${reset(buff2)}\n            ${reset(result)}\n            ${reset(buff3)}\n            ${reset(limit)}\n            ${reset(a)}\n            ${aSetter(a)}\n            ${reset(b)}\n            ${bSetter(b)}\n            ${reset(c)}\n            ${cSetter(c)}\n            ${goto(buff3)}\n            >------------------------------------------------[<<+>>-]>\n            [\n                <<<\n                [<+>-]<\n                [>++++++++++<-]>\n                >>>\n                ------------------------------------------------\n                [<<<+>>>-]>\n                [\n                    <<<<\n                    [<+>-]<\n                    [>++++++++++<-]>\n                    >>>>\n                    ------------------------------------------------\n                    [<<<<+>>>>-]\n                ]\n                <\n            ]\n            <<<\n            ${forceCursor(result)}\n            ${dGetter(result)}\n            ${pop(8)}\n        \"\"\"\n    }\n\n    private fun doA2B(a : Operand, b : Operand, c : Operand, d :VarOperand) : String {\n        assertVarOrNumber(a)\n        assertVarOrNumber(b)\n        assertVarOrNumber(c)\n        assertNotList(d)\n\n        val targetIdx = varIdx(d)\n        if(a is ConstOperand && b is ConstOperand && c is ConstOperand){\n            val result = 100 * (a.content() - 48) + 10 * (b.content() - 48) + (c.content() - 48)\n            return \"${reset(targetIdx)}${inc(result)}\"\n        }\n\n        return a2B(\n                createSetter(a),\n                createSetter(b),\n                createSetter(c, c == d),\n                { \"${reset(targetIdx)}${mv(it, targetIdx)}\" }\n        )\n    }\n\n    private fun b2a(aSetter : Generator, bGetter : Generator, cGetter : Generator, dGetter: Generator): String {\n        val aTmp = push()\n        return \"\"\"\n            ${divMod(aSetter, { \"${reset(it)}${goInc(it, 100)}\"}, bGetter, { \"${reset(aTmp)} ${mv(it,aTmp)})} \"})}\n            ${divMod({ \"${reset(it)}${mv(aTmp, it)}\"}, { \"${reset(it)}${goInc(it, 10)}\" }, cGetter, dGetter)}\n            ${pop()}\n        \"\"\"\n    }\n\n    private fun doB2A(a : Operand, b : VarOperand, c : VarOperand, d : VarOperand) : String {\n        assertVarOrNumber(a)\n        assertNotList(b)\n        assertNotList(c)\n        assertNotList(d)\n\n        if(a is ConstOperand){\n            val aVal = a.content()\n            val bValue = (aVal \/ 100)\n            val cValue = ( (aVal % 100) \/ 10)\n            val dValue = (aVal % 10)\n            return \"${reset(varIdx(b))}${inc(bValue + 48)}${reset(varIdx(c))}${inc(cValue + 48)}${reset(varIdx(d))}${inc(dValue + 48)}\"\n        }\n\n        return b2a(\n                createSetter(a, a == b || a == c || a == d),\n                createIncrGetter(b, 48),\n                createIncrGetter(c, 48),\n                createIncrGetter(d, 48)\n        )\n    }\n\n    private fun doLSet(a : VarOperand, b : Operand, c : Operand) : String {\n        assertVarOrNumber(c)\n        bfAssert(cs.isListVar(a))\n        if(b is ConstOperand) {\n            val index0 = varIdx(a) + b.content() + 4\n\n            return if(c is VarOperand) {\n                \"${reset(index0)}${cp(varIdx(c), index0)}\"\n            } else{\n                \"${reset(index0)}${goInc(index0, (c as ConstOperand).content())}\"\n            }\n        }\n        val listStart = varIdx(a)\n        val cSetter : Generator = when(c){\n            is VarOperand -> ({cp(varIdx(c), it)})\n            is ConstOperand -> ({goInc(it, c.content())})\n            else -> throw Exception(\"Cant set list with list\")\n        }\n        return \"\"\"\n            ${reset(listStart)}\n            ${reset(listStart+1)}${cp(varIdx(b as VarOperand), listStart +1)}\n            ${reset(listStart+2)}+\n            ${cSetter(listStart + 3)}\n            ${goto(listStart)}\n            >[>>>[-<<<<+>>>>]<\n            [->+<]\n            <+[->+<]\n            <[->+<]\n            >-]\n            >>>[-]<[->+<]<\n            -[\n            [-<+>]\n            <<<[->>>>+<<<<]\n            >>-]\n            <<\n        \"\"\"\n    }\n\n    private fun doLGet(a : VarOperand, b : Operand, c : VarOperand) : String {\n        assertVarOrNumber(c)\n        bfAssert(cs.isListVar(a))\n        val cIndex = varIdx(c)\n        if(b is ConstOperand)\n            return \"${reset(cIndex)}${cp(varIdx(a) + b.content() + 4, cIndex)}\"\n\n        val listStart = varIdx(a)\n\n        return \"\"\"\n            ${reset(listStart)}\n            ${reset(listStart+1)}${cp(varIdx(b as VarOperand), listStart +1)}\n            ${reset(listStart+2)}+\n            ${reset(listStart + 3)}\n            ${goto(listStart)}\n            >[>>>[-<<<<+>>>>]<\n            <+[->+<]\n            <[->+<]\n            >-]\n            >>>[-<+<<+>>>]<<<[->>>+<<<]>\n            -[\n            [-<+>]\n            >[-<+>]<\n            <<<[->>>>+<<<<]\n            >>-]\n            <<\n            ${reset(cIndex)}\n            ${mv(listStart+3, cIndex)}\n        \"\"\"\n    }\n\n    private fun xor(x : Int, y : Int, z : Int) : String {\n        val xTmp = push()\n        val yTmp = push()\n        return \"\"\"\n            ${reset(z)}\n            ${reset(xTmp)}\n            ${reset(yTmp)}\n            ${goto(x)}\n            [${goDec(y)}${goInc(xTmp)}${goInc(yTmp)}${goDec(x)}]\n            ${goto(y)}\n            [${goInc(z)}${mv(y, yTmp)}${goto(y)}]\n            ${mv(yTmp, y)}${mv(xTmp, x)}\n            ${pop(2)}\n        \"\"\"\n    }\n\n    private fun doIfEq(instruction : CondInstruction) : String {\n        val (left, right) = instruction.operands\n        assertNotList(left)\n        assertNotList(right)\n        val instr = instruction.instrs\n        val aIdx = varIdx(left as VarOperand)\n        return if(right is ConstOperand) {\n            val tmp0 = push()\n            val tmp1 = push()\n            \"\"\"\n                ${reset(tmp0)}+\n                ${reset(tmp1)}\n                ${goDec(aIdx, right.content())}\n                [\n                    ${goInc(aIdx, right.content())}\n                    ${goDec(tmp0)}\n                    ${goto(aIdx)}[${goInc(tmp1)}${goDec(aIdx)}]\n                ]\n                ${goto(tmp1)}[${goInc(aIdx)}${goDec(tmp1)}]\n                ${goto(tmp0)}\n                [\n                    ${goInc(aIdx, right.content())}\n                    ${transpileInstructions(instr.asIterable())}\n                    ${goDec(tmp0)}\n                ]\n                ${pop(2)}\n            \"\"\"\n        } else {\n            val bIdx = varIdx(right as VarOperand)\n            val tmp0 = push()\n            val z = push()\n            \"\"\"\n                ${reset(tmp0)}+\n                ${xor(aIdx, bIdx ,z)}\n                ${goto(z)}\n                [\n                    ${goDec(tmp0)}\n                    ${reset(z)}\n                ]\n                ${goto(tmp0)}\n                [\n                    ${transpileInstructions(instr.asIterable())}\n                    ${goDec(tmp0)}\n                ]\n                ${pop(2)}\n            \"\"\"\n        }\n    }\n\n    private fun doIfNEq(instruction : CondInstruction) : String {\n        val (left, right) = instruction.operands\n        assertNotList(left)\n        assertNotList(right)\n        val instr = instruction.instrs\n        val aIdx = varIdx(left as VarOperand)\n\n        return if(right is ConstOperand) {\n            val tmp0 = push()\n            val tmp1 = push()\n            \"\"\"\n                ${reset(tmp0)}+\n                ${reset(tmp1)}\n                ${goDec(aIdx, right.content())}\n                [\n                    ${goInc(aIdx, right.content())}\n                    ${goDec(tmp0)}\n                    ${transpileInstructions(instr.asIterable())}\n                    ${goto(aIdx)}[${goInc(tmp1)}${goDec(aIdx)}]\n                ]\n                ${goto(tmp1)}[${goInc(aIdx)}${goDec(tmp1)}]\n                ${goto(tmp0)}\n                [\n                    ${goInc(aIdx, right.content())}\n                    ${goDec(tmp0)}\n                ]\n                ${pop(2)}\n            \"\"\"\n        } else {\n            val bIdx = varIdx(right as VarOperand)\n            val z = push()\n            \"\"\"\n                ${xor(aIdx, bIdx ,z)}\n                ${goto(z)}\n                [\n                    ${transpileInstructions(instr.asIterable())}\n                    ${reset(z)}\n                ]\n                ${pop()}\n            \"\"\"\n        }\n    }\n\n    private fun doWNeq(instructions : CondInstruction) : String {\n        val (left, right) = instructions.operands\n        val instrs = instructions.instrs\n        assertNotList(left)\n        bfAssert(left is VarOperand)\n        assertNotList(right)\n        val a = (left as VarOperand)\n        val aIndex = varIdx(a)\n        if(right is ConstOperand) {\n            return \"\"\"\n                ${goDec(aIndex, right.content())}\n                ${loop(aIndex) {\"\"\"\n                    ${goInc(aIndex, right.content())}\n                    ${transpileInstructions(instrs.asIterable())}\n                    ${goDec(aIndex, right.content())}\n                \"\"\"}}\n                ${goInc(aIndex, right.content())}\n            \"\"\"\n        } else {\n            val bIndex = varIdx(right as VarOperand)\n            val z = push()\n            return \"\"\"\n                ${xor(aIndex, bIndex, z)}\n                ${loop(z) {\"\"\"${transpileInstructions(instrs.asIterable())}\n                    ${xor(aIndex, bIndex, z)}\n                \"\"\" }}\n                ${pop()}\n            \"\"\"\n        }\n    }\n\n    private fun call(proc : Procedure, operands: List<VarOperand>) : String {\n        cs.push(proc, operands)\n        val res = transpileInstructions(proc.code.asIterable())\n        cs.pop()\n        return res\n    }\n\n    private fun doCall(operands : Array<Operand>) : String {\n        bfAssert(operands.isNotEmpty() && operands.all { it is VarOperand } ) {\"Need at least one element, all var names\" }\n        val varnames = operands.map { it as VarOperand }\n        val fnName = varnames[0].varName\n        bfAssert(procedures.contains(fnName)){\"The procedure $fnName does not exist\"}\n        val proc = procedures[fnName]!!\n        return call(proc, varnames.drop(1))\n    }\n\n    fun instructionToBf(int : Instruction) = when(int.type) {\n        Token.SET -> doSet(int.operands[1], int.operands[0] as VarOperand)\n        Token.READ -> doRead(int.operands[0] as VarOperand)\n        Token.MSG -> doMsg(int.operands)\n        Token.INC -> doInc(int.operands[0] as VarOperand, int.operands[1])\n        Token.DEC -> doDec(int.operands[0] as VarOperand, int.operands[1])\n        Token.ADD -> doAdd(int.operands[0], int.operands[1], int.operands[2] as VarOperand)\n        Token.SUB -> doSub(int.operands[0], int.operands[1], int.operands[2] as VarOperand)\n        Token.MUL -> doMul(int.operands[0], int.operands[1], int.operands[2] as VarOperand)\n        Token.DIV -> doDiv(int.operands[0], int.operands[1], int.operands[2] as VarOperand)\n        Token.DIVMOD -> doDivMod(\n            int.operands[0],\n            int.operands[1],\n            int.operands[2] as VarOperand,\n            int.operands[3] as VarOperand)\n        Token.MOD -> doMod(int.operands[0], int.operands[1], int.operands[2] as VarOperand)\n        Token.CMP -> doCmp(int.operands[0], int.operands[1], int.operands[2] as VarOperand)\n        Token.A2B -> doA2B(int.operands[0], int.operands[1], int.operands[2], int.operands[3] as VarOperand)\n        Token.B2A -> doB2A(\n                int.operands[0],\n                int.operands[1] as VarOperand,\n                int.operands[2] as VarOperand,\n                int.operands[3] as VarOperand)\n        Token.LSET -> doLSet(\n                int.operands[0] as VarOperand, int.operands[1], int.operands[2])\n        Token.LGET -> doLGet(int.operands[0] as VarOperand, int.operands[1], int.operands[2] as VarOperand)\n        Token.IFEQ -> doIfEq(int as CondInstruction)\n        Token.IFNEQ -> doIfNEq(int as CondInstruction)\n        Token.WNEQ -> doWNeq(int as CondInstruction)\n        Token.CALL -> doCall(int.operands)\n        else -> throw Exception(\"Unknown instruction ${int.type}\")\n    }\n\n    private fun transpileInstructions(toTranspile : Iterable<Instruction>) =\n            toTranspile.joinToString(\"\") { instructionToBf(it)  }\n\n    fun transpile() = transpileInstructions(instructions)\n\n}\n\nfun isComment(token: String) = \"^(#|\/\/|--|rem )\".toRegex(RegexOption.IGNORE_CASE).containsMatchIn(token)\n\nfun <T> MutableList<T>.removeDuplicates(): MutableList<T>{\n    for(i in this.size-2 downTo 0){\n        if(this[i+1] == this[i] && this[i] == \"\n\"){\n            this.removeAt(i+1)\n        }\n    }\n    return this\n}\n\nfun kcuf(code: String): String {\n    val reg = Regex(\"\"\"\".+?\"|'.'|(--|#|\/{2}|rem).*|-?\\d+|[a-zA-Z_$]+(\\w|[$])*|[\\[\\]=]|\n\"\"\", RegexOption.IGNORE_CASE);\n    val tokens = reg.findAll(code)\n                    .map { it.value }\n                    .filterNot(::isComment)\n                    .toMutableList()\n                    .removeDuplicates()\n    val parser = Parser(tokens)\n    val transpiler = Transpiler(parser.getStatements().toMutableList())\n    transpiler.rootParsing()\n    return transpiler.transpile()\n}\n\n\/\/\n\/\/ If printing the code is annoying or a waste of your bandwith (~220 KB for final test).\n\/\/ Please uncomment the following line.\nval just = NOPRINT()","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208831,"user_id":503,"body":"fun kcuf(RawCode : String,Origin : Boolean = false,Indent : String = \"\\t\") : String\n{\n\tvar Code = \"\"\n\tvar CodeAt = 0\n\tvar Output = \"\"\n\tvar Preserve = 9\n\tvar PreserveMax = -1\n\tval Stack = Array(Preserve,{0})\n\tvar StackAt = 0\n\tvar VarAt = Preserve--\n\tval Var = mutableMapOf<String,Any>()\n\tval AST = mutableListOf<Array<Any>>()\n\tval ASTStack = java.util.Stack<Int>()\n\tvar CurrentAST = AST\n\tval Proc = mutableMapOf<String,Array<Any>>()\n\tvar ProcSig : String? = null\n\tvar ProcVar : MutableList<String>? = null\n\tvar ProcVarType : MutableList<Array<Any>?>? = null\n\n\tvar Line = 0\n\tvar LastCol = 0\n\tval CaseSensetive = {Q : String -> Q.toUpperCase()}\n\tval Clamp = {Q : Int ->\n\t\tval R = Q % 256\n\t\tif (R < 0) 256 + R else R}\n\n\tfun Bad(Q : String,J : Boolean = false) = fun(A : Any?)\n\t{\n\t\tthrow Error((if (null == A) Q else if (A is Array<*>) String.format(Q,*A) else String.format(Q,A)) +\n\t\t\t\"\n\\tat $Line:${if (J) 1 + LastCol else 1 + CodeAt} '$Code'\")\n\t}\n\t\/\/\tParse Error\n\tval ErrorNumberExpected = Bad(\"A number is expected but got %s\")\n\tval ErrorNameExpected = Bad(\"A variable name \/ command is expected but got %s\")\n\tval ErrorCommand = Bad(\"Unexpected command %s\",true)\n\tval ErrorCommandEnd = Bad(\"Expected end of line but got %s\")\n\tval ErrorDefineInProc = Bad(\"Cannot define variables in procedures\")\n\tval ErrorVarUndefined = Bad(\"Undefined variable %s\",true)\n\tval ErrorVarRedeclare = Bad(\"Re-defined variable %s\",true)\n\tval ErrorVarButList = Bad(\"Expected a variable but %s is a list\",true)\n\tval ErrorListButVar = Bad(\"Expected a list but %s is a variable\",true)\n\tval ErrorVarTypeMismatch = Bad(\"Type mismatch\n\" +\n\t\t\"\\tin `%s`\n\" +\n\t\t\"\\t%s was used as a %s at %s:%s `%s`\n\" +\n\t\t\"\\tas well being used as a %s\",true)\n\tval ErrorUnEOL = Bad(\"Unexpected end of line\")\n\tval ErrorUnclosed = Bad(\"Unclosed %s, expected %s but got %s\")\n\tval ErrorBadEscape = Bad(\"Unexpected char escape \\\\%s\")\n\tval ErrorStringExpect = Bad(\"A string is expected but got %s\")\n\tval ErrorStringUnclose = Bad(\"String is not closed\")\n\tval ErrorProcNested = Bad(\"Procedures should not be nested\",true)\n\tval ErrorProcUsed = Bad(\"Procedure re-defined %s\")\n\tval ErrorDupParam = Bad(\"Duplicate parameter name %s\",true)\n\tval ErrorEndNothing = Bad(\"Nothing to end\")\n\tval ErrorEndUnclose = Bad(\"Unclosed block (ifeq \/ ifneq \/ ueq \/ proc)\")\n\t\/\/\tTransform Error\n\tval ErrorNoProc = Bad(\"Undefined procedure %s%s\")\n\tval ErrorProcLength = Bad(\"Procedure %s expects %s argument(s) but got %s%s\")\n\tval ErrorRecursive = Bad(\"Recursive call %s\")\n\tval ErrorArgTypeMismatch = Bad(\"Type mismatch\n\" +\n\t\t\"\\ta %s is expected for parameter %s in `%s`\n\" +\n\t\t\"\\tbut argument %s is a %s\")\n\n\tfun _Taste(Q : Int = 0) = Code.getOrNull(CodeAt + Q) ?: '\\u0000'\n\tfun Taste(Q : Int = 0) = Code.getOrNull(CodeAt + Q)?.toString() ?: \"\"\n\tval TasteEOL =\n\t{\n\t\tval R = _Taste()\n\t\tif (0 < R.toInt()) R.toString() else \"EOL\"\n\t}\n\tval Eat = {++CodeAt}\n\tval Save = {LastCol = CodeAt}\n\tval Walk = {Q : Regex -> while (Q.matches(Taste())) Eat()}\n\tval Discard = {CodeAt = Code.length}\n\tval White =\n\t{\n\t\tWalk(Regex(\"\\\\s\"))\n\t\tif ('\/' == _Taste() && '\/' == _Taste(1) ||\n\t\t\t'-' == _Taste() && '-' == _Taste(1) ||\n\t\t\t'#' == _Taste()) Discard()\n\t}\n\tval Word =\n\t{\n\t\tval S = CodeAt\n\t\tSave()\n\t\tif (Regex(\"[^_A-Za-z$]\").matches(Taste())) ErrorNameExpected(TasteEOL())\n\t\tEat()\n\t\tWalk(Regex(\"[\\\\w$]\"))\n\t\tval R = if (S < Code.length) CaseSensetive(Code.substring(S,CodeAt)) else \"\"\n\t\tWhite()\n\t\tR\n\t}\n\tval MakeName = {H : Boolean ->\n\t{\n\t\tval R = Word()\n\t\tif (R.isEmpty()) ErrorNameExpected(TasteEOL())\n\t\tval T = ProcVar?.indexOf(R) ?: -1\n\t\tif (T < 0)\n\t\t{\n\t\t\tif (!Var.containsKey(R)) ErrorVarUndefined(R)\n\t\t\tif (H != Var[R] is Number) if (H) ErrorVarButList(R) else ErrorListButVar(R)\n\t\t}\n\t\telse if (null == ProcVarType!![T]) ProcVarType!![T] = arrayOf(H,Line,1 + LastCol,Code)\n\t\telse if (H != ProcVarType!![T]!![0]) ErrorVarTypeMismatch(arrayOf\n\t\t(\n\t\t\tProcSig,R,\n\t\t\tif (H) \"list\" else \"variable\",\n\t\t\tProcVarType!![T]!![1],\n\t\t\tProcVarType!![T]!![2],\n\t\t\t(ProcVarType!![T]!![3] as String).trim(),\n\t\t\tif (H) \"variable\" else \"list\"\n\t\t))\n\t\tR\n\t}}\n\tval VarName = MakeName(true)\n\tval ListName = MakeName(false)\n\tval RawNumber =\n\t{\n\t\tval S = CodeAt\n\t\tif ('-' == _Taste()) Eat()\n\t\tWalk(Regex(\"\\\\d\"))\n\t\tval R = Code.substring(S,CodeAt)\n\t\tif (R.isEmpty() || \"-\" == R) ErrorNumberExpected(TasteEOL())\n\t\tWhite()\n\t\tR.toInt()\n\t}\n\tval Number = {Clamp(RawNumber())}\n\tval CharEscape = mapOf(\n\t\t'\\\\' to '\\\\',\n\t\t'\"' to '\"',\n\t\t'\\'' to '\\'',\n\t\t'\"' to '\"',\n\t\t'n' to '\n',\n\t\t'r' to '\\r',\n\t\t't' to '\\t')\n\tval Char =\n\t{\n\t\tvar R = _Taste()\n\t\tEat()\n\t\tif ('\\\\' == R)\n\t\t{\n\t\t\tR = _Taste()\n\t\t\tif (!CharEscape.containsKey(R)) ErrorBadEscape(TasteEOL())\n\t\t\tR = CharEscape.getValue(R)\n\t\t\tEat()\n\t\t}\n\t\tR\n\t}\n\tval NumberOrChar =\n\t{\n\t\tif ('\\'' == _Taste())\n\t\t{\n\t\t\tEat()\n\t\t\tval R = Char()\n\t\t\tif ('\\'' != _Taste()) ErrorUnclosed(arrayOf(\"'\",\"'\",TasteEOL()))\n\t\t\tEat()\n\t\t\tWhite()\n\t\t\tR.toInt()\n\t\t}\n\t\telse Number()\n\t}\n\tval VarNameOrNumber = {if (Regex(\"[-\\\\d']\").matches(Taste())) NumberOrChar() else VarName()}\n\tval String =\n\t{\n\t\tvar R = \"\"\n\t\tif ('\"' != _Taste()) ErrorStringExpect(TasteEOL())\n\t\tEat()\n\t\twhile (!Taste().isEmpty() && '\"' != _Taste()) R += Char()\n\t\tif ('\"' != _Taste()) ErrorStringUnclose(null)\n\t\tEat()\n\t\tWhite()\n\t\tR\n\t}\n\tval VarNameOrString = {if ('\"' == _Taste()) 0 to String() else 1 to VarName()}\n\n\tval MsgList = arrayOf(\n\t{\n\t\tval R = mutableListOf<Pair<Int,String>>()\n\t\twhile (!Taste().isEmpty()) R.add(VarNameOrString())\n\t\tR\n\t})\n\n\tval Begin = {ASTStack.add(CurrentAST.size)}\n\tval Machine = mapOf(\n\t\t\"VAR\" to\n\t\t{\n\t\t\tif (null != ProcSig) ErrorDefineInProc(null)\n\t\t\tif (Taste().isEmpty()) ErrorUnEOL(null)\n\t\t\tvar V = Word()\n\t\t\twhile (!V.isEmpty())\n\t\t\t{\n\t\t\t\tif (Var.containsKey(V)) ErrorVarRedeclare(V)\n\t\t\t\tif ('[' == _Taste())\n\t\t\t\t{\n\t\t\t\t\tEat()\n\t\t\t\t\tWhite()\n\t\t\t\t\tval N = RawNumber()\n\t\t\t\t\tif (']' != _Taste()) ErrorUnclosed(arrayOf(\"[\",\"]\",TasteEOL()))\n\t\t\t\t\tEat()\n\t\t\t\t\tWhite()\n\t\t\t\t\tVar[V] = arrayOf(VarAt,N)\n\t\t\t\t\tVarAt += 4 + N\n\t\t\t\t}\n\t\t\t\telse Var[V] = VarAt++\n\t\t\t\tV = Word()\n\t\t\t}\n\t\t},\n\t\t\"SET\" to arrayOf(VarName,VarNameOrNumber),\n\t\t\"INC\" to arrayOf(VarName,VarNameOrNumber),\n\t\t\"DEC\" to arrayOf(VarName,VarNameOrNumber),\n\t\t\"ADD\" to arrayOf(VarNameOrNumber,VarNameOrNumber,VarName),\n\t\t\"SUB\" to arrayOf(VarNameOrNumber,VarNameOrNumber,VarName),\n\t\t\"MUL\" to arrayOf(VarNameOrNumber,VarNameOrNumber,VarName),\n\t\t\"DIVMOD\" to arrayOf(VarNameOrNumber,VarNameOrNumber,VarName,VarName),\n\t\t\"DIV\" to arrayOf(VarNameOrNumber,VarNameOrNumber,VarName),\n\t\t\"MOD\" to arrayOf(VarNameOrNumber,VarNameOrNumber,VarName),\n\n\t\t\"CMP\" to arrayOf(VarNameOrNumber,VarNameOrNumber,VarName),\n\n\t\t\"A2B\" to arrayOf(VarNameOrNumber,VarNameOrNumber,VarNameOrNumber,VarName),\n\t\t\"B2A\" to arrayOf(VarNameOrNumber,VarName,VarName,VarName),\n\n\t\t\"LSET\" to arrayOf(ListName,VarNameOrNumber,VarNameOrNumber),\n\t\t\"LGET\" to arrayOf(ListName,VarNameOrNumber,VarName),\n\n\t\t\"IFEQ\" to arrayOf(VarName,VarNameOrNumber,Begin),\n\t\t\"IFNEQ\" to arrayOf(VarName,VarNameOrNumber,Begin),\n\t\t\"WEQ\" to arrayOf(VarName,VarNameOrNumber,Begin),\n\t\t\"WNEQ\" to arrayOf(VarName,VarNameOrNumber,Begin),\n\t\t\"PROC\" to\n\t\t{\n\t\t\tif (null != ProcSig) ErrorProcNested(null)\n\t\t\tval N = Word()\n\t\t\tif (Proc.containsKey(N)) ErrorProcUsed(N)\n\t\t\tCurrentAST = mutableListOf()\n\t\t\tProcVar = mutableListOf()\n\t\t\tProcVarType = mutableListOf()\n\t\t\tProcSig = Code\n\t\t\tProc[N] = arrayOf(CurrentAST,ProcVar!!,ProcVarType!!,ProcSig!!)\n\t\t\twhile (!Taste().isEmpty())\n\t\t\t{\n\t\t\t\tval T = Word()\n\t\t\t\tif (ProcVar!!.contains(T)) ErrorDupParam(T)\n\t\t\t\tProcVar!!.add(T)\n\t\t\t\tProcVarType!!.add(null)\n\t\t\t}\n\t\t},\n\t\t\"END\" to arrayOf(\n\t\t{\n\t\t\tif (!ASTStack.isEmpty()) ASTStack.pop()\n\t\t\telse if (null == ProcSig) ErrorEndNothing(null)\n\t\t\telse\n\t\t\t{\n\t\t\t\tCurrentAST = AST\n\t\t\t\tProcSig = null\n\t\t\t\tnull\n\t\t\t}\n\t\t}),\n\t\t\"CALL\" to arrayOf(\n\t\t{\n\t\t\tval N = Word()\n\t\t\tval A = mutableListOf<String>()\n\t\t\twhile (!Taste().isEmpty()) A.add(Word())\n\t\t\tlistOf(N,A)\n\t\t}),\n\n\t\t\"READ\" to arrayOf(VarName),\n\t\t\"MSG\" to MsgList,\n\t\t\"LN\" to MsgList,\n\n\t\t\"REM\" to Discard,\n\n\t\t\"DEBUG\" to arrayOf(Discard),\n\t\t\"STOP\" to arrayOf(Discard))\n\n\tval EscapeMap = mapOf(\n\t\t'&' to \"&amp;\",\n\t\t'+' to \"&plus;\",\n\t\t'-' to \"&minus;\",\n\t\t'<' to \"&lt;\",\n\t\t'>' to \"&gt;\",\n\t\t',' to \"&comma;\",\n\t\t'.' to \"&stop;\",\n\t\t'[' to \"&leftsquare;\",\n\t\t']' to \"&rightsquare;\")\n\tval Escape = {Q : String -> Q.replace(Regex(\"[&+\\\\-<>,.\\\\[\\\\]]\")){EscapeMap.getValue(it.value[0])}}\n\n\tval OpGotoCell = {Q : Int ->\n\t\tOutput += if (Q < StackAt) \"<\".repeat(StackAt - Q)\n\t\t\telse \">\".repeat(Q - StackAt)\n\t\tStackAt = Q\n\t}\n\tval OpAdd = {Q : Int ->\n\t\tval S = Clamp(Q)\n\t\tOutput += if (128 < S) \"-\".repeat(256 - S) else \"+\".repeat(S)\n\t}\n\tval OpSolvePreserve = {Q : Int ->\n\t\tif (PreserveMax < Q) PreserveMax = Q\n\t\tPreserve - Q\n\t}\n\tval OpFly = {Q : Int -> StackAt = OpSolvePreserve(Q)}\n\tval OpGotoPreserve = {Q : Int -> OpGotoCell(OpSolvePreserve(Q))}\n\tval OpGetPreserve = {Q : Int -> Stack[OpSolvePreserve(Q)]}\n\tval OpSetPreserve = {Q : Int,S : Int -> Stack[OpSolvePreserve(Q)] = S}\n\tval OpModifyPreserve = {Q : Int,S : Int ->\n\t\tOpGotoPreserve(Q)\n\t\tOpAdd(S - OpGetPreserve(Q))\n\t\tOpSetPreserve(Q,S)\n\t}\n\tfun OpClearPreserve(Q : Int,J : Boolean = false)\n\t{\n\t\tif (J || 0 != OpGetPreserve(Q))\n\t\t{\n\t\t\tOpGotoPreserve(Q)\n\t\t\tOutput += \"[-]\"\n\t\t\tOpSetPreserve(Q,0)\n\t\t}\n\t}\n\tval OpMsgList = {Q : String ->\n\t\tfor (T in Q)\n\t\t{\n\t\t\tOpModifyPreserve(0,T.toInt())\n\t\t\tOutput += '.'\n\t\t}\n\t}\n\n\tfun Generate\n\t(\n\t\tAST : MutableList<Array<Any>>,\n\t\tCallArg : MutableMap<String,String> = mutableMapOf(),\n\t\tCallStack : java.util.Stack<String> = java.util.Stack(),\n\t\tCallStackMessage : String = \"\",\n\t\t_CurrentIndent : String = \"\"\n\t){\n\t\tvar CurrentIndent = _CurrentIndent\n\n\t\tval OpSolveVar = {Q : String -> CallArg[Q] ?: Q}\n\t\tfun OpGoto(Q : Any,S : Int = 0)\n\t\t{\n\t\t\tif (Q is Int)\n\t\t\t{\n\t\t\t\tif (Q < 0) OpGotoCell(-Q)\n\t\t\t\telse OpGotoPreserve(Q)\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tval T = Var[OpSolveVar(Q as String)]\n\t\t\t\tif (T is Int) OpGotoCell(T)\n\t\t\t\telse OpGotoCell(S + (T as Array<Int>)[0])\n\t\t\t}\n\t\t}\n\t\tfun OpClear(Q : Any,J : Boolean = false)\n\t\t{\n\t\t\twhen (Q)\n\t\t\t{\n\t\t\t\tis Int -> OpClearPreserve(Q,J)\n\t\t\t\tis Array<*> -> Q.forEach{OpClear(it!!,J)}\n\t\t\t\telse ->\n\t\t\t\t{\n\t\t\t\t\tOpGoto(Q)\n\t\t\t\t\tOutput += \"[-]\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfun OpBegin(Q : Any,S : Int = 0)\n\t\t{\n\t\t\tOpGoto(Q,S)\n\t\t\tOutput += \"[-\"\n\t\t}\n\t\tfun OpEnd(Q : Any,S : Int = 0)\n\t\t{\n\t\t\tOpGoto(Q,S)\n\t\t\tOutput += \"]\"\n\t\t}\n\t\tfun OpMove(Q : Any,S : Any,I : Int = 0)\n\t\t{\n\t\t\tOpBegin(Q,I)\n\t\t\tif (S is Array<*>) S.forEach{\n\t\t\t\tOpGoto(it!!)\n\t\t\t\tOutput += '+'\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tOpGoto(S)\n\t\t\t\tOutput += '+'\n\t\t\t}\n\t\t\tOpEnd(Q,I)\n\t\t}\n\t\tfun OpMoveReverse(Q : Any,S : Any,I : Int = 0)\n\t\t{\n\t\t\tOpBegin(Q,I)\n\t\t\tif (S is Array<*>) S.forEach{\n\t\t\t\tOpGoto(it!!)\n\t\t\t\tOutput += '-'\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tOpGoto(S)\n\t\t\t\tOutput += '-'\n\t\t\t}\n\t\t\tOpEnd(Q,I)\n\t\t}\n\t\tfun OpCopy(Q : Any,S : Any,T : Any,J : Boolean = true)\n\t\t{\n\t\t\tif (J) OpClear(T)\n\t\t\tOpMove(Q,if (S is Array<*>) arrayOf(*S,T) else arrayOf(S,T))\n\t\t\tOpMove(T,Q)\n\t\t}\n\t\tval OpPrepare = {Q : Any,S : Any,T : Any ->\n\t\t\tOpClear(S)\n\t\t\tif (Q is Int)\n\t\t\t{\n\t\t\t\tif (S is Array<*>)\n\t\t\t\t{\n\t\t\t\t\tOpGoto(T)\n\t\t\t\t\tOpAdd(Q)\n\t\t\t\t\tOpMove(T,S)\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tOpGoto(S)\n\t\t\t\t\tOpAdd(Q)\n\t\t\t\t}\n\t\t\t}\n\t\t\telse OpCopy(Q,S,T)\n\t\t}\n\t\tfun OpPrepare01(Q : List<*>,W : Any = 0,A : Any = 1,T : Int = 2)\n\t\t{\n\t\t\tOpPrepare(Q[0]!!,W,T)\n\t\t\tOpPrepare(Q[1]!!,A,T)\n\t\t}\n\t\tval OpSet = {Q : Any,S : Any ->\n\t\t\tOpClear(Q)\n\t\t\tOpMove(S,Q)\n\t\t}\n\t\tval OpDivMod = {Arg : List<*> ->\n\t\t\tOpPrepare01(Arg,5,4,0)\n\t\t\tOpCopy(4,8,7)\n\t\t\tOpGoto(7)\n\t\t\tOutput += \"+<-\" +\n\t\t\t\t\"[>>>[->-[>+>>]>[+[-<+>]>+>>]<<<<<]<<-]>\" +\n\t\t\t\t\"[->>[->>>+<<<]<]\"\n\t\t\tOpFly(6)\n\t\t\tOpClear(8,true)\n\t\t\tOpClear(4,true)\n\t\t\tif (null != Arg[2]) OpSet(Arg[2]!!,2) else OpClear(2,true)\n\t\t\tif (3 < Arg.size) OpSet(Arg[3]!!,3) else OpClear(3,true)\n\t\t}\n\t\tfun OpIFWhile(Arg : List<*>,Not : Boolean = false)\n\t\t{\n\t\t\tif (Arg[1] is Int)\n\t\t\t{\n\t\t\t\tOpClear(0)\n\t\t\t\tOpCopy(Arg[0]!!,0,1)\n\t\t\t\tOpGoto(0)\n\t\t\t\tOpAdd(-(Arg[1] as Int))\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tOpPrepare01(Arg)\n\t\t\t\tOpMoveReverse(1,0)\n\t\t\t}\n\t\t\tif (Not)\n\t\t\t{\n\t\t\t\tOpGoto(1)\n\t\t\t\tOutput += \"+>[[-]<-]<[>+<-<]\"\n\t\t\t\tOpFly(2)\n\t\t\t}\n\t\t\tOpGoto(0)\n\t\t}\n\n\t\tAST.forEach{\n\t\t\tvar Command = it[0] as String\n\t\t\tvar Arg = it[1] as List<*>\n\t\t\tval Line = it[2]\n\t\t\tval CurrentCode = it[3] as String\n\t\t\tvar NeedNewLine = true\n\t\t\tvar NeedIndent = false\n\t\t\tCode = CurrentCode\n\t\t\tif (Origin)\n\t\t\t{\n\t\t\t\tif (\"END\" == Command) CurrentIndent = CurrentIndent.substring(Indent.length)\n\t\t\t\tOutput += CurrentIndent + Escape(Code) + '\n'\n\t\t\t\tif (\"END\" != Command || null != Arg[0]) Output += CurrentIndent\n\t\t\t}\n\t\t\twhen (Command)\n\t\t\t{\n\t\t\t\t\"SET\" ->\n\t\t\t\t{\n\t\t\t\t\tOpGoto(Arg[0]!!)\n\t\t\t\t\tOutput += \"[-]\"\n\t\t\t\t\tif (Arg[1] is Int)\n\t\t\t\t\t\tOpAdd(Arg[1] as Int)\n\t\t\t\t\telse\n\t\t\t\t\t\tOpCopy(Arg[1]!!,Arg[0]!!,0)\n\t\t\t\t}\n\t\t\t\t\"INC\" ->\n\t\t\t\t{\n\t\t\t\t\twhen\n\t\t\t\t\t{\n\t\t\t\t\t\tArg[1] is Int ->\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tOpGoto(Arg[0]!!)\n\t\t\t\t\t\t\tOpAdd(Arg[1] as Int)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tOpSolveVar(Arg[0] as String) == OpSolveVar(Arg[1] as String) ->\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tOpClear(0)\n\t\t\t\t\t\t\tOpMove(Arg[0]!!,0)\n\t\t\t\t\t\t\tOpBegin(0)\n\t\t\t\t\t\t\tOpGoto(Arg[0]!!)\n\t\t\t\t\t\t\tOutput += \"++\"\n\t\t\t\t\t\t\tOpEnd(0)\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse -> OpCopy(Arg[1]!!,Arg[0]!!,0)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\"DEC\" ->\n\t\t\t\t{\n\t\t\t\t\tif (Arg[1] is Int)\n\t\t\t\t\t{\n\t\t\t\t\t\tOpGoto(Arg[0]!!)\n\t\t\t\t\t\tOpAdd(-(Arg[1] as Int))\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tOpCopy(Arg[1]!!,0,1)\n\t\t\t\t\t\tOpMoveReverse(0,Arg[0]!!)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\"ADD\" ->\n\t\t\t\t{\n\t\t\t\t\tOpPrepare01(Arg)\n\t\t\t\t\tOpMove(1,0)\n\t\t\t\t\tOpSet(Arg[2]!!,0)\n\t\t\t\t}\n\t\t\t\t\"SUB\" ->\n\t\t\t\t{\n\t\t\t\t\tOpPrepare01(Arg)\n\t\t\t\t\tOpMoveReverse(1,0)\n\t\t\t\t\tOpSet(Arg[2]!!,0)\n\t\t\t\t}\n\t\t\t\t\"MUL\" ->\n\t\t\t\t{\n\t\t\t\t\tOpPrepare01(Arg)\n\t\t\t\t\tOpBegin(0)\n\t\t\t\t\tOpCopy(1,2,3)\n\t\t\t\t\tOpEnd(0)\n\t\t\t\t\tOpClear(1,true)\n\t\t\t\t\tOpSet(Arg[2]!!,2)\n\t\t\t\t}\n\t\t\t\t\"DIVMOD\",\"DIV\" -> OpDivMod(Arg)\n\t\t\t\t\"MOD\" -> OpDivMod(listOf(Arg[0],Arg[1],null,Arg[2]))\n\t\t\t\t\"CMP\" ->\n\t\t\t\t{\n\t\t\t\t\tval X = 4\n\t\t\t\t\tval T0 = 3\n\t\t\t\t\tval T1 = 2\n\t\t\t\t\tOpPrepare01(Arg,arrayOf(T0,X),arrayOf(T1,1 + X),0)\n\t\t\t\t\tOpMoveReverse(1 + X,X)\n\n\t\t\t\t\tOpGoto(1 + X)\n\t\t\t\t\tOutput += \"+>[[-]\"\n\t\t\t\t\tOpFly(X)\n\n\t\t\t\t\tOpGoto(T1 - 1)\n\t\t\t\t\tOutput += \"+<[>-]>[\"\n\t\t\t\t\tOpFly(T1 - 1)\n\t\t\t\t\tOpGoto(X)\n\t\t\t\t\tOutput += '+'\n\t\t\t\t\tOpGoto(T0)\n\t\t\t\t\tOutput += \"[-]\"\n\t\t\t\t\tOpGoto(T1 - 1)\n\t\t\t\t\tOutput += \"->]<+\"\n\t\t\t\t\tOpGoto(T0)\n\t\t\t\t\tOutput += '['\n\t\t\t\t\tOpGoto(T1)\n\t\t\t\t\tOutput += \"-[>-]>[\"\n\t\t\t\t\tOpFly(T1 - 1)\n\t\t\t\t\tOpGoto(X)\n\t\t\t\t\tOutput += '+'\n\t\t\t\t\tOpGoto(T0)\n\t\t\t\t\tOutput += \"[-]+\"\n\t\t\t\t\tOpGoto(T1 - 1)\n\t\t\t\t\tOutput += \"->]<+\"\n\t\t\t\t\tOpGoto(T0)\n\t\t\t\t\tOutput += \"-]\"\n\n\t\t\t\t\tOpGoto(X)\n\t\t\t\t\tOutput += \"[<-]<[>-<-<]\"\n\t\t\t\t\tOpFly(2 + X)\n\n\t\t\t\t\tOpGoto(1 + X)\n\t\t\t\t\tOutput += \"]<[-<]>\"\n\n\t\t\t\t\tOpClear(3,true)\n\t\t\t\t\tOpClear(2,true)\n\t\t\t\t\tOpClear(1,true)\n\n\t\t\t\t\tOpSet(Arg[2]!!,X)\n\t\t\t\t}\n\t\t\t\t\"A2B\" ->\n\t\t\t\t{\n\t\t\t\t\tval (A,B,C,R) = Arg\n\t\t\t\t\tif (A is Int)\n\t\t\t\t\t{\n\t\t\t\t\t\tval a = Clamp(10 * (A - 48))\n\t\t\t\t\t\tif (0 < a)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tOpGoto(1)\n\t\t\t\t\t\t\tOpAdd(a)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tOpCopy(A!!,2,0)\n\t\t\t\t\t\tOpGoto(2)\n\t\t\t\t\t\tOpAdd(-48)\n\t\t\t\t\t\tOpBegin(2)\n\t\t\t\t\t\tOpGoto(1)\n\t\t\t\t\t\tOpAdd(10)\n\t\t\t\t\t\tOpEnd(2)\n\t\t\t\t\t}\n\t\t\t\t\tif (B is Int)\n\t\t\t\t\t{\n\t\t\t\t\t\tOpGoto(1)\n\t\t\t\t\t\tOpAdd(B - 48)\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tOpCopy(B!!,1,0)\n\t\t\t\t\t\tOpGoto(1)\n\t\t\t\t\t\tOpAdd(-48)\n\t\t\t\t\t}\n\t\t\t\t\tOpBegin(1)\n\t\t\t\t\tOpGoto(0)\n\t\t\t\t\tOpAdd(10)\n\t\t\t\t\tOpEnd(1)\n\t\t\t\t\tif (C is Int)\n\t\t\t\t\t{\n\t\t\t\t\t\tOpGoto(0)\n\t\t\t\t\t\tOpAdd(C - 48)\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tOpCopy(C!!,0,1)\n\t\t\t\t\t\tOpGoto(0)\n\t\t\t\t\t\tOpAdd(-48)\n\t\t\t\t\t}\n\t\t\t\t\tOpSet(R!!,0)\n\t\t\t\t}\n\t\t\t\t\"B2A\" ->\n\t\t\t\t{\n\t\t\t\t\tval (R,A,B,C) = Arg\n\t\t\t\t\tif (R is Int)\n\t\t\t\t\t{\n\t\t\t\t\t\tOpClear(A!!)\n\t\t\t\t\t\tOpAdd(R \/ 100)\n\t\t\t\t\t\tOpClear(B!!)\n\t\t\t\t\t\tOpAdd(R \/ 10 % 10)\n\t\t\t\t\t\tOpClear(C!!)\n\t\t\t\t\t\tOpAdd(R % 10)\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tOpDivMod(listOf(R,10,B,C))\n\t\t\t\t\t\tOpDivMod(listOf(B,10,A,B))\n\t\t\t\t\t}\n\t\t\t\t\tOpGoto(0)\n\t\t\t\t\tOpAdd(48)\n\t\t\t\t\tOpMove(0,arrayOf(Arg[1],Arg[2],Arg[3]))\n\t\t\t\t}\n\t\t\t\t\"LSET\" ->\n\t\t\t\t{\n\t\t\t\t\tif (Arg[1] is Int)\n\t\t\t\t\t{\n\t\t\t\t\t\tOpGoto(Arg[0]!!)\n\t\t\t\t\t\tOpAdd(Arg[1] as Int)\n\t\t\t\t\t\tOutput += \"[->+>+<<]\"\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tOpCopy(Arg[1]!!,arrayOf(-1 - (Var[OpSolveVar(Arg[0] as String)] as Array<Int>)[0],\n\t\t\t\t\t\t\t-2 - (Var[OpSolveVar(Arg[0] as String)] as Array<Int>)[0]),Arg[0]!!,false)\n\t\t\t\t\tif (Arg[2] is Int)\n\t\t\t\t\t{\n\t\t\t\t\t\tOpGoto(Arg[0]!!,3)\n\t\t\t\t\t\tOpAdd(Arg[2] as Int)\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tOpCopy(Arg[2]!!,-3 - (Var[OpSolveVar(Arg[0] as String)] as Array<Int>)[0],Arg[0]!!,false)\n\t\t\t\t\tOpGoto(Arg[0]!!)\n\t\t\t\t\tOutput += \">[>>>[-<<<<+>>>>]<[->+<]<[->+<]<[->+<]>-]\" +\n\t\t\t\t\t\t\">>>[-]<[->+<]<\" +\n\t\t\t\t\t\t\"[[-<+>]<<<[->>>>+<<<<]>>-]<<\"\n\t\t\t\t}\n\t\t\t\t\"LGET\" ->\n\t\t\t\t{\n\t\t\t\t\tif (Arg[1] is Int)\n\t\t\t\t\t{\n\t\t\t\t\t\tOpGoto(Arg[0]!!)\n\t\t\t\t\t\tOpAdd(Arg[1] as Int)\n\t\t\t\t\t\tOutput += \"[->+>+<<]\"\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tOpCopy(Arg[1]!!,arrayOf(-1 - (Var[OpSolveVar(Arg[0] as String)] as Array<Int>)[0],\n\t\t\t\t\t\t\t-2 - (Var[OpSolveVar(Arg[0] as String)] as Array<Int>)[0]),Arg[0]!!,false)\n\t\t\t\t\tOpGoto(Arg[0]!!)\n\t\t\t\t\tOutput += \">[>>>[-<<<<+>>>>]<<[->+<]<[->+<]>-]\" +\n\t\t\t\t\t\t\">>>[-<+<<+>>>]<<<[->>>+<<<]>\" +\n\t\t\t\t\t\t\"[[-<+>]>[-<+>]<<<<[->>>>+<<<<]>>-]<<\"\n\t\t\t\t\tOpClear(Arg[2]!!)\n\t\t\t\t\tOpMove(Arg[0]!!,Arg[2]!!,3)\n\t\t\t\t}\n\t\t\t\t\"IFEQ\",\"WEQ\" ->\n\t\t\t\t{\n\t\t\t\t\tOpIFWhile(Arg,true)\n\t\t\t\t\tOutput += '['\n\t\t\t\t\tOpClear(0,true)\n\t\t\t\t\tNeedIndent = true\n\t\t\t\t}\n\t\t\t\t\"IFNEQ\" ->\n\t\t\t\t{\n\t\t\t\t\tOpIFWhile(Arg)\n\t\t\t\t\tOutput += '['\n\t\t\t\t\tOpClear(0,true)\n\t\t\t\t\tNeedIndent = true\n\t\t\t\t}\n\t\t\t\t\"WNEQ\" ->\n\t\t\t\t{\n\t\t\t\t\tif (0 != Arg[1])\n\t\t\t\t\t{\n\t\t\t\t\t\tOpIFWhile(Arg)\n\t\t\t\t\t\tOutput += '['\n\t\t\t\t\t\tOpClear(0,true)\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tOpGoto(Arg[0]!!)\n\t\t\t\t\t\tOutput += '['\n\t\t\t\t\t}\n\t\t\t\t\tNeedIndent = true\n\t\t\t\t}\n\t\t\t\t\"END\" ->\n\t\t\t\t{\n\t\t\t\t\tif (null != Arg[0])\n\t\t\t\t\t{\n\t\t\t\t\t\tCommand = AST[Arg[0] as Int][0] as String\n\t\t\t\t\t\tArg = AST[Arg[0] as Int][1] as List<*>\n\t\t\t\t\t\tif (\"WEQ\" == Command)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tOpIFWhile(Arg,true)\n\t\t\t\t\t\t\tOpGoto(0)\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (\"WNEQ\" == Command)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (0 != Arg[1])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tOpIFWhile(Arg)\n\t\t\t\t\t\t\t\tOpGoto(0)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse OpGoto(Arg[0]!!)\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tOpClear(0)\n\t\t\t\t\t\t\tOpGoto(0)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tOutput += ']'\n\t\t\t\t\t}\n\t\t\t\t\telse NeedNewLine = false\n\t\t\t\t}\n\t\t\t\t\"CALL\" ->\n\t\t\t\t{\n\t\t\t\t\tArg = Arg[0] as List<*>\n\t\t\t\t\tval Arg0 = Arg[0] as String\n\t\t\t\t\tval Arg1 = Arg[1] as MutableList<String>\n\t\t\t\t\tval NextMessage = \"$CallStackMessage\n\\tat line $Line, procedure $Arg0\"\n\t\t\t\t\tif (!Proc.containsKey(Arg0)) ErrorNoProc(arrayOf(Arg0,NextMessage))\n\t\t\t\t\tval T = Proc[Arg0]!!\n\t\t\t\t\tProcVar = T[1] as MutableList<String>\n\t\t\t\t\tProcVarType = T[2] as MutableList<Array<Any>?>\n\t\t\t\t\tProcSig = T[3] as String\n\t\t\t\t\tif (ProcVar!!.size != Arg1.size)\n\t\t\t\t\t\tErrorProcLength(arrayOf(Arg0,ProcVar!![0].length,Arg1.size,NextMessage))\n\t\t\t\t\tif (CallStack.contains(Arg0)) ErrorRecursive(NextMessage)\n\t\t\t\t\tCallStack.add(Arg0)\n\t\t\t\t\tif (Origin) Output += Escape(ProcSig!!) + '\n'\n\t\t\t\t\tval D = mutableMapOf<String,String>()\n\t\t\t\t\tProcVar!!.forEachIndexed{F,V ->\n\t\t\t\t\t\tD[V] = OpSolveVar(Arg1[F])\n\t\t\t\t\t\tif (null != ProcVarType!![F])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tval T = ProcVarType!![F]!![0] as Boolean\n\t\t\t\t\t\t\tif (T != (Var[D[V]] is Int))\n\t\t\t\t\t\t\tErrorArgTypeMismatch(arrayOf\n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\tif (T) \"variable\" else \"list\",\n\t\t\t\t\t\t\t\tV,\n\t\t\t\t\t\t\t\tProcSig,\n\t\t\t\t\t\t\t\tArg1[F],\n\t\t\t\t\t\t\t\tif (T) \"list\" else \"variable\"\n\t\t\t\t\t\t\t))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tGenerate(Proc[Arg0]!![0] as MutableList<Array<Any>>,D,CallStack,NextMessage,CurrentIndent + Indent)\n\t\t\t\t\tNeedNewLine = false\n\t\t\t\t\tCallStack.pop()\n\t\t\t\t}\n\t\t\t\t\"READ\" ->\n\t\t\t\t{\n\t\t\t\t\tOpGoto(Arg[0]!!)\n\t\t\t\t\tOutput += ','\n\t\t\t\t}\n\t\t\t\t\"MSG\",\"LN\" ->\n\t\t\t\t{\n\t\t\t\t\t(Arg[0] as MutableList<Pair<Int,String>>).forEach{(Type,Value) ->\n\t\t\t\t\t\tif (0 == Type) OpMsgList(Value)\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tOpGoto(Value)\n\t\t\t\t\t\t\tOutput += '.'\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (\"LN\" == Command) OpMsgList(\"\n\")\n\t\t\t\t}\n\t\t\t\t\"DEBUG\" -> Output += '_'\n\t\t\t\t\"STOP\" -> Output += '!'\n\t\t\t}\n\t\t\tif (Origin)\n\t\t\t{\n\t\t\t\tif (NeedNewLine) Output += '\n'\n\t\t\t\tif (NeedIndent) CurrentIndent += Indent\n\t\t\t}\n\t\t}\n\t}\n\n\tRawCode.split('\n').forEach{V ->\n\t\t++Line\n\t\tCode = V\n\t\tCodeAt = 0\n\t\tWhite()\n\t\tif (!Taste().isEmpty())\n\t\t{\n\t\t\tval W = Word()\n\t\t\tif (!Machine.containsKey(W)) ErrorCommand(W)\n\t\t\tif (Machine[W] is Array<*>)\n\t\t\t\tCurrentAST.add(arrayOf(W,(Machine[W] as Array<() -> Any>).map{it()},Line,Code.trim()))\n\t\t\telse (Machine[W] as () -> Any)()\n\t\t\tif (!Taste().isEmpty()) ErrorCommandEnd(Taste())\n\t\t\tif (Origin && \"VAR\" == W) Output += Code.trim() + '\n'\n\t\t}\n\t}\n\tif (0 < ASTStack.size) ErrorEndUnclose(null)\n\n\tGenerate(AST)\n\treturn if (Origin) \"Preserved $PreserveMax\n$Output\" else Output.substring(Preserve - PreserveMax)\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}],"5b86a6d7a4dcc13cd900000b":[{"id":208832,"user_id":179,"body":"package kata\n\nobject FluxPuzzle {\n\n    fun mazeSolver(r: Array<IntArray>): Array<String>? {\n        val start = findPosOfValue(r, -1) ?: error(\"Illegal State!\")\n        val destination = findPosOfValue(r, -2) ?: error(\"Illegal State!\")\n        val field = Field(r.first().size, r.size)\n        processField(r) { pos, v ->\n            if (v > 0) {\n                val n = checkSide(v, 0b1000)\n                val e = checkSide(v, 0b0001)\n                val s = checkSide(v, 0b0010)\n                val w = checkSide(v, 0b0100)\n                field.set(pos, Cell(n, e, s, w))\n            }\n        }\n        val path = Model(field, start, destination).path ?: return null\n        val list = mutableListOf<String>()\n        var curr: Path? = path\n        while (curr != null) {\n            list.add(0, curr.trail.joinToString(\"\"))\n            curr = curr.parent\n        }\n        return list.toTypedArray()\n    }\n\n    fun checkSide(value: Int, mask: Int) = if (value and mask == mask) Side.BLOCKED else Side.FREE\n\n    fun findPosOfValue(r: Array<IntArray>, value: Int): Pair<Int, Int>? {\n        processField(r) { pos, v ->\n            if (v == value) return pos\n        }\n        return null\n    }\n\n    inline fun processField(r: Array<IntArray>, block: (Pair<Int, Int>, Int) -> Unit) {\n        r.first().indices.forEach { x ->\n            r.indices.forEach { y ->\n                block(x to y, r[y][x])\n            }\n        }\n    }\n\n    class Model(val field : Field, val start: Pair<Int, Int>, val destination: Pair<Int, Int>) {\n\n        private var visited = setOf<Pair<Int, Int>>()\n\n        val path: Path? = findPath()\n\n        private fun findPath(): Path? {\n            var undone = findAllTrails(Path(start, listOf(), null))\n            while (undone.isNotEmpty()) {\n                undone.filter { it.pos == destination }.forEach { return it }\n                field.rotate()\n                undone = undone\n                    .filter { isUndone(it) }\n                    .map { findAllTrails(Path(it.pos, listOf(), it)) }\n                    .flatten()\n            }\n            return null\n        }\n\n        private fun findAllTrails(path: Path): List<Path> {\n            visited += path.pos\n            var list = listOf(path)\n            Direction.values().forEach {\n                val pos = path.pos\n                val nextPos = pos.move(it.v)\n                if (field.isWalkable(pos, it) && !visited.contains(nextPos)) {\n                    val nextPath = Path(nextPos, path.trail + it, path.parent)\n                    list += findAllTrails(nextPath)\n                }\n            }\n            return list\n        }\n\n        private fun isUndone(path: Path): Boolean {\n            var current: Path? = path\n            (0 until 4).forEach {  _ ->\n                current ?: return true\n                if (current!!.trail.isNotEmpty()) return true\n                current = current!!.parent\n            }\n            return false\n        }\n    }\n\n    class Path(val pos: Pair<Int, Int>, val trail: List<Direction> = listOf(), val parent: Path? = null)\n\n    class Field(val width: Int, val height: Int) {\n\n        val field: Array<Array<Cell>> = (0 until width).map { (0 until height).map { Cell() }.toTypedArray() }.toTypedArray()\n\n        fun set(pos: Pair<Int, Int>, cell: Cell) {\n            field[pos.first][pos.second] = cell\n        }\n\n        fun get(pos: Pair<Int, Int>) = field[pos.first][pos.second]\n\n        fun isWalkable(pos: Pair<Int, Int>, dir: Direction): Boolean {\n            val wantedPos = pos.move(dir.v)\n            if (!inBounds(wantedPos)) return false\n            val currentCell = get(pos)\n            val wantedCell = get(wantedPos)\n            return when (dir) {\n                Direction.N -> currentCell.n == Side.FREE && wantedCell.s == Side.FREE\n                Direction.E -> currentCell.e == Side.FREE && wantedCell.w == Side.FREE\n                Direction.S -> currentCell.s == Side.FREE && wantedCell.n == Side.FREE\n                Direction.W -> currentCell.w == Side.FREE && wantedCell.e == Side.FREE\n            }\n        }\n\n        fun inBounds(pos: Pair<Int, Int>) = when {\n            pos.first < 0 -> false\n            pos.second < 0 -> false\n            pos.first > width - 1 -> false\n            pos.second > height - 1 -> false\n            else -> true\n        }\n\n        fun rotate() {\n            (0 until width).forEach { x ->\n                (0 until height).forEach { y ->\n                    field[x][y] = field[x][y].rotate()\n                }\n            }\n        }\n    }\n\n    data class Cell(val n: Side = Side.FREE, val e: Side = Side.FREE, val s: Side = Side.FREE, val w: Side = Side.FREE) {\n        fun rotate() = Cell(w, n, e, s)\n    }\n\n    enum class Side { BLOCKED, FREE }\n\n    enum class Direction(val v: Pair<Int, Int>) {\n        N(0 to -1), E(1 to 0), S(0 to 1), W(-1 to 0)\n    }\n}\n\nfun Pair<Int, Int>.move(v: Pair<Int, Int>) = (this.first + v.first) to (this.second + v.second)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208833,"user_id":null,"body":"package kata\n\nimport java.awt.Point\n\nenum class Direction(val key: Char, val dx: Int, val dy: Int, val wallBit: Int) {\n    NORTH('N', 0, -1, 3), WEST('W', -1, 0, 2), SOUTH('S', 0, 1, 1), EAST('E', 1, 0, 0);\n\n    fun offset(point: Point) = Point(point.x + this.dx, point.y + this.dy)\n}\n\nval wallCycleLength = Direction.values().size\n\ndata class FluxMaze(val maze: Array<IntArray>) {\n    val start = Point(0, maze.indices.first { maze[it].first() == -1 })\n    val finish = Point(maze[0].lastIndex, maze.indices.first { maze[it].last() == -2 })\n    private val mazeData = maze.map { ints -> ints.map { kotlin.math.max(it, 0) }.toIntArray() }.toTypedArray()\n    init {\n        listOf(start, finish).forEach { mazeData[it.y][it.x] = 0 }\n    }\n    fun move(point: Point, direction: Direction, timeTick: Int): Point? {\n        val newPoint = direction.offset(point)\n        if ((newPoint.x !in mazeData[0].indices) || (newPoint.y !in mazeData.indices)) return null\n        if (mazeData[point.y][point.x].and(1 shl ((timeTick * (wallCycleLength - 1) + direction.wallBit) % wallCycleLength)) != 0) return null\n        if (mazeData[newPoint.y][newPoint.x].and(1 shl ((timeTick * (wallCycleLength - 1) + direction.wallBit + wallCycleLength \/ 2) % wallCycleLength)) != 0) return null\n        return newPoint\n    }\n}\n\nclass FluxSolution : ArrayList<String>() {\n    fun with(char: Char): FluxSolution = FluxSolution().also {\n        it.addAll(this)\n        it[it.lastIndex] = it[it.lastIndex] + char\n    }\n}\n\nclass FluxSolutionMap : LinkedHashMap<Point, FluxSolution>()\n\nobject FluxPuzzle {\n    fun mazeSolver(r: Array<IntArray>): Array<String>? {\n        val maze = FluxMaze(r)\n        val solutionBuilder = FluxSolutionMap().apply { this[maze.start] = FluxSolution().apply { add(\"\") } }\n        var timeTick = 0\n        val pointsToProcess = Array(wallCycleLength) { mutableListOf(maze.start) }\n        while (maze.finish !in solutionBuilder) {\n            if (pointsToProcess.all { it.isEmpty() }) return null\n            while (pointsToProcess[timeTick % wallCycleLength].isNotEmpty()) {\n                val point = pointsToProcess[timeTick % wallCycleLength].removeLast()\n                Direction.values().associateWith { maze.move(point, it, timeTick) }\n                    .filterValues { (it != null) && (it !in solutionBuilder) }.mapValues { it.value!! }\n                    .forEach { (direction, newPoint) ->\n                        solutionBuilder[newPoint] = solutionBuilder[point]!!.with(direction.key)\n                        pointsToProcess.forEach { it.add(newPoint) }\n                    }\n            }\n            solutionBuilder.values.forEach { it.add(\"\") }\n            ++timeTick\n        }\n        return solutionBuilder[maze.finish]!!.dropLast(1).toTypedArray()\n    }\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208834,"user_id":null,"body":"package kata\n\nimport java.util.LinkedList\nimport java.util.Queue\n\n\nclass FluxPuzzleResolver(r: Array<IntArray>) {\n\n    private val visited: List<MutableList<Boolean>> = r.map { it.map { false }.toMutableList() }\n    private val start = r.coord(-1)\n    private val destination = r.coord(-2)\n    private val queueOfQueues: LinkedList<Queue<Visit>> = LinkedList<Queue<Visit>>()\n    private val configs = generateSequence(\n        seed = r.map { it.map { maxOf(0, it) } },\n        nextFunction = { it.map { it.map { (it shl 1).let { ((it and 0b10000) shr 4) or (it and 0b1110) } } }},\n    ).take(4).toList()\n\n    init {\n        visit(place = start, earliestPath = listOf(\"\"))\n    }\n\n    fun mazeSolver(): Array<String>? {\n\n        var epoch = 0\n        while (queueOfQueues.any { it.isNotEmpty() }) {\n            val queue = queueOfQueues.peek()\n            while (queue.isNotEmpty()) {\n                val visit = queue.poll()\n                val newVisits = visit.place().possibleMoves(epoch = epoch)\n                newVisits.forEach {\n                    val path = visit.path.appendToLast(it.first)\n                    val place = it.second\n                    if (place == destination)\n                        return@mazeSolver path.toTypedArray()\n                    visit(place = place, earliestPath = path)\n                }\n            }\n            queueOfQueues.poll()\n            epoch = (epoch + 1).mod(4)\n        }\n        return null \/\/ no solution\n    }\n\n    private fun Pair<Int, Int>.hasWall(direction: String, epoch: Int) =\n        epoch.mod(4).let { epoch ->\n            this.first < 0 || this.second < 0 || this.first >= configs[epoch].size || this.second >= configs[epoch][this.first].size ||\n                    configs[epoch][this.first][this.second].let { cfg ->\n                        when (direction) {\n                            \"E\" -> (cfg and 0b0001) != 0\n                            \"S\" -> (cfg and 0b0010) != 0\n                            \"W\" -> (cfg and 0b0100) != 0\n                            \"N\" -> (cfg and 0b1000) != 0\n                            else -> true\n                        }\n                    }\n        }\n\n    private fun Pair<Int, Int>.neighbour(direction: String) =\n        when (direction) {\n            \"E\" -> this.first to (this.second + 1)\n            \"S\" -> (this.first + 1) to this.second\n            \"W\" -> this.first to (this.second - 1)\n            \"N\" -> (this.first - 1) to this.second\n            else -> this\n        }\n\n    private fun String.opposite() =\n        when (this) {\n            \"E\" -> \"W\"\n            \"S\" -> \"N\"\n            \"W\" -> \"E\"\n            \"N\" -> \"S\"\n            else -> this\n        }\n\n    private fun Pair<Int, Int>.isLegal(direction: String, epoch: Int) =\n        !this.hasWall(direction = direction, epoch = epoch) &&\n                !this.neighbour(direction = direction).hasWall(direction = direction.opposite(), epoch = epoch)\n\n    private fun Pair<Int, Int>.possibleMoves(epoch: Int) =\n        listOf(\"E\", \"S\", \"W\", \"N\")\n            .filter { this.isLegal(direction = it, epoch = epoch) }\n            .map { it to this.neighbour(direction = it) }\n            .filter { !visited[it.second.first][it.second.second] }\n\n    private fun Array<IntArray>.coord(value: Int) =\n        this.withIndex().flatMap { idxdRow -> idxdRow.value.withIndex().filter { it.value == value }.map { Pair(idxdRow.index, it.index) } }.single()\n\n    private fun visit(place: Pair<Int, Int>, earliestPath: List<String>) {\n        while (queueOfQueues.size < 4)\n            queueOfQueues.add(LinkedList<Visit>())\n        (0..3).map { it to (earliestPath + List(it) { \"\" }) }.forEach {\n            queueOfQueues[it.first].add(Visit(path = it.second, place = place))\n        }\n        visited[place.first][place.second] = true\n    }\n\n    fun List<String>.appendToLast(direction: String) =\n        this.dropLast(1) + (this.takeLast(1)[0] + direction)\n\n    private data class Visit(\n        val path: List<String>,\n        val row: Int,\n        val col: Int,\n    ) {\n\n        constructor(path: List<String>, place: Pair<Int, Int>) : this(\n            path = path,\n            row = place.first,\n            col = place.second,\n        )\n\n        fun place() = row to col\n\n    }\n\n}\n\nobject FluxPuzzle {\n\n    fun mazeSolver(r: Array<IntArray>): Array<String>? =\n        FluxPuzzleResolver(r).mazeSolver()\n\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208835,"user_id":179,"body":"package kata\n\nobject FluxPuzzle {\n\n    fun mazeSolver(r: Array<IntArray>): Array<String>? {\n        val start = findPosOfValue(r, -1) ?: error(\"Illegal State!\")\n        val destination = findPosOfValue(r, -2) ?: error(\"Illegal State!\")\n        val field = Field(r.first().size, r.size)\n        processField(r) { pos, v ->\n            if (v > 0) {\n                val n = checkSide(v, 8)\n                val e = checkSide(v, 1)\n                val s = checkSide(v, 2)\n                val w = checkSide(v, 4)\n                field.set(pos, Cell(n, e, s, w))\n            }\n        }\n        val path = Model(field, start, destination).path ?: return null\n        var list = listOf<String>()\n        var curr = path\n        list += curr.trail.joinToString(\"\")\n        while (curr.parent != null) {\n            curr = curr.parent!!\n            list += curr.trail.joinToString(\"\")\n        }\n        return list.reversed().toTypedArray()\n    }\n\n    fun checkSide(value: Int, mask: Int) = if (value and mask == mask) Side.BLOCKED else Side.FREE\n\n    fun findPosOfValue(r: Array<IntArray>, value: Int): Pair<Int, Int>? {\n        processField(r) { pos, v ->\n            if (v == value) return pos\n        }\n        return null\n    }\n\n    inline fun processField(r: Array<IntArray>, block: (Pair<Int, Int>, Int) -> Unit) {\n        r.first().indices.forEach { x ->\n            r.indices.forEach { y ->\n                block(x to y, r[y][x])\n            }\n        }\n    }\n\n    class Model(val field : Field, val start: Pair<Int, Int>, val destination: Pair<Int, Int>) {\n\n        private var visited = setOf<Pair<Int, Int>>()\n\n        val path: Path? = findPath()\n\n        private fun findPath(): Path? {\n            var undone = findAllTrails(Path(start, listOf(), null))\n            undone.filter { it.pos == destination }.forEach { return it }\n            while (undone.isNotEmpty()) {\n                field.rotate()\n                undone = undone.filter { isUndone(it) }.map { p ->\n                    findAllTrails(Path(p.pos, listOf(), p)).apply {\n                        filter { it.pos == destination }.forEach { return it }\n                    }\n                }.flatten()\n            }\n            return null\n        }\n\n        private fun findAllTrails(path: Path): List<Path> {\n            visited += path.pos\n            var list = listOf(path)\n            Direction.values().forEach {\n                val pos = path.pos\n                val nextPos = pos.move(it.v)\n                if (field.isWalkable(pos, it) && !visited.contains(nextPos)) {\n                    val nextPath = Path(nextPos, path.trail + it, path.parent)\n                    list += findAllTrails(nextPath)\n                }\n            }\n            return list\n        }\n\n        private fun isUndone(path: Path): Boolean {\n            var current: Path? = path\n            (0 until 4).forEach {  _ ->\n                current ?: return true\n                if (current!!.trail.isNotEmpty()) return true\n                current = current!!.parent\n            }\n            return false\n        }\n    }\n\n    class Path(val pos: Pair<Int, Int>, val trail: List<Direction> = listOf(), val parent: Path? = null)\n\n    class Field(val width: Int, val height: Int) {\n\n        val field: Array<Array<Cell>> = (0 until width).map { (0 until height).map { Cell() }.toTypedArray() }.toTypedArray()\n\n        fun set(pos: Pair<Int, Int>, cell: Cell) {\n            field[pos.first][pos.second] = cell\n        }\n\n        fun get(pos: Pair<Int, Int>) = field[pos.first][pos.second]\n\n        fun isWalkable(pos: Pair<Int, Int>, dir: Direction): Boolean {\n            val wantedPos = pos.move(dir.v)\n            if (!inBounds(wantedPos)) return false\n            val currentCell = get(pos)\n            val wantedCell = get(wantedPos)\n            return when (dir) {\n                Direction.N -> currentCell.n == Side.FREE && wantedCell.s == Side.FREE\n                Direction.E -> currentCell.e == Side.FREE && wantedCell.w == Side.FREE\n                Direction.S -> currentCell.s == Side.FREE && wantedCell.n == Side.FREE\n                Direction.W -> currentCell.w == Side.FREE && wantedCell.e == Side.FREE\n            }\n        }\n\n        fun inBounds(pos: Pair<Int, Int>) = when {\n            pos.first < 0 -> false\n            pos.second < 0 -> false\n            pos.first > width - 1 -> false\n            pos.second > height - 1 -> false\n            else -> true\n        }\n\n        fun rotate() {\n            (0 until width).forEach { x ->\n                (0 until height).forEach { y ->\n                    field[x][y] = field[x][y].rotate()\n                }\n            }\n        }\n    }\n\n    data class Cell(val n: Side = Side.FREE, val e: Side = Side.FREE, val s: Side = Side.FREE, val w: Side = Side.FREE) {\n        fun rotate() = Cell(w, n, e, s)\n    }\n\n    enum class Side { BLOCKED, FREE }\n\n    enum class Direction(val v: Pair<Int, Int>) {\n        N(0 to -1), E(1 to 0), S(0 to 1), W(-1 to 0)\n    }\n}\n\nfun Pair<Int, Int>.move(v: Pair<Int, Int>) = (this.first + v.first) to (this.second + v.second)","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"},{"id":208836,"user_id":470,"body":"package kata\n\nobject FluxPuzzle {\n\tfun mazeSolver(r: Array<IntArray>): Array<String>? {\n\t\tval grid = r.map { rr -> rr.map { n -> Math.max(0,n) }.toIntArray() }.toTypedArray()\n\t\tval xl = r.size\n\t\tval yl = r[0].size\n\t\tvar pos = -1 to -1\n\t\tvar exz = -1 to -1\n\t\tr.forEachIndexed { i,row -> if (row[0] == -1) { pos = i to 0}; if (row[yl-1] == -2) { exz = i to (yl-1) } }\n\t\t\n\t\t\/\/ verify clear path from one cell to adjacent cell\n\t\tfun clearanceCheck(p1: Pair<Int,Int>,p2: Pair<Int,Int>,phase: Int,dn: Int): Boolean {\n\t\t\tval cel1 = quadPhases[grid[p1.first][p1.second]][phase]\n\t\t\tval cel2 = quadPhases[grid[p2.first][p2.second]][phase]\n\t\t\treturn cel1 and (8 shr dn) == 0 && cel2 and (8 shr (dn+2)%4) == 0\n\t\t}\n\t\t\n\t\t\/\/ get all connected cells for interval `phase`\n\t\tfun clusterScan(xy: Pair<Int,Int>,phase: Int): Set<Pair<Int,Int>> {\n\t\t\tval zet: MutableSet<Pair<Int,Int>> = mutableSetOf()\n\t\t\tvar ix = mutableSetOf<Pair<Int,Int>>(xy)\n\t\t\twhile (!ix.isEmpty()) {\n\t\t\t\tzet.addAll(ix)\n\t\t\t\tval newPts = mutableSetOf<Pair<Int,Int>>()\n\t\t\t\tix.forEach {\n\t\t\t\t\tval (x,y) = it\n\t\t\t\t\tfor ((i,dxy) in dList.withIndex()) {\n\t\t\t\t\t\tval nx = x + dxy.first\n\t\t\t\t\t\tval ny = y + dxy.second\n\t\t\t\t\t\tval nxy = Pair(nx,ny)\n\t\t\t\t\t\tif (nx >= 0 && nx < xl && ny >= 0 && ny < yl && !zet.contains(nxy) && clearanceCheck(it,nxy,phase,i)) { newPts.add(nxy) }}}\n\t\t\t\tix = newPts }\n\t\t\treturn zet\n\t\t}\n\t\t\n\t\t\/\/ get array of clusters for interval `n`\n\t\tfun groupClusters(n: Int): Array<Set<Pair<Int,Int>>> {\n\t\t\tval clusterGroups = mutableListOf<Set<Pair<Int,Int>>>()\n\t\t\tval countedCells = mutableSetOf<Pair<Int,Int>>()\n\t\t\tfor (i in 0 until xl) {\n\t\t\t\tfor (j in 0 until yl) {\n\t\t\t\t\tval xy = i to j\n\t\t\t\t\tif (!countedCells.contains(xy)) clusterScan(xy,n).let { clusterGroups.add(it); countedCells.addAll(it) }}}\n\t\t\treturn clusterGroups.toTypedArray()\n\t\t}\n\t\t\n\t\t\/\/ get path from one cell to another\n\t\tfun findPath(p1: Pair<Int,Int>,p2: Pair<Int,Int>,cluster: Set<Pair<Int,Int>>,phase: Int): String {\n\t\t\tif (p1 == p2) return \"\"\n\t\t\tval walked = mutableSetOf<Pair<Int,Int>>()\n\t\t\tvar xyGroup = mutableListOf(p1 to StringBuilder())\n\t\t\twhile (!xyGroup.none()) {\n\t\t\t\tval nxtGroup = mutableListOf<Pair<Pair<Int,Int>,StringBuilder>>()\n\t\t\t\tfor ((xy,sb) in xyGroup) {\n\t\t\t\t\tdList.forEachIndexed { c,dxy -> Pair(dxy.first + xy.first,dxy.second + xy.second).let {\n\t\t\t\t\t\tif (it in cluster && !walked.contains(it) && clearanceCheck(xy,it,phase,c)) {\n\t\t\t\t\t\t\tval nsb = StringBuilder(sb).append(dirs[c])\n\t\t\t\t\t\t\tnxtGroup.add(it to nsb)\n\t\t\t\t\t\t\tif (it == p2) return nsb.toString()\n\t\t\t\t\t\t\twalked.add(it) } } } }\n\t\t\t\txyGroup = nxtGroup\n\t\t\t}\n\t\t\treturn \"\"\n\t\t}\n\t\t\n\t\t\/\/ 4 phases -> cluster of connected cells (set of points)\n\t\tval tome: Array<Array<Set<Pair<Int,Int>>>> = Array(4,::groupClusters)\n\t\t\/\/ 4 phases -> matrix of group # each cell belongs to\n\t\tval codex: Array<Array<IntArray>> = Array(4,{ tome[it].foldIndexed(Array(xl,{ MutableList<Int>(yl,{ 0 }) }),{ i,rr,set -> set.forEach { (x,y) -> rr[x][y] = i }; rr }).map { rr -> rr.toIntArray() }.toTypedArray() })\n\t\t\/\/ 4 phases -> step for each cluster per phase\n\t\tval tracker: Array<MutableMap<Int,Int>> = Array(4,{ (0 until tome[it].size).map { c -> c to -1 }.toMap().toMutableMap() })\n\t\t\n\t\tval iniGroup = codex[0][pos.first][pos.second]\n\t\tvar cGroups = mutableSetOf(iniGroup)\n\t\tvar endGroup: Int? = null\n\t\tvar i = 0\n\t\tvar j = -1\n\t\t\n\t\ttracker[0][iniGroup] = -2\n\t\texzSeek@ while (!cGroups.none()) {\n\t\t\tj = (i+1) % 4\n\t\t\tval nGroups = mutableSetOf<Int>()\n\t\t\tfor (grpID in cGroups) {\n\t\t\t\tval group: Set<Pair<Int,Int>> = tome[i%4][grpID]\n\t\t\t\tfor ((x,y) in group) {\n\t\t\t\t\tval nxt = codex[j][x][y]\n\t\t\t\t\tif (codex[j][exz.first][exz.second] == nxt) {\n\t\t\t\t\t\tendGroup = nxt\n\t\t\t\t\t\ttracker[j][nxt] = grpID\n\t\t\t\t\t\tbreak@exzSeek }\n\t\t\t\t\tif (!nGroups.contains(nxt) && tracker[j][nxt] == -1) {\n\t\t\t\t\t\tnGroups.add(nxt)\n\t\t\t\t\t\ttracker[j][nxt] = grpID\n\t\t\t\t\t} } }\n\t\t\tcGroups = nGroups\n\t\t\ti++\n\t\t}\n\t\t\n\t\treturn if (endGroup == null) null else\n\t\tsequence {\n\t\t\twhile (endGroup != -2) {\n\t\t\t\tyield(endGroup)\n\t\t\t\tendGroup = tracker[j][endGroup]\n\t\t\t\tj = (j + 3) % 4 } }\n\t\t.toList()\n\t\t.asReversed()\n\t\t.windowed(size=2)\n\t\t.mapIndexed { q,cn ->\n\t\t\tval cluster = tome[q%4][cn[0]!!]\n\t\t\tval nextPt = cluster.intersect(tome[(q+1)%4][cn[1]!!]).first()\n\t\t\tfindPath(pos,nextPt,cluster,q%4).also { pos = nextPt } }\n\t\t.plusElement(findPath(pos,exz,tome[++i%4][codex[i%4][exz.first][exz.second]],i%4))\n\t\t.toTypedArray()\n\t}\n\t\n\tprivate fun celRot(n: Int): Int = (n shl 1).let { it\/16 + it%16 }\n\tprivate val dList = arrayOf(-1 to 0, 0 to -1, 1 to 0, 0 to 1)\n\tprivate val dirs = charArrayOf('N','W','S','E')\n\t\/\/ private val quadPhases = (0..15).map { (0..2).scan(it,{ x,_ -> celRot(x) }).toIntArray() }.toTypedArray()\/\/ Kotlin 1.4\n\tprivate val quadPhases = (0..15).map { n -> var v = n; (0..3).map { _ -> v.also { v = celRot(v) } }.toIntArray() }.toTypedArray()\/\/ CW runner uses Kotlin 1.3\n}","lang_id":29,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:29","updated_at":"2022-12-30 18:39:29"}]}