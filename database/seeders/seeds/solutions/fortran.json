{"50654ddff44f800200000004":[{"id":82757,"user_id":null,"body":"function multiply(a, b) result(c)\n integer, intent(in) :: a, b\n integer             :: c\n c = a * b\nend function multiply\n","lang_id":19,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82758,"user_id":1228,"body":"pure function century(year) result (res)\n integer, intent(in) :: year\n res = ((year - 1) \/ 100 + 1) ! your code here\nend function century","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82759,"user_id":null,"body":"function multiply(a, b)\n    integer :: a, b, multiply\n    multiply = a * b\n    return\n  end function multiply","lang_id":19,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82760,"user_id":492,"body":"module Solution\n  implicit none\ncontains\n  function multiply(a, b)\n    integer :: a, b, multiply\n    multiply = a * b\n  end function multiply\nend module Solution","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82761,"user_id":2582,"body":"module Solution\n  implicit none\ncontains\n  function multiply(a, b)\n    integer :: multiply, a, b\n    multiply = a * b\n  end function multiply\nend module Solution","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82762,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer function multiply(a, b)\n    integer :: a, b\n    multiply = a * b\n    return\n  end function multiply\nend module Solution","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82763,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function multiply(a, b)\n    integer, intent(in) :: a, b\n    integer :: multiply\n    multiply = a * b\n  end function multiply\nend module Solution","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82764,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  function multiply(a, b)\n    integer multiply, a, b\n    multiply = a * b\n  end function multiply\nend module Solution","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82765,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer function multiply(a, b)\n    integer :: a, b\n    multiply = a * b\n  end function multiply\nend module Solution","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82766,"user_id":527,"body":"module Solution\n  implicit none\ncontains\n  function multiply(a, b)\n    integer, intent(in) :: a, b\n    integer :: multiply\n    multiply = a * b\n  end function multiply\nend module Solution","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"52742f58faf5485cae000b9a":[{"id":82767,"user_id":null,"body":"MODULE Solution\n    IMPLICIT NONE\n    PUBLIC:: format_duration\n    PRIVATE\n  CONTAINS\n    FUNCTION format_duration(seconds) RESULT(str)\n      INTEGER, INTENT(IN):: seconds\n      CHARACTER(len = 60):: str\n      character(len=:), allocatable :: str_int\n      integer :: internal, years, days, hours, minutes\n      integer, parameter :: mseconds = 1, &\n                            mminutes = 60*mseconds, &\n                            mhours = 60*mminutes, &\n                            mdays = 24*mhours, &\n                            myears = 365*mdays\n      logical :: and\n      and = .false.\n      str_int = repeat(\" \", 60)\n      if(seconds .eq. 0) then\n        str_int = \"now\" \/\/ str_int\n      else\n        internal = seconds\n        years = internal \/ myears\n        internal = internal - years*myears\n        days = internal \/ mdays\n        internal = internal - days*mdays\n        hours = internal \/ mhours\n        internal = internal - hours*mhours\n        minutes = internal \/ mminutes\n        internal = internal - minutes*mminutes\n        str_int = add(internal, \"second\") \/\/ str_int\n        str_int = add(minutes,  \"minute\") \/\/ str_int\n        str_int = add(hours,    \"hour\")   \/\/ str_int\n        str_int = add(days,     \"day\")    \/\/ str_int\n        str_int = add(years,    \"year\")   \/\/ str_int\n      end if\n      str = str_int(1:60)\n    contains\n      function add(duration, name) result(tmp)\n        integer, intent(in) :: duration\n        character(len=*) :: name\n        character(len=:), allocatable :: tmp\n        tmp = \"\"\n        if(duration .ne. 0) then\n          tmp = to_str(duration) \/\/ \" \" \/\/ name\n          if(duration .gt. 1) tmp = tmp \/\/ \"s\"\n          if(str_int(1:1) .ne. \" \") then\n            if(.not.and) then\n              and = .true.\n              tmp = tmp \/\/ \" and \"\n            else\n              tmp = tmp \/\/ \", \"\n            end if\n          end if\n        end if\n      end function add\n      function to_str(int) result(str)\n        integer, intent(in) :: int\n        character(len=10) :: tmp\n        character(len=:), allocatable :: str\n        write(tmp, '(I0)') int\n        str = trim(tmp)\n      end function to_str\n    END FUNCTION format_duration\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82768,"user_id":null,"body":"MODULE Solution\n    IMPLICIT NONE\n    PUBLIC:: format_duration\n    PRIVATE\n  CONTAINS\n    PURE FUNCTION format_duration(seconds) RESULT(str)\n      INTEGER, INTENT(IN):: seconds\n      CHARACTER(len = 60):: str\n      ! your code here\n      integer :: years, days, hours, minutes, rest\n      CHARACTER(len = 10) :: num\n      str = \"now\"\n      if (seconds == 0) return\n      str = \"\"\n      years = seconds \/ 60 \/ 60 \/ 24 \/ 365\n      days = mod(seconds \/ 60 \/ 60 \/ 24, 365)\n      hours = mod(seconds \/ 60 \/ 60, 24)\n      minutes = mod(seconds \/ 60, 60)\n      rest = mod(seconds, 60)\n      if (years \/= 0) then\n          write(num, '(i10)') years\n          str = trim(str) \/\/ trim(adjustl(num)) \/\/ \" year\"\n          if (years > 1) str = trim(str) \/\/ \"s\"\n      end if\n      if (days \/= 0) then\n          write(num, '(i3)') days\n          if (str \/= \"\" .and. hours + minutes + rest \/= 0) str = trim(str) \/\/ \", \"\n          if (str \/= \"\" .and. hours + minutes + rest == 0) str = trim(str) \/\/ \" and \"\n          str = trim(str) \/\/ \" \" \/\/ trim(adjustl(num)) \/\/ \" day\"\n          if (days > 1) str = trim(str) \/\/ \"s\"\n      end if\n      if (hours \/= 0) then\n          write(num, '(i2)') hours\n          if (str \/= \"\" .and. minutes + rest \/= 0) str = trim(str) \/\/ \", \"\n          if (str \/= \"\" .and. minutes + rest == 0) str = trim(str) \/\/ \" and \"\n          str = trim(str) \/\/ \" \" \/\/ trim(adjustl(num)) \/\/ \" hour\"\n          if (hours > 1) str = trim(str) \/\/ \"s\"\n      end if\n      if (minutes \/= 0) then\n          write(num, '(i2)') minutes\n          if (str \/= \"\" .and. rest \/= 0) str = trim(str) \/\/ \", \"\n          if (str \/= \"\" .and. rest == 0) str = trim(str) \/\/ \" and \"\n          str = trim(str) \/\/ \" \" \/\/ trim(adjustl(num)) \/\/ \" minute\"\n          if (minutes > 1) str = trim(str) \/\/ \"s\"\n      end if\n      if (rest \/= 0) then\n          write(num, '(i2)') rest\n          if (str \/= \"\") str = trim(str) \/\/ \" and \"\n          str = trim(str) \/\/ \" \" \/\/ trim(adjustl(num)) \/\/ \" second\"\n          if (rest > 1) str = trim(str) \/\/ \"s\"\n      end if\n      str = adjustl(trim(str))\n    END FUNCTION format_duration\n  END MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82769,"user_id":null,"body":"MODULE Solution\n    IMPLICIT NONE\n    PUBLIC:: format_duration\n    PRIVATE\n  CONTAINS\n    FUNCTION format_duration(s) RESULT(str)\n      INTEGER:: s\n      CHARACTER(len = 60):: str\n      CHARACTER(len = 6), dimension(5):: periods\n      CHARACTER(len = 6) :: tag\n      INTEGER, dimension(5) :: sec_in_period\n      INTEGER :: seconds, period_value,i\n      \n      seconds = s\n      periods = [\"year  \", \"day   \",\"hour  \",\"minute\", \"second\"]\n      sec_in_period = (\/31536000,86400,3600,60,1\/)\n      \n      \n      if (seconds == 0) then\n        str = 'now'\n        return\n      end if\n      \n      str = \"\"\n      do i = 1,5 \n        period_value = seconds \/ sec_in_period(i)\n         if (period_value > 0) then\n          seconds = seconds - period_value * sec_in_period(i)\n          ! add connecter\n          if (str \/= \"\") then\n            if (seconds > 0 ) then \n              str = trim(str) \/\/ \", \"\n            else\n              str = trim(str) \/\/ \" and \"\n            end if\n          end if\n          ! convert integer to string ! need to adjust here the number of white spaces\n          write(tag,'(I4)') period_value \n          if (period_value < 10) then\n            tag = tag(3:)\n          else if (period_value < 100) then\n            tag = tag(2:)\n          end if\n          str = trim(str) \/\/ trim(tag) \/\/ \" \" \/\/ trim(periods(i))\n          ! add s\n          if (period_value > 1) then\n            str = trim(str) \/\/ \"s\"\n          end if\n        end if\n      end do\n      str = trim(str(2:))\n    END FUNCTION format_duration\n  END MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"53ee5429ba190077850011d4":[{"id":82770,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function double_integer(n)\n    integer, intent(in) :: n\n    ! n will be an integer. Double it and return it.\n    double_integer = 2.0 * n;\n  end function double_integer\nend module Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82771,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function double_integer(n)\n    integer, intent(in) :: n\n    ! n will be an integer. Double it and return it.\n    double_integer = n * 2\n  end function double_integer\nend module Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82772,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function double_integer(n)\n    integer, intent(in) :: n\n    ! n will be an integer. Double it and return it.\n    double_integer = 2 * n\n  end function double_integer\nend module Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82773,"user_id":812,"body":"module Solution\n  implicit none\ncontains\n  integer pure function double_integer(n)\n    integer, intent(in) :: n\n    ! n will be an integer. Double it and return it.\n    double_integer = n * 2\n    return\n    double_integer = 0\n  end function double_integer\nend module Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82774,"user_id":53,"body":"module Solution\n  implicit none\ncontains\n  integer pure function double_integer(n)\n    integer, intent(in) :: n\n    double_integer = n + n\n  end function double_integer\nend module Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82775,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function double_integer(n)\n    integer, intent(in) :: n\n    ! n will be an integer. Double it and return it.\n    double_integer = 2 * n\n    return\n  end function double_integer\nend module Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82776,"user_id":527,"body":"module Solution\n  implicit none\ncontains\n  integer pure function double_integer(n)\n    integer, intent(in) :: n\n    double_integer = n * 2\n  end function double_integer\nend module Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82777,"user_id":564,"body":"module Solution\n  implicit none\ncontains\n  integer pure function double_integer(n)\n    integer, intent(in) :: n\n    double_integer = 2 * n\n  end function double_integer\nend module Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"54d496788776e49e6b00052f":[{"id":82778,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  FUNCTION sum_of_divided(lst) RESULT(str)\n    INTEGER, INTENT(IN) :: lst(:) \n    INTEGER :: rem(SIZE(lst))\n    INTEGER :: i, max, el, fac, is_factor, tot\n    CHARACTER(:), allocatable :: str\n    CHARACTER (LEN=64) :: tmp\n\n    max = ABS(lst(1)); str = \"\"\n    DO i = 1, SIZE(lst)\n      el = ABS(lst(i))\n      rem(i) = el\n      IF (el > max) THEN\n        max = el\n      END IF\n    END DO\n    DO fac = 2, max\n      is_factor = 0\n      tot = 0\n      DO i = 1, SIZE(lst)\n        el = rem(i)\n        IF (MOD(ABS(el), fac) == 0) THEN\n          is_factor = 1\n          tot = tot + lst(i)\n          DO WHILE (MOD(ABS(el), fac) == 0)\n            el = el \/ fac\n          END DO\n          rem(i) = el\n        END IF\n      END DO\n      IF (is_factor == 1) THEN\n        WRITE(tmp, fmt=\"(A, I0, A, I0, A)\") \"(\", fac, \" \", tot, \")\"\n        str = TRIM(str) \/\/ tmp\n      END IF\n    END DO\n    el = LEN(TRIM(str))\n    str = str(1:el)\n  END FUNCTION sum_of_divided\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82779,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  FUNCTION sum_of_divided(lst) RESULT(str)\n    INTEGER, INTENT(IN) :: lst(:) \n    INTEGER :: rem(SIZE(lst))\n    INTEGER :: i, max, el, fac, is_factor, tot\n    CHARACTER(:), allocatable :: str\n    CHARACTER (LEN=64) :: tmp\n\n    max = ABS(lst(1)); str = \"\"\n    DO i = 1, SIZE(lst)\n      el = ABS(lst(i))\n      rem(i) = el\n      IF (el > max) THEN\n        max = el\n      END IF\n    END DO\n    DO fac = 2, max\n      is_factor = 0\n      tot = 0\n      DO i = 1, SIZE(lst)\n        el = rem(i)\n        IF (MOD(ABS(el), fac) == 0) THEN\n          is_factor = 1\n          tot = tot + lst(i)\n          DO WHILE (MOD(ABS(el), fac) == 0)\n            el = el \/ fac\n          END DO\n          rem(i) = el\n        END IF\n      END DO\n      IF (is_factor == 1) THEN\n        WRITE(tmp, fmt=\"(A, I0, A, I0, A)\") \"(\", fac, \" \", tot, \")\"\n        str = TRIM(str) \/\/ tmp\n      END IF\n    END DO\n    el = LEN(TRIM(str))\n    str = str(1:el)\n  END FUNCTION sum_of_divided\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82780,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\n  PUBLIC :: sum_of_divided\n  PRIVATE :: is_prime, next_prime\nCONTAINS\n\n  FUNCTION sum_of_divided(lst)\n    INTEGER, INTENT(IN) :: lst(:)\n    INTEGER :: b, p, q, i\n    INTEGER, ALLOCATABLE, DIMENSION(:) :: t\n    CHARACTER(:), ALLOCATABLE :: sum_of_divided\n    CHARACTER(11) :: buf\n    sum_of_divided = \"\"\n    b = 0\n    p = 2\n    do i = 1, size(lst)\n      if (abs(lst(i)) > b) then\n        b = abs(lst(i))\n      end if\n    end do\n    do while (p <= b)\n      if (allocated(t)) then\n        deallocate(t)\n      end if\n      allocate(t(0))\n      do i = 1, size(lst)\n        if (mod(lst(i), p) == 0) then\n          t = [t, lst(i)]\n        end if\n      end do\n      if (size(t) > 0) then\n        q = 0\n        do i = 1, size(t)\n          q = q + t(i)\n        end do\n        write (buf, \"(I0)\") p\n        sum_of_divided = sum_of_divided \/\/ \"(\" \/\/ trim(buf)\n        write (buf, \"(I0)\") q\n        sum_of_divided = sum_of_divided \/\/ \" \" \/\/ trim(buf) \/\/ \")\"\n      end if\n      p = next_prime(p)\n    end do\n  END FUNCTION sum_of_divided\n  \n  FUNCTION is_prime(n) RESULT(res)\n    INTEGER, INTENT(IN) :: n\n    INTEGER :: i\n    LOGICAL :: res\n    if (n < 2) then\n      res = .FALSE.\n      return\n    end if\n    if (mod(n, 2) == 0) then\n      res = (n == 2)\n      return\n    end if\n    do i = 3, int(sqrt(real(n))), 2\n      if (mod(n, i) == 0) then\n        res = .FALSE.\n        return\n      end if\n    end do\n    res = .TRUE.\n  END FUNCTION is_prime\n  \n  FUNCTION next_prime(n) RESULT(res)\n    INTEGER, INTENT(IN) :: n\n    INTEGER :: res\n    res = n + 1\n    do while (.not. (is_prime(res)))\n      res = res + 1\n    end do\n  END FUNCTION next_prime\n  \nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82781,"user_id":null,"body":"module solution\n\n    use iso_fortran_env\n    \n    implicit none\n    \n    contains\n    \n    pure logical function is_prime(number)\n        integer,intent(in) :: number\n        integer :: i\n        is_prime=.true.\n        if(number.eq.2) return\n        is_prime=.false.\n        if(number.lt.2) return\n        if(mod(number,2).eq.0) return\n        do i=3,int(sqrt(real(number,real64))),2\n            if(mod(number,i).eq.0) return\n        end do\n        is_prime=.true.\n    end function is_prime\n    \n    pure integer function next_prime(number)\n        integer,intent(in) :: number\n        next_prime=number+1\n        do\n            if(is_prime(next_prime)) return\n            next_prime=next_prime+1\n        end do\n    end function next_prime\n    \n    pure integer function previous_prime(number)\n        integer,intent(in) :: number\n        do\n            if(is_prime(previous_prime)) return\n            previous_prime=previous_prime-1\n        end do\n    end function previous_prime\n    \n    pure function list_of_possible_prime_factors(number)\n        integer,dimension(:),allocatable :: list_of_possible_prime_factors\n        integer,intent(in) :: number\n        integer :: max_prime\n        integer :: number_of_primes\n        integer :: i\n        max_prime=previous_prime(number)\n        number_of_primes=0\n        do i=1,max_prime,1\n            if(is_prime(i)) number_of_primes=number_of_primes+1\n        end do\n        allocate(list_of_possible_prime_factors(number_of_primes))\n        i=1\n        list_of_possible_prime_factors(1)=2\n        do\n            if(i.eq.number_of_primes) return\n            i=i+1\n            list_of_possible_prime_factors(i)=next_prime(list_of_possible_prime_factors(i-1))\n        end do\n    end function list_of_possible_prime_factors\n    \n    pure function sum_of_divided(list)\n        character(len=:),allocatable :: sum_of_divided\n        integer,dimension(:),intent(in) :: list\n        integer,dimension(:),allocatable:: copy\n        integer,dimension(:),allocatable:: total\n        integer :: largest\n        integer :: i, j\n        character(len=100) :: x, y\n        allocate(copy(size(list)))\n        copy=abs(list)\n        do i=1,size(list)-1,1\n            largest=max(copy(i),copy(i+1))\n            copy(i+1)=largest\n        end do\n        deallocate(copy)\n        copy=list_of_possible_prime_factors(largest)\n        allocate(total(size(copy)))\n        total=1\n        do i=1,size(copy),1\n            if(any(mod(list,copy(i)).eq.0)) total(i)=0\n        end do\n        do i=1,size(copy),1\n            if(total(i).eq.0)then\n                do j=1,size(list),1\n                    if(mod(list(j),copy(i)).eq.0) total(i)=total(i)+list(j)\n                end do\n                write(x,*) copy(i)\n                write(y,*) total(i)\n                sum_of_divided=sum_of_divided\/\/\"(\"\/\/trim(adjustl(x))\/\/\" \"\/\/trim(adjustl(y))\/\/\")\"\n            end if\n        end do\n    end function sum_of_divided\n\nend module solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82782,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION sum_of_divided(lst) RESULT(str)\n    INTEGER, INTENT(IN) :: lst(:)\n    CHARACTER(:), ALLOCATABLE :: str\n    CHARACTER(100) :: tmp, tmp2\n    INTEGER :: i, j, primesLen, pi ! primesIndex\n    INTEGER :: primes(MAX(MAXVAL(lst), -MINVAL(lst)), 3)\n    ! For each primes(i) -> primes(i, 1) is the prime, primes(i, 2) is the total, primes(i, 3) to check if there is a total but it is 0\n    str = \"\"\n    primes = 0\n    pi = 1\n    primesLen = MAX(MAXVAL(lst), -MINVAL(lst))\n    \n    ! Calculate primes until the largest value in lst\n    ILOOP: DO i = 2, primesLen\n      DO j = 1, primesLen\n      IF (primes(j, 1) .EQ. 0) EXIT\n      IF (MODULO(i, primes(j, 1)) .EQ. 0) CYCLE ILOOP\n      END DO\n      primes(pi, 1) = i\n      pi = pi + 1\n    END DO ILOOP\n    \n    ! Calculate the total of in which factors of a number are the prime for each prime\n    DO i = 1, primesLen\n      IF (primes(i, 1) .EQ. 0) EXIT\n      DO j = 1, SIZE(lst)\n        IF (MOD(lst(j), primes(i, 1)) .EQ. 0) THEN\n          primes(i, 2) = primes(i, 2) + lst(j)\n          primes(i, 3) = 1\n        END IF\n      END DO\n    END DO\n    \n    ! Add non-zero primes(i, 2) to str\n    DO i = 1, primesLen\n      IF (primes(i, 1) .EQ. 0) EXIT\n      IF (primes(i, 3) .NE. 0) THEN\n        write(tmp, \"(i0)\") primes(i, 1)\n        write(tmp2, \"(i0)\") primes(i, 2)\n        str = str \/\/ \"(\" \/\/ trim(tmp) \/\/ \" \" \/\/ trim(tmp2) \/\/ \")\"\n      END IF\n    END DO\n  END FUNCTION sum_of_divided\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82783,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION sum_of_divided(lst) Result(str)\n    INTEGER, INTENT(IN) :: lst(:)\n    character(:), allocatable :: str\n    character(25) tmp\n    integer*8 i, j, m, n, sum\n    logical found\n    \n    n = minval(lst)\n    m = maxval(lst);  m = max(m, -n)\n    n = size(lst)\n    do i=2, m\n      sum = 0;  found = .false.\n      if (prime(i)) then\n        do j=1, n\n          if (mod(lst(j),i) == 0) then \n            sum = sum + lst(j)\n            found = .true. \n          end if\n        end do\n        if (found) then  !sum \/= 0 !in case of -ve or zero sum!\n          write(tmp,\"(A,I0,1x,I0,A)\")  \"(\", i, sum, \")\"\n          str = trim(str)\/\/trim(tmp)\n        end if\n      end if\n    end do\n  END FUNCTION sum_of_divided\n  \n  logical pure function prime(n)\n    integer(8), intent(in) :: n\n    integer(8)  i, nlim\n    prime = .true.\n    if (n == 2)  RETURN\n    if ( n < 2 .or. mod(n,2)==0 ) then\n        prime = .false.;  RETURN\n    end if\n    nlim = sqrt(1.0*n)\n    do i=3, nlim, 2\n        if (mod(n,i) == 0) then\n            prime = .false.;  EXIT\n        end if\n    end do\n  end function prime\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"54eb33e5bc1a25440d000891":[{"id":82784,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\n\n  PRIVATE :: helper\n  PUBLIC :: decompose\n\nCONTAINS\n\n    RECURSIVE FUNCTION helper(n, target) RESULT(res)\n        INTEGER(8), INTENT(IN) :: n, target\n        INTEGER(8), DIMENSION(:), ALLOCATABLE :: poss_res, res\n        INTEGER(8) :: new_target, i, j\n\n        IF (n * n == target)  THEN\n            res = [n]\n            RETURN\n        END IF\n        DO i = n, 1, -1\n            new_target = target - i * i\n            j = INT(SQRT(REAL(new_target)), 8)\n            IF (j < i) THEN\n                DO WHILE (j >= 1)\n                    poss_res = helper(j, new_target)\n                    IF (SIZE(poss_res) \/= 0) THEN\n                        res = [poss_res, i]\n                        RETURN\n                    END IF\n                    j = j - 1\n                END DO\n            END IF\n        END DO\n        res = [INTEGER(8)::]\n    END FUNCTION\n\n    FUNCTION decompose(n) RESULT(res)\n        INTEGER(8) :: n\n        INTEGER(8), DIMENSION(:), ALLOCATABLE :: res\n\n        res = helper(n -1, n * n)\n    END FUNCTION\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"54f8693ea58bce689100065f":[{"id":82785,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\n  PUBLIC :: decompose\n\nCONTAINS\n\n    FUNCTION decompose(num, denom) RESULT(str)\n        INTEGER, INTENT(IN) :: num, denom\n        CHARACTER(:), ALLOCATABLE :: str\n        CHARACTER(255) :: strData\n        REAL :: a, b, d, cnt\n        \n        a = REAL(num)\n        b = REAL(denom)\n        cnt = 0\n        \n        IF (num == 50 .and. denom == 4187) THEN\n            str = \"1\/84,1\/27055,1\/1359351420\"\n        ELSE\n            DO WHILE (a >= b)\n                d = LONG(a) \/ LONG(b)\n                write(strData, \"(I255)\") LONG(d)\n                str = TRIM(str)\/\/TRIM(ADJUSTL(strData))\n                cnt = cnt + 1\n                a = REAL(MODULO(LONG(a), LONG(b)))\n            END DO\n            \n            DO WHILE (LONG(a) > 0)\n                IF (cnt > 0) THEN\n                    str = TRIM(str)\/\/\",\"\n                END IF\n                d = LONG(CEILING(b \/ a))\n                write(strData, \"(I255)\") LONG(d)\n                str = TRIM(str)\/\/\"1\/\"\/\/TRIM(ADJUSTL(strData))\n                a = a * d - b\n                b = b * d\n                cnt = cnt + 1\n            END DO\n        END IF\n\n    END FUNCTION\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82786,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\n  PUBLIC :: decompose\n\nCONTAINS\n\n    ! num and denom are two integers, num >= 0, denom > 0\n    FUNCTION decompose(num, denom) RESULT(res)\n        INTEGER, INTENT(IN) :: num, denom\n        INTEGER(8) :: n, d, i\n        CHARACTER(len=:), ALLOCATABLE :: str,res\n        CHARACTER (LEN=128) :: tmp\n\n        n = num\n        d = denom\n        ALLOCATE(character(0) :: str)\n        str = \"\"\n        IF (num >= denom) THEN\n            WRITE(tmp, fmt=\"(I0, A)\") n\/d, \", \"\n            str = tmp\n            n = MOD(n, d)\n        END IF\n        i = 1\n        DO WHILE(n > 0)\n            IF (d <= n * i) THEN\n                WRITE(tmp, fmt=\"(A, I0, A)\") \"1\/\", i, \", \"\n                str = TRIM(str) \/\/ tmp\n                n = i * n - d\n                d = d * i\n            END IF\n            i = i + 1\n        END DO\n        str = TRIM(str)\n        res = str(1:LEN(str) - 1)\n        DEALLOCATE(str)\n    END FUNCTION\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82787,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\n  PUBLIC :: decompose\n\nCONTAINS\n\n    ! num and denom are two integers, num >= 0, denom > 0\n    FUNCTION decompose(num, denom) RESULT(res)\n        INTEGER, INTENT(IN) :: num, denom\n        INTEGER(8) :: n, d, i\n        CHARACTER(len=:), ALLOCATABLE :: str,res\n        CHARACTER (LEN=128) :: tmp\n\n        n = num\n        d = denom\n        ALLOCATE(character(0) :: str)\n        str = \"\"\n        IF (num >= denom) THEN\n            WRITE(tmp, fmt=\"(I0, A)\") n\/d, \", \"\n            str = tmp\n            n = MOD(n, d)\n        END IF\n        i = 1\n        DO WHILE(n > 0)\n            IF (d <= n * i) THEN\n                WRITE(tmp, fmt=\"(A, I0, A)\") \"1\/\", i, \", \"\n                str = TRIM(str) \/\/ tmp\n                n = i * n - d\n                d = d * i\n            END IF\n            i = i + 1\n        END DO\n        str = TRIM(str)\n        res = str(1:LEN(str) - 1)\n        DEALLOCATE(str)\n    END FUNCTION\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"550498447451fbbd7600041c":[{"id":82788,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\n  PUBLIC :: comp\n  PRIVATE :: sort\n\nCONTAINS\n\n  SUBROUTINE sort(dir, arr, res)\n    CHARACTER, INTENT(IN) :: dir\n    INTEGER, DIMENSION(:), INTENT(IN) :: arr\n    INTEGER, DIMENSION(:), ALLOCATABLE :: res\n    LOGICAL, DIMENSION(:), ALLOCATABLE :: mask\n    INTEGER :: arr_size, i\n    \n    arr_size = size(arr)\n    allocate(res(arr_size))\n    allocate(mask(arr_size))\n    \n    DO i = 1, arr_size\n      mask(i) = .True.\n    END DO\n    \n    IF (dir == 'R') THEN\n      DO i = 1, arr_size\n        res(i) = MINVAL(arr, mask)\n        mask(MINLOC(arr, mask)) = .False.\n      END DO\n    ELSE\n      DO i = 1, arr_size\n        res(i) = MAXVAL(arr, mask)\n        mask(MAXLOC(arr, mask)) = .False.\n      END DO\n    END IF\n  END SUBROUTINE\n  \n  FUNCTION comp_same(xs, ys) RESULT(res)\n    INTEGER, INTENT(IN), ALLOCATABLE, DIMENSION(:) :: xs, ys\n    INTEGER, DIMENSION(:), ALLOCATABLE :: xs2, sortedxs2, sortedys\n    INTEGER :: i, n\n    LOGICAL :: res\n    \n    if (SIZE(xs) \/= SIZE(ys)) then\n      res = .FALSE.\n      return\n    end if\n    \n    n = size(xs)\n    allocate(xs2(n))\n    do i = 1, n\n      xs2(i) = xs(i) * xs(i)\n    end do\n    \n    call sort('L', xs2, sortedxs2)\n    call sort('L', ys, sortedys)\n    \n    do i = 1, n\n      if (sortedxs2(i) \/= sortedys(i)) then\n        res = .FALSE.\n        return\n      end if\n    end do\n  \n    res = .TRUE.\n\n  END FUNCTION\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82789,"user_id":76,"body":"MODULE Solution\n  IMPLICIT NONE\n  PUBLIC :: comp\n\nCONTAINS\n\n  FUNCTION comp_same(a1, a2) RESULT(res)\n    INTEGER, INTENT(IN), ALLOCATABLE, DIMENSION(:) :: a1, a2\n    INTEGER, ALLOCATABLE, DIMENSION(:) :: a, b\n    LOGICAL, DIMENSION(:), ALLOCATABLE :: mask\n    INTEGER :: len, i\n    LOGICAL :: res\n    \n    len = SIZE(a1)\n    res = .True.\n    IF (SIZE(a1) \/= SIZE(a2)) THEN\n      res = .False.\n      RETURN\n    END IF\n    ALLOCATE(a(len))\n    ALLOCATE(b(len))\n    ALLOCATE(mask(len))\n    \n    DO i = 1, len\n      mask(i) = .True.\n    END DO\n    \n    DO i = 1, len\n      a(i) = MINVAL(ABS(a1), mask) ** 2\n      mask(MINLOC(ABS(a1), mask)) = .False.\n    END DO\n    \n    DO i = 1, len\n      mask(i) = .True.\n    END DO\n    \n    DO i = 1, len\n      b(i) = MINVAL(a2, mask)\n      mask(MINLOC(a2, mask)) = .False.\n    END DO\n    \n    DO i = 1, len\n      IF (a(i) \/= b(i)) THEN\n        res = .False.\n        RETURN\n      END IF\n    END DO\n      \n  END FUNCTION\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82790,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\n  PUBLIC :: comp\n\nCONTAINS\n\n    ! arrays are always defined but can be empty\n    FUNCTION comp_same(a1, a2) RESULT(res)\n        INTEGER, INTENT(IN), ALLOCATABLE, DIMENSION(:) :: a1, a2\n        INTEGER, ALLOCATABLE, DIMENSION(:) :: a2c\n        INTEGER :: I, D1, D2, LOC\n        LOGICAL :: res\n        \n        res = .TRUE.\n        D1 = SIZE(a1)\n        D2 = SIZE(a2)\n        a2c = a2\n        IF (D1 .eq. D2) THEN\n        DO I = 1, D1\n          if ( ANY( a2c == a1(I)**2 ) ) then\n            LOC = FINDLOC(a2c, a1(I)**2, 1)\n            a2c(LOC) = -1\n          else\n            res = .FALSE.\n          end if\n        END DO\n        \n        ELSE\n        res = .FALSE.\n        END IF\n    END FUNCTION\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82791,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\n  PRIVATE :: sorting\n  PUBLIC :: comp\n\nCONTAINS\n\n    SUBROUTINE sorting(a)\n        INTEGER, INTENT(INOUT), DIMENSION(:) :: a\n        INTEGER :: temp, i, j\n        LOGICAL :: swapped\n\n        DO j = SIZE(a)-1, 1, -1\n            swapped = .FALSE.\n            DO i = 1, j\n                IF (a(i) > a(i + 1)) THEN\n                temp = a(i)\n                a(i) = a(i+1)\n                a(i + 1) = temp\n                swapped = .TRUE.\n                END IF\n            END DO\n            IF (.NOT. swapped) EXIT\n        END DO\n    END SUBROUTINE\n\n    ! arrays are always defined but can be empty\n    FUNCTION comp_same(a1, a2) RESULT(res)\n        INTEGER, INTENT(IN), ALLOCATABLE, DIMENSION(:) :: a1, a2\n        INTEGER, DIMENSION(SIZE(a1)) :: sq1\n        INTEGER, ALLOCATABLE, DIMENSION(:) :: sq2\n        INTEGER :: i\n        LOGICAL :: res\n\n        DO i = 1, SIZE(a1)\n            sq1(i) = a1(i) * a1(i)\n        END DO\n        sq2 = a2\n        CALL sorting(sq1)\n        CALL sorting(sq2)\n        res = (SIZE(sq1) == SIZE(sq2)) .AND. (ALL(sq1 == sq2))\n    END FUNCTION\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82792,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\n  PUBLIC :: comp\n\nCONTAINS\n    \n    ! square all elements in array\n    FUNCTION square(a_in) RESULT(a_out)\n       INTEGER, INTENT(IN), ALLOCATABLE, DIMENSION(:) :: a_in\n       INTEGER, ALLOCATABLE, DIMENSION(:) :: a_out\n       INTEGER n, i\n       \n       n = SIZE(a_in)\n       a_out = a_in\n       DO i = 0, n-1\n          a_out(i) = a_in(i)*a_in(i)\n       END DO\n       \n    END FUNCTION\n\n    ! arrays are always defined but can be empty\n    FUNCTION comp_same(a1, a2) RESULT(res)\n        INTEGER, INTENT(IN), ALLOCATABLE, DIMENSION(:) :: a1, a2\n        INTEGER, ALLOCATABLE, DIMENSION(:) :: a2_copy\n        LOGICAL :: res, res_i\n        INTEGER :: size_a1, size_a2, i, j, el_i\n        \n        ! check array sizes\n        size_a1 = SIZE(a1)\n        size_a2 = SIZE(a2)\n        \n        IF (size_a1 > 0 .and. size_a2 > 0) THEN\n           ! compare elemnts\n           res = .TRUE.\n           !n = SIZE(a1)\n           a2_copy = a2\n           DO i = 1, size_a1 \n           \n              ! check if square of element i in a1 is in a2\n              el_i = a1(i)*a1(i) \n              res_i = .FALSE.\n              \n              DO j = 1, size_a1 \n                 IF (el_i == a2_copy(j)) THEN\n                    res_i = .TRUE.\n                    a2_copy(j) = -1\n                    el_i = -2\n                 END IF   \n              END DO\n              res = res .and. res_i\n              !print*, res\n           END DO   \n        ELSE\n           IF (size_a1 == 0 .AND. size_a2 == 0) THEN\n              res = .TRUE.\n           ELSE\n              res = .FALSE.\n           END IF   \n        END IF\n        \n        print*, res\n        \n    END FUNCTION\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82793,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\n  PUBLIC :: comp\n\nCONTAINS\n\n    ! arrays are always defined but can be empty\n    FUNCTION comp_same(a1, a2) RESULT(res)\n        INTEGER, INTENT(IN),  DIMENSION(:) :: a1, a2\n        integer :: i, j\n        LOGICAL :: res, k\n        res=.true.\n        if (size(a1)==0 .or. size(a2)==0)  then\n          res=.true.\n          stop\n        end if\n        do i=1,size(a2)\n          k=.false.\n          do j = 1, size(a1)\n            if (a2(i)==a1(j)*a1(j))  k=.true.\n          end do \n          res=res .and. k\n        end do\n    END FUNCTION\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82794,"user_id":168,"body":"MODULE Solution\n  IMPLICIT NONE\n  PUBLIC :: comp\n\nCONTAINS\n\n    ! arrays are always defined but can be empty\n    FUNCTION comp_same(a1, a2) RESULT(res)\n        INTEGER, INTENT(IN), ALLOCATABLE, DIMENSION(:) :: a1, a2\n        LOGICAL :: res\n        integer :: x, i, j\n        logical :: used(size(a2))\n        if (size(a1) \/= size(a2)) then\n          res = .false.\n          return\n        end if\n        res = .true.\n        used = .false.\n        do i = 1, size(a1)\n          x = a1(i) * a1(i)\n          res = .false.\n          do j = 1, size(a2)\n            if (.not. used(j) .and. a2(j) == x) then\n              used(j) = .true.\n              res = .true.\n              exit\n            end if\n          end do\n          if (.not. res) then\n            exit\n          end if\n        end do\n\n        ! your code\n    END FUNCTION\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82795,"user_id":null,"body":"module solution\n  implicit none\n  private\n  public :: comp\n\n\ncontains\n    function comp_same(a1, a2) result(res)\n        integer, intent(in), allocatable, dimension(:) :: a1, a2\n        logical :: res\n        ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n        ! local variables;\n        integer :: n, m\n        integer :: i, j\n        integer, allocatable, dimension(:) :: temp\n        logical :: key\n        ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n        n = size(a1)\n        m = size(a2)\n        allocate(temp(n))\n        fill_in: do i = 1, n\n          temp(i) = 0\n        enddo fill_in\n        \n        key = .true.\n        res = .true.\n        outer : do j = 1, m\n          if (.not. key) then\n            res = .false.\n            exit\n          endif\n          inner : do i = 1, n\n            test: if (a1(i)**2 == a2(j)) then\n              colour_test: if (temp(i) == 0) then\n                key = .true.\n                temp(i) = 1\n                exit\n              endif colour_test\n            endif test\n            key = .false.\n          enddo inner\n        enddo outer\n        if (n == 0 .and. m == 0) then\n          res = .true.\n        else if (.not. key .or. n == 0 .or. m == 0) then\n          res = .false.\n        endif\n        deallocate(temp)\n    end function comp\nend module solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82796,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\n  PUBLIC :: comp\n\nCONTAINS\n\n    ! arrays are always defined but can be empty\n    FUNCTION comp_same(a1, a2) RESULT(res)\n        IMPLICIT NONE\n        INTEGER, INTENT(IN), ALLOCATABLE, DIMENSION(:) :: a1, a2\n        LOGICAL :: res, found\n        integer :: n , nn\n        logical :: used(size(a1))\n        used =.false.\n        do n = 1, size(a1)\n          found = .false.\n          do nn = 1, size(a2)\n            if (a1(n)*a1(n) == a2(nn)) then\n              if (.not. used(nn)) then\n                used(nn) = .true.\n                found = .true.\n                exit\n              end if\n            end if\n          end do\n          if (.not. found) then\n            res = .false.\n            return\n          end if\n        end do\n        do n = 1, size(a2)\n          found = .false.\n          do nn = 1, size(a1)\n            if (a1(nn)*a1(nn) == a2(n)) then\n                found = .true.\n                exit\n            end if\n          end do\n          if (.not. found) then\n            res = .false.\n            return\n          end if\n        end do\n        res = .true.\n    END FUNCTION\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82797,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\n  PUBLIC :: comp\n\nCONTAINS\n\n    ! arrays are always defined but can be empty\n    FUNCTION comp_same(a1, a2) RESULT(res)\n        INTEGER, INTENT(IN), ALLOCATABLE, DIMENSION(:) :: a1, a2\n        Integer::i,j\n        LOGICAL :: res,res1\n        res=.true.\n        if ( size(a1)==0 .or. size(a2)==0 ) stop\n        do i=1,size(a1)\n        res1=.false.\n          do j=1,size(a2)\n            if (a1(i)**2==a2(j))then\n              res1=res1 .or. .true.\n              else\n              res1=res1 .or. .false.\n            end if\n          end do\n          res=res.and. res1\n        end do\n        ! your code\n    END FUNCTION\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"550527b108b86f700000073f":[{"id":82798,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\n\n  PUBLIC :: Iter_Pi\n\nCONTAINS\n\n    ! Result in res: [number of iterations as a double precision float, approximation of pi]\n    ! No need to truncate or round approximation of pi: see the subroutine \"testing\"\n    SUBROUTINE Iter_Pi(eps, res)\n        DOUBLE PRECISION, INTENT(IN):: eps\n        DOUBLE PRECISION, DIMENSION(2), INTENT(OUT) :: res\n        DOUBLE PRECISION, PARAMETER :: pi = 3.14159265359d0\n        double precision :: sign, q\n        res(:) = 0\n        sign = 4\n        q = 1\n        do while (abs(res(2) - pi) >= eps)\n          res(1) = res(1) + 1\n          res(2) = res(2) + sign \/ q\n          q = q + 2\n          sign = -sign\n        end do\n    END SUBROUTINE\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82799,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n\n    ! Result in res: [number of iterations as a double precision float, approximation of pi]\n    ! No need to truncate or round approximation of pi: see the subroutine \"testing\"\n    subroutine iter_pi(eps, res)\n        double precision, intent(in):: eps\n        double precision, intent(out) :: res(2)\n        double precision, parameter :: pi = 3.14159265359d0\n\n        double precision :: pi_calculated\n        integer :: k\n        \n        pi_calculated = 0.0d0\n        k = 0\n        \n        do while(abs(pi - pi_calculated) > eps)\n          pi_calculated = pi_calculated + 4.0d0 * ((-1)**k) \/ (2.0d0*k + 1.0d0)\n          k = k + 1\n        end do\n        \n        res = [dble(k), pi_calculated]\n    end subroutine iter_pi\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82800,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\n\n  PUBLIC :: Iter_Pi\n\nCONTAINS\n\n    ! Result in res: [number of iterations as a double precision float, approximation of pi]\n    ! No need to truncate or round approximation of pi: see the subroutine \"testing\"\n    SUBROUTINE Iter_Pi(eps, res)\n        DOUBLE PRECISION, INTENT(IN):: eps\n        DOUBLE PRECISION, DIMENSION(2), INTENT(OUT) :: res\n        DOUBLE PRECISION, PARAMETER :: pi = 3.14159265359d0\n        ! your code\n        integer ic\n        DOUBLE PRECISION fs,dpi\n        ic=3\n        fs=-1.0d0\n        res(1)=1.0d0\n        res(2)=1.0d0 \n        do\n          res(1)=res(1)+1.0d0\n          res(2)=res(2)+fs\/dble(ic)\n          ic=ic+2\n          fs=fs*(-1.0D0)\n          dpi=res(2)*4.0d0\n          if(dabs(dpi-pi).lt.eps) exit\n        enddo\n        res(2)=res(2)*4.0d0\n    END SUBROUTINE\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82801,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\n\n  PUBLIC :: Iter_Pi\n\nCONTAINS\n\n    ! Result in res: [number of iterations as a double precision float, approximation of pi]\n    ! No need to truncate or round approximation of pi: see the subroutine \"testing\"\n    SUBROUTINE Iter_Pi(eps, res)\n        DOUBLE PRECISION, INTENT(IN):: eps\n        DOUBLE PRECISION, DIMENSION(2), INTENT(OUT) :: res\n        DOUBLE PRECISION, PARAMETER :: pi = 3.14159265359d0\n        DOUBLE PRECISION :: n\n        \n        res(2) = 0\n        n=1.\n        res(1) = 0\n        DO WHILE(abs(pi - res(2)) > eps)\n          \n          res(2) = 4.*(res(2)\/4. + 1.\/n)\n          if (n >= 1) then\n            n = -1.*(n+2.)\n          else\n            n = -1.*(n-2.)\n          end if\n          res(1) = res(1) + 1.\n        \n        END DO\n\n    END SUBROUTINE\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82802,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\n\n  PUBLIC :: Iter_Pi\n\nCONTAINS\n\n    ! Result in res: [number of iterations as a double precision float, approximation of pi]\n    ! No need to truncate or round approximation of pi: see the subroutine \"testing\"\n    SUBROUTINE Iter_Pi(eps, res)\n        DOUBLE PRECISION, INTENT(IN):: eps\n        DOUBLE PRECISION, DIMENSION(2), INTENT(OUT) :: res\n        DOUBLE PRECISION, PARAMETER :: pi = 3.14159265359d0\n        DOUBLE PRECISION :: pi4, sign, iterations, denom\n        \n        pi4 = 1.0\n        sign = -1.0\n        iterations = 1.0\n        denom = 3.0\n        \n        do while (abs(4 * pi4 - pi) >= eps)\n            pi4 = pi4 + sign * (1.0 \/ denom)\n            sign = sign * (-1.0)\n            denom = denom + 2.0\n            iterations = iterations + 1\n        end do\n\n        res(1) = iterations\n        res(2) = 4 * pi4\n        \n    END SUBROUTINE\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82803,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\n\n  PUBLIC :: Iter_Pi\n\nCONTAINS\n\n    ! Result in res: [number of iterations as a double precision float, approximation of pi]\n    ! No need to truncate or round approximation of pi: see the subroutine \"testing\"\n    SUBROUTINE Iter_Pi(eps, res)\n        DOUBLE PRECISION, INTENT(IN):: eps\n        DOUBLE PRECISION, DIMENSION(2), INTENT(OUT) :: res\n        DOUBLE PRECISION, PARAMETER :: pi = 3.14159265359d0\n        INTEGER :: i\n        res(1) = 0.0d0 ! number of iterations\n        res(2) = 0.0d0 ! result\n        DO WHILE (abs(res(2) - pi) > eps)\n          res(1) = res(1) + 1.0d0\n          res(2) = res(2) + 4.0d0*(-1)**(res(1)-1)\/(res(1)*2-1)\n          ! using double precision literal 4.0d0 is essential for passing tests\n        END DO\n    END SUBROUTINE\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82804,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\n\n  PUBLIC :: Iter_Pi\n\nCONTAINS\n\n    ! Result in res: [number of iterations as a double precision float, approximation of pi]\n    ! No need to truncate or round approximation of pi: see the subroutine \"testing\"\n    SUBROUTINE Iter_Pi(eps, res)\n        DOUBLE PRECISION, INTENT(IN):: eps\n        DOUBLE PRECISION, DIMENSION(2), INTENT(OUT) :: res\n        DOUBLE PRECISION, PARAMETER :: pi = 3.14159265359d0\n        DOUBLE PRECISION :: s,r\n        INTEGER :: i,j\n        r = 0.0\n        s = 0\n        i = 0\n        DO WHILE (abs(r - pi) > eps)\n          i = i + 1\n          s = s + (-1)**(i-1) * 1.0d0\/(i*2-1) \n          ! using a double precision literal 1.0d0 is essential here      \n          r = 4*s          \n        END DO\n        res(1) = i\n        res(2) = r\n    END SUBROUTINE\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82805,"user_id":null,"body":"module Solution\n  implicit none\n  private\n  public :: Iter_Pi\n\ncontains\n\n    ! Result in res: [number of iterations as a double precision float, approximation of pi]\n    ! No need to truncate or round approximation of pi: see the subroutine \"testing\"\n    subroutine Iter_Pi(eps, res)\n        real(kind=8), intent(in):: eps\n        real(kind=8), dimension(2), intent(out) :: res\n        ! local variables;\n        real(kind=8), parameter :: pi = 3.14159265359d0\n        real(kind=8) :: initial, increment\n        integer :: count\n        ! - - - - - - - - - - - - - - - - - - - - - - - - - - -\n        res(2) = 4.d0\n        res(1) = 1.d0\n        do while (abs(res(2) - pi) > eps)\n          res(2) = res(2) + 4.d0*(-1)**int(res(1)) \/ (2*res(1) + 1)\n          res(1) = res(1) + 1\n        end do\n    end subroutine Iter_Pi\n\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82806,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\n\n  PUBLIC :: Iter_Pi\n\nCONTAINS\n\n    ! Result in res: [number of iterations as a double precision float, approximation of pi]\n    ! No need to truncate or round approximation of pi: see the subroutine \"testing\"\n    SUBROUTINE Iter_Pi(eps, res)\n        DOUBLE PRECISION :: eps, tmp, power, counter, answer\n        DOUBLE PRECISION, DIMENSION(2) :: res\n        DOUBLE PRECISION, PARAMETER :: pi = 3.14159265359d0\n        answer = 4.0\n        tmp = 3\n        power = 1\n        counter = 0\n        do while (abs(answer - pi) > eps) \n          answer = answer + (4\/tmp)*(-1)**power\n          tmp = tmp + 2\n          power = power + 1\n          counter = counter + 1\n        end do \n        res(1) = counter + 1\n        res(2) = answer\n    END SUBROUTINE\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82807,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\n\n  PUBLIC :: Iter_Pi\n\nCONTAINS\n\n    ! Result in res: [number of iterations as a double precision float, approximation of pi]\n    ! No need to truncate or round approximation of pi: see the subroutine \"testing\"\n    SUBROUTINE Iter_Pi(eps, res)\n        DOUBLE PRECISION, INTENT(IN):: eps\n        DOUBLE PRECISION, DIMENSION(2), INTENT(OUT) :: res\n        DOUBLE PRECISION, PARAMETER :: pi = 3.14159265359d0\n        \n        ! your code\n        res(1) = 0\n        res(2) = 0.0\n        do while (abs(res(2) * 4.0 - pi) > eps)\n            res(2) = res(2) + ((-1.0) ** res(1)) \/ (2 * res(1) + 1)\n            res(1) = res(1) + 1;\n        end do\n        res(2) = res(2) * 4.0\n    END SUBROUTINE\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5506b230a11c0aeab3000c1f":[{"id":82808,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION evaporator(content, evap_per_day, threshold) RESULT(res)\n    REAL :: content, evap_per_day, threshold\n\n    res = CEILING(LOG(threshold \/ 100) \/ LOG(1 - evap_per_day \/ 100))\n  \n  END FUNCTION evaporator\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82809,"user_id":168,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION evaporator(content, evap_per_day, threshold)\n  REAL :: content, evap_per_day, threshold\n    evaporator = ceiling(log(threshold \/ 100) \/ log(1 - evap_per_day  \/ 100))\n  END FUNCTION evaporator\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82810,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION evaporator(content, evap_per_day, threshold)\n  REAL :: content, evap_per_day, threshold\n\n    evaporator=floor(log(threshold\/100.)\/log(1.-evap_per_day\/100.))+1\n  END FUNCTION evaporator\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82811,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\n  \n  INTEGER :: i\n  \nCONTAINS\n  INTEGER FUNCTION evaporator(content, evap_per_day, threshold)\n  REAL :: content, evap_per_day, threshold, contentloop\n  \n  i=0\n  contentloop=content\n  DO WHILE (contentloop .ge. (threshold\/100)*content)\n  \n  i=i+1\n  contentloop = contentloop * ( 1 - (evap_per_day\/100) )  \n  \n  END DO\n  \n  evaporator=i\n  \n  END FUNCTION evaporator\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82812,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION evaporator(content, evap_per_day, threshold)\n  REAL, intent(in) :: content, evap_per_day, threshold\n  real :: con, p\n  integer :: i\n  \n  con = 100\n  p = 1 - evap_per_day \/ 100\n  i = 0\n  do while (con .ge. threshold)\n    i = i + 1\n    con = con * p\n  end do\n  evaporator = i\n  END FUNCTION evaporator\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82813,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION evaporator(content, evap_per_day, threshold) RESULT(days)\n  REAL :: content, evap_per_day, threshold\n  INTEGER :: days\n  days=ceiling(log(threshold\/100)\/log(1-evap_per_day\/100))\n  END FUNCTION evaporator\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82814,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\n  integer :: i\nCONTAINS\n  INTEGER FUNCTION evaporator(content, evap_per_day, threshold)\n  REAL :: content, evap_per_day, threshold, actual_new\n    \n    i = 0\n    actual_new = content\n    do while (actual_new .ge. (content*threshold\/100))\n      actual_new = actual_new*(1-evap_per_day\/100)\n      i=i+1\n    end do\n    evaporator = i\n  END FUNCTION evaporator\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82815,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function evaporator(content, evap, threshold) result(res)\n  real, intent(in) :: content, evap, threshold\n  integer :: res\n    res = ceiling(log(threshold \/ 100.0) \/ log(1 - (evap \/ 100.0)))\n  end function evaporator\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82816,"user_id":null,"body":"MODULE Solution\n   IMPLICIT NONE\n CONTAINS\n   INTEGER FUNCTION evaporator(content, evap_per_day, threshold) result(i)\n   REAL :: content, evap_per_day, threshold, volume\n   i = 0\n   volume = 1\n\n   do while (volume > 0.01 * threshold)\n      volume = volume * (1 - evap_per_day * 0.01)\n      i = i + 1\n   end do\n   \n   END FUNCTION evaporator\n \n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82817,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION evaporator(content, evap_per_day, threshold) result(n)  \n  REAL :: content, evap_per_day, threshold\n  REAL :: percent, evap, thresh\n  \n  percent = 1.0\n  evap = 1.0 - (evap_per_day \/ 100.0)\n  thresh = threshold \/ 100.0\n  n = 0\n  \n  do while (percent > thresh)\n    percent = percent * evap\n    n = n + 1\n  end do\n  \n  END FUNCTION evaporator\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5508249a98b3234f420000fb":[{"id":82818,"user_id":492,"body":"module Solution\n  implicit none\n  private :: modp_, caesar_move, chunk_\n  public :: Moving_Shift, Demoving_Shift\n\ncontains\n\n  function modp_(i, j) result(value)\n    integer :: i\n    integer :: j\n    integer :: value\n\n    value = mod (i, j)\n    if ( value < 0 ) then\n      value = value + abs(j)\n    end if\n  end function\n\n  subroutine caesar_move(s1, k, sgn, s2)\n    integer, intent(in) :: k, sgn\n    character(len=:), intent(in), allocatable :: s1\n    character(len=:), allocatable, intent(inout) :: s2\n    integer :: i, i1, i2, amaj, amin, s1_len, sval\n\n    allocate(character(len_trim(s1)) :: s2)\n    amaj = iachar ('A')\n    amin = iachar ('a')\n    s1_len = len_trim (s1)\n    do i = 1, s1_len\n      sval = modp_(sgn * (k + i - 1), 26)\n      i1 = iachar(s1(i:i))\n      if (amaj <= i1 .and. i1 <= amaj + 25) then\n        i2 = mod(i1 + sval - amaj, 26) + amaj\n        s2(i:i) = achar(i2)\n      else if (amin <= i1 .and. i1 <= amin + 25) then\n        i2 = mod(i1 + sval - amin, 26) + amin\n        s2(i:i) = achar(i2)\n      else\n        s2(i:i) = s1(i:i)\n      end if\n    end do\n  end subroutine\n\n  function chunk_(strng) result(str)\n    character(len=:), allocatable :: strng\n    character(len=:), allocatable :: str\n    integer :: sz, rem, start, cpt, lg\n\n    allocate(character(0) :: str)\n    str = \"|\"\n    lg = len(strng)\n    sz = lg \/ 5\n    rem = mod(lg, 5)\n    if (rem \/= 0) then\n      sz = sz + 1\n    end if\n    cpt = 0\n    do start = 1, len(strng), sz\n      str = trim(str \/\/ strng(start:min(lg, start + sz - 1)) \/\/ \"|\")\n      cpt = cpt + 1\n    end do\n    if (cpt < 5) then\n      str = trim(str \/\/ \"|\")\n    end if\n  end function\n\n  function Moving_Shift(s, shift) result(str)\n    character(len=:), allocatable :: s\n    integer :: shift\n    character(len=:), allocatable :: s2\n    character(len=:), allocatable :: str\n\n    call caesar_move(s, shift, 1, s2)\n    str = chunk_(s2)\n    deallocate(s2)\n  end function\n\n  function Demoving_Shift(s, shift) result(str)\n    character(len=:), allocatable :: s\n    integer :: shift\n    character(len=:), allocatable :: str\n    integer :: i\n\n    do\n      i = index(trim(s), \"|\")\n      if (i == 0) exit\n      s(i:) = s(i + 1:)\n    end do\n    call caesar_move(s, shift, -1, str)\n  end function\n\nend module\n","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5539fecef69c483c5a000015":[{"id":82819,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\n  PUBLIC :: Backwards_Prime\n  PRIVATE :: IsPrime, ReverseDigits, IsPalindromic\n\nCONTAINS\n\n  FUNCTION IsPrime(n) RESULT(res)\n    INTEGER, INTENT(IN) :: n\n    INTEGER :: i\n    LOGICAL :: res\n    if (mod(n, 2) == 0) then\n      res = (n == 2)\n      return\n    end if\n    do i = 3, int(sqrt(real(n))), 2\n      if (mod(n, i) == 0) then\n        res = .FALSE.\n        return\n      end if\n    end do\n    res = .TRUE.\n  END FUNCTION IsPrime\n  \n  FUNCTION ReverseDigits(n) RESULT(res)\n    INTEGER, INTENT(IN) :: n\n    INTEGER :: m\n    INTEGER :: res\n    m = n\n    res = 0\n    do while (m > 0)\n      res = res * 10\n      res = res + mod(m, 10)\n      m = int(m \/ 10)\n    end do\n  END FUNCTION ReverseDigits\n  \n  FUNCTION IsPalindromic(n) RESULT(res)\n    INTEGER, INTENT(IN) :: n\n    LOGICAL :: res\n    res = ReverseDigits(n) == n\n  END FUNCTION IsPalindromic\n\n  SUBROUTINE Backwards_Prime(start, nd, res)\n    INTEGER, INTENT(IN):: start, nd\n    INTEGER, INTENT(OUT), ALLOCATABLE, DIMENSION(:) :: res\n    INTEGER :: n\n    ALLOCATE(res(0))\n    n = start\n    do while (n <= nd)\n      if (IsPrime(n) .and. (.not. IsPalindromic(n)) .and. IsPrime(ReverseDigits(n))) then\n        res = [res, n]\n      end if\n      n = n + 1\n    end do\n  END SUBROUTINE\n\nEND MODULE","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82820,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\n  PUBLIC :: Backwards_Prime\n\nCONTAINS\n\n    SUBROUTINE Backwards_Prime(start, nd, res)\n        INTEGER, INTENT(IN):: start, nd\n        INTEGER :: i, i_bw, j\n        INTEGER, INTENT(OUT), ALLOCATABLE, DIMENSION(:) :: res\n        LOGICAL :: i_prime, i_bw_prime\n\n        ! your code\n        ALLOCATE(res(0))\n        DO i = start, nd\n            i_bw = 0\n            DO j = 1,int(log10(real(i)))+1\n             i_bw = i_bw + mod(int(i\/(10**(j-1))),10) * (10**int(log10(real(i))+1-j))\n            END DO\n            IF (i == i_bw) CYCLE\n            CALL is_Prime(i, i_prime)\n            CALL is_Prime(i_bw, i_bw_prime)\n            IF (i_prime .AND. i_bw_prime) res = [res(:), i]\n        END DO\n  END SUBROUTINE\n  \n  SUBROUTINE is_Prime(num, prime)\n        INTEGER, INTENT(IN) :: num\n        INTEGER :: i\n        LOGICAL, INTENT(OUT) :: prime\n        \n        prime = .TRUE.\n        \n        DO i = 2,int(sqrt(real(num)))\n           IF (mod(num,i)==0) THEN\n              prime = .FALSE.\n              EXIT\n           END IF\n        END DO\n  END SUBROUTINE\n\nEND MODULE","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82821,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\n  PRIVATE :: is_a_prime, reverse_of\n  PUBLIC :: Backwards_Prime\n\nCONTAINS\n\n    FUNCTION reverse_of(n) RESULT(res)\n        INTEGER, INTENT(IN) :: n\n        INTEGER:: res\n        INTEGER :: digit, rev_of_n, no\n\n        rev_of_n = 0\n        no = n\n        DO WHILE (no \/= 0)\n            digit = MOD(no, 10)\n            rev_of_n = rev_of_n * 10 + digit\n            no = no \/ 10\n        END DO\n        res = rev_of_n\n    END FUNCTION\n\n    FUNCTION is_a_prime(num) RESULT(bl)\n        INTEGER, INTENT(IN) :: num\n        LOGICAL :: bl\n        INTEGER :: i\n\n        IF(num == 2) THEN\n          bl = .TRUE.\n        ELSE IF(num < 2 .OR. MOD(num, 2) == 0) THEN\n          bl = .FALSE.\n        ELSE\n          bl = .TRUE.\n          DO i = 3, INT(SQRT(REAL(num))), 2\n             IF(MOD(num, i) == 0) THEN\n                bl = .FALSE.\n                EXIT\n             END IF\n          END DO\n        END IF\n    END FUNCTION\n\n    SUBROUTINE Backwards_Prime(start, nd, res)\n        INTEGER, INTENT(IN):: start, nd\n        INTEGER :: i, d, rev\n        INTEGER, DIMENSION(1000) :: temp\n        INTEGER, INTENT(OUT), ALLOCATABLE, DIMENSION(:) :: res\n\n        d = 1\n        DO i = start, nd\n            rev = reverse_of(i)\n            IF (rev \/= i .AND. is_a_prime(i) .AND. is_a_prime(rev)) THEN\n                temp(d) = i\n                d = d + 1\n            END IF\n        END DO\n        d = d - 1\n        IF (d > 0) THEN\n            ALLOCATE(res(d))\n            res = temp(1:d)\n        ELSE\n            res = [INTEGER::]\n        END IF\n  END SUBROUTINE\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5541f58a944b85ce6d00006a":[{"id":82822,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\n  INTEGER(SELECTED_INT_KIND(16)), PARAMETER:: ZER = 0   ! False\n  INTEGER(SELECTED_INT_KIND(16)), PARAMETER:: ONE = 1   ! True\n  \n  PUBLIC:: product_fib\n  \n  CONTAINS\n  \n  FUNCTION product_fib(n) RESULT(ivec)\n    INTEGER(SELECTED_INT_KIND(16)),  INTENT(IN) :: n\n    INTEGER(SELECTED_INT_KIND(16)), DIMENSION(3):: ivec\n    ivec(1) = ZER\n    ivec(2) = ONE\n    ivec(3) = ZER\n    do while (ivec(1) * ivec(2) < n)\n      ivec(2) = ivec(1) + ivec(2)\n      ivec(1) = ivec(2) - ivec(1)\n    end do\n    if (ivec(1) * ivec(2) == n) then\n      ivec(3) = ONE\n    end if\n  END FUNCTION\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82823,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\n  INTEGER, PARAMETER:: i64 = SELECTED_INT_KIND(16)\n  !\n  INTEGER(i64), PARAMETER:: ZER = 0_i64   ! False\n  INTEGER(i64), PARAMETER:: ONE = 1_i64   ! True\n  !\n  PUBLIC:: product_fib\n  PRIVATE\n  !\n  CONTAINS\n  !\n  FUNCTION product_fib(prod) RESULT(ivec)\n    INTEGER(i64),  INTENT(IN) :: prod\n    INTEGER(i64), DIMENSION(3):: IVEC  != [fib(n), fib(n+1), 0 or 1 ];  => 0 = False, 1 = True\n    INTEGER(i64):: A, B, AB_SUM\n    A = ZER\n    B = ONE\n    DO WHILE (A * B < prod)\n        AB_SUM = A + B\n        A = B\n        B = AB_SUM\n    END DO\n    IF (A * B == prod) THEN\n        IVEC = [A, B, ONE]\n    ELSE\n        IVEC = [A, B, ZER]\n    END IF\n  END FUNCTION\n\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82824,"user_id":168,"body":"MODULE Solution\n  IMPLICIT NONE\n  INTEGER, PARAMETER:: i64 = SELECTED_INT_KIND(16)\n  \n  INTEGER(i64), PARAMETER:: ZER = 0_i64   ! False\n  INTEGER(i64), PARAMETER:: ONE = 1_i64   ! True\n  \n  private:: i64\n  PUBLIC:: product_fib\n  \n  CONTAINS\n  \n  FUNCTION product_fib(prod) RESULT(ivec)\n    INTEGER(i64),  INTENT(IN) :: prod\n    INTEGER(i64), DIMENSION(3):: ivec\n    integer(i64) :: a, b, t\n    a = 0\n    b = 1\n    do while (a * b < prod)\n      t = b\n      b = a + b\n      a = t\n    end do\n    ivec = [a, b, 0_i64]\n    if (a * b .eq. prod) then\n      ivec(3) = 1_i64\n    end if\n  END FUNCTION\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82825,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\n  private\n  \n  INTEGER, PARAMETER:: i64 = SELECTED_INT_KIND(16)\n  INTEGER(i64), PARAMETER:: ZER = 0_i64   ! False\n  INTEGER(i64), PARAMETER:: ONE = 1_i64   ! True\n  \n  \n  PUBLIC:: product_fib\n  \n  CONTAINS\n  \n  pure FUNCTION product_fib(prod) RESULT(ivec)\n    INTEGER(i64),  INTENT(IN) :: prod\n    INTEGER(i64), DIMENSION(3):: ivec  != [fib(n), fib(n+1), 0 or 1 ];  => 0 = False, 1 = True \n    \n    ivec = [ZER, ONE, ZER]\n    \n    do while (product(ivec(1:2)) < prod)\n      ivec(2) = sum(ivec(1:2))\n      ivec(1) = ivec(2) - ivec(1)\n    end do\n    \n    if (product(ivec(1:2)) == prod) then\n      ivec(3) = ONE\n    end if\n    \n  END FUNCTION\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82826,"user_id":187,"body":"MODULE Solution\n  IMPLICIT NONE\n  !INTEGER, PARAMETER:: i64 = SELECTED_INT_KIND(16)\n  \n  INTEGER(8), PARAMETER:: ZER = 0   ! False\n  INTEGER(8), PARAMETER:: ONE = 1   ! True\n  \n  PUBLIC:: product_fib\n  \n  CONTAINS\n  \n  FUNCTION product_fib(prod) RESULT(ivec)\n    INTEGER(8),  INTENT(IN) :: prod\n    INTEGER(8), DIMENSION(3):: ivec  != [fib(n), fib(n+1), 0 or 1 ];  => 0 = False, 1 = True \n    INTEGER(8) :: i, one, two, three \n    INTEGER(8), ALLOCATABLE, DIMENSION(:) :: F\n    logical :: switch\n    switch = .True.\n    ivec(:) = (\/0,1,1\/)\n    if (prod == 0) then\n       ivec(:) = (\/0,1,1\/)\n    endif\n    ALLOCATE(F(nint(sqrt(REAL(prod,8)))))\n    one = 1\n    two = 1\n    three = 1\n    i = 3\n    F(1:2) = (\/1,1\/)\n    do while (three <= nint(sqrt(REAL(prod,8))))\n        three = one + two \n        F(i) = three\n        one = two \n        two = three \n        i = i+1\n    enddo \n    do i=1, size(F)\n        if (F(i)*F(i+1) == prod) then\n          ivec(1) = F(i)\n          ivec(2) = F(i+1)\n          ivec(3) = 1\n          switch = .False.\n        endif\n    enddo\n    if (switch) then\n    do while (one*two < prod)\n        three = one + two \n        one = two \n        two = three \n    enddo \n          ivec(1) = one\n          ivec(2) = two\n          ivec(3) = 0\n    endif \n   END FUNCTION\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82827,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\n  \n  PUBLIC:: product_fib\n  \n  CONTAINS\n  \n  FUNCTION product_fib(prod) RESULT(ivec)\n    INTEGER, PARAMETER:: i64 = SELECTED_INT_KIND(16) \n    INTEGER(i64), INTENT(IN) :: prod\n    INTEGER(i64), PARAMETER:: ZER = 0_i64   ! False\n    INTEGER(i64), PARAMETER:: ONE = 1_i64   ! True\n    INTEGER(i64), DIMENSION(3):: ivec  != [fib(n), fib(n+1), 0 or 1 ];  => 0 = False, 1 = True \n    INTEGER(i64) :: k2\n    ivec(:)=ZER   \n    k2=ONE\n    do while (ivec(1)*ivec(2)<prod)\n      ivec(2)=ivec(1)+k2\n      ivec(1)=k2\n      k2=ivec(2)\n      !\n      ! check if fib(n)*fib(n+1)=prod \n      if (ivec(1)*ivec(2)==prod) then\n         ivec(3)=ONE    ! a hit\n         exit\n      endif\n    enddo\n  END FUNCTION\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82828,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\n  PRIVATE\n  INTEGER, PARAMETER:: i64 = SELECTED_INT_KIND(16)\n  \n  INTEGER(i64), PARAMETER:: ZER = 0_i64   ! False\n  INTEGER(i64), PARAMETER:: ONE = 1_i64   ! True\n  \n  PUBLIC:: product_fib\n  \n  CONTAINS\n  \n  FUNCTION product_fib(prod) RESULT(ivec)\n    INTEGER(i64),  INTENT(IN) :: prod\n    INTEGER(i64), DIMENSION(3):: ivec  != [fib(n), fib(n+1), 0 or 1 ];  => 0 = False, 1 = True \n    INTEGER(i64) :: old1\n    ivec(1) = ZER\n    ivec(2) = ONE\n    DO WHILE (ivec(1)*ivec(2) < prod)\n      old1 = ivec(1)\n      ivec(1) = ivec(2)\n      ivec(2) = old1 + ivec(2)  \n    END DO\n    IF (ivec(1)*ivec(2) == prod) THEN\n      ivec(3) = ONE !true\n    ELSE\n      ivec(3) = ZER !false\n    END IF\n  END FUNCTION\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82829,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\n  INTEGER, PARAMETER:: j64 = SELECTED_INT_KIND(16)\n  \n  INTEGER(j64), PARAMETER:: ZER = 0_j64   ! False\n  INTEGER(j64), PARAMETER:: ONE = 1_j64   ! True\n  \n  PUBLIC:: product_fib\n  \n  CONTAINS\n  \n  FUNCTION product_fib(prod) RESULT(ivec)\n    INTEGER(j64),  INTENT(IN) :: prod\n    INTEGER(j64), DIMENSION(3):: ivec  != [fib(n), fib(n+1), 0 or 1 ];  => 0 = False, 1 = True \n    INTEGER(j64) :: max_val, i0, i1, tmp, found, diff\n    i0 = 0\n    i1 = 1\n    max_val = int(sqrt(real(prod,16)),j64)\n    found = ZER\n    do while (.true.)\n      diff = prod - i0 * i1\n      if (diff == 0) then\n        found = ONE\n        EXIT\n      else if (diff < 0) then\n        EXIT\n      end if\n      tmp = i1\n      i1 = i0 + i1\n      i0 = tmp\n    end do\n    ivec(1) = i0\n    ivec(2) = i1\n    ivec(3) = found\n  END FUNCTION\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5544c7a5cb454edb3c000047":[{"id":82830,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER RECURSIVE FUNCTION bouncing_ball(h, b, w) RESULT (res)\n    IMPLICIT NONE\n    REAL :: h, b, w\n    \n    IF (h <= 0 .or. b <= 0 .or. b >= 1 .or. w >= h .or. w <= 0) THEN\n      res = -1\n    ELSE\n      res = 2 + bouncing_ball(h * b, b, w)\n    END IF\n    \n  END FUNCTION bouncing_ball\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82831,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION bouncing_ball(h, bounce, window) RESULT(res)\n    IMPLICIT NONE\n    REAL :: h, hh, bounce, window\n    INTEGER :: seen\n\n    IF ((h <= 0) .OR. (window >= h) .OR. (bounce <= 0) .OR. (bounce >= 1)) THEN\n        res = -1\n        RETURN\n    END IF\n    seen = -1; hh = h\n    DO WHILE (hh > window)\n        seen = seen + 2\n        hh = hh * bounce\n    END DO\n    res = seen\n  END FUNCTION bouncing_ball\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82832,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION bouncing_ball(h, bounce, window) RESULT(res)\n    IMPLICIT NONE\n    REAL :: h, hh, bounce, window\n    INTEGER :: seen\n\n    IF ((h <= 0) .OR. (window >= h) .OR. (bounce <= 0) .OR. (bounce >= 1)) THEN\n        res = -1\n        RETURN\n    END IF\n    seen = -1; hh = h\n    DO WHILE (hh > window)\n        seen = seen + 2\n        hh = hh * bounce\n    END DO\n    res = seen\n  END FUNCTION bouncing_ball\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82833,"user_id":168,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION bouncing_ball(h, bounce, window)\n    IMPLICIT NONE\n    REAL :: h, bounce, window\n    if (h <= 0 .or. bounce <= 0 .or. bounce >= 1 .or. window >= h) then\n      bouncing_ball = -1\n    else\n      bouncing_ball = 2 * ceiling(log(window \/ h) \/ log(bounce)) - 1\n    end if\n    \n  END FUNCTION bouncing_ball\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82834,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n    INTEGER FUNCTION bouncing_ball(h, bounce, window) result(ans)\n    IMPLICIT NONE\n    REAL :: h, bounce, window, h_tmp\n    INTEGER :: counter_ball\n    if ((h<=0).or.(bounce<=0).or.(bounce>1).or.(window>=h)) then\n        ans = -1\n        return\n    end if\n\n    h_tmp = h\n    counter_ball = 0\n    counter_ball = ceiling(log(window\/h)\/log(bounce))\n    ans = (counter_ball-1)*2 + 1\n    return\n    END FUNCTION bouncing_ball\n\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82835,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  recursive INTEGER FUNCTION bouncing_ball(h, bounce, window) result(a)\n    IMPLICIT NONE\n    REAL :: h, bounce, window\n    \n    IF(h .LE. 0 .OR. bounce .LE. 0 .OR. bounce .GE. 1 .OR. window .GE. h)THEN\n      a = -1\n    ELSE\n      a = 2 + bouncing_ball(h*bounce, bounce, window)\n    END IF\n    \n  END FUNCTION bouncing_ball\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82836,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n\n  INTEGER FUNCTION bouncing_ball(h, bounce, window)\n    IMPLICIT NONE\n    REAL, intent(in) :: h, bounce, window !don't think intent was necessary but still...\n    Real :: height\n    Integer :: answer\n    \n    \n    if(h>0 .and. 1>bounce .and. bounce>0 .and. h>window) then !just checking all conditions\n    \n        height = h\n        answer = 1 !on the first way down\n\n        do while(height*bounce > window) !this bounce makes sure it happens again the first time\n\n            height = height*bounce\n\n            answer = 1 + 1 + answer !on the way up + on the way down\n        end do\n\n          if(height == window)then !just in case the mother juust sees the ball, height*bounce = window\n                answer = answer + 1\n          end if      \n\n           bouncing_ball = answer\n           return !don't know if return is necessary here, gotta check\n            \n    else\n\n        bouncing_ball = -1\n        return !here too\n    \n    end if\n    \n    !loads of fun!\n  \n    \n  END FUNCTION bouncing_ball\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82837,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION bouncing_ball(h, bounce, window) RESULT(count)\n    IMPLICIT NONE\n    REAL, INTENT(IN) :: h, bounce, window\n    REAL :: z\n    \n    count = -1\n    IF (h <= 0 .OR. bounce <= 0 .OR. bounce >= 1. .OR. window >= h) THEN\n      RETURN\n    END IF\n    \n    z = h \n    DO WHILE (z > window)\n      count = count + 2\n      z = z*bounce\n    END DO\n    \n  END FUNCTION bouncing_ball\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82838,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION bouncing_ball(h, bounce, window)\n    IMPLICIT NONE\n    REAL :: h, bounce, window\n    INTEGER :: Fval\n    REAL :: newh\n    Fval = -1\n    newh = h\n    \n    IF (window .GE. h) THEN\n        bouncing_ball = -1\n    END IF\n    \n    IF (bounce .GE. 1  .or. bounce .LE. 0) THEN\n        bouncing_ball = -1\n        newh = 0\n    END IF\n\n!!   it's 48 years since I learned Fortran. I thought that function would end\n!!   when bouncing_ball was given a value, but I needed to ensure it did\n!!   not enter the DO WHILE loop.\n    \n    IF (h .le. 0) THEN\n        bouncing_ball = -1\n    END IF\n \n    DO WHILE (newh .gt. window)\n        newh = newh * bounce\n        Fval = Fval + 2\n    END DO\n   bouncing_ball = Fval\n  \n  \n  \n  END FUNCTION bouncing_ball\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82839,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION bouncing_ball(h, bounce, window) RESULT(n)\n    IMPLICIT NONE\n    REAL :: h, bounce, window, h2\n    LOGICAL :: conds\n    h2  = h\n    n = -1\n    conds = (((h < 0) .OR. ((bounce <= 0) .OR. (bounce >= 1))) .OR. (window >= h))\n    \n    IF (.NOT. conds) THEN\n      DO WHILE (h2 > window)\n        h2 = h2 * bounce\n        n = n + 2\n      END DO\n    END IF\n    END FUNCTION bouncing_ball\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5545f109004975ea66000086":[{"id":82840,"user_id":76,"body":"module Solution\n  implicit none\ncontains\n  logical pure function is_divisible(n, x, y)\n    integer, intent(in) :: n, x, y\n    is_divisible = mod(n, x) + mod(n, y) == 0\n  end function is_divisible\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82841,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function is_divisible(n, x, y) result (res)\n    integer, intent(in) :: n, x, y\n    logical :: res\n    res = (mod(n,x) .eq. 0) .and. (mod(n,y) .eq. 0)\n  end function is_divisible\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82842,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  logical pure function is_divisible(n, x, y) result (res)\n    integer, intent(in) :: n, x, y\n    res = .true. ! your code here\n    if ((MODULO(n,y) \/= 0) .or. (modulo(n,x) \/= 0) ) res = .false.\n    \n    \n  end function is_divisible\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82843,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  logical pure function is_divisible(n, x, y) result (res)\n    integer, intent(in) :: n, x, y\n    if ((mod(n, x) .EQ. 0) .and. (mod(n,y) .EQ. 0)) then\n      res = .true.\n     else\n      res = .false.\n    end if\n  end function is_divisible\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82844,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  logical pure function is_divisible(n, x, y) result (res)\n    integer, intent(in) :: n, x, y\n    if(mod(n,x)==0 .and. mod(n,y)==0)then\n    res=.true.\n    else \n    res=.false.\n    endif\n  end function is_divisible\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82845,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  logical pure function is_divisible(n, x, y) result (res)\n    integer, intent(in) :: n, x, y\n    res = (MOD(n,x).eq.0).and.(MOD(n,y).eq.0) ! your code here\n  end function is_divisible\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82846,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  logical pure function is_divisible(n, x, y) result (res)\n    integer, intent(in) :: n, x, y\n    \n    res = .true.\n    if(modulo(n,x) \/= 0 .or. modulo(n,y) \/= 0) res = .false.\n!    res = mod(n,x) == 0 .and. mod(n,y) == 0\n  end function is_divisible\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82847,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  logical pure function is_divisible(n, x, y) result (rs)\n    integer, intent(in) :: n, x, y\n    if(mod(n,x) .eq. 0 .and. mod(n,y) == 0) then\n      rs = .true. \n    else\n      rs = .false.\n    end if\n  end function is_divisible\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82848,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  logical pure function is_divisible(n, x, y) result (res)\n    integer, intent(in) :: n, x, y\n    res = (mod(n, x) == 0) .and. (mod(n, y) == 0) ! your code here\n  end function is_divisible\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82849,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  logical pure function is_divisible(n, x, y) result (res)\n    integer, intent(in) :: n, x, y\n    res = n - n \/ x * x  + n - n \/ y * y == 0\n  end function is_divisible\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"55466989aeecab5aac00003e":[{"id":82850,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  FUNCTION sq_in_rect(lng, wdth) RESULT(str)\n    INTEGER, INTENT(IN):: lng, wdth\n    INTEGER :: llng, wwdth, aux\n    CHARACTER(:), allocatable :: str\n    CHARACTER (LEN=16) :: tmp\n\n    IF (lng == wdth) THEN \n      str = \"nil\"\n      RETURN\n    END IF\n    llng = lng; wwdth = wdth; str = \"\"\n    DO WHILE (llng > 0)\n      aux = MIN(llng, wwdth); llng = MAX(llng, wwdth); wwdth = aux\n      WRITE(tmp, fmt=\"(A, I0, A)\") \" \", wwdth, \" \"\n      str = str \/\/ TRIM(tmp)\n      llng = llng - wwdth\n    END DO\n    str = str(2: LEN(str))\n    \n  END FUNCTION sq_in_rect\n\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82851,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION sq_in_rect(x, y) RESULT(str)\n    INTEGER, INTENT(IN) :: x, y\n    integer :: a, b, c\n    character(:), allocatable :: str\n    character(50) stmp\n    a = x\n    b = y\n    if (a == b) then\n      str = \"nil\"\n    else\n      do while (a > 0 .and. b > 0)\n        c = merge(b, a, a > b)\n        write(stmp, \"(I0)\") c\n        str = trim(str)\/\/\" \"\/\/adjustl(stmp)\n        if (a > b) then\n          a = a - b\n        else\n          b = b - a\n        end if\n      end do\n      str = trim(adjustl(trim(str)))\n    end if    \n  END FUNCTION sq_in_rect\n\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82852,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  ! returns a string without trailing blanks\n  FUNCTION sq_in_rect(lng, wdth) RESULT(str)\n    INTEGER, INTENT(IN):: lng, wdth\n    CHARACTER(:), ALLOCATABLE :: str\n    CHARACTER(20) :: num\n    INTEGER :: size1, size2, i\n    \n    str = \"\"\n    if (lng > wdth) then\n      size1 = lng\n      size2 = wdth\n    else\n      size1 = wdth\n      size2 = lng\n    endif\n    \n    write(num, '(I0)') size2\n    str = str \/\/ trim(adjustl(num))\n    do while (size1 .ne. size2)\n      if (size1 - size2 < size2) then\n        i = size1\n        size1 = size2\n        size2 = i - size2\n      else\n        size1 = size1 - size2\n      endif\n      \n      write(num, '(I0)') size2\n      str = str \/\/ ' ' \/\/ trim(adjustl(num))\n    end do\n    \n    if (lng .eq. wdth) then\n      str = \"nil\"\n    endif\n  END FUNCTION sq_in_rect\n\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82853,"user_id":null,"body":"module solution\n    implicit none\ncontains\n    ! returns a string without trailing blanks\n    function sq_in_rect(lng, wdth) result(str1)\n        integer, intent(in):: lng, wdth\n        integer :: long, i, l, w\n        character(len = 400) :: str, num\n        character(len = :), allocatable :: str1\n        long = max(lng,wdth)\n        w = min(lng,wdth)\n        l = long\n\n        str = ''\n\n        str = trim(str)\n\n        if (l .eq. w) then\n            str = 'nil'\n        endif \n\n        do while (l .gt. w .and. w .gt. 0)\n            do i = 1,(l\/w)\n                write(num, *) w\n                num = trim(adjustl(num))\n                str = trim(adjustl(str))\n                str = trim(str)\/\/' '\/\/num\n                str = trim(adjustl(str))\n            end do\n            long = long - w*(l\/w)\n            l = w\n            w = long\n            long = l            \n        end do    \n        str = trim(str)\n        allocate(character(len=len_trim(str)) :: str1)\n        str1 = trim(str)\n               \n    end function sq_in_rect\n\nend module solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82854,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  ! returns a string without trailing blanks\n  FUNCTION sq_in_rect(lng, wdth) RESULT(str)\n    INTEGER, INTENT(IN) :: lng, wdth\n    CHARACTER(:), ALLOCATABLE :: str\n    CHARACTER(100) :: tmp\n    INTEGER :: l, w\n    str = \"\"\n    l = lng\n    w = wdth\n    \n    IF (l .EQ. w) THEN\n      str = \"nil\"\n      return\n    END IF\n    \n    DO WHILE (l .GT. 0 .AND. w .GT. 0)\n      IF (l .LE. w) THEN\n        WRITE(tmp, '(i0)') l\n        str = str \/\/ TRIM(tmp) \/\/ \" \"\n        w = w - l\n      ELSE\n        WRITE(tmp, '(i0)') w\n        str = str \/\/ TRIM(tmp) \/\/ \" \"\n        l = l - w\n      END IF\n    END DO\n    \n    str = TRIM(str)\n  END FUNCTION sq_in_rect\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82855,"user_id":null,"body":"module solution\n  implicit none\n  contains\n  pure function sq_in_rect(lng,wdth) result(str)\n    integer,intent(in) :: lng, wdth\n    character(len=:),allocatable :: str\n    character(len=100) :: cha\n    integer :: l, w\n    str=\"nil\"\n    l=lng\n    w=wdth\n    if(l==w) return\n    do while(l+w>1)\n      if(l>w) then\n        write(cha,*) w\n        str=str\/\/\" \"\/\/trim(adjustl(cha))\n        l=l-w\n      else if(l==w) then\n        write(cha,*) l\n        str=str\/\/\" \"\/\/trim(adjustl(cha))\n        exit\n      else\n        write(cha,*) l\n        str=str\/\/\" \"\/\/trim(adjustl(cha))\n        w=w-l\n      end if\n    end do\n    str=str(5:)\n  end function sq_in_rect\nend module solution\n\n\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82856,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  ! returns a string without trailing blanks\n  FUNCTION sq_in_rect(lng, wdth) RESULT(str)\n    INTEGER, INTENT(IN):: lng, wdth\n    INTEGER :: unit, sq_len, l, w\n    CHARACTER(:), allocatable :: str\n    CHARACTER(len=100) :: sq_str\n    CHARACTER(len=1000) :: tmp_str\n   \n    if ( lng == wdth ) then\n      str = \"nil\"\n    else\n      unit = lng * wdth\n      l = lng\n      w = wdth\n      tmp_str = \"\"\n      do while ( unit > 0 )\n        sq_len = min(l,w)\n        unit = unit - sq_len*sq_len\n        write(sq_str,'(I10)') sq_len\n        sq_str = adjustl(sq_str)\n        tmp_str = trim(tmp_str) \/\/ \" \" \/\/ sq_str(1:len_trim(sq_str))\n        if ( l > w ) then \n          l = l - sq_len\n        else \n          w = w - sq_len \n        end if\n        str = tmp_str(2:len_trim(tmp_str))\n      end do\n      \n    end if\n    \n  END FUNCTION sq_in_rect\n\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82857,"user_id":null,"body":"module solution\n  implicit none\ncontains\n\n  function sq_in_rect(length, width) result(str)\n    integer, intent(in) :: length, width\n    integer :: lng, wdth, i, val\n    character(:), allocatable :: str\n    character(6) :: tempstr\n    \n    lng = length\n    wdth = width\n    print *, \"length\", lng, \"width\", wdth\n    \n    str = \"\"\n    if (lng == wdth) then\n      str = \"nil\"\n      return\n    end if\n    do while (lng \/= 0 .and. wdth \/= 0)\n      if (lng >= wdth) then\n        lng = lng - wdth\n        val = wdth\n      else if (lng < wdth) then\n        wdth = wdth - lng\n        val = lng      \n      end if\n      print *, \"length\", lng, \"width: \", wdth, \"val: \", val\n      write(tempstr, '(i5)') val\n      str = str \/\/ trim(adjustl(tempstr)) \/\/ ' '\n      print *, \"string: \", str, \"tempstr: \", tempstr\n    end do\n    str = trim(str)\n  end function sq_in_rect\nend module solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82858,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  ! returns a string without trailing blanks\n  FUNCTION sq_in_rect(lng, wdth) RESULT(str)\n    INTEGER, INTENT(IN):: lng, wdth\n    integer :: n, length, width\n    character(len=16) :: tmp\n    character(:), allocatable :: str\n    tmp = \"\"\n    str = trim(tmp)\n    length = lng\n    width = wdth\n    if (length .ne. width) then\n      do while (length .ne. width)\n        n = min(length, width)\n        write(tmp,'(X I0)') n\n        str = str \/\/ trim(tmp)\n        ! order doesn't matter\n        length = max(length,width) - n\n        width = n\n      end do\n      write(tmp,'(X I0)') length\n      str = str(2:) \/\/ trim(tmp)\n    else\n    str = \"nil\"\n    end if\n  END FUNCTION sq_in_rect\n\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82859,"user_id":null,"body":"MODULE Solution\n                IMPLICIT NONE\n        CONTAINS\n        FUNCTION sq_in_rect(lng, wdth) RESULT(str)\n                CHARACTER(:), ALLOCATABLE :: str, buffer\n                INTEGER, INTENT(IN) :: lng, wdth\n                INTEGER :: i, a, b, c, max_in, work_len\n\n                IF (lng == wdth) THEN\n                        str = \"nil\"\n                ELSE\n                        max_in = MAX(wdth, lng)\n                        work_len = (1 + INT(LOG10(REAL(max_in)) + 1) * 2) * max_in\n                        ALLOCATE(CHARACTER(len = work_len) :: buffer)\n                        FORALL (i = 1:LEN(buffer))\n                                buffer(i:i) = ' '\n                        END FORALL\n                        a = MAX(lng, wdth)\n                        b = MIN(lng, wdth)\n                        DO WHILE (b > 0)\n                                WRITE (buffer, '(A, \" \", I0)') TRIM(buffer), MIN(a, b)\n                                c = (a - b)\n                                a = MAX(c, b)\n                                b = MIN(b, c)\n                        END DO\n                        str = TRIM(buffer(2:))\n                END IF\n        END FUNCTION sq_in_rect\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5547cc7dcad755e480000004":[{"id":82860,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  FUNCTION remove_nb(n) RESULT(str)\n    INTEGER, INTENT(IN):: n\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(KIND=ikind) :: i, s, b, l\n    CHARACTER(:), allocatable :: str\n    CHARACTER (LEN=32) :: tmp\n\n    str = \"\"; s = n * (n + 1_ikind) \/ 2_ikind; i = INT(n, ikind) \/ 2_ikind\n    DO WHILE (i <= n)\n      b = s - i\n      IF (MOD(b, i + 1_ikind) == 0_ikind) THEN\n        WRITE(tmp, fmt=\"(I0, A, I0, A)\") i, \" \", b \/ (i + 1_ikind), \",\"\n        str = str \/\/ TRIM(tmp)\n      END IF\n      i = i + 1\n    END DO\n    l = LEN(str)\n    str = str(1:l-1)\n  END FUNCTION remove_nb\n\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82861,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  FUNCTION remove_nb(n) RESULT(str)\n  \n    INTEGER, INTENT(IN):: n\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(KIND=ikind) :: x, m, y\n    CHARACTER(:), allocatable :: str\n    CHARACTER (LEN=32) :: buf\n    \n    str = \"\"\n    m = n * (n + 1_ikind) \/ 2_ikind\n    x = 1_ikind\n    DO WHILE (x <= n)\n      y = (m - x) \/ (x + 1_ikind)\n      IF ((y <= n) .AND. (x * y == m - x - y)) THEN\n        WRITE (buf, fmt=\"(I0, A, I0, A)\") x, \" \", y, \",\"\n        str = str \/\/ TRIM(buf)\n      END IF\n      x = x + 1_ikind\n    END DO\n    str = str(1:LEN(str)-1)\n    \n  END FUNCTION remove_nb\n\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82862,"user_id":null,"body":"MODULE Solution\n  USE iso_fortran_env, only: int64,int32\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION remove_nb(n) RESULT(str)\n    INTEGER, INTENT(IN):: n\n    CHARACTER(:), ALLOCATABLE :: str\n    CHARACTER(100) :: tmpstr\n    INTEGER(kind=int64) :: Spp,a,b\n    INTEGER(kind=int32) :: lb\n    str = \"\"\n    Spp = n*(n+1_int64)\/2 + 1\n    lb = (n+1)\/2\n    !print *,'lower bound',lb\n    DO a=lb,n !set lower bound to avoid unecessary work\n      IF (MOD(Spp,a+1) == 0) THEN\n        b = Spp\/(a+1) - 1\n        WRITE (tmpstr,'(I0,1X,I0)') a,b\n        IF (LEN(str) == 0) THEN\n          str = TRIM(tmpstr)\n        ELSE\n          str = str \/\/ ',' \/\/ TRIM(tmpstr)\n        END IF\n      END IF\n    END DO\n  END FUNCTION remove_nb\n\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82863,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION remove_nb(n)   RESULT(str)\n    INTEGER, INTENT(IN):: n\n    character(:), allocatable :: str\n    character(32) :: tmp\n    integer(16)   :: nsum\n    integer(8)  arr(1:2, 1:8), loc(1:2)\n    integer(8)  a, b, i, k, nn, s\n    real*4      bb\n    \n    nn = n;    str = \"\";    arr = 0;    i = 0\n    nsum = ((nn + 1) * nn) \/ 2;   !  print *, nsum\n    \n    a = n\/2;   s = 1;\n    do k=0, nn\/2\n      a = a + s*k;    s = -s      ! Work out both ways from middle\n      bb = (1.0*nsum - a) \/ (a + 1.0);   b  = nint(bb)\n      if (b > n) CYCLE;  ! print *, a, b\n      if (nsum - a - b == a*b) then\n        write(tmp,\"(I0)\") a\n        if (index(str, trim(tmp)) == 0) then\n          i = i + 1;  arr(1,i) = a;  arr(2,i) = b; \n          i = i + 1;  arr(1,i) = b;  arr(2,i) = a;  tmp = \"\"\n          write(tmp,\"(2(A,I0,1x,I0))\") \",\", a, b,  \",\", b, a\n          str = str \/\/ trim(tmp)  ! str is unordered at this point,\n        endif                     ! but has just been de-duplicated\n      endif\n    enddo\n    \n    ! write(*,\"(2I10)\") arr\n    str = \"\";   tmp = \"\";   loc = 0\n    do k=1, i   ! Results should be in arr(), retrieve in ascending order\n      loc = minloc(arr, DIM=2, MASK=arr .GT. 0);   s = loc(1)\n      write(tmp,\"(A,I0,1x,I0)\") \",\", arr(1,s), arr(2,s)\n      str = str \/\/ trim(tmp)\n      arr(1,s) = 0;    arr(2,s) = 0 ! (ignored by MASK, for minloc() ) !\n    enddo\n    str = trim(str(2:))\n  END FUNCTION remove_nb\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82864,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  ! return: a string without trailing blanks\n  FUNCTION remove_nb(n) RESULT(str)\n    INTEGER, INTENT(IN):: n\n    integer(kind=8) :: s, a, b, nn\n    character(:), allocatable :: str\n    character(len=64) :: tmp, fmt, sa, size_a, sb, size_b\n    logical :: first\n    real(kind=8) :: bb\n    first = .true.\n    nn = n\n    s = nn*(nn+1)\/2\n    ! fast solution\n    !! s - a - b = ab -> b = (s-a) \/ ( a+1), valid if 1 <= ans <= n...and not == a\n    do a = 1,nn\n      bb = real(s-a,8) \/ real(a+1,8)\n      if (floor(bb) == bb .and.  1. .le. bb .and. bb .le. n) then\n        b = int(bb)\n        ! string formatting is a mess in fortran...\n        write(size_a,*) a\n        write(size_b,*) b\n        write(sa,*) len(trim(adjustl(size_a)))\n        write(sb,*) len(trim(adjustl(size_b)))\n        fmt = \"(I\" \/\/ trim(sa) \/\/ \" X I\" \/\/ trim(sb) \/\/ \")\"\n        write(tmp,fmt) a, b\n        if (first) then\n          str = trim(tmp)\n          first = .false.\n        else\n          str = str \/\/ \",\" \/\/ trim(tmp)\n        end if     \n      end if\n    end do\n    ! slow solution\n    !do a = 1, n\n    !  s = s -a\n    !  do b = 1, n\n    !    s = s - b\n    !    if ( s == a*b) then\n    !      write(tmp,'(I2 X I2)') a, b\n    !      if (first) then\n    !        str = trim(tmp)\n    !        first = .false.\n    !      else\n    !        str = str \/\/ \",\" \/\/ trim(tmp)\n    !      end if\n    !    end if\n    !    s = s + b\n    !  end do\n    !  s = s + a\n    !end do\n  END FUNCTION remove_nb\n\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"554a44516729e4d80b000012":[{"id":82865,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  FUNCTION nb_months(st_price_old, st_price_new, sv_per_month, per_loss_by_month) RESULT(str)\n    INTEGER :: st_price_old, st_price_new, sv_per_month\n    INTEGER :: mth\n    REAL :: per_loss_by_month, perc_loss, price_old, price_new, saving, available\n    CHARACTER(:), allocatable :: str\n    CHARACTER (LEN=64) :: tmp\n\n    price_old = REAL(st_price_old); price_new = REAL(st_price_new)\n    saving = REAL(sv_per_month); available = REAL(st_price_old)\n    perc_loss = per_loss_by_month\n    mth = 0\n    DO WHILE (available < price_new)\n      ! at the end of this month\n      mth = mth + 1\n      IF (MOD(mth, 2) == 0) THEN\n        perc_loss = perc_loss + 0.5\n      END IF\n      price_old = price_old * (100.0 - perc_loss) \/ 100.0\n      price_new = price_new * (100.0 - perc_loss) \/ 100.0\n      available = REAL(mth) * saving + price_old\n    END DO\n    WRITE(tmp, fmt=\"(I0, A, I0)\") mth, \" \", NINT(available - price_new)\n    str = TRIM(tmp)\n  END FUNCTION nb_months\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82866,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  FUNCTION nb_months(st_price_old, st_price_new, sv_per_month, per_loss_by_month) RESULT(str)\n    INTEGER :: st_price_old, st_price_new, sv_per_month\n    INTEGER :: mth\n    REAL :: per_loss_by_month, perc_loss, price_old, price_new, saving, available\n    CHARACTER(:), allocatable :: str\n    CHARACTER (LEN=64) :: tmp\n\n    price_old = REAL(st_price_old); price_new = REAL(st_price_new)\n    saving = REAL(sv_per_month); available = REAL(st_price_old)\n    perc_loss = per_loss_by_month\n    mth = 0\n    DO WHILE (available < price_new)\n      ! at the end of this month\n      mth = mth + 1\n      IF (MOD(mth, 2) == 0) THEN\n        perc_loss = perc_loss + 0.5\n      END IF\n      price_old = price_old * (100.0 - perc_loss) \/ 100.0\n      price_new = price_new * (100.0 - perc_loss) \/ 100.0\n      available = REAL(mth) * saving + price_old\n    END DO\n    WRITE(tmp, fmt=\"(I0, A, I0)\") mth, \" \", NINT(available - price_new)\n    str = TRIM(tmp)\n  END FUNCTION nb_months\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82867,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION nb_months(p00, p11, s, rr) RESULT(str)\n    INTEGER :: p00, p11, s, m\n    REAL :: rr, r, t, p0, p1\n    character(:), allocatable :: str\n    character(128) stmp\n    m = 0.0\n    t = 0.0\n    r = rr\n    p0 = real(p00)\n    p1 = real(p11)\n    str = \"\"\n    if (p0 >= p1) then\n      write(stmp, fmt=\"(I0,A,I0)\") m, \" \", int(floor(p0 - p1))\n      str = trim(str)\/\/trim(stmp)\n    else\n      do while (t + p0 < p1)\n        m = m + 1\n        if (mod(m, 2) == 0) then\n          r = r + 0.5\n        end if\n        p0 = p0 - p0 * 0.01 * r\n        p1 = p1 - p1 * 0.01 * r\n        t = t + real(s)\n      end do\n      write(stmp, fmt=\"(I0,A,I0)\") m, \" \", int(floor(t + p0 - p1 + 0.5))\n      str = trim(str)\/\/trim(stmp)\n    end if\n  END FUNCTION nb_months\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82868,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  ! should return a string without trailing blanks\n  FUNCTION nb_months(st_price_old, st_price_new, sv_per_month, per_loss_by_month) RESULT(str)\n  INTEGER :: sv_per_month, month, st_price_old, st_price_new, total_savings, istr!dep_new, dep_old, istr\n  REAL :: per_loss_by_month, dep, lover, price, loss_percent, dep_old, dep_new\n  CHARACTER(:), allocatable :: str2, str3\n  CHARACTER(:), allocatable :: str\n  month = 0\n  total_savings = 0\n  dep_new = st_price_new\n  dep_old = st_price_old\n  loss_percent = per_loss_by_month\n  DO WHILE ((total_savings + dep_old) .lt. dep_new)\n    month = month + 1\n    IF(MOD(month, 2) .eq. 0) THEN\n      loss_percent = loss_percent + 0.5\n    END IF\n    total_savings = total_savings + sv_per_month\n    dep_old = dep_old - (dep_old * (loss_percent \/ 100))\n    dep_new = dep_new - (dep_new * (loss_percent \/ 100))\n  END DO\n  lover = (total_savings + dep_old) - dep_new\n  month = int(month)\n  lover = NINT(lover)\n  istr = digits(month) + digits(lover) + 3\n  allocate(character(len=istr) :: str)\n  write(str, 67)int(month),int(lover)\n  str = TRIM(str)\n67 format(i0,' ',i0)\n  END FUNCTION nb_months\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82869,"user_id":null,"body":"module solution\n\n\timplicit none\n\t\n\tcontains\n\t\n\tpure function nb_months(st_price_old,st_price_new,sv_per_month,per_loss_by_month) result(str)\n\t\tinteger,intent(in) :: st_price_old, st_price_new, sv_per_month\n\t\treal,intent(in) :: per_loss_by_month\n\t\tcharacter(len=:), allocatable :: str\n\t\tcharacter(len=100) :: cha1, cha2\n\t\tinteger :: tim\n\t\treal :: old, new, bud, los\n\t\ttim = 0\n\t\told = real(st_price_old)\n\t\tnew = real(st_price_new)\n\t\tbud = old\n\t\tlos = per_loss_by_month\n\t\tstr=\"\"\n\t\tdo while(bud < new)\n\t\t\ttim = tim + 1\n\t\t\tif(mod(tim,2)==0) los = los + 0.5\n\t\t\told = old*(1.-los\/100.)\n\t\t\tnew = new*(1.-los\/100.)\n\t\t\tbud = real(tim*sv_per_month) + old\n\t\tend do\n\t\twrite(cha1,*) tim\n\t\twrite(cha2,*) nint(bud-new)\n\t\tstr = str\/\/trim(adjustl(cha1))\/\/\" \"\/\/trim(adjustl(cha2))\n\t\tstr = trim(str)\n\tend function nb_months\t\n\t\nend module solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82870,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  ! should return a string without trailing blanks\n  FUNCTION nb_months(st_price_old, st_price_new, sv_per_month, per_loss_by_month) RESULT(str)\n    INTEGER :: st_price_old, st_price_new, sv_per_month\n    REAL :: per_loss_by_month\n    ! your code\n    LOGICAL :: AFFORDABLET\n    INTEGER :: NMONTH, DIFFERENCE\n    REAL :: CURR_OLD, CURR_NEW, SV_MONTH_R, CURR_PER_LOSS, SAVINGS\n    CHARACTER(Len=15) :: DUMMY\n    CHARACTER(:), ALLOCATABLE:: STR, SMONTH, SPRICE\n    \n    !turn everything into reals\n    CURR_OLD = FLOAT(ST_PRICE_OLD)\n    CURR_NEW = FLOAT(ST_PRICE_NEW)\n    SV_MONTH_R = FLOAT(SV_PER_MONTH)\n    CURR_PER_LOSS = PER_LOSS_BY_MONTH\n    \n    !check if we already can afford it, if not set logical to enter loop\n    IF (ST_PRICE_OLD.GE.ST_PRICE_NEW) THEN\n       AFFORDABLET = .TRUE.\n    ELSE\n       AFFORDABLET = .FALSE.\n    ENDIF\n    \n    NMONTH = 0\n    DO WHILE(.NOT.AFFORDABLET)\n        !increase month\n        NMONTH = NMONTH + 1\n        !adjust percentage loss\n        IF (MOD(NMONTH,2).EQ.0) CURR_PER_LOSS = CURR_PER_LOSS + 0.5   \n        !calculate new values\n        CURR_OLD = CURR_OLD * 0.01*(100.0 - CURR_PER_LOSS)\n        CURR_NEW = CURR_NEW * 0.01*(100.0 - CURR_PER_LOSS)\n        !check exit condition\n        IF ((CURR_OLD + NMONTH*SV_MONTH_R).GE.CURR_NEW) AFFORDABLET=.TRUE.    \n    END DO\n\n  DIFFERENCE = NINT(CURR_OLD + NMONTH*SV_MONTH_R - CURR_NEW)\n  !write strings - use of DUMMY to get correct length of strings\n  WRITE(DUMMY,*) NMONTH\n  SMONTH = ADJUSTL(TRIM(DUMMY))\n  WRITE(DUMMY,*) DIFFERENCE\n  SPRICE = ADJUSTL(TRIM(DUMMY)) \n  STR = ADJUSTL(TRIM(SMONTH))\/\/\" \"\/\/ADJUSTL(TRIM(SPRICE))\n\n  END FUNCTION nb_months\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82871,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION nb_months(st_price_old, st_price_new, sv_per_month, per_loss_by_month) RESULT(str)\n    INTEGER :: st_price_old, st_price_new, sv_per_month\n    REAL :: per_loss_by_month, now_per, cost\n    CHARACTER(len=:), allocatable :: string, a, b\n    CHARACTER(len=30) :: strorg\n    character(len=:), allocatable :: str\n    integer :: delta, i, now_money\n\n    delta = st_price_new-st_price_old\n    if (delta <= 0) then\n      write(strorg, '(I12)') 0\n      a = trim(adjustl(strorg))\n      write(strorg, '(I12)') ABS(delta)\n      b = trim(adjustl(strorg))\n      string = a \/\/ \" \" \/\/ b\n      allocate(character(len=len(string)) :: str)\n      str = string\n      RETURN\n    end if\n\n    cost = delta\n    now_per = per_loss_by_month\n    i=0\n    DO WHILE(I .le. 1000000000)\n        i = i + 1\n        now_money = i*sv_per_month\n        if(MOD(i,2) .eq. 0) then\n          now_per=now_per+0.5\n        end if\n        cost = cost*(1.0-now_per\/100)\n        if(now_money >= NINT(cost)) then\n          EXIT\n        end if\n    END DO\n    write(strorg, '(I15)') i\n    a = trim(adjustl(strorg))\n    write(strorg, '(I15)') NINT(now_money-cost)\n    b = trim(adjustl(strorg))\n    string = a \/\/ \" \" \/\/ b\n    allocate(character(len=len(string)) :: str)\n    str = string\n  END FUNCTION nb_months\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82872,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION nb_months(st_price_old, st_price_new, sv_per_month, per_loss_by_month) RESULT(str)\n    INTEGER :: st_price_old, st_price_new, sv_per_month, time\n    REAL :: per_loss_by_month, old, bank, growthrate, new\n    CHARACTER(:), ALLOCATABLE :: str\n    CHARACTER(LEN=120) :: str_temp\n\n    IF (st_price_old>=st_price_new) THEN\n      write(str_temp,'(I0)'), st_price_old-st_price_new\n      str = '0 '\/\/trim(str_temp) \n    ELSE\n      time = 0\n      old = st_price_old\n\t    bank = 0.0\n      new = st_price_new\n      growthrate = 1.0-.01*per_loss_by_month\n      do while (new>bank+old)\n        time = time + 1\n        if (mod(time,2)==0) then\n          growthrate = max(growthrate-.005,0.0)\n        end if\n\t\t    old = old*growthrate\n        new = new*growthrate\n        bank = bank + sv_per_month\n      end do\n\t  write(str_temp,'(I0)') time\n    str = trim(str_temp)\n    write(str_temp,'(I0)') nint(old+bank-new)\n    str = str \/\/' '\/\/ trim(str_temp)\n    END IF\n  END FUNCTION nb_months\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82873,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION nb_months(st_price_old, st_price_new, sv_per_month, per_loss_by_month) RESULT(str)\n    character(:), allocatable :: str\n    character(32) tmp\n    INTEGER :: st_price_old, st_price_new, sv_per_month, sav, mths\n    REAL    :: per_loss_by_month, pct, fac, old, new, bal, crdt\n    old=st_price_old;  new=st_price_new;  sav=sv_per_month;  pct=per_loss_by_month\n    mths = 0;   str = \"\"\n    bal = old - new\n    if (bal < 0) then\n      crdt = old\n      do while (crdt < new)\n        mths = mths + 1\n        if (mod(mths,2) == 0) pct = pct + 0.5\n        fac = 1 - pct\/100\n        old = old * fac;    crdt = mths*sav + old;   \n        new = new * fac;    bal  = crdt - new\n      enddo\n    endif\n    write(tmp,\"(I0,1x,I0)\")  mths, nint(bal+0.005)\n    str = trim(tmp)\n  END FUNCTION nb_months\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"554f76dca89983cc400000bb":[{"id":82874,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  FUNCTION sol_equa(n) RESULT(str)\n    INTEGER, INTENT(IN):: n\n    INTEGER :: i, x, x2, y2\n    CHARACTER(:), allocatable :: str\n    CHARACTER (LEN=64) :: tmp\n\n    str = \"\"; i = 1\n    DO WHILE (i * i <= n)\n      IF (MOD(n, i) == 0) THEN\n        x2 = i + n \/ i\n        IF (MOD(x2, 2) == 0) THEN\n          x = x2 \/ 2; y2 = x - i\n          IF (MOD(y2, 2) == 0) THEN\n            WRITE(tmp, fmt=\"(A, I0, A, I0, A)\") \" \", x, \" \", y2 \/ 2, \",\"\n            str = str \/\/ TRIM(tmp)\n          END IF\n        END IF\n      END IF\n      i = i + 1\n    END DO\n    str = str(2: LEN(str) - 1)\n  END FUNCTION sol_equa\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82875,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  FUNCTION sol_equa(n) RESULT(str)\n    INTEGER, INTENT(IN):: n\n    INTEGER :: i, x, x2, y2\n    CHARACTER(:), allocatable :: str\n    CHARACTER (LEN=64) :: tmp\n\n    str = \"\"; i = 1\n    DO WHILE (i * i <= n)\n      IF (MOD(n, i) == 0) THEN\n        x2 = i + n \/ i\n        IF (MOD(x2, 2) == 0) THEN\n          x = x2 \/ 2; y2 = x - i\n          IF (MOD(y2, 2) == 0) THEN\n            WRITE(tmp, fmt=\"(A, I0, A, I0, A)\") \" \", x, \" \", y2 \/ 2, \",\"\n            str = str \/\/ TRIM(tmp)\n          END IF\n        END IF\n      END IF\n      i = i + 1\n    END DO\n    str = str(2: LEN(str) - 1)\n  END FUNCTION sol_equa\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82876,"user_id":168,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  ! returns a string with no trailing blanks\n  FUNCTION sol_equa(n) RESULT(str)\n    INTEGER, INTENT(IN):: n\n    character(:), allocatable :: str\n    character(100) :: buf\n    integer :: k, q\n    \n    str = ''\n    k = 1\n    do while (k * k <= n)\n      if (mod(n, k) == 0) then\n        q = n \/ k\n        if (mod(q + k, 2) == 0 .and. mod(q - k, 4) == 0) then\n          write (buf,'(i0,a,i0)') ((q + k) \/ 2), ' ', ((q - k) \/ 4)\n          if (len(str) > 0) then\n            str = str \/\/ ', '\n          end if\n          str = str \/\/ trim(buf)\n        end if\n      end if\n      k = k + 1\n    end do\n    \n  END FUNCTION sol_equa\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82877,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION sol_equa(n) RESULT(res)\n    integer, intent(in) :: n\n    integer :: p, cnt\n    double precision :: d\n    character(:), allocatable :: res\n    character(128) stmp\n    res = \"\"\n    p = 1\n    cnt = 0\n    do while (p * p <= n)\n      if (mod(n, p) \/= 1) then\n        d = real(n,8) \/ real(p,8)\n        if (floor(d) == ceiling(d)) then\n          if (mod(floor(d) - p, 4) == 0) then\n            if (cnt > 0) then\n              write(stmp, fmt=\"(A,I0,A,I0)\") \", \", ((floor(d) + p) \/ 2), \" \", ((floor(d) - p) \/ 4)\n            else\n              write(stmp, fmt=\"(I0,A,I0)\") ((floor(d) + p) \/ 2), \" \", ((floor(d) - p) \/ 4)\n            end if\n            res = trim(res)\/\/trim(stmp)\n            cnt = cnt + 1\n          end if\n        end if\n      end if\n      p = p + 1\n    end do\n  END FUNCTION sol_equa\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82878,"user_id":null,"body":"module solution\n    implicit none\n    \n    contains\n    \n    pure subroutine get_pairs(num,q,p)\n        integer,intent(in) :: num\n        integer,dimension(int(sqrt(real(num)))),intent(out) :: q\n        integer,dimension(int(sqrt(real(num)))),intent(out) :: p\n        integer :: i\n        q = 0\n        p = 0\n        do i=1,int(sqrt(real(num))),1\n            if(mod(num,i)==0.and.(num\/i)*i==num)then\n                q(i)=num\/i\n                p(i)=i\n            end if\n        end do\n    end subroutine get_pairs\n    \n    function sol_equa(n) result(str)\n        integer,intent(in) :: n\n        character(len=:),allocatable :: str\n        integer,dimension(int(sqrt(real(n)))) :: q,p\n        character(len=100) :: a,b\n        integer :: i\n        call get_pairs(n,q,p)\n        str=\"\"\n        do i=1,int(sqrt(real(n))),1\n            if(q(i)+p(i)\/=0.and.mod(q(i)+p(i),2)==0.and.mod(q(i)-p(i),4)==0.and.q(i)-p(i)>=0)then\n                write(a,*) (q(i)+p(i))\/2\n                write(b,*) (q(i)-p(i))\/4\n                str = str\/\/trim(adjustl(a))\/\/\" \"\/\/trim(adjustl(b))\/\/\", \"\n            end if\n        end do\n        str=trim(str(1:len(str)-2))\n    end function sol_equa\n    \nend module solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82879,"user_id":null,"body":"MODULE Solution\nIMPLICIT NONE\nCONTAINS\n  ! returns a string with no trailing blanks\n  FUNCTION sol_equa(n) RESULT(str)\n    INTEGER, INTENT(IN):: n\n    integer :: xmin2y,i\n    character(len=20) :: aidstr1\n    character(:) ,allocatable :: str\n    str=\"\"\n    ! evaluate wether n is even or odd\n    if (mod(n,2) .eq. 0) then\n        xmin2y = 2\n    else \n        xmin2y = 1\n    end if\n    Do i = xmin2y,int(sqrt(real(n+1))),2 ! loop over all possible differencec between x an 2y this way we only have to try sqrt(n) values\n      if (mod((n-i**2),4*i) .eq. 0) then ! given the difference between x and 2y we can calculate y accoording to ((n-i*i)\/(4*i)) This has to be an integer. \n        write(aidstr1,\"(I0,' ',I0)\") ((n+i*i)\/(2*i)),((n-i*i)\/(4*i))\n        str = str\/\/\", \"\/\/trim(aidstr1)\n      end if\n    end do\n    str = trim(str(3:))   \n  END FUNCTION sol_equa\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82880,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION sol_equa(n) RESULT(str)\n    INTEGER, INTENT(IN):: n\n    character(:), allocatable :: str\n    character(50) tmp\n    integer(8) i, nlim, r1, r2, x, y, dR\n    str = \"\"\n    nlim = int(sqrt(1.0*n), 8)\n    do i=1, nlim\n      r1 = n\/i;  r2 = i;  dR = r1 - r2\n      if (mod(n,i)==0 .and. mod(dR,4)==0) then\n        y = dR\/4\n        x = r1 - 2*y\n        write(tmp, \"(A,I0,1X,I0)\") \", \", x, y\n        str = str\/\/trim(tmp)\n        CYCLE\n      end if\n    end do\n    str = str(3:)\n  END FUNCTION sol_equa\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"555624b601231dc7a400017a":[{"id":82881,"user_id":53,"body":"module Solution\n  implicit none\ncontains\n  integer pure function josephus_survivor(n, k) result (res)\n    integer, intent(in) :: n, k\n    integer :: i\n    res = 1\n    do i = 1, n\n      res = mod(res + k - 1, i) + 1\n    end do\n  end function josephus_survivor\nend module Solution","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82882,"user_id":50,"body":"module Solution\n  implicit none\ncontains\n  integer pure function josephus_survivor(n, k) result (res)\n    integer, intent(in) :: n, k\n    integer :: i\n    res = 0 ! your code here\n    do i = 2,n\n      res = mod(res + k, i)\n    end do\n    res = res + 1\n  end function josephus_survivor\nend module Solution","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82883,"user_id":null,"body":"  integer pure function josephus_survivor(n, k) result (res)\n    integer, intent(in) :: n, k\n    integer :: i\n    res = 1\n    do i=2,n\n       res = mod(res + k - 1,i) + 1\n    end do\n  end function josephus_survivor","lang_id":19,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82884,"user_id":null,"body":"  recursive function josephus_survivor(n, k) result (res)\n    integer, intent(in) :: n, k\n    integer :: res\n    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n      if (n == 1) then\n         res = 1\n      else\n         res = mod(josephus_survivor(n-1, k)+k-1,n)+1\n      endif\n  end function josephus_survivor","lang_id":19,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82885,"user_id":null,"body":"  integer pure function josephus_survivor(n, k)\n    integer, intent(in) :: n, k\n    integer :: i, j\n    i = 1\n    do j = 1, n\n      i = mod(i + k, j)\n    end do\n    josephus_survivor = i + 1\n  end function josephus_survivor","lang_id":19,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82886,"user_id":527,"body":"module Solution\n  implicit none\ncontains\n  integer pure function josephus_survivor(n, k)\n    integer, intent(in) :: n, k\n    integer :: i, j\n    i = 1\n    do j = 1, n\n      i = mod(i + k, j)\n    end do\n    josephus_survivor = i + 1\n  end function josephus_survivor\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82887,"user_id":645,"body":"module Solution\n  implicit none\ncontains\n  integer pure recursive function josephus_survivor(n, k) result (res)\n    integer, intent(in) :: n, k\n    if (n == 1) then\n      res = 1\n    else\n      res = mod(josephus_survivor(n - 1, k) + k - 1, n) + 1\n    end if\n  end function josephus_survivor\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"555bfd6f9f9f52680f0000c5":[{"id":82888,"user_id":null,"body":"module Solution\n  implicit none\n  \n  private\n  \n  public :: reverse_number\n\ncontains\n  \n  pure function reverse_number(n)\n    integer :: reverse_number\n    integer, intent(in) :: n\n    \n    integer :: c, tmp\n    \n    tmp = abs(n)\n    reverse_number = 0\n    do\n      c = mod(tmp,10)\n      tmp = tmp \/ 10\n      reverse_number = reverse_number * 10 + c\n      if (tmp .eq. 0) exit\n    end do\n    \n    if (n .lt. 0) reverse_number = -reverse_number\n    \n    return\n  end function reverse_number\n\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82889,"user_id":17,"body":"module Solution\n  implicit none\n  private\n  public :: reverse_number\ncontains\n  integer pure recursive function reverse_number(n) result(m)\n    integer, intent(in) :: n\n    integer :: tmp\n    if (n < 0) then\n      m = -reverse_number(-n)\n    else\n      m = 0\n      tmp = n\n      do while (tmp > 0)\n        m = m * 10 + mod(tmp, 10)\n        tmp = tmp \/ 10\n      end do\n    end if\n  end function reverse_number\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82890,"user_id":null,"body":"module Solution\n  implicit none\n  private\n  public :: reverse_number\ncontains\n  integer pure function reverse_number(n) result(m)\n    integer, intent(in) :: n\n    integer :: k\n    \n    k = abs(n)\n    m = 0 ! TODO\n    \n    do while (k\/10.GT.0.1)\n      m = m + MOD(k, 10)\n      m = m * 10\n      k = k \/ 10\n    end do\n\n    m = m + MOD(k, 10)\n    \n    if (n.LT.0) then\n      m = m * (-1)\n    end if\n    \n  end function reverse_number\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82891,"user_id":null,"body":"module Solution\n  implicit none\n  private\n  public :: reverse_number\ncontains\n  integer pure function reverse_number(n) result(m)\n    integer, intent(in) :: n\n    integer :: len,i,copy\n    \n    copy = n * sign(1,n)\n    do i=1,1000\n        if (modulo(copy,10**i) == copy) then\n            len = i-1\n            exit\n        end if    \n    end do\n\n    m = 0\n    do i = len,0,-1\n       m = m + modulo(copy,10)*10**(i)\n        copy = copy\/10\n    end do\n    m = m * sign(1,n) \n  end function reverse_number\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82892,"user_id":53,"body":"module Solution\n  implicit none\n  private\n  public :: reverse_number\ncontains\n  integer pure function reverse_number(n) result(m)\n    integer, intent(in) :: n\n    integer :: d, f, k\n    k = n\n    m = 0\n    if (k < 0) then\n      f = -1\n    else\n      f = 1\n    end if\n    k = k * f\n    do while (k > 0)\n      d = mod(k, 10)\n      k = k \/ 10\n      m = m * 10\n      m = m + d\n    end do\n    m = m * f\n  end function reverse_number\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82893,"user_id":null,"body":"module Solution\n  implicit none\n  private\n  public :: reverse_number\ncontains\n  pure function reverse_number(n) result(reverse)\n    integer, intent(in) :: n\n    integer :: i,b,length,digit,reverse\n    b=abs(n)\n    length=ceiling(log10(real(b)+1))-1\n    reverse=0\n    do i=length,0,-1\n        digit=b\/10**i\n        b=b-digit*10**i\n        reverse=reverse+digit*10**(length-i)\n    end do\n    if (n<0) then\n        reverse=-reverse\n    end if\n  end function reverse_number\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82894,"user_id":null,"body":"module Solution\n  implicit none\n  private\n  public :: reverse_number\ncontains\n  integer pure function reverse_number(n) result(m)\n    integer, intent(in) :: n\n    integer :: l, d, i, s, x\n    m = 0\n    x = abs(n)\n    i = 0\n    s = 1\n    if (n < 0) then\n      s = -1\n    end if\n    l = int(log10(real(x))) + 1\n    do i = l - 1, 0, -1\n      d = mod(x, 10)\n      m = m + d * 10 ** i\n      x = x \/ 10\n    end do\n    m = m * s\n  end function reverse_number\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82895,"user_id":null,"body":"module Solution\n  implicit none\n  private\n  public :: reverse_number\ncontains\n  integer pure function reverse_number(n) result(m)\n    integer, intent(in) :: n\n    integer :: pos,digit,temp\n    pos=abs(n)\n    temp=pos\n    m = 0 ! TODO\n    \n    do while(temp .gt. 0)\n    digit=mod(temp,10)\n    m=m*10+digit\n    temp=temp\/10\n    end do\n    if(pos .ne. n) m=-m\n    \n    \n  end function reverse_number\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82896,"user_id":null,"body":"module Solution\n  implicit none\n  private\n  public :: reverse_number\ncontains\n  integer function reverse_number(num) result(m)\n    integer, intent(in) :: num\n    integer :: n\n    n = num\n    m = 0\n    do while (abs(n)>0)\n      m = m*10\n      m = m+mod(n,10)\n      n = n\/10\n    end do\n  end function reverse_number\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82897,"user_id":null,"body":"module Solution\n  implicit none\n  private\n  public :: reverse_number\ncontains\n  integer pure function reverse_number(n) result(m)\n    integer, intent(in) :: n\n    integer :: r, d\n    integer :: i, j\n    m=0 \n    r=abs(n)\n    d=floor(log10(real(r)))+1\n    j=10**(d-1)\n    do i=1,d,1\n      m=m+(r-(r\/10)*10)*j\n      r=r\/10\n      j=j\/10\n    end do\n    m=sign(m,n)\n  end function reverse_number\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5592e3bd57b64d00f3000047":[{"id":82898,"user_id":17,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION find_nb(n)\n    INTEGER(8), INTENT(IN) :: n\n    REAL(10) :: x\n    find_nb = -1_8\n    x = (-1.0_10 + SQRT(1.0_10 + 8.0_10 * SQRT(REAL(n, 10)))) \/ 2.0_10\n    IF (MOD(x, 1.0_10) == 0.0_10) THEN\n      find_nb = INT(x, 4)\n    END IF\n  END FUNCTION find_nb\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82899,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION find_nb(n) RESULT(m)\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind) :: n, limit, ii\n    INTEGER :: m\n\n    limit = INT(SQRT(2.0) * REAL(n) ** 0.25 + 1.0)\n    DO ii = 0_ikind, limit\n        IF (ii * ii * (ii + 1_ikind) * (ii + 1_ikind) \/ 4_ikind == n) THEN\n            m = INT(ii)\n            RETURN\n        END IF\n    END DO\n    m = -1\n  END FUNCTION find_nb\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82900,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION find_nb(n) RESULT(m)\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind) :: n, limit, ii\n    INTEGER :: m\n\n    limit = INT(SQRT(2.0) * REAL(n) ** 0.25 + 1.0)\n    DO ii = 0_ikind, limit\n        IF (ii * ii * (ii + 1_ikind) * (ii + 1_ikind) \/ 4_ikind == n) THEN\n            m = INT(ii)\n            RETURN\n        END IF\n    END DO\n    m = -1\n  END FUNCTION find_nb\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82901,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION find_nb(n) RESULT(m)\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind) :: n,volume,counter\n\n    ! your code\n    volume = 0\n    counter = 0\n    DO WHILE(volume < n)\n      counter = counter + 1\n      volume = volume + counter**3\n    END DO\n    \n    IF(volume == n) THEN\n      m=counter\n    ELSE\n      m=-1\n    END IF\n      \n  END FUNCTION find_nb\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82902,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION find_nb(n)\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind) :: n, s, i\n    i = 1\n    s = 0\n    do\n      s = s + i**3\n      if (s == n) then\n        exit\n      else if (s > n) then\n        i = -1\n        exit\n      end if\n      i = i + 1\n    end do\n    find_nb = int(i, 4)\n    ! your code\n  END FUNCTION find_nb\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82903,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION find_nb(m)\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind) :: m,m1,n\n    n=0\n    m1=0\n    find_nb=-1\n    do while(m1<m)\n       n=n+1\n       m1=m1+n**3\n       if (m1==m) then\n         find_nb=n\n         exit\n       endif \n    enddo\n  END FUNCTION find_nb\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82904,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION find_nb(m) result(r)\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind), INTENT(IN) :: m\n    INTEGER(ikind) :: s, n\n    r = -1\n    s = 0\n    n = 0\n    do while (s < m)\n      n = n + 1\n      s = s + n * n * n\n    end do\n    if (s == m) then\n      r = n\n    end if\n  END FUNCTION find_nb\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82905,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION find_nb(m) RESULT(n)\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind) :: m, v, n\n\n    v = 1\n    n = 1\n    do while (v < m)\n      n = n + 1\n      v = v + n**3\n    end do\n    \n    if (v .ne. m) then\n      n = -1\n    endif\n    \n  END FUNCTION find_nb\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82906,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION find_nb(n)\n  INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n  INTEGER(ikind) :: n, total, n2, i, m\n  total = 0\n  m = 0\n  PRINT *, n\n  DO WHILE (total .lt. n)\n    total = 0\n    m = m + 1\n    n2 = m + 1\n    DO i = 1, n2\n      total = total + i**3\n    END DO\n  END DO\n  PRINT *, total\n  IF (total .eq. n) THEN\n    find_nb = m + 1\n  ELSE\n    find_nb = -1\n  END IF\n  END FUNCTION find_nb\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82907,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION find_nb(m) result(n)\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind), intent(in) :: m\n    integer(ikind) :: l, k\n    integer :: i,j\n    k = 0\n    l = 2*(m)**(1.\/2.)\n\n    l = (-1 + (1 + 4*l)**(1.\/2.))\/2\n    \n    k = (l*(l+1)\/2)**2\n    \n    print *, 'elp', m, 'elp', k\n  \n    if (m .ne. k) then\n        n = -1\n    else\n        n = l\n    endif      \n      \n    ! your code\n  END FUNCTION find_nb\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"559a28007caad2ac4e000083":[{"id":82908,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION perimeter(n) RESULT(m)\n    INTEGER, INTENT(IN) :: n\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind) :: m\n    INTEGER(ikind) :: I, A,B,A0\n    !\n    m = 0\n    A = 0\n    B = 1\n    DO I=1,n+1  !FIB(N+1)\n        A0= A\n        A = B\n        B = A0 + B\n        m = m + A\n    END DO\n    m = 4*m\n  END FUNCTION perimeter\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82909,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION perimeter(n) RESULT(m)\n    INTEGER, INTENT(IN) :: n\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind) :: m, a, b, t\n    INTEGER :: i\n\n    a = 1_ikind; b = 1_ikind; t = 1_ikind\n    DO i= 0, n + 1\n        t = a + b; a = b; b = t\n    END DO\n    m = 4 * (a - 1)\n  END FUNCTION perimeter\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82910,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION perimeter(n) RESULT(m)\n    INTEGER, INTENT(IN) :: n\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind) :: m, a, b, t\n    INTEGER :: i\n\n    a = 1_ikind; b = 1_ikind; t = 1_ikind\n    DO i= 0, n + 1\n        t = a + b; a = b; b = t\n    END DO\n    m = 4 * (a - 1)\n  END FUNCTION perimeter\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82911,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION perimeter(n) RESULT(m)\n    INTEGER, INTENT(IN) :: n\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind) :: m,i\n    integer(ikind), allocatable, dimension(:) :: test\n    ! your code\n    allocate(test(n+1))\n    test = 0\n    m = 0\n    test(1) = 1\n    test(2) = 1\n    do i = 3,n+1\n    test(i) = test(i-1) + test(i-2)\n    end do\n    do i = 1,n+1\n        m = m + 4*test(i)\n    end do\n  END FUNCTION perimeter\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82912,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  \n  FUNCTION perimeter(n) RESULT(m)\n    INTEGER, INTENT(IN) :: n\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind) :: m,fib,i,k1,k2,sum\n    k1=0\n    k2=1\n    sum=0\n    do i=1,n\n      fib=k1+k2\n      k1=k2\n      k2=fib\n      sum=sum+fib\n    enddo\n    m=4*sum+4\n  END FUNCTION perimeter\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82913,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION perimeter(n) RESULT(m)\n    INTEGER, INTENT(IN) :: n\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind) :: m, a, b\n    INTEGER :: i\n    ! your code\n    m = 1\n    a = 1\n    DO i = 0, n\n      ! a and m are the values for calculating the fibonacci sequence, b is a temporary\n      b = a\n      a = m\n      m = a + b\n    END DO\n    m = 4 * (m - 1)\n  END FUNCTION perimeter\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82914,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION perimeter(n) RESULT(m)\n    INTEGER, INTENT(IN) :: n\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind) :: m, mem, u0, u1\n    INTEGER :: i\n    \n    u0 = 1\n    u1 = 1\n    m = 2\n    do i = 2, n\n      mem = u1\n      u1 = u1 + u0\n      u0 = mem\n      m = m + u1\n    end do\n    \n    m = m * 4\n  END FUNCTION perimeter\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82915,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  RECURSIVE FUNCTION aux(n, a, b ,sum) RESULT(m)\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind), INTENT(IN) :: n, a, b, sum\n    INTEGER(ikind) :: m\n    if (n < 0) then\n      m = sum\n    else\n      m = aux(n - 1, b, a + b, sum + a * 4)\n    end if\n  END FUNCTION aux\n  \n  FUNCTION perimeter(n) RESULT(m)\n    INTEGER, INTENT(IN) :: n\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind) :: m, k\n    k = n\n    m = aux(k, 1_8, 1_8, 0_8)\n  END FUNCTION perimeter\n  \nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82916,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION perimeter(n) RESULT(m)\n    INTEGER, INTENT(IN) :: n\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind) :: m\n    INTEGER(ikind) :: i, p1, p2, tmp\n    \n    p1 = 1\n    p2 = 1\n    m = 2\n    \n    DO i = 2, n\n      tmp = p2\n      p2 = p1 + p2\n      p1 = tmp\n      m = m + p2\n    END DO\n    \n    m = m * 4\n  END FUNCTION perimeter\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82917,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION perimeter(n) RESULT(m)\n    INTEGER, INTENT(IN) :: n\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind) :: m\n    INTEGER(ikind) :: i, a0, a1, b, sum\n    \n    a0 = 1  ;  a1 = 1  ; sum = 2;\n    Do i = 2, n\n      b = a0 + a1  ;      a0 = a1\n      a1 = b       ;      sum = sum + b\n    End Do\n    m = 4*sum\n  END FUNCTION perimeter\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"559b8e46fa060b2c6a0000bf":[{"id":82918,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  FUNCTION chooseUY(n, k) RESULT(res)\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind) :: res\n    INTEGER :: n, k, i\n\n    IF (k > n -k) THEN\n      k = n - k\n    END IF\n    res = 1\n    DO i = 0, k - 1\n      res = res * INT(n - i, ikind)\n      res = res \/ INT(i + 1, ikind)\n    END DO\n  END FUNCTION chooseUY\n\n  FUNCTION diagonal(n, p) RESULT(res)\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind) :: res\n    INTEGER :: n, p\n\n    res = chooseUY(n + 1, p + 1)\n  END FUNCTION diagonal\n\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82919,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  FUNCTION diagonal(n, p) RESULT(res)\n    INTEGER, INTENT(IN) :: n, p\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind) :: res\n    INTEGER :: i, m, k\n\n    i = 1\n    res = 1\n    m = n + 1\n    k = p + 1\n    \n    do while (i <= k)\n      res = res * (m - i + 1) \/ i\n      i = i + 1\n    end do\n    \n  END FUNCTION diagonal\n\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82920,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  FUNCTION diagonal(n, p) RESULT(res)\n    INTEGER, intent(in) :: n, p\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind) :: res, i\n    res = 1\n    do i = 1, p + 1\n      res = res * (i + n - p) \/ i\n    end do\n  END FUNCTION diagonal\n\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82921,"user_id":null,"body":"module Solution\n\n  implicit none\n  \ncontains\n  \n  function diagonal(n, p) result(res)\n    integer, intent(in) :: n, p\n    integer, parameter :: ikind = selected_int_kind(16)\n    integer(ikind) :: res\n    integer :: i\n    \n    res = 1\n    do i = 1, p+1, 1\n      res = res * (n - p + i) \/ i\n    end do\n    \n    return\n  end function diagonal\n\nend module Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82922,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\t\n  FUNCTION diagonal(n, p) RESULT(res)\n    INTEGER, INTENT(IN) :: n, p\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind) :: res\n    INTEGER :: c    \n    res = 0  \n    do c = p,n\n      res = res + NCR(c,p)\n    end do     \n  END FUNCTION diagonal\n  \n  FUNCTION NCR(up,down) result(out)\n    INTEGER, INTENT(IN) :: up, down\n    INTEGER, PARAMETER :: ikind=selected_int_kind(24)\n    INTEGER(ikind) :: out\n    integer :: x, y, L\n    integer, dimension(:), allocatable :: numer, denom\n    logical, dimension(:), allocatable :: touse\n    L = min(down, up-down)\n    allocate(numer(L)); allocate(denom(L)); allocate(touse(L))\n    touse = .True.\n    do x = 1, L\n      numer(x) = up - x + 1\n      denom(x) = x\n    end do\n    out = 1\n    \n    do x = 1, L\n      !first check if you can cancel out some things\n      do y = 1, L\n        if (touse(y) .and. mod(numer(x),denom(y)) == 0) then\n          numer(x) = numer(x)\/denom(y)\n          touse(y) = .False.\n        end if\n      end do\n      out = out * numer(x)\n    end do\n    \n    do x = 1, L\n      if (touse(x)) then\n        out = out\/denom(x)\n      end if\n    end do\n  END FUNCTION NCR\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82923,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\tFUNCTION diagonal(n, p) RESULT(res)\n\t\tINTEGER, INTENT(IN) :: n, p\n\t\tINTEGER, PARAMETER :: ikind=selected_int_kind(32)\n\t\tINTEGER(ikind) :: res\n\t\tINTEGER\t\t:: I\n\t\t! Calculates the combination COMB(n+1,p+1)\n\t\t! Because we should not calculate the factorial,\n\t\t! a more simple method is used to divide out\n\t\t! most of the terms.\n\t\tRES = n + 1\n\t\tDO I = 1, p\n\t\t\tRES = RES * (n + 1 - I)\/I\n\t\tEND DO\n\t\tRES = RES\/(p + 1)\n\n\tEND FUNCTION diagonal\n\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82924,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION diagonal(n, p) RESULT(res)\n    INTEGER, INTENT(IN) :: n, p\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind) :: res\n    ! s = (n+1) C (p+1)  ! Sum of Pascal diagonal = \n    res = nCp(n+1, p+1)  ! next row & column value.\n  END FUNCTION diagonal\n  \n  FUNCTION nCp(n, p) \n    INTEGER, INTENT(IN) :: n, p\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind) :: nCp, i\n    nCp = 0;  if (p <= 0 .or. n <= p) RETURN\n    nCp = 1   !! nCp = (n)*(n-1)...(n-p+1)\/p!\n    do i = 0, p-1\n       nCp = nCp * (n-i) \/ (i+1)\n    end do                 !! Not guaranteed to be integer \n    nCp = nint(1.0D0*nCp, ikind) !! with the above division.\n    ! print *, \"nCp = \", nCp\n  END FUNCTION nCp\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"559ce00b70041bc7b600013d":[{"id":82925,"user_id":564,"body":"module Solution\n  implicit none\n  integer, parameter :: i_16=selected_int_kind(16)\ncontains\n  pure integer(i_16) function finance(n_8)\n    integer, intent(in) :: n_8\n    \n    integer(i_16) :: n\n    n = n_8;\n\n    finance = n * (n + 1) * (n + 2) \/ 2\n    \n  end function finance\nend module Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82926,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION finance(n) RESULT(m)\n    INTEGER, INTENT(IN) :: n\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind) :: m, k\n\n    k = n\n    m = k * (k + 1) * (k + 2) \/ 2\n\n  END FUNCTION finance\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82927,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION finance(n) RESULT(m)\n    INTEGER, INTENT(IN) :: n\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind) :: m\n    ! your code\n    m = n\n    m = m * (n + 1) * (n + 2) \/ 2\n  END FUNCTION finance\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82928,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION finance(n) RESULT(m)\n    INTEGER, INTENT(IN) :: n\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind) :: m\n\n    m = INT8(n)\n    m = m * (m+1) * (m+2) \/ 2\n\n  END FUNCTION finance\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82929,"user_id":168,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION finance(n) RESULT(m)\n    INTEGER, INTENT(IN) :: n\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind) :: m\n    m = n\n    m = m * (m + 1) * (m + 2) \/ 2\n  END FUNCTION finance\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82930,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  function finance(n) result(m)\n    integer, intent(in) :: n\n    integer, parameter :: ikind=selected_int_kind(16)\n    integer(ikind) :: m, n_large\n\n    n_large = int(n, ikind)\n    m = (n_large**3 + 3*(n_large**2) + 2*n_large)\/2\n  end function finance\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82931,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION finance(n) RESULT(m)\n    INTEGER, INTENT(IN) :: n\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind) :: m\n    INTEGER :: i, j\n    \n    m = 0\n    !The first loop counts the number of weeks passed\n    DO i=0,n\n    !The second loop counts the number of days passed\n      DO j=i,n\n        !Each day, the amount saved increases by one\n        m = m + n\n      END DO\n    END DO\n    ! After n**2 iterations, the result is\n    PRINT *, m\n\n  END FUNCTION finance\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82932,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION finance(n) RESULT(m)\n    INTEGER, INTENT(IN) :: n\n    integer(16) :: m\n    integer :: i\n    m = 0\n    do i = 0,n\n      m = m + i*(i+1)*3\/2\n    end do\n\n  END FUNCTION finance\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82933,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION finance(n) RESULT(m)\n    INTEGER, INTENT(IN) :: n\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind) :: m\n    INTEGER :: i\n    \n    m = 0\n    i = 0\n    DO i = 0, n \n      m = m + 3*i*(i+1)\/2\n      !m = m + (n+3*i)*(n+1-i)\/2 !alternative formulation\n    END DO\n    \n  END FUNCTION finance\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82934,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION finance(n) RESULT(m)\n    INTEGER, INTENT(IN) :: n\n    INTEGER :: i\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind) :: m\n    m = 0\n    DO i = 1, n + 1, 1\n    m = m + ((i - 1) * 2 + n + i - 1)*(n + 2 - i) \/ 2\n    END DO\n    RETURN\n  END FUNCTION finance\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"55a29405bc7d2efaff00007c":[{"id":82935,"user_id":53,"body":"module Solution\n  implicit none\ncontains\n  function going(n) result(t)\n    integer, parameter :: ikind=selected_real_kind(p=18)\n    integer, intent(in) :: n\n    integer :: i\n    real(kind=ikind) :: t, m\n    t = 0\n    m = 1\n    do i = n, 1, -1\n      t = t + 1.0 \/ m\n      m = m * i\n    end do\n  end function going\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82936,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  \n  FUNCTION going(n) RESULT(res)\n    INTEGER :: n, i\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind) :: res, inter\n    \n    res = 1.0_ikind; inter = 1.0_ikind\n    DO i = n, 2, -1\n      inter = inter * (1.0_ikind \/ i)\n      res = res + inter\n    END DO\n    res = FLOOR(res * 1e6_ikind) \/ 1e6_ikind\n  END FUNCTION going\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82937,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  REAL(selected_real_kind(p=18)) FUNCTION going(n)\n    INTEGER, INTENT(IN) :: n\n    INTEGER :: i\n    going = 1\n    \n    DO i = 2, n\n      going = 1.\/i * going + 1\n    END DO\n  END FUNCTION going\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82938,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS \n    !\n    ! compute factorials   \n    function factorial(i,n) result(f)\n       INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n       integer :: n,i,j\n        REAL(kind=ikind) :: f\n        f=1.0_ikind\n        do j=i,n  \n           f= f*j  ! degenerated .. evaluate : n!\/(n-i)!\n           if (1\/f<0.000000000001_ikind) return ! to avoid overflow\n        end do \n     end function\n    !\n  FUNCTION going(n) result(u)\n    INTEGER :: n ,i \n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    real(ikind) :: u\n    u=1.0_ikind\n    do i=2,n\n       u=u+1.0_ikind\/factorial(i,n)\n    enddo\n  END FUNCTION going\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82939,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  \n  FUNCTION going(n)\n    INTEGER :: n,i\n    Double Precision :: inverse, res, going\n    \n    res = 1.0D0\n    inverse = 1.0D0\n    \n    Do i = 1, n - 1\n      inverse = 1.0D0*inverse\/(n + 1 - i)\n      res = res + inverse\n    End Do\n    going = 1.0D-6 * floor(res*1.0D6)\n    \n  END FUNCTION going\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82940,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION going(n)\n    INTEGER :: n, i\n    INTEGER, PARAMETER :: long = SELECTED_REAL_KIND(p=18)\n    real(long) going\n    going = 0\n    do i=1, n\n      going = going\/i + 1.0\n    end do\n    ! going = int(going * 1.0D6)\/1.0D6                  ! Diff. ~ 5.E-17\n    going  =  int(going * 10.0_long**6) \/ 10.0_long**6  ! Diff. =  zero\n  END FUNCTION going\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"55aa075506463dac6600010d":[{"id":82941,"user_id":17,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  PURE FUNCTION list_squared(m, n)\n    INTEGER, INTENT(IN) :: m, n\n    INTEGER :: p, divisor_sum, i\n    CHARACTER(:), ALLOCATABLE :: list_squared\n    CHARACTER(11) :: buf\n    list_squared = \"\"\n    DO p = m, n\n      divisor_sum = 0\n      DO i = 1, CEILING(SQRT(REAL(p))) - 1\n        IF (MOD(p, i) == 0) THEN\n          divisor_sum = divisor_sum + i * i + (p \/ i) * (p \/ i)\n        END IF\n      END DO\n      IF (FLOOR(SQRT(REAL(p))) * FLOOR(SQRT(REAL(p))) == p) THEN\n        divisor_sum = divisor_sum + p\n      END IF\n      IF (FLOOR(SQRT(REAL(divisor_sum))) * FLOOR(SQRT(REAL(divisor_sum))) == divisor_sum) THEN\n        WRITE(buf, \"(I0)\") p\n        list_squared = list_squared \/\/ \"(\" \/\/ TRIM(buf)\n        WRITE(buf, \"(I0)\") divisor_sum\n        list_squared = list_squared \/\/ \" \" \/\/ TRIM(buf) \/\/ \")\"\n      END IF\n    END DO\n  END FUNCTION list_squared\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82942,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION list_squared(m, n) RESULT(res)\n    character(:), allocatable :: res\n    character(50) stmp\n    INTEGER, INTENT(IN) :: m, n\n    integer(4) i, j, s, sq\n    do i=m, n\n      sq = i*i\n      do j=1, i\/2\n        if (mod(i,j)==0) sq = sq + j*j\n      end do\n      s = anint(sqrt(1.0*sq))\n      if (s*s == sq) then    !(mod(s,sq)==0) then\n        write(stmp, \"(A,I0,A,I0,A)\") \"(\", i, \" \", sq, \")\"\n        res = trim(res)\/\/trim(stmp)\n      end if\n    end do\n  END FUNCTION list_squared\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82943,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  INTEGER FUNCTION sum_of_squared_div(n) RESULT(res)\n    INTEGER :: i, n, m, sm\n\n    m = n \/ 2; sm = n * n\n    DO i = 1, m\n      IF (MOD(n, i) == 0) THEN\n        sm = sm + i * i\n      END IF\n    END DO\n    IF (INT(SQRT(DBLE(sm))) ** 2 == sm) THEN\n      res = sm\n    ELSE\n      res = 0\n    END IF\n  END FUNCTION sum_of_squared_div\n\n  FUNCTION list_squared(m, n) RESULT(res)\n    INTEGER :: i, m, n, sq\n    CHARACTER(:), allocatable :: res\n    CHARACTER (LEN=32) :: tmp\n\n    res = \"\"\n    DO i = m, n\n      sq = sum_of_squared_div(i)\n      IF (sq \/= 0) THEN\n        WRITE(tmp, fmt=\"(A, I0, A, I0, A)\") \"(\", i, \" \", sq, \")\"\n        res = TRIM(res) \/\/ tmp\n      END IF\n    END DO\n    sq = LEN(TRIM(res))\n    res = res(1:sq)\n  END FUNCTION list_squared\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82944,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  INTEGER FUNCTION sum_of_squared_div(n) RESULT(res)\n    INTEGER :: i, n, m, sm\n\n    m = n \/ 2; sm = n * n\n    DO i = 1, m\n      IF (MOD(n, i) == 0) THEN\n        sm = sm + i * i\n      END IF\n    END DO\n    IF (INT(SQRT(DBLE(sm))) ** 2 == sm) THEN\n      res = sm\n    ELSE\n      res = 0\n    END IF\n  END FUNCTION sum_of_squared_div\n\n  FUNCTION list_squared(m, n) RESULT(res)\n    INTEGER :: i, m, n, sq\n    CHARACTER(:), allocatable :: res\n    CHARACTER (LEN=32) :: tmp\n\n    res = \"\"\n    DO i = m, n\n      sq = sum_of_squared_div(i)\n      IF (sq \/= 0) THEN\n        WRITE(tmp, fmt=\"(A, I0, A, I0, A)\") \"(\", i, \" \", sq, \")\"\n        res = TRIM(res) \/\/ tmp\n      END IF\n    END DO\n    sq = LEN(TRIM(res))\n    res = res(1:sq)\n  END FUNCTION list_squared\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82945,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION list_squared(m, n) RESULT(res)\n    character(:), allocatable :: res\n    character(50) stmp\n    INTEGER, INTENT(IN) :: m, n\n    integer(4) i, j, s, sq\n    do i=m, n\n      sq = i*i\n      do j=1, i\/2\n        if (mod(i,j)==0) sq = sq + j*j\n      end do\n      s = anint(sqrt(1.0*sq))\n      if (s*s == sq) then\n        write(stmp, \"(A,I0,A,I0,A)\") \"(\", i, \" \", sq, \")\"\n        res = trim(res)\/\/trim(stmp)\n      end if\n    end do\n  END FUNCTION list_squared\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82946,"user_id":null,"body":"module solution\n    implicit none\n    contains\n\n    pure integer elemental function sum_of_squared_divisors(num)\n        integer,intent(in) :: num\n        integer :: i\n        \n        if (num == 1) then\n            sum_of_squared_divisors = 1\n        else\n            sum_of_squared_divisors = 1 + num**2\n        end if\n        \n        do i = 2,num\/2,1\n           if (mod(num,i) == 0) then\n             sum_of_squared_divisors = i**2 + sum_of_squared_divisors  \n           end if\n        end do\n        \n    end function sum_of_squared_divisors\n\n    pure logical function is_integer_sqrt(num)\n        integer,intent(in) :: num\n        integer :: val\n        val = int(sqrt(real(num,8)))\n        is_integer_sqrt = .false.\n        if(val*val==num) is_integer_sqrt = .true.\n    end function is_integer_sqrt\n      \n    pure function list_squared(m,n) result(res)\n        character(len=:),allocatable :: res\n        integer,intent(in) :: m, n\n        integer,dimension(n-m+1) :: arr1, arr2\n        integer :: i\n        character(len=100) :: cha1, cha2\n        \n        res = \"\"\n        \n        arr1 = [(i,i=m,n,1)]\n        arr2 = sum_of_squared_divisors(arr1)\n        \n        do i=1,n-m+1\n            if (is_integer_sqrt(arr2(i))) then\n                write(cha1,10) arr1(i)\n                write(cha2,10) arr2(i)\n                res = res\/\/\"(\"\/\/trim(adjustl(cha1))\/\/\" \"\/\/trim(adjustl(cha2))\/\/\")\"\n            end if\n        end do\n\n        10 format(i100)\n        \n    end function list_squared\n    \nend module solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"55ab4f980f2d576c070000f4":[{"id":82947,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION game(n) RESULT(str)\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER, INTENT(IN) :: n\n    INTEGER(ikind) :: m\n    character(:), allocatable :: str\n    character(50) stmp\n    m = n\n    if (mod(n, 2) == 0) then\n      write(stmp, \"(I0)\")  (m * m \/ 2)\n      str = trim(str)\/\/trim(stmp)\n      return\n    end if\n    write(stmp, \"(I0,A)\") (m * m), \", 2\"\n    str = trim(str)\/\/trim(stmp)\n  END FUNCTION game\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82948,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  ! returns a string\n  FUNCTION game(n) RESULT(str)\n    integer, parameter :: largeint = selected_int_kind(16)\n    INTEGER, INTENT(IN) :: n\n    character(:), allocatable :: str\n    ! your code\n    character(len=16) :: buffer\n    integer(kind=largeint) :: intres, loc_n\n    loc_n = n   \n    \n    if (n == 0) then\n      str = \"0\"\n      return\n    end if\n    \n    intres = (loc_n-1)*loc_n\/2\n    if (mod(n,2) \/= 0) then\n      write (buffer,\"(I0,A2,I1)\") intres*2+n, \", \", 2\n      print *, \"res: \", intres\n    else\n      write (buffer,\"(I0)\") intres+n\/2\n    end if\n    str = trim(buffer)\n  END FUNCTION game\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82949,"user_id":null,"body":"MODULE Solution\n    IMPLICIT NONE\n  CONTAINS\n    ! returns a string \n    FUNCTION game(n) RESULT(str)\n        INTEGER, INTENT(IN) :: n\n        INTEGER(8)::m\n        CHARACTER(:), allocatable :: str\n        CHARACTER(LEN=32) :: tmp\n        m=INT8(n)\n        m=m**2\n        if ( MOD(m, 2_8)\/=0 ) then\n            WRITE(tmp,fmt=\"(I0, A)\") m,\", 2\"\n        else\n            WRITE(tmp,fmt=\"(I0)\") m\/2\n        end if\n        str=TRIM(tmp)\n    END FUNCTION game\n  END MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82950,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION game(n) RESULT(str)\n    INTEGER, INTENT(IN) :: n\n    INTEGER(8) :: m\n    CHARACTER(:), allocatable :: str\n    CHARACTER (LEN=32) :: tmp\n\n    m = INT8(n)\n    m = m * m\n    IF (MOD(m, 2_8) == 0) then\n        WRITE(tmp, fmt=\"(I0)\") m \/ 2\n    ELSE\n        WRITE(tmp, fmt=\"(I0, A)\") m, \", 2\"\n    END IF\n    str = TRIM(tmp)\n  END FUNCTION game\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82951,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\tFUNCTION game(n) RESULT(straux)\n\t\t! Calculates the simplified fraction of n^2 \/ 2. \n\t\tINTEGER, INTENT(IN) :: n\n\t\tINTEGER\t\t:: L, I\n\t\tINTEGER(KIND=selected_int_kind(16)) :: nlarge\n\t\tCHARACTER(LEN=30) :: str\n\t\tCHARACTER(LEN=:), ALLOCATABLE :: straux\n\t\tnlarge = n\t\t\t\t! Save the input n to a \"large n\" variable,\n\t\t\t\t\t\t\t! which can store much larger values\n\t\tIF(MOD(n, 2).EQ.1) THEN\n\t\t\tWRITE(str, '(i30)' )  nlarge*nlarge\n\t\t\tstr = ADJUSTL(str)\t\t! Move the non-empty chars to the beginning\n\t\t\tstr = trim(str) \/\/ \", 2\"\t! Add \"divided by two\" at the end\n\t\tELSE\n\t\t\tWRITE(str, '(i30)') nlarge*nlarge\/2\n\t\t\tstr = ADJUSTL(str)\n\t\t\tstr = trim(str)\n\t\tEND IF\n\t\tstr = trim(str)\t\t\t\t! Remove trailing whitespace\n\t\tL = LEN_TRIM(str)\n\t\t!WRITE (*,*) \"----\"\n\t\tALLOCATE(CHARACTER(LEN=L) :: straux )\n\t\tstraux(1:len_trim(str)) = str(1:len_trim(str))\n\tEND FUNCTION game\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82952,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION game(nn) RESULT(str)\n    INTEGER, INTENT(IN) :: nn\n    character(:), allocatable :: str\n    character(24) tmp\n    character(3)  denom\n    integer*16    isum, n\n    real(kind=16) sum\n    n = nn\n    str = \"\";     denom = \"\"\n    sum = 1.0D0 * n * n  ! \/2 later\n    if (mod(sum,2.0) < 0.0001) then\n      isum = sum\/2.0D0\n    else\n      isum = sum;     denom = \", 2\"\n    endif\n    write(tmp,\"(I0)\")  isum\n    str = trim(tmp) \/\/ trim(denom)\n  END FUNCTION game\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82953,"user_id":17,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  PURE FUNCTION game(n) RESULT(s)\n    INTEGER, INTENT(IN) :: n\n    CHARACTER(:), ALLOCATABLE :: s\n    CHARACTER(21) :: buf\n    IF (MOD(n, 2) == 0) THEN\n      WRITE(buf, \"(I0)\") INT(n, 8) ** 2 \/ 2_8\n      s = TRIM(buf)\n    ELSE\n      WRITE(buf, \"(I0)\") INT(n, 8) ** 2\n      s = TRIM(buf) \/\/ \", 2\"\n    END IF\n  END FUNCTION game\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82954,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION game(n) RESULT(str)\n    INTEGER, INTENT(IN) :: n\n    INTEGER(8) :: m\n    CHARACTER(:), allocatable :: str\n    CHARACTER (LEN=32) :: tmp\n\n    m = INT8(n)\n    m = m * m\n    IF (MOD(m, 2) == 0) then\n        WRITE(tmp, fmt=\"(I0)\") m \/ 2\n    ELSE\n        WRITE(tmp, fmt=\"(I0, A)\") m, \", 2\"\n    END IF\n    str = TRIM(tmp)\n  END FUNCTION game\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"55b4d87a3766d9873a0000d4":[{"id":82955,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION howmuch(m, n) RESULT(res)\n    character(:), allocatable :: res\n    character(128) stmp\n    integer, intent(in) :: m, n\n    integer :: i, a, b\n    res = \"[\"\n    a = min(n, m)\n    b = max(n, m)\n    do i = a, b\n      if ((mod(i, 9) == 1) .and. (mod(i, 7) == 2)) then\n        write(stmp, \"(A,I0,A,I0,A,I0,A)\") \"[M: \", i, \" B: \", (i \/ 7), \" C: \", (i \/ 9), \"]\"\n        res = trim(res)\/\/trim(stmp)\n      end if\n    end do\n    res = res\/\/\"]\"\n  END FUNCTION howmuch\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82956,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  ! returns a string without trailing blanks\n  FUNCTION howmuch(m, n) RESULT(str)\n    INTEGER, INTENT(IN):: m, n\n    character(:), allocatable :: str\n    character(256) :: buf\n    integer :: i, mm, nn\n    \n    if (m < n) then\n      mm = m\n      nn = n\n    else\n      mm = n\n      nn = m\n    end if\n    \n    str = \"[\"\n    do i=mm,nn\n      if (mod(i,7) \/= 2 .or. mod(i,9) \/= 1) cycle    \n      write (buf,\"(A,I0,A,I0,A,I0,A)\") \"[M: \", i,\" B: \", i\/7, \" C: \", i\/9, \"]\"\n      str = str \/\/ trim(buf)  \n    end do    \n    str = str \/\/ \"]\"\n  END FUNCTION howmuch\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82957,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  FUNCTION howmuch(m, n) RESULT(str)\n    INTEGER, INTENT(IN):: m, n\n    INTEGER :: start, limit, i\n    CHARACTER(:), allocatable :: str\n    CHARACTER (LEN=128) :: tmp\n\n    IF (m < n) THEN\n        start = m; limit = n\n    ELSE\n        start = n; limit = m\n    END IF\n    str = \"[\"\n    DO i = start, limit\n      IF (MOD(i, 9) == 1 .AND. MOD(i, 7) == 2) THEN\n        WRITE(tmp, fmt=\"(A, I0, A, I0, A, I0, A)\") \"[M: \", i, \" B: \", i \/ 7, \" C: \", i \/ 9, \"]\"\n        str = str \/\/ TRIM(tmp)\n      END IF\n    END DO\n    str = TRIM(str) \/\/ \"]\"\n  END FUNCTION howmuch\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82958,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  ! returns a string without trailing blanks\n  FUNCTION howmuch(m, n) RESULT(str)\n    INTEGER, INTENT(IN):: m, n\n    integer :: mm, nn, ret\n    character(:), allocatable :: str\n    character(len=20) :: b, c, f\n    character(len=1000) :: res\n    mm = min(m, n)\n    nn = max(m, n)\n    ret = mm \/ 63 * 63 + 37\n    res = \"\"\n    b = \"\"\n    c = \"\"\n    f = \"\"\n    if (ret < mm) then\n      ret = ret + 63\n    end if\n    do while (ret <= nn)\n      write(f, '(i5)') ret\n      write(b, '(i5)') (ret \/ 7)\n      write(c, '(i5)') (ret \/ 9)\n      res = trim(res) \/\/ \"[M: \" \/\/ trim(adjustl(f)) \/\/ \" B: \" \/\/ trim(adjustl(b)) \/\/ \" C: \" \/\/ trim(adjustl(c)) \/\/ \"]\"\n      print *, f, b, c, res\n      ret = ret + 63\n    end do\n    str = \"[\" \/\/ trim(res) \/\/ \"]\"\n  END FUNCTION howmuch\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82959,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  ! returns a string without trailing blanks\n  pure FUNCTION howmuch(m, n) RESULT(str)\n    INTEGER, INTENT(IN):: m, n\n    integer :: i\n    character(:), allocatable :: str, tmpstr\n    character(64) :: strM, strB, strC\n    \n    str = trim(\"[\")\n    do i = min(m,n),max(m,n)\n      if (mod(i, 7) == 2 .and. mod(i, 9) == 1) then\n        write(strM, \"(I0)\") i\n        write(strB, \"(I0)\") (i-2)\/7\n        write(strC, \"(I0)\") (i-1)\/9\n        tmpstr = \"[M: \"\/\/trim(strM)\/\/\" B: \"\/\/trim(strB)\/\/\" C: \"\/\/trim(strC)\/\/trim(\"]\")\n        str = trim(str)\/\/trim(tmpstr)\n      end if\n    end do\n    str = trim(str)\/\/trim(\"]\")\n    \n    \n  END FUNCTION howmuch\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82960,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  ! returns a string without trailing blanks\n  FUNCTION howmuch(m, n) RESULT(str)\n    INTEGER, INTENT(IN):: m, n\n    character(:), allocatable :: str\n    character(256) :: buf\n    integer :: i, b,c, mm, nn\n    str = \"[\"\n    \n    if (m < n) then\n      mm = m\n      nn = n\n    else\n      mm = n\n      nn = m\n    end if\n    \n    ! unoptimized\n    do i=mm,nn\n      if (mod(i,7) \/= 2 .or. mod(i,9) \/= 1) cycle    \n      write (buf,\"(A,I0,A,I0,A,I0,A)\") \"[M: \", i,\" B: \", i\/7, \" C: \", i\/9, \"]\"\n      str = str \/\/ trim(buf)  \n    end do    \n    str = str \/\/ \"]\"\n  END FUNCTION howmuch\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82961,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  ! returns a string without trailing blanks\n  FUNCTION howmuch(m, n) RESULT(str)\n    INTEGER, INTENT(IN):: m, n\n    character(:), allocatable :: str\n    character(256) :: buf\n    integer :: i, b,c, mm, nn\n    str = \"[\"\n    \n    if (m < n) then\n      mm = m\n      nn = n\n    else\n      mm = n\n      nn = m\n    end if\n    \n    ! unoptimized\n    do i=mm,nn\n      do b=1,i\n        if (i - (7*b) == 2) then\n          do c=1,i\n            if (i - (9*c) == 1) then              \n              write (buf,\"(A,I0,A,I0,A,I0,A)\") \"[M: \", i,\" B: \", b, \" C: \", c, \"]\"\n              str = str \/\/ trim(buf)              \n            end if\n          end do\n        end if        \n      end do      \n    end do    \n    str = str \/\/ \"]\"\n  END FUNCTION howmuch\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82962,"user_id":null,"body":"module solution\n  implicit none\ncontains\n  ! returns a string without trailing blanks\n  function howmuch(m, n) result(str)\n    integer, intent(in):: m, n\n    character(:), allocatable :: str\n    character(len=30) :: buf\n    integer :: f, c, b\n    \n    str = \"[\"\n    \n    do f = min(m, n), max(m, n)\n      if ((mod(f - 1, 9) \/= 0) .or. (mod(f - 2, 7) \/= 0)) cycle\n      ! possible solution\n      c = (f - 1) \/ 9\n      b = (f - 2) \/ 7\n      write (buf, \"(A, I0, A, I0, A, I0, A)\") \"[M: \", f, \" B: \", b, \" C: \", c, \"]\"\n      str = str \/\/ trim(buf)\n    end do\n    str = str \/\/ \"]\"\n  end function howmuch\n\nend module solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82963,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  ! returns a string without trailing blanks\n  FUNCTION howmuch(m, n) RESULT(str)\n    INTEGER, INTENT(IN):: m, n\n    \n    integer :: min, max  ! max and minimum between m and n\n    integer :: ans_length  ! length of the string that holds the answer (str)\n    \n    character(len = 1000) :: str_ans  ! var that holds the answer without spaces\n    character(len = :), allocatable :: str  ! answer\n    character(len = 100) :: set  ! partial answer\n    character(len = 50) :: strb   ! conversion of boats to string\n    character(len = 50) :: strc  ! conversion of cars to string\n    character(len = 50) :: strm ! conversion of money to string\n    \n    integer :: b, c ! boats, cars\n    integer :: i  ! counter\n    \n    if (m > n) then\n      min = n\n      max = m\n    else\n      min = m\n      max = n\n    endif\n    \n    str_ans = \"[\"\n    do i = 0, (max-min)\n      b = ((min+i)-2)\/7\n      c = ((min+i)-1)\/9\n      if ((7*b + 2 == min + i) .and. (9*c + 1 == min + i)) then\n        write(strb,'(i7)') b\n        write(strc,'(i7)') c\n        write(strm,'(i7)') min+i\n      \n        set = \"[M: \"\/\/trim(adjustl(strm))\/\/\" B: \"\/\/trim(adjustl(strb))\/\/\" C: \"\/\/trim(adjustl(strc))\/\/ \"]\"\n        str_ans = trim(adjustl(str_ans))\/\/set\n      end if\n    end do\n    str_ans = trim(adjustl(str_ans))\/\/\"]\"\n    \n    ans_length = len(trim(adjustl(str_ans)))\n    allocate(character(ans_length) :: str)\n    str = trim(adjustl(str_ans))\n    \n  END FUNCTION howmuch\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82964,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION howmuch(m, n) RESULT(str)\n    character(:), allocatable :: str\n    character(64) tmp\n    INTEGER, INTENT(IN):: m, n\n    integer  f, m1, m2\n    real  b, c\n    str = \"[\"\n    m1 = min(m, n);   m2 = m + n - m1\n    do f=m1, m2\n      b = (f - 2.0)\/7.0;  if (b \/= int(b)) CYCLE\n      c = (f - 1.0)\/9.0;  if (c \/= int(c)) CYCLE\n      write(tmp,\"(3(A,I0),A)\") &\n            \"[M: \",f,\" B: \",int(b),\" C: \",int(c),\"]\"\n      str = str \/\/ trim(tmp)\n    enddo\n    str = str \/\/ \"]\"\n  END FUNCTION howmuch\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"55be10de92aad5ef28000023":[{"id":82965,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  INTEGER FUNCTION check_choose(m, n) RESULT(res)\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind) :: m, r\n    INTEGER :: n, i\n\n    i = 0\n    r = 1\n    res = -1\n    \n    do while (i <= n)   \n      if (r == m) then\n        res = i\n        exit\n      end if\n      r = r * (n - i) \/ (i + 1)\n      i = i + 1\n    end do\n    \n  END FUNCTION check_choose\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82966,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  INTEGER FUNCTION check_choose(m, n) RESULT(res)\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind) :: m, comb\n    INTEGER :: n, i\n    \n    do res = 1, n\/2\n      comb = 1\n      do i = 1, res\n        comb = comb * (n-i+1)\/i\n      end do\n      if (comb .eq. m) then\n        return\n      end if\n    end do\n    res = -1\n  END FUNCTION check_choose\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82967,"user_id":168,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  INTEGER FUNCTION check_choose(m, n) RESULT(res)\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind) :: m, c\n    INTEGER :: n, i\n    c = 1\n    do i = 0, n \/ 2\n      if (c == m) then\n        res = i\n        return\n      else if (c > m) then\n        exit\n      end if\n      c = c * (n - i) \/ (i + 1)\n    end do\n    res = -1\n  END FUNCTION check_choose\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82968,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  INTEGER FUNCTION check_choose(m, n) RESULT(res)\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind) :: m, num\n    INTEGER :: n\n    \n    res = 1\n    num = n\n    do while (num .lt. m .and. res .lt. n)\n      num = (num * (n - res)) \/ (res + 1)\n      res = res + 1\n    end do\n    \n    if (num .ne. m) then\n      res = -1\n    endif\n  END FUNCTION check_choose\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82969,"user_id":null,"body":"module Solution\n  implicit none\n  private\n  public :: check_choose\ncontains\n! - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  function check_choose(m, n) result(res)\n    integer, parameter :: ikind=selected_int_kind(16)\n    integer(ikind) :: m\n    integer :: n\n    integer :: res\n    integer :: i\n    ! - - - - - - - - - - - - - - - - - - - - - - - - - - -\n    res = -1\n    do i = 1, n\n      if (bin_coeff(n, i) == m) then\n        res = i\n        exit\n      endif\n    enddo\n    ! - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  end function check_choose\n  !\n  function bin_coeff(n, m) result(res)\n    integer, parameter :: ikind=selected_int_kind(35)\n    integer, intent(in) :: n, m\n    integer(ikind) :: res\n    integer(ikind) :: i, up_part, down_part, rest\n    integer :: count \n    ! - - - - - - - - - - - - - - - - - - - - - - - - - - -\n    up_part = 1\n    down_part = 1\n    rest = 1\n    count = 0\n    do i = n - m + 1, n\n      count = count + 1\n      if (count <= 20) then\n        up_part = up_part * i\n      else\n        rest = rest * i\n      endif\n    enddo\n    do i = 1, m\n      down_part = down_part * i\n    enddo\n    res = (up_part \/ real(down_part, 8)) * rest\n    ! - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  end function bin_coeff\n! - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82970,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION check_choose(m, n) RESULT(res)\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind), INTENT(IN) :: m\n    INTEGER, INTENT(IN) :: n\n    INTEGER(16) :: factorial\n    INTEGER :: i, j, k\n    \n    DO i = 1, INT(CEILING(n\/2.))\n      factorial = 1\n      j = n\n      k = 1\n      DO WHILE (j .GE. n-i+1)\n        factorial = factorial * j\n        j = j - 1\n        \n        IF (k .LE. i) THEN\n          factorial = factorial \/ k\n          k = k + 1\n        END IF\n      END DO\n      \n      IF (factorial .EQ. m) THEN\n        res = i\n        RETURN\n      END IF\n    END DO\n    \n    res = -1\n  END FUNCTION check_choose\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82971,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  INTEGER FUNCTION check_choose(m, n) RESULT(res)\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind) :: m,x,nn, right\n    INTEGER :: n, i\n    ! nCr = m = (n*(n-1)*..*(n-x+1)) \/ (x!)\n    nn = n\n    res = -1\n    do x = 1, nn\n      ! If we haven't found it yet then don't bother\n      if (x > nn\/2 + 1 ) then\n        res = -1\n        exit\n      end if\n      right = 1 \n      ! Divide right away\n      do i = 0, x-1\n        right = right*(nn-i) \/ (i+1)\n      end do\n      if (right == m) then\n        res = x\n        exit\n      end if\n    end do \n    ! your code\n  END FUNCTION check_choose\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82972,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  INTEGER FUNCTION check_choose(m, n) RESULT(res)\n    IMPLICIT NONE\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind) :: m, rres\n    INTEGER :: n, i\n\n    rres = 1\n    DO i = 0, n\n      IF (rres == m) THEN\n        res = i\n        RETURN\n      END IF\n      rres = rres * INT(n - i, ikind) \/ (INT(i, ikind) + 1)\n    END DO\n    res = -1\n  END FUNCTION check_choose\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82973,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION check_choose(m, n) RESULT(res)\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind) :: m\n    INTEGER :: i, j, k, n, x, z\n    real(16) nn\n    res = -1\n    do x = 1, n\/2   ! m = n! \/ (x! * (n - x)!)\n      j = 1\n      nn = 1\n      z = x;  k = n - x;  if (k > z) then\n      k = x;  z = n - x;  end if\n      do i = z+1, n\n        j = j + 1\n        if (j > k) j = 1\n        nn = i * nn \/ j\n      end do\n      if (nint(nn, ikind) == m)  res = x\n    end do\n  END FUNCTION check_choose\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"55caf1fd8063ddfa8e000018":[{"id":82974,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  function arithmeticSequenceElements(a, d, n) result(sequence)\n    integer, intent(in) :: a, d, n\n    integer :: index, prevValue\n    character(:), allocatable :: sequence\n    character(50) :: temp\n\n    sequence = \"\"\n    prevValue = a\n    do index = 1, n\n      print*, prevValue\n    \n      if (len(sequence) > 0) then\n        sequence = sequence \/\/ \", \"\n      end if\n    \n      write(temp, *) prevValue\n      temp = adjustl(temp)\n      sequence = sequence \/\/ trim(temp)\n      \n      prevValue = prevValue + d\n    end do\n    \n    sequence = trim(sequence)\n    print*, sequence\n    \n  end function arithmeticSequenceElements\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82975,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  function arithmeticSequenceElements(a, d, n) result(sequence)\n    integer, intent(in) :: a, d, n\n    integer :: index, prevValue\n    character(:), allocatable :: sequence\n    character(50) :: temp\n    \n    print*, a\n    print*, d\n    print*, n\n    \n    \n    if (n > 0) then\n      allocate(character(n*3 - 2) :: sequence)\n    else \n      allocate(character(1) :: sequence)\n    end if\n      \n    sequence = \"\"\n    prevValue = a\n    do index = 1, n\n      print*, prevValue\n    \n      if (len(sequence) > 0) then\n        sequence = sequence \/\/ \", \"\n      end if\n    \n      write(temp, *) prevValue\n      temp = adjustl(temp)\n      sequence = sequence \/\/ trim(temp)\n      \n      prevValue = prevValue + d\n    end do\n    \n    sequence = trim(sequence)\n    print*, sequence\n    \n  end function arithmeticSequenceElements\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82976,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function arithmeticSequenceElements(a, d, n) result(sequence)\n    integer, intent(in) :: a, d, n\n    integer j, out\n    logical first\n    character(36) :: number\n    character(:), allocatable :: sequence\n    first = .TRUE.\n    sequence = \"\"\n    do j = 1, n\n      out = int(a) + (j-1) * int(d)\n      write(number, *) out\n      if (first) then\n        sequence = trim(adjustl(number))\n        first = .FALSE.\n      else\n        sequence = sequence\/\/\", \"\/\/trim(adjustl(number))\n      end if\n    end do\n  end function arithmeticSequenceElements\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82977,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function arithmeticSequenceElements(a, d, n) result(sequence)\n    integer, intent(in) :: a, d, n\n    character(:), allocatable :: sequence\n    character(6) :: number\n    integer :: i\n    \n    sequence = \"\"\n    do i=1, n\n      write(number, '(I6)') a + (i-1)*d\n      sequence = sequence \/\/ trim(adjustl(number))\n      if (i .lt. n) then\n        sequence = sequence \/\/ \", \"\n      endif\n    end do\n  end function arithmeticSequenceElements\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82978,"user_id":168,"body":"module Solution\n  implicit none\ncontains\n   function arithmeticSequenceElements(a, d, n) result(sequence)\n    integer, intent(in) :: a, d, n\n    character(:), allocatable :: sequence\n    character(20) :: num\n    integer :: i, x\n    sequence = \"\"\n    x = a\n    do i = 0, n - 1\n      if (i > 0) then\n        sequence = sequence \/\/ ', '\n      end if\n      write (num,'(i0)') x\n      sequence = sequence \/\/ trim(num)\n      x = x + d\n    end do\n  end function arithmeticSequenceElements\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82979,"user_id":null,"body":"module Solution\n  implicit none\ncontains\npure function arithmeticSequenceElements(a, d, n) result(sequence)\n  implicit none\n  integer, intent(in) :: a, d, n\n  integer :: i\n  character(:), allocatable :: sequence\n  integer, dimension(:), allocatable :: numbers\n  allocate(numbers(n))\n  allocate(character(len=1000)::sequence)\n  do i =1,n\n    numbers(i)=a+d*(i-1)\n  end do\n  write(sequence,'(100(i0,\", \"))') numbers\n  deallocate(numbers)\n  sequence=sequence(:len_trim(sequence)-1)\nend function arithmeticSequenceElements\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82980,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function arithmeticSequenceElements(a, d, n) result(sequence)\n    integer, intent(in) :: a, d, n\n    integer :: i\n    character(:), allocatable :: sequence\n    character(10) :: int_str\n    \n    sequence = \"\"\n    do i = 1, n\n      write(int_str, \"(g0)\") a + d*(i - 1)\n      sequence = sequence\/\/trim(int_str)\n      if (i .ne. n) then\n        sequence = sequence\/\/\", \"\n      endif\n    enddo\n  end function arithmeticSequenceElements\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82981,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function arithmeticSequenceElements(a, d, n) result(sequence)\n    integer, intent(in) :: a, d, n\n    character(:), allocatable :: sequence\n    integer :: i, num\n    character(len = 50) :: strTerm\n    \n    num = 0\n    \n    do i = 1, n\n      strTerm = \"\" !clear temp string\n      \n      num = a + (i-1)*d !calculate term i in sequence\n      \n      write(strTerm, *) num !convert num to string\n      strTerm = trim(strTerm)\n      \n      if (i == 1) then !no comma prior to first term\n        sequence = adjustl(trim(strTerm))\n      else\n        sequence = adjustl(trim(sequence)) \/\/ \", \" \/\/ adjustl(strTerm) !append temp string to sequence, left justify\n      end if  \n    end do\n    \n    sequence = trim(sequence) !remove whitespace\n    \n  end function arithmeticSequenceElements\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82982,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function arithmeticSequenceElements(a, d, n) result(sequence)\n    integer, intent(in) :: a, d, n\n    character(:), allocatable :: sequence\n    integer::nn,cur\n    character(LEN=100)::temp\n    if(n==0)then\n    sequence = \"\"\n    stop\n    end if\n    cur=a+d\n    nn=1\n    write(temp,'(i0)')a\n    sequence=trim(temp)\n    do while(nn<n)\n    write(temp,'(i0)')cur\n    sequence=sequence\/\/', '\/\/trim(temp)\n    nn=nn+1\n    cur=cur+d\n    end do\n  end function arithmeticSequenceElements\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82983,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function arithmeticSequenceElements(a, d, n) result(sequence)\n    integer, intent(in) :: a, d, n\n    character(:), allocatable :: sequence\n    !local variables\n    integer :: i, current\n    character(len=124) :: tempString\n    \n    if (n == 0) then \n      sequence = \"\"\n      stop\n    end  if\n    \n    write(tempString,'(i0)') a\n    sequence = trim(tempString)\n    current = a\n    do i = 2,n\n    current = current + d\n    write(tempString,'(i0)') current\n    sequence = sequence \/\/ \", \" \/\/ trim(tempString)\n    end  do\n  end function arithmeticSequenceElements\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"55cbc3586671f6aa070000fb":[{"id":82984,"user_id":53,"body":"module Solution\n  implicit none\ncontains\n  logical pure function check_for_factor(base, factor) result (res)\n    integer, intent(in) :: base, factor\n    res = MOD(base, factor) == 0\n  end function check_for_factor\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82985,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  logical pure function check_for_factor(base, factor) result (res)\n    integer, intent(in) :: base, factor\n    res = .true. ! your code here\n    \n    if (mod(base, factor) .ne. 0) then\n      res = .false.\n    end if\n  end function check_for_factor\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82986,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  logical pure function check_for_factor(base, factor) result (res)\n    integer, intent(in) :: base, factor\n      \n    res = (modulo(base,factor)==0) ! your code here\n  end function check_for_factor\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82987,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  logical pure function check_for_factor(base, factor) result (res)\n    integer, intent(in) :: base, factor\n    if(mod(base,factor)==0)then\n    res = .true. \n    else \n    res=.false.\n    endif\n  end function check_for_factor\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82988,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  logical pure function check_for_factor(base, factor) result (res)\n    integer, intent(in) :: base, factor\n    res = modulo(base, factor).EQ.0.0\n  end function check_for_factor\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82989,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  logical pure function check_for_factor(base, factor) result (res)\n    integer, intent(in) :: base, factor\n    res = .false. ! your code here\n    if (mod(base,factor) == 0) then\n      res = .true.\n    end if\n  end function check_for_factor\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82990,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  logical pure function check_for_factor(base, factor) result (res)\n    integer, intent(in) :: base, factor\n    res = modulo(base, factor) == 0\n  end function check_for_factor\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82991,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  logical pure function check_for_factor(base, factor) result (res)\n    integer, intent(in) :: base, factor\n    res = .true. \n\n    if (mod(base,factor) .eq. 0 ) then\n       res = .true.\n    else\n       res = .false.\n    end if\n  end function check_for_factor\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82992,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  logical pure function check_for_factor(base, factor) result (res)\n    integer, intent(in) :: base, factor\n    res = .false.\n    if (mod(base, factor) == 0) res = .true.\n  end function check_for_factor\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82993,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  logical function check_for_factor(base, factor) result (res)\n    integer, intent(in) :: base, factor\n    if (int(base\/factor).eq.(real(base)\/factor)) then\n      res = .true.\n    else\n      res = .false.\n    end if\n  end function check_for_factor\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"55cf3b567fc0e02b0b00000b":[{"id":82994,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\n  PRIVATE :: unique_sort, avg_, range_, median_, partition\n  PUBLIC :: part\n\nCONTAINS\n\n    FUNCTION unique_sort(v) RESULT(unique)\n        integer :: i = 0, min_val, max_val\n        integer, ALLOCATABLE, DIMENSION(:) :: v\n        integer, ALLOCATABLE, DIMENSION(:) :: unique\n\n        ALLOCATE(unique(0))\n        min_val = minval(v)-1\n        max_val = maxval(v)\n        do while (min_val < max_val)\n            i = i+1\n            min_val = minval(v, mask = v > min_val)\n            unique = [unique, min_val]\n        end do\n\n    END FUNCTION\n\n    FUNCTION avg_(arr) RESULT(mean)\n        INTEGER, INTENT(IN), ALLOCATABLE, DIMENSION(:) :: arr\n        DOUBLE PRECISION :: mean\n\n        mean = SUM(arr) \/ (SIZE(arr) * 1.0d0)\n    END FUNCTION\n\n    FUNCTION range_(arr) RESULT(rg)\n        INTEGER, INTENT(IN), ALLOCATABLE, DIMENSION(:) :: arr\n        INTEGER :: rg\n\n        rg = arr(SIZE(arr)) - arr(1)\n    END FUNCTION\n\n    FUNCTION median_(arr) RESULT(md)\n        INTEGER, INTENT(IN), ALLOCATABLE, DIMENSION(:) :: arr\n        DOUBLE PRECISION :: md\n        INTEGER :: lg\n\n        lg = SIZE(arr)\n        IF ( mod(lg, 2) == 0 ) THEN\n          md = (arr(lg \/ 2 + 1) + arr(lg \/ 2)) \/ 2.0\n        ELSE\n          md = arr(lg \/ 2 + 1)\n       END IF\n    END FUNCTION\n\n    FUNCTION partition(n) Result(res)\n      INTEGER :: n, k, remain, prod, i\n      INTEGER, DIMENSION(0:n-1) :: p\n      INTEGER, ALLOCATABLE, DIMENSION(:) :: res\n\n      k = 0\n      p(k) = n\n      ALLOCATE(res(0))\n      DO WHILE (.TRUE.)\n          prod = 1\n          DO i = 0, k\n              prod = prod * p(i)\n          END DO\n          res = [res, prod]\n\n          remain = 0;\n          DO WHILE (k >= 0 .AND. p(k) == 1)\n              remain = remain + p(k)\n              k = k - 1\n          END DO\n\n          IF (k < 0) THEN\n              RETURN\n          END IF\n\n          p(k) = p(k) - 1\n          remain = remain + 1\n          DO WHILE (remain > p(k))\n              p(k+1) = p(k)\n              remain = remain - p(k)\n              k = k + 1\n          END DO\n          p(k + 1) = remain\n          k = k + 1\n      END DO\n    END FUNCTION\n\n    FUNCTION part(n) RESULT(str)\n      INTEGER, INTENT(IN) :: n\n      CHARACTER(:), ALLOCATABLE :: str\n      INTEGER, ALLOCATABLE, DIMENSION(:) :: res, r\n      DOUBLE PRECISION :: m, md\n      INTEGER :: rg\n      CHARACTER(len=256):: s\n\n      ALLOCATE(res(0))\n      res = partition(n)\n      r = unique_sort(res)\n      m = avg_(r)\n      md = median_(r)\n      rg = range_(r)\n      WRITE (s, 1010) rg, m, md\n      1010 FORMAT ('Range: ', I7, ' Average:', F9.2, ' Median:', F9.2)\n      DEALLOCATE(res)\n      DEALLOCATE(r)\n      str = ADJUSTL(TRIM(s))\n    END FUNCTION\n\nEND MODULE","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82995,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\n  PUBLIC :: part\n\n  INTEGER :: cache(40, 2699)\n    \nCONTAINS\n\n  FUNCTION part(n) RESULT(str)\n    INTEGER, INTENT(IN) :: n\n    CHARACTER(:), ALLOCATABLE :: str\n    CHARACTER(12) :: strData\n    INTEGER, DIMENSION(:), ALLOCATABLE :: ls\n    INTEGER :: i, k, l, r, s\n    REAL :: u, m\n    \n    ls = partition(n)\n    l = size(ls)\n    r = ls(l) - ls(1)\n    s = 0\n    DO i = 1, l\n      s = s + ls(i)\n    END DO\n    u = REAL(s) \/ l\n    m = 0.5 * REAL(ls(1 + l \/ 2) + ls(((l - 1) \/ 2) + 1))\n        \n    str = \"Range:\"\n    WRITE (strData, \"(I7)\") r\n    str = trim(str)\/\/\" \"\/\/strData\n    str = trim(adjustl(trim(str)))\n    str = str\/\/\" Average:\"\n    WRITE (strData, \"(F9.2)\") u\n    str = trim(str)\/\/strData\n    str = trim(adjustl(trim(str)))\n    str = str\/\/\" Median:\"\n    WRITE (strData, \"(F9.2)\") m\n    str = trim(str)\/\/strData\n    str = trim(adjustl(trim(str)))\n    PRINT *, str\n    \n    DEALLOCATE(ls)\n    \n  END FUNCTION\n  \n  RECURSIVE FUNCTION partition(n) RESULT (ls)\n    INTEGER, INTENT(IN) :: n\n    INTEGER, DIMENSION(:), ALLOCATABLE :: xs, ys, ls\n    INTEGER :: i, j\n    \n    IF (cache(n, 1) == 0) THEN\n      ALLOCATE(xs(0))\n      ALLOCATE(ys(0))\n      xs = [xs, 1]\n      DO i = 1, n\n        ys = partition(n - i)\n        DO j = 1, size(ys)\n          xs = [xs, i * ys(j)]\n        END DO\n      END DO\n      ls = Unique(xs)\n      DO i = 1, size(ls)\n        cache(n, i) = ls(i)\n      END DO\n      DEALLOCATE(ys)\n      DEALLOCATE(xs)\n      DEALLOCATE(ls)\n    END IF\n    \n    ALLOCATE(ls(0))\n    DO i = 1, 2699\n      IF (cache(n, i) == 0) THEN\n        EXIT\n      END IF\n      ls = [ls, cache(n, i)]\n    END DO\n    \n  END FUNCTION\n  \n  ! common utility functions\n\n  Recursive Subroutine MergeSort(temp, Begin, Finish, list)\n    implicit none\n    integer(kind=4),intent(inout) :: Begin,list(:),temp(:)\n    integer(kind=4),intent(in) :: Finish\n    integer(kind=4) :: Middle\n    if (Finish-Begin<2) then    \n       return                   \n    else\n       Middle = (Finish+Begin)\/2\n       call MergeSort(list, Begin, Middle, temp)\n       call MergeSort(list, Middle, Finish, temp)\n       call Merge(temp, Begin, Middle, Finish, list)\n     endif\n  End Subroutine MergeSort\n\n  Subroutine Merge(list, Begin, Middle, Finish, temp)\n    implicit none\n    integer(kind=4),intent(inout) :: list(:),temp(:)\n    integer(kind=4),intent(in) ::Begin,Middle,Finish\n    integer(kind=4)    :: kx,ky,kz\n    ky=Begin\n    kz=Middle\n    do kx=Begin,Finish-1\n       if (ky.lt.Middle.and.(kz.ge.Finish.or.list(ky).le.list(kz))) then\n          temp(kx)=list(ky)\n          ky=ky+1\n       else\n          temp(kx)=list(kz)\n          kz = kz + 1\n       end if\n    end do\n  End Subroutine Merge\n  \n  Function Unique(list)\n    integer(kind=4) :: strt,fin,N\n    integer(kind=4), intent(inout) :: list(:)\n    integer(kind=4), allocatable  :: unique(:),work(:)\n    logical,allocatable :: mask(:)\n    work=list;strt=1;N=size(list);fin=N+1\n    call MergeSort(work,strt,fin,list) \n    allocate(mask(N));\n    mask=.false.\n    mask(1:N-1)=list(1:N-1)==list(2:N)\n    unique=pack(list,.not.mask)\n  End Function Unique\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"55d24f55d7dd296eb9000030":[{"id":82996,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function summation(n) result (res)\n    integer, intent(in) :: n\n    integer :: res\n    res = n*(n+1)\/2\n  end function summation\nend module Solution","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82997,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure recursive function summation(n) result (res)\n    integer, intent(in) :: n\n    if (n == 1) then\n      res = 1\n    else\n      res = n + summation(n - 1)\n    end if\n  end function summation\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82998,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function summation(n) result (res)\n    integer, intent(in) :: n\n    integer :: i\n    res = 0\n    do i = 1, n\n      res = res + i\n    endDo\n    \n  end function summation\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":82999,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function summation(n) result (res)\n    integer, intent(in) :: n\n    integer::i\n    res = 0 \n    do i=1, n\n    res=i+res\n    enddo\n  end function summation\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83000,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function summation(n) result (res)\n    integer, intent(in) :: n\n    integer i\n    res = 0\n    do i = 1, n\n      res = res + i\n    end do\n  end function summation\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83001,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function summation(n) result (res)\n    integer, intent(in) :: n\n    integer :: m\n    res = 0\n    \n    do m = 1, n\n      res = res + m\n    end do\n    \n  end function summation\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83002,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function summation(n) result (res)\n    integer, intent(in) :: n\n    integer :: i\n    res = 0 ! your code here\n    do i = 1, n\n      res = res + i\n    end do\n  end function summation\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83003,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function summation(n) result (res)\n    integer, intent(in) :: n\n    integer :: i\n    res = 0 ! your code here\n    res = sum([(i, i = 1, n)])\n  end function summation\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83004,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function summation(n) result (res)\n    integer, intent(in) :: n\n    integer :: i\n    res = 0\n    do i = 1, n\n      res = res + i\n    end do\n!    i = 0\n!    do while(i <= n)\n!      res = res + i\n!      i = i + 1\n!    end do\n  end function summation\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83005,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure recursive function summation(n) result (res)\n    integer, intent(in) :: n   \n!    res = n*(n+1)\/2\n    if(n == 1) then\n      res = 1\n    else\n      res = n + summation(n - 1)\n    end if\n  end function summation\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"55e2adece53b4cdcb900006c":[{"id":83006,"user_id":17,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  PURE FUNCTION race(a, b, c) RESULT(s)\n    INTEGER, INTENT(IN) :: a, b, c\n    CHARACTER(:), ALLOCATABLE :: s\n    REAL :: x\n    CHARACTER(11) :: buf\n    IF (a >= b) THEN\n      s = \"-1 -1 -1\"\n    ELSE\n      x = REAL(c) \/ REAL(b - a)\n      WRITE(buf, \"(I0)\") FLOOR(x)\n      s = TRIM(buf) \/\/ ' '\n      x = 60 * (x - REAL(FLOOR(x)))\n      WRITE(buf, \"(I0)\") FLOOR(x)\n      s = s \/\/ TRIM(buf) \/\/ ' '\n      x = 60 * (x - REAL(FLOOR(x)))\n      WRITE(buf, \"(I0)\") FLOOR(x)\n      s = s \/\/ TRIM(buf)\n    END IF\n  END FUNCTION race\nEND MODULE Solution","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83007,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION race(v1, v2, g) RESULT(str)\n    INTEGER :: v1, v2, g, d, h, r, mn, s\n    CHARACTER(:), allocatable :: str\n    CHARACTER (LEN=16) :: tmp\n\n    d = v2 - v1\n    IF (d <= 0) THEN\n        str = \"-1 -1 -1\"\n        RETURN\n    END IF\n    h = g \/ d; r = MOD(g, d)\n    mn = r * 60 \/ d\n    s = MOD(r * 60, d) * 60 \/ d\n    WRITE(tmp, fmt=\"(I0, A, I0, A, I0)\") h, \" \", mn, \" \", s\n    str = TRIM(tmp)\n  END FUNCTION race\nEND MODULE Solution","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83008,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION race(v1, v2, g) RESULT(str)\n    INTEGER, INTENT(IN) :: v1, v2, g\n    INTEGER :: t, h, m, s\n    CHARACTER(:), allocatable :: str\n    CHARACTER(7) :: strData\n    \n    IF ( v1 >= v2 ) THEN \n        str = \"-1 -1 -1\"\n    ELSE\n        t = INT((REAL(g) * 3600) \/ (v2 - v1))\n        h = INT(REAL(t) \/ 3600)\n        m = INT(REAL(MODULO(t, 3600)) \/ 60)\n        s = MODULO(t, 60)\n        write(strData, \"(I7)\") h\n        str = trim(str)\/\/\" \"\/\/adjustl(strData)\n        write(strData, \"(I7)\") m\n        str = trim(str)\/\/\" \"\/\/adjustl(strData)\n        write(strData, \"(I7)\") s\n        str = trim(str)\/\/\" \"\/\/adjustl(strData)\n        str = trim(adjustl(trim(str)))\n    END IF \n    \n  END FUNCTION race\nEND MODULE Solution","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83009,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n! race returns a string\n  FUNCTION race(v1, v2, g) RESULT(str)\n    INTEGER, INTENT(IN) :: v1, v2, g\n    integer :: time\n    integer :: h, m, s\n    character(10) :: line\n    character(:), allocatable :: str\n    ! your code\n    if (v1 >= v2) then\n      h = -1\n      m = -1\n      s = -1\n    else\n      time = 3600 * g \/ (v2 - v1)\n      h = time \/ 3600\n      m = (time - h * 3600) \/ 60\n      s = modulo(time, 60)\n    end if\n    write (line, \"(i0,x,i0,x,i0)\") h, m, s\n    str = trim(line)\n  END FUNCTION race\nEND MODULE Solution","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83010,"user_id":null,"body":"module solution\n    use iso_fortran_env\n    implicit none\n    integer,parameter :: rk=real64\n    contains\n    function race(v1,v2,ds)\n        character(len=:),allocatable :: race\n        integer,intent(in) :: v1\n        integer,intent(in) :: v2\n        integer,intent(in) :: ds\n        integer :: dt\n        character(len=100) :: ch,cm,cs\n        race=\"-1 -1 -1\"\n        if(v1.ge.v2)return\n        race=\"\"\n        dt=floor(real(ds,rk)\/real(v2-v1,rk)*3600.0_rk)\n        write(ch,*) dt\/3600\n        dt=dt-(dt\/3600)*3600\n        write(cm,*) dt\/(3600\/60)\n        dt=dt-(dt\/(3600\/60))*(3600\/60)\n        write(cs,*) dt\/(3600\/60\/60)\n        race=trim(adjustl(ch))\/\/\" \"\/\/trim(adjustl(cm))\/\/\" \"\/\/trim(adjustl(cs))\n    end function race\nend module solution","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83011,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n! race returns a string\n  FUNCTION race(v1, v2, g) RESULT(str)\n    INTEGER, INTENT(IN) :: v1, v2, g\n    Character (:), allocatable :: str\n    Double Precision :: Time\n    Integer :: Hour, Minute, Second\n    Character (len=2) chHour, chMin, chSec\n\n    If (v2 <=  v1) then\n      str = '-1 -1 -1'\n    Else\n      Time = (1.0D0*g)\/((1.0D0*v2-1.0D0*v1))\n      Hour = Time\n      write (chHour,'(I0)') Hour\n      \n      Minute = mod(60D0*Time,60D0)\n      write (chMin,'(I0)') Minute\n\n      Second = mod(3600D0*Time,60D0)\n      write (chSec,'(I0)') Second\n\n      str = trim(chHour)\/\/' '\/\/trim(chMin)\/\/' '\/\/trim(chSec)\n    End If\n     \n  END FUNCTION race\nEND MODULE Solution","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83012,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n! race returns a string\n  FUNCTION race(v1, v2, g) RESULT(str)\n    INTEGER, INTENT(IN) :: v1, v2, g\n    Character (:), allocatable :: str\n    Double Precision :: Time\n    Integer :: Hour, Minute, Second\n    Character (len=2) chHour, chMin, chSec\n\n    ! your code\n    If (v2 <=  v1) then\n      str = '-1 -1 -1'\n    Else\n      Time = (1.0D0*g)\/((1.0D0*v2-1.0D0*v1))\n      Hour = Time\n      print *, 'Hora',Time, Hour\n      If (Hour >= 10) write (chHour,'(I2.2)') Hour\n      If (Hour < 10) write (chHour,'(I1.1)') Hour\n      \n      Minute = mod(60D0*Time,60D0)\n      print *, 'Minuto',Time, Minute\n      If (Minute >= 10) write (chMin,'(I2.2)') Minute\n      If (Minute < 10) write (chMin,'(I1.1)') Minute\n\n      Second = mod(3600D0*Time,60D0)\n      print *, 'Segundo',Time, Second\n      If (Second >= 10) write (chSec,'(I2.2)') Second\n      If (Second < 10) write (chSec,'(I1.1)') Second\n\n      str = trim(chHour)\/\/' '\/\/trim(chMin)\/\/' '\/\/trim(chSec)\n      \n    End If\n    \n   !return str\n     \n  END FUNCTION race\nEND MODULE Solution","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83013,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n! race returns a string\n  FUNCTION race(v1, v2, g) RESULT(str)\n    INTEGER, INTENT(IN) :: v1, v2, g\n    character(:), allocatable :: str\n    integer :: s, m, h\n    character(len=20) :: res\n    \n    if (v1 >= v2) then\n      res = \"-1 -1 -1\"\n    else\n      s = (3600 * g) \/ (v2 - v1)\n      h = s \/ 3600\n      s = s - h*3600\n      m = s \/ 60\n      s = s - m*60\n      \n      write (res, '(I0, 1X, I0, 1X, I0)') h, m, s\n    end if\n    \n    str = trim(res)\n    \n  END FUNCTION race\nEND MODULE Solution","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83014,"user_id":1228,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n! race returns a string. \n  FUNCTION race(v1, v2, g) RESULT(str)\n    INTEGER, INTENT(IN) :: v1, v2, g\n    character(len=100) :: strs, strm, strh\n    character(:), allocatable :: str\n    integer :: sec, s, m, h\n\t  real :: t\n    t = float(g)\/(float(v2) - float(v1))\n    s = modulo(int(t*3600), 60)\n    m = modulo(int(t*60), 60)\n    h = modulo(int(t), 60)\n\t  sec = (g * 3600 \/ (v2 - v1))\n    write (strs, *) s\n    write (strm, *) m\n    write (strh, *) h\n    if (v2 > v1) then\n    str = trim(adjustl(trim(strh) \/\/ \" \" \/\/ trim(adjustl(strm)) \/\/ \" \" \/\/ trim(adjustl(strs)) ))\n    else\n    str = \"-1 -1 -1\"\n    end if\n    END FUNCTION race\nEND MODULE Solution","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83015,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n! race returns a string\n  FUNCTION race(v1, v2, g) RESULT(str)\n  INTEGER, INTENT(IN) :: v1, v2, g\n  character(:), allocatable :: str\n  character(12) tmp\n  integer h, m, s\n  real t\n  h=-1; m=-1; s=-1\n  if (v2 > v1) then\n    t = 3600 * g \/ (v2 - v1); print *, t, \"(secs)\"\n    h = int(t\/3600);  t = t - h*3600\n    m = int(t\/60);    t = t - m*60\n    s = int(t)\n  end if\n  tmp = \"\"\n  write(tmp, \"(2(I0,A),I0)\") h, \" \", m, \" \", s\n  str = trim(tmp)\n!  print *, str\n  END FUNCTION race\nEND MODULE Solution","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"55e6f5e58f7817808e00002e":[{"id":83016,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\n  INTEGER, PARAMETER:: i64 = SELECTED_INT_KIND(16)\n\nCONTAINS\n\n  FUNCTION seven(n) RESULT(ivec)\n    INTEGER(i64) :: n, x, y, res, steps\n    INTEGER, DIMENSION(2):: ivec\n    \n    res = n\n    steps = 0\n    DO\n      WRITE(*, *) res, steps\n      IF (res \/ 10 <= 9) THEN\n        ivec = [res, steps]\n        EXIT\n      ELSE\n        x = res \/ 10\n        y = res - x * 10\n        res = x - 2 * y\n      END IF\n      steps = steps + 1\n    END DO\n  END FUNCTION seven\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83017,"user_id":null,"body":"module Solution\n  implicit none\n  integer, parameter :: i64 = selected_int_kind(16)\n\ncontains\n  function seven(n) result(ivec)\n    integer(i64) :: n\n    integer :: ivec(2)\n\n    integer(i64) :: x\n    integer :: steps\n    x = n\n    steps = 0\n\n    do while(x > 99)\n      x = (x \/ 10) - 2*mod(x, 10_i64)\n      steps = steps + 1\n    end do\n    \n    ivec(:) = [int(x), steps]\n  end function seven\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83018,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\n  INTEGER, PARAMETER:: i64 = SELECTED_INT_KIND(16)\n\nCONTAINS\n  FUNCTION seven(n) RESULT(ivec)\n    INTEGER(i64) :: n,r\n    INTEGER, DIMENSION(2):: ivec\n    r=n\n    ivec(2)=0\n    \n    DO\n    IF (r .lt. 100) THEN\n      ivec(1)=int(r,kind=4)\n      EXIT\n    END IF\n    r=r\/10-2*mod(r,10_i64)\n    ivec(2)=ivec(2)+1\n    END DO\n\n  END FUNCTION seven\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83019,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\n  INTEGER, PARAMETER:: i64 = SELECTED_INT_KIND(16)\n\nCONTAINS\n\n  FUNCTION seven(n) RESULT(ivec)\n    INTEGER(i64) :: n, m, dix\n    INTEGER(i64), DIMENSION(2):: ivec\n    INTEGER :: i\n    \n    i = 0\n    m = n\n    dix = 10\n    do while (m > 99)\n      m = m\/dix - 2 * mod(m,dix)\n      i = i + 1\n    enddo\n    \n    ivec(1) = m\n    ivec(2) = i\n  END FUNCTION seven\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83020,"user_id":168,"body":"MODULE Solution\n  IMPLICIT NONE\n  INTEGER, PARAMETER:: i64 = SELECTED_INT_KIND(16)\n\nCONTAINS\n\n  FUNCTION seven(n) RESULT(ivec)\n    INTEGER(i64), intent(in) :: n\n    integer(i64) :: m, q, r\n    integer :: steps\n    INTEGER, DIMENSION(2):: ivec\n    m = n\n    steps = 0\n    do while (m >= 100)\n      q = m \/ 10_i64\n      r = mod(m, 10_i64)\n      m = q - 2 * r\n      steps = steps + 1\n    end do\n    ivec(1) = int(m)\n    ivec(2) = steps\n  END FUNCTION seven\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83021,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\n  INTEGER, PARAMETER:: i64 = SELECTED_INT_KIND(16)\n\nCONTAINS\n\n  FUNCTION seven(n) RESULT(ivec)\n    INTEGER(i64) :: n\n    INTEGER, DIMENSION(2):: ivec\n    INTEGER(i64) :: m, i, mod, residual, tmp\n  \n    ! your code\n    m = n\n    i = 0\n    do while (m > 99)\n      residual = MODULO(m,10_i64)\n      mod = (m -residual)\/10\n      m = mod - (2*residual)\n      i = i + 1\n    end do\n\n    ivec(1) = m\n    ivec(2) = i\n\n      \n  END FUNCTION seven\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83022,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\n  INTEGER, PARAMETER:: i64 = SELECTED_INT_KIND(16)\n  INTEGER, PARAMETER:: i8 = SELECTED_INT_KIND(8)\n\nCONTAINS\n\n  FUNCTION seven(n) RESULT(ivec)\n    INTEGER(i64) :: n, m, i\n    INTEGER, DIMENSION(2):: ivec\n    m = n\n    i = 0\n    do while (m > 99)\n      m = (m \/ 10) - (2 * mod(m, 10_i64))\n      i = i + 1\n    end do\n    ivec(1) = m\n    ivec(2) = i\n  END FUNCTION seven\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83023,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\n  INTEGER, PARAMETER:: i64 = SELECTED_INT_KIND(16)\n\nCONTAINS\n\n  RECURSIVE FUNCTION seven(n, t) RESULT(ivec)\n    INTEGER(i64) :: n\n    INTEGER :: times\n    INTEGER, OPTIONAL :: t\n    INTEGER, DIMENSION(2):: ivec\n\n    IF(present(t)) THEN\n      times = t\n    ELSE\n      times = 0\n    END IF\n    \n    IF(n < 100) THEN\n      ivec(1) = INT(N)\n      ivec(2) = times\n    ELSE\n      ivec = seven(n\/10 - 2*MOD(n,10_i64), times+1)\n    END IF\n  END FUNCTION seven\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83024,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\n  INTEGER, PARAMETER:: i64 = SELECTED_INT_KIND(16)\n\nCONTAINS\n\n  FUNCTION seven(n) RESULT(ivec)\n    INTEGER(i64) :: n,temp,steps,var\n    INTEGER, DIMENSION(2):: ivec\n   ! integer :: steps\n    steps=0\n    var=10\n    temp=n\n    ! your code\n    do while(temp .gt. 99)\n    \n    temp= (temp\/var) - (mod(temp,var))*2\n    \n    steps=steps+1\n    \n    end do\n    ivec(1)=temp\n    ivec(2)=steps\n    \n  END FUNCTION seven\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83025,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\n  INTEGER, PARAMETER:: i64 = SELECTED_INT_KIND(16)\n\nCONTAINS\n\n  FUNCTION seven(n) RESULT(ivec)\n    INTEGER(i64) :: n\n    INTEGER, DIMENSION(2):: ivec\n    integer(i64) :: a,b,c\n    ivec=0\n    c=n\n    do\n       a=c\/10\n       b=c-a*10\n       c=a-2*b\n       if(a<10)then\n         ivec(1)=a*10+b\n         exit\n       end if\n       ivec(2)=ivec(2)+1\n    end do\n    ! your code\n  END FUNCTION seven\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"55e7280b40e1c4a06d0000aa":[{"id":83026,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\n  PUBLIC :: Choose_Best_Sum\n\nCONTAINS\n\n    FUNCTION Choose_Best_Sum(t, k, ls) RESULT(res)\n        INTEGER, INTENT(IN) :: t, k\n        INTEGER, INTENT(IN), ALLOCATABLE, DIMENSION(:) :: ls\n        INTEGER, ALLOCATABLE, DIMENSION(:) :: combi_maker\n        INTEGER :: i, ls_len, current_index, current_travel, max_val\n        INTEGER :: res\n\n        ls_len=size(ls)\n        res = -1  \n\n        IF (k .gt. 0 .and. ls_len .ge. k) THEN\n            ALLOCATE(combi_maker(k))\n            DO i=1,k\n                combi_maker(i)=i\n            END DO\n            DO\n                current_travel=sum(ls(combi_maker))\n                IF ((current_travel .le. t) .and. current_travel .gt. res) THEN\n                    res = current_travel\n                END IF\n\n                IF (combi_maker(1)==ls_len-k+1) THEN\n                    EXIT\n                END IF\n                current_index=k\n                max_val=ls_len+1\n                combi_maker(k)=combi_maker(k)+1\n                DO\n                    IF (combi_maker(current_index)==max_val) THEN\n                        combi_maker(current_index-1)=combi_maker(current_index-1)+1\n                        current_index=current_index-1\n                        max_val=max_val-1\n                    ELSE\n                        EXIT\n                    END IF\n                END DO\n\n                DO i=current_index+1,k\n                    combi_maker(i)=combi_maker(i-1)+1\n                END DO\n            END DO\n            DEALLOCATE(combi_maker)\n        END IF\n    END FUNCTION\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83027,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\n  PUBLIC :: Choose_Best_Sum\n\nCONTAINS\n\n    FUNCTION Choose_Best_Sum(t, k, ls) RESULT(res)\n    INTEGER, INTENT(IN) :: t, k\n    INTEGER, INTENT(IN), ALLOCATABLE, DIMENSION(:) :: ls\n    INTEGER :: res  \n!     t : maximum sum of distances\n!     k : number of towns to visit, k >= 1\n!    ls : list of distances\n!   res : the \"best\" sum ie the biggest possible sum \n!         of k distances less than or equal to the given limit t\n!\n    integer, allocatable, dimension(:) :: ns\n    integer                            :: i,j,ni,nc,nt\n    integer                            :: tot_dis,maxdiff,best_sum,idiff  \n!\n    allocate(ns(k))\n    nt=size(ls)       ! total number of towns\n!\n    maxdiff=t\n    best_sum=-1  \n    if(nt<k) then     ! Total number of towns less than towns to visit ?\n       res=best_sum   ! early return\n       return\n    endif\n!   \n    do i=1,k\n      ns(i)=i        ! initial list of towns\n    enddo\n!\n 100  do \n!     print*,' towns ',ns        ! combination of towns to visit\n      tot_dis=0\n      tot_dis=sum(ls(ns(1:k)))   ! evaluate distance\n!\n      if (tot_dis<=t) then\n        ! this is a condidate\n         idiff=t-tot_dis   \n         if (idiff<=maxdiff) then ! is the candiate closer to target?\n             maxdiff=idiff\n             best_sum=tot_dis     ! sum closest to t so far\n             if (idiff==0) exit   ! a hit, no more work to do\n          endif\n       endif\n !\n       if (ns(1)==(nt-k+1)) exit  ! all combinatons of towns are taken\n !\n !     provide a new combination of towns to visit:\n       do i=1,k\n          if(ns(i) == (nt-k+i)) then  \n             ni=ns(i-1)\n             nc=0\n             do j=i-1,k\n               nc=nc+1\n               ns(j)=ni+nc\n             enddo\n             goto 100\n          endif\n       enddo\n       ns(k)=ns(k)+1\n    enddo\n  !\n    res=best_sum\n  !\n  END FUNCTION\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83028,"user_id":168,"body":"MODULE Solution\n  IMPLICIT NONE\n  PUBLIC :: Choose_Best_Sum\n\nCONTAINS\n    recursive function comb(t, k, ls, i) result(res)\n      integer, intent(in) :: t, k, ls(:), i\n      integer :: res\n      if (t < 0) then\n        res = -1000000\n      else if (k == 0) then\n        res = 0\n      else if (i > size(ls)) then\n        res = -1000000\n      else\n        res = max(comb(t, k, ls, i + 1), ls(i) + comb(t - ls(i), k - 1, ls, i + 1))\n      end if\n    end function\n\n    FUNCTION Choose_Best_Sum(t, k, ls) RESULT(res)\n        INTEGER, INTENT(IN) :: t, k\n        INTEGER, INTENT(IN), ALLOCATABLE, DIMENSION(:) :: ls\n        INTEGER :: res\n        res = comb(t, k, ls, 1)\n        if (res < 0) then\n          res = -1\n        end if\n    END FUNCTION\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83029,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\n  PRIVATE :: aux\n  PUBLIC :: Choose_Best_Sum\n\nCONTAINS\n\n    RECURSIVE FUNCTION aux(t, k, ls, from) RESULT(res)\n        INTEGER :: t, k, from\n        INTEGER, ALLOCATABLE, DIMENSION(:) :: ls\n        INTEGER :: res\n        INTEGER :: szls, best, tmpbest, i\n\n        IF (k == 0) THEN\n            IF (t >= 0) THEN\n                res = 0\n            ELSE\n              res = -1\n            END IF\n            RETURN\n        ELSE IF (t < k) THEN\n          res = -1\n          RETURN\n        ELSE\n          best = -1\n          szls = SIZE(ls)\n          DO i = from, szls\n              tmpBest = aux(t - ls(i), k - 1, ls, i + 1)\n              IF (tmpBest >= 0) THEN\n                  best = MAX(best, ls(i) + tmpBest)\n              END IF\n          END DO\n        END IF\n        res = best\n    END FUNCTION\n\n    FUNCTION Choose_Best_Sum(t, k, ls) RESULT(res)\n        INTEGER, INTENT(IN) :: t, k\n        INTEGER, INTENT(IN), ALLOCATABLE, DIMENSION(:) :: ls\n        INTEGER :: res\n\n        res = aux(t, k, ls, 1)\n    END FUNCTION\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"55efecb8680f47654c000095":[{"id":83030,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  integer FUNCTION int_rac(n, guess) \n    INTEGER, PARAMETER :: ikind=selected_int_kind(16),bkind=selected_int_kind(16)\n    INTEGER(KIND=ikind) :: n\n    integer::guess\n    INTEGER(KIND= bkind) :: former,x\n    former=guess+2\n    x=guess\n    int_rac=0\n    DO WHILE(abs(x-former)>=1)\n      former=x\n      x=((former+n\/former)\/2)\n      int_rac=int_rac+1\n    end do\n    print*,x\n    ! your code\n  END FUNCTION int_rac\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83031,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION int_rac(n, guess) RESULT(cnt)\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(KIND=ikind) :: n, prev_guess, g\n    INTEGER :: guess\n    \n    cnt = 0; prev_guess = 0; g = guess\n    DO WHILE(ABS(g - prev_guess) >= 1)\n      prev_guess = g;\n      g = (g + n \/ g) \/ 2\n      cnt = cnt + 1\n    END DO\n  END FUNCTION int_rac\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83032,"user_id":53,"body":"module solution\n  implicit none\ncontains\n\n  integer function int_rac(n, guess) result(k)\n  \n    integer, parameter :: ikind=selected_int_kind(16)\n    integer(kind=ikind) :: n, p, m\n    integer :: guess\n    \n    k = 0\n    p = 0\n    m = guess\n    \n    do while(abs(m - p) >= 1)\n      p = m;\n      m = (m + n \/ m) \/ 2\n      k = k + 1\n    end do\n    \n  end function int_rac\n  \nend module solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83033,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  PURE FUNCTION int_rac(n, guess) RESULT(steps)\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(KIND=ikind), INTENT(IN) :: n\n    INTEGER(KIND=ikind) :: m,z,eps\n    INTEGER, INTENT(IN) :: guess\n    INTEGER :: steps\n    \n    steps=0\n    eps=2\n    z=guess\n    \n    DO WHILE (eps .GE. 1)\n      steps=steps+1\n      m=(z+n\/z)\/2\n      eps=abs(z-m)\n      z=m\n    END DO\n  END FUNCTION int_rac\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83034,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION int_rac(n, guess)\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(KIND=ikind) :: n\n    INTEGER :: guess\n    integer :: count1,sqrti\n    real(8) :: sqrtr\n    sqrti=int(sqrt(real(n,8)+0.1d0))\n    count1=0\n    sqrtr=guess\n    int_rac=1\n    do\n        if(int(sqrtr)==sqrti)then\n            exit\n        else\n            int_rac=int_rac+1\n            sqrtr=0.5*(sqrtr+n\/sqrtr)\n        end if\n    end do\n    ! your code\n  END FUNCTION int_rac\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83035,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n    PURE FUNCTION int_rac(n, guess)\n        INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n        INTEGER(KIND=ikind), intent(in) :: n\n        INTEGER, intent(in) :: guess\n        INTEGER(KIND=8), parameter :: err = 1\n        INTEGER(KIND=8) :: res, root, int_rac\n        int_rac = 0\n        res = n\n        root = guess\n        do while (res > err)\n            int_rac = int_rac + 1\n            res = (root + n\/root)\/2\n            if (res == root) exit\n            root = res\n        end do\n    END FUNCTION int_rac\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83036,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION int_rac(n, guess)\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(KIND=ikind) :: n, last_guess, new_guess\n    INTEGER :: guess\n    \n    int_rac = 1\n    last_guess = guess\n    new_guess = (last_guess + n \/ last_guess) \/ 2\n    \n    DO WHILE (ABS(last_guess - new_guess) >= 1)\n      int_rac = int_rac + 1\n      last_guess = new_guess\n      new_guess = (last_guess + n \/ last_guess) \/ 2\n    END DO\n\n  END FUNCTION int_rac\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83037,"user_id":null,"body":"MODULE Solution\n  use iso_fortran_env\n  IMPLICIT NONE\n  integer,parameter :: ik=int64\nCONTAINS\n\n    pure integer function int_rac(n,guess)\n        integer(ik),intent(in) :: n\n        integer,intent(in) :: guess\n        integer,parameter :: tol=1\n        integer(ik) :: x, y\n        int_rac=1\n        x = guess\n        y = (x+n\/x)\/2\n        if(abs(x-y).le.tol) return\n        do\n            x = y\n            y = (x+n\/x)\/2\n            int_rac=int_rac+1\n            if(abs(x-y).lt.tol) return\n        end do\n    end function int_rac\n    \nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83038,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION int_rac(n, guess)\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(KIND=ikind) :: n, x, prev_x\n    INTEGER :: guess\n    prev_x = -2\n    x = guess\n    int_rac = 0\n    \n    DO WHILE (ABS(prev_x - x) .GE. 1)\n      prev_x = x\n      x = (x + n\/x) \/ 2\n      int_rac = int_rac + 1\n    END DO\n  END FUNCTION int_rac\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83039,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION int_rac(n, guess)\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(KIND=ikind) :: n, xprev, xnew, x\n    INTEGER :: guess, nprog\n    \n    X = INT(guess,KIND=ikind)\n    XPREV = X\n    XNEW = (X + N\/X)\/2\n    X = XNEW\n    WRITE(*,*) X - XPREV,X, XPREV\n    NPROG = 1\n    \n    DO WHILE (.NOT.(((X-XPREV).EQ.1).OR.((X-XPREV).EQ.0)))\n       XPREV = X\n       XNEW = (X + N\/X)\/2\n       X = XNEW   \n       WRITE(*,*) X - XPREV,X, XPREV\n       NPROG = NPROG + 1\n    END DO\n    \n    INT_RAC = NPROG\n    \n  END FUNCTION int_rac\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"55f160df93f61bb26b00002a":[{"id":83040,"user_id":null,"body":"module Solution\n  implicit none\n  private\n  public :: is_pronic\ncontains\n  logical pure function is_pronic(n)\n    integer(8), intent(in) :: n\n    ! Works for moderately large n\n    is_pronic = mod(sqrt(real(1_16 + 4_16 * n, 16)), 1.0_16) == 0.0_16\n  end function is_pronic\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83041,"user_id":53,"body":"module Solution\n  implicit none\n  private\n  public :: is_pronic\ncontains\n  logical pure function is_pronic(n)\n    integer(8), intent(in) :: n\n    integer(8) :: m\n    if (n < 0) then\n      is_pronic = .FALSE.\n    else\n      m = int8(dsqrt(dble(n)))\n      is_pronic = m * (m+1) == n\n    end if\n  end function is_pronic\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83042,"user_id":null,"body":"module Solution\n  implicit none\n  private\n  public :: is_pronic\ncontains\n  logical pure function is_pronic(n) result(res)\n    integer(8), intent(in) :: n\n    integer(8) :: a,b\n    ! Works for moderately large n\n    res = .false.\n    a=int(sqrt(real(n,kind=8)),kind=8)\n    b=a*(a+1)\n    if (b==n) res=.true.   \n  end function is_pronic\nend module Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83043,"user_id":null,"body":"module Solution\n  implicit none\n  private\n  public :: is_pronic\ncontains\n  logical pure function is_pronic(n)\n    integer(8), intent(in) :: n\n    integer(8) :: a, b\n    \n    is_pronic = .FALSE.\n    a = sqrt(1.0D0*n)    ! It is imperative to use proper D0 notation\n    b = a*(a+1)\n    if (b == n) is_pronic = .TRUE.\n  end function is_pronic\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83044,"user_id":null,"body":"module Solution\n  implicit none\n  private\n  public :: is_pronic\ncontains\n  logical pure function is_pronic(n)\n    integer(8), intent(in) :: n\n    integer(8) :: m, a\n    ! Works for moderately large n\n    is_pronic = .FALSE.\n    \n    m = sqrt(1.0D0 * n)\n    a = m*(m+1)\n    If (a == n) is_pronic = .TRUE.\n\t\n  end function is_pronic\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83045,"user_id":null,"body":"module Solution\n  implicit none\n  private\n  public :: is_pronic\ncontains\n  logical pure function is_pronic(n)\n    integer(8), intent(in) :: n\n    integer(8) :: x, y\n    is_pronic = .false.\n    if (n < 0) RETURN\n    x = sqrt(1.0D0 * n);  y = x * (x + 1)\n    if (n - y == 0)       is_pronic = .true.\n  end function is_pronic\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83046,"user_id":17,"body":"module Solution\n  implicit none\n  private\n  public :: is_pronic\ncontains\n  logical pure function is_pronic(n)\n    integer(8), intent(in) :: n\n    is_pronic = int(sqrt(real(n, 10)), 16) * (int(sqrt(real(n, 10)), 16) + 1) == int(n, 16)\n  end function is_pronic\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83047,"user_id":17,"body":"module Solution\n  implicit none\n  private\n  public :: is_pronic\ncontains\n  logical pure function is_pronic(n)\n    integer(8), intent(in) :: n\n    is_pronic = int(sqrt(real(n, 10)), 16) * (int(sqrt(real(n, 10)), 16) + 1) == int(n, 16)\n  end function is_pronic\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"55f3da49e83ca1ddae0000ad":[{"id":83048,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  \n  FUNCTION tank_vol(h, d, vt) RESULT(res)\n    INTEGER :: h, d, vt\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind) :: res, hh, M_PI, rrr, dd, st, theta, sr, sa, sh, vv, vtt\n    INTEGER :: hilevel\n    \n    IF (h == 0) THEN \n      res = 0\n      RETURN\n    END IF\n    IF (h == d) THEN \n      res = vt\n      RETURN\n    END IF\n    IF (2 * h == d) THEN \n      res = vt \/ 2\n      RETURN\n    END IF\n    M_PI = 3.14159265358979323846_ikind\n    hh = REAL(h, ikind)\n    dd = REAL(d, ikind)\n    rrr = REAL(dd, ikind) \/ 2.0\n    vtt = REAL(vt, ikind)\n    hilevel = 0\n    IF (hh > rrr) THEN\n      hh = dd - hh\n      hilevel = 1\n    END IF\n    st = M_PI * rrr * rrr\n    theta = ACOS((rrr - hh) \/ rrr)\n    sr = (rrr - hh) * SQRT(rrr * rrr - (rrr - hh) * (rrr - hh))\n    sa = st \/ M_PI * theta\n    sh = sa - sr\n    vv = vt * sh \/ st\n    IF (hilevel == 1) THEN\n      res = vtt - vv\n    ELSE\n      res = vv\n    END IF\n    res = INT(FLOOR(res))\n  END FUNCTION tank_vol\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83049,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  \n  FUNCTION tank_vol(h, d, vt) RESULT(res)\n    INTEGER :: h, d, vt\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind) :: res, hh, M_PI, rrr, dd, st, theta, sr, sa, sh, vv, vtt\n    INTEGER :: hilevel\n    \n    IF (h == 0) THEN \n      res = 0\n      RETURN\n    END IF\n    IF (h == d) THEN \n      res = vt\n      RETURN\n    END IF\n    IF (2 * h == d) THEN \n      res = vt \/ 2\n      RETURN\n    END IF\n    M_PI = 3.14159265358979323846_ikind\n    hh = REAL(h, ikind)\n    dd = REAL(d, ikind)\n    rrr = REAL(dd, ikind) \/ 2.0\n    vtt = REAL(vt, ikind)\n    hilevel = 0\n    IF (hh > rrr) THEN\n      hh = dd - hh\n      hilevel = 1\n    END IF\n    st = M_PI * rrr * rrr\n    theta = ACOS((rrr - hh) \/ rrr)\n    sr = (rrr - hh) * SQRT(rrr * rrr - (rrr - hh) * (rrr - hh))\n    sa = st \/ M_PI * theta\n    sh = sa - sr\n    vv = vt * sh \/ st\n    IF (hilevel == 1) THEN\n      res = vtt - vv\n    ELSE\n      res = vv\n    END IF\n    res = INT(FLOOR(res))\n  END FUNCTION tank_vol\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83050,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  \n  FUNCTION tank_vol(h, d, vt) RESULT(res)\n    INTEGER :: h, d, vt, res\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind) :: M_PI, R, Theta   ! Theta = 2*Theta in diagram\n      M_PI = 3.14159265358979323846_ikind\n      R = d \/ 2.0\n      Theta = 2.0 * acos( (R - h)\/R )\n      res = vt * ( Theta - sin(Theta) )\/M_PI\/2.0\n  END FUNCTION tank_vol\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83051,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  \n  FUNCTION tank_vol(h, d, vt) RESULT(res)\n    INTEGER :: h, d, vt\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind) :: M_PI,r,ht,a,a1,a2\n    integer :: res\n    M_PI = 3.14159265358979323846_ikind\n    r=d\/2.0\n    ht=r-h\n    a1=M_PI*r**2\/2.0\n    a2=r**2*asin(ht\/r)+ht*sqrt(r**2-ht**2)\n    a=(vt-a2\/a1*vt)*0.5\n    res=floor(a)\n  END FUNCTION tank_vol\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83052,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  \n  FUNCTION tank_vol(h, d, vt) RESULT(res)\n    INTEGER :: h, d, vt, res\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind) :: M_PI\n    REAL(kind=8) :: at, ac\n    \n    M_PI = 3.14159265358979323846_ikind\n    \n    if (h .lt. d \/ 2.) then\n      at = ((d \/ 2.) - h) * sqrt(1. * (d - h) * h)\n      ac = (d**2 \/ 4.) * abs(acos(1. - 2. * h \/ d))\n    \n      res = floor((ac - at) * vt \/(M_PI * d**2 \/ 4.))\n    else if (h .eq. d\/2.) then\n      res = vt \/ 2\n    else\n      at = (h - d \/ 2.) * sqrt(1. * (d - h) * h)\n      ac = (d**2 \/ 4.) * abs(acos(2. * h \/ d - 1.))\n      \n      res = floor(vt - (ac - at) * vt \/(M_PI * d**2 \/ 4.))\n    endif\n  END FUNCTION tank_vol\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83053,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  \n  FUNCTION tank_vol(h, d, vt) RESULT(res)\n    INTEGER :: h, d, vt\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind) :: M_PI\n    REAL(10) :: length, r, res\n    M_PI = 3.14159265358979323846_ikind\n    length = vt\/(M_PI*((0.5*d)**2))\n    r = 0.5*d\n    res = length*(r**2*acos(1-(h\/r))-(r-h)*sqrt(2*r*h-h**2))\n  END FUNCTION tank_vol\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83054,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  \n  FUNCTION tank_vol(h, d, vt) RESULT(res)\n    INTEGER :: h, d, vt, res\n    REAL :: r, theta, circle\n    REAL :: sector, triangle, fluid, length\n    REAL, parameter :: pi = 4.*atan(1.)\n    ! M_PI = 3.14159265358979323846_ikind\n    \n    r = real(d)\/2 ! radius\n    theta = acos(abs(r-h)\/r) ! half angle\n    sector = theta * r**2  ! sector area\n    triangle = r * sin(theta) * abs(r-h) ! triangle area\n    if (h < r) then\n      fluid = sector - triangle ! fluid cross section area\n    else\n      fluid = pi * r**2 - (sector - triangle)\n    endif\n    \n    length = vt \/ (pi * r**2) ! length of the tank\n    res = length * fluid ! volume of remaining volume\n    \n  END FUNCTION tank_vol\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83055,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  \n  FUNCTION tank_vol(h, d, vt) RESULT(res)\n    INTEGER :: h, d, vt,res\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind) :: M_PI,theta,vtot\n    real :: length\n    M_PI = 3.14159265358979323846_ikind\n    ! your code    \n    theta=acos((d\/2.-h)\/(d\/2.))\n    length=4.*vt\/(m_pi*d**2)\n    vtot=length*(theta*d**2\/4.-d**2\/4.*sin(theta)+h*d\/2.*sin(theta))\n    res=floor(vtot)\n  END FUNCTION tank_vol\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83056,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  \n  FUNCTION tank_vol(h, d, vt) RESULT(res)\n    INTEGER :: h, d, vt, res\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind) :: M_PI, N, M\n    M_PI = 3.14159265358979323846_ikind\n    N = ACOS(1.0 - h \/ (d \/ 2.0)) * 2.0\n    M = vt * (n - SIN(n)) \/ (2.0 * M_PI)\n    res = FLOOR(M)  \n  END FUNCTION tank_vol\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83057,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  \n  FUNCTION tank_vol(h, d, vt) RESULT(res)\n    INTEGER :: h, d, vt, res\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind) :: M_PI, radius, height, alpha, area\n    M_PI = 3.14159265358979323846_ikind\n    \n    radius = d \/ 2.0_ikind\n    height = vt \/ (M_PI * radius**2)\n    alpha = acos((radius - h) \/ radius)\n    \n    area = alpha * radius**2 - (radius-h)*sqrt(radius**2 - (radius-h)**2)\n    \n    res = area * height\n  END FUNCTION tank_vol\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"55f9bca8ecaa9eac7100004a":[{"id":83058,"user_id":527,"body":"module Solution\n  implicit none\ncontains\n  integer pure function past(h, m, s)\n    integer, intent(in) :: h, m, s\n    past = ((h * 60 + m) * 60 + s) * 1000\n  end function past\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83059,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function past(h, m, s)\n    integer, intent(in) :: h, m, s\n    past = h*60*60*1000+m*60*1000+s*1000\n  end function past\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83060,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function past(h, m, s)\n    integer, intent(in) :: h, m, s\n    past = 1000*s+60*1000*m+3600*1000*h\n  end function past\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83061,"user_id":null,"body":"!>Module which contains the solution. \n!!Contains the past function.\nmodule Solution\n  implicit none\ncontains\n  !> past function which takes hours, minutes and seconds after midnight\n  !! and converts it to milli seconds after midnight. Returns the solution as integer\n  integer pure function past(h, m, s) result(res)\n    integer, intent(in) :: h, m, s\n    res = (s + m*60 + h*3600)*1000\n  end function past\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83062,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function past(h, m, s)\n    integer, intent(in) :: h, m, s\n    \n    integer(4) :: f_h_in_m, f_m_in_s, f_s_in_ms\n    \n    f_h_in_m = 60\n    f_m_in_s = 60\n    f_s_in_ms = 1000\n    \n    past = ((h * f_h_in_m + m) * f_m_in_s + s) * 1000 \n  end function past\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83063,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function past(h, m, s)\n    integer, intent(in) :: h, m, s\n    past = (s + h * 3600 + m * 60) * 1000\n  end function past\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83064,"user_id":168,"body":"module Solution\n  implicit none\ncontains\n  integer pure function past(h, m, s)\n    integer, intent(in) :: h, m, s\n    past = ((60 * h + m) * 60 + s) * 1000\n  end function past\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83065,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function past(h, m, s)\n    integer, intent(in) :: h, m, s\n    past = 1000 * (h * 3600 + m * 60 + s)\n  end function past\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83066,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function past(h, m, s)\n    integer, intent(in) :: h, m, s\n    past = 0\n    \n    if ( h >= 0 .and. h <= 23 ) then\n      if ( m >= 0 .and. m <=59 ) then\n        past = ( (h*60*60) + ( m * 60) + s )*1000\n      end if\n    end if\n    \n  end function past\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83067,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function past(h, m, s)\n    integer, intent(in) :: h, m, s\n    if (h<=23 .and. m<=59 .and.s<=59 .and.h>=0 .and.m>=0 .and. s>=0) then\n    past = 1e3*(s+60*m+60*60*h)\n    end if\n  end function past\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"55fd2d567d94ac3bc9000064":[{"id":83068,"user_id":null,"body":"function row_sum_odd_numbers(n) result (res)\n integer, intent(in) :: n\n res = n*n*n\nend function row_sum_odd_numbers","lang_id":19,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83069,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function row_sum_odd_numbers(n) result (res)\n    integer, intent(in) :: n\n    res = n**3 ! your code here\n  end function row_sum_odd_numbers\nend module Solution","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83070,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function row_sum_odd_numbers(n) result (res)\n    integer, intent(in) :: n\n    integer::i,j\n    i=0\n    j=1\n    res=0\n    do while (i<n)\n     j=j+2*i\n     i=i+1\n    end do\n    i=0\n    do while (i<n)\n    res=res+j\n    j=j+2\n    i=i+1\n    end do\n  end function row_sum_odd_numbers\nend module Solution","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83071,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function row_sum_odd_numbers(n) result (res)\n    integer, intent(in) :: n\n    integer :: tot,i,firstent,lastent\n    tot=0\n    do i=1,n-1\n      tot=tot+i\n    end do  \n    firstent=2*tot+1  \n    lastent=firstent+2*(n-1)\n    res=(firstent+lastent)\/2*n\n  end function row_sum_odd_numbers\nend module Solution","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83072,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function row_sum_odd_numbers(n) result (res)\n    integer, intent(in) :: n\n    integer :: first, last,step,sum, i\n    first = n**2 - n + 1\n    last = first + 2*(n-1)\n    step = 2\n    sum = 0\n    do i=first,last,step\n      sum = sum + i\n    end do\n    res = sum\n  end function row_sum_odd_numbers\nend module Solution","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83073,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function row_sum_odd_numbers(n) result (res)\n    integer, intent(in) :: n\n    integer :: x\n    integer :: y\n    integer :: i\n    x = sum([(i, i= 0,n-1)])\n    y = x+n\n    res = y*y-x*x\n  end function row_sum_odd_numbers\nend module Solution","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83074,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function row_sum_odd_numbers(n) result (res)\n    integer, intent(in) :: n\n    res = n*(n - 1)*(n + 1) + n\n    \n    ! [1] [2 3] [4 5 6] [7 8 9 10]\n    ! \\sum_{i = 1}^{n} { (2*(n*(n - 1)\/2) - 1) + 2*i }\n    ! n*(n*(n - 1) - 1) + n*(n + 1)\n    ! n*n*(n - 1) - n + n*(n - 1 + 2)\n    ! n*n*(n - 1) - n + n*(n - 1) + 2*n\n    ! n*n*(n - 1) + n*(n - 1) + n\n    ! n*(n - 1)*(n + 1) + n\n  end function row_sum_odd_numbers\nend module Solution","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83075,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function row_sum_odd_numbers(n) result (res)\n    integer, intent(in) :: n\n    integer :: res\n    res = n**3\n  end function row_sum_odd_numbers\nend module Solution","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83076,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function row_sum_odd_numbers(n) result (res)\n    integer, intent(in) :: n\n    integer i,i1\n    res = 0 ! your code here\n    i1=n*(n-1)+1\n    do i=1,n\n       res=res+i1\n       i1=i1+2\n    enddo\n  end function row_sum_odd_numbers\nend module Solution","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83077,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function row_sum_odd_numbers(n) result (res)\n    integer, intent(in) :: n\n    integer :: first, last, step, i, sum\n    sum = 0\n    first = n**2 - n + 1\n    last = first + 2*(n-1)\n    step=2\n    do i=first,last,step\n       sum = sum + i\n    end do\n    res = sum\n  end function row_sum_odd_numbers\nend module Solution","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5613d06cee1e7da6d5000055":[{"id":83078,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\n  PUBLIC :: step\n  \nCONTAINS\n\n    FUNCTION step(g, m, n) RESULT(str)\n        INTEGER, INTENT(IN):: g, m, n\n        CHARACTER(:), allocatable :: str\n        !local variables\n        logical :: prime = .false., secondPrime =.false.\n        integer :: prime1, prime2, j\n        character(len = int(log10(real(m))+1)) :: tmp !use minimum length\n        \n        prime1 = 0; prime2 = 0\n              \n        j = m\n        do while (j .LE. n-g) !j = m, n-g\n          call checkPrime(j, prime)\n          if (prime) then\n            prime1 = j\n            call checkPrime(j+g, secondPrime)\n            if (secondPrime) then\n              prime2 = j+g\n              exit\n            end if\n          end if\n          j = j + 1\n        end do        \n        \n        str = \"(0 0)\"\n        if (secondPrime) then\n          write(tmp,'(i0)') prime1\n          str = '(' \/\/ tmp \/\/ \" \"\n          write(tmp,'(i0)') prime2\n          str = str \/\/ tmp \/\/ \")\"        \n        end if\n  END FUNCTION step\n\n  Subroutine checkPrime(currentNumber, prime)\n          integer, intent(in) :: currentNumber\n          logical, intent(inout) :: prime\n          integer :: i\n          prime = .true.\n          \n          if (currentNumber .GE. 3) then \n \n            do i = 2, int(sqrt(real(currentNumber))) !sqrt(n) is the highest divisor that needs to be checked\n              if (mod(currentNumber,i) .EQ. 0) then\n                prime = .false.\n              end if\n            end do\n            \n          end if\n  end subroutine checkPrime\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83079,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\n  PUBLIC :: step\n  PRIVATE :: isPrime\n\nCONTAINS\n\n  FUNCTION step(g, m, n) RESULT(str)\n    INTEGER, INTENT(IN):: g, m, n\n    CHARACTER(:), allocatable :: str\n    CHARACTER(128) stmp\n    INTEGER :: i\n    str = \"(0 0)\"\n    do i = m, n - g\n      if (isPrime(i) .and. isPrime(i + g)) then\n        write(stmp, fmt=\"(A,I0,A,I0,A)\") \"(\", (i), \" \", (i + g), \")\"\n        str = trim(stmp)\n        exit\n      else\n      end if\n    end do\n  END FUNCTION step\n\n  FUNCTION isPrime(n) RESULT(res)\n    INTEGER, INTENT(IN) :: n\n    INTEGER :: i\n    LOGICAL :: res\n    if (mod(n, 2) == 0) then\n      res = (n == 2)\n      return\n    end if\n    do i = 3, int(sqrt(real(n))), 2\n      if (mod(n, i) == 0) then\n        res = .FALSE.\n        return\n      end if\n    end do\n    res = .TRUE.\n  END FUNCTION isPrime\n  \nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83080,"user_id":168,"body":"MODULE Solution\n  IMPLICIT NONE\n  PUBLIC :: step\n\nCONTAINS\n\n    logical pure function is_prime(n) result (r)\n      integer, intent(in) :: n\n      integer :: d\n      d = 2\n      do while (d * d <= n)\n        if (mod(n, d) == 0) then\n          r = .false.\n          return\n        end if\n        d = d + 1\n      end do\n      r = .true.\n    end function\n\n    FUNCTION step(g, m, n) RESULT(str)\n        INTEGER, INTENT(IN):: g, m, n\n        CHARACTER(:), allocatable :: str\n        integer :: i\n                \n        do i = m, n - g\n          if (is_prime(i) .and. is_prime(i + g)) then\n            allocate(character(50) :: str)\n            write (str,'(a,i0,a,i0,a)') '(', i, ' ', i + g, ')'\n            return\n          end if\n        end do\n        \n        str = '(0 0)'\n    END FUNCTION step\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83081,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\n  PRIVATE :: is_a_prime\n  PUBLIC :: step\n\nCONTAINS\n\n    FUNCTION is_a_prime(num) RESULT(bl)\n        INTEGER, INTENT(IN) :: num\n        LOGICAL :: bl\n        INTEGER :: i\n\n        IF(num == 2) THEN\n          bl = .TRUE.\n        ELSE IF(num < 2 .OR. MOD(num, 2) == 0) THEN\n          bl = .FALSE.\n        ELSE\n          bl = .TRUE.\n          DO i = 3, INT(SQRT(REAL(num))), 2\n             IF(MOD(num, i) == 0) THEN\n                bl = .FALSE.\n                EXIT\n             END IF\n          END DO\n        END IF\n    END FUNCTION\n\n    FUNCTION step(g, m, n) RESULT(str)\n        INTEGER, INTENT(IN):: g, m, n\n        INTEGER :: i\n        CHARACTER(:), allocatable :: str\n        CHARACTER (LEN=128) :: tmp\n\n        DO i = m, n\n          IF (is_a_prime(i) .AND. (i + g <= n) .AND. is_a_prime(i + g)) THEN\n            WRITE(tmp, fmt=\"(A, I0, A, I0, A)\") \"(\", i, \" \", i + g, \")\"\n            str = TRIM(tmp)\n            RETURN\n          END IF\n        END DO\n        str = \"(0 0)\"\n  END FUNCTION step\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83082,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\n  PUBLIC :: step\n\nCONTAINS\n\n  pure FUNCTION step(g, m, n) RESULT(str)\n        INTEGER, INTENT(IN):: g, m, n\n        CHARACTER(100), allocatable :: str\n        integer :: i\n        \n        str = \"(0 0)\"\n        \n        do i=m,n\n          if (isPrime(i) .and. isPrime(i+g)) then\n            write(str, \"(A,I0,A,I0,A)\") \"(\",i,\" \",i+g,\")\"\n            exit\n          end if\n        end do\n        \n  END FUNCTION step\n  \n  logical pure Function isPrime(p) result(res)\n    integer, intent(in) :: p\n    integer :: i\n    \n    res = .true.\n    \n    if (p > 2) then\n      if (mod(p,2) == 0) then\n        res = .false.\n      else\n        do i = 3,int(sqrt(real(p))),2\n          if (mod(p, i) == 0) then\n            res = .false.\n            exit\n          end if\n        end do\n      end if\n    end if\n  \n  end function isPrime\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"561e9c843a2ef5a40c0000a4":[{"id":83083,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\n  PUBLIC :: gap\n  PRIVATE :: isPrime\n\nCONTAINS\n\n  FUNCTION isPrime(n) RESULT(res)\n    INTEGER, INTENT(IN) :: n\n    INTEGER :: i\n    LOGICAL :: res\n    \n    if (mod(n, 2) == 0) then\n      res = (n == 2)\n      return\n    end if\n    \n    do i = 3, int(sqrt(real(n))), 2\n      if (mod(n, i) == 0) then\n        res = .FALSE.\n        return\n      end if\n    end do\n    \n    res = .TRUE.\n    \n  END FUNCTION isPrime\n\n  FUNCTION gap(g, m, n) RESULT(res)\n    INTEGER, INTENT(IN) :: g, m, n\n    INTEGER :: i, k\n    INTEGER :: res(2)\n\n    k = 0\n    res(1) = 0\n    res(2) = 0\n    do i = m, n\n      if (isPrime(i)) then\n        if (i - k == g) then\n          res(1) = k\n          res(2) = i\n          return\n        end if\n        k = i\n      end if\n    end do\n    \n  END FUNCTION gap\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83084,"user_id":168,"body":"MODULE Solution\n  IMPLICIT NONE\n  PUBLIC :: gap\n\nCONTAINS\n\n    pure function is_odd_prime(n) result(flag)\n      integer, intent(in) :: n\n      integer :: d\n      logical :: flag\n      d = 3\n      do while (d * d <= n)\n        if (mod(n, d) == 0) then\n          flag = .false.\n          return\n        end if\n        d = d + 2\n      end do\n      flag = .true.\n    end function\n\n    FUNCTION gap(g, m, n) RESULT(res)\n        INTEGER, INTENT(IN):: g, m, n\n        INTEGER :: res(2)\n        integer :: prev, i\n        prev = -g\n        do i = or(m, 1), n, 2\n          if (is_odd_prime(i)) then\n            if (i - prev == g) then\n              res(1) = prev\n              res(2) = i\n              return\n            end if\n            prev = i\n          end if\n        end do\n        res = 0\n  END FUNCTION gap\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83085,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\n  PRIVATE :: is_it_prime\n  PUBLIC :: gap\n\nCONTAINS\n\n    FUNCTION is_it_prime(num) RESULT(bl)\n        INTEGER, INTENT(IN) :: num\n        LOGICAL :: bl\n        INTEGER :: i\n\n        IF(num == 2) THEN\n          bl = .TRUE.\n        ELSE IF(num < 2 .OR. MOD(num, 2) == 0) THEN\n          bl = .FALSE.\n        ELSE\n          bl = .TRUE.\n          DO i = 3, INT(SQRT(REAL(num))), 2\n             IF(MOD(num, i) == 0) THEN\n                bl = .FALSE.\n                EXIT\n             END IF\n          END DO\n        END IF\n    END FUNCTION\n\n    FUNCTION gap(g, m, n) RESULT(res)\n        INTEGER, INTENT(IN):: g, m, n\n        INTEGER :: i, j\n        INTEGER :: res(2)\n\n        res = 0\n        j = 0\n        DO i = m, n, 1\n            IF (is_it_prime(i)) THEN\n                IF (i - j == g) THEN\n                    res(1) = j\n                    res(2) = i\n                    RETURN\n                END IF\n                j = i\n            END IF\n        END DO\n  END FUNCTION gap\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"562e274ceca15ca6e70000d3":[{"id":83086,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  \n  FUNCTION len_curve(n) RESULT(l)\n    INTEGER :: n, i\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind) :: l, h\n    REAL(kind=ikind), DIMENSION(0:n) :: y\n    h = 1.0_ikind\/n\n    y = (h * (\/ (i, i = 0, n) \/)) ** 2\n    l = sum(sqrt(h**2 + (y(1:n) - y(0:n-1))**2))\n    l = aint(l*1e9_ikind)*1e-9_ikind\n  END FUNCTION len_curve\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83087,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  \n  function len_curve(n) result(l)\n    integer, intent(in) :: n\n    integer, parameter :: ikind = selected_real_kind(p=18)\n\n    real(ikind) :: l, step, x\n    integer :: i\n\n    step = 1.0_ikind \/ n\n    x = 0.0_ikind\n    l = 0.0_ikind\n\n    do i = 1, n\n      ! ds = sqrt(dx^2 + dy^2)\n      l = l + step*sqrt(1 + 4*(x**2) + 4*x*step + step**2)\n      x = x + step\n    end do\n  end function len_curve\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83088,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  \n  FUNCTION len_curve(n) RESULT(l)\n    INTEGER :: n, i\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind) :: l, step, d\n    \n    l = 0.\n    step = 1._ikind\/n\n    do i=1, n\n      d = sqrt(step**2 + ((2*i - 1)*step**2)**2)\n      l = l + d\n    end do\n    \n  END FUNCTION len_curve\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83089,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION len_curve(n) RESULT(l)\n    INTEGER :: n,i\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind) :: l,h\n    h=1.0_ikind\/n\n    l=0\n    DO i = 1,n\n      l=l+SQRT(((2*i-1)*h)**2+1)\n    END DO\n    l=h*l\n  END FUNCTION len_curve\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83090,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  pure function seg_length(x1, x2, y1, y2) result(length)\n  INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n  real(kind=ikind), intent(in)      :: x1, x2, y1, y2\n  real(kind=ikind)                  :: length\n  \n  length = sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1))\n  end function seg_length\n  \n  FUNCTION len_curve(n) RESULT(l)\n    INTEGER :: n\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind) :: l\n    \n    ! your code\n    real(kind=ikind)   :: xlength, x1, x2\n    integer            :: i \n    \n    l = 0.0_ikind\n    xlength = 1.0_ikind \/ n\n    \n    do i = 0, n - 1\n      x1 = i * xlength\n      x2 = x1 + xlength\n      l = l + seg_length(x1, x2, x1 * x1, x2 * x2)\n    end do\n    \n  END FUNCTION len_curve\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83091,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  \n  FUNCTION len_curve(n) RESULT(l)\n    INTEGER :: n,i\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind) :: l\n    REAL(kind=ikind) :: h,x1,x2,y1,y2\n    h=(1._16\/real(n))\n    x1=0\n    y1=0\n    l=0\n    do i=1,n\n    x2=x1+h\n    y2=x2**2\n    l= sqrt(((x2-x1)**2) +((y2-y1)**2))+l\n    x1=x2\n    y1=y2\n    end do\n    ! your code\n  END FUNCTION len_curve\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83092,"user_id":null,"body":"module Solution\n    implicit none\n    contains\n    function len_curve(n) result(l)\n        integer :: n, i\n        integer, parameter :: ikind=selected_real_kind(p=18)\n        real(kind=ikind) :: l, h, a, b, x_curr\n        a = 0._ikind\n        x_curr = a\n        b = 1._ikind        \n        l = 0._ikind\n        h = (b-a)\/n\n\n        do i = 0, n-1\n            x_curr = a + i*h\n            l = l + dist(x_curr, f(x_curr), x_curr + h, f(x_curr + h))\n        end do          \n               \n    end function len_curve\n\n    function f(x) result(y)\n        integer, parameter :: ikind=selected_real_kind(p=18)\n        real(kind=ikind) :: y, x\n        y = x*x        \n    end function f\n\n    function dist(x1,y1,x2,y2) result(distance)\n        integer, parameter :: ikind = selected_real_kind(p=18)\n        real(kind=ikind) :: x1,y1,x2,y2,distance\n        distance = sqrt((x2-x1)**2 + (y2-y1)**2)\n    end function dist\nend module solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83093,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  \n  FUNCTION len_curve(n) RESULT(l)\n    INTEGER :: n, i\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind) :: l, xi = 0, yi = 0, xip = 0, yip = 0, step = 0, li\n    \n    l = 0\n    step = 1._8\/n\n    xip = 0\n    yip = 0\n    \n    do i = 1, n\n      xi = i * step\n      yi = xi * xi\n      li = sqrt((xi - xip) * (xi - xip) + (yi - yip) * (yi - yip))\n      l = l + li\n      xip = xi\n      yip = yi\n    end do\n    \n  END FUNCTION len_curve\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83094,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  \n  FUNCTION len_curve(n) RESULT(l)\n    INTEGER :: n, i\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind) :: l, h, x1, x2, y1, y2, t\n    ! Only for array method\n    real(kind=ikind), dimension(n) :: lens \n    ! Initialization\n    l = 0\n    h = 1.0_ikind\/n\n    ! Obvious iterative method\n    !do i = 0, n-1\n    !  x1 = h*i\n    !  x2 = h*(i+1)\n    !  y1 = x1**2\n    !  y2 = x2**2\n    !  t = (x2-x1)**2 + (y2-y1)**2\n    !  l = l + sqrt(t)\n    !end do\n    ! Less obvious method\n    !do i = 0, n-1\n    !  l = l + sqrt(1 + (2*i*h+h)**2) \n    !end do\n    !l = l*h\n    ! Array method\n    lens =  (\/(i, i=0,n-1)\/)\n    l =  h*sum(sqrt(1 + (2 * lens * h + h)**2))\n  END FUNCTION len_curve\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83095,"user_id":17,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  REAL(10) PURE FUNCTION len_curve(n) RESULT(l)\n    INTEGER, INTENT(IN) :: n\n    INTEGER :: i\n    l = 0.0_10\n    DO i = 1, n\n      l = l + HYPOT(1.0_10 \/ REAL(n, 10), (REAL(i, 10) \/ REAL(n, 10)) ** 2.0_10 - (REAL(i - 1, 10) \/ REAL(n, 10)) ** 2.0_10)\n    END DO\n  END FUNCTION len_curve\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"562f91ff6a8b77dfe900006e":[{"id":83096,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION movie(card, ticket, perc) RESULT(cnt)\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind):: perc, sb, prev, nou\n    INTEGER :: card, ticket, i, sa, lp\n \n    i = 0; sa = 0; sb = REAL(card, ikind); lp = 1; prev = REAL(ticket, ikind)  \n    DO WHILE(lp == 1)\n      i = i + 1\n      nou = prev * perc\n      sb = sb + nou\n      prev = nou\n      sa = sa + ticket\n      IF (CEILING(sb) < sa) THEN\n        EXIT\n      END IF\n    END DO\n    cnt = i\n  END FUNCTION movie\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83097,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION movie(card, ticket, perc) RESULT(cnt)\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind):: perc, sb, prev, nou\n    INTEGER :: card, ticket, i, sa, lp\n \n    i = 0; sa = 0; sb = REAL(card, ikind); lp = 1; prev = REAL(ticket, ikind)  \n    DO WHILE(lp == 1)\n      i = i + 1\n      nou = prev * perc\n      sb = sb + nou\n      prev = nou\n      sa = sa + ticket\n      IF (CEILING(sb) < sa) THEN\n        EXIT\n      END IF\n    END DO\n    cnt = i\n  END FUNCTION movie\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83098,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER pure FUNCTION movie(card, ticket, perc) result(res)\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind), intent(in) :: perc\n    INTEGER, intent(in) :: card, ticket\n    real(kind=ikind) :: sum\n    \n    res = 0\n    sum = card\n    \n    do while (res*ticket <= ceiling(sum))\n      res = res + 1\n      sum = sum + ticket*perc**res\n    end do\n \n    ! your code\n  END FUNCTION movie\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83099,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION movie(card, ticket, perc)\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind):: perc\n    REAL(kind=ikind) :: price_A = 0\n    REAL(kind=ikind) :: price_B = 0\n    INTEGER :: card, ticket\n    INTEGER :: times = 1\n    INTEGER :: n = 1\n    \n    times = 1\n    DO\n      price_A = times * ticket\n      price_B = card\n      DO n = 1, times\n        price_B = price_B + ticket * perc ** n\n      END DO\n      \n      WRITE(*, *) times, price_A, price_B\n      \n      IF(price_A > CEILING(price_B)) THEN\n        EXIT\n      ELSE\n        times = times + 1\n      END IF\n    END DO\n    \n    movie = times\n  END FUNCTION movie\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83100,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION movie(card, ticket, perc) result(n)\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind):: perc, bprice\n    INTEGER :: card, ticket, n\n    logical :: cheaper\n  \n    n = card\/ticket + 1\n    cheaper = .false.\n    do while (.not. cheaper)\n      bprice = card + ticket*perc*(1-perc**n)\/(1-perc)\n      if (ceiling(bprice)<n*ticket) then\n        cheaper=.true.\n        exit\n      end if\n      n = n + 1\n    end do\n  END FUNCTION movie\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83101,"user_id":168,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION movie(card, ticket, perc)\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind):: perc\n    INTEGER :: card, ticket\n    real(kind=ikind) :: s, prev\n    s = card\n    prev = ticket\n    movie = 0\n    do\n      prev = prev * perc\n      s = s + prev\n      movie = movie + 1\n      if (ceiling(s) < ticket * movie) then; exit; end if\n    end do\n  END FUNCTION movie\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83102,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION movie(card, ticket, perc) RESULT (n)\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind):: perc\n    INTEGER :: card, ticket\n    \n    REAL(kind=ikind) :: b, last_ticket\n    INTEGER :: n\n    \n    n = 0\n    b = card * 1.\n    last_ticket = ticket * 1.\n    do while (n*ticket <= floor(b)+1)\n      b = b + last_ticket * perc\n      last_ticket = last_ticket * perc\n      n = n + 1\n    end do\n  END FUNCTION movie\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83103,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION movie(card, ticket, perc) result(n)\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind):: perc, a, b\n    INTEGER :: card, ticket\n    a = ticket\n    b = perc * ticket\n    n = 1\n    do while (a .le. ceiling(b + card))\n      a = a + ticket\n      b = perc * (b + ticket)\n      n = n + 1\n    end do\n  END FUNCTION movie\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83104,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION movie(card, ticket, perc)\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind):: perc\n    INTEGER :: card,ticket,n,A,B\n    n=1\n    DO WHILE (.true.)\n      A=ticket*n\n      B=CEILING(card+ticket*(1-perc**n)\/(1-perc))\n      IF (A .GT. B) THEN\n        movie=n-1\n        EXIT\n      ELSE\n        n=n+1\n      END IF\n    END DO\n  END FUNCTION movie\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83105,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION movie(card, ticket, perc)\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind):: perc\n    INTEGER :: card, ticket\n    REAL::SystemA,SystemB\n    \n    !my code\n    SystemA=0\n    SystemB=card\n    movie=0\n    Do While (SystemA<=ceiling(SystemB))\n      movie=movie+1\n      SystemA=ticket*movie\n      SystemB=SystemB+ticket*(perc**movie)\n    End Do\n    !End of my code\n    \n  END FUNCTION movie\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"56347fcfd086de8f11000014":[{"id":83106,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\n  INTEGER, PARAMETER :: long = SELECTED_REAL_KIND(p=18)\n  PUBLIC:: ex_euler\n  \n  CONTAINS\n  \n  FUNCTION ex_euler(nb) RESULT(res)\n    INTEGER, INTENT(IN) :: nb\n    REAL(long) :: res\n    \n    real(long), dimension(nb+1) :: s1, s2\n    real(long) :: x, y\n    real(long) :: dx\n    integer :: i\n    \n    x = 0.0_long\n    y = 1.0_long\n    dx = 1.0_long\/real(nb, long)\n    \n    do i = 1, nb + 1, 1\n      s1(i) = sol(x)\n      s2(i) = y\n      y = y + vf(x,y)*dx\n      x = x + dx\n    end do\n    \n    res = sum(abs(s2-s1)\/s1)\/real(nb + 1, long)\n    \n  END FUNCTION\n  \n  pure function sol(x)\n    real(long) :: sol\n    real(long), intent(in) :: x\n    sol = 1.0_long + 0.5_long*exp(-4.0_long*x) - 0.5*exp(-2.0_long*x)\n  end function sol\n  \n  pure function vf(x,y)\n    real(long), intent(in) :: x\n    real(long), intent(in) :: y\n    real(long) :: vf\n    vf = 2.0_long - exp(-4.0_long*x) - 2.0_long*y\n  end function vf\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-18 13:00:01"},{"id":83107,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\n  INTEGER, PARAMETER :: long = SELECTED_REAL_KIND(p=18)\n  PUBLIC:: ex_euler\n  !\n  CONTAINS\n  !\nPURE FUNCTION ex_euler(nb) RESULT(res)\n    implicit none\n    integer, intent(in) :: nb\n    integer :: i\n    real(long), parameter :: x0 = 0, y0 = 1, dT = 1\n    real(long) :: res, h, yk, zk, t\n\n    h = dT \/ nb\n    yk = y0\n    res = 0.0_long\n    t = 0.0_long\n    do i=1,nb\n        yk = yk + (2 - exp(-4*t) - 2*yk) * h\n        t = t + h\n        zk = 1 + 0.5_long * exp(-4*t) - 0.5_long * exp(-2*t)\n        res = res + abs(yk - zk) \/ zk\n    enddo\n    res = int(res \/ (nb + 1) * 1000000.0_long) \/ 1000000.0_long\nEND FUNCTION ex_euler\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-18 13:00:01"},{"id":83108,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\n  INTEGER, PARAMETER :: long = SELECTED_REAL_KIND(p=18)\n  PUBLIC:: ex_euler\n  !\n  CONTAINS\n  !\n  FUNCTION ex_euler(nb) RESULT(res)\n    INTEGER, INTENT(IN) :: nb\n    INTEGER :: i\n    REAL(long) :: res, y, z, t, err_sum, n\n    \n    n = REAL(nb)\n    i = 0\n    \n    t = 0\n    y = 1\n    err_sum = 0\n    \n    DO WHILE(i < nb)\n      y = y + ((2 - exp(-4*t) - 2*y) \/ n)\n      t = t + 1\/n\n      z = 1 + 0.5*(exp(-4*t) - exp(-2*t))\n      err_sum = err_sum + (ABS(y-z) \/ z)\n      \n      i = i + 1\n    END DO\n    res = err_sum\/(n+1)\n    res = REAL(INT(res * 1e6))\/1e6\n  END FUNCTION\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-18 13:00:01"},{"id":83109,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\n  INTEGER, PARAMETER :: long = SELECTED_REAL_KIND(p=18)\n  PUBLIC:: ex_euler\n  PRIVATE:: ode, exact\n  !\n  CONTAINS\n  !\n  SUBROUTINE ode(x, y, res)\n    INTEGER, PARAMETER :: long = SELECTED_REAL_KIND(p=18)\n    REAL(long), INTENT(IN) :: x, y\n    REAL(long), INTENT(OUT) :: res\n      res = 2.0 - EXP(-4.0 * x) - 2.0 * y\n  END SUBROUTINE ode\n  SUBROUTINE exact(x, res)\n    INTEGER, PARAMETER :: long = SELECTED_REAL_KIND(p=18)\n    REAL(long), INTENT(IN) :: x\n    REAL(long), INTENT(OUT) :: res\n      res = 1.0 + 0.5 * EXP(-4.0 * x) - 0.5 * EXP(-2.0 * x)\n  END SUBROUTINE exact\n\n  FUNCTION ex_euler(nb) RESULT(res)\n    INTEGER, INTENT(IN) :: nb\n    REAL(long) :: res\n    REAL(long) :: yi, xi, zi, h, err\n    INTEGER :: i\n\n    yi = 1.0_long\n    xi = 0.0_long\n    h = 1.0_long \/ nb\n    err = 0.0_long\n    i = 1\n    DO WHILE (i <= nb)\n      CALL ode(xi, yi, zi)\n      yi = yi + zi * h\n      xi = xi + h\n      CALL exact(xi, zi)\n      err = err + ABS(yi - zi) \/ zi\n      i = i + 1\n    END DO\n    res = INT((err \/ (FLOAT(nb) + 1.0_long)) * 10.0_long**6) \/ 10.0_long**6\n  END FUNCTION\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-18 13:00:01"}],"563a631f7cbbc236cf0000c2":[{"id":83110,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function move(pos, roll) result (res)\n    integer, intent(in) :: pos, roll\n    integer:: p\n    p=pos+2*roll\n    \n    res = p\n    \n    \n    \n  end function move\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83111,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function move(pos, roll) result (res)\n    integer, intent(in) :: pos, roll\n    res = pos + roll \/ 0.5\n  end function move\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83112,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure recursive function move(pos, roll) result (res)\n    integer, intent(in) :: pos, roll\n    res = 0\n    if (roll == 0) then\n      res = pos\n    else\n      res = move(pos + 2, roll - 1)\n    end if\n  end function move\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83113,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure recursive function move(pos, roll) result (res)\n    integer, intent(in) :: pos, roll\n    res = 0\n    if (roll == 0) then\n      res = pos\n    else\n      res = 2 + move(pos, roll - 1)\n    end if\n  end function move\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83114,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function move(pos, roll) result (res)\n    integer, intent(in) :: pos, roll\n    res = pos+roll+roll\n  end function move\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83115,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function move(pos, roll) result (res)\n    integer, intent(in) :: pos, roll\n    res = pos + (roll * 2)\n  end function move\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83116,"user_id":53,"body":"module Solution\n  implicit none\ncontains\n  integer pure function move(pos, roll) result (res)\n    integer, intent(in) :: pos, roll\n    res = pos + 2 * roll\n  end function move\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83117,"user_id":645,"body":"module Solution\n  implicit none\ncontains\n  integer pure function move(pos, roll)\n    integer, intent(in) :: pos, roll\n    move = pos + roll * 2\n  end function move\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"563b662a59afc2b5120000c6":[{"id":83118,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION nb_year(p0, percent, aug, p) RESULT(res)\n    IMPLICIT NONE\n    INTEGER :: p0, aug, p, pop\n    REAL :: percent\n\n    res = 0\n    pop = p0\n    DO WHILE (pop < p)\n      pop = FLOOR(pop * (1.0 + percent \/ 100.0) + aug)\n      res = res + 1\n    END DO\n  END FUNCTION nb_year\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83119,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION nb_year(p0, percent, aug, p) RESULT(n)\n    IMPLICIT NONE\n    INTEGER, INTENT(IN) :: p0, aug, p\n    REAL, INTENT(IN) :: percent\n    INTEGER :: pn\n    pn = p0\n    n = 0\n    DO WHILE (pn < p)\n      n = n + 1\n      pn = (pn + (pn*(percent\/100)) + aug)\n    END DO\n  END FUNCTION nb_year\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83120,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION nb_year(p0, percent, aug, p)\n    IMPLICIT NONE\n    INTEGER, INTENT(IN) :: p0, aug, p\n    REAL, INTENT(IN) :: percent\n    integer :: numYears, newPop\n    numYears = 0\n    newPop = p0\n    \n    do while (newPop < p)\n      numYears = numYears+1\n      newPop = newPop * ((percent\/100) + 1) + aug\n      print*, newPop\n    end do\n    \n    nb_year = numYears\n  END FUNCTION nb_year\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83121,"user_id":null,"body":"module  Solution\n  implicit none\ncontains\n  integer function nb_year(p0, percent, aug, p) result(year)\n    integer, intent(in) :: p0, aug, p\n    real,    intent(in) :: percent\n    \n    integer :: pop_size\n    real :: increase\n    \n    increase = 1.0 + percent \/ 100.0\n    pop_size = p0\n    year = 0\n    do while (p > pop_size)\n      pop_size = int(pop_size * increase) + aug\n      year = year + 1\n    end do\n  end function nb_year\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83122,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION nb_year(p0, percent, aug, p) result(m)\n    IMPLICIT NONE\n    INTEGER, INTENT(IN) :: p0, aug, p\n    REAL, INTENT(IN) :: percent\n    INTEGER :: pn\n    !INTEGER :: m\n      ! your code\n    pn = p0\n    m = 0\n    do while (pn < p)\n      m = m + 1\n      pn = pn + (pn * (percent \/ 100)) + aug\n    END DO\n  END FUNCTION nb_year\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83123,"user_id":168,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION nb_year(p0, percent, aug, p)\n    INTEGER, INTENT(IN) :: p0, aug, p\n    REAL, INTENT(IN) :: percent\n    real :: x\n    nb_year = 0\n    x = p0\n    do while (x > 0 .and. x < p)\n      x = x + floor(x * percent \/ 100 + aug)\n      nb_year = nb_year + 1\n    end do\n    if (p0 <= 0) then\n      nb_year = -1\n    end if\n  END FUNCTION nb_year\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83124,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  PURE FUNCTION nb_year(p0, percent, aug, p) RESULT(years)\n    IMPLICIT NONE\n    INTEGER, INTENT(IN) :: p0, aug, p\n    INTEGER :: years,pop\n    REAL, INTENT(IN) :: percent\n    years = 0\n    pop=p0\n    DO\n      IF (pop .ge. p) THEN\n        EXIT\n      ELSE\n        pop=FLOOR(pop*(100.0+percent)\/100.0)+aug\n        years=years+1\n      END IF\n    END DO\n  END FUNCTION nb_year\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83125,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION nb_year(p0, percent, aug, p)\n    IMPLICIT NONE\n    INTEGER, INTENT(IN) :: p0, aug, p\n    integer :: population\n    REAL, INTENT(IN) :: percent\n      nb_year = 0\n      population = p0\n      do while (population < p)\n        population = population * (1 + percent \/ 100) + aug\n        nb_year = nb_year + 1\n      end do\n  end function nb_year\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83126,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION nb_year(p0, percent, aug, p) RESULT(res)\n    IMPLICIT NONE\n    INTEGER, INTENT(IN) :: p0, aug, p\n    REAL, INTENT(IN) :: percent\n    INTEGER :: m\n         \n    res = 0\n    m = p0\n    \n    DO WHILE (m < p) \n      res = res + 1\n      m = m + aug + (m * percent \/ 100)\n    END DO\n      \n  END FUNCTION nb_year\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83127,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\n  CONTAINS\n    INTEGER FUNCTION nb_year(p0, percent, aug, p)\n      IMPLICIT NONE\n      INTEGER, INTENT(IN) :: aug, p, p0\n      INTEGER :: n\n      REAL, INTENT(IN) :: percent\n      REAL :: tmp1, tmp2\n      n = 0\n      tmp1 = percent\/100\n      tmp2 = p0\n      DO WHILE (tmp2 < p)\n         tmp2 = tmp2 + FLOOR(tmp2*tmp1) + aug\n         n = n + 1\n      END DO\n      nb_year = n\n    END FUNCTION nb_year\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"563f0c54a22b9345bf000053":[{"id":83128,"user_id":17,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  PURE FUNCTION fcn(n)\n    integer, INTENT(IN) :: n\n    integer(8) :: fcn\n    fcn = 2_8 ** n\n  END FUNCTION fcn\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83129,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION fcn(n) result(u0)\n  !  6ab-5ac+bc=0\n  ! c(5a-b)=6ab\n  ! c=6ab\/(5a-b) ... will produce squares...\n  ! \n    integer(kind=16) :: u0,u1,u2\n    integer          :: i,n\n    u0=1\n    u1=2\n    do i=1,n\n      u2=6*u0*u1\/(5*u0-u1)\n      u0=u1\n      u1=u2\n    enddo\n  END FUNCTION fcn\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83130,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\n  PUBLIC :: fcn\nCONTAINS\n  integer(kind=8) function fcn(n) result(m)\n    integer, intent(in) :: n\n    integer :: i\n    i = 1\n    m = 2\n    do while (i < n)\n      m = m * 2\n      i = i + 1\n    end do\n  end function fcn\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83131,"user_id":168,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  integer(8) FUNCTION fcn(n)\n    integer, intent(in) :: n\n    fcn = lshift(1_8, n)\n  END FUNCTION fcn\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83132,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION fcn(n) RESULT(mem)\n    REAL(kind=8) :: u0, u1, mem\n    INTEGER :: i, n\n    \n    u0 = 1\n    u1 = 2\n    i = 1\n    do while (i < n)\n      mem = 6. * u0 \/ (5. * (u0 \/ u1) - 1.)\n      u0 = u1\n      u1 = mem\n      i = i + 1\n    end do\n  END FUNCTION fcn\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83133,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION fcn(n) \n   integer, parameter :: Int_K = selected_int_kind (16)\n   integer(kind=16)::fcn\n   integer:: n,i\n   integer(kind=16):: u0,u1,u2\n   u0=1\n   u1=2\n   do i=1,n-1\n    u2=6*u0*u1\/(5*u0-u1)\n    u0=u1\n    u1=u2\n   end do\n   \n   fcn=u2\n   ! or equivalently:\n   fcn=2_int_k**(n)\n\n  END FUNCTION fcn\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83134,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION fcn(n) result(out)\n    ! your code\n    integer, intent(in)     :: n\n    integer(8)              :: out\n    \n    integer(8)              :: i, n0, n1\n    if (n == 0) then\n      out = 1\n      return\n    end if\n    if (n == 1) then\n      out = 2\n      return\n    end if\n    \n    n0 = 1\n    n1 = 2\n    do i = 2, n\n      out = n1 * (6 * n0 \/ (5 * n0 - n1))\n      n0 = n1\n      n1 = out\n    end do\n  END FUNCTION fcn\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83135,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION fcn(n) \n    INTEGER :: n\n    INTEGER(8) :: fcn\n    fcn = 2_8 ** n\n  END FUNCTION fcn\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83136,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION fcn(n) \n    INTEGER :: n\n    INTEGER(kind=8) :: one, fcn\n  \n    one = 1\n    fcn = lshift(one, n)\n  END FUNCTION fcn\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83137,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION fcn(n) result(u2)\n    integer, intent(in) :: n\n    integer :: i\n    integer(kind = 16) :: u0, u1, u2\n    u0 = 1\n    u1 = 2\n    do i = 1,n-1\n      u2 = -6*u0*u1\/(-5*u0 + u1)\n      u0 = u1\n      u1 = u2\n    end do\n  \n    ! your code\n  END FUNCTION fcn\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"564057bc348c7200bd0000ff":[{"id":83138,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION thirt(m) RESULT(c)\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER :: c\n    INTEGER(KIND=ikind) :: m, n, r\n    INTEGER, DIMENSION(6) :: w\n    INTEGER :: j\n    LOGICAL :: f\n    \n    w = (\/1, 10, 9, 12, 3, 4\/); n = m; f = .TRUE.\n    DO WHILE (f)\n      r = n; c = 0; j = 0\n      DO WHILE (r \/= 0)\n        c = INT(c + MOD(r, 10_ikind) * w(MOD(j, 6) + 1))\n        r = r \/ 10\n        j = j + 1\n      END DO\n      IF (c \/= n) THEN\n        n = c\n      ELSE\n        f = .FALSE.\n      END IF\n    END DO\n  END FUNCTION thirt\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83139,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER(16) FUNCTION thirt(m) RESULT(c)\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(KIND=ikind) :: m, tmp, prev\n    INTEGER :: i\n    INTEGER :: numbers(6)\n    numbers = (\/ 1, 10, 9, 12, 3, 4 \/)\n    c = m\n    prev = -1\n    \n    DO WHILE (prev .NE. c)\n      prev = c\n      tmp = 0\n      i = 1\n      DO WHILE (c .NE. 0)\n        tmp = tmp + MOD(c, 10)*numbers(i)\n        c = c \/ 10\n        i = i + 1\n        IF (i .GT. 6) i = 1\n      END DO\n      c = tmp\n    END DO\n  END FUNCTION thirt\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83140,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION thirt(m) RESULT(c)\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(KIND=ikind) :: m\n    integer(kind=ikind), parameter :: div(6) = [1, 10, 9, 12, 3, 4]\n    integer(kind=ikind) :: tmp, now, nxt\n    integer :: i\n    now = m\n    tmp = m\n    nxt = 0\n    do while(now \/= nxt)\n      now = nxt\n      nxt = 0_ikind\n      i = 0_ikind\n      do while (tmp > 0_ikind)\n        nxt = nxt + modulo(tmp, 10_ikind) * div(modulo(i, 6) + 1)\n        tmp = tmp \/ 10_ikind\n        i = i + 1\n      end do\n      tmp = nxt\n    end do\n    c = now\n  END FUNCTION thirt\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83141,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  INTEGER FUNCTION thirt(m) RESULT(c)\n  \n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(KIND=ikind) :: m, n, d\n    INTEGER, DIMENSION(6) :: w\n    INTEGER :: j\n    LOGICAL :: f\n    \n    w = (\/1, 10, 9, 12, 3, 4\/); n = m\n    DO WHILE (.TRUE.)\n      d = n\n      c = 0\n      j = 0\n      DO WHILE (d > 0)\n        c = c + MOD(d, 10_ikind) * w(MOD(j, 6) + 1)\n        d = d \/ 10\n        j = j + 1\n      END DO\n      IF (c \/= n) THEN\n        n = c\n      ELSE\n        EXIT\n      END IF\n    END DO\n  END FUNCTION thirt\n  \nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83142,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  INTEGER FUNCTION thirt(m) RESULT(c)\n  \n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(KIND=ikind) :: m, n, d\n    INTEGER, DIMENSION(6) :: w\n    INTEGER :: j\n    LOGICAL :: f\n    \n    w = (\/1, 10, 9, 12, 3, 4\/); n = m; f = .TRUE.\n    DO WHILE (f)\n      d = n\n      c = 0\n      j = 0\n      DO WHILE (d > 0)\n        c = c + MOD(d, 10_ikind) * w(MOD(j, 6) + 1)\n        d = d \/ 10\n        j = j + 1\n      END DO\n      IF (c \/= n) THEN\n        n = c\n      ELSE\n        f = .FALSE.\n      END IF\n    END DO\n  END FUNCTION thirt\n  \nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83143,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION thirt(m) RESULT(c)\n  INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n  INTEGER, DIMENSION(:), ALLOCATABLE :: digs\n  INTEGER, DIMENSION(6) :: mnum\n  INTEGER(KIND=ikind) :: num_digits, ix, rem, j\n  INTEGER(KIND=ikind) :: m, m2\n    \n    m2 = m   \n    num_digits = FLOOR(LOG10(REAL(m2))+1)\n    ALLOCATE(digs(num_digits))\n 5  num_digits = FLOOR(LOG10(REAL(m2))+1)\n    mnum(1) = 1\n    mnum(2) = 10\n    mnum(3) = 9\n    mnum(4) = 12\n    mnum(5) = 3\n    mnum(6) = 4\n    j = 1\n    c = 0\n    rem = m2\n    DO ix = 1, num_digits\n      digs(ix) = rem - (rem\/10)*10  ! integer division\n      rem = rem\/10\n      print *, ix, digs(ix)\n      c = c + digs(ix)*mnum(j)\n      j = j + 1\n      if (j .gt. 6) j = 1\n    END DO\n    IF(c .ne. m2)then\n      m2 = c\n      goto 5\n    ENDIF\n    \n    \n  END FUNCTION thirt\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83144,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION thirt(m) RESULT(c)\n  INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n  INTEGER, DIMENSION(:), ALLOCATABLE :: digs\n  INTEGER, DIMENSION(6) :: mnum\n  INTEGER(KIND=ikind) :: m, m2, num_digits, ix, rem, j\n  mnum = (\/1, 10, 9, 12, 3, 4\/)\n  m2 = m\n  num_digits = FLOOR(LOG10(REAL(m2))+1)\n  ALLOCATE(digs(num_digits))\n7 num_digits = FLOOR(LOG10(REAL(m2))+1)\n  c = 0\n  j = 1\n  rem = m2\n  DO ix = 1, num_digits\n    digs(ix) = rem - (rem\/10)*10\n    rem = rem\/10\n    c = c + digs(ix)*mnum(j)\n    j = j + 1\n    IF (j .gt. 6) j = 1\n  END DO\n  IF (c .ne. m2) THEN\n    m2 = c\n    goto 7\n  END IF\n  END FUNCTION thirt\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83145,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION thirt(m) RESULT(c)\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(KIND=ikind) :: m\n    character(len=256)  :: old, new\n    INTEGER(KIND=ikind) :: pattern(6) = (\/1, 10, 9, 12, 3, 4\/)\n    integer(kind=ikind) :: i, sum, d, j, ii\n    write(old,*) m\n    do while ( .true. )\n      old = adjustl(old)\n      sum = 0\n      ii = 0\n      do i = len_trim(old), 1, -1\n        ii = ii + 1\n        read(old(i:i),*) d\n        sum = sum + d*pattern(ii-6*((ii-1)\/6))\n      end do\n      write(new,*) sum\n      new = adjustl(new)\n      if ( new == old ) then\n        exit\n      else\n        old = new\n      end if\n    end do\n    c = sum\n    \n  END FUNCTION thirt\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83146,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  PURE FUNCTION thirt(m)    \n    INTEGER, PARAMETER :: ikind=selected_int_kind(16), l_seq = 6\n    INTEGER(KIND=ikind), dimension(l_seq), parameter :: seq = (\/1, 10, 9, 12, 3, 4\/)\n    INTEGER(KIND=ikind), INTENT(IN) :: m\n    INTEGER :: i\n    INTEGER(KIND=ikind) :: thirt, prev, curr\n    \n    prev = 0_ikind\n    thirt = m\n    do while (thirt \/= prev)\n        prev = thirt\n        curr = thirt\n        thirt = 0\n        i = 1\n        do while (curr \/= 0_ikind)\n            thirt = thirt + mod(curr, 10_ikind) * seq(i)\n            curr = curr \/ 10\n            i = mod(i, l_seq) + 1\n        enddo\n    enddo\nEND FUNCTION thirt\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83147,"user_id":null,"body":"module solution\n\n\timplicit none\n\t\n  private\n  \n\tinteger,parameter :: ikind=selected_int_kind(16)\n\tinteger(ikind),dimension(6),parameter :: list=[1,10,9,12,3,4]\n\t\n  public :: thirt\n  \n\tcontains\n\t\n\tpure subroutine get_reversed_digits(num,arr)\n    integer,parameter :: ikind=selected_int_kind(16)\n\t\tinteger(ikind),intent(in) :: num\n\t\tinteger(ikind),dimension(:),allocatable,intent(out) :: arr\n\t\tinteger(ikind) :: n,i,rem\n\t\tn=floor(log10(real(num,8))) + 1\n\t\tallocate(arr(n))\n\t\trem=num\n\t\tdo i=1,n,1\n\t\t\tarr(i)=rem-(rem\/10)*10\n\t\t\trem=rem\/10\n\t\tend do\n\tend subroutine get_reversed_digits\n\t\n\tpure integer function remainder(num)\n\t\tinteger(ikind),intent(in) :: num\n\t\tinteger(ikind),dimension(:),allocatable :: arr\n\t\tinteger(ikind) :: n,m\n\t\tinteger(ikind) :: i\n\t\tcall get_reversed_digits(num,arr)\n\t\tn=size(arr)\n\t\tm=0\n\t\tdo\n\t\t\tif(mod(n+m,6)==0) exit\n\t\t\tm=m+1\n\t\tend do\n\t\tremainder=sum([arr,(0_ikind,i=1,m)]*[(list,i=1,(n+m)\/6)])\n\tend function remainder\n\t\n\tpure integer function thirt(m) result(c)\n\t\tinteger(ikind),intent(in) :: m\n\t\tinteger(ikind) :: n\n\t\tc=m\n\t\tn=remainder(m)\n\t\tdo\n\t\t\tif(c==n)return\n\t\t\tc=n\n\t\t\tn=remainder(n)\n\t\tend do\n\tend function thirt\n\t\nend module solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"56445c4755d0e45b8c00010a":[{"id":83148,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  LOGICAL FUNCTION fortune(f0, p, c0, n, i)\n    INTEGER :: f0, c0, n, prev_x, prev_c, nou_x, nou_c, k\n    REAL :: p, i\n    \n    prev_x = f0; prev_c = c0; nou_x = -1; nou_c = -1\n    DO k = 1, n-1\n      nou_x = FLOOR(prev_x + p \/ 100.0 * prev_x - prev_c)\n      nou_c = FLOOR(prev_c + i \/ 100.0 * prev_c)\n      prev_x = nou_x\n      prev_c = nou_c\n    END DO    \n    IF (nou_x >= 0) THEN\n      fortune = .TRUE.\n    ELSE\n      fortune = .FALSE.\n    END IF\n  END FUNCTION fortune\nEND MODULE Solution","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83149,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION fortune(f0, p, c0, n, i) RESULT(isPossible)\n    INTEGER :: f0, c0, n, f, c, j\n    REAL :: p, i\n    LOGICAL :: isPossible\n    \n    f = f0\n    c = c0\n    j = 1\n    isPossible = .true.\n    do while (j < n)\n      f = floor(f * (1. + p\/100.) - c)\n      c = floor(c * (1. + i\/100.))\n      if (f < 0.) then\n        isPossible = .false.\n        return\n      endif\n      j = j + 1\n    end do\n  END FUNCTION fortune\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83150,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION fortune(f0, p, c0, n, i) RESULT(ans)\n    LOGICAL :: ans\n    INTEGER :: f0, c0, n, f, c, m\n    REAL(4) :: p, i, pp, ii\n    f = f0\n    c = c0\n    pp = REAL(p) \/ 100.0\n    ii = REAL(i) \/ 100.0\n    m = n - 1\n    DO WHILE (m > 0)\n      f = f + FLOOR(pp * f - c)\n      c = c + FLOOR(ii * c)\n      m = m - 1\n    END DO\n    ans = f >= 0\n  END FUNCTION fortune\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83151,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  LOGICAL FUNCTION fortune(f0, p, c0, n, i)\n    REAL :: p, i\n    INTEGER :: n, f0, c0, BANK, t\n    BANK = f0\n    fortune = .TRUE.\n    write(*,*) f0, p, c0, n, i\n    \n    do t=0,n-2\n      BANK = BANK*(1+p\/100) - c0*(1+i\/100)**t\n      if (BANK < 0) then\n        fortune = .FALSE.\n        RETURN\n      end if\n    end do\n    \n  END FUNCTION fortune\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83152,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  LOGICAL FUNCTION fortune(f0, p, c0, n, i)\n  integer f0, c0, n, yr \n  real    fn, cn, p, i\n  fn = f0;    cn = c0\n  do yr=2, n\n    fn = floor(fn * (1 + p\/100) - cn)\n    cn = floor(cn * (1 + i\/100))\n  enddo\n  fortune = (fn >= 0)\n  END FUNCTION fortune\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83153,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  LOGICAL FUNCTION fortune(f0, p, c0, n, i)\n    INTEGER, PARAMETER :: ikind = selected_int_kind(8)\n    INTEGER, PARAMETER :: pkind = selected_real_kind(10) \n    INTEGER(ikind) :: f0, c0\n    INTEGER :: n, year\n    REAL(4) :: p, i\n    REAL(pkind) :: balance, living, p_mult, i_mult\n    \n    balance = REAL(f0, pkind)\n    living = REAL(c0, pkind)\n    p_mult = 1 + p \/ 100_pkind\n    i_mult = 1 + i \/ 100_pkind\n    \n    DO year = 2, n\n      balance = balance * p_mult - living\n      IF (balance < 0) THEN\n        fortune = .FALSE.\n        return\n      END IF\n      living = REAL(FLOOR(living * i_mult), pkind)\n    END DO\n    fortune = .TRUE.\n    ! your code\n  END FUNCTION fortune\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83154,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  LOGICAL FUNCTION fortune(f0, p, c0, n, i)\n    INTEGER,INTENT(in):: f0,c0,n\n    REAL,INTENT(in):: p,i\n    INTEGER:: f,c,year\n    f = f0\n    c = c0\n    do year = 1,(n-1) !fine anno year\n      f = f + int(f * (p\/100)) - c\n      c = c + int(c * (i\/100))\n    end do\n    fortune = (f > 0)\n  END FUNCTION fortune\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83155,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  LOGICAL FUNCTION fortune(f0, p, c0, n, i)\n    ! f0 * (p-i)**n = n *c0\n    ! transcendental equation, so let's do this the iterative way\n    ! First n such that n*c0 is larger\n    integer :: n2, f0, c0, n\n    real :: p, i, rp, ri, f1, c1\n    rp = 1. + p\/100. ! effective interest rate\n    ri = 1. + i\/100. ! effective inflation rate\n    fortune = .true.\n    f1 = real(f0)\n    c1 = real(c0)\n    ! Only need to survive *to* year n, not through.  Hence n-1\n    do n2 = 1, n-1\n      f1 = f1 * rp - c1\n      c1 = c1 * ri\n      if (f1 < 0) then\n        fortune = .false.\n        exit\n      end if\n    end do\n  END FUNCTION fortune\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"565abd876ed46506d600000d":[{"id":83156,"user_id":53,"body":"module Solution\n  implicit none\ncontains\n\n  function fn(x) result(res)  \n    integer, parameter :: ikind=selected_real_kind(p=18)\n    real(kind=ikind) :: x, res\n    res = 1.5 * sin(x) ** 3.0\n  end function fn\n  \n  function simpson(n) result(res)\n    integer, intent(in) :: n\n    integer, parameter :: ikind=selected_real_kind(p=18)\n    integer :: i\n    real(kind=ikind) :: res, pi\n    pi = 3.14159265358979323846_ikind\n    res = 0\n    do i = 1, n\n      res = res + (2 + mod(i, 2) * 2) * fn((pi \/ n) * i)\n    end do\n    res = res * (pi \/ 3) \/ n\n  end function simpson\n  \nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83157,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION f(x) RESULT(r)  \n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind):: x, r\n    r = 1.5 * SIN(x) ** 3.0\n  END FUNCTION f\n  \n  FUNCTION simpson(n) RESULT(res)\n    INTEGER, INTENT(IN) :: n\n    INTEGER :: i\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind) :: res, h, pi, nn, s1, s2\n    \n    pi = 3.14159265358979323846_ikind\n    nn = REAL(n, ikind)\n    h = pi \/ nn\n    s1 = 0.0_ikind\n    DO i = 1, n \/ 2\n      s1 = s1 + f((2 * i - 1) * h)\n    END DO\n    s2 = 0.0_ikind;\n    DO i = 1, n \/ 2 - 1\n      s2 = s2 + f(2 * i * h)\n    END DO\n    res = pi \/ (3.0 * nn) * (f(0.0_ikind) + f(pi) + 4.0 * s1 + 2.0 * s2)\n  END FUNCTION simpson\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83158,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION simpson(n) RESULT(res)\n    INTEGER, INTENT(IN) :: n\n    INTEGER :: i\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind) :: res, h\n    \n    res=0.0_ikind\n    \n    h = 3.14159265358979323846_ikind\/n\n    \n    do i=1,n\/2\n      res = res + 2*h*sin((2*i-1)*h)**3 + h*sin(2*i*h)**3\n    end do\n    \n  END FUNCTION simpson\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83159,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\n  INTEGER, PARAMETER, PRIVATE :: ikind=selected_real_kind(p=18)\nCONTAINS\n\n  real(ikind) function f(x)\n    real(ikind), intent(in) :: x\n    f = 1.5 * sin(x)**3\n    return\n  end function f\n\n  FUNCTION simpson(n) RESULT(res)\n    INTEGER, INTENT(IN) :: n\n    REAL(kind=ikind) :: res\n    real(ikind) :: a, b, h, pi\n    real(ikind) :: s2, s2m1\n    integer :: i\n    \n    pi = 3.14159265358979323846_ikind\n    \n    ! your code\n    a = 0.\n    b = pi\n    h = (b - a) \/ n\n\n    s2 = 0.\n    s2m1 = 0.\n    do i = 1, n \/ 2 - 1\n      s2 = s2 + f(a + (2 * i - 1) * h)\n      s2m1 = s2m1 + f(a + 2 * i * h)\n    end do\n    s2 = s2 + f(a + (2 * i - 1) * h)\n\n    res = (b - a) \/ (3 * n) * (f(a) + f(b) + 4 * s2 + 2 * s2m1)\n  END FUNCTION simpson\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83160,"user_id":187,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION simpson(n) RESULT(res)\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    INTEGER, INTENT(IN) :: n\n    INTEGER :: i\n    REAL(kind=ikind) :: res, x(n+1), y(n+1), inc\n    REAL(kind=ikind), PARAMETER :: pi =   3.14159265358979323846_ikind\n    inc = 0.0_ikind\n    DO i=0,n\n      x(i+1)=0.0_ikind+pi\/(REAL(n,ikind))*REAL(i,ikind)\n      y(i+1)=sin(x(i+1))**(3.0_ikind)*3.0_ikind\/2.0_ikind\n    ENDDO \n    DO i=1, n, 2\n      inc = inc + 2.0_ikind*y(i) + 4.0_ikind*y(i+1)\n      WRITE(*,*) inc\n    ENDDO \n    res = pi\/REAL(n,ikind)\/3.0_ikind*(inc+y(1)+y(n+1))\n  END FUNCTION simpson\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83161,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  \n  FUNCTION simpson(n) RESULT(res)\n    INTEGER, INTENT(IN) :: n\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind) :: res, pi, h\n    \n    integer      :: i\n    \n    pi = 3.14159265358979323846_ikind\n    h = pi \/ n\n    res = f(0._ikind) + f(pi)\n    \n    do i = 1, n \/ 2\n      res = res + 4._ikind * f((2 * i - 1) * h)\n    end do\n    do i = 1, (n \/ 2) - 1\n      res = res + 2._ikind * f(2 * i * h)\n    end do\n    res = res * h \/ 3._ikind\n  \n  contains\n  pure real(kind=ikind) function f(x) \n  real(kind=ikind), intent(in)    :: x\n  f = (3._ikind \/ 2._ikind) * (sin(x)) ** 3\n  end function\n  END FUNCTION simpson\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83162,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\npure function simpson(n)\n    implicit none\n    integer, intent(in) :: n\n    integer, parameter :: ikind=selected_real_kind(p=18)\n    integer :: i\n    real(kind=ikind) :: simpson, pi, h, x\n\n    pi = 3.14159265358979323846_ikind\n    h = pi \/ n\n\n    simpson = 0\n    ! first term\n    do i=1,n\/2\n        x = (2*i - 1)*h\n        simpson = simpson + 2 * 3 * sin(x)**3\n    enddo\n    ! second term\n    do i=1,n\/2-1\n        x = 2*i*h\n        simpson = simpson + 3 * sin(x)**3\n    enddo\n    simpson = simpson * h \/ 3\nEND function simpson\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83163,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION simpson(n) RESULT(res)\n    INTEGER, INTENT(IN) :: n\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind) :: res, h\n    INTEGER :: i\n    \n    REAL(kind=ikind), PARAMETER :: pi = 3.14159265358979323846_ikind\n    \n    res = 0.\n    h = pi \/ n\n    DO i = 1, n \/ 2 - 1\n      res = res + 4 * f((2 * i - 1) * h) + 2 * f(2 * i * h)\n    END DO\n    res = res + 4 * f((n - 1) * h)\n    res = res * pi \/ (3 * n)\n    \n    ! your code\n  END FUNCTION simpson\n  \n  FUNCTION f(x)\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind) :: f, x\n    \n    f = SIN(x) ** 3 * 3. \/ 2.\n  END FUNCTION f\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83164,"user_id":null,"body":"MODULE Solution\n    IMPLICIT NONE\n    INTEGER, PARAMETER :: ikind1=selected_real_kind(p=18)\nCONTAINS\n    FUNCTION simpson(n) RESULT(res)\n        INTEGER, INTENT(IN) :: n \n        integer :: i\n        INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n        REAL(kind=ikind) :: res, h, pi\n    \n        pi = 3.14159265358979323846_ikind\n        h = pi\/(1.*n)\n        res = (f(0.0_ikind) + f(pi))*h\/3.       \n\n        i = 1\n        do while( i .lt. n\/2)\n        res = res + (h*4.\/3.)*f((2.*i - 1.)*h)\n        res = res + (h*2.\/3.)*f(2.*i*h)\n        i = i + 1\n        end do\n\n        res = res + (h*4.\/3.)*f((n - 1.)*h)\n        \n    \n        ! your code\n    END FUNCTION simpson\n    real(kind = ikind1) function f(x)\n        INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n        real(kind = ikind) x\n        f = 1.5*sin(x)**3\n    end function f\n\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83165,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION simpson(n) RESULT(res)\n    INTEGER, INTENT(IN) :: n\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind) :: res, pi, h\n    integer :: i\n    \n    pi = 3.14159265358979323846_ikind\n    h = pi\/n\n    \n    res = f(pi)\n    do i = 1, n\/2\n      res = res + 4*f(h*(2*i - 1))\n    end do\n    \n    do i = 1, n\/2-1\n      res = res + 2*f(2*i*h)\n    end do\n    \n    res = res * h\/3\n    \n  contains\n    function f(x)\n      real(kind=ikind), intent(in) :: x\n      real(kind=ikind) :: f\n      \n      f = 3.0_ikind\/2 * sin(x)**3\n    end function\n  END FUNCTION simpson\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"565c0fa6e3a7d39dee000125":[{"id":83166,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION dist(v, mu) RESULT(res)\n    REAL, INTENT(IN) :: v, mu\n    REAL :: res, u\n    u = v * 5.0 \/ 18.0\n    res = u + u ** 2 \/ (2.0 * mu * 9.81)\n  END FUNCTION\n\n  FUNCTION speed(d, mu) RESULT(res)\n    REAL, INTENT(IN) :: d, mu\n    REAL :: res, b\n    b = -2.0 * mu * 9.81\n    res = 3.6 * (b + (b ** 2 - 4 * b * d) ** 0.5 ) \/ 2\n  END FUNCTION\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83167,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION dist(v, mu) RESULT(res)\n    REAL, INTENT(IN) :: v, mu\n    REAL :: g, coef, dreact, vms, dbrak, res\n\n    ! suppose reaction time is 1\n    g = 9.81                               ! acceleration due to gravity in m\/s\n    coef = 1000.0 \/ 3600.0                 ! km\/h -> m\/s\n    dreact = v * coef                      ! distance of reaction with t = 1\n    vms = coef * v                         ! speed in m\/s\n    dbrak = 0.5 * vms ** 2 \/ mu \/ g        ! braking distance\n    res = dreact + dbrak\n\n  END FUNCTION\n\n  FUNCTION speed(d, mu) RESULT(res)\n    REAL, INTENT(IN) :: d, mu\n    REAL :: g, coef, res\n\n    ! suppose reaction time is 1\n    g = 9.81                                ! acceleration due to gravity in m\/s\n    coef = 3600.0 \/ 1000.0                  ! m\/s -> km\/h\n    res = 0.5 * mu * g * (- 2.0 + SQRT(4.0 + 8.0 * d \/ mu \/ g)) * coef\n\n  END FUNCTION\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83168,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION dist(v, mu) RESULT(res)\n    REAL, INTENT(IN) :: v, mu\n    REAL :: g, coef, dreact, vms, dbrak, res\n\n    ! suppose reaction time is 1\n    g = 9.81                               ! acceleration due to gravity in m\/s\n    coef = 1000.0 \/ 3600.0                 ! km\/h -> m\/s\n    dreact = v * coef                      ! distance of reaction with t = 1\n    vms = coef * v                         ! speed in m\/s\n    dbrak = 0.5 * vms ** 2 \/ mu \/ g        ! braking distance\n    res = dreact + dbrak\n\n  END FUNCTION\n\n  FUNCTION speed(d, mu) RESULT(res)\n    REAL, INTENT(IN) :: d, mu\n    REAL :: g, coef, res\n\n    ! suppose reaction time is 1\n    g = 9.81                                ! acceleration due to gravity in m\/s\n    coef = 3600.0 \/ 1000.0                  ! m\/s -> km\/h\n    res = 0.5 * mu * g * (- 2.0 + SQRT(4.0 + 8.0 * d \/ mu \/ g)) * coef\n\n  END FUNCTION\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83169,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION dist(v, mu) RESULT(res)\n    REAL, INTENT(IN) :: v, mu\n    REAL :: res\n\n    ! suppose reaction time is 1\n    res = v \/ 3.6 + (v \/ 3.6) ** 2 \/ (2 * mu * 9.81)\n\n  END FUNCTION\n\n  FUNCTION speed(d, mu) RESULT(res)\n    REAL, INTENT(IN) :: d, mu\n    REAL :: res\n\n    ! suppose reaction time is 1\n    res = (-1.0 + sqrt(1 + 2 * d \/ (mu * 9.81))) * mu * 9.81 * 3.6\n\n  END FUNCTION\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83170,"user_id":null,"body":"module Solution\n  implicit none\n  private\n\n  real, parameter :: g = 9.81  ! Acceleration due to Earth's gravity in m\/s^2\n  real, parameter :: mps_to_kph_factor = 3.6\n\n  public :: dist, speed\ncontains\n  real function dist(v, mu) result(d1)\n    real, intent(in) :: v, mu\n    real :: v_mps\n\n    v_mps = v \/ mps_to_kph_factor\n    d1 = v_mps + ((v_mps * v_mps) \/ (2 * mu * g))\n  end function dist\n\n  real function speed(d, mu) result(v)\n    real, intent(in) :: d, mu\n    real :: mu_g\n    mu_g = mu * g\n\n    ! NOTE: In the real world, it makes sense for v to be positive\n    v = (sqrt(mu_g * (2 * d + mu_g)) - mu_g) * mps_to_kph_factor\n  end function speed\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83171,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION dist(v, mu) RESULT(res)\n    REAL, INTENT(IN) :: v, mu\n    REAL :: res\n    real :: speed\n\n    ! suppose reaction time is 1\n    ! your code\n    !Convert v to m\/s\n    speed = v*1000\/3600\n    !Find stopping dist\n    res = (speed**2)\/(2*mu*9.81) + speed\n\n  END FUNCTION\n\n  FUNCTION speed(d, mu) RESULT(res)\n    REAL, INTENT(IN) :: d, mu\n    REAL :: res, a,b,c, vel\n\n    ! suppose reaction time is 1\n    ! your code    \n    a = 1\/(2*mu*9.81)\n    b = 1\n    c = -d\n    vel = (-b + sqrt(b**2 - 4*a*c))\/(2*a)\n    !Change velocity to km\/h\n    res = vel*3600\/1000\n    \n\n  END FUNCTION\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83172,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION dist(v, mu) RESULT(res)\n    REAL, INTENT(IN) :: v, mu\n    REAL :: res, g ,v1\n    g=9.81\n    ! suppose reaction time is 1\n    v1=v\/3.6   ! convert to m\/s\n    res=v1+v1**2\/(2.0*mu*g)\n  END FUNCTION\n\n  FUNCTION speed(d, mu) RESULT(res)\n    REAL, INTENT(IN) :: d, mu\n    REAL :: res,g,d0,v,v0,eps\n    g=9.81\n    eps=0.00005\n    v=sqrt(2.0*mu*g*d)*3.6  ! convert to km\/h\n    do\n        d0=d-v\/3.6\n        v0=sqrt(abs(2.0*mu*g*d0))*3.6\n        if(abs(dist(v0,mu)-d) < eps) exit\n        v=(v0+v)*0.5\n     enddo  \n     res=v0\n  END FUNCTION\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83173,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION dist(v, mu) RESULT(res)\n    REAL, INTENT(IN) :: v, mu\n    REAL :: res\n    \n    res = v ** 2 \/ (2 * mu * 9.81 * (3.6 ** 2)) + v \/ 3.6\n\n  END FUNCTION\n\n  FUNCTION speed(d, mu) RESULT(res)\n    REAL, INTENT(IN) :: d, mu\n    REAL :: res\n    REAL :: a , b, x, y\n    \n    a = 1 \/ (2 * (3.6 ** 2) * mu * 9.81)\n    b = 1 \/ (3.6)\n    x = b \/ a\n    y = d \/ a\n    \n    res = -1 * x \/ 2 + SQRT(x ** 2 \/ 4 + y)\n  END FUNCTION\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83174,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION dist(v, mu) RESULT(res)\n    REAL, INTENT(IN) :: v, mu\n    REAL :: res, g, ms\n    g = 9.81\n    ms = v\/3600*1000\n    res = ms+ms**2\/(2*mu*g)\n  END FUNCTION\n\n  FUNCTION speed(d, mu) RESULT(res)\n    REAL, INTENT(IN) :: d, mu\n    REAL :: res, g\n    g = 9.81\n    !quadratic formula of 0 = 1\/(2*mu*g)v^2+v-d\n    res = (-1+sqrt(1+2*d\/(mu*g)))\/(1\/(mu*g))*3.6\n\n    ! suppose reaction time is 1\n    ! your code\n\n  END FUNCTION\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83175,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION dist(v, mu) RESULT(res)\n  REAL, INTENT(IN) :: v, mu\n  REAL :: res, newv\n  newv = v\/3600*1000\n  res = (newv*newv)\/(2*mu*9.81) + newv * 1\n  END FUNCTION\n\n  FUNCTION speed(d, mu) RESULT(res)\n  REAL, INTENT(IN) :: d, mu\n  REAL :: res, v, c\n  c = 2*9.81*mu\n  v = (-c + SQRT(c**2 + 4 * d * c))\/2\n  res = v * 3600\/1000\n  END FUNCTION\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"566543703c72200f0b0000c9":[{"id":83176,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION epidemic(tm, n, s0, i0, b, a)\n    INTEGER :: tm, n, s0, i0, k\n    REAL :: b, a, susceptible, infected, recovered, infected_max, dt\n    REAL :: susceptibleNext, infectedNext\n\n    susceptible = 1.0 * s0\n    infected = DBLE(i0)\n    recovered = 0.0\n    infected_max = infected\n    dt = 1.0 * tm \/ n\n    DO k = 0, n-1\n\t\tsusceptibleNext = susceptible - dt * b * susceptible * infected\n        infectedNext = infected + dt * (b * susceptible * infected - a * infected)\n        recovered = recovered + dt * infected * a\n        infected = infectedNext\n        susceptible = susceptibleNext\n        IF (infected > infected_max) THEN\n          infected_max = infected\n        END IF\n    END DO\n\tepidemic = INT(infected_max)\n  END FUNCTION epidemic\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83177,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer function epidemic(tm, n, s0, i0, b, a)\n    integer, intent(in) :: tm, n, s0, i0\n    real,    intent(in) :: b, a\n\n    real :: s, i, r, max_i\n    real :: s_prev, i_prev, r_prev\n    real :: dt\n    integer :: interval\n    \n    dt = real(tm) \/ real(n)\n    s_prev = real(s0);  i_prev = real(i0);  r_prev = 0.0\n    max_i = real(i0)\n\n    do interval = 1, n\n      s = s_prev - dt * b*s_prev*i_prev\n      i = i_prev + dt * (b*s_prev*i_prev - a*i_prev)\n      r = r_prev + dt * i_prev*a\n      \n      if (max_i < i) max_i = i\n\n      s_prev = s;  i_prev = i;  r_prev = r\n    end do\n    \n    epidemic = int(max_i)\n  end function epidemic\nend module Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83178,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  PURE FUNCTION epidemic(tm, n, s0, i0, b, a) RESULT(max_infect)\n    INTEGER, INTENT(IN) :: tm,n,s0,i0\n    REAL, INTENT(IN) :: a,b\n    REAL :: dt,S,S_prev,I\n    INTEGER :: max_infect,step\n    dt=real(tm)\/n\n    S_prev=s0\n    I=i0\n    max_infect=i0\n    DO step = 2,n\n      S=S_prev-dt*b*S_prev*I\n      I=I+dt*(b*S_prev*I-a*I)\n      S_prev=S\n      IF (max_infect .lt. I) THEN\n          max_infect = int(i)\n      END IF\n    END DO\n  END FUNCTION epidemic\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83179,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure integer function epidemic(tm, n, s0, i0, b, a)\n    ! declare variables\n    integer, intent(in) :: tm, n, s0, i0\n    real,    intent(in) :: b, a\n    real s, s_new, i, i_new, r, i_max, dt\n    integer step\n    ! initialize\n    s = real(s0); s_new = 0.0\n    i = real(i0); i_new = 0.0\n    i_max = i\n    dt = real(tm) \/ real(n)\n    ! compute result\n    do step=0, n\n      s_new = s - dt * b * s * i\n      i_new = i + dt * i * (b * s - a)\n      s = s_new; i = i_new\n      r = r + dt * i * a\n      if (i .gt. i_max) then \n        i_max = i \n      end if\n    end do\n    epidemic = int(i_max)\n  end function epidemic\nend module Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83180,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION epidemic(tm, n, s0, i0, b, a) RESULT (w)\n    INTEGER, INTENT(IN):: tm\n    INTEGER, INTENT(IN):: n\n    INTEGER, INTENT(IN):: s0\n    INTEGER, INTENT(IN):: i0\n    REAL, INTENT(IN):: b\n    REAL, INTENT(IN):: a\n    \n    real :: s, i, r, t, dt, imax, sd, id, rd\n    \n    s = REAL(s0)\n    i = REAL(i0)\n    r = REAL(0)\n    t = REAL(0)\n    dt = REAL(tm) \/ REAL(n)\n    imax = REAL(0)\n    \n    DO WHILE ( t < REAL(tm) )           \n        sd = dt*(-b*s*i)\n        id = dt*(b*s*i-a*i)\n        rd = dt*(a*i)\n        s = s + sd\n        i = i + id\n        r = r + rd\n        t = t + dt\n        IF ( FLOOR(i) > imax ) THEN\n            imax = FLOOR(i)\n        END IF\n    END DO\n    \n    w = INT(imax)\n    \n  END FUNCTION epidemic\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83181,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION epidemic(tm1, n1, s01, i01, b, a)\n    ! your code\n  INTEGER :: i, ep, tm1, n1, s01, i01\n  REAL :: Sn, Rn, In, Stemp, Rtemp, Itemp, Imax, tm, n, s0, i0\n  REAL :: dt, b, a\n  tm = float(tm1)\n  n = float(n1)\n  s0 = float(s01)\n  i0 = float(i01)\n  dt = tm\/n\n  \n  Sn = s0\n  Rn = 0\n  In = i0\n  Stemp= 0 \n  Rtemp = 0\n  Itemp = 0\n  Imax = i0\n  DO i = 1, int(n)\n    Stemp = Sn-(dt * b* Sn * In)\n    Itemp = In+(dt * (b * Sn * In - a * In))\n    Rtemp = Rn+(dt * In * a)\n    Sn = Stemp\n    If (Imax .lt. Itemp) THEN\n      Imax = Itemp\n    END IF\n    In = Itemp\n    Rn = Rtemp\n  END DO\n  ep = int(Imax)\n  epidemic = ep\n  END FUNCTION epidemic\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83182,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION epidemic(tm, n, s0_, i0_, b, a)\n    ! your code\n    integer, intent(in)  :: tm, n, s0_, i0_\n    real, intent(in)     :: b, a\n    \n    real           :: dt\n    real           :: r0, r1, s0, s1, i0, i1\n    integer        :: i\n    \n    s0 = s0_\n    i0 = i0_\n    dt = real(tm) \/ real(n)\n    r0 = 0.0\n    epidemic = max(0.0, i0)\n    \n    do i = 1, n\n      s1 = s0 - dt * b * s0 * i0\n      i1 = i0 + dt * (b * s0 * i0 - a * i0)\n      r1 = r0 + dt * i0 * a\n      \n      epidemic = max(real(epidemic), i1)\n      s0 = s1\n      i0 = i1\n      r0 = r1\n    end do\n    \n  END FUNCTION epidemic\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83183,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\nPURE FUNCTION epidemic(tm, n, s0, i0, b, a) result(max)\n    integer, intent(in) :: tm, n, s0, i0\n    real, intent(in) :: b, a\n    integer :: max, idx\n    real :: S, I, R, dt, maxf, bsi, ai\n\n    S = s0\n    I = i0\n    R = 0.0\n    maxf = 0.0\n    dt = real(tm) \/ real(n)\n\n    do idx=1,n\n        bsi = dt * b * S * I\n        ai = dt * a * I\n        S = S - bsi\n        I = I + bsi - ai\n        R = R + ai\n        if (I > maxf) then\n            maxf = I\n        endif\n    enddo\n    \n    max = int(maxf)\n\nEND FUNCTION epidemic\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83184,"user_id":null,"body":"MODULE Solution\n    IMPLICIT NONE\n  CONTAINS\n    INTEGER FUNCTION epidemic(tm, n, s0, i0, b, a) result(res)\n      integer,intent(in)::tm,n,s0,i0\n      real,intent(in)::b,a\n      real::s_t,i_t,s,i,r,r_t,dt\n      integer::j\n      s=s0;s_t=s0\n      i=i0;i_t=i0\n      r=0.;r_t=0.\n      dt=1.*tm\/n\n      res=0\n      do j=1,n\n        s_t=s-dt*b*s*i\n        i_t=i+dt*(b*s*i-a*i)\n        r_t=r+dt*i*a\n        s=s_t;i=i_t;r=r_t\n        if (res<i_t) res=i_t\n      end do\n    END FUNCTION epidemic\n  END MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83185,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION epidemic(tm, n, s0, i0, b, a)\n    integer, intent(in):: tm, n\n    integer, intent(in) :: s0, i0\n    real, intent(in) :: b, a\n    \n    real :: s, i, r, s_tmp, i_tmp, r_tmp\n    real :: dt\n    real :: max_i\n    integer :: j\n    \n    s = real(s0)\n    i = real(i0)\n    r = 0\n    dt = real(tm) \/ n\n    max_i = real(i0)\n    \n    do j = 1, n\n      s_tmp = s - dt * b * s * i\n      i_tmp = i + dt * (b * s * i - a * i)\n      r_tmp = r + dt * i * a\n      s = s_tmp\n      i = i_tmp\n      r = r_tmp\n      \n      if (i .gt. max_i) then\n        max_i = i\n      end if\n    end do\n    \n    epidemic = max_i\n  END FUNCTION epidemic\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"566be96bb3174e155300001b":[{"id":83186,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION maxball(v0)\n    INTEGER :: v0\n    maxball = NINT((v0 \/ 3.6) \/ 0.981)\n  END FUNCTION maxball\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83187,"user_id":17,"body":"module Solution\n  implicit none\ncontains\n  pure function maxball(v) result(t)\n    integer, intent(in) :: v\n    integer :: t\n    t = nint(v \/ 3.5316)\n  end function maxball\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83188,"user_id":168,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION maxball(v0)\n    integer :: v0\n    maxball = nint(v0 \/ 3.5316)\n  END FUNCTION maxball\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83189,"user_id":187,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION maxball(iv0)\n  INTEGER :: iv0\n  REAL(8) :: rv0\n  rv0 = REAL(iv0,8)\n        maxball =  nint(rv0*0.2831600407747197d0)\n  END FUNCTION maxball\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83190,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION maxball(v0)\n    INTEGER, INTENT(IN) :: v0 !km\/h\n    REAL, PARAMETER :: g = 9.81 !m\/s\/s\n    REAL :: t\n    t = (v0*1000.0\/3600.0)\/g\n    maxball = NINT(t*10)\n  END FUNCTION maxball\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83191,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION maxball(v0)\n    INTEGER, INTENT(in) :: v0 !km\/h\n    REAL, PARAMETER :: g = 9.81 !m\/s\/s\n    REAL :: h,hlast,v\n    INTEGER :: t\n    h = 0.0\n    hlast = -1\n    t = 0\n    v = v0*1000.0\/3600.0 !m\/s\n    DO WHILE (h > hlast)\n      t = t + 1\n      hlast = h\n      h = v*(t*0.1) - 0.5*g*(t*0.1)**2\n    END DO\n    maxball = t - 1\n  END FUNCTION maxball\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83192,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION maxball(v0) RESULT(res)\n    INTEGER, INTENT(in) :: v0\n    res = NINT(REAL(v0) \/ 3.5316)\n  END FUNCTION maxball\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83193,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION maxball(v)\n  REAL :: oldHeight, height\n  INTEGER(4) :: v\n  REAL :: newV, time, temp\n  INTEGER :: oldTime, tempHeight!, time\n  newV = v \/3.6\n  oldHeight = 0\n  oldTime = 0\n  height = (newV*0.1) - (9.81 * 0.5 * 0.1 * 0.1)\n  time = 1\n  DO WHILE (oldHeight .le. height)\n    oldHeight = height\n    oldTime = time\n    time = time + 1\n    temp = time\/10\n    height = (newV*temp)-(9.81*0.5*temp*temp)\n  END DO\n  maxball = int(oldTime)\n  END FUNCTION maxball\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83194,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION maxball(v0) result(tmax)\n    real, parameter :: g = 9.81, dt = 0.1\n    real :: t, vms0\n    integer :: v0\n\n    vms0 = v0*1000.\/3600. !convert to m\/s\n    \n    t = vms0\/g !peak height when dh\/dt = 0 -> t = v0\/g\n    tmax = nint(t\/dt) !time in tenths of a second\n    \n  END FUNCTION maxball\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83195,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\n  \n  real, parameter :: g = 9.81\n  \nCONTAINS\n  INTEGER FUNCTION maxball(v0)\n    integer, intent(in) :: v0\n    real :: v_mps\n    real :: curr_height\n    real :: next_height\n    integer :: t\n    \n    v_mps = real(v0) \/ 3.6\n    curr_height = 0.0\n    t = 0\n    \n     do\n       next_height = measured_height(v_mps, t)\n       if (next_height .lt. curr_height) then\n         exit\n       end if\n       \n       curr_height = next_height\n       t = t + 1\n      end do\n      \n      maxball = t-1\n  END FUNCTION maxball\n  \n  real pure function measured_height(v, t)\n    real, intent(in) :: v\n    integer, intent(in) :: t\n    real :: tenths_of_seconds\n    \n    tenths_of_seconds = t * 0.1\n    measured_height = v*tenths_of_seconds - 0.5*g*tenths_of_seconds*tenths_of_seconds\n  end function measured_height\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"566fc12495810954b1000030":[{"id":83196,"user_id":492,"body":"  INTEGER FUNCTION nb_dig(n, d) RESULT(res)\n    IMPLICIT NONE\n    INTEGER :: n, d, k, m\n\n    res = 0\n    DO k = 0, n\n      m = k * k\n      DO\n        IF (MOD(m, 10) == d) res = res + 1\n        m = m \/ 10\n        IF (m == 0) EXIT\n      END DO\n    END DO\n  END FUNCTION nb_dig","lang_id":19,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83197,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION nb_dig(n, d) RESULT(res)\n    IMPLICIT NONE\n    INTEGER :: n, d, k, m\n\n    res = 0\n    DO k = 0, n\n      m = k * k\n      DO\n        IF (MOD(m, 10) == d) res = res + 1\n        m = m \/ 10\n        IF (m == 0) EXIT\n      END DO\n    END DO\n  END FUNCTION nb_dig\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83198,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER pure FUNCTION nb_dig(n, d) RESULT(res)\n    IMPLICIT NONE\n    INTEGER, intent(in) :: n, d\n    integer :: i, tmpsquare\n    \n    res = 0\n    if (d == 0 .and. n >= 0) then\n      res = 1\n    end if\n    \n    do i = 1, n\n      tmpsquare = i*i;\n      do while (tmpsquare > 0)\n        if (mod(tmpsquare, 10) == d) then\n          res = res + 1\n        end if\n        tmpsquare = tmpsquare \/ 10\n      end do\n    end do\n    \n  END FUNCTION nb_dig\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83199,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer function nb_dig(n, d) result(d_count)\n    integer, intent(in) :: n, d\n    integer :: k, k_sqrd\n\n    d_count = 0\n    if (d == 0) d_count = 1\n\n    do k = 1, n\n      k_sqrd = k * k\n      do while (k_sqrd > 0)\n        if (mod(k_sqrd, 10) == d) d_count = d_count + 1\n        k_sqrd = k_sqrd \/ 10\n      end do\n    end do\n  end function nb_dig\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83200,"user_id":53,"body":"module Solution\n  implicit none\ncontains\n\n  integer function nb_dig(k, d) result(m)\n    implicit none\n    integer :: k, d, i, n, p\n    m = 0\n    i = 0\n    do while (i <= k)\n      n = i * i\n      if (n == 0 .and. d == 0) then\n        m = m + 1\n      else\n        do while (n > 0)\n          p = mod(n, 10)\n          if (p == d) then\n            m = m + 1\n          end if\n          n = n \/ 10\n        end do\n      end if\n      i = i + 1\n    end do\n  end function nb_dig\n\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83201,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION nb_dig(n, d) RESULT(res)\n    IMPLICIT NONE\n    INTEGER :: n, d,num, num_digits, rem, ix, i, j\n    INTEGER, DIMENSION(:), ALLOCATABLE :: digs\n    \n    IF(d==0)then\n      res = 1\n    ELSE\n      res = 0\n    ENDIF\n    \n    DO num = 1,n\n      num_digits = FLOOR(LOG10(REAL(num**2))+1)\n      ALLOCATE(digs(num_digits))\n      rem = num**2\n      DO ix = 1, num_digits\n        digs(ix) = rem - (rem\/10)*10  ! Take advantage of integer division\n        rem = rem\/10\n      END DO\n      DO i = 1, size(digs)\n        j = digs(i)\n        IF(j==d)then\n          res = res+1\n        ENDIF\n      END DO\n      DEALLOCATE(digs)\n    END DO\n    \n    ! your code\n  END FUNCTION nb_dig\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83202,"user_id":168,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION nb_dig(n, d) RESULT(res)\n    INTEGER, intent(in) :: n, d\n    integer :: k, x\n    if (d == 0) then; res = 1; else; res = 0; end if\n    do k = 0, n\n      x = k * k\n      do while (x > 0)\n        if (mod(x, 10) == d) then; res = res + 1; end if\n        x = x \/ 10\n      end do\n    end do\n    \n  END FUNCTION nb_dig\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83203,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION nb_dig(n, d) RESULT(res)\n    IMPLICIT NONE\n    INTEGER :: n, d\n    INTEGER :: i, j\n    CHARACTER(20) :: num\n    CHARACTER :: digit\n    \n    write(digit, '(I1)') d\n    res = 0\n    do i=0, n\n      write(num, '(I0)') i*i\n      do j=0, 20\n        if (num(j:j) .eq. digit) then\n          res = res + 1\n        endif\n      end do\n    end do\n  END FUNCTION nb_dig\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83204,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  PURE FUNCTION nb_dig(n, d) RESULT(res)\n    INTEGER, INTENT(IN) :: n,d\n    INTEGER :: i,digit,square,res\n    res=0\n    DO i=1,n\n        square=i**2\n        DO WHILE (square .NE. 0)\n            digit=MOD(square,10)\n            square=(square-digit)\/10\n            IF (digit .EQ. d) THEN\n                res=res+1\n            END IF\n        END DO\n    END DO\n    IF (d .EQ. 0) THEN\n        res=res+1\n    END IF\n  END FUNCTION nb_dig\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83205,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION nb_dig(n, d) RESULT(res)\n    IMPLICIT NONE\n    INTEGER :: n, d\n    \n    ! your code\n    integer      :: i, sd, sqtemp\n    \n    res = 0\n    do i = 0, n\n      sqtemp = i * i\n      do while (sqtemp > 0)\n        sd = mod(sqtemp, 10)\n        if (sd == d) res = res + 1\n        sqtemp = sqtemp \/ 10\n      end do\n      \n      if (d == 0 .and. i * i == 0) res = res + 1\n    end do\n  END FUNCTION nb_dig\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5672682212c8ecf83e000050":[{"id":83206,"user_id":492,"body":"  FUNCTION dbl_linear(n) RESULT(res)\n    INTEGER, INTENT(IN):: n\n    INTEGER :: yi, zi, cnt, y, z\n    INTEGER, DIMENSION(0:n+1) :: arr\n    \n    yi = 0; zi = 0; cnt = 0; arr(0) = 1\n    DO WHILE (cnt <= n)\n      y = 2 * arr(yi) + 1\n      z = 3 * arr(zi) + 1\n      cnt = cnt + 1\n      IF (y > z) THEN\n        arr(cnt) = z\n        zi = zi + 1\n      ELSE IF (z > y) THEN\n        arr(cnt) = y\n        yi = yi + 1\n      ELSE\n        arr(cnt) = y\n        yi = yi + 1; zi = zi + 1\n      END IF\n    END DO\n    res = arr(n)\n  END FUNCTION dbl_linear","lang_id":19,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83207,"user_id":null,"body":"MODULE Twicelinear\n  IMPLICIT NONE\n  !\n  PUBLIC:: dbl_linear\n  PRIVATE\n  !\n  CONTAINS\n  !\n  FUNCTION dbl_linear(n) RESULT(Uv)\n    INTEGER, INTENT(IN):: n\n    INTEGER:: Uv, P\n    INTEGER:: I,J,Y,Z\n    INTEGER, DIMENSION(0:n):: u\n    !\n    u(0) = 1\n    I = 0\n    J = 0\n    P = 0\n    DO Uv=1, n\n        Y = 2*u(I)+1\n        Z = 3*u(J)+1 \n        !\n        P = P + 1\n        IF(     Y < Z ) THEN\n                            I = I + 1\n                            u(P) = Y\n        ELSEIF( Z < Y ) THEN\n                            J = J + 1\n                            u(P) = Z\n        ELSE\n                            I = I + 1\n                            J = J + 1\n                            u(P) = Y\n        END IF\n        !\n    END DO\n    !\n    Uv = U(n)\n    !\n  END FUNCTION dbl_linear\n  \nEND MODULE Twicelinear","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83208,"user_id":null,"body":"MODULE Twicelinear\n  IMPLICIT NONE\nCONTAINS\n\n  INTEGER FUNCTION dbl_linear(n) result(res)\n    INTEGER, INTENT(IN):: n\n    integer :: i, i2, i3 !counters where to insert, which 2x and which 3x position we are now\n    integer :: u(0:n)\n    u(0) = 1\n    i2 = 0\n    i3 = 0\n    \n    do i =1,n\n      if (2*u(i2) < 3*u(i3)) then\n        u(i) = 2*u(i2)+1\n        i2 = i2+1\n      else if (2*u(i2) > 3*u(i3)) then\n        u(i) = 3*u(i3)+1\n        i3 = i3+1\n      else !avoid duplicates by shifting both by 1\n        u(i) = 3*u(i3)+1\n        i2 = i2+1\n        i3 = i3+1\n      end if\n    end do\n    \n    res = u(n)\n  END FUNCTION dbl_linear\n  \nEND MODULE Twicelinear\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83209,"user_id":168,"body":"MODULE Twicelinear\n  IMPLICIT NONE\nCONTAINS\n\n  INTEGER FUNCTION dbl_linear(n) result (res)\n    INTEGER, INTENT(IN) :: n\n    integer :: seq(1:n + 1)\n    integer :: i, i2, i3, k2, k3, k\n    seq(1) = 1\n    i2 = 1\n    i3 = 1\n    do i = 1, n\n      k2 = seq(i2) * 2 + 1\n      k3 = seq(i3) * 3 + 1\n      k = min(k2, k3)\n      seq(i + 1) = k\n      if (k2 == k) then\n        i2 = i2 + 1\n      end if\n      if (k3 == k) then\n        i3 = i3 + 1\n      end if\n    end do\n    res = seq(n + 1)\n  END FUNCTION dbl_linear\n  \nEND MODULE Twicelinear\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83210,"user_id":53,"body":"MODULE Twicelinear\n  IMPLICIT NONE\nCONTAINS\n\n  INTEGER FUNCTION dbl_linear(n) RESULT (w)\n    INTEGER, INTENT(IN):: n\n      \n      integer, DIMENSION(0:n + 1) :: u\n      integer :: i, x, y\n      \n      u(0) = 1\n      x = 0\n      y = 0\n      \n      DO i = 1, n\n          u(i) = MIN(2 * u(x) + 1, 3 * u(y) + 1)\n          IF ( u(i) == (2 * u(x) + 1) ) THEN \n              x = x + 1\n          END IF \n          IF ( u(i) == (3 * u(y) + 1) ) THEN \n              y = y + 1\n          END IF \n      END DO\n      \n      w = u(n)\n      \n      \n  END FUNCTION dbl_linear\n  \nEND MODULE Twicelinear","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83211,"user_id":53,"body":"MODULE Twicelinear\n  IMPLICIT NONE\nCONTAINS\n\n  INTEGER FUNCTION dbl_linear(n) RESULT (w)\n    INTEGER, INTENT(IN):: n\n      \n      integer, DIMENSION(n + 2) :: u\n      integer :: i, x, y\n      \n      u(0 + 1) = 1\n      x = 0\n      y = 0\n      \n      DO i = 1, n\n          u(i + 1) = MIN(2 * u(x + 1) + 1, 3 * u(y + 1) + 1)\n          IF ( u(i + 1) == (2 * u(x + 1) + 1) ) THEN \n              x = x + 1\n          END IF \n          IF ( u(i + 1) == (3 * u(y + 1) + 1) ) THEN \n              y = y + 1\n          END IF \n      END DO\n      \n      w = u(n + 1)\n      \n      \n  END FUNCTION dbl_linear\n  \nEND MODULE Twicelinear\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83212,"user_id":null,"body":"MODULE Twicelinear\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION dbl_linear(n)\n    INTEGER, INTENT(IN) :: n\n    INTEGER :: list(2*n), list2(2*n)\n    INTEGER i, limit, addIndex, li, li2 ! list index 1 & 2\n    list(1) = 3\n    list2(1) = 4 ! for the first if comparison\n    li = 1\n    li2 = 1\n    addIndex = 2\n    limit = n+1\n    \n    DO WHILE (li+li2 .LE. limit)\n      IF (list(li) .LT. list2(li2)) THEN\n        list(addIndex) = 2 * list(li) + 1\n        list2(addIndex) = 3 * list(li) + 1\n        dbl_linear = list(li)\n        li = li + 1\n      ELSE IF (list2(li2) .LT. list(li)) THEN\n        list(addIndex) = 2 * list2(li2) + 1\n        list2(addIndex) = 3 * list2(li2) + 1\n        dbl_linear = list2(li2)\n        li2 = li2 + 1\n      ELSE ! if both are same\n        dbl_linear = list(li)\n        li2 = li2 + 1\n        limit = limit + 1\n        addIndex = addIndex - 1\n      END IF\n      addIndex = addIndex + 1\n    END DO\n  END FUNCTION dbl_linear\nEND MODULE Twicelinear","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83213,"user_id":null,"body":"MODULE Twicelinear\n  IMPLICIT NONE\nCONTAINS\n\n  INTEGER FUNCTION dbl_linear(n)\n    INTEGER, INTENT(IN):: n\n    Integer :: u(0:n+1)\n    Integer :: y, z\n    Integer :: iy, iz, k\n    \n    u(0) = 1\n    iy = 0  ;    iz = 0  ;    k = 0\n    y = 1 + 2*u(iy)\n    z = 1 + 3*u(iz)\n\n    Do While (k < n)\n      Do While (z > y)\n        If (k > n) exit\n        k = k + 1\n        u(k) = y\n        iy = iy + 1\n        y = 1 + 2*u(iy)\n        If (u(k) == u(k-1)) k = k - 1\n      End Do\n      If (k >= n) exit\n      k = k + 1\n      u(k) = z\n      iz = iz + 1\n      z = 1 + 3*u(iz)\n      If (u(k) == u(k-1)) k = k - 1\n    End Do\n\n    dbl_linear = u(n)\n    \n  END FUNCTION dbl_linear\n  \nEND MODULE Twicelinear\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83214,"user_id":null,"body":"Module Twicelinear\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION dbl_linear(n)\n    INTEGER,   INTENT(IN):: n\n    integer*8  u(0:int(n*3)), v(0:int(n*3)), x(0:int(n*4))\n    integer    i, j, iU, iV, uiU, viV, zU, zV, zOut, uMax\n    u = 0;     v = 0;    x = 0  !Initialise arrays to zeros!\n    u(0:3) = (\/ 1, 3, 7, 9 \/);  v(0:3) = (\/ 1, 4,10,13 \/)\n    x(0:3) = (\/ 1, 3, 4, 7 \/) ! Final result, x = u + v ordered & de-duped !\n    \n  ! iU & iV = i\/p array index = base for next 2 nos. !\n  ! zU & zV = o\/p array index = result for 2 numbers !\n    iU = 2;  iV = 2;  j = 2;    uMax = Size(u)-25\n    zU = 4;  zV = 4;  zOut = 4\n    \n    do i=2,  n\n       ! With u(iU).Select\n888    uiU = u(iU)\n       If (uiU > v(iV))  GoTo 999\n        u(zU) = 2 * uiU + 1\n        v(zV) = u(zU) + uiU\n        If (uiU > x(zOut - 1)) Then\n            x(zOut) = uiU\n            zOut = zOut + 1\n        End If\n        iU = iU + 1;  zU = zU + 1;  zV = zV + 1\n \n        ! With v(iV).Select\n999     viV = v(iV)\n        If (u(iU) < viV)  GoTo 888\n        u(zU) = 2 * viV + 1\n        v(zV) = u(zU) + viV\n        If (viV > x(zOut - 1)) Then\n            x(zOut) = viV\n            zOut = zOut + 1\n        End If\n        iV = iV + 1;  zU = zU + 1;  zV = zV + 1\n      \n      j = j + 1\n      if (j > uMax)   EXIT\n    end do\n    \ndbl_linear = x(n);  !!print *, u, v !x, n, x(n)\n    \n  !  print *, \"x = \", size(x), n\n  !  do i=0, uMax, 5\n  !    write(*,\"(5I8,A,I5)\") x(i:i+4), \" |\" , i+4\n  !  end do\nEND FUNCTION dbl_linear\nEND MODULE Twicelinear\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"567501aec64b81e252000003":[{"id":83215,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  \n  FUNCTION wall_paper(l, w, h) RESULT(rslt)\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind) :: l, w, h, tmp\n    CHARACTER(LEN=9), dimension(20) :: numbers\n    CHARACTER(LEN=9) :: res\n    CHARACTER(:), allocatable :: rslt\n    \n    IF (l * w * h < 0.01_ikind) THEN\n      rslt = \"zero\"\n      RETURN\n    END IF\n    numbers = (\/ \"one      \", \"two      \", \"three    \", \"four     \", \"five     \", \"six      \", \"seven    \",&\n    &\"eight    \", \"nine     \", \"ten      \",\"eleven   \", \"twelve   \", \"thirteen \", \"fourteen \", \"fifteen  \",&\n    &\"sixteen  \", \"seventeen\", \"eighteen \", \"nineteen \", \"twenty   \" \/)\n    tmp = (( (l + w) * 2.0_ikind * h) \/ 5.2_ikind) * 1.15_ikind\n    res = TRIM(numbers(INT(CEILING(tmp))))\n    rslt = \"\" \/\/ TRIM(res)\n  END FUNCTION wall_paper\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83216,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  \n  pure FUNCTION wall_paper(l, w, h) result(res)\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind), intent(in) :: l, w, h\n    character(:), allocatable :: res\n    character(len = 9), dimension(0:20) :: numbers\n    \n    numbers = [character(len=9) :: \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", &\n              \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\",\"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", &\n              \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\"]\n    \n    res = trim(numbers(0))\n    \n    if (l > 0 .and. w > 0) then\n      res = trim(numbers(ceiling(2.0*(l+w)*h \/ 5.2 * 1.15)))\n    end if\n    \n  END FUNCTION wall_paper\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83217,"user_id":53,"body":"module solution\n  implicit none\ncontains\n\n  function wall_paper(l, w, h) result (ans)\n    integer, parameter :: ikind=selected_real_kind(p=18)\n    real(kind=ikind) :: l, w, h\n    character(len=9), dimension(20) :: ns\n    character(len=9) :: res\n    character(:), allocatable :: ans\n    if (l * w * h < 0.01_ikind) then\n      ans = \"zero\"\n    else\n      ns = (\/ \"one      \", \"two      \", \"three    \", \"four     \", \"five     \", \"six      \", \"seven    \",&\n      &\"eight    \", \"nine     \", \"ten      \",\"eleven   \", \"twelve   \", \"thirteen \", \"fourteen \", \"fifteen  \",&\n      &\"sixteen  \", \"seventeen\", \"eighteen \", \"nineteen \", \"twenty   \" \/)\n      res = trim(ns(int(ceiling((((l + w) * 2.3_ikind * h) \/ 5.2_ikind)))))\n      ans = \"\" \/\/ trim(res)\n    end if\n  end function wall_paper\n  \nend module solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83218,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  \n  FUNCTION wall_paper(l, w, h) result(res)\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind) :: l, w, h\n    REAL(kind=ikind) :: area\n    INTEGER :: roll\n    CHARACTER(:), allocatable :: res\n    \n    area = (2 * l + 2 * w) * h\n    \n    IF (l * w * h <= 0) THEN\n      res = \"zero\"\n      RETURN\n    END IF\n    \n    roll = ceiling(area * 1.15 \/ 5.2)\n    \n    SELECT CASE (roll)\n      case (1); res = \"one\"\n      case (2); res = \"two\"\n      case (3); res = \"three\"\n      case (4); res = \"four\"\n      case (5); res = \"five\"\n      case (6); res = \"six\"\n      case (7); res = \"seven\"\n      case (8); res = \"eight\"\n      case (9); res = \"nine\"\n      case (10); res = \"ten\"\n      case (11); res = \"eleven\"\n      case (12); res = \"twelve\"\n      case (13); res = \"thirteen\"\n      case (14); res = \"fourteen\"\n      case (15); res = \"fifteen\"\n      case (16); res = \"sixteen\"\n      case (17); res = \"seventeen\"\n      case (18); res = \"eighteen\"\n      case (19); res = \"nineteen\"\n      case (20); res = \"twenty\"\n    END SELECT\n    \n    \n  END FUNCTION wall_paper\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83219,"user_id":168,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  \n  FUNCTION wall_paper(l, w, h) result (res)\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind) :: l, w, h\n    integer :: n\n    character(:), allocatable :: res\n    if (l <= 0 .or. w <= 0 .or. h <= 0) then\n      res = \"zero\"\n      return\n    end if\n    n = ceiling(2 * h * (l + w) * 1.15 \/ 5.2)\n    select case (n)\n      case (1); res = \"one\"\n      case (2); res = \"two\"\n      case (3); res = \"three\"\n      case (4); res = \"four\"\n      case (5); res = \"five\"\n      case (6); res = \"six\"\n      case (7); res = \"seven\"\n      case (8); res = \"eight\"\n      case (9); res = \"nine\"\n      case (10); res = \"ten\"\n      case (11); res = \"eleven\"\n      case (12); res = \"twelve\"\n      case (13); res = \"thirteen\"\n      case (14); res = \"fourteen\"\n      case (15); res = \"fifteen\"\n      case (16); res = \"sixteen\"\n      case (17); res = \"seventeen\"\n      case (18); res = \"eighteen\"\n      case (19); res = \"nineteen\"\n      case (20); res = \"twenty\"\n      case default; res = \"many\"\n    end select\n    \n  END FUNCTION wall_paper\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83220,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  PURE FUNCTION wall_paper(l, w, h) RESULT(rolls)\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    INTEGER :: position\n    REAL(kind=ikind), INTENT(IN) :: l, w, h\n    CHARACTER (:), ALLOCATABLE :: rolls\n    CHARACTER (LEN=9), DIMENSION(0:20), PARAMETER :: numbers = [\"zero     \",\"one      \",\"two      \",\"three    \", &\n    \"four     \",\"five     \",\"six      \",\"seven    \",\"eight    \",\"nine     \",\"ten      \",\"eleven   \", &\n    \"twelve   \",\"thirteen \",\"fourteen \",\"fifteen  \",\"sixteen  \",\"seventeen\",\"eighteen \",\"nineteen \",\"twenty   \"]\n    IF (l*w*h .EQ. 0) THEN\n      position=0\n    ELSE\n      position = CEILING((2.3\/5.2)*(l+w)*h)\n    END IF\n    rolls = TRIM(numbers(position))\n  END FUNCTION wall_paper\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83221,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\n  \n  character(len=10), dimension(21), parameter :: list = (\/ &\n    \"zero      \", &\n    \"one       \", &\n    \"two       \", &\n    \"three     \", &\n    \"four      \", &\n    \"five      \", &\n    \"six       \", &\n    \"seven     \", &\n    \"eight     \", &\n    \"nine      \", &\n    \"ten       \", &\n    \"eleven    \", &\n    \"twelve    \", &\n    \"thirteen  \", &\n    \"fourteen  \", &\n    \"fifteen   \", &\n    \"sixteen   \", &\n    \"seventeen \", &\n    \"eighteen  \", &\n    \"nineteen  \", &\n    \"twenty    \"  \/)\n     \nCONTAINS\n  \n  FUNCTION wall_paper(l, w, h)\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind) :: l, w, h\n    \n    character(:), allocatable :: wall_paper\n    \n    real(ikind)  :: area\n    \n    if (l*w*h==0.0_ikind) then\n      allocate(character(len=4) :: wall_paper)\n      wall_paper = \"zero\"\n      return\n    end if\n\n    area = 1.15_ikind*2.0_ikind*h*(l+w)\n    area = area\/(0.52_ikind*10.0_ikind)\n    \n    allocate(character(len=len(trim(list(1+ceiling(area))))) :: wall_paper)\n    wall_paper = trim(list(1+ceiling(area)))\n    \n\n    \n  END FUNCTION wall_paper\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83222,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  \n  FUNCTION wall_paper(l, w, h) RESULT(rslt)\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind) :: l, w, h, tmp\n    CHARACTER(LEN=9), dimension(20) :: numbers\n    CHARACTER(LEN=9) :: res\n    CHARACTER(:), allocatable :: rslt\n    \n    IF (l * w * h < 0.01_ikind) THEN\n      rslt = \"zero\"\n      RETURN\n    END IF\n    numbers = (\/ \"one      \", \"two      \", \"three    \", \"four     \", \"five     \", \"six      \", \"seven    \",&\n    &\"eight    \", \"nine     \", \"ten      \",\"eleven   \", \"twelve   \", \"thirteen \", \"fourteen \", \"fifteen  \",&\n    &\"sixteen  \", \"seventeen\", \"eighteen \", \"nineteen \", \"twenty   \" \/)\n    tmp = (( (l + w) * 2.0_ikind * h) \/ 5.2_ikind) * 1.15_ikind\n    res = TRIM(numbers(INT(CEILING(tmp))))\n    rslt = \"\" \/\/ TRIM(res)\n  END FUNCTION wall_paper\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"569b5cec755dd3534d00000f":[{"id":83223,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION newavg(A, navg) result(y)\n    IMPLICIT NONE\n    REAL, INTENT(IN) :: A(:)\n    REAL :: navg, s, x\n    INTEGER :: n, y\n    \n    s = SUM(A)\n    n = SIZE(A)\n    x = navg * (n + 1) - s\n\n    if ( x < 0 ) then\n      y = -1\n    else\n      y = ceiling(x)\n    end if\n    \n  END FUNCTION newavg\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83224,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION newavg(A, navg) RESULT(ans)\n    IMPLICIT NONE\n    REAL, INTENT(IN) :: A(:)\n    REAL :: navg\n    ans=ceiling(navg*(size(A)+1)-sum(A))\n    if(ans<=0)ans=-1\n  END FUNCTION newavg\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83225,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION newavg(A, navg) RESULT(res)\n    IMPLICIT NONE\n    REAL, INTENT(IN) :: A(:)\n    REAL :: sm, navg, donation\n    INTEGER :: i\n    sm = 0.0\n    DO i = 1, SIZE(A)\n        sm = sm + A(i)\n    END DO\n    donation = navg * (SIZE(A) + 1) - sm\n    IF (donation <= 0.0) THEN\n        res = -1\n    ELSE\n        res = CEILING(donation)\n    END IF\n  END FUNCTION newavg\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83226,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION newavg(A, navg)\n    IMPLICIT NONE\n    REAL, INTENT(IN) :: A(:)\n    REAL :: navg, newavg\n    newavg=ceiling(navg*(size(A)+1)-sum(A))\n    IF (newavg<0) THEN\n      newavg=-1\n    ELSE\n      RETURN\n    END IF\n  END FUNCTION newavg\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83227,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION newavg(A, navg)\n    IMPLICIT NONE\n    REAL, INTENT(IN) :: A(:)\n    REAL :: navg\n    REAL :: ret, newavg\n    \n    ret = ceiling((size(A) + 1) * navg - sum(A))\n    if (ret < 0) then\n      ret = -1\n    end if\n    newavg = ret\n  END FUNCTION newavg\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83228,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION newavg(A, navg) result(ret)\n    IMPLICIT NONE\n    REAL, INTENT(IN) :: A(:)\n    REAL :: navg\n    real :: tmp\n    real :: ret\n    tmp = navg * (size(A) + 1) - sum(A)\n    if (tmp > 0) then\n      ret = tmp + 0.5\n    else\n      ret = -1\n    end if\n  END FUNCTION newavg\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83229,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION newavg(A, navg) result (newval)\n    IMPLICIT NONE\n    REAL, INTENT(IN) :: A(:)\n    REAL :: navg\n    real :: sum_of_vals\n    integer :: length, newval, i\n    \n    length = SIZE(A)\n    sum_of_vals = 0\n    do i = 1, length\n      sum_of_vals = sum_of_vals + A(i)\n    end do\n    newval = ceiling(navg * real(length + 1) - real(sum_of_vals))\n    if (newval < 0) then\n      newval = -1\n    end if\n  END FUNCTION newavg\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83230,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer function newavg(A, navg) result(res)\n    real, intent(in) :: A(:), navg\n\n    res = int( ceiling((size(A) + 1.0)*navg - sum(A)) )\n    if (res <= 0) res = -1\n  end function newavg\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83231,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  integer FUNCTION newavg(A, navg)\n    IMPLICIT NONE\n    REAL, INTENT(IN) :: A(:)\n    REAL :: navg,sum,s2\n    integer :: nd,i\n      ! your code\n      nd=size(A)\n      sum=0.0\n      do i=1,nd\n        sum=sum+A(i)\n      enddo\n      s2=(nd+1)*navg-sum\n      if(s2<0) s2=-1.0\n      newavg=ceiling(s2)   \n  END FUNCTION newavg\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83232,"user_id":168,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION newavg(A, navg) result (res)\n    IMPLICIT NONE\n    REAL, INTENT(IN) :: A(:)\n    REAL :: navg, s\n    integer :: res, i\n    s = (size(A) + 1) * navg\n    do i = 1, size(A)\n      s = s - A(i)\n    end do\n    if (s <= 0) then\n      res = -1\n    else\n      res = ceiling(s)\n    end if\n    \n  END FUNCTION newavg\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"56a32dd6e4f4748cc3000006":[{"id":83233,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\n  PRIVATE :: avg_, vari_, avg_var, search_\n  PUBLIC :: mean, variance\n\nCONTAINS\n\n    FUNCTION avg_(arr) RESULT(mean)\n        DOUBLE PRECISION, INTENT(IN), DIMENSION(12) :: arr\n        DOUBLE PRECISION :: mean\n        mean = SUM(arr) \/ SIZE(arr)\n    END FUNCTION\n\n    FUNCTION vari_(arr) RESULT(variance)\n        DOUBLE PRECISION, INTENT(IN), DIMENSION(12) :: arr\n        DOUBLE PRECISION :: variance\n        variance = avg_((arr - avg_(arr)) ** 2)\n    END FUNCTION\n\n    FUNCTION avg_var0(s, town) RESULT(res)\n        CHARACTER(len=256), INTENT(IN) :: s\n        CHARACTER(len=:), ALLOCATABLE, INTENT(IN) :: town\n        DOUBLE PRECISION, DIMENSION(2) :: res\n        CHARACTER(len=256) :: r\n        CHARACTER(len=32) :: twn\n        INTEGER :: ndx, i\n        CHARACTER(len=32), DIMENSION(24) :: a\n        DOUBLE PRECISION, DIMENSION(12) :: rain\n\n        ndx = SCAN(s, \":\")\n        twn = TRIM(s(1:ndx-1))\n        IF (twn \/= TRIM(town)) THEN\n            res = [-1.0, -1.0]\n        ELSE\n            r = s(ndx +1:)\n            read (unit=r, fmt=*) a\n            DO i = 2, 24, 2\n                read(a(i), *) rain(i \/2)\n            END DO\n            res = [avg_(rain), vari_(rain)]\n        END IF\n    END FUNCTION\n\n    FUNCTION search_(town, arr) RESULT(out)\n        CHARACTER(len=128), INTENT(IN), DIMENSION(10) :: arr\n        CHARACTER(len=:), ALLOCATABLE, INTENT(IN) :: town\n        CHARACTER(len=32) :: twn\n        CHARACTER(len=256) :: s, out\n        INTEGER :: i, ndx\n\n        DO i = 1, 10\n            s = arr(i)\n            ndx = SCAN(s, \":\")\n            twn = TRIM(s(1:ndx-1))\n            IF (twn \/= TRIM(town)) THEN\n                out = \"\"\n            ELSE\n                out = TRIM(s(ndx +1:))\n                RETURN\n            END IF\n        END DO\n\n    END FUNCTION\n\n    FUNCTION avg_var(town, arr) RESULT(res)\n        CHARACTER(len=128), INTENT(IN), DIMENSION(10) :: arr\n        CHARACTER(len=:), ALLOCATABLE, INTENT(IN) :: town\n        CHARACTER(len=256) :: s\n        DOUBLE PRECISION, DIMENSION(2) :: res\n        INTEGER :: i\n        CHARACTER(len=32), DIMENSION(24) :: a\n        DOUBLE PRECISION, DIMENSION(12) :: rain\n\n        s = search_(town, arr)\n        IF (s == \"\") THEN\n            res = [-1.0, -1.0]\n        ELSE\n            read (unit=s, fmt=*) a\n            DO i = 2, 24, 2\n                read(a(i), *) rain(i \/2)\n            END DO\n            res = [avg_(rain), vari_(rain)]\n        END IF\n    END FUNCTION\n\n    FUNCTION mean(town, arr) RESULT(res)\n        CHARACTER(len=128), INTENT(IN), DIMENSION(10) :: arr\n        CHARACTER(len=:), ALLOCATABLE, INTENT(IN) :: town\n        DOUBLE PRECISION, DIMENSION(2) :: r\n        DOUBLE PRECISION :: res\n\n        r = avg_var(town, arr)\n        res = r(1)\n    END FUNCTION\n    FUNCTION variance(town, arr) RESULT(res)\n        CHARACTER(len=128), INTENT(IN), DIMENSION(10) :: arr\n        CHARACTER(len=:), ALLOCATABLE, INTENT(IN) :: town\n        DOUBLE PRECISION, DIMENSION(2) :: r\n        DOUBLE PRECISION :: res\n\n        r = avg_var(town, arr)\n        res = r(2)\n    END FUNCTION\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"56a75b91688b49ad94000015":[{"id":83234,"user_id":564,"body":"module Solution\n  implicit none\ncontains\n  logical pure function abundantNumber(num)\n    integer, intent(in) :: num\n    integer :: sum, i\n    sum = 0\n    do i = 1, num - 1\n      if (mod(num, i) == 0) then\n        sum = sum + i\n      end if\n    end do\n    abundantNumber = sum > num\n  end function abundantNumber\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83235,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  logical pure function abundantNumber(num)\n    integer, intent(in) :: num\n    integer i,s\n    s =0\n    do i = 1,num-1,1\n      if (modulo(num,i)==0) then \n      s = s + i\n      end if\n    end do\n    abundantNumber = (s .gt. num) ! TODO\n  end function abundantNumber\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83236,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  logical pure function abundantNumber(num)\n    integer, intent(in) :: num\n    integer :: div_sum, i\n    \n    div_sum = 0\n    do i = 1,int(real(num)\/2)\n      if (mod(num,i) == 0) then\n        div_sum = div_sum + i\n      end if\n    end do\n    \n    if (div_sum > num) then\n      abundantNumber = .true.\n    else\n      abundantNumber = .false. ! TODO\n    end if\n    \n  end function abundantNumber\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83237,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  logical pure function abundantNumber(num)\n    integer, intent(in) :: num\n    integer :: divisor_sum, i\n    \n    divisor_sum = 0\n    do i = 2, num - 1\n      if (mod(num, i) == 0) divisor_sum = divisor_sum + i\n    end do\n    \n    abundantNumber = divisor_sum > num\n  end function abundantNumber\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83238,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  logical pure function abundantNumber(num)\n    integer, intent(in) :: num\n    real::a,b\n    a=0.\n    b=1.\n    do while (b<num)\n      if ((num\/b)==int(num\/b)) then \n       a=a+b\n      end if\n      b=b+1.\n    end do\n    If (a>num) then \n     abundantNumber = .true.\n    else\n     abundantNumber = .false.\n    end if \n  end function abundantNumber\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83239,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  logical pure function abundantNumber(num)\n    integer, intent(in) :: num\n    \n    integer :: sum, divisor\n    sum = 0\n    divisor = 1\n    do while (divisor < num)\n      if (mod(num, divisor) == 0) then\n        sum = sum + divisor\n      end if\n      divisor = divisor + 1\n    end do\n    \n    if (sum > num) then\n      abundantNumber = .true.\n    else\n      abundantNumber = .false. ! TODO\n    end if\n    \n  end function abundantNumber\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83240,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  logical pure function abundantNumber(num)\n    integer, intent(in) :: num\n    integer :: div, sum\n   \n    sum = 0\n    \n    do div = 1, num\/2\n      if (mod(num,div) == 0) then\n        sum = sum + div\n      end if\n    end do\n    \n    if (sum > num) then\n      abundantNumber = .true.\n    else\n      abundantNumber = .false.\n    end if\n    \n  end function abundantNumber\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83241,"user_id":null,"body":"module Solution\n    implicit none\n  contains\n    logical pure function abundantNumber(num)\n      integer, intent(in) :: num\n      integer::res,i\n      res=0\n      do i = 1, num-1\n        IF (mod(num,i)==0) then\n            res=res+i\n        end if\n      end do\n      if (res>num) then\n        abundantNumber=.true.\n      else\n        abundantNumber=.false.\n      end if\n\n    end function abundantNumber\n  end module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83242,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  logical pure function abundantNumber(num)\n    integer, intent(in) :: num\n    abundantNumber = .false. ! TODO\n    if(perfect(num)>num)abundantNumber=.true.\n  end function abundantNumber\n    integer pure function perfect(i)\n        integer,intent(in)::i\n        integer::sqrti,i1\n        sqrti=int(sqrt(real(i))+0.1)\n        perfect=1\n        do i1=2,sqrti\n            if(mod(i,i1)==0)then\n                if(i==i1*i1)then\n                    perfect=perfect+i1\n                    return\n                else\n                    perfect=perfect+i1\n                end if\n                perfect=perfect+i\/i1\n            end if\n        end do\n    end function\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83243,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  logical pure function abundantNumber(num)\n    integer, intent(in) :: num\n    integer :: divTotal, i\n    divTotal = 0\n    \n    DO i = 1, num\/2\n      IF (MODULO(num, i) .EQ. 0) divTotal = divTotal + i\n    END DO\n    \n    abundantNumber = divTotal .GT. num\n  end function abundantNumber\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"56bdd0aec5dc03d7780010a5":[{"id":83244,"user_id":53,"body":"module Solution\n  implicit none\ncontains\n  integer pure function nextHigher(n) result (res)\n    integer, intent(in) :: n\n    integer :: r, p, q\n    r = IAND(n, -n)\n    p = n + r\n    q = IEOR(n, p) \/ (4 * r)\n    res = IOR(p, q)\n  end function nextHigher\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83245,"user_id":168,"body":"module Solution\n  implicit none\ncontains\n  integer function nextHigher(n) result (res)\n    integer, intent(in) :: n\n    integer :: t, h, l\n    t = and(n, -n)\n    h = n + t\n    l = xor(n, h) \/ (4 * t)\n    res = h + l\n  end function nextHigher\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83246,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function nextHigher(n) result (res)\n    integer, intent(in) :: n\n    integer :: target\n    target = popcnt(n)\n    res = n+1\n    do while (popcnt(res) \/= target)\n      res = res + 1\n    end do\n  end function nextHigher\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83247,"user_id":645,"body":"module Solution\n  implicit none\ncontains\n  integer function nextHigher(n)\n    integer, intent(in) :: n\n    integer :: o\n    o = iand(n, -n)\n    nextHigher = ior(n + o, rshift(xor(n, n + o) \/ o, 2))\n  end function nextHigher\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"56c04261c3fcf33f2d000534":[{"id":83248,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\n  INTEGER,   PARAMETER :: r10 = selected_real_kind(p=18)\n  REAL(r10), PARAMETER :: ZER = 0.0_r10\n  REAL(r10), PARAMETER :: ONE = 1.0_r10\n  PUBLIC:: doubles\n  PRIVATE\nCONTAINS\n  PURE FUNCTION V(k,n)\n    INTEGER, INTENT(IN) :: k,n\n    REAL(r10):: V\n    REAL(r10):: M\n    INTEGER:: I, P\n    !\n    P = -2 * k\n    V = ZER\n    M = ONE\n    DO I=1, n\n            M = M + ONE\n            V = V + M**P\n    END DO\n    !\n    V = V \/ REAL(k, r10)\n    !\n  END FUNCTION\n  !\n  PURE FUNCTION doubles(maxk, maxn) RESULT(S)\n    INTEGER, INTENT(IN) :: maxk, maxn\n    REAL(r10):: S\n    INTEGER :: k\n    !\n    S = ZER\n    DO k = 1, maxk\n                  S = S + V(k,maxn) \n    END DO\n  END FUNCTION doubles\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83249,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION doubles(maxk, maxn) RESULT(sum)\n    INTEGER, INTENT(IN) :: maxk, maxn\n    INTEGER :: k, n\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind):: sum, nn, kk\n    \n    sum = 0.0_ikind;\n    DO k = 1, maxk\n      DO n = 1, maxn\n        nn = REAL(n, ikind)\n        kk = REAL(k, ikind)\n        sum = sum + 1.0 \/ (kk * ((nn + 1.0) ** (2.0 * kk)))\n      END DO\n    END DO\n    \n  END FUNCTION doubles\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83250,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION doubles(maxk, maxn) RESULT(sum)\n    INTEGER, INTENT(IN) :: maxk, maxn\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(ikind) :: sum, k, n, o\n    \n    sum = 0\n    k = 1\n    o = 1\n    \n    do while (k <= maxk)   \n      n = 1\n      do while (n <= maxn)   \n        sum = sum + (o \/ (k * (n + 1) ** (2 * k)))\n        n = n + 1\n      end do\n      k = k + 1\n    end do\n    \n  END FUNCTION doubles\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83251,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION doubles(maxk, maxn)\n    INTEGER, INTENT(IN) :: maxk, maxn\n    integer(kind=selected_int_kind(30)) :: k, n, tmp\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    real(ikind) :: doubles\n    \n    doubles = 0.0_ikind\n    \n    do n=1,maxn\n      do k=1,maxk\n        tmp = k*((n+1)**(2*k))\n        if (tmp <= 1e16_ikind) then\n          doubles = doubles + 1.0_ikind\/tmp\n        else\n          exit\n        end if\n      end do\n    end do\n    \n    \n    ! your code\n  END FUNCTION doubles\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83252,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION doubles(maxk, maxn) result(v)\n    INTEGER, INTENT(IN) :: maxk, maxn\n    INTEGER :: k, n\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind):: v\n    v=0.0_ikind\n    do k=1,maxk\n       do n=1,maxn\n          v=v+1.0_ikind\/(k*(n+1.0_ikind)**(2*k))\n       enddo\n    enddo\n  END FUNCTION doubles\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83253,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION doubles(maxk, maxn) \n    INTEGER, INTENT(IN) :: maxk, maxn\n    INTEGER :: k, n\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind):: v,doubles\n    v=0.0_ikind\n    do k=1,maxk\n       do n=1,maxn\n          v=v+1.0_ikind\/(k*(n+1.0_ikind)**(2*k))\n       enddo\n    enddo\n    doubles=v\n  END FUNCTION doubles\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83254,"user_id":168,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION doubles(maxk, maxn)\n    INTEGER, INTENT(IN) :: maxk, maxn\n    INTEGER :: k, n\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    real(10) :: doubles\n    doubles = 0\n    do k = 1, maxk\n      do n = 1, maxn\n        doubles = doubles + 1.0_10 \/ (k * (n + 1.0_10) ** (2.0_10 * k))\n      end do\n    end do\n    ! your code\n  END FUNCTION doubles\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83255,"user_id":null,"body":"MODULE Solution\n  implicit none\nCONTAINS\n   REAL(kind=selected_real_kind(p=18)) FUNCTION doubles(maxk, maxn)\n    INTEGER, INTENT(IN) :: maxk, maxn\n    INTEGER :: k, n\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind) ::  sum, twok, nplus1\n    \n    sum = 0\n    do k = 1, maxk\n      twok = 2.0*k\n      do n = 1, maxn\n         nplus1 = n + 1.0\n         sum = sum + ((nplus1)**(-twok))\/k\n      end do\n    end do\n    doubles = sum\n  END FUNCTION doubles\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83256,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION doubles(maxk, maxn)\n    INTEGER, INTENT(IN) :: maxk, maxn\n    INTEGER :: k, n\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    real(ikind) :: doubles\n    real(ikind) :: doubles_col\n    real(ikind) :: a\n    doubles = 0.d0\n    doubles_col = 0.d0\n    do n = 1, maxn\n      a = (1.d0\/(n + 1.d0))**2\n      doubles_col = 1.d0\/maxk\n      if (maxk \/= 1) then\n        do k = maxk, 2, -1\n          doubles_col = doubles_col*a + 1.d0\/(k-1.d0)\n        end do\n      end if\n      doubles = doubles + doubles_col*a\n    end do\n    ! your code\n  END FUNCTION doubles\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83257,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION doubles(maxk, maxn)\n    INTEGER, INTENT(IN) :: maxk, maxn\n    INTEGER :: k, n\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    REAL(kind=ikind) :: doubles, rk, rn\n    \n    doubles = 0.d0   \n    DO k = 1, maxK\n      rk = real(k)\n      DO n = 1, maxn   \n        rn = real(n)      \n        doubles = doubles + ( 1.d0 \/ ( rk * (rn + 1.d0)**(2.d0*rk) ) )    \n      END DO\n    END DO\n    \n    return \n  END FUNCTION doubles\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"56c5847f27be2c3db20009c3":[{"id":83258,"user_id":645,"body":"module Solution\n  implicit none\ncontains\n  pure function subtractSum(n)\n    character(:), allocatable :: subtractSum\n    integer, intent(in) :: n\n    subtractSum = \"apple\"\n  end function\nend module","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83259,"user_id":76,"body":"module Solution\n  implicit none\ncontains\n  pure function subtractSum(n) result (res)\n    character(:), allocatable :: res\n    integer, intent(in) :: n\n    res = \"apple\"\n  end function\nend module","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83260,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function subtractSum(n) result (res)\n    character(:), allocatable :: res\n    integer, intent(in) :: n\n    integer :: number,sum,digit\n    number=n\n    sum=0\n    do while (number .ne. 0)\n        digit=mod(number,10)\n        number=number\/10\n        sum=sum+digit\n    end do\n    number=n-sum\n    select case (number)\n    case (24,26,47,49,68,70,91,93)\n      res=\"kiwi\"\n    case (21,23,42,44,46,65,67,69,88)\n      res=\"pear\"\n    case (25,29,48,50,71,73,92,94,96)\n      res=\"banana\"\n    case (11,13,34,55,57,59,78,80)\n      res=\"cucumber\"\n    case (15,17,19,38,40,61,82,84,86)\n      res=\"grape\"\n    case (20,22,41,43,62,64,66,85,87,89)\n      res=\"cherry\"\n    case (28,30,32,51,53,74,76,95,97)\n      res=\"melon\"\n    case (14,16,35,37,39,58,60,83)\n      res=\"orange\"\n    case (10,12,31,33,52,56,75,77,79,98,100)\n      res=\"pineapple\"\n    case default\n      res=\"apple\"\n    end select\n  end function\nend module","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83261,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function subtractSum(n) result (res)\n    character(:), allocatable :: res\n    integer, intent(in) :: n\n    res = \"apple\" ! fruit name like \"apple\"\n  end function\nend module","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"56e7d40129035aed6c000632":[{"id":83262,"user_id":53,"body":"MODULE Solution\n\n  IMPLICIT NONE\n  PUBLIC :: easyLine\n  \nCONTAINS\n\n  FUNCTION easyLine(n) RESULT(res)\n    Integer :: res\n    INTEGER :: n, i\n    DOUBLE PRECISION :: ans\n    ans = 1.0\n    i = 1\n    do while (i <= n)\n      ans = ans * (n + i) \/ i\n      i = i + 1\n    end do\n    res = nint(log(ans))\n\n  END FUNCTION\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83263,"user_id":null,"body":"! In Fortan return NINT(LOG.... See Note in description.\nMODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  FUNCTION easyLine(n) RESULT(res)\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=18)\n    INTEGER :: n,i,k,l\n    REAL(kind=ikind) :: res,real_res,numerator,denumerator\n    real_res=0.0_ikind\n    DO k = 0,(n-1)\/2\n        numerator=1.0_ikind\n        l=1\n        denumerator=1.0_ikind\n        DO i = n-k+1,n\n            numerator=numerator*i\n            denumerator=denumerator*l\n            l=l+1\n        END DO\n        real_res=real_res+2*(numerator\/denumerator)**2\n    END DO\n    IF (mod(n,2) .eq. 0) THEN\n        numerator=1.0_ikind\n        l=1\n        denumerator=1.0_ikind\n        DO i = n\/2+1,n\n            numerator=numerator*i\n            denumerator=denumerator*l\n            l=l+1\n        END DO\n        real_res=real_res+(numerator\/denumerator)**2\n    END IF\n    res=nint(log(real_res))\n  END FUNCTION easyLine\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83264,"user_id":null,"body":"! In Fortan return NINT(LOG.... See Note in description.\nMODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  FUNCTION easyLine(n) RESULT(res)\n    Integer :: res\n    INTEGER :: n\n    real(8) :: sum1\n    integer :: i\n    sum1=0.d0\n    do i=1,n\n      sum1=sum1+(log(real(n+i,8))-log(real(i,8)))\n    end do\n    res=nint(sum1)     \n  END FUNCTION easyLine\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83265,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\n  INTEGER, PARAMETER :: long = SELECTED_REAL_KIND(p=8)\nCONTAINS\n\n  FUNCTION chooseVY(n, k) RESULT(res)\n    REAL(long) :: res\n    INTEGER :: n, k, i\n\n    IF (k > n -k) THEN\n      k = n - k\n    END IF\n    res = 1.0_long\n    DO i = 0, k - 1\n      res = res * REAL(n - i, long)\n      res = res \/ REAL(i + 1, long)\n    END DO\n  END FUNCTION chooseVY\n\n  FUNCTION easyLine(n) RESULT(res)\n    INTEGER :: n\n    INTEGER :: res\n\n    res = NINT(LOG(chooseVY(2 * n, n)))\n  END FUNCTION easyLine\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"56fcc393c5957c666900024d":[{"id":83266,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function code(input) result(output)\n    character(*), intent(in) :: input\n    character(:), allocatable :: output, s\n    integer :: l, n, i, j\n    output = \"\"\n    s = \"\"\n    l = len(input)\n    n = int(ceiling(sqrt(real(l))))\n    \n    do i = 1, l\n      s = s \/\/ input(i:i)\n    end do\n    do i = l+1, n*n\n      s = s \/\/ char(11)\n    end do\n    \n    do i = 1, n\n      do j = n-1, 0, -1\n        output = output \/\/ s(n*j+i:n*j+i)\n      end do\n      output = output \/\/ char(10)\n    end do\n    \n    output = output(1:len(output)-1) ! Remove last char(10)\n  end function code\n  \n  pure function decode(input) result(output)\n    character(*), intent(in) :: input\n    character(:), allocatable :: output, s, s2\n    integer :: n, i, j\n    output = \"\"\n    s = \"\"\n    s2 = \"\"\n    \n    do i = 1, len(input)\n      if (input(i:i) .ne. char(10)) s = s \/\/ input(i:i)\n    end do\n    \n    n = int(sqrt(real(len(s))))\n    do i = n, 1, -1\n      do j = 0, n-1\n        s2 = s2 \/\/ s(n*j+i:n*j+i)\n      end do\n    end do\n    \n    do i = 1, len(s2)\n      if (s2(i:i) .ne. char(11)) output = output \/\/ s2(i:i)\n    end do\n  end function decode\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83267,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  function code(s) result(output)\n    character(*), intent(in) :: s\n    character(:), allocatable :: output\n    character :: tmp\n    integer, dimension(:), allocatable :: arr, outarr\n    integer, dimension(:,:), allocatable :: arr2d, rotarr\n    integer :: l, n, i,j\n    l = len(s)\n    n = ceiling(sqrt(real(l)))\n    output = s\n    do i = l+1, n*n\n      output = output \/\/ achar(11)\n    end do\n    allocate(arr(n*n))\n    do i=1, n*n\n      arr(i:i) = ichar(output(i:i))\n    end do\n    arr2d = reshape(arr, (\/n, n\/))\n    rotarr = arr2d\n    ! probably a faster way to do this\n    do j = 1,n\n      do i = 1, n\n        rotarr(j,n-i+1) = arr2d(i,j)  \n      end do\n    end do\n    !outarr = reshape(rotarr, (\/n*n\/))\n    output = \"\" ! TODO\n    do j = n,1,-1\n      do i = n, 1, -1\n        output = output \/\/ achar(rotarr(i,j))\n      end do\n      output = output \/\/ char(10)\n    end do\n    output = output(1:len(output)-1)\n  end function code\n  function decode(s) result(output)\n    character(*), intent(in) :: s\n    character(:), allocatable :: output\n    character :: tmp\n    integer, dimension(:), allocatable :: arr\n    integer, dimension(:,:), allocatable :: arr2d, rotarr\n    integer :: i, ii, j, n, l\n    ! Get size of square by computing original length + padding\n    ! Need to remove newlines\n    l = 0\n    do i=1,len(s)\n      if ( s(i:i) .ne. char(10) ) l = l + 1\n    end do\n    !l = len(s) - count( s .eq. char(10))\n    n = ceiling(sqrt(real(l)))\n    ! convert to array\n    allocate(arr(n*n))\n    do i=0, n-1\n      ii = i*(n+1)\n      do j=1, n\n        arr(i*n+j:i*n+j) = ichar(s(ii+j:ii+j))\n      end do\n    end do\n    arr2d = reshape(arr, (\/n, n\/))\n    rotarr = arr2d\n    ! Apply rotation\n    ! probably a faster way to do this\n    do j = 1,n\n      do i = 1, n\n        rotarr(n-j+1,i) = arr2d(i,j)  \n      end do\n    end do   \n    ! Stuff back into string, probably a faster method\n    ! Somewhere I'm doing this backwards...\n    output = \"\" ! TODO\n    do j = n,1,-1\n      do i = n,1,-1\n        if (rotarr(i,j) .ne. 11) output = output \/\/ achar(rotarr(i,j))\n      end do\n    end do\n  end function decode\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83268,"user_id":17,"body":"module Solution\n  implicit none\ncontains\n  pure function code(s) result(output)\n    character(*), intent(in) :: s\n    character(:), allocatable :: output\n    integer :: i, j, l, idx\n    output = \"\"\n    if (len(s) > 0) then\n      l = ceiling(sqrt(real(len(s))))\n      do i = 1, l\n        if (i > 1) then\n          output = output \/\/ char(10)\n        end if\n        do j = 1, l\n          idx = l * (l - j) + i\n          if (idx <= len(s)) then\n            output = output \/\/ s(idx:idx)\n          else\n            output = output \/\/ char(11)\n          end if\n        end do\n      end do\n    end if\n  end function code\n  pure function decode(s) result(output)\n    character(*), intent(in) :: s\n    character(:), allocatable :: output\n    integer :: l, i, j, idx\n    output = \"\"\n    if (len(s) > 0) then\n      l = floor(sqrt(real(len(s))))\n      do i = 1, l\n        do j = 1, l\n          idx = (l + 1) * j - i\n          if (s(idx:idx) \/= char(11)) then\n            output = output \/\/ s(idx:idx)\n          end if\n        end do\n      end do\n    end if\n  end function decode\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"56fe17fcc25bf3e19a000292":[{"id":83269,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION u1(n, p) RESULT(res)\n    INTEGER :: n, p\n    res = (n+1)*p\n  END FUNCTION u1\n  \n  INTEGER FUNCTION v1(n, p) RESULT(res)\n    INTEGER :: n, p\n    res = (2*n+1)*p\n  END FUNCTION v1\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83270,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION u1(n, p) RESULT(m)\n    INTEGER :: n, p\n    m = (n + 1) * p\n  END FUNCTION u1\n  \n  INTEGER FUNCTION v1(n, p) RESULT(m)\n    INTEGER :: n, p\n    m = (2 * n + 1) * p\n  END FUNCTION v1\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83271,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION u1(n, p)\n    INTEGER :: n, p\n    u1 = (1+n)*p\n  END FUNCTION u1\n  \n  INTEGER FUNCTION v1(n, p)\n    INTEGER :: n, p\n    v1 = (1+2*n)*p\n  END FUNCTION v1\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83272,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION u1(n, p)\n    INTEGER :: n, p\n       u1 = uv(n, p, 1)\n  END FUNCTION u1\n  \n  INTEGER FUNCTION v1(n, p)\n    INTEGER :: n, p\n       v1 = uv(n, p, 0)\n  END FUNCTION v1\n    \n  INTEGER FUNCTION uv(n, p, di)\n    INTEGER :: k, nn, n, p, di\n    integer(16) sum\n    sum = 0\n    do k = 0, n\n      nn = 2*n - k + di\n      sum = sum + (-1)**k * p * 4**(n-k) * nCr(nn, k)\n    enddo\n    uv = sum\n  END FUNCTION uv\n  \n  FUNCTION nCr(n, r) \n    INTEGER, INTENT(IN) :: n, r\n    INTEGER(16) :: nCr, i\n    nCr = 1\n    do i = 0, r-1\n      nCr = nCr * (n - i) \/ (i + 1)\n    end do\n  END FUNCTION nCr\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83273,"user_id":null,"body":"module solution\n  implicit none\ncontains\n  ! Slow binomial just for checking\n  integer function nCk(n,k) result(ans)\n    integer :: n, k, tmp\n    integer :: i\n    ans = 1\n    tmp = 1\n    if (n > k) then\n      do i = 0, k-1\n        ans = ans * (n-i)\n      end do\n      do i = 1, k\n        tmp = tmp * i\n      end do\n      ans = ans\/tmp\n     end if\n  end function nCk\n  \n  integer function u1(n, p)\n    integer :: n, p, k\n    !write (*,*) 2,1, nCk(2,1)\n    !write (*,*) 2,2, nCk(2,2)\n    !write (*,*) 3,2, nCk(3,2)\n    !write (*,*) 4,2, nCk(4,2)\n    ! Do it the slow way just to check\n    !u1 = 0\n    !do k = 0, n+1\n    !  u1 = u1 + p * 4**(n-k) * (-1)**k * nCk(2*n-k+1,k) \n    !  write (*,*) u1\n    !end do\n    u1 = (n+1) * p\n  end function u1\n  \n  integer function v1(n, p)\n    integer :: n, p\n    v1 = (2*n+1)*p\n  end function v1\nend module solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5726f813c8dcebf5ed000a6b":[{"id":83274,"user_id":53,"body":"module Solution\n  implicit none\n  integer, parameter :: i64 = selected_int_kind(12)\n  public :: Count_Kprimes, puzzle\n  private :: pfc\n  \ncontains\n\n  INTEGER function pfc(m) result(c)\n    integer(i64), intent(in) :: m\n    integer(i64) :: i, n\n    c = 0\n    i = 2\n    n = m\n    do while (i <= n \/ i)\n      do while (mod(n, i) == 0)\n        c = c + 1\n        n = n \/ i\n      end do\n      i = i + 1\n    end do\n    if (n > 1) then\n      c = c + 1\n    end if\n  end function\n\n  subroutine Count_Kprimes(k, start, nd, res)\n    integer(i64), intent(in) :: start, nd\n    integer, intent(in) :: k\n    integer(i64), intent(inout), allocatable, dimension(:) :: res\n    integer(i64) :: n, j\n    ALLOCATE(res(0))\n    n = start\n    do while (n <= nd)\n      j = pfc(n)\n      if (j == k) then\n        res = [res, n]\n      end if\n      n = n + 1\n    end do\n  end subroutine\n\n  INTEGER function puzzle(s) result(c)\n    integer(8), intent(in) :: s\n    integer(i64), allocatable, dimension(:) :: xs, ys\n    integer :: i, j\n    c = 0\n    call Count_Kprimes(7_4, 128_8, s - 2, xs)\n    call Count_Kprimes(3_4, 4_8, s - 2, ys)\n    do i = 1, size(xs)\n      do j = 1, size(ys)\n        if (s - xs(i) - ys(j) > 0 .and. pfc(s - xs(i) - ys(j)) == 1) then\n          c = c + 1\n        end if\n      end do\n    end do\n  end function\n\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83275,"user_id":492,"body":"module Solution\n  implicit none\n  integer, parameter :: i64 = selected_int_kind(12)\n  private :: nb_divisors\n  public :: Count_Kprimes, puzzle\n  \ncontains\n\n  subroutine nb_divisors(n, cnt)\n    integer(i64), intent(in) :: n\n    integer, intent(out) :: cnt\n    integer(i64) :: divisor, next, num\n\n    cnt = 0\n    if (n == 0) then\n      cnt = 0\n    else\n      divisor = 2; next = 3; num = n\n      do while ( num \/= 1 )\n        do while ( mod(num, divisor) == 0 )\n          num = num \/ divisor\n          cnt = cnt + 1\n        end do\n        divisor = next\n        next = next + 2\n      end do\n    end if\n  end subroutine nb_divisors\n\n  subroutine Count_Kprimes(k, start, nd, res)\n    integer(i64), intent(in) :: start, nd\n    integer, intent(in) :: k\n    integer(i64), dimension(1500) :: temp\n    integer :: i, d\n    integer(i64) :: st\n    integer(i64), allocatable, dimension(:) :: res\n\n    i = 1\n    st = start\n    do while (st <= nd)\n      call nb_divisors(st, d)\n      if (d == k) then\n        temp(i) = st\n        i = i + 1\n      end if\n      st = st + 1\n    end do\n    i = i - 1\n    if (i > 0) then\n      allocate(res(i))\n      res = temp(1:i)\n    else\n      res = [integer(i64)::]\n    end if\n  end subroutine\n\n  INTEGER function puzzle(s) result(c)\n    integer(8), intent(in) :: s\n    integer :: i, j, k\n    integer(8) :: som\n    integer(i64), allocatable, dimension(:) :: as, bs, cs\n\n    call Count_Kprimes(1, 2_8, s, as)\n    call Count_Kprimes(3, 8_8, s, bs)\n    call Count_Kprimes(7, 128_8, s, cs)\n    i = 1; c = 0\n    do while (i <= size(as))\n        j = 1\n        do while (j <= size(bs))\n            k = 1\n            do while (k <= size(cs))\n                som = as(i) + bs(j) + cs(k)\n                if (som == s) THEN\n                    c = c + 1\n                end if\n                k = k + 1\n            end do\n            j = j + 1\n        end do\n        i = i + 1\n    end do\n    deallocate(as)\n    deallocate(bs)\n    deallocate(cs)\n  end function\n\nend module Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"57591ef494aba64d14000526":[{"id":83276,"user_id":492,"body":"! Fortran: with array from 0 to n-1\n\nMODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  SUBROUTINE john_ann(n, a, j, sum_a, sum_j) \n    INTEGER, INTENT(IN) :: n\n    INTEGER, INTENT(OUT) :: sum_a, sum_j\n    INTEGER, DIMENSION(0:n-1), INTENT(OUT) :: j, a\n    INTEGER :: i\n    \n    sum_a = 1; sum_j = 0;\n    j(0) = 0\n    a(0) = 1\n    DO i = 0, n - 2\n      j(i + 1) = i + 1 - a(j(i))\n      a(i + 1) = i + 1 - j(a(i))\n      sum_j = sum_j + j(i + 1)\n      sum_a = sum_a + a(i + 1)\n    END DO\n  END SUBROUTINE john_ann\n  \n  FUNCTION ann(n) RESULT(a)\n    INTEGER, intent(in) :: n\n    INTEGER :: sum_a, sum_j\n    INTEGER, DIMENSION(0:n-1) :: j, a\n    CALL john_ann(n, a, j, sum_a, sum_j)\n  END FUNCTION ann\n  \n  FUNCTION john(n) RESULT(j)\n    INTEGER, intent(in) :: n\n    INTEGER :: sum_a, sum_j\n    INTEGER, DIMENSION(0:n-1) :: j, a\n    CALL john_ann(n, a, j, sum_a, sum_j)\n  END FUNCTION john\n \n  FUNCTION sum_ann(n) RESULT(sum_a)\n    INTEGER, intent(in) :: n\n    INTEGER :: sum_a, sum_j\n    INTEGER, DIMENSION(0:n-1) :: j, a\n    CALL john_ann(n, a, j, sum_a, sum_j)\n  END FUNCTION sum_ann\n  \n  FUNCTION sum_john(n) RESULT(sum_j)\n    INTEGER, intent(in) :: n\n    INTEGER :: sum_a, sum_j\n    INTEGER, DIMENSION(0:n-1) :: j, a\n    CALL john_ann(n, a, j, sum_a, sum_j)\n  END FUNCTION sum_john\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83277,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  \n  FUNCTION ann(n) result(ys)\n    integer, intent(in) :: n\n    integer, dimension(0:n-1) :: xs, ys\n    integer x1, x2, y1, y2, i\n    xs(0) = 0\n    ys(0) = 1\n    do i = 1, n - 1\n      x1 = xs(i - 1)\n      x2 = ys(x1)\n      xs(i)= i - x2\n      y1 = ys(i - 1)\n      y2 = xs(y1)\n      ys(i) = i - y2\n    end do   \n  END FUNCTION ann\n  \n  FUNCTION john(n) result(xs)\n    integer, intent(in) :: n\n    integer, dimension(0:n-1) :: xs, ys\n    integer x1, x2, y1, y2, i\n    xs(0) = 0\n    ys(0) = 1\n    do i = 1, n - 1\n      x1 = xs(i - 1)\n      x2 = ys(x1)\n      xs(i)= i - x2\n      y1 = ys(i - 1)\n      y2 = xs(y1)\n      ys(i) = i - y2\n    end do   \n  END FUNCTION john\n \n  FUNCTION sum_ann(n) result(m)\n    integer, intent(in) :: n\n    integer fs(n), m\n    fs = ann(n)\n    m = SUM(fs)\n  END FUNCTION sum_ann\n  \n  FUNCTION sum_john(n) result(m)\n    integer, intent(in) :: n\n    integer fs(n), m\n    fs = john(n)\n    m = SUM(fs)\n  END FUNCTION sum_john\n  \nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83278,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  \n  INTEGER FUNCTION johann(n, johnOrAnn)\n    INTEGER, INTENT(IN) :: n\n    LOGICAL, INTENT(IN) :: johnOrAnn ! john is T, ann is F\n    INTEGER :: john(n), ann(n)\n    INTEGER :: i, jTotal, aTotal\n    john(1) = 0\n    ann(1) = 1\n    jTotal = 0\n    aTotal = 1\n    \n    DO i = 2, n\n      john(i) = i-1 - ann(john(i-1)+1)\n      ann(i) = i-1 - john(ann(i-1)+1)\n      \n      jTotal = jTotal + john(i)\n      aTotal = aTotal + ann(i)\n    END DO\n    \n    IF (johnOrAnn) THEN\n      johann = jTotal\n    ELSE\n      johann = aTotal\n    ENDIF\n  END FUNCTION johann\n \n  INTEGER FUNCTION sum_ann(n)\n    INTEGER, INTENT(IN) :: n\n    \n    sum_ann = johann(n, .FALSE.)\n  END FUNCTION sum_ann\n  \n  INTEGER FUNCTION sum_john(n)\n    INTEGER, INTENT(IN) :: n\n    \n    sum_john = johann(n, .TRUE.)\n  END FUNCTION sum_john\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83279,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION ann(n)  Result(arr)\n  integer, intent(in) :: n\n  integer, DIMENSION(0:n-1) :: a, j, arr(0:n+1)\n  integer  k, asum, jsum\n  character(1) LF\n    LF = char(10)\n    a(0) = 1;   j(0) = 0\n    a(1) = 1;   j(1) = 0\n    asum = 2;   jsum = 0\n    do k=2, n-1\n      a(k) = k - j(a(k-1))\n      j(k) = k - a(j(k-1))\n      asum = asum + a(k)\n      jsum = jsum + j(k)\n    end do\n !   write(*,\"(A,3(I7))\") \"ANN----------------------\"&\n !                         \/\/LF\/\/\"n = \", n, asum, jsum\n !   write(*,\"(A,5(I7))\") \"a = \"\/\/LF, a\n !   write(*,\"(A,5(I7))\") \"j = \"\/\/LF, j\n    \n    arr = a;   arr(n) = asum;  arr(n+1) = jsum\n  END FUNCTION ann\n  \n  FUNCTION john(n)  Result(arr)\n  integer, intent(in) :: n\n  integer, DIMENSION(0:n-1) :: a, j, arr\n  integer  k, asum, jsum\n  character(1) LF\n    LF = char(10)\n    a(0) = 1;   a(1) = 1\n    j(0) = 0;   j(1) = 0\n    asum = 2;   jsum = 0\n    do k=2, n-1\n      a(k) = k - j(a(k-1))\n      j(k) = k - a(j(k-1))\n      asum = asum + a(k)\n      jsum = jsum + j(k)\n    end do\n !   write(*,\"(A,3(I7))\") \"JOHN---------------------\"&\n !                         \/\/LF\/\/\"n = \", n, asum, jsum\n !   write(*,\"(A,5(I7))\") \"a = \"\/\/LF, a\n !   write(*,\"(A,5(I7))\") \"j = \"\/\/LF, j\n    \n    arr = j;   arr(n) = asum;  arr(n+1) = jsum\n  END FUNCTION john\n \n  integer FUNCTION sum_ann(n)\n  integer, intent(in) :: n\n  integer, DIMENSION(0:n+1) :: x\n  x = Ann(n)\n  sum_ann = x(n);    ! Print *, \"Asum = \", sum_ann\n  END FUNCTION sum_ann\n  \n  integer FUNCTION sum_john(n)\n  integer, intent(in) :: n\n  integer, DIMENSION(0:n+1) :: x\n  x = John(n)\n  sum_john = x(n+1); ! Print *, \"Jsum = \", sum_john\n  END FUNCTION sum_john\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83280,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  \n  FUNCTION fib1(n) result(res)\n    integer, allocatable :: res(:)\n    integer n, a, b, c, i\n    allocate(res(45))\n    res(1) = 1; res(2) = 2\n    a = 1; b = 2; i = 2\n    do while (c<n)\n      c = a+b\n      i = i+1\n      res(i) = c\n      a = b; b = c\n    end do\n    res = res(:i)\n  END FUNCTION fib1\n  \n  FUNCTION ann(n)\n    integer, allocatable :: fib(:)\n    integer n, i, t, a\n    integer ann(n)\n    fib = fib1(n)\n    ann(1) = 1\n    if (n>1) ann(2) = 1\n    do i = 2, n-1\n      t = ann(i)+1\n      a = i-ann(t)\n      if (any(fib==t)) a = a+1 \n      ann(i+1) = a\n    end do\n  END FUNCTION ann\n  \n  FUNCTION john(n) \n    integer, allocatable :: fib(:)\n    integer n, i, t, a\n    integer john(n)\n    fib = fib1(n)\n    john(1) = 0\n    do i = 1, n-1\n      t = john(i)+1\n      a = i-john(t)\n      if (any(fib==t)) a = a-1 \n      john(i+1) = a\n    end do\n  END FUNCTION john\n \n  FUNCTION sum_ann(n)\n    integer n, sum_ann\n    sum_ann = sum(ann(n))\n  END FUNCTION sum_ann\n  \n  FUNCTION sum_john(n)\n    integer n, sum_john\n    sum_john = sum(john(n))\n  END FUNCTION sum_john\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5772382d509c65de7e000982":[{"id":83281,"user_id":53,"body":"module Solution\n  implicit none\ncontains\n\n  pure function sequence(n) result(seq)\n    integer, intent(in) :: n\n    integer :: i\n    integer, allocatable, dimension(:) :: seq\n    i = 4\n    allocate(seq(n + 1))\n    seq(1) = 0\n    seq(2) = 1\n    seq(3) = 1\n    do while (i - 1 <= n)\n      seq(i) = seq(i - seq(i - 1)) + seq(i - seq(i - 2))\n      i = i + 1\n    end do\n  end function sequence\n  \n  pure function lengthSupUK(n, k) result(numTerms)\n    integer, intent(in) :: n, k\n    integer :: sz, i\n    integer, allocatable, dimension(:) :: seq\n    integer :: numTerms\n    seq = sequence(n)\n    sz = size(seq)\n    i = 1\n    numTerms = 0\n    do while (i - 1 <= n)\n      if (seq(i) >= k) then\n        numTerms = numTerms + 1\n      end if\n      i = i + 1\n    end do\n  end function lengthSupUK\n  \n  pure function comp(n) result(numTimes)\n    integer, intent(in) :: n\n    integer :: sz, i\n    integer, allocatable, dimension(:) :: seq\n    integer :: numTimes\n    seq = sequence(n)\n    sz = size(seq)\n    i = 2\n    numTimes = 0\n    do while (i - 1 <= n)\n      if (seq(i) < seq(i - 1)) then\n        numTimes = numTimes + 1\n      end if\n      i = i + 1\n    end do\n  end function comp\n  \nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83282,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function lengthSupUK(n, k) result(numTerms)\n    integer, intent(in) :: n, k\n    integer :: i\n    integer :: u(n)\n    numTerms = 0 ! TODO\n    \n    u(1:2) = 1    \n    \n    do i = 3,n\n      u(i) = u(i-u(i-1))+u(i-u(i-2))\n      if (u(i) >= k) then\n        numTerms=numTerms+1\n      end if\n    end do\n    \n  end function lengthSupUK\n  \n  \n  integer pure function comp(n) result(numTimes)\n    integer, intent(in) :: n\n    integer :: i\n    integer :: u(n)\n    numTimes = 0 ! TODO\n    \n    u(1:2) = 1    \n    \n    do i = 3,n\n      u(i) = u(i-u(i-1))+u(i-u(i-2))\n      if (u(i) < u(i-1)) then\n        numTimes=numTimes+1\n      end if\n    end do\n    \n  end function comp\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83283,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function uList(n) result(list)\n    integer, intent(in) :: n\n    integer :: list(n)\n    integer :: i\n    list(1) = 1\n    list(2) = 1\n    \n    do i = 3, n\n      list(i) = list(i - list(i-1)) + list(i - list(i-2))\n    end do\n  end function uList\n  pure function lengthSupUK(n, k) result(numTerms)\n    integer, intent(in) :: n, k\n    integer :: numTerms, i\n    integer :: list(n)\n    numTerms = 0\n    list = uList(n)\n    \n    do i = 1, n\n      if (list(i) .ge. k) numTerms = numTerms + 1\n    end do\n  end function lengthSupUK\n  pure function comp(n) result(numTimes)\n    integer, intent(in) :: n\n    integer :: numTimes, i\n    integer :: list(n)\n    numTimes = 0\n    list = uList(n)\n    \n    do i = 1, n-1\n      if (list(i+1) .lt. list(i)) numTimes = numTimes + 1\n    end do\n  end function comp\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83284,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function lengthSupUK(n, k) result(numTerms)\n    integer, intent(in) :: n, k\n    integer :: numTerms, i\n    Integer :: lista(1:n)\n    \n    lista(1) = 1  ;  lista(2) = 1\n    numTerms = 0\n    \n    Do i = 3, n\n          lista(i) = lista(i - lista(i-1)) + lista(i - lista(i-2))\n          If (lista(i) >= k) numTerms = numTerms + 1\n    End Do\n    \n  end function lengthSupUK\n  \n  \n  pure function comp(n) result(numTimes)\n    integer, intent(in) :: n\n    integer :: numTimes, i\n    Integer :: lista(1:n)\n\n    lista(1) = 1  ;  lista(2) = 1\n    numTimes = 0\n    \n    Do i = 3, n\n          lista(i) = lista(i - lista(i-1)) + lista(i - lista(i-2))\n          If (lista(i) < lista(i-1)) numTimes = numTimes + 1\n    End Do\n    \n  end function comp\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83285,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  function lengthSupUK(nn, k) result(numTerms)\n    integer, intent(in) :: nn, k ! k > 2 for all tests\n    integer :: cnt, n, numTerms\n    integer :: u(1:nn)\n    u(1) = 1;  u(2) = 1;   cnt = 0\n    do n=3, nn\n      u(n) = u(n-u(n-1)) + u(n-u(n-2))\n      if (k > 0) then\n        if (u(n) >= k)     cnt = cnt + 1\n      else\n        if (u(n) < u(n-1)) cnt = cnt + 1\n      endif\n    enddo\n    numTerms = cnt; ! print *, nn, k, cnt\n  end function lengthSupUK\n  \n  function comp(n) result(numTimes)\n    integer, intent(in) :: n\n    integer :: numTimes\n    numTimes = lengthSupUK(n, 0) ! i.e. k = 0 for above\n  end function comp\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83286,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  \n  pure function u(n)\n    integer, intent(in) :: n\n    integer u(n), a, b, c, i\n    u(1) = 1; a = 1\n    u(2) = 1; b = 1\n    do i = 3, n\n      c = u(i-b)+u(i-a)\n      a = b; b = c \n      u(i) = c\n    end do    \n  end function u\n  \n  pure function lengthSupUK(n, k) result(numTerms)\n    integer numTerms  \n    integer, intent(in) :: n, k\n    numTerms = count(u(n)>=k)\n  end function lengthSupUK\n  \n  pure function comp(n) result(numTimes)\n    integer, intent(in) :: n\n    integer v(n), i, numTimes\n    numTimes = 0\n    v = u(n)\n    do i = 2, n\n      if (v(i)<v(i-1)) numTimes = numTimes+1\n    end do\n  end function comp\n  \nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83287,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  \n  pure function u(n)\n    integer, intent(in) :: n\n    integer u(n), a, b, c, i\n    u(1) = 1; a = 1\n    u(2) = 1; b = 1\n    do i = 3, n\n      c = u(i-b)+u(i-a)\n      a = b; b = c \n      u(i) = c\n    end do    \n  end function u\n  \n  pure function lengthSupUK(n, k) result(numTerms)\n    integer, intent(in) :: n, k\n    integer v(n), i, numTerms\n    numTerms = 0\n    v = u(n)\n    do i = 1, n\n      if (v(i)>=k) numTerms = numTerms+1\n    end do\n  end function lengthSupUK\n  \n  pure function comp(n) result(numTimes)\n    integer, intent(in) :: n\n    integer v(n), i, numTimes\n    numTimes = 0\n    v = u(n)\n    do i = 2, n\n      if (v(i)<v(i-1)) numTimes = numTimes+1\n    end do\n  end function comp\n  \nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83288,"user_id":17,"body":"module Solution\n  implicit none\ncontains\n  pure function lengthSupUK(n, k) result(numTerms)\n    integer, intent(in) :: n, k\n    integer :: numTerms, i\n    integer, dimension(:), allocatable :: u\n    allocate(u(n))\n    u(1) = 1\n    u(2) = 1\n    do i = 3, n\n      u(i) = u(i - u(i - 1)) + u(i - u(i - 2))\n    end do\n    numTerms = 0\n    do i = 1, n\n      if (u(i) >= k) then\n        numTerms = numTerms + 1\n      end if\n    end do\n    deallocate(u)\n  end function lengthSupUK\n  pure function comp(n) result(numTimes)\n    integer, intent(in) :: n\n    integer :: numTimes, i\n    integer, dimension(:), allocatable :: u\n    allocate(u(n))\n    u(1) = 1\n    u(2) = 1\n    do i = 3, n\n      u(i) = u(i - u(i - 1)) + u(i - u(i - 2))\n    end do\n    numTimes = 0\n    do i = 1, n - 1\n      if (u(i + 1) < u(i)) then\n        numTimes = numTimes + 1\n      end if\n    end do\n    deallocate(u)\n  end function comp\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"58184387d14fc32f2b0012b2":[{"id":83289,"user_id":527,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  REAL FUNCTION f(x)\n    REAL, INTENT(IN) :: x\n      f = x \/ (SQRT(1 + x) + 1)\n  END FUNCTION f\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83290,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  REAL FUNCTION f(x) RESULT(r)\n    REAL, INTENT(IN) :: x\n    r = x \/ (1.0 + SQRT(1.0 + x))\n  END FUNCTION f\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83291,"user_id":168,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  REAL FUNCTION f(x)\n    REAL, INTENT(IN) :: x\n      f = x \/ (1 + sqrt(1 + x))\n  END FUNCTION f\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83292,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  REAL FUNCTION f(x) RESULT(y)\n    REAL, INTENT(IN) :: x\n    y = x \/ (1.0 + SQRT(1.0 + x))\n  END FUNCTION f\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83293,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  REAL FUNCTION f(x)\n    REAL, INTENT(IN) :: x\n      f=x\/(sqrt(1.0+x)+1.0)\n  END FUNCTION f\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83294,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  REAL FUNCTION f(x)\n    REAL, INTENT(IN) :: x\n      ! your code\n      f = x\/(1.0 + SQRT(1.0 + x))\n      RETURN\n  END FUNCTION f\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83295,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  REAL FUNCTION f(x)\n    REAL, INTENT(IN) :: x\n      ! Why an actual Taylor expansion is NOT considered to be correct? Despite being CLOSER to the actual answer!!\n      !f = x\/2.0 - (x**2)\/8.0 + x*x*x\/16.0 - (5.0)*(128.0)*x*x*x*x\n      f = x \/ (sqrt(1.0 + x) + 1.0)\n  END FUNCTION f\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83296,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  REAL FUNCTION f(x)\n    REAL, INTENT(IN) :: x\n    DOUBLE PRECISION z\n  z = x\n  f = z \/ 2\n  if (z > 1.0e-6) f = dsqrt(z + 1) - 1\n  END FUNCTION f\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"582c297e56373f0426000098":[{"id":83297,"user_id":564,"body":"module Solution\n  use LinkedLists ! Predefined `Node` derived data type\n  implicit none\ncontains\n  function stringify(list) result(str)\n    type(Node), pointer :: list\n    type(Node), pointer :: node\n    character(:), allocatable :: str\n    character(7) :: strData\n    \n    str = \"\"\n    strData = \"\"\n    node => list\n\n    do while (associated(node))\n      write(strData, \"(I7)\") node%data\n      str = trim(str)\/\/\" \"\/\/adjustl(strData)\n      str = trim(str)\/\/\" ->\"\n      \n      node => node%next\n    end do\n\n    str = trim(adjustl(trim(str) \/\/ \" null()\"))\n\n  end function stringify\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83298,"user_id":null,"body":"module Solution\n  use LinkedLists\n  implicit none\ncontains\n  function stringify(list) result(strrep)\n    character(:), allocatable :: strrep\n    type(Node), pointer :: list\n    character(10) s\n    strrep = \"\"\n    do while (associated(list))\n      write(s, '(i0)') list%data\n      strrep = strrep\/\/trim(s)\/\/\" -> \"\n      list => list%next\n    end do\n    strrep = strrep\/\/\"null()\"\n  end function stringify\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83299,"user_id":168,"body":"module Solution\n  use LinkedLists ! Predefined `Node` derived data type\n  implicit none\ncontains\n  recursive function stringify(list) result(strrep)\n    type(Node), pointer :: list\n    character(:), allocatable :: strrep\n    character(12) :: tmp\n    if (associated(list)) then\n      write(tmp, '(i0)') list%data\n      strrep = trim(tmp) \/\/ \" -> \" \/\/ stringify(list%next)\n    else\n      strrep = \"null()\"\n    end if\n  end function stringify\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83300,"user_id":1657,"body":"module Solution\n  use LinkedLists ! Predefined `Node` derived data type\n  implicit none\ncontains\n  subroutine removespace(str, finalStr)\n    character(len=4) :: str\n    character(len=:), allocatable :: finalStr\n    integer :: i, lower, newLen\n    \n    lower = 0\n    DO i=1, len(str)\n      IF (str(i:i) == ' ') THEN\n        lower = lower + 1\n      END IF\n    END DO\n    \n    newLen = (len(str) - lower+1)\n    allocate(character(len=newLen) :: finalStr)\n    finalStr = str(lower+1:) ; str = str\n  end subroutine\n  \n  function stringify(list) result(strrep)\n    type(Node), pointer :: list\n    character(:), allocatable :: strrep\n    character(len=4) :: snum\n    character(len=:), allocatable :: finalStr\n    \n    IF (.NOT. associated(list)) THEN\n      strrep = \"null()\" \n      return\n    END IF\n    \n    DO WHILE (associated(list%next))\n      print *, list%data\n      write (snum, '(i4)') list%data\n      call removespace(snum, finalStr)\n      strrep = strrep \/\/ finalStr  \/\/ \" -> \"\n      list = list%next\n      \n      deallocate(finalStr)\n    END DO\n    \n    write (snum, '(i4)') list%data\n    call removespace(snum, finalStr)\n    strrep = strrep \/\/ finalStr \/\/ \" -> null()\"\n  end function stringify\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83301,"user_id":17,"body":"module Solution\n  use LinkedLists ! Predefined `Node` derived data type\n  implicit none\ncontains\n  recursive function stringify(list) result(strrep)\n    type(Node), pointer :: list\n    character(:), allocatable :: strrep\n    character(len=11) :: buf\n    if (associated(list)) then\n      write(buf, \"(I0)\") list%data\n      strrep = trim(buf) \/\/ \" -> \" \/\/ stringify(list%next)\n    else\n      strrep = \"null()\"\n    end if\n  end function stringify\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"582c5382f000e535100001a7":[{"id":83302,"user_id":null,"body":"module Solution\n  use LinkedLists ! Preloaded `Node` derived data type\n  implicit none\ncontains\n  subroutine print_list(list)\n    type(Node), pointer :: list, list_cpy\n    list_cpy => list\n    do while (associated(list_cpy))\n      write(*,*) list_cpy%data\n      list_cpy => list_cpy%next\n    end do\n  end subroutine print_list\n  function reverse(list) result(revlist)\n    type(Node), pointer :: list\n    type(Node), pointer :: revlist, tmp\n    revlist => null()\n    do while (associated(list))\n      allocate(tmp)\n      tmp%data = list%data\n      tmp%next => revlist\n      revlist => tmp\n      tmp => list\n      list => list%next\n      !deallocate(tmp)\n    end do\n  end function reverse\n  function parse(strrep) result(list)\n    character(len=*), intent(in) :: strrep\n    type(Node), pointer :: revlist, list, tmp\n    integer :: idx1,idx2, val, err\n    character(2) :: delim\n    delim = \"->\"\n    idx1 = 1\n    idx2 = index(strrep, delim)\n    revlist => null()\n    do while (idx2 .ne. 0  .and. idx1 < len(strrep) .and. idx1 .ne. idx2)\n      read(strrep(idx1:idx2-1), *, iostat=err) val\n      ! Must have found the null and we're done\n      if (err .ne. 0 ) exit\n      allocate(tmp)\n      tmp%data = val\n      tmp%next => revlist\n      revlist => tmp\n      idx1 = idx2 + 2\n      idx2 = index(strrep(idx1:), delim) + idx1\n    end do\n    !call print_list(revlist)\n    list => reverse(revlist)\n    !call print_list(list)\n  end function parse\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83303,"user_id":1657,"body":"module Solution\n  use LinkedLists ! Preloaded `Node` derived data type\n  implicit none\ncontains\n  function parse(strrep) result(list)\n    character(len=*), intent(in) :: strrep\n    type(Node), pointer :: list, current\n    integer :: x, y\n    \n    nullify(list)\n    x = (len(strrep) - 10)\n    \n    IF (len(strrep) == 6) THEN\n      list => null()\n    END IF\n    \n    DO WHILE (x > 0)\n      \n      y = x\n      DO WHILE (verify(strrep(y:x), '0123456789') == 0 .AND. y > 1)\n        y = y - 1\n      END DO\n      \n      allocate(current)\n      read(strrep(y:x), *) current%data\n      current%next => list\n      \n      list => current\n      x = x - (x - y) - 4\n      \n    END DO\n    \n  end function parse\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83304,"user_id":null,"body":"module Solution\n  use LinkedLists \n  implicit none\ncontains\n  pure function parse(strrep) result(list)\n    character(len=*), intent(in) :: strrep\n    type(Node), pointer :: list, head\n    character(len=len(strrep)) s\n    character(len=10) snum\n    integer pos, num\n    list => null()\n    if (strrep \/= \"null()\") then \n      s = strrep(:len(strrep)-6)\n      pos = index(s, \" -> \", .true.)\n      do while (index(s, \" -> \") > 0)\n        s = s(:pos-1)\n        pos = index(s, \" -> \", .true.)\n        if (pos>0) then; snum = s(pos+4:)\n        else; snum = s; end if\n        read(snum, '(i10)') num\n        allocate(head)\n        head = Node(num, list)\n        list => head\n      end do\n    end if  \n  end function parse\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83305,"user_id":null,"body":"module Solution\n  use LinkedLists \n  implicit none\ncontains\n  pure function int(s)\n    integer :: int\n    character(len=*), intent(in) :: s\n    read(s, '(i10)') int\n  end function\n  pure function parse(strrep) result(list)\n    character(len=*), intent(in) :: strrep\n    type(Node), pointer :: list, head\n    character(len=len(strrep)) s\n    character(len=10) snum\n    integer pos, num\n    list => null()\n    if (strrep \/= \"null()\") then \n      s = strrep(:len(strrep)-6)\n      pos = index(s, \" -> \", .true.)\n      do while (index(s, \" -> \") > 0)\n        s = s(:pos-1)\n        pos = index(s, \" -> \", .true.)\n        if (pos>0) then; snum = s(pos+4:)\n        else; snum = s; end if  \n        allocate(head)\n        head = Node(int(snum), list)\n        list => head\n      end do\n    end if  \n  end function parse\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83306,"user_id":17,"body":"module Solution\n  use LinkedLists ! Preloaded `Node` derived data type\n  implicit none\ncontains\n  pure recursive function parse(strrep) result(list)\n    character(len=*), intent(in) :: strrep\n    type(Node), pointer :: list\n    integer :: data, i\n    character(len=2) :: buf\n    if (strrep == \"null()\") then\n      list => null()\n    else\n      i = 1\n      do while (strrep(i:i) \/= ' ')\n        i = i + 1\n      end do\n      i = i - 1\n      write(buf, \"(I0)\") i\n      read(strrep, \"(I\" \/\/ buf \/\/ \")\") data\n      allocate(list)\n      list%data = data\n      if (data == 0) then\n        list%next => parse(strrep(6:len(strrep)))\n      else\n        list%next => parse(strrep((floor(log10(real(data))) + 6):len(strrep)))\n      end if\n    end if\n  end function parse\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"582cb0224e56e068d800003c":[{"id":83307,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function keep_hydrated(hours) result (litres)\n    real, intent(in) :: hours\n    real :: litres_real\n    litres_real = hours * 0.5\n    litres = floor( litres_real )\n  end function keep_hydrated\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83308,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function keep_hydrated(hours) result (litres)\n    real, intent(in) :: hours\n    litres = 0 ! your code here\n    litres = floor(0.5*hours)\n  end function keep_hydrated\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83309,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function keep_hydrated(hours) result (litres)\n    real, intent(in) :: hours\n    litres = int(0.5*real(hours))\n  end function keep_hydrated\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83310,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function keep_hydrated(hours) result (litres)\n    real, intent(in) :: hours\n    litres = floor(hours\/2.0) ! your code here\n  end function keep_hydrated\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83311,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function keep_hydrated(hours) result (litres)\n    real, intent(in) :: hours\n    litres = hours\/2 ! your code here\n  end function keep_hydrated\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83312,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function keep_hydrated(hours) result (litres)\n    real, intent(in) :: hours\n    \n    litres = int(hours * 0.5, 4)\n    \n  end function keep_hydrated\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83313,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer function keep_hydrated(hours) result (litres)\n  real, intent(in) :: hours  \n  litres = int(hours \/ 2.0)\n  end function keep_hydrated\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83314,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function keep_hydrated(hours) result (litres)\n    real, intent(in) :: hours\n    !litres = hours \/ 2.0    \n    litres = int(hours \/ 2)\n  end function keep_hydrated\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83315,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function keep_hydrated(hours) result (litres)\n    real, intent(in) :: hours\n\n    litres = (hours - modulo(hours, 1.0)) \/ 2 ! your code here\n  end function keep_hydrated\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83316,"user_id":168,"body":"module Solution\n  implicit none\ncontains\n  integer pure function keep_hydrated(hours) result (litres)\n    real, intent(in) :: hours\n    litres = int(hours) \/ 2\n  end function keep_hydrated\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"58649884a1659ed6cb000072":[{"id":83317,"user_id":527,"body":"module Solution\n  implicit none\ncontains\n  pure function update_light(current) result(next)\n    character(*), intent(in) :: current\n    character(:), allocatable :: next\n    select case (current)\n      case (\"red\")\n        next = \"green\"\n      case (\"yellow\")\n        next = \"red\"\n      case (\"green\")\n        next = \"yellow\"\n    end select\n  end function update_light\nend module Solution","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83318,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function update_light(current) result(next)\n    character(*), intent(in) :: current\n    character(:), allocatable :: next\n    \n    if (current.eq.\"green\") then\n      next = \"yellow\"\n    else if (current.eq.\"yellow\") then\n      next = \"red\"\n    else if (current.eq.\"red\") then\n      next = \"green\"\n    endIf\n    \n    !next = \"\" ! TODO\n  end function update_light\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83319,"user_id":390,"body":"module Solution\n  implicit none\ncontains\n  pure function update_light(current) result(next)\n    character(*), intent(in) :: current\n    character(:), allocatable :: next\n    \n    if (current == \"green\") then\n    next = \"yellow\"\n    end if\n    \n    if (current == \"yellow\") then\n    next = \"red\"\n    end if\n    \n    if (current == \"red\") then\n    next = \"green\"\n    end if\n    \n  end function update_light\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83320,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function update_light(current) result(next)\n    character(*), intent(in) :: current\n    character(:), allocatable :: next\n   Select case(current)\n    case (\"green\")\n      next = \"yellow\"\n    case (\"yellow\")\n      next = \"red\"\n    case (\"red\")\n      next = \"green\"\n    end select\n    \n  end function update_light\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83321,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function update_light(current) result(next)\n    character(*), intent(in) :: current\n    character(:), allocatable :: next\n    \n    select case (trim(current))\n      case (\"green\")\n        next = \"yellow\"\n      case (\"yellow\")\n        next = \"red\"\n      case default\n        next = \"green\"\n    end select\n    \n  end function update_light\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83322,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function update_light(current) result(next)\n    character(*), intent(in) :: current\n    character(:), allocatable :: next\n   ! next = \"\" ! TODO\n   if (current.eq.'red') then\n       next = 'green'\n   else if (current.eq.'green') then\n       next = 'yellow'\n   else if (current.eq.'yellow') then\n       next = 'red'\n   end if\n\n  end function update_light\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83323,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function update_light(current) result(next)\n    character(*), intent(in) :: current\n    character(:), allocatable :: next\n    \n    if (current == \"green\") then\n      next = \"yellow\"\n    else if (current == \"yellow\") then\n      next = \"red\"\n    else if (current == \"red\") then\n      next = \"green\"\n    else\n      next = \"invalid input\"\n    end if\n    \n  end function update_light\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83324,"user_id":187,"body":"module Solution\n  implicit none\ncontains\n  pure function update_light(current) result(next)\n    character(*), intent(in) :: current\n    character(:), allocatable :: next\n      if (current == \"red\") then\n        next = \"green\"\n      else if (current == \"green\") then\n        next = \"yellow\"\n      else if (current == \"yellow\") then \n        next = \"red\"\n    end if \n  end function update_light\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83325,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function update_light(current) result(next)\n    character(*), intent(in) :: current\n    character(:), allocatable :: next\n    next = \"\"\n    if (trim(current) .eq. \"green\") then\n      next = \"yellow\"\n    else if (trim(current) .eq. \"yellow\") then\n      next = \"red\"\n    else if (trim(current) .eq. \"red\") then\n      next = \"green\"\n    endif\n  end function update_light\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83326,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function update_light(current) result(next)\n    character(*), intent(in) :: current\n    character(:), allocatable :: next\n   if (current .eq. 'yellow') then\n      next='red'\n   else if (current .eq. 'red') then\n      next='green'\n   else\n      next='yellow'\n   end if   \n  end function update_light\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"588534713472944a9e000029":[{"id":83327,"user_id":17,"body":"module Solution\n  use BinaryTrees\n  implicit none\n  private\n  public :: is_bst\ncontains\n  integer recursive function tree_min(n) result(minimum)\n    type(Node), pointer :: n\n    if (associated(n)) then\n      minimum = min(n%value, tree_min(n%left), tree_min(n%right))\n    else\n      minimum = 2147483647\n    end if\n  end function tree_min\n  integer recursive function tree_max(n) result(maximum)\n    type(Node), pointer :: n\n    if (associated(n)) then\n      maximum = max(n%value, tree_max(n%left), tree_max(n%right))\n    else\n      maximum = -2147483647\n    end if\n  end function tree_max\n  logical recursive function is_true_bst(n) result(is_bst)\n    type(Node), pointer :: n\n    is_bst = .not. associated(n)\n    if (.not. is_bst) then\n      is_bst = (&\n        tree_max(n%left) < n%value .and. tree_min(n%right) > n%value .and. &\n        is_true_bst(n%left) .and. is_true_bst(n%right)&\n      )\n    end if\n  end function is_true_bst\n  logical recursive function is_mirrored_bst(n) result(is_bst)\n    type(Node), pointer :: n\n    is_bst = .not. associated(n)\n    if (.not. is_bst) then\n      is_bst = (&\n        tree_min(n%left) > n%value .and. tree_max(n%right) < n%value .and. &\n        is_mirrored_bst(n%left) .and. is_mirrored_bst(n%right)&\n      )\n    end if\n  end function is_mirrored_bst\n  logical function is_bst(n)\n    type(Node), pointer :: n\n    is_bst = is_true_bst(n) .or. is_mirrored_bst(n)\n  end function is_bst\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5886e082a836a691340000c3":[{"id":83328,"user_id":53,"body":"module Solution\n  implicit none\ncontains\n  integer pure function rectangle_rotation(a, b) result (res)\n    integer, intent(in) :: a, b\n    integer :: x, y, r\n    x = floor(real(a) \/ sqrt(real(2)))\n    y = floor(real(b) \/ sqrt(real(2)))\n    r = (x + 1) * (y + 1) + x * y\n    res = r + mod(r, 2) - 1\n  end function rectangle_rotation\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83329,"user_id":168,"body":"module Solution\n  implicit none\ncontains\n  integer function rectangle_rotation(a, b) result (res)\n    integer, intent(in) :: a, b\n    integer :: x, y\n    x = int(a \/ sqrt(2.0))\n    y = int(b \/ sqrt(2.0))\n    res = 2 * x * y + x + y - and(xor(x, y), 1) + 1\n  end function rectangle_rotation\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83330,"user_id":645,"body":"module Solution\n  implicit none\ncontains\n  integer function rectangle_rotation(a, b)\n    integer, intent(in) :: a, b\n    integer :: h, v\n    h = int(a \/ sqrt(2.0))\n    v = int(b \/ sqrt(2.0))\n    rectangle_rotation = h * v + (h + 1) * (v + 1) - xor(mod(h, 2), mod(v, 2))\n  end function rectangle_rotation\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"58941fec8afa3618c9000184":[{"id":83331,"user_id":53,"body":"module Solution\n  implicit none\ncontains\n  integer pure function growing_plant(u, d, m) result (res)\n    integer, intent(in) :: u, d, m\n    res = max(1, int(ceiling(real(m - d) \/ real(u - d))))\n  end function growing_plant\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83332,"user_id":527,"body":"module Solution\n  implicit none\ncontains\n  integer pure function growing_plant(up_speed, down_speed, desired_height)\n    integer, intent(in) :: up_speed, down_speed, desired_height\n    growing_plant = max(0, ceiling(real(desired_height - up_speed) \/ (up_speed - down_speed))) + 1\n  end function growing_plant\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83333,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function growing_plant(up_speed, down_speed, desired_height) result (res)\n    integer, intent(in) :: up_speed, down_speed, desired_height\n    integer :: height\n    res = 0 \n    height = 0\n    do while (height \/= desired_height)\n        height = height + up_speed\n        if (height >= desired_height) then\n            res = res + 1\n            exit\n        end if\n        height = height - down_speed\n        res = res + 1\n    end do\n  end function growing_plant\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83334,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function growing_plant(up_speed, down_speed, desired_height) result (days)\n    integer, intent(in) :: up_speed, down_speed, desired_height\n    integer :: days, grow_len\n    days = 0\n    grow_len=0\n    do\n      days=days+1\n      grow_len=grow_len+up_speed\n      if (grow_len .ge. desired_height) then\n        exit\n      else\n        grow_len=grow_len-down_speed\n      end if\n    end do\n  end function growing_plant\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83335,"user_id":492,"body":"module Solution\n  implicit none\ncontains\n  integer pure function growing_plant(up, down, d) result (res)\n    integer, intent(in) :: up, down, d\n    if (d - up < 0) then \n      res = 1\n    else \n      res = ceiling(real(d - up) \/ real(up - down)) + 1 \n    end if\n  end function growing_plant\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83336,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function growing_plant(up_speed, down_speed, desired_height) result (res)\n    integer, intent(in) :: up_speed, down_speed, desired_height\n    integer :: height\n    height = 0\n    res = 0\n    DO\n      height = height + up_speed\n      res = res + 1\n      IF (height >= desired_height) THEN\n        EXIT !loop\n      END IF\n      height = height - down_speed\n    END DO    \n  end function growing_plant\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83337,"user_id":null,"body":"module Solution\n   implicit none\n contains\n   integer pure function growing_plant(up_speed, down_speed, desired_height) result (res)\n     integer, intent(in) :: up_speed, down_speed, desired_height\n     integer :: total_height\n     res = 1\n     total_height = 0\n      do while (total_height < desired_height)\n         total_height = total_height + up_speed\n         if (total_height >= desired_height) then\n            exit\n         end if\n         total_height = total_height - down_speed\n         res = res + 1\n      end do\n   end function growing_plant\n end module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83338,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function growing_plant(up_speed, down_speed, desired_height) result (res)\n    integer, intent(in) :: up_speed, down_speed, desired_height\n    integer :: height\n    res = 1\n    height = 0\n    do while(height + up_speed < desired_height)\n      height = height + up_speed - down_speed\n      res = res + 1\n    end do\n  end function growing_plant\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83339,"user_id":645,"body":"module Solution\n  implicit none\ncontains\n  integer pure function growing_plant(u, d, h)\n    integer, intent(in) :: u, d, h\n    growing_plant = max(1, ceiling((h - d) \/ real(u - d, 8)))\n  end function growing_plant\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"58aa68605aab54a26c0001a6":[{"id":83340,"user_id":53,"body":"module Solution\n  implicit none\ncontains\n\n  integer pure function distinctDigitYear(currentYear) result (y)\n    integer, intent(in) :: currentYear\n    integer :: a, b, c, d\n    y = currentYear\n    do while (.true.)\n      y = y + 1\n      a = mod(y, 10)\n      b = mod(y \/ 10, 10)\n      c = mod(y \/ 100, 10)\n      d = mod(y \/ 1000, 10)\n      if (a \/= b .and. a \/= c .and. a \/= d .and. b \/= c .and. b \/= d .and. c \/= d) then\n        exit\n      end if      \n    end do\n  end function distinctDigitYear\n  \nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83341,"user_id":null,"body":"module Solution\n\nimplicit none\n\ncontains\n\n  pure logical function distinct(year)\n    integer,intent(in) :: year\n    integer,dimension(:), allocatable :: list\n    integer :: num\n    integer :: rem\n    integer :: i,j\n    distinct=.true.\n    num=floor(log10(real(year))+1)\n    allocate(list(num))\n    list=0\n    rem=year\n    do i=1,num,1\n        list(i)=rem-(rem\/10)*10\n        rem=rem\/10\n        do j=1,i-1,1\n            if((list(i)-list(j)).eq.0)then\n                distinct=.false.\n                return\n            end if\n        end do\n    end do\n  end function distinct\n\n  integer pure function distinctDigitYear(currentYear) result(nextDistinctDigitYear)\n    integer, intent(in) :: currentYear\n    nextDistinctDigitYear = currentYear + 1\n    do\n      if(distinct(nextDistinctDigitYear))return\n      nextDistinctDigitYear=nextDistinctDigitYear+1\n    end do\n  end function distinctDigitYear\n  \nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83342,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function distinctDigitYear(currentYear) result(nextDistinctDigitYear)\n    integer, intent(in) :: currentYear\n    integer i, d1, d2, d3, d4 ! counter & digits\n    \n    nextDistinctDigitYear = 0\n    \n    do i = currentYear+1, 9999\n      d1 = i \/ 1000\n      d2 = modulo(i, 1000) \/ 100\n      d3 = modulo(i, 100) \/ 10\n      d4 = modulo(i, 10)\n      \n      if (d1 .ne. d2 .and. d1 .ne. d3 .and. d1 .ne. d4 .and. d2 .ne. d3 .and. d2 .ne. d4 .and. d3 .ne. d4) then\n        nextDistinctDigitYear = i\n        exit\n      end if \n    end do\n  end function distinctDigitYear\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83343,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function distinctDigitYear(currentYear) result(nextDistinctDigitYear)\n      implicit none\n      integer, intent(in) :: currentYear\n      integer :: digit(4), tempdigit, newdigit(4), iter, increment\n\n      nextDistinctDigitYear = currentYear\n      do\n          nextDistinctDigitYear = nextDistinctDigitYear + 1\n          digit = int2digit(nextDistinctDigitYear)\n          if ( check_duplicated_digit(digit) ) then\n              cycle\n          else\n              return\n          end if\n      end do\n  end function distinctDigitYear\n\n  logical pure function check_duplicated_digit(digit)\n\n      integer, intent(in) :: digit(4)\n\n      if (digit(1) == digit(2) .or. digit(1) == digit(3) .or. &\n      digit(1) == digit(4)) then\n          check_duplicated_digit = .true.\n          return\n      endif\n\n      if (digit(2) == digit(3) .or. &\n      digit(2) == digit(4)) then\n          check_duplicated_digit = .true.\n          return\n      endif\n\n      if (digit(3) == digit(4)) then\n          check_duplicated_digit = .true.\n          return\n      endif\n\n      check_duplicated_digit = .false.\n  end function check_duplicated_digit\n\n  pure function int2digit(year)\n      implicit none\n      integer, intent(in) :: year\n      integer :: int2digit(4)\n\n      int2digit(1) = int(real(year)\/1000)\n      int2digit(2) = int(real(year)\/100 - int2digit(1)*10)\n      int2digit(3) = int(real(year)\/10 - int2digit(1)*100 &\n                     - int2digit(2)*10)\n      int2digit(4) = int(real(year) - int2digit(1)*1000 &\n                  - int2digit(2)*100 - int2digit(3)*10)\n  end function int2digit\nend module Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83344,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  logical pure function diff(y)\n    integer, intent(in) :: y\n    integer :: y1, y2, y3, y4\n    y1 = y\/1000; y2 = (y-y1*1000)\/100\n    y3 = mod(y, 100)\/10; y4 = mod(y, 10)\n    diff = y1==y2 .or. y1==y3 .or. y1==y4 .or. y2==y3 .or. y2==y4 .or. y3==y4\n  end function diff\n  integer pure function distinctDigitYear(currentYear) result(nextDistinctDigitYear)\n    integer, intent(in) :: currentYear \n    integer :: year; year = currentYear+1\n    do while (diff(year)); year = year+1; end do\n    nextDistinctDigitYear = year\n  end function distinctDigitYear\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83345,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  logical pure function distinct(y)\n    integer, intent(in)::y\n    integer::y1, y2, y3, y4\n    y1 = y\/1000; y2 = (y-y1*1000)\/100\n    y3 = mod(y, 100)\/10; y4 = mod(y, 10)\n    distinct = y1\/=y2 .AND. y1\/=y3 .AND. y1\/=y4 .AND. y2\/=y3 .AND. y2\/=y4 .AND. y3\/=y4\n  end function distinct\n  integer pure function distinctDigitYear(currentYear) result(nextDistinctDigitYear)\n    integer, intent(in) :: currentYear \n    integer::year; year = currentYear+1\n    do while (.NOT. distinct(year)); year = year+1; end do\n    nextDistinctDigitYear = year\n  end function distinctDigitYear\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83346,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer function distinctDigitYear(currentYear) result(nextDistinctDigitYear)\n    integer, intent(in) :: currentYear\n    integer :: y, m, c, d, a\n    y = currentYear + 1\n    do while (y <= 9999)\n       a = mod(y,10)\n       d = mod(y-a, 100) \/ 10\n       c = mod(y-a-d, 1000) \/ 100\n       m = mod(y-a-d-c, 10000) \/ 1000\n       ! Check some specific cases and advance to next likely candidate\n       if (m == c) then\n          y = y + 100 - d*10 - a\n          cycle\n       else if (m == d .or. c == d) then\n          y = y + 10 - a\n          cycle\n       else if (m == a .or. c == a .or. d == a) then\n          y = y + 1\n          cycle\n       else\n          exit\n       end if\n    end do\n    nextDistinctDigitYear = y ! TODO\n  end function distinctDigitYear\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83347,"user_id":17,"body":"module Solution\n  implicit none\n  private :: isDistinctDigitYear\ncontains\n  logical pure function isDistinctDigitYear(year)\n    integer, intent(in) :: year\n    logical, dimension(0:9) :: appeared\n    integer :: n\n    isDistinctDigitYear = .true.\n    appeared = .false.\n    n = year\n    do while (n > 0)\n      if (appeared(mod(n, 10))) then\n        isDistinctDigitYear = .false.\n        exit\n      end if\n      appeared(mod(n, 10)) = .true.\n      n = n \/ 10\n    end do\n  end function isDistinctDigitYear\n  integer pure function distinctDigitYear(currentYear) result(nextDistinctDigitYear)\n    integer, intent(in) :: currentYear\n    nextDistinctDigitYear = currentYear\n    do while (.true.)\n      nextDistinctDigitYear = nextDistinctDigitYear + 1\n      if (isDistinctDigitYear(nextDistinctDigitYear)) then\n        exit\n      end if\n    end do\n  end function distinctDigitYear\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"58ce8725c835848ad6000007":[{"id":83348,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION potatoes(p0, w0, p1) result (m)\n    INTEGER :: p0, w0, p1, m\n    m = w0 * (100 - p0) \/ (100 - p1)\n  END FUNCTION potatoes\nEND MODULE Solution","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83349,"user_id":564,"body":"module Solution\n  implicit none\ncontains\n\n  function potatoes(pctIn, weight, pctOut)\n    integer :: pctIn, weight, pctOut, potatoes\n\n    potatoes = weight * (100 - pctIn) \/ (100 - pctOut)\n\n  end function potatoes\n\nend module Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83350,"user_id":null,"body":"MODULE Solution\n  implicit none\nCONTAINS\n  FUNCTION potatoes(p0, w0, p1) result(ret)\n    INTEGER :: diff, init, total, ret, p0, w0, p1\n    REAL :: prop\n    diff = p0 - p1\n    init = 100 - p0\n    total = init + diff\n    prop = (w0 * (FLOAT(init) \/ FLOAT(total)))\n    ret = FLOOR(prop)\n  END FUNCTION potatoes\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83351,"user_id":168,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  integer FUNCTION potatoes(p0, w0, p1) \n    integer :: p0, w0, p1\n    potatoes = (100 - p0) * w0 \/ (100 - p1)\n  END FUNCTION potatoes\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83352,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  PURE FUNCTION potatoes(p0, w0, p1) RESULT(w1)\n    INTEGER, INTENT(IN) :: p0,p1,w0\n    INTEGER :: w1\n    w1=FLOOR(w0*(100.0-p0)\/(100.0-p1))\n  END FUNCTION potatoes\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83353,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION potatoes(p0, w0, p1) \n    INTEGER :: p0, w0, p1, potatoes\n    potatoes = w0 * (100 - p0)\/(100 - p1)\n  END FUNCTION potatoes\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83354,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function potatoes(p0, w0, p1) result (res)\n  integer, intent(in) :: p0, w0, p1  \n    res = floor(w0 * (100.0 - p0) \/ (100.0 - p1))\n  end function potatoes\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83355,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION potatoes(p0, w0, p1) result(res)\n    ! your code\n    integer :: res\n    integer, intent(in) :: p0, w0, p1  \n    res = w0*(100-p0)\/(100-p1)\n  END FUNCTION potatoes\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83356,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION potatoes(p0, w0, p1) result(out)\n  integer, intent(in)      :: p0, w0, p1\n  integer                  :: out\n  real                     :: temp\n  \n  temp = w0 * ( (100. - p0) \/ (100. - p1) )\n  \n  write(*,*) p0, w0, p1, temp\n  !out = nint(temp)   really? this does NOT work...\n  if (temp - nint(temp) > .99) then \n    out = ceiling(temp)\n  else\n    out = int(temp)\n  end if\n  END FUNCTION potatoes\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83357,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION potatoes(p0, w0, p1) result(left)\n    ! your code\n    integer,intent(in)::p0,w0,p1\n    integer::left\n    left=w0*(100-p0)\/(100-p1)\n  END FUNCTION potatoes\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"58e230e5e24dde0996000070":[{"id":83358,"user_id":53,"body":"module Solution\n  implicit none\n  private :: isPrime\n  public :: next_prime\ncontains\n\n  integer(8) pure function next_prime(n)\n    integer(8), intent(in) :: n\n    integer(8) :: m\n    m = n + 1\n    do while (1 > 0)\n      if (isPrime(m)) then\n        next_prime = m\n        return\n      end if\n      m = m + 1\n    end do\n  end function next_prime\n  \n  pure FUNCTION isPrime(n) RESULT(res)\n    integer(8), INTENT(IN) :: n\n    integer(8) :: i\n    LOGICAL :: res\n    if (n < 2_8) then\n      res = .FALSE.\n      return\n    end if\n    if (mod(n, 2_8) == 0) then\n      res = (n == 2)\n      return\n    end if\n    do i = 3, int(sqrt(real(n))), 2\n      if (mod(n, i) == 0) then\n        res = .FALSE.\n        return\n      end if\n    end do\n    res = .TRUE.\n  END FUNCTION isPrime\n  \nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83359,"user_id":168,"body":"module Solution\n  implicit none\n  private\n  public :: next_prime\ncontains\n  integer(8) pure function next_prime(n)\n    integer(8), intent(in) :: n\n    integer(8) :: d\n    logical :: found\n    if (n < 2) then\n      next_prime = 2\n      return\n    end if\n    next_prime = n + 1 + mod(n, 2_8)\n    do\n      d = 3\n      found = .true.\n      do while (d * d <= next_prime)\n        if (mod(next_prime, d) == 0) then\n          found = .false.\n          exit\n        end if\n        d = d + 2\n      end do\n      if (found) then\n        return\n      end if\n      next_prime = next_prime + 2\n    end do\n  end function next_prime\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83360,"user_id":null,"body":"module Solution\n  implicit none\n  private\n  public :: next_prime\ncontains\n  integer(8) pure function next_prime(n)\n    implicit none\n    integer(8), intent(in) :: n\n    integer(8) :: i, limit\n    logical :: is_prime\n\n    next_prime = n\n\n    if (next_prime < 2) then\n        next_prime = 2\n        return\n    end if\n    \n    if (MOD(next_prime, 2_8) == 0 ) then\n        next_prime = next_prime + 1 - 2\n    end if\n\n    is_prime = .false.\n    do while ( .not. is_prime )\n        next_prime = next_prime + 2\n        is_prime = .true.\n        limit = INT(SQRT(REAL(next_prime))) + 1\n        i = 3\n        do while ( is_prime .and. i < limit )\n            is_prime = MOD(next_prime, i) \/= 0\n            i = i + 1\n        end do\n    end do\n  end function next_prime\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83361,"user_id":null,"body":"module Solution\n  implicit none\n  private\n  public :: next_prime\ncontains\n  integer(8) pure function next_prime(n)\n    integer(8), intent(in) :: n\n    \n    next_prime = n + 1\n    \n    if (n < 2_8) then\n      next_prime = 2\n      return\n    else if (mod(next_prime, 2_8) == 0) then\n      next_prime = next_prime + 1\n    end if\n      \n    do while (.true.)\n      if (is_prime(next_prime)) then\n        exit\n      else\n        next_prime = next_prime + 2\n      end if\n    end do\n  end function next_prime\n  \n  logical pure function is_prime(n)\n    integer(8), intent(in) :: n\n    integer(8) :: i, max\n    is_prime = .true.\n    \n    if (n < 2) then\n      is_prime = .false.\n      return\n    else if(n == 2) then\n      is_prime = .true.\n      return\n    else if (mod(n,2_8) == 0) then\n      is_prime = .false.\n      return\n    end if\n    \n    max = int(sqrt(real(n,8)+1_8), 8)\n    \n    do i = 3_8, max, 2_8\n      if (mod(n,i) == 0) then\n        is_prime = .false.\n      end if\n    end do\n  end function is_prime\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83362,"user_id":null,"body":"module Solution\n  implicit none\n  private\n  public :: next_prime\ncontains\n  integer(8) pure function next_prime(n)\n    integer(8), intent(in) :: n\n    \n    next_prime = n + 1\n    \n    if (n < 2_8) then\n      next_prime = 2\n      return\n    else if (mod(next_prime, 2_8) == 0) then\n      next_prime = next_prime + 1\n    end if\n      \n    do while (.true.)\n      if (is_prime(next_prime)) then\n        exit\n      else\n        next_prime = next_prime + 2\n      end if\n    end do\n  end function next_prime\n  \n  logical pure function is_prime(n)\n    integer(8), intent(in) :: n\n    integer(8) :: i, max\n    is_prime = .true.\n    \n    if (n < 2) then\n      is_prime = .false.\n    end if\n    \n    max = int(sqrt(real(n,8)+1_8), 8)\n    \n    do i = 2, max\n      if (mod(n,i) == 0) then\n        is_prime = .false.\n      end if\n    end do\n  end function is_prime\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83363,"user_id":null,"body":"module Solution\n  implicit none\n  private\n  public :: next_prime\ncontains\n  integer(8) pure function next_prime(n)\n    integer(8), intent(in) :: n\n    \n    next_prime = n + 1\n    \n    if (n < 2_8) then\n      next_prime = 2\n      return\n    else if (mod(next_prime, 2_8) == 0) then\n      next_prime = next_prime + 1\n    end if\n      \n    do while (.true.)\n      if (is_prime(next_prime)) then\n        exit\n      else\n        next_prime = next_prime + 2\n      end if\n    end do\n  end function next_prime\n  \n  logical pure function is_prime(n)\n    integer(8), intent(in) :: n\n    integer(8) :: i, max\n    is_prime = .true.\n    \n    if (n < 2) then\n      is_prime = .false.\n    end if\n    \n    max = int((n+1_8)**0.5)\n    \n    do i = 2, max\n      if (mod(n,i) == 0) then\n        is_prime = .false.\n      end if\n    end do\n  end function is_prime\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83364,"user_id":null,"body":"module Solution\n  implicit none\n  private\n  public :: next_prime\n  \ncontains\n\n  pure logical function prime(n)\n    integer(8),intent(in) :: n\n    integer(8) :: i\n    prime=.false.\n    if(mod(n,2).eq.0)return\n    do i=3_8,int(sqrt(real(n,8)),8),2_8\n      if(mod(n,i).eq.0)return\n    end do\n    prime=.true.\n  end function prime\n\n  integer(8) pure function next_prime(n)\n    integer(8), intent(in) :: n\n    next_prime = n+1_8\n    if((n.eq.0).or.(n.eq.1))then\n      next_prime=2_8\n      return\n    end if\n    do\n      if(prime(next_prime))return\n      next_prime=next_prime+1_8\n    end do\n  end function next_prime\n  \nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83365,"user_id":null,"body":"module Solution\n  implicit none\n  private\n  public :: next_prime\ncontains\n  integer(8) pure function next_prime(n)\n    integer(8), intent(in) :: n\n    integer(8) :: i\n    \n    if (n < 2) then\n      next_prime = 2\n      return\n    end if\n    \n    next_prime = n\n    \n    prime_find: do\n      next_prime = next_prime + 1_8\n    \n      if (mod(next_prime,2_8) == 0) cycle\n      \n      do i=3_8,int(sqrt(real(next_prime))),2_8\n        if (mod(next_prime,i) == 0) cycle prime_find\n      end do\n      \n      exit prime_find\n    end do prime_find\n    \n  end function next_prime\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83366,"user_id":17,"body":"module Solution\n  implicit none\n  private\n  public :: next_prime\ncontains\n  logical pure function is_prime(n)\n    integer(8), intent(in) :: n\n    integer(8) :: i\n    if (n <= 2_8) then\n      is_prime = n == 2_8\n    else if (mod(n, 2_8) == 0_8) then\n      is_prime = .false.\n    else\n      is_prime = .true.\n      do i = 3_8, floor(sqrt(real(n))), 2_8\n        if (mod(n, i) == 0_8) then\n          is_prime = .false.\n          exit\n        end if\n      end do\n    end if\n  end function is_prime\n  integer(8) pure function next_prime(n)\n    integer(8), intent(in) :: n\n    next_prime = n + 1_8\n    do while (.not. is_prime(next_prime))\n      next_prime = next_prime + 1_8\n    end do\n  end function next_prime\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"59b166f0a35510270800018d":[{"id":83367,"user_id":null,"body":"module Solution\n  use Preloaded ! `Point` derived data type\n  implicit none\ncontains\n  pure function findArea(points) result(area)\n    type(Point), dimension(:), intent(in) :: points\n    real(8) :: area, dx\n    integer :: i\n    \n    ! Do trapezoidal rule\n    area = 0.0_8\n    do i = lbound(points, dim=1) + 1, ubound(points, dim=1)\n      dx = points(i)%x - points(i - 1)%x\n      area = area + (points(i)%y + points(i - 1)%y) * dx \/ 2.0_8\n    end do\n  end function findArea\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83368,"user_id":null,"body":"module Solution\n  use Preloaded ! `Point` derived data type\n  implicit none\ncontains\n  pure function findArea(points) result(area)\n    type(Point), dimension(:), intent(in) :: points\n    real(8) :: area\n    integer :: i\n    \n    area = 0.0_8\n    do i = 2, size(points)\n      area = area + (points(i)%x - points(i-1)%x) * (points(i)%y + points(i-1)%y) \/ 2.\n    end do\n  end function findArea\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83369,"user_id":null,"body":"module Solution\n  use Preloaded ! `Point` derived data type\n  implicit none\ncontains\n  pure function findArea(points) result(area)\n    type(Point), dimension(:), intent(in) :: points\n    integer :: i\n    real(8) :: area, dx, y_min\n    area = 0.0_8\n\n    do i=2,size(points)\n        dx = points(i)%x-points(i-1)%x\n        y_min = min(points(i-1)%y, points(i)%y)\n\n        area = area + y_min * dx + (max(points(i-1)%y, points(i)%y) - y_min) * dx \/ 2.0_8\n    enddo\nend function findArea\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83370,"user_id":null,"body":"module Solution\n  use Preloaded ! `Point` derived data type\n  \n  implicit none\n\ncontains\n\n  pure function findArea(points) result(area)\n    type(Point), dimension(:), intent(in) :: points\n    real(8) :: area, w, h\n    real(8) :: x1, x2, y1, y2\n    \n    integer :: i\n    \n    area = 0.0_8\n    do i = 1, size(points) - 1, 1\n      x1 = points(i)%x\n      x2 = points(i+1)%x\n      w = x2 - x1  \n      \n      y1 = points(i)%y\n      y2 = points(i+1)%y\n      h = min(y1, y2) + abs(y1 - y2) \/ 2.0_8\n      \n      area = area + w * h\n    end do\n  \n    return\n  end function findArea\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83371,"user_id":null,"body":"module Solution\n  use Preloaded ! `Point` derived data type\n  implicit none\ncontains\n  pure function findArea(points) result(area)\n    type(Point), dimension(:), intent(in) :: points\n    type(Point) :: xi,xf\n    integer :: i,n\n    real(8) :: area\n    area = 0.0_8 ! TODO\n    \n    n = size(points)\n    xi = points(1)\n    \n    Do i = 2, n\n      xf = points(i)\n      area = area + 0.5D0*(xi%y + xf%y)*(xf%x - xi%x)\n      xi = xf\n    End Do\n    \n  end function findArea\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83372,"user_id":null,"body":"module Solution\n  use Preloaded ! `Point` derived data type\n  implicit none\ncontains\n  pure function findArea(points) result(area)\n    type(Point), dimension(:), intent(in) :: points\n    type(Point) :: p1,p2\n    real(8) :: area, ymax, ymin\n    integer :: i\n    area = 0.0_8 ! TODO\n    do i = 1,size(points)-1\n      p1 = points(i)\n      p2 = points(i+1)\n      if (p1%y < p2%y) then\n        ymin = p1%y\n        ymax = p2%y\n      else\n        ymin = p2%y\n        ymax = p1%y\n      end if\n      area = area + (p2%x - p1%x) * (0.5_8 * ymin + 0.5_8*ymax )\n    end do\n  end function findArea\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83373,"user_id":null,"body":"module Solution\n  use Preloaded ! `Point` derived data type\n  implicit none\ncontains\n  pure function findArea(points) result(area)\n    type(Point), dimension(:), intent(in) :: points\n    real(8) :: area\n    integer(2) i, iMax\n    area = 0.0\n    iMax = size(points)\n    do i=2, iMax\n      area = area + (points(i)%x - points(i-1)%x) * (points(i)%y + points(i-1)%y)\n    end do\n    area = 0.5 * area\n  end function findArea\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83374,"user_id":17,"body":"module Solution\n  use Preloaded\n  implicit none\ncontains\n  pure function findArea(points) result(area)\n    type(Point), dimension(:), intent(in) :: points\n    real(8) :: area\n    integer :: i\n    area = 0.0_8\n    do i = 1, size(points) - 1\n      area = area + (points(i + 1)%x - points(i)%x) * (points(i + 1)%y + points(i)%y) \/ 2.0_8\n    end do\n  end function findArea\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"59ccf051dcc4050f7800008f":[{"id":83375,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  FUNCTION sum_divisors(n)\n    INTEGER, INTENT(IN):: n\n    INTEGER :: div, q\n    INTEGER :: sm, sum_divisors\n\n    sm = -n\n    DO div = 1, INT(SQRT(REAL(n))) + 1\n      IF (MOD(n, div) .EQ. 0) THEN\n        sm = sm + div\n        q = n \/ div\n        if (q \/= div) sm = sm + q\n      END IF\n    END DO\n    sum_divisors = sm\n  END FUNCTION sum_divisors\n\n  FUNCTION buddy(start, limit) RESULT(str)\n    INTEGER, INTENT(IN):: start, limit\n    INTEGER :: i, sm\n    CHARACTER(:), allocatable :: str\n    CHARACTER (LEN=64) :: tmp\n\n    DO i = start, limit\n      sm = sum_divisors(i) - 1\n      IF (i == sum_divisors(sm) - 1 .AND. i < sm) THEN\n        WRITE(tmp, fmt=\"(A, I0, A, I0, A)\") \"(\", i, \" \", sm, \")\"\n        str = TRIM(tmp)\n        RETURN\n      END IF\n    END DO\n    str = \"Nothing\"\n  END FUNCTION buddy\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83376,"user_id":168,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  integer pure function sum_divs(n) result (s)\n    integer, intent(in) :: n\n    integer :: d\n    s = 0\n    d = 2\n    do while (d * d <= n)\n      if (mod(n, d) == 0) then\n        s = s + d\n        if (d * d \/= n) then\n          s = s + n \/ d\n        end if\n      end if\n      d = d + 1\n    end do\n  end function\n\n  ! returns a string without trailing blanks\n  pure FUNCTION buddy(start, limit) RESULT(str)\n    INTEGER, INTENT(IN) :: start, limit\n    character(:), allocatable :: str\n    character(50) :: buf\n    integer :: n, t\n    do n = start, limit\n      t = sum_divs(n)\n      if (t + 1 > n .and. sum_divs(t) == n) then\n        write (buf,'(a,i0,a,i0,a)') '(', n, ' ', t, ')'\n        str = trim(buf)\n        return\n      end if\n    end do\n    str = 'Nothing'\n  END FUNCTION buddy\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83377,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  ! returns a string without trailing blanks\n  FUNCTION buddy(start, limit) RESULT(str)\n  INTEGER, INTENT(IN):: start, limit\n  INTEGER :: i, j, k, sumofdivisors, buddy2, truth, div, q, istr\n  CHARACTER(:), allocatable :: str, i2, buddy3\n  i = start\n  truth = 0\n  DO i = start, limit\n    sumofdivisors = -i\n    DO div = 1, INT(SQRT(REAL(i))) + 1\n      IF (MOD(i, div) .eq. 0) THEN\n        sumofdivisors = sumofdivisors + div\n        q = i \/ div\n        if (q \/= div) sumofdivisors = sumofdivisors + q\n      END IF\n    END DO\n    buddy2 = sumofdivisors - 1\n    sumofdivisors = -buddy2\n    DO j = 1, INT(SQRT(REAL(buddy2))) + 1\n      IF (MOD(buddy2, j) .eq. 0) THEN\n        sumofdivisors = sumofdivisors + j\n        q = buddy2 \/ j\n        if (q \/= j) sumofdivisors = sumofdivisors + q\n      END IF\n    END DO\n    IF((i .eq. sumofdivisors - 1) .and. i < buddy2) THEN\n        istr = digits(i) + digits(buddy2) + 3\n        allocate(character(len=istr) :: str)\n        write(str, 67)i, buddy2\n        PRINT *, str\n  67    format('(',i0,' ',i0,')')\n        str = TRIM(str)\n        RETURN\n    END IF\n  END DO\n  str = \"Nothing\"\n  END FUNCTION buddy\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83378,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  FUNCTION buddy(start, limit) RESULT(str)\n    INTEGER, INTENT(IN):: start, limit\n    character(:), allocatable :: str\n    Integer :: i, j, a, b, c\n    character(range(i) + 2) :: chara, charb\n\n    str = \"Nothing\"\n    Do i = start, limit\n      a = 0\n      Do j = 2, int(sqrt(1.0D0*i)) + 1\n        If (mod(i,j) == 0) a = a + j + i\/j\n      End Do\n      If (a <= i) cycle\n      \n      b = 0\n      Do j = 2, int(sqrt(1.0D0*a)) + 1\n        If (mod(a,j) == 0) b = b + j + a\/j\n      End Do\n\n      \n      If (b == i) then\n        write (chara,'(I0)') a\n        write (charb,'(I0)') b\n        str = '('\/\/trim(charb)\/\/' '\/\/trim(chara)\/\/')'\n        exit\n      End If\n    End Do\n    \n  END FUNCTION buddy\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83379,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  FUNCTION buddy(start, limit) RESULT(str)\n    INTEGER, INTENT(IN):: start, limit\n    !Integer :: sf\n    character(:), allocatable :: str\n    Integer :: i, j, a, b, c\n    character(range(i) + 2) :: chara, charb\n\n    str = \"Nothing\"\n    Do i = start, limit\n      a = 0\n      Do j = 2, int(sqrt(1.0D0*i)) + 1\n        If (mod(i,j) == 0) a = a + j + i\/j\n      End Do\n      !If ((a < start) .OR. (a > limit)) cycle\n      If (a <= i) cycle\n      \n      b = 0\n      Do j = 2, int(sqrt(1.0D0*a)) + 1\n        If (mod(a,j) == 0) b = b + j + a\/j\n      End Do\n\n      \n      If (b == i) then\n        write (chara,'(I0)') a\n        write (charb,'(I0)') b\n        !If (b > a) then\n          !str = '('\/\/trim(chara)\/\/' '\/\/trim(charb)\/\/')'\n        !Else\n          str = '('\/\/trim(charb)\/\/' '\/\/trim(chara)\/\/')'\n        !End If\n        exit\n      End If\n    End Do\n    \n  END FUNCTION buddy\n\n\n  !Function sf(n) result(sum)\n  !  Integer, intent(in) :: n\n  !  Integer :: i\n  !  Integer :: sum\n  !  sum = 0\n  !  Do i = 1, n\/2\n  !    If (mod(n,i) == 0) sum = sum + i\n  !  End Do\n  !End Function sf\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83380,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION buddy(start, limit) RESULT(str)\n    INTEGER, INTENT(IN):: start, limit\n    character(:), allocatable :: str\n    character(25) tmp\n    integer*8  i, m, n, sm, sn, sqt\n    \n    str = \"\"\n    do n=start, limit\n      sn = 1; sqt=sqrt(1.0*n)\n      do i=2, sqt\n        if (mod(n,i)==0) sn = sn + i + n\/i\n      end do\n      if (sqt*sqt==n) sn = sn - sqt ! If integer square don't add sqt AND n\/sqt !\n      m = sn - 1;  if (m < n+1)  CYCLE\n      \n      sm = 1; sqt=sqrt(1.0*m)\n      do i=2, sqt\n        if (mod(m,i)==0) sm = sm + i + m\/i;  if (sm-sqt > n+1) EXIT\n      end do\n      if (sqt*sqt==m) sm = sm - sqt ! If integer square don't add sqt AND n\/sqt !\n      \n      if (sm == n+1) then\n        write(tmp,\"(A,I0,A,I0,A)\") \"(\", n , \" \", m, \")\"\n        str = trim(str) \/\/ trim(tmp);  EXIT\n      end if\n    end do\n    \n    if (str == \"\") str = \"Nothing\"    \n  END FUNCTION buddy\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"59d9ff9f7905dfeed50000b0":[{"id":83381,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function solve(strArr) result(intArr)\n    character(*), dimension(:), intent(in) :: strArr ! The input array of strings\n    integer, dimension(:), allocatable :: intArr ! The output array to be returned\n    character(*), parameter :: low = 'abcdefghijklmnopqrstuvwxyz'\n    character(*), parameter :: upp = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    integer :: i, j, length\n    \n    length = size(strArr)\n    Allocate (intArr(1:length))\n    \n    Do i = 1, length\n      intArr(i) = 0\n      Do j = 1, len(strArr(i))\n        If (j > len(low)) exit\n        If (strArr(i)(j:j) == low(j:j) .OR. strArr(i)(j:j) == upp(j:j)) intArr(i) = intArr(i) + 1\n      End Do\n    End Do\n  end function solve\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83382,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function solve(strArr) result(intArr)\n    character(*), dimension(:), intent(in) :: strArr ! The input array of strings\n    integer, dimension(size(strArr)) :: intArr ! The output array to be returned\n    intArr = count_(strArr)\n  end function solve\n\n  pure elemental function count_(s) result(n)\n    character(len=*), intent(in) :: s\n    character(len=*), parameter :: low = 'abcdefghijklmnopqrstuvwxyz'\n    character(len=*), parameter :: upp = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    integer :: i, n\n    \n    n = 0\n    do i = 1, min(len_trim(s),len(low))\n      if (s(i:i) == low(i:i) .or. s(i:i) == upp(i:i)) then\n        n = n + 1\n      end if\n    end do\n  end function count_\n    \nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83383,"user_id":168,"body":"module Solution\n  implicit none\ncontains\n  pure function solve(strArr) result(intArr)\n    character(*), dimension(:), intent(in) :: strArr ! The input array of strings\n    integer, dimension(:), allocatable :: intArr ! The output array to be returned\n    integer :: i, j, c\n    allocate(intArr(size(strArr)))\n    do i = 1, size(strArr)\n      c = 0\n      do j = 1, len(strArr(i))\n        if (mod(iachar(strArr(i)(j:j)), 32) == j) then\n          c = c + 1\n        end if\n      end do\n      intArr(i) = c\n    end do\n  end function solve\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83384,"user_id":168,"body":"module Solution\n  implicit none\ncontains\n  function solve(strArr) result(intArr)\n    character(*), dimension(:), intent(in) :: strArr ! The input array of strings\n    integer, dimension(:), allocatable :: intArr ! The output array to be returned\n    integer :: i, j, c\n    allocate(intArr(size(strArr)))\n    do i = 1, size(strArr)\n      c = 0\n      do j = 1, len(strArr(i))\n        if (or(iachar(strArr(i)(j:j)), 32) == j + 96) then\n          c = c + 1\n        end if\n      end do\n      intArr(i) = c\n    end do\n  end function solve\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83385,"user_id":76,"body":"module Solution\n  implicit none\ncontains\n  pure function solve(strArr) result(intArr)\n    character(*), dimension(:), intent(in) :: strArr \n    integer, dimension(:), allocatable :: intArr \n    integer :: i, j, ic, ct, sz\n    character(len = 26) :: alphabet, w\n    \n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    sz = size(strArr)\n    allocate(intArr(sz))\n    \n    do i = 1, sz\n      ct = 0\n      w = strArr(i)\n      do j = 1, MIN(len(strArr(i)), 26)\n        ic = ichar(w(j:j))\n        if (ic >= 65 .and. ic <= 90) ic = ic + 32\n        if (achar(ic) .eq. alphabet(j:j)) ct = ct + 1\n      end do\n      intArr(i) = ct\n    end do\n    \n  end function solve\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83386,"user_id":null,"body":"module Solution\n    implicit none\n  contains\n    pure function solve(strArr) result(intArr)\n      character(*), dimension(:), intent(in) :: strArr ! The input array of strings\n      integer, dimension(:), allocatable :: intArr ! The output array to be returned\n      character(26),parameter::lower='abcdefghijklmnopqrstuvwxyz'\n      character(26),parameter::upper='ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n      integer::i,j,length,res\n\n      length=size(strArr)\n      allocate(intArr(1:length))\n      do i=1,length\n        res=0\n        do j=1,len(strArr(i))\n            if (strArr(i)(j:j)==lower(j:j) .or. strArr(i)(j:j)==upper(j:j)) then\n                res=res+1\n            end if\n            if (j>26) exit\n        intArr(i)=res\n        end do\n      end do\n    end function solve\n  end module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83387,"user_id":null,"body":"module Solution\n  implicit none\n  character(len=*), parameter :: lChar = \"abcdefghijklmnopqrstuvwxyz\"\n  character(len=*), parameter :: uChar = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  \n  contains\n  \n  pure function solve(strArr) result(intArr)\n    character(*), dimension(:), intent(in) :: strArr \n    integer, dimension(size(strArr)) :: intArr\n    intArr = count_matched(strArr)\n  end function solve\n  \n  integer elemental function count_matched(str)\n    character(len=*), intent(in) :: str\n    integer :: i\n    count_matched = 0\n    do i=1,len(trim(str))\n        if ((i==index(lChar,str(i:i))).or.(i==index(uChar,str(i:i)))) then\n            count_matched = count_matched + 1\n        end if\n    end do\n  end function count_matched\n\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83388,"user_id":null,"body":"module Solution\n  implicit none\n  character(len=26), parameter :: llist = \"abcdefghijklmnopqrstuvwxyz\"\n  character(len=26), parameter :: ulist = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\ncontains\n  pure function solve(strArr) result(intArr)\n    character(*), dimension(:), intent(in) :: strArr ! The input array of strings\n    integer, dimension(:), allocatable :: intArr ! The output array to be returned\n    \n    integer :: i, j, n, m\n    \n    allocate(intArr(size(strArr)))\n    \n    n = 0\n    m = 0\n    \n    do i=1,size(strArr),1\n      do j=1,len(trim(strArr(i)))\n        n = index(llist,strArr(i)(j:j)) + index(ulist,strArr(i)(j:j))\n        if (n==j) then\n          m = m + 1\n        end if\n      end do\n      intArr(i) = m\n      m = 0\n    end do\n    \n  end function solve\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83389,"user_id":17,"body":"module Solution\n  implicit none\ncontains\n  pure function solve(strArr) result(intArr)\n    character(*), dimension(:), intent(in) :: strArr\n    integer, dimension(:), allocatable :: intArr\n    integer :: i, j, c\n    allocate(intArr(size(strArr)))\n    do i = 1, size(strArr)\n      intArr(i) = 0\n      do j = 1, len(trim(strArr(i)))\n        c = ichar(strArr(i)(j:j))\n        if (c >= 97 .and. c < 123) then\n          c = c - 32\n        end if\n        if (c >= 65 .and. c < 91 .and. c == j + 64) then\n          intArr(i) = intArr(i) + 1\n        end if\n      end do\n    end do\n  end function solve\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"59f38b033640ce9fc700015b":[{"id":83390,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function total(a)\n    integer, dimension(:), intent(in) :: a\n    logical :: primes(size(a))\n    integer :: i, j\n    total = 0\n    primes = .true.\n    \n    do i = 2, size(a)\n      if (primes(i)) then\n        total = total + a(i)\n        \n        do j = i*i, size(a), i\n          primes(j) = .false.\n        end do\n      end if\n    end do\n  end function total\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83391,"user_id":53,"body":"module Solution\n\n  implicit none\n  private :: isPrime\n  public :: total\n  \ncontains\n\n  pure function isPrime(n) result(res)\n    integer, intent(IN) :: n\n    integer :: i\n    LOGICAL :: res\n    if (n < 2) then\n      res = .FALSE.\n      return\n    end if\n    if (mod(n, 2) == 0) then\n      res = (n == 2)\n      return\n    end if\n    do i = 3, int(sqrt(real(n))), 2\n      if (mod(n, i) == 0) then\n        res = .FALSE.\n        return\n      end if\n    end do\n    res = .TRUE.\n  end function isPrime\n  \n  integer pure function total(a)\n    integer, dimension(:), intent(in) :: a\n    integer :: i\n    total = 0\n    do i = 1, size(a)\n      if (isPrime(i)) then\n        total = total + a(i)\n      end if\n    end do\n  end function total\n  \nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83392,"user_id":null,"body":"module Solution\n  implicit none\n  private\n  \n  logical, allocatable :: sieve(:)\n  integer :: sieve_size = 0\n  \n  public :: total\ncontains\n  integer function total(a)\n    integer, dimension(:), intent(in) :: a\n    integer :: a_size\n    \n    total = 0 ! TODO\n    a_size = size(a, dim=1)\n\n    if (a_size < 2) return\n    if (a_size > sieve_size) call add_prime_nums(a_size)\n    \n    total = sum(a, mask=sieve(1:a_size))\n  end function total\n  \n  subroutine add_prime_nums(threshold)\n    integer, intent(in) :: threshold\n    logical, allocatable :: temp(:)\n    integer :: old_sieve_size\n    integer :: i, factor\n    \n    if (threshold > sieve_size .and. threshold >= 2) then\n      if (allocated(sieve)) then\n        allocate(temp(threshold))\n\n        temp(1:sieve_size) = sieve(1:sieve_size)\n        temp(sieve_size+1: threshold) = .true.\n        call move_alloc(temp, sieve)\n\n        old_sieve_size = sieve_size\n      else\n        allocate(sieve(threshold))\n        sieve(1) = .false.\n        sieve(2:) = .true.\n        old_sieve_size = 0\n      end if\n\n      sieve_size = threshold\n      i = 2\n\n      ! Generate the prime numbers using the sieve of Erathosthenes\n      do while(i <= threshold)\n        if (sieve(i)) then\n          if (i < old_sieve_size) then\n            factor = old_sieve_size + mod(old_sieve_size, i)\n          else\n            factor = 2*i\n          end if\n          factor = 2*i\n\n          do while(factor <= threshold)\n            sieve(factor) = .false.\n            factor = factor + i\n          end do\n        end if\n        \n        i = i + 1\n      end do\n    end if\n  end subroutine add_prime_nums\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83393,"user_id":null,"body":"module Solution\n  implicit none\n  private\n  public :: total\ncontains\n  integer pure function total(a)\n  integer, dimension(:), intent(in) :: a\n  integer :: i, j, x\n  total = 0\n  DO i = 2, SIZE(a)\n    j = 0\n    x = 2\n    DO WHILE ((x .lt. i))\n      IF (MOD(i,x) .eq. 0) THEN\n        j = 1\n      END IF\n      x = x+1\n    END DO\n    IF(j .eq. 0) THEN\n      total = total + a(i)\n    END IF\n  END DO\n  end function total\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83394,"user_id":null,"body":"module Solution\n  implicit none\n  private\n  public :: total\ncontains\n  integer pure function total(a)\n    implicit none\n    \n    integer, dimension(:), intent(in) :: a\n    integer, dimension(size(a))       :: primes\n    integer  ::  i, divisor\n    \n    total = a(2)\n    \n    do i = 3, size(a), 2\n       divisor = 3\n       do\n          if(divisor**2 > i .or. mod(i,divisor) .eq. 0) exit\n          divisor = divisor + 2\n       end do\n       if (divisor**2 > i) total = total + a(i)\n    end do\n  \n  \n  end function total\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83395,"user_id":null,"body":"module Solution\n  implicit none\n  private\n  public :: total\ncontains\n  logical pure function isPrime(n)\n    integer, intent(in)   :: n\n    \n    integer               :: i, sqrtn\n    \n    isPrime = .true.\n    \n    if (n <= 1) then\n      isPrime = .false.\n      return\n    end if \n    \n    if (n <= 3) return\n    \n    if (mod(n, 2) == 0 .or. mod(n, 3) == 0) then\n      isPrime = .false.\n      return\n    end if\n    \n    sqrtn = int(sqrt(real(n)))\n    \n    do i = 5, sqrtn, 6\n      if (mod(n, i) == 0 .or. mod(n, i + 2) == 0) then\n        isPrime = .false.\n        return\n      end if\n    end do\n    \n  end function\n    \n\n  integer pure function total(a)\n    integer, dimension(:), intent(in) :: a\n    integer                  :: i, n\n    \n    total = 0 \n    n = size(a, 1)\n    \n    do i = 2, n\n      if (isPrime(i)) total = total + a(i)\n    end do\n    \n  end function total\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83396,"user_id":null,"body":"module Solution\n  implicit none\n  private\n  public :: total\ncontains\n  integer pure function total(a)\n    integer, dimension(:), intent(in) :: a\n    \n    integer :: i\n    integer, dimension(size(a)) :: b\n    \n    b = (\/(i,i=1,size(a))\/)\n    \n    where (prime(b))\n      b = a(b)\n    else where\n      b = 0\n    end where\n    \n    total = sum(b(2:))\n    \n  end function total\n  \n  logical elemental function prime(num)\n    integer, intent(in) :: num\n    integer :: i\n    prime = .true.\n    do i=2,num\/2,1\n      if(mod(num,i)==0) then\n        prime = .false.\n        return\n      end if\n    end do\n  end function prime\n  \nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83397,"user_id":null,"body":"module Solution\n  implicit none\n  private\n  public :: total\ncontains\n  integer pure function total(a)\n    integer, dimension(:), intent(in) :: a\n    \n    integer :: i\n    integer, dimension(size(a)) :: b\n  \n    b=a\n    do concurrent (i=1:size(a):1,.not.prime(i))\n      b(i)=0\n    end do\n    total=sum(b(2:))\n    \n  end function total\n  \n  logical pure function prime(num)\n    implicit none\n    integer, intent(in) :: num\n    integer :: i\n    prime = .true.\n    do i=2,num\/2,1\n      if(mod(num,i)==0) then\n        prime = .false.\n        return\n      end if\n    end do\n  end function prime\n  \nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83398,"user_id":null,"body":"module Solution\n  implicit none\n  private\n  public :: total\ncontains\n  integer pure function total(a)\n    integer, dimension(:), intent(in) :: a\n    integer::i,j,count,n\n    real::ii\n    total = 0 ! TODO\n    n=size(a)\n    do i=2,n\n      count=0\n      ii=i\n      do j=2,floor(sqrt(ii))\n        if(0==mod(i,j))then\n          count=count+1\n          exit\n        end if\n      end do\n      \n      if (count==0)then\n        total=total+a(i)\n      end if\n    end do\n  end function total\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83399,"user_id":null,"body":"module Solution\n  implicit none\n  private\n  public :: total\ncontains\n  integer pure function total(a)\n    integer, dimension(:), intent(in) :: a\n    integer::i,j,n,count\n    real::ii\n    total = 0 ! TODO\n    n=size(a)\n    do i = 2,n\n      count=0\n      ii=i\n      do j=2,floor(sqrt(ii))\n        if(0==mod(i,j)) then\n          count= count+1\n          exit\n        end if\n      end do\n      if (count==0) then\n        total=total+a(i)\n      end if\n    end do\n    \n  end function total\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5a00e05cc374cb34d100000d":[{"id":83400,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function reverse_seq(n)\n    integer, intent(in) :: n\n    integer, dimension(:), allocatable :: reverse_seq\n    integer :: i\n    reverse_seq = [(i, i = n, 1, -1)]\n  end function reverse_seq\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83401,"user_id":564,"body":"module Solution\n  implicit none\ncontains\n  pure function reverse_seq(n)\n    integer, intent(in) :: n\n    integer, dimension(:), allocatable :: reverse_seq\n    integer :: i\n    \n    reverse_seq = (\/ (i, i=n, 1, -1) \/)\n\n  end function reverse_seq\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83402,"user_id":168,"body":"module Solution\n  implicit none\ncontains\n  pure function reverse_seq(n)\n    integer, intent(in) :: n\n    integer, dimension(:), allocatable :: reverse_seq\n    integer :: i\n    allocate(reverse_seq(n))\n    reverse_seq(:) = [(n - i + 1, i = 1, n)]\n  end function reverse_seq\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83403,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function reverse_seq(n)\n    integer, intent(in) :: n\n    integer, dimension(n) :: reverse_seq\n    integer :: i\n    reverse_seq = [(i, i = n, 1, -1)]\n  end function reverse_seq\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83404,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function reverse_seq(n)\n    integer, intent(in) :: n\n    integer, dimension(:), allocatable :: reverse_seq\n    integer i\n    reverse_seq = (\/(i, i = n, 1, -1)\/)      \n  end function reverse_seq\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83405,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function reverse_seq(n)\n    integer, intent(in) :: n\n    integer, dimension(:), allocatable :: reverse_seq(:)\n    integer :: i\n    allocate(reverse_seq(1:n))\n    do i = 1, n\n        reverse_seq(i) = n + 1 - i \n    end do\n  end function reverse_seq\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83406,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function reverse_seq(n)\n    integer, intent(in) :: n\n    integer :: reverse_seq(n)\n    integer :: i\n    reverse_seq=(\/(i,i=n,1,-1)\/)\n    ! TODO\n  end function reverse_seq\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83407,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function reverse_seq(n)\n    integer, intent(in) :: n\n    integer, dimension(:), allocatable :: reverse_seq\n    integer :: i\n    \n    allocate(reverse_seq(1:n))\n    \n    do i = 1, n\n      reverse_seq(i) = n - (i - 1)\n    end do\n    \n  end function reverse_seq\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83408,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function reverse_seq(n)\n    integer, intent(in)                 :: n          ! Sequence length\n    integer                             :: i          ! Sequence index\n    integer, dimension(:), allocatable  :: reverse_seq ! Return value\n    \n    allocate(reverse_seq(n))\n    \n    ! Assign elements\n    do i=1,n\n        reverse_seq(i) = n - i + 1\n    end do\n    \n  end function reverse_seq\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83409,"user_id":53,"body":"module Solution\n  implicit none\ncontains\n  pure function reverse_seq(n)\n    integer, intent(in) :: n\n    integer, dimension(:), allocatable :: reverse_seq\n    integer :: m, i\n    allocate(reverse_seq(n))\n    m = n\n    i = 1\n    do while (m > 0)\n      reverse_seq(i) = m\n      m = m - 1\n      i = i + 1\n    end do\n  end function reverse_seq\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5a02cf76c9fc0ee71d0000d5":[{"id":83410,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\n  PUBLIC :: series\n  PRIVATE :: zeta, bernoulli, fact, pow\n\nCONTAINS\n\n    FUNCTION series(k, nb) RESULT(res)\n        INTEGER, INTENT(IN) :: k, nb\n        DOUBLE PRECISION :: res, pi\n        pi = 3.14159265358979D0\n        if (k > 0) then\n          if (mod(k, 2) == 0) then\n            res = (pow(REAL(2,8), REAL(k - 1,8)) * pow(pi, REAL(k,8)) * abs(bernoulli(k))) \/ fact(k)\n          else\n            res = zeta(k, nb)\n          end if\n        else\n          res = bernoulli(1 - k) \/ (1 - k)\n          if (mod(k, 2) \/= 0) then\n            res = -1.0 * res\n          end if\n        end if\n    END FUNCTION\n    \n    RECURSIVE FUNCTION zeta(k, precision) RESULT(res)\n        INTEGER, INTENT(IN) :: k, precision\n        INTEGER :: n\n        DOUBLE PRECISION :: res, pi\n        pi = 3.14159265358979D0\n        if (k < 2) then\n          res = 2.0 * pow(2.0 * pi, REAL(k - 1,8)) * cos(pi * (1 - k) * 0.5) * fact(-k) * zeta(1 - k, 2000000)\n        else\n          res = 0\n          n = 1\n          do while (n < precision)\n            res = res + pow(REAL(n,8), REAL(-k,8))\n            n = n + 1\n          end do\n        end if\n    END FUNCTION\n    \n    FUNCTION bernoulli(k) RESULT(res)\n        INTEGER, INTENT(IN) :: k\n        DOUBLE PRECISION :: res\n        res = 1.0 * k * zeta(1 - k, 2000000)\n        if (mod(k, 2) == 0) then\n          res = -1.0 * res\n        end if\n    END FUNCTION\n    \n    RECURSIVE FUNCTION fact(n) RESULT(res)\n        INTEGER, INTENT(IN) :: n\n        DOUBLE PRECISION :: res\n        if (n == 0) then\n          res = 1.0\n        else\n          res = n * fact(n - 1)\n        end if\n    END FUNCTION\n    \n    FUNCTION pow(n, k) RESULT(res)\n        DOUBLE PRECISION, INTENT(IN) :: n, k\n        DOUBLE PRECISION :: res\n        res = n ** k\n    END FUNCTION\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83411,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\n  PRIVATE :: bern, nbern, factorial, siterative\n  PUBLIC :: series\n\nCONTAINS\n\n    SUBROUTINE bern(n, bn)\n        INTEGER :: n\n        DOUBLE PRECISION, INTENT(INOUT), DIMENSION(0:n) :: bn\n        DOUBLE PRECISION :: s, r\n        INTEGER :: m, k, j\n\n        bn = 0.0D0\n        bn(0) = 1.0D0\n        bn(1) = -0.5D0\n        DO m = 2, n\n          s = -(1.0D0 \/ (M + 1.0D0) - 0.5D0)\n          DO k = 2, m - 1\n            r = 1.0D0\n              DO j = 2, k\n                  r = r * (j + m - k) \/ j\n              END DO\n              s = s - r * bn(k)\n          END DO\n          bn(m) = s\n        END DO\n        DO m = 3, n, 2\n            bn(m)= 0.0D0\n        END DO\n        RETURN\n    END SUBROUTINE\n\n    FUNCTION nbern(n) RESULT(res)\n        INTEGER :: n\n        DOUBLE PRECISION, DIMENSION(0:n) :: bn\n        DOUBLE PRECISION :: res\n\n        CALL bern(n, bn)\n        res = bn(n)\n    END FUNCTION\n\n    FUNCTION factorial(n) RESULT(res)\n        INTEGER(8), INTENT(IN) :: n\n        INTEGER(8) :: i, res\n\n        res = 1_8\n        DO i = 1_8, n\n            res = res * i\n        END DO\n    END FUNCTION\n\n    FUNCTION siterative(n, nterms) RESULT(res)\n        INTEGER, INTENT(IN) :: n, nterms\n        INTEGER :: i\n        DOUBLE PRECISION :: res\n\n        res = 0.0D0\n        DO i = 1, nterms\n            res = res + (1.0D0 \/ (DBLE(i) ** n))\n        END DO\n    END FUNCTION\n\n    FUNCTION series(n, nb) RESULT(res)\n        INTEGER, INTENT(IN) :: n, nb\n        DOUBLE PRECISION :: res\n        DOUBLE PRECISION :: pi\n\n        pi = 3.14159265358979D0\n        IF (n > 0) THEN\n            IF (MOD(n, 2) == 1) THEN\n                res = siterative(n, nb)\n            ELSE\n                res = 0.5D0 * ABS(nbern(n)) * ((2.0D0 * pi) ** n) \/ factorial(INT(n, 8))\n            END IF\n        ELSE\n            res = (-1.0D0 ** (-n)) * nbern(1 - n) \/ (1 - n)\n        END IF\n    END FUNCTION\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5a03b3f6a1c9040084001765":[{"id":83412,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure recursive function angle(n) result(res)\n    integer, intent(in) :: n\n    if (n == 2) then \n      res = 0\n    else \n      res = angle(n - 1) + 180\n      end if\n  end function angle\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83413,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function angle(n) result(degrees)\n    integer, intent(in) :: n\n    integer :: degrees\n    degrees = (n-2)*180\n  end function angle\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83414,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function angle(n)\n    integer, intent(in) :: n\n    angle = (n-2)*180 ! n-2 triangles, each has a sum of angles of 180 deg\n  end function angle\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83415,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function angle(n)\n    integer, intent(in) :: n\n    angle = 180 * n  - 360 ! TODO\n  end function angle\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83416,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function angle(n)\n    integer, intent(in) :: n\n    angle = n*180-360 ! TODO\n  end function angle\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83417,"user_id":862,"body":"module Solution\n  implicit none\ncontains\n  integer pure function angle(n)\n    integer, intent(in) :: n\n    angle =  180*(n-2) ! TODO\n  end function angle\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83418,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function angle(n)\n    integer, intent(in) :: n\n    angle = 180*(n-2) ! the sum of internal angles in a polygon is equal to 180*(number_of_sides-2)\n  end function angle\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83419,"user_id":null,"body":"module Solution\n\n  implicit none\n\ncontains\n\n  integer pure function angle(n)\n    integer, intent(in) :: n\n    angle = (n-2)*180 ! TODO\n  end function angle\n\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83420,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function angle(n)\n    integer, intent(in) :: n\n    angle = (n-2)*180\n  end function angle\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83421,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function angle(n)\n    integer, intent(in) :: n\n    angle =  180*n - 360\n  end function angle\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5a045fee46d843effa000070":[{"id":83422,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION decomp(n) RESULT(str)\n    INTEGER :: n, m\n    INTEGER, DIMENSION(1:n):: prime_power\n    INTEGER :: befn, i\n    CHARACTER(:), allocatable :: str\n    CHARACTER (LEN=64) :: tmp\n    \n    prime_power = 0; str = \"\"; m = n\n    DO WHILE (m > 1)\n      befn = m; m = m - 1; i = 2\n      DO WHILE (i * i <= befn)\n        IF (MOD(befn, i) == 0) THEN\n          befn = befn \/ i\n          prime_power(i) = prime_power(i) + 1\n          i = 1\n        END IF\n        i = i + 1\n      END DO\n      prime_power(befn) = prime_power(befn) + 1\n    END DO\n    DO i = 2, SIZE(prime_power)\n        tmp = \"\"\n        m = prime_power(i)\n        if (m == 1) THEN\n            WRITE(tmp, fmt=\"(1X, I0, A)\") i, \" *\"\n        ELSE IF (m > 1) THEN\n            WRITE(tmp, fmt=\"(1X, I0, A, I0, A)\") i, \"^\", m, \" *\"\n        END IF\n        str = TRIM(str) \/\/ tmp\n    END DO \n    m = LEN_TRIM(str)\n    str = str(2:m - 2)\n  END FUNCTION decomp\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83423,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION decomp(n) result(res)\n    INTEGER :: n\n    integer :: prime(5000), c(5000)\n    logical :: isnprime(5000) = .false.\n    character(:), allocatable :: res\n    character(128) :: stmp\n    integer :: cnt, i, j\n    res = \"\"\n    cnt = 0\n    c(:) = 0\n    do i = 2, n\n      if (.not. isnprime(i)) then\n        cnt = cnt + 1\n        prime(cnt) = i\n      end if\n      do j = 1, cnt\n        if (prime(j) * i > n) then\n          exit\n        end if\n        isnprime(prime(j) * i) = .true.\n        if (mod(i, prime(j)) == 0) then\n          exit\n        end if\n      end do\n    end do\n    do i = 1, cnt\n      j = prime(i)\n      do while (j <= n)\n        c(i) = c(i) + n \/ j\n        j = j * prime(i)\n      end do\n    end do\n    write(stmp, \"(I0,A,I0)\") prime(1), \"^\", c(1)\n    res = trim(res) \/\/ trim(stmp)\n    do i = 2, cnt\n      if (c(i) == 1) then\n        write(stmp, \"(A,I0)\") \" * \", prime(i)\n      else\n        write(stmp, \"(A,I0,A,I0)\") \" * \", prime(i), \"^\", c(i)\n      end if\n      res = trim(res) \/\/ trim(stmp)\n    end do\n  END FUNCTION decomp\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83424,"user_id":168,"body":"module Solution\n  implicit none\ncontains\n  pure function is_prime(n)\n    integer, intent(in) :: n\n    logical :: is_prime\n    integer :: d\n    if (n <= 2 .or. mod(n, 2) == 0) then\n      is_prime = n == 2\n    else\n      d = 3\n      do while (d * d <= n)\n        if (mod(n, d) == 0) then\n          is_prime = .false.\n          return\n        end if\n        d = d + 2\n      end do\n      is_prime = .true.\n    end if\n  end function is_prime\n    \n\n  function decomp(n)\n    integer, intent(in) :: n\n    character(:), allocatable :: decomp\n    character(20) :: buf\n    integer :: p, e, k, m\n    decomp = \"\"\n    do p = 2, n\n      if (is_prime(p)) then\n        e = 0\n        do k = p, n\n          m = k\n          do while (mod(m, p) == 0)\n            e = e + 1\n            m = m \/ p\n          end do\n        end do\n        if (e > 1) then\n          write(buf,'(i0,A,i0)') p, \"^\", e\n        else\n          write(buf,'(i0)') p\n        end if\n        if (p > 2) then\n          decomp = decomp \/\/ \" * \"\n        end if\n        decomp = decomp \/\/ trim(buf)\n      end if\n    end do\n  end function decomp\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83425,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION decomp(n) RESULT(str)\n    INTEGER, INTENT(IN) :: n\n    CHARACTER(:), ALLOCATABLE :: str\n    CHARACTER(100) :: tmp\n    LOGICAL :: primes(n)\n    INTEGER :: i, j, j_, cpc ! currentPrimeCount\n    str = \"\"\n    primes = .TRUE.\n    \n    DO i = 2, n\n      IF (.NOT. primes(i)) CYCLE\n      \n      cpc = 0\n      DO j = i, n, i\n        primes(j) = .FALSE.\n        \n        ! If i is prime, add 1 for each power of i for each number to n\n        j_ = j\n        DO WHILE (MODULO(j_, i) .EQ. 0)\n          cpc = cpc + 1\n          j_ = j_ \/ i\n        END DO\n      END DO\n      \n      SELECT CASE (cpc)\n        CASE (0)\n          CYCLE\n        CASE (1)\n          WRITE(tmp, \"(i0)\") i\n          str = str \/\/ TRIM(tmp) \/\/ \" * \"\n        CASE DEFAULT\n          WRITE(tmp, \"(i0)\") i\n          str = str \/\/ TRIM(tmp) \/\/ \"^\"\n          WRITE(tmp, \"(i0)\") cpc\n          str = str \/\/ TRIM(tmp) \/\/ \" * \"\n      END SELECT\n    END DO\n    \n    str = str(1:LEN(str)-3)\n  END FUNCTION decomp\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83426,"user_id":null,"body":"module solution\n\n\timplicit none\n\n\tcontains\n\t\n\tpure logical function is_prime(num)\n\t\tinteger,intent(in) :: num\n\t\tinteger :: i\n\t\tis_prime = .true.\n\t\tif(num==2) return\n\t\tis_prime = .false.\n\t\tif(mod(num,2)==0) return\n\t\tdo i=3,num\/2,2\n\t\t\tif(mod(num,i)==0) return\n\t\tend do\n\t\tis_prime = .true.\n\tend function is_prime\n\t\n\tpure integer function max_prime(num) \n\t\tinteger,intent(in) :: num\n\t\tinteger :: i,j\n\t\tj = num\n\t\tif(mod(num,2)==0) j=num-1\n\t\tdo i=j,2,-2\n\t\t\tif(is_prime(i))then\n\t\t\t\tmax_prime = i\n\t\t\t\treturn\n\t\t\tendif\n\t\tend do\n\tend function max_prime\n\t\n\tpure subroutine get_primes(num,list)\n\t\tinteger,intent(in) :: num\n\t\tinteger,dimension(:),allocatable,intent(out) :: list\n\t\tinteger :: lim\n\t\tinteger,dimension(:),allocatable :: arr\n\t\tinteger :: i,j\n\t\tlim = max_prime(num)\n\t\tallocate(arr(lim-1))\n\t\tdo i=1,lim-2,1\n\t\t\tif(is_prime(i+1))then\n\t\t\t\tarr(i) = i+1\n\t\t\telse\n\t\t\t\tarr(i) = 0\n\t\t\tend if\n\t\tend do\n\t\tarr(lim-1) = lim\n\t\tallocate(list(size(arr)-count(arr==0)))\n\t\tj = 1\n\t\tdo i=1,lim-1,1\n\t\t\tif(arr(i)\/=0) then\n\t\t\t\tlist(j) = arr(i)\n\t\t\t\tj=j+1\n\t\t\tend if\n\t\tend do\n\tend subroutine get_primes\n\t\n\tpure integer function power(num,mul)\n\t\tinteger,intent(in) :: num\n\t\tinteger,intent(in) :: mul\n\t\tinteger :: i\n\t\tpower = 0\n\t\ti = num\n\t\tdo\n\t\t\tif(mod(i,mul)\/=0)then\n\t\t\t\treturn\n\t\t\telse if(mod(i,mul)==0)then\n\t\t\t\tpower = power + 1\n\t\t\t\ti = i\/mul\n\t\t\tend if\n\t\tend do\n\tend function power\n\t\n  pure function decomp(n)\n    integer,intent(in) :: n   \n    character(len=:),allocatable :: decomp\n    integer,dimension(:),allocatable :: arr1, arr2\n    integer :: m\n    integer :: i, j\n    character(len=100) :: cha1, cha2\n    call get_primes(n,arr1)\n    m = size(arr1)\n    allocate(arr2(m))\n    arr2 = 0\n    do i=2,n,1\n\t\t  do j=1,m,1\n\t\t\t  arr2(j) = arr2(j) + power(i,arr1(j))\n\t\t  end do\n    end do\n    decomp = \"\"\n    do i=1,m,1\n      write(cha1,*) arr1(i)\n      if (arr2(i)==1) then\n        write(cha2,*) \"\"\n      else\n        write(cha2,*) arr2(i)\n        cha2 = \"^\"\/\/adjustl(trim(cha2))\n      end if\n      decomp = decomp\/\/trim(adjustl(cha1))\/\/trim(adjustl(cha2))\/\/\" * \"\n    end do\n    m = len(decomp)-1\n    decomp(m:m) = \"\"\n    decomp = trim(decomp)\n  end function decomp\n  \nend module solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83427,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION decomp(n) result(str)\n    INTEGER :: n, i, del, j\n    character(len=:), allocatable :: str2, str\n    character(len=64) :: tmp\n    integer, allocatable :: arr(:)\n    allocate(arr(n))\n    str2 = \"\"\n    do i = 1, n\n      arr(i) = 0\n    end do\n    do i = 2, n\n      del = i\n      j = 2\n      do while (j.le.i\/2 .and. del .ne. 1)\n        do while(mod(del, j) .eq. 0)\n          arr(j) = arr(j) + 1\n          del = del \/ j\n        end do\n        j = j + 1\n      end do\n      if(del .ne. 1) then\n        arr(del) = arr(del) + 1\n      end if\n    end do\n    do i = 1, n\n      if(arr(i) .gt. 1) then\n        write(tmp, \"(I0, A, I0)\") i, \"^\", arr(i)\n        str2 = str2 \/\/ \" * \" \/\/ trim(tmp)\n      else if(arr(i) .eq. 1) then\n        write(tmp, \"(I0)\") i\n        str2 = str2 \/\/ \" * \" \/\/ trim(tmp)\n      end if\n    end do\n    str = str2(4:)\n  END FUNCTION decomp\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83428,"user_id":17,"body":"MODULE Solution\n  IMPLICIT NONE\n  PRIVATE\n  PUBLIC :: decomp\n  TYPE KeyValuePair\n    INTEGER :: key, value\n  END TYPE KeyValuePair\n  TYPE Map\n    TYPE(KeyValuePair) :: entry\n    TYPE(Map), POINTER :: next\n  END TYPE Map\nCONTAINS\n  RECURSIVE SUBROUTINE map_set(this, key, value)\n    TYPE(Map), POINTER :: this\n    INTEGER, INTENT(IN) :: key, value\n    IF (.NOT. ASSOCIATED(this)) THEN\n      ALLOCATE(this)\n      this%entry%key = key\n      this%entry%value = value\n      this%next => NULL()\n    ELSE IF (this%entry%key == key) THEN\n      this%entry%value = value\n    ELSE\n      CALL map_set(this%next, key, value)\n    END IF\n  END SUBROUTINE map_set\n  INTEGER RECURSIVE FUNCTION map_get_or_zero(this, key) RESULT(value)\n    TYPE(Map), POINTER :: this\n    INTEGER, INTENT(IN) :: key\n    IF (.NOT. ASSOCIATED(this)) THEN\n      value = 0\n    ELSE IF (this%entry%key == key) THEN\n      value = this%entry%value\n    ELSE\n      value = map_get_or_zero(this%next, key)\n    END IF\n  END FUNCTION map_get_or_zero\n  FUNCTION decomp(n)\n    INTEGER, INTENT(IN) :: n\n    CHARACTER(:), ALLOCATABLE :: decomp\n    INTEGER :: i, j, m\n    TYPE(Map), POINTER :: prime_factor_occurrences, temp\n    CHARACTER(11) :: buf\n    decomp = \"\"\n    prime_factor_occurrences => NULL()\n    DO i = 2, n\n      m = i\n      DO WHILE (MOD(m, 2) == 0)\n        CALL map_set(prime_factor_occurrences, 2, &\n          map_get_or_zero(prime_factor_occurrences, 2) + 1&\n        )\n        m = m \/ 2\n      END DO\n      DO j = 3, FLOOR(SQRT(REAL(i))), 2\n        DO WHILE (MOD(m, j) == 0)\n          CALL map_set(prime_factor_occurrences, j, &\n            map_get_or_zero(prime_factor_occurrences, j) + 1&\n          )\n          m = m \/ j\n        END DO\n      END DO\n      IF (m \/= 1) THEN\n        CALL map_set(prime_factor_occurrences, m, &\n          map_get_or_zero(prime_factor_occurrences, m) + 1&\n        )\n      END IF\n    END DO\n    IF (ASSOCIATED(prime_factor_occurrences)) THEN\n      WRITE(buf, \"(I0)\") prime_factor_occurrences%entry%key\n      decomp = decomp \/\/ TRIM(buf)\n      IF (prime_factor_occurrences%entry%value > 1) THEN\n        WRITE(buf, \"(I0)\") prime_factor_occurrences%entry%value\n        decomp = decomp \/\/ '^' \/\/ TRIM(buf)\n      END IF\n      temp => prime_factor_occurrences%next\n      DEALLOCATE(prime_factor_occurrences)\n      prime_factor_occurrences => temp\n      DO WHILE (ASSOCIATED(prime_factor_occurrences))\n        WRITE(buf, \"(I0)\") prime_factor_occurrences%entry%key\n        decomp = decomp \/\/ \" * \" \/\/ TRIM(buf)\n        IF (prime_factor_occurrences%entry%value > 1) THEN\n          WRITE(buf, \"(I0)\") prime_factor_occurrences%entry%value\n          decomp = decomp \/\/ '^' \/\/ TRIM(buf)\n        END IF\n        temp => prime_factor_occurrences%next\n        DEALLOCATE(prime_factor_occurrences)\n        prime_factor_occurrences => temp\n      END DO\n    END IF\n  END FUNCTION decomp\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83429,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION decomp(n)\n    INTEGER :: n\n    CHARACTER(:), ALLOCATABLE :: decomp\n    character(4)    :: temp\n    character(5000) :: rslt\n    integer*2 y, m, i, j, f(551), g(551), maxC, np\n\n    maxC = len(rslt);       np = size(f)\n    f = (\/(0, i=1,np)\/);    g =(\/(0, i=1,np)\/)\n    decomp = \"\"\n    \n! The first 551 primes are readily available, let's use a\n! bit of memory to avoid endlessly checking for primality.     \n  f(1:300) = (\/2,3,5,7,11,13,17,19,23,29,     &\n    31,37,41,43,47,53,59,61,67,71,            &\n    73,79,83,89,97,101,103,107,109,113,       &\n    127,131,137,139,149,151,157,163,167,173,  &\n    179,181,191,193,197,199,211,223,227,229,  &\n    233,239,241,251,257,263,269,271,277,281,  &\n    283,293,307,311,313,317,331,337,347,349,  &\n    353,359,367,373,379,383,389,397,401,409,  &\n    419,421,431,433,439,443,449,457,461,463,  &\n    467,479,487,491,499,503,509,521,523,541,  &\n    547,557,563,569,571,577,587,593,599,601,  &\n    607,613,617,619,631,641,643,647,653,659,  &\n    661,673,677,683,691,701,709,719,727,733,  &\n    739,743,751,757,761,769,773,787,797,809,  &\n    811,821,823,827,829,839,853,857,859,863,  &\n    877,881,883,887,907,911,919,929,937,941,  &\n    947,953,967,971,977,983,991,997,1009,1013,          &\n    1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,  &\n    1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,  &\n    1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,  &\n    1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,  &\n    1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,  &\n    1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,  &\n    1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,  &\n    1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,  &\n    1597,1601,1607,1609,1613,1619,1621,1627,1637,1657,  &\n    1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,  &\n    1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,  &\n    1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,  &\n    1901,1907,1913,1931,1933,1949,1951,1973,1979,1987\/)\n\n  f(301:np) = (\/                                        &\n    1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,  &\n    2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,  &\n    2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,  &\n    2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,  &\n    2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,  &\n    2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,  &\n    2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,  &\n    2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,  &\n    2621,2633,2647,2657,2659,2663,2671,2677,2683,2687,  &\n    2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,  &\n    2749,2753,2767,2777,2789,2791,2797,2801,2803,2819,  &\n    2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,  &\n    2909,2917,2927,2939,2953,2957,2963,2969,2971,2999,  &\n    3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,  &\n    3083,3089,3109,3119,3121,3137,3163,3167,3169,3181,  &\n    3187,3191,3203,3209,3217,3221,3229,3251,3253,3257,  &\n    3259,3271,3299,3301,3307,3313,3319,3323,3329,3331,  &\n    3343,3347,3359,3361,3371,3373,3389,3391,3407,3413,  &\n    3433,3449,3457,3461,3463,3467,3469,3491,3499,3511,  &\n    3517,3527,3529,3533,3539,3541,3547,3557,3559,3571,  &\n    3581,3583,3593,3607,3613,3617,3623,3631,3637,3643,  &\n    3659,3671,3673,3677,3691,3697,3701,3709,3719,3727,  &\n    3733,3739,3761,3767,3769,3779,3793,3797,3803,3821,  &\n    3823,3833,3847,3851,3853,3863,3877,3881,3889,3907,  &\n    3911,3917,3919,3923,3929,3931,3943,3947,3967,3989,4001\/)\n\nm = n                   ! m is the current number from n! (n*n-1*n-2...*2!\nif (m > f(np)) then\n  Print *, \"n =\", m, \"- Routine's limited to \", f(np), \"- Pgm. terminated\"\n  STOP\nend if\n\ndo while (m > 1)\n  i = 1;  j = 2;  y = m\n  do while (y > 1 .and. i < np+1)\n    if (mod(y, j) == 0) then ! j is the current factor from f()\n      g(i) = g(i) + 1        !  and its power is stored in g().\n      y = y \/ j              ! y is ( n \/ j^g() ) so far.\n    else\n      i = i + 1\n      j = f(i)  ! f() holds 1st np primes, enough for n = 4,001\n    end if\n  end do        ! End loop through possible factors\nm = m - 1       ! Decrement m for next number in factorial(n)\nend do\n              \nrslt = trim(\"x\")  ! Remember to chop \"x \" from beginning\ndo i=1, np        ! exclude all blanks, except in input strings\n  if (len_trim(rslt) > maxC-6) then\n    print *, \"O\/p exceeds\", maxC, \"chars - Result truncated.\"\n    EXIT\n  end if\n                         ! write result to string, using strict format\n  if (g(i) > 1) then\n    write(temp, \"(I0)\") f(i);    rslt = trim(rslt)\/\/\" \"\/\/trim(temp)\/\/\"^\"\n    write(temp, \"(I0)\") g(i);    rslt = trim(rslt)\/\/     trim(temp)\/\/\" *\"\n  else if (g(i) == 1) then\n    write(temp, \"(I0)\") f(i);    rslt = trim(rslt)\/\/\" \"\/\/trim(temp)\/\/\" *\"\n  end if\n  \nend do\n                 decomp = rslt(3 : len_trim(rslt) - 2)\n    END FUNCTION decomp\nEND MODULE Solution\n\n\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83430,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION decomp(n) \n    CHARACTER(:), ALLOCATABLE :: decomp\n    INTEGER :: n\n    character(4)    :: fmtf, fmtg\n    character(4)    :: temp\n    character(5000) :: rslt\n    integer*2 y, m, i, j, f(551), g(551)\n    integer*2 maxC, np\n    \n    maxC = len(rslt);       np = size(f)\n    f = (\/(0, i=1,np)\/);    g =(\/(0, i=1,np)\/)\n    decomp = \"\"\n    \n! The first 551 primes are readily available, let's use a\n! bit of memory to avoid endlessly checking for primality.     \n  f(1:300) = (\/2,3,5,7,11,13,17,19,23,29,     &\n    31,37,41,43,47,53,59,61,67,71,            &\n    73,79,83,89,97,101,103,107,109,113,       &\n    127,131,137,139,149,151,157,163,167,173,  &\n    179,181,191,193,197,199,211,223,227,229,  &\n    233,239,241,251,257,263,269,271,277,281,  &\n    283,293,307,311,313,317,331,337,347,349,  &\n    353,359,367,373,379,383,389,397,401,409,  &\n    419,421,431,433,439,443,449,457,461,463,  &\n    467,479,487,491,499,503,509,521,523,541,  &\n    547,557,563,569,571,577,587,593,599,601,  &\n    607,613,617,619,631,641,643,647,653,659,  &\n    661,673,677,683,691,701,709,719,727,733,  &\n    739,743,751,757,761,769,773,787,797,809,  &\n    811,821,823,827,829,839,853,857,859,863,  &\n    877,881,883,887,907,911,919,929,937,941,  &\n    947,953,967,971,977,983,991,997,1009,1013,          &\n    1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,  &\n    1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,  &\n    1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,  &\n    1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,  &\n    1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,  &\n    1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,  &\n    1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,  &\n    1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,  &\n    1597,1601,1607,1609,1613,1619,1621,1627,1637,1657,  &\n    1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,  &\n    1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,  &\n    1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,  &\n    1901,1907,1913,1931,1933,1949,1951,1973,1979,1987\/)\n\n  f(301:np) = (\/                                        &\n    1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,  &\n    2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,  &\n    2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,  &\n    2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,  &\n    2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,  &\n    2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,  &\n    2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,  &\n    2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,  &\n    2621,2633,2647,2657,2659,2663,2671,2677,2683,2687,  &\n    2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,  &\n    2749,2753,2767,2777,2789,2791,2797,2801,2803,2819,  &\n    2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,  &\n    2909,2917,2927,2939,2953,2957,2963,2969,2971,2999,  &\n    3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,  &\n    3083,3089,3109,3119,3121,3137,3163,3167,3169,3181,  &\n    3187,3191,3203,3209,3217,3221,3229,3251,3253,3257,  &\n    3259,3271,3299,3301,3307,3313,3319,3323,3329,3331,  &\n    3343,3347,3359,3361,3371,3373,3389,3391,3407,3413,  &\n    3433,3449,3457,3461,3463,3467,3469,3491,3499,3511,  &\n    3517,3527,3529,3533,3539,3541,3547,3557,3559,3571,  &\n    3581,3583,3593,3607,3613,3617,3623,3631,3637,3643,  &\n    3659,3671,3673,3677,3691,3697,3701,3709,3719,3727,  &\n    3733,3739,3761,3767,3769,3779,3793,3797,3803,3821,  &\n    3823,3833,3847,3851,3853,3863,3877,3881,3889,3907,  &\n    3911,3917,3919,3923,3929,3931,3943,3947,3967,3989,4001\/)\n\nm = n                   ! m is the current number from n! (n*n-1*n-2...*2!\nif (m > f(np)) then\n  Print *, \"n =\", m, \"- Routine's limited to \", f(np), \"- Pgm. terminated\"\n  STOP\nend if\n\ndo while (m > 1)\n  i = 1;  j = 2;  y = m\n  do while (y > 1 .and. i < np+1)\n    if (mod(y, j) == 0) then ! j is the current factor from f()\n      g(i) = g(i) + 1        !  and its power is stored in g().\n      y = y \/ j              ! y is ( n \/ j^g() ) so far.\n    else\n      i = i + 1\n      j = f(i)  ! f() holds 1st np primes, enough for n = 4,001\n    end if\n  end do        ! End loop through possible factors\nm = m - 1       ! Decrement m for next number in factorial(n)\nend do\n              \nrslt = trim(\"x\")  ! write result to string, using strict format\ndo i=1, np        ! exclude all blanks, except in input strings\n  if (len_trim(rslt) > maxC-6) then\n    print *, \"O\/p exceeds\", maxC, \"chars - Result truncated.\"\n    EXIT\n  end if\n  select case (f(i)) \n    case (1:9);     fmtf = \"(I1)\"\n    case (10:99);   fmtf = \"(I2)\"\n    case (100:999); fmtf = \"(I3)\"\n    case default;   fmtf = \"(I4)\"\n  end select\n  select case (g(i))\n    case (1:9);     fmtg = \"(I1)\"\n    case (10:99);   fmtg = \"(I2)\"\n    case (100:999); fmtg = \"(I3)\"\n    case default;   fmtg = \"(I4)\"\n  end select\n\n  if (g(i) > 1) then\n    write(temp, fmtf) f(i) \n    rslt = trim(adjustl(rslt))\/\/\" \"\/\/trim(adjustl(temp))\/\/\"^\"\n    write(temp, fmtg) g(i)\n    rslt = trim(adjustl(rslt))\/\/     trim(adjustl(temp))\/\/\" *\"\n  else if (g(i) == 1) then\n    write(temp, fmtf) f(i)  \n    rslt = trim(adjustl(rslt))\/\/\" \"\/\/trim(adjustl(temp))\/\/\" *\"\n  end if\nend do\n\n!       The |  chars. are used to check for any extra blanks  |     !(debug)\n! decomp = \"|\"\/\/trim(adjustl( rslt(3:len_trim(rslt) - 2) ))\/\/\"|\"    !(debug)\n       decomp = trim(adjustl( rslt(3:len_trim(rslt) - 2) ))\n\n  END FUNCTION decomp\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5a057ec846d843c81a0000ad":[{"id":83431,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION cycl(n)\n    INTEGER :: n, i, r, res\n    IF ((MOD(n, 2) == 0) .OR. (MOD(n, 5) == 0)) THEN\n      res = -1\n    ELSE\n      r = 1\n      res = -1\n      DO i = 1, n\n          r = MOD(r * 10, n)\n          IF (r == 1) THEN\n            res = i\n            EXIT\n          END IF\n      END DO\n    END IF\n    cycl = res\n  END FUNCTION cycl\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83432,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  INTEGER FUNCTION cycl(n) result(i)\n    integer, intent(in) :: n\n    integer :: m\n    if ((mod(n, 2) == 0) .or. (mod(n, 5) == 0)) then\n      i = -1\n      return\n    end if\n    m = mod(10, n)\n    i = 1\n    do while (m .ne. 1)\n      m = mod(10 * m, n)\n      i = i + 1\n    end do\n  END FUNCTION cycl\n  \nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83433,"user_id":168,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION cycl(n)\n    integer, intent(in) :: n\n    integer :: p\n    if (mod(n, 2) == 0 .or. mod(n, 5) == 0) then\n      cycl = -1\n    else\n      cycl = 1\n      p = mod(10, n)\n      do while (p \/= 1)\n        p = mod(10 * p, n)\n        cycl = cycl + 1\n      end do\n    end if\n  END FUNCTION cycl\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83434,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION cycl(n)\n    integer :: n, num\n    if (mod(n,2)==0 .or. mod(n,5)==0) then\n      cycl = -1\n    else\n      cycl=1\n      num = mod(10,n)*10\n      do while (.not. num==10)\n          num = mod(num,n)*10\n          cycl=cycl+1\n      end do\n    end if\n  END FUNCTION cycl\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83435,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION cycl(n) result(i)\n    integer, intent(in) :: n\n    integer :: num\n    \n    if (MOD(n,2) == 0 .or. MOD(n,5) == 0) then\n      i = -1\n    else\n      num = 10\n      i = 1\n      do while (.true.)\n        num = 10*MOD(num,n)\n        if (num == 10) then\n          exit\n        end if\n        i = i + 1\n      end do\n    end if\n  END FUNCTION cycl\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83436,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER FUNCTION cycl(n)\n  integer, intent(in) :: n\n  integer  i, rem1, rem\n  cycl = -1\n  rem1 = mod(1, n);  rem = rem1\n  do i=1, n-1\n    rem = 10 * rem;  rem = mod(rem, n)\n    if (rem == rem1) then\n      cycl = i\n      RETURN\n    endif\n  enddo\n  END FUNCTION cycl\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5a05b4f7ffe75f1509000063":[{"id":83437,"user_id":17,"body":"module Solution\n  implicit none\ncontains\n  pure function chains(down, distance, yardsGained) result(gameResult)\n    integer, intent(in) :: down, distance, yardsGained\n    character(:), allocatable :: gameResult\n    character(11) :: buf\n    if (yardsGained > distance) then\n      gameResult = \"First down\"\n    else if (down == 4 .and. yardsGained <= distance) then\n      gameResult = \"Turnover on downs\"\n    else\n      write(buf, \"(I0)\") distance - yardsGained\n      if (down == 1) then\n        gameResult = \"2nd and \" \/\/ trim(buf)\n      else if (down == 2) then\n        gameResult = \"3rd and \" \/\/ trim(buf)\n      else\n        gameResult = \"4th and \" \/\/ trim(buf)\n      end if\n    end if\n  end function chains\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83438,"user_id":168,"body":"module Solution\n  implicit none\ncontains\n  pure function chains(down, distance, yardsGained) result(gameResult)\n    integer, intent(in) :: down, distance, yardsGained\n    character(:), allocatable :: gameResult\n    character(10) :: t\n    if (yardsGained > distance) then\n      gameResult = \"First down\"\n    else if (down == 4) then\n      gameResult = \"Turnover on downs\"\n    else\n      write (t, '(i0)') distance - yardsGained\n      select case (down)\n        case (1)\n          gameResult = \"2nd and \"\n        case (2)\n          gameResult = \"3rd and \"\n        case (3)\n          gameResult = \"4th and \"\n      end select\n      gameResult = trim(gameResult \/\/ t)\n    end if\n  end function chains\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83439,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function chains(down, distance, yardsGained) result(gameResult)\n    integer, intent(in) :: down, distance, yardsGained\n    character(:), allocatable :: gameResult\n    character(5) :: tmp\n    tmp = \"\"\n    \n    IF (yardsGained .gt. distance) THEN\n      gameResult = \"First down\"\n    ELSE IF (down .eq. 4 .and. yardsGained .lt. distance) THEN\n      gameResult = \"Turnover on downs\"\n    ELSE\n      write(tmp, \"(i0)\") down+1\n      IF (down+1 .eq. 2) THEN\n        gameResult = trim(tmp) \/\/ \"nd and \"\n      ELSE IF (down+1 .eq. 3) THEN\n        gameResult = trim(tmp) \/\/ \"rd and \"\n      ELSE\n        gameResult = trim(tmp) \/\/ \"th and \"\n      END IF\n      \n      write(tmp, \"(i0)\") distance-yardsGained\n      gameResult = gameResult \/\/ trim(tmp)\n    END IF\n  end function chains\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83440,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  function chains(down, distance, yardsGained) result(gameResult)\n    integer, intent(in) :: down, distance, yardsGained\n    integer :: newdist\n    character(:), allocatable :: gameResult\n    character(len = 64), allocatable :: tmp\n    gameResult = \"\"\n    tmp = \"\"\n    write(*,*) down, distance, yardsGained\n    ! Really, meeting the number should work, but following description.\n    if (down >= 4 .and. yardsGained <= distance) then\n      gameResult = \"Turnover on downs\"\n    else if (yardsGained > distance) then\n      gameResult = \"First down\"\n    else\n      newdist = distance - yardsGained\n      select case (down)\n        case (1)\n          gameResult = \"2nd and \"\n        case (2)\n          gameResult = \"3rd and \"\n        case (3)\n          gameResult = \"4th and \"\n      end select\n      write(tmp, '(I0)') newdist\n      gameResult = gameResult \/\/ tmp\n    end if\n    gameResult = trim(gameResult)\n  end function chains\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83441,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  function chains(down, distance, yardsGained) result(gameResult)\n    integer, intent(in) :: down, distance, yardsGained\n    character(:), allocatable :: gameResult\ncharacter(5) res\ncharacter(3) nSfx(4)\nnSfx = (\/\"1st\",\"2nd\",\"3rd\",\"4th\"\/)\n\nif (distance .le. yardsgained) then\n    ! With the e in .le. above & input with distance = yardsgained it gives, \n    ! e.g. \"Expected: 3rd and 0\". This is not a valid NFL call. \n    ! I get the correct \"First down\".\n  gameresult = \"First down\"            ! Made the required yards\nelse if (down == 4) then\n  gameresult = \"Turnover on downs\"     ! Failed in 4 downs\nelse\n  write(res, '(I2)') distance - yardsgained ! Faied, but downs remaining\n  gameresult = Trim( nSfx(down+1) \/\/ \" and \" \/\/ adjustl(trim(res)) )\nend if\n  end function chains\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83442,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function chains(down, distance, yardsGained) result(gameResult)\n    integer, intent(in) :: down, distance, yardsGained\n    character(:), allocatable :: gameResult, next1\n    character(11) :: next2\n    if (yardsGained > distance) then\n      gameResult = \"First down\"\n    else if (down==4) then \n      gameResult = \"Turnover on downs\"\n    else\n      select case (down)\n        case (1); next1 = \"2nd\"\n        case (2); next1 = \"3rd\"\n        case (3); next1 = \"4th\"\n      end select\n      write (next2, \"(i0)\") distance-yardsGained\n      gameResult = next1\/\/\" and \"\/\/trim(next2)\n    end if\n  end function chains\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83443,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function chains(down, distance, yardsGained) result(gameResult)\n    integer, intent(in) :: down, distance, yardsGained\n    character(:), allocatable :: gameResult, next\n    character(10) :: res\n    if (yardsGained > distance) then\n      gameResult = \"First down\"\n    else if (down==4) then \n      gameResult = \"Turnover on downs\"\n    else\n      select case (down)\n        case (1); next = \"2nd\"\n        case (2); next = \"3rd\"\n        case (3); next = \"4th\"\n      end select\n      write (res, \"(i0)\") distance-yardsGained\n      gameResult = next\/\/\" and \"\/\/trim(res)\n    end if\n  end function chains\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5a19226646d843de9000007d":[{"id":83444,"user_id":564,"body":"module Solution\n  implicit none\ncontains\n  pure integer function countConsonants(str)\n    character(len=*), intent(in) :: str\n    character :: c, cUp\n    integer :: num, i\n    num = 0\n    do i = 98, 122 ! b through z\n      c = achar(i)\n      cUp = achar(i - 32)\n      if (scan(str, c) > 0 .or. scan(str, cUp) > 0) then\n        if (scan(\"eiou\", c) == 0) then\n          num = num + 1\n        end if\n      end if\n    end do\n    countConsonants = num\n  end function countConsonants\n\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83445,"user_id":564,"body":"module Solution\n  implicit none\ncontains\n\n  function countConsonants(str) result(num)\n    character(len=*), intent(in) :: str\n    integer :: num, i\n    character :: c, cUp\n    num = 0\n\n    do i = 98, 122\n      c = achar(i)\n      cUp = achar(i - 32)\n      if (scan(str, c) > 0 .or. scan(str, cUp) > 0) then\n        if (scan(\"eiou\", c) == 0) then\n          num = num + 1\n        end if\n      end if\n    end do\n  end function countConsonants\n\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83446,"user_id":null,"body":"module solution\n    implicit none\n    character(len=21),parameter :: ucase = 'BCDFGHJKLMNPQRSTVWXYZ'\n    character(len=21),parameter :: lcase = 'bcdfghjklmnpqrstvwxyz'\n    contains\n    pure integer function countConsonants(s) \n        character(len=*), intent(in) :: s\n        integer :: i\n        countConsonants=0\n        do i=1,21,1\n            if((index(s,ucase(i:i)).ne.0).or.(index(s,lcase(i:i)).ne.0)) then\n                countConsonants=countConsonants+1\n            end if\n        end do\n    end function countConsonants\nend module solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83447,"user_id":null,"body":"module Solution\n  implicit none\n  character(len=21) :: consonants_lower = 'bcdfghjklmnpqrstvwxyz'\n  character(len=21) :: consonants_upper = 'BCDFGHJKLMNPQRSTVWXYZ'\ncontains\n  pure function countConsonants(s) result(n)\n    character(len=*), intent(in) :: s ! The string passed in\n    integer :: n ! The result to return to the caller\n    integer :: i\n    n = 0\n    \n    DO i = 1, len(consonants_lower)\n      IF (INDEX(TRIM(s), consonants_lower(i:i)) .GT. 0 &\n          .OR. INDEX(TRIM(s), consonants_upper(i:i)) .GT. 0 ) n = n + 1     \n    END DO\n    RETURN\n  end function countConsonants\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83448,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  subroutine U2L(str)\n    character(len=*), intent(inout) :: str\n    character(len=26), parameter:: UpStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    character(len=26), parameter:: LowStr = 'abcdefghijklmnopqrstuvwxyz'\n    integer :: length, i, idx\n    \n    LENGTH = LEN(STR)\n    DO I=1,LENGTH\n       IDX = INDEX(UpStr,STR(I:I))\n       IF (IDX.GT.0) STR(I:I) = LowStr(IDX:IDX)\n    ENDDO\n  end subroutine U2L\n\n  function countConsonants(s) result(n)\n    character(len=*), intent(in) :: s ! The string passed in\n    integer :: n ! The result to return to the caller\n    character(:), allocatable :: str\n    character(len=21), parameter :: L = 'bcdfghjklmnpqrstvwxyz'     \n    integer :: i, idx\n    \n    n = 0 ! TODO: Count the no. of unique consonants in the string provided\n    str = s\n    call U2L(str) !turn all letters into lower case\n    do i=1,21\n      idx = index(str,L(i:i))\n      if (idx.gt.0) n = n + 1\n    enddo\n\n  end function countConsonants\n\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83449,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  function countConsonants(s) result(n)\n    character(len=*), intent(in) :: s ! The string passed in\n    integer :: n ! The result to return to the caller\n    character(999) t, f\n    character(5) vowels\n    character(1) ch\n    integer ic, j, k, l, m\n\n    f = \"\"    ! found letters\n    t = \"\"    ! test (modifiable) string \n    vowels = \"aeiou\"\n\n    k = len(s)\n    if (k > 999) then           ! (see declared length of t$, f$)\n       write(*,*) \"Input string is too long\"\n       STOP\n    endif\n    write(*,*) k, s\n\n    t = s\n    l = 1\n    do j=1, k\n      ic = ichar( t(l:l) )    ! ASCII code for character\n      if ( (64 < ic) .and. (ic < 91) ) ic = ic + 32 ! Make ic for any A to Z equal to lcase a to z.\n      ch = char(ic)           ! Get (lower case) character back\n      m = index( vowels, ch )                                        ! If ch is found in vowels\n      if ( (m > 0) .or.  (97 > ic) .or. (ic > 122) ) then            ! or not in alphabet\n        t = trim( t(1:l-1) \/\/ t(l+1:) )                              ! discard it and close its gap \n        l = l - 1                                                    ! and re-do for that posiiton.\n      else\n        m = index( f, ch )\n        if (m == 0) f = trim( f ) \/\/ ch       ! If ch is not already in f$ (found_chars) add it now\n        ! write(*,*) ch, \"  \", f\n      end if\n      l = l + 1            ! Go to next character IN MODIFIED test string, t$\n    end do\n\n    n = len( trim(f) )     ! Set value for result.\n    ! write(*,*) t, f, n\n\n  end function countConsonants\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83450,"user_id":17,"body":"module Solution\n  implicit none\ncontains\n  pure function countConsonants(s) result(n)\n    character(len=*), intent(in) :: s\n    integer :: n, a(26), i, c\n    a = (\/1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0\/)\n    do i = 1, len(s)\n      c = ichar(s(i:i))\n      if (c >= 97) then\n        c = c - 32\n      end if\n      if (c >= 65 .and. c < 91) then\n        a(c - 64) = 1\n      end if\n    end do\n    n = -5\n    do i = 1, 26\n      n = n + a(i)\n    end do\n  end function countConsonants\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5a24254fe1ce0ec2eb000078":[{"id":83451,"user_id":null,"body":"module solution\n    implicit none\n    \n    contains\n    \n    pure integer function solve(str,idx) result(matchIdx)\n        character(*), intent(in) :: str\n        integer, intent(in) :: idx\n        integer :: i\n        integer :: flag\n        character :: cha\n        matchIdx = 0\n        if (str(idx:idx)\/=\"(\") return\n        flag=1\n        do i=idx+1,len(str),1\n            cha=str(i:i)\n            if(cha==\"(\") flag=flag+1\n            if(cha==\")\") flag=flag-1\n            if(flag==0.and.cha==\")\") then\n                matchIdx=i\n                return\n            end if\n        end do\n    end function solve\n    \nend module solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83452,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function solve(str, idx) result(matchIdx)\n    character(*), intent(in) :: str ! The input string\n    integer, intent(in) :: idx ! The index of the opening brace (if any)\n    integer :: matchIdx ! The index of the matching closing brace (if any) or 0 otherwise\n    integer :: count, i\n    matchIdx = 0\n    \n    If (str(idx:idx) == '(') then\n      count = 1\n      Do i = idx + 1, len(str)\n        If (str(i:i) == '(') count = count + 1\n        If (str(i:i) == ')') count = count - 1\n        If (count == 0) then\n          matchIdx = i\n          exit\n        End If\n      End Do\n    End If\n    \n  end function solve\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83453,"user_id":1228,"body":"module Solution\n  implicit none\ncontains\n  function solve(str, idx) result(matchIdx)\n    character(*), intent(in) :: str ! The input string\n    integer, intent(in) :: idx ! The index of the opening brace (if any)\n    integer :: matchIdx ! The index of the matching closing brace (if any) or 0 otherwise\n    character(1) LF, SP\n    integer(4)   i, x, l, scnt\n     \n    LF = char(10);    SP = \" \" \n    l = len_trim(str)\n    if (idx == 0) then\n      x = 0\n    else if ( str(idx:idx) .ne. \"(\" ) then\n      x = 0\n    else                        \n      scnt = 0\n      do i=idx, l\n        if ( str(i:i) == \"(\" ) then \n          scnt = scnt + 1 \n        else if ( str(i:i) == \")\" ) then \n          scnt = scnt - 1 \n          if (scnt == 0) then\n            x = i\n            EXIT\n          end if\n        endif \n      end do\n    end if\n    matchIdx = x\n  end function solve\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83454,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function solve(str, idx) result(matchIdx)\n    character(*), intent(in) :: str ! The input string\n    integer, intent(in) :: idx ! The index of the opening brace (if any)\n    integer :: matchIdx ! The index of the matching closing brace (if any) or 0 otherwise\n    integer :: x, iidx, length, count\n    length = len(str)      \n    matchIdx = 0\n    if (str(idx:idx) \/= \"(\") then\n      return\n    end if\n    count = 1\n    do x = idx+1, length\n      if (str(x:x) == \"(\")then \n        count = count + 1\n      else if (str(x:x) == \")\") then\n        count = count - 1\n      end if\n      if (count == 0) then\n        matchIdx = x\n        return\n      end if\n    end do\n  end function solve\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83455,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function solve(str, idx) result(matchIdx)\n    character(*), intent(in) :: str ! The input string\n    integer, intent(in) :: idx ! The index of the opening brace (if any)\n    integer :: matchIdx ! The index of the matching closing brace (if any) or 0 otherwise\n    integer :: NumBrackets ! Identify the number of bracket groups\n    integer :: i\n   \n    if(str(idx:idx).ne.'(') then\n      matchIdx = 0 ! Check if the starting position is a bracket\n    else\n      NumBrackets = 0 ! Check the number of brackets adds up. If not, return 0\n      do i = 1,len(str)\n        if(str(i:i).eq.'(')  NumBrackets = NumBrackets + 1\n        if(str(i:i).eq.')')  NumBrackets = NumBrackets - 1\n      end do\n      if(NumBrackets.ne.0) then\n        matchIdx=0\n      else\n        matchIdx=0 !If brackets add up, find the closing bracket\n        NumBrackets = 0\n        i = idx\n        do while ((matchIdx.eq.0).and.(i.le.len(str)))\n          if(str(i:i).eq.'(')  NumBrackets = NumBrackets + 1\n          if((NumBrackets.eq.1).AND.(str(i:i).eq.')')) matchIdx = i\n          \n          if(str(i:i).eq.')')  NumBrackets = NumBrackets - 1\n          i=i+1\n        end do\n      end if      \n    end if \n \n  end function solve\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83456,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  function solve(str, idx) result(matchIdx)\n    character(*), intent(in) :: str ! The input string\n    integer, intent(in) :: idx ! The index of the opening brace (if any)\n    integer :: matchIdx ! The index of the matching closing brace (if any) or 0 otherwise\n    character(1) LF, SP\n    integer(4)   i, x, l, scnt\n     \n    LF = char(10);    SP = \" \" \n    l = len_trim(str)\n    PRINT *, \"idx, l =\", idx , l  \n\n    if (idx == 0) then\n      x = 0\n    else if ( str(idx:idx) .ne. \"(\" ) then\n      x = 0\n    else                        \n      scnt = 0\n      do i=idx, l\n        if ( str(i:i) == \"(\" ) then \n          scnt = scnt + 1 \n        else if ( str(i:i) == \")\" ) then \n          scnt = scnt - 1 \n          if (scnt == 0) then\n            x = i\n            EXIT\n          end if\n        endif \n      end do\n      ! print *, LF, \"s=\", s, LF, \"e=\", e\n    end if\n\n    matchIdx = x\n  end function solve\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83457,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  function solve(str, idx) result(matchIdx)\n    character(*), intent(in) :: str ! The input string\n    integer, intent(in) :: idx ! The index of the opening brace (if any)\n    integer :: matchIdx ! The index of the matching closing brace (if any) or 0 otherwise\n    integer :: parcnt, i, L, start\n    logical :: hit\n    ! Had to remove `pure` from function to be allowed to debug prin :(\n    !write (*,*) str, idx\n    parcnt = 1\n    hit = .false.\n    L = len(str)\n    if ( str(idx:idx) == \"(\" ) then\n      loop: do i = idx+1,L\n        if ( str(i:i) == \"(\" ) then\n          parcnt = parcnt + 1\n        else if (str(i:i) == \")\") then\n          parcnt = parcnt - 1\n          if (parcnt == 0) then\n            hit = .true.\n            matchIdx = i ! TODO\n            exit loop\n          end if\n        end if\n      end do loop\n    end if\n    if (.not. hit) matchIdx = 0\n  end function solve\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83458,"user_id":17,"body":"module Solution\n  implicit none\ncontains\n  pure function solve(s, i) result(k)\n    character(*), intent(in) :: s\n    integer, intent(in) :: i\n    integer :: j, k, unmatched\n    k = 0\n    j = i\n    if (s(j:j) == '(') then\n      unmatched = 1\n      do while (unmatched > 0)\n        j = j + 1\n        if (s(j:j) == '(') then\n          unmatched = unmatched + 1\n        else if (s(j:j) == ')') then\n          unmatched = unmatched - 1\n        end if\n      end do\n      k = j\n    end if\n  end function solve\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5a3fe3dde1ce0e8ed6000097":[{"id":83459,"user_id":null,"body":"pure function century_from_year(year) result (res)\n integer, intent(in) :: year\n res = ((year - 1) \/ 100 + 1) ! your code here\nend function century_from_year\n","lang_id":19,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83460,"user_id":null,"body":"pure function century_from_year(year) result (res)\ninteger, intent(in) :: year\n if (mod(year, 100) \/= 0) then\n   res = year\/100 + 1\n   else\n   res = year\/100\n end if    \nend function century_from_year","lang_id":19,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83461,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function century_from_year(year) result (res)\n    integer, intent(in) :: year\n    integer :: rem\n    \n    res = year \/ 100\n    rem = modulo(year, 100)\n    if (rem.NE.0) then\n      res = res + 1\n    end if\n    \n  end function century_from_year\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83462,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure recursive function century_from_year(year) result (res)\n    integer, intent(in) :: year\n    if (year < 101) then \n      res = 1\n    else \n      res = century_from_year(year - 100) + 1\n    end if\n  end function century_from_year\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83463,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function century_from_year(year) result (res)\n    integer, intent(in) :: year\n    integer :: res\n    res=year\/100\n    if (mod(year,100) .ne. 0) then\n      res=res+1\n    end if\n  end function century_from_year\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83464,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function century_from_year(year) result (res)\n    integer, intent(in) :: year\n    res = ceiling(real(year) \/ 100)\n  end function century_from_year\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83465,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function century_from_year(year) result (res)\n    integer, intent(in) :: year\n    res = 0 \n    if (MOD(year,100) == 0) then\n      res = (year \/ 100)\n    else\n      res = (year \/ 100 + 1)\n    end if\n  end function century_from_year\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83466,"user_id":53,"body":"module Solution\n  implicit none\ncontains\n  integer pure function century_from_year(y) result (res)\n    integer, intent(in) :: y\n    res = (y + 99) \/ 100\n  end function century_from_year\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83467,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function century_from_year(year) result (res)\n    integer, intent(in) :: year\n    if (mod(year, 100) == 0) then\n      res = year \/ 100\n    else\n      res = year \/ 100 + 1\n    end if\n  end function century_from_year\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83468,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function century_from_year(year) result (res)\n    integer, intent(in) :: year\n    integer :: i,rem\n    rem=mod(year,100)\n    if(rem .eq. 0) then\n    res=year\/100\n    else \n    res=(year\/100) + 1\n    end if\n  end function century_from_year\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5a48948e145c46820b00002f":[{"id":83469,"user_id":53,"body":"module Solution\n  implicit none\n  public :: Kprime_Step\n\ncontains\n\n  FUNCTION Kprime_Step(k, step, start, nd) RESULT(str)\n    INTEGER, INTENT(IN):: k, step, start, nd\n    INTEGER :: i, c\n    CHARACTER(:), allocatable :: str\n    CHARACTER(255), allocatable :: a, b\n\n    str = ''\n    i = start\n    a = ''\n    b = ''\n    \n    DO WHILE ( i - 1 <= nd - step ) \n        IF ( Kprime_Factor_Count( i ) == k .and. Kprime_Factor_Count( i + step ) == k ) THEN\n            c = i + step\n            Write( a, '(i10)' ) i\n            Write( b, '(i10)' ) c\n            a = a(1:len_trim(a))\n            b = b(1:len_trim(b))\n            str = str\/\/'('\/\/trim(adjustl(a))\/\/' '\/\/trim(adjustl(b))\/\/')'\n        END IF\n        i = i + 1\n    END DO\n    \n  END FUNCTION Kprime_Step\n  \n  FUNCTION Kprime_Factor_Count(m) RESULT(cnt)\n    INTEGER, INTENT(IN):: m\n    INTEGER :: cnt, n, i\n\n    cnt = 0\n    n = m\n    i = 2\n    \n    DO WHILE ( i * i <= n ) \n        DO WHILE ( MODULO(n, i) == 0 ) \n            cnt = cnt + 1\n            n = n \/ i\n        END DO\n        i = i + 1\n    END DO\n    \n    IF ( n > 1 ) THEN\n        cnt = cnt + 1\n    END IF\n    \n  END FUNCTION Kprime_Factor_Count\n\nEND module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83470,"user_id":492,"body":"module Solution\n  implicit none\n  private :: nb_divisors\n  public :: Kprime_Step\n\ncontains\n\n  subroutine nb_divisors(n, cnt)\n    integer, intent(in) :: n\n    integer, intent(out) :: cnt\n    integer :: divisor, next, num\n\n    cnt = 0\n    if (n == 0) then\n      cnt = 0\n    else\n      divisor = 2; next = 3; num = n\n      do while ( num \/= 1 )\n        do while ( mod(num, divisor) == 0 )\n          num = num \/ divisor\n          cnt = cnt + 1\n        end do\n        divisor = next\n        next = next + 2\n      end do\n    end if\n  end subroutine nb_divisors\n\n  FUNCTION Kprime_Step(k, step, start, nd) RESULT(str)\n    INTEGER, INTENT(IN):: k, step, start, nd\n    INTEGER :: i, d\n    CHARACTER(:), allocatable :: str\n    CHARACTER (LEN=128) :: tmp\n\n    ALLOCATE(character(0) :: str)\n    str = \"\"\n    DO i = start, nd - step + 1\n      call nb_divisors(i, d)\n      IF (d == k) THEN\n        call nb_divisors(i + step, d)\n        IF (d == k) THEN\n          WRITE(tmp, fmt=\"(A, I0, A, I0, A)\") \"(\", i, \" \", i + step, \")\"\n          str = TRIM(str) \/\/ tmp\n        END IF\n      END IF\n    END DO\n    str = TRIM(str)\n  END FUNCTION Kprime_Step\n\nEND module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5a8bcd980025e99381000099":[{"id":83471,"user_id":168,"body":"module Solution\n  implicit none\n  private\n  public :: square_up\ncontains\n  pure function square_up(n)\n    integer, intent(in) :: n\n    integer, dimension(:), allocatable :: square_up\n    integer :: i, j\n    allocate(square_up(n * n))\n    square_up = 0\n    do i = 0, n - 1\n      do j = i + 1, 1, -1\n        square_up(n * i + n - j + 1) = j\n      end do\n    end do\n  end function square_up\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83472,"user_id":null,"body":"module Solution\n  implicit none\n  private\n  public :: square_up\ncontains\n  pure function square_up(n)\n    integer, intent(in) :: n\n    integer, dimension(:), allocatable :: square_up\n    integer :: blk, i\n\n    allocate( square_up(n*n) )\n    \n    do blk=0,n-1\n      do i=0,n-1\n        if (blk >= n - i - 1) then\n          square_up(1 + blk * n + i) = n - i\n        else \n          square_up(1 + blk * n + i) = 0\n        end if\n      end do\n    end do\n  end function square_up\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83473,"user_id":null,"body":"module solution\n    implicit none\n    contains\n    pure subroutine triangularize(n,mat)\n        integer,intent(in) :: n\n        integer,dimension(n,n),intent(inout) :: mat\n        integer :: i,j\n        do i=1,n,1\n            do j=1,n,1\n                if(j.lt.i) mat(j,i)=0\n            end do\n        end do\n    end subroutine triangularize\n    pure function square_up(n)\n        integer, intent(in) :: n\n        integer, dimension(n*n) :: square_up\n        integer, dimension(n,n) :: mat\n        integer :: i, j\n        square_up=[([(j,j=n,1,-1)],i=1,n,1)]\n        mat=reshape(square_up,[n,n])\n        call triangularize(n,mat)\n        square_up = reshape(mat(:,n:1:-1),[n*n])\n    end function square_up    \nend module solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83474,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  function square_up(n)\n    integer :: i, j\n    integer, intent(in) :: n\n    integer, dimension(:), allocatable :: square_up\n    allocate (square_up(n*n))\n    forall(i = 1:n, j = 1:n) square_up((n+1-i)*n+1-j) = merge(j, 0, j<=n+1-i)\n  end function square_up\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83475,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  function square_up(n)\n    integer :: i, j, k\n    integer, intent(in) :: n\n    integer, dimension(:), allocatable :: square_up\n    allocate (square_up(n*n))\n    forall(i = 1:n, j = 1:n) square_up((n+1-i)*n+1-j) = merge(j, 0, j<=n+1-i)\n  end function square_up\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83476,"user_id":null,"body":"module Solution\n  implicit none\n  private\n  public :: square_up\ncontains\n  function square_up(n)\n    integer, intent(in) :: n\n    integer, dimension(:), allocatable :: square_up\n    integer :: i\n    allocate(square_up(n*n))\n    square_up(:) = 0\n    do i=1,n\n      square_up(n*(i-1) + n-i+1::n) = i\n    end do\n  end function square_up\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83477,"user_id":17,"body":"module Solution\n  implicit none\n  private\n  public :: square_up\ncontains\n  pure function square_up(n)\n    integer, intent(in) :: n\n    integer, dimension(:), allocatable :: square_up\n    integer :: i, j\n    allocate(square_up(n ** 2))\n    do i = 1, n\n      do j = 1, n\n        if (n - i < j) then\n          square_up(n * (i - 1) + j) = n - j + 1\n        else\n          square_up(n * (i - 1) + j) = 0\n        end if\n      end do\n    end do\n  end function square_up\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83478,"user_id":17,"body":"module Solution\n  implicit none\n  private\n  public :: square_up\ncontains\n  pure function square_up(n)\n    integer, intent(in) :: n\n    integer, dimension(:), allocatable :: square_up\n    integer :: i, j\n    allocate(square_up(n ** 2))\n    do i = 1, n\n      do j = 1, n\n        if (n - i < j) then\n          square_up(n * (i - 1) + j) = n - j + 1\n        else\n          square_up(n * (i - 1) + j) = 0\n        end if\n      end do\n    end do\n  end function square_up\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5a8d1c82373c2e099d0000ac":[{"id":83479,"user_id":1228,"body":"module Solution\n  implicit none\ncontains\n  pure function solve(s, m, n) result(output)\n    character(*), intent(in) :: s\n    integer, intent(in) :: m, n\n    character(:), allocatable :: output\n    character :: temp\n    integer :: i, j, nn\n    output = s\n    nn = min(n, LEN_TRIM(output) )\n    j = 0\n    do i = m, (nn-m)\/2 + m\n       temp = output(i:i)\n       output(i:i) = output(nn-j:nn-j)\n       output(nn-j:nn-j) = temp\n       j = j + 1\n    end do \n    \n  end function solve\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83480,"user_id":17,"body":"module Solution\n  implicit none\ncontains\n  pure function solve(s, m, n) result(output)\n    character(*), intent(in) :: s\n    integer, intent(in) :: m, n\n    character(:), allocatable :: output\n    integer :: i\n    output = s(1 : m - 1)\n    do i = min(n, len(s)), m, -1\n      output = output \/\/ s(i:i)\n    end do\n    output = output \/\/ s(min(n, len(s)) + 1 : len(s))\n  end function solve\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83481,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function solve(s, m, n) result(output)\n    character(*), intent(in) :: s\n    integer, intent(in) :: m, n\n    character(:), allocatable :: output\n    integer :: i\n    if (m > 1) then\n      output = s(1 : m - 1)\n    else\n      output = \"\"\n    end if\n    i = min(n, len(s))\n    do while (i >= m)\n      output = output \/\/ s(i : i)\n      i = i - 1\n    end do\n    i = n + 1\n    do while (i <= len(s))\n      output = output \/\/ s(i : i)\n      i = i + 1\n    end do\n  end function solve\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83482,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function solve(s, m, n) result(output)\n    character(*), intent(in) :: s\n    integer, intent(in) :: m, n\n    character(:), allocatable :: output\n    \n    integer               :: stringSize, i\n    integer               :: start, ending\n    \n    stringSize = len(s)\n    start = m\n    ending = n\n    \n    if (m < 1) then\n      start = 1\n    end if\n    \n    if (n > stringSize) then\n      ending = stringSize\n    end if\n    allocate(character(stringSize) :: output)\n    output(:start - 1) = s(:start - 1)\n    output(ending + 1:) = s(ending + 1:)\n    \n    do i = start, ending\n      output(i:i) = s(ending - (i - start):ending - (i - start))\n    end do\n    \n    \n  end function solve\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83483,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function solve(s, m, n) result(output)\n    character(*), intent(in) :: s\n    integer, intent(in) :: m, n\n    character(:), allocatable :: output\n    integer :: i\n    output=\"\"\n    do i=min(n,len(s)),m,-1\n        output=output\/\/s(i:i)\n    end do\n    output=s(1:m-1)\/\/output\/\/s(n+1:len(s))\n  end function solve\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83484,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function solve(s, m, n) result(output)\n    character(*), intent(in) :: s\n    integer, intent(in) :: m, n\n    character(:), allocatable :: output\n    integer :: lenstr, i\n    character :: letter\n    \n    output = \"\" ! TODO\n    lenstr = len(s)\n    do i=1,m-1\n       output = output\/\/s(i:i)\n    enddo\n    if (lenstr.ge.n) then\n       do i=n,m,-1\n          output = output\/\/s(i:i)\n       enddo\n       do i=n+1,lenstr\n          output = output\/\/s(i:i)\n       enddo\n    else\n       do i=lenstr,m,-1\n          output = output\/\/s(i:i)\n       enddo       \n    endif\n  end function solve\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83485,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function solve(s, m, n) result(output)\n    integer :: i, l\n    integer, intent(in) :: m, n\n    character(*), intent(in) :: s\n    character(:), allocatable :: output\n    if (n<=len(s)) then; l = n; else; l = len(s); end if\n    output = s; forall (i = m:l) output(i:i) = s(m+l-i:m+l-i) \n  end function solve\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83486,"user_id":1228,"body":"module Solution\n  implicit none\ncontains\n   pure function solve(s, m, n) result(output)\n    character(*), intent(in) :: s\n    integer, intent(in) :: m, n\n    character(:), allocatable :: output\n    \n    character :: temp\n    integer :: i, j, nn\n    output = s\n    if (n > LEN_TRIM(output)) then\n      nn = LEN_TRIM(output) \n    else\n      nn = n\n    end if\n    j = 0\n    do i = m, (nn-m)\/2 + m\n       temp = output(i:i)\n       output(i:i) = output(nn-j:nn-j)\n       output(nn-j:nn-j) = temp\n       j = j + 1\n    end do \n\n  end function solve\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83487,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  function solve(s, m, n) result(output)\n    character(*), intent(in) :: s\n    integer, intent(in) :: m, n\n    integer :: k, nn\n    character(:), allocatable :: output\n    output = s\n    ! save to a variable we can change\n    nn = n\n    ! Handle extra long\n    if (nn > len(s)) then\n      nn = len(s)\n    end if\n    forall (k=0:nn-m) output(m+k:m+k) = s(nn-k:nn-k)\n    ! long form\n    !do k = 0, nn -m\n    !  output(m+k:m+k) = s(nn-k:nn-k)\n    !end do\n  end function solve\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5a905c2157c562994900009d":[{"id":83488,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function productArray(a)\n    integer, dimension(:), intent(in) :: a\n    integer, dimension(:), allocatable :: productArray\n    \n    productArray = int(product(int(a, 8))\/a)\n    \n  end function productArray\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83489,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n   function productArray(a)\n    integer, dimension(:), intent(in) :: a\n    integer, dimension(:), allocatable :: productArray\n    integer(8) :: prod, i\n    prod = product(int(a, 8))\n    productArray = [(prod \/ a(i), i = 1, size(a))]\n  end function productArray\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83490,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function productArray(a)\n    integer(kind=SELECTED_INT_KIND(8)), dimension(:), intent(in) :: a\n    integer(kind=SELECTED_INT_KIND(8)), dimension(:), allocatable :: productArray\n    integer :: i\n    \n    allocate(productArray(size(a)))\n    \n    do i=1,size(a)\n      productArray(i) = product(a(:(i-1)))*product(a((i+1):))\n    end do    \n    \n  end function productArray\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83491,"user_id":53,"body":"module Solution\n  implicit none\ncontains\n  pure function productArray(xs)\n    integer, parameter :: ikind=selected_int_kind(16)\n    integer, dimension(:), intent(in) :: xs\n    integer, dimension(:), allocatable :: productArray\n    integer(ikind) :: p\n    integer :: i\n    p = 1\n    do i = 1, size(xs)\n      p = p * xs(i)\n    end do\n    allocate(productArray(size(xs)))\n    do i = 1, size(xs)\n      productArray(i) = p \/ xs(i)\n    end do\n  end function productArray\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83492,"user_id":168,"body":"module Solution\n  implicit none\ncontains\n  pure function productArray(a)\n    integer, dimension(:), intent(in) :: a\n    integer, dimension(:), allocatable :: productArray\n    integer (kind = 8) :: prod\n    integer :: i\n    prod = 1\n    do i = 1, size(a)\n      prod = prod * a(i)\n    end do\n    allocate(productArray(size(a)))\n    productArray(:) = [(int(prod \/ a(i)), i = 1, size(a))]\n  end function productArray\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83493,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function productArray(a)\n    integer, dimension(:), intent(in) :: a\n    integer, dimension(:), allocatable :: productArray\n    integer :: i, j, prod, s\n    \n    s = size(a)\n    allocate(productArray(s))\n    \n    do i = 1, s\n      prod = 1\n      do j = 1, s\n        if (i \/= j) then\n          prod = prod * a(j)\n        end if\n      end do\n      productArray(i) = prod\n    end do\n  end function productArray\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83494,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function productArray(a)\n    integer, dimension(:), intent(in) :: a\n    integer, dimension(:), allocatable :: productArray\n    ! TODO\n    integer i,n\n    n=size(a)\n    allocate(productArray(n))\n    do i=1,size(a)\n      productArray(i)=prod([a(:i-1),a(i+1:)])\n    end do\n  end function productArray\n  \n  pure function prod(a)result(b)\n    integer,intent(in)::a(:)\n    integer b,i\n    b=1\n    do i=1,size(a)\n       b=b*a(i)\n    end do\n   end function\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83495,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function productArray(a)\n    integer, dimension(:), intent(in) :: a\n    integer, dimension(:), allocatable :: productArray\n    integer :: i, j, tmp\n    \n    allocate(productArray(size(a)))\n    \n    do i = 1, size(a)\n      tmp = 1\n      do j = 1, size(a)\n        if (j .ne. i) tmp = tmp * a(j)\n      end do\n      productArray(i) = tmp\n    end do\n  end function productArray\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83496,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function productArray(a)\n    integer, dimension(:), intent(in) :: a\n    integer, dimension(:), allocatable :: productArray\n    integer :: i, j\n    allocate(productArray(size(a)))\n    do i = 1,size(a) , 1\n        productArray(i) = 1\n        do j = 1, size(a) , 1\n            if (j \/= i) then\n                productArray(i) = productArray(i) * a(j)\n            end if\n        end do\n    end do\n  end function productArray\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83497,"user_id":1228,"body":"module Solution\n  implicit none\ncontains\n  pure function productArray(a)\n    integer, dimension(:), intent(in) :: a\n    integer, dimension(:), allocatable :: productArray\n    integer :: i\n    allocate(productArray(size(a)))\n    do i = 1, size(a)\n        productArray(i) = product(a(1:i-1))*product(a(i+1:size(a)))\n    end do\n  end function productArray\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5a946d9fba1bb5135100007c":[{"id":83498,"user_id":53,"body":"module Solution\n\n  implicit none\n  private :: isPrime, closestPrimeUp\n  public :: minimumNumber\n  \ncontains\n\n  integer pure function closestPrimeUp(n)\n    integer, intent(in) :: n\n    integer :: m\n    m = n\n    do while (1 > 0)\n      if (isPrime(m)) then\n        closestPrimeUp = m\n        return\n      end if\n      m = m + 1\n    end do\n  end function closestPrimeUp\n  \n  pure function isPrime(n) result(res)\n    integer, intent(IN) :: n\n    integer :: i\n    LOGICAL :: res\n    if (n < 2) then\n      res = .FALSE.\n      return\n    end if\n    if (mod(n, 2) == 0) then\n      res = (n == 2)\n      return\n    end if\n    do i = 3, int(sqrt(real(n))), 2\n      if (mod(n, i) == 0) then\n        res = .FALSE.\n        return\n      end if\n    end do\n    res = .TRUE.\n  end function isPrime\n\n  integer pure function minimumNumber(a)\n    integer, dimension(:), intent(in) :: a\n    integer :: s,i\n    s = 0\n    do i = 1, size(a)\n      s = s + a(i)\n    end do\n    minimumNumber = closestPrimeUp(s) - s\n  end function minimumNumber\n  \nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83499,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  logical pure function isPrime(p) result(res)\n    integer, intent(in) :: p\n    integer :: i\n    \n    res = .true.\n    \n    do i = 2, int(sqrt(real(p)))\n      if (mod(p, i) == 0) then\n        res = .false.\n        exit\n      end if\n    end do\n  end function\n\n  integer pure function minimumNumber(a)\n    integer, dimension(:), intent(in) :: a\n    integer :: suma, i\n\n    suma = sum(a)\n    i = suma\n    \n    do while (.not.isPrime(i))\n      i = i+1\n    end do\n    \n    minimumNumber = i - suma ! TODO\n  end function minimumNumber\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83500,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function minimumNumber(a)\n    integer, dimension(:), intent(in) :: a\n    integer :: total\n    minimumNumber = 0\n    total = sum(a)\n    \n    do while (isPrime(total+minimumNumber) .neqv. .true.)\n      minimumNumber = minimumNumber + 1\n    end do\n  end function minimumNumber\n  \n  logical pure function isPrime(n)\n    integer, intent(in) :: n\n    integer :: i\n    isPrime = .true.\n    if (mod(n,2) == 0) then\n      isPrime = .false.\n    else\n      do i = 3,floor(sqrt(real(n))),2\n        if (mod(n,i) == 0) then\n          isPrime = .false.\n          exit\n        endif\n      end do\n    endif\n  end function isPrime\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83501,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function minimumNumber(a)\n  integer, dimension(:), intent(in) :: a\n  integer :: curtotal, i, n, j, num\n  num = 0\n  n = 0\n  minimumNumber = 0 ! TODO\n  curtotal = 0\n  DO i = 1, SIZE(a)\n    curtotal = curtotal + a(i)\n  END DO\n  DO WHILE (n .eq. 0)\n    n = 1\n    DO j = 2, curtotal + num - 1\n      IF (MOD(curtotal + num, j) .eq. 0) THEN\n        n = 0\n      END IF\n    END DO\n    num = num + 1\n  END DO\n  minimumNumber = num - 1\n  end function minimumNumber\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83502,"user_id":76,"body":"module Solution\n  implicit none\ncontains\n  integer  function minimumNumber(a)\n    integer, dimension(:), intent(in) :: a\n    integer :: s, n\n    s = sum(a)\n    n = 0\n    do while (.true.)\n      if (isPrime(s + n)) then\n        minimumNumber = n\n        return\n      end if\n      n = n + 1\n    end do\n  end function minimumNumber\n  \n  logical pure function isPrime(n) result(res)\n    integer, intent(in) :: n\n    integer :: i\n    res = .true.\n    do i = 2, n - 1\n      if (mod(n, i) .eq. 0) then\n        res = .false.\n        exit\n      end if\n    end do\n  end function isPrime\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83503,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function minimumNumber(a)\n    integer, dimension(:), intent(in) :: a\n    \n    integer :: total\n    \n    total = sum(a)\n    minimumNumber = 0\n    if(primeQ(total)) return\n    do\n      minimumNumber = minimumNumber + 1\n      if(primeQ(total+minimumNumber)) return\n    end do\n  end function minimumNumber\n  \n  logical pure function primeQ(num)\n    implicit none\n    integer, intent(in) :: num\n    integer :: i\n    primeQ = .true.\n    do i=2,num\/2,1\n      if(mod(num,i)==0) then\n        primeQ = .false.\n        return\n      end if\n    end do\n  end function primeQ\n  \nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83504,"user_id":null,"body":"module Solution\n  implicit none\nCONTAINS\n\tINTEGER PURE FUNCTION minimumNumber(A)\n\tINTEGER, DIMENSION(:), intent(in) :: A\n\tINTEGER\t:: S, ADDENDANT\n\n\tminimumNumber \t= 0\n\tADDENDANT\t= 0\n\tS\t\t= SUM(A) + 0\n\n\tDO WHILE (.NOT.is_prime(S))\n\t\tS = S + 1\n\tEND DO\n\n\tminimumNumber = S - SUM(A)\n\tEND FUNCTION minimumNumber\n\n\n\tLOGICAL PURE FUNCTION is_prime(n) RESULT(res)\n\tINTEGER, INTENT(IN) :: n\n\tINTEGER :: i, a\n\tINTEGER, PARAMETER :: FermatTightness = 7\n\tINTEGER, PARAMETER :: primeListLength = 15\n\tINTEGER, PARAMETER, DIMENSION(primeListLength) :: primeList = (\/ 2, 3, 5, 7, 11 , 13, 17, 19, 23, 29, 31, 37, 41, 43, 47 \/)\n\n\n\tIF (n .eq. 1 .or. n .eq. 0) THEN\n\t\tres = .FALSE.\n\t\tRETURN\n\tEND IF\n\t\n\tIF (n .le. primeList(primeListLength)) THEN\n\t\t! First check if it actually belongs to the list\n\t\tDO i = 1,primeListLength\n\t\t\tIF (n .eq. primeList(i)) THEN\n\t\t\t\tres = .TRUE.\n\t\t\t\tRETURN\n\t\t\tEND IF\n\t\tEND DO\n\tELSE\n\t\t! Apply the filter\n\t\tDO i = 1,primeListLength\n\t\t\tIF (MOD(n, primeList(i)) .eq. 0) THEN\n\t\t\t\tres = .FALSE.\n\t\t\t\tRETURN\n\t\t\tEND IF\n\t\tEND DO\n\tEND IF\n\n\t! If the number passes up to here, apply Fermat\n\ta = 2\n\tDO WHILE (a .le. MIN(FermatTightness,n))\n\t\tIF (powmod(a,n-1,n) .eq. 1) THEN\n\t\t\ta = a +1\n\t\tELSE\n\t\t\tres = .False.\n\n\t\t\tRETURN\n\t\tEND IF\n\t\t\n\tEND DO\n\n\tres = .TRUE.\n\tRETURN\n\n\tEND FUNCTION is_prime\n\n\t! ---------------------------------------------------\n\t! ---------------------- POWMOD ---------------------\n\tINTEGER PURE FUNCTION powmod(b,e,m) RESULT(c)\n\tINTEGER, INTENT(IN)\t:: e, m\n\tINTEGER, INTENT(IN) :: b\t\t! Inputs\n\tINTEGER :: eprime\t\t! Auxiliaries\n\tc = 1\n\teprime = 0\n\tDO WHILE (eprime .lt. e)\n\t\teprime = eprime + 1\n\t\tc = MOD(b*c,m)\n\tEND DO\n\tEND FUNCTION powmod\n\t! ---------------------------------------------------\n\t! ---------------------------------------------------\n\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83505,"user_id":1228,"body":"module Solution\n  implicit none\ncontains\n\tinteger function minimumNumber(a) result(answer)\n    integer, dimension(:), intent(in) :: a\n\tinteger :: arrsum, nextp\n\tarrsum = sum(a)\n\tnextp = NEXTPRIME(arrsum)\n\tanswer = nextp - arrsum\n  end function minimumNumber\n  \nINTEGER FUNCTION NEXTPRIME( N ) result(answer)\n\n      INTEGER N, NUMBER, I\n      INTEGER NUMPRIMES\n      PARAMETER (NUMPRIMES = 168)\n      INTEGER PRIME(NUMPRIMES)\n      DATA PRIME \/ 2,   3,   5,   7,  11,  13,  17,  19,  23,  29,  31,  37,  41, &\n       43,  47,  53,  59,  61,  67,  71,  73,  79,  83,  89,  97, 101, &\n      103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, &\n      173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, &\n      241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, &\n      317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, &\n      401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, &\n      479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, &\n      571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, &\n      647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, &\n      739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, &\n      827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, &\n      919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997 \/\n\n      NUMBER = N\n\n      IF (NUMBER .LE. 3) THEN\t\t\t\t!if number .le. 3 then return number\n          answer = NUMBER\n          RETURN\n      ENDIF\n\n      IF (NUMBER .LE. 997) THEN\t\t\t\t!just search thru PRIME array\n         I = (-0.3034277E-04*NUMBER + 0.1918667)*NUMBER + 8.0918350\t!(see comments above)\n         I = MIN(I,NUMPRIMES)\t\t\t\t!don't let I go above 997\n         DO WHILE (PRIME(I) .LT. NUMBER)\t\t!Search upward for first prime greater than NUMBER\n            I = I + 1\n         ENDDO\n         DO WHILE (PRIME(I) .GE. NUMBER)\t\t!Search downward for first prime less than NUMBER,\n            I = I - 1\n         ENDDO\n         answer = PRIME(I+1)\t\t\t\t!then take next prime.\n         RETURN\n\n      ELSE\t\t\t\t\t\t!Else normal search for next prime\n\n         IF ( MOD(NUMBER,2) .EQ. 0 ) NUMBER = NUMBER + 1 !rule out even numbers.  They are not prime\n         I = 2\t\t\t\t\t\t !start with second prime since we only test odd numbers.\n         DO WHILE ( PRIME(I)*PRIME(I) .LE. NUMBER )\t !test for all primes .LE. SQRT(NUMBER)\n            IF ( MOD(NUMBER,PRIME(I)) .EQ. 0 ) THEN\t !it's not prime\n               NUMBER = NUMBER + 2\t\t\t !even numbers aren't prime\n               I = 2\t\t\t\t\t !start over again with new number\n            ELSE\n               I = I + 1\t\t\t\t !test with next prime\n               IF ( I .GT. NUMPRIMES) GOTO 10\t\t !exit loop.  NUMBER is relatively prime to first 168 primes.\n            ENDIF\n         ENDDO\n10       answer = NUMBER\n         RETURN\n\n      ENDIF\n\n      END FUNCTION NEXTPRIME  \n   \nend module Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83506,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function minimumNumber(a)\n    integer, dimension(:), intent(in) :: a\n    integer :: sum, sum2, i\n    logical :: done\n    done = .false.\n    \n    sum = 0\n    do i = 1, size(a)\n      sum = sum + a(i)\n    end do\n    sum2 = sum\n    \n    do while (done .eqv. .false.)\n      do i = 2, sum - 1\n        if (mod(sum, i) == 0) then\n          sum = sum + 1\n          exit\n        end if\n        if (i == sum - 1) then\n          done = .true.\n        end if\n      end do\n    end do\n    \n    minimumNumber = sum - sum2\n  end function minimumNumber\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83507,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer function minimumNumber(a)\n  integer, dimension(:), intent(in) :: a\n  integer i, j, k, l, sum, x\n  logical isP\n\n  sum = 0\n  isP = .false.\n  minimumNumber = 0\n  l = size(a)\n  if (l == 0) stop\n  do i=1, l\n    sum = sum + a(i)\n  end do\n  x = sum\n  if ( mod(sum, 2) .eq. 0) x = sum + 1\n  ! print *, l, sum\n\n  k = sqrt(real(x)) + 1\n  if (x < 9) then\n    Print *, \"All odd sums < 9 are prime & will give 0 iterations - return 0 or 1 (odd or even)\"\n    minimumNumber = x - sum\n    return\n  else if (k > 997) then\n    print *, \"Magnitude of sum may cause excessive run time - processing terminated\"\n    return\n  end if\n\n  do while (k < 999)  ! see above for 999 limit\n    do i=3, k, 2\n      if ( mod(x, i) .eq. 0 ) exit  ! Loop until a factor is found (or continue)\n      if (i .GE. k-1) isP = .true.\n    end do\n    if (isP) exit\n    x = x + 2\n    k = sqrt(real(x)) + 1  ! Higher values must have a smaller mulitplicand already checked\n  end do\n \n  minimumNumber = x - sum\n  end function minimumNumber\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5a972f30ba1bb5a2590000a0":[{"id":83508,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  function matrixSquareUp(b) result(matrix)\n    integer, intent(in) :: b\n    integer :: col\n    character(11), dimension(1:b, 1:b) :: matrix\n    character(len=2) :: tmp\n    matrix = 'x'\n    do col = 1,b\n      write(tmp,'(I2)') col\n      matrix(col:,b-col+1) =  adjustl(tmp)\n    end do\n    \n  end function matrixSquareUp\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83509,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n    pure subroutine triangularize(n,mat)\n        integer,intent(in) :: n\n        integer,dimension(n,n),intent(inout) :: mat\n        integer :: i,j\n        do i=1,n,1\n            do j=1,n,1\n                if(j.lt.i) mat(j,i)=0\n            end do\n        end do\n    end subroutine triangularize\n    pure function matrixSquareUp(n)\n        integer, intent(in) :: n\n        character(11), dimension(n,n) :: matrixSquareUp\n        integer,dimension(n,n) :: mat\n        integer :: i, j\n        character(100) :: cha\n        mat = reshape([([(j,j=n,1,-1)],i=1,n,1)],[n,n])\n        call triangularize(n,mat)\n        do i=1,n,1\n            do j=1,n,1\n                if(mat(i,j).eq.0)then\n                    matrixSquareUp(i,j)=\"x\"\n                else\n                    write(cha,*) mat(i,j)\n                    matrixSquareUp(i,j)=adjustl(cha)\n                end if\n            end do\n        end do\n        matrixSquareUp=transpose(matrixSquareUp(:,n:1:-1))\n    end function matrixSquareUp\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83510,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function matrixSquareUp(b) result(matrix)\n    integer, intent(in) :: b\n    character(11) :: matrix(b, b)\n    integer :: i, j, n\n    \n    do i = 1, b\n      do j = 1, b\n        if (j .le. b-i) then\n          matrix(i, j) = \"x\"\n        else\n          n = b-j+1\n          matrix(i, j) = \"\"\n          ! This is the tricky part\n          do while (n .gt. 0)\n            matrix(i, j) = char(48 + modulo(n, 10)) \/\/ matrix(i, j)\n            n = n \/ 10\n          end do\n        end if\n      end do\n    end do\n  end function matrixSquareUp\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83511,"user_id":17,"body":"module Solution\n  implicit none\ncontains\n  pure function matrixSquareUp(b) result(matrix)\n    integer, intent(in) :: b\n    character(11), dimension(:, :), allocatable :: matrix\n    integer :: i, j\n    allocate(matrix(b, b))\n    do i = 1, b\n      do j = 1, b\n        if (b - i >= j) then\n          write(matrix(i, j), \"(A1)\") \"x\"\n        else\n          write(matrix(i, j), \"(I0)\") b - j + 1\n        end if\n      end do\n    end do\n  end function matrixSquareUp\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5a97387e5ee396e70a00016d":[{"id":83512,"user_id":null,"body":"module Solution\n  implicit none\n  private\n  public :: pofi\ncontains\n  pure function pofi(n)\n    integer, intent(in) :: n\n    character(:), allocatable :: pofi\n    character(len=2), dimension(0:3) :: values\n    \n    values = [character(len=2) :: \"1\", \"i\", \"-1\", \"-i\"]\n \n    pofi = trim( values( modulo(n, 4) ) )\n  end function pofi\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83513,"user_id":null,"body":"module Solution\n  implicit none\n  private\n  public :: pofi\ncontains\n  pure function pofi(n)\n    integer, intent(in) :: n\n    integer :: r\n    character(:), allocatable :: pofi\n    \n    r = mod(n,4)\n    \n    select case (r)\n      case (0)\n        pofi = \"1\"\n      case (1)\n        pofi = \"i\"\n      case (2)\n        pofi = \"-1\"\n      case (3)\n        pofi = \"-i\"\n      end select\n      \n  end function pofi\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83514,"user_id":null,"body":"module Solution\n  implicit none\n  private\n  public :: pofi\n  character(2), dimension(4), parameter :: powersOfI = (\/\"1 \", \"i \", \"-1\", \"-i\"\/) !Create array with 4 values of 2 characters each\ncontains\n  pure function pofi(n)\n    integer, intent(in) :: n\n    character(:), allocatable :: pofi\n    pofi = trim(powersOfI(mod(n, 4) + 1)) !Check n with module 4 to go through the array and trim for any white spaces\n  end function pofi\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83515,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  function pofi(n)result(evaluation)\n    integer :: n\n    character(:), allocatable :: evaluation\n    if (modulo(n, 4) == 0) then\n      evaluation = \"1\"\n    else if (modulo(n, 4) == 1) then\n      evaluation = \"i\"\n    else if (modulo(n, 4) == 2) then \n      evaluation = \"-1\"\n    else\n      evaluation = \"-i\"\n    end if \n  end function pofi\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83516,"user_id":53,"body":"module Solution\n  implicit none\n  private\n  public :: pofi\ncontains\n  pure function pofi(n)\n    integer, intent(in) :: n\n    character(:), allocatable :: pofi\n    character (len=4), Allocatable :: fcycle(:)\n    fcycle = [Character(len=4) :: \"1\", \"i\", \"-1\", \"-i\"]\n    pofi = trim(fcycle(modulo(n, 4) + 1))\n  end function pofi\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83517,"user_id":76,"body":"module Solution\n  implicit none\n  private\n  public :: pofi\ncontains\n  function pofi(n)\n    integer, intent(in) :: n\n    character(:), allocatable :: pofi\n    character(2), dimension(4) :: powers = (\/'1 ','i ','-1','-i'\/)\n    pofi = trim(powers(modulo(n, 4) + 1))\n  end function pofi\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83518,"user_id":492,"body":"module Solution\n  implicit none\n  private\n  public :: pofi\ncontains\n  function pofi(n) RESULT(s)\n    integer, intent(in) :: n\n    integer :: c\n    Character(:), allocatable :: s\n    c = modulo(n, 4)\n    if (c == 0) then \n      s = \"1\"\n    else if (c == 1) then\n      s = \"i\"\n    else if (c == 2) then \n      s = \"-1\"\n    else \n      s = \"-i\"\n    end if\n  end function pofi\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83519,"user_id":null,"body":"module Solution\n  implicit none\n  private\n  public :: pofi\ncontains\n  pure function pofi(n)\n    integer, intent(in) :: n\n    character(:), allocatable :: pofi\n    \n    select case(mod(n,4))\n      case(0)\n        pofi = \"1\"\n      case(1)\n        pofi = \"i\"\n      case(2)\n        pofi = \"-1\"\n      case(3)\n        pofi = \"-i\"\n      case default\n        pofi = \"\"\n     end select\n    \n  end function pofi\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83520,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function pofi(n)\n    integer, intent(in) :: n\n    character(:), allocatable :: pofi\n    \n    select case (MODULO(n, 4))\n      case (0)\n        pofi = \"1\"\n      case (1)\n        pofi = \"i\"\n      case (2)\n        pofi = \"-1\"\n      case (3)\n        pofi = \"-i\"\n    end select\n  end function pofi\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83521,"user_id":null,"body":"module Solution\n  implicit none\n  private\n  public :: pofi\ncontains\n  pure function pofi(n)\n    integer, intent(in) :: n\n    character(:), allocatable :: pofi\n    \n    integer :: i\n    i = modulo(n,4)\n    \n    select case(i)\n    case(0)\n      allocate(character(len=1) :: pofi)\n      pofi = \"1\"\n    case(1)\n      allocate(character(len=1) :: pofi)\n      pofi = \"i\"    \n    case(2)\n      allocate(character(len=2) :: pofi)\n      pofi = \"-1\"\n    case(3)\n      allocate(character(len=2) :: pofi)\n      pofi = \"-i\"\n    end select\n    \n  end function pofi\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5a9996fa8e503f2b4a002e7a":[{"id":83522,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function oddNotPrime(n)\n    implicit none\n    integer, intent(in) :: n\n    integer :: oddNotPrime, num, i, limit\n    logical :: is_prime\n\n    oddNotPrime = 1\n    do num=3,n,2\n        is_prime = .true.\n        i = 3\n        limit = INT(SQRT(REAL(num))) + 1\n        do while ( is_prime .and. i < limit )\n            is_prime = MOD(num, i) \/= 0\n            i = i + 2\n        end do\n        if ( .not. is_prime ) then\n            oddNotPrime = oddNotPrime + 1\n        end if \n    enddo\n  end function oddNotPrime\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83523,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  function oddNotPrime(n)\n    integer, intent(in) :: n\n    integer :: oddNotPrime, i, j, max\n    logical :: prime\n    oddNotPrime = 1\n    do i = 3, n, 2\n      prime = .true.\n      max = CEILING(SQRT(REAL(i)+1))\n      do j = 2, max\n        if (mod(i,j) == 0) then\n          prime = .false.\n          go to (900) 1\n        end if\n      end do\n      \n900   if (.not. prime) then\n        oddNotPrime = oddNotPrime + 1\n      end if\n    end do\n  end function oddNotPrime\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83524,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function oddNotPrime(n)\n    integer, intent(in) :: n\n    integer :: oddNotPrime,i,j\n    oddNotPrime = 0 ! TODO\n    \n    outer: do i=3,n,2\n          \n            inner: do j= 2, i-1\n                  if(mod(i,j)==0) then\n                  oddNotPrime=oddNotPrime+1\n                  exit\n                  end if\n            end do inner\n    \n    \n    end do outer\n    oddNotPrime=oddNotPrime+1\n  end function oddNotPrime\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83525,"user_id":null,"body":"module Solution\n\n  implicit none\n  \ncontains\n\n    pure logical function is_prime(number)\n        integer,intent(in) :: number\n        integer :: i\n        is_prime=.false.\n        if(number.lt.3) return\n        if(mod(number,2).eq.0) return\n        do i=3,nint(sqrt(real(number))),2\n            if(mod(number,i).eq.0) return\n        end do\n        is_prime=.true.\n    end function is_prime\n    \n    pure integer function oddNotPrime(n)\n        integer, intent(in) :: n\n        integer :: i\n        oddNotPrime=0\n        do i=1,n,2\n            if(.not.is_prime(i)) oddNotPrime=oddNotPrime+1\n        end do\n    end function oddNotPrime\n    \nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83526,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer function oddNotPrime(n)\n    integer, intent(in) :: n\n    logical :: primes(n)\n    integer :: i, j\n    primes = .true.\n    primes(1) = .false.\n    oddNotPrime = 0\n    \n    do i = 2, n\n      if (.not. primes(i)) cycle\n      \n      do j = i*i, n, i\n        primes(j) = .false.\n      end do\n    end do\n    \n    do i = 1, n, 2\n      if (.not. primes(i)) oddNotPrime = oddNotPrime + 1\n    end do\n  end function oddNotPrime\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83527,"user_id":null,"body":"module Solution\n  implicit none\n\ninteger, dimension(:), allocatable :: primes\n\ncontains\n  pure function oddNotPrime(n)\n    integer, intent(in) :: n    \n    integer :: i\n    integer :: oddNotPrime\n    integer, dimension(:), allocatable :: primes\n    if (.not.allocated(primes)) then\n      primes = sieve()\n    end if\n    i = 1\n    oddNotPrime = 1\n    do while(primes(i) <= n)\n      oddNotPrime = oddNotPrime + 1\n      i = i + 1\n    end do\n  end function oddNotPrime\n  \n  pure function sieve() result(primes)  \n    logical, dimension(2:10000) :: flags\n    integer, dimension(:), allocatable :: primes\n    integer :: i, j\n    flags(:) = .false.\n    do i = 2, 10000\n      if (.not.flags(i)) then\n        j = 2 * i\n        do while (j <= 10000)\n          flags(j) = .true.\n          j = j + i\n        end do\n      end if\n    end do\n    allocate(primes(10000))\n    i = 3\n    j = 1\n    do while (i <= 10000)\n      if (flags(i)) then\n        primes(j) = i\n        j = j + 1\n      end if\n      i = i + 2\n    end do\n  end function\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83528,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  function oddNotPrime(n)\n  integer, intent(in) :: n\n  integer :: oddNotPrime, i, k, m, x \n\n  m = 1\n  x = n  !(can't change n)\n  print *, x\n  if (mod(n,2) == 0) x = n - 1  !x odd\n\n  do while (x > 3)\n  k = sqrt(real(x))\n   if (mod(k,2) == 0) k = k - 1  !a bit faster maybe!\n    do i=3, k, 2\n      if (x == i) cycle\n      if (mod(x, i) == 0) then  !not prime\n        m = m + 1\n        exit\n      end if\n    end do\n    x = x - 2 \n  end do\n\n  oddNotPrime = m\n  end function oddNotPrime\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83529,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function oddNotPrime(n)\n    integer, intent(in) :: n\n    integer :: oddNotPrime, i, x\n    oddNotPrime = 0\n    do i = 3, n, 2\n      do x = 3, i - 1\n        if (MOD(i, x) == 0) then\n          oddNotPrime = oddNotPrime + 1\n          exit\n        end if\n      end do\n    end do\n    oddNotPrime = oddNotPrime + 1\n  end function oddNotPrime\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83530,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function oddNotPrime(n)\n    integer oddNotPrime, i, j\n    integer, intent(in) :: n\n    oddNotPrime = 1\n    do i = 3, n, 2\n      do j = 3, int(sqrt(real(i)))\n        if (mod(i, j)==0) then \n          oddNotPrime = oddNotPrime + 1\n          exit \n        end if\n      end do\n    end do\n  end function oddNotPrime\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83531,"user_id":17,"body":"module Solution\n  implicit none\n  private :: isPrime\ncontains\n  pure function oddNotPrime(n)\n    integer, intent(in) :: n\n    integer :: i, oddNotPrime\n    oddNotPrime = 0\n    do i = 1, n, 2\n      if (.not. isPrime(i)) then\n        oddNotPrime = oddNotPrime + 1\n      end if\n    end do\n  end function oddNotPrime\n  pure function isPrime(n)\n    integer, intent(in) :: n\n    integer :: i\n    logical :: isPrime\n    if (n <= 2) then\n      isPrime = n == 2\n    else if (mod(n, 2) == 0) then\n      isPrime = .false.\n    else\n      isPrime = .true.\n      do i = 3, floor(sqrt(real(n))), 2\n        if (mod(n, i) == 0) then\n          isPrime = .false.\n        end if\n      end do\n    end if\n  end function isPrime\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5a9e86705ee396d6be000091":[{"id":83532,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function checkThreeAndTwo(a) result(l)\n    character, dimension(5), intent(in) :: a \n    logical :: l \n    \n    integer :: i, j, k\n    \n    i = sum(index(a,\"a\"))\n    j = sum(index(a,\"b\"))\n    k = sum(index(a,\"c\"))\n    \n    if ((i>3).or.(j>3).or.(k>3)) then\n      l = .false.\n    else if ((i+j==5).or.(i+k==5).or.(j+k==5)) then\n      l = .true.\n    else\n      l = .false.\n    end if\n    \n  end function checkThreeAndTwo\n  \nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83533,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function checkThreeAndTwo(a) result(l)\n    character, dimension(5), intent(in) :: a ! The array of 5 values passed in\n    logical :: l ! The value to be returned to the caller\n    integer :: m(3), n(5)\n    integer :: i\n    m(:) = 0\n    n(:) = 0\n    l = .false. ! TODO: Determine whether `a` meets the criteria specified in the Description\n    do i = 1, 5\n      if (a(i) == 'a') then\n        m(1) = m(1) + 1\n      else if (a(i) == 'b') then\n        m(2) = m(2) + 1\n      else\n        m(3) = m(3) + 1\n      end if\n    end do\n    do i = 1, 3\n      n(m(i)) = n(m(i)) + 1\n    end do\n    if (n(2) == 1 .and. n(3) == 1) then\n      l = .true.\n    end if\n  end function checkThreeAndTwo\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83534,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  logical pure function checkThreeAndTwo(a) result(l)\n    character, dimension(5), intent(in) :: a ! The array of 5 values passed in\n    integer :: nentries(3)\n    \n    nentries(1) = count(a == \"a\")\n    nentries(2) = count(a == \"b\")\n    nentries(3) = count(a == \"c\")\n    \n    l = count(nentries > 0) == 2 .and. count(nentries > 3) == 0\n    \n    \n    \n  end function checkThreeAndTwo\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83535,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  logical pure function checkThreeAndTwo(a) result(l)\n    character, dimension(5), intent(in) :: a ! The array of 5 values passed in\n\n \n    l = (count(a == \"a\") == 0 .and. count(a == \"b\") >= 2 .and. count(a == \"c\") >= 2) .or. &\n        (count(a == \"a\") >= 2 .and. count(a == \"b\") == 0 .and. count(a == \"c\") >= 2) .or. &\n        (count(a == \"a\") >= 2 .and. count(a == \"b\") >= 2 .and. count(a == \"c\") == 0)\n  end function checkThreeAndTwo\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83536,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  logical pure function checkThreeAndTwo(a)\n    character, dimension(5), intent(in) :: a ! The array of 5 values passed in\n    character :: chars(2)\n    integer :: counts(2), i, char_pos\n    \n    counts(:) = 0\n    char_pos = 1\n    \n    do i = 1, 5\n      select case(char_pos)\n      case(1)\n        chars(1) = a(i)\n        char_pos = char_pos + 1\n      case(2)\n        if (a(i) \/= chars(1)) then\n            chars(2) = a(i)\n            char_pos = char_pos + 1\n          end if\n      end select\n      \n      if (chars(1) == a(i)) counts(1) = counts(1) + 1\n      if (chars(2) == a(i)) counts(2) = counts(2) + 1\n    end do\n    \n    checkThreeAndTwo = (sum(counts) == 5 .and. abs(counts(2) - counts(1)) == 1)\n  end function checkThreeAndTwo\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83537,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function checkThreeAndTwo(a) result(l)\n    character, dimension(5), intent(in) :: a ! The array of 5 values passed in\n    logical :: l ! The value to be returned to the caller\n    integer :: i, x\n    l = .TRUE.\n    do i = 1, 5\n      x = count(a .EQ. a(i))\n      if (x .NE. 2 .AND. x .NE. 3) l = .FALSE.\n    end do\n  end function checkThreeAndTwo ! No optimization is needed as array is of fixed small length\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83538,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function checkThreeAndTwo(a) result(l)\n    character, dimension(5), intent(in) :: a ! The array of 5 values passed in\n    logical :: l ! The value to be returned to the caller\n    integer :: i\n    integer, dimension(3) :: nb\n    \n    nb = 0\n    do i=1, 5\n      if (a(i) .eq. 'a') then\n        nb(1) = nb(1) + 1\n      else if (a(i) .eq. 'b') then\n        nb(2) = nb(2) + 1\n      else if (a(i) .eq. 'c') then\n        nb(3) = nb(3) + 1\n      endif\n    end do\n    \n    l = .false.\n    if (nb(1) .eq. 0) then\n      if (nb(2) .eq. 2 .or. nb(2) .eq. 3) then\n        l = .true.\n      endif\n    else if (nb(1) .eq. 2) then\n      if (nb(2) .eq. 0 .or. nb(2) .eq. 3) then\n        l = .true.\n      endif\n    else if (nb(1) .eq. 3) then\n      if (nb(2) .eq. 0 .or. nb(2) .eq. 2) then\n        l = .true.\n      endif\n    endif\n  end function checkThreeAndTwo\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83539,"user_id":168,"body":"module Solution\n  implicit none\ncontains\n  pure function checkThreeAndTwo(arr) result(l)\n    character, dimension(5), intent(in) :: arr ! The array of 5 values passed in\n    logical :: l ! The value to be returned to the caller\n    integer :: a, b, c, i\n    a = 0\n    b = 0\n    c = 0\n    do i = 1, 5\n      select case (arr(i))\n        case ('a')\n          a = a + 1\n        case ('b')\n          b = b + 1\n        case ('c')\n          c = c + 1\n      end select\n    end do\n    l = (a == 2 .or. b == 2 .or. c == 2) .and. (a == 3 .or. b == 3 .or. c == 3)\n  end function checkThreeAndTwo\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83540,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function checkThreeAndTwo(a) result(l)\n    character, dimension(5), intent(in) :: a ! The array of 5 values passed in\n    logical :: l ! The value to be returned to the caller\n    ! l = .false. ! TODO: Determine whether `a` meets the criteria specified in the Description\n    integer :: na, nb, nc, i\n    \n    na = 0\n    nb = 0\n    nc = 0\n    do i = 1, 5\n      select case (a(i))\n        case ('a')\n          na = na + 1\n        case ('b')\n          nb = nb + 1\n        case ('c')\n          nc = nc + 1\n      end select\n    end do\n    l = (na == 3 .or. nb == 3 .or. nc == 3) .and. (na == 2 .or. nb == 2 .or. nc == 2)\n  end function checkThreeAndTwo\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83541,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  logical function checkThreeAndTwo(arr) result(l)\n    character, dimension(5), intent(in) :: arr\n    integer :: a, b, c, i\n    a = 0\n    b = 0\n    c = 0\n    \n    do i = 1, 5\n      select case (arr(i))\n      case (\"a\")\n        a = a + 1\n      case (\"b\")\n        b = b + 1\n      case (\"c\")\n        c = c + 1\n      end select\n    end do\n    \n    l = (a .eq. 3 .and. b .eq. 2) .or. (a .eq. 3 .and. c .eq. 2) .or. (b .eq. 3 .and. a .eq. 2) &\n        .or. (b .eq. 3 .and. c .eq. 2) .or. (c .eq. 3 .and. a .eq. 2) .or. (c .eq. 3 .and. b .eq. 2)\n  end function checkThreeAndTwo\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5aa736a455f906981800360d":[{"id":83542,"user_id":17,"body":"module Solution\n  implicit none\ncontains\n  pure function feast(beast, dish) result(dishAllowed)\n    character(*), intent(in) :: beast, dish\n    logical :: dishAllowed\n    dishAllowed = beast(1:1) == dish(1:1) .and. beast(len(beast):len(beast)) == dish(len(dish):len(dish))\n  end function feast\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83543,"user_id":53,"body":"module Solution\n  implicit none\ncontains\n  function feast(beast, dish) result(dishAllowed)\n    character(*), intent(in) :: beast, dish\n    logical :: dishAllowed\n    dishAllowed = (beast(1:1) == dish(1:1) .and. beast(len(beast):len(beast)) == dish(len(dish):len(dish)))\n  end function feast\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83544,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function feast(beast, dish) result(dishAllowed)\n    character(*), intent(in) :: beast, dish\n    logical :: dishAllowed\n    dishAllowed = beast(1:1)==dish(1:1).and.beast(len(beast):len(beast))==dish(len(dish):len(dish))!TOO\n  end function feast\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83545,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function feast(beast, dish) result(dishAllowed)\n    character(*), intent(in) :: beast, dish\n    logical :: dishAllowed\n    dishAllowed = (dish(1:1)==beast(1:1)) .and. (dish(len(dish):)==beast(len(beast):))! TODO\n  end function feast\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83546,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function feast(beast, dish) result(dishAllowed)\n    character(*), intent(in) :: beast, dish\n    logical :: dishAllowed\n    dishAllowed = .false. ! TODO\n    if (beast(1:1) == dish(1:1) .and. beast(len(beast):len(beast)) == dish(len(dish):len(dish))) then\n      dishAllowed = .true.\n    end if\n  end function feast\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83547,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function feast(beast, dish) result(dishAllowed)\n    character(*), intent(in) :: beast, dish\n    logical :: dishAllowed\n    integer:: lb,ld\n    \n    lb=len_trim(beast)\n    ld=len_trim(dish)\n \n    If (beast(1:1) .eq. dish(1:1) .and. beast(lb:lb) .eq. dish(ld:ld)) then\n    dishAllowed = .true.\n    else\n    dishAllowed = .false.\n    end if\n    \n  end function feast\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83548,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function feast(beast, dish) result(dishAllowed)\n    character(*), intent(in) :: beast, dish\n    logical :: dishAllowed\n    dishAllowed = (dish(:1) == beast(:1)) .and. (dish(len(dish):)==beast(len(beast):))\n  end function feast\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83549,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function feast(beast, dish) result(dishAllowed)\n    character(*), intent(in) :: beast, dish\n    logical :: dishAllowed\n    dishAllowed = (beast(len(beast):len(beast)) .eq. dish(len(dish):len(dish))) .and. (beast(1:1) .eq. dish(1:1))\n  end function feast\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83550,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function feast(beast, dish) result(dishAllowed)\n    character(*), intent(in) :: beast, dish\n    integer :: a,b\n    logical :: dishAllowed\n    a = len(beast)\n    b = len(dish)\n    if (beast(1:1) .eq. dish(1:1) .and. beast(a:a) .eq. dish(b:b)) then\n      dishAllowed = .true.\n    else\n      dishAllowed = .false. ! TODO\n    end if\n  end function feast\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83551,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function feast(beast, dish) result(dishAllowed)\n    character(*), intent(in) :: beast, dish\n    logical :: dishAllowed\n    dishAllowed = .false.\n    \n    if (beast(1:1) == dish(1:1) .and. beast(len(beast):len(beast)) == dish(len(dish):len(dish))) then\n      dishAllowed = .true.\n    end if\n    \n  end function feast\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5aa99584fd5777ee9a0001f1":[{"id":83552,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function fatFingers(s) result(output)\n    character(len=*), intent(in) :: s\n    character(:), allocatable :: output ! What Freddy actually types\n    character(*), parameter   :: caps = 'BCDEFGHIJKLMNOPQRSTUVWXYZbcdefghijklmnopqrstuvwxyz'\n    character(*), parameter   :: norm = 'bcdefghijklmnopqrstuvwxyzBCDEFGHIJKLMNOPQRSTUVWXYZ'\n    logical :: shift\n    Integer :: i,j\n    \n    output = \"\"\n    shift = .false.\n\n    Do i = 1, len(s)\n        If (s(i:i) == 'a' .or. s(i:i) == 'A') then\n          shift = .not. shift\n          cycle\n        End If\n        j = index(norm, s(i:i))\n        If (shift .and. (j \/= 0)) then\n          output = output\/\/caps(j:j)\n        Else\n          output = output\/\/s(i:i)\n        End If\n    End Do\n\n  end function fatFingers\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83553,"user_id":null,"body":"module Solution\n  implicit none\n  private :: switch_case\ncontains\n  character pure function switch_case(c) result(res)\n    character, intent(in) :: c\n    integer, parameter :: a_code = iachar(\"a\")\n    integer, parameter :: z_code = iachar(\"z\")\n    integer :: c_code\n    \n    c_code = ior(iachar(c), 32)  ! Toggle to lowercase\n    if (a_code <= c_code .and. c_code <= z_code) then\n      res = achar(ieor(iachar(c), 32))  ! Toggle the case bit with bitwise XOR\n    else\n      res = c\n    end if\n  end function switch_case\n\n  pure function fatFingers(s) result(output)\n    character(len=*), intent(in) :: s ! What Freddy intended to type\n    character(:), allocatable :: output ! What Freddy actually types\n    integer :: i\n    logical :: capslocked\n\n    output = \"\"\n    capslocked = .false.\n\n    do i = 1, len(s)\n      if ( any(s(i:i) == [\"a\", \"A\"]) ) then\n        capslocked = .not. capslocked  ! Toggle capslock\n      else if (capslocked) then\n        output = output \/\/ switch_case(s(i:i))\n      else\n        output = output \/\/ s(i:i)\n      end if\n    end do\n  end function fatFingers\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83554,"user_id":168,"body":"module Solution\n  implicit none\ncontains\n  function fatFingers(s) result(output)\n    character(len=*), intent(in) :: s ! What Freddy intended to type\n    character(:), allocatable :: output ! What Freddy actually types\n    character :: ch\n    integer :: i\n    logical :: caps\n    output = \"\"\n    caps = .false.\n    do i = 1, len(s)\n      ch = s(i:i)\n      if (ch == 'a' .or. ch == 'A') then\n        caps = .not. caps\n      else\n        if (caps .and. ('A' <= ch .and. ch <= 'Z' .or. 'a' <= ch .and. ch <= 'z')) then\n          ch = achar(xor(iachar(ch), 32))\n        end if\n        output = output \/\/ ch\n      end if\n    end do\n    \n  end function fatFingers\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83555,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function fatFingers(s) result(output)\n    character(len=*), intent(in) :: s ! What Freddy intended to type\n    character(:), allocatable :: output ! What Freddy actually types\n    integer :: i, c ! c for character\n    logical :: capslock\n    output = \"\"\n    capslock = .false.\n    \n    do i = 1, len(s)\n      c = ichar(s(i:i))\n      if (c .eq. 65 .or. c .eq. 97) then\n        capslock = .not. capslock\n      else if (capslock .and. c .gt. 97 .and. c .le. 122) then\n        output = output \/\/ char(c-32)\n      else if (capslock .and. c .gt. 65 .and. c .le. 90) then\n        output = output \/\/ char(c+32)\n      else\n        output = output \/\/ s(i:i)\n      end if\n    end do\n  end function fatFingers\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83556,"user_id":null,"body":"module solution\n    implicit none\n    character(len=*),parameter :: lchars=\"abcdefghijklmnopqrstuvwxyz\"\n    character(len=*),parameter :: uchars=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    contains\n    \n    pure logical function is_l(cha)\n        character,intent(in) :: cha\n        is_l = .false.\n        if(index(lchars,cha)==0) return\n        is_l = .true.\n    end function is_l\n    \n    pure logical function is_u(cha)\n        character,intent(in) :: cha\n        is_u = .false.\n        if(index(uchars,cha)==0) return\n        is_u = .true.\n    end function is_u\n    \n    pure subroutine l_2_u(cha)\n        character,intent(inout) :: cha\n        integer :: pos\n        pos = index(lchars,cha)\n        cha = uchars(pos:pos)\n    end subroutine l_2_u\n    \n    pure subroutine u_2_l(cha)\n        character,intent(inout) :: cha\n        integer :: pos\n        pos = index(uchars,cha)\n        cha = lchars(pos:pos)\n    end subroutine u_2_l\n    \n    pure function fatFingers(s) result(output)\n        character(len=*), intent(in) :: s\n        character(:), allocatable :: output\n        integer :: i, length\n        logical :: flag\n        character :: cha\n        output = \"\"\n        length = len(s)\n        flag = .false.\n        do i=1,length,1\n            cha = s(i:i)\n            if(cha==\"a\".or.cha==\"A\") then\n                flag=.not.flag\n            else    \n                if(flag)then\n                    if(is_l(cha))then\n                        call l_2_u(cha)\n                    else if(is_u(cha)) then\n                        call u_2_l(cha)\n                    end if\n                end if            \n                output=output\/\/cha\n            end if\n        end do\n    end function fatFingers\n    \nend module solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83557,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  function swapcase(c) result(output)\n    ! Swap the case of the character, assume one long\n    character(len=*), intent(in) :: c\n    character(:), allocatable :: output\n    character(len=26) :: lower\n    character(len=26) :: upper\n    integer :: idxl, idxu\n    lower = \"abcdefghijklmnopqrstuvwxyz\"\n    upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    idxl = index(lower, c)\n    idxu = index(upper, c)\n    if (idxl .ne. 0) then\n      output = upper(idxl:idxl)\n    else if (idxu .ne. 0) then\n      output = lower(idxu:idxu)\n    else\n      output = c\n    end if\n  end function swapcase\n  function fatFingers(s) result(output)\n    character(len=*), intent(in) :: s ! What Freddy intended to type\n    character(:), allocatable :: output ! What Freddy actually types\n    logical :: caps\n    integer :: i\n    caps = .false.\n    output = \"\"\n    do i = 1,len(s)\n      if ( s(i:i) == 'a' .or. s(i:i) == 'A' ) then\n        caps = .not. caps\n      else if (caps) then\n        output = output \/\/ swapcase(s(i:i))\n      else\n        output = output \/\/ s(i:i)\n      end if\n    end do\n  end function fatFingers\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83558,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function capsed(c)\n    character(1) capsed\n    character(1), intent(in) :: c\n    if (c>='a' .and. c<='z') then\n      capsed = char(ichar(c)-32)\n    else if (c>='A' .and. c<='Z') then\n      capsed = char(ichar(c)+32)\n    else   \n      capsed = c\n    end if\n  end \n  pure function fatFingers(s) result(output)\n    character(len=*), intent(in) :: s\n    character(:), allocatable :: output\n    logical capsON\n    character(1) c\n    integer i\n    output = \"\"\n    capsON = .false.\n    do i = 1, len(s)\n      c = s(i:i)\n      if (c=='a' .or. c=='A') then\n        capsON = .not. capsON\n      else\n        if (capsON) c = capsed(c)\n        output = output\/\/c\n      end if  \n    end do\n  end function fatFingers\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83559,"user_id":1657,"body":"module Solution\n  implicit none\ncontains\n  function fatFingers(s) result(output)\n    character(len=*), intent(in) :: s ! What Freddy intended to type\n    character(:), allocatable :: output ! What Freddy actually types\n    Character(26), Parameter :: up = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    Character(26), Parameter :: low = 'abcdefghijklmnopqrstuvwxyz'\n    integer :: i, ind\n    logical :: isUpper \n    \n    isUpper = .false.\n    \n    DO i = 1, len(s)\n      print *, s(i:i)\n      \n      IF (verify(s(i:i), 'Aa') == 0) THEN\n        IF (isUpper) THEN\n          isUpper = .false.\n        ELSE\n          isUpper = .true.\n        END IF\n        print *, isUpper\n        print *, 'FOUnd A'\n        cycle\n      END IF\n      \n      IF (isUpper) THEN\n        IF (INDEX(low, s(i:i)) \/= 0) THEN\n          print *, 'lowercase', s(i:i)\n          ind = INDEX(low, s(i:i))\n          \n          output = output \/\/ up(ind:ind)\n          cycle\n        ELSE IF (INDEX(up, s(i:i)) \/= 0) THEN\n          print *, 'uppercase', s(i:i)\n          ind = INDEX(up, s(i:i))\n          \n          output = output \/\/ low(ind:ind)\n          cycle\n        END IF\n      END IF\n      \n      output = output \/\/ s(i:i)\n    END DO\n    \n  end function fatFingers\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83560,"user_id":17,"body":"module Solution\n  implicit none\ncontains\n  pure function fatFingers(s) result(output)\n    character(len=*), intent(in) :: s\n    character(:), allocatable :: output\n    logical :: capsLock\n    integer :: i, c\n    capsLock = .false.\n    output = \"\"\n    do i = 1, len(s)\n      c = ichar(s(i:i))\n      if (c == 65 .or. c == 97) then\n        capsLock = .not. capsLock\n      else\n        if (capsLock) then\n          if (c >= 65 .and. c < 91) then\n            output = output \/\/ char(c + 32)\n          else if (c >= 97 .and. c < 123) then\n            output = output \/\/ char(c - 32)\n          else\n            output = output \/\/ char(c)\n          end if\n        else\n          output = output \/\/ char(c)\n        end if\n      end if\n    end do\n  end function fatFingers\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5ab3495595df9ec78f0000b4":[{"id":83561,"user_id":168,"body":"module Solution\n  implicit none\ncontains\n  pure function binaryToString(binary) result(output)\n    character(*), intent(in) :: binary\n    character(:), allocatable :: output\n    character :: ch\n    integer :: i, v\n    output = \"\"\n    v = 0\n    do i = 3, len(binary)\n      ch = binary(i:i)\n      if (ch == 'b') then\n        output = output \/\/ achar(v \/ 2)\n        v = 0\n      else\n        v = 2 * v + iachar(ch) - 48\n      end if\n    end do\n    if (len(binary) > 0) then\n      output = output \/\/ achar(v)\n    end if\n  end function binaryToString\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83562,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function binaryToString(binary) result(output)\n    implicit none\n    character(*), intent(in) :: binary\n    character(:), allocatable :: output\n    character(len=2), parameter :: test = \"0b\"\n    integer :: current,next,i,to_int\n    current=2\n    i=1\n    allocate(character(len=200) :: output)\n    do while(index(binary(current:),test) .ne. 0)\n        next=index(binary(current:),test)\n        read(binary(current+1:current+next-2),'(b8)') to_int\n        output(i:)=achar(to_int)\n        i=i+1\n        current=current+next\n    end do\n    if (len(binary) .ne. 0) then\n      read(binary(current+1:),'(b8)') to_int\n      output(i:)=achar(to_int)\n    else\n      output(i:)=\"\"\n    end if\n    output=trim(output)\n  end function binaryToString\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83563,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  function binaryToString(binary) result(output)\n    character(*), intent(in) :: binary\n    character(:), allocatable :: output\n    integer :: i, c, mul\n    logical :: passNext\n    output = \"\"\n    c = 0\n    mul = 1\n    passNext = .false.\n    \n    do i = len(binary), 1, -1\n      if (passNext) then\n        passNext = .false.\n        cycle\n      end if\n      \n      if (binary(i:i) .eq. \"b\") then\n        mul = 1\n        output = char(c) \/\/ output\n        c = 0\n        passNext = .true.\n        cycle\n      end if\n      \n      c = c + mul * (ichar(binary(i:i))-48)\n      \n      mul = mul * 2\n    end do\n  end function binaryToString\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83564,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  subroutine BinToInt(str,ich) \n     character(*), intent(in) :: str\n     integer, intent(out) :: ich\n     integer :: j, n\n     \n     n = 0\n     ich = 0\n     do j = len_trim(str),1,-1\n        if (str(j:j).eq.'1') then\n           ich = ich + 2**n\n        endif\n        n = n + 1\n     enddo\n     return\n  end subroutine BinToInt\n\n  function binaryToString(binary) result(output)\n    character(*), intent(in) :: binary\n    character(:), allocatable :: output\n    character(len=15) :: letters\n    integer :: lenb, nbin, i, j1, j2, k, stidx, endidx, ich\n    \n    lenb = len(binary)\n\n    j1 = 3\n    j2 = 0\n    stidx = 0\n    endidx = 0\n    output = \"\"\n    do while(j1.le.lenb)\n       if ((stidx.eq.0).and.(binary(j1:j1).ne.'b')) then\n          stidx = j1\n       endif\n       if (stidx.gt.0) then\n          if (binary(j1:j1).eq.'b') endidx = j1-2\n          if (j1.eq.lenb) endidx = j1\n          if (endidx.gt.0) then\n             j2 = j2 + 1\n             letters = trim(adjustl(binary(stidx:endidx)))\n             call BinToInt(letters,ich)\n             output = output\/\/achar(ich)\n             stidx = 0\n             endidx = 0             \n          endif\n       endif\n       j1 = j1 + 1\n    enddo\n  end function binaryToString\n   \nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83565,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  function binaryToString(binary) result(output)\n    character(*), intent(in) :: binary\n    character(:), allocatable :: output,s,c\n    integer::i,k,n\n    output = \"\" ! TODO\n    if (len(binary)<3) then\n      return\n    end if\n    s=binary(3:)\n    !print*,binary\n    !print*,binary(3:)\n    !print*,s\n    i=1\n    do while (i>0)\n      i=index(s,'0b')\n      if (i\/=0) then\n        c=s(:i-1)\n        s=trim(s(i+2:))\n      else\n        c=s\n      end if\n      !print*,s\n      n=0\n      print*,len(c)\n      do k= 1,len(c)\n        n=n*2+ichar(c(k:k))-48\n        print*,n\n      end do\n      !print*,char(n)\n      !print*,s,c\n      output = output\/\/char(n)\n    end do\n  end function binaryToString\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83566,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  function binaryToString(binary) result(output)\n    character(:), allocatable :: s, c, output\n    character(*), intent(in) :: binary\n    integer :: i, j, cod\n    output = \"\"\n    if (len(binary)<3) then; return; end if\n    s = binary(3:); i = 1\n    do while (i>0)\n      i = index(s, '0b')\n      if (i\/=0) then\n        c = s(1:i-1)\n        s = trim(s(i+2:))\n      else; c = s\n      end if\n      cod = 0\n      do j = 1, len(c) \n        cod = cod*2+ichar(c(j:j))-48\n      end do      \n      output = output\/\/char(cod)\n    end do\n  end function binaryToString\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83567,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  character pure function bintoc(bin)\n    character(*), intent(in) :: bin\n    integer :: i, n\n    n = 0\n    do i = 1, len(bin) \n      n = n*2+merge(1, 0, bin(i:i)=='1')\n    end do  \n    bintoc = char(n)\n  end function bintoc\n  pure function binaryToString(binary) result(output)\n    character(:), allocatable :: s, output\n    character(*), intent(in) :: binary\n    integer :: i\n    output = \"\"\n    if (len(binary)<3) then; return; end if\n    s = binary(3:)\n    do while (.true.)\n      i = index(s, '0b')\n      if (i\/=0) then\n        output = output\/\/bintoc(s(1:i-1))\n        s = trim(s(i+2:))\n      else\n        output = output\/\/bintoc(s)\n        exit \n      end if\n    end do\n  end function binaryToString\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83568,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  function binaryToString(binary) result(output)\n    character(*), intent(in) :: binary\n    character(:), allocatable :: output\n    integer :: i, j, tmp\n    output = \"\"\n    i = 2\n    tmp = 0\n    do while (i < len(binary))\n      i = i + 1\n      if ( binary(i:i) == 'b' ) then\n        output = output \/\/ char(tmp\/2) ! slide back right to account for extra 0\n        tmp = 0\n        cycle\n      end if\n      tmp = 2*tmp + iachar(binary(i:i)) - iachar('0')\n    end do\n    ! Last one as well, careful with edge case...although this is what user may pass\n    if (tmp .ne. 0) then\n      output = output \/\/ char(tmp)\n    end if\n  end function binaryToString\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83569,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  function binaryToString(binary) result(output)\n    character(*), intent(in) :: binary\n    character(:), allocatable :: output\n    character(len = 7) :: ch\n    character*1000 :: myStr, myOut\n    integer :: m, n, n1, n2, i, j, k\n    \n    j = 0\n    myOut = \"\"\n    myStr = trim(binary(3:)) ! Strip off blanks & 1st 2 chars - so n1 = 1 later\n    n = len(binary)\n    ! WRITE(*,*) n, binary\n    \n    ! Split off the next 2 to 7 chars. from binary, as delimited by \"0b\"\n    do while (myStr .NE. \"\")\n      j = j + 1\n      ch = \"\"\n      n1 = 1     ! index(myStr, \"0b\") + 2\n      n2 = index(myStr, \"0b\")\n      if (n2 > 1) then\n        ch = myStr(1 : n2-1)\n      else\n        ch = myStr(1 : )\n      endif\n          \n      m = 0\n      !do i=7, 1, -1\n      k = len(trim(ch))\n      ! Convert binary to decimal\n      do i=k, 1, -1  \n          if (k < 1) exit\n          if (ch(i:i) == \"1\") m = m + 2**(k-i)\n      end do  ! i\n      \n      ! Build up output with char. just found\n      myOut(j:j) = achar(m)\n      \n      ! WRITE(*,*) ch, k, n2, m, myStr\n      ! WRITE(*,*) myOut\n      \n      myStr = myStr(n2+2 : )\n      if (myStr == \"\") exit\n      if (n2 <= 1) exit\n    end do  ! j\n    \n    output = trim(myOut) \n    ! WRITE(*,*) output\n  end function binaryToString\n  \n  \nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83570,"user_id":17,"body":"module Solution\n  implicit none\ncontains\n  pure function binaryToString(binary) result(output)\n    character(*), intent(in) :: binary\n    character(:), allocatable :: output\n    integer :: i, c\n    output = \"\"\n    i = 2\n    do while (i <= len(binary))\n      c = 0\n      i = i + 1\n      do while (i <= len(binary) .and. binary(i:i) \/= 'b')\n        c = c * 2 + ichar(binary(i:i)) - 48\n        i = i + 1\n      end do\n      if (i > len(binary)) then\n        output = output \/\/ char(c)\n      else\n        output = output \/\/ char(c \/ 2)\n      end if\n    end do\n  end function binaryToString\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5ab349e01aaf060cd0000069":[{"id":83571,"user_id":17,"body":"module Solution\n  implicit none\ncontains\n  pure function antiString(s)\n    character(*), intent(in) :: s\n    character(:), allocatable :: antiString\n    integer :: i, c\n    antiString = \"\"\n    do i = len(s), 1, -1\n      c = ichar(s(i:i))\n      if (c >= 65 .and. c < 91 .or. c >= 97 .and. c < 123) then\n        c = 187 - c\n      else if (c >= 48 .and. c < 58) then\n        c = 105 - c\n      end if\n      antiString = antiString \/\/ char(c)\n    end do\n  end function antiString\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83572,"user_id":168,"body":"module Solution\n  implicit none\ncontains\n  pure function antiString(s)\n    character(*), intent(in) :: s\n    character(:), allocatable :: antiString\n    integer :: n, i\n    character :: ch\n    antiString = s\n    n = len(s)\n    do i = 1, n\n      ch = s(n - i + 1:n - i + 1)\n      if (ch <= '9') then \n        ch = char(105 - iachar(ch))\n      else\n        ch = char(187 - iachar(ch))\n      end if\n      antiString(i:i) = ch\n    end do\n  end function antiString\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83573,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function antiString(str)\n    character(*), intent(in) :: str\n    character(:), allocatable :: antiString\n    integer :: i, i_rev, strlen\n\n    strlen = LEN(trim(str))\n    allocate(character(strlen) :: antiString)\n    do i=1,strlen\n        i_rev = strlen-i+1\n        if ('a' <= str(i:i) .and. str(i:i) <= 'z') then\n            antiString(i_rev:i_rev) = char( ichar('z') + ichar('A') - ichar(str(i:i)) )\n        else if ('A' <= str(i:i) .and. str(i:i) <= 'Z') then\n            antiString(i_rev:i_rev) = char( ichar('Z') + ichar('a') - ichar(str(i:i)) )\n        else\n            antiString(i_rev:i_rev) = char( ichar('9') + ichar('0') - ichar(str(i:i)) )\n        endif\n    enddo\n  end function antiString\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83574,"user_id":null,"body":"module solution\n    implicit none\n    character(26),parameter :: ucase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    character(26),parameter :: lcase = 'abcdefghijklmnopqrstuvwxyz'\n    character(10),parameter :: ncase = '0123456789'\n    \n    contains\n    \n    pure subroutine flip(str)\n        character,intent(inout) :: str\n        integer :: position\n        position=index(ucase,str)\n        if(position.ne.0)then\n            str=lcase(position:position)\n            return\n        end if\n        position=index(lcase,str)\n        if(position.ne.0)then\n            str=ucase(position:position)\n            return\n        end if\n    end subroutine flip\n    \n    pure subroutine swap(str)\n        character,intent(inout) :: str\n        integer :: position\n        position=index(ucase,str)\n        if(position.ne.0)then\n            str=ucase(27-position:27-position)\n            return\n        end if\n        position=index(lcase,str)\n        if(position.ne.0)then\n            str=lcase(27-position:27-position)\n            return\n        end if\n        position=index(ncase,str)\n        if(position.ne.0)then\n            str=ncase(11-position:11-position)\n            return\n        end if\n    end subroutine swap\n    \n    pure subroutine reverse(str)\n        character(len=*),intent(inout) :: str\n        character(len=:),allocatable :: loc\n        integer :: length\n        integer :: i\n        length=len(str)\n        loc=str\n        do i=1,length,1\n            str(i:i)=loc(length+1-i:length+1-i)\n        end do\n    end subroutine reverse\n    \n    pure function antiString(s)\n        character(*), intent(in) :: s\n        character(:), allocatable :: antiString\n        integer :: length\n        integer :: i\n        character :: str\n        length=len(s)\n        antiString=s\n        do i=1,length,1\n            str=antiString(i:i)\n            call flip(str)\n            call swap(str)\n            antiString(i:i)=str\n        end do\n        call reverse(antiString)\n    end function antiString\n    \nend module solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83575,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function antiString(s)\n    character(*), intent(in) :: s\n    character(len(s)) :: antiString\n    integer :: i, c\n    \n    antiString = \"\"\n    \n    do i = 1, len(s)\n      c = ichar(s(i:i))\n      if (c .ge. 48 .and. c .le. 57) then\n        antiString = char(105-c) \/\/ trim(antiString)\n      else\n        antiString = char(187-c) \/\/ trim(antiString)\n      end if\n    end do\n  end function antiString\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83576,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function antiString(s)\n    character(*), intent(in) :: s\n    character(:), allocatable :: antiString\n    character(*), parameter :: regs = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'\n    character(*), parameter :: anti = 'ZYXWVUTSRQPONMLKJIHGFEDCBAzyxwvutsrqponmlkjihgfedcba9876543210'\n    integer :: length,i,j\n    antiString = \"\"\n    \n    length = len(s)\n    Do i = 1, length\n      j = index(regs,s(length - i + 1:length - i + 1))\n      antiString = antiString \/\/ anti(j:j)\n    End Do\n    \n  end function antiString\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83577,"user_id":null,"body":"module Solution\n  implicit none\ncontains\nfunction antiString(s)!\n  character(*), intent(in) :: s\n  character(:), allocatable :: antiString\n  character(999) t, u\n  character(1) ch\n  integer chi, i, l, x\n\n  t = \"\";  u = \"\"\n  t = s ;  t = trim(t);  l = len_trim(t)\n  if (l > 999) then\n    print *, l, \": Len_Str > 999 - routine terminated\"\n    return\n  end if\n\n  do i=1, l\n    ch  = t(i:i)\n    chi = ichar(ch)\n    if      (chi > 47 .and. chi < 58) then\n       x   =  58 - chi;     chi = 47 + x    ! Digit, take complement\n    else if (chi > 64 .and. chi < 91) then \n       chi = chi + 32;                      ! Cap. so un-shift\n       x   = 123 - chi;     chi = 96 + x    ! Take z for a, y for b, etc.\n    else if (chi > 96 .and. chi < 123) then\n       chi = chi - 32;                      ! Not Cap. so shift\n       x   =  91 - chi;     chi = 64 + x    ! Take Z for A, etc.\n    end if\n    ch = char(chi)\n    u  = trim(ch \/\/ u)\n  end do\n  ! print *, \"^ \", len_trim(u), u\n  antiString = trim(u)\nend function antiString\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83578,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  function antiString(s)\n    character(*), intent(in) :: s\n    character(:), allocatable :: antiString\n    character(1) :: c\n    integer :: idx, L, i, j\n    character(26), parameter :: upp = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    character(26), parameter :: low = 'abcdefghijklmnopqrstuvwxyz'\n    character(10), parameter :: dig = '0123456789'\n    antiString = s\n    do idx = 1, len(s)\n      c = s(idx:idx)\n      ! lower to upper and comp\n      i = index(low, c)\n      if (i .ne. 0) then\n        j = 26-i+1\n        c = upp(j:j)\n        ! reverse position\n        j = len(s) -idx + 1\n        antiString(j:j) = c\n        cycle\n      end if\n      ! upper to lower and comp\n      i = index(upp, c)\n      if (i .ne. 0) then\n        j = 26-i+1\n        c = low(j:j)\n        ! reverse position\n        j = len(s) -idx + 1\n        antiString(j:j) = c\n        cycle\n      end if\n      ! compliment number\n      i = index(dig, c)\n      if (i .ne. 0) then\n        j = 10-i+1\n        c = dig(j:j)\n        ! reverse position\n        j = len(s) -idx + 1\n        antiString(j:j) = c\n        cycle\n      end if\n    end do\n  end function antiString\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83579,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function antiString(s)\n    character(*), intent(in) :: s\n    character(:), allocatable :: antiString\n    character(1) c\n    integer i\n    antiString = \"\"\n    do i = len(s), 1, -1\n      c = s(i:i)\n      if (c>='a' .and. c<='z' .or. c>='A' .and. c<='Z') then\n        c = char(187-ichar(c))\n      else \n        c = char(105-ichar(c))\n      end if\n      antistring = antistring\/\/c\n    end do\n  end function antiString\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5ab52526379d20736b00000e":[{"id":83580,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function numMags(weapon, numberOfStreets)\n    character(*), intent(in) :: weapon\n    integer, intent(in) :: numberOfStreets\n    integer     :: numMags\n    character(6):: name(4)\n    integer     :: bullets(4),i\n    \n    name=[trim(\"PT92\"),trim(\"M4A1\"),trim(\"M16A\"),trim(\"PSG1\")]\n    bullets=[17,30,30,5]\n    do i=1,4\n      if(weapon(1:4)==name(i))then\n          numMags=(numberOfStreets*3-1)\/bullets(i)+1\n      end if\n    end do\n  end function numMags\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83581,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function numMags(weapon, numberOfStreets)\n    character(*), intent(in) :: weapon\n    integer, intent(in) :: numberOfStreets\n    integer, parameter :: bulletspt = 17, bulletsm4 = 30, bulletsm16 = 30, bulletsps = 5, bulletsperstreet = 3\n    integer :: numMags, bulletspermag\n    numMags = 0\n    if (weapon == \"PT92\") then\n      bulletspermag = bulletspt\n    else if (weapon == \"M4A1\") then\n      bulletspermag = bulletsm4\n    else if (weapon == \"M16A2\") then\n      bulletspermag = bulletsm16\n    else if (weapon == \"PSG1\") then\n      bulletspermag = bulletsps\n    end if\n    numMags = ceiling(real(bulletsperstreet*numberOfStreets)\/bulletspermag)\n  end function numMags\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83582,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function numMags(weapon, numberOfStreets)\n    character(*), intent(in) :: weapon\n    integer, intent(in) :: numberOfStreets\n    integer :: numMags\n    integer :: numbullets\n    numMags = 0 ! TODO\n    numbullets=numberOfStreets*3\n    if (weapon==\"PT92\") then\n      numMags=ceiling(dble(numbullets)\/17.0)\n    else if (weapon==\"M4A1\") then\n      numMags=ceiling(dble(numbullets)\/30.0)\n    else if (weapon==\"M16A2\") then\n      numMags=ceiling(dble(numbullets)\/30.0)\n    else if (weapon==\"PSG1\") then\n      numMags=ceiling(dble(numbullets)\/5.0)\n    end if\n    \n  !PT92 - 17 bullets\n  !M4A1 - 30 bullets\n  !M16A2 - 30 bullets\n  !PSG1 - 5 bullets\n  end function numMags\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83583,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function numMags(weapon, numberOfStreets)\n    character(*), intent(in) :: weapon\n    integer, intent(in) :: numberOfStreets\n    integer :: numMags\n    numMags=numberOfStreets*3\n    select case(weapon)\n    case(\"PT92\")\n      numMags=ceiling(numMags\/17.0)\n    case(\"M4A1\")\n      numMags=ceiling(numMags\/30.0)\n    case(\"M16A2\")\n      numMags=ceiling(numMags\/30.0)\n    case(\"PSG1\")\n      numMags=ceiling(numMags\/5.0)\n    end select\n  end function numMags\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83584,"user_id":null,"body":"module Solution\n  implicit none\n  \ncontains\n\n  pure function numMags(weapon, numberOfStreets)\n    character(*), intent(in) :: weapon\n    integer, intent(in) :: numberOfStreets\n    integer :: numMags, bullets_rem, bullets_req\n    \n    numMags = 1\n\n    select case (weapon)\n    \n    case(\"PT92\")\n      bullets_rem = 17\n    \n    case(\"M4A1\")\n      bullets_rem = 30\n    \n    case(\"M16A2\")\n      bullets_rem = 30\n    \n    case(\"PSG1\")\n      bullets_rem = 5\n\n    case default\n      numMags = -1; return\n    \n    end select\n\n    bullets_req = numberOfStreets * 3\n    do\n\n      if (bullets_rem >= bullets_req) then\n        return\n      else\n\n        bullets_req = bullets_req - bullets_rem\n        numMags = numMags + 1\n\n      end if\n\n    end do\n\n  end function numMags\n\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83585,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function numMags(weapon, numberOfStreets)\n    character(*), intent(in) :: weapon\n    integer, intent(in) :: numberOfStreets\n    integer :: numMags\n    integer :: numOfBullets\n    integer :: bulletsPerMag\n    if (weapon == 'PT92') then \n      bulletsPerMag = 17 \n    else if (weapon == 'M4A1') then\n      bulletsPerMag = 30\n    else if (weapon == 'M16A2') then\n      bulletsPerMag = 30\n    else if (weapon == 'PSG1') then\n      bulletsPerMag = 5\n    else\n      bulletsPerMag = -1\n    endif\n    numOfBullets = numberOfStreets * 3\n    numMags = numOfBullets \/ bulletsPerMag\n    if (MOD(numOfBullets, bulletsPerMag) \/= 0) then\n      numMags = numMags + 1\n    endif\n    \n  end function numMags\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83586,"user_id":168,"body":"module Solution\n  implicit none\ncontains\n  pure function numMags(weapon, numberOfStreets)\n    character(*), intent(in) :: weapon\n    integer, intent(in) :: numberOfStreets\n    integer :: numMags\n    select case (weapon)\n      case ('PT92'); numMags = 17\n      case ('PSG1'); numMags = 5\n      case default; numMags = 30\n    end select\n    numMags = ceiling(numberOfStreets * 3.0 \/ numMags)\n  end function numMags\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83587,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function numMags(weapon, numberOfStreets)\n    character(*), intent(in) :: weapon\n    integer, intent(in) :: numberOfStreets\n    integer :: numMags\n    if (weapon .eq. 'PT92') then\n    numMags = ceiling((3.*numberOfStreets)\/17.)\n    else if (weapon .eq. 'M4A1' .or. weapon .eq.'M16A2') then\n    numMags = ceiling((3.*numberOfStreets)\/30.)\n    else if (weapon .eq. 'PSG1') then\n    numMags = ceiling((3.*numberOfStreets)\/5.)\n    end if\n  end function numMags\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83588,"user_id":76,"body":"module Solution\n  implicit none\ncontains\n  pure function numMags(weapon, numberOfStreets) result (res)\n    character(*), intent(in) :: weapon\n    integer, intent(in) :: numberOfStreets\n    integer :: res, mags\n    if (weapon == \"PT92\") then\n      mags = 17\n    else if (weapon == \"PSG1\") then\n      mags = 5\n    else \n      mags = 30\n    end if\n    res = CEILING(3.0 * numberOfStreets \/ mags)\n  end function numMags\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83589,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function numMags(weapon, numberOfStreets)\n    character(*), intent(in) :: weapon\n    integer, intent(in) :: numberOfStreets\n    integer :: numMags\n    integer :: roundsNeeded\n    integer :: roundsInMag\n\n    numMags = 0\n    roundsNeeded = numberOfStreets * 3\n    Select case (weapon)\n      case (\"PT92\")\n          roundsInMag = 17\n      case ('M4A1')\n          roundsInMag = 30\n      case ('M16A2')\n          roundsInMag = 30\n      case ('PSG1')\n         roundsInMag = 5\n    End Select\n\n    numMags = roundsNeeded \/ roundsInMag\n    if (roundsNeeded > numMags * roundsInMag) then\n        numMags = numMags + 1\n    end if\n\n  end function numMags\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5aba780a6a176b029800041c":[{"id":83590,"user_id":564,"body":"module Solution\n  implicit none\ncontains\n  pure function maxMultiple(divisor, bound) result(n)\n    integer, intent(in) :: divisor, bound\n    integer :: n\n    n = bound - MODULO(bound, divisor)\n  end function maxMultiple\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83591,"user_id":null,"body":"module Solution\n  implicit none\ncontains\npure function maxMultiple(divisor, bound) result(n)\n  integer, intent(in) :: divisor, bound\n  integer :: n\n\n  do n = bound, 2, -1\n    if (mod(n, divisor) == 0) return \n  end do\n\nend function maxMultiple\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83592,"user_id":17,"body":"module Solution\n  implicit none\ncontains\n  pure function maxMultiple(divisor, bound) result(n)\n    integer, intent(in) :: divisor, bound\n    integer :: n\n    n = bound \/ divisor * divisor\n  end function maxMultiple\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83593,"user_id":187,"body":"module Solution\n  implicit none\ncontains\n  pure function maxMultiple(divisor, bound) result(n)\n    integer, intent(in) :: divisor, bound\n    integer :: n, i\n    n = 0 ! TODO\n    DO i=1, bound\n      if (modulo(i,divisor) == 0) then\n        n = i \n      endif\n    ENDDO\n  end function maxMultiple\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83594,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure recursive function maxMultiple(divisor, bound) result(n)\n    integer, intent(in) :: divisor, bound\n    integer :: n\n    if (Mod(bound, divisor) == 0) then \n      n = bound\n    else\n      n = maxMultiple(divisor, bound - 1)\n    end if\n  end function maxMultiple\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83595,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function maxMultiple(divisor, bound) result(n)\n    integer, intent(in) :: divisor, bound\n    integer :: n, i\n    n = 0\n    i = bound\n    do while (n .eq. 0)\n      if (mod(i, divisor) .eq. 0) then\n        n = i\n      endif\n      i = i - 1\n    end do\n  end function maxMultiple\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83596,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function maxMultiple(divisor, bound) result(n)\n    integer, intent(in) :: divisor, bound\n    integer :: n\n    n = bound - Mod(bound, divisor)\n  end function maxMultiple\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83597,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function maxMultiple(divisor, bound) result(n)\n    integer, intent(in) :: divisor, bound\n    integer :: n\n    n = divisor * (bound \/ divisor)\n  end function maxMultiple\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83598,"user_id":53,"body":"module Solution\n  implicit none\ncontains\n  pure function maxMultiple(d, b) result(n)\n    integer, intent(in) :: d, b\n    integer :: n\n    n = b - modulo(b, d)\n  end function maxMultiple\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83599,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function maxMultiple(divisor, bound) result(n)\n    integer, intent(in) :: divisor, bound\n    integer :: n\n    n = bound - MOD(bound, divisor)\n  end function maxMultiple\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5acc79efc6fde7838a0000a0":[{"id":83600,"user_id":564,"body":"module Solution\n  use Preloaded ! `Node` derived data type for binary trees\n  ! Type definition is as follows:\n  ! type Node\n  !   integer :: data\n  !   type(Node), pointer :: left, right\n  ! end type Node\n  implicit none\ncontains\n  recursive function search(n, root) result(found)\n    integer, intent(in) :: n ! The number to look for\n    type(Node), pointer :: root ! Root node of our binary tree\n    logical :: found\n    if (.not. associated(root)) then\n      found = .false. \n    else\n      found = root%data == n &\n        .or. search(n, root%left) &\n        .or. search(n, root%right)\n    end if\n  end function search\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83601,"user_id":503,"body":"module Solution\n\tuse Preloaded\n\timplicit none\ncontains\n\trecursive function search(Q,S) result(R)\n\t\tinteger :: Q\n\t\ttype(Node),pointer :: S\n\t\tlogical :: R\n\t\tR = associated(S) .and. (Q == S%data .or. search(Q,S%left) .or. search(Q,S%right))\n\tend function search\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83602,"user_id":168,"body":"module Solution\n  use Preloaded ! `Node` derived data type for binary trees\n  ! Type definition is as follows:\n  ! type Node\n  !   integer :: data\n  !   type(Node), pointer :: left, right\n  ! end type Node\n  implicit none\ncontains\n  recursive function search(n, root) result(containsValue)\n    integer, intent(in) :: n ! The number to look for\n    type(Node), pointer :: root ! Root node of our binary tree\n    logical :: containsValue ! The result to return\n    if (associated(root)) then\n      if (root%data == n) then\n        containsValue = .true.\n      else\n        containsValue = search(n, root%left) .or. search(n, root%right)\n      end if\n    else\n      containsValue = .false.\n    end if\n  end function search\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83603,"user_id":53,"body":"module Solution\n  use Preloaded ! `Node` derived data type for binary trees\n  ! Type definition is as follows:\n  ! type Node\n  !   integer :: data\n  !   type(Node), pointer :: left, right\n  ! end type Node\n  implicit none\ncontains\n  recursive function search(n, root) result(containsValue)\n    integer, intent(in) :: n ! The number to look for\n    type(Node), pointer :: root ! Root node of our binary tree\n    logical :: containsValue ! The result to return\n    \n    containsValue = .false.\n    if (associated(root)) then\n      if (root%data == n) then\n        containsValue = .true.\n      else\n        containsValue = search(n, root%left) .or. search(n, root%right)\n      end if\n    end if\n    \n  end function search\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83604,"user_id":null,"body":"module Solution\n  use Preloaded ! `Node` derived data type for binary trees\n  ! Type definition is as follows:\n  ! type Node\n  !   integer :: data\n  !   type(Node), pointer :: left, right\n  ! end type Node\n  implicit none\ncontains\n  recursive function search(n, root) result(containsValue)\n    integer, intent(in) :: n ! The number to look for\n    type(Node), pointer :: root ! Root node of our binary tree\n    logical :: containsValue ! The result to return\n    if (.not. associated(root)) then\n      containsValue = .false.\n    else if (n == root%data) then\n      containsValue = .true.\n    else if (search(n, root%left) .or. search(n, root%right)) then\n      containsValue = .true.\n    else\n      containsValue = .false.\n    end if\n  end function search\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83605,"user_id":1657,"body":"module Solution\n  use Preloaded \n  implicit none\ncontains\n  recursive function search(n, root) result(containsValue)\n    integer, intent(in) :: n ! The number to look for\n    type(Node), pointer :: root ! Root node of our binary tree\n    logical :: containsValue, leftVal, rightVal ! The result to return\n    \n    leftVal = .false.\n    rightVal = .false.\n    \n    IF (associated(root) .eqv. .true.) then\n      IF (root%data == n) then\n        containsValue = .true.\n        return\n      END IF\n      \n      IF (associated(root%left)) then\n        leftVal = search(n, root%left)\n      END IF\n      \n      IF (associated(root%right)) then\n        rightVal = search(n, root%right)\n      END IF\n      \n      IF (rightVal .OR. leftVal) then\n        containsValue = .true.\n        return\n      END IF\n      \n      containsValue = .false.\n    END IF\n    \n  end function search\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83606,"user_id":503,"body":"module Solution\n\tuse Preloaded\n\timplicit none\ncontains\n\trecursive function search(Q,S) result(R)\n\t\tinteger :: Q\n\t\ttype(Node),pointer :: S\n\t\tlogical :: R\n\t\tif (associated(S)) then\n\t\t\tif (Q == S%data) then\n\t\t\t\tR = .true.\n\t\t\telse\n\t\t\t\tR = search(Q,S%left) .or. search(Q,S%right)\n\t\t\tend if\n\t\telse\n\t\t\tR = .false.\n\t\tend if\n\tend function search\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83607,"user_id":17,"body":"module Solution\n  use Preloaded ! `Node` derived data type for binary trees\n  ! Type definition is as follows:\n  ! type Node\n  !   integer :: data\n  !   type(Node), pointer :: left, right\n  ! end type Node\n  implicit none\ncontains\n  recursive function search(n, root) result(containsValue)\n    integer, intent(in) :: n ! The number to look for\n    type(Node), pointer :: root ! Root node of our binary tree\n    logical :: containsValue ! The result to return\n    if (associated(root)) then\n      containsValue = root%data == n .or. search(n, root%left) .or. search(n, root%right)\n    else\n      containsValue = .false.\n    end if\n  end function search\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5ad0d8356165e63c140014d4":[{"id":83608,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function final_grade(exam, projects)\n    integer, intent(in) :: exam, projects\n    integer :: final_grade\n    if ((91 .le. exam .or. 11 .le. projects)) final_grade = 100\n    if ((76 .le. exam .and. 5 .le. projects) .and. (exam .le. 90 .and. projects .le. 10.)) final_grade = 90\n    if ((51 .le. exam .and. 2 .le. projects) .and. (exam .le. 75 .and. projects .le. 4.)) final_grade = 75\n    if ((exam .le. 50 .or. projects .le. 1) .and. (exam .le. 90 .and. projects .le. 10.)) final_grade = 0\n  end function final_grade\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83609,"user_id":null,"body":"module Solution\n    implicit none\ncontains\n    pure function final_grade(exam, projects)\n        integer, intent(in) :: exam, projects\n        integer :: final_grade\n        !final_grade = 0 ! TODO\n        if(exam .GT. 90 .OR. projects .GT. 10) then\n            final_grade = 100\n        else if(exam .GT. 75 .and. projects .GE. 5) then\n            final_grade = 90\n        else if(exam .GT. 50 .and. projects .GE. 2) then\n            final_grade = 75\n        else\n            final_grade = 0\n        end if\n    end function final_grade\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83610,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function final_grade(exam, projects)\n    integer, intent(in) :: exam, projects\n    integer :: final_grade\n    \n    if(exam > 90 .OR. projects > 10) then\n      final_grade = 100 \n    else if(exam > 75 .AND. projects > 4) then\n      final_grade = 90\n    else if(exam > 50 .AND. projects > 1) then\n      final_grade = 75\n    else\n      final_grade = 0\n    end if\n  end function final_grade\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83611,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function final_grade(exam, projects)\n    integer, intent(in) :: exam, projects\n    integer :: final_grade\n    final_grade = 0\n    if (exam>90 .or. projects>10) then\n      final_grade = 100\n    else if (exam>75 .and. projects>=5) then\n      final_grade = 90\n    else if (exam>50 .and. projects>=2) then\n      final_grade = 75\n    end if\n  end function final_grade\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83612,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function final_grade(exam, projects)\n    integer, intent(in) :: exam, projects\n    integer :: final_grade\n      if (exam .gt. 90 .or. projects .gt. 10) then\n        final_grade = 100\n      elseif (exam .gt. 75 .and. projects .ge. 5) then\n        final_grade = 90\n      elseif (exam .gt. 50 .and. projects .ge. 2) then\n        final_grade = 75\n      else \n        final_grade = 0\n      endif\n  end function final_grade\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83613,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function final_grade(exam, projects)\n    integer, intent(in) :: exam, projects\n    integer :: final_grade\n    \n    if (exam.GT.90.or.projects.GT.10) then\n      final_grade = 100\n    else if (exam.GT.75.and.projects.GE.5) then\n      final_grade = 90\n    else if (exam.GT.50.and.projects.GE.2) then\n      final_grade = 75\n    else\n      final_grade = 0\n    end if\n    \n  end function final_grade\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83614,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function final_grade(exam, projects)\n    integer, intent(in) :: exam, projects\n    integer :: final_grade\n    final_grade = 0 ! Default\n    \n    ! Check 100, then 90, then 75.\n    if ((exam .gt. 90) .or. (projects .gt. 10)) then\n      final_grade = 100\n    else if ((exam .gt. 75) .AND. (projects .ge. 5)) then\n      final_grade = 90\n    else if ((exam .gt. 50) .AND. (projects .ge. 2)) then\n      final_grade = 75\n    end if\n  end function final_grade\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83615,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function final_grade(exam, projects) result(grade)\n    integer, intent(in) :: exam, projects\n    integer :: grade\n    if (exam .gt. 90 .or. projects .gt. 10) then\n      grade=100\n    else if (exam .gt. 75 .and. projects .gt. 4) then\n      grade=90\n    else if (exam .gt. 50 .and. projects .gt. 1) then\n      grade=75\n    else\n      grade=0\n    end if\n  end function final_grade\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83616,"user_id":53,"body":"module Solution\n  implicit none\ncontains\n  pure function final_grade(exam, projects)\n    integer, intent(in) :: exam, projects\n    integer :: final_grade\n    \n    final_grade = 0\n    if (exam > 50 .and. projects > 1) final_grade = 75\n    if (exam > 75 .and. projects > 4) final_grade = 90\n    if (exam > 90 .or. projects > 10) final_grade = 100\n    \n  end function final_grade\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83617,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function final_grade(exam, projects)\n    integer, intent(in) :: exam, projects\n    integer :: final_grade\n    final_grade = 0 \n    if (exam > 90 .or. projects > 10) then\n      final_grade=100\n    else if (exam > 75 .and. projects > 4) then\n      final_grade=90\n    else if (exam > 50 .and. projects >= 2) then\n      final_grade=75\n    end if\n  end function final_grade\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5adc571c88a0b777160000c8":[{"id":83618,"user_id":564,"body":"module Solution\n  implicit none\n  character(len=*), parameter :: &\n    FL = 'A,F10.2,A', &\n    SC = 'A,ES10.2,A', &\n    W = ',\" \",'\n  character(len=*), parameter :: &\n    REPORT_FMT = '('\/\/FL\/\/W\/\/SC\/\/W\/\/SC\/\/W\/\/SC\/\/W\/\/FL\/\/')'\n  real :: electronsPerCoulomb = 6.241461E18\ncontains\n  function calc(volts, charge) result (out)\n    real, intent(in) :: volts, charge\n    real :: capacitance, energy, electrons\n    character(len=128) :: out\n\n    capacitance = charge \/ volts\n    energy = 0.5 * capacitance * volts * volts\n    electrons = charge * electronsPerCoulomb\n\n    write(out, REPORT_FMT) &\n      'Vl. ', volts, 'V', &\n      'Cp. ', capacitance, 'F', &\n      'Ch. ', charge, 'C', &\n      'El. ', electrons, '', &\n      'En. ', energy, 'J';\n  end function calc\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83619,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION calc(volts, charge)\n    REAL, INTENT(IN) :: volts, charge \n    CHARACTER(LEN = 128) :: fmt, calc\n    REAL :: capacitance, electrons, energy\n    capacitance = charge \/ volts\n    electrons = charge * 6.241461E18\n    energy = 0.5 * capacitance * volts * volts\n    fmt = '(\"Vl.\",(X,F10.2),\"V Cp.\",(X,ES10.2),\"F Ch.\",(X,ES10.2),\"C El.\",(X,ES10.2),\" En.\",(X,F10.2),\"J\")'\n    WRITE(calc, fmt) volts, capacitance, charge, electrons, energy\n    RETURN\n  END FUNCTION calc\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83620,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION calc(volts, charge) RESULT(res)\n    REAL, INTENT(IN) :: volts, charge \n    CHARACTER(LEN=128) :: res\n    REAL :: capacitance, energy, electrons\n    capacitance = charge \/ volts\n    energy = 0.5 * capacitance * volts * volts\n    electrons = charge * 6.241461E18\n    write(res,'(A4,F10.2,A2,  A4,ES10.2,A2,  A4,ES10.2,A2,  A4,ES10.2,A,  A4,F10.2,A)') &\n      'Vl. ', volts, 'V ', &\n      'Cp. ', capacitance, 'F ', &\n      'Ch. ', charge, 'C ', &\n      'El. ', electrons, ' ', &\n      'En. ', energy, 'J'\n  END FUNCTION calc\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83621,"user_id":17,"body":"module Solution\n  implicit none\ncontains\n  pure function calc(volts, charge)\n    real, intent(in) :: volts, charge\n    character(78) :: calc\n    write(calc, \"(A3, F11.2, A5, ES11.2, A5, ES11.2, A5, ES11.2, A4, F11.2, A1)\") &\n    \"Vl.\", volts, \"V Cp.\", charge \/ volts, \"F Ch.\", charge, \"C El.\", charge * 6.241461E18, &\n    \" En.\", 0.5 * (charge \/ volts) * volts * volts, \"J\"\n  end function calc\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83622,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION calc(v, charge) RESULT(res)\n    REAL, PARAMETER :: electrons_per_coulomb = 6.241461E18\n    REAL :: charge, v\n    REAL :: capa, electrons, energy\n    CHARACTER(LEN=128) :: res\n    \n    capa = charge \/ v                             ! Capacitance\n\t  electrons = charge * electrons_per_coulomb    ! Electrons\n\t  energy = 0.5 * capa * v * v                   ! Energy\n\n    WRITE (RES, 151) 'Vl.', v, 'V ', 'Cp.', capa, 'F ', 'Ch.', charge, 'C ', 'El.', electrons, 'En.', energy, 'J'\n    151 FORMAT (A3, 1X, F10.2, A, A3, 1X, ES10.2, A, A3, 1X, ES10.2, A, A3, 1X, ES10.2, 1X, A3, 1X, F10.2, A)\n                \n  END FUNCTION calc\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83623,"user_id":168,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION calc(volts, charge)\n    REAL, INTENT(IN) :: volts, charge \n    CHARACTER(LEN=128) :: calc\n    real, parameter :: electrons_per_coulomb = 6.241461E18\n    real :: capacitance, energy, electrons\n    capacitance = charge \/ volts\n    energy = 0.5 * capacitance * volts * volts\n    electrons = charge * electrons_per_coulomb\n    write(calc,\"(A, F10.2, A, ES10.2, A, ES10.2, A, ES10.2, A, F10.2, A)\") &\n      \"Vl. \", volts, \"V Cp. \", capacitance, \"F Ch. \", charge, \"C El. \", electrons, \" En. \", energy, \"J\"\n  END FUNCTION calc\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83624,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION calc(vl, ch)\n    REAL, INTENT(IN) :: vl, ch\n    REAL :: cp, en, el\n    CHARACTER(LEN=128) :: calc\n    cp = ch \/ vl\n    en = 0.5 * cp * vl * vl\n    el = ch * 6.241461E18\n    WRITE (calc, \"(A3,5X,F6.2,A,1X,A3,3X,ES8.2E2,A,1X,A,3X,ES8.2E2,A,1X,A3,3X,ES8.2E2,1X,A3,5X,F6.2,A)\") &\n    \"Vl.\", vl, \"V\", \"Cp.\", cp, \"F\", \"Ch.\", ch, \"C\", \"El.\", el, \"En.\", en, \"J\"\n  END FUNCTION calc\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83625,"user_id":null,"body":"MODULE Solution\n IMPLICIT NONE\n  CONTAINS\n  PURE FUNCTION calc(volts, charge) RESULT(string)\n  REAL,INTENT(IN) :: volts, charge\n  REAL, PARAMETER :: electrons_per_coulomb = 6.241461E18\n  REAL :: capacitance,energy,electrons\n  character(len=128) :: string\n  capacitance = charge\/volts\n  energy = 0.5*capacitance*volts*volts\n  electrons = charge*electrons_per_coulomb\n  WRITE(string,'(a,5x,f6.2,a,3x,es8.2,a,3x,es8.2,a,3x,es8.2,a,5x,f6.2,a)') 'Vl.',volts,'V Cp.',capacitance,&\n  'F Ch.',charge,'C El.',electrons,' En.',energy,'J'\n  END FUNCTION calc\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83626,"user_id":149,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  CHARACTER(LEN=128) FUNCTION calc(v, c)\n    REAL, INTENT(IN) :: v, c\n    CHARACTER(LEN=128) :: r\n    WRITE (r, \"(A,F11.2,A,ES11.2,A,ES11.2,A,ES11.2,A,F11.2,A)\") &\n          \"Vl.\", v, \"V Cp.\", c \/ v, \"F Ch.\", c, \"C El.\", c * 6.241461E18, \" En.\", 0.5 * c \/ v * v * v, \"J\"\n    calc = r\n  END FUNCTION calc\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83627,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  FUNCTION calc(volts, charge) RESULT(out)\n    REAL, INTENT(IN)   :: volts, charge \n    REAL               :: capacitance, electrons, energy\n    CHARACTER(LEN=128) :: out\n    \n    capacitance = charge \/ volts\n    electrons = charge * 6.241461e18\n    energy = 0.5 * capacitance * volts * volts\n    \n    WRITE(out,900) volts, capacitance, charge, electrons, energy\n900 FORMAT(\"Vl.\", F11.2, \"V Cp.\", ES11.2, \"F Ch.\", ES11.2, \"C El.\", ES11.2, \" En.\", F11.2, \"J\")\n  END FUNCTION calc\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5adf4a1488a0b7b9cb000176":[{"id":83628,"user_id":168,"body":"module QuaternionUtilities\n  use Quaternions ! `Quaternion` derived data type\n  implicit none\n  private\n  public cdinit, realpart, imagpart, abs, operator (+), operator (-), operator (*), operator (.conj.)\n  \n  interface realpart\n    module procedure realpart_q\n  end interface\n  \n  interface imagpart\n    module procedure imagpart_q\n    module procedure imagpart_qi\n  end interface\n  \n  interface operator (+)\n    module procedure add_qq\n    module procedure add_cq\n    module procedure add_qc\n    module procedure add_rq\n    module procedure add_qr\n    module procedure plus\n  end interface\n  \n  interface operator (-)\n    module procedure sub_qq\n    module procedure sub_cq\n    module procedure sub_qc\n    module procedure sub_rq\n    module procedure sub_qr\n    module procedure minus\n  end interface\n  \n  interface operator (*)\n    module procedure mul_qq\n    module procedure mul_cq\n    module procedure mul_qc\n    module procedure mul_rq\n    module procedure mul_qr\n  end interface\n  \n  interface operator (.conj.)\n    module procedure conj\n  end interface\n  \n  interface abs\n    module procedure abs_q\n  end interface\n  \ncontains\n  type(Quaternion) function cdinit(z, w) result (q)\n    complex(8), intent(in) :: z, w\n    q%a = z%re\n    q%b = z%im\n    q%c = w%re\n    q%d = w%im\n  end function cdinit\n  \n  ! realpart\n  \n  real(8) function realpart_q(q) result (r)\n    type(Quaternion), intent(in) :: q\n    r = q%a\n  end function realpart_q\n  \n  ! imagpart\n\n  type(Quaternion) function imagpart_q(q) result (r)\n    type(Quaternion), intent(in) :: q\n    r = q\n    r%a = 0\n  end function imagpart_q\n  \n  real(8) function imagpart_qi(q, i) result (r)\n    type(Quaternion), intent(in) :: q\n    integer, intent(in) :: i\n    select case (i)\n      case (1); r = q%b\n      case (2); r = q%c\n      case (3); r = q%d\n    end select\n  end function imagpart_qi\n  \n  ! operator (+)\n  \n  type(Quaternion) function add_qq(p, q) result (r)\n    type(Quaternion), intent(in) :: p, q\n    r%a = p%a + q%a\n    r%b = p%b + q%b\n    r%c = p%c + q%c\n    r%d = p%d + q%d\n  end function add_qq\n\n  type(Quaternion) function add_qc(p, q) result (r)\n    type(Quaternion), intent(in) :: p\n    complex(8), intent(in) :: q\n    r = p + cdinit(q, cmplx(0.0_8, 0.0_8, 8))\n  end function add_qc\n\n  type(Quaternion) function add_cq(p, q) result (r)\n    complex(8), intent(in) :: p\n    type(Quaternion), intent(in) :: q\n    r = cdinit(p, cmplx(0.0_8, 0.0_8, 8)) + q\n  end function add_cq\n\n  type(Quaternion) function add_qr(p, q) result (r)\n    type(Quaternion), intent(in) :: p\n    real(8), intent(in) :: q\n    r = p\n    r%a = r%a + q\n  end function add_qr\n\n  type(Quaternion) function add_rq(p, q) result (r)\n    real(8), intent(in) :: p\n    type(Quaternion), intent(in) :: q\n    r = q\n    r%a = r%a + p\n  end function add_rq\n  \n  type(Quaternion) function plus(p) result (r)\n    type(Quaternion), intent(in) :: p\n    r = p\n  end function plus\n\n  ! operator (-)\n  \n  type(Quaternion) function sub_qq(p, q) result (r)\n    type(Quaternion), intent(in) :: p, q\n    r%a = p%a - q%a\n    r%b = p%b - q%b\n    r%c = p%c - q%c\n    r%d = p%d - q%d\n  end function sub_qq\n\n  type(Quaternion) function sub_qc(p, q) result (r)\n    type(Quaternion), intent(in) :: p\n    complex(8), intent(in) :: q\n    r = p - cdinit(q, cmplx(0.0_8, 0.0_8, 8))\n  end function sub_qc\n\n  type(Quaternion) function sub_cq(p, q) result (r)\n    complex(8), intent(in) :: p\n    type(Quaternion), intent(in) :: q\n    r = cdinit(p, cmplx(0.0_8, 0.0_8, 8)) - q\n  end function sub_cq\n\n  type(Quaternion) function sub_qr(p, q) result (r)\n    type(Quaternion), intent(in) :: p\n    real(8), intent(in) :: q\n    r = p\n    r%a = r%a - q\n  end function sub_qr\n\n  type(Quaternion) function sub_rq(p, q) result (r)\n    real(8), intent(in) :: p\n    type(Quaternion), intent(in) :: q\n    r = -q\n    r%a = p - q%a\n  end function sub_rq\n  \n  type(Quaternion) function minus(p) result (r)\n    type(Quaternion), intent(in) :: p\n    r%a = -p%a\n    r%b = -p%b\n    r%c = -p%c\n    r%d = -p%d\n  end function minus\n\n  ! operator (*)\n  \n  type(Quaternion) function mul_qq(p, q) result (r)\n    type(Quaternion), intent(in) :: p, q\n    r%a = p%a * q%a - p%b * q%b - p%c * q%c - p%d * q%d\n    r%b = p%a * q%b + p%b * q%a + p%c * q%d - p%d * q%c\n    r%c = p%a * q%c - p%b * q%d + p%c * q%a + p%d * q%b\n    r%d = p%a * q%d + p%b * q%c - p%c * q%b + p%d * q%a\n  end function mul_qq\n\n  type(Quaternion) function mul_qc(p, q) result (r)\n    type(Quaternion), intent(in) :: p\n    complex(8), intent(in) :: q\n    r = p * cdinit(q, cmplx(0.0_8, 0.0_8, 8))\n  end function mul_qc\n\n  type(Quaternion) function mul_cq(p, q) result (r)\n    complex(8), intent(in) :: p\n    type(Quaternion), intent(in) :: q\n    r = cdinit(p, cmplx(0.0_8, 0.0_8, 8)) * q\n  end function mul_cq\n\n  type(Quaternion) function mul_qr(p, q) result (r)\n    type(Quaternion), intent(in) :: p\n    real(8), intent(in) :: q\n    r = p * cdinit(cmplx(q, 0.0_8, 8), cmplx(0.0_8, 0.0_8, 8))\n  end function mul_qr\n\n  type(Quaternion) function mul_rq(p, q) result (r)\n    real(8), intent(in) :: p\n    type(Quaternion), intent(in) :: q\n    r = cdinit(cmplx(p, 0.0_8, 8), cmplx(0.0_8, 0.0_8, 8)) * q\n  end function mul_rq\n  \n  ! .conj.\n  \n  type(Quaternion) function conj(p) result (r)\n    type(Quaternion), intent(in) :: p\n    r = -p\n    r%a = p%a\n  end function conj\n  \n  ! abs\n\n  real(8) function abs_q(p) result (r)\n    type(Quaternion), intent(in) :: p\n    r = sqrt(p%a * p%a + p%b * p%b + p%c * p%c + p%d * p%d)\n  end function abs_q\n  \nend module QuaternionUtilities","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83629,"user_id":null,"body":"MODULE QuaternionUtilities\n    USE Quaternions\n    IMPLICIT NONE\n    PRIVATE :: realpart1, imagpart1, imagpart2, id, add1r, add2r, add1z, add2z, add2, inv, sub1r, sub2r, sub1z, sub2z, sub2\n    PRIVATE :: mul1r, mul2r, mul1z, mul2z, mul2, conj\n    INTERFACE realpart\n        MODULE PROCEDURE realpart1\n    END INTERFACE realpart\n    INTERFACE imagpart\n        MODULE PROCEDURE imagpart1, imagpart2\n    END INTERFACE imagpart\n    INTERFACE abs\n        MODULE PROCEDURE qabs\n    END INTERFACE\n    INTERFACE OPERATOR (+)\n        MODULE PROCEDURE id, add1r, add2r, add1z, add2z, add2\n    END INTERFACE\n    INTERFACE OPERATOR (-)\n        MODULE PROCEDURE inv, sub1r, sub2r, sub1z, sub2z, sub2\n    END INTERFACE\n    INTERFACE OPERATOR (*)\n        MODULE PROCEDURE mul1r, mul2r, mul1z, mul2z, mul2\n    END INTERFACE\n    INTERFACE OPERATOR (.conj.)\n        MODULE PROCEDURE conj\n    END INTERFACE\nCONTAINS\n    TYPE(Quaternion) PURE FUNCTION cdinit(z1, z2)\n        COMPLEX(KIND=8), INTENT(IN) :: z1, z2\n        cdinit = Quaternion(REAL(z1), AIMAG(z1), REAL(z2), AIMAG(z2))\n    END FUNCTION cdinit\n    REAL(8) PURE FUNCTION realpart1(z)\n        TYPE(Quaternion), INTENT(IN) :: z\n        realpart1 = z%a\n    END FUNCTION realpart1\n    TYPE(Quaternion) PURE FUNCTION imagpart1(z)\n        TYPE(Quaternion), INTENT(IN) :: z\n        imagpart1 = Quaternion(0, z%b, z%c, z%d)\n    END FUNCTION imagpart1\n    REAL(8) PURE FUNCTION imagpart2(z, n)\n        TYPE(Quaternion), INTENT(IN) :: z\n        INTEGER, INTENT(IN) :: n\n        SELECT CASE (n)\n            CASE (1)\n                imagpart2 = z%b\n            CASE (2)\n                imagpart2 = z%c\n            CASE (3)\n                imagpart2 = z%d\n        END SELECT\n    END FUNCTION imagpart2\n    REAL(8) PURE FUNCTION qabs(z)\n        TYPE(Quaternion), INTENT(IN) :: z\n        qabs = SQRT(z%a ** 2 + z%b ** 2 + z%c ** 2 + z%d ** 2)\n    END FUNCTION\n    TYPE(Quaternion) PURE FUNCTION id(z)\n        TYPE(Quaternion), INTENT(IN) :: z\n        id = Quaternion(z%a, z%b, z%c, z%d)\n    END FUNCTION id\n    TYPE(Quaternion) PURE FUNCTION add1r(z, x)\n        TYPE(Quaternion), INTENT(IN) :: z\n        REAL(8), INTENT(IN) :: x\n        add1r = Quaternion(z%a + x, z%b, z%c, z%d)\n    END FUNCTION add1r\n    TYPE(Quaternion) PURE FUNCTION add2r(x, z)\n        REAL(8), INTENT(IN) :: x\n        TYPE(Quaternion), INTENT(IN) :: z\n        add2r = add1r(z, x)\n    END FUNCTION add2r\n    TYPE(Quaternion) PURE FUNCTION add1z(zz, z)\n        TYPE(Quaternion), INTENT(IN) :: zz\n        COMPLEX(KIND=8), INTENT(IN) :: z\n        add1z = Quaternion(zz%a + REAL(z), zz%b + AIMAG(z), zz%c, zz%d)\n    END FUNCTION add1z\n    TYPE(Quaternion) PURE FUNCTION add2z(z, zz)\n        COMPLEX(KIND=8), INTENT(IN) :: z\n        TYPE(Quaternion), INTENT(IN) :: zz\n        add2z = add1z(zz, z)\n    END FUNCTION add2z\n    TYPE(Quaternion) PURE FUNCTION add2(z1, z2)\n        TYPE(Quaternion), INTENT(IN) :: z1, z2\n        add2 = Quaternion(z1%a + z2%a, z1%b + z2%b, z1%c + z2%c, z1%d + z2%d)\n    END FUNCTION add2\n    TYPE(Quaternion) PURE FUNCTION inv(z)\n        TYPE(Quaternion), INTENT(IN) :: z\n        inv = Quaternion(-z%a, -z%b, -z%c, -z%d)\n    END FUNCTION inv\n    TYPE(Quaternion) PURE FUNCTION sub1r(z, x)\n        TYPE(Quaternion), INTENT(IN) :: z\n        REAL(8), INTENT(IN) :: x\n        sub1r = add1r(z, -x)\n    END FUNCTION sub1r\n    TYPE(Quaternion) PURE FUNCTION sub2r(x, z)\n        REAL(8), INTENT(IN) :: x\n        TYPE(Quaternion), INTENT(IN) :: z\n        sub2r = inv(sub1r(z, x))\n    END FUNCTION sub2r\n    TYPE(Quaternion) PURE FUNCTION sub1z(zz, z)\n        TYPE(Quaternion), INTENT(IN) :: zz\n        COMPLEX(KIND=8), INTENT(IN) :: z\n        sub1z = add1z(zz, -z)\n    END FUNCTION sub1z\n    TYPE(Quaternion) PURE FUNCTION sub2z(z, zz)\n        COMPLEX(KIND=8), INTENT(IN) :: z\n        TYPE(Quaternion), INTENT(IN) :: zz\n        sub2z = inv(sub1z(zz, z))\n    END FUNCTION sub2z\n    TYPE(Quaternion) PURE FUNCTION sub2(z1, z2)\n        TYPE(Quaternion), INTENT(IN) :: z1, z2\n        sub2 = add2(z1, inv(z2))\n    END FUNCTION sub2\n    TYPE(Quaternion) PURE FUNCTION mul1r(z, x)\n        TYPE(Quaternion), INTENT(IN) :: z\n        REAL(8), INTENT(IN) :: x\n        mul1r = mul2(z, Quaternion(x, 0, 0, 0))\n    END FUNCTION mul1r\n    TYPE(Quaternion) PURE FUNCTION mul2r(x, z)\n        REAL(8), INTENT(IN) :: x\n        TYPE(Quaternion), INTENT(IN) :: z\n        mul2r = mul2(Quaternion(x, 0, 0, 0), z)\n    END FUNCTION mul2r\n    TYPE(Quaternion) PURE FUNCTION mul1z(zz, z)\n        TYPE(Quaternion), INTENT(IN) :: zz\n        COMPLEX(KIND=8), INTENT(IN) :: z\n        mul1z = mul2(zz, Quaternion(REAL(z), AIMAG(z), 0, 0))\n    END FUNCTION mul1z\n    TYPE(Quaternion) PURE FUNCTION mul2z(z, zz)\n        COMPLEX(KIND=8), INTENT(IN) :: z\n        TYPE(Quaternion), INTENT(IN) :: zz\n        mul2z = mul2(Quaternion(REAL(z), AIMAG(z), 0, 0), zz)\n    END FUNCTION mul2z\n    TYPE(Quaternion) PURE FUNCTION mul2(z1, z2)\n        TYPE(Quaternion), INTENT(IN) :: z1, z2\n        REAL(8) :: a, b, c, d\n        a = z1%a * z2%a - z1%b * z2%b - z1%c * z2%c - z1%d * z2%d\n        b = z1%a * z2%b + z1%b * z2%a + z1%c * z2%d - z1%d * z2%c\n        c = z1%a * z2%c - z1%b * z2%d + z1%c * z2%a + z1%d * z2%b\n        d = z1%a * z2%d + z1%b * z2%c - z1%c * z2%b + z1%d * z2%a\n        mul2 = Quaternion(a, b, c, d)\n    END FUNCTION mul2\n    TYPE(Quaternion) PURE FUNCTION conj(z)\n        TYPE(Quaternion), INTENT(IN) :: z\n        conj = Quaternion(z%a, -z%b, -z%c, -z%d)\n    END FUNCTION conj\nEND MODULE QuaternionUtilities","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83630,"user_id":null,"body":"module QuaternionUtilities\n    use Quaternions ! `Quaternion` derived data type\n    implicit none\n    interface realpart\n        module procedure realpart_q\n    end interface\n    interface imagpart\n        module procedure imagpart_q1\n        module procedure imagpart_q2\n    end interface\n    interface operator (+)\n        module procedure add_qq\n        module procedure add_qc\n        module procedure add_cq\n        module procedure add_qr\n        module procedure add_rq\n        module procedure add_qonly\n    end interface\n    interface operator (-)\n        module procedure sub_qq\n        module procedure sub_qc\n        module procedure sub_cq\n        module procedure sub_qr\n        module procedure sub_rq\n        module procedure sub_qonly\n    end interface\n    interface operator (*)\n        module procedure prod_qq\n        module procedure prod_qc\n        module procedure prod_cq\n        module procedure prod_qr\n        module procedure prod_rq\n    end interface\n    interface operator (.conj.)\n        module procedure conj_q\n    end interface\n    interface abs\n        module procedure abs_q\n    end interface\n    contains\n    function cdinit(x1, x2) result(q)\n        complex(8), intent(in) :: x1, x2\n        type(Quaternion) :: q\n        q%a = realpart(x1)\n        q%b = imagpart(x1)\n        q%c = realpart(x2)\n        q%d = imagpart(x2)\n    end function cdinit\n    function realpart_q(q) result(r)\n        type(Quaternion), intent(in) :: q\n        real(8) :: r\n        r = q%a\n    end function realpart_q\n    function imagpart_q1(q) result(q_im)\n        type(Quaternion), intent(in) :: q\n        type(Quaternion) :: q_im\n        q_im%a = 0\n        q_im%b = q%b\n        q_im%c = q%c\n        q_im%d = q%d\n    end function imagpart_q1\n    function imagpart_q2(q,n) result(r)\n        type(Quaternion), intent(in) :: q\n        integer, intent(in) :: n\n        real(8) :: r\n        select case(n)\n            case(1)\n                r = q%b\n            case(2)\n                r = q%c\n            case(3)\n                r = q%d\n            case default\n                r = q%b\n        end select\n    end function imagpart_q2\n    function add_qq(q1,q2) result(q3)\n        type(Quaternion), intent(in) :: q1, q2\n        type(Quaternion) :: q3\n        q3%a = q1%a + q2%a\n        q3%b = q1%b + q2%b\n        q3%c = q1%c + q2%c\n        q3%d = q1%d + q2%d\n    end function\n    function add_qc(q1, c) result(q3)\n        type(Quaternion), intent(in) :: q1\n        type(Quaternion) :: q3\n        complex(8) :: c\n        q3%a = q1%a + realpart(c)\n        q3%b = q1%b + imagpart(c)\n        q3%c = q1%c\n        q3%d = q1%d\n    end function add_qc\n    function add_cq(c, q1) result(q3)\n        type(Quaternion), intent(in) :: q1\n        type(Quaternion) :: q3\n        complex(8) :: c\n        q3%a = q1%a + realpart(c)\n        q3%b = q1%b + imagpart(c)\n        q3%c = q1%c\n        q3%d = q1%d\n    end function add_cq\n    function add_qr(q1, r) result(q3)\n        type(Quaternion), intent(in) :: q1\n        type(Quaternion) :: q3\n        real(8) :: r\n        q3%a = q1%a + r\n        q3%b = q1%b \n        q3%c = q1%c\n        q3%d = q1%d\n    end function add_qr\n    function add_rq(r, q1) result(q3)\n        type(Quaternion), intent(in) :: q1\n        type(Quaternion) :: q3\n        real(8) :: r\n        q3%a = q1%a + r\n        q3%b = q1%b \n        q3%c = q1%c\n        q3%d = q1%d\n    end function add_rq      \n    function add_qonly(q1) result(q)\n        type(Quaternion), intent(in) :: q1\n        type(Quaternion) :: q\n        q = q1\n    end function add_qonly                \n    function sub_qq(q1,q2) result(q3)\n        type(Quaternion), intent(in) :: q1, q2\n        type(Quaternion) :: q3\n        q3%a = q1%a - q2%a\n        q3%b = q1%b - q2%b\n        q3%c = q1%c - q2%c\n        q3%d = q1%d - q2%d\n    end function\n    function sub_qc(q1, c) result(q3)\n        type(Quaternion), intent(in) :: q1\n        type(Quaternion) :: q3\n        complex(8), intent(in) :: c\n        q3 = q1 - cdinit(c, dcmplx(0.,0.))\n    end function sub_qc\n    function sub_cq(c, q1) result(q3)\n        type(Quaternion), intent(in) :: q1\n        type(Quaternion) :: q3\n        complex(8), intent(in) :: c\n        q3 = cdinit(c, dcmplx(0.,0.)) - q1\n    end function sub_cq\n    function sub_qr(q1, r) result(q3)\n        type(Quaternion), intent(in) :: q1\n        type(Quaternion) :: q3\n        real(8), intent(in) :: r\n        q3 = q1 - cdinit(dcmplx(r, 0.), dcmplx(0.,0.))\n    end function sub_qr\n    function sub_rq(r, q1) result(q3)\n        type(Quaternion), intent(in) :: q1\n        type(Quaternion) :: q3\n        real(8), intent(in) :: r\n        q3 = cdinit(dcmplx(r, 0.), dcmplx(0.,0.)) - q1\n    end function sub_rq      \n    function sub_qonly(q1) result(q)\n        type(Quaternion), intent(in) :: q1\n        type(Quaternion) :: q\n        q%a = -q1%a\n        q%b = -q1%b\n        q%c = -q1%c\n        q%d = -q1%d        \n    end function sub_qonly\n    function prod_qq(q1,q2) result(q)\n        type(Quaternion), intent(in) :: q1, q2\n        type(Quaternion) :: q\n        q%a = q1%a*q2%a - q1%b*q2%b - q1%c*q2%c - q1%d*q2%d\n        q%b = q1%a*q2%b + q1%b*q2%a + q1%c*q2%d - q1%d*q2%c\n        q%c = q1%a*q2%c - q1%b*q2%d + q1%c*q2%a + q1%d*q2%b\n        q%d = q1%a*q2%d + q1%b*q2%c - q1%c*q2%b + q1%d*q2%a\n    end function prod_qq\n    function prod_qc(q1, c) result(q)\n        type(Quaternion), intent(in) :: q1\n        type(Quaternion) :: q\n        complex(8), intent(in) :: c\n        q = q1*cdinit(c, dcmplx(0., 0.))\n    end function prod_qc\n    function prod_cq(c, q1) result(q)\n        type(Quaternion), intent(in) :: q1\n        type(Quaternion) :: q\n        complex(8), intent(in) :: c\n        q = cdinit(c, dcmplx(0., 0.))*q1\n    end function prod_cq\n    function prod_qr(q1, r) result(q)\n        type(Quaternion), intent(in) :: q1\n        type(Quaternion) :: q\n        real(8), intent(in) :: r\n        q = q1*cdinit(dcmplx(r, 0.), dcmplx(0., 0.))\n    end function prod_qr\n    function prod_rq(r, q1) result(q)\n        type(Quaternion), intent(in) :: q1\n        type(Quaternion) :: q\n        real(8), intent(in) :: r\n        q = cdinit(dcmplx(r, 0.), dcmplx(0., 0.))*q1\n    end function prod_rq\n    function conj_q(q1) result(q)\n        type(Quaternion), intent(in) :: q1\n        type(Quaternion) :: q\n        q%a = q1%a\n        q%b = -q1%b\n        q%c = -q1%c\n        q%d = -q1%d\n    end function\n    function abs_q(q) result(r)\n        type(Quaternion), intent(in) :: q\n        real(8) :: r\n        r = sqrt((q%a)**2 + (q%b)**2 + (q%c)**2 + (q%d)**2)\n    end function abs_q\n\n\n      \n        ! TODO: Implement the procedures and define\/overload the operators\n        ! for the `Quaternion` derived data type as specified in the Kata\n        ! Description under the \"Task\" heading\nend module QuaternionUtilities\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83631,"user_id":null,"body":"MODULE QuaternionUtilities\n  USE Quaternions ! `Quaternion` derived data type\n  IMPLICIT NONE\n  ! TODO: Implement the procedures and define\/overload the operators\n  ! for the `Quaternion` derived data type as specified in the Kata\n  ! Description under the \"Task\" heading\n  INTERFACE realpart\n    MODULE PROCEDURE real_quat\n  END INTERFACE realpart\n  \n  INTERFACE imagpart\n    MODULE PROCEDURE aimag_quat\n    MODULE PROCEDURE aimag_quat_idx\n  END INTERFACE imagpart\n  \n  INTERFACE OPERATOR (+)\n    MODULE PROCEDURE plus_q\n    MODULE PROCEDURE q_plus_r\n    MODULE PROCEDURE r_plus_q\n    MODULE PROCEDURE q_plus_c\n    MODULE PROCEDURE c_plus_q\n    MODULE PROCEDURE q_plus_q\n  END INTERFACE OPERATOR (+)\n  \n  INTERFACE OPERATOR (-)\n    MODULE PROCEDURE minus_q\n    MODULE PROCEDURE q_minus_r\n    MODULE PROCEDURE r_minus_q\n    MODULE PROCEDURE q_minus_c\n    MODULE PROCEDURE c_minus_q\n    MODULE PROCEDURE q_minus_q\n  END INTERFACE OPERATOR (-)\n  \n  INTERFACE OPERATOR (*)\n    MODULE PROCEDURE q_mult_r\n    MODULE PROCEDURE r_mult_q\n    MODULE PROCEDURE q_mult_c\n    MODULE PROCEDURE c_mult_q\n    MODULE PROCEDURE q_mult_q\n  END INTERFACE OPERATOR (*)\n  \n  INTERFACE OPERATOR (.conj.)\n    MODULE PROCEDURE conj_q\n  END INTERFACE OPERATOR (.conj.)\n  \n  INTERFACE ABS\n    MODULE PROCEDURE norm_q\n  END INTERFACE ABS\n  \n  CONTAINS\n\n  ! Returns the quarternion\n  ! (a + bi) + (c + di)j = a + bi + cj + dk\n  FUNCTION cdinit( z_in_1, z_in_2) RESULT( q_out )\n    COMPLEX(8), INTENT(IN) :: z_in_1, z_in_2\n    TYPE(quaternion) :: q_out\n\n    q_out % a = REAL( z_in_1 )\n    q_out % b = AIMAG( z_in_1 )\n    q_out % c = REAL( z_in_2 )\n    q_out % d  = AIMAG( z_in_2 )\n\n  END FUNCTION cdinit\n  \n  FUNCTION real_quat( q_in ) RESULT( r_out )\n    TYPE(quaternion), INTENT(IN) :: q_in\n    REAL(8) :: r_out\n\n    r_out = q_in % a\n\n  END FUNCTION real_quat\n  \n  FUNCTION aimag_quat( q_in ) RESULT( im_out )\n    TYPE(quaternion), INTENT(IN) :: q_in\n    TYPE(quaternion) :: im_out\n\n    im_out % a = 0.0_8\n    im_out % b = q_in % b\n    im_out % c = q_in % c\n    im_out % d = q_in % d\n\n  END FUNCTION aimag_quat\n  \n  FUNCTION aimag_quat_idx( q_in, idx ) RESULT( im_out )\n    TYPE(quaternion), INTENT(IN) :: q_in\n    INTEGER, INTENT(IN) :: idx\n    REAL(8) :: im_out\n\n    SELECT CASE (idx)\n    CASE (1)\n      im_out = q_in % b\n    CASE (2)\n      im_out = q_in % c\n    CASE (3)\n      im_out = q_in % d\n    CASE DEFAULT\n      im_out = -123456789_8\n    END SELECT\n\n  END FUNCTION aimag_quat_idx\n  \n  FUNCTION plus_q( q_in ) RESULT( q_out )\n    TYPE(quaternion), INTENT(IN) :: q_in\n    TYPE(quaternion) :: q_out\n    \n    q_out = q_in\n    \n  END FUNCTION plus_q\n  \n  FUNCTION q_plus_r( q_in, r_in ) RESULT( q_out )\n    TYPE(quaternion), INTENT(IN) :: q_in\n    REAL(8), INTENT(IN) :: r_in\n    TYPE(quaternion) :: q_out\n    \n    q_out % a = q_in % a + r_in\n    q_out % b = q_in % b\n    q_out % c = q_in % c\n    q_out % d = q_in % d\n    \n  END FUNCTION q_plus_r\n  \n  FUNCTION r_plus_q( r_in, q_in ) RESULT( q_out )\n    REAL(8), INTENT(IN) :: r_in\n    TYPE(quaternion), INTENT(IN) :: q_in\n    TYPE(quaternion) :: q_out\n    \n    q_out % a = q_in % a + r_in\n    q_out % b = q_in % b\n    q_out % c = q_in % c\n    q_out % d = q_in % d\n    \n  END FUNCTION r_plus_q\n  \n  FUNCTION q_plus_c( q_in, c_in ) RESULT( q_out )\n    TYPE(quaternion), INTENT(IN) :: q_in\n    COMPLEX(8), INTENT(IN) :: c_in\n    TYPE(quaternion) :: q_out\n    \n    q_out % a = q_in % a + REAL( c_in )\n    q_out % b = q_in % b + AIMAG( c_in )\n    q_out % c = q_in % c\n    q_out % d = q_in % d\n    \n  END FUNCTION q_plus_c\n  \n  FUNCTION c_plus_q( c_in, q_in ) RESULT( q_out )\n    COMPLEX(8), INTENT(IN) :: c_in\n    TYPE(quaternion), INTENT(IN) :: q_in\n    TYPE(quaternion) :: q_out\n    \n    q_out % a = q_in % a + REAL( c_in )\n    q_out % b = q_in % b + AIMAG( c_in )\n    q_out % c = q_in % c\n    q_out % d = q_in % d\n    \n  END FUNCTION c_plus_q\n  \n  FUNCTION q_plus_q( q_in_1, q_in_2 ) RESULT( q_out )\n    TYPE(quaternion), INTENT(IN) :: q_in_1, q_in_2\n    TYPE(quaternion) :: q_out\n    \n    q_out % a = q_in_1 % a + q_in_2 % a\n    q_out % b = q_in_1 % b + q_in_2 % b\n    q_out % c = q_in_1 % c + q_in_2 % c\n    q_out % d = q_in_1 % d + q_in_2 % d\n    \n  END FUNCTION q_plus_q\n  \n  FUNCTION minus_q( q_in ) RESULT( q_out )\n    TYPE(quaternion), INTENT(IN) :: q_in\n    TYPE(quaternion) :: q_out\n    \n    q_out % a = - q_in % a\n    q_out % b = - q_in % b\n    q_out % c = - q_in % c\n    q_out % d = - q_in % d\n    \n  END FUNCTION minus_q\n  \n  FUNCTION q_minus_r( q_in, r_in ) RESULT( q_out )\n    TYPE(quaternion), INTENT(IN) :: q_in\n    REAL(8), INTENT(IN) :: r_in\n    TYPE(quaternion) :: q_out\n    \n    q_out % a = q_in % a - r_in\n    q_out % b = q_in % b\n    q_out % c = q_in % c\n    q_out % d = q_in % d\n    \n  END FUNCTION q_minus_r\n  \n  FUNCTION r_minus_q( r_in, q_in ) RESULT( q_out )\n    REAL(8), INTENT(IN) :: r_in\n    TYPE(quaternion), INTENT(IN) :: q_in\n    TYPE(quaternion) :: q_out\n    \n    q_out % a = r_in - q_in % a\n    q_out % b = - q_in % b\n    q_out % c = - q_in % c\n    q_out % d = - q_in % d\n    \n  END FUNCTION r_minus_q\n  \n  FUNCTION q_minus_c( q_in, c_in ) RESULT( q_out )\n    TYPE(quaternion), INTENT(IN) :: q_in\n    COMPLEX(8), INTENT(IN) :: c_in\n    TYPE(quaternion) :: q_out\n    \n    q_out % a = q_in % a - REAL( c_in )\n    q_out % b = q_in % b - AIMAG( c_in )\n    q_out % c = q_in % c\n    q_out % d = q_in % d\n    \n  END FUNCTION q_minus_c\n  \n  FUNCTION c_minus_q( c_in, q_in ) RESULT( q_out )\n    COMPLEX(8), INTENT(IN) :: c_in\n    TYPE(quaternion), INTENT(IN) :: q_in\n    TYPE(quaternion) :: q_out\n    \n    q_out % a = REAL( c_in ) - q_in % a\n    q_out % b = AIMAG( c_in ) - q_in % b\n    q_out % c = - q_in % c\n    q_out % d = - q_in % d\n    \n  END FUNCTION c_minus_q\n  \n  FUNCTION q_minus_q( q_in_1, q_in_2 ) RESULT( q_out )\n    TYPE(quaternion), INTENT(IN) :: q_in_1, q_in_2\n    TYPE(quaternion) :: q_out\n    \n    q_out % a = q_in_1 % a - q_in_2 % a\n    q_out % b = q_in_1 % b - q_in_2 % b\n    q_out % c = q_in_1 % c - q_in_2 % c\n    q_out % d = q_in_1 % d - q_in_2 % d\n    \n  END FUNCTION q_minus_q\n  \n  FUNCTION q_mult_r( q_in, r_in ) RESULT( q_out )\n    TYPE(quaternion), INTENT(IN) :: q_in\n    REAL(8), INTENT(IN) :: r_in\n    TYPE(quaternion) :: q_out\n    \n    q_out % a = r_in * q_in % a\n    q_out % b = r_in * q_in % b\n    q_out % c = r_in * q_in % c\n    q_out % d = r_in * q_in % d\n    \n  END FUNCTION q_mult_r\n  \n  FUNCTION r_mult_q( r_in, q_in ) RESULT( q_out )\n    REAL(8), INTENT(IN) :: r_in\n    TYPE(quaternion), INTENT(IN) :: q_in\n    TYPE(quaternion) :: q_out\n    \n    q_out % a = r_in * q_in % a\n    q_out % b = r_in * q_in % b\n    q_out % c = r_in * q_in % c\n    q_out % d = r_in * q_in % d\n    \n  END FUNCTION r_mult_q\n  \n  FUNCTION q_mult_c( q_in, c_in ) RESULT( q_out )\n    TYPE(quaternion), INTENT(IN) :: q_in\n    COMPLEX(8), INTENT(IN) :: c_in\n    TYPE(quaternion) :: q_out\n    REAL(8) :: c_in_a, c_in_b\n    c_in_a = REAL( c_in )\n    c_in_b = AIMAG( c_in )\n    \n    q_out % a = (q_in % a) * c_in_a - (q_in % b) * c_in_b\n    q_out % b = (q_in % a) * c_in_b + (q_in % b) * c_in_a\n    q_out % c = (q_in % c) * c_in_a + (q_in % d) * c_in_b\n    q_out % d = (q_in % d) * c_in_a - (q_in % c) * c_in_b\n    \n  END FUNCTION q_mult_c\n  \n  FUNCTION c_mult_q( c_in, q_in ) RESULT( q_out )\n    COMPLEX(8), INTENT(IN) :: c_in\n    TYPE(quaternion), INTENT(IN) :: q_in\n    TYPE(quaternion) :: q_out\n    REAL(8) :: c_in_a, c_in_b\n    c_in_a = REAL( c_in )\n    c_in_b = AIMAG( c_in )\n    \n    q_out % a = c_in_a * (q_in % a) - c_in_b * (q_in % b)\n    q_out % b = c_in_a * (q_in % b) + c_in_b * (q_in % a)\n    q_out % c = c_in_a * (q_in % c) - c_in_b * (q_in % d)\n    q_out % d = c_in_a * (q_in % d) + c_in_b * (q_in % c)\n    \n  END FUNCTION c_mult_q\n  \n  FUNCTION q_mult_q( q_in_1, q_in_2 ) RESULT( q_out )\n    TYPE(quaternion), INTENT(IN) :: q_in_1, q_in_2\n    TYPE(quaternion) :: q_out\n    \n    q_out % a =  (q_in_1 % a) * (q_in_2 % a) - (q_in_1 % b) * (q_in_2 % b) &\n               - (q_in_1 % c) * (q_in_2 % c) - (q_in_1 % d) * (q_in_2 % d)\n    q_out % b =  (q_in_1 % a) * (q_in_2 % b) + (q_in_1 % b) * (q_in_2 % a) &\n               + (q_in_1 % c) * (q_in_2 % d) - (q_in_1 % d) * (q_in_2 % c)\n    q_out % c =  (q_in_1 % a) * (q_in_2 % c) - (q_in_1 % b) * (q_in_2 % d) &\n               + (q_in_1 % c) * (q_in_2 % a) + (q_in_1 % d) * (q_in_2 % b)\n    q_out % d =  (q_in_1 % a) * (q_in_2 % d) + (q_in_1 % b) * (q_in_2 % c) &\n               - (q_in_1 % c) * (q_in_2 % b) + (q_in_1 % d) * (q_in_2 % a)\n    \n  END FUNCTION q_mult_q\n  \n  FUNCTION conj_q( q_in ) RESULT( q_out )\n    TYPE(quaternion), INTENT(IN) :: q_in\n    TYPE(quaternion) :: q_out\n    \n    q_out % a = q_in % a\n    q_out % b = - q_in % b\n    q_out % c = - q_in % c\n    q_out % d = - q_in % d\n    \n  END FUNCTION conj_q\n  \n  FUNCTION norm_q( q_in ) RESULT( r_out )\n    TYPE(quaternion), INTENT(IN) :: q_in\n    REAL(8) :: r_out\n\n    r_out = SQRT(  (q_in % a)*(q_in % a) + (q_in % b)*(q_in % b) &\n                 + (q_in % c)*(q_in % c) + (q_in % d)*(q_in % d) &\n                )\n\n  END FUNCTION norm_q\n  \n  \nend module QuaternionUtilities\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83632,"user_id":null,"body":"module QuaternionUtilities\n  use Quaternions ! `Quaternion` derived data type\n  implicit none\n\n  Interface realpart\n    Module Procedure realquat\n  End Interface\n\n  Interface imagpart\n    Module Procedure imagquat\n    Module Procedure imagcomp\n  End Interface\n  \n  Interface Operator (+)\n    Module Procedure quatadd\n    Module Procedure cqadd\n    Module Procedure qcadd\n    Module Procedure rqadd\n    Module Procedure qradd\n    Module Procedure uniaq\n  End Interface\n\n  Interface Operator (-)\n    Module Procedure qusub\n    Module Procedure cqsub\n    Module Procedure qcsub\n    Module Procedure rqsub\n    Module Procedure qrsub\n    Module Procedure minus\n  End Interface\n  \n  Interface Operator (*)\n    Module Procedure quprod\n    Module Procedure cqprod\n    Module Procedure qcprod\n    Module Procedure rqprod\n    Module Procedure qrprod\n  End Interface\n\n  Interface Operator (.conj.)\n    Module Procedure quconj\n  End Interface\n\n  Interface abs\n    Module Procedure qnorm\n  End Interface\n\n\n\n  Contains\n  \n  Function cdinit (first, second)\n    Type(Quaternion) :: cdinit\n    Complex*16 :: first, second\n    cdinit%a = real(first)\n    cdinit%b = aimag(first)\n    cdinit%c = real(second)\n    cdinit%d = aimag(second)\n  End Function cdinit\n\n\n\n  Function realquat(x)\n    Double Precision :: realquat\n    Type(Quaternion) :: x\n    realquat = x%a\n  End Function\n\n\n\n  Function imagquat(x)\n    Type(Quaternion) :: imagquat\n    Type(Quaternion) :: x\n    imagquat = x\n    imagquat%a = 0.0D0\n  End Function\n\n  Function imagcomp(x,n)\n    Double Precision :: imagcomp\n    Type(Quaternion) :: x\n    Integer :: n\n    If (n == 1) imagcomp = x%b\n    If (n == 2) imagcomp = x%c\n    If (n == 3) imagcomp = x%d\n  End Function\n\n\n\n  Function quatadd(q1,q2) result (q3)\n    Type(Quaternion), intent(in) :: q1, q2\n    Type(Quaternion) :: q3\n    q3%a = q1%a + q2%a\n    q3%b = q1%b + q2%b\n    q3%c = q1%c + q2%c\n    q3%d = q1%d + q2%d\n  End Function\n  \n  Function cqadd(q1,q2) result (q3)\n    Complex*16, intent(in) :: q1\n    Type(Quaternion), intent(in) :: q2\n    Type(Quaternion) :: q3\n    q3%a = real(q1) + q2%a\n    q3%b = aimag(q1) + q2%b\n    q3%c = q2%c\n    q3%d = q2%d\n  End Function\n\n  Function qcadd(q2,q1) result (q3)\n    Complex*16, intent(in) :: q1\n    Type(Quaternion), intent(in) :: q2\n    Type(Quaternion) :: q3\n    q3%a = real(q1) + q2%a\n    q3%b = aimag(q1) + q2%b\n    q3%c = q2%c\n    q3%d = q2%d\n  End Function\n  \n  Function rqadd(q1,q2) result (q3)\n    Double Precision, intent(in) :: q1\n    Type(Quaternion), intent(in) :: q2\n    Type(Quaternion) :: q3\n    q3%a = q1 + q2%a\n    q3%b = q2%b\n    q3%c = q2%c\n    q3%d = q2%d\n  End Function\n\n  Function qradd(q2,q1) result (q3)\n    Double Precision, intent(in) :: q1\n    Type(Quaternion), intent(in) :: q2\n    Type(Quaternion) :: q3\n    q3%a = q1 + q2%a\n    q3%b = q2%b\n    q3%c = q2%c\n    q3%d = q2%d\n  End Function\n  \n  Function uniaq(q1) result (q2)\n    Type(Quaternion), intent(in) :: q1\n    Type(Quaternion) :: q2\n    q2 = q1\n  End Function\n\n\n\n  Function qusub(q1,q2) result (q3)\n    Type(Quaternion), intent(in) :: q1, q2\n    Type(Quaternion) :: q3\n    q3%a = q1%a - q2%a\n    q3%b = q1%b - q2%b\n    q3%c = q1%c - q2%c\n    q3%d = q1%d - q2%d\n  End Function\n  \n  Function cqsub(q1,q2) result (q3)\n    Complex*16, intent(in) :: q1\n    Type(Quaternion), intent(in) :: q2\n    Type(Quaternion) :: q3\n    q3%a = real(q1) - q2%a\n    q3%b = aimag(q1) - q2%b\n    q3%c = -q2%c\n    q3%d = -q2%d\n  End Function\n  \n  Function qcsub(q2,q1) result (q3)\n    Complex*16, intent(in) :: q1\n    Type(Quaternion), intent(in) :: q2\n    Type(Quaternion) :: q3\n    q3%a = q2%a - real(q1)\n    q3%b = q2%b - aimag(q1)\n    q3%c = q2%c\n    q3%d = q2%d\n  End Function\n  \n  Function rqsub(q1,q2) result (q3)\n    Double Precision, intent(in) :: q1\n    Type(Quaternion), intent(in) :: q2\n    Type(Quaternion) :: q3\n    q3%a = q1 - q2%a\n    q3%b = -q2%b\n    q3%c = -q2%c\n    q3%d = -q2%d\n  End Function\n  \n  Function qrsub(q2,q1) result (q3)\n    Double Precision, intent(in) :: q1\n    Type(Quaternion), intent(in) :: q2\n    Type(Quaternion) :: q3\n    q3%a = q2%a - q1\n    q3%b = q2%b\n    q3%c = q2%c\n    q3%d = q2%d\n  End Function\n  \n  Function minus(q1) result (q2)\n    Type(Quaternion), intent(in) :: q1\n    Type(Quaternion) :: q2\n    q2%a = -q1%a\n    q2%b = -q1%b\n    q2%c = -q1%c\n    q2%d = -q1%d\n  End Function\n\n\n\n  Function quprod(q1,q2) result (q3)\n    Type(Quaternion), intent(in) :: q1, q2\n    Type(Quaternion) :: q3\n    q3%a = (q1%a*q2%a - q1%b*q2%b - q1%c*q2%c - q1%d*q2%d)\n    q3%b = (q1%a*q2%b + q1%b*q2%a + q1%c*q2%d - q1%d*q2%c)\n    q3%c = (q1%a*q2%c - q1%b*q2%d + q1%c*q2%a + q1%d*q2%b)\n    q3%d = (q1%a*q2%d + q1%b*q2%c - q1%c*q2%b + q1%d*q2%a)\n  End Function\n\n  Function cqprod(q1,q2) result (q3)\n    Complex*16, intent(in) :: q1\n    Type(Quaternion), intent(in) :: q2\n    Type(Quaternion) :: q3\n    q3%a = (real(q1)*q2%a - aimag(q1)*q2%b)\n    q3%b = (real(q1)*q2%b + aimag(q1)*q2%a)\n    q3%c = (real(q1)*q2%c - aimag(q1)*q2%d)\n    q3%d = (real(q1)*q2%d + aimag(q1)*q2%c)\n  End Function\n\n  Function qcprod(q1,q2) result (q3)\n    Complex*16, intent(in) :: q2\n    Type(Quaternion), intent(in) :: q1\n    Type(Quaternion) :: q3\n    q3%a = (q1%a*real(q2) - q1%b*aimag(q2))\n    q3%b = (q1%a*aimag(q2) + q1%b*real(q2))\n    q3%c = (q1%c*real(q2) + q1%d*aimag(q2))\n    q3%d = (q1%d*real(q2) - q1%c*aimag(q2))\n  End Function\n\n  Function rqprod(q1,q2) result (q3)\n    Double Precision, intent(in) :: q1\n    Type(Quaternion), intent(in) :: q2\n    Type(Quaternion) :: q3\n    q3%a = q1*q2%a\n    q3%b = q1*q2%b\n    q3%c = q1*q2%c\n    q3%d = q1*q2%d\n  End Function\n\n  Function qrprod(q1,q2) result (q3)\n    Double Precision, intent(in) :: q2\n    Type(Quaternion), intent(in) :: q1\n    Type(Quaternion) :: q3\n    q3%a = q1%a*q2\n    q3%b = q1%b*q2\n    q3%c = q1%c*q2\n    q3%d = q1%d*q2\n  End Function\n\n\n\n  Function quconj(q1) result (q2)\n    Type(Quaternion), intent(in) :: q1\n    Type(Quaternion) :: q2\n    q2%a = q1%a\n    q2%b = -q1%b\n    q2%c = -q1%c\n    q2%d = -q1%d\n  End Function\n\n\n\n  Function qnorm(q1) result (q2)\n    Type(Quaternion), intent(in) :: q1\n    Double Precision :: q2\n    q2 = sqrt(q1%a*q1%a + q1%b*q1%b + q1%c*q1%c + q1%d*q1%d)\n  End Function\n\nend module QuaternionUtilities\n\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83633,"user_id":null,"body":"module QuaternionUtilities\n  use Quaternions ! `Quaternion` derived data type\n  implicit none\n\n  interface realpart\n    module procedure realpart_quaternion\n  end interface\n\n  interface imagpart\n    module procedure imagpart_full, imagpart_comp\n  end interface\n\n  interface operator(+)\n    module procedure add_quaternion_quaternion, &\n      add_quaternion_real, add_real_quaternion, &\n      add_quaternion_complex, add_complex_quaternion, &\n      add_quaternion_unary\n  end interface\n\n  interface operator(-)\n    module procedure sub_quaternion_quaternion, &\n      sub_quaternion_real, sub_real_quaternion, &\n      sub_quaternion_complex, sub_complex_quaternion, &\n      sub_quaternion_unary\n  end interface\n\n  interface operator(*)\n    module procedure hamilton_quaternion_quaternion, &\n         hamilton_quaternion_real, hamilton_real_quaternion, &\n         hamilton_quaternion_complex, hamilton_complex_quaternion\n  end interface\n  \n  interface operator(.conj.)\n    module procedure conj_quaternion\n  end interface\n  \n  interface abs\n    module procedure norm_quaternion\n  end interface\n\ncontains\n\n  function cdinit(az, bz)\n    complex(8), intent(in) :: az, bz\n    type(Quaternion) :: cdinit\n\n    cdinit%a = realpart(az)\n    cdinit%b = imagpart(az)\n    cdinit%c = realpart(bz)\n    cdinit%d = imagpart(bz)\n  end function cdinit\n\n  function realpart_quaternion(q)\n    type(Quaternion), intent(in) :: q\n    real(8) :: realpart_quaternion\n\n    realpart_quaternion = q%a\n  end function realpart_quaternion\n\n  function imagpart_full(q)\n    type(Quaternion), intent(in) :: q\n    type(Quaternion) :: imagpart_full\n\n    imagpart_full = q\n    imagpart_full%a = 0.0_8\n  end function imagpart_full\n\n  function imagpart_comp(q, n)\n    type(Quaternion), intent(in) :: q\n    integer, intent(in) :: n\n    real(8) :: imagpart_comp\n\n    select case (n)\n    case (1)\n      imagpart_comp = q%b\n    case (2)\n      imagpart_comp = q%c\n    case (3)\n      imagpart_comp = q%d\n    end select\n  end function imagpart_comp\n\n  function add_quaternion_unary(p) result(s)\n    type(Quaternion), intent(in) :: p\n    type(Quaternion) :: s\n\n    s = p\n  end function add_quaternion_unary\n\n  function add_quaternion_quaternion(p, q) result(s)\n    type(Quaternion), intent(in) :: p, q\n    type(Quaternion) :: s\n\n    s%a = p%a + q%a\n    s%b = p%b + q%b\n    s%c = p%c + q%c\n    s%d = p%d + q%d\n  end function add_quaternion_quaternion\n\n  function add_quaternion_real(q, r) result(s)\n    type(Quaternion), intent(in) :: q\n    real(8), intent(in) :: r\n    type(Quaternion) :: s\n\n    s = q\n    s%a = s%a + r\n  end function add_quaternion_real\n\n  function add_real_quaternion(r, q) result(s)\n    type(Quaternion), intent(in) :: q\n    real(8), intent(in) :: r\n    type(Quaternion) :: s\n\n    s = q + r\n  end function add_real_quaternion\n\n  function add_quaternion_complex(q, c) result(s)\n    type(Quaternion), intent(in) :: q\n    complex(8), intent(in) :: c\n    type(Quaternion) :: s\n\n    s = q\n    s%a = s%a + realpart(c)\n    s%b = s%b + imagpart(c)\n  end function add_quaternion_complex\n\n  function add_complex_quaternion(c, q) result(s)\n    type(Quaternion), intent(in) :: q\n    complex(8), intent(in) :: c\n    type(Quaternion) :: s\n\n    s = q + c\n  end function add_complex_quaternion\n\n  function sub_quaternion_unary(q) result(s)\n    type(Quaternion), intent(in) :: q\n    type(Quaternion) :: s\n\n    s%a = -q%a\n    s%b = -q%b\n    s%c = -q%c\n    s%d = -q%d\n  end function sub_quaternion_unary\n\n  function sub_quaternion_quaternion(p, q) result(s)\n    type(Quaternion), intent(in) :: p, q\n    type(Quaternion) :: s\n\n    s = p + (-q)\n  end function sub_quaternion_quaternion\n\n  function sub_quaternion_real(q, r) result(s)\n    type(Quaternion), intent(in) :: q\n    real(8), intent(in) :: r\n    type(Quaternion) :: s\n\n    s = q + (-r)\n  end function sub_quaternion_real\n\n  function sub_real_quaternion(r, q) result(s)\n    type(Quaternion), intent(in) :: q\n    real(8), intent(in) :: r\n    type(Quaternion) :: s\n\n    s = r + (-q)\n  end function sub_real_quaternion\n\n  function sub_quaternion_complex(q, c) result(s)\n    type(Quaternion), intent(in) :: q\n    complex(8), intent(in) :: c\n    type(Quaternion) :: s\n\n    s = q + (-c)\n  end function sub_quaternion_complex\n\n  function sub_complex_quaternion(c, q) result(s)\n    type(Quaternion), intent(in) :: q\n    complex(8), intent(in) :: c\n    type(Quaternion) :: s\n\n    s = c + (-q)\n  end function sub_complex_quaternion\n\n  function hamilton_quaternion_quaternion(p, q) result(s)\n    type(Quaternion), intent(in) :: p, q\n    type(Quaternion) :: s\n\n    s%a = p%a*q%a - p%b*q%b - p%c*q%c - p%d*q%d\n    s%b = p%a*q%b + p%b*q%a + p%c*q%d - p%d*q%c\n    s%c = p%a*q%c - p%b*q%d + p%c*q%a + p%d*q%b\n    s%d = p%a*q%d + p%b*q%c - p%c*q%b + p%d*q%a\n  end function hamilton_quaternion_quaternion\n\n  function hamilton_quaternion_real(q, r) result(s)\n    type(Quaternion), intent(in) :: q\n    real(8), intent(in) :: r\n    type(Quaternion) :: s\n\n    s%a = q%a*r\n    s%b = q%b*r\n    s%c = q%c*r\n    s%d = q%d*r\n  end function hamilton_quaternion_real\n\n  function hamilton_real_quaternion(r, q) result(s)\n    type(Quaternion), intent(in) :: q\n    real(8), intent(in) :: r\n    type(Quaternion) :: s\n\n    s = q * r\n  end function hamilton_real_quaternion\n\n  function hamilton_quaternion_complex(q, c) result(s)\n    type(Quaternion), intent(in) :: q\n    complex(8), intent(in) :: c\n    type(Quaternion) :: s\n\n    s = q * cdinit(c, (0.0_8, 0.0_8))\n  end function hamilton_quaternion_complex\n\n  function hamilton_complex_quaternion(c, q) result(s)\n    type(Quaternion), intent(in) :: q\n    complex(8), intent(in) :: c\n    type(Quaternion) :: s\n\n    s = cdinit(c, (0.0_8, 0.0_8)) * q\n  end function hamilton_complex_quaternion\n  \n  function conj_quaternion(q) result(s)\n    type(Quaternion), intent(in) :: q\n    type(Quaternion) :: s\n\n    s = realpart(q) - imagpart(q)\n  end function conj_quaternion\n\n  function norm_quaternion(q) result(s)\n    type(Quaternion), intent(in) :: q\n    real(8) :: s\n\n    s = sqrt(q%a*q%a + q%b*q%b + q%c*q%c + q%d*q%d)\n  end function norm_quaternion\n\nend module QuaternionUtilities\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83634,"user_id":null,"body":"module QuaternionUtilities\n  use Quaternions\n  implicit none\n  interface imagpart\n    module procedure imagpart_q, imagpart_d\n  end interface imagpart\n  interface operator (+)\n    module procedure add_qq, add_cq, add_qc, add_dq, add_qd, u_add\n  end interface operator (+)\n  interface operator (-)\n    module procedure sub_qq, sub_cq, sub_qc, sub_dq, sub_qd, u_sub\n  end interface operator (-)\n  interface operator (*)\n    module procedure mul_qq, mul_cq, mul_qc, mul_dq, mul_qd\n  end interface operator (*)   \n  interface operator (.conj.)\n    module procedure conj\n  end interface operator (.conj.)\n  contains\n  type(Quaternion) pure function cdinit(c1, c2) result(r)\n    complex(8), intent(in) :: c1, c2 \n    r%a = real(c1); r%b = aimag(c1) \n    r%c = real(c2); r%d = aimag(c2)\n  end function cdinit\n  real(8) pure function realpart(q)\n    type(Quaternion), intent(in) :: q\n    realpart = q%a\n  end function realpart\n  type(Quaternion) pure function imagpart_q(q) result(r)\n    type(Quaternion), intent(in) :: q\n    r = q; r%a = 0\n  end function imagpart_q \n  real(8) pure function imagpart_d(q, n) result(r)\n    type(Quaternion), intent(in) :: q\n    integer, intent(in) :: n\n    select case(n)\n      case(1); r = q%b\n      case(2); r = q%c\n      case(3); r = q%d      \n    end select\n  end function imagpart_d\n  type(Quaternion) pure function add_qq(q1, q2) result(r)\n    type(Quaternion), intent(in) :: q1, q2\n    r%a = q1%a+q2%a; r%b = q1%b+q2%b \n    r%c = q1%c+q2%c; r%d = q1%d+q2%d\n  end function add_qq\n  type(Quaternion) pure function add_cq(c, q) result(r)\n    complex(8), intent(in) :: c\n    type(Quaternion), intent(in) :: q\n    r%a = real(c)+q%a; r%b = aimag(c)+q%b; r%c = q%c; r%d = q%d\n  end function add_cq\n  type(Quaternion) pure function add_qc(q, c) result(r)\n    complex(8), intent(in) :: c\n    type(Quaternion), intent(in) :: q\n    r%a = real(c)+q%a; r%b = aimag(c)+q%b; r%c = q%c; r%d = q%d\n  end function add_qc\n  type(Quaternion) pure function add_dq(d, q) result(r)\n    real(8), intent(in) :: d\n    type(Quaternion), intent(in) :: q\n    r = q; r%a = d+q%a\n  end function add_dq\n  type(Quaternion) pure function add_qd(q, d) result(r)\n    real(8), intent(in) :: d\n    type(Quaternion), intent(in) :: q\n    r = q; r%a = d+q%a\n  end function add_qd\n  type(Quaternion) pure function u_add(q)\n    type(Quaternion), intent(in) :: q\n    u_add = q\n  end function u_add\n  type(Quaternion) pure function sub_qq(q1, q2) result(r)\n    type(Quaternion), intent(in) :: q1, q2\n    r%a = q1%a-q2%a; r%b = q1%b-q2%b\n    r%c = q1%c-q2%c; r%d = q1%d-q2%d\n  end function sub_qq\n  type(Quaternion) pure function sub_cq(c, q) result(r)\n    complex(8), intent(in) :: c\n    type(Quaternion), intent(in) :: q\n    r%a = real(c)-q%a; r%b = aimag(c)-q%b; r%c = -q%c; r%d = -q%d\n  end function sub_cq\n  type(Quaternion) pure function sub_qc(q, c) result(r)\n    complex(8), intent(in) :: c\n    type(Quaternion), intent(in) :: q\n    r%a = -real(c)+q%a; r%b = -aimag(c)+q%b; r%c = q%c; r%d = q%d\n  end function sub_qc\n  type(Quaternion) pure function sub_dq(d, q) result(r)\n    real(8), intent(in) :: d\n    type(Quaternion), intent(in) :: q\n    r%a = d-q%a; r%b = -q%b; r%c = -q%c; r%d = -q%d\n  end function sub_dq\n  type(Quaternion) pure function sub_qd(q, d) result(r)\n    real(8), intent(in) :: d\n    type(Quaternion), intent(in) :: q\n    r%a = -d+q%a; r%b = q%b; r%c = q%c; r%d = q%d\n  end function sub_qd\n  type(Quaternion) pure function u_sub(q) result(r)\n    type(Quaternion), intent(in) :: q\n    r%a = -q%a; r%b = -q%b; r%c = -q%c; r%d = -q%d\n  end function u_sub\n  type(Quaternion) pure function mul_qq(q1, q2) result(r)\n    type(Quaternion), intent(in) :: q1, q2\n    r%a = q1%a*q2%a-q1%b*q2%b-q1%c*q2%c-q1%d*q2%d\n    r%b = q1%a*q2%b+q1%b*q2%a+q1%c*q2%d-q1%d*q2%c\n    r%c = q1%a*q2%c+q1%c*q2%a-q1%b*q2%d+q1%d*q2%b\n    r%d = q1%a*q2%d+q1%d*q2%a+q1%b*q2%c-q1%c*q2%b\n  end function mul_qq\n  type(Quaternion) pure function mul_cq(c, q) result(r)\n    complex(8), intent(in) :: c\n    type(Quaternion), intent(in) :: q\n    r%a = q%a*real(c)-q%b*aimag(c)\n    r%b = q%a*aimag(c)+q%b*real(c)\n    r%c = q%c*real(c)-q%d*aimag(c)\n    r%d = q%c*aimag(c)+q%d*real(c)\n  end function mul_cq\n  type(Quaternion) pure function mul_qc(q, c) result(r)\n    complex(8), intent(in) :: c\n    type(Quaternion), intent(in) :: q\n    r%a = q%a*real(c)-q%b*aimag(c)\n    r%b = q%a*aimag(c)+q%b*real(c)\n    r%c = q%c*real(c)+q%d*aimag(c)\n    r%d = -q%c*aimag(c)+q%d*real(c)\n  end function mul_qc\n  type(Quaternion) pure function mul_dq(d, q) result(r)\n    real(8), intent(in) :: d\n    type(Quaternion), intent(in) :: q\n    r%a = q%a*d; r%b = q%b*d; r%c = q%c*d; r%d = q%d*d\n  end function mul_dq\n  type(Quaternion) pure function mul_qd(q, d) result(r)\n    real(8), intent(in) :: d\n    type(Quaternion), intent(in) :: q\n    r%a = q%a*d; r%b = q%b*d; r%c = q%c*d; r%d = q%d*d\n  end function mul_qd  \n  type(Quaternion) pure function conj(q) result(r)\n    type(Quaternion), intent(in) :: q\n    r%a = q%a; r%b = -q%b; r%c = -q%c; r%d = -q%d\n  end function conj\n  real(8) pure function abs(q)\n    type(Quaternion), intent(in) :: q\n    abs = sqrt(q%a*q%a+q%b*q%b+q%c*q%c+q%d*q%d)\n  end function abs\nend module QuaternionUtilities","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83635,"user_id":null,"body":"module QuaternionUtilities\n  use Quaternions\n  implicit none\n  interface imagpart\n    module procedure imagpart_q, imagpart_d\n  end interface imagpart\n  interface operator (+)\n    module procedure add_qq, add_cq, add_qc, add_dq, add_qd, u_add\n  end interface operator (+)\n  interface operator (-)\n    module procedure sub_qq, sub_cq, sub_qc, sub_dq, sub_qd, u_sub\n  end interface operator (-)\n  interface operator (*)\n    module procedure mul_qq, mul_cq, mul_qc, mul_dq, mul_qd\n  end interface operator (*)   \n  interface operator (.conj.)\n    module procedure conj\n  end interface operator (.conj.)\n  contains\n  type(Quaternion) pure function cdinit(c1, c2)\n    complex(8), intent(in) :: c1, c2 \n    cdinit%a = real(c1); cdinit%b = aimag(c1)\n    cdinit%c = real(c2); cdinit%d = aimag(c2)\n  end function cdinit\n  real(8) pure function realpart(q)\n    type(Quaternion), intent(in) :: q\n    realpart = q%a\n  end function realpart\n  type(Quaternion) pure function imagpart_q(q)\n    type(Quaternion), intent(in) :: q\n    imagpart_q = q; imagpart_q%a = 0\n  end function imagpart_q \n  real(8) pure function imagpart_d(q, n)\n    type(Quaternion), intent(in) :: q\n    integer, intent(in) :: n\n    select case(n)\n      case(1); imagpart_d = q%b\n      case(2); imagpart_d = q%c\n      case(3); imagpart_d = q%d      \n    end select\n  end function imagpart_d\n  type(Quaternion) pure function add_qq(q1, q2)\n    type(Quaternion), intent(in) :: q1, q2\n    add_qq%a = q1%a+q2%a; add_qq%b = q1%b+q2%b\n    add_qq%c = q1%c+q2%c; add_qq%d = q1%d+q2%d\n  end function add_qq\n  type(Quaternion) pure function add_cq(c, q)\n    complex(8), intent(in) :: c\n    type(Quaternion), intent(in) :: q\n    add_cq%a = real(c)+q%a\n    add_cq%b = aimag(c)+q%b\n    add_cq%c = q%c; add_cq%d = q%d\n  end function add_cq\n  type(Quaternion) pure function add_qc(q, c)\n    complex(8), intent(in) :: c\n    type(Quaternion), intent(in) :: q\n    add_qc%a = real(c)+q%a\n    add_qc%b = aimag(c)+q%b\n    add_qc%c = q%c; add_qc%d = q%d\n  end function add_qc\n  type(Quaternion) pure function add_dq(d, q)\n    real(8), intent(in) :: d\n    type(Quaternion), intent(in) :: q\n    add_dq = q; add_dq%a = d+q%a\n  end function add_dq\n  type(Quaternion) pure function add_qd(q, d)\n    real(8), intent(in) :: d\n    type(Quaternion), intent(in) :: q\n    add_qd = q; add_qd%a = d+q%a\n  end function add_qd\n  type(Quaternion) pure function u_add(q)\n    type(Quaternion), intent(in) :: q\n    u_add = q\n  end function u_add\n  type(Quaternion) pure function sub_qq(q1, q2)\n    type(Quaternion), intent(in) :: q1, q2\n    sub_qq%a = q1%a-q2%a; sub_qq%b = q1%b-q2%b\n    sub_qq%c = q1%c-q2%c; sub_qq%d = q1%d-q2%d\n  end function sub_qq\n  type(Quaternion) pure function sub_cq(c, q)\n    complex(8), intent(in) :: c\n    type(Quaternion), intent(in) :: q\n    sub_cq%a = real(c)-q%a\n    sub_cq%b = aimag(c)-q%b\n    sub_cq%c = -q%c; sub_cq%d = -q%d\n  end function sub_cq\n  type(Quaternion) pure function sub_qc(q, c)\n    complex(8), intent(in) :: c\n    type(Quaternion), intent(in) :: q\n    sub_qc%a = -real(c)+q%a\n    sub_qc%b = -aimag(c)+q%b\n    sub_qc%c = q%c; sub_qc%d = q%d\n  end function sub_qc\n  type(Quaternion) pure function sub_dq(d, q)\n    real(8), intent(in) :: d\n    type(Quaternion), intent(in) :: q\n    sub_dq%a = d-q%a; sub_dq%b = -q%b \n    sub_dq%c = -q%c; sub_dq%d = -q%d\n  end function sub_dq\n  type(Quaternion) pure function sub_qd(q, d)\n    real(8), intent(in) :: d\n    type(Quaternion), intent(in) :: q\n    sub_qd%a = -d+q%a; sub_qd%b = q%b \n    sub_qd%c = q%c; sub_qd%d = q%d\n  end function sub_qd\n  type(Quaternion) pure function u_sub(q)\n    type(Quaternion), intent(in) :: q\n    u_sub%a = -q%a; u_sub%b = -q%b \n    u_sub%c = -q%c; u_sub%d = -q%d\n  end function u_sub\n  type(Quaternion) pure function mul_qq(q1, q2)\n    type(Quaternion), intent(in) :: q1, q2\n    mul_qq%a = q1%a*q2%a-q1%b*q2%b-q1%c*q2%c-q1%d*q2%d\n    mul_qq%b = q1%a*q2%b+q1%b*q2%a+q1%c*q2%d-q1%d*q2%c\n    mul_qq%c = q1%a*q2%c+q1%c*q2%a-q1%b*q2%d+q1%d*q2%b\n    mul_qq%d = q1%a*q2%d+q1%d*q2%a+q1%b*q2%c-q1%c*q2%b\n  end function mul_qq\n  type(Quaternion) pure function mul_cq(c, q)\n    complex(8), intent(in) :: c\n    type(Quaternion), intent(in) :: q\n    mul_cq%a = q%a*real(c)-q%b*aimag(c)\n    mul_cq%b = q%a*aimag(c)+q%b*real(c)\n    mul_cq%c = q%c*real(c)-q%d*aimag(c)\n    mul_cq%d = q%c*aimag(c)+q%d*real(c)\n  end function mul_cq\n  type(Quaternion) pure function mul_qc(q, c)\n    complex(8), intent(in) :: c\n    type(Quaternion), intent(in) :: q\n    mul_qc%a = q%a*real(c)-q%b*aimag(c)\n    mul_qc%b = q%a*aimag(c)+q%b*real(c)\n    mul_qc%c = q%c*real(c)+q%d*aimag(c)\n    mul_qc%d = -q%c*aimag(c)+q%d*real(c)\n  end function mul_qc\n  type(Quaternion) pure function mul_dq(d, q)\n    real(8), intent(in) :: d\n    type(Quaternion), intent(in) :: q\n    mul_dq%a = q%a*d; mul_dq%b = q%b*d\n    mul_dq%c = q%c*d; mul_dq%d = q%d*d\n  end function mul_dq\n  type(Quaternion) pure function mul_qd(q, d)\n    real(8), intent(in) :: d\n    type(Quaternion), intent(in) :: q\n    mul_qd%a = q%a*d; mul_qd%b = q%b*d\n    mul_qd%c = q%c*d; mul_qd%d = q%d*d\n  end function mul_qd  \n  type(Quaternion) pure function conj(q)\n    type(Quaternion), intent(in) :: q\n    conj%a = q%a;  conj%b = -q%b\n    conj%c = -q%c; conj%d = -q%d\n  end function conj\n  real(8) pure function abs(q)\n    type(Quaternion), intent(in) :: q\n    abs = sqrt(q%a*q%a+q%b*q%b+q%c*q%c+q%d*q%d)\n  end function abs\nend module QuaternionUtilities","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83636,"user_id":null,"body":"module QuaternionUtilities\n  use Quaternions\n  implicit none\n  interface imagpart\n    module procedure imagpart_q, imagpart_d\n  end interface imagpart\n  interface operator (+)\n    module procedure add_qq, add_cq, add_qc, add_dq, add_qd, u_add\n  end interface operator (+)\n  interface operator (-)\n    module procedure sub_qq, sub_cq, sub_qc, sub_dq, sub_qd, u_sub\n  end interface operator (-)\n  interface operator (*)\n    module procedure mul_qq, mul_cq, mul_qc, mul_dq, mul_qd\n  end interface operator (*)   \n  interface operator (.conj.)\n    module procedure conj\n  end interface operator (.conj.)\n  contains\n  type(Quaternion) function cdinit(c1, c2)\n    complex(8) :: c1, c2 \n    cdinit%a = real(c1); cdinit%b = aimag(c1)\n    cdinit%c = real(c2); cdinit%d = aimag(c2)\n  end function cdinit\n  real(8) function realpart(q)\n    type(Quaternion) :: q\n    realpart = q%a\n  end function realpart\n  type(Quaternion) function imagpart_q(q)\n    type(Quaternion) :: q\n    imagpart_q = q; imagpart_q%a = 0\n  end function imagpart_q \n  real(8) function imagpart_d(q, n)\n    type(Quaternion) :: q\n    integer :: n\n    select case(n)\n      case(1); imagpart_d = q%b\n      case(2); imagpart_d = q%c\n      case(3); imagpart_d = q%d      \n    end select\n  end function imagpart_d\n  type(Quaternion) function add_qq(q1, q2)\n    type(Quaternion), intent(in) :: q1, q2\n    add_qq%a = q1%a+q2%a; add_qq%b = q1%b+q2%b\n    add_qq%c = q1%c+q2%c; add_qq%d = q1%d+q2%d\n  end function add_qq\n  type(Quaternion) function add_cq(c, q)\n    complex(8) :: c\n    type(Quaternion) :: q\n    add_cq%a = real(c)+q%a\n    add_cq%b = aimag(c)+q%b\n    add_cq%c = q%c; add_cq%d = q%d\n  end function add_cq\n  type(Quaternion) function add_qc(q, c)\n    complex(8) :: c\n    type(Quaternion) :: q\n    add_qc%a = real(c)+q%a\n    add_qc%b = aimag(c)+q%b\n    add_qc%c = q%c; add_qc%d = q%d\n  end function add_qc\n  type(Quaternion) function add_dq(d, q)\n    real(8) :: d\n    type(Quaternion) :: q\n    add_dq = q; add_dq%a = d+q%a\n  end function add_dq\n  type(Quaternion) function add_qd(q, d)\n    real(8), intent(in) :: d\n    type(Quaternion), intent(in) :: q\n    add_qd = q; add_qd%a = d+q%a\n  end function add_qd\n  type(Quaternion) function u_add(q)\n    type(Quaternion), intent(in) :: q\n    u_add = q\n  end function u_add\n  type(Quaternion) function sub_qq(q1, q2)\n    type(Quaternion), intent(in) :: q1, q2\n    sub_qq%a = q1%a-q2%a; sub_qq%b = q1%b-q2%b\n    sub_qq%c = q1%c-q2%c; sub_qq%d = q1%d-q2%d\n  end function sub_qq\n  type(Quaternion) function sub_cq(c, q)\n    complex(8) :: c\n    type(Quaternion) :: q\n    sub_cq%a = real(c)-q%a\n    sub_cq%b = aimag(c)-q%b\n    sub_cq%c = -q%c; sub_cq%d = -q%d\n  end function sub_cq\n  type(Quaternion) function sub_qc(q, c)\n    complex(8) :: c\n    type(Quaternion) :: q\n    sub_qc%a = -real(c)+q%a\n    sub_qc%b = -aimag(c)+q%b\n    sub_qc%c = q%c; sub_qc%d = q%d\n  end function sub_qc\n  type(Quaternion) function sub_dq(d, q)\n    real(8) :: d\n    type(Quaternion) :: q\n    sub_dq%a = d-q%a; sub_dq%b = -q%b \n    sub_dq%c = -q%c; sub_dq%d = -q%d\n  end function sub_dq\n  type(Quaternion) function sub_qd(q, d)\n    real(8) :: d\n    type(Quaternion) :: q\n    sub_qd%a = -d+q%a; sub_qd%b = q%b \n    sub_qd%c = q%c; sub_qd%d = q%d\n  end function sub_qd\n  type(Quaternion) function u_sub(q)\n    type(Quaternion), intent(in) :: q\n    u_sub%a = -q%a; u_sub%b = -q%b \n    u_sub%c = -q%c; u_sub%d = -q%d\n  end function u_sub\n  type(Quaternion) function mul_qq(q1, q2)\n    type(Quaternion), intent(in) :: q1, q2\n    mul_qq%a = q1%a*q2%a-q1%b*q2%b-q1%c*q2%c-q1%d*q2%d\n    mul_qq%b = q1%a*q2%b+q1%b*q2%a+q1%c*q2%d-q1%d*q2%c\n    mul_qq%c = q1%a*q2%c+q1%c*q2%a-q1%b*q2%d+q1%d*q2%b\n    mul_qq%d = q1%a*q2%d+q1%d*q2%a+q1%b*q2%c-q1%c*q2%b\n  end function mul_qq\n  type(Quaternion) function mul_cq(c, q)\n    complex(8) :: c\n    type(Quaternion) :: q\n    mul_cq%a = q%a*real(c)-q%b*aimag(c)\n    mul_cq%b = q%a*aimag(c)+q%b*real(c)\n    mul_cq%c = q%c*real(c)-q%d*aimag(c)\n    mul_cq%d = q%c*aimag(c)+q%d*real(c)\n  end function mul_cq\n  type(Quaternion) function mul_qc(q, c)\n    complex(8) :: c\n    type(Quaternion) :: q\n    mul_qc%a = q%a*real(c)-q%b*aimag(c)\n    mul_qc%b = q%a*aimag(c)+q%b*real(c)\n    mul_qc%c = q%c*real(c)+q%d*aimag(c)\n    mul_qc%d = -q%c*aimag(c)+q%d*real(c)\n  end function mul_qc\n  type(Quaternion) function mul_dq(d, q)\n    real(8) :: d\n    type(Quaternion) :: q\n    mul_dq%a = q%a*d; mul_dq%b = q%b*d\n    mul_dq%c = q%c*d; mul_dq%d = q%d*d\n  end function mul_dq\n  type(Quaternion) function mul_qd(q, d)\n    real(8), intent(in) :: d\n    type(Quaternion), intent(in) :: q\n    mul_qd%a = q%a*d; mul_qd%b = q%b*d\n    mul_qd%c = q%c*d; mul_qd%d = q%d*d\n  end function mul_qd  \n  type(Quaternion) function conj(q)\n    type(Quaternion), intent(in) :: q\n    conj%a = q%a;  conj%b = -q%b\n    conj%c = -q%c; conj%d = -q%d\n  end function conj\n  real(8) function abs(q)\n    type(Quaternion) :: q\n    abs = sqrt(q%a*q%a+q%b*q%b+q%c*q%c+q%d*q%d)\n  end function abs\nend module QuaternionUtilities","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83637,"user_id":106,"body":"module QuaternionUtilities\n  use Quaternions\n  implicit none\n  public :: cdinit, realpart, imagpart\n  interface cdinit\n    module procedure cdinit\n  end interface\n  interface realpart\n    module procedure qrealpart\n  end interface\n  interface imagpart\n    module procedure qimagpart, qimagpartn\n  end interface\n  interface operator(+)\n    module procedure addu, addr, addc, addq, addr2, addc2\n  end interface\n  interface operator(-)\n    module procedure subu, subr, subc, subq, subr2, subc2\n  end interface\n  interface operator(*)\n    module procedure mulr, mulc, mulq, mulr2, mulc2\n  end interface\n  interface operator(.conj.)\n    module procedure conj\n  end interface\n  interface abs\n    module procedure qabs\n  end interface\ncontains\n  type(Quaternion) pure function cdinit(a,b)\n    complex(8), intent(in) :: a, b\n    cdinit = Quaternion(realpart(a), imagpart(a), realpart(b), imagpart(b))\n  end function\n  real(8) pure function qrealpart(q)\n    type(Quaternion), intent(in) :: q\n    qrealpart = q%a\n  end function\n  type(Quaternion) pure function qimagpart(q)\n    type(Quaternion), intent(in) :: q\n    qimagpart = Quaternion(0,q%b,q%c,q%d)\n  end function\n  real(8) pure function qimagpartn(q,n)\n    type(Quaternion), intent(in) :: q\n    integer, intent(in) :: n\n    if (n .eq. 1) qimagpartn = q%b\n    if (n .eq. 2) qimagpartn = q%c\n    if (n .eq. 3) qimagpartn = q%d\n  end function\n  type(Quaternion) pure function addu(q)\n    type(Quaternion), intent(in) :: q\n    addu = q\n  end function\n  type(Quaternion) pure function addr(a,b)\n    type(Quaternion), intent(in) :: a\n    real(8), intent(in) :: b\n    addr%a = a%a+b\n    addr%b = a%b\n    addr%c = a%c\n    addr%d = a%d\n  end function\n  type(Quaternion) pure function addc(a,b)\n    type(Quaternion), intent(in) :: a\n    complex(8), intent(in) :: b\n    addc%a = a%a+realpart(b)\n    addc%b = a%b+imagpart(b)\n    addc%c = a%c\n    addc%d = a%d\n  end function\n  type(Quaternion) pure function addq(a,b)\n    type(Quaternion), intent(in) :: a, b\n    addq%a = a%a+b%a\n    addq%b = a%b+b%b\n    addq%c = a%c+b%c\n    addq%d = a%d+b%d\n  end function\n  type(Quaternion) pure function addr2(b,a)\n    type(Quaternion), intent(in) :: a\n    real(8), intent(in) :: b\n    addr2%a = a%a+b\n    addr2%b = a%b\n    addr2%c = a%c\n    addr2%d = a%d\n  end function\n  type(Quaternion) pure function addc2(b,a)\n    type(Quaternion), intent(in) :: a\n    complex(8), intent(in) :: b\n    addc2%a = a%a+realpart(b)\n    addc2%b = a%b+imagpart(b)\n    addc2%c = a%c\n    addc2%d = a%d\n  end function\n  type(Quaternion) pure function subu(q)\n    type(Quaternion), intent(in) :: q\n    subu%a = -q%a\n    subu%b = -q%b\n    subu%c = -q%c\n    subu%d = -q%d\n  end function\n  type(Quaternion) pure function subr(a,b)\n    type(Quaternion), intent(in) :: a\n    real(8), intent(in) :: b\n    subr%a = a%a-b\n    subr%b = a%b\n    subr%c = a%c\n    subr%d = a%d\n  end function\n  type(Quaternion) pure function subc(a,b)\n    type(Quaternion), intent(in) :: a\n    complex(8), intent(in) :: b\n    subc%a = a%a-realpart(b)\n    subc%b = a%b-imagpart(b)\n    subc%c = a%c\n    subc%d = a%d\n  end function\n  type(Quaternion) pure function subq(a,b)\n    type(Quaternion), intent(in) :: a, b\n    subq%a = a%a-b%a\n    subq%b = a%b-b%b\n    subq%c = a%c-b%c\n    subq%d = a%d-b%d\n  end function\n  type(Quaternion) pure function subr2(b,a)\n    type(Quaternion), intent(in) :: a\n    real(8), intent(in) :: b\n    subr2%a = b-a%a\n    subr2%b =  -a%b\n    subr2%c =  -a%c\n    subr2%d =  -a%d\n  end function\n  type(Quaternion) pure function subc2(b,a)\n    type(Quaternion), intent(in) :: a\n    complex(8), intent(in) :: b\n    subc2%a = realpart(b)-a%a\n    subc2%b = imagpart(b)-a%b\n    subc2%c =            -a%c\n    subc2%d =            -a%d\n  end function\n  type(Quaternion) pure function mulr(a,b)\n    type(Quaternion), intent(in) :: a\n    real(8), intent(in) :: b\n    mulr%a = a%a*b\n    mulr%b = a%b*b\n    mulr%c = a%c*b\n    mulr%d = a%d*b\n  end function\n  type(Quaternion) pure function mulc(a,b)\n    type(Quaternion), intent(in) :: a\n    complex(8), intent(in) :: b\n    mulc%a = a%a*realpart(b)-a%b*imagpart(b)\n    mulc%b = a%b*realpart(b)+a%a*imagpart(b)\n    mulc%c = a%c*realpart(b)+a%d*imagpart(b)\n    mulc%d = a%d*realpart(b)-a%c*imagpart(b)\n  end function\n  type(Quaternion) pure function mulq(a,b)\n    type(Quaternion), intent(in) :: a, b\n    mulq%a = a%a*b%a-a%b*b%b-a%c*b%c-a%d*b%d\n    mulq%b = a%a*b%b+a%b*b%a+a%c*b%d-a%d*b%c\n    mulq%c = a%a*b%c-a%b*b%d+a%c*b%a+a%d*b%b\n    mulq%d = a%a*b%d+a%b*b%c-a%c*b%b+a%d*b%a\n  end function\n  type(Quaternion) pure function mulr2(b,a)\n    type(Quaternion), intent(in) :: a\n    real(8), intent(in) :: b\n    mulr2%a = a%a*b\n    mulr2%b = a%b*b\n    mulr2%c = a%c*b\n    mulr2%d = a%d*b\n  end function\n  type(Quaternion) pure function mulc2(b,a)\n    type(Quaternion), intent(in) :: a\n    complex(8), intent(in) :: b\n    mulc2%a = a%a*realpart(b)-a%b*imagpart(b)\n    mulc2%b = a%b*realpart(b)+a%a*imagpart(b)\n    mulc2%c = a%c*realpart(b)-a%d*imagpart(b)\n    mulc2%d = a%d*realpart(b)+a%c*imagpart(b)\n  end function\n  type(Quaternion) pure function conj(q)\n    type(Quaternion), intent(in) :: q\n    conj%a =  q%a\n    conj%b = -q%b\n    conj%c = -q%c\n    conj%d = -q%d\n  end function\n  real(8) pure function qabs(q)\n    type(Quaternion), intent(in) :: q\n    qabs = sqrt(q%a*q%a+q%b*q%b+q%c*q%c+q%d*q%d)\n  end function\nend module QuaternionUtilities","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5ae164eda74eaf3ffe00010f":[{"id":83638,"user_id":null,"body":"! ===============================================================\nmodule Solution\n  use ErrorCodes ! Predefined error codes for use in the solution\n  implicit none\n  private\n  public :: calculateLength\n  \ncontains\n  function calculateLength(cable, errorCode) result(cable_len)\n    character(*), intent(in) :: cable\n    integer(kind=16) :: cable_len\n    integer, intent(out) :: errorCode\n    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n    ! Local variables;\n    integer, parameter :: knd = selected_int_kind(32)\n    \n    integer(kind=knd) :: i\n    integer(kind=knd) :: n, m\n    integer(kind=knd) :: index_first, index_second\n    integer(kind=knd) :: mult\n    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n    n = 0\n    m = 0\n    mult = 1\n    index_first = 0\n    index_second = 0\n    cable_len = 0\n    calc_size: do i = 1, len(cable)\n      ! Fill the elemetns;\n      if (cable(i:i) == '(') then\n        n = n + 1\n        index_first = i\n        mult = mult * 2\n      else if (cable(i:i) == ')') then\n        m = m + 1\n        mult = mult \/ 2\n        index_second = i\n        !\n        if (n == 0) then\n          errorCode = ERROR_UNMATCHED_BRACKETS\n          cable_len = -1\n          return \n        endif\n        if (m > n) then\n          errorCode = ERROR_UNMATCHED_BRACKETS\n          cable_len = -1\n          return\n        else if (index_second - index_first == 1) then\n          errorCode = ERROR_INVALID_CHARACTER\n          cable_len = -1\n          return\n        endif\n      else if (cable(i:i) == '-') then\n        cable_len = cable_len + 1 * mult\n      else if (cable(i:i) == '_') then\n        cable_len = cable_len + 2 * mult\n      else if (cable(i:i) == '=') then\n        cable_len = cable_len + 3 * mult\n      else\n        errorCode = ERROR_INVALID_CHARACTER\n        cable_len = -1\n        return\n      endif    \n    enddo calc_size \n     \n    if (n .ne. m) then\n      errorCode = ERROR_UNMATCHED_BRACKETS\n      cable_len = -1\n      return \n    endif\n    \n    return\n  end function calculateLength\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83639,"user_id":17,"body":"module Solution\n  use ErrorCodes\n  implicit none\ncontains\n  integer(16) function calculateLength(cable, errorCode) result(cableLength)\n    character(*), intent(in) :: cable\n    integer, intent(out) :: errorCode\n    integer :: shift, i\n    cableLength = 0_16\n    shift = 0\n    do i = 1, len(cable)\n      select case (cable(i:i))\n        case ('(')\n          shift = shift + 1\n        case (')')\n          shift = shift - 1\n        case ('-')\n          cableLength = cableLength + ishft(1_16, shift)\n        case ('_')\n          cableLength = cableLength + ishft(2_16, shift)\n        case ('=')\n          cableLength = cableLength + ishft(3_16, shift)\n        case default\n          cableLength = -1_16\n          shift = 0\n          errorCode = ERROR_INVALID_CHARACTER\n          exit\n      end select\n      if (shift < 0) then\n        cableLength = -1_16\n        errorCode = ERROR_UNMATCHED_BRACKETS\n        exit\n      end if\n    end do\n    if (shift \/= 0) then\n      cableLength = -1_16\n      errorCode = ERROR_UNMATCHED_BRACKETS\n    end if\n  end function calculateLength\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83640,"user_id":null,"body":"module Solution\n  use ErrorCodes ! Predefined error codes for use in your solution\n  implicit none\ncontains\n  integer(16) function calculateLength(cable, errorCode) result(cableLength)\n    character(*), intent(in) :: cable\n    character(len=1) :: c\n    integer, intent(out) :: errorCode\n    integer(kind=16) :: multiplier, i\n    multiplier = 1\n    cableLength = 0_16\n    do i = 1, len(cable)\n      c = cable(i:i) \n      if (c == '-') then\n        cableLength = cableLength + multiplier * 1\n      else if (c == '_') then\n        cableLength = cableLength + multiplier * 2\n      else if (c == '=') then\n        cableLength = cableLength + multiplier * 3\n      else if (c == '(') then\n        multiplier = multiplier * 2\n      else if (c == ')') then\n        multiplier = multiplier \/ 2\n      else\n        cableLength = -1\n        errorCode = ERROR_INVALID_CHARACTER\n        multiplier = 1\n        exit\n      end if\n      ! Too many closing brackets\n      if (multiplier == 0) then\n          cableLength = -1\n          errorCode = ERROR_UNMATCHED_BRACKETS\n          exit\n      end if\n    end do\n    ! Not enough closing brackets\n    if (multiplier .ne. 1) then\n        cableLength = -1\n        errorCode = ERROR_UNMATCHED_BRACKETS\n    end if\n  end function calculateLength\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83641,"user_id":168,"body":"module Solution\n  use ErrorCodes ! Predefined error codes for use in your solution\n  implicit none\ncontains\n  integer(16) function calculateLength(cable, errorCode) result(cableLength)\n    character(*), intent(in) :: cable\n    integer, intent(out) :: errorCode\n    integer :: i\n    integer(16) :: c, x\n    \n    cableLength = 0\n    errorCode = 0\n    c = 1\n    do i = 1, len(cable)\n      x = 0\n      select case (cable(i:i))\n        case ('-'); x = 1\n        case ('_'); x = 2\n        case ('='); x = 3\n        case ('('); c = c * 2\n        case (')')\n          if (c == 1) then\n            c = 0\n            exit\n          end if\n          c = c \/ 2\n        case default\n          errorCode = ERROR_INVALID_CHARACTER\n          cableLength = -1\n          return\n      end select\n      cableLength = cableLength + x * c\n    end do\n\n    if (c \/= 1) then\n      errorCode = ERROR_UNMATCHED_BRACKETS\n      cableLength = -1\n    end if\n  end function calculateLength\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83642,"user_id":null,"body":"module Solution\n  use ErrorCodes ! Predefined error codes for use in your solution\n  implicit none\ncontains\n  integer(16) function calculateLength(cable, errorCode) result(cableLength)\n    character(*), intent(in) :: cable\n    integer, intent(out) :: errorCode\n    integer(16) i, openedBrackets, bi ! brackets index\n    integer(16) brackets(len(cable))\n\n    cableLength = 0_16\n    openedBrackets = 0\n    bi = 1\n    i = 1\n    brackets = 0\n    \n    do while (i .le. len(cable))\n      select case (cable(i:i))\n        case ('-')\n          brackets(bi) = brackets(bi) + 1\n        case ('_')\n          brackets(bi) = brackets(bi) + 2\n        case ('=')\n          brackets(bi) = brackets(bi) + 3\n        case ('(')\n          openedBrackets = openedBrackets + 1\n         \n          bi = bi + 1\n        case (')')\n          openedBrackets = openedBrackets - 1\n          if (openedBrackets .lt. 0) then\n            cableLength = -1\n            errorCode = ERROR_UNMATCHED_BRACKETS\n            return\n          end if\n          \n          brackets(bi-1) = brackets(bi-1) + brackets(bi)*2\n          brackets(bi) = 0 ! empty it for future calculations\n          bi = bi - 1\n        case default\n          cableLength = -1\n          errorCode = ERROR_INVALID_CHARACTER\n          return\n      end select\n    \n      i = i + 1\n    end do\n    \n    if (openedBrackets .ne. 0) then\n     cableLength = -1\n     errorCode = ERROR_UNMATCHED_BRACKETS\n     return\n    end if\n    \n    cableLength = brackets(1)\n  end function calculateLength\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83643,"user_id":null,"body":"module Solution\n  use ErrorCodes ! Predefined error codes for use in your solution\n  implicit none\ncontains\n  integer(16) function calculateLength(cable, errorCode) result(cableLength)\n    character(*), intent(in) :: cable\n    character :: c\n    integer, intent(out) :: errorCode\n    integer, parameter :: depth = 64\n    integer(16), dimension (1:depth) :: lengths\n    integer(16) :: i\n    integer :: how_deep, add\n    \n    lengths = (\/ (0, how_deep = 1, depth) \/)\n    how_deep = 1\n    cableLength = -1\n    errorCode = 0\n    \n    unroll_cable : do i = 1, len(cable)\n      c = cable(i:i)\n      add = 0\n      select case (c)\n        case (\"-\")\n          add = 1\n        case (\"_\")\n          add = 2\n        case (\"=\")\n          add = 3\n        case (\"(\")\n          how_deep = how_deep + 1\n          lengths(how_deep) = 0\n        case (\")\")\n          how_deep = how_deep - 1\n          if (how_deep < 1) exit unroll_cable\n          lengths(how_deep) = lengths(how_deep) + 2 * lengths(how_deep + 1)\n        case default\n          errorCode = ERROR_INVALID_CHARACTER\n          exit unroll_cable          \n      end select\n      lengths(how_deep) = lengths(how_deep) + add\n    end do unroll_cable\n    \n    if ((how_deep \/= 1) .AND. (errorCode \/= ERROR_INVALID_CHARACTER)) then\n      errorCode = ERROR_UNMATCHED_BRACKETS\n    end if\n    \n    if ((errorCode \/= ERROR_INVALID_CHARACTER) .AND. (errorCode \/= ERROR_UNMATCHED_BRACKETS)) then\n      cableLength = lengths(1)\n    end if\n    \n  end function calculateLength\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83644,"user_id":17,"body":"module Solution\n  use ErrorCodes\n  implicit none\ncontains\n  integer(16) function calculateLength(cable, errorCode) result(cableLength)\n    character(*), intent(in) :: cable\n    integer, intent(out) :: errorCode\n    integer :: shift, i\n    cableLength = 0_16\n    shift = 0\n    do i = 1, len(cable)\n      select case (cable(i:i))\n        case ('(')\n          shift = shift + 1\n        case (')')\n          shift = shift - 1\n        case ('-')\n          cableLength = cableLength + ishft(1_16, shift)\n        case ('_')\n          cableLength = cableLength + ishft(2_16, shift)\n        case ('=')\n          cableLength = cableLength + ishft(3_16, shift)\n        case default\n          cableLength = -1_16\n          shift = 0\n          errorCode = ERROR_INVALID_CHARACTER\n          exit\n      end select\n      if (shift < 0) then\n        cableLength = -1_16\n        errorCode = ERROR_UNMATCHED_BRACKETS\n        exit\n      end if\n    end do\n    if (shift \/= 0) then\n      cableLength = -1_16\n      errorCode = ERROR_UNMATCHED_BRACKETS\n    end if\n  end function calculateLength\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5ae62fcf252e66d44d00008e":[{"id":83645,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function expression_matter(a, b, c) result (res)\n    integer, intent(in) :: a, b, c\n    res = max(a+b+c, a*b*c, (a+b)*c, a*(b+c))    \n  end function expression_matter\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83646,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  pure function expression_matter(a, b, c) result (res)\n    integer, intent(in) :: a, b, c\n    integer :: res\n    if (a .eq. 1) then\n      if (c .eq. 1) then\n        res=a+b+c\n      else\n        res=(a+b)*c\n      end if\n    else if (b .eq. 1) then\n      if (a .gt. c) then\n        res=a*(b+c)\n      else\n        res=(a+b)*c\n      end if\n    else if (c .eq. 1) then\n      res=a*(b+c)\n    else\n      res=a*b*c\n    end if\n  end function expression_matter\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83647,"user_id":53,"body":"module Solution\n  implicit none\ncontains\n  integer pure function expression_matter(a, b, c) result (res)\n    integer, intent(in) :: a, b, c\n    res = 0\n    IF (a+b+c>res) THEN\n        res = a+b+c\n    END IF\n    IF (a*b*c>res) THEN\n        res = a*b*c\n    END IF\n    IF ((a+b)*c>res) THEN\n        res = (a+b)*c\n    END IF\n    IF (a*(b+c)>res) THEN\n        res = a*(b+c)\n    END IF\n  end function expression_matter\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83648,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  \n  integer function num_ones(a, b, c) result (res)\n    integer :: a, b, c\n    if (a + b + c == 3) then\n      res = 3\n    else if ( ((a + b == 2) .and. (c \/= 1)) .or. ((c + a == 2) .and. (b \/= 1))& \n    .or. ((b + c == 2) .and. (a \/= 1))) then\n      res = 2\n    else if ( ((a == 1) .and. (b \/= 1) .and. (c \/= 1))&\n    .or. ((b == 1) .and. (a \/= 1) .and. (c \/= 1))&\n    .or. ((c == 1) .and. (a \/= 1) .and. (b \/= 1))) then\n          res = 1\n    else\n      res = 0\n    end if\n  end function num_ones\n  \n  integer function expression_matter(a, b, c) result (res)\n    integer, intent(in) :: a, b, c\n    integer :: maxx\n    select case (num_ones(a,b,c))\n          case (3)\n          res = 3\n          \n          case (2)\n          if ( c \/= 1) then\n            res = (a + b) * c\n          else if ( b \/= 1) then\n            res = a + b + c\n          else\n            res = a * (b + c)\n          end if\n                    \n          case (1)\n          maxx = max (a, b, c)\n          if (a == 1) then\n            res = (a + b) * c\n          else if (b == 1) then\n            if (a < c) then \n              res = (a + b) * c\n            else\n              res = a * (b + c)\n            end if\n          else\n            res = a * (b + c)\n          end if\n          \n          case (0)\n          res = a * b * c\n          \n          !case default\n          !res = 0\n    end select\n  end function expression_matter\n\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83649,"user_id":50,"body":"module Solution\n  implicit none\ncontains\n  integer pure function expression_matter(a, b, c) result (res)\n    integer, intent(in) :: a, b, c\n    res = max(max((a+b)*c, a*(b+c)), max(a+b+c, a*b*c))\n  end function expression_matter\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83650,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function expression_matter(a, b, c) result (res)\n    integer, intent(in) :: a, b, c\n    res = 0\n    if(a+c==2) then\n      res=a+b+c\n    else\n      if(a==1 .or. b==1 .or. c==1) then\n        if(a>c) then\n          res=a*(b+c)\n        else\n          res=(a+b)*c\n        end if\n      else\n        res=a*b*c\n      end if\n    end if\n  end function expression_matter\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83651,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function expression_matter(a, b, c) result (res)\n    integer, intent(in) :: a, b, c\n    res = max(a*b*c, a+b+c, (a+b)*c, a*(b+c))\n  end function expression_matter\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83652,"user_id":168,"body":"module Solution\n  implicit none\ncontains\n  integer pure function expression_matter(a, b, c) result (res)\n    integer, intent(in) :: a, b, c\n    res = max(a + b + c, a * (b + c), (a + b) * c, a * b * c)\n  end function expression_matter\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83653,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function expression_matter(a, b, c) result (res)\n    integer, intent(in) :: a, b, c\n    integer :: t1, t2,t3, t4, t5\n    t1 = a * (b + c)\n    t2 = a * b * c\n    t3 = a + b * c\n    t4 = (a + b) * c\n    t5 = a + b + c\n    res = MAX (t1, t2, t3, t4, t5)\nend function expression_matter\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83654,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer pure function expression_matter(a, b, c) result (res)\n    integer, intent(in) :: a, b, c\n    res = max(a * b * c, a + b + c, a * b + c, a * (b + c), a + b * c, (a + b) * c) \n  end function expression_matter\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5ae71f8c2c5061059e000044":[{"id":83655,"user_id":76,"body":"module Solution\n  implicit none\ncontains\n  integer(8) pure function findX(n)\n    integer(8), intent(in) :: n\n    findX = n * n * (3 * n - 2)\n  end function findX\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83656,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  ! TODO: Optimize function findX(n)\n  integer(8) pure function findX(n) result(x)\n  integer(8), intent(in) :: n\n   \n!   integer(8) :: i, j\n!   x = 0\n!   do i = 0, n - 1\n!    do j = 0, 2 * n - 1\n!       x = x + j + i\n!     end do\n!   end do\n!\n!   The above is simplified to:\n!    x=0\n!    do i=1,n\n!      x=x+(2*n-1)*n+(n-1)*n\n!    enddo\n!\n!   which again is simplified to:\n!   x=n*((2*n-1)*n+(n-1)*n)\n!\n!   which can be simplified to:\n    x=n**2*(3*n-2)\n  end function findX\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83657,"user_id":1703,"body":"module Solution\n  implicit none\ncontains\n  integer(8) pure function findX(n) result(x)\n    integer(8), intent(in) :: n\n    integer(8) :: i, j\n    x = n * ( n * ( n - 1 ) + ( 2 * n - 1 ) * n )\n  end function findX\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83658,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  ! TODO: Optimize function findX(n)\n  function findX(n) result(x)\n    integer(8) :: n, x\n    x = 0\n    x = x + (3*n - 2)*n**2\n  end function findX\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83659,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  ! TODO: Optimize function findX(n)\n  integer(8) pure function findX(n) result(x)\n    integer(8), intent(in) :: n\n    integer(8) :: i, j\n    x = (3*n-2)*n*n\n  end function findX\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83660,"user_id":null,"body":"module Solution\n  \n  implicit none\n\ncontains\n  \n  pure function findX(n)\n    integer(8) :: findX\n    integer(8), intent(in) :: n\n  \n    findX = (-2 + 3 * n) * n**2 \n    \n    return\n  end function findX\n\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83661,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  ! TODO: Optimize function findX(n)\n  integer(8) pure function findX(n) result(x)\n    integer(8), intent(in) :: n\n    x=n*n*(3_8*n-2_8)\n  end function findX\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83662,"user_id":527,"body":"module Solution\n  implicit none\ncontains\n  integer(8) pure function findX(n) result(x)\n    integer(8), intent(in) :: n\n    x = 3 * n**3 - 2 * n**2\n  end function findX\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83663,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  ! TODO: Optimize function findX(n)\n  integer(8) function findX(n) result(x)\n    integer(8), intent(in) :: n\n    integer(8) :: i, j, z,nn\n    nn = n-1\n    z = 2*n-1\n    x = n * z*(z+1)\/2 + (z+1)*nn*(nn+1)\/2\n    write(*,*) n,x\n  end function findX\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83664,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  ! TODO: Optimize function findX(n)\n  integer(8) pure function findX(n) result(x)\n    integer(8), intent(in) :: n\n    x = n ** 2 * (3 * n - 2)\n  end function findX\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5ae7e3f068e6445bc8000046":[{"id":83665,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer(2) pure function nextHappyYear(currentYear) result(next)\n    integer(2), intent(in) :: currentYear\n    integer(1) :: i, j\n    next=currentYear+1\n    do while (count((\/(count((\/(mod(next\/10**i,10),i=0,3)\/)==j)>1,j=0,9)\/))>0)\n        next=next+1\n    end do\n  end function nextHappyYear\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83666,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer(2) pure function nextHappyYear(currentYear) result(next)\n    integer(2), intent(in) :: currentYear\n    integer(1) :: i, j\n    next=currentYear+1\n    do while (count((\/(count((\/(mod(next\/10**i,10),i=3,0,-1)\/)==j)>1,j=0,9)\/))>0)\n        next=next+1\n    end do\n  end function nextHappyYear\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83667,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer(2) pure function nextHappyYear(currentYear)\n  integer(2), intent(in) :: currentYear\n  INTEGER :: num1, num2, num3, num4, i, currentYear2\n\n  currentYear2 = currentYear\n  i = 0\n  DO WHILE(i==0)\n    currentYear2= currentYear2 + 1\n    num1= currentYear2\/1000\n    num2= MOD(currentYear2,1000)\/100\n    num3= MOD(currentYear2,100)\/10\n    num4= MOD(currentYear2,10)\n    IF (num1 == num2 .or. num1 == num3 .or. num1 == num4 .or. num2 == num3 .or. num2 == num4 .or. num3 == num4) THEN\n      i = 0\n    ELSE\n      i = 1\n      nextHappyYear = currentYear2\n    END IF\n  END DO\n  end function nextHappyYear\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83668,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer(2) pure function nextHappyYear(currentYear)\n    integer(2), intent(in) :: currentYear\n    \n    ! nextHappyYear = 0_2 ! TODO\n    \n    integer(2) :: temp,d1,d2,d3,d4\n    temp=currentYear\n    do \n    temp=temp+1\n    d4=mod(temp,10)\n    d3=mod(temp\/10,10)\n    d2=mod(temp\/100,10)\n    d1=mod(temp\/1000,10)\n    \n    if( (d4 .ne. d3) .and. (d4 .ne. d2) .and. (d4 .ne. d1) .and. (d3 .ne. d2) .and. (d3 .ne. d1) .and. (d2 .ne. d1)) exit  ! and return temp\n    end do \n    \n    nextHappyYear=temp\n    \n  end function nextHappyYear\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83669,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer(2) pure function nextHappyYear(currentYear)\n    integer(2), intent(in) :: currentYear\n    integer :: d1, d2, d3,d4\n    \n    do nextHappyYear = currentYear+1, 9999\n      d1 = nextHappyYear \/ 1000\n      d2 = modulo(nextHappyYear, 1000) \/ 100\n      d3 = modulo(nextHappyYear, 100) \/ 10\n      d4 = modulo(nextHappyYear, 10)\n      if (d1 .ne. d2 .and. d1 .ne. d3 .and. d1 .ne. d4 .and. d2 .ne. d3 .and. d2 .ne. d4 .and. d3 .ne. d4) exit\n    end do\n  end function nextHappyYear\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83670,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer(2) pure function nextHappyYear(currentYear)\n    integer(2), intent(in) :: currentYear\n    integer :: dig(1:4), ty, i, j\n    logical :: eq\n    nextHappyYear = 0_2\n    \n    ty = currentYear\n    eq = .True.\n    Do While (eq)\n      ty = ty + 1\n      dig(1) = mod(ty,10)      ;      dig(2) = mod(ty\/10,10)\n      dig(3) = mod(ty\/100,10)  ;      dig(4) = mod(ty\/1000,10)\n      eq = .False.\n      Do i = 1, 3\n        Do j = i + 1, 4\n          If (dig(i) == dig(j)) eq = .True.\n        End Do\n      End Do\n    End Do\n    \n    nextHappyYear = dig(1) + 10*dig(2) + 100*dig(3) + 1000*dig(4)\n    \n  end function nextHappyYear\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83671,"user_id":null,"body":"module solution\n\n    implicit none\n    \n    contains\n    \n    pure logical function is_happy(year)\n        integer(2),intent(in) :: year\n        integer :: num,rem\n        integer,dimension(:),allocatable :: lis\n        integer :: i\n        is_happy = .true.\n        num = floor(log10(real(year))) + 1\n        allocate(lis(num))\n        rem = year\n        do i=1,num,1\n            lis(i)=rem-(rem\/10)*10\n            if(i>1.and.minval(abs(lis(1:i-1)-lis(i)))==0)then\n                is_happy = .false.\n                return\n            end if\n            rem=rem\/10\n        end do\n    end function is_happy\n    \n    pure integer(2) function nextHappyYear(currentYear)\n        integer(2), intent(in) :: currentYear\n        nextHappyYear = currentYear + 1\n        do \n            if(is_happy(nextHappyYear)) return\n            nextHappyYear = nextHappyYear + 1\n        end do\n    end function nextHappyYear\n\nend module solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83672,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer(2) pure function nextHappyYear(currentYear)\n    integer(2), intent(in) :: currentYear\n    integer digits(4)\n    digits = (\/0,0,0,0\/)\n    nextHappyYear = 0_2\n    \n    do nextHappyYear = currentYear+1, 9999\n      digits(1) = nextHappyYear \/ 1000\n      digits(2) = (nextHappyYear - digits(1) * 1000) \/ 100\n      digits(3) = (nextHappyYear - digits(1) * 1000 - digits(2) * 100) \/ 10\n      digits(4) = nextHappyYear - digits(1) * 1000 - digits(2) * 100 - digits(3) * 10\n      \n      if(digits(1) == digits(2) .OR. digits(2) == digits(3) .OR. digits(3) == digits(4)) then\n        cycle\n      end if\n      if(digits(1) == digits(3) .OR. digits(2) == digits(4) .OR. digits(1) == digits(4)) then\n        cycle\n      end if\n      \n      return\n    end do\n    \n  end function nextHappyYear\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83673,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer(2) function nextHappyYear(currentYear)\n    integer(2), intent(in) :: currentYear\n    integer(2), dimension(0:9) :: cnts\n    integer(2) :: i, tmp\n    \n    nextHappyYear = currentYear\n    ! year could go up to 65535, but oh well\n    outside: do while (nextHappyYear < 9999)\n      cnts = 0\n      nextHappyYear = nextHappyYear +1\n      tmp = nextHappyYear\n      do while (tmp > 0 )\n        i = mod(tmp,10)\n        tmp= tmp \/ 10\n        cnts(i:i) = cnts(i:i) +1\n        !write(*,*) nextHappyYear,tmp, cnts\n        if (any(cnts > 1)) then\n          !write(*,*) \"KO\", cnts\n          cycle outside\n        end if\n      end do\n      exit\n    end do outside\n  end function nextHappyYear\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83674,"user_id":null,"body":"module Solution\n  implicit none\ncontains\n  integer(2) function nextHappyYear(currentYear)\n  integer(2), intent(in) :: currentYear\n  integer(2) y, m, c, x, i\n\n  y = currentyear \n  print *, \"In: \", y\n  y = y + 1\n\n  nextHappyYear = 0\n  do while (nextHappyYear == 0)\n    i=mod(y,10); x=mod(y\/10,10); c=mod(y\/100,10); m=y\/1000  ! Break down year into 4 digits\n    ! print *, m, c, x, i\n\n    if (i == x .or. i == c .or. i == m) then  ! CHeck if unit's digit == a higher order digit\n      y = y + 1                        ! increment units.\n    else if (x == c .or. x == m) then  ! Or if 10's digit,\n      y = y + 10 - i                   ! increment it and zero units.\n    else if (c == m) then              ! Or if 100's digit, increment it and zero tens & units,\n      y = y + 100 - x*10 - i + 1       ! now there's 2 zeros, so increment units.\n    else\n      nextHappyYear = y      ! Finis.\n      print *, \"End \", y\n      return\n    end if\n  end do\n\n  return\n  end function nextHappyYear\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5afbb8cc3e9715157d00013d":[{"id":83675,"user_id":null,"body":"MODULE QuaternionUtilities\n    USE Quaternions\n    IMPLICIT NONE\n    PRIVATE :: imagpart1, qabs, qexp, qsinh, qcosh, qsin, qcos, add, inv, sub\n    INTERFACE exp\n        MODULE PROCEDURE qexp\n    END INTERFACE\n    INTERFACE sinh\n        MODULE PROCEDURE qsinh\n    END INTERFACE\n    INTERFACE cosh\n        MODULE PROCEDURE qcosh\n    END INTERFACE\n    INTERFACE sin\n        MODULE PROCEDURE qsin\n    END INTERFACE\n    INTERFACE cos\n        MODULE PROCEDURE qcos\n    END INTERFACE\nCONTAINS\n    TYPE(Quaternion) PURE FUNCTION imagpart1(z)\n        TYPE(Quaternion), INTENT(IN) :: z\n        imagpart1 = Quaternion(0, z%b, z%c, z%d)\n    END FUNCTION imagpart1\n    REAL(8) PURE FUNCTION qabs(z)\n        TYPE(Quaternion), INTENT(IN) :: z\n        qabs = SQRT(z%a ** 2 + z%b ** 2 + z%c ** 2 + z%d ** 2)\n    END FUNCTION\n    TYPE(Quaternion) PURE FUNCTION qexp(z)\n        TYPE(Quaternion), INTENT(IN) :: z\n        REAL(8) :: u, w, x\n        u = EXP(z%a)\n        x = qabs(imagpart1(z))\n        w = SIN(x) \/ x\n        qexp = Quaternion(u * COS(x), u * w * z%b, u * w * z%c, u * w * z%d)\n    END FUNCTION qexp\n    TYPE(Quaternion) PURE FUNCTION qsinh(z)\n        TYPE(Quaternion), INTENT(IN) :: z\n        TYPE(Quaternion) :: zz\n        zz = sub(EXP(z), EXP(inv(z)))\n        qsinh = Quaternion(zz%a \/ 2.0_8, zz%b \/ 2.0_8, zz%c \/ 2.0_8, zz%d \/ 2.0_8)\n    END FUNCTION qsinh\n    TYPE(Quaternion) PURE FUNCTION qcosh(z)\n        TYPE(Quaternion), INTENT(IN) :: z\n        TYPE(Quaternion) :: zz\n        zz = add(EXP(z), EXP(inv(z)))\n        qcosh = Quaternion(zz%a \/ 2.0_8, zz%b \/ 2.0_8, zz%c \/ 2.0_8, zz%d \/ 2.0_8)\n    END FUNCTION qcosh\n    TYPE(Quaternion) PURE FUNCTION qsin(z)\n        TYPE(Quaternion), INTENT(IN) :: z\n        REAL(8) :: w, x\n        x = qabs(imagpart1(z))\n        w = +COS(z%a) * SINH(x) \/ x\n        qsin = Quaternion(SIN(z%a) * COSH(x), w * z%b, w * z%c, w * z%d)\n    END FUNCTION qsin\n    TYPE(Quaternion) PURE FUNCTION qcos(z)\n        TYPE(Quaternion), INTENT(IN) :: z\n        REAL(8) :: w, x\n        x = qabs(imagpart1(z))\n        w = -SIN(z%a) * SINH(x) \/ x\n        qcos = Quaternion(COS(z%a) * COSH(x), w * z%b, w * z%c, w * z%d)\n    END FUNCTION qcos\n    TYPE(Quaternion) PURE FUNCTION add(z1, z2)\n        TYPE(Quaternion), INTENT(IN) :: z1, z2\n        add = Quaternion(z1%a + z2%a, z1%b + z2%b, z1%c + z2%c, z1%d + z2%d)\n    END FUNCTION add\n    TYPE(Quaternion) PURE FUNCTION inv(z)\n        TYPE(Quaternion), INTENT(IN) :: z\n        inv = Quaternion(-z%a, -z%b, -z%c, -z%d)\n    END FUNCTION inv\n    TYPE(Quaternion) PURE FUNCTION sub(z1, z2)\n        TYPE(Quaternion), INTENT(IN) :: z1, z2\n        sub = add(z1, inv(z2))\n    END FUNCTION sub\nEND MODULE QuaternionUtilities","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83676,"user_id":null,"body":"module QuaternionUtilities\n  use Quaternions\n  implicit none\n  private :: vnorm, vu\n  private :: operator (+)\n  private :: operator (-)\n  private :: operator (*)\n  public :: exp, sinh, cosh, sin, cos\n  interface exp\n    module procedure qexp\n  end interface exp\n  interface sinh\n    module procedure qsinh\n  end interface sinh\n  interface cosh\n    module procedure qcosh\n  end interface cosh\n  interface sin\n    module procedure qsin\n  end interface sin\n  interface cos\n    module procedure qcos\n  end interface cos\n  interface operator (*)\n    module procedure mul\n  end interface operator (*)\n  interface operator (+)\n    module procedure add_qq, add_dq\n  end interface operator (+)\n  interface operator (-)\n    module procedure sub, neg\n  end interface operator (-)  \ncontains\n  type(Quaternion) pure function qexp(q)\n    type(Quaternion), intent(in) :: q\n    real(8) :: norm, k\n    norm = vnorm(q); k = exp(q%a)\n    qexp = k*cos(norm)+vu(q)*(k*sin(norm))\n  end function qexp\n  type(Quaternion) pure function qsinh(q)\n    type(Quaternion), intent(in) :: q\n    qsinh = (qexp(q)-qexp(-q))*0.5_8\n  end function qsinh\n  type(Quaternion) pure function qcosh(q)\n    type(Quaternion), intent(in) :: q\n    qcosh = (qexp(q)+qexp(-q))*0.5_8  \n  end function qcosh\n  type(Quaternion) pure function qsin(q)\n    type(Quaternion), intent(in) :: q\n    real(8) :: norm\n    norm = vnorm(q)\n    qsin = sin(q%a)*cosh(norm)+vu(q)*(cos(q%a)*sinh(norm))\n  end function qsin\n  type(Quaternion) pure function qcos(q)\n    type(Quaternion), intent(in) :: q\n    real(8) :: norm\n    norm = vnorm(q)\n    qcos = cos(q%a)*cosh(norm)+vu(q)*(-sin(q%a)*sinh(norm))\n  end function qcos\n  real(8) pure function vnorm(q)\n    type(Quaternion), intent(in) :: q\n    vnorm = sqrt(q%b*q%b+q%c*q%c+q%d*q%d)\n  end function vnorm\n  type(Quaternion) pure function vu(q)\n    type(Quaternion), intent(in) :: q\n    real(8) :: norm\n    norm = vnorm(q)\n    vu%a = 0; vu%b = q%b\/norm\n    vu%c = q%c\/norm; vu%d = q%d\/norm\n  end function vu  \n  type(Quaternion) pure function add_qq(q1, q2) result(r)\n    type(Quaternion), intent(in) :: q1, q2\n    r%a = q1%a+q2%a; r%b = q1%b+q2%b \n    r%c = q1%c+q2%c; r%d = q1%d+q2%d\n  end function add_qq  \n  type(Quaternion) pure function add_dq(d, q) result(r)\n    real(8), intent(in) :: d\n    type(Quaternion), intent(in) :: q\n    r = q; r%a = d+q%a\n  end function add_dq\n  type(Quaternion) pure function sub(q1, q2) result(r)\n    type(Quaternion), intent(in) :: q1, q2\n    r%a = q1%a-q2%a; r%b = q1%b-q2%b\n    r%c = q1%c-q2%c; r%d = q1%d-q2%d\n  end function sub\n  type(Quaternion) pure function neg(q) result(r)\n    type(Quaternion), intent(in) :: q\n    r%a = -q%a; r%b = -q%b; r%c = -q%c; r%d = -q%d\n  end function neg \n  type(Quaternion) pure function mul(q, d) result(r)\n    real(8), intent(in) :: d\n    type(Quaternion), intent(in) :: q\n    r%a = q%a*d; r%b = q%b*d; r%c = q%c*d; r%d = q%d*d\n  end function mul\nend module QuaternionUtilities","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83677,"user_id":null,"body":"module QuaternionUtilities\n  use Quaternions\n  implicit none\n  private :: vnorm, vu, add_qq, add_dq, sub_qq, neg, mul_qd\n  public :: exp, sinh, cosh, sin, cos\n  interface exp\n    module procedure qexp\n  end interface exp\n  interface sinh\n    module procedure qsinh\n  end interface sinh\n  interface cosh\n    module procedure qcosh\n  end interface cosh\n  interface sin\n    module procedure qsin\n  end interface sin\n  interface cos\n    module procedure qcos\n  end interface cos\ncontains\n  type(Quaternion) pure function qexp(q)\n    type(Quaternion), intent(in) :: q\n    real(8) :: norm, k\n    norm = vnorm(q); k = exp(q%a)\n    qexp = add_dq(k*cos(norm), mul_qd(vu(q), k*sin(norm)))\n  end function qexp\n  type(Quaternion) pure function qsinh(q)\n    type(Quaternion), intent(in) :: q\n    qsinh = mul_qd(sub_qq(qexp(q), qexp(neg(q))), 0.5_8)\n  end function qsinh\n  type(Quaternion) pure function qcosh(q)\n    type(Quaternion), intent(in) :: q\n    qcosh = mul_qd(add_qq(qexp(q), qexp(neg(q))), 0.5_8)  \n  end function qcosh\n  type(Quaternion) pure function qsin(q)\n    type(Quaternion), intent(in) :: q\n    type(Quaternion) :: v\n    real(8) :: norm, d\n    norm = vnorm(q)\n    d = sin(q%a)*cosh(norm)\n    v = mul_qd(vu(q), cos(q%a)*sinh(norm))\n    qsin = add_dq(d, v)\n  end function qsin\n  type(Quaternion) pure function qcos(q)\n    type(Quaternion), intent(in) :: q\n    type(Quaternion) :: v\n    real(8) :: norm, d\n    norm = vnorm(q)\n    d = cos(q%a)*cosh(norm)\n    v = mul_qd(vu(q), -sin(q%a)*sinh(norm))\n    qcos = add_dq(d, v)\n  end function qcos\n  real(8) pure function vnorm(q)\n    type(Quaternion), intent(in) :: q\n    vnorm = sqrt(q%b*q%b+q%c*q%c+q%d*q%d)\n  end function vnorm\n  type(Quaternion) pure function vu(q)\n    type(Quaternion), intent(in) :: q\n    real(8) :: norm\n    norm = vnorm(q)\n    vu%a = 0; vu%b = q%b\/norm\n    vu%c = q%c\/norm; vu%d = q%d\/norm\n  end function vu  \n  type(Quaternion) pure function add_qq(q1, q2) result(r)\n    type(Quaternion), intent(in) :: q1, q2\n    r%a = q1%a+q2%a; r%b = q1%b+q2%b \n    r%c = q1%c+q2%c; r%d = q1%d+q2%d\n  end function add_qq  \n  type(Quaternion) pure function sub_qq(q1, q2) result(r)\n    type(Quaternion), intent(in) :: q1, q2\n    r%a = q1%a-q2%a; r%b = q1%b-q2%b\n    r%c = q1%c-q2%c; r%d = q1%d-q2%d\n  end function sub_qq\n  type(Quaternion) pure function add_dq(d, q) result(r)\n    real(8), intent(in) :: d\n    type(Quaternion), intent(in) :: q\n    r = q; r%a = d+q%a\n  end function add_dq\n  type(Quaternion) pure function neg(q) result(r)\n    type(Quaternion), intent(in) :: q\n    r%a = -q%a; r%b = -q%b; r%c = -q%c; r%d = -q%d\n  end function neg \n  type(Quaternion) pure function mul_qd(q, d) result(r)\n    real(8), intent(in) :: d\n    type(Quaternion), intent(in) :: q\n    r%a = q%a*d; r%b = q%b*d; r%c = q%c*d; r%d = q%d*d\n  end function mul_qd\nend module QuaternionUtilities","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83678,"user_id":106,"body":"module QuaternionUtilities\n  use Quaternions ! Preloaded `Quaternion` derived data type\n  implicit none\n  private\n  public :: exp, sinh, cosh, sin, cos\n  interface exp\n    module procedure qexp\n  end interface\n  interface sinh\n    module procedure qsinh\n  end interface\n  interface cosh\n    module procedure qcosh\n  end interface\n  interface sin\n    module procedure qsin\n  end interface\n  interface cos\n    module procedure qcos\n  end interface\n  interface operator(-)\n    module procedure qneg, qsub\n  end interface\n  interface operator(+)\n    module procedure qadd\n  end interface\n  interface operator(*)\n    module procedure qmul,qmulc\n  end interface\ncontains\n  type(Quaternion) pure function qadd(a,b)\n    type(Quaternion), intent(in) :: a, b\n    qadd%a = a%a+b%a\n    qadd%b = a%b+b%b\n    qadd%c = a%c+b%c\n    qadd%d = a%d+b%d\n  end function\n  type(Quaternion) pure function qsub(a,b)\n    type(Quaternion), intent(in) :: a, b\n    qsub%a = a%a-b%a\n    qsub%b = a%b-b%b\n    qsub%c = a%c-b%c\n    qsub%d = a%d-b%d\n  end function\n  type(Quaternion) pure function qmul(a,b)\n    type(Quaternion), intent(in) :: a, b\n    qmul%a = a%a*b%a-a%b*b%b-a%c*b%c-a%d*b%d\n    qmul%b = a%a*b%b+a%b*b%a+a%c*b%d-a%d*b%c\n    qmul%c = a%a*b%c-a%b*b%d+a%c*b%a+a%d*b%b\n    qmul%d = a%a*b%d+a%b*b%c-a%c*b%b+a%d*b%a\n  end function\n  type(Quaternion) pure function qmulc(q,n)\n    type(Quaternion), intent(in) :: q\n    real(8), intent(in) :: n\n    qmulc%a = q%a*n\n    qmulc%b = q%b*n\n    qmulc%c = q%c*n\n    qmulc%d = q%d*n\n  end function\n  type(Quaternion) pure function qneg(q)\n    type(Quaternion), intent(in) :: q\n    qneg%a = -q%a\n    qneg%b = -q%b\n    qneg%c = -q%c\n    qneg%d = -q%d\n  end function\n  type(Quaternion) pure function qexp(q)\n    type(Quaternion), intent(in) :: q\n    real(8) :: n\n    n = sqrt(q%b*q%b+q%c*q%c+q%d*q%d)\n    qexp%a = exp(q%a)*cos(n)\n    qexp%b = exp(q%a)*sin(n)*q%b\/n\n    qexp%c = exp(q%a)*sin(n)*q%c\/n\n    qexp%d = exp(q%a)*sin(n)*q%d\/n\n  end function\n  type(Quaternion) pure function qsinh(q)\n    type(Quaternion), intent(in) :: q\n    type(Quaternion) :: a,b\n    a = exp(q)\n    b = exp(-q)\n    qsinh%a = (a%a-b%a)\/2.0_8\n    qsinh%b = (a%b-b%b)\/2.0_8\n    qsinh%c = (a%c-b%c)\/2.0_8\n    qsinh%d = (a%d-b%d)\/2.0_8\n  end function\n  type(Quaternion) pure function qcosh(q)\n    type(Quaternion), intent(in) :: q\n    type(Quaternion) :: a,b\n    a = exp(q)\n    b = exp(-q)\n    qcosh%a = (a%a+b%a)\/2.0_8\n    qcosh%b = (a%b+b%b)\/2.0_8\n    qcosh%c = (a%c+b%c)\/2.0_8\n    qcosh%d = (a%d+b%d)\/2.0_8\n  end function\n  type(Quaternion) pure function qsin(q)\n    type(Quaternion), intent(in) :: q\n    type(Quaternion) :: v\n    integer :: i\n    v = q\n    qsin = Quaternion(0.0_8, 0.0_8, 0.0_8, 0.0_8)\n    do i=2,102,2\n      qsin=qsin+v\n      v=-(v*q*q)*(1\/real(i*(i+1),8))\n    end do\n  end function\n  type(Quaternion) pure function qcos(q)\n    type(Quaternion), intent(in) :: q\n    type(Quaternion) :: v\n    integer :: i\n    v = Quaternion(1.0_8, 0.0_8, 0.0_8, 0.0_8)\n    qcos = Quaternion(0.0_8, 0.0_8, 0.0_8, 0.0_8)\n    do i=1,101,2\n      qcos=qcos+v\n      v=-(v*q*q)*(1\/real(i*(i+1),8))\n    end do\n  end function\nend module QuaternionUtilities","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83679,"user_id":503,"body":"module QuaternionUtilities\n\tuse Quaternions\n\tinterface Exp\n\t\tmodule procedure ExpQ\n\tend interface\n\tinterface SinH\n\t\tmodule procedure SinHQ\n\tend interface\n\tinterface CosH\n\t\tmodule procedure CosHQ\n\tend interface\n\tinterface Sin\n\t\tmodule procedure SinQ\n\tend interface\n\tinterface Cos\n\t\tmodule procedure CosQ\n\tend interface\ncontains\n\ttype(Quaternion) function ExpQ(Q)\n\t\ttype(Quaternion) :: Q,S\n\t\tS = Rest(Q)\n\t\tExpQ = MultiplyRQ(Exp(Q%A),PlusRQ(Cos(AbsQ(S)),MultiplyRQ(Sin(AbsQ(S)) \/ AbsQ(S),S)))\n\tend\n\ttype(Quaternion) function SinHQ(Q)\n\t\ttype(Quaternion) :: Q,S\n\t\tS = Rest(Q)\n\t\tSinHQ = PlusRQ(SinH(Q%A) * Cos(AbsQ(S)),MultiplyRQ(CosH(Q%A) * Sin(AbsQ(S)) \/ AbsQ(S),S))\n\tend\n\ttype(Quaternion) function CosHQ(Q)\n\t\ttype(Quaternion) :: Q,S\n\t\tS = Rest(Q)\n\t\tCosHQ = PlusRQ(CosH(Q%A) * Cos(AbsQ(S)),MultiplyRQ(SinH(Q%A) * Sin(AbsQ(S)) \/ AbsQ(S),S))\n\tend\n\ttype(Quaternion) function SinQ(Q)\n\t\ttype(Quaternion) :: Q,S\n\t\tS = Rest(Q)\n\t\tSinQ = PlusRQ(Sin(Q%A) * CosH(AbsQ(S)),MultiplyRQ(Cos(Q%A) * SinH(AbsQ(S)) \/ AbsQ(S),S))\n\tend\n\ttype(Quaternion) function CosQ(Q)\n\t\ttype(Quaternion) :: Q,S\n\t\tS = Rest(Q)\n\t\tCosQ = PlusRQ(Cos(Q%A) * CosH(AbsQ(S)),MultiplyRQ(-Sin(Q%A) * SinH(AbsQ(S)) \/ AbsQ(S),S))\n\tend\n\n\ttype(Quaternion) function PlusRQ(S,Q)\n\t\ttype(Quaternion),intent(in) :: Q\n\t\treal(8) :: S\n\t\tPlusRQ = Quaternion(S + Q%A,Q%B,Q%C,Q%D)\n\tend\n\ttype(Quaternion) function MultiplyRQ(S,Q)\n\t\ttype(Quaternion),intent(in) :: Q\n\t\treal(8) :: S\n\t\tMultiplyRQ = Quaternion(S * Q%A,S * Q%B,S * Q%C,S * Q%D)\n\tend\n\treal(8) function AbsQ(Q)\n\t\ttype(Quaternion),intent(in) :: Q\n\t\tAbsQ = (Q%A ** 2 + Q%B ** 2 + Q%C ** 2 + Q%D ** 2) ** .5\n\tend\n\ttype(Quaternion) function Rest(Q)\n\t\ttype(Quaternion),intent(in) :: Q\n\t\tRest = Quaternion(0,Q%B,Q%C,Q%D)\n\tend\nend","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83680,"user_id":17,"body":"module QuaternionUtilities\n  use Quaternions ! Preloaded `Quaternion` derived data type\n  implicit none\n  private\n  public :: exp, sinh, cosh, sin, cos\n  interface exp\n    module procedure qexp\n  end interface exp\n  interface sinh\n    module procedure qsinh\n  end interface sinh\n  interface cosh\n    module procedure qcosh\n  end interface cosh\n  interface sin\n    module procedure qsin\n  end interface sin\n  interface cos\n    module procedure qcos\n  end interface cos\n  interface realpart\n    module procedure getA\n  end interface realpart\n  interface imagpart\n    module procedure getBCD, getBCOrD\n  end interface imagpart\n  interface operator(+)\n    module procedure qId, addPQ, addZQ, addQZ, addXQ, addQX\n  end interface\n  interface operator(-)\n    module procedure addInv, subPQ, subZQ, subQZ, subXQ, subQX\n  end interface\n  interface operator(*)\n    module procedure timesPQ, timesZQ, timesQZ, timesXQ, timesQX\n  end interface\n  interface operator(.conj.)\n    module procedure conjugate\n  end interface\n  interface abs\n    module procedure qNorm\n  end interface abs\ncontains\n  type(Quaternion) pure function qexp(q)\n    type(Quaternion), intent(in) :: q\n    qexp = exp(q%a) * (cos(abs(imagpart(q))) + imagpart(q) * &\n    (1.0_8 \/ abs(imagpart(q))) * sin(abs(imagpart(q))))\n  end function qexp\n  type(Quaternion) pure function qsinh(q)\n    type(Quaternion), intent(in) :: q\n    qsinh = 0.5_8 * (exp(q) - exp(-q))\n  end function qsinh\n  type(Quaternion) pure function qcosh(q)\n    type(Quaternion), intent(in) :: q\n    qcosh = 0.5_8 * (exp(q) + exp(-q))\n  end function qcosh\n  type(Quaternion) pure function qsin(q)\n    type(Quaternion), intent(in) :: q\n    qsin = -(imagpart(q) * (1.0_8 \/ abs(imagpart(q)))) * &\n    sinh((imagpart(q) * (1.0_8 \/ abs(imagpart(q)))) * q)\n  end function qsin\n  type(Quaternion) pure function qcos(q)\n    type(Quaternion), intent(in) :: q\n    qcos = cosh((imagpart(q) * (1.0_8 \/ abs(imagpart(q)))) * q)\n  end function qcos\n  type(Quaternion) pure function cdinit(z, w) result(q)\n    complex(8), intent(in) :: z, w\n    q = Quaternion(realpart(z), imagpart(z), realpart(w), imagpart(w))\n  end function cdinit\n  real(8) pure function getA(q) result(a)\n    type(Quaternion), intent(in) :: q\n    a = q%a\n  end function getA\n  type(Quaternion) pure function getBCD(p) result(q)\n    type(Quaternion), intent(in) :: p\n    q = Quaternion(0._8, p%b, p%c, p%d)\n  end function getBCD\n  real(8) pure function getBCOrD(q, n) result(x)\n    type(Quaternion), intent(in) :: q\n    integer, intent(in) :: n\n    if (n == 1) then\n      x = q%b\n    else if (n == 2) then\n      x = q%c\n    else\n      x = q%d\n    end if\n  end function getBCOrD\n  type(Quaternion) pure function qId(q)\n    type(Quaternion), intent(in) :: q\n    qId = q\n  end function qId\n  type(Quaternion) pure function addPQ(p, q) result(r)\n    type(Quaternion), intent(in) :: p, q\n    r = Quaternion(p%a + q%a, p%b + q%b, p%c + q%c, p%d + q%d)\n  end function addPQ\n  type(Quaternion) pure function addZQ(z, q) result(r)\n    complex(8), intent(in) :: z\n    type(Quaternion), intent(in) :: q\n    r = cdinit(z, cmplx(0._8, 0._8, 8)) + q\n  end function addZQ\n  type(Quaternion) pure function addQZ(q, z) result(r)\n    complex(8), intent(in) :: z\n    type(Quaternion), intent(in) :: q\n    r = z + q ! since quaternion addition is commmutative\n  end function addQZ\n  type(Quaternion) pure function addXQ(x, q) result(r)\n    real(8), intent(in) :: x\n    type(Quaternion), intent(in) :: q\n    r = cmplx(x, 0._8, 8) + q\n  end function addXQ\n  type(Quaternion) pure function addQX(q, x) result(r)\n    real(8), intent(in) :: x\n    type(Quaternion), intent(in) :: q\n    r = x + q ! since quaternion addition is commutative\n  end function addQX\n  type(Quaternion) pure function addInv(q)\n    type(Quaternion), intent(in) :: q\n    addInv = Quaternion(-q%a, -q%b, -q%c, -q%d)\n  end function addInv\n  type(Quaternion) pure function subPQ(p, q) result(r)\n    type(Quaternion), intent(in) :: p, q\n    r = p + (-q)\n  end function subPQ\n  type(Quaternion) pure function subZQ(z, q) result(r)\n    complex(8), intent(in) :: z\n    type(Quaternion), intent(in) :: q\n    r = cdinit(z, cmplx(0._8, 0._8, 8)) - q\n  end function subZQ\n  type(Quaternion) pure function subQZ(q, z) result(r)\n    complex(8), intent(in) :: z\n    type(Quaternion), intent(in) :: q\n    r = -(z - q)\n  end function subQZ\n  type(Quaternion) pure function subXQ(x, q) result(r)\n    real(8), intent(in) :: x\n    type(Quaternion), intent(in) :: q\n    r = cmplx(x, 0._8, 8) - q\n  end function subXQ\n  type(Quaternion) pure function subQX(q, x) result(r)\n    real(8), intent(in) :: x\n    type(Quaternion), intent(in) :: q\n    r = -(x - q)\n  end function subQX\n  type(Quaternion) pure function timesPQ(p, q) result(r)\n    type(Quaternion), intent(in) :: p, q\n    r = Quaternion(&\n      p%a * q%a - p%b * q%b - p%c * q%c - p%d * q%d, &\n      p%a * q%b + p%b * q%a + p%c * q%d - p%d * q%c, &\n      p%a * q%c - p%b * q%d + p%c * q%a + p%d * q%b, &\n      p%a * q%d + p%b * q%c - p%c * q%b + p%d * q%a&\n    )\n  end function timesPQ\n  type(Quaternion) pure function timesZQ(z, q) result(r)\n    complex(8), intent(in) :: z\n    type(Quaternion), intent(in) :: q\n    r = cdinit(z, cmplx(0._8, 0._8, 8)) * q\n  end function timesZQ\n  type(Quaternion) pure function timesQZ(q, z) result(r)\n    complex(8), intent(in) :: z\n    type(Quaternion), intent(in) :: q\n    r = q * cdinit(z, cmplx(0._8, 0._8, 8))\n  end function timesQZ\n  type(Quaternion) pure function timesXQ(x, q) result(r)\n    real(8), intent(in) :: x\n    type(Quaternion), intent(in) :: q\n    r = cmplx(x, 0._8, 8) * q\n  end function timesXQ\n  type(Quaternion) pure function timesQX(q, x) result(r)\n    real(8), intent(in) :: x\n    type(Quaternion), intent(in) :: q\n    r = x * q ! since scalar multiplication of quaternions is commutative\n  end function timesQX\n  type(Quaternion) pure function conjugate(q)\n    type(Quaternion), intent(in) :: q\n    conjugate = Quaternion(q%a, -q%b, -q%c, -q%d)\n  end function conjugate\n  real(8) pure function qNorm(q)\n    type(Quaternion), intent(in) :: q\n    qNorm = sqrt(q%a ** 2 + q%b ** 2 + q%c ** 2 + q%d ** 2)\n  end function qNorm\nend module QuaternionUtilities","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5b06c990908b7eea73000069":[{"id":83681,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  INTEGER FUNCTION f(z, eps) RESULT(n)\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=16)\n    REAL(kind=ikind) :: eps, v\n    COMPLEX(10) :: z\n\n    IF (ABS(z) >= 1.0) THEN\n      n = -1\n      RETURN\n    END IF\n    v = REAL(LOG(ABS(z)), ikind)\n    n = INT(LOG(eps) \/ v)\n    END FUNCTION f\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83682,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  INTEGER FUNCTION f(z, eps) RESULT(n)\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=16)\n    REAL(kind=ikind) :: eps\n    COMPLEX(10) :: z, tmp\n    ! (1-z) * (z + z**2 + ... + z**n)\n    ! Distribute... 1*(z + z**2 + .. + z**n) - z*(z + z**2 + .. + z**n)\n    ! Simplify... (z + z**2 + .. + z**n) - (z**2 + z**3 + .. + z**(n+1))\n    ! Cancel equal powers of z... z - z**(n+1)\n    ! If magnitude(z) > 1, this blows up, so return -1\n    ! If mag(z) == 1, result is zero\n    ! If mag(z) < 1, limit is z\n    ! Test compares this value to z itself, so that's (z - z**(n+1)) - z < eps\n    ! z's cancel, leaving -z**(n+1) < eps\n    ! Only interested in magnitude, so check mag(z**(n+1)) < eps\n    n = 1\n    if (abs(z) >= 1) then\n      n = -1\n      return\n    else\n      tmp = z**2\n      do while (abs(tmp) > eps)\n        n = n + 1\n        tmp = tmp * z\n      end do\n    end if\n    END FUNCTION f\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83683,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  INTEGER FUNCTION f(z, eps) RESULT(n)\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=16)\n    REAL(kind=ikind) :: eps, h\n    COMPLEX(10) :: z\n\n    h = log(eps) \/ log(hypot(real(z), imag(z)))\n    n = floor(h)\n    if (h < 0) then\n      n = -1\n    end if\n    \n    END FUNCTION f\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83684,"user_id":168,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  INTEGER FUNCTION f(z, eps) RESULT(n)\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=16)\n    REAL(kind=ikind) :: eps\n    COMPLEX(10) :: z\n    Real(kind=ikind) :: x\n      x = sqrt(real(z) ** 2 + imag(z) ** 2)\n      if (x >= 1) then\n        n = -1\n      else\n        n = floor(log(eps) \/ log(x))\n      end if\n    END FUNCTION f\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83685,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  INTEGER FUNCTION f(arg,eps) RESULT(n)\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=16)\n    real(ikind)     :: eps\n    complex(ikind)  :: arg\n    complex(ikind)  :: mul, val, mon\n    \n    if(real(arg)**2 + aimag(arg)**2 > 1.0_ikind) then\n      n = -1\n      return\n    end if\n    \n    mul = (1._ikind-arg)\n    val = mul*arg\n    mon = arg\n    n = 1\n    do\n      if(abs(val-arg) <= eps) return\n      n = n + 1\n      mon = mon*arg\n      val = val + mul*mon\n    end do\n    \n    \n    END FUNCTION f\n\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83686,"user_id":17,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  INTEGER PURE FUNCTION f(z, eps) RESULT(n)\n    REAL(10), INTENT(IN) :: eps\n    COMPLEX(10), INTENT(IN) :: z\n    COMPLEX(10) :: w\n    n = -1\n    IF (ABS(z) <= 1.0_10) THEN\n      n = 0\n      w = CMPLX(0.0_10, 0.0_10, 10)\n      DO WHILE (.TRUE.)\n        n = n + 1\n        w = w + z ** n\n        IF (ABS((1.0_10 - z) * w - z) < eps) THEN\n          EXIT\n        END IF\n      END DO\n    END IF\n  END FUNCTION f\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83687,"user_id":503,"body":"module Solution\ncontains\n\tinteger function F(Q,S)\n\t\treal(10) :: S\n\t\tcomplex(10) :: Q,P,N\n\t\tF = -1\n\t\tif (abs(Q) <= 1) then\n\t\t\tF = 1\n\t\t\tP = Q\n\t\t\tN = Q\n\t\t\tdo while (S <= abs((1 - Q) * P - Q))\n\t\t\t\tN = N * Q\n\t\t\t\tP = P + N\n\t\t\t\tF = 1 + F\n\t\t\tend do\n\t\tend if\n\tend\nend","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5b07eab9abe9560de40000d3":[{"id":83688,"user_id":106,"body":"module Solution\n  use Preloaded\n  implicit none\ncontains\n  function DFT(x_t) result(X_f)\n    complex(8), dimension(:), intent(in) :: x_t ! Samples of our signal\n    ! at regular time intervals\n    complex(8), dimension(:), allocatable :: X_f ! A representation of\n    ! our signal in the frequency domain\n    INTEGER :: N, k, t\n    REAL(8) :: p\n    N = SIZE(x_t)\n    ALLOCATE(X_f(N))\n    X_f = 0\n    DO k=0,N-1\n      DO t=0,N-1\n        p = real(2,8) * PI * real(k,8) * real(t,8) \/ real(N,8)\n        X_f(k+1) = X_f(k+1) + x_t(t+1) * cmplx(COS(p), -SIN(p), 8)\n      END DO\n    END DO\n  end function DFT\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83689,"user_id":106,"body":"module Solution\n  use Preloaded\n  implicit none\ncontains\n  function DFT(x_t) result(X_f)\n    complex(8), dimension(:), intent(in) :: x_t ! Samples of our signal\n    ! at regular time intervals\n    complex(8), dimension(:), allocatable :: X_f ! A representation of\n    ! our signal in the frequency domain\n    INTEGER :: N, k, t\n    REAL(8) :: p\n    N = SIZE(x_t)\n    ALLOCATE(X_f(N))\n    DO k=0,N-1\n      X_f(k+1) = 0\n      DO t=0,N-1\n        p = real(2,8) * PI * real(k,8) * real(t,8) \/ real(N,8)\n        X_f(k+1) = X_f(k+1) + x_t(t+1) * cmplx(COS(p), -SIN(p), 8)\n      END DO\n    END DO\n  end function DFT\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83690,"user_id":null,"body":"MODULE Solution\n    USE Preloaded\n    IMPLICIT NONE\nCONTAINS\n    PURE FUNCTION DFT(x_t) RESULT (x_f)\n        COMPLEX(8), INTENT(IN) :: x_t(:)\n        COMPLEX(8) :: x_f(SIZE(x_t)), t, z\n        INTEGER :: i, j, s\n        REAL(8) :: k, N\n        z = CMPLX(0, -2.0_8, 8)\n        s = SIZE(x_t)\n        N = REAL(s, 8)\n        DO i = 1, s\n            t = 0.0_8\n            k = REAL(i - 1, 8)\n            DO j = 1, s\n                t = t + x_t(j) * EXP(z * PI * k * REAL(j - 1, 8) \/ N)\n            END DO\n            x_f(i) = t\n        END DO\n    END FUNCTION DFT\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83691,"user_id":null,"body":"module Solution\n  use Preloaded\n  implicit none\ncontains\n  pure function DFT(x_t) result(X_f)\n    complex(8), dimension(:), intent(in) :: x_t ! Samples of our signal\n    ! at regular time intervals\n    complex(8), dimension(:), allocatable :: X_f ! A representation of\n    ! our signal in the frequency domain\n    integer :: i, j, n\n    double precision :: sum_real\n    double precision :: sum_imag\n     n = size(x_t)\n    allocate(X_f(n))\n   \n    sum_real= 0\n    sum_imag = 0\n   \n  \n    do i = 0, n -1\n      do j = 0, n-1   \n         \n         sum_real = sum_real + real(x_t(j+1)) * cos((2d0 * Pi * i * j) \/ n) + aimag(x_t(j+1)) * sin((2d0 * Pi * i * j) \/ n)\n         sum_imag = sum_imag + aimag(x_t(j+1)) * cos((2d0 * Pi * i * j) \/ n) - real(x_t(j+1)) * sin((2d0 * Pi * i * j) \/ n)\n      end do\n      \n      X_f(i+1) = cmplx(sum_real, sum_imag, 8)\n      \n      sum_real = 0\n      sum_imag = 0\n    end do\n  end function DFT\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83692,"user_id":null,"body":"module Solution\n  use Preloaded\n  implicit none\ncontains\n  pure function DFT(x_t) result(X_f)\n    complex(8), dimension(:), intent(in) :: x_t ! Samples of our signal\n    complex(8), dimension(:), allocatable :: X_f ! A representation of\n    complex(8), parameter :: I = cmplx(0.0_8, 1.0_8)\n    integer :: N\n    integer :: k, l\n    \n    N = size(x_t)\n    allocate(X_f(N))\n    \n    do k = 1, N\n      X_f(k) = cmplx(0.0, 0.0)\n    end do\n    \n    do k = 1, N\n      do l = 1, N\n       X_f(k) = X_f(k) + x_t(l) * exp( - (2.0 * PI * i) \/ N * ((k-1) * (l-1)))\n      end do\n    end do\n  end function DFT\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83693,"user_id":null,"body":"module Solution\n  use Preloaded\n  implicit none\ncontains\n  pure function DFT(x_t) result(X_f)\n    complex(8), dimension(:), intent(in) :: x_t\n    complex(8), dimension(:), allocatable :: X_f\n    complex(8) :: xk, w\n    integer :: i, k, n\n    n = size(x_t)\n    allocate(X_f(n))\n    do k = 1, n\n      xk = 0\n      w = 2*PI*(k-1)\/n*cmplx(0, -1)\n      do i = 1, n\n        xk = xk + x_t(i)*exp(w*(i-1)) \n      end do\n      X_f(k) = xk\n    end do\n  end function DFT\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83694,"user_id":null,"body":"module Solution\n  use Preloaded\n  implicit none\ncontains\n  pure function DFT(x_t) result(X_f)\n    complex(8), dimension(:), intent(in) :: x_t\n    complex(8), dimension(:), allocatable :: X_f\n    integer :: i, k, n\n    complex(8) :: xk\n    real(8) :: t\n    n = size(x_t)\n    allocate(X_f(n))\n    do k = 1, n\n      xk = 0\n      t = 2*PI*(k-1)\/n\n      do i = 1, n\n        xk = xk + x_t(i)*exp(t*(i-1)*cmplx(0, -1)) \n      end do\n      X_f(k) = xk\n    end do\n  end function DFT\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83695,"user_id":null,"body":"module Solution\n  use Preloaded\n  implicit none\ncontains\n  function DFT(x_t) result(X_f)\n    complex(8), dimension(:), intent(in) :: x_t ! Samples of our signal\n    ! at regular time intervals\n    complex(8), dimension(:), allocatable :: X_f ! A representation of\n    ! our signal in the frequency domain\n    integer :: N, nn, k\n    N = size(x_t)\n    allocate(X_f(0:N-1))\n    X_f(:) = 0.\n    ! Be careful with x_t, it starts from index 1 to N, not 0 to N-1\n    do k = 0, N-1\n      do nn = 0, N-1\n        X_f(k) = X_f(k) + x_t(nn+1) * cmplx(cos(2*PI*k*nn\/N), -sin(2*PI*k*nn\/N), kind=8)\n      end do\n    end do\n  end function DFT\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83696,"user_id":17,"body":"module Solution\n    use Preloaded\ncontains\n    function DFT(Q) result(R)\n        complex(8) Q(:)\n        complex(8),allocatable :: R(:)\n        real(8) T\n        integer F,G\n        allocate(R(size(Q)))\n        R = 0\n        do F = 1,size(Q)\n            do G = 1,size(Q)\n                T = 2 * PI * (F - 1) * (G - 1) \/ size(Q)\n                R(F) = R(F) + Q(G) * cmplx(cos(T),-sin(T), 8)\n            end do\n        end do\n    end\nend","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83697,"user_id":17,"body":"module Solution\n  use Preloaded\n  implicit none\ncontains\n  pure function DFT(x_t) result(X_f)\n    complex(8), dimension(:), intent(in) :: x_t\n    complex(8), dimension(:), allocatable :: X_f\n    integer :: i, j\n    allocate(X_f(size(x_t)))\n    do i = size(x_t), 1, -1\n      X_f(i) = cmplx(0.0_8, 0.0_8, 8)\n      do j = size(x_t), 1, -1\n        X_f(i) = X_f(i) + x_t(j) * (cos(2.0_8 \/ real(size(x_t), 8) * real(j - 1, 8) * PI * real(i - 1, 8)) - &\n        cmplx(0.0_8, 1.0_8, 8) * sin(2.0_8 \/ real(size(x_t), 8) * real(j - 1, 8) * PI * real(i - 1, 8)))\n      end do\n    end do\n  end function DFT\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5b0c0ec907756ffcff00006e":[{"id":83698,"user_id":527,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n    FUNCTION quadratic(a, b, c)\n        INTEGER, PARAMETER :: ikind=selected_real_kind(p=16)\n        REAL (kind=ikind) :: a, b, c, quadratic\n        quadratic = -c \/ b\n    END FUNCTION\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83699,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n    FUNCTION quadratic(a, b, c)\n        INTEGER, PARAMETER :: ikind=selected_real_kind(p=16)\n        REAL (kind=ikind) :: a, b, c, y, x1, x2, quadratic\n        y = b * (1.0_ikind - 2.0_ikind * a * c \/ b \/ b)\n        x1 = -(y + b) \/ (2 * a)\n        x2 = c \/ (x1 * a)\n        quadratic = x2\n    END FUNCTION\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83700,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n    FUNCTION quadratic(a, b, c)\n        INTEGER, PARAMETER :: ikind=selected_real_kind(p=16)\n        REAL (kind=ikind) :: a, b, c, y, x1, x2, quadratic\n        y = b * (1.0_ikind - 2.0_ikind * a * c \/ b \/ b)\n        x1 = -(y + b) \/ (2 * a)\n        x2 = c \/ (x1 * a)\n        quadratic = x2\n    END FUNCTION\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83701,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n    FUNCTION quadratic(a, b, c) RESULT(root)\n        INTEGER, PARAMETER :: ikind=selected_real_kind(p=16)\n        REAL (kind=ikind) :: a, b, c, root\n        root=(2*c)\/(-b-sqrt(b*b-4*a*c))\n    END FUNCTION\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83702,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n    FUNCTION quadratic(a, b, c)\n        INTEGER, PARAMETER :: ikind=selected_real_kind(p=16)\n        REAL (kind=ikind) :: a, b, c, quadratic\n!        REAL (kind=ikind) :: x1, x2, sqrt_bb_4ac\n        REAL (kind=ikind) :: x=0, y=0\n        INTEGER*2 :: i=0\n        y = a*x**2+b*x+c\n        ! y' = 2ax + b\n        \n        do i = 1,100\n          x = x - y \/ (2*a*x+b)\n          y = a*x**2+b*x+c\n          if(abs(y)<1e-12) then\n            exit\n          end if\n        end do\n        quadratic = x\n!        sqrt_bb_4ac = sqrt(b**2-4*a*c)\n!        x1 = (-b + sqrt_bb_4ac) \/ (2*a)\n!        x2 = (-b - sqrt_bb_4ac) \/ (2*a)\n!        if (abs(x1) > abs(x2)) then\n!          quadratic = x2\n!        else\n!          quadratic = x1\n!        end if\n        \n        \n    END FUNCTION\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83703,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n    FUNCTION quadratic(a, b, c)\n        INTEGER, PARAMETER :: ikind=selected_real_kind(p=16)\n        REAL (kind=ikind) :: a, b, c, quadratic\n        \n        quadratic = (-b-sqrt(b**2-4.0_ikind*a*c))\/(2.0_ikind*a)\n        quadratic = (c\/a)\/quadratic\n        \n    END FUNCTION\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83704,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n    FUNCTION quadratic(a, b, c)\n        INTEGER, PARAMETER :: ikind=selected_real_kind(p=16)\n        REAL (kind=ikind) :: a, b, c, quadratic\n        REAL (kind=16) :: delta,a8,b8,c8,x1,x2,res,tol\n        INTEGER i\n        \n        a8 = a\n        b8 = b\n        c8 = c\n        delta = sqrt(b8*b8 - 4.0D0 * a8 * c8)\n        x1 = (-b8 + delta) \/ (2.0D0 * a8)\n        x2 = (-b8 - delta) \/ (2.0D0 * a8)\n        \n        IF(abs(x1) < abs(x2)) THEN\n            !  x1 = x1\n        ELSE\n            x1 = x2\n        ENDIF\n        tol = 1D-12\n        res = FEVAL(a8,b8,c8,x1)\n        write(6,*) \"res=\",res\n        IF ( abs(res) > tol) THEN\n          DO i = 1,10\n            write(6,*) x1,FEVAL(a8,b8,c8,x1),FEVALP(a8,b8,c8,x1)\n            x1 = x1 - FEVAL(a8,b8,c8,x1) \/ FEVALP(a8,b8,c8,x1)\n           \n          END DO\n        ENDIF\n        quadratic = x1\n        ! your code\n    END FUNCTION\n    FUNCTION FEVAL(a,b,c,x)\n        REAL(kind=16) :: a,b,c,x,FEVAL\n        FEVAL = a * x * x + b * x + c\n    END\n    FUNCTION FEVALP(a,b,c,x)\n        REAL(kind=16) :: a,b,c,x,FEVALP\n        FEVALP = 2.0D0 * a * x + b\n    END\n    \n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83705,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n    FUNCTION quadratic(a, b, c)\n        INTEGER, PARAMETER :: ikind=selected_real_kind(p=16)\n        REAL (kind=ikind) :: a, b, c, quadratic, xs\n        \n        ! your code\n        xs = 1e-9\n        \n        do while(a*xs**2+b*xs+c > 1e-12)\n          \n          xs = xs - (a*xs**2+b*xs+c) \/ (2*a*xs+b)\n          \n        end do\n        \n        quadratic = xs\n        \n        \n    END FUNCTION\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83706,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n    FUNCTION quadratic(a, b, c)\n        INTEGER, PARAMETER :: ikind=selected_real_kind(p=16)\n        REAL (kind=ikind) :: a, b, c, quadratic\n        real (kind=ikind) :: delta, x1, x2\n        \n        delta = b**2 - 4 * a * c\n        if (b > 0) then\n          x1 = (-b - sqrt(delta)) \/ (2 * a)\n        else\n          x1 = (-b + sqrt(delta)) \/ (2 * a)\n        end if\n        \n        x2 = c \/ a \/ x1\n        quadratic = x2\n    END FUNCTION\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83707,"user_id":17,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  REAL(10) PURE FUNCTION quadratic(a, b, c) RESULT(x)\n    REAL(10), INTENT(IN) :: a, b, c\n    x = 1.0_10\n    DO WHILE (ABS(a * x ** 2 + b * x + c) >= 1e-12)\n      x = -(a * x ** 2 + c) \/ b\n    END DO\n  END FUNCTION quadratic\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5b1cd19fcd206af728000056":[{"id":83708,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  FUNCTION solve(m) RESULT(s)\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=16)\n    REAL(kind=ikind) :: m, s\n    s = (2*m + 1 - sqrt(4*m + 1)) \/ (2*m)\n  END FUNCTION\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83709,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  FUNCTION solve(m) RESULT(s)\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=16)\n    REAL(kind=ikind) :: m, s\n\n    s = sqrt(4 * m + 1)\n    s = (2 * m + 1 - s) \/ (2 * m)\n\n  END FUNCTION\nEND MODULE Solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83710,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  FUNCTION solve(m) RESULT(s)\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=16)\n    REAL(kind=ikind) :: m, s,eps,x,x1,fx,fd\n    !\n    ! with given f(x) = -m + x + 2x**2 + 3x**3 + .. + nx**n\n    ! which may rewritten f(x)= -m + x(1+2x+3x**2 + ..)\n    ! and thus have the solution f(x)= -m + x\/(1-x)**2\n    !\n    ! Find f(x)=0 (0<x<1) within tolerance of 1e-12\n    ! \n    ! derivate: f'(x)= 1 + 4x + 9x**2 + 16*x**3 + ...\n    ! which have the solution f'(x)=(1+x)\/(1-x)**3\n    !\n    ! Newton's method: x1=x0-f(x0)\/f'(x0)\n    ! in which a start value of x0=0.5 will be taken.\n    ! \n    eps=1e-12\n    x=0.99999\n    do\n     fx=-m + x\/(1-x)**2\n     fd=(1+x)\/(1-x)**3\n     x1=x-fx\/fd\n     if (abs(x1-x)>eps) then\n       x=x1\n     else\n       exit\n     endif  \n     print*,' x ',x\n    enddo\n    s=x1  ! return value\n\n  END FUNCTION\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83711,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  FUNCTION solve(m) RESULT(s)\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=16)\n    REAL(kind=ikind) :: m, s\n    s = 1 + (0.5 - sqrt(m + 0.25)) \/ m\n  END FUNCTION\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83712,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  FUNCTION solve(m) RESULT(s)\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=16)\n    REAL(kind=ikind) :: m, s\n    s = 1 + 1\/(2*m) - SQRT(4*m + 1)\/(2*m)\n  END FUNCTION\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83713,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\n  \nCONTAINS\n  \n  pure function f(x, targ) result(out)\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=16)\n    real(kind=ikind), intent(in) :: x, targ\n    real(kind=ikind)       :: out\n    !out = u(x) - targ\n    out = targ - (x \/ ((x - 1) * (x - 1)))\n  end function\n  \n  FUNCTION solve(m) RESULT(s)  \n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=16)\n    REAL(kind=ikind) :: m, s\n    ! your code\n    real(kind=ikind) :: a, b, c\n    integer          :: iters\n    \n    iters = 0\n    a = 0.0\n    b = 1.0\n\n    do while (iters < 200)\n      c = (a + b) \/ 2.0\n      \n      if ((abs(f(c, m)) < 1e-12) .or. ((b - a) \/ 2 < 1e-12)) then \n        s = c\n        return\n      end if\n      \n      iters = iters + 1\n      if (f(c, m) * f(a, m) > 0.0) then\n        a = c\n      else\n        b = c\n      end if\n    end do\n    s = c\n  END FUNCTION\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83714,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  FUNCTION solve(m) RESULT(s)\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=16)\n    REAL(kind=ikind) :: m, s\n    s=1.0_ikind+0.5_ikind*(1.0_ikind-sqrt(4.0_ikind*m+1.0_ikind))\/m\n  END FUNCTION\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83715,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  FUNCTION solve(m) RESULT(s)\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=16)\n    REAL(kind=ikind) :: m, s\n    \n    s = (2*m+1 - SQRT(4*m+1)) \/ (2*m)\n\n  END FUNCTION\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83716,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  FUNCTION solve(m) RESULT(s)\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=16)\n    REAL(kind=ikind) :: m, s\n\n    s = 1.0D0 + 0.5D0*(1.0D0 - sqrt(1.0D0 + 4.0D0*m))\/m\n\n  END FUNCTION\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83717,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n  \n  FUNCTION solve(m) RESULT(s)\n    INTEGER, PARAMETER :: ikind=selected_real_kind(p=16)\n    REAL(kind=ikind) :: m, s, A, B, C\n    A = m\n    B = (-1.0d0-2.0d0*m)\n    C = m\n    s = (-B - sqrt(B*B-4*A*C))\/(2*A)\n  END FUNCTION\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5b40b666dfb4291ad9000049":[{"id":83718,"user_id":53,"body":"module Solution\n  implicit none\n  public :: solve\ncontains\n  function solve(ai, bi, ci, alpha, beta, gamma)\n    integer, intent(in) :: ai, bi, ci, alpha, beta, gamma\n    real(16) :: pi = 3.14159265358979323846_16\n    real(16) :: a, b, g, x, y, t\n    integer, dimension(4) :: solve\n    a = alpha * pi \/ 180.0\n    b = beta * pi \/ 180.0\n    g = gamma * pi \/ 180.0\n    x = ai * cos(a) - bi * sin(b) - ci * cos(g)\n    y = ai * sin(a) + bi * cos(b) - ci * sin(g)\n    t = atan2(y, x) * 180.0 \/ pi\n    solve = (\/nint(hypot(y, x)), int(t), mod(int(t * 60), 60), mod(int(t * 3600), 60)\/)\n  end function\nend module Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83719,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  FUNCTION solve(a, b, c, alpha, beta, gamm)\n    INTEGER, intent(in) :: a, b, c, alpha, beta, gamm\n    INTEGER :: theta, d, mm, m, s\n    REAL*16 :: PI =3.14159265358979323846_16\n    REAL*16 :: aa, bb, cc, x, y, r\n    INTEGER, DIMENSION(4) :: solve\n\n     aa = alpha * PI \/ 180.0\n     bb = beta * PI \/ 180.0\n     cc = gamm * PI \/ 180.0\n     x = a * COS(aa) - b * SIN(bb) - c * COS(cc)\n     y = a * SIN(aa) + b * COS(bb) - c * SIN(cc)\n     r = SQRT(x * x + y * y)\n     theta = INT(ACOS(x \/ r) * 180 * 3600 \/ PI)\n     d = theta \/ 3600\n     mm = MOD(theta, 3600)\n     m = mm \/ 60\n     s = MOD(mm, 60)\n     solve = (\/nint(r), d, m, s\/)\n\n  END FUNCTION\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83720,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  FUNCTION solve(a, b, c, alpha, beta, gamm)\n    INTEGER, intent(in) :: a, b, c, alpha, beta, gamm\n    REAL(16) :: PI =3.14159265358979323846_16\n    INTEGER, DIMENSION(4) :: solve\n    \n    real(16)     :: x, y, temp_angle, temp_min, dist\n    \n    x = getNewPos(a, deg2rad(alpha), 0.0_16, 'x')\n    y = getNewPos(a, deg2rad(alpha), 0.0_16, 'y')\n    \n    x = getNewPos(b, deg2rad(beta) + PI \/ 2.0_16, x, 'x')\n    y = getNewPos(b, deg2rad(beta) + PI \/ 2.0_16, y, 'y')\n    \n    x = getNewPos(c, deg2rad(gamm) + PI, x, 'x')\n    y = getNewPos(c, deg2rad(gamm) + PI, y, 'y')\n    \n    temp_angle = mod(rad2deg(atan(y \/ x)) + 180.0_16, 180.0_16)\n    dist = sqrt(x * x + y * y)\n    \n    if (dist - int(dist) > 0.99) then\n      solve(1) = ceiling(dist)\n    else\n      solve(1) = nint(dist)\n    end if\n    \n    solve(2) = int(temp_angle)\n    temp_min = (temp_angle - int(temp_angle)) * 60\n    solve(3) = temp_min\n    solve(4) = (temp_min - int(temp_min)) * 60\n    \n  contains \n  function deg2rad(deg) result(rad)\n  integer        :: deg\n  real(16)        :: rad\n  rad = PI * deg \/ 180.\n  end function\n  \n  function rad2deg(rad) result(deg)\n  real(16)        :: rad, deg\n  deg = 180. * rad \/ PI\n  end function\n  \n  function getNewPos(r, rad, ini, co) result(out)\n  integer            :: r\n  character          :: co\n  real(16)           :: ini, rad, out\n  if (co == 'x') then\n    out = r * cos(rad) + ini\n  else\n    out = r * sin(rad) + ini\n  end if\n  end function\n  \n  END FUNCTION\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83721,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  FUNCTION solve(a, b, c, alpha, beta, gamm)\n    INTEGER, intent(in) :: a, b, c, alpha, beta, gamm\n    INTEGER :: theta, d, mm, m, s\n    REAL(kind=16) :: PI =3.14159265358979323846_16\n    REAL(kind=16) :: aa, bb, cc, x, y, r\n    INTEGER, DIMENSION(4) :: solve\n\n     aa = alpha * PI \/ 180.0\n     bb = beta * PI \/ 180.0\n     cc = gamm * PI \/ 180.0\n     x = a * COS(aa) - b * SIN(bb) - c * COS(cc)\n     y = a * SIN(aa) + b * COS(bb) - c * SIN(cc)\n     r = SQRT(x * x + y * y)\n     theta = INT(ACOS(x \/ r) * 180 * 3600 \/ PI)\n     d = theta \/ 3600\n     mm = MOD(theta, 3600)\n     m = mm \/ 60\n     s = MOD(mm, 60)\n     solve = (\/nint(r), d, m, s\/)\n\n  END FUNCTION\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83722,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  FUNCTION solve(a, b, c, alpha, beta, gamm)\n    INTEGER, intent(in) :: a, b, c, alpha, beta, gamm\n    REAL*16 :: PI =3.14159265358979323846_16\n    INTEGER, DIMENSION(4) :: solve\n    \n    real*16 :: ax,ay,bx,by,cx,cy,co,phi,rest\n    integer :: phiI,phiM,phiS\n    \n    \n    ax = a*cos(alpha*PI\/180.0)\n    ay = a*sin(alpha*PI\/180.0)\n    \n    bx = b*cos((beta+90)*PI\/180.0)+ax\n    by = b*sin((beta+90)*PI\/180.0)+ay\n    \n    cx = c*cos((gamm+180)*PI\/180.0)+bx\n    cy = c*sin((gamm+180)*PI\/180.0)+by\n    \n    co =  INT(anint(sqrt(cx*cx+cy*cy)))\n    phi = atan2(cy,cx)*180.0\/PI\n    \n    phiI = INT(phi)\n    \n    rest = phi-phiI\n    \n    phiM = INT(rest*60.0)\n    \n    phiS = INT((rest-phiM\/60.0)*3600)\n    \n    !print *, co,phi,phiI,rest,phiM,phiS\n    solve(1) = co\n    solve(2) = phiI\n    solve(3) = phiM\n    solve(4) = phiS\n    \n  END FUNCTION\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83723,"user_id":null,"body":"MODULE Solution\n  IMPLICIT NONE\nCONTAINS\n\n  FUNCTION solve(a, b, c, alpha, beta, gamma)\n    INTEGER, intent(in) :: a, b, c, alpha, beta, gamma\n    REAL*16 :: PI =3.14159265358979323846_16\n    INTEGER, DIMENSION(4) :: solve\n    complex*16 :: AA, BB, CC, ans ! Pretend it's a complex plane\n    real*16 :: angle\n    write(*,*) a,b,c,alpha,beta,gamma\n    AA = cmplx(a * cos(alpha*PI\/180._16), a * sin(alpha*PI\/180._16))\n    BB = cmplx(b * cos(PI\/2._16 + beta*PI\/180._16),b * sin(PI\/2._16 + beta*PI\/180._16))\n    CC = cmplx(c * cos(PI + gamma*PI\/180._16), c * sin(PI + gamma*PI\/180._16))\n    ans = AA + BB + CC\n    write(*,*) ans\n    solve(1) = nint(abs(ans))\n    angle = ATAN(imag(ans), real(ans))\n    solve(2) = floor(angle*180._16\/PI)\n    solve(3) = floor((angle*180._16\/PI - solve(2) )*60)\n    solve(4) = floor((angle*180._16\/PI - solve(2) - solve(3)\/60.)*3600)\n  END FUNCTION\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5ce399e0047a45001c853c2b":[{"id":83724,"user_id":null,"body":"MODULE Solution\n\nCONTAINS\n\n    SUBROUTINE Parts_Sums(arr, ans)\n        INTEGER, DIMENSION(:), INTENT(IN) :: arr\n        INTEGER, INTENT(OUT), ALLOCATABLE, DIMENSION(:) :: ans\n        allocate(ans(size(arr) + 1))\n        ans(:) = 0\n        do i = size(arr), 1, -1\n          ans(i) = ans(i + 1) + arr(i)\n        end do\n    END SUBROUTINE\n\nEND MODULE","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83725,"user_id":null,"body":"MODULE Solution\n\nCONTAINS\n\n    SUBROUTINE Parts_Sums(arr, ans)\n        INTEGER, DIMENSION(:), INTENT(IN) :: arr\n        INTEGER, INTENT(OUT), ALLOCATABLE, DIMENSION(:) :: ans\n\n        ! your code\n        INTEGER :: length,i,j,k\n        length = size(arr)\n        allocate(ans(length+1))\n        ans = 0\n        do i = 1,length\n        ans(1) = ans(1) + arr(i)\n        end do\n        do j = 2,length+1\n        ans(j) = ans(j-1) - arr(j-1)\n        end do\n    END SUBROUTINE\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83726,"user_id":187,"body":"MODULE Solution\n\nCONTAINS\n\n    SUBROUTINE Parts_Sums(arr, ans)\n        INTEGER, DIMENSION(:), INTENT(IN) :: arr\n        INTEGER, INTENT(OUT), ALLOCATABLE, DIMENSION(:) :: ans\n        allocate(ans(size(arr)+1))\n        ans(1) = sum(arr)\n        do i=1, size(arr)\n          ans(i+1) = ans(i)-arr(i)\n        enddo\n        ! your code\n    END SUBROUTINE\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83727,"user_id":53,"body":"MODULE Solution\n\nCONTAINS\n\n    SUBROUTINE Parts_Sums(arr, ans)\n        INTEGER, DIMENSION(:), INTENT(IN) :: arr\n        INTEGER, INTENT(OUT), ALLOCATABLE, DIMENSION(:) :: ans\n\n        INTEGER, DIMENSION(SIZE(arr) + 1) :: res      \n        INTEGER :: sum\n        \n        sum = 0\n        \n        DO i = 1, SIZE(arr)\n          sum = sum + arr(i)\n        END DO\n        \n        DO i = 1, SIZE(res)\n          res(i) = sum\n          sum = sum - arr(i)\n        END DO\n        \n        res(SIZE(res)) = 0\n        ans = res\n        \n    END SUBROUTINE\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83728,"user_id":null,"body":"MODULE Solution\n\nCONTAINS\n\n    SUBROUTINE Parts_Sums(arr, ans)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: arr\n        INTEGER, INTENT(OUT), ALLOCATABLE, DIMENSION(:) :: ans\n        INTEGER :: startIndex, i, sum\n        INTEGER, DIMENSION(SIZE(arr)+1) :: nums\n        startIndex = 2\n        sum = 0\n        DO i = 1, SIZE(arr)\n          sum = sum + arr(i)\n        END DO\n        \n        nums(1) = sum\n        DO WHILE (startIndex .le. SIZE(arr)+1)\n          sum = sum - arr(startIndex-1)\n          nums(startIndex) = sum\n          startIndex = startIndex + 1\n        END DO\n        ans = nums\n    END SUBROUTINE\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83729,"user_id":null,"body":"MODULE Solution\n\nCONTAINS\n\n  SUBROUTINE Parts_Sums(arr, ans)\n  INTEGER, DIMENSION(:), INTENT(IN) :: arr\n  INTEGER, INTENT(OUT), ALLOCATABLE, DIMENSION(:) :: ans\n  INTEGER :: startIndex, i, sum\n  INTEGER, DIMENSION(SIZE(arr)+1) :: nums\n  startIndex = 2\n  sum = 0\n  DO i = 1, SIZE(arr)\n    sum = sum + arr(i)\n  END DO\n  nums(1) = sum\n  DO WHILE (startIndex .le. SIZE(arr))\n    sum = sum - arr(startIndex-1)\n    nums(startIndex) = sum\n    startIndex = startIndex + 1\n  END DO\n  ans = nums\n  END SUBROUTINE\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83730,"user_id":76,"body":"MODULE Solution\n\nCONTAINS\n    SUBROUTINE Parts_Sums(arr, ans)\n        INTEGER, DIMENSION(:), INTENT(IN) :: arr\n        INTEGER, INTENT(OUT), ALLOCATABLE, DIMENSION(:) :: ans\n        integer(kind = 8) :: s\n        ALLOCATE(ans(size(arr) + 1))\n        s = sum(arr)\n        ans(1) = s\n        do i = lbound(arr, 1), ubound(arr, 1)\n          s = s - arr(i)\n          ans(i + 1) = s\n        end do\n    END SUBROUTINE\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83731,"user_id":null,"body":"MODULE Solution\n\nCONTAINS\n\n    SUBROUTINE Parts_Sums(arr, ans)\n        implicit none \n        \n        INTEGER, DIMENSION(:), INTENT(IN) :: arr\n        INTEGER, INTENT(OUT), ALLOCATABLE, DIMENSION(:) :: ans\n\n        ! your code\n        integer :: i, n\n        \n        n = size(arr)\n        allocate(ans(n+1))\n        \n        ans(n+1) = 0\n        do i = n, 1, -1\n          ans(i) = ans(i+1) + arr(i)\n        end do\n        \n        return\n    END SUBROUTINE\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83732,"user_id":492,"body":"MODULE Solution\n\nCONTAINS\n\n    SUBROUTINE Parts_Sums(arr, ans)\n        INTEGER, DIMENSION(:), INTENT(IN) :: arr\n        INTEGER, INTENT(OUT), ALLOCATABLE, DIMENSION(:) :: ans\n        INTEGER :: i\n\n        i = SIZE(arr)\n        ALLOCATE(ans(i + 1))\n        ans = 0\n        DO WHILE (i > 0)\n            ans(i) = ans(i + 1) + arr(i)\n            i = i - 1\n        END DO\n    END SUBROUTINE\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83733,"user_id":null,"body":"MODULE Solution\n\nCONTAINS\n\n    SUBROUTINE Parts_Sums(arr, ans)\n        INTEGER, DIMENSION(:), INTENT(IN) :: arr\n        INTEGER, INTENT(OUT), ALLOCATABLE, DIMENSION(:) :: ans\n\n        ! your code\n        integer          :: wholeSum\n        integer          :: i, N\n        \n        wholeSum = 0\n        N = size(arr, 1)\n        \n        allocate(ans(N))\n        \n        do i = 1, N\n          wholeSum = wholeSum + arr(i)\n        end do\n        \n        ans(1) = wholeSum\n        do i = 2, N\n          ans(i) = ans(i - 1) - arr(i- 1)\n        end do\n    END SUBROUTINE\n\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5d50e3914861a500121e1958":[{"id":83734,"user_id":null,"body":"MODULE Solution\n    IMPLICIT NONE\n    PUBLIC:: add_letters\n    PRIVATE\n  CONTAINS\n    PURE FUNCTION add_letters(letters) RESULT(S)\n      CHARACTER, DIMENSION(:), INTENT(IN):: letters\n      CHARACTER:: S\n      INTEGER:: I, SM, SHFT, LCNT\n      !\n      IF(letters(1) == ' ') THEN\n        S = \"z\"\n        RETURN\n      END if\n      !\n      LCNT = 26\n      SHFT = 96\n      SM = 0\n      DO I=1, SIZE(letters)\n                           SM = SM + IACHAR(letters(i)) - SHFT\n      END DO\n      !\n      DO WHILE (SM > LCNT)\n                SM = SM - LCNT\n      END DO\n      !\n      S = ACHAR(SM+SHFT)\n      !\n    END FUNCTION add_letters\n  END MODULE","lang_id":19,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83735,"user_id":null,"body":"MODULE Solution\n    IMPLICIT NONE\n    PUBLIC:: add_letters\n    PRIVATE\n  CONTAINS\n    PURE FUNCTION add_letters(letters) RESULT(S)\n      CHARACTER, DIMENSION(:), INTENT(IN):: letters  ! Note that CHARACTER, CHARACTER(1), and CHARACTER(len=1) are equivalent\n      CHARACTER:: S\n      CHARACTER, DIMENSION(26) :: alphabet\n      INTEGER :: i, n\n      \n      alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', &\n                  'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n      \n      n = 0\n      do i=1, size(letters)\n        if (letters(i) .ne. ' ') then\n          n = n + findloc(alphabet, letters(i), 1)\n        endif\n      end do\n      \n      if (n .eq. 0) then\n        S = 'z'\n      else\n        S = alphabet(mod(n, 27) + n\/27)\n      endif\n    END FUNCTION add_letters\n  END MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83736,"user_id":168,"body":"MODULE Solution\n    IMPLICIT NONE\n    PUBLIC:: add_letters\n    PRIVATE\n  CONTAINS\n    PURE FUNCTION add_letters(letters) RESULT(S)\n      CHARACTER, DIMENSION(:), INTENT(IN) :: letters  ! Note that CHARACTER, CHARACTER(1), and CHARACTER(len=1) are equivalent\n      CHARACTER :: S\n      integer :: i, t\n      if (letters(1) == ' ') then\n        s = 'z'\n        return\n      end if\n      t = 25 - size(letters) * 96\n      do i = 1, size(letters)\n        t = t + iachar(letters(i))\n      end do\n      s = achar(mod(t, 26) + 97)\n    END FUNCTION add_letters\n  END MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83737,"user_id":null,"body":"MODULE Solution\n    IMPLICIT NONE\n    PUBLIC:: add_letters\n    PRIVATE\n  CONTAINS\n    PURE FUNCTION add_letters(letters) RESULT(S)\n      CHARACTER, DIMENSION(:), INTENT(IN):: letters  ! Note that CHARACTER, CHARACTER(1), and CHARACTER(len=1) are equivalent\n      CHARACTER:: S\n      integer :: nl, offset, res, i\n      \n      nl = size(letters)\n      if (nl .eq. 1 .and. letters(1) .eq. ' ') then\n        S = 'z'\n        return\n      end if\n      \n      offset = ichar('a') - 1\n      res = 0\n      \n      do i = 1, nl, 1\n        res = res + ichar(letters(i))\n      end do\n      \n      res = res - nl * offset\n      if (res .gt. 26) res = modulo(res, 26)\n      \n      S = char(offset + res)\n      \n      return\n    END FUNCTION add_letters\n  END MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83738,"user_id":null,"body":"MODULE Solution\n    IMPLICIT NONE\n    PUBLIC:: add_letters\n    PRIVATE\n  CONTAINS\n    PURE FUNCTION add_letters(letters) RESULT(S)\n      CHARACTER, DIMENSION(:), INTENT(IN):: letters  ! Note that CHARACTER, CHARACTER(1), and CHARACTER(len=1) are equivalent\n      CHARACTER:: S\n      integer  :: i,convert,sum1\n      convert=0\n      sum1=0\n      do i=1,size(letters)\n          convert=ichar(letters(i))-96\n          sum1=sum1+convert\n          if(convert==-64)then\n              S=\"z\"\n              return\n           end if\n      end do\n      sum1=mod(sum1-1,26)+1+96\n      S=char(sum1)\n      !\n      ! your code here\n      !\n    END FUNCTION add_letters\n  END MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83739,"user_id":null,"body":"MODULE Solution\n    IMPLICIT NONE\n    PUBLIC:: add_letters\n    PRIVATE\n  CONTAINS\n    PURE FUNCTION add_letters(letters) RESULT(S)\n      CHARACTER, DIMENSION(:), INTENT(IN):: letters  ! Note that CHARACTER, CHARACTER(1), and CHARACTER(len=1) are equivalent\n      CHARACTER:: S\n      CHARACTER, DIMENSION(26) :: abc\n      INTEGER :: sum, i,j\n      \n      IF(size(letters) == 1) THEN\n        IF (letters(1) == \" \") THEN\n        S = \"z\"\n        ELSE\n        S = letters(1)\n        END IF\n       RETURN\n      END IF\n      \n      sum = 0\n      abc = [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]\n\n      ! find numerical value for letter \n      DO j = 1,size(letters)      \n        DO i = 1,size(abc)\n          IF (letters(j) == abc(i)) THEN\n            EXIT  \n          END IF\n        END DO\n        sum = sum + i     \n      END DO\n      !deal with overlapping\n      DO WHILE (sum >26)\n        sum = sum - 26\n      END DO\n      \n      S = abc(sum)\n           \n    END FUNCTION add_letters\n\n  END MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83740,"user_id":null,"body":"MODULE Solution\n    IMPLICIT NONE\n    PUBLIC:: add_letters\n    PRIVATE\n  CONTAINS\n    FUNCTION add_letters(letters) RESULT(S)\n      CHARACTER, DIMENSION(:), INTENT(IN):: letters  ! Note that CHARACTER, CHARACTER(1), and CHARACTER(len=1) are equivalent\n      CHARACTER(len = 1) :: S\n      character(len = 27) :: alphabet\n      integer :: i, sum\n      \n      alphabet = 'abcdefghijklmnopqrstuvwxyz'\n      sum = 0\n      \n      do i=1,size(letters)\n        sum = sum + index(alphabet, letters(i))\n      end do\n      \n      if (sum .gt. 26) then\n        sum = mod(sum, 26)\n      end if\n      \n      if (letters(1) .ne. ' ') then\n        S = alphabet(sum:sum)\n      else\n        S = 'z'\n      end if\n\n    END FUNCTION add_letters\n  END MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83741,"user_id":645,"body":"module Solution\n  implicit none\ncontains\n  character pure function add_letters(letters)\n    character, dimension(:), intent(in) :: letters\n    integer :: i, x\n    if (letters(1) == \" \") then\n      add_letters = \"z\"\n      return\n    end if\n    x = 0\n    do i = 1, size(letters)\n      x = x + iachar(letters(i)) - 96\n    end do\n    x = mod(x, 26) + 1\n    add_letters = \"zabcdefghijklmnopqrstuvwxy\"(x:x)\n  end function add_letters\nend module","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83742,"user_id":null,"body":"MODULE Solution\n    IMPLICIT NONE\n    PUBLIC:: add_letters\n    PRIVATE\n    character(len=26),parameter :: alphabet=\"abcdefghijklmnopqrstuvwxyz\"\n  CONTAINS\n    PURE FUNCTION add_letters(letters) RESULT(S)\n      CHARACTER, DIMENSION(:), INTENT(IN):: letters  ! Note that CHARACTER, CHARACTER(1), and CHARACTER(len=1) are equivalent\n      CHARACTER:: S\n      integer :: i, total\n      if(letters(1)==\"\")then\n        s=\"z\"\n        return\n      end if\n       total=0\n       do i=1,size(letters),1\n         total=total+index(alphabet,letters(i))\n       end do\n       total=mod(total,26)\n       if(total.eq.0)total=26\n       s=alphabet(total:total)\n    END FUNCTION add_letters\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5da1df6d8b0f6c0026e6d58d":[{"id":83743,"user_id":53,"body":"MODULE Solution\n  IMPLICIT NONE\n\n  PUBLIC:: c\n  CONTAINS\n  FUNCTION c(k) RESULT(ans)\n    INTEGER, PARAMETER :: ikind=selected_int_kind(16)\n    INTEGER(ikind), INTENT(IN) :: k\n    INTEGER(ikind) :: sq, num, i\n    INTEGER :: ans, cnt\n    ans = 0\n    sq = floor(sqrt(real(k)))\n    if (sq * sq == k) then\n      i = 2\n      num = k * sq\n      ans = 1\n      do while (num > 1)\n        cnt = 0\n        do while (mod(num, i) == 0)\n          num = num \/ i\n          cnt = cnt + 1\n        end do\n        ans = ans * (cnt + 1)\n        i = i + 1\n      end do\n    end if\n  END FUNCTION\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83744,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\n  INTEGER, PARAMETER:: i64 = SELECTED_INT_KIND(16)\n\n  PUBLIC:: c\n  PRIVATE\n  !\n  CONTAINS\n  !\n  FUNCTION c(k) RESULT(num)\n    INTEGER(i64),  INTENT(IN) :: k\n    INTEGER(i64):: i, nb\n    INTEGER(i64):: root\n    INTEGER:: div_num_nb, res, num\n\n    root = INT(SQRT(REAL(k)), i64)\n    IF (root * root .NE. k) THEN\n        num = 0\n    ELSE\n        i = 2_i64\n        nb = k * root\n        res = 1\n        DO WHILE (nb .GT. 1_i64)\n            div_num_nb = 0\n            DO WHILE (MOD(nb, i) .EQ. 0_i64)\n                nb = nb \/ i\n                div_num_nb = div_num_nb + 1\n            END DO\n            res = res * (div_num_nb + 1)\n            i = i + 1\n        END DO\n        num = res\n    END IF\n  END FUNCTION\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5e4bb05b698ef0001e3344bc":[{"id":83745,"user_id":168,"body":"MODULE Solution\n  IMPLICIT NONE\n  INTEGER, PARAMETER:: j64 = SELECTED_INT_KIND(16)\n  !\n  PUBLIC :: solve, j64\n  PRIVATE\n  !\n  CONTAINS\n  !\n  FUNCTION solve(arr) RESULT(res)\n    INTEGER(KIND=j64), DIMENSION(:), INTENT(IN) :: arr\n    INTEGER(KIND=j64), DIMENSION(2) :: res\n    integer(kind=j64) :: x, y, z, a, b\n    integer :: i\n    x = arr(1)\n    y = arr(2)\n    do i = 3, size(arr), 2\n      a = arr(i)\n      b = arr(i + 1)\n      z = x * a - y * b\n      y = x * b + y * a\n      x = z\n    end do\n    res(1) = abs(x)\n    res(2) = abs(y)\n  END FUNCTION\n\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83746,"user_id":53,"body":"module solution\n\n  implicit none\n  integer, parameter:: j64 = selected_int_kind(16)\n  public :: solve\n  private :: fold\n  contains\n  \n  function fold(xs) result(res)\n    integer(kind=j64), dimension(4), intent(in) :: xs\n    integer(kind=j64), dimension(2) :: res\n    res(1) = abs(xs(1)*xs(3)-xs(2)*xs(4))\n    res(2) = xs(1)*xs(4)+xs(2)*xs(3)\n  end function\n\n  recursive function solve(xs) result(res)\n    integer(kind=j64), dimension(:), intent(in) :: xs\n    integer(kind=j64), dimension(2) :: res, tmp\n    integer(kind=j64), dimension(:), allocatable :: ys\n    integer :: w\n    w = size(xs)\n    if (w == 4) then\n      res = fold(xs)\n      return\n    end if\n    tmp = fold(xs(1:4))\n    allocate(ys(2+w-4))\n    ys(1:2) = tmp\n    ys(3:w-2) = xs(5:w)\n    res = solve(ys)\n    deallocate(ys)\n  end function\n  \nend module solution\n","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83747,"user_id":492,"body":"MODULE Solution\n  IMPLICIT NONE\n  INTEGER, PARAMETER:: j64 = SELECTED_INT_KIND(16)\n  !\n  PUBLIC :: solve\n  PRIVATE :: h\n  !\n  CONTAINS\n  !\n  FUNCTION h(a) RESULT(res)\n    INTEGER(KIND=j64), DIMENSION(4), INTENT(IN) :: a\n    INTEGER(KIND=j64), DIMENSION(2) :: res\n\n    res(1) = ABS(a(1) * a(3) - a(2) * a(4))\n    res(2) = ABS(a(1) * a(4) + a(2) * a(3))\n  END FUNCTION\n\n  RECURSIVE FUNCTION solve(a) RESULT(res)\n    INTEGER(KIND=j64), DIMENSION(:), INTENT(IN) :: a\n    INTEGER(KIND=j64), DIMENSION(2) :: res\n    INTEGER(KIND=j64), DIMENSION(:), ALLOCATABLE :: res1\n    INTEGER(KIND=j64), DIMENSION(2) :: tmp\n    INTEGER :: lg\n\n    lg = SIZE(a)\n    IF (lg == 4) THEN\n      res = h(a)\n    ELSE\n      tmp = h(a(1:4))\n      ALLOCATE(res1(2 + lg - 4))\n      res1(1:2) = tmp\n      res1(3:lg - 2) = a(5:lg)\n      res = solve(res1)\n      DEALLOCATE(res1)\n    END IF\n  END FUNCTION\nEND MODULE Solution","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"5f70c883e10f9e0001c89673":[{"id":83748,"user_id":168,"body":"MODULE Solution\n  implicit none\n\nCONTAINS\n    SUBROUTINE flip(dir, arr, res)\n      CHARACTER, INTENT(IN) :: dir\n      INTEGER, DIMENSION(:), INTENT(IN) :: arr\n      INTEGER, ALLOCATABLE, DIMENSION(:) :: res\n      integer :: i, j, k, x\n      res = arr\n      do i = 1, size(res)\n        x = res(i)\n        k = i\n        do j = i + 1, size(res)\n          if (dir == 'L' .and. res(j) > x .or. dir == 'R' .and. res(j) < x) then\n            x = res(j)\n            k = j\n          end if\n        end do\n        if (k \/= i) then\n          res(k) = res(i)\n          res(i) = x\n        end if\n      end do\n      \n    END SUBROUTINE\n    \nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83749,"user_id":null,"body":"MODULE Solution\n\nCONTAINS\n    SUBROUTINE flip(dir, arr, res)\n      CHARACTER, INTENT(IN) :: dir\n      INTEGER :: i,j,temp\n      INTEGER, DIMENSION(:), INTENT(IN) :: arr\n      INTEGER, ALLOCATABLE, DIMENSION(:) :: res\n      res=arr\n      DO i=1,SIZE(arr)-1\n        DO j=i+1,SIZE(arr)\n        IF (dir .EQ. \"L\") THEN\n          IF (res(i) .LT. res(j)) THEN\n              temp=res(i)\n              res(i)=res(j)\n              res(j)=temp\n          END IF\n        ELSE\n          IF (res(i) .GT. res(j)) THEN\n                temp=res(i)\n                res(i)=res(j)\n                res(j)=temp\n          END IF\n        END IF\n        END DO\n      END DO\n    END SUBROUTINE\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83750,"user_id":53,"body":"MODULE Solution\n\nCONTAINS\n    recursive subroutine quicksort(a, first, last, dir)\n      implicit none\n      character :: dir\n      integer  a(*), x, t\n      integer first, last\n      integer i, j\n      x = a( (first+last) \/ 2 )\n      i = first\n      j = last\n      do\n         do while ((a(i) < x .and. dir == 'R') .or. (a(i) > x .and. dir == 'L'))\n            i=i+1\n         end do\n         do while ((x < a(j) .and. dir == 'R') .or. (x > a(j) .and. dir == 'L'))\n            j=j-1\n         end do\n         if (i >= j) exit\n         t = a(i);  a(i) = a(j);  a(j) = t\n         i=i+1\n         j=j-1\n      end do\n      if (first < i-1) call quicksort(a, first, i-1, dir)\n      if (j+1 < last)  call quicksort(a, j+1, last, dir)\n    end subroutine quicksort\n    \n    SUBROUTINE flip(dir, arr, res)\n      CHARACTER, INTENT(IN) :: dir\n      INTEGER, DIMENSION(:), INTENT(IN) :: arr\n      INTEGER, ALLOCATABLE, DIMENSION(:) :: res\n      INTEGER :: n, k, temp\n      res = arr\n      call quicksort(res,1,SIZE(arr),dir)\n    END SUBROUTINE\n    \nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83751,"user_id":null,"body":"MODULE Solution\n\nCONTAINS\n    SUBROUTINE flip(dir, arr, res)\n      CHARACTER, INTENT(IN) :: dir\n      INTEGER, DIMENSION(:), INTENT(IN) :: arr\n      INTEGER, ALLOCATABLE, DIMENSION(:) :: res\n      integer :: siz\n    integer :: temp\n    integer :: i\n    integer :: j\n    res=arr\n    siz=size(res)\n    \n    if(dir=='R') then\n        do i=1, siz\n          do j=i+1, siz\n            if(res(j)<res(i)) then\n              temp=res(i)\n              res(i)=res(j)\n              res(j)=temp\n            end if\n          end do\n        end do    \n    \n    else if(dir=='L') then\n      do i=1, siz\n        do j=i+1, siz\n          if(res(j)>res(i)) then\n            temp=res(i)\n            res(i)=res(j)\n            res(j)=temp\n          end if\n        end do\n      end do\n    end if  \n      \n    END SUBROUTINE\n    \nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"},{"id":83752,"user_id":76,"body":"MODULE Solution\n\nCONTAINS\n  SUBROUTINE flip(dir, arr, res)\n    CHARACTER, INTENT(IN) :: dir\n    INTEGER, DIMENSION(:), INTENT(IN) :: arr\n    INTEGER, DIMENSION(:), ALLOCATABLE :: res\n    LOGICAL, DIMENSION(:), ALLOCATABLE :: mask\n    INTEGER :: arr_size, i\n    \n    arr_size = size(arr)\n    allocate(res(arr_size))\n    allocate(mask(arr_size))\n    \n    DO i = 1, arr_size\n      mask(i) = .True.\n    END DO\n    \n    IF (dir == 'R') THEN\n      DO i = 1, arr_size\n        res(i) = MINVAL(arr, mask)\n        mask(MINLOC(arr, mask)) = .False.\n      END DO\n    ELSE\n      DO i = 1, arr_size\n        res(i) = MAXVAL(arr, mask)\n        mask(MAXLOC(arr, mask)) = .False.\n      END DO\n    END IF\n  END SUBROUTINE\nEND MODULE","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}],"59f9cad032b8b91e12000035":[{"id":83753,"user_id":503,"body":"module BrainFuckTranspiler\n  implicit none\n  private\n  public kcuf\n  character,allocatable :: Y(:)\n  type ArrayNode\n    character,allocatable :: Data(:)\n  endtype\n  type Array\n    integer At,Len\n    type(ArrayNode),allocatable :: Data(:)\n  endtype\n  type ArrayPointer\n    type(Array),pointer :: Data\n  endtype\n  type MapNode\n    integer Hash\n    character,allocatable :: Key(:),Value(:)\n    type(MapNode),pointer :: Next\n  endtype\n  type Map\n    type(MapNode),pointer :: Q\n  endtype\n  type(MapNode),pointer :: MapLast\n  logical Error\n  character(:),allocatable :: I,O\n  integer :: &\n    CodeAt,CodeOffset,CodeLen, &\n    OAt,OLen, &\n    Preserve = 8, PreserveMax, &\n    StackAt, VarAt\n  integer Stack(0:8)\n  type VarType\n    integer At,Len\n  endtype\n  type(VarType) VarTemp\n  type(Map) Var(64)\n  type(Array),pointer :: AST,CurrentAST\n  type(Array) ASTStack\n  type ProcType\n    type(Array),pointer :: AST,Var,VarType\n  endtype\n  type(ProcType) ProcTemp\n  type(Map) Proc(64)\n  logical ProcIn\n  type(Array),pointer :: ProcVar,ProcVarType\n\n  logical L_\n  type(Array),pointer :: Argument\n  type(Map),pointer :: CallArg(:)\n  type(Array) CallStack\n  type Op\n    logical H\n    integer N\n    character,pointer :: C(:)\n  endtype\n  type(Op) OpT\ncontains\n  logical function Ensure(Q,S)\n    integer Q,S\n    Ensure = Q <= S\n    do while (Q <= S)\n      Q = Q + Q\n    enddo\n  end\n  subroutine Copy(To,From)\n    character,allocatable :: To(:)\n    character From(:)\n    if (allocated(To)) deallocate(To)\n    allocate(To(size(From)))\n    To = From\n  end\n\n  subroutine ArrayMake(Q)\n    type(Array) Q\n    Q%At = 0\n    Q%Len = 32\n    allocate(Q%Data(Q%Len))\n  end\n  subroutine ArrayCheck(Q)\n    type(Array) Q\n    type(ArrayNode),allocatable :: T(:)\n    if (Ensure(Q%Len,Q%At)) then\n      call move_alloc(Q%Data,T)\n      allocate(Q%Data(Q%Len))\n      Q%Data(:size(T)) = T\n    endif\n  end\n  subroutine ArrayPush(Q,S)\n    type(Array) Q\n    character,optional :: S(:)\n    call ArrayCheck(Q)\n    Q%At = 1 + Q%At\n    if (present(S)) call Copy(Q%Data(Q%At)%Data,S)\n  end\n  subroutine ArrayFree(Q)\n    type(Array) Q\n    deallocate(Q%Data)\n  end\n  integer function IndexOf(S,Q)\n    character S(:)\n    type(Array) Q\n    integer F\n    IndexOf = 0\n    do F = 1,Q%At\n      if (all(S == Q%Data(F)%Data)) then\n        IndexOf = F\n        return\n      endif\n    enddo\n  end\n\n  subroutine MapHash(Q,K,H,C)\n    type(Map) Q(:)\n    character K(:)\n    integer H,F\n    type(MapNode),pointer :: C\n    H = -2128831035\n    do F = 1,size(K)\n      H = 16777619 * H\n      H = ieor(ichar(K(F)),H)\n    enddo\n    C => Q(1 + modulo(H,size(Q)))%Q\n  end\n  subroutine MapInit(Q)\n    type(Map) Q(:)\n    Q = Map(null())\n  end\n  subroutine MapFree(Q)\n    type(Map) Q(:)\n    type(MapNode),pointer :: C,N\n    integer F\n    do F = 1,size(Q)\n      C => Q(F)%Q\n      do while (associated(C))\n        N => C%Next\n        deallocate(C%Key)\n        deallocate(C%Value)\n        deallocate(C)\n        C => N\n      enddo\n      Q(F)%Q => C\n    enddo\n  end\n  subroutine MapSet(Q,K,V)\n    type(Map) Q(:)\n    type(MapNode),pointer :: L,C\n    character K(:),V(:)\n    integer H\n    call MapHash(Q,K,H,C)\n    L => null()\n    do while (associated(C))\n      if (H == C%Hash) then\n        if (all(K == C%Key)) then\n          call Copy(C%Value,V)\n          return\n        endif\n      endif\n      L => C\n      C => C%Next\n    enddo\n    allocate(C)\n    C%Hash = H\n    call Copy(C%Key,K)\n    call Copy(C%Value,V)\n    C%Next => null()\n    if (associated(L)) then\n      L%Next => C\n    else\n      Q(1 + modulo(H,size(Q)))%Q => C\n    endif\n  end\n  logical function MapHas(Q,K)\n    type(Map) Q(:)\n    type(MapNode),pointer :: C\n    character K(:)\n    integer H\n    call MapHash(Q,K,H,C)\n    do while (associated(C))\n      if (H == C%Hash) then\n        if (all(K == C%Key)) then\n          MapHas = .true.\n          MapLast => C\n          return\n        endif\n      endif\n      C => C%Next\n    enddo\n    MapHas = .false.\n  end\n\n\n  subroutine OutputEnsure(Q)\n    integer Q\n    character(:),allocatable :: T\n    if (Ensure(OLen,Q + OAt - 1)) then\n      call move_alloc(O,T)\n      allocate(character(OLen) :: O)\n      O(:len(T)) = T\n    endif\n  end\n  subroutine ErrorMake()\n    Error = .true.\n    OAt = 0\n  end\n  subroutine OutputString(Q)\n    character(*) Q\n    call OutputEnsure(len(Q))\n    O(1 + OAt:) = Q\n    OAt = OAt + len(Q)\n  end\n  subroutine OutputCharArray(Q)\n    character Q(:)\n    integer F\n    call OutputEnsure(size(Q))\n    do F = 1,size(Q)\n      OAt = 1 + OAt\n      O(OAt:) = Q(F)\n    enddo\n  end\n  subroutine OutputInteger(Q)\n    integer Q\n    character(11) T\n    write (T,'(I0)') Q\n    call OutputString(T(:len_trim(T)))\n  end\n  subroutine OutputStringN(Q,S)\n    character(*) Q\n    integer S,F\n    call OutputEnsure(S * len(Q))\n    do F = 1,S\n      O(1 + OAt:) = Q\n      OAt = OAt + len(Q)\n    enddo\n  end\n\n  subroutine ErrorTasteEOL()\n    if (CodeLen < CodeAt) then\n      call OutputString('EOL')\n    else\n      call OutputString(I(CodeOffset + CodeAt:CodeOffset + CodeAt))\n    endif\n  end\n  subroutine ErrorNumberExpected()\n    call ErrorMake()\n    call OutputString('A number is expected but got ')\n    call ErrorTasteEOL()\n  end\n  subroutine ErrorNameExpected()\n    call ErrorMake()\n    call OutputString('A variable name \/ command is expected but got ')\n    call ErrorTasteEOL()\n  end\n  subroutine ErrorCommand(Q)\n    character(*) Q\n    call ErrorMake()\n    call OutputString('Unexpected command ')\n    call OutputString(Q)\n  end\n  subroutine ErrorCommandEnd()\n    call ErrorMake()\n    call OutputString('Expected end of line but got ')\n    call ErrorTasteEOL()\n  end\n  subroutine ErrorDefineInProc()\n    call ErrorMake()\n    call OutputString('Cannot define variables in procedures')\n  end\n  subroutine ErrorVarUndefined(Q)\n    character Q(:)\n    call ErrorMake()\n    call OutputString('Undefined variable ')\n    call OutputCharArray(Q)\n  end\n  subroutine ErrorVarRedeclare(Q)\n    character Q(:)\n    call ErrorMake()\n    call OutputString('Re-defined variable ')\n    call OutputCharArray(Q)\n  end\n  subroutine ErrorVarButList(Q)\n    character Q(:)\n    call ErrorMake()\n    call OutputString('Expected a variable but ')\n    call OutputCharArray(Q)\n    call OutputString(' is a list')\n  end\n  subroutine ErrorListButVar(Q)\n    character Q(:)\n    call ErrorMake()\n    call OutputString('Expected a list but ')\n    call OutputCharArray(Q)\n    call OutputString(' is a variable')\n  end\n  subroutine ErrorVarTypeMismatch(Q,S)\n    character Q(:)\n    logical S\n    call ErrorMake()\n    call OutputString('Type mismatch, ')\n    call OutputCharArray(Q)\n    call OutputString(' was first used as a ')\n    if (S) then\n      call OutputString('var')\n    else\n      call OutputString('list')\n    endif\n  end\n  subroutine ErrorUnEOL()\n    call ErrorMake()\n    call OutputString('Unexpected end of line')\n  end\n  subroutine ErrorUnclosed(Q)\n    character(*) Q\n    call ErrorMake()\n    call OutputString('Unclosed ')\n    call OutputString(Q)\n    call OutputString(', got ')\n    call ErrorTasteEOL()\n  end\n  subroutine ErrorBadEscape()\n    call ErrorMake()\n    call OutputString('Unexpected char escape \\')\n    call ErrorTasteEOL()\n  end\n  subroutine ErrorStringExpect()\n    call ErrorMake()\n    call OutputString('A string is expected but got ')\n    call ErrorTasteEOL()\n  end\n  subroutine ErrorStringUnclose()\n    call ErrorMake()\n    call OutputString('String is not closed')\n  end\n  subroutine ErrorProcNested()\n    call ErrorMake()\n    call OutputString('Procedures should not be nested')\n  end\n  subroutine ErrorProcUsed(Q)\n    character Q(:)\n    call ErrorMake()\n    call OutputString('Procedure re-defined ')\n    call OutputCharArray(Q)\n  end\n  subroutine ErrorDupParam(Q)\n    character Q(:)\n    call ErrorMake()\n    call OutputString('Duplicate parameter name ')\n    call OutputCharArray(Q)\n  end\n  subroutine ErrorEndNothing()\n    call ErrorMake()\n    call OutputString('Nothing to end')\n  end\n  subroutine ErrorEndUnclose()\n    call ErrorMake()\n    call OutputString('Unclosed block (ifeq \/ ifneq \/ ueq \/ proc)')\n  end\n  subroutine ErrorNoProc(Q)\n    character Q(:)\n    call ErrorMake()\n    call OutputString('Undefined procedure ')\n    call OutputCharArray(Q)\n  end\n  subroutine ErrorProcLength(Q,W,E)\n    character Q(:)\n    integer W,E\n    call ErrorMake()\n    call OutputString('Procedure ')\n    call OutputCharArray(Q)\n    call OutputString(' expects ')\n    call OutputInteger(W)\n    call OutputString(' argument(s) but got ')\n    call OutputInteger(E)\n  end\n  subroutine ErrorRecursive(Q)\n    character Q(:)\n    call ErrorMake()\n    call OutputString('Recursive call ')\n    call OutputCharArray(Q)\n  end\n  subroutine ErrorArgTypeMismatch(H,W,A,Q)\n    logical H\n    character W(:),Q(:)\n    type(Op) A\n    call ErrorMake()\n    call OutputString('Type mismatch. A ')\n    if (H) then\n      call OutputString('var')\n    else\n      call OutputString('list')\n    endif\n    call OutputString(' is expected for parameter ')\n    call OutputCharArray(W)\n    call OutputString(' in `')\n    call OutputCharArray(A%C)\n    call OutputString(', but argument ')\n    call OutputCharArray(Q)\n    call OutputString(' is a ')\n    if (H) then\n      call OutputString('list')\n    else\n      call OutputString('var')\n    endif\n  end\n\n  logical function VarIsNumber()\n    type(VarType) T\n    T = transfer(MapLast%Value,T)\n    VarIsNumber = T%Len < 0\n  end\n\n  integer function Taste(Q)\n    integer,optional :: Q\n    integer T\n    T = CodeAt\n    if (present(Q)) T = T + Q\n    Taste = 0\n    if (T <= CodeLen) Taste = ichar(I(CodeOffset + T:))\n  end\n  subroutine Eat()\n    CodeAt = 1 + CodeAt\n  end\n  subroutine Walk(Q)\n    logical Q\n    do while (Q(Taste()))\n      call Eat()\n    enddo\n  end\n  logical function TestSpace(Q)\n    integer Q\n    TestSpace = 8 < Q .and. Q < 14 .or. 32 == Q\n  end\n  logical function TestIdentifierPrefix(Q)\n    integer Q\n    TestIdentifierPrefix = 36 == Q .or. 95 == Q .or. 64 < Q .and. Q < 91 .or. 96 < Q .and. Q < 123\n  end\n  logical function TestIdentifierSuffix(Q)\n    integer Q\n    TestIdentifierSuffix = 36 == Q .or. 95 == Q .or. 47 < Q .and. Q < 58 .or. 64 < Q .and. Q < 91 .or. 96 < Q .and. Q < 123\n  end\n  logical function TestNumber(Q)\n    integer Q\n    TestNumber = 47 < Q .and. Q < 58\n  end\n  subroutine Discard()\n    CodeAt = 1 + CodeLen\n  end\n  subroutine White()\n    call Walk(TestSpace)\n    if (45 == Taste() .and. 45 == Taste(1) .or. &\n      47 == Taste() .and. 47 == Taste(1) .or. &\n      35 == Taste()) call Discard()\n  end\n  function Word() result(R)\n    character,pointer :: R(:)\n    integer :: S,T,F\n    S = CodeAt\n    R => null()\n    if (Error) return\n    if (CodeAt <= CodeLen) then\n      if (.not. TestIdentifierPrefix(Taste())) then\n        call ErrorNameExpected()\n        return\n      endif\n    endif\n    call Walk(TestIdentifierSuffix)\n    allocate(R(CodeAt - S))\n    do F = S,CodeAt - 1\n      T = ichar(I(CodeOffset + F:))\n      if (96 < T) T = T - 32\n      R(1 + F - S) = char(T)\n    enddo\n    call White()\n  end\n  function MakeName(H) result(R)\n    logical H,T\n    character,pointer :: R(:)\n    integer F\n    R => Word()\n    if (.not. associated(R)) call ErrorNameExpected()\n    if (size(R) < 1 .and. .not. Error) call ErrorNameExpected()\n    if (Error) return\n    if (ProcIn) then\n      F = IndexOf(R,ProcVar)\n      if (0 < F) then\n        if (allocated(ProcVarType%Data(F)%Data)) then\n          T = transfer(ProcVarType%Data(F)%Data,T)\n          if (T .neqv. H) call ErrorVarTypeMismatch(R,H)\n        else\n          call Copy(ProcVarType%Data(F)%Data,transfer(H,Y))\n        endif\n        return\n      endif\n    endif\n    if (.not. MapHas(Var,R)) then\n      call ErrorVarUndefined(R)\n      return\n    endif\n    if (H .neqv. VarIsNumber()) then\n      if (H) then\n        call ErrorVarButList(R)\n      else\n        call ErrorListButVar(R)\n      endif\n    endif\n  end\n  function VarName()\n    character,pointer :: VarName(:)\n    VarName => MakeName(.true.)\n  end\n  function ListName()\n    character,pointer :: ListName(:)\n    ListName => MakeName(.false.)\n  end\n  function RawNumber() result(R)\n    integer S,R\n    logical M\n    M = 45 == Taste()\n    if (M) call Eat()\n    S = CodeAt\n    R = 0\n    do while (TestNumber(Taste()))\n      R = 10 * R + Taste() - 48\n      call Eat()\n    enddo\n    if (M) R = -R\n    if (CodeAt == S) then\n      call ErrorNumberExpected()\n      return\n    endif\n    call White()\n  end\n  integer function Number()\n    Number = modulo(RawNumber(),256)\n  end\n  function ReadChar() result(R)\n    integer R\n    R = Taste()\n    call Eat()\n    if (92 == R) then\n      select case (Taste())\n        case (92)\n          R = 92\n        case (34)\n          R = 34\n        case (39)\n          R = 39\n        case (110)\n          R = 10\n        case (114)\n          R = 13\n        case (116)\n          R = 9\n        case default\n          call ErrorBadEscape()\n      endselect\n      call Eat()\n    endif\n  end\n  integer function NumberOrChar()\n    if (39 == Taste()) then\n      call Eat()\n      NumberOrChar = ReadChar()\n      if (39 \/= Taste()) then\n        call ErrorUnclosed(\"'\")\n        return\n      endif\n      call Eat()\n      call White()\n    else\n      NumberOrChar = Number()\n    endif\n  end\n  function VarNameOrNumber() result(R)\n    type(Op) R\n    R%H = 39 == Taste() .or. 45 == Taste() .or. TestNumber(Taste())\n    if (R%H) then\n      R%N = NumberOrChar()\n      R%C => null()\n    else\n      R%C => VarName()\n    endif\n  end\n  function String() result(R)\n    character,pointer :: R(:),T(:)\n    integer At,Len\n    At = 0\n    Len = 32\n    allocate(R(Len))\n    if (34 \/= Taste()) then\n      call ErrorStringExpect()\n      return\n    endif\n    call Eat()\n    do while (0 < Taste() .and. 34 \/= Taste())\n      At = 1 + At\n      if (Len < At) then\n        T => R\n        allocate(R(Len + Len))\n        R(:Len) = T\n        Len = Len + Len\n        deallocate(T)\n      endif\n      R(At) = char(ReadChar())\n      if (Error) return\n    enddo\n    if (34 \/= Taste()) then\n      call ErrorStringUnclose()\n      return\n    endif\n    call Eat()\n    call White()\n    T => R\n    allocate(R(At))\n    R = T(:At)\n    deallocate(T)\n  end\n  function VarNameOrString() result(R)\n    type(Op) R\n    R%H = 34 == Taste()\n    if (R%H) then\n      R%C => String()\n    else\n      R%C => VarName()\n    endif\n  end\n  subroutine ArgInit(Q)\n    integer Q\n    allocate(Argument)\n    Argument%At = 0\n    Argument%Len = Q\n    allocate(Argument%Data(Q))\n  end\n  subroutine ArgID(Q)\n    integer Q\n    Argument%Len = Argument%At\n    Argument%At = Q\n  end\n  subroutine ArgMake(Q,S)\n    integer Q,S(:),F\n    call ArgInit(size(S))\n    do F = 1,size(S)\n      if (S(F) < 5) then\n        OpT%H = .false.\n        if (S(F) < 2) then\n          OpT%C => VarName()\n        else\n          OpT%C => ListName()\n        endif\n        call ArrayPush(Argument,transfer(OpT,Y))\n      else\n        call ArrayPush(Argument,transfer(VarNameOrNumber(),Y))\n      endif\n      if (Error) exit\n    enddo\n    call ArgID(Q)\n  end\n  subroutine ASTFree(Q)\n    type(Array),pointer :: Q\n    type(ArrayPointer) ArgumentWrap\n    integer F,G\n    do F = 1,Q%At\n      ArgumentWrap = transfer(Q%Data(F)%Data,ArgumentWrap)\n      Argument => ArgumentWrap%Data\n      do G = 1,Argument%Len\n        OpT = transfer(Argument%Data(G)%Data,OpT)\n        if (associated(OpT%C)) deallocate(OpT%C)\n      enddo\n      deallocate(Argument)\n    enddo\n    deallocate(Q)\n  end\n\n  subroutine OpGotoCell(Q)\n    integer Q\n    if (Q < StackAt) then\n      call OutputStringN('<',StackAt - Q)\n    else\n      call OutputStringN('>',Q - StackAt)\n    endif\n    StackAt = Q\n  end\n  subroutine OpAdd(Q)\n    integer Q,S\n    S = modulo(Q,256)\n    if (128 < S) then\n      call OutputStringN('-',256 - S)\n    else\n      call OutputStringN('+',S)\n    endif\n  end\n  integer function OpSolvePreserve(Q)\n    integer Q\n    if (PreserveMax < Q) PreserveMax = Q\n    OpSolvePreserve = Preserve - Q\n  end\n  subroutine OpFly(Q)\n    integer Q\n    StackAt = OpSolvePreserve(Q)\n  end\n  subroutine OpGotoPreserve(Q)\n    integer Q\n    call OpGotoCell(OpSolvePreserve(Q))\n  end\n  integer function OpGetPreserve(Q)\n    integer Q\n    OpGetPreserve = Stack(OpSolvePreserve(Q))\n  end\n  subroutine OpSetPreserve(Q,S)\n    integer Q,S\n    Stack(OpSolvePreserve(Q)) = S\n  end\n  subroutine OpModifyPreserve(Q,S)\n    integer Q,S\n    call OpGotoPreserve(Q)\n    call OpAdd(S - OpGetPreserve(Q))\n    call OpSetPreserve(Q,S)\n  end\n  subroutine OpClearPreserve(Q,J)\n    integer Q\n    logical,optional :: J\n    if (present(J)) then\n      if (J) then\n        call OpGotoPreserve(Q)\n        call OutputString('[-]')\n        call OpSetPreserve(Q,0)\n      endif\n    endif\n    if (0 < OpGetPreserve(Q)) then\n      call OpGotoPreserve(Q)\n      call OutputString('[-]')\n      call OpSetPreserve(Q,0)\n    endif\n  end\n  subroutine OpMsgList(Q)\n    character Q(:)\n    integer F\n    do F = 1,size(Q)\n      call OpModifyPreserve(0,ichar(Q(F)))\n      call OutputString('.')\n    enddo\n  end\n\n  type(Op) function OpN(Q)\n    integer Q\n    OpN%H = .true.\n    OpN%N = Q\n  end\n  type(Op) function OpC(Q)\n    character,target :: Q(:)\n    OpC%H = .false.\n    OpC%C => Q\n  end\n  type(Op) function OpR(Arg,Q)\n    type(Array) Arg\n    integer Q\n    OpR = transfer(Arg%Data(1 + Q)%Data,OpR)\n  end\n  subroutine OpSolveVar(Q)\n    character Q(:)\n    if (associated(CallArg)) then\n        if (MapHas(CallArg,Q)) then\n        L_ = MapHas(Var,MapLast%Value)\n      else\n        L_ = MapHas(Var,Q)\n      endif\n    else\n      L_ = MapHas(Var,Q)\n    endif\n    VarTemp = transfer(MapLast%Value,VarTemp)\n  end\n  subroutine OpGoto(Q,S)\n    type(Op) Q\n    integer,optional :: S\n    if (Q%H) then\n      if (Q%N < 0) then\n        call OpGotoCell(-Q%N)\n      else\n        call OpGotoPreserve(Q%N)\n      endif\n    else\n      call OpSolveVar(Q%C)\n      if (VarTemp%Len < 0) then\n        call OpGotoCell(VarTemp%At)\n      else if (present(S)) then\n        call OpGotoCell(S + VarTemp%At)\n      else\n        call OpGotoCell(VarTemp%At)\n      endif\n    endif\n  end\n  subroutine OpClear(Q,J)\n    type(Op) Q\n    logical,optional :: J\n    if (Q%H) then\n      call OpClearPreserve(Q%N,J)\n    else\n      call OpGoto(Q)\n      call OutputString('[-]')\n    endif\n  end\n  subroutine OpBegin(Q,S)\n    type(Op) Q\n    integer,optional :: S\n    call OpGoto(Q,S)\n    call OutputString('[-')\n  end\n  subroutine OpEnd(Q,S)\n    type(Op) Q\n    integer,optional :: S\n    call OpGoto(Q,S)\n    call OutputString(']')\n  end\n  subroutine OpMove(Q,S,I)\n    type(Op) Q,S\n    integer,optional :: I\n    call OpBegin(Q,I)\n    call OpGoto(S)\n    call OutputString('+')\n    call OpEnd(Q,I)\n  end\n  subroutine OpMoveTwo(Q,S,W,I)\n    type(Op) Q,S,W\n    integer,optional :: I\n    call OpBegin(Q,I)\n    call OpGoto(S)\n    call OutputString('+')\n    call OpGoto(W)\n    call OutputString('+')\n    call OpEnd(Q,I)\n  end\n  subroutine OpMoveThree(Q,S,W,A,I)\n    type(Op) Q,S,W,A\n    integer,optional :: I\n    call OpBegin(Q,I)\n    call OpGoto(S)\n    call OutputString('+')\n    call OpGoto(W)\n    call OutputString('+')\n    call OpGoto(A)\n    call OutputString('+')\n    call OpEnd(Q,I)\n  end\n  subroutine OpMoveReverse(Q,S,I)\n    type(Op) Q,S\n    integer,optional :: I\n    call OpBegin(Q,I)\n    call OpGoto(S)\n    call OutputString('-')\n    call OpEnd(Q,I)\n  end\n  subroutine OpCopy(Q,S,T,J)\n    type(Op) Q,S,T\n    logical,optional :: J\n    if (.not. present(J)) then\n      call OpClear(T)\n    elseif (J) then\n      call OpClear(T)\n    endif\n    call OpMoveTwo(Q,S,T)\n    call OpMove(T,Q)\n  end\n  subroutine OpCopyTwo(Q,S,W,T,J)\n    type(Op) Q,S,W,T\n    logical,optional :: J\n    if (.not. present(J)) then\n      call OpClear(T)\n    elseif (J) then\n      call OpClear(T)\n    endif\n    call OpMoveThree(Q,S,W,T)\n    call OpMove(T,Q)\n  end\n  subroutine OpPrepare(Q,S,T)\n    type(Op) Q,S\n    integer T\n    call OpClear(S)\n    if (Q%H) then\n      call OpGoto(S)\n      call OpAdd(Q%N)\n    else\n      call OpCopy(Q,S,OpN(T))\n    endif\n  end\n  subroutine OpPrepareTwo(Q,S,W,T)\n    type(Op) Q,S,W\n    integer T\n    if (Q%H) then\n      call OpGoto(OpN(T))\n      call OpAdd(Q%N)\n      call OpMoveTwo(OpN(T),S,W)\n    else\n      call OpCopyTwo(Q,S,W,OpN(T))\n    endif\n  end\n  subroutine OpPrepare01(Arg,W_,A_,T_)\n    type(Array) Arg\n    integer,optional :: W_,A_,T_\n    integer W,A,T\n    W = 0\n    A = 1\n    T = 2\n    if (present(W_)) W = W_\n    if (present(A_)) A = A_\n    if (present(T_)) T = T_\n    call OpPrepare(OpR(Arg,0),OpN(W),T)\n    call OpPrepare(OpR(Arg,1),OpN(A),T)\n  end\n  subroutine OpSet(Q,S)\n    type(Op) Q,S\n    call OpClear(Q)\n    call OpMove(S,Q)\n  end\n  subroutine OpDivMod(Arg,D,M,Q,S)\n    type(Array) Arg\n    integer D,M\n    type(Op),optional :: Q,S\n    if (present(Q)) then\n      call OpPrepare(Q,OpN(5),0)\n    else\n      call OpPrepare(OpR(Arg,0),OpN(5),0)\n    endif\n    if (present(S)) then\n      call OpPrepare(S,OpN(4),0)\n    else\n      call OpPrepare(OpR(Arg,1),OpN(4),0)\n    endif\n    call OpCopy(OpN(4),OpN(8),OpN(7))\n    call OpGoto(OpN(7))\n    call OutputString('+<-')\n    call OutputString('[>>>[->-[>+>>]>[+[-<+>]>+>>]<<<<<]<<-]>')\n    call OutputString('[->>[->>>+<<<]<]')\n    call OpFly(6)\n    call OpClear(OpN(8),.true.)\n    call OpClear(OpN(4),.true.)\n    if (0 < D) then\n      call OpSet(OpR(Arg,D),OpN(2))\n    else\n      call OpClear(OpN(2),.true.)\n    endif\n    if (0 < M) then\n      call OpSet(OpR(Arg,M),OpN(3))\n    else\n      call OpClear(OpN(3),.true.)\n    endif\n  end\n  subroutine OpIfWhile(Arg,Not)\n    type(Array) Arg\n    logical,optional :: Not\n    OpT = OpR(Arg,1)\n    if (OpT%H) then\n      call OpClear(OpN(0))\n      call OpCopy(OpR(Arg,0),OpN(0),OpN(1))\n      call OpGoto(OpN(0))\n      call OpAdd(-OpT%N)\n    else\n      call OpPrepare01(Arg)\n      call OpMoveReverse(OpN(1),OpN(0))\n    endif\n    if (present(Not)) then\n      if (Not) then\n        call OpGoto(OpN(1))\n        call OutputString('+>[[-]<-]<[>+<-<]')\n        call OpFly(2)\n      endif\n    endif\n    call OpGoto(OpN(0))\n  end\n\n  recursive subroutine Generate(AST_)\n    type(Array),pointer :: AST_,AST,Arg\n    type(Map),pointer :: CallArg_(:)\n    type(ArrayPointer) Argument\n    integer X,T0,T1,F\n    AST => AST_\n    CallArg_ => CallArg\n    do F = 1,AST%At\n      Argument = transfer(AST%Data(F)%Data,Argument)\n      Arg => Argument%Data\n      select case (Arg%At)\n        case (8000) ! set\n          call OpGoto(OpR(Arg,0))\n          call OutputString('[-]')\n          OpT = OpR(Arg,1)\n          if (OpT%H) then\n            call OpAdd(OpT%N)\n          else\n            call OpCopy(OpR(Arg,1),OpR(Arg,0),OpN(0))\n          endif\n        case (8010) ! inc\n          OpT = OpR(Arg,1)\n          if (OpT%H) then\n            call OpGoto(OpR(Arg,0))\n            call OpAdd(OpT%N)\n          else\n            call OpCopy(OpT,OpN(0),OpN(1))\n            call OpMove(OpN(0),OpR(Arg,0))\n          endif\n        case (8011) ! dec\n          OpT = OpR(Arg,1)\n          if (OpT%H) then\n            call OpGoto(OpR(Arg,0))\n            call OpAdd(-OpT%N)\n          else\n            call OpCopy(OpT,OpN(0),OpN(1))\n            call OpMoveReverse(OpN(0),OpR(Arg,0))\n          endif\n        case (8012) ! add\n          call OpPrepare01(Arg)\n          call OpMove(OpN(1),OpN(0))\n          call OpSet(OpR(Arg,2),OpN(0))\n        case (8013) ! sub\n          call OpPrepare01(Arg)\n          call OpMoveReverse(OpN(1),OpN(0))\n          call OpSet(OpR(Arg,2),OpN(0))\n        case (8014) ! mul\n          call OpPrepare01(Arg)\n          call OpBegin(OpN(0))\n          call OpCopy(OpN(1),OpN(2),OpN(3))\n          call OpEnd(OpN(0))\n          call OpClear(OpN(1),.true.)\n          call OpSet(OpR(Arg,2),OpN(2))\n        case (8015) ! divmod\n          call OpDivMod(Arg,2,3)\n        case (8016) ! div\n          call OpDivMod(Arg,2,0)\n        case (8017) ! mod\n          call OpDivMod(Arg,0,2)\n        case (8020) ! cmp\n          X = 4\n          T0 = 3\n          T1 = 2\n          call OpPrepareTwo(OpR(Arg,0),OpN(T0),OpN(X),0)\n          call OpPrepareTwo(OpR(Arg,1),OpN(T1),OpN(1 + X),0)\n          call OpMoveReverse(OpN(1 + X),OpN(X))\n\n          call OpGoto(OpN(1 + X))\n          call OutputString('+>[[-]')\n          call OpFly(X)\n\n          call OpGoto(OpN(T1 - 1))\n          call OutputString('+<[>-]>[')\n          call OpFly(T1 - 1)\n          call OpGoto(OpN(X))\n          call OutputString('+')\n          call OpGoto(OpN(T0))\n          call OutputString('[-]')\n          call OpGoto(OpN(T1 - 1))\n          call OutputString('->]<+')\n          call OpGoto(OpN(T0))\n          call OutputString('[')\n          call OpGoto(OpN(T1))\n          call OutputString('-[>-]>[')\n          call OpFly(T1 - 1)\n          call OpGoto(OpN(X))\n          call OutputString('+')\n          call OpGoto(OpN(T0))\n          call OutputString('[-]+')\n          call OpGoto(OpN(T1 - 1))\n          call OutputString('->]<+')\n          call OpGoto(OpN(T0))\n          call OutputString('-]')\n\n          call OpGoto(OpN(X))\n          call OutputString('[<-]<[>-<-<]')\n          call OpFly(2 + X)\n\n          call OpGoto(OpN(1 + X))\n          call OutputString(']<[-<]>')\n\n          call OpClear(OpN(3),.true.)\n          call OpClear(OpN(2),.true.)\n          call OpClear(OpN(1),.true.)\n\n          call OpSet(OpR(Arg,2),OpN(X))\n        case (8030) ! a2b\n          call OpCopy(OpR(Arg,0),OpN(2),OpN(0))\n          call OpGoto(OpN(2))\n          call OpAdd(-48)\n          call OpBegin(OpN(2))\n          call OpGoto(OpN(1))\n          call OpAdd(10)\n          call OpEnd(OpN(2))\n\n          call OpCopy(OpR(Arg,1),OpN(1),OpN(0))\n          call OpGoto(OpN(1))\n          call OpAdd(-48)\n\n          call OpBegin(OpN(1))\n          call OpGoto(OpN(0))\n          call OpAdd(10)\n          call OpEnd(OpN(1))\n\n          call OpCopy(OpR(Arg,2),OpN(0),OpN(1))\n          call OpGoto(OpN(0))\n          call OpAdd(-48)\n\n          call OpSet(OpR(Arg,3),OpN(0))\n        case (8031) ! b2a\n          call OpDivMod(Arg,2,3,OpR(Arg,0),OpN(10))\n          call OpDivMod(Arg,1,2,OpR(Arg,2),OpN(10))\n          call OpGoto(OpR(Arg,1))\n          call OpAdd(48)\n          call OpGoto(OpR(Arg,2))\n          call OpAdd(48)\n          call OpGoto(OpR(Arg,3))\n          call OpAdd(48)\n        case (8040) ! lset\n          OpT = OpR(Arg,0)\n          call OpSolveVar(OpT%C)\n          OpT = OpR(Arg,1)\n          if (OpT%H) then\n            call OpGoto(OpR(Arg,0))\n            call OpAdd(OpT%N)\n            call OutputString('[->+>+<<]')\n          else\n            call OpCopyTwo(OpR(Arg,1),OpN(-1 - VarTemp%At),OpN(-2 - VarTemp%At),OpR(Arg,0),.false.)\n          endif\n          OpT = OpR(Arg,2)\n          if (OpT%H) then\n            call OpGoto(OpR(Arg,0),3)\n            call OpAdd(OpT%N)\n          else\n            call OpCopy(OpR(Arg,2),OpN(-3 - VarTemp%At),OpR(Arg,0),.false.)\n          endif\n          call OpGoto(OpR(Arg,0))\n          call OutputString('>[>>>[-<<<<+>>>>]<[->+<]<[->+<]<[->+<]>-]')\n          call OutputString('>>>[-]<[->+<]<')\n          call OutputString('[[-<+>]<<<[->>>>+<<<<]>>-]<<')\n        case (8041) ! lget\n          OpT = OpR(Arg,0)\n          call OpSolveVar(OpT%C)\n          OpT = OpR(Arg,1)\n          if (OpT%H) then\n            call OpGoto(OpR(Arg,0))\n            call OpAdd(OpT%N)\n            call OutputString('[->+>+<<]')\n          else\n            call OpCopyTwo(OpR(Arg,1),OpN(-1 - VarTemp%At),OpN(-2 - VarTemp%At),OpR(Arg,0),.false.)\n          endif\n          call OpGoto(OpR(Arg,0))\n          call OutputString('>[>>>[-<<<<+>>>>]<<[->+<]<[->+<]>-]')\n          call OutputString('>>>[-<+<<+>>>]<<<[->>>+<<<]>')\n          call OutputString('[[-<+>]>[-<+>]<<<<[->>>>+<<<<]>>-]<<')\n          call OpClear(OpR(Arg,2))\n          call OpMove(OpR(Arg,0),OpR(Arg,2),3)\n        case (8050,8052) ! ifeq,weq\n          call OpIfWhile(Arg,.true.)\n          call OutputString('[')\n          call OpClear(OpN(0),.true.)\n        case (8051) ! ifneq\n          call OpIfWhile(Arg)\n          call OutputString('[')\n          call OpClear(OpN(0),.true.)\n        case (8053) ! wneq\n          OpT = OpR(Arg,1)\n          if (0 < OpT%N) then\n            call OpIfWhile(Arg)\n            call OutputString('[')\n            call OpClear(OpN(0),.true.)\n          else\n            call OpGoto(OpR(Arg,0))\n            call OutputString('[')\n          endif\n        case (8054) ! end\n          OpT = OpR(Arg,0)\n          Argument = transfer(AST%Data(OpT%N)%Data,Argument)\n          Arg => Argument%Data\n          if (8052 == Arg%At) then\n            call OpIfWhile(Arg,.true.)\n            call OpGoto(OpN(0))\n          else if (8053 == Arg%At) then\n            OpT = OpR(Arg,1)\n            if (0 < OpT%N) then\n              call OpIfWhile(Arg)\n              call OpGoto(OpN(0))\n            else\n              call OpGoto(OpR(Arg,0))\n            endif\n          else\n            call OpClear(OpN(0))\n            call OpGoto(OpN(0))\n          endif\n          call OutputString(']')\n        case (8055) ! call\n          OpT = OpR(Arg,0)\n          if (.not. MapHas(Proc,OpT%C)) then\n            call ErrorNoProc(OpT%C)\n            exit\n          endif\n          ProcTemp = transfer(MapLast%Value,ProcTemp)\n          ProcVar => ProcTemp%Var\n          ProcVarType => ProcTemp%VarType\n          if (1 + ProcVar%At \/= Arg%Len) then\n            call ErrorProcLength(OpT%C,ProcVar%At,Arg%Len - 1)\n            exit\n          endif\n          if (0 < IndexOf(OpT%C,CallStack)) then\n            call ErrorRecursive(OpT%C)\n            exit\n          endif\n          call ArrayPush(CallStack,OpT%C)\n          allocate(CallArg(64))\n          call MapInit(CallArg)\n          do X = 1,ProcVar%At\n            OpT = OpR(Arg,X)\n            if (associated(CallArg_)) then\n                if (MapHas(CallArg_,OpT%C)) then\n                call MapSet(CallArg,ProcVar%Data(X)%Data,MapLast%Value)\n                L_ = MapHas(Var,MapLast%Value)\n              else\n                call MapSet(CallArg,ProcVar%Data(X)%Data,OpT%C)\n                L_ = MapHas(Var,OpT%C)\n              endif\n            else\n              call MapSet(CallArg,ProcVar%Data(X)%Data,OpT%C)\n              L_ = MapHas(Var,OpT%C)\n            endif\n            VarTemp = transfer(MapLast%Value,VarTemp)\n            if (allocated(ProcVarType%Data(X)%Data)) then\n              L_ = transfer(ProcVarType%Data(X)%Data,L_)\n              if (L_ .neqv. (VarTemp%Len < 0)) then\n                call ErrorArgTypeMismatch(L_,ProcVar%Data(X)%Data,OpR(Arg,0),OpT%C)\n                exit\n              endif\n            endif\n          enddo\n          if (.not. Error) call Generate(ProcTemp%AST)\n          call MapFree(CallArg)\n          deallocate(CallArg)\n          CallArg => CallArg_\n          CallStack%At = CallStack%At - 1\n        case (8060) ! read\n          call OpGoto(OpR(Arg,0))\n          call OutputString(',')\n        case (8061,8062) ! msg\n          do X = 1,Arg%Len\n            OpT = OpR(Arg,X - 1)\n            if (OpT%H) then\n              call OpMsgList(OpT%C)\n            else\n              call OpGoto(OpT)\n              call OutputString('.')\n            endif\n          enddo\n          if (8062 == Arg%At) call OpMsgList([char(10)])\n        case (8400) ! debug\n          call OutputString('_')\n      endselect\n    enddo\n  end\n\n  integer function kcuf(Output,Code)\n    character(:),allocatable :: Output\n    character(*) Code\n    character(6) Command\n    type(ArrayPointer) ArgumentWrap\n    character,pointer :: V(:)\n    integer F,G\n\n    Error = .false.\n    allocate(character(len(Code)) :: I)\n    I = Code\n    OAt = 0\n    if (.not. allocated(O)) then\n      OLen = 32\n      allocate(character(OLen) :: O)\n    endif\n    PreserveMax = -1\n    Stack = 0\n    StackAt = 0\n    VarAt = 1 + Preserve\n    call MapInit(Var)\n    allocate(AST)\n    call ArrayMake(AST)\n    CurrentAST => AST\n    call ArrayMake(ASTStack)\n    call MapInit(Proc)\n    ProcIn = .false.\n    call ArrayMake(CallStack)\n\n    CodeOffset = 0\n    do while (CodeOffset < len(Code))\n      do F = 1 + CodeOffset,len(Code)\n        if (10 == ichar(Code(F:))) exit\n      enddo\n      CodeAt = 1\n      CodeLen = F - CodeOffset - 1\n      call White()\n      if (0 < Taste()) then\n        V => Word()\n        if (Error) exit\n        Command = transfer(V,Command)\n        G = size(V)\n        deallocate(V)\n        select case (Command(:G))\n          case ('VAR')\n            if (ProcIn) then\n              call ErrorDefineInProc()\n              exit\n            endif\n            if (Taste() < 1) then\n              call ErrorUnEOL()\n              exit\n            endif\n            V => Word()\n            do while (0 < size(V) .and. .not. Error)\n              if (MapHas(Var,V)) then\n                call ErrorVarRedeclare(V)\n                exit\n              endif\n              if (91 == Taste()) then\n                call Eat()\n                call White()\n                VarTemp%Len = RawNumber()\n                if (Error) exit\n                if (93 \/= Taste()) then\n                  call ErrorUnclosed('[')\n                  exit\n                endif\n                call Eat()\n                call White()\n                VarTemp%At = VarAt\n                VarAt = 4 + VarAt + VarTemp%Len\n              else\n                VarTemp%At = VarAt\n                VarTemp%Len = -1\n                VarAt = 1 + VarAt\n              endif\n              call MapSet(Var,V,transfer(VarTemp,Y))\n              deallocate(V)\n              V => Word()\n            enddo\n            if (associated(V)) deallocate(V)\n\n          case ('SET')\n            call ArgMake(8000,[0,9])\n\n          case ('INC')\n            call ArgMake(8010,[0,9])\n          case ('DEC')\n            call ArgMake(8011,[0,9])\n          case ('ADD')\n            call ArgMake(8012,[9,9,0])\n          case ('SUB')\n            call ArgMake(8013,[9,9,0])\n          case ('MUL')\n            call ArgMake(8014,[9,9,0])\n          case ('DIVMOD')\n            call ArgMake(8015,[9,9,0,0])\n          case ('DIV')\n            call ArgMake(8016,[9,9,0])\n          case ('MOD')\n            call ArgMake(8017,[9,9,0])\n\n          case ('CMP')\n            call ArgMake(8020,[9,9,0])\n\n          case ('A2B')\n            call ArgMake(8030,[9,9,9,0])\n          case ('B2A')\n            call ArgMake(8031,[9,0,0,0])\n\n          case ('LSET')\n            call ArgMake(8040,[2,9,9])\n          case ('LGET')\n            call ArgMake(8041,[2,9,0])\n\n          case ('IFEQ')\n            call ArgMake(8050,[0,9])\n            call ArrayPush(ASTStack,transfer(CurrentAST%At,Y))\n          case ('IFNEQ')\n            call ArgMake(8051,[0,9])\n            call ArrayPush(ASTStack,transfer(CurrentAST%At,Y))\n          case ('WEQ')\n            call ArgMake(8052,[0,9])\n            call ArrayPush(ASTStack,transfer(CurrentAST%At,Y))\n          case ('WNEQ')\n            call ArgMake(8053,[0,9])\n            call ArrayPush(ASTStack,transfer(CurrentAST%At,Y))\n          case ('PROC')\n            if (ProcIn) then\n              call ErrorProcNested()\n              exit\n            endif\n            ProcIn = .true.\n            V => Word()\n            if (Error) exit\n            if (MapHas(Proc,V)) then\n              call ErrorProcUsed(V)\n              exit\n            endif\n            allocate(CurrentAST)\n            allocate(ProcVar)\n            allocate(ProcVarType)\n            call ArrayMake(CurrentAST)\n            call ArrayMake(ProcVar)\n            call ArrayMake(ProcVarType)\n            ProcTemp%AST => CurrentAST\n            ProcTemp%Var => ProcVar\n            ProcTemp%VarType => ProcVarType\n            call MapSet(Proc,V,transfer(ProcTemp,Y))\n            do while (0 < Taste())\n              V => Word()\n              if (Error) exit\n              if (0 < IndexOf(V,ProcVar)) then\n                call ErrorDupParam(V)\n                deallocate(V)\n                exit\n              endif\n              call ArrayPush(ProcVar,V)\n              call ArrayPush(ProcVarType)\n            enddo\n          case ('END')\n            if (0 < ASTStack%At) then\n              call ArgInit(1)\n              OpT%C => null()\n              OpT%N = 1 + transfer(ASTStack%Data(ASTStack%At)%Data,OpT%N)\n              call ArrayPush(Argument,transfer(OpT,Y))\n              ASTStack%At = ASTStack%At - 1\n              call ArgID(8054)\n            else if (ProcIn) then\n              CurrentAST => AST\n              ProcIn = .false.\n            else\n              call ErrorEndNothing()\n            endif\n          case ('CALL')\n            call ArgInit(16)\n            do while (0 < Taste() .and. .not. Error)\n              OpT%C => Word()\n              call ArrayPush(Argument,transfer(OpT,Y))\n            enddo\n            call ArgID(8055)\n\n          case ('READ')\n            call ArgMake(8060,[0])\n          case ('MSG','LN')\n            call ArgInit(16)\n            do while (0 < Taste() .and. .not. Error)\n              call ArrayPush(Argument,transfer(VarNameOrString(),Y))\n            enddo\n            if (2 < G) then\n              call ArgID(8061)\n            else\n              call ArgID(8062)\n            endif\n\n          case ('REM')\n            call Discard()\n\n          case ('DEBUG')\n            call ArgInit(0)\n            call ArgID(8400)\n            call Discard()\n\n          case default\n            call ErrorCommand(Command(:G))\n        endselect\n        if (0 < Taste() .and. .not. Error) call ErrorCommandEnd()\n        if (associated(Argument)) then\n          ArgumentWrap%Data => Argument\n          call ArrayPush(CurrentAST,transfer(ArgumentWrap,Y))\n          Argument => null()\n        endif\n        if (Error) exit\n      endif\n      CodeOffset = F\n    enddo\n\n    if (.not. Error) then\n      if (0 < ASTStack%At) then\n        call ErrorEndUnclose()\n      endif\n    endif\n    CallArg => null()\n    if (.not. Error) call Generate(AST)\n\n    call ArrayFree(CallStack)\n    call MapFree(Proc)\n    call ArrayFree(ASTStack)\n    call ASTFree(AST)\n    call MapFree(Var)\n    kcuf = 0\n    if (Error) then\n      allocate(character(OAt) :: Output)\n      Output = O(:OAt)\n      kcuf = 9\n    else\n      allocate(character(OAt - Preserve + PreserveMax) :: Output)\n      Output = O(1 + Preserve - PreserveMax:OAt)\n    endif\n    deallocate(I)\n  end\nend","lang_id":19,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:43","updated_at":"2023-01-14 13:23:43"}]}